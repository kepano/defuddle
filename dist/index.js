(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Defuddle"] = factory();
	else
		root["Defuddle"] = factory();
})(typeof self !== "undefined" ? self : this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 315:
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mathStandardizationRules = exports.createCleanMathEl = exports.isBlockDisplay = exports.getLatexFromElement = exports.getMathMLFromElement = void 0;
const mathml_to_latex_1 = __webpack_require__(/*! mathml-to-latex */ 354);
const temml = __importStar(__webpack_require__(/*! temml */ 914));
const getMathMLFromElement = (el) => {
    // 1. Direct MathML content
    if (el.tagName.toLowerCase() === 'math') {
        const isBlock = el.getAttribute('display') === 'block';
        return {
            mathml: el.outerHTML,
            latex: el.getAttribute('alttext') || null,
            isBlock
        };
    }
    // 2. MathML in data-mathml attribute
    const mathmlStr = el.getAttribute('data-mathml');
    if (mathmlStr) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathmlStr;
        const mathElement = tempDiv.querySelector('math');
        if (mathElement) {
            const isBlock = mathElement.getAttribute('display') === 'block';
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 3. MathJax assistive MathML
    const assistiveMmlContainer = el.querySelector('.MJX_Assistive_MathML, mjx-assistive-mml');
    if (assistiveMmlContainer) {
        const mathElement = assistiveMmlContainer.querySelector('math');
        if (mathElement) {
            // Check both the math element and container for display mode
            const mathDisplayAttr = mathElement.getAttribute('display');
            const containerDisplayAttr = assistiveMmlContainer.getAttribute('display');
            const isBlock = mathDisplayAttr === 'block' || containerDisplayAttr === 'block';
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 4. KaTeX MathML
    const katexMathml = el.querySelector('.katex-mathml math');
    if (katexMathml) {
        return {
            mathml: katexMathml.outerHTML,
            latex: null, // We'll get LaTeX separately for KaTeX
            isBlock: false // We'll determine this from container
        };
    }
    ;
    return null;
};
exports.getMathMLFromElement = getMathMLFromElement;
const getLatexFromElement = (el) => {
    var _a, _b, _c;
    // Direct data-latex attribute
    const dataLatex = el.getAttribute('data-latex');
    if (dataLatex) {
        return dataLatex;
    }
    // WordPress LaTeX images
    if (el instanceof HTMLImageElement && el.classList.contains('latex')) {
        // Try alt text first as it's cleaner
        const altLatex = el.getAttribute('alt');
        if (altLatex) {
            return altLatex;
        }
        // Fallback to extracting from URL
        const src = el.getAttribute('src');
        if (src) {
            const match = src.match(/latex\.php\?latex=([^&]+)/);
            if (match) {
                return decodeURIComponent(match[1])
                    .replace(/\+/g, ' ') // Replace + with spaces
                    .replace(/%5C/g, '\\'); // Fix escaped backslashes
            }
        }
    }
    // LaTeX in annotation
    const annotation = el.querySelector('annotation[encoding="application/x-tex"]');
    if (annotation === null || annotation === void 0 ? void 0 : annotation.textContent) {
        return annotation.textContent.trim();
    }
    // KaTeX formats
    if (el.matches('.katex')) {
        const katexAnnotation = el.querySelector('.katex-mathml annotation[encoding="application/x-tex"]');
        if (katexAnnotation === null || katexAnnotation === void 0 ? void 0 : katexAnnotation.textContent) {
            return katexAnnotation.textContent.trim();
        }
    }
    // MathJax scripts
    // Important: this will only work if the script has not been removed at an earlier stage
    if (el.matches('script[type="math/tex"]') || el.matches('script[type="math/tex; mode=display"]')) {
        return ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || null;
    }
    // Check for sibling script element
    if (el.parentElement) {
        const siblingScript = el.parentElement.querySelector('script[type="math/tex"], script[type="math/tex; mode=display"]');
        if (siblingScript) {
            return ((_b = siblingScript.textContent) === null || _b === void 0 ? void 0 : _b.trim()) || null;
        }
    }
    // Try to convert MathML to LaTeX as last resort
    const mathml = (0, exports.getMathMLFromElement)(el);
    if (mathml === null || mathml === void 0 ? void 0 : mathml.mathml) {
        try {
            return mathml_to_latex_1.MathMLToLaTeX.convert(mathml.mathml);
        }
        catch (error) {
            console.error('Error converting MathML to LaTeX:', error);
            return null;
        }
    }
    // Fallback to alt text or text content
    return el.getAttribute('alt') || ((_c = el.textContent) === null || _c === void 0 ? void 0 : _c.trim()) || null;
};
exports.getLatexFromElement = getLatexFromElement;
const isBlockDisplay = (el) => {
    // Check explicit display attribute
    const displayAttr = el.getAttribute('display');
    if (displayAttr === 'block') {
        return true;
    }
    // Check common class names
    const classNames = el.className.toLowerCase();
    if (classNames.includes('display') || classNames.includes('block')) {
        return true;
    }
    // Check container classes
    const container = el.closest('.katex-display, .MathJax_Display, [data-display="block"]');
    if (container) {
        return true;
    }
    // Check if preceded by block element
    const prevElement = el.previousElementSibling;
    if ((prevElement === null || prevElement === void 0 ? void 0 : prevElement.tagName.toLowerCase()) === 'p') {
        return true;
    }
    // Check specific formats
    if (el.matches('.mwe-math-fallback-image-display')) {
        return true;
    }
    // Check KaTeX display mode
    if (el.matches('.katex')) {
        // KaTeX elements are inline by default
        // Only block if explicitly marked as display
        return el.closest('.katex-display') !== null;
    }
    // Check MathJax v3 display attribute
    if (el.hasAttribute('display')) {
        return el.getAttribute('display') === 'true';
    }
    // Check MathJax script display attribute
    if (el.matches('script[type="math/tex; mode=display"]')) {
        return true;
    }
    if (el.hasAttribute('display')) {
        return el.getAttribute('display') === 'true';
    }
    // Check parent container display attribute
    const parentContainer = el.closest('[display]');
    if (parentContainer) {
        return parentContainer.getAttribute('display') === 'true';
    }
    return false;
};
exports.isBlockDisplay = isBlockDisplay;
const createCleanMathEl = (mathData, latex, isBlock) => {
    const cleanMathEl = document.createElement('math');
    cleanMathEl.setAttribute('xmlns', 'http://www.w3.org/1998/Math/MathML');
    cleanMathEl.setAttribute('display', isBlock ? 'block' : 'inline');
    cleanMathEl.setAttribute('data-latex', latex || '');
    // First try to use existing MathML content
    if (mathData === null || mathData === void 0 ? void 0 : mathData.mathml) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathData.mathml;
        const mathContent = tempDiv.querySelector('math');
        if (mathContent) {
            cleanMathEl.innerHTML = mathContent.innerHTML;
        }
    }
    // If no MathML content but we have LaTeX, convert using Temml
    else if (latex) {
        try {
            // Convert LaTeX to MathML using Temml
            const mathml = temml.renderToString(latex, {
                displayMode: isBlock,
                throwOnError: false
            });
            if (typeof mathml === 'string') {
                // Extract the inner content of the math element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = mathml;
                const mathContent = tempDiv.querySelector('math');
                if (mathContent) {
                    // Copy attributes except display mode
                    Array.from(mathContent.attributes).forEach(attr => {
                        if (attr.name !== 'display') {
                            cleanMathEl.setAttribute(attr.name, attr.value);
                        }
                    });
                    cleanMathEl.innerHTML = mathContent.innerHTML;
                }
                else {
                    // Use the entire output as fallback
                    cleanMathEl.innerHTML = mathml;
                }
            }
            else {
                cleanMathEl.textContent = latex;
            }
        }
        catch (error) {
            console.error('Error converting LaTeX to MathML:', error);
            cleanMathEl.textContent = latex;
        }
    }
    return cleanMathEl;
};
exports.createCleanMathEl = createCleanMathEl;
// Find math elements
exports.mathStandardizationRules = [
    {
        selector: [
            // WordPress LaTeX images
            'img.latex[src*="latex.php"]',
            // MathJax elements (v2 and v3)
            'span.MathJax',
            'mjx-container',
            'script[type="math/tex"]',
            'script[type="math/tex; mode=display"]',
            '.MathJax_Preview + script[type="math/tex"]',
            '.MathJax_Display',
            '.MathJax_SVG',
            '.MathJax_MathML',
            // MediaWiki math elements
            '.mwe-math-element',
            '.mwe-math-fallback-image-inline',
            '.mwe-math-fallback-image-display',
            '.mwe-math-mathml-inline',
            '.mwe-math-mathml-display',
            // KaTeX elements
            '.katex',
            '.katex-display',
            '.katex-mathml',
            '.katex-html',
            '[data-katex]',
            'script[type="math/katex"]',
            // Generic math elements and other formats
            'math',
            '[data-math]',
            '[data-latex]',
            '[data-tex]',
            'script[type^="math/"]',
            'annotation[encoding="application/x-tex"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            const mathData = (0, exports.getMathMLFromElement)(el);
            const latex = (0, exports.getLatexFromElement)(el);
            const isBlock = (0, exports.isBlockDisplay)(el);
            const cleanMathEl = (0, exports.createCleanMathEl)(mathData, latex, isBlock);
            // Clean up any associated math scripts after we've extracted their content
            if (el.parentElement) {
                // Remove all math-related scripts and previews
                const mathElements = el.parentElement.querySelectorAll(`
					/* MathJax scripts and previews */
					script[type^="math/"],
					.MathJax_Preview,

					/* External math library scripts */
					script[type="text/javascript"][src*="mathjax"],
					script[type="text/javascript"][src*="katex"]
				`);
                mathElements.forEach(el => el.remove());
            }
            return cleanMathEl;
        }
    }
];


/***/ }),

/***/ 354:
/*!*********************************************************!*\
  !*** ./node_modules/mathml-to-latex/dist/bundle.min.js ***!
  \*********************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(()=>(()=>{var e={4582:(e,t)=>{"use strict";function r(e,t){return void 0===t&&(t=Object),t&&"function"==typeof t.freeze?t.freeze(e):e}var a=r({HTML:"text/html",isHTML:function(e){return e===a.HTML},XML_APPLICATION:"application/xml",XML_TEXT:"text/xml",XML_XHTML_APPLICATION:"application/xhtml+xml",XML_SVG_IMAGE:"image/svg+xml"}),n=r({HTML:"http://www.w3.org/1999/xhtml",isHTML:function(e){return e===n.HTML},SVG:"http://www.w3.org/2000/svg",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"});t.assign=function(e,t){if(null===e||"object"!=typeof e)throw new TypeError("target is not an object");for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e},t.find=function(e,t,r){if(void 0===r&&(r=Array.prototype),e&&"function"==typeof r.find)return r.find.call(e,t);for(var a=0;a<e.length;a++)if(Object.prototype.hasOwnProperty.call(e,a)){var n=e[a];if(t.call(void 0,n,a,e))return n}},t.freeze=r,t.MIME_TYPE=a,t.NAMESPACE=n},5752:(e,t,r)=>{var a=r(4582),n=r(4722),o=r(6559),i=r(4466),s=n.DOMImplementation,l=a.NAMESPACE,c=i.ParseError,u=i.XMLReader;function h(e){return e.replace(/\r[\n\u0085]/g,"\n").replace(/[\r\u0085\u2028]/g,"\n")}function d(e){this.options=e||{locator:{}}}function m(){this.cdata=!1}function p(e,t){t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber}function f(e){if(e)return"\n@"+(e.systemId||"")+"#[line:"+e.lineNumber+",col:"+e.columnNumber+"]"}function x(e,t,r){return"string"==typeof e?e.substr(t,r):e.length>=t+r||t?new java.lang.String(e,t,r)+"":e}function g(e,t){e.currentElement?e.currentElement.appendChild(t):e.doc.appendChild(t)}d.prototype.parseFromString=function(e,t){var r=this.options,a=new u,n=r.domBuilder||new m,i=r.errorHandler,s=r.locator,c=r.xmlns||{},d=/\/x?html?$/.test(t),p=d?o.HTML_ENTITIES:o.XML_ENTITIES;s&&n.setDocumentLocator(s),a.errorHandler=function(e,t,r){if(!e){if(t instanceof m)return t;e=t}var a={},n=e instanceof Function;function o(t){var o=e[t];!o&&n&&(o=2==e.length?function(r){e(t,r)}:e),a[t]=o&&function(e){o("[xmldom "+t+"]\t"+e+f(r))}||function(){}}return r=r||{},o("warning"),o("error"),o("fatalError"),a}(i,n,s),a.domBuilder=r.domBuilder||n,d&&(c[""]=l.HTML),c.xml=c.xml||l.XML;var x=r.normalizeLineEndings||h;return e&&"string"==typeof e?a.parse(x(e),c,p):a.errorHandler.error("invalid doc source"),n.doc},m.prototype={startDocument:function(){this.doc=(new s).createDocument(null,null,null),this.locator&&(this.doc.documentURI=this.locator.systemId)},startElement:function(e,t,r,a){var n=this.doc,o=n.createElementNS(e,r||t),i=a.length;g(this,o),this.currentElement=o,this.locator&&p(this.locator,o);for(var s=0;s<i;s++){e=a.getURI(s);var l=a.getValue(s),c=(r=a.getQName(s),n.createAttributeNS(e,r));this.locator&&p(a.getLocator(s),c),c.value=c.nodeValue=l,o.setAttributeNode(c)}},endElement:function(e,t,r){var a=this.currentElement;a.tagName,this.currentElement=a.parentNode},startPrefixMapping:function(e,t){},endPrefixMapping:function(e){},processingInstruction:function(e,t){var r=this.doc.createProcessingInstruction(e,t);this.locator&&p(this.locator,r),g(this,r)},ignorableWhitespace:function(e,t,r){},characters:function(e,t,r){if(e=x.apply(this,arguments)){if(this.cdata)var a=this.doc.createCDATASection(e);else a=this.doc.createTextNode(e);this.currentElement?this.currentElement.appendChild(a):/^\s*$/.test(e)&&this.doc.appendChild(a),this.locator&&p(this.locator,a)}},skippedEntity:function(e){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(e){(this.locator=e)&&(e.lineNumber=0)},comment:function(e,t,r){e=x.apply(this,arguments);var a=this.doc.createComment(e);this.locator&&p(this.locator,a),g(this,a)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(e,t,r){var a=this.doc.implementation;if(a&&a.createDocumentType){var n=a.createDocumentType(e,t,r);this.locator&&p(this.locator,n),g(this,n),this.doc.doctype=n}},warning:function(e){console.warn("[xmldom warning]\t"+e,f(this.locator))},error:function(e){console.error("[xmldom error]\t"+e,f(this.locator))},fatalError:function(e){throw new c(e,this.locator)}},"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,(function(e){m.prototype[e]=function(){return null}})),t.DOMParser=d},4722:(e,t,r)=>{var a=r(4582),n=a.find,o=a.NAMESPACE;function i(e){return""!==e}function s(e,t){return e.hasOwnProperty(t)||(e[t]=!0),e}function l(e){if(!e)return[];var t=function(e){return e?e.split(/[\t\n\f\r ]+/).filter(i):[]}(e);return Object.keys(t.reduce(s,{}))}function c(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function u(e,t){var r=e.prototype;if(!(r instanceof t)){function a(){}a.prototype=t.prototype,c(r,a=new a),e.prototype=r=a}r.constructor!=e&&("function"!=typeof e&&console.error("unknown Class:"+e),r.constructor=e)}var h={},d=h.ELEMENT_NODE=1,m=h.ATTRIBUTE_NODE=2,p=h.TEXT_NODE=3,f=h.CDATA_SECTION_NODE=4,x=h.ENTITY_REFERENCE_NODE=5,g=h.ENTITY_NODE=6,w=h.PROCESSING_INSTRUCTION_NODE=7,b=h.COMMENT_NODE=8,v=h.DOCUMENT_NODE=9,C=h.DOCUMENT_TYPE_NODE=10,A=h.DOCUMENT_FRAGMENT_NODE=11,E=h.NOTATION_NODE=12,_={},y={},q=(_.INDEX_SIZE_ERR=(y[1]="Index size error",1),_.DOMSTRING_SIZE_ERR=(y[2]="DOMString size error",2),_.HIERARCHY_REQUEST_ERR=(y[3]="Hierarchy request error",3)),D=(_.WRONG_DOCUMENT_ERR=(y[4]="Wrong document",4),_.INVALID_CHARACTER_ERR=(y[5]="Invalid character",5),_.NO_DATA_ALLOWED_ERR=(y[6]="No data allowed",6),_.NO_MODIFICATION_ALLOWED_ERR=(y[7]="No modification allowed",7),_.NOT_FOUND_ERR=(y[8]="Not found",8)),M=(_.NOT_SUPPORTED_ERR=(y[9]="Not supported",9),_.INUSE_ATTRIBUTE_ERR=(y[10]="Attribute in use",10));function T(e,t){if(t instanceof Error)var r=t;else r=this,Error.call(this,y[e]),this.message=y[e],Error.captureStackTrace&&Error.captureStackTrace(this,T);return r.code=e,t&&(this.message=this.message+": "+t),r}function N(){}function O(e,t){this._node=e,this._refresh=t,L(this)}function L(e){var t=e._node._inc||e._node.ownerDocument._inc;if(e._inc!==t){var r=e._refresh(e._node);if(we(e,"length",r.length),!e.$$length||r.length<e.$$length)for(var a=r.length;a in e;a++)Object.prototype.hasOwnProperty.call(e,a)&&delete e[a];c(r,e),e._inc=t}}function B(){}function S(e,t){for(var r=e.length;r--;)if(e[r]===t)return r}function F(e,t,r,a){if(a?t[S(t,a)]=r:t[t.length++]=r,e){r.ownerElement=e;var n=e.ownerDocument;n&&(a&&V(n,e,a),function(e,t,r){e&&e._inc++,r.namespaceURI===o.XMLNS&&(t._nsMap[r.prefix?r.localName:""]=r.value)}(n,e,r))}}function P(e,t,r){var a=S(t,r);if(!(a>=0))throw new T(D,new Error(e.tagName+"@"+r));for(var n=t.length-1;a<n;)t[a]=t[++a];if(t.length=n,e){var o=e.ownerDocument;o&&(V(o,e,r),r.ownerElement=null)}}function k(){}function R(){}function I(e){return("<"==e?"&lt;":">"==e&&"&gt;")||"&"==e&&"&amp;"||'"'==e&&"&quot;"||"&#"+e.charCodeAt()+";"}function U(e,t){if(t(e))return!0;if(e=e.firstChild)do{if(U(e,t))return!0}while(e=e.nextSibling)}function j(){this.ownerDocument=this}function V(e,t,r,a){e&&e._inc++,r.namespaceURI===o.XMLNS&&delete t._nsMap[r.prefix?r.localName:""]}function G(e,t,r){if(e&&e._inc){e._inc++;var a=t.childNodes;if(r)a[a.length++]=r;else{for(var n=t.firstChild,o=0;n;)a[o++]=n,n=n.nextSibling;a.length=o,delete a[a.length]}}}function $(e,t){var r=t.previousSibling,a=t.nextSibling;return r?r.nextSibling=a:e.firstChild=a,a?a.previousSibling=r:e.lastChild=r,t.parentNode=null,t.previousSibling=null,t.nextSibling=null,G(e.ownerDocument,e),t}function X(e){return e&&e.nodeType===R.DOCUMENT_TYPE_NODE}function H(e){return e&&e.nodeType===R.ELEMENT_NODE}function W(e){return e&&e.nodeType===R.TEXT_NODE}function z(e,t){var r=e.childNodes||[];if(n(r,H)||X(t))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function Y(e,t){var r=e.childNodes||[];if(n(r,(function(e){return H(e)&&e!==t})))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function J(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!z(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!z(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,X))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element");if(!r&&s)throw new T(q,"Doctype can not be appended since element is present")}}function Z(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!Y(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!Y(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,(function(e){return X(e)&&e!==r})))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element")}}function Q(e,t,r,a){(function(e,t,r){if(!function(e){return e&&(e.nodeType===R.DOCUMENT_NODE||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.ELEMENT_NODE)}(e))throw new T(q,"Unexpected parent node type "+e.nodeType);if(r&&r.parentNode!==e)throw new T(D,"child not in parent");if(!function(e){return e&&(H(e)||W(e)||X(e)||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.COMMENT_NODE||e.nodeType===R.PROCESSING_INSTRUCTION_NODE)}(t)||X(t)&&e.nodeType!==R.DOCUMENT_NODE)throw new T(q,"Unexpected node type "+t.nodeType+" for parent node type "+e.nodeType)})(e,t,r),e.nodeType===R.DOCUMENT_NODE&&(a||J)(e,t,r);var n=t.parentNode;if(n&&n.removeChild(t),t.nodeType===A){var o=t.firstChild;if(null==o)return t;var i=t.lastChild}else o=i=t;var s=r?r.previousSibling:e.lastChild;o.previousSibling=s,i.nextSibling=r,s?s.nextSibling=o:e.firstChild=o,null==r?e.lastChild=i:r.previousSibling=i;do{o.parentNode=e}while(o!==i&&(o=o.nextSibling));return G(e.ownerDocument||e,e),t.nodeType==A&&(t.firstChild=t.lastChild=null),t}function K(){this._nsMap={}}function ee(){}function te(){}function re(){}function ae(){}function ne(){}function oe(){}function ie(){}function se(){}function le(){}function ce(){}function ue(){}function he(){}function de(e,t){var r=[],a=9==this.nodeType&&this.documentElement||this,n=a.prefix,o=a.namespaceURI;if(o&&null==n&&null==(n=a.lookupPrefix(o)))var i=[{namespace:o,prefix:null}];return fe(this,r,e,t,i),r.join("")}function me(e,t,r){var a=e.prefix||"",n=e.namespaceURI;if(!n)return!1;if("xml"===a&&n===o.XML||n===o.XMLNS)return!1;for(var i=r.length;i--;){var s=r[i];if(s.prefix===a)return s.namespace!==n}return!0}function pe(e,t,r){e.push(" ",t,'="',r.replace(/[<>&"\t\n\r]/g,I),'"')}function fe(e,t,r,a,n){if(n||(n=[]),a){if(!(e=a(e)))return;if("string"==typeof e)return void t.push(e)}switch(e.nodeType){case d:var i=e.attributes,s=i.length,l=e.firstChild,c=e.tagName,u=c;if(!(r=o.isHTML(e.namespaceURI)||r)&&!e.prefix&&e.namespaceURI){for(var h,g=0;g<i.length;g++)if("xmlns"===i.item(g).name){h=i.item(g).value;break}if(!h)for(var E=n.length-1;E>=0;E--)if(""===(_=n[E]).prefix&&_.namespace===e.namespaceURI){h=_.namespace;break}if(h!==e.namespaceURI)for(E=n.length-1;E>=0;E--){var _;if((_=n[E]).namespace===e.namespaceURI){_.prefix&&(u=_.prefix+":"+c);break}}}t.push("<",u);for(var y=0;y<s;y++)"xmlns"==(q=i.item(y)).prefix?n.push({prefix:q.localName,namespace:q.value}):"xmlns"==q.nodeName&&n.push({prefix:"",namespace:q.value});for(y=0;y<s;y++){var q,D,M;me(q=i.item(y),0,n)&&(pe(t,(D=q.prefix||"")?"xmlns:"+D:"xmlns",M=q.namespaceURI),n.push({prefix:D,namespace:M})),fe(q,t,r,a,n)}if(c===u&&me(e,0,n)&&(pe(t,(D=e.prefix||"")?"xmlns:"+D:"xmlns",M=e.namespaceURI),n.push({prefix:D,namespace:M})),l||r&&!/^(?:meta|link|img|br|hr|input)$/i.test(c)){if(t.push(">"),r&&/^script$/i.test(c))for(;l;)l.data?t.push(l.data):fe(l,t,r,a,n.slice()),l=l.nextSibling;else for(;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;t.push("</",u,">")}else t.push("/>");return;case v:case A:for(l=e.firstChild;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;return;case m:return pe(t,e.name,e.value);case p:return t.push(e.data.replace(/[<&>]/g,I));case f:return t.push("<![CDATA[",e.data,"]]>");case b:return t.push("\x3c!--",e.data,"--\x3e");case C:var T=e.publicId,N=e.systemId;if(t.push("<!DOCTYPE ",e.name),T)t.push(" PUBLIC ",T),N&&"."!=N&&t.push(" ",N),t.push(">");else if(N&&"."!=N)t.push(" SYSTEM ",N,">");else{var O=e.internalSubset;O&&t.push(" [",O,"]"),t.push(">")}return;case w:return t.push("<?",e.target," ",e.data,"?>");case x:return t.push("&",e.nodeName,";");default:t.push("??",e.nodeName)}}function xe(e,t,r){var a;switch(t.nodeType){case d:(a=t.cloneNode(!1)).ownerDocument=e;case A:break;case m:r=!0}if(a||(a=t.cloneNode(!1)),a.ownerDocument=e,a.parentNode=null,r)for(var n=t.firstChild;n;)a.appendChild(xe(e,n,r)),n=n.nextSibling;return a}function ge(e,t,r){var a=new t.constructor;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var o=t[n];"object"!=typeof o&&o!=a[n]&&(a[n]=o)}switch(t.childNodes&&(a.childNodes=new N),a.ownerDocument=e,a.nodeType){case d:var i=t.attributes,s=a.attributes=new B,l=i.length;s._ownerElement=a;for(var c=0;c<l;c++)a.setAttributeNode(ge(e,i.item(c),!0));break;case m:r=!0}if(r)for(var u=t.firstChild;u;)a.appendChild(ge(e,u,r)),u=u.nextSibling;return a}function we(e,t,r){e[t]=r}_.INVALID_STATE_ERR=(y[11]="Invalid state",11),_.SYNTAX_ERR=(y[12]="Syntax error",12),_.INVALID_MODIFICATION_ERR=(y[13]="Invalid modification",13),_.NAMESPACE_ERR=(y[14]="Invalid namespace",14),_.INVALID_ACCESS_ERR=(y[15]="Invalid access",15),T.prototype=Error.prototype,c(_,T),N.prototype={length:0,item:function(e){return e>=0&&e<this.length?this[e]:null},toString:function(e,t){for(var r=[],a=0;a<this.length;a++)fe(this[a],r,e,t);return r.join("")},filter:function(e){return Array.prototype.filter.call(this,e)},indexOf:function(e){return Array.prototype.indexOf.call(this,e)}},O.prototype.item=function(e){return L(this),this[e]||null},u(O,N),B.prototype={length:0,item:N.prototype.item,getNamedItem:function(e){for(var t=this.length;t--;){var r=this[t];if(r.nodeName==e)return r}},setNamedItem:function(e){var t=e.ownerElement;if(t&&t!=this._ownerElement)throw new T(M);var r=this.getNamedItem(e.nodeName);return F(this._ownerElement,this,e,r),r},setNamedItemNS:function(e){var t,r=e.ownerElement;if(r&&r!=this._ownerElement)throw new T(M);return t=this.getNamedItemNS(e.namespaceURI,e.localName),F(this._ownerElement,this,e,t),t},removeNamedItem:function(e){var t=this.getNamedItem(e);return P(this._ownerElement,this,t),t},removeNamedItemNS:function(e,t){var r=this.getNamedItemNS(e,t);return P(this._ownerElement,this,r),r},getNamedItemNS:function(e,t){for(var r=this.length;r--;){var a=this[r];if(a.localName==t&&a.namespaceURI==e)return a}return null}},k.prototype={hasFeature:function(e,t){return!0},createDocument:function(e,t,r){var a=new j;if(a.implementation=this,a.childNodes=new N,a.doctype=r||null,r&&a.appendChild(r),t){var n=a.createElementNS(e,t);a.appendChild(n)}return a},createDocumentType:function(e,t,r){var a=new oe;return a.name=e,a.nodeName=e,a.publicId=t||"",a.systemId=r||"",a}},R.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(e,t){return Q(this,e,t)},replaceChild:function(e,t){Q(this,e,t,Z),t&&this.removeChild(t)},removeChild:function(e){return $(this,e)},appendChild:function(e){return this.insertBefore(e,null)},hasChildNodes:function(){return null!=this.firstChild},cloneNode:function(e){return ge(this.ownerDocument||this,this,e)},normalize:function(){for(var e=this.firstChild;e;){var t=e.nextSibling;t&&t.nodeType==p&&e.nodeType==p?(this.removeChild(t),e.appendData(t.data)):(e.normalize(),e=t)}},isSupported:function(e,t){return this.ownerDocument.implementation.hasFeature(e,t)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(e){for(var t=this;t;){var r=t._nsMap;if(r)for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a)&&r[a]===e)return a;t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},lookupNamespaceURI:function(e){for(var t=this;t;){var r=t._nsMap;if(r&&Object.prototype.hasOwnProperty.call(r,e))return r[e];t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},isDefaultNamespace:function(e){return null==this.lookupPrefix(e)}},c(h,R),c(h,R.prototype),j.prototype={nodeName:"#document",nodeType:v,doctype:null,documentElement:null,_inc:1,insertBefore:function(e,t){if(e.nodeType==A){for(var r=e.firstChild;r;){var a=r.nextSibling;this.insertBefore(r,t),r=a}return e}return Q(this,e,t),e.ownerDocument=this,null===this.documentElement&&e.nodeType===d&&(this.documentElement=e),e},removeChild:function(e){return this.documentElement==e&&(this.documentElement=null),$(this,e)},replaceChild:function(e,t){Q(this,e,t,Z),e.ownerDocument=this,t&&this.removeChild(t),H(e)&&(this.documentElement=e)},importNode:function(e,t){return xe(this,e,t)},getElementById:function(e){var t=null;return U(this.documentElement,(function(r){if(r.nodeType==d&&r.getAttribute("id")==e)return t=r,!0})),t},getElementsByClassName:function(e){var t=l(e);return new O(this,(function(r){var a=[];return t.length>0&&U(r.documentElement,(function(n){if(n!==r&&n.nodeType===d){var o=n.getAttribute("class");if(o){var i=e===o;if(!i){var s=l(o);i=t.every((c=s,function(e){return c&&-1!==c.indexOf(e)}))}i&&a.push(n)}}var c})),a}))},createElement:function(e){var t=new K;return t.ownerDocument=this,t.nodeName=e,t.tagName=e,t.localName=e,t.childNodes=new N,(t.attributes=new B)._ownerElement=t,t},createDocumentFragment:function(){var e=new ce;return e.ownerDocument=this,e.childNodes=new N,e},createTextNode:function(e){var t=new re;return t.ownerDocument=this,t.appendData(e),t},createComment:function(e){var t=new ae;return t.ownerDocument=this,t.appendData(e),t},createCDATASection:function(e){var t=new ne;return t.ownerDocument=this,t.appendData(e),t},createProcessingInstruction:function(e,t){var r=new ue;return r.ownerDocument=this,r.tagName=r.nodeName=r.target=e,r.nodeValue=r.data=t,r},createAttribute:function(e){var t=new ee;return t.ownerDocument=this,t.name=e,t.nodeName=e,t.localName=e,t.specified=!0,t},createEntityReference:function(e){var t=new le;return t.ownerDocument=this,t.nodeName=e,t},createElementNS:function(e,t){var r=new K,a=t.split(":"),n=r.attributes=new B;return r.childNodes=new N,r.ownerDocument=this,r.nodeName=t,r.tagName=t,r.namespaceURI=e,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,n._ownerElement=r,r},createAttributeNS:function(e,t){var r=new ee,a=t.split(":");return r.ownerDocument=this,r.nodeName=t,r.name=t,r.namespaceURI=e,r.specified=!0,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,r}},u(j,R),K.prototype={nodeType:d,hasAttribute:function(e){return null!=this.getAttributeNode(e)},getAttribute:function(e){var t=this.getAttributeNode(e);return t&&t.value||""},getAttributeNode:function(e){return this.attributes.getNamedItem(e)},setAttribute:function(e,t){var r=this.ownerDocument.createAttribute(e);r.value=r.nodeValue=""+t,this.setAttributeNode(r)},removeAttribute:function(e){var t=this.getAttributeNode(e);t&&this.removeAttributeNode(t)},appendChild:function(e){return e.nodeType===A?this.insertBefore(e,null):function(e,t){return t.parentNode&&t.parentNode.removeChild(t),t.parentNode=e,t.previousSibling=e.lastChild,t.nextSibling=null,t.previousSibling?t.previousSibling.nextSibling=t:e.firstChild=t,e.lastChild=t,G(e.ownerDocument,e,t),t}(this,e)},setAttributeNode:function(e){return this.attributes.setNamedItem(e)},setAttributeNodeNS:function(e){return this.attributes.setNamedItemNS(e)},removeAttributeNode:function(e){return this.attributes.removeNamedItem(e.nodeName)},removeAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);r&&this.removeAttributeNode(r)},hasAttributeNS:function(e,t){return null!=this.getAttributeNodeNS(e,t)},getAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);return r&&r.value||""},setAttributeNS:function(e,t,r){var a=this.ownerDocument.createAttributeNS(e,t);a.value=a.nodeValue=""+r,this.setAttributeNode(a)},getAttributeNodeNS:function(e,t){return this.attributes.getNamedItemNS(e,t)},getElementsByTagName:function(e){return new O(this,(function(t){var r=[];return U(t,(function(a){a===t||a.nodeType!=d||"*"!==e&&a.tagName!=e||r.push(a)})),r}))},getElementsByTagNameNS:function(e,t){return new O(this,(function(r){var a=[];return U(r,(function(n){n===r||n.nodeType!==d||"*"!==e&&n.namespaceURI!==e||"*"!==t&&n.localName!=t||a.push(n)})),a}))}},j.prototype.getElementsByTagName=K.prototype.getElementsByTagName,j.prototype.getElementsByTagNameNS=K.prototype.getElementsByTagNameNS,u(K,R),ee.prototype.nodeType=m,u(ee,R),te.prototype={data:"",substringData:function(e,t){return this.data.substring(e,e+t)},appendData:function(e){e=this.data+e,this.nodeValue=this.data=e,this.length=e.length},insertData:function(e,t){this.replaceData(e,0,t)},appendChild:function(e){throw new Error(y[q])},deleteData:function(e,t){this.replaceData(e,t,"")},replaceData:function(e,t,r){r=this.data.substring(0,e)+r+this.data.substring(e+t),this.nodeValue=this.data=r,this.length=r.length}},u(te,R),re.prototype={nodeName:"#text",nodeType:p,splitText:function(e){var t=this.data,r=t.substring(e);t=t.substring(0,e),this.data=this.nodeValue=t,this.length=t.length;var a=this.ownerDocument.createTextNode(r);return this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling),a}},u(re,te),ae.prototype={nodeName:"#comment",nodeType:b},u(ae,te),ne.prototype={nodeName:"#cdata-section",nodeType:f},u(ne,te),oe.prototype.nodeType=C,u(oe,R),ie.prototype.nodeType=E,u(ie,R),se.prototype.nodeType=g,u(se,R),le.prototype.nodeType=x,u(le,R),ce.prototype.nodeName="#document-fragment",ce.prototype.nodeType=A,u(ce,R),ue.prototype.nodeType=w,u(ue,R),he.prototype.serializeToString=function(e,t,r){return de.call(e,t,r)},R.prototype.toString=de;try{if(Object.defineProperty){function be(e){switch(e.nodeType){case d:case A:var t=[];for(e=e.firstChild;e;)7!==e.nodeType&&8!==e.nodeType&&t.push(be(e)),e=e.nextSibling;return t.join("");default:return e.nodeValue}}Object.defineProperty(O.prototype,"length",{get:function(){return L(this),this.$$length}}),Object.defineProperty(R.prototype,"textContent",{get:function(){return be(this)},set:function(e){switch(this.nodeType){case d:case A:for(;this.firstChild;)this.removeChild(this.firstChild);(e||String(e))&&this.appendChild(this.ownerDocument.createTextNode(e));break;default:this.data=e,this.value=e,this.nodeValue=e}}}),we=function(e,t,r){e["$$"+t]=r}}}catch(ve){}t.DocumentType=oe,t.DOMException=T,t.DOMImplementation=k,t.Element=K,t.Node=R,t.NodeList=N,t.XMLSerializer=he},6559:(e,t,r)=>{"use strict";var a=r(4582).freeze;t.XML_ENTITIES=a({amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}),t.HTML_ENTITIES=a({Aacute:"Á",aacute:"á",Abreve:"Ă",abreve:"ă",ac:"∾",acd:"∿",acE:"∾̳",Acirc:"Â",acirc:"â",acute:"´",Acy:"А",acy:"а",AElig:"Æ",aelig:"æ",af:"⁡",Afr:"𝔄",afr:"𝔞",Agrave:"À",agrave:"à",alefsym:"ℵ",aleph:"ℵ",Alpha:"Α",alpha:"α",Amacr:"Ā",amacr:"ā",amalg:"⨿",AMP:"&",amp:"&",And:"⩓",and:"∧",andand:"⩕",andd:"⩜",andslope:"⩘",andv:"⩚",ang:"∠",ange:"⦤",angle:"∠",angmsd:"∡",angmsdaa:"⦨",angmsdab:"⦩",angmsdac:"⦪",angmsdad:"⦫",angmsdae:"⦬",angmsdaf:"⦭",angmsdag:"⦮",angmsdah:"⦯",angrt:"∟",angrtvb:"⊾",angrtvbd:"⦝",angsph:"∢",angst:"Å",angzarr:"⍼",Aogon:"Ą",aogon:"ą",Aopf:"𝔸",aopf:"𝕒",ap:"≈",apacir:"⩯",apE:"⩰",ape:"≊",apid:"≋",apos:"'",ApplyFunction:"⁡",approx:"≈",approxeq:"≊",Aring:"Å",aring:"å",Ascr:"𝒜",ascr:"𝒶",Assign:"≔",ast:"*",asymp:"≈",asympeq:"≍",Atilde:"Ã",atilde:"ã",Auml:"Ä",auml:"ä",awconint:"∳",awint:"⨑",backcong:"≌",backepsilon:"϶",backprime:"‵",backsim:"∽",backsimeq:"⋍",Backslash:"∖",Barv:"⫧",barvee:"⊽",Barwed:"⌆",barwed:"⌅",barwedge:"⌅",bbrk:"⎵",bbrktbrk:"⎶",bcong:"≌",Bcy:"Б",bcy:"б",bdquo:"„",becaus:"∵",Because:"∵",because:"∵",bemptyv:"⦰",bepsi:"϶",bernou:"ℬ",Bernoullis:"ℬ",Beta:"Β",beta:"β",beth:"ℶ",between:"≬",Bfr:"𝔅",bfr:"𝔟",bigcap:"⋂",bigcirc:"◯",bigcup:"⋃",bigodot:"⨀",bigoplus:"⨁",bigotimes:"⨂",bigsqcup:"⨆",bigstar:"★",bigtriangledown:"▽",bigtriangleup:"△",biguplus:"⨄",bigvee:"⋁",bigwedge:"⋀",bkarow:"⤍",blacklozenge:"⧫",blacksquare:"▪",blacktriangle:"▴",blacktriangledown:"▾",blacktriangleleft:"◂",blacktriangleright:"▸",blank:"␣",blk12:"▒",blk14:"░",blk34:"▓",block:"█",bne:"=⃥",bnequiv:"≡⃥",bNot:"⫭",bnot:"⌐",Bopf:"𝔹",bopf:"𝕓",bot:"⊥",bottom:"⊥",bowtie:"⋈",boxbox:"⧉",boxDL:"╗",boxDl:"╖",boxdL:"╕",boxdl:"┐",boxDR:"╔",boxDr:"╓",boxdR:"╒",boxdr:"┌",boxH:"═",boxh:"─",boxHD:"╦",boxHd:"╤",boxhD:"╥",boxhd:"┬",boxHU:"╩",boxHu:"╧",boxhU:"╨",boxhu:"┴",boxminus:"⊟",boxplus:"⊞",boxtimes:"⊠",boxUL:"╝",boxUl:"╜",boxuL:"╛",boxul:"┘",boxUR:"╚",boxUr:"╙",boxuR:"╘",boxur:"└",boxV:"║",boxv:"│",boxVH:"╬",boxVh:"╫",boxvH:"╪",boxvh:"┼",boxVL:"╣",boxVl:"╢",boxvL:"╡",boxvl:"┤",boxVR:"╠",boxVr:"╟",boxvR:"╞",boxvr:"├",bprime:"‵",Breve:"˘",breve:"˘",brvbar:"¦",Bscr:"ℬ",bscr:"𝒷",bsemi:"⁏",bsim:"∽",bsime:"⋍",bsol:"\\",bsolb:"⧅",bsolhsub:"⟈",bull:"•",bullet:"•",bump:"≎",bumpE:"⪮",bumpe:"≏",Bumpeq:"≎",bumpeq:"≏",Cacute:"Ć",cacute:"ć",Cap:"⋒",cap:"∩",capand:"⩄",capbrcup:"⩉",capcap:"⩋",capcup:"⩇",capdot:"⩀",CapitalDifferentialD:"ⅅ",caps:"∩︀",caret:"⁁",caron:"ˇ",Cayleys:"ℭ",ccaps:"⩍",Ccaron:"Č",ccaron:"č",Ccedil:"Ç",ccedil:"ç",Ccirc:"Ĉ",ccirc:"ĉ",Cconint:"∰",ccups:"⩌",ccupssm:"⩐",Cdot:"Ċ",cdot:"ċ",cedil:"¸",Cedilla:"¸",cemptyv:"⦲",cent:"¢",CenterDot:"·",centerdot:"·",Cfr:"ℭ",cfr:"𝔠",CHcy:"Ч",chcy:"ч",check:"✓",checkmark:"✓",Chi:"Χ",chi:"χ",cir:"○",circ:"ˆ",circeq:"≗",circlearrowleft:"↺",circlearrowright:"↻",circledast:"⊛",circledcirc:"⊚",circleddash:"⊝",CircleDot:"⊙",circledR:"®",circledS:"Ⓢ",CircleMinus:"⊖",CirclePlus:"⊕",CircleTimes:"⊗",cirE:"⧃",cire:"≗",cirfnint:"⨐",cirmid:"⫯",cirscir:"⧂",ClockwiseContourIntegral:"∲",CloseCurlyDoubleQuote:"”",CloseCurlyQuote:"’",clubs:"♣",clubsuit:"♣",Colon:"∷",colon:":",Colone:"⩴",colone:"≔",coloneq:"≔",comma:",",commat:"@",comp:"∁",compfn:"∘",complement:"∁",complexes:"ℂ",cong:"≅",congdot:"⩭",Congruent:"≡",Conint:"∯",conint:"∮",ContourIntegral:"∮",Copf:"ℂ",copf:"𝕔",coprod:"∐",Coproduct:"∐",COPY:"©",copy:"©",copysr:"℗",CounterClockwiseContourIntegral:"∳",crarr:"↵",Cross:"⨯",cross:"✗",Cscr:"𝒞",cscr:"𝒸",csub:"⫏",csube:"⫑",csup:"⫐",csupe:"⫒",ctdot:"⋯",cudarrl:"⤸",cudarrr:"⤵",cuepr:"⋞",cuesc:"⋟",cularr:"↶",cularrp:"⤽",Cup:"⋓",cup:"∪",cupbrcap:"⩈",CupCap:"≍",cupcap:"⩆",cupcup:"⩊",cupdot:"⊍",cupor:"⩅",cups:"∪︀",curarr:"↷",curarrm:"⤼",curlyeqprec:"⋞",curlyeqsucc:"⋟",curlyvee:"⋎",curlywedge:"⋏",curren:"¤",curvearrowleft:"↶",curvearrowright:"↷",cuvee:"⋎",cuwed:"⋏",cwconint:"∲",cwint:"∱",cylcty:"⌭",Dagger:"‡",dagger:"†",daleth:"ℸ",Darr:"↡",dArr:"⇓",darr:"↓",dash:"‐",Dashv:"⫤",dashv:"⊣",dbkarow:"⤏",dblac:"˝",Dcaron:"Ď",dcaron:"ď",Dcy:"Д",dcy:"д",DD:"ⅅ",dd:"ⅆ",ddagger:"‡",ddarr:"⇊",DDotrahd:"⤑",ddotseq:"⩷",deg:"°",Del:"∇",Delta:"Δ",delta:"δ",demptyv:"⦱",dfisht:"⥿",Dfr:"𝔇",dfr:"𝔡",dHar:"⥥",dharl:"⇃",dharr:"⇂",DiacriticalAcute:"´",DiacriticalDot:"˙",DiacriticalDoubleAcute:"˝",DiacriticalGrave:"`",DiacriticalTilde:"˜",diam:"⋄",Diamond:"⋄",diamond:"⋄",diamondsuit:"♦",diams:"♦",die:"¨",DifferentialD:"ⅆ",digamma:"ϝ",disin:"⋲",div:"÷",divide:"÷",divideontimes:"⋇",divonx:"⋇",DJcy:"Ђ",djcy:"ђ",dlcorn:"⌞",dlcrop:"⌍",dollar:"$",Dopf:"𝔻",dopf:"𝕕",Dot:"¨",dot:"˙",DotDot:"⃜",doteq:"≐",doteqdot:"≑",DotEqual:"≐",dotminus:"∸",dotplus:"∔",dotsquare:"⊡",doublebarwedge:"⌆",DoubleContourIntegral:"∯",DoubleDot:"¨",DoubleDownArrow:"⇓",DoubleLeftArrow:"⇐",DoubleLeftRightArrow:"⇔",DoubleLeftTee:"⫤",DoubleLongLeftArrow:"⟸",DoubleLongLeftRightArrow:"⟺",DoubleLongRightArrow:"⟹",DoubleRightArrow:"⇒",DoubleRightTee:"⊨",DoubleUpArrow:"⇑",DoubleUpDownArrow:"⇕",DoubleVerticalBar:"∥",DownArrow:"↓",Downarrow:"⇓",downarrow:"↓",DownArrowBar:"⤓",DownArrowUpArrow:"⇵",DownBreve:"̑",downdownarrows:"⇊",downharpoonleft:"⇃",downharpoonright:"⇂",DownLeftRightVector:"⥐",DownLeftTeeVector:"⥞",DownLeftVector:"↽",DownLeftVectorBar:"⥖",DownRightTeeVector:"⥟",DownRightVector:"⇁",DownRightVectorBar:"⥗",DownTee:"⊤",DownTeeArrow:"↧",drbkarow:"⤐",drcorn:"⌟",drcrop:"⌌",Dscr:"𝒟",dscr:"𝒹",DScy:"Ѕ",dscy:"ѕ",dsol:"⧶",Dstrok:"Đ",dstrok:"đ",dtdot:"⋱",dtri:"▿",dtrif:"▾",duarr:"⇵",duhar:"⥯",dwangle:"⦦",DZcy:"Џ",dzcy:"џ",dzigrarr:"⟿",Eacute:"É",eacute:"é",easter:"⩮",Ecaron:"Ě",ecaron:"ě",ecir:"≖",Ecirc:"Ê",ecirc:"ê",ecolon:"≕",Ecy:"Э",ecy:"э",eDDot:"⩷",Edot:"Ė",eDot:"≑",edot:"ė",ee:"ⅇ",efDot:"≒",Efr:"𝔈",efr:"𝔢",eg:"⪚",Egrave:"È",egrave:"è",egs:"⪖",egsdot:"⪘",el:"⪙",Element:"∈",elinters:"⏧",ell:"ℓ",els:"⪕",elsdot:"⪗",Emacr:"Ē",emacr:"ē",empty:"∅",emptyset:"∅",EmptySmallSquare:"◻",emptyv:"∅",EmptyVerySmallSquare:"▫",emsp:" ",emsp13:" ",emsp14:" ",ENG:"Ŋ",eng:"ŋ",ensp:" ",Eogon:"Ę",eogon:"ę",Eopf:"𝔼",eopf:"𝕖",epar:"⋕",eparsl:"⧣",eplus:"⩱",epsi:"ε",Epsilon:"Ε",epsilon:"ε",epsiv:"ϵ",eqcirc:"≖",eqcolon:"≕",eqsim:"≂",eqslantgtr:"⪖",eqslantless:"⪕",Equal:"⩵",equals:"=",EqualTilde:"≂",equest:"≟",Equilibrium:"⇌",equiv:"≡",equivDD:"⩸",eqvparsl:"⧥",erarr:"⥱",erDot:"≓",Escr:"ℰ",escr:"ℯ",esdot:"≐",Esim:"⩳",esim:"≂",Eta:"Η",eta:"η",ETH:"Ð",eth:"ð",Euml:"Ë",euml:"ë",euro:"€",excl:"!",exist:"∃",Exists:"∃",expectation:"ℰ",ExponentialE:"ⅇ",exponentiale:"ⅇ",fallingdotseq:"≒",Fcy:"Ф",fcy:"ф",female:"♀",ffilig:"ﬃ",fflig:"ﬀ",ffllig:"ﬄ",Ffr:"𝔉",ffr:"𝔣",filig:"ﬁ",FilledSmallSquare:"◼",FilledVerySmallSquare:"▪",fjlig:"fj",flat:"♭",fllig:"ﬂ",fltns:"▱",fnof:"ƒ",Fopf:"𝔽",fopf:"𝕗",ForAll:"∀",forall:"∀",fork:"⋔",forkv:"⫙",Fouriertrf:"ℱ",fpartint:"⨍",frac12:"½",frac13:"⅓",frac14:"¼",frac15:"⅕",frac16:"⅙",frac18:"⅛",frac23:"⅔",frac25:"⅖",frac34:"¾",frac35:"⅗",frac38:"⅜",frac45:"⅘",frac56:"⅚",frac58:"⅝",frac78:"⅞",frasl:"⁄",frown:"⌢",Fscr:"ℱ",fscr:"𝒻",gacute:"ǵ",Gamma:"Γ",gamma:"γ",Gammad:"Ϝ",gammad:"ϝ",gap:"⪆",Gbreve:"Ğ",gbreve:"ğ",Gcedil:"Ģ",Gcirc:"Ĝ",gcirc:"ĝ",Gcy:"Г",gcy:"г",Gdot:"Ġ",gdot:"ġ",gE:"≧",ge:"≥",gEl:"⪌",gel:"⋛",geq:"≥",geqq:"≧",geqslant:"⩾",ges:"⩾",gescc:"⪩",gesdot:"⪀",gesdoto:"⪂",gesdotol:"⪄",gesl:"⋛︀",gesles:"⪔",Gfr:"𝔊",gfr:"𝔤",Gg:"⋙",gg:"≫",ggg:"⋙",gimel:"ℷ",GJcy:"Ѓ",gjcy:"ѓ",gl:"≷",gla:"⪥",glE:"⪒",glj:"⪤",gnap:"⪊",gnapprox:"⪊",gnE:"≩",gne:"⪈",gneq:"⪈",gneqq:"≩",gnsim:"⋧",Gopf:"𝔾",gopf:"𝕘",grave:"`",GreaterEqual:"≥",GreaterEqualLess:"⋛",GreaterFullEqual:"≧",GreaterGreater:"⪢",GreaterLess:"≷",GreaterSlantEqual:"⩾",GreaterTilde:"≳",Gscr:"𝒢",gscr:"ℊ",gsim:"≳",gsime:"⪎",gsiml:"⪐",Gt:"≫",GT:">",gt:">",gtcc:"⪧",gtcir:"⩺",gtdot:"⋗",gtlPar:"⦕",gtquest:"⩼",gtrapprox:"⪆",gtrarr:"⥸",gtrdot:"⋗",gtreqless:"⋛",gtreqqless:"⪌",gtrless:"≷",gtrsim:"≳",gvertneqq:"≩︀",gvnE:"≩︀",Hacek:"ˇ",hairsp:" ",half:"½",hamilt:"ℋ",HARDcy:"Ъ",hardcy:"ъ",hArr:"⇔",harr:"↔",harrcir:"⥈",harrw:"↭",Hat:"^",hbar:"ℏ",Hcirc:"Ĥ",hcirc:"ĥ",hearts:"♥",heartsuit:"♥",hellip:"…",hercon:"⊹",Hfr:"ℌ",hfr:"𝔥",HilbertSpace:"ℋ",hksearow:"⤥",hkswarow:"⤦",hoarr:"⇿",homtht:"∻",hookleftarrow:"↩",hookrightarrow:"↪",Hopf:"ℍ",hopf:"𝕙",horbar:"―",HorizontalLine:"─",Hscr:"ℋ",hscr:"𝒽",hslash:"ℏ",Hstrok:"Ħ",hstrok:"ħ",HumpDownHump:"≎",HumpEqual:"≏",hybull:"⁃",hyphen:"‐",Iacute:"Í",iacute:"í",ic:"⁣",Icirc:"Î",icirc:"î",Icy:"И",icy:"и",Idot:"İ",IEcy:"Е",iecy:"е",iexcl:"¡",iff:"⇔",Ifr:"ℑ",ifr:"𝔦",Igrave:"Ì",igrave:"ì",ii:"ⅈ",iiiint:"⨌",iiint:"∭",iinfin:"⧜",iiota:"℩",IJlig:"Ĳ",ijlig:"ĳ",Im:"ℑ",Imacr:"Ī",imacr:"ī",image:"ℑ",ImaginaryI:"ⅈ",imagline:"ℐ",imagpart:"ℑ",imath:"ı",imof:"⊷",imped:"Ƶ",Implies:"⇒",in:"∈",incare:"℅",infin:"∞",infintie:"⧝",inodot:"ı",Int:"∬",int:"∫",intcal:"⊺",integers:"ℤ",Integral:"∫",intercal:"⊺",Intersection:"⋂",intlarhk:"⨗",intprod:"⨼",InvisibleComma:"⁣",InvisibleTimes:"⁢",IOcy:"Ё",iocy:"ё",Iogon:"Į",iogon:"į",Iopf:"𝕀",iopf:"𝕚",Iota:"Ι",iota:"ι",iprod:"⨼",iquest:"¿",Iscr:"ℐ",iscr:"𝒾",isin:"∈",isindot:"⋵",isinE:"⋹",isins:"⋴",isinsv:"⋳",isinv:"∈",it:"⁢",Itilde:"Ĩ",itilde:"ĩ",Iukcy:"І",iukcy:"і",Iuml:"Ï",iuml:"ï",Jcirc:"Ĵ",jcirc:"ĵ",Jcy:"Й",jcy:"й",Jfr:"𝔍",jfr:"𝔧",jmath:"ȷ",Jopf:"𝕁",jopf:"𝕛",Jscr:"𝒥",jscr:"𝒿",Jsercy:"Ј",jsercy:"ј",Jukcy:"Є",jukcy:"є",Kappa:"Κ",kappa:"κ",kappav:"ϰ",Kcedil:"Ķ",kcedil:"ķ",Kcy:"К",kcy:"к",Kfr:"𝔎",kfr:"𝔨",kgreen:"ĸ",KHcy:"Х",khcy:"х",KJcy:"Ќ",kjcy:"ќ",Kopf:"𝕂",kopf:"𝕜",Kscr:"𝒦",kscr:"𝓀",lAarr:"⇚",Lacute:"Ĺ",lacute:"ĺ",laemptyv:"⦴",lagran:"ℒ",Lambda:"Λ",lambda:"λ",Lang:"⟪",lang:"⟨",langd:"⦑",langle:"⟨",lap:"⪅",Laplacetrf:"ℒ",laquo:"«",Larr:"↞",lArr:"⇐",larr:"←",larrb:"⇤",larrbfs:"⤟",larrfs:"⤝",larrhk:"↩",larrlp:"↫",larrpl:"⤹",larrsim:"⥳",larrtl:"↢",lat:"⪫",lAtail:"⤛",latail:"⤙",late:"⪭",lates:"⪭︀",lBarr:"⤎",lbarr:"⤌",lbbrk:"❲",lbrace:"{",lbrack:"[",lbrke:"⦋",lbrksld:"⦏",lbrkslu:"⦍",Lcaron:"Ľ",lcaron:"ľ",Lcedil:"Ļ",lcedil:"ļ",lceil:"⌈",lcub:"{",Lcy:"Л",lcy:"л",ldca:"⤶",ldquo:"“",ldquor:"„",ldrdhar:"⥧",ldrushar:"⥋",ldsh:"↲",lE:"≦",le:"≤",LeftAngleBracket:"⟨",LeftArrow:"←",Leftarrow:"⇐",leftarrow:"←",LeftArrowBar:"⇤",LeftArrowRightArrow:"⇆",leftarrowtail:"↢",LeftCeiling:"⌈",LeftDoubleBracket:"⟦",LeftDownTeeVector:"⥡",LeftDownVector:"⇃",LeftDownVectorBar:"⥙",LeftFloor:"⌊",leftharpoondown:"↽",leftharpoonup:"↼",leftleftarrows:"⇇",LeftRightArrow:"↔",Leftrightarrow:"⇔",leftrightarrow:"↔",leftrightarrows:"⇆",leftrightharpoons:"⇋",leftrightsquigarrow:"↭",LeftRightVector:"⥎",LeftTee:"⊣",LeftTeeArrow:"↤",LeftTeeVector:"⥚",leftthreetimes:"⋋",LeftTriangle:"⊲",LeftTriangleBar:"⧏",LeftTriangleEqual:"⊴",LeftUpDownVector:"⥑",LeftUpTeeVector:"⥠",LeftUpVector:"↿",LeftUpVectorBar:"⥘",LeftVector:"↼",LeftVectorBar:"⥒",lEg:"⪋",leg:"⋚",leq:"≤",leqq:"≦",leqslant:"⩽",les:"⩽",lescc:"⪨",lesdot:"⩿",lesdoto:"⪁",lesdotor:"⪃",lesg:"⋚︀",lesges:"⪓",lessapprox:"⪅",lessdot:"⋖",lesseqgtr:"⋚",lesseqqgtr:"⪋",LessEqualGreater:"⋚",LessFullEqual:"≦",LessGreater:"≶",lessgtr:"≶",LessLess:"⪡",lesssim:"≲",LessSlantEqual:"⩽",LessTilde:"≲",lfisht:"⥼",lfloor:"⌊",Lfr:"𝔏",lfr:"𝔩",lg:"≶",lgE:"⪑",lHar:"⥢",lhard:"↽",lharu:"↼",lharul:"⥪",lhblk:"▄",LJcy:"Љ",ljcy:"љ",Ll:"⋘",ll:"≪",llarr:"⇇",llcorner:"⌞",Lleftarrow:"⇚",llhard:"⥫",lltri:"◺",Lmidot:"Ŀ",lmidot:"ŀ",lmoust:"⎰",lmoustache:"⎰",lnap:"⪉",lnapprox:"⪉",lnE:"≨",lne:"⪇",lneq:"⪇",lneqq:"≨",lnsim:"⋦",loang:"⟬",loarr:"⇽",lobrk:"⟦",LongLeftArrow:"⟵",Longleftarrow:"⟸",longleftarrow:"⟵",LongLeftRightArrow:"⟷",Longleftrightarrow:"⟺",longleftrightarrow:"⟷",longmapsto:"⟼",LongRightArrow:"⟶",Longrightarrow:"⟹",longrightarrow:"⟶",looparrowleft:"↫",looparrowright:"↬",lopar:"⦅",Lopf:"𝕃",lopf:"𝕝",loplus:"⨭",lotimes:"⨴",lowast:"∗",lowbar:"_",LowerLeftArrow:"↙",LowerRightArrow:"↘",loz:"◊",lozenge:"◊",lozf:"⧫",lpar:"(",lparlt:"⦓",lrarr:"⇆",lrcorner:"⌟",lrhar:"⇋",lrhard:"⥭",lrm:"‎",lrtri:"⊿",lsaquo:"‹",Lscr:"ℒ",lscr:"𝓁",Lsh:"↰",lsh:"↰",lsim:"≲",lsime:"⪍",lsimg:"⪏",lsqb:"[",lsquo:"‘",lsquor:"‚",Lstrok:"Ł",lstrok:"ł",Lt:"≪",LT:"<",lt:"<",ltcc:"⪦",ltcir:"⩹",ltdot:"⋖",lthree:"⋋",ltimes:"⋉",ltlarr:"⥶",ltquest:"⩻",ltri:"◃",ltrie:"⊴",ltrif:"◂",ltrPar:"⦖",lurdshar:"⥊",luruhar:"⥦",lvertneqq:"≨︀",lvnE:"≨︀",macr:"¯",male:"♂",malt:"✠",maltese:"✠",Map:"⤅",map:"↦",mapsto:"↦",mapstodown:"↧",mapstoleft:"↤",mapstoup:"↥",marker:"▮",mcomma:"⨩",Mcy:"М",mcy:"м",mdash:"—",mDDot:"∺",measuredangle:"∡",MediumSpace:" ",Mellintrf:"ℳ",Mfr:"𝔐",mfr:"𝔪",mho:"℧",micro:"µ",mid:"∣",midast:"*",midcir:"⫰",middot:"·",minus:"−",minusb:"⊟",minusd:"∸",minusdu:"⨪",MinusPlus:"∓",mlcp:"⫛",mldr:"…",mnplus:"∓",models:"⊧",Mopf:"𝕄",mopf:"𝕞",mp:"∓",Mscr:"ℳ",mscr:"𝓂",mstpos:"∾",Mu:"Μ",mu:"μ",multimap:"⊸",mumap:"⊸",nabla:"∇",Nacute:"Ń",nacute:"ń",nang:"∠⃒",nap:"≉",napE:"⩰̸",napid:"≋̸",napos:"ŉ",napprox:"≉",natur:"♮",natural:"♮",naturals:"ℕ",nbsp:" ",nbump:"≎̸",nbumpe:"≏̸",ncap:"⩃",Ncaron:"Ň",ncaron:"ň",Ncedil:"Ņ",ncedil:"ņ",ncong:"≇",ncongdot:"⩭̸",ncup:"⩂",Ncy:"Н",ncy:"н",ndash:"–",ne:"≠",nearhk:"⤤",neArr:"⇗",nearr:"↗",nearrow:"↗",nedot:"≐̸",NegativeMediumSpace:"​",NegativeThickSpace:"​",NegativeThinSpace:"​",NegativeVeryThinSpace:"​",nequiv:"≢",nesear:"⤨",nesim:"≂̸",NestedGreaterGreater:"≫",NestedLessLess:"≪",NewLine:"\n",nexist:"∄",nexists:"∄",Nfr:"𝔑",nfr:"𝔫",ngE:"≧̸",nge:"≱",ngeq:"≱",ngeqq:"≧̸",ngeqslant:"⩾̸",nges:"⩾̸",nGg:"⋙̸",ngsim:"≵",nGt:"≫⃒",ngt:"≯",ngtr:"≯",nGtv:"≫̸",nhArr:"⇎",nharr:"↮",nhpar:"⫲",ni:"∋",nis:"⋼",nisd:"⋺",niv:"∋",NJcy:"Њ",njcy:"њ",nlArr:"⇍",nlarr:"↚",nldr:"‥",nlE:"≦̸",nle:"≰",nLeftarrow:"⇍",nleftarrow:"↚",nLeftrightarrow:"⇎",nleftrightarrow:"↮",nleq:"≰",nleqq:"≦̸",nleqslant:"⩽̸",nles:"⩽̸",nless:"≮",nLl:"⋘̸",nlsim:"≴",nLt:"≪⃒",nlt:"≮",nltri:"⋪",nltrie:"⋬",nLtv:"≪̸",nmid:"∤",NoBreak:"⁠",NonBreakingSpace:" ",Nopf:"ℕ",nopf:"𝕟",Not:"⫬",not:"¬",NotCongruent:"≢",NotCupCap:"≭",NotDoubleVerticalBar:"∦",NotElement:"∉",NotEqual:"≠",NotEqualTilde:"≂̸",NotExists:"∄",NotGreater:"≯",NotGreaterEqual:"≱",NotGreaterFullEqual:"≧̸",NotGreaterGreater:"≫̸",NotGreaterLess:"≹",NotGreaterSlantEqual:"⩾̸",NotGreaterTilde:"≵",NotHumpDownHump:"≎̸",NotHumpEqual:"≏̸",notin:"∉",notindot:"⋵̸",notinE:"⋹̸",notinva:"∉",notinvb:"⋷",notinvc:"⋶",NotLeftTriangle:"⋪",NotLeftTriangleBar:"⧏̸",NotLeftTriangleEqual:"⋬",NotLess:"≮",NotLessEqual:"≰",NotLessGreater:"≸",NotLessLess:"≪̸",NotLessSlantEqual:"⩽̸",NotLessTilde:"≴",NotNestedGreaterGreater:"⪢̸",NotNestedLessLess:"⪡̸",notni:"∌",notniva:"∌",notnivb:"⋾",notnivc:"⋽",NotPrecedes:"⊀",NotPrecedesEqual:"⪯̸",NotPrecedesSlantEqual:"⋠",NotReverseElement:"∌",NotRightTriangle:"⋫",NotRightTriangleBar:"⧐̸",NotRightTriangleEqual:"⋭",NotSquareSubset:"⊏̸",NotSquareSubsetEqual:"⋢",NotSquareSuperset:"⊐̸",NotSquareSupersetEqual:"⋣",NotSubset:"⊂⃒",NotSubsetEqual:"⊈",NotSucceeds:"⊁",NotSucceedsEqual:"⪰̸",NotSucceedsSlantEqual:"⋡",NotSucceedsTilde:"≿̸",NotSuperset:"⊃⃒",NotSupersetEqual:"⊉",NotTilde:"≁",NotTildeEqual:"≄",NotTildeFullEqual:"≇",NotTildeTilde:"≉",NotVerticalBar:"∤",npar:"∦",nparallel:"∦",nparsl:"⫽⃥",npart:"∂̸",npolint:"⨔",npr:"⊀",nprcue:"⋠",npre:"⪯̸",nprec:"⊀",npreceq:"⪯̸",nrArr:"⇏",nrarr:"↛",nrarrc:"⤳̸",nrarrw:"↝̸",nRightarrow:"⇏",nrightarrow:"↛",nrtri:"⋫",nrtrie:"⋭",nsc:"⊁",nsccue:"⋡",nsce:"⪰̸",Nscr:"𝒩",nscr:"𝓃",nshortmid:"∤",nshortparallel:"∦",nsim:"≁",nsime:"≄",nsimeq:"≄",nsmid:"∤",nspar:"∦",nsqsube:"⋢",nsqsupe:"⋣",nsub:"⊄",nsubE:"⫅̸",nsube:"⊈",nsubset:"⊂⃒",nsubseteq:"⊈",nsubseteqq:"⫅̸",nsucc:"⊁",nsucceq:"⪰̸",nsup:"⊅",nsupE:"⫆̸",nsupe:"⊉",nsupset:"⊃⃒",nsupseteq:"⊉",nsupseteqq:"⫆̸",ntgl:"≹",Ntilde:"Ñ",ntilde:"ñ",ntlg:"≸",ntriangleleft:"⋪",ntrianglelefteq:"⋬",ntriangleright:"⋫",ntrianglerighteq:"⋭",Nu:"Ν",nu:"ν",num:"#",numero:"№",numsp:" ",nvap:"≍⃒",nVDash:"⊯",nVdash:"⊮",nvDash:"⊭",nvdash:"⊬",nvge:"≥⃒",nvgt:">⃒",nvHarr:"⤄",nvinfin:"⧞",nvlArr:"⤂",nvle:"≤⃒",nvlt:"<⃒",nvltrie:"⊴⃒",nvrArr:"⤃",nvrtrie:"⊵⃒",nvsim:"∼⃒",nwarhk:"⤣",nwArr:"⇖",nwarr:"↖",nwarrow:"↖",nwnear:"⤧",Oacute:"Ó",oacute:"ó",oast:"⊛",ocir:"⊚",Ocirc:"Ô",ocirc:"ô",Ocy:"О",ocy:"о",odash:"⊝",Odblac:"Ő",odblac:"ő",odiv:"⨸",odot:"⊙",odsold:"⦼",OElig:"Œ",oelig:"œ",ofcir:"⦿",Ofr:"𝔒",ofr:"𝔬",ogon:"˛",Ograve:"Ò",ograve:"ò",ogt:"⧁",ohbar:"⦵",ohm:"Ω",oint:"∮",olarr:"↺",olcir:"⦾",olcross:"⦻",oline:"‾",olt:"⧀",Omacr:"Ō",omacr:"ō",Omega:"Ω",omega:"ω",Omicron:"Ο",omicron:"ο",omid:"⦶",ominus:"⊖",Oopf:"𝕆",oopf:"𝕠",opar:"⦷",OpenCurlyDoubleQuote:"“",OpenCurlyQuote:"‘",operp:"⦹",oplus:"⊕",Or:"⩔",or:"∨",orarr:"↻",ord:"⩝",order:"ℴ",orderof:"ℴ",ordf:"ª",ordm:"º",origof:"⊶",oror:"⩖",orslope:"⩗",orv:"⩛",oS:"Ⓢ",Oscr:"𝒪",oscr:"ℴ",Oslash:"Ø",oslash:"ø",osol:"⊘",Otilde:"Õ",otilde:"õ",Otimes:"⨷",otimes:"⊗",otimesas:"⨶",Ouml:"Ö",ouml:"ö",ovbar:"⌽",OverBar:"‾",OverBrace:"⏞",OverBracket:"⎴",OverParenthesis:"⏜",par:"∥",para:"¶",parallel:"∥",parsim:"⫳",parsl:"⫽",part:"∂",PartialD:"∂",Pcy:"П",pcy:"п",percnt:"%",period:".",permil:"‰",perp:"⊥",pertenk:"‱",Pfr:"𝔓",pfr:"𝔭",Phi:"Φ",phi:"φ",phiv:"ϕ",phmmat:"ℳ",phone:"☎",Pi:"Π",pi:"π",pitchfork:"⋔",piv:"ϖ",planck:"ℏ",planckh:"ℎ",plankv:"ℏ",plus:"+",plusacir:"⨣",plusb:"⊞",pluscir:"⨢",plusdo:"∔",plusdu:"⨥",pluse:"⩲",PlusMinus:"±",plusmn:"±",plussim:"⨦",plustwo:"⨧",pm:"±",Poincareplane:"ℌ",pointint:"⨕",Popf:"ℙ",popf:"𝕡",pound:"£",Pr:"⪻",pr:"≺",prap:"⪷",prcue:"≼",prE:"⪳",pre:"⪯",prec:"≺",precapprox:"⪷",preccurlyeq:"≼",Precedes:"≺",PrecedesEqual:"⪯",PrecedesSlantEqual:"≼",PrecedesTilde:"≾",preceq:"⪯",precnapprox:"⪹",precneqq:"⪵",precnsim:"⋨",precsim:"≾",Prime:"″",prime:"′",primes:"ℙ",prnap:"⪹",prnE:"⪵",prnsim:"⋨",prod:"∏",Product:"∏",profalar:"⌮",profline:"⌒",profsurf:"⌓",prop:"∝",Proportion:"∷",Proportional:"∝",propto:"∝",prsim:"≾",prurel:"⊰",Pscr:"𝒫",pscr:"𝓅",Psi:"Ψ",psi:"ψ",puncsp:" ",Qfr:"𝔔",qfr:"𝔮",qint:"⨌",Qopf:"ℚ",qopf:"𝕢",qprime:"⁗",Qscr:"𝒬",qscr:"𝓆",quaternions:"ℍ",quatint:"⨖",quest:"?",questeq:"≟",QUOT:'"',quot:'"',rAarr:"⇛",race:"∽̱",Racute:"Ŕ",racute:"ŕ",radic:"√",raemptyv:"⦳",Rang:"⟫",rang:"⟩",rangd:"⦒",range:"⦥",rangle:"⟩",raquo:"»",Rarr:"↠",rArr:"⇒",rarr:"→",rarrap:"⥵",rarrb:"⇥",rarrbfs:"⤠",rarrc:"⤳",rarrfs:"⤞",rarrhk:"↪",rarrlp:"↬",rarrpl:"⥅",rarrsim:"⥴",Rarrtl:"⤖",rarrtl:"↣",rarrw:"↝",rAtail:"⤜",ratail:"⤚",ratio:"∶",rationals:"ℚ",RBarr:"⤐",rBarr:"⤏",rbarr:"⤍",rbbrk:"❳",rbrace:"}",rbrack:"]",rbrke:"⦌",rbrksld:"⦎",rbrkslu:"⦐",Rcaron:"Ř",rcaron:"ř",Rcedil:"Ŗ",rcedil:"ŗ",rceil:"⌉",rcub:"}",Rcy:"Р",rcy:"р",rdca:"⤷",rdldhar:"⥩",rdquo:"”",rdquor:"”",rdsh:"↳",Re:"ℜ",real:"ℜ",realine:"ℛ",realpart:"ℜ",reals:"ℝ",rect:"▭",REG:"®",reg:"®",ReverseElement:"∋",ReverseEquilibrium:"⇋",ReverseUpEquilibrium:"⥯",rfisht:"⥽",rfloor:"⌋",Rfr:"ℜ",rfr:"𝔯",rHar:"⥤",rhard:"⇁",rharu:"⇀",rharul:"⥬",Rho:"Ρ",rho:"ρ",rhov:"ϱ",RightAngleBracket:"⟩",RightArrow:"→",Rightarrow:"⇒",rightarrow:"→",RightArrowBar:"⇥",RightArrowLeftArrow:"⇄",rightarrowtail:"↣",RightCeiling:"⌉",RightDoubleBracket:"⟧",RightDownTeeVector:"⥝",RightDownVector:"⇂",RightDownVectorBar:"⥕",RightFloor:"⌋",rightharpoondown:"⇁",rightharpoonup:"⇀",rightleftarrows:"⇄",rightleftharpoons:"⇌",rightrightarrows:"⇉",rightsquigarrow:"↝",RightTee:"⊢",RightTeeArrow:"↦",RightTeeVector:"⥛",rightthreetimes:"⋌",RightTriangle:"⊳",RightTriangleBar:"⧐",RightTriangleEqual:"⊵",RightUpDownVector:"⥏",RightUpTeeVector:"⥜",RightUpVector:"↾",RightUpVectorBar:"⥔",RightVector:"⇀",RightVectorBar:"⥓",ring:"˚",risingdotseq:"≓",rlarr:"⇄",rlhar:"⇌",rlm:"‏",rmoust:"⎱",rmoustache:"⎱",rnmid:"⫮",roang:"⟭",roarr:"⇾",robrk:"⟧",ropar:"⦆",Ropf:"ℝ",ropf:"𝕣",roplus:"⨮",rotimes:"⨵",RoundImplies:"⥰",rpar:")",rpargt:"⦔",rppolint:"⨒",rrarr:"⇉",Rrightarrow:"⇛",rsaquo:"›",Rscr:"ℛ",rscr:"𝓇",Rsh:"↱",rsh:"↱",rsqb:"]",rsquo:"’",rsquor:"’",rthree:"⋌",rtimes:"⋊",rtri:"▹",rtrie:"⊵",rtrif:"▸",rtriltri:"⧎",RuleDelayed:"⧴",ruluhar:"⥨",rx:"℞",Sacute:"Ś",sacute:"ś",sbquo:"‚",Sc:"⪼",sc:"≻",scap:"⪸",Scaron:"Š",scaron:"š",sccue:"≽",scE:"⪴",sce:"⪰",Scedil:"Ş",scedil:"ş",Scirc:"Ŝ",scirc:"ŝ",scnap:"⪺",scnE:"⪶",scnsim:"⋩",scpolint:"⨓",scsim:"≿",Scy:"С",scy:"с",sdot:"⋅",sdotb:"⊡",sdote:"⩦",searhk:"⤥",seArr:"⇘",searr:"↘",searrow:"↘",sect:"§",semi:";",seswar:"⤩",setminus:"∖",setmn:"∖",sext:"✶",Sfr:"𝔖",sfr:"𝔰",sfrown:"⌢",sharp:"♯",SHCHcy:"Щ",shchcy:"щ",SHcy:"Ш",shcy:"ш",ShortDownArrow:"↓",ShortLeftArrow:"←",shortmid:"∣",shortparallel:"∥",ShortRightArrow:"→",ShortUpArrow:"↑",shy:"­",Sigma:"Σ",sigma:"σ",sigmaf:"ς",sigmav:"ς",sim:"∼",simdot:"⩪",sime:"≃",simeq:"≃",simg:"⪞",simgE:"⪠",siml:"⪝",simlE:"⪟",simne:"≆",simplus:"⨤",simrarr:"⥲",slarr:"←",SmallCircle:"∘",smallsetminus:"∖",smashp:"⨳",smeparsl:"⧤",smid:"∣",smile:"⌣",smt:"⪪",smte:"⪬",smtes:"⪬︀",SOFTcy:"Ь",softcy:"ь",sol:"/",solb:"⧄",solbar:"⌿",Sopf:"𝕊",sopf:"𝕤",spades:"♠",spadesuit:"♠",spar:"∥",sqcap:"⊓",sqcaps:"⊓︀",sqcup:"⊔",sqcups:"⊔︀",Sqrt:"√",sqsub:"⊏",sqsube:"⊑",sqsubset:"⊏",sqsubseteq:"⊑",sqsup:"⊐",sqsupe:"⊒",sqsupset:"⊐",sqsupseteq:"⊒",squ:"□",Square:"□",square:"□",SquareIntersection:"⊓",SquareSubset:"⊏",SquareSubsetEqual:"⊑",SquareSuperset:"⊐",SquareSupersetEqual:"⊒",SquareUnion:"⊔",squarf:"▪",squf:"▪",srarr:"→",Sscr:"𝒮",sscr:"𝓈",ssetmn:"∖",ssmile:"⌣",sstarf:"⋆",Star:"⋆",star:"☆",starf:"★",straightepsilon:"ϵ",straightphi:"ϕ",strns:"¯",Sub:"⋐",sub:"⊂",subdot:"⪽",subE:"⫅",sube:"⊆",subedot:"⫃",submult:"⫁",subnE:"⫋",subne:"⊊",subplus:"⪿",subrarr:"⥹",Subset:"⋐",subset:"⊂",subseteq:"⊆",subseteqq:"⫅",SubsetEqual:"⊆",subsetneq:"⊊",subsetneqq:"⫋",subsim:"⫇",subsub:"⫕",subsup:"⫓",succ:"≻",succapprox:"⪸",succcurlyeq:"≽",Succeeds:"≻",SucceedsEqual:"⪰",SucceedsSlantEqual:"≽",SucceedsTilde:"≿",succeq:"⪰",succnapprox:"⪺",succneqq:"⪶",succnsim:"⋩",succsim:"≿",SuchThat:"∋",Sum:"∑",sum:"∑",sung:"♪",Sup:"⋑",sup:"⊃",sup1:"¹",sup2:"²",sup3:"³",supdot:"⪾",supdsub:"⫘",supE:"⫆",supe:"⊇",supedot:"⫄",Superset:"⊃",SupersetEqual:"⊇",suphsol:"⟉",suphsub:"⫗",suplarr:"⥻",supmult:"⫂",supnE:"⫌",supne:"⊋",supplus:"⫀",Supset:"⋑",supset:"⊃",supseteq:"⊇",supseteqq:"⫆",supsetneq:"⊋",supsetneqq:"⫌",supsim:"⫈",supsub:"⫔",supsup:"⫖",swarhk:"⤦",swArr:"⇙",swarr:"↙",swarrow:"↙",swnwar:"⤪",szlig:"ß",Tab:"\t",target:"⌖",Tau:"Τ",tau:"τ",tbrk:"⎴",Tcaron:"Ť",tcaron:"ť",Tcedil:"Ţ",tcedil:"ţ",Tcy:"Т",tcy:"т",tdot:"⃛",telrec:"⌕",Tfr:"𝔗",tfr:"𝔱",there4:"∴",Therefore:"∴",therefore:"∴",Theta:"Θ",theta:"θ",thetasym:"ϑ",thetav:"ϑ",thickapprox:"≈",thicksim:"∼",ThickSpace:"  ",thinsp:" ",ThinSpace:" ",thkap:"≈",thksim:"∼",THORN:"Þ",thorn:"þ",Tilde:"∼",tilde:"˜",TildeEqual:"≃",TildeFullEqual:"≅",TildeTilde:"≈",times:"×",timesb:"⊠",timesbar:"⨱",timesd:"⨰",tint:"∭",toea:"⤨",top:"⊤",topbot:"⌶",topcir:"⫱",Topf:"𝕋",topf:"𝕥",topfork:"⫚",tosa:"⤩",tprime:"‴",TRADE:"™",trade:"™",triangle:"▵",triangledown:"▿",triangleleft:"◃",trianglelefteq:"⊴",triangleq:"≜",triangleright:"▹",trianglerighteq:"⊵",tridot:"◬",trie:"≜",triminus:"⨺",TripleDot:"⃛",triplus:"⨹",trisb:"⧍",tritime:"⨻",trpezium:"⏢",Tscr:"𝒯",tscr:"𝓉",TScy:"Ц",tscy:"ц",TSHcy:"Ћ",tshcy:"ћ",Tstrok:"Ŧ",tstrok:"ŧ",twixt:"≬",twoheadleftarrow:"↞",twoheadrightarrow:"↠",Uacute:"Ú",uacute:"ú",Uarr:"↟",uArr:"⇑",uarr:"↑",Uarrocir:"⥉",Ubrcy:"Ў",ubrcy:"ў",Ubreve:"Ŭ",ubreve:"ŭ",Ucirc:"Û",ucirc:"û",Ucy:"У",ucy:"у",udarr:"⇅",Udblac:"Ű",udblac:"ű",udhar:"⥮",ufisht:"⥾",Ufr:"𝔘",ufr:"𝔲",Ugrave:"Ù",ugrave:"ù",uHar:"⥣",uharl:"↿",uharr:"↾",uhblk:"▀",ulcorn:"⌜",ulcorner:"⌜",ulcrop:"⌏",ultri:"◸",Umacr:"Ū",umacr:"ū",uml:"¨",UnderBar:"_",UnderBrace:"⏟",UnderBracket:"⎵",UnderParenthesis:"⏝",Union:"⋃",UnionPlus:"⊎",Uogon:"Ų",uogon:"ų",Uopf:"𝕌",uopf:"𝕦",UpArrow:"↑",Uparrow:"⇑",uparrow:"↑",UpArrowBar:"⤒",UpArrowDownArrow:"⇅",UpDownArrow:"↕",Updownarrow:"⇕",updownarrow:"↕",UpEquilibrium:"⥮",upharpoonleft:"↿",upharpoonright:"↾",uplus:"⊎",UpperLeftArrow:"↖",UpperRightArrow:"↗",Upsi:"ϒ",upsi:"υ",upsih:"ϒ",Upsilon:"Υ",upsilon:"υ",UpTee:"⊥",UpTeeArrow:"↥",upuparrows:"⇈",urcorn:"⌝",urcorner:"⌝",urcrop:"⌎",Uring:"Ů",uring:"ů",urtri:"◹",Uscr:"𝒰",uscr:"𝓊",utdot:"⋰",Utilde:"Ũ",utilde:"ũ",utri:"▵",utrif:"▴",uuarr:"⇈",Uuml:"Ü",uuml:"ü",uwangle:"⦧",vangrt:"⦜",varepsilon:"ϵ",varkappa:"ϰ",varnothing:"∅",varphi:"ϕ",varpi:"ϖ",varpropto:"∝",vArr:"⇕",varr:"↕",varrho:"ϱ",varsigma:"ς",varsubsetneq:"⊊︀",varsubsetneqq:"⫋︀",varsupsetneq:"⊋︀",varsupsetneqq:"⫌︀",vartheta:"ϑ",vartriangleleft:"⊲",vartriangleright:"⊳",Vbar:"⫫",vBar:"⫨",vBarv:"⫩",Vcy:"В",vcy:"в",VDash:"⊫",Vdash:"⊩",vDash:"⊨",vdash:"⊢",Vdashl:"⫦",Vee:"⋁",vee:"∨",veebar:"⊻",veeeq:"≚",vellip:"⋮",Verbar:"‖",verbar:"|",Vert:"‖",vert:"|",VerticalBar:"∣",VerticalLine:"|",VerticalSeparator:"❘",VerticalTilde:"≀",VeryThinSpace:" ",Vfr:"𝔙",vfr:"𝔳",vltri:"⊲",vnsub:"⊂⃒",vnsup:"⊃⃒",Vopf:"𝕍",vopf:"𝕧",vprop:"∝",vrtri:"⊳",Vscr:"𝒱",vscr:"𝓋",vsubnE:"⫋︀",vsubne:"⊊︀",vsupnE:"⫌︀",vsupne:"⊋︀",Vvdash:"⊪",vzigzag:"⦚",Wcirc:"Ŵ",wcirc:"ŵ",wedbar:"⩟",Wedge:"⋀",wedge:"∧",wedgeq:"≙",weierp:"℘",Wfr:"𝔚",wfr:"𝔴",Wopf:"𝕎",wopf:"𝕨",wp:"℘",wr:"≀",wreath:"≀",Wscr:"𝒲",wscr:"𝓌",xcap:"⋂",xcirc:"◯",xcup:"⋃",xdtri:"▽",Xfr:"𝔛",xfr:"𝔵",xhArr:"⟺",xharr:"⟷",Xi:"Ξ",xi:"ξ",xlArr:"⟸",xlarr:"⟵",xmap:"⟼",xnis:"⋻",xodot:"⨀",Xopf:"𝕏",xopf:"𝕩",xoplus:"⨁",xotime:"⨂",xrArr:"⟹",xrarr:"⟶",Xscr:"𝒳",xscr:"𝓍",xsqcup:"⨆",xuplus:"⨄",xutri:"△",xvee:"⋁",xwedge:"⋀",Yacute:"Ý",yacute:"ý",YAcy:"Я",yacy:"я",Ycirc:"Ŷ",ycirc:"ŷ",Ycy:"Ы",ycy:"ы",yen:"¥",Yfr:"𝔜",yfr:"𝔶",YIcy:"Ї",yicy:"ї",Yopf:"𝕐",yopf:"𝕪",Yscr:"𝒴",yscr:"𝓎",YUcy:"Ю",yucy:"ю",Yuml:"Ÿ",yuml:"ÿ",Zacute:"Ź",zacute:"ź",Zcaron:"Ž",zcaron:"ž",Zcy:"З",zcy:"з",Zdot:"Ż",zdot:"ż",zeetrf:"ℨ",ZeroWidthSpace:"​",Zeta:"Ζ",zeta:"ζ",Zfr:"ℨ",zfr:"𝔷",ZHcy:"Ж",zhcy:"ж",zigrarr:"⇝",Zopf:"ℤ",zopf:"𝕫",Zscr:"𝒵",zscr:"𝓏",zwj:"‍",zwnj:"‌"}),t.entityMap=t.HTML_ENTITIES},8978:(e,t,r)=>{var a=r(4722);t.DOMImplementation=a.DOMImplementation,t.XMLSerializer=a.XMLSerializer,t.DOMParser=r(5752).DOMParser},4466:(e,t,r)=>{var a=r(4582).NAMESPACE,n=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,o=new RegExp("[\\-\\.0-9"+n.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),i=new RegExp("^"+n.source+o.source+"*(?::"+n.source+o.source+"*)?$");function s(e,t){this.message=e,this.locator=t,Error.captureStackTrace&&Error.captureStackTrace(this,s)}function l(){}function c(e,t){return t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber,t}function u(e,t,r,n,o,i){function s(e,t,a){r.attributeNames.hasOwnProperty(e)&&i.fatalError("Attribute "+e+" redefined"),r.addValue(e,t.replace(/[\t\n\r]/g," ").replace(/&#?\w+;/g,o),a)}for(var l,c=++t,u=0;;){var h=e.charAt(c);switch(h){case"=":if(1===u)l=e.slice(t,c),u=3;else{if(2!==u)throw new Error("attribute equal must after attrName");u=3}break;case"'":case'"':if(3===u||1===u){if(1===u&&(i.warning('attribute value must after "="'),l=e.slice(t,c)),t=c+1,!((c=e.indexOf(h,t))>0))throw new Error("attribute value no end '"+h+"' match");s(l,d=e.slice(t,c),t-1),u=5}else{if(4!=u)throw new Error('attribute value must after "="');s(l,d=e.slice(t,c),t),i.warning('attribute "'+l+'" missed start quot('+h+")!!"),t=c+1,u=5}break;case"/":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:u=7,r.closed=!0;case 4:case 1:break;case 2:r.closed=!0;break;default:throw new Error("attribute invalid close char('/')")}break;case"":return i.error("unexpected end of input"),0==u&&r.setTagName(e.slice(t,c)),c;case">":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:break;case 4:case 1:"/"===(d=e.slice(t,c)).slice(-1)&&(r.closed=!0,d=d.slice(0,-1));case 2:2===u&&(d=l),4==u?(i.warning('attribute "'+d+'" missed quot(")!'),s(l,d,t)):(a.isHTML(n[""])&&d.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+d+'" missed value!! "'+d+'" instead!!'),s(d,d,t));break;case 3:throw new Error("attribute value missed!!")}return c;case"":h=" ";default:if(h<=" ")switch(u){case 0:r.setTagName(e.slice(t,c)),u=6;break;case 1:l=e.slice(t,c),u=2;break;case 4:var d=e.slice(t,c);i.warning('attribute "'+d+'" missed quot(")!!'),s(l,d,t);case 5:u=6}else switch(u){case 2:r.tagName,a.isHTML(n[""])&&l.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+l+'" missed value!! "'+l+'" instead2!!'),s(l,l,t),t=c,u=1;break;case 5:i.warning('attribute space is required"'+l+'"!!');case 6:u=1,t=c;break;case 3:u=4,t=c;break;case 7:throw new Error("elements closed character '/' and '>' must be connected to")}}c++}}function h(e,t,r){for(var n=e.tagName,o=null,i=e.length;i--;){var s=e[i],l=s.qName,c=s.value;if((m=l.indexOf(":"))>0)var u=s.prefix=l.slice(0,m),h=l.slice(m+1),d="xmlns"===u&&h;else h=l,u=null,d="xmlns"===l&&"";s.localName=h,!1!==d&&(null==o&&(o={},p(r,r={})),r[d]=o[d]=c,s.uri=a.XMLNS,t.startPrefixMapping(d,c))}for(i=e.length;i--;)(u=(s=e[i]).prefix)&&("xml"===u&&(s.uri=a.XML),"xmlns"!==u&&(s.uri=r[u||""]));var m;(m=n.indexOf(":"))>0?(u=e.prefix=n.slice(0,m),h=e.localName=n.slice(m+1)):(u=null,h=e.localName=n);var f=e.uri=r[u||""];if(t.startElement(f,h,n,e),!e.closed)return e.currentNSMap=r,e.localNSMap=o,!0;if(t.endElement(f,h,n),o)for(u in o)Object.prototype.hasOwnProperty.call(o,u)&&t.endPrefixMapping(u)}function d(e,t,r,a,n){if(/^(?:script|textarea)$/i.test(r)){var o=e.indexOf("</"+r+">",t),i=e.substring(t+1,o);if(/[&<]/.test(i))return/^script$/i.test(r)?(n.characters(i,0,i.length),o):(i=i.replace(/&#?\w+;/g,a),n.characters(i,0,i.length),o)}return t+1}function m(e,t,r,a){var n=a[r];return null==n&&((n=e.lastIndexOf("</"+r+">"))<t&&(n=e.lastIndexOf("</"+r)),a[r]=n),n<t}function p(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function f(e,t,r,a){if("-"===e.charAt(t+2))return"-"===e.charAt(t+3)?(n=e.indexOf("--\x3e",t+4))>t?(r.comment(e,t+4,n-t-4),n+3):(a.error("Unclosed comment"),-1):-1;if("CDATA["==e.substr(t+3,6)){var n=e.indexOf("]]>",t+9);return r.startCDATA(),r.characters(e,t+9,n-t-9),r.endCDATA(),n+3}var o=function(e,t){var r,a=[],n=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;for(n.lastIndex=t,n.exec(e);r=n.exec(e);)if(a.push(r),r[1])return a}(e,t),i=o.length;if(i>1&&/!doctype/i.test(o[0][0])){var s=o[1][0],l=!1,c=!1;i>3&&(/^public$/i.test(o[2][0])?(l=o[3][0],c=i>4&&o[4][0]):/^system$/i.test(o[2][0])&&(c=o[3][0]));var u=o[i-1];return r.startDTD(s,l,c),r.endDTD(),u.index+u[0].length}return-1}function x(e,t,r){var a=e.indexOf("?>",t);if(a){var n=e.substring(t,a).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);return n?(n[0].length,r.processingInstruction(n[1],n[2]),a+2):-1}return-1}function g(){this.attributeNames={}}s.prototype=new Error,s.prototype.name=s.name,l.prototype={parse:function(e,t,r){var n=this.domBuilder;n.startDocument(),p(t,t={}),function(e,t,r,n,o){function i(e){var t=e.slice(1,-1);return Object.hasOwnProperty.call(r,t)?r[t]:"#"===t.charAt(0)?function(e){if(e>65535){var t=55296+((e-=65536)>>10),r=56320+(1023&e);return String.fromCharCode(t,r)}return String.fromCharCode(e)}(parseInt(t.substr(1).replace("x","0x"))):(o.error("entity not found:"+e),e)}function l(t){if(t>_){var r=e.substring(_,t).replace(/&#?\w+;/g,i);C&&p(_),n.characters(r,0,t-_),_=t}}function p(t,r){for(;t>=b&&(r=v.exec(e));)w=r.index,b=w+r[0].length,C.lineNumber++;C.columnNumber=t-w+1}for(var w=0,b=0,v=/.*(?:\r\n?|\n)|.*$/g,C=n.locator,A=[{currentNSMap:t}],E={},_=0;;){try{var y=e.indexOf("<",_);if(y<0){if(!e.substr(_).match(/^\s*$/)){var q=n.doc,D=q.createTextNode(e.substr(_));q.appendChild(D),n.currentElement=D}return}switch(y>_&&l(y),e.charAt(y+1)){case"/":var M=e.indexOf(">",y+3),T=e.substring(y+2,M).replace(/[ \t\n\r]+$/g,""),N=A.pop();M<0?(T=e.substring(y+2).replace(/[\s<].*/,""),o.error("end tag name: "+T+" is not complete:"+N.tagName),M=y+1+T.length):T.match(/\s</)&&(T=T.replace(/[\s<].*/,""),o.error("end tag name: "+T+" maybe not complete"),M=y+1+T.length);var O=N.localNSMap,L=N.tagName==T;if(L||N.tagName&&N.tagName.toLowerCase()==T.toLowerCase()){if(n.endElement(N.uri,N.localName,T),O)for(var B in O)Object.prototype.hasOwnProperty.call(O,B)&&n.endPrefixMapping(B);L||o.fatalError("end tag name: "+T+" is not match the current start tagName:"+N.tagName)}else A.push(N);M++;break;case"?":C&&p(y),M=x(e,y,n);break;case"!":C&&p(y),M=f(e,y,n,o);break;default:C&&p(y);var S=new g,F=A[A.length-1].currentNSMap,P=(M=u(e,y,S,F,i,o),S.length);if(!S.closed&&m(e,M,S.tagName,E)&&(S.closed=!0,r.nbsp||o.warning("unclosed xml attribute")),C&&P){for(var k=c(C,{}),R=0;R<P;R++){var I=S[R];p(I.offset),I.locator=c(C,{})}n.locator=k,h(S,n,F)&&A.push(S),n.locator=C}else h(S,n,F)&&A.push(S);a.isHTML(S.uri)&&!S.closed?M=d(e,M,S.tagName,i,n):M++}}catch(e){if(e instanceof s)throw e;o.error("element parse error: "+e),M=-1}M>_?_=M:l(Math.max(y,_)+1)}}(e,t,r,n,this.errorHandler),n.endDocument()}},g.prototype={setTagName:function(e){if(!i.test(e))throw new Error("invalid tagName:"+e);this.tagName=e},addValue:function(e,t,r){if(!i.test(e))throw new Error("invalid attribute:"+e);this.attributeNames[e]=this.length,this[this.length++]={qName:e,value:t,offset:r}},length:0,getLocalName:function(e){return this[e].localName},getLocator:function(e){return this[e].locator},getQName:function(e){return this[e].qName},getURI:function(e){return this[e].uri},getValue:function(e){return this[e].value}},t.XMLReader=l,t.ParseError=s},8917:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;var a=r(6200);Object.defineProperty(t,"InvalidNumberOfChildrenError",{enumerable:!0,get:function(){return a.InvalidNumberOfChildrenError}})},6200:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;class r extends Error{constructor(e,t,r,a="exactly"){super(`${e} tag must have ${a} ${t} children. It's actually ${r}`),this.name="InvalidNumberOfChildrenError"}}t.InvalidNumberOfChildrenError=r},4279:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(828),t),n(r(5975),t),n(r(799),t),n(r(2424),t)},5975:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JoinWithManySeparators=void 0;class r{constructor(e){this._separators=e}static join(e,t){return new r(t)._join(e)}_join(e){return e.reduce(((e,t,r,a)=>e+t+(r===a.length-1?"":this._get(r))),"")}_get(e){return this._separators[e]?this._separators[e]:this._separators.length>0?this._separators[this._separators.length-1]:","}}t.JoinWithManySeparators=r},799:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathMLElementToLaTeXConverter=void 0;const a=r(5443);t.mathMLElementToLaTeXConverter=e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter()},2424:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.normalizeWhiteSpaces=void 0,t.normalizeWhiteSpaces=e=>e.replace(/\s+/g," ")},7192:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BracketWrapper=void 0;const a=r(1855);t.BracketWrapper=class{constructor(){this._open="{",this._close="}"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},5025:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=void 0;const a=r(1855);t.GenericWrapper=class{constructor(e,t){this._open="\\left"+e,this._close="\\right"+t}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},828:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=t.ParenthesisWrapper=t.BracketWrapper=void 0;var a=r(7192);Object.defineProperty(t,"BracketWrapper",{enumerable:!0,get:function(){return a.BracketWrapper}});var n=r(1168);Object.defineProperty(t,"ParenthesisWrapper",{enumerable:!0,get:function(){return n.ParenthesisWrapper}});var o=r(5025);Object.defineProperty(t,"GenericWrapper",{enumerable:!0,get:function(){return o.GenericWrapper}})},1168:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ParenthesisWrapper=void 0;const a=r(1855);t.ParenthesisWrapper=class{constructor(){this._open="\\left(",this._close="\\right)"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}wrapIfMoreThanOneChar(e){return e.length<=1?e:this.wrap(e)}}},1855:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Wrapper=void 0,t.Wrapper=class{constructor(e,t){this._open=e,this._close=t}wrap(e){return this._open+e+this._close}}},2697:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VoidMathMLElement=void 0,t.VoidMathMLElement=class{constructor(){this.name="void",this.value="",this.children=[],this.attributes={}}}},4760:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericSpacingWrapper=void 0;const a=r(4279);t.GenericSpacingWrapper=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}},9376:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericUnderOver=void 0;const a=r(799),n=r(8917),o=r(472);t.GenericUnderOver=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert(),i=(0,a.mathMLElementToLaTeXConverter)(t[1]).convert();return this._applyCommand(o,i)}_applyCommand(e,t){const r=this._mathmlElement.name.match(/under/)?s.Under:s.Over;return new i(r).apply(e,t)}};class i{constructor(e){this._type=e}apply(e,t){return o.latexAccents.includes(t)?`${t}{${e}}`:`${this._defaultCommand}{${t}}{${e}}`}get _defaultCommand(){return this._type===s.Under?"\\underset":"\\overset"}}var s;!function(e){e[e.Under=0]="Under",e[e.Over=1]="Over"}(s||(s={}))},6959:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=t.GenericUnderOver=t.GenericSpacingWrapper=t.MTr=t.MTable=t.MUnderover=t.MText=t.MMultiscripts=t.MSubsup=t.MSub=t.MSup=t.MPhantom=t.MError=t.MEnclose=t.MAction=t.MRoot=t.MFrac=t.MFenced=t.MSqrt=t.MN=t.MO=t.MI=t.Math=void 0;var a=r(393);Object.defineProperty(t,"Math",{enumerable:!0,get:function(){return a.Math}});var n=r(7037);Object.defineProperty(t,"MI",{enumerable:!0,get:function(){return n.MI}});var o=r(3487);Object.defineProperty(t,"MO",{enumerable:!0,get:function(){return o.MO}});var i=r(4464);Object.defineProperty(t,"MN",{enumerable:!0,get:function(){return i.MN}});var s=r(8686);Object.defineProperty(t,"MSqrt",{enumerable:!0,get:function(){return s.MSqrt}});var l=r(9511);Object.defineProperty(t,"MFenced",{enumerable:!0,get:function(){return l.MFenced}});var c=r(6440);Object.defineProperty(t,"MFrac",{enumerable:!0,get:function(){return c.MFrac}});var u=r(6052);Object.defineProperty(t,"MRoot",{enumerable:!0,get:function(){return u.MRoot}});var h=r(1678);Object.defineProperty(t,"MAction",{enumerable:!0,get:function(){return h.MAction}});var d=r(2631);Object.defineProperty(t,"MEnclose",{enumerable:!0,get:function(){return d.MEnclose}});var m=r(1840);Object.defineProperty(t,"MError",{enumerable:!0,get:function(){return m.MError}});var p=r(7443);Object.defineProperty(t,"MPhantom",{enumerable:!0,get:function(){return p.MPhantom}});var f=r(6926);Object.defineProperty(t,"MSup",{enumerable:!0,get:function(){return f.MSup}});var x=r(2564);Object.defineProperty(t,"MSub",{enumerable:!0,get:function(){return x.MSub}});var g=r(1358);Object.defineProperty(t,"MSubsup",{enumerable:!0,get:function(){return g.MSubsup}});var w=r(8303);Object.defineProperty(t,"MMultiscripts",{enumerable:!0,get:function(){return w.MMultiscripts}});var b=r(3951);Object.defineProperty(t,"MText",{enumerable:!0,get:function(){return b.MText}});var v=r(1222);Object.defineProperty(t,"MUnderover",{enumerable:!0,get:function(){return v.MUnderover}});var C=r(2350);Object.defineProperty(t,"MTable",{enumerable:!0,get:function(){return C.MTable}});var A=r(1586);Object.defineProperty(t,"MTr",{enumerable:!0,get:function(){return A.MTr}});var E=r(4760);Object.defineProperty(t,"GenericSpacingWrapper",{enumerable:!0,get:function(){return E.GenericSpacingWrapper}});var _=r(9376);Object.defineProperty(t,"GenericUnderOver",{enumerable:!0,get:function(){return _.GenericUnderOver}});var y=r(9165);Object.defineProperty(t,"Void",{enumerable:!0,get:function(){return y.Void}})},1678:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAction=void 0;const a=r(799);t.MAction=class{constructor(e){this._mathmlElement=e}convert(){const{children:e}=this._mathmlElement;return this._isToggle()?e.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\Longrightarrow "):(0,a.mathMLElementToLaTeXConverter)(e[0]).convert()}_isToggle(){const{actiontype:e}=this._mathmlElement.attributes;return"toggle"===e||!e}}},393:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Math=void 0;const a=r(799),n=r(2424);t.Math=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return(0,n.normalizeWhiteSpaces)(e)}}},2631:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MEnclose=void 0;const a=r(799);t.MEnclose=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return"actuarial"===this._notation?`\\overline{\\left.${e}\\right|}`:"radical"===this._notation?`\\sqrt{${e}}`:["box","roundedbox","circle"].includes(this._notation)?`\\boxed{${e}}`:"left"===this._notation?`\\left|${e}`:"right"===this._notation?`${e}\\right|`:"top"===this._notation?`\\overline{${e}}`:"bottom"===this._notation?`\\underline{${e}}`:"updiagonalstrike"===this._notation?`\\cancel{${e}}`:"downdiagonalstrike"===this._notation?`\\bcancel{${e}}`:"updiagonalarrow"===this._notation?`\\cancelto{}{${e}}`:["verticalstrike","horizontalstrike"].includes(this._notation)?`\\hcancel{${e}}`:"madruwb"===this._notation?`\\underline{${e}\\right|}`:"phasorangle"===this._notation?`{\\angle \\underline{${e}}}`:`\\overline{\\left.\\right)${e}}`}get _notation(){return this._mathmlElement.attributes.notation||"longdiv"}}},1840:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MError=void 0;const a=r(799);t.MError=class{constructor(e){this._mathmlElement=e}convert(){return`\\color{red}{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},9511:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFenced=void 0;const a=r(799),n=r(4279);t.MFenced=class{constructor(e){this._mathmlElement=e,this._open=this._mathmlElement.attributes.open||"",this._close=this._mathmlElement.attributes.close||"",this._separators=Array.from(this._mathmlElement.attributes.separators||"")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert()));return this._isThereRelativeOfName(this._mathmlElement.children,"mtable")?new i(this._open,this._close).apply(e):new o(this._open,this._close,this._separators).apply(e)}_isThereRelativeOfName(e,t){return e.some((e=>e.name===t||this._isThereRelativeOfName(e.children,t)))}};class o{constructor(e,t,r){this._open=e||"(",this._close=t||")",this._separators=r}apply(e){const t=n.JoinWithManySeparators.join(e,this._separators);return new n.GenericWrapper(this._open,this._close).wrap(t)}}class i{constructor(e,t){this._genericCommand="matrix",this._separators=new s(e,t)}apply(e){const t=this._command,r=`\\begin{${t}}\n${e.join("")}\n\\end{${t}}`;return t===this._genericCommand?this._separators.wrap(r):r}get _command(){return this._separators.areParentheses()?"pmatrix":this._separators.areSquareBrackets()?"bmatrix":this._separators.areBrackets()?"Bmatrix":this._separators.areDivides()?"vmatrix":this._separators.areParallels()?"Vmatrix":this._separators.areNotEqual()?this._genericCommand:"bmatrix"}}class s{constructor(e,t){this._open=e,this._close=t}wrap(e){return new n.GenericWrapper(this._open,this._close).wrap(e)}areParentheses(){return this._compare("(",")")}areSquareBrackets(){return this._compare("[","]")}areBrackets(){return this._compare("{","}")}areDivides(){return this._compare("|","|")}areParallels(){return this._compare("||","||")}areNotEqual(){return this._open!==this._close}_compare(e,t){return this._open===e&&this._close===t}}},6440:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFrac=void 0;const a=r(8917),n=r(4279);t.MFrac=class{constructor(e){this._mathmlElement=e}convert(){const{children:e,name:t}=this._mathmlElement,r=e.length;if(2!==r)throw new a.InvalidNumberOfChildrenError(t,2,r);const o=(0,n.mathMLElementToLaTeXConverter)(e[0]).convert(),i=(0,n.mathMLElementToLaTeXConverter)(e[1]).convert();return this._isBevelled()?`${this._wrapIfMoreThanOneChar(o)}/${this._wrapIfMoreThanOneChar(i)}`:`\\frac{${o}}{${i}}`}_wrapIfMoreThanOneChar(e){return(new n.ParenthesisWrapper).wrapIfMoreThanOneChar(e)}_isBevelled(){return!!this._mathmlElement.attributes.bevelled}}},7037:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MI=void 0;const a=r(4279),n=r(5406),o=r(6122);t.MI=class{constructor(e){this.utf8Converter=new o.HashUTF8ToLtXConverter,this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value);if(" "===e)return i.apply(e);const t=e.trim(),r=i.apply(t),n=this.utf8Converter.convert(r);return n!==r?n:this.wrapInMathVariant(r,this.getMathVariant(this._mathmlElement.attributes))}getMathVariant(e){if(e&&e.mathvariant)return e.mathvariant}wrapInMathVariant(e,t){switch(t){case"bold":return`\\mathbf{${e}}`;case"italic":return`\\mathit{${e}}`;case"bold-italic":return`\\mathbf{\\mathit{${e}}}`;case"double-struck":return`\\mathbb{${e}}`;case"bold-fraktur":return`\\mathbf{\\mathfrak{${e}}}`;case"script":return`\\mathcal{${e}}`;case"bold-script":return`\\mathbf{\\mathcal{${e}}}`;case"fraktur":return`\\mathfrak{${e}}`;case"sans-serif":return`\\mathsf{${e}}`;case"bold-sans-serif":return`\\mathbf{\\mathsf{${e}}}`;case"sans-serif-italic":return`\\mathsf{\\mathit{${e}}}`;case"sans-serif-bold-italic":return`\\mathbf{\\mathsf{\\mathit{${e}}}}`;case"monospace":return`\\mathtt{${e}}`;default:return e}}};class i{constructor(e){this._value=e}static apply(e){return new i(e)._apply()}_apply(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new o.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathSymbolsByChar[this._value]}_findByGlyph(){return n.allMathSymbolsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},8303:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MMultiscripts=void 0;const a=r(4279),n=r(8917);t.MMultiscripts=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(r<3)throw new n.InvalidNumberOfChildrenError(e,3,r,"at least");const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return this._prescriptLatex()+this._wrapInParenthesisIfThereIsSpace(o)+this._postscriptLatex()}_prescriptLatex(){const{children:e}=this._mathmlElement;let t,r;if(this._isPrescripts(e[1]))t=e[2],r=e[3];else{if(!this._isPrescripts(e[3]))return"";t=e[4],r=e[5]}return`\\_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_postscriptLatex(){const{children:e}=this._mathmlElement;if(this._isPrescripts(e[1]))return"";const t=e[1],r=e[2];return`_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_wrapInParenthesisIfThereIsSpace(e){return e.match(/\s+/g)?(new a.ParenthesisWrapper).wrap(e):e}_isPrescripts(e){return"mprescripts"===(null==e?void 0:e.name)}}},4464:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MN=void 0;const a=r(4279),n=r(5406);t.MN=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return n.mathNumberByGlyph[e]||e}}},3487:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MO=void 0;const a=r(4279),n=r(5406);t.MO=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return o.operate(e)}};class o{constructor(e){this._value=e}static operate(e){return new o(e)._operate()}_operate(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new n.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathOperatorsByChar[this._value]}_findByGlyph(){return n.allMathOperatorsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},7443:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MPhantom=void 0,t.MPhantom=class{constructor(e){this._mathmlElement=e}convert(){return""}}},6052:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MRoot=void 0;const a=r(4279),n=r(8917);t.MRoot=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return`\\sqrt[${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}]{${o}}`}}},8686:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSqrt=void 0;const a=r(4279);t.MSqrt=class{constructor(e){this._mathmlElement=e}convert(){return`\\sqrt{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},2564:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSub=void 0;const a=r(4279),n=r(8917);t.MSub=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},1358:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSubsup=void 0;const a=r(4279),n=r(8917);t.MSubsup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);const a=t[0],o=t[1],i=t[2];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}^${this._handleSuperscriptChild(i)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}_handleSuperscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},6926:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSup=void 0;const a=r(4279),n=r(8917);t.MSup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}^${this._handleExponentChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleExponentChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},2350:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTable=void 0;const a=r(4279);t.MTable=class{constructor(e){this._mathmlElement=e,this._addFlagRecursiveIfName(this._mathmlElement.children,"mtable","innerTable")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\\\\n");return this._hasFlag("innerTable")?this._wrap(e):e}_wrap(e){return`\\begin{matrix}${e}\\end{matrix}`}_addFlagRecursiveIfName(e,t,r){e.forEach((e=>{e.name===t&&(e.attributes[r]=r),this._addFlagRecursiveIfName(e.children,t,r)}))}_hasFlag(e){return!!this._mathmlElement.attributes[e]}}},3951:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MText=void 0;const a=r(7037);t.MText=class{constructor(e){this._mathmlElement=e}convert(){const{attributes:e,value:t}=this._mathmlElement;return[...t].map((e=>/^[a-zA-Z0-9]$/.test(e)||" "===e?{value:e,isAlphanumeric:!0}:{value:e,isAlphanumeric:!1})).reduce(((e,t)=>{if(t.isAlphanumeric){const r=e[e.length-1];if(r&&r.isAlphanumeric)return r.value+=t.value,e}return[...e,t]}),[]).map((t=>t.isAlphanumeric?new n(e.mathvariant).apply(t.value):new a.MI({name:"mi",attributes:{},children:[],value:t.value}).convert())).join("")}};class n{constructor(e){this._mathvariant=e||"normal"}apply(e){return this._commands.reduce(((t,r,a)=>0===a?`${r}{${e}}`:`${r}{${t}}`),"")}get _commands(){switch(this._mathvariant){case"bold":return["\\textbf"];case"italic":return["\\textit"];case"bold-italic":return["\\textit","\\textbf"];case"double-struck":return["\\mathbb"];case"monospace":return["\\mathtt"];case"bold-fraktur":case"fraktur":return["\\mathfrak"];default:return["\\text"]}}}},1586:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTr=void 0;const a=r(4279);t.MTr=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" & ")}}},1222:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MUnderover=void 0;const a=r(4279),n=r(8917);t.MUnderover=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);return`${(0,a.mathMLElementToLaTeXConverter)(t[0]).convert()}_{${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(t[2]).convert()}}`}}},9165:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=void 0,t.Void=class{constructor(e){this._mathmlElement=e}convert(){return""}}},5443:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return n(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLElementToLatexConverterAdapter=void 0;const i=o(r(6959)),s=r(2697);t.MathMLElementToLatexConverterAdapter=class{constructor(e){this._mathMLElement=null!=e?e:new s.VoidMathMLElement}toLatexConverter(){const{name:e}=this._mathMLElement;return new(l[e]||i.GenericSpacingWrapper)(this._mathMLElement)}};const l={math:i.Math,mi:i.MI,mo:i.MO,mn:i.MN,msqrt:i.MSqrt,mfenced:i.MFenced,mfrac:i.MFrac,mroot:i.MRoot,maction:i.MAction,menclose:i.MEnclose,merror:i.MError,mphantom:i.MPhantom,msup:i.MSup,msub:i.MSub,msubsup:i.MSubsup,mmultiscripts:i.MMultiscripts,mtext:i.MText,munderover:i.MUnderover,mtable:i.MTable,mtr:i.MTr,mover:i.GenericUnderOver,munder:i.GenericUnderOver,mrow:i.GenericSpacingWrapper,mpadded:i.GenericSpacingWrapper,void:i.Void}},5243:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorHandler=void 0,t.ErrorHandler=class{constructor(){this._errors=[],this.errorLocator={}}fixError(e,t){return this._isMissingAttributeValueError(t)?(this._errors.push(t),this._fixMissingAttribute(t,e)):e}isThereAnyErrors(){return this._errors.length>0}cleanErrors(){this._errors=[]}_fixMissingAttribute(e,t){const r=e.split('"')[1];if(r)return t.replace(this._matchMissingValueForAttribute(r),"");for(;this._mathGenericMissingValue().exec(t);)t=t.replace(this._mathGenericMissingValue(),"$1$3");return t}_matchMissingValueForAttribute(e){return new RegExp(`(${e}=(?!("|')))|(${e}(?!("|')))`,"gm")}_mathGenericMissingValue(){return/(\<.* )(\w+=(?!\"|\'))(.*\>)/gm}_isMissingAttributeValueError(e){return!!e.includes("attribute")&&!!e.includes("missed")||e.includes("attribute value missed")}}},9208:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(9548),t),n(r(5243),t),n(r(1101),t)},1101:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ElementsToMathMLAdapter=void 0,t.ElementsToMathMLAdapter=class{convert(e){return e.filter((e=>void 0!==e.tagName)).map((e=>this._convertElement(e)))}_convertElement(e){return{name:e.tagName,attributes:this._convertElementAttributes(e.attributes),value:this._hasElementChild(e)?"":e.textContent||"",children:this._hasElementChild(e)?this.convert(Array.from(e.childNodes)):[]}}_convertElementAttributes(e){return Array.from(e).reduce(((e,t)=>Object.assign({[t.nodeName]:t.nodeValue===t.nodeName?"":t.nodeValue},e)),{})}_hasElementChild(e){const t=e.childNodes;return!!t&&0!==t.length&&this._isThereAnyNoTextNode(t)}_isThereAnyNoTextNode(e){return Array.from(e).some((e=>"#text"!==e.nodeName))}}},9548:function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.XmlToMathMLAdapter=void 0;const n=a(r(8978));t.XmlToMathMLAdapter=class{constructor(e,t){this._xml="",this._elementsConvertor=e,this._errorHandler=t,this._xmlDOM=new n.default.DOMParser({locator:this._errorHandler.errorLocator,errorHandler:this._fixError.bind(this)})}convert(e){return this._xml=this._removeLineBreaks(e),this._xml=this._removeMsWordPrefixes(this._xml),this._elementsConvertor.convert(this._mathMLElements)}_fixError(e){this._xml=this._errorHandler.fixError(this._xml,e)}_removeLineBreaks(e){return e.replace(/\n|\r\n|\r/g,"")}_removeMsWordPrefixes(e){return e.replace(/mml:/g,"")}get _mathMLElements(){let e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math");return this._errorHandler.isThereAnyErrors()&&(this._errorHandler.cleanErrors(),e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math")),Array.from(e)}}},7941:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(8585),t)},8585:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeToMathElementsConverter=void 0;const a=r(9208);t.makeToMathElementsConverter=()=>{const e=new a.ElementsToMathMLAdapter,t=new a.ErrorHandler;return new a.XmlToMathMLAdapter(e,t)}},8672:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(3798),t)},3798:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLToLaTeX=void 0;const a=r(5443),n=r(7941);t.MathMLToLaTeX=class{static convert(e){return(0,n.makeToMathElementsConverter)().convert(e).map((e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter())).map((e=>e.convert())).join("").trim()}}},2965:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByChar=void 0,t.allMathOperatorsByChar={_:"\\underline","&#x23E1;":"\\underbrace","&#x23E0;":"\\overbrace","&#x23DF;":"\\underbrace","&#x23DE;":"\\overbrace","&#x23DD;":"\\underbrace","&#x23DC;":"\\overbrace","&#x23B5;":"\\underbrace","&#x23B4;":"\\overbrace","&#x20DC;":"\\square","&#x20DB;":"\\square","&#x2064;":"","&#x2057;":"''''","&#x203E;":"\\bar","&#x2037;":"```","&#x2036;":"``","&#x2035;":"`","&#x2034;":"'''","&#x2033;":"''","&#x201F;":"``","&#x201E;":",,","&#x201B;":"`","&#x201A;":",","&#x302;":"\\hat","&#x2F7;":"\\sim","&#x2DD;":"\\sim","&#x2DC;":"\\sim","&#x2DA;":"\\circ","&#x2D9;":"\\cdot","&#x2D8;":"","&#x2CD;":"\\_","&#x2CB;":"ˋ","&#x2CA;":"ˊ","&#x2C9;":"ˉ","&#x2C7;":"","&#x2C6;":"\\hat","&#xBA;":"o","&#xB9;":"1","&#xB8;":"¸","&#xB4;":"´","&#xB3;":"3","&#xB2;":"2","&#xB0;":"\\circ","&#xAF;":"\\bar","&#xAA;":"a","&#xA8;":"\\cdot\\cdot","~":"\\sim","`":"`","^":"\\hat","--":"--","++":"++","&amp;":"\\&","&#x2061;":"","&#x221C;":"\\sqrt[4]{}","&#x221B;":"\\sqrt[3]{}","&#x221A;":"\\sqrt{}","&#x2146;":"d","&#x2145;":"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","&#x266F;":"\\#","&#x266E;":"","&#x266D;":"","&#x2032;":"'","&lt;>":"<>","**":"\\star\\star","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x2299;":"\\bigodot","&#xAC;":"\\neg","&#x2222;":"\\measuredangle","&#x2221;":"\\measuredangle","&#x2220;":"\\angle","&#xF7;":"\\div","/":"/","&#x2216;":"\\backslash","\\":"\\backslash","%":"\\%","&#x2297;":"\\bigotimes","&#xB7;":"\\cdot","&#x2A3F;":"\\coprod","&#x2A2F;":"\\times","&#x22C5;":"\\cdot","&#x22A1;":"\\boxdot","&#x22A0;":"\\boxtimes","&#x2062;":"","&#x2043;":"-","&#x2022;":"\\cdot","&#xD7;":"\\times",".":".","*":"\\star","&#x222A;":"\\cup","&#x2229;":"\\cap","&#x2210;":"\\coprod","&#x220F;":"\\prod","&#x2240;":"","&#x2AFF;":"","&#x2AFC;":"\\mid\\mid\\mid","&#x2A09;":"\\times","&#x2A08;":"","&#x2A07;":"","&#x2A06;":"\\sqcup","&#x2A05;":"\\sqcap","&#x2A02;":"\\otimes","&#x2A00;":"\\odot","&#x22C2;":"\\cap","&#x22C1;":"\\vee","&#x22C0;":"\\wedge","&#x2A04;":"\\uplus","&#x2A03;":"\\cup","&#x22C3;":"\\cup","&#x2A1C;":"\\underline{\\int}","&#x2A1B;":"\\overline{\\int}","&#x2A1A;":"\\int","&#x2A19;":"\\int","&#x2A18;":"\\int","&#x2A17;":"\\int","&#x2A16;":"\\oint","&#x2A15;":"\\oint","&#x2A14;":"\\int","&#x2A13;":"\\int","&#x2A12;":"\\int","&#x2A11;":"\\int","&#x2A10;":"\\int","&#x2A0F;":"\\bcancel{\\int}","&#x2A0E;":"","&#x2A0D;":"\\hcancel{\\int}","&#x2A0C;":"\\iiiint","&#x2233;":"\\oint","&#x2232;":"\\oint","&#x2231;":"\\int","&#x2230;":"\\oiint","&#x222F;":"\\oiint","&#x222E;":"\\oint","&#x222B;":"\\int","&#x2A01;":"\\oplus","&#x2298;":"\\oslash","&#x2296;":"\\ominus","&#x2295;":"\\oplus","&#x222D;":"\\iiint","&#x222C;":"\\iint","&#x2A0B;":"","&#x2A0A;":"","&#x2211;":"\\sum","&#x229F;":"\\boxminus","&#x229E;":"\\boxplus","&#x2214;":"\\dot{+}","&#x2213;":"+-","&#x2212;":"-","&#xB1;":"\\pm","-":"-","+":"+","&#x2B46;":"\\Rrightarrow","&#x2B45;":"\\Lleftarrow","&#x29F4;":":\\rightarrow","&#x29EF;":"","&#x29DF;":"\\bullet-\\bullet","&#x299F;":"\\angle","&#x299E;":"\\measuredangle","&#x299D;":"\\measuredangle","&#x299C;":"\\perp","&#x299B;":"\\measuredangle","&#x299A;":"","&#x2999;":"\\vdots","&#x297F;":"","&#x297E;":"","&#x297D;":"\\prec","&#x297C;":"\\succ","&#x297B;":"\\underset{\\rightarrow}{\\supset}","&#x297A;":"","&#x2979;":"\\underset{\\rightarrow}{\\subset}","&#x2978;":"\\underset{\\rightarrow}{>}","&#x2977;":"","&#x2976;":"\\underset{\\leftarrow}{<}","&#x2975;":"\\underset{\\approx}{\\rightarrow}","&#x2974;":"\\underset{\\sim}{\\rightarrow}","&#x2973;":"\\underset{\\sim}{\\leftarrow}","&#x2972;":"\\overset{\\sim}{\\rightarrow}","&#x2971;":"\\overset{=}{\\rightarrow}","&#x2970;":"","&#x296F;":"","&#x296E;":"","&#x296D;":"\\overline{\\rightharpoondown}","&#x296C;":"\\underline{\\rightharpoonup}","&#x296B;":"\\overline{\\leftharpoondown}","&#x296A;":"\\underline{\\leftharpoonup}","&#x2969;":"\\rightleftharpoons","&#x2968;":"\\rightleftharpoons","&#x2967;":"\\rightleftharpoons","&#x2966;":"\\rightleftharpoons","&#x2965;":"\\Downarrow","&#x2964;":"\\Rightarrow","&#x2963;":"\\Uparrow","&#x2962;":"\\Leftarrow","&#x2961;":"\\downarrow","&#x2960;":"\\uparrow","&#x295F;":"\\rightarrow","&#x295E;":"\\leftarrow","&#x295D;":"\\downarrow","&#x295C;":"\\uparrow","&#x295B;":"\\rightarrow","&#x295A;":"\\leftarrow","&#x2959;":"\\downarrow","&#x2958;":"\\uparrow","&#x2957;":"\\rightarrow","&#x2956;":"\\leftarrow","&#x2955;":"\\downarrow","&#x2954;":"\\uparrow","&#x2953;":"\\rightarrow","&#x2952;":"\\leftarrow","&#x2951;":"\\updownarrow","&#x2950;":"\\leftrightarrow","&#x294F;":"\\updownarrow","&#x294E;":"\\leftrightarrow","&#x294D;":"\\updownarrow","&#x294C;":"\\updownarrow","&#x294B;":"\\leftrightarrow","&#x294A;":"\\leftrightarrow","&#x2949;":"","&#x2948;":"\\leftrightarrow","&#x2947;":"\\nrightarrow","&#x2946;":"","&#x2945;":"","&#x2944;":"\\rightleftarrows","&#x2943;":"\\leftrightarrows","&#x2942;":"\\rightleftarrows","&#x2941;":"\\circlearrowright","&#x2940;":"\\circlearrowleft","&#x293F;":"\\rightarrow","&#x293E;":"\\leftarrow","&#x293D;":"","&#x293C;":"","&#x293B;":"","&#x293A;":"","&#x2939;":"","&#x2938;":"","&#x2937;":"\\Rsh","&#x2936;":"\\Lsh","&#x2935;":"\\downarrow","&#x2934;":"\\uparrow","&#x2933;":"\\leadsto","&#x2932;":"","&#x2931;":"","&#x2930;":"","&#x292F;":"","&#x292E;":"","&#x292D;":"","&#x292C;":"\\times","&#x292B;":"\\times","&#x292A;":"","&#x2929;":"","&#x2928;":"","&#x2927;":"","&#x2926;":"","&#x2925;":"","&#x2924;":"","&#x2923;":"","&#x2922;":"","&#x2921;":"","&#x2920;":"\\mapsto\\cdot","&#x291F;":"\\cdot\\leftarrow","&#x291E;":"\\rightarrow\\cdot","&#x291D;":"\\leftarrow","&#x291C;":"\\rightarrow","&#x291B;":"\\leftarrow","&#x291A;":"\\rightarrow","&#x2919;":"\\leftarrow","&#x2918;":"\\rightarrow","&#x2917;":"\\rightarrow","&#x2916;":"\\rightarrow","&#x2915;":"\\rightarrow","&#x2914;":"\\rightarrow","&#x2913;":"\\downarrow","&#x2912;":"\\uparrow","&#x2911;":"\\rightarrow","&#x2910;":"\\rightarrow","&#x290F;":"\\rightarrow","&#x290E;":"\\leftarrow","&#x290D;":"\\rightarrow","&#x290C;":"\\leftarrow","&#x290B;":"\\Downarrow","&#x290A;":"\\Uparrow","&#x2909;":"\\uparrow","&#x2908;":"\\downarrow","&#x2907;":"\\Rightarrow","&#x2906;":"\\Leftarrow","&#x2905;":"\\mapsto","&#x2904;":"\\nLeftrightarrow","&#x2903;":"\\nRightarrow","&#x2902;":"\\nLeftarrow","&#x2901;":"\\rightsquigarrow","&#x2900;":"\\rightsquigarrow","&#x27FF;":"\\rightsquigarrow","&#x27FE;":"\\Rightarrow","&#x27FD;":"\\Leftarrow","&#x27FC;":"\\mapsto","&#x27FB;":"\\leftarrow","&#x27FA;":"\\Longleftrightarrow","&#x27F9;":"\\Longrightarrow","&#x27F8;":"\\Longleftarrow","&#x27F7;":"\\leftrightarrow","&#x27F6;":"\\rightarrow","&#x27F5;":"\\leftarrow","&#x27F1;":"\\Downarrow","&#x27F0;":"\\Uparrow","&#x22B8;":"\\rightarrow","&#x21FF;":"\\leftrightarrow","&#x21FE;":"\\rightarrow","&#x21FD;":"\\leftarrow","&#x21FC;":"\\nleftrightarrow","&#x21FB;":"\\nrightarrow","&#x21FA;":"\\nleftarrow","&#x21F9;":"\\nleftrightarrow","&#x21F8;":"\\nrightarrow","&#x21F7;":"\\nleftarrow","&#x21F6;":"\\Rrightarrow","&#x21F5;":"","&#x21F4;":"\\rightarrow","&#x21F3;":"\\Updownarrow","&#x21F2;":"\\searrow","&#x21F1;":"\\nwarrow","&#x21F0;":"\\Leftarrow","&#x21EF;":"\\Uparrow","&#x21EE;":"\\Uparrow","&#x21ED;":"\\Uparrow","&#x21EC;":"\\Uparrow","&#x21EB;":"\\Uparrow","&#x21EA;":"\\Uparrow","&#x21E9;":"\\Downarrow","&#x21E8;":"\\Rightarrow","&#x21E7;":"\\Uparrow","&#x21E6;":"\\Leftarrow","&#x21E5;":"\\rightarrow","&#x21E4;":"\\leftarrow","&#x21E3;":"\\downarrow","&#x21E2;":"\\rightarrow","&#x21E1;":"\\uparrow","&#x21E0;":"\\leftarrow","&#x21DF;":"\\downarrow","&#x21DE;":"\\uparrow","&#x21DD;":"\\rightsquigarrow","&#x21DC;":"\\leftarrow","&#x21DB;":"\\Rrightarrow","&#x21DA;":"\\Lleftarrow","&#x21D9;":"\\swarrow","&#x21D8;":"\\searrow","&#x21D7;":"\\nearrow","&#x21D6;":"\\nwarrow","&#x21D5;":"\\Updownarrow","&#x21D4;":"\\Leftrightarrow","&#x21D3;":"\\Downarrow","&#x21D2;":"\\Rightarrow","&#x21D1;":"\\Uparrow","&#x21D0;":"\\Leftarrow","&#x21CF;":"\\nRightarrow","&#x21CE;":"\\nLeftrightarrow","&#x21CD;":"\\nLeftarrow","&#x21CC;":"\\rightleftharpoons","&#x21CB;":"\\leftrightharpoons","&#x21CA;":"\\downdownarrows","&#x21C9;":"\\rightrightarrows","&#x21C8;":"\\upuparrows","&#x21C7;":"\\leftleftarrows","&#x21C6;":"\\leftrightarrows","&#x21C5;":"","&#x21C4;":"\\rightleftarrows","&#x21C3;":"\\downharpoonleft","&#x21C2;":"\\downharpoonright","&#x21C1;":"\\rightharpoondown","&#x21C0;":"\\rightharpoonup","&#x21BF;":"\\upharpoonleft","&#x21BE;":"\\upharpoonright","&#x21BD;":"\\leftharpoondown","&#x21BC;":"\\leftharpoonup","&#x21BB;":"\\circlearrowright","&#x21BA;":"\\circlearrowleft","&#x21B9;":"\\leftrightarrows","&#x21B8;":"\\overline{\\nwarrow}","&#x21B7;":"\\curvearrowright","&#x21B6;":"\\curvearrowleft","&#x21B5;":"\\swarrow","&#x21B4;":"\\searrow","&#x21B3;":"\\Rsh","&#x21B2;":"\\Lsh","&#x21B1;":"\\Rsh","&#x21B0;":"\\Lsh","&#x21AF;":"\\swarrow","&#x21AE;":"","&#x21AD;":"\\leftrightsquigarrow","&#x21AC;":"\\looparrowright","&#x21AB;":"\\looparrowleft","&#x21AA;":"\\hookrightarrow","&#x21A9;":"\\hookleftarrow","&#x21A8;":"\\underline{\\updownarrow}","&#x21A7;":"\\downarrow","&#x21A6;":"\\rightarrowtail","&#x21A5;":"\\uparrow","&#x21A4;":"\\leftarrowtail","&#x21A3;":"\\rightarrowtail","&#x21A2;":"\\leftarrowtail","&#x21A1;":"\\downarrow","&#x21A0;":"\\twoheadrightarrow","&#x219F;":"\\uparrow","&#x219E;":"\\twoheadleftarrow","&#x219D;":"\\nearrow","&#x219C;":"\\nwarrow","&#x219B;":"","&#x219A;":"","&#x2199;":"\\swarrow","&#x2198;":"\\searrow","&#x2197;":"\\nearrow","&#x2196;":"\\nwarrow","&#x2195;":"\\updownarrow","&#x2194;":"\\leftrightarrow","&#x2193;":"\\downarrow","&#x2192;":"\\rightarrow","&#x2191;":"\\uparrow","&#x2190;":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\left|\\right.","&#x2AFE;":"","&#x2AFD;":"//","&#x2AFB;":"///","&#x2AFA;":"","&#x2AF9;":"","&#x2AF8;":"","&#x2AF7;":"","&#x2AF6;":"\\vdots","&#x2AF5;":"","&#x2AF4;":"","&#x2AF3;":"","&#x2AF2;":"\\nparallel","&#x2AF1;":"","&#x2AF0;":"","&#x2AEF;":"","&#x2AEE;":"\\bcancel{\\mid}","&#x2AED;":"","&#x2AEC;":"","&#x2AEB;":"","&#x2AEA;":"","&#x2AE9;":"","&#x2AE8;":"\\underline{\\perp}","&#x2AE7;":"\\overline{\\top}","&#x2AE6;":"","&#x2AE5;":"","&#x2AE4;":"","&#x2AE3;":"","&#x2AE2;":"","&#x2AE1;":"","&#x2AE0;":"\\perp","&#x2ADF;":"\\top","&#x2ADE;":"\\dashv","&#x2ADD;&#x338;":"","&#x2ADD;":"","&#x2ADB;":"\\pitchfork","&#x2ADA;":"","&#x2AD9;":"","&#x2AD8;":"","&#x2AD7;":"","&#x2AD6;":"","&#x2AD5;":"","&#x2AD4;":"","&#x2AD3;":"","&#x2AD2;":"","&#x2AD1;":"","&#x2AD0;":"","&#x2ACF;":"","&#x2ACE;":"","&#x2ACD;":"","&#x2ACC;":"\\underset{\\neq}{\\supset}","&#x2ACB;":"\\underset{\\neq}{\\subset}","&#x2ACA;":"\\underset{\\approx}{\\supset}","&#x2AC9;":"\\underset{\\approx}{\\subset}","&#x2AC8;":"\\underset{\\sim}{\\supset}","&#x2AC7;":"\\underset{\\sim}{\\subset}","&#x2AC6;":"\\supseteqq","&#x2AC5;":"\\subseteqq","&#x2AC4;":"\\dot{\\supseteq}","&#x2AC3;":"\\dot{\\subseteq}","&#x2AC2;":"\\underset{\\times}{\\supset}","&#x2AC1;":"\\underset{\\times}{\\subset}","&#x2AC0;":"\\underset{+}{\\supset}","&#x2ABF;":"\\underset{+}{\\subset}","&#x2ABE;":"","&#x2ABD;":"","&#x2ABC;":"\\gg ","&#x2ABB;":"\\ll","&#x2ABA;":"\\underset{\\cancel{\\approx}}{\\succ}","&#x2AB9;":"\\underset{\\cancel{\\approx}}{\\prec}","&#x2AB8;":"\\underset{\\approx}{\\succ}","&#x2AB7;":"\\underset{\\approx}{\\prec}","&#x2AB6;":"\\underset{\\cancel{=}}{\\succ}","&#x2AB5;":"\\underset{\\cancel{=}}{\\prec}","&#x2AB4;":"\\underset{=}{\\succ}","&#x2AB3;":"\\underset{=}{\\prec}","&#x2AB2;":"","&#x2AB1;":"","&#x2AAE;":"","&#x2AAD;":"\\underline{\\hcancel{>}}","&#x2AAC;":"\\underline{\\hcancel{>}}","&#x2AAB;":"\\hcancel{>}","&#x2AAA;":"\\hcancel{<}","&#x2AA9;":"","&#x2AA8;":"","&#x2AA7;":"\\vartriangleright","&#x2AA6;":"\\vartriangleleft","&#x2AA5;":"><","&#x2AA4;":"><","&#x2AA3;":"\\underline{\\ll}","&#x2AA2;&#x338;":"\\cancel{\\gg}","&#x2AA2;":"\\gg","&#x2AA1;&#x338;":"\\cancel{\\ll}","&#x2AA1;":"\\ll","&#x2AA0;":"\\overset{\\sim}{\\geqq}","&#x2A9F;":"\\overset{\\sim}{\\leqq}","&#x2A9E;":"\\overset{\\sim}{>}","&#x2A9D;":"\\overset{\\sim}{<}","&#x2A9C;":"","&#x2A9B;":"","&#x2A9A;":"\\overset{=}{>}","&#x2A99;":"\\overset{=}{<}","&#x2A98;":"","&#x2A97;":"","&#x2A96;":"","&#x2A95;":"","&#x2A94;":"","&#x2A93;":"","&#x2A92;":"\\underset{=}{\\gtrless}","&#x2A91;":"\\underset{=}{\\lessgtr}","&#x2A90;":"\\underset{<}{\\gtrsim}","&#x2A8F;":"\\underset{>}{\\lesssim}","&#x2A8E;":"\\underset{\\simeq}{>}","&#x2A8D;":"\\underset{\\simeq}{<}","&#x2A8C;":"\\gtreqqless","&#x2A8B;":"\\lesseqqgtr","&#x2A8A;":"\\underset{\\cancel{\\approx}}{>}","&#x2A89;":"\\underset{\\approx}{<}","&#x2A86;":"\\underset{\\approx}{>}","&#x2A85;":"\\underset{\\approx}{<}","&#x2A84;":"","&#x2A83;":"","&#x2A82;":"","&#x2A81;":"","&#x2A80;":"","&#x2A7F;":"","&#x2A7E;&#x338;":"\\bcancel{\\geq}","&#x2A7E;":"\\geq","&#x2A7D;&#x338;":"\\bcancel{\\leq}","&#x2A7D;":"\\leq","&#x2A7C;":"","&#x2A7B;":"","&#x2A7A;":"","&#x2A79;":"","&#x2A78;":"\\overset{\\dots}{\\equiv}","&#x2A77;":"","&#x2A76;":"===","&#x2A75;":"==","&#x2A74;":"::=","&#x2A73;":"","&#x2A72;":"\\underset{=}{+}","&#x2A71;":"\\overset{=}{+}","&#x2A70;":"\\overset{\\approx}{=}","&#x2A6F;":"\\overset{\\wedge}{=}","&#x2A6E;":"\\overset{*}{=}","&#x2A6D;":"\\dot{\\approx}","&#x2A6C;":"","&#x2A6B;":"","&#x2A6A;":"\\dot{\\sim}","&#x2A69;":"","&#x2A68;":"","&#x2A67;":"\\dot{\\equiv}","&#x2A66;":"\\underset{\\cdot}{=}","&#x2A65;":"","&#x2A64;":"","&#x2A63;":"\\underset{=}{\\vee}","&#x2A62;":"\\overset{=}{\\vee}","&#x2A61;":"ul(vv)","&#x2A60;":"\\underset{=}{\\wedge}","&#x2A5F;":"\\underline{\\wedge}","&#x2A5E;":"\\overset{=}{\\wedge}","&#x2A5D;":"\\hcancel{\\vee}","&#x2A5C;":"\\hcancel{\\wedge}","&#x2A5B;":"","&#x2A5A;":"","&#x2A59;":"","&#x2A58;":"\\vee","&#x2A57;":"\\wedge","&#x2A56;":"","&#x2A55;":"","&#x2A54;":"","&#x2A53;":"","&#x2A52;":"\\dot{\\vee}","&#x2A51;":"\\dot{\\wedge}","&#x2A50;":"","&#x2A4F;":"","&#x2A4E;":"","&#x2A4D;":"\\overline{\\cap}","&#x2A4C;":"\\overline{\\cup}","&#x2A4B;":"","&#x2A4A;":"","&#x2A49;":"","&#x2A48;":"","&#x2A47;":"","&#x2A46;":"","&#x2A45;":"","&#x2A44;":"","&#x2A43;":"\\overline{\\cap}","&#x2A42;":"\\overline{\\cup}","&#x2A41;":"","&#x2A40;":"","&#x2A3E;":"","&#x2A3D;":"\\llcorner","&#x2A3C;":"\\lrcorner","&#x2A3B;":"","&#x2A3A;":"","&#x2A39;":"","&#x2A38;":"","&#x2A37;":"","&#x2A36;":"\\hat{\\otimes}","&#x2A35;":"","&#x2A34;":"","&#x2A33;":"","&#x2A32;":"\\underline{\\times}","&#x2A31;":"\\underline{\\times}","&#x2A30;":"\\dot{\\times}","&#x2A2E;":"","&#x2A2D;":"","&#x2A2C;":"","&#x2A2B;":"","&#x2A2A;":"","&#x2A29;":"","&#x2A28;":"","&#x2A27;":"","&#x2A26;":"\\underset{\\sim}{+}","&#x2A25;":"\\underset{\\circ}{+}","&#x2A24;":"\\overset{\\sim}{+}","&#x2A23;":"\\hat{+}","&#x2A22;":"\\dot{+}","&#x2A21;":"\\upharpoonright","&#x2A20;":">>","&#x2A1F;":"","&#x2A1E;":"\\triangleleft","&#x2A1D;":"\\bowtie","&#x29FF;":"","&#x29FE;":"+","&#x29FB;":"\\hcancel{|||}","&#x29FA;":"\\hcancel{||}","&#x29F9;":"\\backslash","&#x29F8;":"/","&#x29F7;":"hcancel{\backslash}","&#x29F6;":"","&#x29F5;":"\\backslash","&#x29F2;":"\\Phi","&#x29F1;":"","&#x29F0;":"","&#x29EE;":"","&#x29ED;":"","&#x29EC;":"","&#x29EB;":"\\lozenge","&#x29EA;":"","&#x29E9;":"","&#x29E8;":"","&#x29E7;":"\\ddagger","&#x29E2;":"\\sqcup\\sqcup","&#x29E1;":"","&#x29E0;":"\\square","&#x29DE;":"","&#x29DD;":"","&#x29DC;":"","&#x29DB;":"\\{\\{","&#x29D9;":"\\{","&#x29D8;":"\\}","&#x29D7;":"","&#x29D6;":"","&#x29D5;":"\\bowtie","&#x29D4;":"\\bowtie","&#x29D3;":"\\bowtie","&#x29D2;":"\\bowtie","&#x29D1;":"\\bowtie","&#x29D0;&#x338;":"| \\not\\triangleright","&#x29D0;":"| \\triangleright","&#x29CF;&#x338;":"\\not\\triangleleft |","&#x29CF;":"\\triangleleft |","&#x29CE;":"","&#x29CD;":"\\triangle","&#x29CC;":"","&#x29CB;":"\\underline{\\triangle}","&#x29CA;":"\\dot{\\triangle}","&#x29C9;":"","&#x29C8;":"\\boxed{\\circ}","&#x29C7;":"\\boxed{\\circ}","&#x29C6;":"\\boxed{\\rightarrow}","&#x29C5;":"\\bcancel{\\square}","&#x29C4;":"\\cancel{\\square}","&#x29C3;":"\\odot","&#x29C2;":"\\odot","&#x29BF;":"\\odot","&#x29BE;":"\\odot","&#x29BD;":"\\varnothing","&#x29BC;":"\\oplus","&#x29BB;":"\\otimes","&#x29BA;":"","&#x29B9;":"\\varnothing","&#x29B8;":"\\varnothing","&#x29B7;":"\\ominus","&#x29B6;":"\\ominus","&#x29B5;":"\\ominus","&#x29B4;":"\\vec{\\varnothing}","&#x29B3;":"\\vec{\\varnothing}","&#x29B2;":"\\dot{\\varnothing}","&#x29B1;":"\\overline{\\varnothing}","&#x29B0;":"\\varnothing","&#x29AF;":"","&#x29AE;":"","&#x29AD;":"","&#x29AC;":"","&#x29AB;":"","&#x29AA;":"","&#x29A9;":"","&#x29A8;":"","&#x29A7;":"","&#x29A6;":"","&#x29A5;":"","&#x29A4;":"","&#x29A3;":"","&#x29A2;":"","&#x29A1;":"\\not\\lor","&#x29A0;":"\\bcancel{>}","&#x2982;":":","&#x2981;":"\\circ","&#x2758;":"|","&#x25B2;":"\\bigtriangleup","&#x22FF;":"\\Epsilon","&#x22FE;":"\\overline{\\ni}","&#x22FD;":"\\overline{\\ni}","&#x22FC;":"\\in","&#x22FB;":"\\in","&#x22FA;":"\\in","&#x22F9;":"\\underline{\\in}","&#x22F8;":"\\underline{\\in}","&#x22F7;":"\\overline{\\in}","&#x22F6;":"\\overline{\\in}","&#x22F5;":"\\dot{\\in}","&#x22F4;":"\\in","&#x22F3;":"\\in","&#x22F2;":"\\in","&#x22F0;":"\\ddots","&#x22E9;":"\\underset{\\sim}{\\succ}","&#x22E8;":"\\underset{\\sim}{\\prec}","&#x22E7;":"\\underset{\\not\\sim}{>}","&#x22E6;":"\\underset{\\not\\sim}{<}","&#x22E5;":"\\not\\sqsupseteq","&#x22E4;":"\\not\\sqsubseteq","&#x22E3;":"\\not\\sqsupseteq","&#x22E2;":"\\not\\sqsubseteq","&#x22E1;":"\\nsucc","&#x22E0;":"\\nprec","&#x22DF;":"\\succ","&#x22DE;":"\\prec","&#x22DD;":"\\overline{>}","&#x22DC;":"\\overline{<}","&#x22DB;":"\\underset{>}{\\leq}","&#x22DA;":"\\underset{<}{\\geq}","&#x22D5;":"\\#","&#x22D3;":"\\cup","&#x22D2;":"\\cap","&#x22D1;":"\\supset","&#x22D0;":"\\subset","&#x22CF;":"\\wedge","&#x22CE;":"\\vee","&#x22CD;":"\\simeq","&#x22C8;":"\\bowtie","&#x22C7;":"\\ast","&#x22C6;":"\\star","&#x22C4;":"\\diamond","&#x22BF;":"\\triangle","&#x22BE;":"\\measuredangle","&#x22BD;":"\\overline{\\lor}","&#x22BC;":"\\overline{\\land}","&#x22BB;":"\\underline{\\lor}","&#x22BA;":"\\top","&#x22B9;":"","&#x22B7;":"\\circ\\multimap","&#x22B6;":"\\circ\\multimap","&#x22B3;":"\\triangleright","&#x22B2;":"\\triangleleft","&#x22B1;":"\\succ","&#x22B0;":"\\prec","&#x22AB;":"|\\models","&#x22AA;":"|\\models","&#x22A7;":"\\models","&#x22A6;":"\\vdash","&#x229D;":"\\ominus","&#x229C;":"\\ominus","&#x229B;":"\\odot","&#x229A;":"\\odot","&#x2294;":"\\sqcup","&#x2293;":"\\sqcap","&#x2292;":"\\sqsupseteq","&#x2291;":"\\sqsubseteq","&#x2290;&#x338;":"\\not\\sqsupset","&#x2290;":"\\sqsupset","&#x228F;&#x338;":"\\not\\sqsubset","&#x228F;":"\\sqsubset","&#x228E;":"\\cup","&#x228D;":"\\cup","&#x228C;":"\\cup","&#x227F;&#x338;":"\\not\\succsim","&#x227F;":"\\succsim","&#x227E;":"\\precsim","&#x2279;":"\\not\\overset{>}{<}","&#x2278;":"\\not\\overset{>}{<}","&#x2277;":"\\overset{>}{<}","&#x2276;":"\\overset{<}{>}","&#x2275;":"\\not\\geg","&#x2274;":"\\not\\leq","&#x2273;":"\\geg","&#x2272;":"\\leq","&#x226C;":"","&#x2267;":"\\geg","&#x2266;&#x338;":"\\not\\leq","&#x2266;":"\\leq","&#x2263;":"\\overset{=}{=} ","&#x225E;":"\\overset{m}{=} ","&#x225D;":"\\overset{def}{=}","&#x2258;":"=","&#x2256;":"=","&#x2255;":"=:","&#x2253;":"\\doteq","&#x2252;":"\\doteq","&#x2251;":"\\doteq","&#x2250;":"\\doteq","&#x224F;&#x338;":"","&#x224F;":"","&#x224E;&#x338;":"","&#x224E;":"","&#x224C;":"\\approx","&#x224B;":"\\approx","&#x224A;":"\\approx","&#x2242;&#x338;":"\\neq","&#x2242;":"=","&#x223F;":"\\sim","&#x223E;":"\\infty","&#x223D;&#x331;":"\\sim","&#x223D;":"\\sim","&#x223B;":"\\sim","&#x223A;":":-:","&#x2239;":"-:","&#x2238;":"\\bot","&#x2237;":"::","&#x2236;":":","&#x2223;":"|","&#x221F;":"\\llcorner","&#x2219;":"\\cdot","&#x2218;":"\\circ","&#x2217;":"*","&#x2215;":"/","&#x220E;":"\\square","&#x220D;":"\\ni","&#x220A;":"\\in","&#x2206;":"\\Delta","&#x2044;":"/","&#x2AB0;&#x338;":"\\nsucceq","&#x2AB0;":"\\succeq","&#x2AAF;&#x338;":"\\npreceq","&#x2AAF;":"\\preceq","&#x2A88;":"\\ngeqslant","&#x2A87;":"\\nleqslant","&#x29F3;":"\\Phi","&#x29E6;":"\\models","&#x29E5;":"\\not\\equiv","&#x29E4;":"\\approx\\neq","&#x29E3;":"\\neq","&#x29C1;":"\\circle","&#x29C0;":"\\circle","&#x25E6;":"\\circle","&#x25D7;":"\\circle","&#x25D6;":"\\circle","&#x25CF;":"\\circle","&#x25CE;":"\\circledcirc","&#x25CD;":"\\circledcirc","&#x25CC;":"\\circledcirc","&#x25C9;":"\\circledcirc","&#x25C8;":"\\diamond","&#x25C7;":"\\diamond","&#x25C6;":"\\diamond","&#x25C5;":"\\triangleleft","&#x25C4;":"\\triangleleft","&#x25C3;":"\\triangleleft","&#x25C2;":"\\triangleleft","&#x25C1;":"\\triangleleft","&#x25C0;":"\\triangleleft","&#x25BF;":"\\triangledown","&#x25BE;":"\\triangledown","&#x25BD;":"\\triangledown","&#x25BC;":"\\triangledown","&#x25B9;":"\\triangleright","&#x25B8;":"\\triangleright","&#x25B7;":"\\triangleright","&#x25B6;":"\\triangleright","&#x25B5;":"\\triangle","&#x25B4;":"\\triangle","&#x25B3;":"\\triangle","&#x25B1;":"\\square","&#x25B0;":"\\square","&#x25AF;":"\\square","&#x25AE;":"\\square","&#x25AD;":"\\square","&#x25AB;":"\\square","&#x25AA;":"\\square","&#x25A1;":"\\square","&#x25A0;":"\\square","&#x22ED;":"\\not\\triangleright","&#x22EC;":"\\not\\triangleleft","&#x22EB;":"\\not\\triangleright","&#x22EA;":"\\not\\triangleleft","&#x22D9;":"\\ggg","&#x22D8;":"\\lll","&#x22D7;":"*>","&#x22D6;":"<*","&#x22D4;":"\\pitchfork","&#x22CC;":"","&#x22CB;":"","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#x22B5;":"\\triangleright","&#x22B4;":"","&#x22A5;":"\\bot","&#x2281;":"\\nsucc","&#x2280;":"\\preceq","&#x227D;":"\\succeq","&#x227C;":"\\preceq","&#x227B;":"\\succ","&#x227A;":"\\prec","&#x2271;":"\\geq/","&#x2270;":"\\leq/","&#x226D;":"\\neq","&#x226B;&#x338;":"\\not\\gg","&#x226B;":"\\gg","&#x226A;&#x338;":"\\not\\ll","&#x226A;":"\\ll","&#x2269;":"\\ngeqslant","&#x2268;":"\\nleqslant","&#x2261;":"\\equiv","&#x225F;":"\\doteq","&#x225C;":"\\triangleq","&#x225B;":"\\doteq","&#x225A;":"\\triangleq","&#x2259;":"\\triangleq","&#x2257;":"\\doteq","&#x2254;":":=","&#x224D;":"\\asymp","&#x2247;":"\\ncong","&#x2246;":"\\ncong","&#x2245;":"\\cong","&#x2244;":"\\not\\simeq","&#x2243;":"\\simeq","&#x2241;":"\\not\\sim","&#x2226;":"\\not\\parallel","&#x2225;":"\\parallel","&#x2224;":"\\not|","&#x221D;":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","&#x2260;":"\\neq","&#x2262;":"\\equiv /","&#x2249;":"\\approx /","&#x223C;":"sim","&#x2248;":"\\approx","&#x226E;":"</","&lt;":"<","&#x226F;":">/",">=":">=",">":">","&#x2265;":"\\geq","&#x2264;":"\\leq","&lt;=":"<=","&#x228B;":"\\supsetneq","&#x228A;":"\\subsetneq","&#x2289;":"\\nsupseteq","&#x2288;":"\\nsubseteq","&#x2287;":"\\supseteq","&#x2286;":"\\subseteq","&#x2285;":"\\not\\supset","&#x2284;":"\\not\\subset","&#x2283;&#x20D2;":"\\supset |","&#x2283;":"\\supset","&#x2282;&#x20D2;":"\\subset |","&#x2282;":"\\subset","&#x220C;":"\\not\\in","&#x2209;":"\\notin","&#x2208;":"\\in","&#x2201;":"C","&#x2204;":"\\nexists","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x2227;":"\\land","&amp;&amp;":"\\&\\&","&#x2228;":"\\lor","&#x22AF;":"\\cancel{\\vDash}","&#x22AE;":"\\cancel{\\Vdash}","&#x22AD;":"\\nvDash","&#x22AC;":"\\nvDash","&#x22A9;":"\\Vdash","&#x22A8;":"\\vDash","&#x22A4;":"\\top","&#x22A3;":"\\dashv","&#x22A2;":"\\vdash","&#x220B;":"\\ni","&#x22F1;":"\\ddots","&#x22EF;":"\\hdots","&#x22EE;":"\\vdots","&#x2026;":"\\hdots","&#x3F6;":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","&#x2235;":"\\because","&#x2234;":"\\therefore ","&#x2063;":"",",":",",";":";","&#x29FD;":"\\}","&#x29FC;":"\\{","&#x2998;":"\\]","&#x2997;":"\\[","&#x2996;":"\\ll","&#x2995;":"\\gg","&#x2994;":"\\gg","&#x2993;":"\\ll","&#x2992;":"\\gg","&#x2991;":"\\ll","&#x2990;":"\\]","&#x298F;":"\\]","&#x298E;":"\\]","&#x298D;":"\\[","&#x298C;":"\\[","&#x298B;":"\\]","&#x298A;":"\\triangleright","&#x2989;":"\\triangleleft","&#x2988;":"|\\)","&#x2987;":"\\(|","&#x2986;":"|\\)","&#x2985;":"\\(\\(","&#x2984;":"|\\}","&#x2983;":"\\{|","&#x2980;":"\\||","&#x27EF;":"\\left. \\right]","&#x27EE;":"\\left[ \\right.","&#x27ED;":"\\left. \\right]]","&#x27EC;":"\\left[[ \\right.","&#x27EB;":"\\gg","&#x27EA;":"\\ll","&#x27E9;":"\\rangle","&#x27E8;":"\\langle","&#x27E7;":"\\left. \\right]]","&#x27E6;":"\\left[[ \\right.","&#x2773;":"\\left.\\right)","&#x2772;":"\\left(\\right.","&#x232A;":"\\rangle","&#x2329;":"\\langle","&#x230B;":"\\rfloor","&#x230A;":"\\lfloor","&#x2309;":"\\rceil","&#x2308;":"\\lceil","&#x2016;":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","&#x201D;":'"',"&#x201C;":"``","&#x2019;":"'","&#x2018;":"`","%CE%B1":"\\alpha","%CE%B2":"\\beta","%CE%B3":"\\gamma","%CE%93":"\\Gamma","%CE%B4":"\\delta","%CE%94":"\\Delta","%CF%B5":"\\epsilon","%CE%B6":"\\zeta","%CE%B7":"\\eta","%CE%B8":"\\theta","%CE%98":"\\Theta","%CE%B9":"\\iota","%CE%BA":"\\kappa","%CE%BB":"\\lambda","%CE%BC":"\\mu","%CE%BD":"\\nu","%CE%BF":"\\omicron","%CF%80":"\\pi","%CE%A0":"\\Pi","%CF%81":"\\pho","%CF%83":"\\sigma","%CE%A3":"\\Sigma","%CF%84":"\\tau","%CF%85":"\\upsilon","%CE%A5":"\\Upsilon","%CF%95":"\\phi","%CE%A6":"\\Phi","%CF%87":"\\chi","%CF%88":"\\psi","%CE%A8":"\\Psi","%CF%89":"\\omega","%CE%A9":"\\Omega"}},9039:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByGlyph=void 0,t.allMathOperatorsByGlyph={_:"\\underline","⏡":"\\underbrace","⏠":"\\overbrace","⏟":"\\underbrace","⏞":"\\overbrace","⏝":"\\underbrace","⏜":"\\overbrace","⎵":"\\underbrace","⎴":"\\overbrace","⃜":"\\square","⃛":"\\square","⁤":"","⁗":"''''","‾":"\\overline","‷":"```","‶":"``","‵":"`","‴":"'''","″":"''","‟":"``","„":",,","‛":"`","‚":",","^":"\\hat","˷":"\\sim","˝":"\\sim","˜":"\\sim","˚":"\\circ","˙":"\\cdot","˘":" ",ˍ:"\\_",ˋ:"ˋ",ˊ:"ˊ",ˉ:"ˉ",ˇ:"",ˆ:"\\hat",º:"o","¹":"1","¸":",","´":"´","³":"3","²":"2","°":"\\circ","¯":"\\bar",ª:"a","↛":"\\nrightarrow","¨":"\\cdot\\cdot","~":"\\sim","`":"`","--":"--","++":"++","&":"\\&","∜":"\\sqrt[4]{}","∛":"\\sqrt[3]{}","√":"\\sqrt{}",ⅆ:"d",ⅅ:"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","♯":"\\#","♮":"","♭":"","′":"'","<>":"<>","**":"\\star\\star","∇":"\\nabla","∂":"\\partial","⊙":"\\bigodot","¬":"\\neg","∢":"\\measuredangle","∡":"\\measuredangle","∠":"\\angle","÷":"\\div","/":"/","∖":"\\backslash","\\":"\\backslash","%":"\\%","⊗":"\\bigotimes","·":"\\cdot","⨿":"\\coprod","⨯":"\\times","⋅":"\\cdot","⊡":"\\boxdot","⊠":"\\boxtimes","⁢":"","⁃":"-","•":"\\cdot",".":".","*":"\\star","∪":"\\cup","∩":"\\cap","∐":"\\coprod","∏":"\\prod","≀":"","⫿":"","⫼":"\\mid\\mid\\mid","⨉":"\\times","⨈":"","⨇":"","⨆":"\\sqcup","⨅":"\\sqcap","⨂":"\\otimes","⨀":"\\odot","⋂":"\\cap","⋁":"\\vee","⋀":"\\wedge","⨄":"\\uplus","⨃":"\\cup","⋃":"\\cup","⨜":"\\underline{\\int}","⨛":"\\overline{\\int}","⨚":"\\int","⨙":"\\int","⨘":"\\int","⨗":"\\int","⨖":"\\oint","⨕":"\\oint","⨔":"\\int","⨓":"\\int","⨒":"\\int","⨑":"\\int","⨐":"\\int","⨏":"\\bcancel{\\int}","⨎":"","⨍":"\\hcancel{\\int}","⨌":"\\iiiint","∳":"\\oint","∲":"\\oint","∱":"\\int","∰":"\\oiint","∯":"\\oiint","∮":"\\oint","∫":"\\int","⨁":"\\oplus","⊘":"\\oslash","⊖":"\\ominus","⊕":"\\oplus","∭":"\\iiint","∬":"\\iint","⨋":"","⨊":"","∑":"\\sum","⊟":"\\boxminus","⊞":"\\boxplus","∔":"\\dot{+}","∓":"+-","−":"-","±":"\\pm","-":"-","+":"+","⭆":"\\Rrightarrow","⭅":"\\Lleftarrow","⧴":":\\rightarrow","⧯":"","⧟":"\\bullet-\\bullet","⦟":"\\angle","⦞":"\\measuredangle","⦝":"\\measuredangle","⦜":"\\perp","⦛":"\\measuredangle","⦚":"","⦙":"\\vdots","⥿":"","⥾":"","⥽":"\\prec","⥼":"\\succ","⥻":"\\underset{\\rightarrow}{\\supset}","⥺":"","⥹":"\\underset{\\rightarrow}{\\subset}","⥸":"\\underset{\\rightarrow}{>}","⥷":"","⥶":"\\underset{\\leftarrow}{<}","⥵":"\\underset{\\approx}{\\rightarrow}","⥴":"\\underset{\\sim}{\\rightarrow}","⥳":"\\underset{\\sim}{\\leftarrow}","⥲":"\\overset{\\sim}{\\rightarrow}","⥱":"\\overset{=}{\\rightarrow}","⥰":"","⥯":"","⥮":"","⥭":"\\overline{\\rightharpoondown}","⥬":"\\underline{\\rightharpoonup}","⥫":"\\overline{\\leftharpoondown}","⥪":"\\underline{\\leftharpoonup}","⥩":"\\rightleftharpoons","⥨":"\\rightleftharpoons","⥧":"\\rightleftharpoons","⥦":"\\rightleftharpoons","⥥":"\\Downarrow","⥤":"\\Rightarrow","⥣":"\\Uparrow","⥢":"\\Leftarrow","⥡":"\\downarrow","⥠":"\\uparrow","⥟":"\\rightarrow","⥞":"\\leftarrow","⥝":"\\downarrow","⥜":"\\uparrow","⥛":"\\rightarrow","⥚":"\\leftarrow","⥙":"\\downarrow","⥘":"\\uparrow","⥗":"\\rightarrow","⥖":"\\leftarrow","⥕":"\\downarrow","⥔":"\\uparrow","⥓":"\\rightarrow","⥒":"\\leftarrow","⥑":"\\updownarrow","⥐":"\\leftrightarrow","⥏":"\\updownarrow","⥎":"\\leftrightarrow","⥍":"\\updownarrow","⥌":"\\updownarrow","⥋":"\\leftrightarrow","⥊":"\\leftrightarrow","⥉":"","⥈":"\\leftrightarrow","⥇":"\\nrightarrow","⥆":"","⥅":"","⥄":"\\rightleftarrows","⥃":"\\leftrightarrows","⥂":"\\rightleftarrows","⥁":"\\circlearrowright","⥀":"\\circlearrowleft","⤿":"\\rightarrow","⤾":"\\leftarrow","⤽":"\\leftarrow","⤼":"\\rightarrow","⤻":"\\rightarrow","⤺":"\\leftarrow","⤹":"\\downarrow","⤸":"\\downarrow","⤷":"\\Rsh","⤶":"\\Lsh","⤵":"\\downarrow","⤴":"\\uparrow","⤳":"\\rightarrow","⤲":"\\leftarrow","⤱":" ","⤰":" ","⤯":" ","⤮":" ","⤭":" ","⤬":"\\times","⤫":"\\times","⤪":" ","⤩":" ","⤨":" ","⤧":" ","⤦":" ","⤥":" ","⤤":" ","⤣":" ","⤢":" ","⤡":" ","⤠":"\\mapsto\\cdot","⤟":"\\cdot\\leftarrow","⤞":"\\rightarrow\\cdot","⤝":"\\leftarrow","⤜":"\\rightarrow","⤛":"\\leftarrow","⤚":"\\rightarrow","⤙":"\\leftarrow","⤘":"\\rightarrow","⤗":"\\rightarrow","⤖":"\\rightarrow","⤕":"\\rightarrow","⤔":"\\rightarrow","⤓":"\\downarrow","⤒":"\\uparrow","⤑":"\\rightarrow","⤐":"\\rightarrow","⤏":"\\rightarrow","⤎":"\\leftarrow","⤍":"\\rightarrow","⤌":"\\leftarrow","⤋":"\\Downarrow","⤊":"\\Uparrow","⤉":"\\uparrow","⤈":"\\downarrow","⤇":"\\Rightarrow","⤆":"\\Leftarrow","⤅":"\\mapsto","⤄":"\\nLeftrightarrow","⤃":"\\nRightarrow","⤂":"\\nLeftarrow","⤁":"\\rightsquigarrow","⤀":"\\rightsquigarrow","⟿":"\\rightsquigarrow","⟾":"\\Rightarrow","⟽":"\\Leftarrow","⟼":"\\mapsto","⟻":"\\leftarrow","⟺":"\\Longleftrightarrow","⟹":"\\Longrightarrow","⟸":"\\Longleftarrow","⟷":"\\leftrightarrow","⟶":"\\rightarrow","⟵":"\\leftarrow","⟱":"\\Downarrow","⟰":"\\Uparrow","⊸":"\\rightarrow","⇿":"\\leftrightarrow","⇾":"\\rightarrow","⇽":"\\leftarrow","⇼":"\\nleftrightarrow","⇻":"\\nrightarrow","⇺":"\\nleftarrow","⇹":"\\nleftrightarrow","⇸":"\\nrightarrow","⇷":"\\nleftarrow","⇶":"\\Rrightarrow","⇵":"","⇴":"\\rightarrow","⇳":"\\Updownarrow","⇲":"\\searrow","⇱":"\\nwarrow","⇰":"\\Leftarrow","⇯":"\\Uparrow","⇮":"\\Uparrow","⇭":"\\Uparrow","⇬":"\\Uparrow","⇫":"\\Uparrow","⇪":"\\Uparrow","⇩":"\\Downarrow","⇨":"\\Rightarrow","⇧":"\\Uparrow","⇦":"\\Leftarrow","⇥":"\\rightarrow","⇤":"\\leftarrow","⇣":"\\downarrow","⇢":"\\rightarrow","⇡":"\\uparrow","⇠":"\\leftarrow","⇟":"\\downarrow","⇞":"\\uparrow","⇝":"\\rightsquigarrow","⇜":"\\leftarrow","⇛":"\\Rrightarrow","⇚":"\\Lleftarrow","⇙":"\\swarrow","⇘":"\\searrow","⇗":"\\nearrow","⇖":"\\nwarrow","⇕":"\\Updownarrow","⇔":"\\Leftrightarrow","⇓":"\\Downarrow","⇒":"\\Rightarrow","⇑":"\\Uparrow","⇐":"\\Leftarrow","⇏":"\\nRightarrow","⇎":"\\nLeftrightarrow","⇍":"\\nLeftarrow","⇌":"\\rightleftharpoons","⇋":"\\leftrightharpoons","⇊":"\\downdownarrows","⇉":"\\rightrightarrows","⇈":"\\upuparrows","⇇":"\\leftleftarrows","⇆":"\\leftrightarrows","⇅":"","⇄":"\\rightleftarrows","⇃":"\\downharpoonleft","⇂":"\\downharpoonright","⇁":"\\rightharpoondown","⇀":"\\rightharpoonup","↿":"\\upharpoonleft","↾":"\\upharpoonright","↽":"\\leftharpoondown","↼":"\\leftharpoonup","↻":"\\circlearrowright","↺":"\\circlearrowleft","↹":"\\leftrightarrows","↸":"\\overline{\\nwarrow}","↷":"\\curvearrowright","↶":"\\curvearrowleft","↵":"\\swarrow","↴":"\\searrow","↳":"\\Rsh","↲":"\\Lsh","↱":"\\Rsh","↰":"\\Lsh","↯":"\\swarrow","↮":"","↭":"\\leftrightsquigarrow","↬":"\\looparrowright","↫":"\\looparrowleft","↪":"\\hookrightarrow","↩":"\\hookleftarrow","↨":"\\underline{\\updownarrow}","↧":"\\downarrow","↦":"\\rightarrowtail","↥":"\\uparrow","↤":"\\leftarrowtail","↣":"\\rightarrowtail","↢":"\\leftarrowtail","↡":"\\downarrow","↠":"\\twoheadrightarrow","↟":"\\uparrow","↞":"\\twoheadleftarrow","↝":"\\nearrow","↜":"\\nwarrow","↚":"","↙":"\\swarrow","↘":"\\searrow","↗":"\\nearrow","↖":"\\nwarrow","↕":"\\updownarrow","↔":"\\leftrightarrow","↓":"\\downarrow","→":"\\rightarrow","↑":"\\uparrow","←":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\mid","⫾":"","⫽":"//","⫻":"///","⫺":"","⫹":"","⫸":"","⫷":"","⫶":"\\vdots","⫵":"","⫴":"","⫳":"","⫲":"\\nparallel","⫱":"","⫰":"","⫯":"","⫮":"\\bcancel{\\mid}","⫭":"","⫬":"","⫫":"","⫪":"","⫩":"","⫨":"\\underline{\\perp}","⫧":"\\overline{\\top}","⫦":"","⫥":"","⫤":"","⫣":"","⫢":"","⫡":"","⫠":"\\perp","⫟":"\\top","⫞":"\\dashv","⫝̸":"","⫝":"","⫛":"\\pitchfork","⫚":"","⫙":"","⫘":"","⫗":"","⫖":"","⫕":"","⫔":"","⫓":"","⫒":"","⫑":"","⫐":"","⫏":"","⫎":"","⫍":"","⫌":"\\underset{\\neq}{\\supset}","⫋":"\\underset{\\neq}{\\subset}","⫊":"\\underset{\\approx}{\\supset}","⫉":"\\underset{\\approx}{\\subset}","⫈":"\\underset{\\sim}{\\supset}","⫇":"\\underset{\\sim}{\\subset}","⫆":"\\supseteqq","⫅":"\\subseteqq","⫄":"\\dot{\\supseteq}","⫃":"\\dot{\\subseteq}","⫂":"\\underset{\\times}{\\supset}","⫁":"\\underset{\\times}{\\subset}","⫀":"\\underset{+}{\\supset}","⪿":"\\underset{+}{\\subset}","⪾":"","⪽":"","⪼":"\\gg ","⪻":"\\ll","⪺":"\\underset{\\cancel{\\approx}}{\\succ}","⪹":"\\underset{\\cancel{\\approx}}{\\prec}","⪸":"\\underset{\\approx}{\\succ}","⪷":"\\underset{\\approx}{\\prec}","⪶":"\\underset{\\cancel{=}}{\\succ}","⪵":"\\underset{\\cancel{=}}{\\prec}","⪴":"\\underset{=}{\\succ}","⪳":"\\underset{=}{\\prec}","⪲":"","⪱":"","⪮":"","⪭":"\\underline{\\hcancel{>}}","⪬":"\\underline{\\hcancel{>}}","⪫":"\\hcancel{>}","⪪":"\\hcancel{<}","⪩":"","⪨":"","⪧":"\\vartriangleright","⪦":"\\vartriangleleft","⪥":"><","⪤":"><","⪣":"\\underline{\\ll}","⪢̸":"\\cancel{\\gg}","⪢":"\\gg","⪡̸":"\\cancel{\\ll}","⪡":"\\ll","⪠":"\\overset{\\sim}{\\geqq}","⪟":"\\overset{\\sim}{\\leqq}","⪞":"\\overset{\\sim}{>}","⪝":"\\overset{\\sim}{<}","⪜":"","⪛":"","⪚":"\\overset{=}{>}","⪙":"\\overset{=}{<}","⪘":"","⪗":"","⪖":"","⪕":"","⪔":"","⪓":"","⪒":"\\underset{=}{\\gtrless}","⪑":"\\underset{=}{\\lessgtr}","⪐":"\\underset{<}{\\gtrsim}","⪏":"\\underset{>}{\\lesssim}","⪎":"\\underset{\\simeq}{>}","⪍":"\\underset{\\simeq}{<}","⪌":"\\gtreqqless","⪋":"\\lesseqqgtr","⪊":"\\underset{\\cancel{\\approx}}{>}","⪉":"\\underset{\\approx}{<}","⪆":"\\underset{\\approx}{>}","⪅":"\\underset{\\approx}{<}","⪄":"","⪃":"","⪂":"","⪁":"","⪀":"","⩿":"","⩾̸":"\\bcancel{\\geq}","⩾":"\\geq","⩽̸":"\\bcancel{\\leq}","⩽":"\\leq","⩼":"","⩻":"","⩺":"","⩹":"","⩸":"\\overset{\\dots}{\\equiv}","⩷":"","⩶":"===","⩵":"==","⩴":"::=","⩳":"","⩲":"\\underset{=}{+}","⩱":"\\overset{=}{+}","⩰":"\\overset{\\approx}{=}","⩯":"\\overset{\\wedge}{=}","⩮":"\\overset{*}{=}","⩭":"\\dot{\\approx}","⩬":"","⩫":"","⩪":"\\dot{\\sim}","⩩":"","⩨":"","⩧":"\\dot{\\equiv}","⩦":"\\underset{\\cdot}{=}","⩥":"","⩤":"","⩣":"\\underset{=}{\\vee}","⩢":"\\overset{=}{\\vee}","⩡":"ul(vv)","⩠":"\\underset{=}{\\wedge}","⩟":"\\underline{\\wedge}","⩞":"\\overset{=}{\\wedge}","⩝":"\\hcancel{\\vee}","⩜":"\\hcancel{\\wedge}","⩛":"","⩚":"","⩙":"","⩘":"\\vee","⩗":"\\wedge","⩖":"","⩕":"","⩔":"","⩓":"","⩒":"\\dot{\\vee}","⩑":"\\dot{\\wedge}","⩐":"","⩏":"","⩎":"","⩍":"\\overline{\\cap}","⩌":"\\overline{\\cup}","⩋":"","⩊":"","⩉":"","⩈":"","⩇":"","⩆":"","⩅":"","⩄":"","⩃":"\\overline{\\cap}","⩂":"\\overline{\\cup}","⩁":"","⩀":"","⨾":"","⨽":"\\llcorner","⨼":"\\lrcorner","⨻":"","⨺":"","⨹":"","⨸":"","⨷":"","⨶":"\\hat{\\otimes}","⨵":"","⨴":"","⨳":"","⨲":"\\underline{\\times}","⨱":"\\underline{\\times}","⨰":"\\dot{\\times}","⨮":"\\bigodot","⨭":"\\bigodot","⨬":"","⨫":"","⨪":"","⨩":"","⨨":"","⨧":"","◻":"\\Box","⨦":"\\underset{\\sim}{+}","⨥":"\\underset{\\circ}{+}","⨤":"\\overset{\\sim}{+}","⨣":"\\hat{+}","⨢":"\\dot{+}","⨡":"\\upharpoonright","⨠":">>","⨟":"","⨞":"\\triangleleft","⨝":"\\bowtie","⧿":"","⧾":"+","⧻":"\\hcancel{|||}","⧺":"\\hcancel{||}","⧹":"\\backslash","⧸":"/","⧷":"hcancel{\backslash}","⧶":"","⧵":"\\backslash","⧲":"\\Phi","⧱":"","⧰":"","⧮":"","⧭":"","⧬":"","⧫":"\\lozenge","⧪":"","⧩":"","⧨":"","⧧":"\\ddagger","⧢":"\\sqcup\\sqcup","⧡":"","⧠":"\\square","⧞":"","⧝":"","⧜":"","⧛":"\\{\\{","⧙":"\\{","⧘":"\\}","⧗":"","⧖":"","⧕":"\\bowtie","⧔":"\\bowtie","⧓":"\\bowtie","⧒":"\\bowtie","⧑":"\\bowtie","⧐̸":"| \\not\\triangleright","⧐":"| \\triangleright","⧏̸":"\\not\\triangleleft |","⧏":"\\triangleleft |","⧎":"","⧍":"\\triangle","⧌":"","⧋":"\\underline{\\triangle}","⧊":"\\dot{\\triangle}","⧉":"","⧈":"\\boxed{\\circ}","⧇":"\\boxed{\\circ}","⧆":"\\boxed{\\rightarrow}","⧅":"\\bcancel{\\square}","⧄":"\\cancel{\\square}","⧃":"\\odot","⧂":"\\odot","⦿":"\\odot","⦾":"\\odot","⦽":"\\varnothing","⦼":"\\oplus","⦻":"\\otimes","⦺":"","⦹":"\\varnothing","⦸":"\\varnothing","⦷":"\\ominus","⦶":"\\ominus","⦵":"\\ominus","⦴":"\\vec{\\varnothing}","⦳":"\\vec{\\varnothing}","⦲":"\\dot{\\varnothing}","⦱":"\\overline{\\varnothing}","⦰":"\\varnothing","⦯":"\\measuredangle","⦮":"\\measuredangle","⦭":"\\measuredangle","⦬":"\\measuredangle","⦫":"\\measuredangle","⦪":"\\measuredangle","⦩":"\\measuredangle","⦨":"\\measuredangle","⦧":"","⦦":"","⦥":"","⦤":"","⦣":"\\ulcorner","⦢":"\\measuredangle","⦡":"\\not\\lor","⦠":"\\bcancel{>}","⦂":":","⦁":"\\cdot","❘":"\\mid","▲":"\\bigtriangleup","⋿":"\\Epsilon","⋾":"\\overline{\\ni}","⋽":"\\overline{\\ni}","⋼":"\\in","⋻":"\\in","⋺":"\\in","⋹":"\\underline{\\in}","⋸":"\\underline{\\in}","⋷":"\\overline{\\in}","⋶":"\\overline{\\in}","⋵":"\\dot{\\in}","⋴":"\\in","⋳":"\\in","⋲":"\\in","⋰":"\\ddots","։":":","⋩":"\\underset{\\sim}{\\succ}","⋨":"\\underset{\\sim}{\\prec}","⋧":"\\underset{\\not\\sim}{>}","⋦":"\\underset{\\not\\sim}{<}","⋥":"\\not\\sqsupseteq","⋤":"\\not\\sqsubseteq","⋣":"\\not\\sqsupseteq","⋢":"\\not\\sqsubseteq","⋡":"\\nsucc","⋠":"\\nprec","⋟":"\\succ","⋞":"\\prec","⋝":"\\overline{>}","⋜":"\\overline{<}","⋛":"\\underset{>}{\\leq}","⋚":"\\underset{<}{\\geq}","⋕":"\\#","⋓":"\\cup","⋒":"\\cap","⋑":"\\supset","⋐":"\\subset","⋏":"\\wedge","⋎":"\\vee","⋍":"\\simeq","⋈":"\\Join","⋇":"\\ast","⋆":"\\star","⋄":"\\diamond","⊿":"\\triangle","⊾":"\\measuredangle","⊽":"\\overline{\\lor}","⊼":"\\overline{\\land}","⊻":"\\underline{\\lor}","⊺":"\\top",土:"\\pm",十:"+","⊹":"","⊷":"\\circ\\multimap","⊶":"\\circ\\multimap","⊳":"\\triangleright","⊲":"\\triangleleft","⊱":"\\succ","⊰":"\\prec","⊫":"|\\models","⊪":"|\\models","⊧":"\\models","⊦":"\\vdash","⊝":"\\ominus","⊜":"\\ominus","⊛":"\\odot","⊚":"\\odot","⊔":"\\sqcup","⊓":"\\sqcap","⊒":"\\sqsupseteq","⊑":"\\sqsubseteq","⊐̸":"\\not\\sqsupset","⊐":"\\sqsupset","⊏̸":"\\not\\sqsubset","⊏":"\\sqsubset","⊎":"\\cup","⊍":"\\cup","⊌":"\\cup","≿̸":"\\not\\succsim","≿":"\\succsim","≾":"\\precsim","≹":"\\not\\overset{>}{<}","≸":"\\not\\overset{>}{<}","≷":"\\overset{>}{<}","≶":"\\overset{<}{>}","≵":"\\not\\geg","≴":"\\not\\leq","≳":"\\geg","≲":"\\leq","≬":"","≧":"\\geg","≦̸":"\\not\\leq","≦":"\\leq","≣":"\\overset{=}{=} ","≞":"\\overset{m}{=} ","≝":"\\overset{def}{=}","≘":"=","≖":"=","≕":"=:","≓":"\\doteq","≒":"\\doteq","≑":"\\doteq","≐":"\\doteq","≏̸":"","≏":"","≎̸":"","≎":"","≌":"\\approx","≋":"\\approx","≊":"\\approx","≂̸":"\\neq","≂":"=","∿":"\\sim","∾":"\\infty","∽̱":"\\sim","∽":"\\sim","∻":"\\sim","∺":":-:","∹":"-:","∸":"\\bot","∷":"::","∶":":","∣":"\\mid","∟":"\\llcorner","∘":"\\circ","∗":"*","∕":"/","∎":"\\square","∍":"\\ni","∊":"\\in","∆":"\\Delta","⁄":"/","⪰̸":"\\nsucceq","⪰":"\\succeq","⪯̸":"\\npreceq","⪯":"\\preceq","⪈":"\\ngeqslant","⪇":"\\nleqslant","⧳":"\\Phi","⧦":"\\models","⧥":"\\not\\equiv","⧤":"\\approx\\neq","⧣":"\\neq","⧁":"\\circle","⧀":"\\circle","◦":"\\circle","◗":"\\circle","◖":"\\circle","●":"\\circle","◎":"\\circledcirc","◍":"\\circledcirc","◌":"\\circledcirc","◉":"\\circledcirc","◈":"\\diamond","◇":"\\diamond","◆":"\\diamond","◅":"\\triangleleft","◄":"\\triangleleft","◃":"\\triangleleft","◂":"\\triangleleft","◁":"\\triangleleft","◀":"\\triangleleft","▿":"\\triangledown","▾":"\\triangledown","▽":"\\triangledown","▼":"\\triangledown","▹":"\\triangleright","▸":"\\triangleright","▷":"\\triangleright","▶":"\\triangleright","▵":"\\triangle","▴":"\\triangle","△":"\\triangle","▱":"\\square","▰":"\\blacksquare","▯":"\\square","▮":"\\blacksquare","▭":"\\square","▫":"\\square","▪":"\\square","□":"\\square","■":"\\blacksquare","⋭":"\\not\\triangleright","⋬":"\\not\\triangleleft","⋫":"\\not\\triangleright","⋪":"\\not\\triangleleft","⋙":"\\ggg","⋘":"\\lll","⋗":"*>","⋖":"<*","⋔":"\\pitchfork","⋌":"","⋋":"\\bowtie","⋊":"\\ltimes","⋉":"\\rtimes","⊵":"\\triangleright","\\triangleleft":"","⊥":"\\bot","⊁":"\\nsucc","⊀":"\\preceq","≽":"\\succeq","≼":"\\preceq","≻":"\\succ","≺":"\\prec","≱":"\\geq/","≰":"\\leq/","≭":"\\neq","≫̸":"\\not\\gg","≫":"\\gg","≪̸":"\\not\\ll","≪":"\\ll","≩":"\\ngeqslant","≨":"\\nleqslant","≡":"\\equiv","≟":"\\doteq","≜":"\\triangleq","≛":"\\doteq","≚":"\\triangleq","≙":"\\triangleq","≗":"\\doteq","≔":":=","≍":"\\asymp","≇":"\\ncong","≆":"\\ncong","≅":"\\cong","≄":"\\not\\simeq","≃":"\\simeq","≁":"\\not\\sim","∦":"\\not\\parallel","∥":"\\parallel","∤":"\\not|","∝":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","≠":"\\neq","≢":"\\equiv /","≉":"\\approx /","∼":"sim","≈":"\\approx","≮":"</","<":"<","≯":">/",">=":">=",">":">","≥":"\\geq","≤":"\\leq","<=":"<=","⊋":"\\supsetneq","⊊":"\\subsetneq","⊉":"\\nsupseteq","⊈":"\\nsubseteq","⊇":"\\supseteq","⊆":"\\subseteq","⊅":"\\not\\supset","⊄":"\\not\\subset","⊃⃒":"\\supset |","⊃":"\\supset","⊂⃒":"\\subset |","⊂":"\\subset","∌":"\\not\\in","∉":"\\notin","∈":"\\in","∁":"C","∄":"\\nexists","∃":"\\exists","∀":"\\forall","∧":"\\land","&&":"\\&\\&","∨":"\\lor","⊯":"\\cancel{\\vDash}","⊮":"\\cancel{\\Vdash}","⊭":"\\nvDash","⊬":"\\nvDash","⊩":"\\Vdash","⊨":"\\vDash","⊤":"\\top","⊣":"\\dashv","⊢":"\\vdash","∋":"\\ni","⋱":"\\ddots","⋯":"\\hdots","⋮":"\\vdots","϶":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","∵":"\\because","∴":"\\therefore ","⁣":"\\llbracket",",":",",";":";","⧽":"\\}","⧼":"\\{","⦘":"\\]","⦗":"\\[","⦖":"\\ll","⦕":"\\gg","⦔":"\\gg","⦓":"\\ll","⦒":"\\gg","⦑":"\\ll","⦐":"\\]","⦏":"\\]","⦎":"\\]","⦍":"\\[","⦌":"\\[","⦋":"\\]","⦊":"\\triangleright","⦉":"\\triangleleft","⦈":"|\\)","⦇":"\\(|","⦆":"|\\)","⦅":"\\(\\(","⦄":"|\\}","⦃":"\\{|","⦀":"\\||","⟯":"\\left. \\right]","⟮":"\\left[ \\right.","⟭":"\\left. \\right]]","⟬":"\\left[[ \\right.","⟫":"\\gg","⟪":"\\ll","⟧":"\\)|","⟦":"\\(|","❳":"\\left.\\right)","❲":"\\left(\\right.","〉":"\\rangle","〈":"\\langle","⌋":"\\rfloor","⌊":"\\lfloor","⌉":"\\rceil","⌈":"\\lceil","‖":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","”":'\\"',"“":"\\text{``}","’":"'","‘":"`",α:"\\alpha",β:"\\beta",γ:"\\gamma",Γ:"\\Gamma",δ:"\\delta",Δ:"\\Delta",ϵ:"\\epsilon",ζ:"\\zeta",η:"\\eta",θ:"\\theta",Θ:"\\Theta",ι:"\\iota",κ:"\\kappa",λ:"\\lambda",ν:"\\nu",ο:"\\omicron",π:"\\pi",Π:"\\Pi",ρ:"\\rho",σ:"\\sigma",Σ:"\\Sigma",τ:"\\tau",υ:"\\upsilon",Υ:"\\Upsilon",ϕ:"\\phi",Φ:"\\Phi",χ:"\\chi",ψ:"\\psi",Ψ:"\\Psi",ω:"\\omega",Ω:"\\Omega",Ω:"\\Omega","∅":"\\emptyset","⟲":"\\circlearrowleft","⟳":"\\circlearrowright","×":"\\times","½":"\\dfrac{1}{2}",μ:"\\mu",Ө:"\\theta","✓":"\\checkmark","⟩":"\\rangle","⟨":"\\langle","¼":"\\dfrac{1}{4}","…":"\\ldots",ℏ:"\\hbar",ℜ:"\\mathfrak{R}",Ѳ:"\\theta",Ø:"\\emptyset",ϱ:"\\varrho",ф:"\\phi",ℇ:"\\varepsilon",T:"T","∙":"\\cdot",Ρ:"P","∞":"\\infty",ᐁ:"\\nabla",ƞ:"\\eta","⁺":"^{+}","⁻":"^{-}","⁼":"^{=}","⁽":"^{(}","⁾":"^{)}","〗":"\\)|","〖":"\\langle",";":";","൦":"\\circ","┴":"\\perp","✕":"\\times","⎻":"-","»":"\\gg","⬆":"\\uparrow","⬇":"\\downarrow","⬅":"\\leftarrow","➡":"\\rightarrow","⎼":"-","⎜":"\\mid","⎥":"\\mid",ħ:"\\hbar","⮕":"\\rightarrow","・":"\\cdot","¦":"\\mid","£":"\\pounds","¥":"\\yen","✗":"\\times","✔":"\\checkmark",ⁿ:"^{n}","«":"\\ll",เ:"\\prime","†":"\\dagger","│":"\\mid",$:"\\$","#":"\\#","℃":"\\text{\\textdegree C}","℉":"\\text{\\textdegree F}","█":"\\blacksquare","℧":"\\mho",ⅇ:"\\text{e}",ɼ:"r","‡":"\\ddagger",ἱ:"i",ϒ:"\\Upsilon",𝛿:"\\delta","˳":"\\cdot",ѳ:"\\theta",𝜙:"\\phi",П:"\\prod",о:"o",ђ:"\\hbar",Ʌ:"\\Lambda","।":"\\mid","€":"\\euro",ῡ:"\\bar{u}",φ:"\\varphi",ȼ:"c",𝞮:"\\epsilon",Χ:"\\mathsf{X}",ₙ:"_{n}"}},8249:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByChar=void 0,t.allMathSymbolsByChar={"&#xA0;":"\\textrm{ }","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x21D4;":"\\iff","&#x21D2;":"=>","&#xAC;":"\\neg","&#x2124;":"\\mathbb{Z}","&#x211D;":"\\mathbb{R}","&#x211A;":"\\mathbb{Q}","&#x2115;":"\\mathbb{N}","&#x2102;":"CC","&#x25A1;":"\\square","&#x22C4;":"\\diamond","&#x25B3;":"\\triangle","&#x2322;":"\\frown","&#x2220;":"\\angle","&#x22F1;":"\\ddots","&#x22EE;":"\\vdots","&#x2235;":"\\because","&#x2234;":"\\therefore","&#x2135;":"\\aleph","&#x2205;":"\\oslash","&#xB1;":"\\pm","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x222E;":"\\oint","&#x222B;":"\\int","&#x22C3;":"\\cup","&#x222A;":"\\cup","&#x22C2;":"\\cap","&#x2229;":"\\cap","&#x22C1;":"\\vee","&#x2228;":"\\vee","&#x22C0;":"\\wedge","&#x2227;":"\\wedge","&#x220F;":"\\prod","&#x2211;":"\\sum","&#x2299;":"\\bigodot","&#x2297;":"\\bigoplus","&#x2295;":"o+","&#x2218;":"@","&#x22C8;":"\\bowtie","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#xF7;":"\\div","&#xD7;":"\\times","\\":"\\backslash","&#x22C6;":"\\star","&#x2217;":"\\star","&#x22C5;":"\\cdot","&#x3A9;":"\\Omega","&#x3C9;":"\\omega","&#x3A8;":"\\Psi","&#x3C8;":"\\psi","&#x3C7;":"\\chi","&#x3C6;":"\\varphi","&#x3A6;":"\\Phi","&#x3D5;":"\\phi","&#x3C5;":"\\upsilon","&#x3C4;":"\\tau","&#x3A3;":"\\Sigma","&#x3C3;":"\\sigma","&#x3C1;":"\\rho","&#x3A0;":"\\Pi","&#x3C0;":"\\pi","&#x39E;":"\\Xi","&#x3BE;":"\\xi","&#x3BD;":"\\nu","&#x3BC;":"\\mu","&#x39B;":"\\Lambda","&#x3BB;":"\\lambda","&#x3BA;":"\\kappa","&#x3B9;":"\\iota","&#x3D1;":"\\vartheta","&#x398;":"\\Theta","&#x3B8;":"\\theta","&#x3B7;":"\\eta","&#x3B6;":"\\zeta","&#x25B;":"\\varepsilon","&#x3B5;":"\\epsilon","&#x394;":"\\Delta","&#x3B4;":"\\delta","&#x393;":"\\Gamma","&#x3B3;":"\\gamma","&#x3B2;":"\\beta","&#x3B1;":"\\alpha","&#x221E;":"\\infty","‬":"\\text{\\textdir TRT}","‎":"\\text{\\textdir LTR}"}},8171:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByGlyph=void 0,t.allMathSymbolsByGlyph={" ":"\\textrm{ }","∃":"\\exists","∀":"\\forall","⇔":"\\iff","⇒":"\\Rightarrow","¬":"\\neg","□":"\\square","⋄":"\\diamond","△":"\\triangle","⌢":"\\frown","∠":"\\angle","⋱":"\\ddots","⋮":"\\vdots","∵":"\\because","∴":"\\therefore",ℵ:"\\aleph","∅":"\\emptyset","±":"\\pm","∇":"\\nabla","∂":"\\partial","∮":"\\oint","∫":"\\int","⋃":"\\cup","∪":"\\cup","⋂":"\\cap","∩":"\\cap","⋁":"\\vee","∨":"\\vee","⋀":"\\wedge","∧":"\\wedge","∏":"\\prod","∑":"\\sum","⊙":"\\bigodot","⊗":"\\bigoplus","⊕":"o+","∘":"@","⋈":"\\bowtie","⋊":"\\rtimes","⋉":"\\ltimes","÷":"\\div","×":"\\times","\\":"\\backslash","⋆":"\\star","∗":"\\star","⋅":"\\cdot",Ω:"\\Omega",ω:"\\omega",Ψ:"\\Psi",ψ:"\\psi",χ:"\\chi",φ:"\\varphi",Φ:"\\Phi",ϕ:"\\phi",υ:"\\upsilon",τ:"\\tau",Σ:"\\Sigma",σ:"\\sigma",ρ:"\\rho",Π:"\\Pi",π:"\\pi",Ξ:"\\Xi",ξ:"\\xi",ν:"\\nu",μ:"\\mu",Λ:"\\Lambda",λ:"\\lambda",κ:"\\kappa",ι:"\\iota",ϑ:"\\vartheta",Θ:"\\Theta",θ:"\\theta",η:"\\eta",ζ:"\\zeta",ɛ:"\\varepsilon",ε:"\\epsilon",Δ:"\\Delta",δ:"\\delta",Γ:"\\Gamma",γ:"\\gamma",β:"\\beta",α:"\\alpha","∞":"\\infty",ϵ:"\\epsilon",µ:"\\mu","²":"^{2}",ı:"\\imath","∎":"\\blacksquare",ม:"\\mathbf{m}",Ω:"\\Omega","⟲":"\\circlearrowleft","⟳":"\\circlearrowright",त:" ","¥":"\\yen","⁽":"^{(}","⁾":"^{)}",ß:"\\ss",Ћ:"\\hbar","⦵":"\\ominus","⊿":"\\bigtriangleup","↛'":"\\nrightarrow","†":"\\dagger",เ:"\\prime",白:" ","⿱":" ",ℸ:"\\wp",퓰:" ",ⁿ:"^{n}","✔":"\\checkmark","✗":"\\times","½":"\\dfrac{1}{2}",Ө:"\\theta","✓":"\\checkmark","⟩":"\\rangle","⟨":"\\langle","〈":"\\langle","¼":"\\dfrac{1}{4}","…":"\\ldots",ℏ:"\\hbar",ℜ:"\\mathfrak{R}",Ѳ:"\\theta",Ø:"\\emptyset",ϱ:"\\varrho",ф:"\\phi",T:"T","∙":"\\cdot",Ρ:"P",ᐁ:"\\nabla",ƞ:"\\eta",ɣ:"\\gamma",ћ:"\\hbar",Ɛ:"\\varepsilon",ⅅ:"\\_{D}",𝜆:"\\lambda","〗":"\\rangle","〖":"\\langle",";":";",𝑥:"x",𝑦:"y",𝑧:"z",𝑖:"i",𝑗:"j",𝑘:"k",𝑚:"m",𝑒:"e",𝑟:"r",ɳ:"\\eta",𝛽:"\\beta","⍵":"\\omega",℘:"\\wp",𝜋:"\\pi",Є:"\\epsilon",є:"\\epsilon",𝜀:"\\epsilon",п:"\\pi",Ν:"\\nu",ɵ:"\\theta",𝜓:"\\psi",ϴ:"\\theta",ɸ:"\\phi",Ӷ:"\\Gamma",ɭ:"\\ell",ʋ:"\\upsilon",𝛟:"\\varphi","⍬":"\\theta",Ф:"\\Phi",𝜑:"\\varphi",ⅈ:"i",ο:"o",ơ:"o",ƒ:"f","⍴":"\\rho","🇽":"x",𝑝:"p",𝑞:"q",𝑠:"s",𝑡:"t",𝑢:"u",𝑣:"v",𝑤:"w",𝑎:"a",𝑏:"b",𝑐:"c",𝑑:"d",𝑓:"f",𝑔:"g",𝑙:"l",𝑛:"n",𝑜:"o",𝔀:"w",𝚟:"v",ṁ:"m","൦":"\\circ","┴":"\\perp","✕":"\\times","∣":"\\mid",Փ:"\\Phi","⎜":"\\mid",ħ:"\\hbar",ፈ:" ","⦨":"\\llbracket",ế:"\\hat{e}","¢":"\\cent","⤹":"\\downarrow","⤸":"\\downarrow","⤷":"\\Rsh","⤶":"\\Lsh","⤵":"\\downarrow","⤴":"\\uparrow","⤳":"\\rightarrow","|":"\\mid","⎥":"\\mid","♥":"\\heartsuit",О:"0",Υ:"Y",х:"x",𝓏:"z",𝓎:"y",𝓍:"x",р:"p",а:"a","£":"\\pounds",m:"m",𝚵:"\\Xi","⓪":"\\textcircled{0}","①":"\\textcircled{1}","②":"\\textcircled{2}","③":"\\textcircled{3}","④":"\\textcircled{4}","⑤":"\\textcircled{5}","⑥":"\\textcircled{6}","⑦":"\\textcircled{7}","⑧":"\\textcircled{8}","⑨":"\\textcircled{9}","⑩":"\\textcircled{10}","⑪":"\\textcircled{11}","⑫":"\\textcircled{12}","⑬":"\\textcircled{13}","⑭":"\\textcircled{14}","⑮":"\\textcircled{15}","⑯":"\\textcircled{16}","⑰":"\\textcircled{17}","⑱":"\\textcircled{18}","⑲":"\\textcircled{19}","⑳":"\\textcircled{20}","㉑":"\\textcircled{21}","㉒":"\\textcircled{22}","㉓":"\\textcircled{23}","㉔":"\\textcircled{24}","㉕":"\\textcircled{25}","㉖":"\\textcircled{26}","㉗":"\\textcircled{27}","㉘":"\\textcircled{28}","㉙":"\\textcircled{29}","㉚":"\\textcircled{30}","㉛":"\\textcircled{31}","㉜":"\\textcircled{32}","㉝":"\\textcircled{33}","㉞":"\\textcircled{34}","㉟":"\\textcircled{35}","㊱":"\\textcircled{36}","㊲":"\\textcircled{37}","㊳":"\\textcircled{38}","㊴":"\\textcircled{39}","㊵":"\\textcircled{40}","㊶":"\\textcircled{41}","㊷":"\\textcircled{42}","㊸":"\\textcircled{43}","㊹":"\\textcircled{44}","㊺":"\\textcircled{45}","㊻":"\\textcircled{46}","㊼":"\\textcircled{47}","㊽":"\\textcircled{48}","㊾":"\\textcircled{49}","㊿":"\\textcircled{50}","&":"\\&","‖":"\\parallel","%":"\\%","“":"\\text{``}",$:"\\$","#":"\\#","℃":"\\text{\\textdegree C}","℉":"\\text{\\textdegree F}","█":"\\blacksquare","℧":"\\mho","⌋":"\\rfloor","⌊":"\\lfloor","⌉":"\\rceil","⌈":"\\lceil",ℇ:"\\varepsilon",ⅇ:"\\text{e}",ɼ:"r","↛":"\\nrightarrow",ˆ:"\\hat{}","‾":"\\overline","→":"\\rightarrow","‡":"\\ddagger","・":"\\cdot","▱":"\\square","∆":"\\Delta",ἱ:"i","∡":"\\angle",ϒ:"\\Upsilon","↓":"\\downarrow","↑":"\\uparrow","»":"\\gg","⊤":"\\top","⧸":"/",𝛿:"\\delta","˳":"\\cdot","։":":","⦪":"\\measuredangle","⦩":"\\measuredangle","⦫":"\\measuredangle","⦁":"\\cdot",ѳ:"\\theta","⦢":"\\measuredangle","¸":",","⎻":"\\overline","⟦":"\\llbracket",𝜙:"\\phi",П:"\\prod",о:"o","≈":"\\approx","≤":"\\leq",ђ:"\\hbar",Ʌ:"\\Lambda",土:"\\pm","⎼":"-",十:"+","≠":"\\neq","←":"\\leftarrow","।":"\\mid","€":"\\euro","˘":" ",ῡ:"\\bar{u}","∥":"\\parallel","↔":"\\leftrightarrow","√":"\\sqrt{}",ȼ:"c",𝞮:"\\epsilon","·":"\\cdot","⦬":"\\measuredangle","⦮":"\\measuredangle","⦭":"\\measuredangle","«":"\\ll",Χ:"\\mathsf{X}","│":"\\mid","〉":"\\rangle",ₙ:"_{n}","▫":"\\square","●":"\\circle","”":'\\"'}},5406:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(2965),t),n(r(9039),t),n(r(8249),t),n(r(8171),t),n(r(472),t),n(r(4320),t),n(r(6122),t)},472:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.latexAccents=void 0,t.latexAccents=["\\hat","\\bar","\\underbrace","\\overbrace"]},4320:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathNumberByGlyph=void 0,t.mathNumberByGlyph={"₀":"_{0}","₁":"_{1}","₂":"_{2}","₃":"_{3}","₄":"_{4}","₅":"_{5}","₆":"_{6}","₇":"_{7}","₈":"_{8}","₉":"_{9}","⁰":"^{0}","¹":"^{1}","²":"^{2}","³":"^{3}","⁴":"^{4}","⁵":"^{5}","⁶":"^{6}","⁷":"^{7}","⁸":"^{8}","⁹":"^{9}",ⁿ:"^{n}",ₙ:"_{n}","⓪":"\\textcircled{0}","①":"\\textcircled{1}","②":"\\textcircled{2}","③":"\\textcircled{3}","④":"\\textcircled{4}","⑤":"\\textcircled{5}","⑥":"\\textcircled{6}","⑦":"\\textcircled{7}","⑧":"\\textcircled{8}","⑨":"\\textcircled{9}","⑩":"\\textcircled{10}","⑪":"\\textcircled{11}","⑫":"\\textcircled{12}","⑬":"\\textcircled{13}","⑭":"\\textcircled{14}","⑮":"\\textcircled{15}","⑯":"\\textcircled{16}","⑰":"\\textcircled{17}","⑱":"\\textcircled{18}","⑲":"\\textcircled{19}","⑳":"\\textcircled{20}","㉑":"\\textcircled{21}","㉒":"\\textcircled{22}","㉓":"\\textcircled{23}","㉔":"\\textcircled{24}","㉕":"\\textcircled{25}","㉖":"\\textcircled{26}","㉗":"\\textcircled{27}","㉘":"\\textcircled{28}","㉙":"\\textcircled{29}","㉚":"\\textcircled{30}","㉛":"\\textcircled{31}","㉜":"\\textcircled{32}","㉝":"\\textcircled{33}","㉞":"\\textcircled{34}","㉟":"\\textcircled{35}","㊱":"\\textcircled{36}","㊲":"\\textcircled{37}","㊳":"\\textcircled{38}","㊴":"\\textcircled{39}","㊵":"\\textcircled{40}","㊶":"\\textcircled{41}","㊷":"\\textcircled{42}","㊸":"\\textcircled{43}","㊹":"\\textcircled{44}","㊺":"\\textcircled{45}","㊻":"\\textcircled{46}","㊼":"\\textcircled{47}","㊽":"\\textcircled{48}","㊾":"\\textcircled{49}","㊿":"\\textcircled{50}","½":"\\dfrac{1}{2}","⅓":"\\dfrac{1}{3}","⅔":"\\dfrac{2}{3}","¼":"\\dfrac{1}{4}","¾":"\\dfrac{3}{4}","⅕":"\\dfrac{1}{5}","⅖":"\\dfrac{2}{5}","⅗":"\\dfrac{3}{5}","⅘":"\\dfrac{4}{5}","⅙":"\\dfrac{1}{6}","⅚":"\\dfrac{5}{6}","⅐":"\\dfrac{1}{7}","⅛":"\\dfrac{1}{8}","⅜":"\\dfrac{3}{8}","⅝":"\\dfrac{5}{8}","⅞":"\\dfrac{7}{8}","⅑":"\\dfrac{1}{9}","⅒":"\\dfrac{1}{10}"}},6122:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HashUTF8ToLtXConverter=void 0,t.HashUTF8ToLtXConverter=class{convert(e){if(e.match(/[a-z0-9]/i))return e;const t=r[e];if(t){return this.convertAccentCharToLtX(t)||e}return this.convertSpecialCharToLtX(e)||e}convertAccentCharToLtX(e){const{char:t,accent:r}=e,n=a[r];return n?`\\${n}{${t}}`:null}convertSpecialCharToLtX(e){const t=n[e];if(!t)return null;const{letter:r,fontCmd:a}=t;return`\\${a}{${r}}`}};const r={á:{char:"a",accent:"´"},à:{char:"a",accent:"`"},â:{char:"a",accent:"^"},ã:{char:"a",accent:"~"},ä:{char:"a",accent:"¨"},å:{char:"a",accent:"˚"},ą:{char:"a",accent:"˙"},ă:{char:"a",accent:"˘"},ǎ:{char:"a",accent:"ˇ"},ǟ:{char:"a",accent:"ˆ"},ǻ:{char:"a",accent:"˙"},ǡ:{char:"a",accent:"-"},ā:{char:"a",accent:"-"},é:{char:"e",accent:"´"},è:{char:"e",accent:"`"},ê:{char:"e",accent:"^"},ë:{char:"e",accent:"¨"},ę:{char:"e",accent:"˙"},ě:{char:"e",accent:"ˇ"},ȇ:{char:"i",accent:"^"},ё:{char:"e",accent:"¨"},ē:{char:"e",accent:"-"},í:{char:"i",accent:"´"},ì:{char:"i",accent:"`"},î:{char:"i",accent:"^"},ï:{char:"i",accent:"¨"},į:{char:"i",accent:"˙"},ǐ:{char:"i",accent:"ˇ"},ȉ:{char:"i",accent:"`"},ȋ:{char:"i",accent:"¨"},ī:{char:"i",accent:"-"},ó:{char:"o",accent:"´"},ò:{char:"o",accent:"`"},ô:{char:"o",accent:"^"},õ:{char:"o",accent:"~"},ö:{char:"o",accent:"¨"},ő:{char:"o",accent:"˝"},ǒ:{char:"o",accent:"ˇ"},ȍ:{char:"o",accent:"`"},ȏ:{char:"o",accent:"¨"},ȫ:{char:"o",accent:"˘"},ȭ:{char:"o",accent:"˝"},ȯ:{char:"o",accent:"˙"},ō:{char:"o",accent:"-"},ú:{char:"u",accent:"´"},ù:{char:"u",accent:"`"},û:{char:"u",accent:"^"},ü:{char:"u",accent:"¨"},ű:{char:"u",accent:"˝"},ǔ:{char:"u",accent:"ˇ"},ǖ:{char:"u",accent:"¨"},ǘ:{char:"u",accent:"¨"},ǚ:{char:"u",accent:"¨"},ǜ:{char:"u",accent:"¨"},ȕ:{char:"u",accent:"`"},ȗ:{char:"u",accent:"¨"},ū:{char:"u",accent:"-"},ý:{char:"y",accent:"´"},ỳ:{char:"y",accent:"`"},ŷ:{char:"y",accent:"^"},ÿ:{char:"y",accent:"¨"},ȳ:{char:"y",accent:"-"},Á:{char:"A",accent:"´"},À:{char:"A",accent:"`"},Â:{char:"A",accent:"^"},Ã:{char:"A",accent:"~"},Ä:{char:"A",accent:"¨"},Å:{char:"A",accent:"˚"},Å:{char:"A",accent:"˚"},Ȧ:{char:"A",accent:"˙"},Ă:{char:"A",accent:"˘"},Ǎ:{char:"A",accent:"ˇ"},Ǟ:{char:"A",accent:"˝"},Ǻ:{char:"A",accent:"˚"},Ǡ:{char:"A",accent:"-"},Ā:{char:"A",accent:"-"},É:{char:"E",accent:"´"},È:{char:"E",accent:"`"},Ė:{char:"E",accent:"˙"},Ê:{char:"E",accent:"^"},Ë:{char:"E",accent:"¨"},Ě:{char:"E",accent:"ˇ"},Ȅ:{char:"E",accent:"`"},Ȇ:{char:"E",accent:"¨"},Ē:{char:"E",accent:"-"},Í:{char:"I",accent:"´"},Ì:{char:"I",accent:"`"},Î:{char:"I",accent:"^"},Ï:{char:"I",accent:"¨"},Ĭ:{char:"I",accent:"˘"},Ǐ:{char:"I",accent:"ˇ"},Ȉ:{char:"I",accent:"`"},Ȋ:{char:"I",accent:"¨"},Ī:{char:"I",accent:"-"},Ó:{char:"O",accent:"´"},Ò:{char:"O",accent:"`"},Ô:{char:"O",accent:"^"},Õ:{char:"O",accent:"~"},Ö:{char:"O",accent:"¨"},Ő:{char:"O",accent:"˝"},Ǒ:{char:"O",accent:"ˇ"},Ȍ:{char:"O",accent:"`"},Ȏ:{char:"O",accent:"¨"},Ȫ:{char:"O",accent:"˘"},Ȭ:{char:"O",accent:"˝"},Ȯ:{char:"O",accent:"˙"},Ō:{char:"O",accent:"-"},Ú:{char:"U",accent:"´"},Ù:{char:"U",accent:"`"},Û:{char:"U",accent:"^"},Ü:{char:"U",accent:"¨"},Ű:{char:"U",accent:"˝"},Ǔ:{char:"U",accent:"ˇ"},Ǖ:{char:"U",accent:"¨"},Ȕ:{char:"U",accent:"`"},Ȗ:{char:"U",accent:"¨"},Ū:{char:"U",accent:"-"},Ý:{char:"Y",accent:"´"},Ỳ:{char:"Y",accent:"`"},Ŷ:{char:"Y",accent:"^"},Ÿ:{char:"Y",accent:"¨"},Ȳ:{char:"Y",accent:"-"},ñ:{char:"n",accent:"~"},Ñ:{char:"N",accent:"~"},ç:{char:"c",accent:"˙"},Ç:{char:"C",accent:"˙"},ṽ:{char:"v",accent:"~"},Ṽ:{char:"V",accent:"~"},ĵ:{char:"j",accent:"^"},Ĵ:{char:"J",accent:"^"},ź:{char:"z",accent:"´"},Ź:{char:"Z",accent:"´"},Ż:{char:"Z",accent:"^"},ż:{char:"z",accent:"^"},Ž:{char:"Z",accent:"ˇ"},ž:{char:"z",accent:"ˇ"},ẑ:{char:"z",accent:"ˆ"}},a={"´":"grave","`":"acute","^":"hat","~":"tilde","¨":"ddot","˚":"mathring","˘":"breve",ˇ:"check","˝":"ddot","˙":"dot","-":"bar",ˆ:"hat","˜":"tilde"},n={𝐀:{letter:"A",fontCmd:"mathbf"},𝐁:{letter:"B",fontCmd:"mathbf"},𝐂:{letter:"C",fontCmd:"mathbf"},𝐃:{letter:"D",fontCmd:"mathbf"},𝐄:{letter:"E",fontCmd:"mathbf"},Ε:{letter:"E",fontCmd:"mathbf"},𝐅:{letter:"F",fontCmd:"mathbf"},𝐆:{letter:"G",fontCmd:"mathbf"},𝐇:{letter:"H",fontCmd:"mathbf"},𝐈:{letter:"I",fontCmd:"mathbf"},𝐉:{letter:"J",fontCmd:"mathbf"},𝐊:{letter:"K",fontCmd:"mathbf"},𝐋:{letter:"L",fontCmd:"mathbf"},𝐌:{letter:"M",fontCmd:"mathbf"},𝐍:{letter:"N",fontCmd:"mathbf"},𝐎:{letter:"O",fontCmd:"mathbf"},𝐏:{letter:"P",fontCmd:"mathbf"},𝐐:{letter:"Q",fontCmd:"mathbf"},𝐑:{letter:"R",fontCmd:"mathbf"},𝐒:{letter:"S",fontCmd:"mathbf"},𝐓:{letter:"T",fontCmd:"mathbf"},𝐔:{letter:"U",fontCmd:"mathbf"},𝐕:{letter:"V",fontCmd:"mathbf"},𝐖:{letter:"W",fontCmd:"mathbf"},𝐗:{letter:"X",fontCmd:"mathbf"},𝞆:{letter:"X",fontCmd:"mathbf"},𝐘:{letter:"Y",fontCmd:"mathbf"},𝐙:{letter:"Z",fontCmd:"mathbf"},"𝟎":{letter:"0",fontCmd:"mathbf"},"𝟏":{letter:"1",fontCmd:"mathbf"},"𝟐":{letter:"2",fontCmd:"mathbf"},"𝟑":{letter:"3",fontCmd:"mathbf"},"𝟒":{letter:"4",fontCmd:"mathbf"},"𝟓":{letter:"5",fontCmd:"mathbf"},"𝟔":{letter:"6",fontCmd:"mathbf"},"𝟕":{letter:"7",fontCmd:"mathbf"},"𝟖":{letter:"8",fontCmd:"mathbf"},"𝟗":{letter:"9",fontCmd:"mathbf"},𝐴:{letter:"A",fontCmd:"mathit"},𝐵:{letter:"B",fontCmd:"mathit"},𝐶:{letter:"C",fontCmd:"mathit"},𝐷:{letter:"D",fontCmd:"mathit"},𝐸:{letter:"E",fontCmd:"mathit"},𝐹:{letter:"F",fontCmd:"mathit"},𝐺:{letter:"G",fontCmd:"mathit"},𝐻:{letter:"H",fontCmd:"mathit"},𝐼:{letter:"I",fontCmd:"mathit"},Ι:{letter:"I",fontCmd:"mathit"},𝐽:{letter:"J",fontCmd:"mathit"},𝐾:{letter:"K",fontCmd:"mathit"},𝐿:{letter:"L",fontCmd:"mathit"},𝑀:{letter:"M",fontCmd:"mathit"},𝑁:{letter:"N",fontCmd:"mathit"},𝑂:{letter:"O",fontCmd:"mathit"},𝑃:{letter:"P",fontCmd:"mathit"},𝑄:{letter:"Q",fontCmd:"mathit"},𝑅:{letter:"R",fontCmd:"mathit"},𝑆:{letter:"S",fontCmd:"mathit"},𝑇:{letter:"T",fontCmd:"mathit"},𝑈:{letter:"U",fontCmd:"mathit"},𝑉:{letter:"V",fontCmd:"mathit"},𝑊:{letter:"W",fontCmd:"mathit"},𝑋:{letter:"X",fontCmd:"mathit"},𝑌:{letter:"Y",fontCmd:"mathit"},𝑍:{letter:"Z",fontCmd:"mathit"},𝔸:{letter:"A",fontCmd:"mathbb"},𝔹:{letter:"B",fontCmd:"mathbb"},ℂ:{letter:"C",fontCmd:"mathbb"},𝔻:{letter:"D",fontCmd:"mathbb"},𝔼:{letter:"E",fontCmd:"mathbb"},𝔽:{letter:"F",fontCmd:"mathbb"},𝔾:{letter:"G",fontCmd:"mathbb"},ℍ:{letter:"H",fontCmd:"mathbb"},𝕀:{letter:"I",fontCmd:"mathbb"},𝕁:{letter:"J",fontCmd:"mathbb"},𝕂:{letter:"K",fontCmd:"mathbb"},𝕃:{letter:"L",fontCmd:"mathbb"},𝕄:{letter:"M",fontCmd:"mathbb"},ℕ:{letter:"N",fontCmd:"mathbb"},𝕆:{letter:"O",fontCmd:"mathbb"},ℙ:{letter:"P",fontCmd:"mathbb"},ℚ:{letter:"Q",fontCmd:"mathbb"},ℝ:{letter:"R",fontCmd:"mathbb"},𝕊:{letter:"S",fontCmd:"mathbb"},𝕋:{letter:"T",fontCmd:"mathbb"},𝕌:{letter:"U",fontCmd:"mathbb"},𝕍:{letter:"V",fontCmd:"mathbb"},𝕎:{letter:"W",fontCmd:"mathbb"},𝕏:{letter:"X",fontCmd:"mathbb"},𝕐:{letter:"Y",fontCmd:"mathbb"},ℤ:{letter:"Z",fontCmd:"mathbb"},"𝟘":{letter:"0",fontCmd:"mathbb"},"𝟙":{letter:"1",fontCmd:"mathbb"},"𝟚":{letter:"2",fontCmd:"mathbb"},"𝟛":{letter:"3",fontCmd:"mathbb"},"𝟜":{letter:"4",fontCmd:"mathbb"},"𝟝":{letter:"5",fontCmd:"mathbb"},"𝟞":{letter:"6",fontCmd:"mathbb"},"𝟟":{letter:"7",fontCmd:"mathbb"},"𝟠":{letter:"8",fontCmd:"mathbb"},"𝟡":{letter:"9",fontCmd:"mathbb"},𝒜:{letter:"A",fontCmd:"mathcal"},𝓐:{letter:"A",fontCmd:"mathcal"},ℬ:{letter:"B",fontCmd:"mathcal"},𝒞:{letter:"C",fontCmd:"mathcal"},𝒟:{letter:"D",fontCmd:"mathcal"},𝓓:{letter:"D",fontCmd:"mathcal"},ℰ:{letter:"E",fontCmd:"mathcal"},ℱ:{letter:"F",fontCmd:"mathcal"},𝓕:{letter:"F",fontCmd:"mathcal"},𝒢:{letter:"G",fontCmd:"mathcal"},ℋ:{letter:"H",fontCmd:"mathcal"},ℐ:{letter:"I",fontCmd:"mathcal"},𝒥:{letter:"J",fontCmd:"mathcal"},𝒦:{letter:"K",fontCmd:"mathcal"},ℒ:{letter:"L",fontCmd:"mathcal"},𝓛:{letter:"L",fontCmd:"mathcal"},ℳ:{letter:"M",fontCmd:"mathcal"},𝒩:{letter:"N",fontCmd:"mathcal"},𝒪:{letter:"O",fontCmd:"mathcal"},𝓞:{letter:"O",fontCmd:"mathcal"},𝒫:{letter:"P",fontCmd:"mathcal"},𝒬:{letter:"Q",fontCmd:"mathcal"},ℛ:{letter:"R",fontCmd:"mathcal"},𝕽:{letter:"R",fontCmd:"mathcal"},"℟":{letter:"R",fontCmd:"mathcal"},𝒮:{letter:"S",fontCmd:"mathcal"},𝒯:{letter:"T",fontCmd:"mathcal"},𝒰:{letter:"U",fontCmd:"mathcal"},𝒱:{letter:"V",fontCmd:"mathcal"},𝒲:{letter:"W",fontCmd:"mathcal"},𝒳:{letter:"X",fontCmd:"mathcal"},𝒴:{letter:"Y",fontCmd:"mathcal"},𝒵:{letter:"Z",fontCmd:"mathcal"},𝔄:{letter:"A",fontCmd:"mathfrak"},𝔅:{letter:"B",fontCmd:"mathfrak"},ℭ:{letter:"C",fontCmd:"mathfrak"},𝔇:{letter:"D",fontCmd:"mathfrak"},𝔈:{letter:"E",fontCmd:"mathfrak"},𝔉:{letter:"F",fontCmd:"mathfrak"},𝔊:{letter:"G",fontCmd:"mathfrak"},ℌ:{letter:"H",fontCmd:"mathfrak"},ℑ:{letter:"I",fontCmd:"mathfrak"},𝔍:{letter:"J",fontCmd:"mathfrak"},𝔎:{letter:"K",fontCmd:"mathfrak"},𝔏:{letter:"L",fontCmd:"mathfrak"},𝔐:{letter:"M",fontCmd:"mathfrak"},𝔑:{letter:"N",fontCmd:"mathfrak"},𝔒:{letter:"O",fontCmd:"mathfrak"},𝔓:{letter:"P",fontCmd:"mathfrak"},𝔔:{letter:"Q",fontCmd:"mathfrak"},ℜ:{letter:"R",fontCmd:"mathfrak"},𝔖:{letter:"S",fontCmd:"mathfrak"},𝔗:{letter:"T",fontCmd:"mathfrak"},𝔘:{letter:"U",fontCmd:"mathfrak"},𝔙:{letter:"V",fontCmd:"mathfrak"},𝔚:{letter:"W",fontCmd:"mathfrak"},𝔛:{letter:"X",fontCmd:"mathfrak"},𝔜:{letter:"Y",fontCmd:"mathfrak"},ℨ:{letter:"Z",fontCmd:"mathfrak"},𝖠:{letter:"A",fontCmd:"mathsf"},Α:{letter:"A",fontCmd:"mathsf"},𝖡:{letter:"B",fontCmd:"mathsf"},Β:{letter:"B",fontCmd:"mathsf"},𝖢:{letter:"C",fontCmd:"mathsf"},𝖣:{letter:"D",fontCmd:"mathsf"},𝖤:{letter:"E",fontCmd:"mathsf"},𝖥:{letter:"F",fontCmd:"mathsf"},𝖦:{letter:"G",fontCmd:"mathsf"},𝖧:{letter:"H",fontCmd:"mathsf"},𝖨:{letter:"I",fontCmd:"mathsf"},𝖩:{letter:"J",fontCmd:"mathsf"},ȷ:{letter:"J",fontCmd:"mathsf"},𝖪:{letter:"K",fontCmd:"mathsf"},Κ:{letter:"K",fontCmd:"mathsf"},𝖫:{letter:"L",fontCmd:"mathsf"},𝖬:{letter:"M",fontCmd:"mathsf"},𝖭:{letter:"N",fontCmd:"mathsf"},𝖮:{letter:"O",fontCmd:"mathsf"},𝖯:{letter:"P",fontCmd:"mathsf"},𝖰:{letter:"Q",fontCmd:"mathsf"},𝖱:{letter:"R",fontCmd:"mathsf"},𝖲:{letter:"S",fontCmd:"mathsf"},𝖳:{letter:"T",fontCmd:"mathsf"},𝖴:{letter:"U",fontCmd:"mathsf"},𝖵:{letter:"V",fontCmd:"mathsf"},𝖶:{letter:"W",fontCmd:"mathsf"},𝖷:{letter:"X",fontCmd:"mathsf"},Χ:{letter:"X",fontCmd:"mathsf"},𝖸:{letter:"Y",fontCmd:"mathsf"},𝖹:{letter:"Z",fontCmd:"mathsf"},𝚨:{letter:"A",fontCmd:"mathtt"},𝚩:{letter:"B",fontCmd:"mathtt"},𝚪:{letter:"\\Gamma",fontCmd:"mathtt"},𝚫:{letter:"\\Delta",fontCmd:"mathtt"},𝚬:{letter:"E",fontCmd:"mathtt"},𝚭:{letter:"F",fontCmd:"mathtt"},𝚮:{letter:"G",fontCmd:"mathtt"},𝚯:{letter:"\\Theta",fontCmd:"mathtt"},𝚰:{letter:"I",fontCmd:"mathtt"},𝚱:{letter:"J",fontCmd:"mathtt"},𝚲:{letter:"\\Lambda",fontCmd:"mathtt"},𝚳:{letter:"L",fontCmd:"mathtt"},𝚴:{letter:"M",fontCmd:"mathtt"},𝚵:{letter:"\\Pi",fontCmd:"mathtt"},𝚶:{letter:"O",fontCmd:"mathtt"},𝚷:{letter:"\\Pi",fontCmd:"mathtt"},𝚸:{letter:"Q",fontCmd:"mathtt"},𝚹:{letter:"R",fontCmd:"mathtt"},𝚺:{letter:"S",fontCmd:"mathtt"},𝚻:{letter:"T",fontCmd:"mathtt"},𝚼:{letter:"U",fontCmd:"mathtt"},𝚽:{letter:"\\Phi",fontCmd:"mathtt"},𝚾:{letter:"W",fontCmd:"mathtt"},𝚿:{letter:"\\Psi",fontCmd:"mathtt"},𝛀:{letter:"\\Omega",fontCmd:"mathtt"}}}},t={};function r(a){var n=t[a];if(void 0!==n)return n.exports;var o=t[a]={exports:{}};return e[a].call(o.exports,o,o.exports,r),o.exports}var a={};return(()=>{"use strict";var e=a;Object.defineProperty(e,"__esModule",{value:!0}),e.MathMLToLaTeX=void 0;var t=r(8672);Object.defineProperty(e,"MathMLToLaTeX",{enumerable:!0,get:function(){return t.MathMLToLaTeX}})})(),a})()));
//# sourceMappingURL=bundle.min.js.map

/***/ }),

/***/ 608:
/*!*************************!*\
  !*** ./src/metadata.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetadataExtractor = void 0;
class MetadataExtractor {
    static extract(doc, schemaOrgData) {
        var _a, _b;
        let domain = '';
        let url = '';
        try {
            // Try to get URL from document location
            url = ((_a = doc.location) === null || _a === void 0 ? void 0 : _a.href) || '';
            // If no URL from location, try other sources
            if (!url) {
                url = this.getMetaContent(doc, "property", "og:url") ||
                    this.getMetaContent(doc, "property", "twitter:url") ||
                    this.getSchemaProperty(doc, schemaOrgData, 'url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntityOfPage.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntity.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'WebSite.url') ||
                    ((_b = doc.querySelector('link[rel="canonical"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('href')) || '';
            }
            if (url) {
                domain = new URL(url).hostname.replace(/^www\./, '');
            }
        }
        catch (e) {
            // If URL parsing fails, try to get from base tag
            const baseTag = doc.querySelector('base[href]');
            if (baseTag) {
                try {
                    url = baseTag.getAttribute('href') || '';
                    domain = new URL(url).hostname.replace(/^www\./, '');
                }
                catch (e) {
                    console.warn('Failed to parse base URL:', e);
                }
            }
        }
        return {
            title: this.getTitle(doc, schemaOrgData),
            description: this.getDescription(doc, schemaOrgData),
            domain,
            favicon: this.getFavicon(doc, url),
            image: this.getImage(doc, schemaOrgData),
            published: this.getPublished(doc, schemaOrgData),
            author: this.getAuthor(doc, schemaOrgData),
            site: this.getSite(doc, schemaOrgData),
            schemaOrgData,
            wordCount: 0,
            parseTime: 0
        };
    }
    static getAuthor(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "sailthru.author") ||
            this.getSchemaProperty(doc, schemaOrgData, 'author.name') ||
            this.getMetaContent(doc, "property", "author") ||
            this.getMetaContent(doc, "name", "byl") ||
            this.getMetaContent(doc, "name", "author") ||
            this.getMetaContent(doc, "name", "authorList") ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "twitter:creator") ||
            this.getMetaContent(doc, "name", "application-name") ||
            '');
    }
    static getSite(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'WebSite.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "application-name") ||
            this.getAuthor(doc, schemaOrgData) ||
            '');
    }
    static getTitle(doc, schemaOrgData) {
        var _a, _b;
        const rawTitle = (this.getMetaContent(doc, "property", "og:title") ||
            this.getMetaContent(doc, "name", "twitter:title") ||
            this.getSchemaProperty(doc, schemaOrgData, 'headline') ||
            this.getMetaContent(doc, "name", "title") ||
            this.getMetaContent(doc, "name", "sailthru.title") ||
            ((_b = (_a = doc.querySelector('title')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) ||
            '');
        return this.cleanTitle(rawTitle, this.getSite(doc, schemaOrgData));
    }
    static cleanTitle(title, siteName) {
        if (!title || !siteName)
            return title;
        // Remove site name if it exists
        const siteNameEscaped = siteName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const patterns = [
            `\\s*[\\|\\-–—]\\s*${siteNameEscaped}\\s*$`, // Title | Site Name
            `^\\s*${siteNameEscaped}\\s*[\\|\\-–—]\\s*`, // Site Name | Title
        ];
        for (const pattern of patterns) {
            const regex = new RegExp(pattern, 'i');
            if (regex.test(title)) {
                title = title.replace(regex, '');
                break;
            }
        }
        return title.trim();
    }
    static getDescription(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "description") ||
            this.getMetaContent(doc, "property", "description") ||
            this.getMetaContent(doc, "property", "og:description") ||
            this.getSchemaProperty(doc, schemaOrgData, 'description') ||
            this.getMetaContent(doc, "name", "twitter:description") ||
            this.getMetaContent(doc, "name", "sailthru.description") ||
            '');
    }
    static getImage(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "property", "og:image") ||
            this.getMetaContent(doc, "name", "twitter:image") ||
            this.getSchemaProperty(doc, schemaOrgData, 'image.url') ||
            this.getMetaContent(doc, "name", "sailthru.image.full") ||
            '');
    }
    static getFavicon(doc, baseUrl) {
        var _a, _b;
        const iconFromMeta = this.getMetaContent(doc, "property", "og:image:favicon");
        if (iconFromMeta)
            return iconFromMeta;
        const iconLink = (_a = doc.querySelector("link[rel='icon']")) === null || _a === void 0 ? void 0 : _a.getAttribute("href");
        if (iconLink)
            return iconLink;
        const shortcutLink = (_b = doc.querySelector("link[rel='shortcut icon']")) === null || _b === void 0 ? void 0 : _b.getAttribute("href");
        if (shortcutLink)
            return shortcutLink;
        // Only try to construct favicon URL if we have a valid base URL
        if (baseUrl) {
            try {
                return new URL("/favicon.ico", baseUrl).href;
            }
            catch (e) {
                console.warn('Failed to construct favicon URL:', e);
            }
        }
        return '';
    }
    static getPublished(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'datePublished') ||
            this.getMetaContent(doc, "name", "publishDate") ||
            this.getMetaContent(doc, "property", "article:published_time") ||
            this.getTimeElement(doc) ||
            this.getMetaContent(doc, "name", "sailthru.date") ||
            '');
    }
    static getMetaContent(doc, attr, value) {
        var _a, _b;
        const selector = `meta[${attr}]`;
        const element = Array.from(doc.querySelectorAll(selector))
            .find(el => { var _a; return ((_a = el.getAttribute(attr)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === value.toLowerCase(); });
        const content = element ? (_b = (_a = element.getAttribute("content")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : "" : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static getTimeElement(doc) {
        var _a, _b, _c, _d;
        const selector = `time`;
        const element = Array.from(doc.querySelectorAll(selector))[0];
        const content = element ? ((_d = (_b = (_a = element.getAttribute("datetime")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.trim()) !== null && _d !== void 0 ? _d : "") : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static decodeHTMLEntities(text, doc) {
        const textarea = doc.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }
    static getSchemaProperty(doc, schemaOrgData, property, defaultValue = '') {
        if (!schemaOrgData)
            return defaultValue;
        const searchSchema = (data, props, fullPath, isExactMatch = true) => {
            if (typeof data === 'string') {
                return props.length === 0 ? [data] : [];
            }
            if (!data || typeof data !== 'object') {
                return [];
            }
            if (Array.isArray(data)) {
                const currentProp = props[0];
                if (/^\[\d+\]$/.test(currentProp)) {
                    const index = parseInt(currentProp.slice(1, -1));
                    if (data[index]) {
                        return searchSchema(data[index], props.slice(1), fullPath, isExactMatch);
                    }
                    return [];
                }
                if (props.length === 0 && data.every(item => typeof item === 'string' || typeof item === 'number')) {
                    return data.map(String);
                }
                return data.flatMap(item => searchSchema(item, props, fullPath, isExactMatch));
            }
            const [currentProp, ...remainingProps] = props;
            if (!currentProp) {
                if (typeof data === 'string')
                    return [data];
                if (typeof data === 'object' && data.name) {
                    return [data.name];
                }
                return [];
            }
            if (data.hasOwnProperty(currentProp)) {
                return searchSchema(data[currentProp], remainingProps, fullPath ? `${fullPath}.${currentProp}` : currentProp, true);
            }
            if (!isExactMatch) {
                const nestedResults = [];
                for (const key in data) {
                    if (typeof data[key] === 'object') {
                        const results = searchSchema(data[key], props, fullPath ? `${fullPath}.${key}` : key, false);
                        nestedResults.push(...results);
                    }
                }
                if (nestedResults.length > 0) {
                    return nestedResults;
                }
            }
            return [];
        };
        try {
            let results = searchSchema(schemaOrgData, property.split('.'), '', true);
            if (results.length === 0) {
                results = searchSchema(schemaOrgData, property.split('.'), '', false);
            }
            const result = results.length > 0 ? results.filter(Boolean).join(', ') : defaultValue;
            return this.decodeHTMLEntities(result, doc);
        }
        catch (error) {
            console.error(`Error in getSchemaProperty for ${property}:`, error);
            return defaultValue;
        }
    }
    static extractSchemaOrgData(doc) {
        const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
        const schemaData = [];
        schemaScripts.forEach(script => {
            let jsonContent = script.textContent || '';
            try {
                jsonContent = jsonContent
                    .replace(/\/\*[\s\S]*?\*\/|^\s*\/\/.*$/gm, '')
                    .replace(/^\s*<!\[CDATA\[([\s\S]*?)\]\]>\s*$/, '$1')
                    .replace(/^\s*(\*\/|\/\*)\s*|\s*(\*\/|\/\*)\s*$/g, '')
                    .trim();
                const jsonData = JSON.parse(jsonContent);
                if (jsonData['@graph'] && Array.isArray(jsonData['@graph'])) {
                    schemaData.push(...jsonData['@graph']);
                }
                else {
                    schemaData.push(jsonData);
                }
            }
            catch (error) {
                console.error('Error parsing schema.org data:', error);
                console.error('Problematic JSON content:', jsonContent);
            }
        });
        return schemaData;
    }
}
exports.MetadataExtractor = MetadataExtractor;


/***/ }),

/***/ 628:
/*!*************************!*\
  !*** ./src/defuddle.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
const metadata_1 = __webpack_require__(/*! ./metadata */ 608);
const constants_1 = __webpack_require__(/*! ./constants */ 640);
const math_1 = __webpack_require__(/*! ./math */ 315);
const ELEMENT_STANDARDIZATION_RULES = [
    // Math elements
    ...math_1.mathStandardizationRules,
    // Code blocks
    {
        selector: 'pre',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Function to get language from class
            const getLanguageFromClass = (element) => {
                // Check data-lang attribute first
                const dataLang = element.getAttribute('data-lang');
                if (dataLang) {
                    return dataLang.toLowerCase();
                }
                // Define language patterns
                const languagePatterns = [
                    /^language-(\w+)$/, // language-javascript
                    /^lang-(\w+)$/, // lang-javascript
                    /^(\w+)-code$/, // javascript-code
                    /^code-(\w+)$/, // code-javascript
                    /^syntax-(\w+)$/, // syntax-javascript
                    /^code-snippet__(\w+)$/, // code-snippet__javascript
                    /^highlight-(\w+)$/, // highlight-javascript
                    /^(\w+)-snippet$/ // javascript-snippet
                ];
                // Then check the class attribute for patterns
                if (element.className && typeof element.className === 'string') {
                    for (const pattern of languagePatterns) {
                        const match = element.className.toLowerCase().match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                    // Then check for supported language
                    if (constants_1.SUPPORTED_LANGUAGES.has(element.className.toLowerCase())) {
                        return element.className.toLowerCase();
                    }
                }
                const classNames = Array.from(element.classList);
                for (const className of classNames) {
                    // Check patterns first
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                }
                // Only check bare language names if no patterns were found
                for (const className of classNames) {
                    if (constants_1.SUPPORTED_LANGUAGES.has(className.toLowerCase())) {
                        return className.toLowerCase();
                    }
                }
                return '';
            };
            // Try to get the language from the element and its ancestors
            let language = '';
            let currentElement = el;
            while (currentElement && !language) {
                language = getLanguageFromClass(currentElement);
                // Also check for code elements within the current element
                if (!language && currentElement.querySelector('code')) {
                    language = getLanguageFromClass(currentElement.querySelector('code'));
                }
                currentElement = currentElement.parentElement;
            }
            // Function to recursively extract text content while preserving structure
            const extractStructuredText = (element) => {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent || '';
                }
                let text = '';
                if (element instanceof HTMLElement) {
                    // Handle line breaks
                    if (element.tagName === 'BR') {
                        return '\n';
                    }
                    // Handle code elements and their children
                    element.childNodes.forEach(child => {
                        text += extractStructuredText(child);
                    });
                    // Add newline after each code element
                    if (element.tagName === 'CODE') {
                        text += '\n';
                    }
                }
                return text;
            };
            // Extract all text content
            let codeContent = extractStructuredText(el);
            // Clean up the content
            codeContent = codeContent
                // Remove any extra newlines at the start
                .replace(/^\n+/, '')
                // Remove any extra newlines at the end
                .replace(/\n+$/, '')
                // Replace multiple consecutive newlines with a single newline
                .replace(/\n{3,}/g, '\n\n');
            // Create new pre element
            const newPre = document.createElement('pre');
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    newPre.setAttribute(attr.name, attr.value);
                }
            });
            // Create code element
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    },
    // Simplify headings by removing internal navigation elements
    {
        selector: 'h1, h2, h3, h4, h5, h6',
        element: 'keep',
        transform: (el) => {
            var _a, _b, _c, _d, _e;
            // If heading only contains a single anchor with internal link
            if (el.children.length === 1 &&
                ((_a = el.firstElementChild) === null || _a === void 0 ? void 0 : _a.tagName) === 'A' &&
                (((_b = el.firstElementChild.getAttribute('href')) === null || _b === void 0 ? void 0 : _b.includes('#')) ||
                    ((_c = el.firstElementChild.getAttribute('href')) === null || _c === void 0 ? void 0 : _c.startsWith('#')))) {
                // Create new heading of same level
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes from original heading
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                return newHeading;
            }
            // If heading contains navigation buttons or other utility elements
            const buttons = el.querySelectorAll('button');
            if (buttons.length > 0) {
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_e = el.textContent) === null || _e === void 0 ? void 0 : _e.trim()) || '';
                return newHeading;
            }
            return el;
        }
    },
    // Convert divs with paragraph role to actual paragraphs
    {
        selector: 'div[data-testid^="paragraph"], div[role="paragraph"]',
        element: 'p',
        transform: (el) => {
            const p = document.createElement('p');
            // Copy innerHTML
            p.innerHTML = el.innerHTML;
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    p.setAttribute(attr.name, attr.value);
                }
            });
            return p;
        }
    },
    // Convert divs with list roles to actual lists
    {
        selector: 'div[role="list"]',
        element: 'ul',
        // Custom handler for list type detection and transformation
        transform: (el) => {
            var _a;
            // First determine if this is an ordered list
            const firstItem = el.querySelector('div[role="listitem"] .label');
            const label = ((_a = firstItem === null || firstItem === void 0 ? void 0 : firstItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
            const isOrdered = label.match(/^\d+\)/);
            // Create the appropriate list type
            const list = document.createElement(isOrdered ? 'ol' : 'ul');
            // Process each list item
            const items = el.querySelectorAll('div[role="listitem"]');
            items.forEach(item => {
                const li = document.createElement('li');
                const content = item.querySelector('.content');
                if (content) {
                    // Convert any paragraph divs inside content
                    const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
                    paragraphDivs.forEach(div => {
                        const p = document.createElement('p');
                        p.innerHTML = div.innerHTML;
                        div.replaceWith(p);
                    });
                    // Convert any nested lists recursively
                    const nestedLists = content.querySelectorAll('div[role="list"]');
                    nestedLists.forEach(nestedList => {
                        var _a;
                        const firstNestedItem = nestedList.querySelector('div[role="listitem"] .label');
                        const nestedLabel = ((_a = firstNestedItem === null || firstNestedItem === void 0 ? void 0 : firstNestedItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        const isNestedOrdered = nestedLabel.match(/^\d+\)/);
                        const newNestedList = document.createElement(isNestedOrdered ? 'ol' : 'ul');
                        // Process nested items
                        const nestedItems = nestedList.querySelectorAll('div[role="listitem"]');
                        nestedItems.forEach(nestedItem => {
                            const nestedLi = document.createElement('li');
                            const nestedContent = nestedItem.querySelector('.content');
                            if (nestedContent) {
                                // Convert paragraph divs in nested items
                                const nestedParagraphs = nestedContent.querySelectorAll('div[role="paragraph"]');
                                nestedParagraphs.forEach(div => {
                                    const p = document.createElement('p');
                                    p.innerHTML = div.innerHTML;
                                    div.replaceWith(p);
                                });
                                nestedLi.innerHTML = nestedContent.innerHTML;
                            }
                            newNestedList.appendChild(nestedLi);
                        });
                        nestedList.replaceWith(newNestedList);
                    });
                    li.innerHTML = content.innerHTML;
                }
                list.appendChild(li);
            });
            return list;
        }
    },
    {
        selector: 'div[role="listitem"]',
        element: 'li',
        // Custom handler for list item content
        transform: (el) => {
            const content = el.querySelector('.content');
            if (!content)
                return el;
            // Convert any paragraph divs inside content
            const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
            paragraphDivs.forEach(div => {
                const p = document.createElement('p');
                p.innerHTML = div.innerHTML;
                div.replaceWith(p);
            });
            return content;
        }
    },
    // Code blocks with syntax highlighting
    {
        selector: '.wp-block-syntaxhighlighter-code, .syntaxhighlighter, .highlight, .highlight-source, .wp-block-code, pre[class*="language-"], pre[class*="brush:"]',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Create new pre element
            const newPre = document.createElement('pre');
            // Try to detect language
            let language = '';
            // Check for WordPress syntax highlighter specific format
            const syntaxEl = el.querySelector('.syntaxhighlighter');
            if (syntaxEl) {
                // Get language from syntaxhighlighter class
                const classes = Array.from(syntaxEl.classList);
                const langClass = classes.find(c => !['syntaxhighlighter', 'nogutter'].includes(c));
                if (langClass && constants_1.SUPPORTED_LANGUAGES.has(langClass.toLowerCase())) {
                    language = langClass.toLowerCase();
                }
            }
            // If no language found yet, check other common patterns
            if (!language) {
                const classNames = Array.from(el.classList);
                const languagePatterns = [
                    /(?:^|\s)(?:language|lang|brush|syntax)-(\w+)(?:\s|$)/i,
                    /(?:^|\s)(\w+)(?:\s|$)/i
                ];
                for (const className of classNames) {
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match && match[1] && constants_1.SUPPORTED_LANGUAGES.has(match[1].toLowerCase())) {
                            language = match[1].toLowerCase();
                            break;
                        }
                    }
                    if (language)
                        break;
                }
            }
            // Extract code content, handling various formats
            let codeContent = '';
            // Handle WordPress syntax highlighter table format
            const codeContainer = el.querySelector('.syntaxhighlighter table .code .container');
            if (codeContainer) {
                // Process each line
                const lines = Array.from(codeContainer.children);
                codeContent = lines
                    .map(line => {
                    // Get all code elements in this line
                    const codeParts = Array.from(line.querySelectorAll('code'))
                        .map(code => {
                        // Get the text content, preserving spaces
                        let text = code.textContent || '';
                        // If this is a 'spaces' class element, convert to actual spaces
                        if (code.classList.contains('spaces')) {
                            text = ' '.repeat(text.length);
                        }
                        return text;
                    })
                        .join('');
                    return codeParts || line.textContent || '';
                })
                    .join('\n');
            }
            else {
                // Handle WordPress syntax highlighter non-table format
                const codeLines = el.querySelectorAll('.code .line');
                if (codeLines.length > 0) {
                    codeContent = Array.from(codeLines)
                        .map(line => {
                        const codeParts = Array.from(line.querySelectorAll('code'))
                            .map(code => code.textContent || '')
                            .join('');
                        return codeParts || line.textContent || '';
                    })
                        .join('\n');
                }
                else {
                    // Fallback to regular text content
                    codeContent = el.textContent || '';
                }
            }
            // Clean up the content
            codeContent = codeContent
                .replace(/^\s+|\s+$/g, '') // Trim start/end whitespace
                .replace(/\t/g, '    ') // Convert tabs to spaces
                .replace(/\n{3,}/g, '\n\n') // Normalize multiple newlines
                .replace(/\u00a0/g, ' '); // Replace non-breaking spaces with regular spaces
            // Create code element with language class if detected
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    }
];
class Defuddle {
    /**
     * Create a new Defuddle instance
     * @param doc - The document to parse
     * @param options - Options for parsing
     */
    constructor(doc, options = {}) {
        this.doc = doc;
        this.options = options;
        this.debug = options.debug || false;
    }
    /**
     * Parse the document and extract its main content
     */
    parse() {
        const startTime = performance.now();
        // Extract metadata first since we'll need it in multiple places
        const schemaOrgData = metadata_1.MetadataExtractor.extractSchemaOrgData(this.doc);
        const metadata = metadata_1.MetadataExtractor.extract(this.doc, schemaOrgData);
        try {
            // Evaluate styles and sizes on original document
            const mobileStyles = this._evaluateMediaQueries(this.doc);
            // Check for small images in original document, excluding lazy-loaded ones
            const smallImages = this.findSmallImages(this.doc);
            // Clone document
            const clone = this.doc.cloneNode(true);
            // Apply mobile style to clone
            this.applyMobileStyles(clone, mobileStyles);
            // Find main content
            const mainContent = this.findMainContent(clone);
            if (!mainContent) {
                const endTime = performance.now();
                return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
            }
            // Remove small images identified from original document
            this.removeSmallImages(clone, smallImages);
            // Perform other destructive operations on the clone
            this.removeHiddenElements(clone);
            this.removeClutter(clone);
            // Clean up the main content
            this.cleanContent(mainContent, metadata);
            const content = mainContent ? mainContent.outerHTML : this.doc.body.innerHTML;
            const endTime = performance.now();
            return Object.assign(Object.assign({ content }, metadata), { wordCount: this.countWords(content), parseTime: Math.round(endTime - startTime) });
        }
        catch (error) {
            console.error('Defuddle', 'Error processing document:', error);
            const endTime = performance.now();
            return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
        }
    }
    countWords(content) {
        // Create a temporary div to parse HTML content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        // Get text content, removing extra whitespace
        const text = tempDiv.textContent || '';
        const words = text
            .trim()
            .replace(/\s+/g, ' ') // Replace multiple spaces with single space
            .split(' ')
            .filter(word => word.length > 0); // Filter out empty strings
        return words.length;
    }
    // Make all other methods private by removing the static keyword and using private
    _log(...args) {
        if (this.debug) {
            console.log('Defuddle:', ...args);
        }
    }
    _evaluateMediaQueries(doc) {
        const mobileStyles = [];
        const maxWidthRegex = /max-width[^:]*:\s*(\d+)/;
        try {
            // Get all styles, including inline styles
            const sheets = Array.from(doc.styleSheets).filter(sheet => {
                try {
                    // Access rules once to check validity
                    sheet.cssRules;
                    return true;
                }
                catch (e) {
                    // Expected error for cross-origin stylesheets
                    if (e instanceof DOMException && e.name === 'SecurityError') {
                        return false;
                    }
                    throw e;
                }
            });
            // Process all sheets in a single pass
            const mediaRules = sheets.flatMap(sheet => {
                try {
                    return Array.from(sheet.cssRules)
                        .filter((rule) => rule instanceof CSSMediaRule &&
                        rule.conditionText.includes('max-width'));
                }
                catch (e) {
                    if (this.debug) {
                        console.warn('Defuddle: Failed to process stylesheet:', e);
                    }
                    return [];
                }
            });
            // Process all media rules in a single pass
            mediaRules.forEach(rule => {
                const match = rule.conditionText.match(maxWidthRegex);
                if (match) {
                    const maxWidth = parseInt(match[1]);
                    if (constants_1.MOBILE_WIDTH <= maxWidth) {
                        // Batch process all style rules
                        const styleRules = Array.from(rule.cssRules)
                            .filter((r) => r instanceof CSSStyleRule);
                        styleRules.forEach(cssRule => {
                            try {
                                mobileStyles.push({
                                    selector: cssRule.selectorText,
                                    styles: cssRule.style.cssText
                                });
                            }
                            catch (e) {
                                if (this.debug) {
                                    console.warn('Defuddle: Failed to process CSS rule:', e);
                                }
                            }
                        });
                    }
                }
            });
        }
        catch (e) {
            console.error('Defuddle: Error evaluating media queries:', e);
        }
        return mobileStyles;
    }
    applyMobileStyles(doc, mobileStyles) {
        let appliedCount = 0;
        mobileStyles.forEach(({ selector, styles }) => {
            try {
                const elements = doc.querySelectorAll(selector);
                elements.forEach(element => {
                    element.setAttribute('style', (element.getAttribute('style') || '') + styles);
                    appliedCount++;
                });
            }
            catch (e) {
                console.error('Defuddle', 'Error applying styles for selector:', selector, e);
            }
        });
    }
    removeHiddenElements(doc) {
        let count = 0;
        const elementsToRemove = new Set();
        // First pass: Get all elements matching hidden selectors
        const hiddenElements = doc.querySelectorAll(constants_1.HIDDEN_ELEMENT_SELECTORS);
        hiddenElements.forEach(el => elementsToRemove.add(el));
        count += hiddenElements.length;
        // Second pass: Use TreeWalker for efficient traversal
        const treeWalker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, {
            acceptNode: (node) => {
                // Skip elements already marked for removal
                if (elementsToRemove.has(node)) {
                    return NodeFilter.FILTER_REJECT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        // Batch style computations
        const elements = [];
        let currentNode;
        while (currentNode = treeWalker.nextNode()) {
            elements.push(currentNode);
        }
        // Process styles in batches to minimize layout thrashing
        const BATCH_SIZE = 100;
        for (let i = 0; i < elements.length; i += BATCH_SIZE) {
            const batch = elements.slice(i, i + BATCH_SIZE);
            // Read phase - gather all computedStyles
            const styles = batch.map(el => window.getComputedStyle(el));
            // Write phase - mark elements for removal
            batch.forEach((element, index) => {
                const computedStyle = styles[index];
                if (computedStyle.display === 'none' ||
                    computedStyle.visibility === 'hidden' ||
                    computedStyle.opacity === '0') {
                    elementsToRemove.add(element);
                    count++;
                }
            });
        }
        // Final pass: Batch remove all hidden elements
        elementsToRemove.forEach(el => el.remove());
        this._log('Removed hidden elements:', count);
    }
    removeClutter(doc) {
        const startTime = performance.now();
        let exactSelectorCount = 0;
        let partialSelectorCount = 0;
        // Track all elements to be removed
        const elementsToRemove = new Set();
        // First collect elements matching exact selectors
        const exactElements = doc.querySelectorAll(constants_1.EXACT_SELECTORS.join(','));
        exactElements.forEach(el => {
            if (el === null || el === void 0 ? void 0 : el.parentNode) {
                elementsToRemove.add(el);
                exactSelectorCount++;
            }
        });
        // Pre-compile regexes and combine into a single regex for better performance
        const combinedPattern = constants_1.PARTIAL_SELECTORS.join('|');
        const partialRegex = new RegExp(combinedPattern, 'i');
        // Create an efficient attribute selector for elements we care about
        const attributeSelector = '[class],[id],[data-testid],[data-qa],[data-cy]';
        const allElements = doc.querySelectorAll(attributeSelector);
        // Process elements for partial matches
        allElements.forEach(el => {
            // Skip if already marked for removal
            if (elementsToRemove.has(el)) {
                return;
            }
            // Get all relevant attributes and combine into a single string
            const attrs = [
                el.className && typeof el.className === 'string' ? el.className : '',
                el.id || '',
                el.getAttribute('data-testid') || '',
                el.getAttribute('data-qa') || '',
                el.getAttribute('data-cy') || ''
            ].join(' ').toLowerCase();
            // Skip if no attributes to check
            if (!attrs.trim()) {
                return;
            }
            // Check for partial match using single regex test
            if (partialRegex.test(attrs)) {
                elementsToRemove.add(el);
                partialSelectorCount++;
            }
        });
        // Remove all collected elements in a single pass
        elementsToRemove.forEach(el => el.remove());
        const endTime = performance.now();
        this._log('Removed clutter elements:', {
            exactSelectors: exactSelectorCount,
            partialSelectors: partialSelectorCount,
            total: elementsToRemove.size,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    flattenDivs(element) {
        let processedCount = 0;
        const startTime = performance.now();
        // Process in batches to maintain performance
        let keepProcessing = true;
        const shouldPreserveElement = (el) => {
            const tagName = el.tagName.toLowerCase();
            // Check if element should be preserved
            if (constants_1.PRESERVE_ELEMENTS.has(tagName))
                return true;
            // Check for semantic roles
            const role = el.getAttribute('role');
            if (role && ['article', 'main', 'navigation', 'banner', 'contentinfo'].includes(role)) {
                return true;
            }
            // Check for semantic classes
            const className = el.className.toLowerCase();
            if (className.match(/(?:article|main|content|footnote|reference|bibliography)/)) {
                return true;
            }
            // Check if div contains mixed content types that should be preserved
            if (tagName === 'div') {
                const children = Array.from(el.children);
                const hasPreservedElements = children.some(child => constants_1.PRESERVE_ELEMENTS.has(child.tagName.toLowerCase()) ||
                    child.getAttribute('role') === 'article' ||
                    child.className.toLowerCase().includes('article'));
                if (hasPreservedElements)
                    return true;
            }
            return false;
        };
        const isWrapperDiv = (div) => {
            var _a;
            // Check if it's just empty space
            if (!((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim()))
                return true;
            // Check if it only contains other divs or block elements
            const children = Array.from(div.children);
            if (children.length === 0)
                return true;
            // Check if all children are block elements
            const allBlockElements = children.every(child => {
                const tag = child.tagName.toLowerCase();
                return tag === 'div' || tag === 'p' || tag === 'h1' || tag === 'h2' ||
                    tag === 'h3' || tag === 'h4' || tag === 'h5' || tag === 'h6' ||
                    tag === 'ul' || tag === 'ol' || tag === 'pre' || tag === 'blockquote' ||
                    tag === 'figure';
            });
            if (allBlockElements)
                return true;
            // Check for common wrapper patterns
            const className = div.className.toLowerCase();
            const isWrapper = /(?:wrapper|container|layout|row|col|grid|flex|outer|inner|content-area)/i.test(className);
            if (isWrapper)
                return true;
            // Check if it has excessive whitespace or empty text nodes
            const textNodes = Array.from(div.childNodes).filter(node => { var _a; return node.nodeType === Node.TEXT_NODE && ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.trim()); });
            if (textNodes.length === 0)
                return true;
            // Check if it's a div that only contains block elements
            const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                const tag = child.tagName.toLowerCase();
                return constants_1.INLINE_ELEMENTS.has(tag);
            });
            if (hasOnlyBlockElements)
                return true;
            return false;
        };
        // Function to process a single div
        const processDiv = (div) => {
            var _a, _b;
            // Skip processing if div has been removed or should be preserved
            if (!div.isConnected || shouldPreserveElement(div))
                return false;
            // Case 1: Empty div or div with only whitespace
            if (!div.hasChildNodes() || !((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim())) {
                div.remove();
                processedCount++;
                return true;
            }
            // Case 2: Top-level div - be more aggressive
            if (div.parentElement === element) {
                const children = Array.from(div.children);
                const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (hasOnlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
            }
            // Case 3: Wrapper div - merge up aggressively
            if (isWrapperDiv(div)) {
                // Special case: if div only contains block elements, merge them up
                const children = Array.from(div.children);
                const onlyBlockElements = !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (onlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
                // Otherwise handle as normal wrapper
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            // Case 4: Div only contains text content - convert to paragraph
            if (!div.children.length && ((_b = div.textContent) === null || _b === void 0 ? void 0 : _b.trim())) {
                const p = document.createElement('p');
                p.textContent = div.textContent;
                div.replaceWith(p);
                processedCount++;
                return true;
            }
            // Case 5: Div has single child
            if (div.children.length === 1) {
                const child = div.firstElementChild;
                const childTag = child.tagName.toLowerCase();
                // Don't unwrap if child is inline or should be preserved
                if (!constants_1.INLINE_ELEMENTS.has(childTag) && !shouldPreserveElement(child)) {
                    div.replaceWith(child);
                    processedCount++;
                    return true;
                }
            }
            // Case 6: Deeply nested div - merge up
            let nestingDepth = 0;
            let parent = div.parentElement;
            while (parent) {
                if (parent.tagName.toLowerCase() === 'div') {
                    nestingDepth++;
                }
                parent = parent.parentElement;
            }
            if (nestingDepth > 0) { // Changed from > 1 to > 0 to be more aggressive
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            return false;
        };
        // First pass: Process top-level divs
        const processTopLevelDivs = () => {
            const topDivs = Array.from(element.children).filter(el => el.tagName.toLowerCase() === 'div');
            let modified = false;
            topDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Second pass: Process remaining divs from deepest to shallowest
        const processRemainingDivs = () => {
            const allDivs = Array.from(element.getElementsByTagName('div'))
                .sort((a, b) => {
                // Count nesting depth
                const getDepth = (el) => {
                    let depth = 0;
                    let parent = el.parentElement;
                    while (parent) {
                        if (parent.tagName.toLowerCase() === 'div')
                            depth++;
                        parent = parent.parentElement;
                    }
                    return depth;
                };
                return getDepth(b) - getDepth(a); // Process deepest first
            });
            let modified = false;
            allDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Final cleanup pass - aggressively flatten remaining divs
        const finalCleanup = () => {
            const remainingDivs = Array.from(element.getElementsByTagName('div'));
            let modified = false;
            remainingDivs.forEach(div => {
                // Check if div only contains paragraphs
                const children = Array.from(div.children);
                const onlyParagraphs = children.every(child => child.tagName.toLowerCase() === 'p');
                if (onlyParagraphs || (!shouldPreserveElement(div) && isWrapperDiv(div))) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    modified = true;
                }
            });
            return modified;
        };
        // Execute all passes until no more changes
        do {
            keepProcessing = false;
            if (processTopLevelDivs())
                keepProcessing = true;
            if (processRemainingDivs())
                keepProcessing = true;
            if (finalCleanup())
                keepProcessing = true;
        } while (keepProcessing);
        const endTime = performance.now();
        this._log('Flattened divs:', {
            count: processedCount,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    cleanContent(element, metadata) {
        // Remove HTML comments
        this.removeHtmlComments(element);
        // Handle H1 elements - remove first one and convert others to H2
        this.handleHeadings(element, metadata.title);
        // Standardize footnotes and citations
        this.standardizeFootnotes(element);
        // Handle lazy-loaded images
        this.handleLazyImages(element);
        // Convert embedded content to standard formats
        this.standardizeElements(element);
        // Skip div flattening in debug mode
        if (!this.debug) {
            // First pass of div flattening
            this.flattenDivs(element);
            // Strip unwanted attributes
            this.stripUnwantedAttributes(element);
            // Remove empty elements
            this.removeEmptyElements(element);
            // Remove trailing headings
            this.removeTrailingHeadings(element);
            // Final pass of div flattening after cleanup operations
            this.flattenDivs(element);
        }
        else {
            // In debug mode, still do basic cleanup but preserve structure
            this.stripUnwantedAttributes(element);
            this.removeEmptyElements(element);
            this.removeTrailingHeadings(element);
            this._log('Debug mode: Skipping div flattening to preserve structure');
        }
    }
    removeTrailingHeadings(element) {
        let removedCount = 0;
        const hasContentAfter = (el) => {
            // Check if there's any meaningful content after this element
            let nextContent = '';
            let sibling = el.nextSibling;
            // First check direct siblings
            while (sibling) {
                if (sibling.nodeType === Node.TEXT_NODE) {
                    nextContent += sibling.textContent || '';
                }
                else if (sibling.nodeType === Node.ELEMENT_NODE) {
                    // If we find an element sibling, check its content
                    nextContent += sibling.textContent || '';
                }
                sibling = sibling.nextSibling;
            }
            // If we found meaningful content at this level, return true
            if (nextContent.trim()) {
                return true;
            }
            // If no content found at this level and we have a parent,
            // check for content after the parent
            const parent = el.parentElement;
            if (parent && parent !== element) {
                return hasContentAfter(parent);
            }
            return false;
        };
        // Process all headings from bottom to top
        const headings = Array.from(element.querySelectorAll('h1, h2, h3, h4, h5, h6'))
            .reverse();
        headings.forEach(heading => {
            if (!hasContentAfter(heading)) {
                heading.remove();
                removedCount++;
            }
            else {
                // Stop processing once we find a heading with content after it
                return;
            }
        });
        if (removedCount > 0) {
            this._log('Removed trailing headings:', removedCount);
        }
    }
    handleHeadings(element, title) {
        var _a;
        const h1s = element.getElementsByTagName('h1');
        Array.from(h1s).forEach(h1 => {
            var _a;
            const h2 = document.createElement('h2');
            h2.innerHTML = h1.innerHTML;
            // Copy allowed attributes
            Array.from(h1.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    h2.setAttribute(attr.name, attr.value);
                }
            });
            (_a = h1.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(h2, h1);
        });
        // Remove first H2 if it matches title
        const h2s = element.getElementsByTagName('h2');
        if (h2s.length > 0) {
            const firstH2 = h2s[0];
            const firstH2Text = ((_a = firstH2.textContent) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) || '';
            const normalizedTitle = title.toLowerCase().trim();
            if (normalizedTitle && normalizedTitle === firstH2Text) {
                firstH2.remove();
            }
        }
    }
    removeHtmlComments(element) {
        const comments = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_COMMENT, null);
        let node;
        while (node = walker.nextNode()) {
            comments.push(node);
        }
        comments.forEach(comment => {
            comment.remove();
        });
        this._log('Removed HTML comments:', comments.length);
    }
    stripUnwantedAttributes(element) {
        let attributeCount = 0;
        const processElement = (el) => {
            // Skip SVG elements - preserve all their attributes
            if (el instanceof SVGElement) {
                return;
            }
            const attributes = Array.from(el.attributes);
            attributes.forEach(attr => {
                const attrName = attr.name.toLowerCase();
                // In debug mode, allow debug attributes and data- attributes
                if (this.debug) {
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName) &&
                        !constants_1.ALLOWED_ATTRIBUTES_DEBUG.has(attrName) &&
                        !attrName.startsWith('data-')) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
                else {
                    // In normal mode, only allow standard attributes
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName)) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
            });
        };
        processElement(element);
        element.querySelectorAll('*').forEach(processElement);
        this._log('Stripped attributes:', attributeCount);
    }
    removeEmptyElements(element) {
        let removedCount = 0;
        let iterations = 0;
        let keepRemoving = true;
        while (keepRemoving) {
            iterations++;
            keepRemoving = false;
            // Get all elements without children, working from deepest first
            const emptyElements = Array.from(element.getElementsByTagName('*')).filter(el => {
                if (constants_1.ALLOWED_EMPTY_ELEMENTS.has(el.tagName.toLowerCase())) {
                    return false;
                }
                // Check if element has only whitespace or &nbsp;
                const textContent = el.textContent || '';
                const hasOnlyWhitespace = textContent.trim().length === 0;
                const hasNbsp = textContent.includes('\u00A0'); // Unicode non-breaking space
                // Check if element has no meaningful children
                const hasNoChildren = !el.hasChildNodes() ||
                    (Array.from(el.childNodes).every(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            const nodeText = node.textContent || '';
                            return nodeText.trim().length === 0 && !nodeText.includes('\u00A0');
                        }
                        return false;
                    }));
                // Special case: Check for divs that only contain spans with commas
                if (el.tagName.toLowerCase() === 'div') {
                    const children = Array.from(el.children);
                    const hasOnlyCommaSpans = children.length > 0 && children.every(child => {
                        var _a;
                        if (child.tagName.toLowerCase() !== 'span')
                            return false;
                        const content = ((_a = child.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        return content === ',' || content === '' || content === ' ';
                    });
                    if (hasOnlyCommaSpans)
                        return true;
                }
                return hasOnlyWhitespace && !hasNbsp && hasNoChildren;
            });
            if (emptyElements.length > 0) {
                emptyElements.forEach(el => {
                    el.remove();
                    removedCount++;
                });
                keepRemoving = true;
            }
        }
        this._log('Removed empty elements:', {
            count: removedCount,
            iterations
        });
    }
    createFootnoteItem(footnoteNumber, content, refs) {
        const newItem = document.createElement('li');
        newItem.className = 'footnote';
        newItem.id = `fn:${footnoteNumber}`;
        // Handle content
        if (typeof content === 'string') {
            const paragraph = document.createElement('p');
            paragraph.innerHTML = content;
            newItem.appendChild(paragraph);
        }
        else {
            // Get all paragraphs from the content
            const paragraphs = Array.from(content.querySelectorAll('p'));
            if (paragraphs.length === 0) {
                // If no paragraphs, wrap content in a paragraph
                const paragraph = document.createElement('p');
                paragraph.innerHTML = content.innerHTML;
                newItem.appendChild(paragraph);
            }
            else {
                // Copy existing paragraphs
                paragraphs.forEach(p => {
                    const newP = document.createElement('p');
                    newP.innerHTML = p.innerHTML;
                    newItem.appendChild(newP);
                });
            }
        }
        // Add backlink(s) to the last paragraph
        const lastParagraph = newItem.querySelector('p:last-of-type') || newItem;
        refs.forEach((refId, index) => {
            const backlink = document.createElement('a');
            backlink.href = `#${refId}`;
            backlink.title = 'return to article';
            backlink.className = 'footnote-backref';
            backlink.innerHTML = '↩';
            if (index < refs.length - 1) {
                backlink.innerHTML += ' ';
            }
            lastParagraph.appendChild(backlink);
        });
        return newItem;
    }
    collectFootnotes(element) {
        const footnotes = {};
        let footnoteCount = 1;
        const processedIds = new Set(); // Track processed IDs
        // Collect all footnotes and their IDs from footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => {
            // Substack has individual footnote divs with no parent
            if (list.matches('div.footnote[data-component-name="FootnoteToDOM"]')) {
                const anchor = list.querySelector('a.footnote-number');
                const content = list.querySelector('.footnote-content');
                if (anchor && content) {
                    const id = anchor.id.replace('footnote-', '').toLowerCase();
                    if (id && !processedIds.has(id)) {
                        footnotes[footnoteCount] = {
                            content: content,
                            originalId: id,
                            refs: []
                        };
                        processedIds.add(id);
                        footnoteCount++;
                    }
                }
                return;
            }
            // Common format using OL/UL and LI elements
            const items = list.querySelectorAll('li, div[role="listitem"]');
            items.forEach(li => {
                var _a, _b, _c, _d;
                let id = '';
                let content = null;
                // Handle citations with .citations class
                const citationsDiv = li.querySelector('.citations');
                if ((_a = citationsDiv === null || citationsDiv === void 0 ? void 0 : citationsDiv.id) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith('r')) {
                    id = citationsDiv.id.toLowerCase();
                    // Look for citation content within the citations div
                    const citationContent = citationsDiv.querySelector('.citation-content');
                    if (citationContent) {
                        content = citationContent;
                    }
                }
                else {
                    // Extract ID from various formats
                    if (li.id.toLowerCase().startsWith('bib.bib')) {
                        id = li.id.replace('bib.bib', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn:')) {
                        id = li.id.replace('fn:', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn')) {
                        id = li.id.replace('fn', '').toLowerCase();
                        // Nature.com
                    }
                    else if (li.hasAttribute('data-counter')) {
                        id = ((_c = (_b = li.getAttribute('data-counter')) === null || _b === void 0 ? void 0 : _b.replace(/\.$/, '')) === null || _c === void 0 ? void 0 : _c.toLowerCase()) || '';
                    }
                    else {
                        const match = (_d = li.id.split('/').pop()) === null || _d === void 0 ? void 0 : _d.match(/cite_note-(.+)/);
                        id = match ? match[1].toLowerCase() : li.id.toLowerCase();
                    }
                    content = li;
                }
                if (id && !processedIds.has(id)) {
                    footnotes[footnoteCount] = {
                        content: content || li,
                        originalId: id,
                        refs: []
                    };
                    processedIds.add(id);
                    footnoteCount++;
                }
            });
        });
        return footnotes;
    }
    findOuterFootnoteContainer(el) {
        let current = el;
        let parent = el.parentElement;
        // Keep going up until we find an element that's not a span or sup
        while (parent && (parent.tagName.toLowerCase() === 'span' ||
            parent.tagName.toLowerCase() === 'sup')) {
            current = parent;
            parent = parent.parentElement;
        }
        return current;
    }
    // Every footnote reference should be a sup element with an anchor inside
    // e.g. <sup id="fnref:1"><a href="#fn:1">1</a></sup>
    createFootnoteReference(footnoteNumber, refId) {
        const sup = document.createElement('sup');
        sup.id = refId;
        const link = document.createElement('a');
        link.href = `#fn:${footnoteNumber}`;
        link.textContent = footnoteNumber;
        sup.appendChild(link);
        return sup;
    }
    standardizeFootnotes(element) {
        const footnotes = this.collectFootnotes(element);
        // Standardize inline footnotes using the collected IDs
        const footnoteInlineReferences = element.querySelectorAll(constants_1.FOOTNOTE_INLINE_REFERENCES);
        // Group references by their parent sup element
        const supGroups = new Map();
        footnoteInlineReferences.forEach(el => {
            var _a, _b, _c, _d;
            if (!(el instanceof HTMLElement))
                return;
            let footnoteId = '';
            let footnoteContent = '';
            // Extract footnote ID based on element type
            // Nature.com
            if (el.matches('a[id^="ref-link"]')) {
                footnoteId = ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                // Science.org
            }
            else if (el.matches('a[role="doc-biblioref"]')) {
                const xmlRid = el.getAttribute('data-xml-rid');
                if (xmlRid) {
                    footnoteId = xmlRid;
                }
                else {
                    const href = el.getAttribute('href');
                    if (href === null || href === void 0 ? void 0 : href.startsWith('#core-R')) {
                        footnoteId = href.replace('#core-', '');
                    }
                }
                // Substack
            }
            else if (el.matches('a.footnote-anchor, span.footnote-hovercard-target a')) {
                const id = ((_b = el.id) === null || _b === void 0 ? void 0 : _b.replace('footnote-anchor-', '')) || '';
                if (id) {
                    footnoteId = id.toLowerCase();
                }
                // Arxiv
            }
            else if (el.matches('cite.ltx_cite')) {
                const link = el.querySelector('a');
                if (link) {
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_c = href.split('/').pop()) === null || _c === void 0 ? void 0 : _c.match(/bib\.bib(\d+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                }
            }
            else if (el.matches('sup.reference')) {
                const links = el.querySelectorAll('a');
                Array.from(links).forEach(link => {
                    var _a;
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_a = href.split('/').pop()) === null || _a === void 0 ? void 0 : _a.match(/(?:cite_note|cite_ref)-(.+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                });
            }
            else if (el.matches('sup[id^="fnref:"]')) {
                footnoteId = el.id.replace('fnref:', '').toLowerCase();
            }
            else if (el.matches('sup[id^="fnr"]')) {
                footnoteId = el.id.replace('fnr', '').toLowerCase();
            }
            else if (el.matches('span.footnote-reference')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
            }
            else if (el.matches('span.footnote-link')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
                footnoteContent = el.getAttribute('data-footnote-content') || '';
            }
            else if (el.matches('a.citation')) {
                footnoteId = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                footnoteContent = el.getAttribute('href') || '';
            }
            else if (el.matches('a[id^="fnref"]')) {
                footnoteId = el.id.replace('fnref', '').toLowerCase();
            }
            else {
                // Other citation types
                const href = el.getAttribute('href');
                if (href) {
                    const id = href.replace(/^[#]/, '');
                    footnoteId = id.toLowerCase();
                }
            }
            if (footnoteId) {
                // Find the footnote number by matching the original ID
                const footnoteEntry = Object.entries(footnotes).find(([_, data]) => data.originalId === footnoteId.toLowerCase());
                if (footnoteEntry) {
                    const [footnoteNumber, footnoteData] = footnoteEntry;
                    // Create footnote reference ID
                    const refId = footnoteData.refs.length > 0 ?
                        `fnref:${footnoteNumber}-${footnoteData.refs.length + 1}` :
                        `fnref:${footnoteNumber}`;
                    footnoteData.refs.push(refId);
                    // Find the outermost container (span or sup)
                    const container = this.findOuterFootnoteContainer(el);
                    // If container is a sup, group references
                    if (container.tagName.toLowerCase() === 'sup') {
                        if (!supGroups.has(container)) {
                            supGroups.set(container, []);
                        }
                        const group = supGroups.get(container);
                        group.push(this.createFootnoteReference(footnoteNumber, refId));
                    }
                    else {
                        // Replace the container directly
                        container.replaceWith(this.createFootnoteReference(footnoteNumber, refId));
                    }
                }
            }
        });
        // Handle grouped references
        supGroups.forEach((references, container) => {
            if (references.length > 0) {
                // Create a document fragment to hold all the references
                const fragment = document.createDocumentFragment();
                // Add each reference as its own sup element
                references.forEach((ref, index) => {
                    const link = ref.querySelector('a');
                    if (link) {
                        const sup = document.createElement('sup');
                        sup.id = ref.id;
                        sup.appendChild(link.cloneNode(true));
                        fragment.appendChild(sup);
                    }
                });
                container.replaceWith(fragment);
            }
        });
        // Create the standardized footnote list
        const newList = document.createElement('footnotes');
        newList.className = 'footnotes';
        const orderedList = document.createElement('ol');
        // Create footnote items in order
        Object.entries(footnotes).forEach(([number, data]) => {
            const newItem = this.createFootnoteItem(parseInt(number), data.content, data.refs);
            orderedList.appendChild(newItem);
        });
        // Remove original footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => list.remove());
        // If we have any footnotes, add the new list to the document
        if (orderedList.children.length > 0) {
            newList.appendChild(orderedList);
            element.appendChild(newList);
        }
    }
    handleLazyImages(element) {
        let processedCount = 0;
        const lazyImages = element.querySelectorAll('img[data-src], img[data-srcset]');
        lazyImages.forEach(img => {
            if (!(img instanceof HTMLImageElement))
                return;
            // Handle data-src
            const dataSrc = img.getAttribute('data-src');
            if (dataSrc && !img.src) {
                img.src = dataSrc;
                processedCount++;
            }
            // Handle data-srcset
            const dataSrcset = img.getAttribute('data-srcset');
            if (dataSrcset && !img.srcset) {
                img.srcset = dataSrcset;
                processedCount++;
            }
            // Remove lazy loading related classes and attributes
            img.classList.remove('lazy', 'lazyload');
            img.removeAttribute('data-ll-status');
            img.removeAttribute('data-src');
            img.removeAttribute('data-srcset');
        });
        this._log('Processed lazy images:', processedCount);
    }
    standardizeElements(element) {
        let processedCount = 0;
        // Convert elements based on standardization rules
        ELEMENT_STANDARDIZATION_RULES.forEach(rule => {
            const elements = element.querySelectorAll(rule.selector);
            elements.forEach(el => {
                if (rule.transform) {
                    // If there's a transform function, use it to create the new element
                    const transformed = rule.transform(el);
                    el.replaceWith(transformed);
                    processedCount++;
                }
            });
        });
        // Convert lite-youtube elements
        const liteYoutubeElements = element.querySelectorAll('lite-youtube');
        liteYoutubeElements.forEach(el => {
            const videoId = el.getAttribute('videoid');
            if (!videoId)
                return;
            const iframe = document.createElement('iframe');
            iframe.width = '560';
            iframe.height = '315';
            iframe.src = `https://www.youtube.com/embed/${videoId}`;
            iframe.title = el.getAttribute('videotitle') || 'YouTube video player';
            iframe.frameBorder = '0';
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.setAttribute('allowfullscreen', '');
            el.replaceWith(iframe);
            processedCount++;
        });
        this._log('Converted embedded elements:', processedCount);
    }
    // Find small IMG and SVG elements
    findSmallImages(doc) {
        const MIN_DIMENSION = 33;
        const smallImages = new Set();
        const transformRegex = /scale\(([\d.]+)\)/;
        const startTime = performance.now();
        let processedCount = 0;
        // 1. Read phase - Gather all elements in a single pass
        const elements = [
            ...Array.from(doc.getElementsByTagName('img')),
            ...Array.from(doc.getElementsByTagName('svg'))
        ].filter(element => {
            // Skip lazy-loaded images that haven't been processed yet
            // and math images which may be small
            if (element instanceof HTMLImageElement) {
                const ignoredImage = element.classList.contains('lazy') ||
                    element.classList.contains('lazyload') ||
                    element.classList.contains('latex') ||
                    element.hasAttribute('decoding') ||
                    element.hasAttribute('data-src') ||
                    element.hasAttribute('data-srcset');
                return !ignoredImage;
            }
            return true;
        });
        if (elements.length === 0) {
            return smallImages;
        }
        // 2. Batch process - Collect all measurements in one go
        const measurements = elements.map(element => ({
            element,
            // Static attributes (no reflow)
            naturalWidth: element instanceof HTMLImageElement ? element.naturalWidth : 0,
            naturalHeight: element instanceof HTMLImageElement ? element.naturalHeight : 0,
            attrWidth: parseInt(element.getAttribute('width') || '0'),
            attrHeight: parseInt(element.getAttribute('height') || '0')
        }));
        // 3. Batch compute styles - Process in chunks to avoid long tasks
        const BATCH_SIZE = 50;
        for (let i = 0; i < measurements.length; i += BATCH_SIZE) {
            const batch = measurements.slice(i, i + BATCH_SIZE);
            try {
                // Read phase - compute all styles at once
                const styles = batch.map(({ element }) => window.getComputedStyle(element));
                const rects = batch.map(({ element }) => element.getBoundingClientRect());
                // Process phase - no DOM operations
                batch.forEach((measurement, index) => {
                    var _a;
                    try {
                        const style = styles[index];
                        const rect = rects[index];
                        // Get transform scale in the same batch
                        const transform = style.transform;
                        const scale = transform ?
                            parseFloat(((_a = transform.match(transformRegex)) === null || _a === void 0 ? void 0 : _a[1]) || '1') : 1;
                        // Calculate effective dimensions
                        const widths = [
                            measurement.naturalWidth,
                            measurement.attrWidth,
                            parseInt(style.width) || 0,
                            rect.width * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        const heights = [
                            measurement.naturalHeight,
                            measurement.attrHeight,
                            parseInt(style.height) || 0,
                            rect.height * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        // Decision phase - no DOM operations
                        if (widths.length > 0 && heights.length > 0) {
                            const effectiveWidth = Math.min(...widths);
                            const effectiveHeight = Math.min(...heights);
                            if (effectiveWidth < MIN_DIMENSION || effectiveHeight < MIN_DIMENSION) {
                                const identifier = this.getElementIdentifier(measurement.element);
                                if (identifier) {
                                    smallImages.add(identifier);
                                    processedCount++;
                                }
                            }
                        }
                    }
                    catch (e) {
                        if (this.debug) {
                            console.warn('Defuddle: Failed to process element dimensions:', e);
                        }
                    }
                });
            }
            catch (e) {
                if (this.debug) {
                    console.warn('Defuddle: Failed to process batch:', e);
                }
            }
        }
        const endTime = performance.now();
        this._log('Found small elements:', {
            count: processedCount,
            totalElements: elements.length,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        return smallImages;
    }
    removeSmallImages(doc, smallImages) {
        let removedCount = 0;
        ['img', 'svg'].forEach(tag => {
            const elements = doc.getElementsByTagName(tag);
            Array.from(elements).forEach(element => {
                const identifier = this.getElementIdentifier(element);
                if (identifier && smallImages.has(identifier)) {
                    element.remove();
                    removedCount++;
                }
            });
        });
        this._log('Removed small elements:', removedCount);
    }
    getElementIdentifier(element) {
        // Try to create a unique identifier using various attributes
        if (element instanceof HTMLImageElement) {
            // For lazy-loaded images, use data-src as identifier if available
            const dataSrc = element.getAttribute('data-src');
            if (dataSrc)
                return `src:${dataSrc}`;
            const src = element.src || '';
            const srcset = element.srcset || '';
            const dataSrcset = element.getAttribute('data-srcset');
            if (src)
                return `src:${src}`;
            if (srcset)
                return `srcset:${srcset}`;
            if (dataSrcset)
                return `srcset:${dataSrcset}`;
        }
        const id = element.id || '';
        const className = element.className || '';
        const viewBox = element instanceof SVGElement ? element.getAttribute('viewBox') || '' : '';
        if (id)
            return `id:${id}`;
        if (viewBox)
            return `viewBox:${viewBox}`;
        if (className)
            return `class:${className}`;
        return null;
    }
    findMainContent(doc) {
        // Find all potential content containers
        const candidates = [];
        constants_1.ENTRY_POINT_ELEMENTS.forEach((selector, index) => {
            const elements = doc.querySelectorAll(selector);
            elements.forEach(element => {
                // Base score from selector priority (earlier = higher)
                let score = (constants_1.ENTRY_POINT_ELEMENTS.length - index) * 10;
                // Add score based on content analysis
                score += this.scoreElement(element);
                candidates.push({ element, score });
            });
        });
        if (candidates.length === 0) {
            // Fall back to scoring block elements
            // Currently <body> element is used as the fallback, so this is not used
            return this.findContentByScoring(doc);
        }
        // Sort by score descending
        candidates.sort((a, b) => b.score - a.score);
        if (this.debug) {
            this._log('Content candidates:', candidates.map(c => ({
                element: c.element.tagName,
                selector: this.getElementSelector(c.element),
                score: c.score
            })));
        }
        return candidates[0].element;
    }
    findContentByScoring(doc) {
        const candidates = this.scoreElements(doc);
        return candidates.length > 0 ? candidates[0].element : null;
    }
    getElementSelector(element) {
        const parts = [];
        let current = element;
        while (current && current !== this.doc.documentElement) {
            let selector = current.tagName.toLowerCase();
            if (current.id) {
                selector += '#' + current.id;
            }
            else if (current.className && typeof current.className === 'string') {
                selector += '.' + current.className.trim().split(/\s+/).join('.');
            }
            parts.unshift(selector);
            current = current.parentElement;
        }
        return parts.join(' > ');
    }
    scoreElements(doc) {
        const candidates = [];
        constants_1.BLOCK_ELEMENTS.forEach((tag) => {
            Array.from(doc.getElementsByTagName(tag)).forEach((element) => {
                const score = this.scoreElement(element);
                if (score > 0) {
                    candidates.push({ score, element });
                }
            });
        });
        return candidates.sort((a, b) => b.score - a.score);
    }
    scoreElement(element) {
        let score = 0;
        // Score based on element properties
        const className = element.className && typeof element.className === 'string' ?
            element.className.toLowerCase() : '';
        const id = element.id ? element.id.toLowerCase() : '';
        // Score based on content
        const text = element.textContent || '';
        const words = text.split(/\s+/).length;
        score += Math.min(Math.floor(words / 100), 3);
        // Score based on link density
        const links = element.getElementsByTagName('a');
        const linkText = Array.from(links).reduce((acc, link) => { var _a; return acc + (((_a = link.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0); }, 0);
        const linkDensity = text.length ? linkText / text.length : 0;
        if (linkDensity > 0.5) {
            score -= 10;
        }
        // Score based on presence of meaningful elements
        const paragraphs = element.getElementsByTagName('p').length;
        score += paragraphs;
        const images = element.getElementsByTagName('img').length;
        score += Math.min(images * 3, 9);
        return score;
    }
}
exports.Defuddle = Defuddle;


/***/ }),

/***/ 640:
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SUPPORTED_LANGUAGES = exports.ALLOWED_ATTRIBUTES_DEBUG = exports.ALLOWED_ATTRIBUTES = exports.ALLOWED_EMPTY_ELEMENTS = exports.FOOTNOTE_LIST_SELECTORS = exports.FOOTNOTE_INLINE_REFERENCES = exports.PARTIAL_SELECTORS = exports.EXACT_SELECTORS = exports.HIDDEN_ELEMENT_SELECTORS = exports.INLINE_ELEMENTS = exports.PRESERVE_ELEMENTS = exports.BLOCK_ELEMENTS = exports.MOBILE_WIDTH = exports.ENTRY_POINT_ELEMENTS = void 0;
// Entry point elements
// These are the elements that will be used to find the main content
exports.ENTRY_POINT_ELEMENTS = [
    'article',
    '[role="article"]',
    '.post-content',
    '.article-content',
    '#article-content',
    '.content-article',
    'main',
    '[role="main"]',
    'body' // ensures there is always a match
];
exports.MOBILE_WIDTH = 600;
exports.BLOCK_ELEMENTS = ['div', 'section', 'article', 'main'];
// Elements that should not be unwrapped
exports.PRESERVE_ELEMENTS = new Set([
    'pre', 'code', 'table', 'thead', 'tbody', 'tr', 'td', 'th',
    'ul', 'ol', 'li', 'dl', 'dt', 'dd',
    'figure', 'figcaption', 'picture',
    'details', 'summary',
    'blockquote',
    'form', 'fieldset'
]);
// Inline elements that should not be unwrapped
exports.INLINE_ELEMENTS = new Set([
    'a', 'span', 'strong', 'em', 'i', 'b', 'u', 'code', 'br', 'small',
    'sub', 'sup', 'mark', 'del', 'ins', 'q', 'abbr', 'cite', 'time'
]);
// Hidden elements that should be removed
exports.HIDDEN_ELEMENT_SELECTORS = [
    '[hidden]',
    //	'[aria-hidden="true"]', needed for math formulas
    //	'[style*="display: none"]', needed for for math formulas
    //	'[style*="display:none"]',
    '[style*="visibility: hidden"]',
    '[style*="visibility:hidden"]',
    '.hidden',
    '.invisible'
].join(',');
// Selectors to be removed
exports.EXACT_SELECTORS = [
    // scripts, styles
    'noscript',
    'script:not([type^="math/"])',
    'style',
    // ads
    '.ad:not([class*="gradient"])',
    '[class^="ad-" i]',
    '[class$="-ad" i]',
    '[id^="ad-" i]',
    '[id$="-ad" i]',
    '[role="banner" i]',
    '.promo',
    '.Promo',
    '#barrier-page', // ft.com
    // comments
    '[id="comments" i]',
    // header, nav
    'header',
    '.header',
    '#header',
    'nav',
    '.navigation',
    '#navigation',
    '[role="navigation" i]',
    '[role="dialog" i]',
    '[role*="complementary" i]',
    '[class*="pagination" i]',
    '.menu',
    '#menu',
    '#siteSub',
    // metadata
    '.author',
    '.Author',
    '.contributor',
    '.date',
    '.meta',
    '.tags',
    '.toc',
    '.Toc',
    '#toc',
    '#title',
    '#Title',
    '[href*="/category"]',
    '[href*="/categories"]',
    '[href*="/tag/"]',
    '[href*="/tags/"]',
    '[href*="/topics"]',
    '[href*="author"]',
    '[href="#site-content"]',
    '[src*="author"]',
    // footer
    'footer',
    // inputs, forms, elements
    'aside',
    'button',
    // '[role="button"]', Medium images
    'canvas',
    'dialog',
    'fieldset',
    'form',
    'input:not([type="checkbox"])',
    'label',
    'link',
    'option',
    'select',
    'textarea',
    'time',
    // iframes
    'instaread-player',
    'iframe:not([src*="youtube"]):not([src*="youtu.be"]):not([src*="vimeo"]):not([src*="twitter"])',
    // logos
    '[class="logo" i]',
    '#logo',
    '#Logo',
    // newsletter
    '#newsletter',
    '#Newsletter',
    // hidden for print
    '.noprint',
    '[data-link-name*="skip" i]',
    '[data-print-layout="hide" i]',
    '[data-block="donotprint" i]',
    // footnotes, citations
    '[class*="clickable-icon" i]',
    'li span[class*="ltx_tag" i][class*="ltx_tag_item" i]',
    'a[href^="#"][class*="anchor" i]',
    'a[href^="#"][class*="ref" i]',
    // link lists
    '[data-container*="most-viewed" i]',
    // sidebar
    '.sidebar',
    '.Sidebar',
    '#sidebar',
    '#Sidebar',
    '#sitesub',
    // other
    '#primaryaudio', // NPR
    '#NYT_ABOVE_MAIN_CONTENT_REGION',
    '[data-testid="photoviewer-children-figure"] > span', // New York Times
    'table.infobox',
    '.pencraft:not(.pc-display-contents)', // Substack
    '[data-optimizely="related-articles-section" i]' // The Economist
];
// Removal patterns tested against attributes: class, id, data-testid, and data-qa
// Case insensitive, partial matches allowed
exports.PARTIAL_SELECTORS = [
    'access-wall',
    'activitypub',
    'actioncall',
    'appendix',
    'avatar',
    'advert',
    '-ad-',
    '_ad_',
    'allterms',
    'alert-box',
    'around-the-web',
    'article-bottom-section',
    'article__copy',
    'article_date',
    'article-end ',
    'article_header',
    'article__header',
    'article__info',
    'article-info',
    'article__meta',
    'article-subject',
    'article_subject',
    'article-snippet',
    'article-separator',
    'article--share',
    'article--topics',
    'articletags',
    'article-tags',
    'article_tags',
    'article-title',
    'article_title',
    'articletopics',
    'article-topics',
    'article-type',
    'article--lede', // The Verge
    'articlewell',
    'associated-people',
    'audio-card',
    //	'author', Gwern
    'authored-by',
    'author-box',
    'author-name',
    'author-bio',
    'author-mini-bio',
    'back-to-top',
    'backlinks-section',
    'banner',
    'bio-block',
    'blog-pager',
    'bookmark-',
    '-bookmark',
    'bottom-of-article',
    'brand-bar',
    'breadcrumb',
    'button-wrapper',
    'btn-',
    '-btn',
    'byline',
    'captcha',
    'card-text',
    'card-media',
    'cat_header',
    'catlinks',
    'chapter-list', // The Economist
    'collections',
    'comments',
    //	'-comment', Syntax highlighting
    'commentbox',
    'comment-count',
    'comment-content',
    'comment-form',
    'comment-number',
    'comment-respond',
    'comment-thread',
    'complementary',
    'consent',
    'content-card', // The Verge
    'content-topics',
    'contentpromo',
    'context-widget', // Reuters
    'core-collateral',
    '_cta',
    '-cta',
    'cta-',
    'cta_',
    'current-issue', // The Nation
    'custom-list-number',
    'dateline',
    'dateheader',
    'date-header',
    'date_header-',
    //	'dialog',
    'disclaimer',
    'disclosure',
    'discussion',
    'discuss_',
    'disqus',
    'donate',
    'dropdown', // Ars Technica
    'eletters',
    'emailsignup',
    'engagement-widget',
    'entry-author-info',
    'entry-categories',
    'entry-date',
    'entry-meta',
    'entry-title',
    'entry-utility',
    'eyebrow',
    'expand-reduce',
    'externallinkembedwrapper', // The New Yorker
    'extra-services',
    'extra-title',
    'facebook',
    'favorite',
    'feedback',
    'feed-links',
    'field-site-sections',
    'fixed',
    'floating-vid',
    'follow',
    'footer',
    'footnote-back',
    'footnoteback',
    'for-you',
    'frontmatter',
    'further-reading',
    'gist-meta',
    //	'global',
    'google',
    'goog-',
    'graph-view',
    'header-logo',
    'header-pattern', // The Verge
    'hero-list',
    'hide-for-print',
    'hide-print',
    'hide-when-no-script',
    'hidden-sidenote',
    'interlude',
    'interaction',
    'jumplink',
    'jump-to-',
    //	'keyword', // used in syntax highlighting
    'kicker',
    'labstab', // Arxiv
    '-labels',
    'language-name',
    'latest-content',
    '-ledes-', // The Verge
    '-license',
    'link-box',
    'links-grid', // BBC
    'links-title', // BBC
    'listing-dynamic-terms', // Boston Review
    'list-tags',
    'loading',
    'loa-info',
    'logo_container',
    'ltx_role_refnum', // Arxiv
    'ltx_tag_bibitem',
    'ltx_error',
    'marketing',
    'media-inquiry',
    'menu-',
    'meta-',
    'metadata',
    'might-like',
    '_modal',
    '-modal',
    'more-',
    'morenews',
    'morestories',
    'move-helper',
    'mw-editsection',
    'mw-cite-backlink',
    'mw-indicators',
    'mw-jump-link',
    'nav-',
    'nav_',
    'navbar',
    //	'navigation',
    'next-',
    'news-story-title',
    //	'newsletter', used on Substack
    'newsletter_',
    'newsletter-signup',
    'newslettersignup',
    'newsletterwidget',
    'newsletterwrapper',
    'not-found',
    'nomobile',
    'noprint',
    'originally-published', // Mercury News
    'outline-view',
    'overlay',
    'page-title',
    '-partners',
    'plea',
    'popular',
    //	'popup', Gwern
    'pop-up',
    'popover',
    'post-bottom',
    'post__category',
    'postcomment',
    'postdate',
    'post-author',
    'post-date',
    'post_date',
    'post-feeds',
    'postinfo',
    'post-info',
    'post_info',
    'post-inline-date',
    'post-links',
    'post-meta',
    'postmeta',
    'postsnippet',
    'post_snippet',
    'post-snippet',
    'posttitle',
    'post-title',
    'post_title',
    'posttax',
    'post-tax',
    'post_tax',
    'posttag',
    'post_tag',
    'post-tag',
    //	'preview', used on Obsidian Publish
    'prevnext',
    'previousnext',
    'press-inquiries',
    'print-none',
    'print-header',
    'profile',
    //	'promo',
    'promo-box',
    'pubdate',
    'pub_date',
    'pub-date',
    'publication-date',
    'publicationName', // Medium
    'qr-code',
    'qr_code',
    '_rail',
    'readmore',
    'read-next',
    'read_next',
    'read_time',
    'read-time',
    'reading_time',
    'reading-time',
    'reading-list',
    'recentpost',
    'recent_post',
    'recent-post',
    'recommend',
    'redirectedfrom',
    'recirc',
    'register',
    'related',
    'relevant',
    'reversefootnote',
    'screen-reader-text',
    //	'share',
    //	'-share', scitechdaily.com
    'share-box',
    'sharedaddy',
    'share-icons',
    'sharelinks',
    'share-section',
    'sidebartitle',
    'sidebar_',
    'sidebar-content',
    'similar-',
    'similar_',
    'similars-',
    'sideitems',
    'side-box',
    'site-index',
    'site-header',
    'site-logo',
    'site-name',
    //	'skip-',
    //	'skip-link', TechCrunch
    '_skip-link',
    'slug-wrap',
    'social',
    'speechify-ignore',
    'sponsor',
    'springercitation',
    //	'-stats',
    '_stats',
    'sticky',
    'storyreadtime', // Medium
    'storypublishdate', // Medium
    'subject-label',
    'subscribe',
    '_tags',
    'tags__item',
    'tag_list',
    'taxonomy',
    'table-of-contents',
    'tabs-',
    //	'teaser', Nature
    'terminaltout',
    'time-rubric',
    'timestamp',
    'tip_off',
    'tiptout',
    '-tout-',
    '-toc',
    'toggle-caption',
    'topic-list',
    'toolbar',
    'tooltip',
    'top-wrapper',
    'tree-item',
    'trending',
    'trust-feat',
    'trust-badge',
    'twitter',
    'visually-hidden',
    'welcomebox'
    //	'widget-'
];
// Selectors for footnotes and citations
exports.FOOTNOTE_INLINE_REFERENCES = [
    'sup.reference',
    'cite.ltx_cite',
    'sup[id^="fnr"]',
    'sup[id^="fnref:"]',
    'span.footnote-link',
    'a.citation',
    'a[id^="ref-link"]',
    'a[href^="#fn"]',
    'a[href^="#cite"]',
    'a[href^="#reference"]',
    'a[href^="#footnote"]',
    'a[href^="#r"]', // Common in academic papers
    'a[href^="#b"]', // Common for bibliography references
    'a[href*="cite_note"]',
    'a[href*="cite_ref"]',
    'a.footnote-anchor', // Substack
    'span.footnote-hovercard-target a', // Substack
    'a[role="doc-biblioref"]', // Science.org
    'a[id^="fnref"]',
    'a[id^="ref-link"]', // Nature.com
].join(',');
exports.FOOTNOTE_LIST_SELECTORS = [
    'div.footnote ol',
    'div.footnotes ol',
    'div[role="doc-endnotes"]',
    'div[role="doc-footnotes"]',
    'ol.footnotes-list',
    'ol.footnotes',
    'ol.references',
    'ol[class*="article-references"]',
    'section.footnotes ol',
    'section[role="doc-endnotes"]',
    'section[role="doc-footnotes"]',
    'section[role="doc-bibliography"]',
    'ul.footnotes-list',
    'ul.ltx_biblist',
    'div.footnote[data-component-name="FootnoteToDOM"]' // Substack
].join(',');
// Elements that are allowed to be empty
// These are not removed even if they have no content
exports.ALLOWED_EMPTY_ELEMENTS = new Set([
    'area',
    'audio',
    'base',
    'br',
    'circle',
    'col',
    'defs',
    'ellipse',
    'embed',
    'figure',
    'g',
    'hr',
    'iframe',
    'img',
    'input',
    'line',
    'link',
    'mask',
    'meta',
    'object',
    'param',
    'path',
    'pattern',
    'picture',
    'polygon',
    'polyline',
    'rect',
    'source',
    'stop',
    'svg',
    'td',
    'th',
    'track',
    'use',
    'video',
    'wbr'
]);
// Attributes to keep
exports.ALLOWED_ATTRIBUTES = new Set([
    'alt',
    'allow',
    'allowfullscreen',
    'aria-label',
    'checked',
    'colspan',
    'controls',
    'data-latex',
    'data-src',
    'data-srcset',
    'data-lang',
    'dir',
    'display',
    'frameborder',
    'headers',
    'height',
    'href',
    'lang',
    'role',
    'rowspan',
    'src',
    'srcset',
    'title',
    'type',
    'width',
    // MathML attributes
    'accent',
    'accentunder',
    'align',
    'columnalign',
    'columnlines',
    'columnspacing',
    'columnspan',
    'data-mjx-texclass',
    'depth',
    'displaystyle',
    'fence',
    'frame',
    'framespacing',
    'linethickness',
    'lspace',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'scriptlevel',
    'separator',
    'stretchy',
    'symmetric',
    'voffset',
    'xmlns'
]);
exports.ALLOWED_ATTRIBUTES_DEBUG = new Set([
    'class',
    'id',
]);
// Supported languages for code blocks
exports.SUPPORTED_LANGUAGES = new Set([
    // Markup & Web
    'markup', 'html', 'xml', 'svg', 'mathml', 'ssml', 'atom', 'rss',
    'javascript', 'js', 'jsx', 'typescript', 'ts', 'tsx',
    'webassembly', 'wasm',
    // Common Programming Languages
    'python',
    'java',
    'csharp', 'cs', 'dotnet', 'aspnet',
    'cpp', 'c++', 'c', 'objc',
    'ruby', 'rb',
    'php',
    'golang',
    'rust',
    'swift',
    'kotlin',
    'scala',
    'dart',
    // Shell & Scripting
    'bash', 'shell', 'sh',
    'powershell',
    'batch',
    // Data & Config
    'json', 'jsonp',
    'yaml', 'yml',
    'toml',
    'dockerfile',
    'gitignore',
    // Query Languages
    'sql', 'mysql', 'postgresql',
    'graphql',
    'mongodb',
    'sparql',
    // Markup & Documentation
    'markdown', 'md',
    'latex', 'tex',
    'asciidoc', 'adoc',
    'jsdoc',
    // Functional Languages
    'haskell', 'hs',
    'elm',
    'elixir',
    'erlang',
    'ocaml',
    'fsharp',
    'scheme',
    'lisp', 'elisp',
    'clojure',
    // Other Languages
    'matlab',
    'fortran',
    'cobol',
    'pascal',
    'perl',
    'lua',
    'julia',
    'groovy',
    'crystal',
    'nim',
    'zig',
    // Domain Specific
    'regex',
    'gradle',
    'cmake',
    'makefile',
    'nix',
    'terraform',
    'solidity',
    'glsl',
    'hlsl',
    // Assembly
    'nasm',
    'masm',
    'armasm',
    // Game Development
    'gdscript',
    'unrealscript',
    // Others
    'abap',
    'actionscript',
    'ada',
    'agda',
    'antlr4',
    'applescript',
    'arduino',
    'coffeescript',
    'django',
    'erlang',
    'fortran',
    'haxe',
    'idris',
    'kotlin',
    'livescript',
    'matlab',
    'nginx',
    'pascal',
    'prolog',
    'puppet',
    'scala',
    'scheme',
    'tcl',
    'verilog',
    'vhdl'
]);


/***/ }),

/***/ 914:
/*!*******************************************!*\
  !*** ./node_modules/temml/dist/temml.cjs ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/**
 * This is the ParseError class, which is the main error thrown by Temml
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */
class ParseError {
  constructor(
    message, // The error message
    token // An object providing position information
  ) {
    let error = " " + message;
    let start;

    const loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      // If we have the input and a position, make the error a bit fancier

      // Get the input
      const input = loc.lexer.input;

      // Prepend some information
      start = loc.start;
      const end = loc.end;
      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": \n";
      }

      // Underline token in question using combining underscores
      const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

      // Extract some context from the input and add it to the error
      let left;
      if (start > 15) {
        left = "…" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      let right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "…";
      } else {
        right = input.slice(end);
      }
      error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    const self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;
    self.position = start;
    return self;
  }
}

ParseError.prototype.__proto__ = Error.prototype;

//
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide a default value if a setting is undefined
 */
const deflt = function(setting, defaultIfUndefined) {
  return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

const uppercase = /([A-Z])/g;
const hyphenate = function(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};

const ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};

const ESCAPE_REGEX = /[&><"']/g;

/**
 * Escapes text to prevent scripting attacks.
 */
function escape(text) {
  return String(text).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
const getBaseElem = function(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem(group.body);
  } else {
    return group;
  }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
const isCharacterBox = function(group) {
  const baseElem = getBaseElem(group);

  // These are all the types of groups which hold single characters
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom"
};

const assert = function(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};

/**
 * Return the protocol of a URL, or "_relative" if the URL does not specify a
 * protocol (and thus is relative), or `null` if URL has invalid protocol
 * (so should be outright rejected).
 */
const protocolFromUrl = function(url) {
  // Check for possible leading protocol.
  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace
  // (\x00) or C0 control (\x00-\x1F) characters.
  // eslint-disable-next-line no-control-regex
  const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
  if (!protocol) {
    return "_relative";
  }
  // Reject weird colons
  if (protocol[2] !== ":") {
    return null;
  }
  // Reject invalid characters in scheme according to
  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  // Lowercase the protocol
  return protocol[1].toLowerCase();
};

/**
 * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. The TeXbook
 * gives an acceptable rounding error of 100sp (which would be the nearest
 * 1/6551.6em with our ptPerEm = 10):
 * http://www.ctex.org/documents/shredder/src/texbook.pdf#page=69
 */
const round = function(n) {
  return +n.toFixed(4);
};

var utils = {
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl,
  round
};

/**
 * This is a module for storing settings passed into Temml. It correctly handles
 * default settings.
 */


/**
 * The main Settings object
 */
class Settings {
  constructor(options) {
    // allow null options
    options = options || {};
    this.displayMode = utils.deflt(options.displayMode, false);    // boolean
    this.annotate = utils.deflt(options.annotate, false);           // boolean
    this.leqno = utils.deflt(options.leqno, false);                // boolean
    this.throwOnError = utils.deflt(options.throwOnError, false);  // boolean
    this.errorColor = utils.deflt(options.errorColor, "#b22222");  // string
    this.macros = options.macros || {};
    this.wrap = utils.deflt(options.wrap, "tex");                    // "tex" | "="
    this.xml = utils.deflt(options.xml, false);                     // boolean
    this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);  // booelean
    this.strict = utils.deflt(options.strict, false);    // boolean
    this.trust = utils.deflt(options.trust, false);  // trust context. See html.js.
    this.maxSize = (options.maxSize === undefined
      ? [Infinity, Infinity]
      : Array.isArray(options.maxSize)
      ? options.maxSize
      : [Infinity, Infinity]
    );
    this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000)); // number
  }

  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      const protocol = utils.protocolFromUrl(context.url);
      if (protocol == null) {
        return false
      }
      context.protocol = protocol;
    }
    const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
}

/**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */
const _functions = {};

/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */
const _mathmlGroupBuilders = {};

function defineFunction({
  type,
  names,
  props,
  handler,
  mathmlBuilder
}) {
  // Set default values of functions
  const data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler: handler
  };
  for (let i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }
  if (type) {
    if (mathmlBuilder) {
      _mathmlGroupBuilders[type] = mathmlBuilder;
    }
  }
}

/**
 * Use this to register only the MathML builder for a function(e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */
function defineFunctionBuilders({ type, mathmlBuilder }) {
  defineFunction({
    type,
    names: [],
    props: { numArgs: 0 },
    handler() {
      throw new Error("Should never be called.")
    },
    mathmlBuilder
  });
}

const normalizeArgument = function(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg
};

// Since the corresponding buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
const ordargument = function(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg]
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */
class DocumentFragment {
  constructor(children) {
    this.children = children;
    this.classes = [];
    this.style = {};
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  /** Convert the fragment into a node. */
  toNode() {
    const frag = document.createDocumentFragment();

    for (let i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }

    return frag;
  }

  /** Convert the fragment into HTML markup. */
  toMarkup() {
    let markup = "";

    // Simply concatenate the markup for the children together.
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    // To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    const toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
}

/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 */

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */
const createClass = function(classes) {
  return classes.filter((cls) => cls).join(" ");
};

const initNode = function(classes, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.style = style || {};
};

/**
 * Convert into an HTML node
 */
const toNode = function(tagName) {
  const node = document.createElement(tagName);

  // Apply the class
  node.className = createClass(this.classes);

  // Apply inline styles
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      node.style[style] = this.style[style];
    }
  }

  // Apply attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  }

  // Append the children, also as HTML nodes
  for (let i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }

  return node;
};

/**
 * Convert into an HTML markup string
 */
const toMarkup = function(tagName) {
  let markup = `<${tagName}`;

  // Add the class
  if (this.classes.length) {
    markup += ` class="${utils.escape(createClass(this.classes))}"`;
  }

  let styles = "";

  // Add the styles, after hyphenation
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      styles += `${utils.hyphenate(style)}:${this.style[style]};`;
    }
  }

  if (styles) {
    markup += ` style="${styles}"`;
  }

  // Add the attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      markup += ` ${attr}="${utils.escape(this.attributes[attr])}"`;
    }
  }

  markup += ">";

  // Add the markup of the children, also as markup
  for (let i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }

  markup += `</${tagName}>`;

  return markup;
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style.
 *
 */
class Span {
  constructor(classes, children, style) {
    initNode.call(this, classes, style);
    this.children = children || [];
  }

  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  toNode() {
    return toNode.call(this, "span");
  }

  toMarkup() {
    return toMarkup.call(this, "span");
  }
}

let TextNode$1 = class TextNode {
  constructor(text) {
    this.text = text;
  }
  toNode() {
    return document.createTextNode(this.text);
  }
  toMarkup() {
    return utils.escape(this.text);
  }
};

// Create an <a href="…"> node.
class AnchorNode {
  constructor(href, classes, children) {
    this.href = href;
    this.classes = classes;
    this.children = children || [];
  }

  toNode() {
    const node = document.createElement("a");
    node.setAttribute("href", this.href);
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node
  }

  toMarkup() {
    let markup = `<a href='${utils.escape(this.href)}'`;
    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }
    markup += ">";
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</a>";
    return markup
  }
}

/*
 * This node represents an image embed (<img>) element.
 */
class Img {
  constructor(src, alt, style) {
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  toNode() {
    const node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    return node;
  }

  toMarkup() {
    let markup = `<img src='${this.src}' alt='${this.alt}'`;

    // Add the styles, after hyphenation
    let styles = "";
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }
    if (styles) {
      markup += ` style="${utils.escape(styles)}"`;
    }

    markup += ">";
    return markup;
  }
}

//
/**
 * These objects store data about MathML nodes.
 * The `toNode` and `toMarkup` functions  create namespaced DOM nodes and
 * HTML text markup respectively.
 */


function newDocumentFragment(children) {
  return new DocumentFragment(children);
}

/**
 * This node represents a general purpose MathML node of any type,
 * for example, `"mo"` or `"mspace"`, corresponding to `<mo>` and
 * `<mspace>` tags).
 */
class MathNode {
  constructor(type, children, classes, style) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
    this.style = style || {};   // Used for <mstyle> elements
    this.label = "";
  }

  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value) {
    this.attributes[name] = value;
  }

  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }

  setLabel(value) {
    this.label = value;
  }

  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }

  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    let markup = "<" + this.type;

    // Add the attributes
    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils.escape(this.attributes[attr]);
        markup += '"';
      }
    }

    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }

    let styles = "";

    // Add the styles, after hyphenation
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }

    if (styles) {
      markup += ` style="${styles}"`;
    }

    markup += ">";

    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}

/**
 * This node represents a piece of text.
 */
class TextNode {
  constructor(text) {
    this.text = text;
  }

  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }

  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }

  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}

// Do not make an <mrow> the only child of a <mstyle>.
// An <mstyle> acts as its own implicit <mrow>.
const wrapWithMstyle = expression => {
  let node;
  if (expression.length === 1 && expression[0].type === "mrow") {
    node = expression.pop();
    node.type = "mstyle";
  } else {
    node = new MathNode("mstyle", expression);
  }
  return node
};

var mathMLTree = {
  MathNode,
  TextNode,
  newDocumentFragment
};

/**
 * This file provides support for building horizontal stretchy elements.
 */


// TODO: Remove when Chromium stretches \widetilde & \widehat
const estimatedWidth = node => {
  let width = 0;
  if (node.body) {
    for (const item of node.body) {
      width += estimatedWidth(item);
    }
  } else if (node.type === "supsub") {
    width += estimatedWidth(node.base);
    if (node.sub) { width += 0.7 * estimatedWidth(node.sub); }
    if (node.sup) { width += 0.7 * estimatedWidth(node.sup); }
  } else if (node.type === "mathord" || node.type === "textord") {
    for (const ch of node.text.split('')) {
      const codePoint = ch.codePointAt(0);
      if ((0x60 < codePoint && codePoint < 0x7B) || (0x03B0 < codePoint && codePoint < 0x3CA)) {
        width += 0.56; // lower case latin or greek. Use advance width of letter n
      } else if (0x2F < codePoint && codePoint < 0x3A) {
        width += 0.50; // numerals.
      } else {
        width += 0.92; // advance width of letter M
      }
    }
  } else {
    width += 1.0;
  }
  return width
};

const stretchyCodePoint = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  wideparen: "⏜", // \u23dc
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23df",
  overbrace: "\u23de",
  overgroup: "\u23e0",
  overparen: "⏜",
  undergroup: "\u23e1",
  underparen: "\u23dd",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21d2",
  xRightarrow: "\u21d2",
  overleftharpoon: "\u21bc",
  xleftharpoonup: "\u21bc",
  overrightharpoon: "\u21c0",
  xrightharpoonup: "\u21c0",
  xLeftarrow: "\u21d0",
  xLeftrightarrow: "\u21d4",
  xhookleftarrow: "\u21a9",
  xhookrightarrow: "\u21aa",
  xmapsto: "\u21a6",
  xrightharpoondown: "\u21c1",
  xleftharpoondown: "\u21bd",
  xtwoheadleftarrow: "\u219e",
  xtwoheadrightarrow: "\u21a0",
  xlongequal: "=",
  xrightleftarrows: "\u21c4",
  yields: "\u2192",
  yieldsLeft: "\u2190",
  mesomerism: "\u2194",
  longrightharpoonup: "\u21c0",
  longleftharpoondown: "\u21bd",
  eqrightharpoonup: "\u21c0",
  eqleftharpoondown: "\u21bd",
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};

const mathMLnode = function(label) {
  const child = new mathMLTree.TextNode(stretchyCodePoint[label.slice(1)]);
  const node = new mathMLTree.MathNode("mo", [child]);
  node.setAttribute("stretchy", "true");
  return node
};

const crookedWides = ["\\widetilde", "\\widehat", "\\widecheck", "\\utilde"];

// TODO: Remove when Chromium stretches \widetilde & \widehat
const accentNode = (group) => {
  const mo = mathMLnode(group.label);
  if (crookedWides.includes(group.label)) {
    const width = estimatedWidth(group.base);
    if (1 < width && width < 1.6) {
      mo.classes.push("tml-crooked-2");
    } else if (1.6 <= width && width < 2.5) {
      mo.classes.push("tml-crooked-3");
    } else if (2.5 <= width) {
      mo.classes.push("tml-crooked-4");
    }
  }
  return mo
};

var stretchy = {
  mathMLnode,
  accentNode
};

/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are two properties they can have:
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

// Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
const ATOMS = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
};
const NON_ATOMS = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
};

const symbols = {
  math: {},
  text: {}
};

/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */
function defineSymbol(mode, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = { group, replace };

  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
const math = "math";
const text = "text";

// groups:
const accent = "accent-token";
const bin = "bin";
const close = "close";
const inner = "inner";
const mathord = "mathord";
const op = "op-token";
const open = "open";
const punct = "punct";
const rel = "rel";
const spacing = "spacing";
const textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, rel, "\u2261", "\\equiv", true);
defineSymbol(math, rel, "\u227a", "\\prec", true);
defineSymbol(math, rel, "\u227b", "\\succ", true);
defineSymbol(math, rel, "\u223c", "\\sim", true);
defineSymbol(math, rel, "\u27c2", "\\perp", true);
defineSymbol(math, rel, "\u2aaf", "\\preceq", true);
defineSymbol(math, rel, "\u2ab0", "\\succeq", true);
defineSymbol(math, rel, "\u2243", "\\simeq", true);
defineSymbol(math, rel, "\u224c", "\\backcong", true);
defineSymbol(math, rel, "|", "\\mid", true);
defineSymbol(math, rel, "\u226a", "\\ll", true);
defineSymbol(math, rel, "\u226b", "\\gg", true);
defineSymbol(math, rel, "\u224d", "\\asymp", true);
defineSymbol(math, rel, "\u2225", "\\parallel");
defineSymbol(math, rel, "\u2323", "\\smile", true);
defineSymbol(math, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, rel, "\u2250", "\\doteq", true);
defineSymbol(math, rel, "\u2322", "\\frown", true);
defineSymbol(math, rel, "\u220b", "\\ni", true);
defineSymbol(math, rel, "\u220c", "\\notni", true);
defineSymbol(math, rel, "\u221d", "\\propto", true);
defineSymbol(math, rel, "\u22a2", "\\vdash", true);
defineSymbol(math, rel, "\u22a3", "\\dashv", true);
defineSymbol(math, rel, "\u220b", "\\owns");
defineSymbol(math, rel, "\u2258", "\\arceq", true);
defineSymbol(math, rel, "\u2259", "\\wedgeq", true);
defineSymbol(math, rel, "\u225a", "\\veeeq", true);
defineSymbol(math, rel, "\u225b", "\\stareq", true);
defineSymbol(math, rel, "\u225d", "\\eqdef", true);
defineSymbol(math, rel, "\u225e", "\\measeq", true);
defineSymbol(math, rel, "\u225f", "\\questeq", true);
defineSymbol(math, rel, "\u2260", "\\ne", true);
defineSymbol(math, rel, "\u2260", "\\neq");
// unicodemath
defineSymbol(math, rel, "\u2a75", "\\eqeq", true);
defineSymbol(math, rel, "\u2a76", "\\eqeqeq", true);
// mathtools.sty
defineSymbol(math, rel, "\u2237", "\\dblcolon", true);
defineSymbol(math, rel, "\u2254", "\\coloneqq", true);
defineSymbol(math, rel, "\u2255", "\\eqqcolon", true);
defineSymbol(math, rel, "\u2239", "\\eqcolon", true);
defineSymbol(math, rel, "\u2A74", "\\Coloneqq", true);

// Punctuation
defineSymbol(math, punct, "\u002e", "\\ldotp");
defineSymbol(math, punct, "\u00b7", "\\cdotp");

// Misc Symbols
defineSymbol(math, textord, "\u0023", "\\#");
defineSymbol(text, textord, "\u0023", "\\#");
defineSymbol(math, textord, "\u0026", "\\&");
defineSymbol(text, textord, "\u0026", "\\&");
defineSymbol(math, textord, "\u2135", "\\aleph", true);
defineSymbol(math, textord, "\u2200", "\\forall", true);
defineSymbol(math, textord, "\u210f", "\\hbar", true);
defineSymbol(math, textord, "\u2203", "\\exists", true);
// ∇ is actually a unary operator, not binary. But this works.
defineSymbol(math, bin, "\u2207", "\\nabla", true);
defineSymbol(math, textord, "\u266d", "\\flat", true);
defineSymbol(math, textord, "\u2113", "\\ell", true);
defineSymbol(math, textord, "\u266e", "\\natural", true);
defineSymbol(math, textord, "Å", "\\Angstrom", true);
defineSymbol(text, textord, "Å", "\\Angstrom", true);
defineSymbol(math, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, textord, "\u2667", "\\varclubsuit", true);
defineSymbol(math, textord, "\u2118", "\\wp", true);
defineSymbol(math, textord, "\u266f", "\\sharp", true);
defineSymbol(math, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, textord, "\u2666", "\\vardiamondsuit", true);
defineSymbol(math, textord, "\u211c", "\\Re", true);
defineSymbol(math, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, textord, "\u2665", "\\varheartsuit", true);
defineSymbol(math, textord, "\u2111", "\\Im", true);
defineSymbol(math, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, textord, "\u2664", "\\varspadesuit", true);
defineSymbol(math, textord, "\u2640", "\\female", true);
defineSymbol(math, textord, "\u2642", "\\male", true);
defineSymbol(math, textord, "\u00a7", "\\S", true);
defineSymbol(text, textord, "\u00a7", "\\S");
defineSymbol(math, textord, "\u00b6", "\\P", true);
defineSymbol(text, textord, "\u00b6", "\\P");
defineSymbol(text, textord, "\u263a", "\\smiley", true);
defineSymbol(math, textord, "\u263a", "\\smiley", true);

// Math and Text
defineSymbol(math, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\textdagger");
defineSymbol(math, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\textdaggerdbl");

// Large Delimiters
defineSymbol(math, close, "\u23b1", "\\rmoustache", true);
defineSymbol(math, open, "\u23b0", "\\lmoustache", true);
defineSymbol(math, close, "\u27ef", "\\rgroup", true);
defineSymbol(math, open, "\u27ee", "\\lgroup", true);

// Binary Operators
defineSymbol(math, bin, "\u2213", "\\mp", true);
defineSymbol(math, bin, "\u2296", "\\ominus", true);
defineSymbol(math, bin, "\u228e", "\\uplus", true);
defineSymbol(math, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, bin, "\u2217", "\\ast");
defineSymbol(math, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, bin, "\u25ef", "\\bigcirc", true);
defineSymbol(math, bin, "\u2219", "\\bullet", true);
defineSymbol(math, bin, "\u2021", "\\ddagger");
defineSymbol(math, bin, "\u2240", "\\wr", true);
defineSymbol(math, bin, "\u2a3f", "\\amalg");
defineSymbol(math, bin, "\u0026", "\\And"); // from amsmath
defineSymbol(math, bin, "\u2AFD", "\\sslash", true); // from stmaryrd

// Arrow Symbols
defineSymbol(math, rel, "\u27f5", "\\longleftarrow", true);
defineSymbol(math, rel, "\u21d0", "\\Leftarrow", true);
defineSymbol(math, rel, "\u27f8", "\\Longleftarrow", true);
defineSymbol(math, rel, "\u27f6", "\\longrightarrow", true);
defineSymbol(math, rel, "\u21d2", "\\Rightarrow", true);
defineSymbol(math, rel, "\u27f9", "\\Longrightarrow", true);
defineSymbol(math, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, rel, "\u27f7", "\\longleftrightarrow", true);
defineSymbol(math, rel, "\u21d4", "\\Leftrightarrow", true);
defineSymbol(math, rel, "\u27fa", "\\Longleftrightarrow", true);
defineSymbol(math, rel, "\u21a4", "\\mapsfrom", true);
defineSymbol(math, rel, "\u21a6", "\\mapsto", true);
defineSymbol(math, rel, "\u27fc", "\\longmapsto", true);
defineSymbol(math, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, rel, "\u21a9", "\\hookleftarrow", true);
defineSymbol(math, rel, "\u21aa", "\\hookrightarrow", true);
defineSymbol(math, rel, "\u2198", "\\searrow", true);
defineSymbol(math, rel, "\u21bc", "\\leftharpoonup", true);
defineSymbol(math, rel, "\u21c0", "\\rightharpoonup", true);
defineSymbol(math, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, rel, "\u21bd", "\\leftharpoondown", true);
defineSymbol(math, rel, "\u21c1", "\\rightharpoondown", true);
defineSymbol(math, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, rel, "\u21cc", "\\rightleftharpoons", true);
defineSymbol(math, mathord, "\u21af", "\\lightning", true);
defineSymbol(math, mathord, "\u220E", "\\QED", true);
defineSymbol(math, mathord, "\u2030", "\\permil", true);
defineSymbol(text, textord, "\u2030", "\\permil");
defineSymbol(math, mathord, "\u2609", "\\astrosun", true);
defineSymbol(math, mathord, "\u263c", "\\sun", true);
defineSymbol(math, mathord, "\u263e", "\\leftmoon", true);
defineSymbol(math, mathord, "\u263d", "\\rightmoon", true);
defineSymbol(math, mathord, "\u2295", "\\Earth");

// AMS Negated Binary Relations
defineSymbol(math, rel, "\u226e", "\\nless", true);
// Symbol names preceeded by "@" each have a corresponding macro.
defineSymbol(math, rel, "\u2a87", "\\lneq", true);
defineSymbol(math, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, rel, "\u2268\ufe00", "\\lvertneqq");
defineSymbol(math, rel, "\u22e6", "\\lnsim", true);
defineSymbol(math, rel, "\u2a89", "\\lnapprox", true);
defineSymbol(math, rel, "\u2280", "\\nprec", true);
// unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e0", "\\npreceq", true);
defineSymbol(math, rel, "\u22e8", "\\precnsim", true);
defineSymbol(math, rel, "\u2ab9", "\\precnapprox", true);
defineSymbol(math, rel, "\u2241", "\\nsim", true);
defineSymbol(math, rel, "\u2224", "\\nmid", true);
defineSymbol(math, rel, "\u2224", "\\nshortmid");
defineSymbol(math, rel, "\u22ac", "\\nvdash", true);
defineSymbol(math, rel, "\u22ad", "\\nvDash", true);
defineSymbol(math, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, rel, "\u22ec", "\\ntrianglelefteq", true);
defineSymbol(math, rel, "\u2284", "\\nsubset", true);
defineSymbol(math, rel, "\u2285", "\\nsupset", true);
defineSymbol(math, rel, "\u228a", "\\subsetneq", true);
defineSymbol(math, rel, "\u228a\ufe00", "\\varsubsetneq");
defineSymbol(math, rel, "\u2acb", "\\subsetneqq", true);
defineSymbol(math, rel, "\u2acb\ufe00", "\\varsubsetneqq");
defineSymbol(math, rel, "\u226f", "\\ngtr", true);
defineSymbol(math, rel, "\u2a88", "\\gneq", true);
defineSymbol(math, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, rel, "\u2269\ufe00", "\\gvertneqq");
defineSymbol(math, rel, "\u22e7", "\\gnsim", true);
defineSymbol(math, rel, "\u2a8a", "\\gnapprox", true);
defineSymbol(math, rel, "\u2281", "\\nsucc", true);
// unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e1", "\\nsucceq", true);
defineSymbol(math, rel, "\u22e9", "\\succnsim", true);
defineSymbol(math, rel, "\u2aba", "\\succnapprox", true);
// unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u2246", "\\ncong", true);
defineSymbol(math, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, rel, "\u2226", "\\nshortparallel");
defineSymbol(math, rel, "\u22af", "\\nVDash", true);
defineSymbol(math, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, rel, "\u22ed", "\\ntrianglerighteq", true);
defineSymbol(math, rel, "\u228b", "\\supsetneq", true);
defineSymbol(math, rel, "\u228b", "\\varsupsetneq");
defineSymbol(math, rel, "\u2acc", "\\supsetneqq", true);
defineSymbol(math, rel, "\u2acc\ufe00", "\\varsupsetneqq");
defineSymbol(math, rel, "\u22ae", "\\nVdash", true);
defineSymbol(math, rel, "\u2ab5", "\\precneqq", true);
defineSymbol(math, rel, "\u2ab6", "\\succneqq", true);
defineSymbol(math, bin, "\u22b4", "\\unlhd");
defineSymbol(math, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, rel, "\u219a", "\\nleftarrow", true);
defineSymbol(math, rel, "\u219b", "\\nrightarrow", true);
defineSymbol(math, rel, "\u21cd", "\\nLeftarrow", true);
defineSymbol(math, rel, "\u21cf", "\\nRightarrow", true);
defineSymbol(math, rel, "\u21ae", "\\nleftrightarrow", true);
defineSymbol(math, rel, "\u21ce", "\\nLeftrightarrow", true);

// AMS Misc
defineSymbol(math, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, textord, "\u210f", "\\hslash");
defineSymbol(math, textord, "\u25bd", "\\triangledown");
defineSymbol(math, textord, "\u25ca", "\\lozenge");
defineSymbol(math, textord, "\u24c8", "\\circledS");
defineSymbol(math, textord, "\u00ae", "\\circledR", true);
defineSymbol(text, textord, "\u00ae", "\\circledR");
defineSymbol(text, textord, "\u00ae", "\\textregistered");
defineSymbol(math, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, textord, "\u2204", "\\nexists");
defineSymbol(math, textord, "\u2127", "\\mho");
defineSymbol(math, textord, "\u2132", "\\Finv", true);
defineSymbol(math, textord, "\u2141", "\\Game", true);
defineSymbol(math, textord, "\u2035", "\\backprime");
defineSymbol(math, textord, "\u2036", "\\backdprime");
defineSymbol(math, textord, "\u2037", "\\backtrprime");
defineSymbol(math, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, textord, "\u2605", "\\bigstar");
defineSymbol(math, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, textord, "\u2201", "\\complement", true);
// unicode-math maps U+F0 to \matheth. We map to AMS function \eth
defineSymbol(math, textord, "\u00f0", "\\eth", true);
defineSymbol(text, textord, "\u00f0", "\u00f0");
defineSymbol(math, textord, "\u2571", "\\diagup");
defineSymbol(math, textord, "\u2572", "\\diagdown");
defineSymbol(math, textord, "\u25a1", "\\square");
defineSymbol(math, textord, "\u25a1", "\\Box");
defineSymbol(math, textord, "\u25ca", "\\Diamond");
// unicode-math maps U+A5 to \mathyen. We map to AMS function \yen
defineSymbol(math, textord, "\u00a5", "\\yen", true);
defineSymbol(text, textord, "\u00a5", "\\yen", true);
defineSymbol(math, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, textord, "\u2713", "\\checkmark");
defineSymbol(math, textord, "\u2717", "\\ballotx", true);
defineSymbol(text, textord, "\u2717", "\\ballotx");
defineSymbol(text, textord, "\u2022", "\\textbullet");

// AMS Hebrew
defineSymbol(math, textord, "\u2136", "\\beth", true);
defineSymbol(math, textord, "\u2138", "\\daleth", true);
defineSymbol(math, textord, "\u2137", "\\gimel", true);

// AMS Greek
defineSymbol(math, textord, "\u03dd", "\\digamma", true);
defineSymbol(math, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, open, "\u231C", "\\ulcorner", true);
defineSymbol(math, close, "\u231D", "\\urcorner", true);
defineSymbol(math, open, "\u231E", "\\llcorner", true);
defineSymbol(math, close, "\u231F", "\\lrcorner", true);

// AMS Binary Relations
defineSymbol(math, rel, "\u2266", "\\leqq", true);
defineSymbol(math, rel, "\u2a7d", "\\leqslant", true);
defineSymbol(math, rel, "\u2a95", "\\eqslantless", true);
defineSymbol(math, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, rel, "\u2a85", "\\lessapprox", true);
defineSymbol(math, rel, "\u224a", "\\approxeq", true);
defineSymbol(math, bin, "\u22d6", "\\lessdot");
defineSymbol(math, rel, "\u22d8", "\\lll", true);
defineSymbol(math, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, rel, "\u22da", "\\lesseqgtr", true);
defineSymbol(math, rel, "\u2a8b", "\\lesseqqgtr", true);
defineSymbol(math, rel, "\u2251", "\\doteqdot");
defineSymbol(math, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, rel, "\u223d", "\\backsim", true);
defineSymbol(math, rel, "\u22cd", "\\backsimeq", true);
defineSymbol(math, rel, "\u2ac5", "\\subseteqq", true);
defineSymbol(math, rel, "\u22d0", "\\Subset", true);
defineSymbol(math, rel, "\u228f", "\\sqsubset", true);
defineSymbol(math, rel, "\u227c", "\\preccurlyeq", true);
defineSymbol(math, rel, "\u22de", "\\curlyeqprec", true);
defineSymbol(math, rel, "\u227e", "\\precsim", true);
defineSymbol(math, rel, "\u2ab7", "\\precapprox", true);
defineSymbol(math, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, rel, "\u22a8", "\\vDash", true);
defineSymbol(math, rel, "\u22ab", "\\VDash", true);
defineSymbol(math, rel, "\u22aa", "\\Vvdash", true);
defineSymbol(math, rel, "\u2323", "\\smallsmile");
defineSymbol(math, rel, "\u2322", "\\smallfrown");
defineSymbol(math, rel, "\u224f", "\\bumpeq", true);
defineSymbol(math, rel, "\u224e", "\\Bumpeq", true);
defineSymbol(math, rel, "\u2267", "\\geqq", true);
defineSymbol(math, rel, "\u2a7e", "\\geqslant", true);
defineSymbol(math, rel, "\u2a96", "\\eqslantgtr", true);
defineSymbol(math, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, rel, "\u2a86", "\\gtrapprox", true);
defineSymbol(math, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, rel, "\u22d9", "\\ggg", true);
defineSymbol(math, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, rel, "\u22db", "\\gtreqless", true);
defineSymbol(math, rel, "\u2a8c", "\\gtreqqless", true);
defineSymbol(math, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, rel, "\u2257", "\\circeq", true);
defineSymbol(math, rel, "\u225c", "\\triangleq", true);
defineSymbol(math, rel, "\u223c", "\\thicksim");
defineSymbol(math, rel, "\u2248", "\\thickapprox");
defineSymbol(math, rel, "\u2ac6", "\\supseteqq", true);
defineSymbol(math, rel, "\u22d1", "\\Supset", true);
defineSymbol(math, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, rel, "\u227d", "\\succcurlyeq", true);
defineSymbol(math, rel, "\u22df", "\\curlyeqsucc", true);
defineSymbol(math, rel, "\u227f", "\\succsim", true);
defineSymbol(math, rel, "\u2ab8", "\\succapprox", true);
defineSymbol(math, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, rel, "\u22a9", "\\Vdash", true);
defineSymbol(math, rel, "\u2223", "\\shortmid");
defineSymbol(math, rel, "\u2225", "\\shortparallel");
defineSymbol(math, rel, "\u226c", "\\between", true);
defineSymbol(math, rel, "\u22d4", "\\pitchfork", true);
defineSymbol(math, rel, "\u221d", "\\varpropto");
defineSymbol(math, rel, "\u25c0", "\\blacktriangleleft");
// unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2234", "\\therefore", true);
defineSymbol(math, rel, "\u220d", "\\backepsilon");
defineSymbol(math, rel, "\u25b6", "\\blacktriangleright");
// unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2235", "\\because", true);
defineSymbol(math, rel, "\u22d8", "\\llless");
defineSymbol(math, rel, "\u22d9", "\\gggtr");
defineSymbol(math, bin, "\u22b2", "\\lhd");
defineSymbol(math, bin, "\u22b3", "\\rhd");
defineSymbol(math, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, rel, "\u2251", "\\Doteq", true);
defineSymbol(math, rel, "\u297d", "\\strictif", true);
defineSymbol(math, rel, "\u297c", "\\strictfi", true);

// AMS Binary Operators
defineSymbol(math, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, bin, "\u22d2", "\\Cap", true);
defineSymbol(math, bin, "\u22d3", "\\Cup", true);
defineSymbol(math, bin, "\u2a5e", "\\doublebarwedge", true);
defineSymbol(math, bin, "\u229f", "\\boxminus", true);
defineSymbol(math, bin, "\u229e", "\\boxplus", true);
defineSymbol(math, bin, "\u29C4", "\\boxslash", true);
defineSymbol(math, bin, "\u22c7", "\\divideontimes", true);
defineSymbol(math, bin, "\u22c9", "\\ltimes", true);
defineSymbol(math, bin, "\u22ca", "\\rtimes", true);
defineSymbol(math, bin, "\u22cb", "\\leftthreetimes", true);
defineSymbol(math, bin, "\u22cc", "\\rightthreetimes", true);
defineSymbol(math, bin, "\u22cf", "\\curlywedge", true);
defineSymbol(math, bin, "\u22ce", "\\curlyvee", true);
defineSymbol(math, bin, "\u229d", "\\circleddash", true);
defineSymbol(math, bin, "\u229b", "\\circledast", true);
defineSymbol(math, bin, "\u22ba", "\\intercal", true);
defineSymbol(math, bin, "\u22d2", "\\doublecap");
defineSymbol(math, bin, "\u22d3", "\\doublecup");
defineSymbol(math, bin, "\u22a0", "\\boxtimes", true);
defineSymbol(math, bin, "\u22c8", "\\bowtie", true);
defineSymbol(math, bin, "\u22c8", "\\Join");
defineSymbol(math, bin, "\u27d5", "\\leftouterjoin", true);
defineSymbol(math, bin, "\u27d6", "\\rightouterjoin", true);
defineSymbol(math, bin, "\u27d7", "\\fullouterjoin", true);

// stix Binary Operators
defineSymbol(math, bin, "\u2238", "\\dotminus", true);
defineSymbol(math, bin, "\u27D1", "\\wedgedot", true);
defineSymbol(math, bin, "\u27C7", "\\veedot", true);
defineSymbol(math, bin, "\u2A62", "\\doublebarvee", true);
defineSymbol(math, bin, "\u2A63", "\\veedoublebar", true);
defineSymbol(math, bin, "\u2A5F", "\\wedgebar", true);
defineSymbol(math, bin, "\u2A60", "\\wedgedoublebar", true);
defineSymbol(math, bin, "\u2A54", "\\Vee", true);
defineSymbol(math, bin, "\u2A53", "\\Wedge", true);
defineSymbol(math, bin, "\u2A43", "\\barcap", true);
defineSymbol(math, bin, "\u2A42", "\\barcup", true);
defineSymbol(math, bin, "\u2A48", "\\capbarcup", true);
defineSymbol(math, bin, "\u2A40", "\\capdot", true);
defineSymbol(math, bin, "\u2A47", "\\capovercup", true);
defineSymbol(math, bin, "\u2A46", "\\cupovercap", true);
defineSymbol(math, bin, "\u2A4D", "\\closedvarcap", true);
defineSymbol(math, bin, "\u2A4C", "\\closedvarcup", true);
defineSymbol(math, bin, "\u2A2A", "\\minusdot", true);
defineSymbol(math, bin, "\u2A2B", "\\minusfdots", true);
defineSymbol(math, bin, "\u2A2C", "\\minusrdots", true);
defineSymbol(math, bin, "\u22BB", "\\Xor", true);
defineSymbol(math, bin, "\u22BC", "\\Nand", true);
defineSymbol(math, bin, "\u22BD", "\\Nor", true);
defineSymbol(math, bin, "\u22BD", "\\barvee");
defineSymbol(math, bin, "\u2AF4", "\\interleave", true);
defineSymbol(math, bin, "\u29E2", "\\shuffle", true);
defineSymbol(math, bin, "\u2AF6", "\\threedotcolon", true);
defineSymbol(math, bin, "\u2982", "\\typecolon", true);
defineSymbol(math, bin, "\u223E", "\\invlazys", true);
defineSymbol(math, bin, "\u2A4B", "\\twocaps", true);
defineSymbol(math, bin, "\u2A4A", "\\twocups", true);
defineSymbol(math, bin, "\u2A4E", "\\Sqcap", true);
defineSymbol(math, bin, "\u2A4F", "\\Sqcup", true);
defineSymbol(math, bin, "\u2A56", "\\veeonvee", true);
defineSymbol(math, bin, "\u2A55", "\\wedgeonwedge", true);
defineSymbol(math, bin, "\u29D7", "\\blackhourglass", true);
defineSymbol(math, bin, "\u29C6", "\\boxast", true);
defineSymbol(math, bin, "\u29C8", "\\boxbox", true);
defineSymbol(math, bin, "\u29C7", "\\boxcircle", true);
defineSymbol(math, bin, "\u229C", "\\circledequal", true);
defineSymbol(math, bin, "\u29B7", "\\circledparallel", true);
defineSymbol(math, bin, "\u29B6", "\\circledvert", true);
defineSymbol(math, bin, "\u29B5", "\\circlehbar", true);
defineSymbol(math, bin, "\u27E1", "\\concavediamond", true);
defineSymbol(math, bin, "\u27E2", "\\concavediamondtickleft", true);
defineSymbol(math, bin, "\u27E3", "\\concavediamondtickright", true);
defineSymbol(math, bin, "\u22C4", "\\diamond", true);
defineSymbol(math, bin, "\u29D6", "\\hourglass", true);
defineSymbol(math, bin, "\u27E0", "\\lozengeminus", true);
defineSymbol(math, bin, "\u233D", "\\obar", true);
defineSymbol(math, bin, "\u29B8", "\\obslash", true);
defineSymbol(math, bin, "\u2A38", "\\odiv", true);
defineSymbol(math, bin, "\u29C1", "\\ogreaterthan", true);
defineSymbol(math, bin, "\u29C0", "\\olessthan", true);
defineSymbol(math, bin, "\u29B9", "\\operp", true);
defineSymbol(math, bin, "\u2A37", "\\Otimes", true);
defineSymbol(math, bin, "\u2A36", "\\otimeshat", true);
defineSymbol(math, bin, "\u22C6", "\\star", true);
defineSymbol(math, bin, "\u25B3", "\\triangle", true);
defineSymbol(math, bin, "\u2A3A", "\\triangleminus", true);
defineSymbol(math, bin, "\u2A39", "\\triangleplus", true);
defineSymbol(math, bin, "\u2A3B", "\\triangletimes", true);
defineSymbol(math, bin, "\u27E4", "\\whitesquaretickleft", true);
defineSymbol(math, bin, "\u27E5", "\\whitesquaretickright", true);
defineSymbol(math, bin, "\u2A33", "\\smashtimes", true);

// AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.
defineSymbol(math, rel, "\u21e2", "\\dashrightarrow", true);
// unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21e0", "\\dashleftarrow", true);
defineSymbol(math, rel, "\u21c7", "\\leftleftarrows", true);
defineSymbol(math, rel, "\u21c6", "\\leftrightarrows", true);
defineSymbol(math, rel, "\u21da", "\\Lleftarrow", true);
defineSymbol(math, rel, "\u219e", "\\twoheadleftarrow", true);
defineSymbol(math, rel, "\u21a2", "\\leftarrowtail", true);
defineSymbol(math, rel, "\u21ab", "\\looparrowleft", true);
defineSymbol(math, rel, "\u21cb", "\\leftrightharpoons", true);
defineSymbol(math, rel, "\u21b6", "\\curvearrowleft", true);
// unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21ba", "\\circlearrowleft", true);
defineSymbol(math, rel, "\u21b0", "\\Lsh", true);
defineSymbol(math, rel, "\u21c8", "\\upuparrows", true);
defineSymbol(math, rel, "\u21bf", "\\upharpoonleft", true);
defineSymbol(math, rel, "\u21c3", "\\downharpoonleft", true);
defineSymbol(math, rel, "\u22b6", "\\origof", true);
defineSymbol(math, rel, "\u22b7", "\\imageof", true);
defineSymbol(math, rel, "\u22b8", "\\multimap", true);
defineSymbol(math, rel, "\u21ad", "\\leftrightsquigarrow", true);
defineSymbol(math, rel, "\u21c9", "\\rightrightarrows", true);
defineSymbol(math, rel, "\u21c4", "\\rightleftarrows", true);
defineSymbol(math, rel, "\u21a0", "\\twoheadrightarrow", true);
defineSymbol(math, rel, "\u21a3", "\\rightarrowtail", true);
defineSymbol(math, rel, "\u21ac", "\\looparrowright", true);
defineSymbol(math, rel, "\u21b7", "\\curvearrowright", true);
// unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21bb", "\\circlearrowright", true);
defineSymbol(math, rel, "\u21b1", "\\Rsh", true);
defineSymbol(math, rel, "\u21ca", "\\downdownarrows", true);
defineSymbol(math, rel, "\u21be", "\\upharpoonright", true);
defineSymbol(math, rel, "\u21c2", "\\downharpoonright", true);
defineSymbol(math, rel, "\u21dd", "\\rightsquigarrow", true);
defineSymbol(math, rel, "\u21dd", "\\leadsto");
defineSymbol(math, rel, "\u21db", "\\Rrightarrow", true);
defineSymbol(math, rel, "\u21be", "\\restriction");

defineSymbol(math, textord, "\u2018", "`");
defineSymbol(math, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\textdollar");
defineSymbol(math, textord, "¢", "\\cent");
defineSymbol(text, textord, "¢", "\\cent");
defineSymbol(math, textord, "%", "\\%");
defineSymbol(text, textord, "%", "\\%");
defineSymbol(math, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\textunderscore");
defineSymbol(text, textord, "\u2423", "\\textvisiblespace", true);
defineSymbol(math, textord, "\u2220", "\\angle", true);
defineSymbol(math, textord, "\u221e", "\\infty", true);
defineSymbol(math, textord, "\u2032", "\\prime");
defineSymbol(math, textord, "\u2033", "\\dprime");
defineSymbol(math, textord, "\u2034", "\\trprime");
defineSymbol(math, textord, "\u2057", "\\qprime");
defineSymbol(math, textord, "\u25b3", "\\triangle");
defineSymbol(text, textord, "\u0391", "\\Alpha", true);
defineSymbol(text, textord, "\u0392", "\\Beta", true);
defineSymbol(text, textord, "\u0393", "\\Gamma", true);
defineSymbol(text, textord, "\u0394", "\\Delta", true);
defineSymbol(text, textord, "\u0395", "\\Epsilon", true);
defineSymbol(text, textord, "\u0396", "\\Zeta", true);
defineSymbol(text, textord, "\u0397", "\\Eta", true);
defineSymbol(text, textord, "\u0398", "\\Theta", true);
defineSymbol(text, textord, "\u0399", "\\Iota", true);
defineSymbol(text, textord, "\u039a", "\\Kappa", true);
defineSymbol(text, textord, "\u039b", "\\Lambda", true);
defineSymbol(text, textord, "\u039c", "\\Mu", true);
defineSymbol(text, textord, "\u039d", "\\Nu", true);
defineSymbol(text, textord, "\u039e", "\\Xi", true);
defineSymbol(text, textord, "\u039f", "\\Omicron", true);
defineSymbol(text, textord, "\u03a0", "\\Pi", true);
defineSymbol(text, textord, "\u03a1", "\\Rho", true);
defineSymbol(text, textord, "\u03a3", "\\Sigma", true);
defineSymbol(text, textord, "\u03a4", "\\Tau", true);
defineSymbol(text, textord, "\u03a5", "\\Upsilon", true);
defineSymbol(text, textord, "\u03a6", "\\Phi", true);
defineSymbol(text, textord, "\u03a7", "\\Chi", true);
defineSymbol(text, textord, "\u03a8", "\\Psi", true);
defineSymbol(text, textord, "\u03a9", "\\Omega", true);
defineSymbol(math, mathord, "\u0391", "\\Alpha", true);
defineSymbol(math, mathord, "\u0392", "\\Beta", true);
defineSymbol(math, mathord, "\u0393", "\\Gamma", true);
defineSymbol(math, mathord, "\u0394", "\\Delta", true);
defineSymbol(math, mathord, "\u0395", "\\Epsilon", true);
defineSymbol(math, mathord, "\u0396", "\\Zeta", true);
defineSymbol(math, mathord, "\u0397", "\\Eta", true);
defineSymbol(math, mathord, "\u0398", "\\Theta", true);
defineSymbol(math, mathord, "\u0399", "\\Iota", true);
defineSymbol(math, mathord, "\u039a", "\\Kappa", true);
defineSymbol(math, mathord, "\u039b", "\\Lambda", true);
defineSymbol(math, mathord, "\u039c", "\\Mu", true);
defineSymbol(math, mathord, "\u039d", "\\Nu", true);
defineSymbol(math, mathord, "\u039e", "\\Xi", true);
defineSymbol(math, mathord, "\u039f", "\\Omicron", true);
defineSymbol(math, mathord, "\u03a0", "\\Pi", true);
defineSymbol(math, mathord, "\u03a1", "\\Rho", true);
defineSymbol(math, mathord, "\u03a3", "\\Sigma", true);
defineSymbol(math, mathord, "\u03a4", "\\Tau", true);
defineSymbol(math, mathord, "\u03a5", "\\Upsilon", true);
defineSymbol(math, mathord, "\u03a6", "\\Phi", true);
defineSymbol(math, mathord, "\u03a7", "\\Chi", true);
defineSymbol(math, mathord, "\u03a8", "\\Psi", true);
defineSymbol(math, mathord, "\u03a9", "\\Omega", true);
defineSymbol(math, open, "\u00ac", "\\neg", true);
defineSymbol(math, open, "\u00ac", "\\lnot");
defineSymbol(math, textord, "\u22a4", "\\top");
defineSymbol(math, textord, "\u22a5", "\\bot");
defineSymbol(math, textord, "\u2205", "\\emptyset");
defineSymbol(math, textord, "\u2300", "\\varnothing");
defineSymbol(math, mathord, "\u03b1", "\\alpha", true);
defineSymbol(math, mathord, "\u03b2", "\\beta", true);
defineSymbol(math, mathord, "\u03b3", "\\gamma", true);
defineSymbol(math, mathord, "\u03b4", "\\delta", true);
defineSymbol(math, mathord, "\u03f5", "\\epsilon", true);
defineSymbol(math, mathord, "\u03b6", "\\zeta", true);
defineSymbol(math, mathord, "\u03b7", "\\eta", true);
defineSymbol(math, mathord, "\u03b8", "\\theta", true);
defineSymbol(math, mathord, "\u03b9", "\\iota", true);
defineSymbol(math, mathord, "\u03ba", "\\kappa", true);
defineSymbol(math, mathord, "\u03bb", "\\lambda", true);
defineSymbol(math, mathord, "\u03bc", "\\mu", true);
defineSymbol(math, mathord, "\u03bd", "\\nu", true);
defineSymbol(math, mathord, "\u03be", "\\xi", true);
defineSymbol(math, mathord, "\u03bf", "\\omicron", true);
defineSymbol(math, mathord, "\u03c0", "\\pi", true);
defineSymbol(math, mathord, "\u03c1", "\\rho", true);
defineSymbol(math, mathord, "\u03c3", "\\sigma", true);
defineSymbol(math, mathord, "\u03c4", "\\tau", true);
defineSymbol(math, mathord, "\u03c5", "\\upsilon", true);
defineSymbol(math, mathord, "\u03d5", "\\phi", true);
defineSymbol(math, mathord, "\u03c7", "\\chi", true);
defineSymbol(math, mathord, "\u03c8", "\\psi", true);
defineSymbol(math, mathord, "\u03c9", "\\omega", true);
defineSymbol(math, mathord, "\u03b5", "\\varepsilon", true);
defineSymbol(math, mathord, "\u03d1", "\\vartheta", true);
defineSymbol(math, mathord, "\u03d6", "\\varpi", true);
defineSymbol(math, mathord, "\u03f1", "\\varrho", true);
defineSymbol(math, mathord, "\u03c2", "\\varsigma", true);
defineSymbol(math, mathord, "\u03c6", "\\varphi", true);
defineSymbol(math, mathord, "\u03d8", "\\Coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\varcoppa", true);
defineSymbol(math, mathord, "\u03de", "\\Koppa", true);
defineSymbol(math, mathord, "\u03df", "\\koppa", true);
defineSymbol(math, mathord, "\u03e0", "\\Sampi", true);
defineSymbol(math, mathord, "\u03e1", "\\sampi", true);
defineSymbol(math, mathord, "\u03da", "\\Stigma", true);
defineSymbol(math, mathord, "\u03db", "\\stigma", true);
defineSymbol(math, mathord, "\u2aeb", "\\Bot");
defineSymbol(math, bin, "\u2217", "\u2217", true);
defineSymbol(math, bin, "+", "+");
defineSymbol(math, bin, "\u2217", "*");
defineSymbol(math, bin, "\u2044", "/", true);
defineSymbol(math, bin, "\u2044", "\u2044");
defineSymbol(math, bin, "\u2212", "-", true);
defineSymbol(math, bin, "\u22c5", "\\cdot", true);
defineSymbol(math, bin, "\u2218", "\\circ", true);
defineSymbol(math, bin, "\u00f7", "\\div", true);
defineSymbol(math, bin, "\u00b1", "\\pm", true);
defineSymbol(math, bin, "\u00d7", "\\times", true);
defineSymbol(math, bin, "\u2229", "\\cap", true);
defineSymbol(math, bin, "\u222a", "\\cup", true);
defineSymbol(math, bin, "\u2216", "\\setminus", true);
defineSymbol(math, bin, "\u2227", "\\land");
defineSymbol(math, bin, "\u2228", "\\lor");
defineSymbol(math, bin, "\u2227", "\\wedge", true);
defineSymbol(math, bin, "\u2228", "\\vee", true);
defineSymbol(math, open, "\u27e6", "\\llbracket", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u27e7", "\\rrbracket", true);
defineSymbol(math, open, "\u27e8", "\\langle", true);
defineSymbol(math, open, "\u27ea", "\\lAngle", true);
defineSymbol(math, open, "\u2989", "\\llangle", true);
defineSymbol(math, open, "|", "\\lvert");
defineSymbol(math, open, "\u2016", "\\lVert", true);
defineSymbol(math, textord, "!", "\\oc"); // cmll package
defineSymbol(math, textord, "?", "\\wn");
defineSymbol(math, textord, "\u2193", "\\shpos");
defineSymbol(math, textord, "\u2195", "\\shift");
defineSymbol(math, textord, "\u2191", "\\shneg");
defineSymbol(math, close, "?", "?");
defineSymbol(math, close, "!", "!");
defineSymbol(math, close, "‼", "‼");
defineSymbol(math, close, "\u27e9", "\\rangle", true);
defineSymbol(math, close, "\u27eb", "\\rAngle", true);
defineSymbol(math, close, "\u298a", "\\rrangle", true);
defineSymbol(math, close, "|", "\\rvert");
defineSymbol(math, close, "\u2016", "\\rVert");
defineSymbol(math, open, "\u2983", "\\lBrace", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u2984", "\\rBrace", true);
defineSymbol(math, rel, "=", "\\equal", true);
defineSymbol(math, rel, ":", ":");
defineSymbol(math, rel, "\u2248", "\\approx", true);
defineSymbol(math, rel, "\u2245", "\\cong", true);
defineSymbol(math, rel, "\u2265", "\\ge");
defineSymbol(math, rel, "\u2265", "\\geq", true);
defineSymbol(math, rel, "\u2190", "\\gets");
defineSymbol(math, rel, ">", "\\gt", true);
defineSymbol(math, rel, "\u2208", "\\in", true);
defineSymbol(math, rel, "\u2209", "\\notin", true);
defineSymbol(math, rel, "\ue020", "\\@not");
defineSymbol(math, rel, "\u2282", "\\subset", true);
defineSymbol(math, rel, "\u2283", "\\supset", true);
defineSymbol(math, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteqq");
defineSymbol(math, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, rel, "\u2289", "\\nsupseteqq");
defineSymbol(math, rel, "\u22a8", "\\models");
defineSymbol(math, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, rel, "\u2264", "\\le");
defineSymbol(math, rel, "\u2264", "\\leq", true);
defineSymbol(math, rel, "<", "\\lt", true);
defineSymbol(math, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, rel, "\u2192", "\\to");
defineSymbol(math, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, rel, "\u2271", "\\ngeqq");
defineSymbol(math, rel, "\u2271", "\\ngeqslant");
defineSymbol(math, rel, "\u2270", "\\nleq", true);
defineSymbol(math, rel, "\u2270", "\\nleqq");
defineSymbol(math, rel, "\u2270", "\\nleqslant");
defineSymbol(math, rel, "\u2aeb", "\\Perp", true); //cmll package
defineSymbol(math, spacing, "\u00a0", "\\ ");
defineSymbol(math, spacing, "\u00a0", "\\space");
// Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%
defineSymbol(math, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(text, spacing, "\u00a0", "\\ ");
defineSymbol(text, spacing, "\u00a0", " ");
defineSymbol(text, spacing, "\u00a0", "\\space");
defineSymbol(text, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(math, spacing, null, "\\nobreak");
defineSymbol(math, spacing, null, "\\allowbreak");
defineSymbol(math, punct, ",", ",");
defineSymbol(text, punct, ":", ":");
defineSymbol(math, punct, ";", ";");
defineSymbol(math, bin, "\u22bc", "\\barwedge");
defineSymbol(math, bin, "\u22bb", "\\veebar");
defineSymbol(math, bin, "\u2299", "\\odot", true);
// Firefox turns ⊕ into an emoji. So append \uFE0E. Define Unicode character in macros, not here.
defineSymbol(math, bin, "\u2295\uFE0E", "\\oplus");
defineSymbol(math, bin, "\u2297", "\\otimes", true);
defineSymbol(math, textord, "\u2202", "\\partial", true);
defineSymbol(math, bin, "\u2298", "\\oslash", true);
defineSymbol(math, bin, "\u229a", "\\circledcirc", true);
defineSymbol(math, bin, "\u22a1", "\\boxdot", true);
defineSymbol(math, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, bin, "\u2020", "\\dagger");
defineSymbol(math, bin, "\u22c4", "\\diamond");
defineSymbol(math, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, bin, "\u25b9", "\\triangleright");
defineSymbol(math, open, "{", "\\{");
defineSymbol(text, textord, "{", "\\{");
defineSymbol(text, textord, "{", "\\textbraceleft");
defineSymbol(math, close, "}", "\\}");
defineSymbol(text, textord, "}", "\\}");
defineSymbol(text, textord, "}", "\\textbraceright");
defineSymbol(math, open, "{", "\\lbrace");
defineSymbol(math, close, "}", "\\rbrace");
defineSymbol(math, open, "[", "\\lbrack", true);
defineSymbol(text, textord, "[", "\\lbrack", true);
defineSymbol(math, close, "]", "\\rbrack", true);
defineSymbol(text, textord, "]", "\\rbrack", true);
defineSymbol(math, open, "(", "\\lparen", true);
defineSymbol(math, close, ")", "\\rparen", true);
defineSymbol(math, open, "⦇", "\\llparenthesis", true);
defineSymbol(math, close, "⦈", "\\rrparenthesis", true);
defineSymbol(text, textord, "<", "\\textless", true); // in T1 fontenc
defineSymbol(text, textord, ">", "\\textgreater", true); // in T1 fontenc
defineSymbol(math, open, "\u230a", "\\lfloor", true);
defineSymbol(math, close, "\u230b", "\\rfloor", true);
defineSymbol(math, open, "\u2308", "\\lceil", true);
defineSymbol(math, close, "\u2309", "\\rceil", true);
defineSymbol(math, textord, "\\", "\\backslash");
defineSymbol(math, textord, "|", "|");
defineSymbol(math, textord, "|", "\\vert");
defineSymbol(text, textord, "|", "\\textbar", true); // in T1 fontenc
defineSymbol(math, textord, "\u2016", "\\|");
defineSymbol(math, textord, "\u2016", "\\Vert");
defineSymbol(text, textord, "\u2016", "\\textbardbl");
defineSymbol(text, textord, "~", "\\textasciitilde");
defineSymbol(text, textord, "\\", "\\textbackslash");
defineSymbol(text, textord, "^", "\\textasciicircum");
defineSymbol(math, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, rel, "\u21d1", "\\Uparrow", true);
defineSymbol(math, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, rel, "\u21d3", "\\Downarrow", true);
defineSymbol(math, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, rel, "\u21d5", "\\Updownarrow", true);
defineSymbol(math, op, "\u2210", "\\coprod");
defineSymbol(math, op, "\u22c1", "\\bigvee");
defineSymbol(math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, op, "\u2a04", "\\biguplus");
defineSymbol(math, op, "\u2a04", "\\bigcupplus");
defineSymbol(math, op, "\u2a03", "\\bigcupdot");
defineSymbol(math, op, "\u2a07", "\\bigdoublevee");
defineSymbol(math, op, "\u2a08", "\\bigdoublewedge");
defineSymbol(math, op, "\u22c2", "\\bigcap");
defineSymbol(math, op, "\u22c3", "\\bigcup");
defineSymbol(math, op, "\u222b", "\\int");
defineSymbol(math, op, "\u222b", "\\intop");
defineSymbol(math, op, "\u222c", "\\iint");
defineSymbol(math, op, "\u222d", "\\iiint");
defineSymbol(math, op, "\u220f", "\\prod");
defineSymbol(math, op, "\u2211", "\\sum");
defineSymbol(math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, op, "\u2a00", "\\bigodot");
defineSymbol(math, op, "\u2a09", "\\bigtimes");
defineSymbol(math, op, "\u222e", "\\oint");
defineSymbol(math, op, "\u222f", "\\oiint");
defineSymbol(math, op, "\u2230", "\\oiiint");
defineSymbol(math, op, "\u2231", "\\intclockwise");
defineSymbol(math, op, "\u2232", "\\varointclockwise");
defineSymbol(math, op, "\u2a0c", "\\iiiint");
defineSymbol(math, op, "\u2a0d", "\\intbar");
defineSymbol(math, op, "\u2a0e", "\\intBar");
defineSymbol(math, op, "\u2a0f", "\\fint");
defineSymbol(math, op, "\u2a12", "\\rppolint");
defineSymbol(math, op, "\u2a13", "\\scpolint");
defineSymbol(math, op, "\u2a15", "\\pointint");
defineSymbol(math, op, "\u2a16", "\\sqint");
defineSymbol(math, op, "\u2a17", "\\intlarhk");
defineSymbol(math, op, "\u2a18", "\\intx");
defineSymbol(math, op, "\u2a19", "\\intcap");
defineSymbol(math, op, "\u2a1a", "\\intcup");
defineSymbol(math, op, "\u2a05", "\\bigsqcap");
defineSymbol(math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, op, "\u222b", "\\smallint");
defineSymbol(text, inner, "\u2026", "\\textellipsis");
defineSymbol(math, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u22f0", "\\iddots", true);
defineSymbol(math, inner, "\u22ef", "\\@cdots", true);
defineSymbol(math, inner, "\u22f1", "\\ddots", true);
defineSymbol(math, textord, "\u22ee", "\\varvdots"); // \vdots is a macro
defineSymbol(text, textord, "\u22ee", "\\varvdots");
defineSymbol(math, accent, "\u02ca", "\\acute");
defineSymbol(math, accent, "\u0060", "\\grave");
defineSymbol(math, accent, "\u00a8", "\\ddot");
defineSymbol(math, accent, "\u2026", "\\dddot");
defineSymbol(math, accent, "\u2026\u002e", "\\ddddot");
defineSymbol(math, accent, "\u007e", "\\tilde");
defineSymbol(math, accent, "\u203e", "\\bar");
defineSymbol(math, accent, "\u02d8", "\\breve");
defineSymbol(math, accent, "\u02c7", "\\check");
defineSymbol(math, accent, "\u005e", "\\hat");
defineSymbol(math, accent, "\u2192", "\\vec");
defineSymbol(math, accent, "\u02d9", "\\dot");
defineSymbol(math, accent, "\u02da", "\\mathring");
defineSymbol(math, mathord, "\u0131", "\\imath", true);
defineSymbol(math, mathord, "\u0237", "\\jmath", true);
defineSymbol(math, textord, "\u0131", "\u0131");
defineSymbol(math, textord, "\u0237", "\u0237");
defineSymbol(text, textord, "\u0131", "\\i", true);
defineSymbol(text, textord, "\u0237", "\\j", true);
defineSymbol(text, textord, "\u00df", "\\ss", true);
defineSymbol(text, textord, "\u00e6", "\\ae", true);
defineSymbol(text, textord, "\u0153", "\\oe", true);
defineSymbol(text, textord, "\u00f8", "\\o", true);
defineSymbol(math, mathord, "\u00f8", "\\o", true);
defineSymbol(text, textord, "\u00c6", "\\AE", true);
defineSymbol(text, textord, "\u0152", "\\OE", true);
defineSymbol(text, textord, "\u00d8", "\\O", true);
defineSymbol(math, mathord, "\u00d8", "\\O", true);
defineSymbol(text, accent, "\u02ca", "\\'"); // acute
defineSymbol(text, accent, "\u02cb", "\\`"); // grave
defineSymbol(text, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(text, accent, "\u02dc", "\\~"); // tilde
defineSymbol(text, accent, "\u02c9", "\\="); // macron
defineSymbol(text, accent, "\u02d8", "\\u"); // breve
defineSymbol(text, accent, "\u02d9", "\\."); // dot above
defineSymbol(text, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(text, accent, "\u02da", "\\r"); // ring above
defineSymbol(text, accent, "\u02c7", "\\v"); // caron
defineSymbol(text, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(text, accent, "\u02dd", "\\H"); // double acute
defineSymbol(math, accent, "\u02ca", "\\'"); // acute
defineSymbol(math, accent, "\u02cb", "\\`"); // grave
defineSymbol(math, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(math, accent, "\u02dc", "\\~"); // tilde
defineSymbol(math, accent, "\u02c9", "\\="); // macron
defineSymbol(math, accent, "\u02d8", "\\u"); // breve
defineSymbol(math, accent, "\u02d9", "\\."); // dot above
defineSymbol(math, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(math, accent, "\u02da", "\\r"); // ring above
defineSymbol(math, accent, "\u02c7", "\\v"); // caron
defineSymbol(math, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(math, accent, "\u02dd", "\\H"); // double acute

// These ligatures are detected and created in Parser.js's `formLigatures`.
const ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};

defineSymbol(text, textord, "\u2013", "--", true);
defineSymbol(text, textord, "\u2013", "\\textendash");
defineSymbol(text, textord, "\u2014", "---", true);
defineSymbol(text, textord, "\u2014", "\\textemdash");
defineSymbol(text, textord, "\u2018", "`", true);
defineSymbol(text, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, textord, "\u2019", "'", true);
defineSymbol(text, textord, "\u2019", "\\textquoteright");
defineSymbol(text, textord, "\u201c", "``", true);
defineSymbol(text, textord, "\u201c", "\\textquotedblleft");
defineSymbol(text, textord, "\u201d", "''", true);
defineSymbol(text, textord, "\u201d", "\\textquotedblright");
//  \degree from gensymb package
defineSymbol(math, textord, "\u00b0", "\\degree", true);
defineSymbol(text, textord, "\u00b0", "\\degree");
// \textdegree from inputenc package
defineSymbol(text, textord, "\u00b0", "\\textdegree", true);
// TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Regular defines this character "163".
defineSymbol(math, textord, "\u00a3", "\\pounds");
defineSymbol(math, textord, "\u00a3", "\\mathsterling", true);
defineSymbol(text, textord, "\u00a3", "\\pounds");
defineSymbol(text, textord, "\u00a3", "\\textsterling", true);
defineSymbol(math, textord, "\u2720", "\\maltese");
defineSymbol(text, textord, "\u2720", "\\maltese");
defineSymbol(math, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\texteuro");
defineSymbol(math, textord, "\u00a9", "\\copyright", true);
defineSymbol(text, textord, "\u00a9", "\\textcopyright");
defineSymbol(math, textord, "\u2300", "\\diameter", true);
defineSymbol(text, textord, "\u2300", "\\diameter");

// Italic Greek
defineSymbol(math, textord, "𝛤", "\\varGamma");
defineSymbol(math, textord, "𝛥", "\\varDelta");
defineSymbol(math, textord, "𝛩", "\\varTheta");
defineSymbol(math, textord, "𝛬", "\\varLambda");
defineSymbol(math, textord, "𝛯", "\\varXi");
defineSymbol(math, textord, "𝛱", "\\varPi");
defineSymbol(math, textord, "𝛴", "\\varSigma");
defineSymbol(math, textord, "𝛶", "\\varUpsilon");
defineSymbol(math, textord, "𝛷", "\\varPhi");
defineSymbol(math, textord, "𝛹", "\\varPsi");
defineSymbol(math, textord, "𝛺", "\\varOmega");
defineSymbol(text, textord, "𝛤", "\\varGamma");
defineSymbol(text, textord, "𝛥", "\\varDelta");
defineSymbol(text, textord, "𝛩", "\\varTheta");
defineSymbol(text, textord, "𝛬", "\\varLambda");
defineSymbol(text, textord, "𝛯", "\\varXi");
defineSymbol(text, textord, "𝛱", "\\varPi");
defineSymbol(text, textord, "𝛴", "\\varSigma");
defineSymbol(text, textord, "𝛶", "\\varUpsilon");
defineSymbol(text, textord, "𝛷", "\\varPhi");
defineSymbol(text, textord, "𝛹", "\\varPsi");
defineSymbol(text, textord, "𝛺", "\\varOmega");


// There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode
const mathTextSymbols = '0123456789/@."';
for (let i = 0; i < mathTextSymbols.length; i++) {
  const ch = mathTextSymbols.charAt(i);
  defineSymbol(math, textord, ch, ch);
}

// All of these are textords in text mode
const textSymbols = '0123456789!@*()-=+";:?/.,';
for (let i = 0; i < textSymbols.length; i++) {
  const ch = textSymbols.charAt(i);
  defineSymbol(text, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (let i = 0; i < letters.length; i++) {
  const ch = letters.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// Some more letters in Unicode Basic Multilingual Plane.
const narrow = "ÇÐÞçþℂℍℕℙℚℝℤℎℏℊℋℌℐℑℒℓ℘ℛℜℬℰℱℳℭℨ";
for (let i = 0; i < narrow.length; i++) {
  const ch = narrow.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
let wideChar = "";
for (let i = 0; i < letters.length; i++) {
  // The hex numbers in the next line are a surrogate pair.
  // 0xD835 is the high surrogate for all letters in the range we support.
  // 0xDC00 is the low surrogate for bold A.
  wideChar = String.fromCharCode(0xd835, 0xdc00 + i); // A-Z a-z bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc34 + i); // A-Z a-z italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc68 + i); // A-Z a-z bold italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd04 + i); // A-Z a-z Fractur
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdda0 + i); // A-Z a-z sans-serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xddd4 + i); // A-Z a-z sans bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde08 + i); // A-Z a-z sans italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde70 + i); // A-Z a-z monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd38 + i); // A-Z a-z double struck
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  const ch = letters.charAt(i);
  wideChar = String.fromCharCode(0xd835, 0xdc9c + i); // A-Z a-z calligraphic
  defineSymbol(math, mathord, ch, wideChar);
  defineSymbol(text, textord, ch, wideChar);
}

// Next, some wide character numerals
for (let i = 0; i < 10; i++) {
  wideChar = String.fromCharCode(0xd835, 0xdfce + i); // 0-9 bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfe2 + i); // 0-9 sans serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfec + i); // 0-9 bold sans
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdff6 + i); // 0-9 monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);
}

/*
 * Neither Firefox nor Chrome support hard line breaks or soft line breaks.
 * (Despite https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs)
 * So Temml has work-arounds for both hard and soft breaks.
 * The work-arounds sadly do not work simultaneously. Any top-level hard
 * break makes soft line breaks impossible.
 *
 * Hard breaks are simulated by creating a <mtable> and putting each line in its own <mtr>.
 *
 * To create soft line breaks, Temml avoids using the <semantics> and <annotation> tags.
 * Then the top level of a <math> element can be occupied by <mrow> elements, and the browser
 * will break after a <mrow> if the expression extends beyond the container limit.
 *
 * The default is for soft line breaks after each top-level binary or
 * relational operator, per TeXbook p. 173. So we gather the expression into <mrow>s so that
 * each <mrow> ends in a binary or relational operator.
 *
 * An option is for soft line breaks before an "=" sign. That changes the <mrow>s.
 *
 * Soft line breaks will not work in Chromium and Safari, only Firefox.
 *
 * Hopefully browsers will someday do their own linebreaking and we will be able to delete
 * much of this module.
 */

const openDelims = "([{⌊⌈⟨⟮⎰⟦⦃";
const closeDelims = ")]}⌋⌉⟩⟯⎱⟦⦄";

function setLineBreaks(expression, wrapMode, isDisplayMode) {
  const mtrs = [];
  let mrows = [];
  let block = [];
  let numTopLevelEquals = 0;
  let i = 0;
  let level = 0;
  while (i < expression.length) {
    while (expression[i] instanceof DocumentFragment) {
      expression.splice(i, 1, ...expression[i].children); // Expand the fragment.
    }
    const node = expression[i];
    if (node.attributes && node.attributes.linebreak &&
      node.attributes.linebreak === "newline") {
      // A hard line break. Create a <mtr> for the current block.
      if (block.length > 0) {
        mrows.push(new mathMLTree.MathNode("mrow", block));
      }
      mrows.push(node);
      block = [];
      const mtd = new mathMLTree.MathNode("mtd", mrows);
      mtd.style.textAlign = "left";
      mtrs.push(new mathMLTree.MathNode("mtr", [mtd]));
      mrows = [];
      i += 1;
      continue
    }
    block.push(node);
    if (node.type && node.type === "mo" && node.children.length === 1 &&
        !Object.prototype.hasOwnProperty.call(node.attributes, "movablelimits")) {
      const ch = node.children[0].text;
      if (openDelims.indexOf(ch) > -1) {
        level += 1;
      } else if (closeDelims.indexOf(ch) > -1) {
        level -= 1;
      } else if (level === 0 && wrapMode === "=" && ch === "=") {
        numTopLevelEquals += 1;
        if (numTopLevelEquals > 1) {
          block.pop();
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [node];
        }
      } else if (level === 0 && wrapMode === "tex" && ch !== "∇") {
        // Check if the following node is a \nobreak text node, e.g. "~""
        const next = i < expression.length - 1 ? expression[i + 1] : null;
        let glueIsFreeOfNobreak = true;
        if (
          !(
            next &&
            next.type === "mtext" &&
            next.attributes.linebreak &&
            next.attributes.linebreak === "nobreak"
          )
        ) {
          // We may need to start a new block.
          // First, put any post-operator glue on same line as operator.
          for (let j = i + 1; j < expression.length; j++) {
            const nd = expression[j];
            if (
              nd.type &&
              nd.type === "mspace" &&
              !(nd.attributes.linebreak && nd.attributes.linebreak === "newline")
            ) {
              block.push(nd);
              i += 1;
              if (
                nd.attributes &&
                nd.attributes.linebreak &&
                nd.attributes.linebreak === "nobreak"
              ) {
                glueIsFreeOfNobreak = false;
              }
            } else {
              break;
            }
          }
        }
        if (glueIsFreeOfNobreak) {
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [];
        }
      }
    }
    i += 1;
  }
  if (block.length > 0) {
    const element = new mathMLTree.MathNode("mrow", block);
    mrows.push(element);
  }
  if (mtrs.length > 0) {
    const mtd = new mathMLTree.MathNode("mtd", mrows);
    mtd.style.textAlign = "left";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    mtrs.push(mtr);
    const mtable = new mathMLTree.MathNode("mtable", mtrs);
    if (!isDisplayMode) {
      mtable.setAttribute("columnalign", "left");
      mtable.setAttribute("rowspacing", "0em");
    }
    return mtable
  }
  return mathMLTree.newDocumentFragment(mrows);
}

/**
 * This file converts a parse tree into a corresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */


/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
const makeText = function(text, mode, style) {
  if (
    symbols[mode][text] &&
    symbols[mode][text].replace &&
    text.charCodeAt(0) !== 0xd835 &&
    !(
      Object.prototype.hasOwnProperty.call(ligatures, text) &&
      style &&
      ((style.fontFamily && style.fontFamily.slice(4, 6) === "tt") ||
        (style.font && style.font.slice(4, 6) === "tt"))
    )
  ) {
    text = symbols[mode][text].replace;
  }

  return new mathMLTree.TextNode(text);
};

const copyChar = (newRow, child) => {
  if (newRow.children.length === 0 ||
      newRow.children[newRow.children.length - 1].type !== "mtext") {
    const mtext = new mathMLTree.MathNode(
      "mtext",
      [new mathMLTree.TextNode(child.children[0].text)]
    );
    newRow.children.push(mtext);
  } else {
    newRow.children[newRow.children.length - 1].children[0].text += child.children[0].text;
  }
};

const consolidateText = mrow => {
  // If possible, consolidate adjacent <mtext> elements into a single element.
  if (mrow.type !== "mrow" && mrow.type !== "mstyle") { return mrow }
  if (mrow.children.length === 0) { return mrow } // empty group, e.g., \text{}
  const newRow = new mathMLTree.MathNode("mrow");
  for (let i = 0; i < mrow.children.length; i++) {
    const child = mrow.children[i];
    if (child.type === "mtext" && Object.keys(child.attributes).length === 0) {
      copyChar(newRow, child);
    } else if (child.type === "mrow") {
      // We'll also check the children of an mrow. One level only. No recursion.
      let canConsolidate = true;
      for (let j = 0; j < child.children.length; j++) {
        const grandChild = child.children[j];
        if (grandChild.type !== "mtext" || Object.keys(child.attributes).length !== 0) {
          canConsolidate = false;
          break
        }
      }
      if (canConsolidate) {
        for (let j = 0; j < child.children.length; j++) {
          const grandChild = child.children[j];
          copyChar(newRow, grandChild);
        }
      } else {
        newRow.children.push(child);
      }
    } else {
      newRow.children.push(child);
    }
  }
  for (let i = 0; i < newRow.children.length; i++) {
    if (newRow.children[i].type === "mtext") {
      const mtext = newRow.children[i];
      // Firefox does not render a space at either end of an <mtext> string.
      // To get proper rendering, we replace leading or trailing spaces with no-break spaces.
      if (mtext.children[0].text.charAt(0) === " ") {
        mtext.children[0].text = "\u00a0" + mtext.children[0].text.slice(1);
      }
      const L = mtext.children[0].text.length;
      if (L > 0 && mtext.children[0].text.charAt(L - 1) === " ") {
        mtext.children[0].text = mtext.children[0].text.slice(0, -1) + "\u00a0";
      }
      for (const [key, value] of Object.entries(mrow.attributes)) {
        mtext.attributes[key] = value;
      }
    }
  }
  if (newRow.children.length === 1 && newRow.children[0].type === "mtext") {
    return newRow.children[0]; // A consolidated <mtext>
  } else {
    return newRow
  }
};

/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */
const makeRow = function(body, semisimple = false) {
  if (body.length === 1 && !(body[0] instanceof DocumentFragment)) {
    return body[0];
  } else if (!semisimple) {
    // Suppress spacing on <mo> nodes at both ends of the row.
    if (body[0] instanceof MathNode && body[0].type === "mo" && !body[0].attributes.fence) {
      body[0].attributes.lspace = "0em";
      body[0].attributes.rspace = "0em";
    }
    const end = body.length - 1;
    if (body[end] instanceof MathNode && body[end].type === "mo" && !body[end].attributes.fence) {
      body[end].attributes.lspace = "0em";
      body[end].attributes.rspace = "0em";
    }
  }
  return new mathMLTree.MathNode("mrow", body);
};

/**
 * Check for <mi>.</mi> which is how a dot renders in MathML,
 * or <mo separator="true" lspace="0em" rspace="0em">,</mo>
 * which is how a braced comma {,} renders in MathML
 */
function isNumberPunctuation(group) {
  if (!group) {
    return false
  }
  if (group.type === 'mi' && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '.'
  } else if (group.type === "mtext" && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '\u2008' // punctuation space
  } else if (group.type === 'mo' && group.children.length === 1 &&
    group.getAttribute('separator') === 'true' &&
    group.getAttribute('lspace') === '0em' &&
    group.getAttribute('rspace') === '0em') {
    const child = group.children[0];
    return child instanceof TextNode && child.text === ','
  } else {
    return false
  }
}
const isComma = (expression, i) => {
  const node = expression[i];
  const followingNode = expression[i + 1];
  return (node.type === "atom" && node.text === ",") &&
    // Don't consolidate if there is a space after the comma.
    node.loc && followingNode.loc && node.loc.end === followingNode.loc.start
};

const isRel = item => {
  return (item.type === "atom" && item.family === "rel") ||
      (item.type === "mclass" && item.mclass === "mrel")
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also do a couple chores along the way:
 * (1) Suppress spacing when an author wraps an operator w/braces, as in {=}.
 * (2) Suppress spacing between two adjacent relations.
 */
const buildExpression = function(expression, style, semisimple = false) {
  if (!semisimple && expression.length === 1) {
    const group = buildGroup$1(expression[0], style);
    if (group instanceof MathNode && group.type === "mo") {
      // When TeX writers want to suppress spacing on an operator,
      // they often put the operator by itself inside braces.
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }

  const groups = [];
  const groupArray = [];
  let lastGroup;
  for (let i = 0; i < expression.length; i++) {
    groupArray.push(buildGroup$1(expression[i], style));
  }

  for (let i = 0; i < groupArray.length; i++) {
    const group = groupArray[i];

    // Suppress spacing between adjacent relations
    if (i < expression.length - 1 && isRel(expression[i]) && isRel(expression[i + 1])) {
      group.setAttribute("rspace", "0em");
    }
    if (i > 0 && isRel(expression[i]) && isRel(expression[i - 1])) {
      group.setAttribute("lspace", "0em");
    }

    // Concatenate numbers
    if (group.type === 'mn' && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (isNumberPunctuation(group) && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (lastGroup && lastGroup.type === "mn" && i < groupArray.length - 1 &&
      groupArray[i + 1].type === "mn" && isComma(expression, i)) {
      lastGroup.children.push(...group.children);
      continue
    } else if (group.type === 'mn' && isNumberPunctuation(lastGroup)) {
      // Concatenate <mi>.</mi> followed by <mn>...</mn>
      group.children = [...lastGroup.children, ...group.children];
      groups.pop();
    } else if ((group.type === 'msup' || group.type === 'msub') &&
        group.children.length >= 1 && lastGroup &&
        (lastGroup.type === 'mn' || isNumberPunctuation(lastGroup))) {
      // Put preceding <mn>...</mn> or <mi>.</mi> inside base of
      // <msup><mn>...base...</mn>...exponent...</msup> (or <msub>)
      const base = group.children[0];
      if (base instanceof MathNode && base.type === 'mn' && lastGroup) {
        base.children = [...lastGroup.children, ...base.children];
        groups.pop();
      }
    }
    groups.push(group);
    lastGroup = group;
  }
  return groups
};

/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */
const buildExpressionRow = function(expression, style, semisimple = false) {
  return makeRow(buildExpression(expression, style, semisimple), semisimple);
};

/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */
const buildGroup$1 = function(group, style) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }

  if (_mathmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    const result = _mathmlGroupBuilders[group.type](group, style);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};

const glue$1 = _ => {
  return new mathMLTree.MathNode("mtd", [], [], { padding: "0", width: "50%" })
};

const labelContainers = ["mrow", "mtd", "mtable", "mtr"];
const getLabel = parent => {
  for (const node of parent.children) {
    if (node.type && labelContainers.includes(node.type)) {
      if (node.classes && node.classes[0] === "tml-label") {
        const label = node.label;
        return label
      } else {
        const label = getLabel(node);
        if (label) { return label }
      }
    } else if (!node.type) {
      const label = getLabel(node);
      if (label) { return label }
    }
  }
};

const taggedExpression = (expression, tag, style, leqno) => {
  tag = buildExpressionRow(tag[0].body, style);
  tag = consolidateText(tag);
  tag.classes.push("tml-tag");

  const label = getLabel(expression); // from a \label{} function.
  expression = new mathMLTree.MathNode("mtd", [expression]);
  const rowArray = [glue$1(), expression, glue$1()];
  rowArray[leqno ? 0 : 2].classes.push(leqno ? "tml-left" : "tml-right");
  rowArray[leqno ? 0 : 2].children.push(tag);
  const mtr = new mathMLTree.MathNode("mtr", rowArray, ["tml-tageqn"]);
  if (label) { mtr.setAttribute("id", label); }
  const table = new mathMLTree.MathNode("mtable", [mtr]);
  table.style.width = "100%";
  table.setAttribute("displaystyle", "true");
  return table
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it.
 */
function buildMathML(tree, texExpression, style, settings) {
  // Strip off outer tag wrapper for processing below.
  let tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }

  const expression = buildExpression(tree, style);

  if (expression.length === 1 && expression[0] instanceof AnchorNode) {
    return expression[0]
  }

  const wrap = (settings.displayMode || settings.annotate) ? "none" : settings.wrap;

  const n1 = expression.length === 0 ? null : expression[0];
  let wrapper = expression.length === 1 && tag === null && (n1 instanceof MathNode)
      ? expression[0]
      : setLineBreaks(expression, wrap, settings.displayMode);

  if (tag) {
    wrapper = taggedExpression(wrapper, tag, style, settings.leqno);
  }

  if (settings.annotate) {
    // Build a TeX annotation of the source
    const annotation = new mathMLTree.MathNode(
      "annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    wrapper = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  }

  const math = new mathMLTree.MathNode("math", [wrapper]);

  if (settings.xml) {
    math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  }
  if (wrapper.style.width) {
    math.style.width = "100%";
  }
  if (settings.displayMode) {
    math.setAttribute("display", "block");
    math.style.display = "block math"; // necessary in Chromium.
    // Firefox and Safari do not recognize display: "block math".
    // Set a class so that the CSS file can set display: block.
    math.classes = ["tml-display"];
  }
  return math;
}

const smalls = "acegıȷmnopqrsuvwxyzαγεηικμνοπρςστυχωϕ𝐚𝐜𝐞𝐠𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐮𝐯𝐰𝐱𝐲𝐳";
const talls = "ABCDEFGHIJKLMNOPQRSTUVWXYZbdfhkltΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩβδλζφθψ"
             + "𝐀𝐁𝐂𝐃𝐄𝐅𝐆𝐇𝐈𝐉𝐊𝐋𝐌𝐍𝐎𝐏𝐐𝐑𝐒𝐓𝐔𝐕𝐖𝐗𝐘𝐙𝐛𝐝𝐟𝐡𝐤𝐥𝐭";
const longSmalls = new Set(["\\alpha", "\\gamma", "\\delta", "\\epsilon", "\\eta", "\\iota",
  "\\kappa", "\\mu", "\\nu", "\\pi", "\\rho", "\\sigma", "\\tau", "\\upsilon", "\\chi", "\\psi",
  "\\omega", "\\imath", "\\jmath"]);
const longTalls = new Set(["\\Gamma", "\\Delta", "\\Sigma", "\\Omega", "\\beta", "\\delta",
  "\\lambda", "\\theta", "\\psi"]);

const mathmlBuilder$a = (group, style) => {
  const accentNode = group.isStretchy
    ? stretchy.accentNode(group)
    : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);

  if (group.label === "\\vec") {
    accentNode.style.transform = "scale(0.75) translate(10%, 30%)";
  } else {
    accentNode.style.mathStyle = "normal";
    accentNode.style.mathDepth = "0";
    if (needWebkitShift.has(group.label) &&  utils.isCharacterBox(group.base)) {
      let shift = "";
      const ch = group.base.text;
      if (smalls.indexOf(ch) > -1 || longSmalls.has(ch)) { shift = "tml-xshift"; }
      if (talls.indexOf(ch) > -1  || longTalls.has(ch))  { shift = "tml-capshift"; }
      if (shift) { accentNode.classes.push(shift); }
    }
  }
  if (!group.isStretchy) {
    accentNode.setAttribute("stretchy", "false");
  }

  const node = new mathMLTree.MathNode((group.label === "\\c" ? "munder" : "mover"),
    [buildGroup$1(group.base, style), accentNode]
  );

  return node;
};

const nonStretchyAccents = new Set([
  "\\acute",
  "\\grave",
  "\\ddot",
  "\\dddot",
  "\\ddddot",
  "\\tilde",
  "\\bar",
  "\\breve",
  "\\check",
  "\\hat",
  "\\vec",
  "\\dot",
  "\\mathring"
]);

const needWebkitShift = new Set([
  "\\acute",
  "\\bar",
  "\\breve",
  "\\check",
  "\\dot",
  "\\ddot",
  "\\grave",
  "\\hat",
  "\\mathring",
  "\\'", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"
]);

const combiningChar = {
  "\\`": "\u0300",
  "\\'": "\u0301",
  "\\^": "\u0302",
  "\\~": "\u0303",
  "\\=": "\u0304",
  "\\u": "\u0306",
  "\\.": "\u0307",
  '\\"': "\u0308",
  "\\r": "\u030A",
  "\\H": "\u030B",
  "\\v": "\u030C"
};

// Accents
defineFunction({
  type: "accent",
  names: [
    "\\acute",
    "\\grave",
    "\\ddot",
    "\\dddot",
    "\\ddddot",
    "\\tilde",
    "\\bar",
    "\\breve",
    "\\check",
    "\\hat",
    "\\vec",
    "\\dot",
    "\\mathring",
    "\\overparen",
    "\\widecheck",
    "\\widehat",
    "\\wideparen",
    "\\widetilde",
    "\\overrightarrow",
    "\\overleftarrow",
    "\\Overrightarrow",
    "\\overleftrightarrow",
    "\\overgroup",
    "\\overleftharpoon",
    "\\overrightharpoon"
  ],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);

    const isStretchy = !nonStretchyAccents.has(context.funcName);

    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: isStretchy,
      base: base
    };
  },
  mathmlBuilder: mathmlBuilder$a
});

// Text-mode accents
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\c", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);
    const mode = context.parser.mode;

    if (mode === "math" && context.parser.settings.strict) {
      // LaTeX only writes a warning. It doesn't stop. We'll issue the same warning.
      // eslint-disable-next-line no-console
      console.log(`Temml parse error: Command ${context.funcName} is invalid in math mode.`);
    }

    if (mode === "text" && base.text && base.text.length === 1
        && context.funcName in combiningChar  && smalls.indexOf(base.text) > -1) {
      // Return a combining accent character
      return {
        type: "textord",
        mode: "text",
        text: base.text + combiningChar[context.funcName]
      }
    } else {
      // Build up the accent
      return {
        type: "accent",
        mode: mode,
        label: context.funcName,
        isStretchy: false,
        base: base
      }
    }
  },
  mathmlBuilder: mathmlBuilder$a
});

defineFunction({
  type: "accentUnder",
  names: [
    "\\underleftarrow",
    "\\underrightarrow",
    "\\underleftrightarrow",
    "\\undergroup",
    "\\underparen",
    "\\utilde"
  ],
  props: {
    numArgs: 1
  },
  handler: ({ parser, funcName }, args) => {
    const base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base
    };
  },
  mathmlBuilder: (group, style) => {
    const accentNode = stretchy.accentNode(group);
    accentNode.style["math-depth"] = 0;
    const node = new mathMLTree.MathNode("munder", [
      buildGroup$1(group.base, style),
      accentNode
    ]);
    return node;
  }
});

/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into CSS units.
 */


const ptPerUnit = {
  // Convert to CSS (Postscipt) points, not TeX points
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 800 / 803, // convert TeX point to CSS (Postscript) point
  pc: (12 * 800) / 803, // pica
  dd: ((1238 / 1157) * 800) / 803, // didot
  cc: ((14856 / 1157) * 800) / 803, // cicero (12 didot)
  nd: ((685 / 642) * 800) / 803, // new didot
  nc: ((1370 / 107) * 800) / 803, // new cicero (12 new didot)
  sp: ((1 / 65536) * 800) / 803, // scaled point (TeX's internal smallest unit)
  mm: (25.4 / 72),
  cm: (2.54 / 72),
  in: (1 / 72),
  px: (96 / 72)
};

/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */
const validUnits = [
  "em",
  "ex",
  "mu",
  "pt",
  "mm",
  "cm",
  "in",
  "px",
  "bp",
  "pc",
  "dd",
  "cc",
  "nd",
  "nc",
  "sp"
];

const validUnit = function(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return validUnits.indexOf(unit) > -1
};

const emScale = styleLevel => {
  const scriptLevel = Math.max(styleLevel - 1, 0);
  return [1, 0.7, 0.5][scriptLevel]
};

/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS value.
 */
const calculateSize = function(sizeValue, style) {
  let number = sizeValue.number;
  if (style.maxSize[0] < 0 && number > 0) {
    return { number: 0, unit: "em" }
  }
  const unit = sizeValue.unit;
  switch (unit) {
    case "mm":
    case "cm":
    case "in":
    case "px": {
      const numInCssPts = number * ptPerUnit[unit];
      if (numInCssPts > style.maxSize[1]) {
        return { number: style.maxSize[1], unit: "pt" }
      }
      return { number, unit }; // absolute CSS units.
    }
    case "em":
    case "ex": {
      // In TeX, em and ex do not change size in \scriptstyle.
      if (unit === "ex") { number *= 0.431; }
      number = Math.min(number / emScale(style.level), style.maxSize[0]);
      return { number: utils.round(number), unit: "em" };
    }
    case "bp": {
      if (number > style.maxSize[1]) { number = style.maxSize[1]; }
      return { number, unit: "pt" }; // TeX bp is a CSS pt. (1/72 inch).
    }
    case "pt":
    case "pc":
    case "dd":
    case "cc":
    case "nd":
    case "nc":
    case "sp": {
      number = Math.min(number * ptPerUnit[unit], style.maxSize[1]);
      return { number: utils.round(number), unit: "pt" }
    }
    case "mu": {
      number = Math.min(number / 18, style.maxSize[0]);
      return { number: utils.round(number), unit: "em" }
    }
    default:
      throw new ParseError("Invalid unit: '" + unit + "'")
  }
};

// Helper functions

const padding$1 = width => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", width + "em");
  return node
};

const paddedNode = (group, lspace = 0.3, rspace = 0, mustSmash = false) => {
  if (group == null && rspace === 0) { return padding$1(lspace) }
  const row = group ? [group] : [];
  if (lspace !== 0)   { row.unshift(padding$1(lspace)); }
  if (rspace > 0) { row.push(padding$1(rspace)); }
  if (mustSmash) {
    // Used for the bottom arrow in a {CD} environment
    const mpadded = new mathMLTree.MathNode("mpadded", row);
    mpadded.setAttribute("height", "0");
    return mpadded
  } else {
    return new mathMLTree.MathNode("mrow", row)
  }
};

const labelSize = (size, scriptLevel) =>  Number(size) / emScale(scriptLevel);

const munderoverNode = (fName, body, below, style) => {
  const arrowNode = stretchy.mathMLnode(fName);
  // Is this the short part of a mhchem equilibrium arrow?
  const isEq = fName.slice(1, 3) === "eq";
  const minWidth = fName.charAt(1) === "x"
    ? "1.75"  // mathtools extensible arrows are ≥ 1.75em long
    : fName.slice(2, 4) === "cd"
    ? "3.0"  // cd package arrows
    : isEq
    ? "1.0"  // The shorter harpoon of a mhchem equilibrium arrow
    : "2.0"; // other mhchem arrows
  // TODO: When Firefox supports minsize, use the next line.
  //arrowNode.setAttribute("minsize", String(minWidth) + "em")
  arrowNode.setAttribute("lspace", "0");
  arrowNode.setAttribute("rspace", (isEq ? "0.5em" : "0"));

  // <munderover> upper and lower labels are set to scriptlevel by MathML
  // So we have to adjust our label dimensions accordingly.
  const labelStyle = style.withLevel(style.level < 2 ? 2 : 3);
  const minArrowWidth = labelSize(minWidth, labelStyle.level);
  // The dummyNode will be inside a <mover> inside a <mover>
  // So it will be at scriptlevel 3
  const dummyWidth = labelSize(minWidth, 3);
  const emptyLabel = paddedNode(null, minArrowWidth.toFixed(4), 0);
  const dummyNode = paddedNode(null, dummyWidth.toFixed(4), 0);
  // The arrow is a little longer than the label. Set a spacer length.
  const space = labelSize((isEq ? 0 : 0.3), labelStyle.level).toFixed(4);
  let upperNode;
  let lowerNode;

  const gotUpper = (body && body.body &&
    // \hphantom        visible content
    (body.body.body || body.body.length > 0));
  if (gotUpper) {
    let label =  buildGroup$1(body, labelStyle);
    const mustSmash = (fName === "\\\\cdrightarrow" || fName === "\\\\cdleftarrow");
    label = paddedNode(label, space, space, mustSmash);
    // Since Firefox does not support minsize, stack a invisible node
    // on top of the label. Its width will serve as a min-width.
    // TODO: Refactor this after Firefox supports minsize.
    upperNode = new mathMLTree.MathNode("mover", [label, dummyNode]);
  }
  const gotLower = (below && below.body &&
    (below.body.body || below.body.length > 0));
  if (gotLower) {
    let label =  buildGroup$1(below, labelStyle);
    label = paddedNode(label, space, space);
    lowerNode = new mathMLTree.MathNode("munder", [label, dummyNode]);
  }

  let node;
  if (!gotUpper && !gotLower) {
    node = new mathMLTree.MathNode("mover", [arrowNode, emptyLabel]);
  } else if (gotUpper && gotLower) {
    node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
  } else if (gotUpper) {
    node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
  } else {
    node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
  }
  if (minWidth === "3.0") { node.style.height = "1em"; } // CD environment
  node.setAttribute("accent", "false"); // Necessary for MS Word
  return node
};

// Stretchy arrows with an optional argument
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    // The next 5 functions are here only to support mhchem
    "\\yields",
    "\\yieldsLeft",
    "\\mesomerism",
    "\\longrightharpoonup",
    "\\longleftharpoondown",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    return {
      type: "xArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    // Build the arrow and its labels.
    const node = munderoverNode(group.name, group.body, group.below, style);
    // Create operator spacing for a relation.
    const row = [node];
    row.unshift(padding$1(0.2778));
    row.push(padding$1(0.2778));
    return new mathMLTree.MathNode("mrow", row)
  }
});

const arrowComponent = {
  "\\xtofrom": ["\\xrightarrow", "\\xleftarrow"],
  "\\xleftrightharpoons": ["\\xleftharpoonup", "\\xrightharpoondown"],
  "\\xrightleftharpoons": ["\\xrightharpoonup", "\\xleftharpoondown"],
  "\\yieldsLeftRight": ["\\yields", "\\yieldsLeft"],
  // The next three all get the same harpoon glyphs. Only the lengths and paddings differ.
  "\\equilibrium": ["\\longrightharpoonup", "\\longleftharpoondown"],
  "\\equilibriumRight": ["\\longrightharpoonup", "\\eqleftharpoondown"],
  "\\equilibriumLeft": ["\\eqrightharpoonup", "\\longleftharpoondown"]
};

// Browsers are not good at stretching a glyph that contains a pair of stacked arrows such as ⇄.
// So we stack a pair of single arrows.
defineFunction({
  type: "stackedArrow",
  names: [
    "\\xtofrom",              // expfeil
    "\\xleftrightharpoons",   // mathtools
    "\\xrightleftharpoons",   // mathtools
    "\\yieldsLeftRight",      // mhchem
    "\\equilibrium",          // mhchem
    "\\equilibriumRight",
    "\\equilibriumLeft"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    const lowerArrowBody = args[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: args[0]
      }
      : null;
    const upperArrowBelow = optArgs[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: optArgs[0]
      }
      : null;
    return {
      type: "stackedArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      upperArrowBelow,
      lowerArrowBody,
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    const topLabel = arrowComponent[group.name][0];
    const botLabel = arrowComponent[group.name][1];
    const topArrow = munderoverNode(topLabel, group.body, group.upperArrowBelow, style);
    const botArrow = munderoverNode(botLabel, group.lowerArrowBody, group.below, style);
    let wrapper;

    const raiseNode = new mathMLTree.MathNode("mpadded", [topArrow]);
    raiseNode.setAttribute("voffset", "0.3em");
    raiseNode.setAttribute("height", "+0.3em");
    raiseNode.setAttribute("depth", "-0.3em");
    // One of the arrows is given ~zero width. so the other has the same horzontal alignment.
    if (group.name === "\\equilibriumLeft") {
      const botNode =  new mathMLTree.MathNode("mpadded", [botArrow]);
      botNode.setAttribute("width", "0.5em");
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), botNode, raiseNode, padding$1(0.2778)]
      );
    } else {
      raiseNode.setAttribute("width", (group.name === "\\equilibriumRight" ? "0.5em" : "0"));
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), raiseNode, botArrow, padding$1(0.2778)]
      );
    }

    wrapper.setAttribute("voffset", "-0.18em");
    wrapper.setAttribute("height", "-0.18em");
    wrapper.setAttribute("depth", "+0.18em");
    return wrapper
  }
});

/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */
const _environments = {};

function defineEnvironment({ type, names, props, handler, mathmlBuilder }) {
  // Set default values of environments.
  const data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (let i = 0; i < names.length; ++i) {
    _environments[names[i]] = data;
  }
  if (mathmlBuilder) {
    _mathmlGroupBuilders[type] = mathmlBuilder;
  }
}

/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error(
      `Expected node of type ${type}, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return node;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function assertSymbolNodeType(node) {
  const typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error(
      `Expected node of symbol group type, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return typedNode;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" ||
      Object.prototype.hasOwnProperty.call(NON_ATOMS, node.type))) {
    return node;
  }
  return null;
}

const cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};

const newCell = () => {
  // Create an empty cell, to be filled below with parse nodes.
  return { type: "styling", body: [], mode: "math", scriptLevel: "display" };
};

const isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};

const isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};

function cdArrow(arrowChar, labels, parser) {
  // Return a parse tree of an arrow and its labels.
  // This acts in a way similar to a macro expansion.
  const funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      const bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      const arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel],
        semisimple: true
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      const arrow = { type: "textord", text: "\\Vert", mode: "math" };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return { type: "textord", text: " ", mode: "math" };
  }
}

function parseCD(parser) {
  // Get the array's parse nodes with \\ temporarily mapped to \cr.
  const parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    // Get the parse nodes for the next row.
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    const next = parser.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop(); // final row ended in \\
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }

  let row = [];
  const body = [row];

  // Loop thru the parse nodes. Collect them into cells and arrows.
  for (let i = 0; i < parsedRows.length; i++) {
    // Start a new row.
    const rowNodes = parsedRows[i];
    // Create the first cell.
    let cell = newCell();

    for (let j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        // If a parseNode is not an arrow, it goes into a cell.
        cell.body.push(rowNodes[j]);
      } else {
        // Parse node j is an "@", the start of an arrow.
        // Before starting on the arrow, push the cell into `row`.
        row.push(cell);

        // Now collect parseNodes into an arrow.
        // The character after "@" defines the arrow type.
        j += 1;
        const arrowChar = assertSymbolNodeType(rowNodes[j]).text;

        // Create two empty label nodes. We may or may not use them.
        const labels = new Array(2);
        labels[0] = { type: "ordgroup", mode: "math", body: [] };
        labels[1] = { type: "ordgroup", mode: "math", body: [] };

        // Process the arrow.
        if ("=|.".indexOf(arrowChar) > -1) ; else if ("<>AV".indexOf(arrowChar) > -1) {
          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take
          // two optional labels. E.g. the right-point arrow syntax is
          // really:  @>{optional label}>{optional label}>
          // Collect parseNodes into labels.
          for (let labelNum = 0; labelNum < 2; labelNum++) {
            let inLabel = true;
            for (let k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError(
                  "Missing a " + arrowChar + " character to complete a CD arrow.",
                  rowNodes[k]
                );
              }

              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              // isLabelEnd never returned a true.
              throw new ParseError(
                "Missing a " + arrowChar + " character to complete a CD arrow.",
                rowNodes[j]
              );
            }
          }
        } else {
          throw new ParseError(`Expected one of "<>AV=|." after @.`);
        }

        // Now join the arrow to its labels.
        const arrow = cdArrow(arrowChar, labels, parser);

        // Wrap the arrow in a styling node
        row.push(arrow);
        // In CD's syntax, cells are implicit. That is, everything that
        // is not an arrow gets collected into a cell. So create an empty
        // cell now. It will collect upcoming parseNodes.
        cell = newCell();
      }
    }
    if (i % 2 === 0) {
      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell
      // The last cell is not yet pushed into `row`, so:
      row.push(cell);
    } else {
      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow
      // Remove the empty cell that was placed at the beginning of `row`.
      row.shift();
    }
    row = [];
    body.push(row);
  }
  body.pop();

  // End row group
  parser.gullet.endGroup();
  // End array group defining \\
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: "math",
    body,
    tags: null,
    labels: new Array(body.length + 1).fill(""),
    envClasses: ["jot", "cd"],
    cols: [],
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}

// The functions below are not available for general use.
// They are here only for internal use by the {CD} environment in placing labels
// next to vertical arrows.

// We don't need any such functions for horizontal arrows because we can reuse
// the functionality that already exists for extensible arrows.

defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  mathmlBuilder(group, style) {
    if (group.label.body.length === 0) {
      return new mathMLTree.MathNode("mrow", style)  // empty label
    }
    // Abuse an <mtable> to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.label, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    const mtable = new mathMLTree.MathNode("mtable", [mtr]);
    const label = new mathMLTree.MathNode("mpadded", [mtable]);
    // Set the label width to zero so that the arrow will be centered under the corner cell.
    label.setAttribute("width", "0");
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    if (group.side === "left") {
      label.style.display = "flex";
      label.style.justifyContent = "flex-end";
    }
    return label;
  }
});

defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler({ parser }, args) {
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow", [buildGroup$1(group.fragment, style)]);
  }
});

const ordGroup = (body) => {
  return {
    "type": "ordgroup",
    "mode": "math",
    "body": body,
    "semisimple": true
  }
};

const phantom = (body, type) => {
  return {
    "type": type,
    "mode": "math",
    "body": ordGroup(body)
  }
};

/*
 * A helper for \bordermatrix.
 * parseArray() has parsed the tokens as if the environment
 * was \begin{matrix}. That parse tree is this function’s input.
 * Here, we rearrange the parse tree to get one that will
 * result in TeX \bordermatrix.
 * The final result includes a {pmatrix}, which is the bottom
 * half of a <mover> element. The top of the <mover> contains
 * the \bordermatrix headings. The top section also contains the
 * contents of the bottom {pmatrix}. Those elements are hidden via
 * \hphantom, but they ensure that column widths are the same top and
 * bottom.
 *
 * We also create a left {matrix} with a single column that contains
 * elements shifted out of the matrix. The left {matrix} also
 * contains \vphantom copies of the other {pmatrix} elements.
 * As before, this ensures consistent row heights of left and main.
 */

const bordermatrixParseTree = (matrix, delimiters) => {
  const body = matrix.body;
  body[0].shift(); // dispose of top left cell

  // Create an array for the left column
  const leftColumnBody = new Array(body.length - 1).fill().map(() => []);
  for (let i = 1; i < body.length; i++) {
    // The visible part of the cell
    leftColumnBody[i - 1].push(body[i].shift());
    // A vphantom with contents from the pmatrix, to set minimum cell height
    const phantomBody = [];
    for (let j = 0; j < body[i].length; j++) {
      phantomBody.push(structuredClone(body[i][j]));
    }
    leftColumnBody[i - 1].push(phantom(phantomBody, "vphantom"));
  }

  // Create an array for the top row
  const topRowBody = new Array(body.length).fill().map(() => []);
  for (let j = 0; j < body[0].length; j++) {
    topRowBody[0].push(structuredClone(body[0][j]));
  }
  // Copy the rest of the pmatrix, but squashed via \hphantom
  for (let i = 1; i < body.length; i++) {
    for (let j = 0; j < body[0].length; j++) {
      topRowBody[i].push(phantom(structuredClone(body[i][j]).body, "hphantom"));
    }
  }

  // Squash the top row of the main {pmatrix}
  for (let j = 0; j < body[0].length; j++) {
    body[0][j] = phantom(structuredClone(body[0][j]).body, "hphantom");
  }

  // Now wrap the arrays in the proper parse nodes.

  const leftColumn = {
    type: "array",
    mode: "math",
    body: leftColumnBody,
    cols: [{ type: "align", align: "c" }],
    rowGaps: new Array(leftColumnBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(leftColumnBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(leftColumnBody.length).fill(""),
    arraycolsep: { "number": 0.04, unit: "em" }
  };

  const topRow = {
    type: "array",
    mode: "math",
    body: topRowBody,
    cols: new Array(topRowBody.length).fill({ type: "align", align: "c" }),
    rowGaps: new Array(topRowBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(topRowBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(topRowBody.length).fill(""),
    arraycolsep: null
  };

  const topWrapper = {
    type: "styling",
    mode: "math",
    scriptLevel: "text", // Must set this explicitly.
    body: [topRow]       // Default level is "script".
  };

  const container = {
    type: "leftright",
    mode: "math",
    body: [matrix],
    left: delimiters ? delimiters[0] : "(",
    right: delimiters ? delimiters[1] : ")",
    rightColor: undefined
  };

  const base = {
    type: "op",   // The base of a TeX \overset
    mode: "math",
    limits: true,
    alwaysHandleSupSub: true,
    parentIsSupSub: true,
    symbol: false,
    stack: true,
    suppressBaseShift: true,
    body: [container]
  };

  const mover = {
    type: "supsub",  // We're using the MathML equivalent
    mode: "math",    // of TeX \overset.
    base: base,      // That keeps the {pmatrix} aligned with
    sup: topWrapper, // the math centerline.
    sub: null
  };

  return ordGroup([leftColumn, mover])
};

/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */
class SourceLocation {
  constructor(lexer, start, end) {
    this.lexer = lexer; // Lexer holding the input string.
    this.start = start; // Start offset, zero-based inclusive.
    this.end = end;     // End offset, zero-based exclusive.
  }

  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
}

/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */
class Token {
  constructor(
    text, // the text of this token
    loc
  ) {
    this.text = text;
    this.loc = loc;
  }

  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(
    endToken, // last token of the range, inclusive
    text // the text of the newly constructed token
  ) {
    return new Token(text, SourceLocation.range(this, endToken));
  }
}

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are
// provided in the the arrays below, in that order.
//

// Math style is not quite the same thing as script level.
const StyleLevel = {
  DISPLAY: 0,
  TEXT: 1,
  SCRIPT: 2,
  SCRIPTSCRIPT: 3
};

/**
 * All registered global/built-in macros.
 * `macros.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `macros.js`.
 */
const _macros = {};

// This function might one day accept an additional argument and do more things.
function defineMacro(name, body) {
  _macros[name] = body;
}

/**
 * Predefined macros for Temml.
 * This can be used to define some commands in terms of others.
 */

const macros = _macros;

//////////////////////////////////////////////////////////////////////
// macro tools

defineMacro("\\noexpand", function(context) {
  // The expansion is the token itself; but that token is interpreted
  // as if its meaning were ‘\relax’ if it is a control sequence that
  // would ordinarily be expanded by TeX’s expansion rules.
  const t = context.popToken();
  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }
  return { tokens: [t], numArgs: 0 };
});

defineMacro("\\expandafter", function(context) {
  // TeX first reads the token that comes immediately after \expandafter,
  // without expanding it; let’s call this token t. Then TeX reads the
  // token that comes after t (and possibly more tokens, if that token
  // has an argument), replacing it by its expansion. Finally TeX puts
  // t back in front of that expansion.
  const t = context.popToken();
  context.expandOnce(true); // expand only an expandable token
  return { tokens: [t], numArgs: 0 };
});

// LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}
defineMacro("\\@firstoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[0], numArgs: 0 };
});

// LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}
defineMacro("\\@secondoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[1], numArgs: 0 };
});

// LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol that isn't a space, consuming any spaces but not consuming the
// first nonspace character.  If that nonspace character matches #1, then
// the macro expands to #2; otherwise, it expands to #3.
defineMacro("\\@ifnextchar", function(context) {
  const args = context.consumeArgs(3); // symbol, if, else
  context.consumeSpaces();
  const nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return { tokens: args[1], numArgs: 0 };
  } else {
    return { tokens: args[2], numArgs: 0 };
  }
});

// LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");

// LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode
defineMacro("\\TextOrMath", function(context) {
  const args = context.consumeArgs(2);
  if (context.mode === "text") {
    return { tokens: args[0], numArgs: 0 };
  } else {
    return { tokens: args[1], numArgs: 0 };
  }
});

const stringFromArg = arg => {
  // Reverse the order of the arg and return a string.
  let str = "";
  for (let i = arg.length - 1; i > -1; i--) {
    str += arg[i].text;
  }
  return str
};

// Lookup table for parsing numbers in base 8 through 16
const digitToNumber = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

const nextCharNumber = context => {
  const numStr = context.future().text;
  if (numStr === "EOF") { return [null, ""] }
  return [digitToNumber[numStr.charAt(0)], numStr]
};

const appendCharNumbers = (number, numStr, base) => {
  for (let i = 1; i < numStr.length; i++) {
    const digit = digitToNumber[numStr.charAt(i)];
    number *= base;
    number += digit;
  }
  return number
};

// TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.
defineMacro("\\char", function(context) {
  let token = context.popToken();
  let base;
  let number = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    // Parse a number in the given base, starting with first `token`.
    let numStr = token.text;
    number = digitToNumber[numStr.charAt(0)];
    if (number == null || number >= base) {
      throw new ParseError(`Invalid base-${base} digit ${token.text}`);
    }
    number = appendCharNumbers(number, numStr, base);
    let digit;
    [digit, numStr] = nextCharNumber(context);
    while (digit != null && digit < base) {
      number *= base;
      number += digit;
      number = appendCharNumbers(number, numStr, base);
      context.popToken();
      [digit, numStr] = nextCharNumber(context);
    }
  }
  return `\\@char{${number}}`;
});

function recreateArgStr(context) {
  // Recreate the macro's original argument string from the array of parse tokens.
  const tokens = context.consumeArgs(1)[0];
  let str = "";
  let expectedLoc = tokens[tokens.length - 1].loc.start;
  for (let i = tokens.length - 1; i >= 0; i--) {
    const actualLoc = tokens[i].loc.start;
    if (actualLoc > expectedLoc) {
      // context.consumeArgs has eaten a space.
      str += " ";
      expectedLoc = actualLoc;
    }
    str += tokens[i].text;
    expectedLoc += tokens[i].text.length;
  }
  return str
}

// The Latin Modern font renders <mi>√</mi> at the wrong vertical alignment.
// This macro provides a better rendering.
defineMacro("\\surd", '\\sqrt{\\vphantom{|}}');

// See comment for \oplus in symbols.js.
defineMacro("\u2295", "\\oplus");

// Since Temml has no \par, ignore \long.
defineMacro("\\long", "");

//////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");

// Symbols from latex.ltx:
// \def~{\nobreakspace{}}
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");

defineMacro("\\Bbbk", "\\Bbb{k}");

// \mathstrut from the TeXbook, p 360
defineMacro("\\mathstrut", "\\vphantom{(}");

// \underbar from TeXbook p 353
defineMacro("\\underbar", "\\underline{\\text{#1}}");

//////////////////////////////////////////////////////////////////////
// LaTeX_2ε

// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.
defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22ee", "\\vdots");

// {array} environment gaps
defineMacro("\\arraystretch", "1");     // line spacing factor times 12pt
defineMacro("\\arraycolsep", "6pt");    // half the width separating columns

//////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf

//\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");

// \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");

// AMSMath's automatic \dots, based on \mdots@@ macro.
const dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcap": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\bigtimes": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};

defineMacro("\\dots", function(context) {
  // TODO: If used in text mode, should expand to \textellipsis.
  // However, in Temml, \textellipsis and \ldots behave the same
  // (in text mode), and it's unlikely we'd see any of the math commands
  // that affect the behavior of \dots when in text mode.  So fine for now
  // (until we support \ifmmode ... \else ... \fi).
  let thedots = "\\dotso";
  const next = context.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (["bin", "rel"].includes(symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});

const spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  $: true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};

defineMacro("\\dotso", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\dotsc", function(context) {
  const next = context.future().text;
  // \dotsc uses \extra@ but not \extrap@, instead specially checking for
  // ';' and '.', but doesn't check for ','.
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\cdots", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});

defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\idotsint", "\\dotsi");
// amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.
defineMacro("\\dotsx", "\\ldots\\,");

// \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");

// Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
// \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\,", "{\\tmspace+{3mu}{.1667em}}");
// \let\thinspace\,
defineMacro("\\thinspace", "\\,");
// \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "{\\tmspace+{4mu}{.2222em}}");
// \let\medspace\:
defineMacro("\\medspace", "\\:");
// \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu
defineMacro("\\;", "{\\tmspace+{5mu}{.2777em}}");
// \let\thickspace\;
defineMacro("\\thickspace", "\\;");
// \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\!", "{\\tmspace-{3mu}{.1667em}}");
// \let\negthinspace\!
defineMacro("\\negthinspace", "\\!");
// \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip
defineMacro("\\negmedspace", "{\\tmspace-{4mu}{.2222em}}");
// \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip
defineMacro("\\negthickspace", "{\\tmspace-{5mu}{.277em}}");
// \def\enspace{\kern.5em }
defineMacro("\\enspace", "\\kern.5em ");
// \def\enskip{\hskip.5em\relax}
defineMacro("\\enskip", "\\hskip.5em\\relax");
// \def\quad{\hskip1em\relax}
defineMacro("\\quad", "\\hskip1em\\relax");
// \def\qquad{\hskip2em\relax}
defineMacro("\\qquad", "\\hskip2em\\relax");

defineMacro("\\AA", "\\TextOrMath{\\Angstrom}{\\mathring{A}}\\relax");

// \tag@in@display form of \tag
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\notag", "\\nonumber");
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");

// \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\bmod", "\\mathbin{\\text{mod}}");
defineMacro(
  "\\pod",
  "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"
);
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro(
  "\\mod",
  "\\allowbreak" +
    "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" +
    "{\\rm mod}\\,\\,#1"
);

//////////////////////////////////////////////////////////////////////
// LaTeX source2e

// \expandafter\let\expandafter\@normalcr
//     \csname\expandafter\@gobble\string\\ \endcsname
// \DeclareRobustCommand\newline{\@normalcr\relax}
defineMacro("\\newline", "\\\\\\relax");

// \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.
defineMacro("\\TeX", "\\textrm{T}\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125em\\textrm{X}");

defineMacro(
  "\\LaTeX",
    "\\textrm{L}\\kern-.35em\\raisebox{0.2em}{\\scriptstyle A}\\kern-.15em\\TeX"
);

defineMacro(
  "\\Temml",
  // eslint-disable-next-line max-len
  "\\textrm{T}\\kern-0.2em\\lower{0.2em}{\\textrm{E}}\\kern-0.08em{\\textrm{M}\\kern-0.08em\\raise{0.2em}\\textrm{M}\\kern-0.08em\\textrm{L}}"
);

// \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");

defineMacro("\\colon", `\\mathpunct{\\char"3a}`);

//////////////////////////////////////////////////////////////////////
// mathtools.sty

defineMacro("\\prescript", "\\pres@cript{_{#1}^{#2}}{}{#3}");

//\providecommand\ordinarycolon{:}
defineMacro("\\ordinarycolon", `\\char"3a`);
// Raise to center on the math axis, as closely as possible.
defineMacro("\\vcentcolon", "\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}}");
// \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\coloneq", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2212}');
// \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\Coloneq", '\\mathrel{\\char"2237\\char"2212}');
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqqcolon", '\\mathrel{\\char"3d\\char"2237}');
// \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqcolon", '\\mathrel{\\char"2212\\char"2237}');
// \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\colonapprox", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2248}');
// \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\Colonapprox", '\\mathrel{\\char"2237\\char"2248}');
// \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');
// \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\Colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');

//////////////////////////////////////////////////////////////////////
// colonequals.sty

// Alternate names for mathtools's macros:
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
// \colonapprox name is same in mathtools and colonequals.
defineMacro("\\coloncolonapprox", "\\Colonapprox");
// \colonsim name is same in mathtools and colonequals.
defineMacro("\\coloncolonsim", "\\Colonsim");

// Present in newtxmath, pxfonts and txfonts
defineMacro("\\notni", "\\mathrel{\\char`\u220C}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");

//////////////////////////////////////////////////////////////////////
// From amsopn.sty
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{\\text{lim}}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{\\text{lim}}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{\\text{lim}}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{\\text{lim}}}");

defineMacro("\\centerdot", "{\\medspace\\rule{0.167em}{0.189em}\\medspace}");

//////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\operatorname*{plim}");

//////////////////////////////////////////////////////////////////////
// MnSymbol.sty

defineMacro("\\leftmodels", "\\mathop{\\reflectbox{$\\models$}}");

//////////////////////////////////////////////////////////////////////
// braket.sty
// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf

defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
// A helper for \Braket and \Set
const replaceVert = (argStr, match) => {
  const ch = match[0] === "|" ? "\\vert" : "\\Vert";
  const replaceStr = `}\\,\\middle${ch}\\,{`;
  return argStr.slice(0, match.index) + replaceStr + argStr.slice(match.index + match[0].length)
};
defineMacro("\\Braket",  function(context) {
  let argStr = recreateArgStr(context);
  const regEx = /\|\||\||\\\|/g;
  let match;
  while ((match = regEx.exec(argStr)) !== null) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\langle{" + argStr + "}\\right\\rangle"
});
defineMacro("\\Set",  function(context) {
  let argStr = recreateArgStr(context);
  const match = /\|\||\||\\\|/.exec(argStr);
  if (match) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\{\\:{" + argStr + "}\\:\\right\\}"
});
defineMacro("\\set",  function(context) {
  const argStr = recreateArgStr(context);
  return "\\{{" + argStr.replace(/\|/, "}\\mid{") + "}\\}"
});

//////////////////////////////////////////////////////////////////////
// actuarialangle.dtx
defineMacro("\\angln", "{\\angl n}");

//////////////////////////////////////////////////////////////////////
// derivative.sty
defineMacro("\\odv", "\\@ifstar\\odv@next\\odv@numerator");
defineMacro("\\odv@numerator", "\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}");
defineMacro("\\odv@next", "\\frac{\\mathrm{d}}{\\mathrm{d}#2}#1");
defineMacro("\\pdv", "\\@ifstar\\pdv@next\\pdv@numerator");

const pdvHelper = args => {
  const numerator = args[0][0].text;
  const denoms = stringFromArg(args[1]).split(",");
  const power = String(denoms.length);
  const numOp = power === "1" ? "\\partial" : `\\partial^${power}`;
  let denominator = "";
  denoms.map(e => { denominator += "\\partial " + e.trim() +  "\\,";});
  return [numerator, numOp,  denominator.replace(/\\,$/, "")]
};
defineMacro("\\pdv@numerator", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp} ${numerator}}{${denominator}}`
});
defineMacro("\\pdv@next", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp}}{${denominator}} ${numerator}`
});

//////////////////////////////////////////////////////////////////////
// upgreek.dtx
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\upbeta", "\\up@greek{\\beta}");
defineMacro("\\upgamma", "\\up@greek{\\gamma}");
defineMacro("\\updelta", "\\up@greek{\\delta}");
defineMacro("\\upepsilon", "\\up@greek{\\epsilon}");
defineMacro("\\upzeta", "\\up@greek{\\zeta}");
defineMacro("\\upeta", "\\up@greek{\\eta}");
defineMacro("\\uptheta", "\\up@greek{\\theta}");
defineMacro("\\upiota", "\\up@greek{\\iota}");
defineMacro("\\upkappa", "\\up@greek{\\kappa}");
defineMacro("\\uplambda", "\\up@greek{\\lambda}");
defineMacro("\\upmu", "\\up@greek{\\mu}");
defineMacro("\\upnu", "\\up@greek{\\nu}");
defineMacro("\\upxi", "\\up@greek{\\xi}");
defineMacro("\\upomicron", "\\up@greek{\\omicron}");
defineMacro("\\uppi", "\\up@greek{\\pi}");
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\uprho", "\\up@greek{\\rho}");
defineMacro("\\upsigma", "\\up@greek{\\sigma}");
defineMacro("\\uptau", "\\up@greek{\\tau}");
defineMacro("\\upupsilon", "\\up@greek{\\upsilon}");
defineMacro("\\upphi", "\\up@greek{\\phi}");
defineMacro("\\upchi", "\\up@greek{\\chi}");
defineMacro("\\uppsi", "\\up@greek{\\psi}");
defineMacro("\\upomega", "\\up@greek{\\omega}");

//////////////////////////////////////////////////////////////////////
// cmll package
defineMacro("\\invamp", '\\mathbin{\\char"214b}');
defineMacro("\\parr", '\\mathbin{\\char"214b}');
defineMacro("\\with", '\\mathbin{\\char"26}');
defineMacro("\\multimapinv", '\\mathrel{\\char"27dc}');
defineMacro("\\multimapboth", '\\mathrel{\\char"29df}');
defineMacro("\\scoh", '{\\mkern5mu\\char"2322\\mkern5mu}');
defineMacro("\\sincoh", '{\\mkern5mu\\char"2323\\mkern5mu}');
defineMacro("\\coh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2322}}}
{\\smash{\\lower4mu{\\char"2323}}}\\mkern5mu}`);
defineMacro("\\incoh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2323}}}
{\\smash{\\lower4mu{\\char"2322}}}\\mkern5mu}`);


//////////////////////////////////////////////////////////////////////
// chemstyle package
defineMacro("\\standardstate", "\\text{\\tiny\\char`⦵}");

﻿/* eslint-disable */
/* -*- Mode: JavaScript; indent-tabs-mode:nil; js-indent-level: 2 -*- */
/* vim: set ts=2 et sw=2 tw=80: */

/*************************************************************
 *
 *  Temml mhchem.js
 *
 *  This file implements a Temml version of mhchem version 3.3.0.
 *  It is adapted from MathJax/extensions/TeX/mhchem.js
 *  It differs from the MathJax version as follows:
 *    1. The interface is changed so that it can be called from Temml, not MathJax.
 *    2. \rlap and \llap are replaced with \mathrlap and \mathllap.
 *    3. The reaction arrow code is simplified. All reaction arrows are rendered
 *       using Temml extensible arrows instead of building non-extensible arrows.
 *    4. The ~bond forms are composed entirely of \rule elements.
 *    5. Two dashes in _getBond are wrapped in braces to suppress spacing. i.e., {-}
 *    6. The electron dot uses \textbullet instead of \bullet.
 *    7. \smash[T] has been removed. (WebKit hides anything inside \smash{…})
 *
 *    This code, as other Temml code, is released under the MIT license.
 * 
 * /*************************************************************
 *
 *  MathJax/extensions/TeX/mhchem.js
 *
 *  Implements the \ce command for handling chemical formulas
 *  from the mhchem LaTeX package.
 *
 *  ---------------------------------------------------------------------
 *
 *  Copyright (c) 2011-2015 The MathJax Consortium
 *  Copyright (c) 2015-2018 Martin Hensel
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

//
// Coding Style
//   - use '' for identifiers that can by minified/uglified
//   - use "" for strings that need to stay untouched

// version: "3.3.0" for MathJax and Temml


// Add \ce, \pu, and \tripleDash to the Temml macros.

defineMacro("\\ce", function(context) {
  return chemParse(context.consumeArgs(1)[0], "ce")
});

defineMacro("\\pu", function(context) {
  return chemParse(context.consumeArgs(1)[0], "pu");
});

// Math fonts do not include glyphs for the ~ form of bonds. So we'll send path geometry
// So we'll compose characters built from \rule elements.
defineMacro("\\uniDash", `{\\rule{0.672em}{0.06em}}`)
defineMacro("\\triDash", `{\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}}`)
defineMacro("\\tripleDash", `\\kern0.075em\\raise0.25em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverLine", `\\kern0.075em\\mathrlap{\\raise0.125em{\\uniDash}}\\raise0.34em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\triDash}}\\raise0.27em{\\uniDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)
defineMacro("\\tripleDashBetweenDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\uniDash}}\\raise0.27em{\\triDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)

  //
  //  This is the main function for handing the \ce and \pu commands.
  //  It takes the argument to \ce or \pu and returns the corresponding TeX string.
  //

  var chemParse = function (tokens, stateMachine) {
    // Recreate the argument string from Temml's array of tokens.
    var str = "";
    var expectedLoc = tokens.length && tokens[tokens.length - 1].loc.start
    for (var i = tokens.length - 1; i >= 0; i--) {
      if(tokens[i].loc.start > expectedLoc) {
        // context.consumeArgs has eaten a space.
        str += " ";
        expectedLoc = tokens[i].loc.start;
      }
      str += tokens[i].text;
      expectedLoc += tokens[i].text.length;
    }
    // Call the mhchem core parser.
    var tex = texify.go(mhchemParser.go(str, stateMachine));
    return tex;
  };

  //
  // Core parser for mhchem syntax  (recursive)
  //
  /** @type {MhchemParser} */
  var mhchemParser = {
    //
    // Parses mchem \ce syntax
    //
    // Call like
    //   go("H2O");
    //
    go: function (input, stateMachine) {
      if (!input) { return []; }
      if (stateMachine === undefined) { stateMachine = 'ce'; }
      var state = '0';

      //
      // String buffers for parsing:
      //
      // buffer.a == amount
      // buffer.o == element
      // buffer.b == left-side superscript
      // buffer.p == left-side subscript
      // buffer.q == right-side subscript
      // buffer.d == right-side superscript
      //
      // buffer.r == arrow
      // buffer.rdt == arrow, script above, type
      // buffer.rd == arrow, script above, content
      // buffer.rqt == arrow, script below, type
      // buffer.rq == arrow, script below, content
      //
      // buffer.text_
      // buffer.rm
      // etc.
      //
      // buffer.parenthesisLevel == int, starting at 0
      // buffer.sb == bool, space before
      // buffer.beginsWithBond == bool
      //
      // These letters are also used as state names.
      //
      // Other states:
      // 0 == begin of main part (arrow/operator unlikely)
      // 1 == next entity
      // 2 == next entity (arrow/operator unlikely)
      // 3 == next atom
      // c == macro
      //
      /** @type {Buffer} */
      var buffer = {};
      buffer['parenthesisLevel'] = 0;

      input = input.replace(/\n/g, " ");
      input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
      input = input.replace(/[\u2026]/g, "...");

      //
      // Looks through mhchemParser.transitions, to execute a matching action
      // (recursive)
      //
      var lastInput;
      var watchdog = 10;
      /** @type {ParserOutput[]} */
      var output = [];
      while (true) {
        if (lastInput !== input) {
          watchdog = 10;
          lastInput = input;
        } else {
          watchdog--;
        }
        //
        // Find actions in transition table
        //
        var machine = mhchemParser.stateMachines[stateMachine];
        var t = machine.transitions[state] || machine.transitions['*'];
        iterateTransitions:
        for (var i=0; i<t.length; i++) {
          var matches = mhchemParser.patterns.match_(t[i].pattern, input);
          if (matches) {
            //
            // Execute actions
            //
            var task = t[i].task;
            for (var iA=0; iA<task.action_.length; iA++) {
              var o;
              //
              // Find and execute action
              //
              if (machine.actions[task.action_[iA].type_]) {
                o = machine.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else if (mhchemParser.actions[task.action_[iA].type_]) {
                o = mhchemParser.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else {
                throw ["MhchemBugA", "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"];  // Trying to use non-existing action
              }
              //
              // Add output
              //
              mhchemParser.concatArray(output, o);
            }
            //
            // Set next state,
            // Shorten input,
            // Continue with next character
            //   (= apply only one transition per position)
            //
            state = task.nextState || state;
            if (input.length > 0) {
              if (!task.revisit) {
                input = matches.remainder;
              }
              if (!task.toContinue) {
                break iterateTransitions;
              }
            } else {
              return output;
            }
          }
        }
        //
        // Prevent infinite loop
        //
        if (watchdog <= 0) {
          throw ["MhchemBugU", "mhchem bug U. Please report."];  // Unexpected character
        }
      }
    },
    concatArray: function (a, b) {
      if (b) {
        if (Array.isArray(b)) {
          for (var iB=0; iB<b.length; iB++) {
            a.push(b[iB]);
          }
        } else {
          a.push(b);
        }
      }
    },

    patterns: {
      //
      // Matching patterns
      // either regexps or function that return null or {match_:"a", remainder:"bc"}
      //
      patterns: {
        // property names must not look like integers ("2") for correct property traversal order, later on
        'empty': /^$/,
        'else': /^./,
        'else2': /^./,
        'space': /^\s/,
        'space A': /^\s(?=[A-Z\\$])/,
        'space$': /^\s$/,
        'a-z': /^[a-z]/,
        'x': /^x/,
        'x$': /^x$/,
        'i$': /^i$/,
        'letters': /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
        '\\greek': /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
        'one lowercase latin letter $': /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
        '$one lowercase latin letter$ $': /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
        'one lowercase greek letter $': /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
        'digits': /^[0-9]+/,
        '-9.,9': /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
        '-9.,9 no missing 0': /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
        '(-)(9.,9)(e)(99)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '(-)(9)^(-9)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        'state of aggregation $': function (input) {  // ... or crystal system
          var a = mhchemParser.patterns.findObserveGroups(input, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");  // (aq), (aq,$\infty$), (aq, sat)
          if (a  &&  a.remainder.match(/^($|[\s,;\)\]\}])/)) { return a; }  //  AND end of 'phrase'
          var m = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);  // OR crystal system ($o$) (\ca$c$)
          if (m) {
            return { match_: m[0], remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '_{(state of aggregation)}$': /^_\{(\([a-z]{1,3}\))\}/,
        '{[(': /^(?:\\\{|\[|\()/,
        ')]}': /^(?:\)|\]|\\\})/,
        ', ': /^[,;]\s*/,
        ',': /^[,;]/,
        '.': /^[.]/,
        '. ': /^([.\u22C5\u00B7\u2022])\s*/,
        '...': /^\.\.\.(?=$|[^.])/,
        '* ': /^([*])\s*/,
        '^{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^{", "", "", "}"); },
        '^($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", "$", "$", ""); },
        '^a': /^\^([0-9]+|[^\\_])/,
        '^\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '^\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", ""); },
        '^\\x': /^\^(\\[a-zA-Z]+)\s*/,
        '^(-1)': /^\^(-?\d+)/,
        '\'': /^'/,
        '_{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_{", "", "", "}"); },
        '_($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", "$", "$", ""); },
        '_9': /^_([+\-]?[0-9]+|[^\\])/,
        '_\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '_\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", ""); },
        '_\\x': /^_(\\[a-zA-Z]+)\s*/,
        '^_': /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
        '{}': /^\{\}/,
        '{...}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "{", "}", ""); },
        '{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}"); },
        '$...$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "$", "$", ""); },
        '${(...)}$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "${", "", "", "}$"); },
        '$(...)$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$"); },
        '=<>': /^[=<>]/,
        '#': /^[#\u2261]/,
        '+': /^\+/,
        '-$': /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,  // -space -, -; -] -/ -$ -state-of-aggregation
        '-9': /^-(?=[0-9])/,
        '- orbital overlap': /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
        '-': /^-/,
        'pm-operator': /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
        'operator': /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
        'arrowUpDown': /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
        '\\bond{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\bond{", "", "", "}"); },
        '->': /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
        'CMT': /^[CMT](?=\[)/,
        '[(...)]': function (input) { return mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]"); },
        '1st-level escape': /^(&|\\\\|\\hline)\s*/,
        '\\,': /^(?:\\[,\ ;:])/,  // \\x - but output no space before
        '\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", ""); },
        '\\ca': /^\\ca(?:\s+|(?![a-zA-Z]))/,
        '\\x': /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
        'orbital': /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,  // only those with numbers in front, because the others will be formatted correctly anyway
        'others': /^[\/~|]/,
        '\\frac{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\frac{", "", "", "}", "{", "", "", "}"); },
        '\\overset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\overset{", "", "", "}", "{", "", "", "}"); },
        '\\underset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underset{", "", "", "}", "{", "", "", "}"); },
        '\\underbrace{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underbrace{", "", "", "}_", "{", "", "", "}"); },
        '\\color{(...)}0': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}"); },
        '\\color{(...)}{(...)}1': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}", "{", "", "", "}"); },
        '\\color(...){(...)}2': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}"); },
        '\\ce{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\ce{", "", "", "}"); },
        'oxidation$': /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
        'd-oxidation$': /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,  // 0 could be oxidation or charge
        'roman numeral': /^[IVX]+/,
        '1/2$': /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
        'amount': function (input) {
          var match;
          // e.g. 2, 0.5, 1/2, -2, n/2, +;  $a$ could be added later in parsing
          match = input.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          var a = mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
          if (a) {  // e.g. $2n-1$, $-$
            match = a.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/);
            if (match) {
              return { match_: match[0], remainder: input.substr(match[0].length) };
            }
          }
          return null;
        },
        'amount2': function (input) { return this['amount'](input); },
        '(KV letters),': /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
        'formula$': function (input) {
          if (input.match(/^\([a-z]+\)$/)) { return null; }  // state of aggregation = no formula
          var match = input.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          return null;
        },
        'uprightEntities': /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
        '/': /^\s*(\/)\s*/,
        '//': /^\s*(\/\/)\s*/,
        '*': /^\s*[*.]\s*/
      },
      findObserveGroups: function (input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
        /** @type {{(input: string, pattern: string | RegExp): string | string[] | null;}} */
        var _match = function (input, pattern) {
          if (typeof pattern === "string") {
            if (input.indexOf(pattern) !== 0) { return null; }
            return pattern;
          } else {
            var match = input.match(pattern);
            if (!match) { return null; }
            return match[0];
          }
        };
        /** @type {{(input: string, i: number, endChars: string | RegExp): {endMatchBegin: number, endMatchEnd: number} | null;}} */
        var _findObserveGroups = function (input, i, endChars) {
          var braces = 0;
          while (i < input.length) {
            var a = input.charAt(i);
            var match = _match(input.substr(i), endChars);
            if (match !== null  &&  braces === 0) {
              return { endMatchBegin: i, endMatchEnd: i + match.length };
            } else if (a === "{") {
              braces++;
            } else if (a === "}") {
              if (braces === 0) {
                throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
              } else {
                braces--;
              }
            }
            i++;
          }
          if (braces > 0) {
            return null;
          }
          return null;
        };
        var match = _match(input, begExcl);
        if (match === null) { return null; }
        input = input.substr(match.length);
        match = _match(input, begIncl);
        if (match === null) { return null; }
        var e = _findObserveGroups(input, match.length, endIncl || endExcl);
        if (e === null) { return null; }
        var match1 = input.substring(0, (endIncl ? e.endMatchEnd : e.endMatchBegin));
        if (!(beg2Excl || beg2Incl)) {
          return {
            match_: match1,
            remainder: input.substr(e.endMatchEnd)
          };
        } else {
          var group2 = this.findObserveGroups(input.substr(e.endMatchEnd), beg2Excl, beg2Incl, end2Incl, end2Excl);
          if (group2 === null) { return null; }
          /** @type {string[]} */
          var matchRet = [match1, group2.match_];
          return {
            match_: (combine ? matchRet.join("") : matchRet),
            remainder: group2.remainder
          };
        }
      },

      //
      // Matching function
      // e.g. match("a", input) will look for the regexp called "a" and see if it matches
      // returns null or {match_:"a", remainder:"bc"}
      //
      match_: function (m, input) {
        var pattern = mhchemParser.patterns.patterns[m];
        if (pattern === undefined) {
          throw ["MhchemBugP", "mhchem bug P. Please report. (" + m + ")"];  // Trying to use non-existing pattern
        } else if (typeof pattern === "function") {
          return mhchemParser.patterns.patterns[m](input);  // cannot use cached var pattern here, because some pattern functions need this===mhchemParser
        } else {  // RegExp
          var match = input.match(pattern);
          if (match) {
            var mm;
            if (match[2]) {
              mm = [ match[1], match[2] ];
            } else if (match[1]) {
              mm = match[1];
            } else {
              mm = match[0];
            }
            return { match_: mm, remainder: input.substr(match[0].length) };
          }
          return null;
        }
      }
    },

    //
    // Generic state machine actions
    //
    actions: {
      'a=': function (buffer, m) { buffer.a = (buffer.a || "") + m; },
      'b=': function (buffer, m) { buffer.b = (buffer.b || "") + m; },
      'p=': function (buffer, m) { buffer.p = (buffer.p || "") + m; },
      'o=': function (buffer, m) { buffer.o = (buffer.o || "") + m; },
      'q=': function (buffer, m) { buffer.q = (buffer.q || "") + m; },
      'd=': function (buffer, m) { buffer.d = (buffer.d || "") + m; },
      'rm=': function (buffer, m) { buffer.rm = (buffer.rm || "") + m; },
      'text=': function (buffer, m) { buffer.text_ = (buffer.text_ || "") + m; },
      'insert': function (buffer, m, a) { return { type_: a }; },
      'insert+p1': function (buffer, m, a) { return { type_: a, p1: m }; },
      'insert+p1+p2': function (buffer, m, a) { return { type_: a, p1: m[0], p2: m[1] }; },
      'copy': function (buffer, m) { return m; },
      'rm': function (buffer, m) { return { type_: 'rm', p1: m || ""}; },
      'text': function (buffer, m) { return mhchemParser.go(m, 'text'); },
      '{text}': function (buffer, m) {
        var ret = [ "{" ];
        mhchemParser.concatArray(ret, mhchemParser.go(m, 'text'));
        ret.push("}");
        return ret;
      },
      'tex-math': function (buffer, m) { return mhchemParser.go(m, 'tex-math'); },
      'tex-math tight': function (buffer, m) { return mhchemParser.go(m, 'tex-math tight'); },
      'bond': function (buffer, m, k) { return { type_: 'bond', kind_: k || m }; },
      'color0-output': function (buffer, m) { return { type_: 'color0', color: m[0] }; },
      'ce': function (buffer, m) { return mhchemParser.go(m); },
      '1/2': function (buffer, m) {
        /** @type {ParserOutput[]} */
        var ret = [];
        if (m.match(/^[+\-]/)) {
          ret.push(m.substr(0, 1));
          m = m.substr(1);
        }
        var n = m.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
        n[1] = n[1].replace(/\$/g, "");
        ret.push({ type_: 'frac', p1: n[1], p2: n[2] });
        if (n[3]) {
          n[3] = n[3].replace(/\$/g, "");
          ret.push({ type_: 'tex-math', p1: n[3] });
        }
        return ret;
      },
      '9,9': function (buffer, m) { return mhchemParser.go(m, '9,9'); }
    },
    //
    // createTransitions
    // convert  { 'letter': { 'state': { action_: 'output' } } }  to  { 'state' => [ { pattern: 'letter', task: { action_: [{type_: 'output'}] } } ] }
    // with expansion of 'a|b' to 'a' and 'b' (at 2 places)
    //
    createTransitions: function (o) {
      var pattern, state;
      /** @type {string[]} */
      var stateArray;
      var i;
      //
      // 1. Collect all states
      //
      /** @type {Transitions} */
      var transitions = {};
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = state.split("|");
          o[pattern][state].stateArray = stateArray;
          for (i=0; i<stateArray.length; i++) {
            transitions[stateArray[i]] = [];
          }
        }
      }
      //
      // 2. Fill states
      //
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = o[pattern][state].stateArray || [];
          for (i=0; i<stateArray.length; i++) {
            //
            // 2a. Normalize actions into array:  'text=' ==> [{type_:'text='}]
            // (Note to myself: Resolving the function here would be problematic. It would need .bind (for *this*) and currying (for *option*).)
            //
            /** @type {any} */
            var p = o[pattern][state];
            if (p.action_) {
              p.action_ = [].concat(p.action_);
              for (var k=0; k<p.action_.length; k++) {
                if (typeof p.action_[k] === "string") {
                  p.action_[k] = { type_: p.action_[k] };
                }
              }
            } else {
              p.action_ = [];
            }
            //
            // 2.b Multi-insert
            //
            var patternArray = pattern.split("|");
            for (var j=0; j<patternArray.length; j++) {
              if (stateArray[i] === '*') {  // insert into all
                for (var t in transitions) {
                  transitions[t].push({ pattern: patternArray[j], task: p });
                }
              } else {
                transitions[stateArray[i]].push({ pattern: patternArray[j], task: p });
              }
            }
          }
        }
      }
      return transitions;
    },
    stateMachines: {}
  };

  //
  // Definition of state machines
  //
  mhchemParser.stateMachines = {
    //
    // \ce state machines
    //
    //#region ce
    'ce': {  // main parser
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'else':  {
          '0|1|2': { action_: 'beginsWithBond=false', revisit: true, toContinue: true } },
        'oxidation$': {
          '0': { action_: 'oxidation-output' } },
        'CMT': {
          'r': { action_: 'rdt=', nextState: 'rt' },
          'rd': { action_: 'rqt=', nextState: 'rdt' } },
        'arrowUpDown': {
          '0|1|2|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '1' } },
        'uprightEntities': {
          '0|1|2': { action_: [ 'o=', 'output' ], nextState: '1' } },
        'orbital': {
          '0|1|2|3': { action_: 'o=', nextState: 'o' } },
        '->': {
          '0|1|2|3': { action_: 'r=', nextState: 'r' },
          'a|as': { action_: [ 'output', 'r=' ], nextState: 'r' },
          '*': { action_: [ 'output', 'r=' ], nextState: 'r' } },
        '+': {
          'o': { action_: 'd= kv',  nextState: 'd' },
          'd|D': { action_: 'd=', nextState: 'd' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd|qD': { action_: 'd=', nextState: 'qd' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' },
          '3': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        'amount': {
          '0|2': { action_: 'a=', nextState: 'a' } },
        'pm-operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', { type_: 'operator', option: '\\pm' } ], nextState: '0' } },
        'operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        '-$': {
          'o|q': { action_: [ 'charge or bond', 'output' ],  nextState: 'qd' },
          'd': { action_: 'd=', nextState: 'd' },
          'D': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd': { action_: 'd=', nextState: 'qd' },
          'qD|dq': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        '-9': {
          '3|o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '3' } },
        '- orbital overlap': {
          'o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'd': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' } },
        '-': {
          '0|1|2': { action_: [ { type_: 'output', option: 1 }, 'beginsWithBond=true', { type_: 'bond', option: "-" } ], nextState: '3' },
          '3': { action_: { type_: 'bond', option: "-" } },
          'a': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'as': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "-" } ], nextState: '3' },
          'b': { action_: 'b=' },
          'o': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'q': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'd|qd|dq': { action_: { type_: '- after o/d', option: true }, nextState: '2' },
          'D|qD|p': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        'amount2': {
          '1|3': { action_: 'a=', nextState: 'a' } },
        'letters': {
          '0|1|2|3|a|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },
          'q|dq': { action_: ['output', 'o='], nextState: 'o' },
          'd|D|qd|qD': { action_: 'o after d', nextState: 'o' } },
        'digits': {
          'o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q': { action_: [ 'output', 'o=' ], nextState: 'o' },
          'a': { action_: 'o=', nextState: 'o' } },
        'space A': {
          'b|p|bp': {} },
        'space': {
          'a': { nextState: 'as' },
          '0': { action_: 'sb=false' },
          '1|2': { action_: 'sb=true' },
          'r|rt|rd|rdt|rdq': { action_: 'output', nextState: '0' },
          '*': { action_: [ 'output', 'sb=true' ], nextState: '1'} },
        '1st-level escape': {
          '1|2': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ] },
          '*': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ], nextState: '0' } },
        '[(...)]': {
          'r|rt': { action_: 'rd=', nextState: 'rd' },
          'rd|rdt': { action_: 'rq=', nextState: 'rdq' } },
        '...': {
          'o|d|D|dq|qd|qD': { action_: [ 'output', { type_: 'bond', option: "..." } ], nextState: '3' },
          '*': { action_: [ { type_: 'output', option: 1 }, { type_: 'insert', option: 'ellipsis' } ], nextState: '1' } },
        '. |* ': {
          '*': { action_: [ 'output', { type_: 'insert', option: 'addition compound' } ], nextState: '1' } },
        'state of aggregation $': {
          '*': { action_: [ 'output', 'state of aggregation' ], nextState: '1' } },
        '{[(': {
          'a|as|o': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '0|1|2|3': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '*': { action_: [ 'output', 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' } },
        ')]}': {
          '0|1|2|3|b|p|bp|o': { action_: [ 'o=', 'parenthesisLevel--' ], nextState: 'o' },
          'a|as|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=', 'parenthesisLevel--' ], nextState: 'o' } },
        ', ': {
          '*': { action_: [ 'output', 'comma' ], nextState: '0' } },
        '^_': {  // ^ and _ without a sensible argument
          '*': { } },
        '^{(...)}|^($...$)': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'D' },
          'q': { action_: 'd=', nextState: 'qD' },
          'd|D|qd|qD|dq': { action_: [ 'output', 'd=' ], nextState: 'D' } },
        '^a|^\\x{}{}|^\\x{}|^\\x|\'': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'd' },
          'q': { action_: 'd=', nextState: 'qd' },
          'd|qd|D|qD': { action_: 'd=' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' } },
        '_{(state of aggregation)}$': {
          'd|D|q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x': {
          '0|1|2|as': { action_: 'p=', nextState: 'p' },
          'b': { action_: 'p=', nextState: 'bp' },
          '3|o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '=<>': {
          '0|1|2|3|a|as|o|q|d|D|qd|qD|dq': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: '3' } },
        '#': {
          '0|1|2|3|a|as|o': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "#" } ], nextState: '3' } },
        '{}': {
          '*': { action_: { type_: 'output', option: 1 },  nextState: '1' } },
        '{...}': {
          '0|1|2|3|a|as|b|p|bp': { action_: 'o=', nextState: 'o' },
          'o|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '$...$': {
          'a': { action_: 'a=' },  // 2$n$
          '0|1|2|3|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },  // not 'amount'
          'as|o': { action_: 'o=' },
          'q|d|D|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '\\bond{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: "3" } },
        '\\frac{(...)}': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'frac-output' ], nextState: '3' } },
        '\\overset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'overset-output' ], nextState: '3' } },
        '\\underset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underset-output' ], nextState: '3' } },
        '\\underbrace{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underbrace-output' ], nextState: '3' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color-output' ], nextState: '3' } },
        '\\color{(...)}0': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color0-output' ] } },
        '\\ce{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'ce' ], nextState: '3' } },
        '\\,': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '1' } },
        '\\x{}{}|\\x{}|\\x': {
          '0|1|2|3|a|as|b|p|bp|o|c0': { action_: [ 'o=', 'output' ], nextState: '3' },
          '*': { action_: ['output', 'o=', 'output' ], nextState: '3' } },
        'others': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '3' } },
        'else2': {
          'a': { action_: 'a to o', nextState: 'o', revisit: true },
          'as': { action_: [ 'output', 'sb=true' ], nextState: '1', revisit: true },
          'r|rt|rd|rdt|rdq': { action_: [ 'output' ], nextState: '0', revisit: true },
          '*': { action_: [ 'output', 'copy' ], nextState: '3' } }
      }),
      actions: {
        'o after d': function (buffer, m) {
          var ret;
          if ((buffer.d || "").match(/^[0-9]+$/)) {
            var tmp = buffer.d;
            buffer.d = undefined;
            ret = this['output'](buffer);
            buffer.b = tmp;
          } else {
            ret = this['output'](buffer);
          }
          mhchemParser.actions['o='](buffer, m);
          return ret;
        },
        'd= kv': function (buffer, m) {
          buffer.d = m;
          buffer.dType = 'kv';
        },
        'charge or bond': function (buffer, m) {
          if (buffer['beginsWithBond']) {
            /** @type {ParserOutput[]} */
            var ret = [];
            mhchemParser.concatArray(ret, this['output'](buffer));
            mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            return ret;
          } else {
            buffer.d = m;
          }
        },
        '- after o/d': function (buffer, m, isAfterD) {
          var c1 = mhchemParser.patterns.match_('orbital', buffer.o || "");
          var c2 = mhchemParser.patterns.match_('one lowercase greek letter $', buffer.o || "");
          var c3 = mhchemParser.patterns.match_('one lowercase latin letter $', buffer.o || "");
          var c4 = mhchemParser.patterns.match_('$one lowercase latin letter$ $', buffer.o || "");
          var hyphenFollows =  m==="-" && ( c1 && c1.remainder===""  ||  c2  ||  c3  ||  c4 );
          if (hyphenFollows && !buffer.a && !buffer.b && !buffer.p && !buffer.d && !buffer.q && !c1 && c3) {
            buffer.o = '$' + buffer.o + '$';
          }
          /** @type {ParserOutput[]} */
          var ret = [];
          if (hyphenFollows) {
            mhchemParser.concatArray(ret, this['output'](buffer));
            ret.push({ type_: 'hyphen' });
          } else {
            c1 = mhchemParser.patterns.match_('digits', buffer.d || "");
            if (isAfterD && c1 && c1.remainder==='') {
              mhchemParser.concatArray(ret, mhchemParser.actions['d='](buffer, m));
              mhchemParser.concatArray(ret, this['output'](buffer));
            } else {
              mhchemParser.concatArray(ret, this['output'](buffer));
              mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            }
          }
          return ret;
        },
        'a to o': function (buffer) {
          buffer.o = buffer.a;
          buffer.a = undefined;
        },
        'sb=true': function (buffer) { buffer.sb = true; },
        'sb=false': function (buffer) { buffer.sb = false; },
        'beginsWithBond=true': function (buffer) { buffer['beginsWithBond'] = true; },
        'beginsWithBond=false': function (buffer) { buffer['beginsWithBond'] = false; },
        'parenthesisLevel++': function (buffer) { buffer['parenthesisLevel']++; },
        'parenthesisLevel--': function (buffer) { buffer['parenthesisLevel']--; },
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation', p1: mhchemParser.go(m, 'o') };
        },
        'comma': function (buffer, m) {
          var a = m.replace(/\s*$/, '');
          var withSpace = (a !== m);
          if (withSpace  &&  buffer['parenthesisLevel'] === 0) {
            return { type_: 'comma enumeration L', p1: a };
          } else {
            return { type_: 'comma enumeration M', p1: a };
          }
        },
        'output': function (buffer, m, entityFollows) {
          // entityFollows:
          //   undefined = if we have nothing else to output, also ignore the just read space (buffer.sb)
          //   1 = an entity follows, never omit the space if there was one just read before (can only apply to state 1)
          //   2 = 1 + the entity can have an amount, so output a\, instead of converting it to o (can only apply to states a|as)
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          if (!buffer.r) {
            ret = [];
            if (!buffer.a && !buffer.b && !buffer.p && !buffer.o && !buffer.q && !buffer.d && !entityFollows) {
              //ret = [];
            } else {
              if (buffer.sb) {
                ret.push({ type_: 'entitySkip' });
              }
              if (!buffer.o && !buffer.q && !buffer.d && !buffer.b && !buffer.p && entityFollows!==2) {
                buffer.o = buffer.a;
                buffer.a = undefined;
              } else if (!buffer.o && !buffer.q && !buffer.d && (buffer.b || buffer.p)) {
                buffer.o = buffer.a;
                buffer.d = buffer.b;
                buffer.q = buffer.p;
                buffer.a = buffer.b = buffer.p = undefined;
              } else {
                if (buffer.o && buffer.dType==='kv' && mhchemParser.patterns.match_('d-oxidation$', buffer.d || "")) {
                  buffer.dType = 'oxidation';
                } else if (buffer.o && buffer.dType==='kv' && !buffer.q) {
                  buffer.dType = undefined;
                }
              }
              ret.push({
                type_: 'chemfive',
                a: mhchemParser.go(buffer.a, 'a'),
                b: mhchemParser.go(buffer.b, 'bd'),
                p: mhchemParser.go(buffer.p, 'pq'),
                o: mhchemParser.go(buffer.o, 'o'),
                q: mhchemParser.go(buffer.q, 'pq'),
                d: mhchemParser.go(buffer.d, (buffer.dType === 'oxidation' ? 'oxidation' : 'bd')),
                dType: buffer.dType
              });
            }
          } else {  // r
            /** @type {ParserOutput[]} */
            var rd;
            if (buffer.rdt === 'M') {
              rd = mhchemParser.go(buffer.rd, 'tex-math');
            } else if (buffer.rdt === 'T') {
              rd = [ { type_: 'text', p1: buffer.rd || "" } ];
            } else {
              rd = mhchemParser.go(buffer.rd);
            }
            /** @type {ParserOutput[]} */
            var rq;
            if (buffer.rqt === 'M') {
              rq = mhchemParser.go(buffer.rq, 'tex-math');
            } else if (buffer.rqt === 'T') {
              rq = [ { type_: 'text', p1: buffer.rq || ""} ];
            } else {
              rq = mhchemParser.go(buffer.rq);
            }
            ret = {
              type_: 'arrow',
              r: buffer.r,
              rd: rd,
              rq: rq
            };
          }
          for (var p in buffer) {
            if (p !== 'parenthesisLevel'  &&  p !== 'beginsWithBond') {
              delete buffer[p];
            }
          }
          return ret;
        },
        'oxidation-output': function (buffer, m) {
          var ret = [ "{" ];
          mhchemParser.concatArray(ret, mhchemParser.go(m, 'oxidation'));
          ret.push("}");
          return ret;
        },
        'frac-output': function (buffer, m) {
          return { type_: 'frac-ce', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'overset-output': function (buffer, m) {
          return { type_: 'overset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underset-output': function (buffer, m) {
          return { type_: 'underset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underbrace-output': function (buffer, m) {
          return { type_: 'underbrace', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1]) };
        },
        'r=': function (buffer, m) { buffer.r = m; },
        'rdt=': function (buffer, m) { buffer.rdt = m; },
        'rd=': function (buffer, m) { buffer.rd = m; },
        'rqt=': function (buffer, m) { buffer.rqt = m; },
        'rq=': function (buffer, m) { buffer.rq = m; },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; }
      }
    },
    'a': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        '$(...)$': {
          '*': { action_: 'tex-math tight', nextState: '1' } },
        ',': {
          '*': { action_: { type_: 'insert', option: 'commaDecimal' } } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'o': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        'letters': {
          '*': { action_: 'rm' } },
        '\\ca': {
          '*': { action_: { type_: 'insert', option: 'circa' } } },
        '\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: '{text}' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'text': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '{...}': {
          '*': { action_: 'text=' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '\\greek': {
          '*': { action_: [ 'output', 'rm' ] } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: [ 'output', 'copy' ] } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.text_) {
            /** @type {ParserOutput} */
            var ret = { type_: 'text', p1: buffer.text_ };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'pq': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'state of aggregation $': {
          '*': { action_: 'state of aggregation' } },
        'i$': {
          '0': { nextState: '!f', revisit: true } },
        '(KV letters),': {
          '0': { action_: 'rm', nextState: '0' } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'letters': {
          '*': { action_: 'rm' } },
        '-9.,9': {
          '*': { action_: '9,9'  } },
        ',': {
          '*': { action_: { type_: 'insert+p1', option: 'comma enumeration S' } } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation subscript', p1: mhchemParser.go(m, 'o') };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'pq') };
        }
      }
    },
    'bd': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'x$': {
          '0': { nextState: '!f', revisit: true } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '-9.,9 no missing 0': {
          '*': { action_: '9,9' } },
        '.': {
          '*': { action_: { type_: 'insert', option: 'electron dot' } } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'x': {
          '*': { action_: { type_: 'insert', option: 'KV x' } } },
        'letters': {
          '*': { action_: 'rm' } },
        '\'': {
          '*': { action_: { type_: 'insert', option: 'prime' } } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'bd') };
        }
      }
    },
    'oxidation': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'roman numeral': {
          '*': { action_: 'roman-numeral' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'roman-numeral': function (buffer, m) { return { type_: 'roman numeral', p1: m || "" }; }
      }
    },
    'tex-math': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'tex-math tight': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        '-|+': {
          '*': { action_: 'tight operator' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'tight operator': function (buffer, m) { buffer.o = (buffer.o || "") + "{"+m+"}"; },
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    '9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        ',': {
          '*': { action_: 'comma' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; }
      }
    },
    //#endregion
    //
    // \pu state machines
    //
    //#region pu
    'pu': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'space$': {
          '*': { action_: [ 'output', 'space' ] } },
        '{[(|)]}': {
          '0|a': { action_: 'copy' } },
        '(-)(9)^(-9)': {
          '0': { action_: 'number^', nextState: 'a' } },
        '(-)(9.,9)(e)(99)': {
          '0': { action_: 'enumber', nextState: 'a' } },
        'space': {
          '0|a': {} },
        'pm-operator': {
          '0|a': { action_: { type_: 'operator', option: '\\pm' }, nextState: '0' } },
        'operator': {
          '0|a': { action_: 'copy', nextState: '0' } },
        '//': {
          'd': { action_: 'o=', nextState: '/' } },
        '/': {
          'd': { action_: 'o=', nextState: '/' } },
        '{...}|else': {
          '0|d': { action_: 'd=', nextState: 'd' },
          'a': { action_: [ 'space', 'd=' ], nextState: 'd' },
          '/|q': { action_: 'q=', nextState: 'q' } }
      }),
      actions: {
        'enumber': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          if (m[1]) {
            mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
            if (m[2]) {
              if (m[2].match(/[,.]/)) {
                mhchemParser.concatArray(ret, mhchemParser.go(m[2], 'pu-9,9'));
              } else {
                ret.push(m[2]);
              }
            }
            m[3] = m[4] || m[3];
            if (m[3]) {
              m[3] = m[3].trim();
              if (m[3] === "e"  ||  m[3].substr(0, 1) === "*") {
                ret.push({ type_: 'cdot' });
              } else {
                ret.push({ type_: 'times' });
              }
            }
          }
          if (m[3]) {
            ret.push("10^{"+m[5]+"}");
          }
          return ret;
        },
        'number^': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
          ret.push("^{"+m[2]+"}");
          return ret;
        },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; },
        'space': function () { return { type_: 'pu-space-1' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          var md = mhchemParser.patterns.match_('{(...)}', buffer.d || "");
          if (md  &&  md.remainder === '') { buffer.d = md.match_; }
          var mq = mhchemParser.patterns.match_('{(...)}', buffer.q || "");
          if (mq  &&  mq.remainder === '') { buffer.q = mq.match_; }
          if (buffer.d) {
            buffer.d = buffer.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.d = buffer.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
          }
          if (buffer.q) {  // fraction
            buffer.q = buffer.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.q = buffer.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
            var b5 = {
              d: mhchemParser.go(buffer.d, 'pu'),
              q: mhchemParser.go(buffer.q, 'pu')
            };
            if (buffer.o === '//') {
              ret = { type_: 'pu-frac', p1: b5.d, p2: b5.q };
            } else {
              ret = b5.d;
              if (b5.d.length > 1  ||  b5.q.length > 1) {
                ret.push({ type_: ' / ' });
              } else {
                ret.push({ type_: '/' });
              }
              mhchemParser.concatArray(ret, b5.q);
            }
          } else {  // no fraction
            ret = mhchemParser.go(buffer.d, 'pu-2');
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-2': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '*': {
          '*': { action_: [ 'output', 'cdot' ], nextState: '0' } },
        '\\x': {
          '*': { action_: 'rm=' } },
        'space': {
          '*': { action_: [ 'output', 'space' ], nextState: '0' } },
        '^{(...)}|^(-1)': {
          '1': { action_: '^(-1)' } },
        '-9.,9': {
          '0': { action_: 'rm=', nextState: '0' },
          '1': { action_: '^(-1)', nextState: '0' } },
        '{...}|else': {
          '*': { action_: 'rm=', nextState: '1' } }
      }),
      actions: {
        'cdot': function () { return { type_: 'tight cdot' }; },
        '^(-1)': function (buffer, m) { buffer.rm += "^{"+m+"}"; },
        'space': function () { return { type_: 'pu-space-2' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret = [];
          if (buffer.rm) {
            var mrm = mhchemParser.patterns.match_('{(...)}', buffer.rm || "");
            if (mrm  &&  mrm.remainder === '') {
              ret = mhchemParser.go(mrm.match_, 'pu');
            } else {
              ret = { type_: 'rm', p1: buffer.rm };
            }
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '0': { action_: 'output-0' },
          'o': { action_: 'output-o' } },
        ',': {
          '0': { action_: [ 'output-0', 'comma' ], nextState: 'o' } },
        '.': {
          '0': { action_: [ 'output-0', 'copy' ], nextState: 'o' } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; },
        'output-0': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length % 3;
            if (a === 0) { a = 3; }
            for (var i=buffer.text_.length-3; i>0; i-=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(0, a));
            ret.reverse();
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        },
        'output-o': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length - 3;
            for (var i=0; i<a; i+=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(i));
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    }
    //#endregion
  };

  //
  // texify: Take MhchemParser output and convert it to TeX
  //
  /** @type {Texify} */
  var texify = {
    go: function (input, isInner) {  // (recursive, max 4 levels)
      if (!input) { return ""; }
      var res = "";
      var cee = false;
      for (var i=0; i < input.length; i++) {
        var inputi = input[i];
        if (typeof inputi === "string") {
          res += inputi;
        } else {
          res += texify._go2(inputi);
          if (inputi.type_ === '1st-level escape') { cee = true; }
        }
      }
      if (!isInner && !cee && res) {
        res = "{" + res + "}";
      }
      return res;
    },
    _goInner: function (input) {
      if (!input) { return input; }
      return texify.go(input, true);
    },
    _go2: function (buf) {
      /** @type {undefined | string} */
      var res;
      switch (buf.type_) {
        case 'chemfive':
          res = "";
          var b5 = {
            a: texify._goInner(buf.a),
            b: texify._goInner(buf.b),
            p: texify._goInner(buf.p),
            o: texify._goInner(buf.o),
            q: texify._goInner(buf.q),
            d: texify._goInner(buf.d)
          };
          //
          // a
          //
          if (b5.a) {
            if (b5.a.match(/^[+\-]/)) { b5.a = "{"+b5.a+"}"; }
            res += b5.a + "\\,";
          }
          //
          // b and p
          //
          if (b5.b || b5.p) {
            res += "{\\vphantom{X}}";
            res += "^{\\hphantom{"+(b5.b||"")+"}}_{\\hphantom{"+(b5.p||"")+"}}";
            res += "{\\vphantom{X}}";
            // In the next two lines, I've removed \smash[t] (ron)
            // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
            //res += "^{\\smash[t]{\\vphantom{2}}\\mathllap{"+(b5.b||"")+"}}";
            res += "^{\\vphantom{2}\\mathllap{"+(b5.b||"")+"}}";
            //res += "_{\\vphantom{2}\\mathllap{\\smash[t]{"+(b5.p||"")+"}}}";
            res += "_{\\vphantom{2}\\mathllap{"+(b5.p||"")+"}}";
          }
          //
          // o
          //
          if (b5.o) {
            if (b5.o.match(/^[+\-]/)) { b5.o = "{"+b5.o+"}"; }
            res += b5.o;
          }
          //
          // q and d
          //
          if (buf.dType === 'kv') {
            if (b5.d || b5.q) {
              res += "{\\vphantom{X}}";
            }
            if (b5.d) {
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else if (buf.dType === 'oxidation') {
            if (b5.d) {
              res += "{\\vphantom{X}}";
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // A Firefox bug adds a bogus depth to <mphantom>, so we change \vphantom{X} to {}
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else {
            if (b5.q) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
            if (b5.d) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              res += "^{"+b5.d+"}";
            }
          }
          break;
        case 'rm':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'text':
          if (buf.p1.match(/[\^_]/)) {
            buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
            res = "\\mathrm{"+buf.p1+"}";
          } else {
            res = "\\text{"+buf.p1+"}";
          }
          break;
        case 'roman numeral':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'state of aggregation':
          res = "\\mskip2mu "+texify._goInner(buf.p1);
          break;
        case 'state of aggregation subscript':
          res = "\\mskip1mu "+texify._goInner(buf.p1);
          break;
        case 'bond':
          res = texify._getBond(buf.kind_);
          if (!res) {
            throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + buf.kind_ + ")"];
          }
          break;
        case 'frac':
          var c = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
          res = "\\mathchoice{\\textstyle"+c+"}{"+c+"}{"+c+"}{"+c+"}";
          break;
        case 'pu-frac':
          var d = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          res = "\\mathchoice{\\textstyle"+d+"}{"+d+"}{"+d+"}{"+d+"}";
          break;
        case 'tex-math':
          res = buf.p1 + " ";
          break;
        case 'frac-ce':
          res = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'overset':
          res = "\\overset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underset':
          res = "\\underset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underbrace':
          res =  "\\underbrace{" + texify._goInner(buf.p1) + "}_{" + texify._goInner(buf.p2) + "}";
          break;
        case 'color':
          res = "{\\color{" + buf.color1 + "}{" + texify._goInner(buf.color2) + "}}";
          break;
        case 'color0':
          res = "\\color{" + buf.color + "}";
          break;
        case 'arrow':
          var b6 = {
            rd: texify._goInner(buf.rd),
            rq: texify._goInner(buf.rq)
          };
          var arrow = texify._getArrow(buf.r);
          if (b6.rq) { arrow += "[{\\rm " + b6.rq + "}]"; }
          if (b6.rd) {
            arrow += "{\\rm " + b6.rd + "}";
          } else {
            arrow += "{}";
          }
          res = arrow;
          break;
        case 'operator':
          res = texify._getOperator(buf.kind_);
          break;
        case '1st-level escape':
          res = buf.p1+" ";  // &, \\\\, \\hlin
          break;
        case 'space':
          res = " ";
          break;
        case 'entitySkip':
          res = "~";
          break;
        case 'pu-space-1':
          res = "~";
          break;
        case 'pu-space-2':
          res = "\\mkern3mu ";
          break;
        case '1000 separator':
          res = "\\mkern2mu ";
          break;
        case 'commaDecimal':
          res = "{,}";
          break;
          case 'comma enumeration L':
          res = "{"+buf.p1+"}\\mkern6mu ";
          break;
        case 'comma enumeration M':
          res = "{"+buf.p1+"}\\mkern3mu ";
          break;
        case 'comma enumeration S':
          res = "{"+buf.p1+"}\\mkern1mu ";
          break;
        case 'hyphen':
          res = "\\text{-}";
          break;
        case 'addition compound':
          res = "\\,{\\cdot}\\,";
          break;
        case 'electron dot':
          res = "\\mkern1mu \\text{\\textbullet}\\mkern1mu ";
          break;
        case 'KV x':
          res = "{\\times}";
          break;
        case 'prime':
          res = "\\prime ";
          break;
        case 'cdot':
          res = "\\cdot ";
          break;
        case 'tight cdot':
          res = "\\mkern1mu{\\cdot}\\mkern1mu ";
          break;
        case 'times':
          res = "\\times ";
          break;
        case 'circa':
          res = "{\\sim}";
          break;
        case '^':
          res = "uparrow";
          break;
        case 'v':
          res = "downarrow";
          break;
        case 'ellipsis':
          res = "\\ldots ";
          break;
        case '/':
          res = "/";
          break;
        case ' / ':
          res = "\\,/\\,";
          break;
        default:
          assertNever(buf);
          throw ["MhchemBugT", "mhchem bug T. Please report."];  // Missing texify rule or unknown MhchemParser output
      }
      assertString(res);
      return res;
    },
    _getArrow: function (a) {
      switch (a) {
        case "->": return "\\yields";
        case "\u2192": return "\\yields";
        case "\u27F6": return "\\yields";
        case "<-": return "\\yieldsLeft";
        case "<->": return "\\mesomerism";
        case "<-->": return "\\yieldsLeftRight";
        case "<=>": return "\\equilibrium";
        case "\u21CC": return "\\equilibrium";
        case "<=>>": return "\\equilibriumRight";
        case "<<=>": return "\\equilibriumLeft";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getBond: function (a) {
      switch (a) {
        case "-": return "{-}";
        case "1": return "{-}";
        case "=": return "{=}";
        case "2": return "{=}";
        case "#": return "{\\equiv}";
        case "3": return "{\\equiv}";
        case "~": return "{\\tripleDash}";
        case "~-": return "{\\tripleDashOverLine}";
        case "~=": return "{\\tripleDashOverDoubleLine}";
        case "~--": return "{\\tripleDashOverDoubleLine}";
        case "-~-": return "{\\tripleDashBetweenDoubleLine}";
        case "...": return "{{\\cdot}{\\cdot}{\\cdot}}";
        case "....": return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
        case "->": return "{\\rightarrow}";
        case "<-": return "{\\leftarrow}";
        case "<": return "{<}";
        case ">": return "{>}";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getOperator: function (a) {
      switch (a) {
        case "+": return " {}+{} ";
        case "-": return " {}-{} ";
        case "=": return " {}={} ";
        case "<": return " {}<{} ";
        case ">": return " {}>{} ";
        case "<<": return " {}\\ll{} ";
        case ">>": return " {}\\gg{} ";
        case "\\pm": return " {}\\pm{} ";
        case "\\approx": return " {}\\approx{} ";
        case "$\\approx$": return " {}\\approx{} ";
        case "v": return " \\downarrow{} ";
        case "(v)": return " \\downarrow{} ";
        case "^": return " \\uparrow{} ";
        case "(^)": return " \\uparrow{} ";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    }
  };

  //
  // Helpers for code analysis
  // Will show type error at calling position
  //
  /** @param {number} a */
  function assertNever(a) {}
  /** @param {string} a */
  function assertString(a) {}

/* eslint-disable no-undef */

//////////////////////////////////////////////////////////////////////
// texvc.sty

// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax

// We also omit texvc's \O, which conflicts with \text{\O}

defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\bull", "\\bullet");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\isin", "\\in");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");

/* eslint-disable no-undef */

/****************************************************
 *
 *  physics.js
 *
 *  Implements the Physics Package for LaTeX input.
 *
 *  ---------------------------------------------------------------------
 *
 *  The original version of this file is licensed as follows:
 *  Copyright (c) 2015-2016 Kolen Cheung <https://github.com/ickc/MathJax-third-party-extensions>.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  ---------------------------------------------------------------------
 *
 *  This file has been revised from the original in the following ways:
 *  1. The interface is changed so that it can be called from Temml, not MathJax.
 *  2. \Re and \Im are not used, to avoid conflict with existing LaTeX letters.
 *
 *  This revision of the file is released under the MIT license.
 *  https://mit-license.org/
 */
defineMacro("\\quantity", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\qty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\pqty", "{\\left( #1 \\right)}");
defineMacro("\\bqty", "{\\left[ #1 \\right]}");
defineMacro("\\vqty", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\Bqty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\absolutevalue", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\abs", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\norm", "{\\left\\Vert #1 \\right\\Vert}");
defineMacro("\\evaluated", "{\\left.#1 \\right\\vert}");
defineMacro("\\eval", "{\\left.#1 \\right\\vert}");
defineMacro("\\order", "{\\mathcal{O} \\left( #1 \\right)}");
defineMacro("\\commutator", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\comm", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\anticommutator", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\acomm", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\poissonbracket", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\pb", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\vectorbold", "{\\boldsymbol{ #1 }}");
defineMacro("\\vb", "{\\boldsymbol{ #1 }}");
defineMacro("\\vectorarrow", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\va", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\vectorunit", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\vu", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\dotproduct", "\\mathbin{\\boldsymbol\\cdot}");
defineMacro("\\vdot", "{\\boldsymbol\\cdot}");
defineMacro("\\crossproduct", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cross", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cp", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\gradient", "{\\boldsymbol\\nabla}");
defineMacro("\\grad", "{\\boldsymbol\\nabla}");
defineMacro("\\divergence", "{\\grad\\vdot}");
//defineMacro("\\div", "{\\grad\\vdot}"); Not included in Temml. Conflicts w/LaTeX \div
defineMacro("\\curl", "{\\grad\\cross}");
defineMacro("\\laplacian", "\\nabla^2");
defineMacro("\\tr", "{\\operatorname{tr}}");
defineMacro("\\Tr", "{\\operatorname{Tr}}");
defineMacro("\\rank", "{\\operatorname{rank}}");
defineMacro("\\erf", "{\\operatorname{erf}}");
defineMacro("\\Res", "{\\operatorname{Res}}");
defineMacro("\\principalvalue", "{\\mathcal{P}}");
defineMacro("\\pv", "{\\mathcal{P}}");
defineMacro("\\PV", "{\\operatorname{P.V.}}");
// Temml does not use the next two lines. They conflict with LaTeX letters.
//defineMacro("\\Re", "{\\operatorname{Re} \\left\\{ #1 \\right\\}}");
//defineMacro("\\Im", "{\\operatorname{Im} \\left\\{ #1 \\right\\}}");
defineMacro("\\qqtext", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qq", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qcomma", "{\\text{,}\\quad}");
defineMacro("\\qc", "{\\text{,}\\quad}");
defineMacro("\\qcc", "{\\quad\\text{c.c.}\\quad}");
defineMacro("\\qif", "{\\quad\\text{if}\\quad}");
defineMacro("\\qthen", "{\\quad\\text{then}\\quad}");
defineMacro("\\qelse", "{\\quad\\text{else}\\quad}");
defineMacro("\\qotherwise", "{\\quad\\text{otherwise}\\quad}");
defineMacro("\\qunless", "{\\quad\\text{unless}\\quad}");
defineMacro("\\qgiven", "{\\quad\\text{given}\\quad}");
defineMacro("\\qusing", "{\\quad\\text{using}\\quad}");
defineMacro("\\qassume", "{\\quad\\text{assume}\\quad}");
defineMacro("\\qsince", "{\\quad\\text{since}\\quad}");
defineMacro("\\qlet", "{\\quad\\text{let}\\quad}");
defineMacro("\\qfor", "{\\quad\\text{for}\\quad}");
defineMacro("\\qall", "{\\quad\\text{all}\\quad}");
defineMacro("\\qeven", "{\\quad\\text{even}\\quad}");
defineMacro("\\qodd", "{\\quad\\text{odd}\\quad}");
defineMacro("\\qinteger", "{\\quad\\text{integer}\\quad}");
defineMacro("\\qand", "{\\quad\\text{and}\\quad}");
defineMacro("\\qor", "{\\quad\\text{or}\\quad}");
defineMacro("\\qas", "{\\quad\\text{as}\\quad}");
defineMacro("\\qin", "{\\quad\\text{in}\\quad}");
defineMacro("\\differential", "{\\text{d}}");
defineMacro("\\dd", "{\\text{d}}");
defineMacro("\\derivative", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\dv", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\partialderivative", "{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}");
defineMacro("\\variation", "{\\delta}");
defineMacro("\\var", "{\\delta}");
defineMacro("\\functionalderivative", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\fdv", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\innerproduct", "{\\left\\langle {#1} \\mid { #2} \\right\\rangle}");
defineMacro("\\outerproduct",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\dyad",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\ketbra",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\op",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\expectationvalue", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\expval", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\ev", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\matrixelement",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\matrixel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\mel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");

// Helper functions
function getHLines(parser) {
  // Return an array. The array length = number of hlines.
  // Each element in the array tells if the line is dashed.
  const hlineInfo = [];
  parser.consumeSpaces();
  let nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}

const validateAmsEnvironmentContext = context => {
  const settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError(`{${context.envName}} can be used only in display mode.`);
  }
};

const sizeRegEx$1 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const arrayGaps = macros => {
  let arraystretch = macros.get("\\arraystretch");
  if (typeof arraystretch !== "string") {
    arraystretch = stringFromArg(arraystretch.tokens);
  }
  arraystretch = isNaN(arraystretch) ? null : Number(arraystretch);
  let arraycolsepStr = macros.get("\\arraycolsep");
  if (typeof arraycolsepStr !== "string") {
    arraycolsepStr = stringFromArg(arraycolsepStr.tokens);
  }
  const match = sizeRegEx$1.exec(arraycolsepStr);
  const arraycolsep = match
    ? { number: +(match[1] + match[2]), unit: match[3] }
    : null;
  return [arraystretch, arraycolsep]
};

const checkCellForLabels = cell => {
  // Check if the author wrote a \tag{} inside this cell.
  let rowLabel = "";
  for (let i = 0; i < cell.length; i++) {
    if (cell[i].type === "label") {
      if (rowLabel) { throw new ParseError(("Multiple \\labels in one row")) }
      rowLabel = cell[i].string;
    }
  }
  return rowLabel
};

// autoTag (an argument to parseArray) can be one of three values:
// * undefined: Regular (not-top-level) array; no tags on each row
// * true: Automatic equation numbering, overridable by \tag
// * false: Tags allowed on each row, but no automatic numbering
// This function *doesn't* work with the "split" environment name.
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
  // return undefined;
}

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument scriptLevel
 * ("text", "display", etc.), then each cell is cast into that scriptLevel.
 */
function parseArray(
  parser,
  {
    cols, // [{ type: string , align: l|c|r|null }]
    envClasses, // align(ed|at|edat) | array | cases | cd | small | multline
    autoTag,        // boolean
    singleRow,      // boolean
    emptySingleRow, // boolean
    maxNumCols,     // number
    leqno,          // boolean
    arraystretch,   // number  | null
    arraycolsep     // size value | null
},
  scriptLevel
) {
  const endToken = envClasses && envClasses.includes("bordermatrix") ? "}" : "\\end";
  parser.gullet.beginGroup();
  if (!singleRow) {
    // \cr is equivalent to \\ without the optional size argument (see below)
    // TODO: provide helpful error when \cr is used outside array environment
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }

  // Start group for first cell
  parser.gullet.beginGroup();

  let row = [];
  const body = [row];
  const rowGaps = [];
  const labels = [];

  const hLinesBeforeRow = [];

  const tags = (autoTag != null ? [] : undefined);

  // amsmath uses \global\@eqnswtrue and \global\@eqnswfalse to represent
  // whether this row should have an equation number.  Simulate this with
  // a \@eqnsw macro set to 1 or 0.
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", undefined, true);
      } else {
        tags.push(Boolean(autoTag) &&
            parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();

  // Test for \hline at the top of the array.
  hLinesBeforeRow.push(getHLines(parser));

  while (true) {
    // Parse each cell in its own group (namespace)
    let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();

    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell,
      semisimple: true
    };
    row.push(cell);
    const next = parser.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (envClasses.includes("array")) {
          if (parser.settings.strict) {
            throw new ParseError("Too few columns " + "specified in the {array} column argument.",
              parser.nextToken)
          }
        } else if (maxNumCols === 2) {
          throw new ParseError("The split environment accepts no more than two columns",
            parser.nextToken);
        } else {
          throw new ParseError("The equation environment accepts only one column",
            parser.nextToken)
        }
      }
      parser.consume();
    } else if (next === endToken) {
      endRow();
      // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
      // the last line is empty.  However, AMS environments keep the
      // empty row if it's the only one.
      // NOTE: Currently, `cell` is the last item added into `row`.
      if (row.length === 1 && cell.body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      labels.push(checkCellForLabels(cell.body));
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser.consume();
      let size;
      // \def\Let@{\let\\\math@cr}
      // \def\math@cr{...\math@cr@}
      // \def\math@cr@{\new@ifnextchar[\math@cr@@{\math@cr@@[\z@]}}
      // \def\math@cr@@[#1]{...\math@cr@@@...}
      // \def\math@cr@@@{\cr}
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();

      labels.push(checkCellForLabels(cell.body));

      // check for \hline(s) following the row separator
      hLinesBeforeRow.push(getHLines(parser));

      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or " + endToken, parser.nextToken);
    }
  }

  // End cell group
  parser.gullet.endGroup();
  // End array group defining \cr
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: parser.mode,
    body,
    cols,
    rowGaps,
    hLinesBeforeRow,
    envClasses,
    autoTag,
    scriptLevel,
    tags,
    labels,
    leqno,
    arraystretch,
    arraycolsep
  };
}

// Decides on a scriptLevel for cells in an array according to whether the given
// environment name starts with the letter 'd'.
function dCellStyle(envName) {
  return envName.slice(0, 1) === "d" ? "display" : "text"
}

const alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};

const glue = group => {
  const glueNode = new mathMLTree.MathNode("mtd", []);
  glueNode.style = { padding: "0", width: "50%" };
  if (group.envClasses.includes("multline")) {
    glueNode.style.width = "7.5%";
  }
  return glueNode
};

const mathmlBuilder$9 = function(group, style) {
  const tbl = [];
  const numRows = group.body.length;
  const hlines = group.hLinesBeforeRow;

  for (let i = 0; i < numRows; i++) {
    const rw = group.body[i];
    const row = [];
    const cellLevel = group.scriptLevel === "text"
      ? StyleLevel.TEXT
      : group.scriptLevel === "script"
      ? StyleLevel.SCRIPT
      : StyleLevel.DISPLAY;

    for (let j = 0; j < rw.length; j++) {
      const mtd = new mathMLTree.MathNode(
        "mtd",
        [buildGroup$1(rw[j], style.withLevel(cellLevel))]
      );

      if (group.envClasses.includes("multline")) {
        const align = i === 0 ? "left" : i === numRows - 1 ? "right" : "center";
        mtd.setAttribute("columnalign", align);
        if (align !== "center") {
          mtd.classes.push("tml-" + align);
        }
      }
      row.push(mtd);
    }
    const numColumns = group.body[0].length;
    // Fill out a short row with empty <mtd> elements.
    for (let k = 0; k < numColumns - rw.length; k++) {
      row.push(new mathMLTree.MathNode("mtd", [], style));
    }
    if (group.autoTag) {
      const tag = group.tags[i];
      let tagElement;
      if (tag === true) {  // automatic numbering
        tagElement = new mathMLTree.MathNode("mtext", [new Span(["tml-eqn"])]);
      } else if (tag === false) {
        // \nonumber/\notag or starred environment
        tagElement = new mathMLTree.MathNode("mtext", [], []);
      } else {  // manual \tag
        tagElement = buildExpressionRow(tag[0].body, style.withLevel(cellLevel), true);
        tagElement = consolidateText(tagElement);
        tagElement.classes = ["tml-tag"];
      }
      if (tagElement) {
        row.unshift(glue(group));
        row.push(glue(group));
        if (group.leqno) {
          row[0].children.push(tagElement);
          row[0].classes.push("tml-left");
        } else {
          row[row.length - 1].children.push(tagElement);
          row[row.length - 1].classes.push("tml-right");
        }
      }
    }
    const mtr = new mathMLTree.MathNode("mtr", row, []);
    const label = group.labels.shift();
    if (label && group.tags && group.tags[i]) {
      mtr.setAttribute("id", label);
      if (Array.isArray(group.tags[i])) { mtr.classes.push("tml-tageqn"); }
    }

    // Write horizontal rules
    if (i === 0 && hlines[0].length > 0) {
      if (hlines[0].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderTop = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderTop = hlines[0][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }
    if (hlines[i + 1].length > 0) {
      if (hlines[i + 1].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderBottom = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderBottom = hlines[i + 1][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }

    // Check for \hphantom \from \bordermatrix
    let mustSquashRow = true;
    for (let j = 0; j < mtr.children.length; j++) {
      const child = mtr.children[j].children[0];
      if (!(child && child.type === "mpadded" && child.attributes.height === "0px")) {
        mustSquashRow = false;
        break
      }
    }
    if (mustSquashRow) {
      // All the cell contents are \hphantom. Squash the padding.
      for (let j = 0; j < mtr.children.length; j++) {
        mtr.children[j].style.paddingTop = "0";
        mtr.children[j].style.paddingBottom = "0";
      }
    }

    tbl.push(mtr);
  }

  if (group.arraystretch && group.arraystretch !== 1) {
    // In LaTeX, \arraystretch is a factor applied to a 12pt strut height.
    // It defines a baseline to baseline distance.
    // Here, we do an approximation of that approach.
    const pad = String(1.4 * group.arraystretch - 0.8) + "ex";
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingTop = pad;
        tbl[i].children[j].style.paddingBottom = pad;
      }
    }
  }

  let sidePadding;
  let sidePadUnit;
  if (group.envClasses.length > 0) {
    sidePadding = group.envClasses.includes("abut")
      ? "0"
      : group.envClasses.includes("cases")
      ? "0"
      : group.envClasses.includes("small")
      ? "0.1389"
      : group.envClasses.includes("cd")
      ? "0.25"
      : "0.4"; // default side padding
    sidePadUnit = "em";
  }
  if (group.arraycolsep) {
    const arraySidePad = calculateSize(group.arraycolsep, style);
    sidePadding = arraySidePad.number.toFixed(4);
    sidePadUnit = arraySidePad.unit;
  }
  if (sidePadding) {
    const numCols = tbl.length === 0 ? 0 : tbl[0].children.length;

    const sidePad = (j, hand) => {
      if (j === 0 && hand === 0) { return "0" }
      if (j === numCols - 1 && hand === 1) { return "0" }
      if (group.envClasses[0] !== "align") { return sidePadding }
      if (hand === 1) { return "0" }
      if (group.autoTag) {
        return (j % 2) ? "1" : "0"
      } else {
        return (j % 2) ? "0" : "1"
      }
    };

    // Side padding
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingLeft = `${sidePad(j, 0)}${sidePadUnit}`;
        tbl[i].children[j].style.paddingRight = `${sidePad(j, 1)}${sidePadUnit}`;
      }
    }
  }
  if (group.envClasses.length === 0) {
    // Set zero padding on side of the matrix
    for (let i = 0; i < tbl.length; i++) {
      tbl[i].children[0].style.paddingLeft = "0em";
      if (tbl[i].children.length === tbl[0].children.length) {
        tbl[i].children[tbl[i].children.length - 1].style.paddingRight = "0em";
      }
    }
  }

  if (group.envClasses.length > 0) {
    // Justification
    const align = group.envClasses.includes("align") || group.envClasses.includes("alignat");
    for (let i = 0; i < tbl.length; i++) {
      const row = tbl[i];
      if (align) {
        for (let j = 0; j < row.children.length; j++) {
          // Chromium does not recognize text-align: left. Use -webkit-
          // TODO: Remove -webkit- when Chromium no longer needs it.
          row.children[j].classes = ["tml-" + (j % 2 ? "left" : "right")];
        }
        if (group.autoTag) {
          const k = group.leqno ? 0 : row.children.length - 1;
          row.children[k].classes = ["tml-" + (group.leqno ? "left" : "right")];
        }
      }
      if (row.children.length > 1 && group.envClasses.includes("cases")) {
        row.children[1].style.paddingLeft = "1em";
      }

      if (group.envClasses.includes("cases") || group.envClasses.includes("subarray")) {
        for (const cell of row.children) {
          cell.classes.push("tml-left");
        }
      }
    }
  }

  let table = new mathMLTree.MathNode("mtable", tbl);
  if (group.envClasses.length > 0) {
    // Top & bottom padding
    if (group.envClasses.includes("jot")) {
      table.classes.push("tml-jot");
    } else if (group.envClasses.includes("small")) {
      table.classes.push("tml-small");
    }
  }
  if (group.scriptLevel === "display") { table.setAttribute("displaystyle", "true"); }

  if (group.autoTag || group.envClasses.includes("multline")) {
    table.style.width = "100%";
  }

  // Column separator lines and column alignment
  let align = "";

  if (group.cols && group.cols.length > 0) {
    const cols = group.cols;
    let prevTypeWasAlign = false;
    let iStart = 0;
    let iEnd = cols.length;

    while (cols[iStart].type === "separator") {
      iStart += 1;
    }
    while (cols[iEnd - 1].type === "separator") {
      iEnd -= 1;
    }

    if (cols[0].type === "separator") {
      const sep = cols[1].type === "separator"
        ? "0.15em double"
        : cols[0].separator === "|"
        ? "0.06em solid "
        : "0.06em dashed ";
      for (const row of table.children) {
        row.children[0].style.borderLeft = sep;
      }
    }
    let iCol = group.autoTag ? 0 : -1;
    for (let i = iStart; i < iEnd; i++) {
      if (cols[i].type === "align") {
        const colAlign = alignMap[cols[i].align];
        align += colAlign;
        iCol += 1;
        for (const row of table.children) {
          if (colAlign.trim() !== "center" && iCol < row.children.length) {
            row.children[iCol].classes = ["tml-" + colAlign.trim()];
          }
        }
        prevTypeWasAlign = true;
      } else if (cols[i].type === "separator") {
        // MathML accepts only single lines between cells.
        // So we read only the first of consecutive separators.
        if (prevTypeWasAlign) {
          const sep = cols[i + 1].type === "separator"
            ? "0.15em double"
            : cols[i].separator === "|"
            ? "0.06em solid"
            : "0.06em dashed";
          for (const row of table.children) {
            if (iCol < row.children.length) {
              row.children[iCol].style.borderRight = sep;
            }
          }
        }
        prevTypeWasAlign = false;
      }
    }
    if (cols[cols.length - 1].type === "separator") {
      const sep = cols[cols.length - 2].type === "separator"
        ? "0.15em double"
        : cols[cols.length - 1].separator === "|"
        ? "0.06em solid"
        : "0.06em dashed";
      for (const row of table.children) {
        row.children[row.children.length - 1].style.borderRight = sep;
        row.children[row.children.length - 1].style.paddingRight = "0.4em";
      }
    }
  }
  if (group.autoTag) {
     // allow for glue cells on each side
    align = "left " + (align.length > 0 ? align : "center ") + "right ";
  }
  if (align) {
    // Firefox reads this attribute, not the -webkit-left|right written above.
    // TODO: When Chrome no longer needs "-webkit-", use CSS and delete the next line.
    table.setAttribute("columnalign", align.trim());
  }

  if (group.envClasses.includes("small")) {
    // A small array. Wrap in scriptstyle.
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }

  return table
};

// Convenience function for align, align*, aligned, alignat, alignat*, alignedat, split.
const alignedHandler = function(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  const isSplit = context.envName === "split";
  const cols = [];
  const res = parseArray(
    context.parser,
    {
      cols,
      emptySingleRow: true,
      autoTag: isSplit ? undefined : getAutoTag(context.envName),
      envClasses: ["abut", "jot"], // set row spacing & provisional column spacing
      maxNumCols: context.envName === "split" ? 2 : undefined,
      leqno: context.parser.settings.leqno
    },
    "display"
  );

  // Determining number of columns.
  // 1. If the first argument is given, we use it as a number of columns,
  //    and makes sure that each row doesn't exceed that number.
  // 2. Otherwise, just count number of columns = maximum number
  //    of cells in each row ("aligned" mode -- isAligned will be true).
  //
  // At the same time, prepend empty group {} at beginning of every second
  // cell in each row (starting with second cell) so that operators become
  // binary.  This behavior is implemented in amsmath's \start@aligned.
  let numMaths;
  let numCols = 0;
  const isAlignedAt = context.envName.indexOf("at") > -1;
  if (args[0] && isAlignedAt) {
    // alignat environment takes an argument w/ number of columns
    let arg0 = "";
    for (let i = 0; i < args[0].body.length; i++) {
      const textord = assertNodeType(args[0].body[i], "textord");
      arg0 += textord.text;
    }
    if (isNaN(arg0)) {
      throw new ParseError("The alignat enviroment requires a numeric first argument.")
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  res.body.forEach(function(row) {
    if (isAlignedAt) {
      // Case 1
      const curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError(
          "Too many math in a row: " + `expected ${numMaths}, but got ${curMaths}`,
          row[0]
        );
      }
    } else if (numCols < row.length) {
      // Case 2
      numCols = row.length;
    }
  });

  // Adjusting alignment.
  // In aligned mode, we add one \qquad between columns;
  // otherwise we add nothing.
  for (let i = 0; i < numCols; ++i) {
    let align = "r";
    if (i % 2 === 1) {
      align = "l";
    }
    cols[i] = {
      type: "align",
      align: align
    };
  }
  if (context.envName === "split") ; else if (isAlignedAt) {
    res.envClasses.push("alignat"); // Sets justification
  } else {
    res.envClasses[0] = "align"; // Sets column spacing & justification
  }
  return res;
};

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    const res = {
      cols,
      envClasses: ["array"],
      maxNumCols: cols.length,
      arraystretch,
      arraycolsep
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  mathmlBuilder: mathmlBuilder$9
});

// The matrix environments of amsmath build on the array environment
// of LaTeX, which is discussed above.
// The mathtools package adds starred versions of the same environments.
// These have an optional argument to choose left|center|right justification.
defineEnvironment({
  type: "array",
  names: [
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix",
    "matrix*",
    "pmatrix*",
    "bmatrix*",
    "Bmatrix*",
    "vmatrix*",
    "Vmatrix*"
  ],
  props: {
    numArgs: 0
  },
  handler(context) {
    const delimiters = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    // \hskip -\arraycolsep in amsmath
    let colAlign = "c";
    const payload = {
      envClasses: [],
      cols: []
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      // It's one of the mathtools starred functions.
      // Parse the optional alignment argument.
      const parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [];
      }
    }
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: colAlign });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    res.arraystretch = arraystretch;
    if (arraycolsep && !(arraycolsep === 6 && arraycolsep === "pt")) {
      res.arraycolsep = arraycolsep;
    }
    return delimiters
      ? {
        type: "leftright",
        mode: context.mode,
        body: [res],
        left: delimiters[0],
        right: delimiters[1],
        rightColor: undefined // \right uninfluenced by \color in array
      }
      : res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["bordermatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { cols: [], envClasses: ["bordermatrix"] };
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: "c" });
    res.envClasses = [];
    res.arraystretch = 1;
    if (context.envName === "matrix") { return res}
    return bordermatrixParseTree(res, context.delimiters)
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { type: "small" };
    const res = parseArray(context.parser, payload, "script");
    res.envClasses = ["small"];
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Parsing of {subarray} is similar to {array}
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      // {subarray} only recognizes "l" & "c"
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    let res = {
      cols,
      envClasses: ["small"]
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def
// \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.
// {rcases} is another mathtools environment. It's brace is on the right side.
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = {
      cols: [],
      envClasses: ["cases"]
    };
    const res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: undefined
    };
  },
  mathmlBuilder: mathmlBuilder$9
});

// In the align environment, one uses ampersands, &, to specify number of
// columns in each row, and to locate spacing between each column.
// align gets automatic numbering. align* and aligned do not.
// The alignedat environment can be used in math mode.
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust where spacing occurs.
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (context.envName !== "gathered") {
      validateAmsEnvironmentContext(context);
    }
    const res = {
      cols: [],
      envClasses: ["abut", "jot"],
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      envClasses: ["align"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["multline", "multline*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: context.envName === "multline",
      maxNumCols: 1,
      envClasses: ["jot", "multline"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  mathmlBuilder: mathmlBuilder$9
});

// Catch \hline outside array environment
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(`${context.funcName} valid only within array environment`);
  }
});

const environments = _environments;

// \bordermatrix  from TeXbook pp 177 & 361
// Optional argument from Herbert Voß, Math mode, p 20
// Ref: https://tug.ctan.org/obsolete/info/math/voss/mathmode/Mathmode.pdf

defineFunction({
  type: "bordermatrix",
  names: ["\\bordermatrix", "\\matrix"],
  props: {
    numArgs: 0,
    numOptionalArgs: 1
  },
  handler: ({ parser, funcName }, args, optArgs) => {
    // Find out if the author has defined custom delimiters
    let delimiters = ["(", ")"];
    if (funcName === "\\bordermatrix" && optArgs[0] && optArgs[0].body) {
      const body = optArgs[0].body;
      if (body.length === 2 && body[0].type === "atom" && body[1].type === "atom") {
        if (body[0].family === "open" && body[1].family === "close") {
          delimiters = [body[0].text, body[1].text];
        }
      }
    }
    // consume the opening brace
    parser.consumeSpaces();
    parser.consume();

    // Pass control to the environment handler in array.js.
    const env = environments["bordermatrix"];
    const context = {
      mode: parser.mode,
      envName: funcName.slice(1),
      delimiters,
      parser
    };
    const result = env.handler(context);
    parser.expect("}", true);
    return result
  }
});

// \@char is an internal function that takes a grouped decimal argument like
// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, token }, args) {
    const arg = assertNodeType(args[0], "ordgroup");
    const group = arg.body;
    let number = "";
    for (let i = 0; i < group.length; i++) {
      const node = assertNodeType(group[i], "textord");
      number += node.text;
    }
    const code = parseInt(number);
    if (isNaN(code)) {
      throw new ParseError(`\\@char has non-numeric argument ${number}`, token)
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: String.fromCodePoint(code)
    }
  }
});

// Helpers
const htmlRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6})$/i;
const htmlOrNameRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i;
const RGBregEx = /^ *\d{1,3} *(?:, *\d{1,3} *){2}$/;
const rgbRegEx = /^ *[10](?:\.\d*)? *(?:, *[10](?:\.\d*)? *){2}$/;
const xcolorHtmlRegEx = /^[a-f0-9]{6}$/i;
const toHex = num => {
  let str = num.toString(16);
  if (str.length === 1) { str = "0" + str; }
  return str
};

// Colors from Tables 4.1 and 4.2 of the xcolor package.
// Table 4.1 (lower case) RGB values are taken from chroma and xcolor.dtx.
// Table 4.2 (Capitalizzed) values were sampled, because Chroma contains a unreliable
// conversion from cmyk to RGB. See https://tex.stackexchange.com/a/537274.
const xcolors = JSON.parse(`{
  "Apricot": "#ffb484",
  "Aquamarine": "#08b4bc",
  "Bittersweet": "#c84c14",
  "blue": "#0000FF",
  "Blue": "#303494",
  "BlueGreen": "#08b4bc",
  "BlueViolet": "#503c94",
  "BrickRed": "#b8341c",
  "brown": "#BF8040",
  "Brown": "#802404",
  "BurntOrange": "#f8941c",
  "CadetBlue": "#78749c",
  "CarnationPink": "#f884b4",
  "Cerulean": "#08a4e4",
  "CornflowerBlue": "#40ace4",
  "cyan": "#00FFFF",
  "Cyan": "#08acec",
  "Dandelion": "#ffbc44",
  "darkgray": "#404040",
  "DarkOrchid": "#a8548c",
  "Emerald": "#08ac9c",
  "ForestGreen": "#089c54",
  "Fuchsia": "#90348c",
  "Goldenrod": "#ffdc44",
  "gray": "#808080",
  "Gray": "#98949c",
  "green": "#00FF00",
  "Green": "#08a44c",
  "GreenYellow": "#e0e474",
  "JungleGreen": "#08ac9c",
  "Lavender": "#f89cc4",
  "lightgray": "#c0c0c0",
  "lime": "#BFFF00",
  "LimeGreen": "#90c43c",
  "magenta": "#FF00FF",
  "Magenta": "#f0048c",
  "Mahogany": "#b0341c",
  "Maroon": "#b03434",
  "Melon": "#f89c7c",
  "MidnightBlue": "#086494",
  "Mulberry": "#b03c94",
  "NavyBlue": "#086cbc",
  "olive": "#7F7F00",
  "OliveGreen": "#407c34",
  "orange": "#FF8000",
  "Orange": "#f8843c",
  "OrangeRed": "#f0145c",
  "Orchid": "#b074ac",
  "Peach": "#f8945c",
  "Periwinkle": "#8074bc",
  "PineGreen": "#088c74",
  "pink": "#ff7f7f",
  "Plum": "#98248c",
  "ProcessBlue": "#08b4ec",
  "purple": "#BF0040",
  "Purple": "#a0449c",
  "RawSienna": "#983c04",
  "red": "#ff0000",
  "Red": "#f01c24",
  "RedOrange": "#f86434",
  "RedViolet": "#a0246c",
  "Rhodamine": "#f0549c",
  "Royallue": "#0874bc",
  "RoyalPurple": "#683c9c",
  "RubineRed": "#f0047c",
  "Salmon": "#f8948c",
  "SeaGreen": "#30bc9c",
  "Sepia": "#701404",
  "SkyBlue": "#48c4dc",
  "SpringGreen": "#c8dc64",
  "Tan": "#e09c74",
  "teal": "#007F7F",
  "TealBlue": "#08acb4",
  "Thistle": "#d884b4",
  "Turquoise": "#08b4cc",
  "violet": "#800080",
  "Violet": "#60449c",
  "VioletRed": "#f054a4",
  "WildStrawberry": "#f0246c",
  "yellow": "#FFFF00",
  "Yellow": "#fff404",
  "YellowGreen": "#98cc6c",
  "YellowOrange": "#ffa41c"
}`);

const colorFromSpec = (model, spec) => {
  let color = "";
  if (model === "HTML") {
    if (!htmlRegEx.test(spec)) {
      throw new ParseError("Invalid HTML input.")
    }
    color = spec;
  } else if (model === "RGB") {
    if (!RGBregEx.test(spec)) {
      throw new ParseError("Invalid RGB input.")
    }
    spec.split(",").map(e => { color += toHex(Number(e.trim())); });
  } else {
    if (!rgbRegEx.test(spec)) {
      throw new ParseError("Invalid rbg input.")
    }
    spec.split(",").map(e => {
      const num = Number(e.trim());
      if (num > 1) { throw new ParseError("Color rgb input must be < 1.") }
      color += toHex(Number((num * 255).toFixed(0)));
    });
  }
  if (color.charAt(0) !== "#") { color = "#" + color; }
  return color
};

const validateColor = (color, macros, token) => {
  const macroName = `\\\\color@${color}`; // from \defineColor.
  const match = htmlOrNameRegEx.exec(color);
  if (!match) { throw new ParseError("Invalid color: '" + color + "'", token) }
  // We allow a 6-digit HTML color spec without a leading "#".
  // This follows the xcolor package's HTML color model.
  // Predefined color names are all missed by this RegEx pattern.
  if (xcolorHtmlRegEx.test(color)) {
    return "#" + color
  } else if (color.charAt(0) === "#") {
    return color
  } else if (macros.has(macroName)) {
    color = macros.get(macroName).tokens[0].text;
  } else if (xcolors[color]) {
    color = xcolors[color];
  }
  return color
};

const mathmlBuilder$8 = (group, style) => {
  // In LaTeX, color is not supposed to change the spacing of any node.
  // So instead of wrapping the group in an <mstyle>, we apply
  // the color individually to each node and return a document fragment.
  let expr = buildExpression(group.body, style.withColor(group.color));
  expr = expr.map(e => {
    e.style.color = group.color;
    return e
  });
  return mathMLTree.newDocumentFragment(expr)
};

defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "original"]
  },
  handler({ parser, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }
    const body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: true,
      body: ordargument(body)
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw"]
  },
  handler({ parser, breakOnTokenText, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }

    // Parse out the implicit body that should be colored.
    const body = parser.parseExpression(true, breakOnTokenText, true);

    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: false,
      body
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\definecolor"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw"]
  },
  handler({ parser, funcName, token }, args) {
    const name = assertNodeType(args[0], "raw").string;
    if (!/^[A-Za-z]+$/.test(name)) {
      throw new ParseError("Color name must be latin letters.", token)
    }
    const model = assertNodeType(args[1], "raw").string;
    if (!["HTML", "RGB", "rgb"].includes(model)) {
      throw new ParseError("Color model must be HTML, RGB, or rgb.", token)
    }
    const spec = assertNodeType(args[2], "raw").string;
    const color = colorFromSpec(model, spec);
    parser.gullet.macros.set(`\\\\color@${name}`, { tokens: [{ text: color }], numArgs: 0 });
    return { type: "internal", mode: parser.mode }
  }
  // No mathmlBuilder. The point of \definecolor is to set a macro.
});

// Row breaks within tabular environments, and line breaks at top level


// \DeclareRobustCommand\\{...\@xnewline}
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },

  handler({ parser }, args, optArgs) {
    const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    const newLine = !parser.settings.displayMode;
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    }
  },

  // The following builder is called only at the top level,
  // not within tabular/array environments.

  mathmlBuilder(group, style) {
    // MathML 3.0 calls for newline to occur in an <mo> or an <mspace>.
    // Ref: https://www.w3.org/TR/MathML3/chapter3.html#presm.linebreaking
    const node = new mathMLTree.MathNode("mo");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        const size = calculateSize(group.size, style);
        node.setAttribute("height", size.number + size.unit);
      }
    }
    return node
  }
});

const globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};

const checkControlSequence = (tok) => {
  const name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};

const getRHS = (parser) => {
  let tok = parser.gullet.popToken();
  if (tok.text === "=") {
    // consume optional equals
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      // consume one optional space
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};

const letCommand = (parser, name, tok, global) => {
  let macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    // don't expand it later even if a macro with the same name is defined
    // e.g., \let\foo=\frac \def\frac{\relax} \frac12
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global);
};

// <assignment> -> <non-macro assignment>|<macro assignment>
// <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
// <macro assignment> -> <definition>|<prefix><macro assignment>
// <prefix> -> \global|\long|\outer
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser, funcName }) {
    parser.consumeSpaces();
    const token = parser.fetch();
    if (globalMap[token.text]) {
      // Temml doesn't have \par, so ignore \long
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError(`Invalid token after macro prefix`, token);
  }
});

// Basic support for macro definitions: \def, \gdef, \edef, \xdef
// <definition> -> <def><control sequence><definition text>
// <def> -> \def|\gdef|\edef|\xdef
// <definition text> -> <parameter text><left brace><balanced text><right brace>
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let tok = parser.gullet.popToken();
    const name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }

    let numArgs = 0;
    let insert;
    const delimiters = [[]];
    // <parameter text> contains no braces
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        // If the very last character of the <parameter text> is #, so that
        // this # is immediately followed by {, TeX will behave as if the {
        // had been inserted at the right end of both the parameter text
        // and the replacement text.
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters[numArgs].push("{");
          break;
        }

        // A parameter, the first appearance of # must be followed by 1,
        // the next by 2, and so on; up to nine #’s are allowed
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError(`Invalid argument number "${tok.text}"`);
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError(`Argument number "${tok.text}" out of order`);
        }
        numArgs++;
        delimiters.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters[numArgs].push(tok.text);
      }
    }
    // replacement text, enclosed in '{' and '}' and properly nested
    let { tokens } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }

    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      if (tokens.length > parser.gullet.settings.maxExpand) {
        throw new ParseError("Too many expansions in an " + funcName);
      }
      tokens.reverse(); // to fit in with stack order
    }
    // Final arg is the expansion of the macro
    parser.gullet.macros.set(
      name,
      { tokens, numArgs, delimiters },
      funcName === globalMap[funcName]
    );
    return { type: "internal", mode: parser.mode };
  }
});

// <simple assignment> -> <let assignment>
// <let assignment> -> \futurelet<control sequence><token><token>
//     | \let<control sequence><equals><one optional space><token>
// <equals> -> <optional spaces>|<optional spaces>=
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    const tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return { type: "internal", mode: parser.mode };
  }
});

// ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    const middle = parser.gullet.popToken();
    const tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return { type: "internal", mode: parser.mode };
  }
});

defineFunction({
  type: "internal",
  names: ["\\newcommand", "\\renewcommand", "\\providecommand"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let name = "";
    const tok = parser.gullet.popToken();
    if (tok.text === "{") {
      name = checkControlSequence(parser.gullet.popToken());
      parser.gullet.popToken();
    } else {
      name = checkControlSequence(tok);
    }

    const exists = parser.gullet.isDefined(name);
    if (exists && funcName === "\\newcommand") {
      throw new ParseError(
        `\\newcommand{${name}} attempting to redefine ${name}; use \\renewcommand`
      );
    }
    if (!exists && funcName === "\\renewcommand") {
      throw new ParseError(
        `\\renewcommand{${name}} when command ${name} does not yet exist; use \\newcommand`
      );
    }

    let numArgs = 0;
    if (parser.gullet.future().text === "[") {
      let tok = parser.gullet.popToken();
      tok = parser.gullet.popToken();
      if (!/^[0-9]$/.test(tok.text)) {
        throw new ParseError(`Invalid number of arguments: "${tok.text}"`);
      }
      numArgs = parseInt(tok.text);
      tok = parser.gullet.popToken();
      if (tok.text !== "]") {
        throw new ParseError(`Invalid argument "${tok.text}"`);
      }
    }

    // replacement text, enclosed in '{' and '}' and properly nested
    const { tokens } = parser.gullet.consumeArg();

    if (!(funcName === "\\providecommand" && parser.gullet.macros.has(name))) {
      // Ignore \providecommand
      parser.gullet.macros.set(
        name,
        { tokens, numArgs }
      );
    }

    return { type: "internal", mode: parser.mode };

  }
});

// Extra data needed for the delimiter handler down below
const delimiterSizes = {
  "\\bigl": { mclass: "mopen", size: 1 },
  "\\Bigl": { mclass: "mopen", size: 2 },
  "\\biggl": { mclass: "mopen", size: 3 },
  "\\Biggl": { mclass: "mopen", size: 4 },
  "\\bigr": { mclass: "mclose", size: 1 },
  "\\Bigr": { mclass: "mclose", size: 2 },
  "\\biggr": { mclass: "mclose", size: 3 },
  "\\Biggr": { mclass: "mclose", size: 4 },
  "\\bigm": { mclass: "mrel", size: 1 },
  "\\Bigm": { mclass: "mrel", size: 2 },
  "\\biggm": { mclass: "mrel", size: 3 },
  "\\Biggm": { mclass: "mrel", size: 4 },
  "\\big": { mclass: "mord", size: 1 },
  "\\Big": { mclass: "mord", size: 2 },
  "\\bigg": { mclass: "mord", size: 3 },
  "\\Bigg": { mclass: "mord", size: 4 }
};

const delimiters = [
  "(",
  "\\lparen",
  ")",
  "\\rparen",
  "[",
  "\\lbrack",
  "]",
  "\\rbrack",
  "\\{",
  "\\lbrace",
  "\\}",
  "\\rbrace",
  "⦇",
  "\\llparenthesis",
  "⦈",
  "\\rrparenthesis",
  "\\lfloor",
  "\\rfloor",
  "\u230a",
  "\u230b",
  "\\lceil",
  "\\rceil",
  "\u2308",
  "\u2309",
  "<",
  ">",
  "\\langle",
  "\u27e8",
  "\\rangle",
  "\u27e9",
  "\\lAngle",
  "\u27ea",
  "\\rAngle",
  "\u27eb",
  "\\llangle",
  "⦉",
  "\\rrangle",
  "⦊",
  "\\lt",
  "\\gt",
  "\\lvert",
  "\\rvert",
  "\\lVert",
  "\\rVert",
  "\\lgroup",
  "\\rgroup",
  "\u27ee",
  "\u27ef",
  "\\lmoustache",
  "\\rmoustache",
  "\u23b0",
  "\u23b1",
  "\\llbracket",
  "\\rrbracket",
  "\u27e6",
  "\u27e6",
  "\\lBrace",
  "\\rBrace",
  "\u2983",
  "\u2984",
  "/",
  "\\backslash",
  "|",
  "\\vert",
  "\\|",
  "\\Vert",
  "\u2016",
  "\\uparrow",
  "\\Uparrow",
  "\\downarrow",
  "\\Downarrow",
  "\\updownarrow",
  "\\Updownarrow",
  "."
];

// Export isDelimiter for benefit of parser.
const dels = ["}", "\\left", "\\middle", "\\right"];
const isDelimiter = str => str.length > 0 &&
  (delimiters.includes(str) || delimiterSizes[str] || dels.includes(str));

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

// Delimiter functions
function checkDelimiter(delim, context) {
  const symDelim = checkSymbolNodeType(delim);
  if (symDelim && delimiters.includes(symDelim.text)) {
    // If a character is not in the MathML operator dictionary, it will not stretch.
    // Replace such characters w/characters that will stretch.
    if (["<", "\\lt"].includes(symDelim.text)) { symDelim.text = "⟨"; }
    if ([">", "\\gt"].includes(symDelim.text)) { symDelim.text = "⟩"; }
    return symDelim;
  } else if (symDelim) {
    throw new ParseError(`Invalid delimiter '${symDelim.text}' after '${context.funcName}'`, delim);
  } else {
    throw new ParseError(`Invalid delimiter type '${delim.type}'`, delim);
  }
}

//                               /         \
const needExplicitStretch = ["\u002F", "\u005C", "\\backslash", "\\vert", "|"];

defineFunction({
  type: "delimsizing",
  names: [
    "\\bigl",
    "\\Bigl",
    "\\biggl",
    "\\Biggl",
    "\\bigr",
    "\\Bigr",
    "\\biggr",
    "\\Biggr",
    "\\bigm",
    "\\Bigm",
    "\\biggm",
    "\\Biggm",
    "\\big",
    "\\Big",
    "\\bigg",
    "\\Bigg"
  ],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  mathmlBuilder: (group) => {
    const children = [];

    if (group.delim === ".") { group.delim = ""; }
    children.push(makeText(group.delim, group.mode));

    const node = new mathMLTree.MathNode("mo", children);

    if (group.mclass === "mopen" || group.mclass === "mclose") {
      // Only some of the delimsizing functions act as fences, and they
      // return "mopen" or "mclose" mclass.
      node.setAttribute("fence", "true");
    } else {
      // Explicitly disable fencing if it's not a fence, to override the
      // defaults.
      node.setAttribute("fence", "false");
    }
    if (needExplicitStretch.includes(group.delim) || group.delim.indexOf("arrow") > -1) {
      // We have to explicitly set stretchy to true.
      node.setAttribute("stretchy", "true");
    }
    node.setAttribute("symmetric", "true"); // Needed for tall arrows in Firefox.
    node.setAttribute("minsize", sizeToMaxHeight[group.size] + "em");
    node.setAttribute("maxsize", sizeToMaxHeight[group.size] + "em");
    return node;
  }
});

function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}

defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text
    };
  }
});

defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    const parser = context.parser;
    // Parse out the implicit body
    ++parser.leftrightDepth;
    // parseExpression stops before '\\right' or `\\middle`
    let body = parser.parseExpression(false, null, true);
    let nextToken = parser.fetch();
    while (nextToken.text === "\\middle") {
      // `\middle`, from the ε-TeX package, ends one group and starts another group.
      // We had to parse this expression with `breakOnMiddle` enabled in order
      // to get TeX-compliant parsing of \over.
      // But we do not want, at this point, to end on \middle, so continue
      // to parse until we fetch a `\right`.
      parser.consume();
      const middle = parser.fetch().text;
      if (!symbols.math[middle]) {
        throw new ParseError(`Invalid delimiter '${middle}' after '\\middle'`);
      }
      checkDelimiter({ type: "atom", mode: "math", text: middle }, { funcName: "\\middle" });
      body.push({ type: "middle", mode: "math", delim: middle });
      parser.consume();
      body = body.concat(parser.parseExpression(false, null, true));
      nextToken = parser.fetch();
    }
    --parser.leftrightDepth;
    // Check the next token
    parser.expect("\\right", false);
    const right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim
    };
  },
  mathmlBuilder: (group, style) => {
    assertParsed(group);
    const inner = buildExpression(group.body, style);

    if (group.left === ".") { group.left = ""; }
    const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
    leftNode.setAttribute("fence", "true");
    leftNode.setAttribute("form", "prefix");
    if (group.left === "/" || group.left === "\u005C" || group.left.indexOf("arrow") > -1) {
      leftNode.setAttribute("stretchy", "true");
    }
    inner.unshift(leftNode);

    if (group.right === ".") { group.right = ""; }
    const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
    rightNode.setAttribute("fence", "true");
    rightNode.setAttribute("form", "postfix");
    if (group.right === "\u2216" || group.right.indexOf("arrow") > -1) {
      rightNode.setAttribute("stretchy", "true");
    }
    if (group.body.length > 0) {
      const lastElement = group.body[group.body.length - 1];
      if (lastElement.type === "color" && !lastElement.isTextColor) {
        // \color is a switch. If the last element is of type "color" then
        // the user set the \color switch and left it on.
        // A \right delimiter turns the switch off, but the delimiter itself gets the color.
        rightNode.setAttribute("mathcolor", lastElement.color);
      }
    }
    inner.push(rightNode);

    return makeRow(inner);
  }
});

defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  mathmlBuilder: (group, style) => {
    const textNode = makeText(group.delim, group.mode);
    const middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    if (group.delim.indexOf("arrow") > -1) {
      middleNode.setAttribute("stretchy", "true");
    }
    // The next line is not semantically correct, but
    // Chromium fails to stretch if it is not there.
    middleNode.setAttribute("form", "prefix");
    // MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});

const padding = _ => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", "3pt");
  return node
};

const mathmlBuilder$7 = (group, style) => {
  let node;
  if (group.label.indexOf("colorbox") > -1 || group.label === "\\boxed") {
    // MathML core does not support +width attribute in <mpadded>.
    // Firefox does not reliably add side padding.
    // Insert <mspace>
    node = new mathMLTree.MathNode("mrow", [
      padding(),
      buildGroup$1(group.body, style),
      padding()
    ]);
  } else {
    node = new mathMLTree.MathNode("menclose", [buildGroup$1(group.body, style)]);
  }
  switch (group.label) {
    case "\\overline":
      node.setAttribute("notation", "top"); // for Firefox & WebKit
      node.classes.push("tml-overline");    // for Chromium
      break
    case "\\underline":
      node.setAttribute("notation", "bottom");
      node.classes.push("tml-underline");
      break
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "upstrike"]));
      break
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "downstrike"]));
      break
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "sout"]));
      break
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      node.classes.push("tml-xcancel");
      break
    case "\\longdiv":
      node.setAttribute("notation", "longdiv");
      node.classes.push("longdiv-top");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["longdiv-arc"]));
      break
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      node.classes.push("phasor-bottom");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["phasor-angle"]));
      break
    case "\\textcircled":
      node.setAttribute("notation", "circle");
      node.classes.push("circle-pad");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["textcircle"]));
      break
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      node.classes.push("actuarial");
      break
    case "\\boxed":
      // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}} from amsmath.sty
      node.setAttribute("notation", "box");
      node.classes.push("tml-box");
      node.setAttribute("scriptlevel", "0");
      node.setAttribute("displaystyle", "true");
      break
    case "\\fbox":
      node.setAttribute("notation", "box");
      node.classes.push("tml-fbox");
      break
    case "\\fcolorbox":
    case "\\colorbox": {
      // <menclose> doesn't have a good notation option for \colorbox.
      // So use <mpadded> instead. Set some attributes that come
      // included with <menclose>.
      //const fboxsep = 3; // 3 pt from LaTeX source2e
      //node.setAttribute("height", `+${2 * fboxsep}pt`)
      //node.setAttribute("voffset", `${fboxsep}pt`)
      const style = { padding: "3pt 0 3pt 0" };

      if (group.label === "\\fcolorbox") {
        style.border = "0.0667em solid " + String(group.borderColor);
      }
      node.style = style;
      break
    }
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};

defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
    }
    const body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let borderColor = "";
    let backgroundColor;
    if (model) {
      const borderSpec = assertNodeType(args[0], "raw").string;
      const backgroundSpec = assertNodeType(args[0], "raw").string;
      borderColor = colorFromSpec(model, borderSpec);
      backgroundColor = colorFromSpec(model, backgroundSpec);
    } else {
      borderColor = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
      backgroundColor = validateColor(assertNodeType(args[1], "raw").string, parser.gullet.macros);
    }
    const body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});

defineFunction({
  type: "enclose",
  names: ["\\angl", "\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\overline",
    "\\boxed", "\\longdiv", "\\phase"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});


defineFunction({
  type: "enclose",
  names: ["\\textcircled"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

// Environment delimiters. HTML/MathML rendering is defined in the corresponding
// defineEnvironment definitions.
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler({ parser, funcName }, args) {
    const nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    let envName = "";
    for (let i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }

    if (funcName === "\\begin") {
      // begin...end is similar to left...right
      if (!Object.prototype.hasOwnProperty.call(environments, envName )) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      // Build the environment object. Arguments and other information will
      // be made available to the begin and end methods using properties.
      const env = environments[envName];
      const { args, optArgs } = parser.parseArguments("\\begin{" + envName + "}", env);
      const context = {
        mode: parser.mode,
        envName,
        parser
      };
      const result = env.handler(context, args, optArgs);
      parser.expect("\\end", false);
      const endNameToken = parser.nextToken;
      const end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError(
          `Mismatch: \\begin{${envName}} matched by \\end{${end.name}}`,
          endNameToken
        );
      }
      return result;
    }

    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});

defineFunction({
  type: "envTag",
  names: ["\\env@tag"],
  props: {
    numArgs: 1,
    argTypes: ["math"]
  },
  handler({ parser }, args) {
    return {
      type: "envTag",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

defineFunction({
  type: "noTag",
  names: ["\\env@notag"],
  props: {
    numArgs: 0
  },
  handler({ parser }) {
    return {
      type: "noTag",
      mode: parser.mode
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

const isLongVariableName = (group, font) => {
  if (font !== "mathrm" || group.body.type !== "ordgroup" || group.body.body.length === 1) {
    return false
  }
  if (group.body.body[0].type !== "mathord") { return false }
  for (let i = 1; i < group.body.body.length; i++) {
    const parseNodeType = group.body.body[i].type;
    if (!(parseNodeType ===  "mathord" ||
    (parseNodeType ===  "textord" && !isNaN(group.body.body[i].text)))) {
      return false
    }
  }
  return true
};

const mathmlBuilder$6 = (group, style) => {
  const font = group.font;
  const newStyle = style.withFont(font);
  const mathGroup = buildGroup$1(group.body, newStyle);

  if (mathGroup.children.length === 0) { return mathGroup } // empty group, e.g., \mathrm{}
  if (font === "boldsymbol" && ["mo", "mpadded", "mrow"].includes(mathGroup.type)) {
    mathGroup.style.fontWeight = "bold";
    return mathGroup
  }
  // Check if it is possible to consolidate elements into a single <mi> element.
  if (isLongVariableName(group, font)) {
    // This is a \mathrm{…} group. It gets special treatment because symbolsOrd.js
    // wraps <mi> elements with <mrow>s to work around a Firefox bug.
    const mi = mathGroup.children[0].children[0];
    delete mi.attributes.mathvariant;
    for (let i = 1; i < mathGroup.children.length; i++) {
      mi.children[0].text += mathGroup.children[i].type === "mn"
        ? mathGroup.children[i].children[0].text
        : mathGroup.children[i].children[0].children[0].text;
    }
    // Wrap in a <mrow> to prevent the same Firefox bug.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  let canConsolidate = mathGroup.children[0].type === "mo";
  for (let i = 1; i < mathGroup.children.length; i++) {
    if (mathGroup.children[i].type === "mo" && font === "boldsymbol") {
      mathGroup.children[i].style.fontWeight = "bold";
    }
    if (mathGroup.children[i].type !== "mi") { canConsolidate = false; }
    const localVariant = mathGroup.children[i].attributes &&
      mathGroup.children[i].attributes.mathvariant || "";
    if (localVariant !== "normal") { canConsolidate = false; }
  }
  if (!canConsolidate) { return mathGroup }
  // Consolidate the <mi> elements.
  const mi = mathGroup.children[0];
  for (let i = 1; i < mathGroup.children.length; i++) {
    mi.children.push(mathGroup.children[i].children[0]);
  }
  if (mi.attributes.mathvariant && mi.attributes.mathvariant === "normal") {
    // Workaround for a Firefox bug that renders spurious space around
    // a <mi mathvariant="normal">
    // Ref: https://bugs.webkit.org/show_bug.cgi?id=129097
    // We insert a text node that contains a zero-width space and wrap in an mrow.
    // TODO: Get rid of this <mi> workaround when the Firefox bug is fixed.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  return mi
};

const fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};

defineFunction({
  type: "font",
  names: [
    // styles
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\up@greek",
    "\\boldsymbol",

    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathsfit",
    "\\mathtt",

    // aliases
    "\\Bbb",
    "\\bm",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = normalizeArgument(args[0]);
    let func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

// Old font changing functions
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ parser, funcName, breakOnTokenText }, args) => {
    const { mode } = parser;
    const body = parser.parseExpression(true, breakOnTokenText, true);
    const fontStyle = `math${funcName.slice(1)}`;

    return {
      type: "font",
      mode: mode,
      font: fontStyle,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

const stylArray = ["display", "text", "script", "scriptscript"];
const scriptLevel = { auto: -1, display: 0, text: 0, script: 1, scriptscript: 2 };

const mathmlBuilder$5 = (group, style) => {
  // Track the scriptLevel of the numerator and denominator.
  // We may need that info for \mathchoice or for adjusting em dimensions.
  const childOptions = group.scriptLevel === "auto"
    ? style.incrementLevel()
    : group.scriptLevel === "display"
    ? style.withLevel(StyleLevel.TEXT)
    : group.scriptLevel === "text"
    ? style.withLevel(StyleLevel.SCRIPT)
    : style.withLevel(StyleLevel.SCRIPTSCRIPT);

  // Chromium (wrongly) continues to shrink fractions beyond scriptscriptlevel.
  // So we check for levels that Chromium shrinks too small.
  // If necessary, set an explicit fraction depth.
  const numer = buildGroup$1(group.numer, childOptions);
  const denom = buildGroup$1(group.denom, childOptions);
  if (style.level === 3) {
    numer.style.mathDepth = "2";
    numer.setAttribute("scriptlevel", "2");
    denom.style.mathDepth = "2";
    denom.setAttribute("scriptlevel", "2");
  }

  let node = new mathMLTree.MathNode("mfrac", [numer, denom]);

  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    const ruleWidth = calculateSize(group.barSize, style);
    node.setAttribute("linethickness", ruleWidth.number + ruleWidth.unit);
  }

  if (group.leftDelim != null || group.rightDelim != null) {
    const withDelims = [];

    if (group.leftDelim != null) {
      const leftOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))
      ]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }

    withDelims.push(node);

    if (group.rightDelim != null) {
      const rightOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))
      ]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }

    node = makeRow(withDelims);
  }

  if (group.scriptLevel !== "auto") {
    node = new mathMLTree.MathNode("mstyle", [node]);
    node.setAttribute("displaystyle", String(group.scriptLevel === "display"));
    node.setAttribute("scriptlevel", scriptLevel[group.scriptLevel]);
  }

  return node;
};

defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac", // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac" // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];
    let hasBarLine = false;
    let leftDelim = null;
    let rightDelim = null;
    let scriptLevel = "auto";

    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }

    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        scriptLevel = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        scriptLevel = "text";
        break;
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      scriptLevel,
      barSize: null
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "display",
      barSize: null
    };
  }
});

// Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler({ parser, funcName, token }) {
    let replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});

const delimFromValue = function(delimString) {
  let delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};

defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler({ parser }, args) {
    const numer = args[4];
    const denom = args[5];

    // Look into the parse nodes to get the desired delimiters.
    const leftNode = normalizeArgument(args[0]);
    const leftDelim = leftNode.type === "atom" && leftNode.family === "open"
      ? delimFromValue(leftNode.text)
      : null;
    const rightNode = normalizeArgument(args[1]);
    const rightDelim =
      rightNode.type === "atom" && rightNode.family === "close"
        ? delimFromValue(rightNode.text)
        : null;

    const barNode = assertNodeType(args[2], "size");
    let hasBarLine;
    let barSize = null;
    if (barNode.isBlank) {
      // \genfrac acts differently than \above.
      // \genfrac treats an empty size group as a signal to use a
      // standard bar size. \above would see size = 0 and omit the bar.
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }

    // Find out if we want displaystyle, textstyle, etc.
    let scriptLevel = "auto";
    let styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        const textOrd = assertNodeType(styl.body[0], "textord");
        scriptLevel = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      scriptLevel = stylArray[Number(styl.text)];
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      scriptLevel
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

// \above is an infix fraction that also defines a fraction bar size.
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler({ parser, funcName, token }, args) {
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      barSize: assertNodeType(args[0], "size").value,
      token
    };
  }
});

defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const barSize = assert(assertNodeType(args[1], "infix").barSize);
    const denom = args[2];

    const hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "auto"
    };
  },

  mathmlBuilder: mathmlBuilder$5
});

// \hbox is provided for compatibility with LaTeX functions that act on a box.
// This function by itself doesn't do anything but set scriptlevel to \textstyle
// and prevent a soft line break.

defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInArgument: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = style.withLevel(StyleLevel.TEXT);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

const mathmlBuilder$4 = (group, style) => {
  const accentNode = stretchy.mathMLnode(group.label);
  accentNode.style["math-depth"] = 0;
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [
    buildGroup$1(group.base, style),
    accentNode
  ]);
};

// Horizontal stretchy braces
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  mathmlBuilder: mathmlBuilder$4
});

defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const body = args[1];
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\href",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\href" is not trusted`, token)
    }

    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const math = new MathNode("math", [buildExpressionRow(group.body, style)]);
    const anchorNode = new AnchorNode(group.href, [], [math]);
    return anchorNode
  }
});

defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\url",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\url" is not trusted`, token)
    }

    const chars = [];
    for (let i = 0; i < href.length; i++) {
      let c = href[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    const body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});

defineFunction({
  type: "html",
  names: ["\\class", "\\id", "\\style", "\\data"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    const value = assertNodeType(args[0], "raw").string;
    const body = args[1];

    if (parser.settings.strict) {
      throw new ParseError(`Function "${funcName}" is disabled in strict mode`, token)
    }

    let trustContext;
    const attributes = {};

    switch (funcName) {
      case "\\class":
        attributes.class = value;
        trustContext = {
          command: "\\class",
          class: value
        };
        break;
      case "\\id":
        attributes.id = value;
        trustContext = {
          command: "\\id",
          id: value
        };
        break;
      case "\\style":
        attributes.style = value;
        trustContext = {
          command: "\\style",
          style: value
        };
        break;
      case "\\data": {
        const data = value.split(",");
        for (let i = 0; i < data.length; i++) {
          const keyVal = data[i].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\data");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }

        trustContext = {
          command: "\\data",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }

    if (!parser.settings.isTrusted(trustContext)) {
      throw new ParseError(`Function "${funcName}" is not trusted`, token)
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const element =  buildExpressionRow(group.body, style);

    const classes = [];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    element.classes = classes;

    for (const attr in group.attributes) {
      if (attr !== "class" && Object.prototype.hasOwnProperty.call(group.attributes, attr)) {
        element.setAttribute(attr, group.attributes[attr]);
      }
    }

    return element;
  }
});

const sizeData = function(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    // str is a number with no unit specified.
    // default unit is bp, per graphix package.
    return { number: +str, unit: "bp" }
  } else {
    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data
  }
};

defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: ({ parser, token }, args, optArgs) => {
    let width = { number: 0, unit: "em" };
    let height = { number: 0.9, unit: "em" };  // sorta character sized.
    let totalheight = { number: 0, unit: "em" };
    let alt = "";

    if (optArgs[0]) {
      const attributeStr = assertNodeType(optArgs[0], "raw").string;

      // Parser.js does not parse key/value pairs. We get a string.
      const attributes = attributeStr.split(",");
      for (let i = 0; i < attributes.length; i++) {
        const keyVal = attributes[i].split("=");
        if (keyVal.length === 2) {
          const str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break
            case "width":
              width = sizeData(str);
              break
            case "height":
              height = sizeData(str);
              break
            case "totalheight":
              totalheight = sizeData(str);
              break
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.")
          }
        }
      }
    }

    const src = assertNodeType(args[0], "url").url;

    if (alt === "") {
      // No alt given. Use the file name. Strip away the path.
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }

    if (
      !parser.settings.isTrusted({
        command: "\\includegraphics",
        url: src
      })
    ) {
      throw new ParseError(`Function "\\includegraphics" is not trusted`, token)
    }

    return {
      type: "includegraphics",
      mode: parser.mode,
      alt: alt,
      width: width,
      height: height,
      totalheight: totalheight,
      src: src
    }
  },
  mathmlBuilder: (group, style) => {
    const height = calculateSize(group.height, style);
    const depth = { number: 0, unit: "em" };

    if (group.totalheight.number > 0) {
      if (group.totalheight.unit === height.unit &&
        group.totalheight.number > height.number) {
        depth.number = group.totalheight.number - height.number;
        depth.unit = height.unit;
      }
    }

    let width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, style);
    }

    const graphicStyle = { height: height.number + depth.number + "em" };
    if (width.number > 0) {
      graphicStyle.width = width.number + width.unit;
    }
    if (depth.number > 0) {
      graphicStyle.verticalAlign = -depth.number + depth.unit;
    }

    const node = new Img(group.src, group.alt, graphicStyle);
    node.height = height;
    node.depth = depth;
    return new mathMLTree.MathNode("mtext", [node])
  }
});

// Horizontal spacing commands


// TODO: \hskip and \mskip should support plus and minus in lengths

defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler({ parser, funcName, token }, args) {
    const size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      const mathFunction = funcName[1] === "m"; // \mkern, \mskip
      const muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          throw new ParseError(`LaTeX's ${funcName} supports only mu units, ` +
            `not ${size.value.unit} units`, token)
        }
        if (parser.mode !== "math") {
          throw new ParseError(`LaTeX's ${funcName} works only in math mode`, token)
        }
      } else {
        // !mathFunction
        if (muUnit) {
          throw new ParseError(`LaTeX's ${funcName} doesn't support mu units`, token)
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  mathmlBuilder(group, style) {
    const dimension = calculateSize(group.dimension, style);
    const ch = dimension.unit === "em" ? spaceCharacter(dimension.number) : "";
    if (group.mode === "text" && ch.length > 0) {
      const character = new mathMLTree.TextNode(ch);
      return new mathMLTree.MathNode("mtext", [character]);
    } else {
      const node = new mathMLTree.MathNode("mspace");
      node.setAttribute("width", dimension.number + dimension.unit);
      if (dimension.number < 0) {
        node.style.marginLeft = dimension.number + dimension.unit;
      }
      return node;
    }
  }
});

const spaceCharacter = function(width) {
  if (width >= 0.05555 && width <= 0.05556) {
    return "\u200a"; // &VeryThinSpace;
  } else if (width >= 0.1666 && width <= 0.1667) {
    return "\u2009"; // &ThinSpace;
  } else if (width >= 0.2222 && width <= 0.2223) {
    return "\u2005"; // &MediumSpace;
  } else if (width >= 0.2777 && width <= 0.2778) {
    return "\u2005\u200a"; // &ThickSpace;
  } else {
    return "";
  }
};

// Limit valid characters to a small set, for safety.
const invalidIdRegEx = /[^A-Za-z_0-9-]/g;

defineFunction({
  type: "label",
  names: ["\\label"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser }, args) {
    return {
      type: "label",
      mode: parser.mode,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Return a no-width, no-ink element with an HTML id.
    const node = new mathMLTree.MathNode("mrow", [], ["tml-label"]);
    if (group.string.length > 0) {
      node.setLabel(group.string);
    }
    return node
  }
});

// Horizontal overlap functions

const textModeLap = ["\\clap", "\\llap", "\\rlap"];

defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap", "\\clap", "\\llap", "\\rlap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    if (textModeLap.includes(funcName)) {
      if (parser.settings.strict && parser.mode !== "text") {
        throw new ParseError(`{${funcName}} can be used only in text mode.
 Try \\math${funcName.slice(1)}`, token)
      }
      funcName = funcName.slice(1);
    } else {
      funcName = funcName.slice(5);
    }
    const body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName,
      body
    }
  },
  mathmlBuilder: (group, style) => {
    // mathllap, mathrlap, mathclap
    let strut;
    if (group.alignment === "llap") {
      // We need an invisible strut with the same depth as the group.
      // We can't just read the depth, so we use \vphantom methods.
      const phantomInner = buildExpression(ordargument(group.body), style);
      const phantom = new mathMLTree.MathNode("mphantom", phantomInner);
      strut = new mathMLTree.MathNode("mpadded", [phantom]);
      strut.setAttribute("width", "0px");
    }

    const inner = buildGroup$1(group.body, style);
    let node;
    if (group.alignment === "llap") {
      inner.style.position = "absolute";
      inner.style.right = "0";
      inner.style.bottom = `0`; // If we could have read the ink depth, it would go here.
      node = new mathMLTree.MathNode("mpadded", [strut, inner]);
    } else {
      node = new mathMLTree.MathNode("mpadded", [inner]);
    }

    if (group.alignment === "rlap") {
      if (group.body.body.length > 0 && group.body.body[0].type === "genfrac") {
        // In Firefox, a <mpadded> squashes the 3/18em padding of a child \frac. Put it back.
        node.setAttribute("lspace", "0.16667em");
      }
    } else {
      const offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
      if (group.alignment === "llap") {
        node.style.position = "relative";
      } else {
        node.style.display = "flex";
        node.style.justifyContent = "center";
      }
    }
    node.setAttribute("width", "0px");
    return node
  }
});

// Switching from text mode back to math mode
defineFunction({
  type: "ordgroup",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler({ funcName, parser }, args) {
    const outerMode = parser.mode;
    parser.switchMode("math");
    const close = funcName === "\\(" ? "\\)" : "$";
    const body = parser.parseExpression(false, close);
    parser.expect(close);
    parser.switchMode(outerMode);
    return {
      type: "ordgroup",
      mode: parser.mode,
      body
    };
  }
});

// Check for extra closing math delimiters
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, token) {
    throw new ParseError(`Mismatched ${context.funcName}`, token);
  }
});

const chooseStyle = (group, style) => {
  switch (style.level) {
    case StyleLevel.DISPLAY:       // 0
      return group.display;
    case StyleLevel.TEXT:          // 1
      return group.text;
    case StyleLevel.SCRIPT:        // 2
      return group.script;
    case StyleLevel.SCRIPTSCRIPT:  // 3
      return group.scriptscript;
    default:
      return group.text;
  }
};

defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: ({ parser }, args) => {
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  mathmlBuilder: (group, style) => {
    const body = chooseStyle(group, style);
    return buildExpressionRow(body, style);
  }
});

const textAtomTypes = ["text", "textord", "mathord", "atom"];

function mathmlBuilder$3(group, style) {
  let node;
  const inner = buildExpression(group.body, style);

  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox || inner[0].type === "mathord") {
      node = inner[0];
      node.type = "mi";
      if (node.children.length === 1 && node.children[0].text && node.children[0].text === "∇") {
        node.setAttribute("mathvariant", "normal");
      }
    } else {
      node = new mathMLTree.MathNode("mi", inner);
    }
  } else {
    node = new mathMLTree.MathNode("mrow", inner);
    if (group.mustPromote) {
      node = inner[0];
      node.type = "mo";
      if (group.isCharacterBox && group.body[0].text && /[A-Za-z]/.test(group.body[0].text)) {
        node.setAttribute("mathvariant", "italic");
      }
    } else {
      node = new mathMLTree.MathNode("mrow", inner);
    }

    // Set spacing based on what is the most likely adjacent atom type.
    // See TeXbook p170.
    const doSpacing = style.level < 2; // Operator spacing is zero inside a (sub|super)script.
    if (node.type === "mrow") {
      if (doSpacing ) {
        if (group.mclass === "mbin") {
          // medium space
          node.children.unshift(padding$1(0.2222));
          node.children.push(padding$1(0.2222));
        } else if (group.mclass === "mrel") {
          // thickspace
          node.children.unshift(padding$1(0.2778));
          node.children.push(padding$1(0.2778));
        } else if (group.mclass === "mpunct") {
          node.children.push(padding$1(0.1667));
        } else if (group.mclass === "minner") {
          node.children.unshift(padding$1(0.0556));  // 1 mu is the most likely option
          node.children.push(padding$1(0.0556));
        }
      }
    } else {
      if (group.mclass === "mbin") {
        // medium space
        node.attributes.lspace = (doSpacing ? "0.2222em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2222em" : "0");
      } else if (group.mclass === "mrel") {
        // thickspace
        node.attributes.lspace = (doSpacing ? "0.2778em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2778em" : "0");
      } else if (group.mclass === "mpunct") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = (doSpacing ? "0.1667em" : "0");
      } else if (group.mclass === "mopen" || group.mclass === "mclose") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0em";
      } else if (group.mclass === "minner" && doSpacing) {
        node.attributes.lspace = "0.0556em"; // 1 mu is the most likely option
        node.attributes.width = "+0.1111em";
      }
    }

    if (!(group.mclass === "mopen" || group.mclass === "mclose")) {
      delete node.attributes.stretchy;
      delete node.attributes.form;
    }
  }
  return node;
}

// Math class commands except \mathop
defineFunction({
  type: "mclass",
  names: [
    "\\mathord",
    "\\mathbin",
    "\\mathrel",
    "\\mathopen",
    "\\mathclose",
    "\\mathpunct",
    "\\mathinner"
  ],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    const isCharacterBox = utils.isCharacterBox(body);
    // We should not wrap a <mo> around a <mi> or <mord>. That would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    let mustPromote = true;
    const mord = { type: "mathord", text: "", mode: parser.mode };
    const arr = (body.body) ? body.body : [body];
    for (const arg of arr) {
      if (textAtomTypes.includes(arg.type)) {
        if (symbols[parser.mode][arg.text]) {
          mord.text += symbols[parser.mode][arg.text].replace;
        } else if (arg.text) {
          mord.text += arg.text;
        } else if (arg.body) {
          arg.body.map(e => { mord.text += e.text; });
        }
      } else {
        mustPromote = false;
        break
      }
    }
    if (mustPromote && funcName === "\\mathord" && mord.type === "mathord"
                    && mord.text.length > 1) {
      return mord
    } else {
      return {
        type: "mclass",
        mode: parser.mode,
        mclass: "m" + funcName.slice(5),
        body: ordargument(mustPromote ? mord : body),
        isCharacterBox,
        mustPromote
      };
    }
  },
  mathmlBuilder: mathmlBuilder$3
});

const binrelClass = (arg) => {
  // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
  // (by rendering separately and with {}s before and after, and measuring
  // the change in spacing).  We'll do roughly the same by detecting the
  // atom type directly.
  const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};

// \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler({ parser }, args) {
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});

// Build a relation or stacked op by placing one symbol on top of another
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler({ parser, funcName }, args) {
    const baseArg = args[1];
    const shiftedArg = args[0];

    const baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      stack: true,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };

    return {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
  },
  mathmlBuilder: mathmlBuilder$3
});

// Helper function
const buildGroup = (el, style, noneNode) => {
  if (!el) { return noneNode }
  const node = buildGroup$1(el, style);
  if (node.type === "mrow" && node.children.length === 0) { return noneNode }
  return node
};

defineFunction({
  type: "multiscript",
  names: ["\\sideset", "\\pres@cript"], // See macros.js for \prescript
  props: {
    numArgs: 3
  },
  handler({ parser, funcName, token }, args) {
    if (args[2].body.length === 0) {
      throw new ParseError(funcName + `cannot parse an empty base.`)
    }
    const base = args[2].body[0];
    if (parser.settings.strict && funcName === "\\sideset" && !base.symbol) {
      throw new ParseError(`The base of \\sideset must be a big operator. Try \\prescript.`)
    }

    if ((args[0].body.length > 0 && args[0].body[0].type !== "supsub") ||
        (args[1].body.length > 0 && args[1].body[0].type !== "supsub")) {
      throw new ParseError("\\sideset can parse only subscripts and " +
                            "superscripts in its first two arguments", token)
    }

    // The prescripts and postscripts come wrapped in a supsub.
    const prescripts = args[0].body.length > 0 ? args[0].body[0] : null;
    const postscripts = args[1].body.length > 0 ? args[1].body[0] : null;

    if (!prescripts && !postscripts) {
      return base
    } else if (!prescripts) {
      // It's not a multi-script. Get a \textstyle supsub.
      return {
        type: "styling",
        mode: parser.mode,
        scriptLevel: "text",
        body: [{
          type: "supsub",
          mode: parser.mode,
          base,
          sup: postscripts.sup,
          sub: postscripts.sub
        }]
      }
    } else {
      return {
        type: "multiscript",
        mode: parser.mode,
        isSideset: funcName === "\\sideset",
        prescripts,
        postscripts,
        base
      }
    }
  },
  mathmlBuilder(group, style) {
    const base =  buildGroup$1(group.base, style);

    const prescriptsNode = new mathMLTree.MathNode("mprescripts");
    const noneNode = new mathMLTree.MathNode("none");
    let children = [];

    const preSub = buildGroup(group.prescripts.sub, style, noneNode);
    const preSup = buildGroup(group.prescripts.sup, style, noneNode);
    if (group.isSideset) {
      // This seems silly, but LaTeX does this. Firefox ignores it, which does not make me sad.
      preSub.setAttribute("style", "text-align: left;");
      preSup.setAttribute("style", "text-align: left;");
    }

    if (group.postscripts) {
      const postSub = buildGroup(group.postscripts.sub, style, noneNode);
      const postSup = buildGroup(group.postscripts.sup, style, noneNode);
      children = [base, postSub, postSup, prescriptsNode, preSub, preSup];
    } else {
      children = [base, prescriptsNode, preSub, preSup];
    }

    return new mathMLTree.MathNode("mmultiscripts", children);
  }
});

defineFunction({
  type: "not",
  names: ["\\not"],
  props: {
    numArgs: 1,
    primitive: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    const isCharacterBox = utils.isCharacterBox(args[0]);
    let body;
    if (isCharacterBox) {
      body = ordargument(args[0]);
      if (body[0].text.charAt(0) === "\\") {
        body[0].text = symbols.math[body[0].text].replace;
      }
      // \u0338 is the Unicode Combining Long Solidus Overlay
      body[0].text = body[0].text.slice(0, 1) + "\u0338" + body[0].text.slice(1);
    } else {
      // When the argument is not a character box, TeX does an awkward, poorly placed overlay.
      // We'll do the same.
      const notNode = { type: "textord", mode: "math", text: "\u0338" };
      const kernNode = { type: "kern", mode: "math", dimension: { number: -0.6, unit: "em" } };
      body = [notNode, kernNode, args[0]];
    }
    return {
      type: "not",
      mode: parser.mode,
      body,
      isCharacterBox
    };
  },
  mathmlBuilder(group, style) {
    if (group.isCharacterBox) {
      const inner = buildExpression(group.body, style, true);
      return inner[0]
    } else {
      return buildExpressionRow(group.body, style)
    }
  }
});

// Limits, symbols

// Some helpers

const ordAtomTypes = ["textord", "mathord", "atom"];

// Most operators have a large successor symbol, but these don't.
const noSuccessor = ["\\smallint"];

// Math operators (e.g. \sin) need a space between these types and themselves:
const ordTypes = ["textord", "mathord", "ordgroup", "close", "leftright", "font"];

// NOTE: Unlike most `builders`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.

const setSpacing = node => {
  // The user wrote a \mathop{…} function. Change spacing from default to OP spacing.
  // The most likely spacing for an OP is a thin space per TeXbook p170.
  node.attributes.lspace = "0.1667em";
  node.attributes.rspace = "0.1667em";
};

const mathmlBuilder$2 = (group, style) => {
  let node;

  if (group.symbol) {
    // This is a symbol. Just add the symbol.
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (noSuccessor.includes(group.name)) {
      node.setAttribute("largeop", "false");
    } else {
      node.setAttribute("movablelimits", "false");
    }
    if (group.fromMathOp) { setSpacing(node); }
  } else if (group.body) {
    // This is an operator with children. Add them.
    node = new MathNode("mo", buildExpression(group.body, style));
    if (group.fromMathOp) { setSpacing(node); }
  } else {
    // This is a text operator. Add all of the characters from the operator's name.
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);

    if (!group.parentIsSupSub) {
      // Append an invisible <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new MathNode("mo", [makeText("\u2061", "text")]);
      const row = [node, operator];
      // Set spacing
      if (group.needsLeadingSpace) {
        const lead = new MathNode("mspace");
        lead.setAttribute("width", "0.1667em"); // thin space.
        row.unshift(lead);
      }
      if (!group.isFollowedByDelimiter) {
        const trail = new MathNode("mspace");
        trail.setAttribute("width", "0.1667em"); // thin space.
        row.push(trail);
      }
      node = new MathNode("mrow", row);
    }
  }

  return node;
};

const singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22c0": "\\bigwedge",
  "\u22c1": "\\bigvee",
  "\u22c2": "\\bigcap",
  "\u22c3": "\\bigcup",
  "\u2a00": "\\bigodot",
  "\u2a01": "\\bigoplus",
  "\u2a02": "\\bigotimes",
  "\u2a04": "\\biguplus",
  "\u2a05": "\\bigsqcap",
  "\u2a06": "\\bigsqcup",
  "\u2a03": "\\bigcupdot",
  "\u2a07": "\\bigdoublevee",
  "\u2a08": "\\bigdoublewedge",
  "\u2a09": "\\bigtimes"
};

defineFunction({
  type: "op",
  names: [
    "\\coprod",
    "\\bigvee",
    "\\bigwedge",
    "\\biguplus",
    "\\bigcupplus",
    "\\bigcupdot",
    "\\bigcap",
    "\\bigcup",
    "\\bigdoublevee",
    "\\bigdoublewedge",
    "\\intop",
    "\\prod",
    "\\sum",
    "\\bigotimes",
    "\\bigoplus",
    "\\bigodot",
    "\\bigsqcap",
    "\\bigsqcup",
    "\\bigtimes",
    "\\smallint",
    "\u220F",
    "\u2210",
    "\u2211",
    "\u22c0",
    "\u22c1",
    "\u22c2",
    "\u22c3",
    "\u2a00",
    "\u2a01",
    "\u2a02",
    "\u2a04",
    "\u2a06"
  ],
  props: {
    numArgs: 0
  },
  handler: ({ parser, funcName }, args) => {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      stack: false, // This is true for \stackrel{}, not here.
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Note: calling defineFunction with a type that's already been defined only
// works because the same mathmlBuilder is being used.
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    // It would be convienient to just wrap a <mo> around the argument.
    // But if the argument is a <mi> or <mord>, that would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    const arr = (body.body) ? body.body : [body];
    const isSymbol = arr.length === 1 && ordAtomTypes.includes(arr[0].type);
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: isSymbol,
      fromMathOp: true,
      stack: false,
      name: isSymbol ? arr[0].text : null,
      body: isSymbol ? null : ordargument(body)
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

const singleCharIntegrals = {
  "\u222b": "\\int",
  "\u222c": "\\iint",
  "\u222d": "\\iiint",
  "\u222e": "\\oint",
  "\u222f": "\\oiint",
  "\u2230": "\\oiiint",
  "\u2231": "\\intclockwise",
  "\u2232": "\\varointclockwise",
  "\u2a0c": "\\iiiint",
  "\u2a0d": "\\intbar",
  "\u2a0e": "\\intBar",
  "\u2a0f": "\\fint",
  "\u2a12": "\\rppolint",
  "\u2a13": "\\scpolint",
  "\u2a15": "\\pointint",
  "\u2a16": "\\sqint",
  "\u2a17": "\\intlarhk",
  "\u2a18": "\\intx",
  "\u2a19": "\\intcap",
  "\u2a1a": "\\intcup"
};

// No limits, not symbols
defineFunction({
  type: "op",
  names: [
    "\\arcsin",
    "\\arccos",
    "\\arctan",
    "\\arctg",
    "\\arcctg",
    "\\arg",
    "\\ch",
    "\\cos",
    "\\cosec",
    "\\cosh",
    "\\cot",
    "\\cotg",
    "\\coth",
    "\\csc",
    "\\ctg",
    "\\cth",
    "\\deg",
    "\\dim",
    "\\exp",
    "\\hom",
    "\\ker",
    "\\lg",
    "\\ln",
    "\\log",
    "\\sec",
    "\\sin",
    "\\sinh",
    "\\sh",
    "\\sgn",
    "\\tan",
    "\\tanh",
    "\\tg",
    "\\th"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Limits, not symbols
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// No limits, symbols
defineFunction({
  type: "op",
  names: [
    "\\int",
    "\\iint",
    "\\iiint",
    "\\iiiint",
    "\\oint",
    "\\oiint",
    "\\oiiint",
    "\\intclockwise",
    "\\varointclockwise",
    "\\intbar",
    "\\intBar",
    "\\fint",
    "\\rppolint",
    "\\scpolint",
    "\\pointint",
    "\\sqint",
    "\\intlarhk",
    "\\intx",
    "\\intcap",
    "\\intcup",
    "\u222b",
    "\u222c",
    "\u222d",
    "\u222e",
    "\u222f",
    "\u2230",
    "\u2231",
    "\u2232",
    "\u2a0c",
    "\u2a0d",
    "\u2a0e",
    "\u2a0f",
    "\u2a12",
    "\u2a13",
    "\u2a15",
    "\u2a16",
    "\u2a17",
    "\u2a18",
    "\u2a19",
    "\u2a1a"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      stack: false,
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// NOTE: Unlike most builders, this one handles not only
// "operatorname", but also  "supsub" since \operatorname* can
// affect super/subscripting.

const mathmlBuilder$1 = (group, style) => {
  let expression = buildExpression(group.body, style.withFont("mathrm"));

  // Is expression a string or has it something like a fraction?
  let isAllString = true; // default
  for (let i = 0; i < expression.length; i++) {
    let node = expression[i];
    if (node instanceof mathMLTree.MathNode) {
      if ((node.type === "mrow" || node.type === "mpadded") && node.children.length === 1 &&
          node.children[0] instanceof mathMLTree.MathNode) {
        node = node.children[0];
      }
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mtext":
          break; // Do nothing yet.
        case "mspace":
          {
            if (node.attributes.width) {
              const width = node.attributes.width.replace("em", "");
              const ch = spaceCharacter(Number(width));
              if (ch === "") {
                isAllString = false;
              } else {
                expression[i] = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(ch)]);
              }
            }
          }
          break
        case "mo": {
          const child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }

  if (isAllString) {
    // Write a single TextNode instead of multiple nested tags.
    const word = expression.map((node) => node.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  } else if (
    expression.length === 1
    && ["mover", "munder"].includes(expression[0].type) &&
    (expression[0].children[0].type === "mi" || expression[0].children[0].type === "mtext")
  ) {
    expression[0].children[0].type = "mi";
    if (group.parentIsSupSub) {
      return new mathMLTree.MathNode("mrow", expression)
    } else {
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      return mathMLTree.newDocumentFragment([expression[0], operator])
    }
  }

  let wrapper;
  if (isAllString) {
    wrapper = new mathMLTree.MathNode("mi", expression);
    if (expression[0].text.length === 1) {
      wrapper.setAttribute("mathvariant", "normal");
    }
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }

  if (!group.parentIsSupSub) {
    // Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
    const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
    const fragment = [wrapper, operator];
    if (group.needsLeadingSpace) {
      // LaTeX gives operator spacing, but a <mi> gets ord spacing.
      // So add a leading space.
      const space = new mathMLTree.MathNode("mspace");
      space.setAttribute("width", "0.1667em"); // thin space.
      fragment.unshift(space);
    }
    if (!group.isFollowedByDelimiter) {
      const trail = new mathMLTree.MathNode("mspace");
      trail.setAttribute("width", "0.1667em"); // thin space.
      fragment.push(trail);
    }
    return mathMLTree.newDocumentFragment(fragment)
  }

  return wrapper
};

// \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = args[0];
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: (funcName === "\\operatornamewithlimits"),
      limits: false,
      parentIsSupSub: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType)
    };
  },
  mathmlBuilder: mathmlBuilder$1
});

defineMacro("\\operatorname",
  "\\@ifstar\\operatornamewithlimits\\operatorname@");

defineFunctionBuilders({
  type: "ordgroup",
  mathmlBuilder(group, style) {
    return buildExpressionRow(group.body, style, group.semisimple);
  }
});

defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(group.body, style);
    return new mathMLTree.MathNode("mphantom", inner);
  }
});

defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});

defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});

// In LaTeX, \pmb is a simulation of bold font.
// The version of \pmb in ambsy.sty works by typesetting three copies of the argument
// with small offsets. We use CSS font-weight:bold.

defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "pmb",
      mode: parser.mode,
      body: ordargument(args[0])
    }
  },
  mathmlBuilder(group, style) {
    const inner = buildExpression(group.body, style);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    node.setAttribute("style", "font-weight:bold");
    return node
  }
});

// \raise, \lower, and \raisebox

const mathmlBuilder = (group, style) => {
  const newStyle = style.withLevel(StyleLevel.TEXT);
  const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, newStyle)]);
  const dy = calculateSize(group.dy, style);
  node.setAttribute("voffset", dy.number + dy.unit);
  // Add padding, which acts to increase height in Chromium.
  // TODO: Figure out some way to change height in Firefox w/o breaking Chromium.
  if (dy.number > 0) {
    node.style.padding = dy.number + dy.unit + " 0 0 0";
  } else {
    node.style.padding = "0 0 " + Math.abs(dy.number) + dy.unit + " 0";
  }
  return node
};

defineFunction({
  type: "raise",
  names: ["\\raise", "\\lower"],
  props: {
    numArgs: 2,
    argTypes: ["size", "primitive"],
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    if (funcName === "\\lower") { amount.number *= -1; }
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});


defineFunction({
  type: "raise",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});

defineFunction({
  type: "ref",
  names: ["\\ref", "\\eqref"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser, funcName }, args) {
    return {
      type: "ref",
      mode: parser.mode,
      funcName,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Create an empty <a> node. Set a class and an href attribute.
    // The post-processor will populate with the target's tag or equation number.
    const classes = group.funcName === "\\ref" ? ["tml-ref"] : ["tml-ref", "tml-eqref"];
    return new AnchorNode("#" + group.string, classes, null)
  }
});

defineFunction({
  type: "reflect",
  names: ["\\reflectbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "reflect",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    const node = buildGroup$1(group.body, style);
    node.style.transform = "scaleX(-1)";
    return node
  }
});

defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser }) {
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});

defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["size", "size", "size"]
  },
  handler({ parser }, args, optArgs) {
    const shift = optArgs[0];
    const width = assertNodeType(args[0], "size");
    const height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  mathmlBuilder(group, style) {
    const width = calculateSize(group.width, style);
    const height = calculateSize(group.height, style);
    const shift = group.shift
      ? calculateSize(group.shift, style)
      : { number: 0, unit: "em" };
    const color = (style.color && style.getColor()) || "black";

    const rule = new mathMLTree.MathNode("mspace");
    if (width.number > 0 && height.number > 0) {
      rule.setAttribute("mathbackground", color);
    }
    rule.setAttribute("width", width.number + width.unit);
    rule.setAttribute("height", height.number + height.unit);
    if (shift.number === 0) { return rule }

    const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift.number >= 0) {
      wrapper.setAttribute("height", "+" + shift.number + shift.unit);
    } else {
      wrapper.setAttribute("height", shift.number + shift.unit);
      wrapper.setAttribute("depth", "+" + -shift.number + shift.unit);
    }
    wrapper.setAttribute("voffset", shift.number + shift.unit);
    return wrapper;
  }
});

// The size mappings are taken from TeX with \normalsize=10pt.
// We don't have to track script level. MathML does that.
const sizeMap = {
  "\\tiny": 0.5,
  "\\sixptsize": 0.6,
  "\\Tiny": 0.6,
  "\\scriptsize": 0.7,
  "\\footnotesize": 0.8,
  "\\small": 0.9,
  "\\normalsize": 1.0,
  "\\large": 1.2,
  "\\Large": 1.44,
  "\\LARGE": 1.728,
  "\\huge": 2.074,
  "\\Huge": 2.488
};

defineFunction({
  type: "sizing",
  names: [
    "\\tiny",
    "\\sixptsize",
    "\\Tiny",
    "\\scriptsize",
    "\\footnotesize",
    "\\small",
    "\\normalsize",
    "\\large",
    "\\Large",
    "\\LARGE",
    "\\huge",
    "\\Huge"
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ breakOnTokenText, funcName, parser }, args) => {
    if (parser.settings.strict && parser.mode === "math") {
      // eslint-disable-next-line no-console
      console.log(`Temml strict-mode warning: Command ${funcName} is invalid in math mode.`);
    }
    const body = parser.parseExpression(false, breakOnTokenText, true);
    return {
      type: "sizing",
      mode: parser.mode,
      funcName,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const newStyle = style.withFontSize(sizeMap[group.funcName]);
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    const factor = (sizeMap[group.funcName] / style.fontSize).toFixed(4);
    node.setAttribute("mathsize", factor + "em");
    return node;
  }
});

// smash, with optional [tb], as in AMS

defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args, optArgs) => {
    let smashHeight = false;
    let smashDepth = false;
    const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      // Optional [tb] argument is engaged.
      // ref: amsmath: \renewcommand{\smash}[1][tb]{%
      //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
      let letter = "";
      for (let i = 0; i < tbArg.body.length; ++i) {
        const node = tbArg.body[i];
        // TODO: Write an AssertSymbolNode
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }

    const body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  mathmlBuilder: (group, style) => {
    const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, style)]);

    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }

    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }

    return node;
  }
});

defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser }, args, optArgs) {
    const index = optArgs[0];
    const body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  mathmlBuilder(group, style) {
    const { body, index } = group;
    return index
      ? new mathMLTree.MathNode("mroot", [
        buildGroup$1(body, style),
        buildGroup$1(index, style.incrementLevel())
      ])
    : new mathMLTree.MathNode("msqrt", [buildGroup$1(body, style)]);
  }
});

const styleMap = {
  display: 0,
  text: 1,
  script: 2,
  scriptscript: 3
};

const styleAttributes = {
  display: ["0", "true"],
  text: ["0", "false"],
  script: ["1", "false"],
  scriptscript: ["2", "false"]
};

defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ breakOnTokenText, funcName, parser }, args) {
    // parse out the implicit body
    const body = parser.parseExpression(true, breakOnTokenText, true);

    const scriptLevel = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what scriptLevel to use by pulling out the scriptLevel from
      // the function name
      scriptLevel,
      body
    };
  },
  mathmlBuilder(group, style) {
    // Figure out what scriptLevel we're changing to.
    const newStyle = style.withLevel(styleMap[group.scriptLevel]);
    // The style argument in the next line does NOT directly set a MathML script level.
    // It just tracks the style level, in case we need to know it for supsub or mathchoice.
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);

    const attr = styleAttributes[group.scriptLevel];

    // Here is where we set the MathML script level.
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
  }
});

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */

// Helpers
const symbolRegEx = /^m(over|under|underover)$/;

// Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.
defineFunctionBuilders({
  type: "supsub",
  mathmlBuilder(group, style) {
    // Is the inner group a relevant horizontal brace?
    let isBrace = false;
    let isOver;
    let isSup;
    let appendApplyFunction = false;
    let appendSpace = false;
    let needsLeadingSpace = false;

    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }

    if (group.base && !group.base.stack &&
      (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
      appendApplyFunction = !group.base.symbol;
      appendSpace = appendApplyFunction && !group.isFollowedByDelimiter;
      needsLeadingSpace = group.base.needsLeadingSpace;
    }

    const children = group.base && group.base.stack
      ? [buildGroup$1(group.base.body[0], style)]
      : [buildGroup$1(group.base, style)];

    // Note regarding scriptstyle level.
    // (Sub|super)scripts should not shrink beyond MathML scriptlevel 2 aka \scriptscriptstyle
    // Ref: https://w3c.github.io/mathml-core/#the-displaystyle-and-scriptlevel-attributes
    // (BTW, MathML scriptlevel 2 is equal to Temml level 3.)
    // But Chromium continues to shrink the (sub|super)scripts. So we explicitly set scriptlevel 2.

    const childStyle = style.inSubOrSup();
    if (group.sub) {
      const sub = buildGroup$1(group.sub, childStyle);
      if (style.level === 3) { sub.setAttribute("scriptlevel", "2"); }
      children.push(sub);
    }

    if (group.sup) {
      const sup = buildGroup$1(group.sup, childStyle);
      if (style.level === 3) { sup.setAttribute("scriptlevel", "2"); }
      const testNode = sup.type === "mrow" ? sup.children[0] : sup;
      if ((testNode && testNode.type === "mo" && testNode.classes.includes("tml-prime"))
        && group.base && group.base.text && "fF".indexOf(group.base.text) > -1) {
        // Chromium does not address italic correction on prime.  Prevent f′ from overlapping.
        testNode.classes.push("prime-pad");
      }
      children.push(sup);
    }

    let nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "mover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munder";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      const base = group.base;
      if (base && ((base.type === "op" && base.limits) || base.type === "multiscript") &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munderover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (style.level === StyleLevel.DISPLAY || base.limits)
      ) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }

    let node = new mathMLTree.MathNode(nodeType, children);
    if (appendApplyFunction) {
      // Append an <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      if (needsLeadingSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node = mathMLTree.newDocumentFragment([space, node, operator]);
      } else {
        node = mathMLTree.newDocumentFragment([node, operator]);
      }
      if (appendSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node.children.push(space);
      }
    } else if (symbolRegEx.test(nodeType)) {
      // Wrap in a <mrow>. Otherwise Firefox stretchy parens will not stretch to include limits.
      node = new mathMLTree.MathNode("mrow", [node]);
    }

    return node
  }
});

// Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.

const short = ["\\shortmid", "\\nshortmid", "\\shortparallel",
  "\\nshortparallel", "\\smallsetminus"];

const arrows = ["\\Rsh", "\\Lsh", "\\restriction"];

const isArrow = str => {
  if (str.length === 1) {
    const codePoint = str.codePointAt(0);
    return (0x218f < codePoint && codePoint < 0x2200)
  }
  return str.indexOf("arrow") > -1 || str.indexOf("harpoon") > -1 || arrows.includes(str)
};

defineFunctionBuilders({
  type: "atom",
  mathmlBuilder(group, style) {
    const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      // Delims built here should not stretch vertically.
      // See delimsizing.js for stretchy delims.
      if (group.family === "open") {
        node.setAttribute("form", "prefix");
        // Set an explicit attribute for stretch. Otherwise Firefox may do it wrong.
        node.setAttribute("stretchy", "false");
      } else if (group.family === "close") {
        node.setAttribute("form", "postfix");
        node.setAttribute("stretchy", "false");
      }
    } else if (group.text === "\\mid") {
      // Firefox messes up this spacing if at the end of an <mrow>. See it explicitly.
      node.setAttribute("lspace", "0.22em"); // medium space
      node.setAttribute("rspace", "0.22em");
      node.setAttribute("stretchy", "false");
    } else if (group.family === "rel" && isArrow(group.text)) {
      node.setAttribute("stretchy", "false");
    } else if (short.includes(group.text)) {
      node.setAttribute("mathsize", "70%");
    } else if (group.text === ":") {
      // ":" is not in the MathML operator dictionary. Give it BIN spacing.
      node.attributes.lspace = "0.2222em";
      node.attributes.rspace = "0.2222em";
    } else if (group.needsSpacing) {
      // Fix a MathML bug that occurs when a <mo> is between two <mtext> elements.
      if (group.family === "bin") {
        return new mathMLTree.MathNode("mrow", [padding$1(0.222), node, padding$1(0.222)])
      } else {
        // REL spacing
        return new mathMLTree.MathNode("mrow", [padding$1(0.2778), node, padding$1(0.2778)])
      }
    }
    return node;
  }
});

/**
 * Maps TeX font commands to "mathvariant" attribute in buildMathML.js
 */
const fontMap = {
  // styles
  mathbf: "bold",
  mathrm: "normal",
  textit: "italic",
  mathit: "italic",
  mathnormal: "italic",

  // families
  mathbb: "double-struck",
  mathcal: "script",
  mathfrak: "fraktur",
  mathscr: "script",
  mathsf: "sans-serif",
  mathtt: "monospace"
};

/**
 * Returns the math variant as a string or null if none is required.
 */
const getVariant = function(group, style) {
  // Handle font specifiers as best we can.
  // Chromium does not support the MathML mathvariant attribute.
  // So we'll use Unicode replacement characters instead.
  // But first, determine the math variant.

  // Deal with the \textit, \textbf, etc., functions.
  if (style.fontFamily === "texttt") {
    return "monospace"
  } else if (style.fontFamily === "textsc") {
    return "normal"; // handled via character substitution in symbolsOrd.js.
  } else if (style.fontFamily === "textsf") {
    if (style.fontShape === "textit" && style.fontWeight === "textbf") {
      return "sans-serif-bold-italic"
    } else if (style.fontShape === "textit") {
      return "sans-serif-italic"
    } else if (style.fontWeight === "textbf") {
      return "sans-serif-bold"
    } else {
      return "sans-serif"
    }
  } else if (style.fontShape === "textit" && style.fontWeight === "textbf") {
    return "bold-italic"
  } else if (style.fontShape === "textit") {
    return "italic"
  } else if (style.fontWeight === "textbf") {
    return "bold"
  }

  // Deal with the \mathit, mathbf, etc, functions.
  const font = style.font;
  if (!font || font === "mathnormal") {
    return null
  }

  const mode = group.mode;
  switch (font) {
    case "mathit":
      return "italic"
    case "mathrm": {
      const codePoint = group.text.codePointAt(0);
      // LaTeX \mathrm returns italic for Greek characters.
      return  (0x03ab < codePoint && codePoint < 0x03cf) ? "italic" : "normal"
    }
    case "greekItalic":
      return "italic"
    case "up@greek":
      return "normal"
    case "boldsymbol":
    case "mathboldsymbol":
      return "bold-italic"
    case "mathbf":
      return "bold"
    case "mathbb":
      return "double-struck"
    case "mathfrak":
      return "fraktur"
    case "mathscr":
    case "mathcal":
      return "script"
    case "mathsf":
      return "sans-serif"
    case "mathsfit":
      return "sans-serif-italic"
    case "mathtt":
      return "monospace"
  }

  let text = group.text;
  if (symbols[mode][text] && symbols[mode][text].replace) {
    text = symbols[mode][text].replace;
  }

  return Object.prototype.hasOwnProperty.call(fontMap, font) ? fontMap[font] : null
};

// Chromium does not support the MathML `mathvariant` attribute.
// Instead, we replace ASCII characters with Unicode characters that
// are defined in the font as bold, italic, double-struck, etc.
// This module identifies those Unicode code points.

// First, a few helpers.
const script = Object.freeze({
  B: 0x20EA, // Offset from ASCII B to Unicode script B
  E: 0x20EB,
  F: 0x20EB,
  H: 0x20C3,
  I: 0x20C7,
  L: 0x20C6,
  M: 0x20E6,
  R: 0x20C9,
  e: 0x20CA,
  g: 0x20A3,
  o: 0x20C5
});

const frak = Object.freeze({
  C: 0x20EA,
  H: 0x20C4,
  I: 0x20C8,
  R: 0x20CA,
  Z: 0x20CE
});

const bbb = Object.freeze({
  C: 0x20BF, // blackboard bold
  H: 0x20C5,
  N: 0x20C7,
  P: 0x20C9,
  Q: 0x20C9,
  R: 0x20CB,
  Z: 0x20CA
});

const bold = Object.freeze({
  "\u03f5": 0x1D2E7, // lunate epsilon
  "\u03d1": 0x1D30C, // vartheta
  "\u03f0": 0x1D2EE, // varkappa
  "\u03c6": 0x1D319, // varphi
  "\u03f1": 0x1D2EF, // varrho
  "\u03d6": 0x1D30B  // varpi
});

const boldItalic = Object.freeze({
  "\u03f5": 0x1D35B, // lunate epsilon
  "\u03d1": 0x1D380, // vartheta
  "\u03f0": 0x1D362, // varkappa
  "\u03c6": 0x1D38D, // varphi
  "\u03f1": 0x1D363, // varrho
  "\u03d6": 0x1D37F  // varpi
});

const boldsf = Object.freeze({
  "\u03f5": 0x1D395, // lunate epsilon
  "\u03d1": 0x1D3BA, // vartheta
  "\u03f0": 0x1D39C, // varkappa
  "\u03c6": 0x1D3C7, // varphi
  "\u03f1": 0x1D39D, // varrho
  "\u03d6": 0x1D3B9  // varpi
});

const bisf = Object.freeze({
  "\u03f5": 0x1D3CF, // lunate epsilon
  "\u03d1": 0x1D3F4, // vartheta
  "\u03f0": 0x1D3D6, // varkappa
  "\u03c6": 0x1D401, // varphi
  "\u03f1": 0x1D3D7, // varrho
  "\u03d6": 0x1D3F3  // varpi
});

// Code point offsets below are derived from https://www.unicode.org/charts/PDF/U1D400.pdf
const offset = Object.freeze({
  upperCaseLatin: { // A-Z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3BF },
    "italic": ch =>                 { return 0x1D3F3 },
    "bold-italic": ch =>            { return 0x1D427 },
    "script": ch =>                 { return script[ch] || 0x1D45B },
    "script-bold": ch =>            { return 0x1D48F },
    "fraktur": ch =>                { return frak[ch] || 0x1D4C3 },
    "fraktur-bold": ch =>           { return 0x1D52B },
    "double-struck": ch =>          { return bbb[ch] || 0x1D4F7 },
    "sans-serif": ch =>             { return 0x1D55F },
    "sans-serif-bold": ch =>        { return 0x1D593 },
    "sans-serif-italic": ch =>      { return 0x1D5C7 },
    "sans-serif-bold-italic": ch => { return 0x1D63C },
    "monospace": ch =>              { return 0x1D62F }
  },
  lowerCaseLatin: { // a-z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3B9 },
    "italic": ch =>                 { return ch === "h" ? 0x20A6 : 0x1D3ED },
    "bold-italic": ch =>            { return 0x1D421 },
    "script": ch =>                 { return script[ch] || 0x1D455 },
    "script-bold": ch =>            { return 0x1D489 },
    "fraktur": ch =>                { return 0x1D4BD },
    "fraktur-bold": ch =>           { return 0x1D525 },
    "double-struck": ch =>          { return 0x1D4F1 },
    "sans-serif": ch =>             { return 0x1D559 },
    "sans-serif-bold": ch =>        { return 0x1D58D },
    "sans-serif-italic": ch =>      { return 0x1D5C1 },
    "sans-serif-bold-italic": ch => { return 0x1D5F5 },
    "monospace": ch =>              { return 0x1D629 }
  },
  upperCaseGreek: { // A-Ω
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D317 },
    "italic": ch =>                 { return 0x1D351 },
    // \boldsymbol actually returns upright bold for upperCaseGreek
    "bold-italic": ch =>            { return 0x1D317 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3C5 },
    "sans-serif-bold": ch =>        { return 0x1D3C5 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3FF },
    "monospace": ch =>              { return 0 }
  },
  lowerCaseGreek: { // α-ω
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D311 },
    "italic": ch =>                 { return 0x1D34B },
    "bold-italic": ch =>            { return ch === "\u03d5" ? 0x1D37E : 0x1D385 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3BF },
    "sans-serif-bold": ch =>        { return 0x1D3BF },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3F9 },
    "monospace": ch =>              { return 0 }
  },
  varGreek: { // \varGamma, etc
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return  bold[ch] || -51 },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return boldItalic[ch] || 0x3A },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    "sans-serif": ch =>             { return boldsf[ch] || 0x74 },
    "sans-serif-bold": ch =>        { return boldsf[ch] || 0x74 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return bisf[ch] || 0xAE },
    "monospace": ch =>              { return 0 }
  },
  numeral: { // 0-9
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D79E },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return 0 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0x1D7A8 },
    "sans-serif": ch =>             { return 0x1D7B2 },
    "sans-serif-bold": ch =>        { return 0x1D7BC },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0 },
    "monospace": ch =>              { return 0x1D7C6 }
  }
});

const variantChar = (ch, variant) => {
  const codePoint = ch.codePointAt(0);
  const block = 0x40 < codePoint && codePoint < 0x5b
    ? "upperCaseLatin"
    : 0x60 < codePoint && codePoint < 0x7b
    ? "lowerCaseLatin"
    : (0x390  < codePoint && codePoint < 0x3AA)
    ? "upperCaseGreek"
    : 0x3B0 < codePoint && codePoint < 0x3CA || ch === "\u03d5"
    ? "lowerCaseGreek"
    : 0x1D6E1 < codePoint && codePoint < 0x1D6FC  || bold[ch]
    ? "varGreek"
    : (0x2F < codePoint && codePoint <  0x3A)
    ? "numeral"
    : "other";
  return block === "other"
    ? ch
    : String.fromCodePoint(codePoint + offset[block][variant](ch))
};

const smallCaps = Object.freeze({
  a: "ᴀ",
  b: "ʙ",
  c: "ᴄ",
  d: "ᴅ",
  e: "ᴇ",
  f: "ꜰ",
  g: "ɢ",
  h: "ʜ",
  i: "ɪ",
  j: "ᴊ",
  k: "ᴋ",
  l: "ʟ",
  m: "ᴍ",
  n: "ɴ",
  o: "ᴏ",
  p: "ᴘ",
  q: "ǫ",
  r: "ʀ",
  s: "s",
  t: "ᴛ",
  u: "ᴜ",
  v: "ᴠ",
  w: "ᴡ",
  x: "x",
  y: "ʏ",
  z: "ᴢ"
});

// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
// src/symbols.js.

const numberRegEx = /^\d(?:[\d,.]*\d)?$/;
const latinRegEx = /[A-Ba-z]/;
const primes = new Set(["\\prime", "\\dprime", "\\trprime", "\\qprime",
  "\\backprime", "\\backdprime", "\\backtrprime"]);

const italicNumber = (text, variant, tag) => {
  const mn = new mathMLTree.MathNode(tag, [text]);
  const wrapper = new mathMLTree.MathNode("mstyle", [mn]);
  wrapper.style["font-style"] = "italic";
  wrapper.style["font-family"] = "Cambria, 'Times New Roman', serif";
  if (variant === "bold-italic") { wrapper.style["font-weight"] = "bold"; }
  return wrapper
};

defineFunctionBuilders({
  type: "mathord",
  mathmlBuilder(group, style) {
    const text = makeText(group.text, group.mode, style);
    const codePoint = text.text.codePointAt(0);
    // Test for upper-case Greek
    const defaultVariant = (0x0390 < codePoint && codePoint < 0x03aa) ? "normal" : "italic";
    const variant = getVariant(group, style) || defaultVariant;
    if (variant === "script") {
      text.text = variantChar(text.text, variant);
      return new mathMLTree.MathNode("mi", [text], [style.font])
    } else if (variant !== "italic") {
      text.text = variantChar(text.text, variant);
    }
    let node = new mathMLTree.MathNode("mi", [text]);
    // TODO: Handle U+1D49C - U+1D4CF per https://www.unicode.org/charts/PDF/U1D400.pdf
    if (variant === "normal") {
      node.setAttribute("mathvariant", "normal");
      if (text.text.length === 1) {
        // A Firefox bug will apply spacing here, but there should be none. Fix it.
        node = new mathMLTree.MathNode("mpadded", [node]);
        node.setAttribute("lspace", "0");
        node.setAttribute("rspace", "0");
      }
    }
    return node
  }
});

defineFunctionBuilders({
  type: "textord",
  mathmlBuilder(group, style) {
    let ch = group.text;
    const codePoint = ch.codePointAt(0);
    if (style.fontFamily === "textsc") {
      // Convert small latin letters to small caps.
      if (96 < codePoint && codePoint < 123) {
        ch = smallCaps[ch];
      }
    }
    const text = makeText(ch, group.mode, style);
    const variant = getVariant(group, style) || "normal";

    let node;
    if (numberRegEx.test(group.text)) {
      const tag = group.mode === "text" ? "mtext" : "mn";
      if (variant === "italic" || variant === "bold-italic") {
        return italicNumber(text, variant, tag)
      } else {
        if (variant !== "normal") {
          text.text = text.text.split("").map(c => variantChar(c, variant)).join("");
        }
        node = new mathMLTree.MathNode(tag, [text]);
      }
    } else if (group.mode === "text") {
      if (variant !== "normal") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mtext", [text]);
    } else if (primes.has(group.text)) {
      node = new mathMLTree.MathNode("mo", [text]);
      // TODO: If/when Chromium uses ssty variant for prime, remove the next line.
      node.classes.push("tml-prime");
    } else {
      const origText = text.text;
      if (variant !== "italic") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mi", [text]);
      if (text.text === origText && latinRegEx.test(origText)) {
        node.setAttribute("mathvariant", "italic");
      }
    }
    return node
  }
});

// A map of CSS-based spacing functions to their CSS class.
const cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};

// A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.
const regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};

// ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.
defineFunctionBuilders({
  type: "spacing",
  mathmlBuilder(group, style) {
    let node;

    if (Object.prototype.hasOwnProperty.call(regularSpace, group.text)) {
      // Firefox does not render a space in a <mtext> </mtext>. So write a no-break space.
      // TODO: If Firefox fixes that bug, uncomment the next line and write ch into the node.
      //const ch = (regularSpace[group.text].className === "nobreak") ? "\u00a0" : " "
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else if (Object.prototype.hasOwnProperty.call(cssSpace, group.text)) {
      // MathML 3.0 calls for nobreak to occur in an <mo>, not an <mtext>
      // Ref: https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs
      node = new mathMLTree.MathNode("mo");
      if (group.text === "\\nobreak") {
        node.setAttribute("linebreak", "nobreak");
      }
    } else {
      throw new ParseError(`Unknown type of space "${group.text}"`)
    }

    return node
  }
});

defineFunctionBuilders({
  type: "tag"
});

// For a \tag, the work usually done in a mathmlBuilder is instead done in buildMathML.js.
// That way, a \tag can be pulled out of the parse tree and wrapped around the outer node.

// Non-mathy text, possibly in a font
const textFontFamilies = {
  "\\text": undefined,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm",
  "\\textsc": "textsc"      // small caps
};

const textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};

const textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};

const styleWithFont = (group, style) => {
  const font = group.font;
  // Checks if the argument is a font family or a font style.
  if (!font) {
    return style;
  } else if (textFontFamilies[font]) {
    return style.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return style.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return style.fontShape === "textit"
      ? style.withTextFontShape("textup")
      : style.withTextFontShape("textit")
  }
  return style.withTextFontShape(textFontShapes[font])
};

defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    "\\textsc",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = styleWithFont(group, style);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

// \vcenter:  Vertically center the argument group on the math axis.

defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    // Use a math table to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.body, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    return new mathMLTree.MathNode("mtable", [mtr])
  }
});

defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    // \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  mathmlBuilder(group, style) {
    const text = new mathMLTree.TextNode(makeVerb(group));
    const node = new mathMLTree.MathNode("mtext", [text]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});

/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */
const makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");

/** Include this to ensure that all functions are defined. */

const functions = _functions;

/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */


/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first two groups
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - mathches numerals
 * - matches a backslash followed by one or more whitespace characters
 * - matches a backslash followed by one or more letters then whitespace
 * - matches a backslash followed by any BMP character
 * Capturing groups:
 *   [1] regular whitespace
 *   [2] backslash followed by whitespace
 *   [3] anything else, which may include:
 *     [4] left character of \verb*
 *     [5] left character of \verb
 *     [6] backslash followed by word, excluding any trailing whitespace
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
const spaceRegexString = "[ \r\n\t]";
const controlWordRegexString = "\\\\[a-zA-Z@]+";
const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
const controlWordWhitespaceRegexString = `(${controlWordRegexString})${spaceRegexString}*`;
const controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
const combiningDiacriticalMarkString = "[\u0300-\u036f]";
const combiningDiacriticalMarksEndRegex = new RegExp(`${combiningDiacriticalMarkString}+$`);
const tokenRegexString =
  `(${spaceRegexString}+)|` + // whitespace
  `${controlSpaceRegexString}|` +  // whitespace
  "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|\\\\verb\\*([^]).*?\\4" + // \verb*
  "|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
  `|${controlWordWhitespaceRegexString}` + // \macroName + spaces
  `|${controlSymbolRegexString})`; // \\, \', etc.

/** Main Lexer class */
class Lexer {
  constructor(input, settings) {
    // Separate accents from characters
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, 'g');
    // Category codes. The lexer only supports comment characters (14) for now.
    // MacroExpander additionally distinguishes active (13).
    this.catcodes = {
      "%": 14, // comment character
      "~": 13  // active character
    };
  }

  setCatcode(char, code) {
    this.catcodes[char] = code;
  }

  /**
   * This function lexes a single token.
   */
  lex() {
    const input = this.input;
    const pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    const match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError(
        `Unexpected character: '${input[pos]}'`,
        new Token(input[pos], new SourceLocation(this, pos, pos + 1))
      );
    }
    const text = match[6] || match[3] || (match[2] ? "\\ " : " ");

    if (this.catcodes[text] === 14) {
      // comment character
      const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length; // EOF
        if (this.settings.strict) {
          throw new ParseError("% comment has no terminating newline; LaTeX would " +
              "fail because of commenting the end of math mode")
        }
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }

    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}

/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */


class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins = {}, globalMacros = {}) {
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }

  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }

  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError(
        "Unbalanced namespace destruction: attempt " +
          "to pop global namespace; please report this as a bug"
      );
    }
    const undefs = this.undefStack.pop();
    for (const undef in undefs) {
      if (Object.prototype.hasOwnProperty.call(undefs, undef )) {
        if (undefs[undef] === undefined) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }

  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.current, name ) ||
    Object.prototype.hasOwnProperty.call(this.builtins, name );
  }

  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (Object.prototype.hasOwnProperty.call(this.current, name )) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }

  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   */
  set(name, value, global = false) {
    if (global) {
      // Global set is equivalent to setting in all groups.  Simulate this
      // by destroying any undos currently scheduled for this name,
      // and adding an undo with the *new* value (in case it later gets
      // locally reset within this environment).
      for (let i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      // Undo this set at end of this group (possibly to `undefined`),
      // unless an undo is already in place, in which case that older
      // value is the correct one.
      const top = this.undefStack[this.undefStack.length - 1];
      if (top && !Object.prototype.hasOwnProperty.call(top, name )) {
        top[name] = this.current[name];
      }
    }
    this.current[name] = value;
  }
}

/**
 * This file contains the “gullet” where macros are expanded
 * until only non-macro tokens remain.
 */


// List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
const implicitCommands = {
  "^": true, // Parser.js
  _: true, // Parser.js
  "\\limits": true, // Parser.js
  "\\nolimits": true // Parser.js
};

class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    // Make new global namespace
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = []; // contains tokens in REVERSE order
  }

  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }

  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }

  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }

  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1]
  }

  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future(); // ensure non-empty stack
    return this.stack.pop();
  }

  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }

  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }

  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    let start;
    let end;
    let tokens;
    if (isOptional) {
      this.consumeSpaces(); // \@ifnextchar gobbles any space following it
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken(); // don't include [ in tokens
      ({ tokens, end } = this.consumeArg(["]"]));
    } else {
      ({ tokens, start, end } = this.consumeArg());
    }

    // indicate the end of an argument
    this.pushToken(new Token("EOF", end.loc));

    this.pushTokens(tokens);
    return start.range(end, "");
  }

  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (;;) {
      const token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }

  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    // The argument for a delimited parameter is the shortest (possibly
    // empty) sequence of tokens with properly nested {...} groups that is
    // followed ... by this particular list of non-parameter tokens.
    // The argument for an undelimited parameter is the next nonblank
    // token, unless that token is ‘{’, when the argument will be the
    // entire {...} group that follows.
    const tokens = [];
    const isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      // Ignore spaces between arguments.  As the TeXbook says:
      // "After you have said ‘\def\row#1#2{...}’, you are allowed to
      //  put spaces between the arguments (e.g., ‘\row x n’), because
      //  TeX doesn’t use single spaces as undelimited arguments."
      this.consumeSpaces();
    }
    const start = this.future();
    let tok;
    let depth = 0;
    let match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError(
          "Unexpected end of input in a macro argument" +
            ", expected '" +
            (delims && isDelimited ? delims[match] : "}") +
            "'",
          tok
        );
      }
      if (delims && isDelimited) {
        if ((depth === 0 || (depth === 1 && delims[match] === "{")) && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            // don't include delims in tokens
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    // If the argument found ... has the form ‘{<nested tokens>}’,
    // ... the outermost braces enclosing the argument are removed
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse(); // to fit in with stack order
    return { tokens, start, end: tok };
  }

  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters) {
    if (delimiters) {
      if (delimiters.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      const delims = delimiters[0];
      for (let i = 0; i < delims.length; i++) {
        const tok = this.popToken();
        if (delims[i] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }

    const args = [];
    for (let i = 0; i < numArgs; i++) {
      args.push(this.consumeArg(delimiters && delimiters[i + 1]).tokens);
    }
    return args;
  }

  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    const topToken = this.popToken();
    const name = topToken.text;
    const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || (expandableOnly && expansion.unexpandable)) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.expansionCount++;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError(
        "Too many expansions: infinite loop or " + "need to increase maxExpand setting"
      );
    }
    let tokens = expansion.tokens;
    const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      // paste arguments in place of the placeholders
      tokens = tokens.slice(); // make a shallow copy
      for (let i = tokens.length - 1; i >= 0; --i) {
        let tok = tokens[i];
        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i]; // next token on stack
          if (tok.text === "#") {
            // ## → #
            tokens.splice(i + 1, 1); // drop first #
          } else if (/^[1-9]$/.test(tok.text)) {
            // replace the placeholder with the indicated argument
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    // Concatenate expansion onto top of stack.
    this.pushTokens(tokens);
    return tokens.length;
  }

  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }

  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (;;) {
      if (this.expandOnce() === false) { // fully expanded
        const token = this.stack.pop();
        // The token after \noexpand is interpreted as if its meaning were ‘\relax’
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token
      }
    }

    // This pathway is impossible.
    throw new Error(); // eslint-disable-line no-unreachable
  }

  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
  }

  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    const output = [];
    const oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      // Expand only expandable tokens
      if (this.expandOnce(true) === false) {  // fully expanded
        const token = this.stack.pop();
        if (token.treatAsRelax) {
          // the expansion of \noexpand is the token itself
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    return output;
  }

  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    const tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }

  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    const definition = this.macros.get(name);
    if (definition == null) {
      // mainly checking for undefined here
      return definition;
    }
    // If a single character has an associated catcode other than 13
    // (active character), then don't expand it.
    if (name.length === 1) {
      const catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return
      }
    }
    const expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      let numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        const stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      const bodyLexer = new Lexer(expansion, this.settings);
      const tokens = [];
      let tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse(); // to fit in with stack using push and pop
      const expanded = { tokens, numArgs };
      return expanded;
    }

    return expansion;
  }

  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return (
      this.macros.has(name) ||
      Object.prototype.hasOwnProperty.call(functions, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.math, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.text, name ) ||
      Object.prototype.hasOwnProperty.call(implicitCommands, name )
    );
  }

  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    const macro = this.macros.get(name);
    return macro != null
      ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable
      : Object.prototype.hasOwnProperty.call(functions, name ) && !functions[name].primitive;
  }
}

// Helpers for Parser.js handling of Unicode (sub|super)script characters.

const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;

const uSubsAndSups = Object.freeze({
  '₊': '+',
  '₋': '-',
  '₌': '=',
  '₍': '(',
  '₎': ')',
  '₀': '0',
  '₁': '1',
  '₂': '2',
  '₃': '3',
  '₄': '4',
  '₅': '5',
  '₆': '6',
  '₇': '7',
  '₈': '8',
  '₉': '9',
  '\u2090': 'a',
  '\u2091': 'e',
  '\u2095': 'h',
  '\u1D62': 'i',
  '\u2C7C': 'j',
  '\u2096': 'k',
  '\u2097': 'l',
  '\u2098': 'm',
  '\u2099': 'n',
  '\u2092': 'o',
  '\u209A': 'p',
  '\u1D63': 'r',
  '\u209B': 's',
  '\u209C': 't',
  '\u1D64': 'u',
  '\u1D65': 'v',
  '\u2093': 'x',
  '\u1D66': 'β',
  '\u1D67': 'γ',
  '\u1D68': 'ρ',
  '\u1D69': '\u03d5',
  '\u1D6A': 'χ',
  '⁺': '+',
  '⁻': '-',
  '⁼': '=',
  '⁽': '(',
  '⁾': ')',
  '⁰': '0',
  '¹': '1',
  '²': '2',
  '³': '3',
  '⁴': '4',
  '⁵': '5',
  '⁶': '6',
  '⁷': '7',
  '⁸': '8',
  '⁹': '9',
  '\u1D2C': 'A',
  '\u1D2E': 'B',
  '\u1D30': 'D',
  '\u1D31': 'E',
  '\u1D33': 'G',
  '\u1D34': 'H',
  '\u1D35': 'I',
  '\u1D36': 'J',
  '\u1D37': 'K',
  '\u1D38': 'L',
  '\u1D39': 'M',
  '\u1D3A': 'N',
  '\u1D3C': 'O',
  '\u1D3E': 'P',
  '\u1D3F': 'R',
  '\u1D40': 'T',
  '\u1D41': 'U',
  '\u2C7D': 'V',
  '\u1D42': 'W',
  '\u1D43': 'a',
  '\u1D47': 'b',
  '\u1D9C': 'c',
  '\u1D48': 'd',
  '\u1D49': 'e',
  '\u1DA0': 'f',
  '\u1D4D': 'g',
  '\u02B0': 'h',
  '\u2071': 'i',
  '\u02B2': 'j',
  '\u1D4F': 'k',
  '\u02E1': 'l',
  '\u1D50': 'm',
  '\u207F': 'n',
  '\u1D52': 'o',
  '\u1D56': 'p',
  '\u02B3': 'r',
  '\u02E2': 's',
  '\u1D57': 't',
  '\u1D58': 'u',
  '\u1D5B': 'v',
  '\u02B7': 'w',
  '\u02E3': 'x',
  '\u02B8': 'y',
  '\u1DBB': 'z',
  '\u1D5D': 'β',
  '\u1D5E': 'γ',
  '\u1D5F': 'δ',
  '\u1D60': '\u03d5',
  '\u1D61': 'χ',
  '\u1DBF': 'θ'
});

// Used for Unicode input of calligraphic and script letters
const asciiFromScript = Object.freeze({
  "\ud835\udc9c": "A",
  "\u212c": "B",
  "\ud835\udc9e": "C",
  "\ud835\udc9f": "D",
  "\u2130": "E",
  "\u2131": "F",
  "\ud835\udca2": "G",
  "\u210B": "H",
  "\u2110": "I",
  "\ud835\udca5": "J",
  "\ud835\udca6": "K",
  "\u2112": "L",
  "\u2133": "M",
  "\ud835\udca9": "N",
  "\ud835\udcaa": "O",
  "\ud835\udcab": "P",
  "\ud835\udcac": "Q",
  "\u211B": "R",
  "\ud835\udcae": "S",
  "\ud835\udcaf": "T",
  "\ud835\udcb0": "U",
  "\ud835\udcb1": "V",
  "\ud835\udcb2": "W",
  "\ud835\udcb3": "X",
  "\ud835\udcb4": "Y",
  "\ud835\udcb5": "Z"
});

// Mapping of Unicode accent characters to their LaTeX equivalent in text and
// math mode (when they exist).
var unicodeAccents = {
  "\u0301": { text: "\\'", math: "\\acute" },
  "\u0300": { text: "\\`", math: "\\grave" },
  "\u0308": { text: '\\"', math: "\\ddot" },
  "\u0303": { text: "\\~", math: "\\tilde" },
  "\u0304": { text: "\\=", math: "\\bar" },
  "\u0306": { text: "\\u", math: "\\breve" },
  "\u030c": { text: "\\v", math: "\\check" },
  "\u0302": { text: "\\^", math: "\\hat" },
  "\u0307": { text: "\\.", math: "\\dot" },
  "\u030a": { text: "\\r", math: "\\mathring" },
  "\u030b": { text: "\\H" },
  '\u0327': { text: '\\c' }
};

var unicodeSymbols = {
  "á": "á",
  "à": "à",
  "ä": "ä",
  "ǟ": "ǟ",
  "ã": "ã",
  "ā": "ā",
  "ă": "ă",
  "ắ": "ắ",
  "ằ": "ằ",
  "ẵ": "ẵ",
  "ǎ": "ǎ",
  "â": "â",
  "ấ": "ấ",
  "ầ": "ầ",
  "ẫ": "ẫ",
  "ȧ": "ȧ",
  "ǡ": "ǡ",
  "å": "å",
  "ǻ": "ǻ",
  "ḃ": "ḃ",
  "ć": "ć",
  "č": "č",
  "ĉ": "ĉ",
  "ċ": "ċ",
  "ď": "ď",
  "ḋ": "ḋ",
  "é": "é",
  "è": "è",
  "ë": "ë",
  "ẽ": "ẽ",
  "ē": "ē",
  "ḗ": "ḗ",
  "ḕ": "ḕ",
  "ĕ": "ĕ",
  "ě": "ě",
  "ê": "ê",
  "ế": "ế",
  "ề": "ề",
  "ễ": "ễ",
  "ė": "ė",
  "ḟ": "ḟ",
  "ǵ": "ǵ",
  "ḡ": "ḡ",
  "ğ": "ğ",
  "ǧ": "ǧ",
  "ĝ": "ĝ",
  "ġ": "ġ",
  "ḧ": "ḧ",
  "ȟ": "ȟ",
  "ĥ": "ĥ",
  "ḣ": "ḣ",
  "í": "í",
  "ì": "ì",
  "ï": "ï",
  "ḯ": "ḯ",
  "ĩ": "ĩ",
  "ī": "ī",
  "ĭ": "ĭ",
  "ǐ": "ǐ",
  "î": "î",
  "ǰ": "ǰ",
  "ĵ": "ĵ",
  "ḱ": "ḱ",
  "ǩ": "ǩ",
  "ĺ": "ĺ",
  "ľ": "ľ",
  "ḿ": "ḿ",
  "ṁ": "ṁ",
  "ń": "ń",
  "ǹ": "ǹ",
  "ñ": "ñ",
  "ň": "ň",
  "ṅ": "ṅ",
  "ó": "ó",
  "ò": "ò",
  "ö": "ö",
  "ȫ": "ȫ",
  "õ": "õ",
  "ṍ": "ṍ",
  "ṏ": "ṏ",
  "ȭ": "ȭ",
  "ō": "ō",
  "ṓ": "ṓ",
  "ṑ": "ṑ",
  "ŏ": "ŏ",
  "ǒ": "ǒ",
  "ô": "ô",
  "ố": "ố",
  "ồ": "ồ",
  "ỗ": "ỗ",
  "ȯ": "ȯ",
  "ȱ": "ȱ",
  "ő": "ő",
  "ṕ": "ṕ",
  "ṗ": "ṗ",
  "ŕ": "ŕ",
  "ř": "ř",
  "ṙ": "ṙ",
  "ś": "ś",
  "ṥ": "ṥ",
  "š": "š",
  "ṧ": "ṧ",
  "ŝ": "ŝ",
  "ṡ": "ṡ",
  "ẗ": "ẗ",
  "ť": "ť",
  "ṫ": "ṫ",
  "ú": "ú",
  "ù": "ù",
  "ü": "ü",
  "ǘ": "ǘ",
  "ǜ": "ǜ",
  "ǖ": "ǖ",
  "ǚ": "ǚ",
  "ũ": "ũ",
  "ṹ": "ṹ",
  "ū": "ū",
  "ṻ": "ṻ",
  "ŭ": "ŭ",
  "ǔ": "ǔ",
  "û": "û",
  "ů": "ů",
  "ű": "ű",
  "ṽ": "ṽ",
  "ẃ": "ẃ",
  "ẁ": "ẁ",
  "ẅ": "ẅ",
  "ŵ": "ŵ",
  "ẇ": "ẇ",
  "ẘ": "ẘ",
  "ẍ": "ẍ",
  "ẋ": "ẋ",
  "ý": "ý",
  "ỳ": "ỳ",
  "ÿ": "ÿ",
  "ỹ": "ỹ",
  "ȳ": "ȳ",
  "ŷ": "ŷ",
  "ẏ": "ẏ",
  "ẙ": "ẙ",
  "ź": "ź",
  "ž": "ž",
  "ẑ": "ẑ",
  "ż": "ż",
  "Á": "Á",
  "À": "À",
  "Ä": "Ä",
  "Ǟ": "Ǟ",
  "Ã": "Ã",
  "Ā": "Ā",
  "Ă": "Ă",
  "Ắ": "Ắ",
  "Ằ": "Ằ",
  "Ẵ": "Ẵ",
  "Ǎ": "Ǎ",
  "Â": "Â",
  "Ấ": "Ấ",
  "Ầ": "Ầ",
  "Ẫ": "Ẫ",
  "Ȧ": "Ȧ",
  "Ǡ": "Ǡ",
  "Å": "Å",
  "Ǻ": "Ǻ",
  "Ḃ": "Ḃ",
  "Ć": "Ć",
  "Č": "Č",
  "Ĉ": "Ĉ",
  "Ċ": "Ċ",
  "Ď": "Ď",
  "Ḋ": "Ḋ",
  "É": "É",
  "È": "È",
  "Ë": "Ë",
  "Ẽ": "Ẽ",
  "Ē": "Ē",
  "Ḗ": "Ḗ",
  "Ḕ": "Ḕ",
  "Ĕ": "Ĕ",
  "Ě": "Ě",
  "Ê": "Ê",
  "Ế": "Ế",
  "Ề": "Ề",
  "Ễ": "Ễ",
  "Ė": "Ė",
  "Ḟ": "Ḟ",
  "Ǵ": "Ǵ",
  "Ḡ": "Ḡ",
  "Ğ": "Ğ",
  "Ǧ": "Ǧ",
  "Ĝ": "Ĝ",
  "Ġ": "Ġ",
  "Ḧ": "Ḧ",
  "Ȟ": "Ȟ",
  "Ĥ": "Ĥ",
  "Ḣ": "Ḣ",
  "Í": "Í",
  "Ì": "Ì",
  "Ï": "Ï",
  "Ḯ": "Ḯ",
  "Ĩ": "Ĩ",
  "Ī": "Ī",
  "Ĭ": "Ĭ",
  "Ǐ": "Ǐ",
  "Î": "Î",
  "İ": "İ",
  "Ĵ": "Ĵ",
  "Ḱ": "Ḱ",
  "Ǩ": "Ǩ",
  "Ĺ": "Ĺ",
  "Ľ": "Ľ",
  "Ḿ": "Ḿ",
  "Ṁ": "Ṁ",
  "Ń": "Ń",
  "Ǹ": "Ǹ",
  "Ñ": "Ñ",
  "Ň": "Ň",
  "Ṅ": "Ṅ",
  "Ó": "Ó",
  "Ò": "Ò",
  "Ö": "Ö",
  "Ȫ": "Ȫ",
  "Õ": "Õ",
  "Ṍ": "Ṍ",
  "Ṏ": "Ṏ",
  "Ȭ": "Ȭ",
  "Ō": "Ō",
  "Ṓ": "Ṓ",
  "Ṑ": "Ṑ",
  "Ŏ": "Ŏ",
  "Ǒ": "Ǒ",
  "Ô": "Ô",
  "Ố": "Ố",
  "Ồ": "Ồ",
  "Ỗ": "Ỗ",
  "Ȯ": "Ȯ",
  "Ȱ": "Ȱ",
  "Ő": "Ő",
  "Ṕ": "Ṕ",
  "Ṗ": "Ṗ",
  "Ŕ": "Ŕ",
  "Ř": "Ř",
  "Ṙ": "Ṙ",
  "Ś": "Ś",
  "Ṥ": "Ṥ",
  "Š": "Š",
  "Ṧ": "Ṧ",
  "Ŝ": "Ŝ",
  "Ṡ": "Ṡ",
  "Ť": "Ť",
  "Ṫ": "Ṫ",
  "Ú": "Ú",
  "Ù": "Ù",
  "Ü": "Ü",
  "Ǘ": "Ǘ",
  "Ǜ": "Ǜ",
  "Ǖ": "Ǖ",
  "Ǚ": "Ǚ",
  "Ũ": "Ũ",
  "Ṹ": "Ṹ",
  "Ū": "Ū",
  "Ṻ": "Ṻ",
  "Ŭ": "Ŭ",
  "Ǔ": "Ǔ",
  "Û": "Û",
  "Ů": "Ů",
  "Ű": "Ű",
  "Ṽ": "Ṽ",
  "Ẃ": "Ẃ",
  "Ẁ": "Ẁ",
  "Ẅ": "Ẅ",
  "Ŵ": "Ŵ",
  "Ẇ": "Ẇ",
  "Ẍ": "Ẍ",
  "Ẋ": "Ẋ",
  "Ý": "Ý",
  "Ỳ": "Ỳ",
  "Ÿ": "Ÿ",
  "Ỹ": "Ỹ",
  "Ȳ": "Ȳ",
  "Ŷ": "Ŷ",
  "Ẏ": "Ẏ",
  "Ź": "Ź",
  "Ž": "Ž",
  "Ẑ": "Ẑ",
  "Ż": "Ż",
  "ά": "ά",
  "ὰ": "ὰ",
  "ᾱ": "ᾱ",
  "ᾰ": "ᾰ",
  "έ": "έ",
  "ὲ": "ὲ",
  "ή": "ή",
  "ὴ": "ὴ",
  "ί": "ί",
  "ὶ": "ὶ",
  "ϊ": "ϊ",
  "ΐ": "ΐ",
  "ῒ": "ῒ",
  "ῑ": "ῑ",
  "ῐ": "ῐ",
  "ό": "ό",
  "ὸ": "ὸ",
  "ύ": "ύ",
  "ὺ": "ὺ",
  "ϋ": "ϋ",
  "ΰ": "ΰ",
  "ῢ": "ῢ",
  "ῡ": "ῡ",
  "ῠ": "ῠ",
  "ώ": "ώ",
  "ὼ": "ὼ",
  "Ύ": "Ύ",
  "Ὺ": "Ὺ",
  "Ϋ": "Ϋ",
  "Ῡ": "Ῡ",
  "Ῠ": "Ῠ",
  "Ώ": "Ώ",
  "Ὼ": "Ὼ"
};

/* eslint no-constant-condition:0 */

const binLeftCancellers = ["bin", "op", "open", "punct", "rel"];
const sizeRegEx = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const textRegEx = /^ *\\text/;

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */

class Parser {
  constructor(input, settings, isPreamble = false) {
    // Start in math mode
    this.mode = "math";
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings, this.mode);
    // Store the settings for use in parsing
    this.settings = settings;
    // Are we defining a preamble?
    this.isPreamble = isPreamble;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
    this.prevAtomType = "";
  }

  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text, consume = true) {
    if (this.fetch().text !== text) {
      throw new ParseError(`Expected '${text}', got '${this.fetch().text}'`, this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }

  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }

  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }

  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    // Create a group namespace for every $...$, $$...$$, \[...\].)
    // A \def is then valid only within that pair of delimiters.
    this.gullet.beginGroup();

    if (this.settings.colorIsTextColor) {
      // Use old \color behavior (same as LaTeX's \textcolor) if requested.
      // We do this within the group for the math expression, so it doesn't
      // pollute settings.macros.
      this.gullet.macros.set("\\color", "\\textcolor");
    }

    // Try to parse the input
    const parse = this.parseExpression(false);

    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF");

    if (this.isPreamble) {
      const macros = Object.create(null);
      Object.entries(this.gullet.macros.current).forEach(([key, value]) => {
        macros[key] = value;
      });
      this.gullet.endGroup();
      return macros
    }

    // The only local macro that we want to save is from \tag.
    const tag = this.gullet.macros.get("\\df@tag");

    // End the group namespace for the expression
    this.gullet.endGroup();

    if (tag) { this.gullet.macros.current["\\df@tag"] = tag; }

    return parse;
  }

  static get endOfExpression() {
    return ["}", "\\endgroup", "\\end", "\\right", "\\endtoggle", "&"];
  }

  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    // Save the next token from the current job.
    const oldToken = this.nextToken;
    this.consume();

    // Run the new job, terminating it with an excess '}'
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    const parse = this.parseExpression(false);
    this.expect("}");

    // Restore the next token from the current job.
    this.nextToken = oldToken;

    return parse;
  }

/**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   *
   * `breakOnMiddle`: \color, \over, and old styling functions work on an implicit group.
   *                  These groups end just before the usual tokens, but they also
   *                  end just before `\middle`.
   */
  parseExpression(breakOnInfix, breakOnTokenText, breakOnMiddle) {
    const body = [];
    this.prevAtomType = "";
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
      // Ignore spaces in math mode
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      const lex = this.fetch();
      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnMiddle && lex.text === "\\middle") {
        break
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      const atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
      // Keep a record of the atom type, so that op.js can set correct spacing.
      this.prevAtomType = atom.type === "atom" ? atom.family : atom.type;
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }

  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    let overIndex = -1;
    let funcName;

    for (let i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i].token);
        }
        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }

    if (overIndex !== -1 && funcName) {
      let numerNode;
      let denomNode;

      const numerBody = body.slice(0, overIndex);
      const denomBody = body.slice(overIndex + 1);

      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = { type: "ordgroup", mode: this.mode, body: numerBody };
      }

      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = { type: "ordgroup", mode: this.mode, body: denomBody };
      }

      let node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }

  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(
    name // For error reporting.
  ) {
    const symbolToken = this.fetch();
    const symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces(); // ignore spaces before sup/subscript argument
    const group = this.parseGroup(name);

    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }

    return group;
  }

  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text) {
    const textordArray = [];

    for (let i = 0; i < text.length; i++) {
      textordArray.push({ type: "textord", mode: "text", text: text[i] });
    }

    const textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };

    const colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };

    return colorNode;
  }

  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    const base = this.parseGroup("atom", breakOnTokenText);

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
      return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    let superscript;
    let subscript;
    while (true) {
      // Guaranteed in math mode, so eat any spaces first.
      this.consumeSpaces();

      // Lex the first token
      const lex = this.fetch();

      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        // We got a limit control
        if (base && base.type === "op") {
          const limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        // We got a superscript start
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        // We got a subscript start
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        // We got a prime
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        const prime = { type: "textord", mode: this.mode, text: "\\prime" };

        // Many primes can be grouped together, so we handle this here
        const primes = [prime];
        this.consume();
        // Keep lexing tokens until we get something that's not a prime
        while (this.fetch().text === "'") {
          // For each one, add another prime to the list
          primes.push(prime);
          this.consume();
        }
        // If there's a superscript following the primes, combine that
        // superscript in with the primes.
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        // Put everything into an ordgroup as the superscript
        superscript = { type: "ordgroup", mode: this.mode, body: primes };
      } else if (uSubsAndSups[lex.text]) {
        // A Unicode subscript or superscript character.
        // We treat these similarly to the unicode-math package.
        // So we render a string of Unicode (sub|super)scripts the
        // same as a (sub|super)script of regular characters.
        const isSub = unicodeSubRegEx.test(lex.text);
        const subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        // Continue fetching tokens to fill out the group.
        while (true) {
          const token = this.fetch().text;
          if (!(uSubsAndSups[token])) { break }
          if (unicodeSubRegEx.test(token) !== isSub) { break }
          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        }
        // Now create a (sub|super)script.
        const body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = { type: "ordgroup", mode: "math", body };
        } else {
          superscript = { type: "ordgroup", mode: "math", body };
        }
      } else {
        // If it wasn't ^, _, a Unicode (sub|super)script, or ', stop parsing super/subscripts
        break;
      }
    }

    if (superscript || subscript) {
      if (base && base.type === "multiscript" && !base.postscripts) {
        // base is the result of a \prescript function.
        // Write the sub- & superscripts into the multiscript element.
        base.postscripts = { sup: superscript, sub: subscript };
        return base
      } else {
        // We got either a superscript or subscript, create a supsub
        const isFollowedByDelimiter = (!base || base.type !== "op" && base.type !== "operatorname")
          ? undefined
          : isDelimiter(this.nextToken.text);
        return {
          type: "supsub",
          mode: this.mode,
          base: base,
          sup: superscript,
          sub: subscript,
          isFollowedByDelimiter
        }
      }
    } else {
      // Otherwise return the original body
      return base;
    }
  }

  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(
    breakOnTokenText,
    name // For determining its context
  ) {
    const token = this.fetch();
    const func = token.text;
    const funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume(); // consume command token

    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError(
        "Got function '" + func + "' with no arguments" + (name ? " as " + name : ""),
        token
      );
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }

    const prevAtomType = this.prevAtomType;
    const { args, optArgs } = this.parseArguments(func, funcData);
    this.prevAtomType = prevAtomType;
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }

  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    const context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    const func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError(`No function handler for ${name}`);
    }
  }

  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(
    func, // Should look like "\name" or "\begin{name}".
    funcData
  ) {
    const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return { args: [], optArgs: [] };
    }

    const args = [];
    const optArgs = [];

    for (let i = 0; i < totalArgs; i++) {
      let argType = funcData.argTypes && funcData.argTypes[i];
      const isOptional = i < funcData.numOptionalArgs;

      if (
        (funcData.primitive && argType == null) ||
        // \sqrt expands into primitive if optional argument doesn't exist
        (funcData.type === "sqrt" && i === 1 && optArgs[0] == null)
      ) {
        argType = "primitive";
      }

      const arg = this.parseGroupOfType(`argument to '${func}'`, argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        // should be unreachable
        throw new ParseError("Null argument, please report this as a bug");
      }
    }

    return { args, optArgs };
  }

  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        // hbox argument type wraps the argument in the equivalent of
        // \hbox, which is like \text but switching to \textstyle size.
        const group = this.parseArgumentGroup(optional, "text");
        return group != null
          ? {
            type: "styling",
            mode: group.mode,
            body: [group],
            scriptLevel: "text" // simulate \textstyle
          }
          : null;
      }
      case "raw": {
        const token = this.parseStringGroup("raw", optional);
        return token != null
          ? {
            type: "raw",
            mode: "text",
            string: token.text
          }
          : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        const group = this.parseGroup(name);
        if (group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return group;
      }
      case "original":
      case null:
      case undefined:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }

  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (true) {
      const ch = this.fetch().text;
      // \ufe0e is the Unicode variation selector to supress emoji. Ignore it.
      if (ch === " " || ch === "\u00a0" || ch === "\ufe0e") {
        this.consume();
      } else {
        break
      }
    }
  }

  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(
    modeName, // Used to describe the mode in error messages.
    optional
  ) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume(); // consume the end of the argument
    argToken.text = str;
    return argToken;
  }

  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(
    regex,
    modeName // Used to describe the mode in error messages.
  ) {
    const firstToken = this.fetch();
    let lastToken = firstToken;
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }

  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    let res;
    let isBlank = false;
    // don't expand before parseStringGroup
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      // Because we've tested for what is !optional, this block won't
      // affect \kern, \hspace, etc. It will capture the mandatory arguments
      // to \genfrac and \above.
      res.text = "0pt"; // Enable \above{}
      isBlank = true; // This is here specifically for \genfrac
    }
    const match = sizeRegEx.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }

  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13); // active character
    this.gullet.lexer.setCatcode("~", 12); // other character
    const res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14); // comment character
    this.gullet.lexer.setCatcode("~", 13); // active character
    if (res == null) {
      return null;
    }
    // hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.
    let url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    url = res.text.replace(/{\u2044}/g, "/");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }

  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    const outerMode = this.mode;
    if (mode) {
      // Switch to specified mode
      this.switchMode(mode);
    }

    this.gullet.beginGroup();
    const expression = this.parseExpression(false, "EOF");
    // TODO: find an alternative way to denote the end
    this.expect("EOF"); // expect the end of the argument
    this.gullet.endGroup();
    const result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };

    if (mode) {
      // Switch mode back
      this.switchMode(outerMode);
    }
    return result;
  }

  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(
    name, // For error reporting.
    breakOnTokenText
  ) {
    const firstToken = this.fetch();
    const text = firstToken.text;

    let result;
    // Try to parse an open brace or \begingroup
    if (text === "{" || text === "\\begingroup" || text === "\\toggle") {
      this.consume();
      const groupEnd = text === "{"
        ? "}"
        : text === "\\begingroup"
        ? "\\endgroup"
        : "\\endtoggle";

      this.gullet.beginGroup();
      // If we get a brace, parse an expression
      const expression = this.parseExpression(false, groupEnd);
      const lastToken = this.fetch();
      this.expect(groupEnd); // Check that we got a matching closing brace
      this.gullet.endGroup();
      result = {
        type: (lastToken.text === "\\endtoggle" ? "toggle" : "ordgroup"),
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/
        semisimple: text === "\\begingroup" || undefined
      };
    } else {
      // If there exists a function with this name, parse the function.
      // Otherwise, just return a nucleus
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text[0] === "\\" &&
          !Object.prototype.hasOwnProperty.call(implicitCommands, text )) {
        result = this.formatUnsupportedCmd(text);
        this.consume();
      }
    }
    return result;
  }

  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    let n = group.length - 1;
    for (let i = 0; i < n; ++i) {
      const a = group[i];
      const v = a.text;
      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }
      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }

  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    const nucleus = this.fetch();
    let text = nucleus.text;

    if (/^\\verb[^a-zA-Z]/.test(text)) {
      this.consume();
      let arg = text.slice(5);
      const star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      // Lexer's tokenRegex is constructed to always have matching
      // first/last characters.
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
      }
      arg = arg.slice(1, -1); // remove first and last char
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    // At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.
    if (Object.prototype.hasOwnProperty.call(unicodeSymbols, text[0]) &&
      this.mode === "math" && !symbols[this.mode][text[0]]) {
      // This behavior is not strict (XeTeX-compatible) in math mode.
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Accented Unicode text character "${text[0]}" used in ` + `math mode`,
          nucleus
        );
      }
      text = unicodeSymbols[text[0]] + text.slice(1);
    }
    // Strip off any combining characters
    const match = this.mode === "math"
      ? combiningDiacriticalMarksEndRegex.exec(text)
      : null;
    if (match) {
      text = text.substring(0, match.index);
      if (text === "i") {
        text = "\u0131"; // dotless i, in math and text mode
      } else if (text === "j") {
        text = "\u0237"; // dotless j, in math and text mode
      }
    }
    // Recognize base symbol
    let symbol;
    if (symbols[this.mode][text]) {
      let group = symbols[this.mode][text].group;
      if (group === "bin" && binLeftCancellers.includes(this.prevAtomType)) {
        // Change from a binary operator to a unary (prefix) operator
        group = "open";
      }
      const loc = SourceLocation.range(nucleus);
      let s;
      if (Object.prototype.hasOwnProperty.call(ATOMS, group )) {
        const family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text
        };
        if ((family === "rel" || family === "bin") && this.prevAtomType === "text") {
          if (textRegEx.test(loc.lexer.input.slice(loc.end))) {
            s.needsSpacing = true;  // Fix a MathML bug.
          }
        }
      } else {
        if (asciiFromScript[text]) {
          // Unicode 14 disambiguates chancery from roundhand.
          // See https://www.unicode.org/charts/PDF/U1D400.pdf
          this.consume();
          const nextCode = this.fetch().text.charCodeAt(0);
          // mathcal is Temml default. Use mathscript if called for.
          const font = nextCode === 0xfe01 ? "mathscr" : "mathcal";
          if (nextCode === 0xfe00 || nextCode === 0xfe01) { this.consume(); }
          return {
            type: "font",
            mode: "math",
            font,
            body: { type: "mathord", mode: "math", loc, text: asciiFromScript[text] }
          }
        }
        // Default ord character. No disambiguation necessary.
        s = {
          type: group,
          mode: this.mode,
          loc,
          text
        };
      }
      symbol = s;
    } else if (text.charCodeAt(0) >= 0x80 || combiningDiacriticalMarksEndRegex.exec(text)) {
      // no symbol for e.g. ^
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Unicode text character "${text[0]}" used in math mode`, nucleus)
      }
      // All nonmathematical Unicode characters are rendered as if they
      // are in text mode (wrapped in \text) because that's what it
      // takes to render them in LaTeX.
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text
      };
    } else {
      return null; // EOF, ^, _, {, }, etc.
    }
    this.consume();
    // Transform combining characters into accents
    if (match) {
      for (let i = 0; i < match[0].length; i++) {
        const accent = match[0][i];
        if (!unicodeAccents[accent]) {
          throw new ParseError(`Unknown accent ' ${accent}'`, nucleus);
        }
        const command = unicodeAccents[accent][this.mode] ||
                        unicodeAccents[accent].text;
        if (!command) {
          throw new ParseError(`Accent ${accent} unsupported in ${this.mode} mode`, nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          base: symbol
        };
      }
    }
    return symbol;
  }
}

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
const parseTree = function(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(toParse, settings);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];

  let tree = parser.parse();

  // LaTeX ignores a \tag placed outside an AMS environment.
  if (!(tree.length > 0 &&  tree[0].type && tree[0].type === "array" && tree[0].addEqnNum)) {
    // If the input used \tag, it will set the \df@tag macro to the tag.
    // In this case, we separately parse the tag and wrap the tree.
    if (parser.gullet.macros.get("\\df@tag")) {
      if (!settings.displayMode) {
        throw new ParseError("\\tag works only in display mode")
      }
      parser.gullet.feed("\\df@tag");
      tree = [
        {
          type: "tag",
          mode: "text",
          body: tree,
          tag: parser.parse()
        }
      ];
    }
  }

  return tree
};

/**
 * This file contains information about the style that the mathmlBuilder carries
 * around with it. Data is held in an `Style` object, and when
 * recursing, a new `Style` object can be created with the `.with*` functions.
 */

const subOrSupLevel = [2, 2, 3, 3];

/**
 * This is the main Style class. It contains the current style.level, color, and font.
 *
 * Style objects should not be modified. To create a new Style with
 * different properties, call a `.with*` method.
 */
class Style {
  constructor(data) {
    // Style.level can be 0 | 1 | 2 | 3, which correspond to
    //       displaystyle, textstyle, scriptstyle, and scriptscriptstyle.
    // style.level usually does not directly set MathML's script level. MathML does that itself.
    // However, Chromium does not stop shrinking after scriptscriptstyle, so we do explicitly
    // set a scriptlevel attribute in those conditions.
    // We also use style.level to track math style so that we can get the correct
    // scriptlevel when needed in supsub.js, mathchoice.js, or for dimensions in em.
    this.level = data.level;
    this.color = data.color;  // string | void
    // A font family applies to a group of fonts (i.e. SansSerif), while a font
    // represents a specific font (i.e. SansSerif Bold).
    // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
    this.font = data.font || "";                // string
    this.fontFamily = data.fontFamily || "";    // string
    this.fontSize = data.fontSize || 1.0;       // number
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.maxSize = data.maxSize;                // [number, number]
  }

  /**
   * Returns a new style object with the same properties as "this".  Properties
   * from "extension" will be copied to the new style object.
   */
  extend(extension) {
    const data = {
      level: this.level,
      color: this.color,
      font: this.font,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize
    };

    for (const key in extension) {
      if (Object.prototype.hasOwnProperty.call(extension, key)) {
        data[key] = extension[key];
      }
    }

    return new Style(data);
  }

  withLevel(n) {
    return this.extend({
      level: n
    });
  }

  incrementLevel() {
    return this.extend({
      level: Math.min(this.level + 1, 3)
    });
  }

  inSubOrSup() {
    return this.extend({
      level: subOrSupLevel[this.level]
    })
  }

  /**
   * Create a new style object with the given color.
   */
  withColor(color) {
    return this.extend({
      color: color
    });
  }

  /**
   * Creates a new style object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }

  /**
   * Create a new style objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font size
   */
  withFontSize(num) {
    return this.extend({
      fontSize: num
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }

  /**
   * Gets the CSS color of the current style object
   */
  getColor() {
    return this.color;
  }
}

/* Temml Post Process
 * Populate the text contents of each \ref & \eqref
 *
 * As with other Temml code, this file is released under terms of the MIT license.
 * https://mit-license.org/
 */

const version = "0.11.02";

function postProcess(block) {
  const labelMap = {};
  let i = 0;

  // Get a collection of the parents of each \tag & auto-numbered equation
  const amsEqns = document.getElementsByClassName('tml-eqn');
  for (let parent of amsEqns) {
    // AMS automatically numbered equation.
    // Assign an id.
    i += 1;
    parent.setAttribute("id", "tml-eqn-" + String(i));
    // No need to write a number into the text content of the element.
    // A CSS counter has done that even if this postProcess() function is not used.

    // Find any \label that refers to an AMS automatic eqn number.
    while (true) {
      if (parent.tagName === "mtable") { break }
      const labels = parent.getElementsByClassName("tml-label");
      if (labels.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = String(i);
        break
      } else {
        parent = parent.parentElement;
      }
    }
  }

  // Find \labels associated with \tag
  const taggedEqns = document.getElementsByClassName('tml-tageqn');
  for (const parent of taggedEqns) {
    const labels = parent.getElementsByClassName("tml-label");
    if (labels.length > 0) {
      const tags = parent.getElementsByClassName("tml-tag");
      if (tags.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = tags[0].textContent;
      }
    }
  }

  // Populate \ref & \eqref text content
  const refs = block.getElementsByClassName("tml-ref");
  [...refs].forEach(ref => {
    const attr = ref.getAttribute("href");
    let str = labelMap[attr.slice(1)];
    if (ref.className.indexOf("tml-eqref") === -1) {
      // \ref. Omit parens.
      str = str.replace(/^\(/, "");
      str = str.replace(/\)$/, "");
    } else {
      // \eqref. Include parens
      if (str.charAt(0) !== "(") { str = "(" + str; }
      if (str.slice(-1) !== ")") { str =  str + ")"; }
    }
    const mtext = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mtext");
    mtext.appendChild(document.createTextNode(str));
    const math =  document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
    math.appendChild(mtext);
    ref.textContent = '';
    ref.appendChild(math);
  });
}

const findEndOfMath = function(delimiter, text, startIndex) {
  // Adapted from
  // https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx
  let index = startIndex;
  let braceLevel = 0;

  const delimLength = delimiter.length;

  while (index < text.length) {
    const character = text[index];

    if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter) {
      return index;
    } else if (character === "\\") {
      index++;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    }

    index++;
  }

  return -1;
};

const escapeRegex = function(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};

const amsRegex = /^\\(?:begin|(?:eq)?ref){/;

const splitAtDelimiters = function(text, delimiters) {
  let index;
  const data = [];

  const regexLeft = new RegExp(
    "(" + delimiters.map((x) => escapeRegex(x.left)).join("|") + ")"
  );

  while (true) {
    index = text.search(regexLeft);
    if (index === -1) {
      break;
    }
    if (index > 0) {
      data.push({
        type: "text",
        data: text.slice(0, index)
      });
      text = text.slice(index); // now text starts with delimiter
    }
    // ... so this always succeeds:
    const i = delimiters.findIndex((delim) => text.startsWith(delim.left));
    index = findEndOfMath(delimiters[i].right, text, delimiters[i].left.length);
    if (index === -1) {
      break;
    }
    const rawData = text.slice(0, index + delimiters[i].right.length);
    const math = amsRegex.test(rawData)
      ? rawData
      : text.slice(delimiters[i].left.length, index);
    data.push({
      type: "math",
      data: math,
      rawData,
      display: delimiters[i].display
    });
    text = text.slice(index + delimiters[i].right.length);
  }

  if (text !== "") {
    data.push({
      type: "text",
      data: text
    });
  }

  return data;
};

const defaultDelimiters = [
  { left: "$$", right: "$$", display: true },
  { left: "\\(", right: "\\)", display: false },
  // LaTeX uses $…$, but it ruins the display of normal `$` in text:
  // {left: "$", right: "$", display: false},
  // $ must come after $$

  // Render AMS environments even if outside $$…$$ delimiters.
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  // Ditto \ref & \eqref
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false },

  { left: "\\[", right: "\\]", display: true }
];

const firstDraftDelimiters = {
  "$": [
         { left: "$$", right: "$$", display: true },
         { left: "$`", right: "`$", display: false },
         { left: "$", right: "$", display: false }
  ],
  "(": [
    { left: "\\[", right: "\\]", display: true },
    { left: "\\(", right: "\\)", display: false }
  ]
};

const amsDelimiters = [
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false }
];

const delimitersFromKey = key => {
  if (key === "$" || key === "(") {
    return firstDraftDelimiters[key];
  } else if (key === "$+" || key === "(+") {
    const firstDraft = firstDraftDelimiters[key.slice(0, 1)];
    return firstDraft.concat(amsDelimiters)
  } else if (key === "ams") {
    return amsDelimiters
  } else if (key === "all") {
    return (firstDraftDelimiters["("]).concat(firstDraftDelimiters["$"]).concat(amsDelimiters)
  } else {
    return defaultDelimiters
  }
};

/* Note: optionsCopy is mutated by this method. If it is ever exposed in the
 * API, we should copy it before mutating.
 */
const renderMathInText = function(text, optionsCopy) {
  const data = splitAtDelimiters(text, optionsCopy.delimiters);
  if (data.length === 1 && data[0].type === "text") {
    // There is no formula in the text.
    // Let's return null which means there is no need to replace
    // the current text node with a new one.
    return null;
  }

  const fragment = document.createDocumentFragment();

  for (let i = 0; i < data.length; i++) {
    if (data[i].type === "text") {
      fragment.appendChild(document.createTextNode(data[i].data));
    } else {
      const span = document.createElement("span");
      let math = data[i].data;
      // Override any display mode defined in the settings with that
      // defined by the text itself
      optionsCopy.displayMode = data[i].display;
      try {
        if (optionsCopy.preProcess) {
          math = optionsCopy.preProcess(math);
        }
        // Importing render() from temml.js would be a circular dependency.
        // So call the global version.
        // eslint-disable-next-line no-undef
        temml.render(math, span, optionsCopy);
      } catch (e) {
        if (!(e instanceof ParseError)) {
          throw e;
        }
        optionsCopy.errorCallback(
          "Temml auto-render: Failed to parse `" + data[i].data + "` with ",
          e
        );
        fragment.appendChild(document.createTextNode(data[i].rawData));
        continue;
      }
      fragment.appendChild(span);
    }
  }

  return fragment;
};

const renderElem = function(elem, optionsCopy) {
  for (let i = 0; i < elem.childNodes.length; i++) {
    const childNode = elem.childNodes[i];
    if (childNode.nodeType === 3) {
      // Text node
      const frag = renderMathInText(childNode.textContent, optionsCopy);
      if (frag) {
        i += frag.childNodes.length - 1;
        elem.replaceChild(frag, childNode);
      }
    } else if (childNode.nodeType === 1) {
      // Element node
      const className = " " + childNode.className + " ";
      const shouldRender =
        optionsCopy.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 &&
        optionsCopy.ignoredClasses.every((x) => className.indexOf(" " + x + " ") === -1);

      if (shouldRender) {
        renderElem(childNode, optionsCopy);
      }
    }
    // Otherwise, it's something else, and ignore it.
  }
};

const renderMathInElement = function(elem, options) {
  if (!elem) {
    throw new Error("No element provided to render");
  }

  const optionsCopy = {};

  // Object.assign(optionsCopy, option)
  for (const option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      optionsCopy[option] = options[option];
    }
  }

  if (optionsCopy.fences) {
    optionsCopy.delimiters = delimitersFromKey(optionsCopy.fences);
  } else {
    optionsCopy.delimiters = optionsCopy.delimiters || defaultDelimiters;
  }
  optionsCopy.ignoredTags = optionsCopy.ignoredTags || [
    "script",
    "noscript",
    "style",
    "textarea",
    "pre",
    "code",
    "option"
  ];
  optionsCopy.ignoredClasses = optionsCopy.ignoredClasses || [];
  // eslint-disable-next-line no-console
  optionsCopy.errorCallback = optionsCopy.errorCallback || console.error;

  // Enable sharing of global macros defined via `\gdef` between different
  // math elements within a single call to `renderMathInElement`.
  optionsCopy.macros = optionsCopy.macros || {};

  renderElem(elem, optionsCopy);
  postProcess(elem);
};

/* eslint no-console:0 */
/**
 * This is the main entry point for Temml. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from Temml are
 * errors in the expression, or errors in javascript handling.
 */


/**
 * @type {import('./temml').render}
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
let render = function(expression, baseNode, options = {}) {
  baseNode.textContent = "";
  const alreadyInMathElement = baseNode.tagName.toLowerCase() === "math";
  if (alreadyInMathElement) { options.wrap = "none"; }
  const math = renderToMathMLTree(expression, options);
  if (alreadyInMathElement) {
    // The <math> element already exists. Populate it.
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else if (math.children.length > 1) {
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else {
    baseNode.appendChild(math.toNode());
  }
};

// Temml's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" &&
      console.warn(
        "Warning: Temml doesn't work in quirks mode. Make sure your " +
          "website has a suitable doctype."
      );

    render = function() {
      throw new ParseError("Temml doesn't work in quirks mode.");
    };
  }
}

/**
 * @type {import('./temml').renderToString}
 * Parse and build an expression, and return the markup for that.
 */
const renderToString = function(expression, options) {
  const markup = renderToMathMLTree(expression, options).toMarkup();
  return markup;
};

/**
 * @type {import('./temml').generateParseTree}
 * Parse an expression and return the parse tree.
 */
const generateParseTree = function(expression, options) {
  const settings = new Settings(options);
  return parseTree(expression, settings);
};

/**
 * @type {import('./temml').definePreamble}
 * Take an expression which contains a preamble.
 * Parse it and return the macros.
 */
const definePreamble = function(expression, options) {
  const settings = new Settings(options);
  settings.macros = {};
  if (!(typeof expression === "string" || expression instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(expression, settings, true);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];
  const macros = parser.parse();
  return macros
};

/**
 * If the given error is a Temml ParseError,
 * renders the invalid LaTeX as a span with hover title giving the Temml
 * error message.  Otherwise, simply throws the error.
 */
const renderError = function(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }
  const node = new Span(["temml-error"], [new TextNode$1(expression + "\n\n" + error.toString())]);
  node.style.color = options.errorColor;
  node.style.whiteSpace = "pre-line";
  return node;
};

/**
 * @type {import('./temml').renderToMathMLTree}
 * Generates and returns the Temml build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */
const renderToMathMLTree = function(expression, options) {
  const settings = new Settings(options);
  try {
    const tree = parseTree(expression, settings);
    const style = new Style({
      level: settings.displayMode ? StyleLevel.DISPLAY : StyleLevel.TEXT,
      maxSize: settings.maxSize
    });
    return buildMathML(tree, expression, style, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};

/** @type {import('./temml').default} */
var temml$1 = {
  /**
   * Current Temml version
   */
  version: version,
  /**
   * Renders the given LaTeX into MathML, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into MathML string,
   * for sending to the client.
   */
  renderToString,
  /**
   * Finds all the math delimiters in a given element of a running HTML document
   * and converts the contents of each instance into a <math> element.
   */
  renderMathInElement,
  /**
   * Post-process an entire HTML block.
   * Writes AMS auto-numbers and implements \ref{}.
   * Typcally called once, after a loop has rendered many individual spans.
   */
  postProcess,
  /**
   * Temml error, usually during parsing.
   */
  ParseError,
  /**
   * Creates a set of macros with document-wide scope.
   */
  definePreamble,
  /**
   * Parses the given LaTeX into Temml's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into a MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToMathMLTree: renderToMathMLTree,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro
};

module.exports = temml$1;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
var defuddle_1 = __webpack_require__(/*! ./defuddle */ 628);
Object.defineProperty(exports, "Defuddle", ({ enumerable: true, get: function () { return defuddle_1.Defuddle; } }));

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEdBQUcsR0FBRyxjQUFjLGFBQWEsc0NBQXNDLFNBQVMsaUVBQWlFLFdBQVcsaUNBQWlDLGFBQWEsTUFBTSx5Q0FBeUMsMENBQTBDLDBCQUEwQixNQUFNLGdCQUFnQixVQUFVLGNBQWMsR0FBRyxFQUFFLEdBQUcsT0FBTywyQkFBMkIsYUFBYSxrQkFBa0IsTUFBTSxtQkFBbUIsR0FBRyxXQUFXLEdBQUcsRUFBRSxHQUFHLElBQUksU0FBUyxHQUFHLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLHFCQUFxQixJQUFJLGlKQUFpSixJQUFJLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLElBQUksNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLE1BQU0sNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLElBQUksOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLElBQUksOEJBQThCLElBQUksOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLElBQUksOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLElBQUksOEJBQThCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssa0NBQWtDLEtBQUssa0NBQWtDLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssa0NBQWtDLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssbUNBQW1DLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssK0JB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QTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQyxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxD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QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLGdCQUFnQjtBQUN0RCxzQ0FBc0MsZ0JBQWdCO0FBQ3RELHNDQUFzQyxnQkFBZ0I7QUFDdEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDO0FBQ3RDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scURBQXFELFdBQVc7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QixHQUFHLGlCQUFpQjtBQUN4RjtBQUNBO0FBQ0Esd0RBQXdELCtCQUErQjtBQUN2RjtBQUNBLE1BQU0saUJBQWlCO0FBQ3ZCLEtBQUssd0JBQXdCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQSxLQUFLLCtCQUErQjtBQUNwQztBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSx5QkFBeUIsSUFBSTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsYUFBYTtBQUMzQixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxpQ0FBaUMsbUNBQW1DO0FBQ3BFLElBQUk7QUFDSjtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEUsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O1VDM2xjQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQSw0REFBc0M7QUFBN0IsNkdBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vRGVmdWRkbGUvLi9zcmMvbWF0aC50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy9tYXRobWwtdG8tbGF0ZXgvZGlzdC9idW5kbGUubWluLmpzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL21ldGFkYXRhLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2RlZnVkZGxlLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy90ZW1tbC9kaXN0L3RlbW1sLmNqcyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHRoaXMsICgpID0+IHtcbnJldHVybiAiLCJpbXBvcnQgeyBNYXRoTUxUb0xhVGVYIH0gZnJvbSAnbWF0aG1sLXRvLWxhdGV4JztcbmltcG9ydCAqIGFzIHRlbW1sIGZyb20gJ3RlbW1sJztcblxuZXhwb3J0IGludGVyZmFjZSBNYXRoRGF0YSB7XG5cdG1hdGhtbDogc3RyaW5nO1xuXHRsYXRleDogc3RyaW5nIHwgbnVsbDtcblx0aXNCbG9jazogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGdldE1hdGhNTEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogTWF0aERhdGEgfCBudWxsID0+IHtcblx0Ly8gMS4gRGlyZWN0IE1hdGhNTCBjb250ZW50XG5cdGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdtYXRoJykge1xuXHRcdGNvbnN0IGlzQmxvY2sgPSBlbC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWF0aG1sOiBlbC5vdXRlckhUTUwsXG5cdFx0XHRsYXRleDogZWwuZ2V0QXR0cmlidXRlKCdhbHR0ZXh0JykgfHwgbnVsbCxcblx0XHRcdGlzQmxvY2tcblx0XHR9O1xuXHR9XG5cblx0Ly8gMi4gTWF0aE1MIGluIGRhdGEtbWF0aG1sIGF0dHJpYnV0ZVxuXHRjb25zdCBtYXRobWxTdHIgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWF0aG1sJyk7XG5cdGlmIChtYXRobWxTdHIpIHtcblx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGVtcERpdi5pbm5lckhUTUwgPSBtYXRobWxTdHI7XG5cdFx0Y29uc3QgbWF0aEVsZW1lbnQgPSB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRpZiAobWF0aEVsZW1lbnQpIHtcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1hdGhtbDogbWF0aEVsZW1lbnQub3V0ZXJIVE1MLFxuXHRcdFx0XHRsYXRleDogbWF0aEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhbHR0ZXh0JykgfHwgbnVsbCxcblx0XHRcdFx0aXNCbG9ja1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLiBNYXRoSmF4IGFzc2lzdGl2ZSBNYXRoTUxcblx0Y29uc3QgYXNzaXN0aXZlTW1sQ29udGFpbmVyID0gZWwucXVlcnlTZWxlY3RvcignLk1KWF9Bc3Npc3RpdmVfTWF0aE1MLCBtangtYXNzaXN0aXZlLW1tbCcpO1xuXHRcblx0aWYgKGFzc2lzdGl2ZU1tbENvbnRhaW5lcikge1xuXHRcdGNvbnN0IG1hdGhFbGVtZW50ID0gYXNzaXN0aXZlTW1sQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRcblx0XHRpZiAobWF0aEVsZW1lbnQpIHtcblx0XHRcdC8vIENoZWNrIGJvdGggdGhlIG1hdGggZWxlbWVudCBhbmQgY29udGFpbmVyIGZvciBkaXNwbGF5IG1vZGVcblx0XHRcdGNvbnN0IG1hdGhEaXNwbGF5QXR0ciA9IG1hdGhFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzcGxheScpO1xuXHRcdFx0Y29uc3QgY29udGFpbmVyRGlzcGxheUF0dHIgPSBhc3Npc3RpdmVNbWxDb250YWluZXIuZ2V0QXR0cmlidXRlKCdkaXNwbGF5Jyk7XHRcdFx0XG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gbWF0aERpc3BsYXlBdHRyID09PSAnYmxvY2snIHx8IGNvbnRhaW5lckRpc3BsYXlBdHRyID09PSAnYmxvY2snO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtYXRobWw6IG1hdGhFbGVtZW50Lm91dGVySFRNTCxcblx0XHRcdFx0bGF0ZXg6IG1hdGhFbGVtZW50LmdldEF0dHJpYnV0ZSgnYWx0dGV4dCcpIHx8IG51bGwsXG5cdFx0XHRcdGlzQmxvY2tcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0Ly8gNC4gS2FUZVggTWF0aE1MXG5cdGNvbnN0IGthdGV4TWF0aG1sID0gZWwucXVlcnlTZWxlY3RvcignLmthdGV4LW1hdGhtbCBtYXRoJyk7XG5cdGlmIChrYXRleE1hdGhtbCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRtYXRobWw6IGthdGV4TWF0aG1sLm91dGVySFRNTCxcblx0XHRcdGxhdGV4OiBudWxsLCAvLyBXZSdsbCBnZXQgTGFUZVggc2VwYXJhdGVseSBmb3IgS2FUZVhcblx0XHRcdGlzQmxvY2s6IGZhbHNlIC8vIFdlJ2xsIGRldGVybWluZSB0aGlzIGZyb20gY29udGFpbmVyXG5cdFx0fTtcblx0fVxuO1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRMYXRleEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogc3RyaW5nIHwgbnVsbCA9PiB7XG5cdC8vIERpcmVjdCBkYXRhLWxhdGV4IGF0dHJpYnV0ZVxuXHRjb25zdCBkYXRhTGF0ZXggPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGF0ZXgnKTtcblx0aWYgKGRhdGFMYXRleCkge1xuXHRcdHJldHVybiBkYXRhTGF0ZXg7XG5cdH1cblxuXHQvLyBXb3JkUHJlc3MgTGFUZVggaW1hZ2VzXG5cdGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXRleCcpKSB7XG5cdFx0Ly8gVHJ5IGFsdCB0ZXh0IGZpcnN0IGFzIGl0J3MgY2xlYW5lclxuXHRcdGNvbnN0IGFsdExhdGV4ID0gZWwuZ2V0QXR0cmlidXRlKCdhbHQnKTtcblx0XHRpZiAoYWx0TGF0ZXgpIHtcblx0XHRcdHJldHVybiBhbHRMYXRleDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRmFsbGJhY2sgdG8gZXh0cmFjdGluZyBmcm9tIFVSTFxuXHRcdGNvbnN0IHNyYyA9IGVsLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goL2xhdGV4XFwucGhwXFw/bGF0ZXg9KFteJl0rKS8pO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcKy9nLCAnICcpIC8vIFJlcGxhY2UgKyB3aXRoIHNwYWNlc1xuXHRcdFx0XHRcdC5yZXBsYWNlKC8lNUMvZywgJ1xcXFwnKTsgLy8gRml4IGVzY2FwZWQgYmFja3NsYXNoZXNcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBMYVRlWCBpbiBhbm5vdGF0aW9uXG5cdGNvbnN0IGFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCdhbm5vdGF0aW9uW2VuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIl0nKTtcblx0aWYgKGFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0cmV0dXJuIGFubm90YXRpb24udGV4dENvbnRlbnQudHJpbSgpO1xuXHR9XG5cblx0Ly8gS2FUZVggZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLmthdGV4JykpIHtcblx0XHRjb25zdCBrYXRleEFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCcua2F0ZXgtbWF0aG1sIGFubm90YXRpb25bZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiXScpO1xuXHRcdGlmIChrYXRleEFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0XHRyZXR1cm4ga2F0ZXhBbm5vdGF0aW9uLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHR9XG5cdH1cblxuXHQvLyBNYXRoSmF4IHNjcmlwdHNcblx0Ly8gSW1wb3J0YW50OiB0aGlzIHdpbGwgb25seSB3b3JrIGlmIHRoZSBzY3JpcHQgaGFzIG5vdCBiZWVuIHJlbW92ZWQgYXQgYW4gZWFybGllciBzdGFnZVxuXHRpZiAoZWwubWF0Y2hlcygnc2NyaXB0W3R5cGU9XCJtYXRoL3RleFwiXScpIHx8IGVsLm1hdGNoZXMoJ3NjcmlwdFt0eXBlPVwibWF0aC90ZXg7IG1vZGU9ZGlzcGxheVwiXScpKSB7XG5cdFx0cmV0dXJuIGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzaWJsaW5nIHNjcmlwdCBlbGVtZW50XG5cdGlmIChlbC5wYXJlbnRFbGVtZW50KSB7XG5cdFx0Y29uc3Qgc2libGluZ1NjcmlwdCA9IGVsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3R5cGU9XCJtYXRoL3RleFwiXSwgc2NyaXB0W3R5cGU9XCJtYXRoL3RleDsgbW9kZT1kaXNwbGF5XCJdJyk7XG5cdFx0aWYgKHNpYmxpbmdTY3JpcHQpIHtcblx0XHRcdHJldHVybiBzaWJsaW5nU2NyaXB0LnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvLyBUcnkgdG8gY29udmVydCBNYXRoTUwgdG8gTGFUZVggYXMgbGFzdCByZXNvcnRcblx0Y29uc3QgbWF0aG1sID0gZ2V0TWF0aE1MRnJvbUVsZW1lbnQoZWwpO1xuXHRpZiAobWF0aG1sPy5tYXRobWwpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIE1hdGhNTFRvTGFUZVguY29udmVydChtYXRobWwubWF0aG1sKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY29udmVydGluZyBNYXRoTUwgdG8gTGFUZVg6JywgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0Ly8gRmFsbGJhY2sgdG8gYWx0IHRleHQgb3IgdGV4dCBjb250ZW50XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0Jsb2NrRGlzcGxheSA9IChlbDogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xuXHQvLyBDaGVjayBleHBsaWNpdCBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRjb25zdCBkaXNwbGF5QXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpO1xuXHRpZiAoZGlzcGxheUF0dHIgPT09ICdibG9jaycpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIENoZWNrIGNvbW1vbiBjbGFzcyBuYW1lc1xuXHRjb25zdCBjbGFzc05hbWVzID0gZWwuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmIChjbGFzc05hbWVzLmluY2x1ZGVzKCdkaXNwbGF5JykgfHwgY2xhc3NOYW1lcy5pbmNsdWRlcygnYmxvY2snKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgY29udGFpbmVyIGNsYXNzZXNcblx0Y29uc3QgY29udGFpbmVyID0gZWwuY2xvc2VzdCgnLmthdGV4LWRpc3BsYXksIC5NYXRoSmF4X0Rpc3BsYXksIFtkYXRhLWRpc3BsYXk9XCJibG9ja1wiXScpO1xuXHRpZiAoY29udGFpbmVyKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBwcmVjZWRlZCBieSBibG9jayBlbGVtZW50XG5cdGNvbnN0IHByZXZFbGVtZW50ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcblx0aWYgKHByZXZFbGVtZW50Py50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgc3BlY2lmaWMgZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLm13ZS1tYXRoLWZhbGxiYWNrLWltYWdlLWRpc3BsYXknKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgS2FUZVggZGlzcGxheSBtb2RlXG5cdGlmIChlbC5tYXRjaGVzKCcua2F0ZXgnKSkge1xuXHRcdC8vIEthVGVYIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuXHRcdC8vIE9ubHkgYmxvY2sgaWYgZXhwbGljaXRseSBtYXJrZWQgYXMgZGlzcGxheVxuXHRcdHJldHVybiBlbC5jbG9zZXN0KCcua2F0ZXgtZGlzcGxheScpICE9PSBudWxsO1xuXHR9XG5cblx0Ly8gQ2hlY2sgTWF0aEpheCB2MyBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNwbGF5JykpIHtcblx0XHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkaXNwbGF5JykgPT09ICd0cnVlJztcblx0fVxuXG5cdC8vIENoZWNrIE1hdGhKYXggc2NyaXB0IGRpc3BsYXkgYXR0cmlidXRlXG5cdGlmIChlbC5tYXRjaGVzKCdzY3JpcHRbdHlwZT1cIm1hdGgvdGV4OyBtb2RlPWRpc3BsYXlcIl0nKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzcGxheScpKSB7XG5cdFx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpID09PSAndHJ1ZSc7XG5cdH1cblxuXHQvLyBDaGVjayBwYXJlbnQgY29udGFpbmVyIGRpc3BsYXkgYXR0cmlidXRlXG5cdGNvbnN0IHBhcmVudENvbnRhaW5lciA9IGVsLmNsb3Nlc3QoJ1tkaXNwbGF5XScpO1xuXHRpZiAocGFyZW50Q29udGFpbmVyKSB7XG5cdFx0cmV0dXJuIHBhcmVudENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ3RydWUnO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsZWFuTWF0aEVsID0gKG1hdGhEYXRhOiBNYXRoRGF0YSB8IG51bGwsIGxhdGV4OiBzdHJpbmcgfCBudWxsLCBpc0Jsb2NrOiBib29sZWFuKTogRWxlbWVudCA9PiB7XG5cdGNvbnN0IGNsZWFuTWF0aEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWF0aCcpO1xuXG5cdGNsZWFuTWF0aEVsLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcpO1xuXHRjbGVhbk1hdGhFbC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCBpc0Jsb2NrID8gJ2Jsb2NrJyA6ICdpbmxpbmUnKTtcblx0Y2xlYW5NYXRoRWwuc2V0QXR0cmlidXRlKCdkYXRhLWxhdGV4JywgbGF0ZXggfHwgJycpO1xuXG5cdC8vIEZpcnN0IHRyeSB0byB1c2UgZXhpc3RpbmcgTWF0aE1MIGNvbnRlbnRcblx0aWYgKG1hdGhEYXRhPy5tYXRobWwpIHtcblx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGVtcERpdi5pbm5lckhUTUwgPSBtYXRoRGF0YS5tYXRobWw7XG5cdFx0Y29uc3QgbWF0aENvbnRlbnQgPSB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRpZiAobWF0aENvbnRlbnQpIHtcblx0XHRcdGNsZWFuTWF0aEVsLmlubmVySFRNTCA9IG1hdGhDb250ZW50LmlubmVySFRNTDtcblx0XHR9XG5cdH1cblx0Ly8gSWYgbm8gTWF0aE1MIGNvbnRlbnQgYnV0IHdlIGhhdmUgTGFUZVgsIGNvbnZlcnQgdXNpbmcgVGVtbWxcblx0ZWxzZSBpZiAobGF0ZXgpIHtcblx0XHR0cnkge1x0XHRcdFxuXHRcdFx0Ly8gQ29udmVydCBMYVRlWCB0byBNYXRoTUwgdXNpbmcgVGVtbWxcblx0XHRcdGNvbnN0IG1hdGhtbCA9IHRlbW1sLnJlbmRlclRvU3RyaW5nKGxhdGV4LCB7XG5cdFx0XHRcdGRpc3BsYXlNb2RlOiBpc0Jsb2NrLFxuXHRcdFx0XHR0aHJvd09uRXJyb3I6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBtYXRobWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEV4dHJhY3QgdGhlIGlubmVyIGNvbnRlbnQgb2YgdGhlIG1hdGggZWxlbWVudFxuXHRcdFx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdHRlbXBEaXYuaW5uZXJIVE1MID0gbWF0aG1sO1xuXHRcdFx0XHRjb25zdCBtYXRoQ29udGVudCA9IHRlbXBEaXYucXVlcnlTZWxlY3RvcignbWF0aCcpO1xuXHRcdFx0XHRpZiAobWF0aENvbnRlbnQpIHtcblx0XHRcdFx0XHQvLyBDb3B5IGF0dHJpYnV0ZXMgZXhjZXB0IGRpc3BsYXkgbW9kZVxuXHRcdFx0XHRcdEFycmF5LmZyb20obWF0aENvbnRlbnQuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0XHRcdGlmIChhdHRyLm5hbWUgIT09ICdkaXNwbGF5Jykge1xuXHRcdFx0XHRcdFx0XHRjbGVhbk1hdGhFbC5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjbGVhbk1hdGhFbC5pbm5lckhUTUwgPSBtYXRoQ29udGVudC5pbm5lckhUTUw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gVXNlIHRoZSBlbnRpcmUgb3V0cHV0IGFzIGZhbGxiYWNrXG5cdFx0XHRcdFx0Y2xlYW5NYXRoRWwuaW5uZXJIVE1MID0gbWF0aG1sO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbk1hdGhFbC50ZXh0Q29udGVudCA9IGxhdGV4O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBjb252ZXJ0aW5nIExhVGVYIHRvIE1hdGhNTDonLCBlcnJvcik7XG5cdFx0XHRjbGVhbk1hdGhFbC50ZXh0Q29udGVudCA9IGxhdGV4O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjbGVhbk1hdGhFbDtcbn07XG5cbi8vIEZpbmQgbWF0aCBlbGVtZW50c1xuZXhwb3J0IGNvbnN0IG1hdGhTdGFuZGFyZGl6YXRpb25SdWxlcyA9IFtcblx0e1xuXHRcdHNlbGVjdG9yOiBbXG5cdFx0Ly8gV29yZFByZXNzIExhVGVYIGltYWdlc1xuXHRcdFx0J2ltZy5sYXRleFtzcmMqPVwibGF0ZXgucGhwXCJdJyxcblxuXHRcdC8vIE1hdGhKYXggZWxlbWVudHMgKHYyIGFuZCB2Mylcblx0XHRcdCdzcGFuLk1hdGhKYXgnLFxuXHRcdFx0J21qeC1jb250YWluZXInLFxuXHRcdFx0J3NjcmlwdFt0eXBlPVwibWF0aC90ZXhcIl0nLFxuXHRcdFx0J3NjcmlwdFt0eXBlPVwibWF0aC90ZXg7IG1vZGU9ZGlzcGxheVwiXScsXG5cdFx0XHQnLk1hdGhKYXhfUHJldmlldyArIHNjcmlwdFt0eXBlPVwibWF0aC90ZXhcIl0nLFxuXHRcdFx0Jy5NYXRoSmF4X0Rpc3BsYXknLFxuXHRcdFx0Jy5NYXRoSmF4X1NWRycsXG5cdFx0XHQnLk1hdGhKYXhfTWF0aE1MJyxcblxuXHRcdC8vIE1lZGlhV2lraSBtYXRoIGVsZW1lbnRzXG5cdFx0XHQnLm13ZS1tYXRoLWVsZW1lbnQnLFxuXHRcdFx0Jy5td2UtbWF0aC1mYWxsYmFjay1pbWFnZS1pbmxpbmUnLFxuXHRcdFx0Jy5td2UtbWF0aC1mYWxsYmFjay1pbWFnZS1kaXNwbGF5Jyxcblx0XHRcdCcubXdlLW1hdGgtbWF0aG1sLWlubGluZScsXG5cdFx0XHQnLm13ZS1tYXRoLW1hdGhtbC1kaXNwbGF5JyxcblxuXHRcdC8vIEthVGVYIGVsZW1lbnRzXG5cdFx0XHQnLmthdGV4Jyxcblx0XHRcdCcua2F0ZXgtZGlzcGxheScsXG5cdFx0XHQnLmthdGV4LW1hdGhtbCcsXG5cdFx0XHQnLmthdGV4LWh0bWwnLFxuXHRcdFx0J1tkYXRhLWthdGV4XScsXG5cdFx0XHQnc2NyaXB0W3R5cGU9XCJtYXRoL2thdGV4XCJdJyxcblxuXHRcdC8vIEdlbmVyaWMgbWF0aCBlbGVtZW50cyBhbmQgb3RoZXIgZm9ybWF0c1xuXHRcdFx0J21hdGgnLFxuXHRcdFx0J1tkYXRhLW1hdGhdJyxcblx0XHRcdCdbZGF0YS1sYXRleF0nLFxuXHRcdFx0J1tkYXRhLXRleF0nLFxuXHRcdFx0J3NjcmlwdFt0eXBlXj1cIm1hdGgvXCJdJyxcblx0XHRcdCdhbm5vdGF0aW9uW2VuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIl0nXG5cdFx0XS5qb2luKCcsJyksXG5cdFx0ZWxlbWVudDogJ21hdGgnLFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHRpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuIGVsO1xuXG5cdFx0XHRjb25zdCBtYXRoRGF0YSA9IGdldE1hdGhNTEZyb21FbGVtZW50KGVsKTtcblx0XHRcdGNvbnN0IGxhdGV4ID0gZ2V0TGF0ZXhGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gaXNCbG9ja0Rpc3BsYXkoZWwpO1xuXHRcdFx0Y29uc3QgY2xlYW5NYXRoRWwgPSBjcmVhdGVDbGVhbk1hdGhFbChtYXRoRGF0YSwgbGF0ZXgsIGlzQmxvY2spO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCBhbnkgYXNzb2NpYXRlZCBtYXRoIHNjcmlwdHMgYWZ0ZXIgd2UndmUgZXh0cmFjdGVkIHRoZWlyIGNvbnRlbnRcblx0XHRcdGlmIChlbC5wYXJlbnRFbGVtZW50KSB7XG5cdFx0XHRcdC8vIFJlbW92ZSBhbGwgbWF0aC1yZWxhdGVkIHNjcmlwdHMgYW5kIHByZXZpZXdzXG5cdFx0XHRcdGNvbnN0IG1hdGhFbGVtZW50cyA9IGVsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgXG5cdFx0XHRcdFx0LyogTWF0aEpheCBzY3JpcHRzIGFuZCBwcmV2aWV3cyAqL1xuXHRcdFx0XHRcdHNjcmlwdFt0eXBlXj1cIm1hdGgvXCJdLFxuXHRcdFx0XHRcdC5NYXRoSmF4X1ByZXZpZXcsXG5cblx0XHRcdFx0XHQvKiBFeHRlcm5hbCBtYXRoIGxpYnJhcnkgc2NyaXB0cyAqL1xuXHRcdFx0XHRcdHNjcmlwdFt0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCJdW3NyYyo9XCJtYXRoamF4XCJdLFxuXHRcdFx0XHRcdHNjcmlwdFt0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCJdW3NyYyo9XCJrYXRleFwiXVxuXHRcdFx0XHRgKTtcblx0XHRcdFx0bWF0aEVsZW1lbnRzLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gY2xlYW5NYXRoRWw7XG5cdFx0fVxuXHR9XG5dOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuTWF0aE1MVG9MYVRlWD10KCk6ZS5NYXRoTUxUb0xhVGVYPXQoKX0odGhpcywoKCk9PigoKT0+e3ZhciBlPXs0NTgyOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1PYmplY3QpLHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZnJlZXplP3QuZnJlZXplKGUpOmV9dmFyIGE9cih7SFRNTDpcInRleHQvaHRtbFwiLGlzSFRNTDpmdW5jdGlvbihlKXtyZXR1cm4gZT09PWEuSFRNTH0sWE1MX0FQUExJQ0FUSU9OOlwiYXBwbGljYXRpb24veG1sXCIsWE1MX1RFWFQ6XCJ0ZXh0L3htbFwiLFhNTF9YSFRNTF9BUFBMSUNBVElPTjpcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiLFhNTF9TVkdfSU1BR0U6XCJpbWFnZS9zdmcreG1sXCJ9KSxuPXIoe0hUTUw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsaXNIVE1MOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09bi5IVE1MfSxTVkc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFhNTDpcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFhNTE5TOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIn0pO3QuYXNzaWduPWZ1bmN0aW9uKGUsdCl7aWYobnVsbD09PWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJ0YXJnZXQgaXMgbm90IGFuIG9iamVjdFwiKTtmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKGVbcl09dFtyXSk7cmV0dXJuIGV9LHQuZmluZD1mdW5jdGlvbihlLHQscil7aWYodm9pZCAwPT09ciYmKHI9QXJyYXkucHJvdG90eXBlKSxlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmZpbmQpcmV0dXJuIHIuZmluZC5jYWxsKGUsdCk7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDthKyspaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYSkpe3ZhciBuPWVbYV07aWYodC5jYWxsKHZvaWQgMCxuLGEsZSkpcmV0dXJuIG59fSx0LmZyZWV6ZT1yLHQuTUlNRV9UWVBFPWEsdC5OQU1FU1BBQ0U9bn0sNTc1MjooZSx0LHIpPT57dmFyIGE9cig0NTgyKSxuPXIoNDcyMiksbz1yKDY1NTkpLGk9cig0NDY2KSxzPW4uRE9NSW1wbGVtZW50YXRpb24sbD1hLk5BTUVTUEFDRSxjPWkuUGFyc2VFcnJvcix1PWkuWE1MUmVhZGVyO2Z1bmN0aW9uIGgoZSl7cmV0dXJuIGUucmVwbGFjZSgvXFxyW1xcblxcdTAwODVdL2csXCJcXG5cIikucmVwbGFjZSgvW1xcclxcdTAwODVcXHUyMDI4XS9nLFwiXFxuXCIpfWZ1bmN0aW9uIGQoZSl7dGhpcy5vcHRpb25zPWV8fHtsb2NhdG9yOnt9fX1mdW5jdGlvbiBtKCl7dGhpcy5jZGF0YT0hMX1mdW5jdGlvbiBwKGUsdCl7dC5saW5lTnVtYmVyPWUubGluZU51bWJlcix0LmNvbHVtbk51bWJlcj1lLmNvbHVtbk51bWJlcn1mdW5jdGlvbiBmKGUpe2lmKGUpcmV0dXJuXCJcXG5AXCIrKGUuc3lzdGVtSWR8fFwiXCIpK1wiI1tsaW5lOlwiK2UubGluZU51bWJlcitcIixjb2w6XCIrZS5jb2x1bW5OdW1iZXIrXCJdXCJ9ZnVuY3Rpb24geChlLHQscil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/ZS5zdWJzdHIodCxyKTplLmxlbmd0aD49dCtyfHx0P25ldyBqYXZhLmxhbmcuU3RyaW5nKGUsdCxyKStcIlwiOmV9ZnVuY3Rpb24gZyhlLHQpe2UuY3VycmVudEVsZW1lbnQ/ZS5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0KTplLmRvYy5hcHBlbmRDaGlsZCh0KX1kLnByb3RvdHlwZS5wYXJzZUZyb21TdHJpbmc9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLm9wdGlvbnMsYT1uZXcgdSxuPXIuZG9tQnVpbGRlcnx8bmV3IG0saT1yLmVycm9ySGFuZGxlcixzPXIubG9jYXRvcixjPXIueG1sbnN8fHt9LGQ9L1xcL3g/aHRtbD8kLy50ZXN0KHQpLHA9ZD9vLkhUTUxfRU5USVRJRVM6by5YTUxfRU5USVRJRVM7cyYmbi5zZXREb2N1bWVudExvY2F0b3IocyksYS5lcnJvckhhbmRsZXI9ZnVuY3Rpb24oZSx0LHIpe2lmKCFlKXtpZih0IGluc3RhbmNlb2YgbSlyZXR1cm4gdDtlPXR9dmFyIGE9e30sbj1lIGluc3RhbmNlb2YgRnVuY3Rpb247ZnVuY3Rpb24gbyh0KXt2YXIgbz1lW3RdOyFvJiZuJiYobz0yPT1lLmxlbmd0aD9mdW5jdGlvbihyKXtlKHQscil9OmUpLGFbdF09byYmZnVuY3Rpb24oZSl7byhcIlt4bWxkb20gXCIrdCtcIl1cXHRcIitlK2YocikpfXx8ZnVuY3Rpb24oKXt9fXJldHVybiByPXJ8fHt9LG8oXCJ3YXJuaW5nXCIpLG8oXCJlcnJvclwiKSxvKFwiZmF0YWxFcnJvclwiKSxhfShpLG4scyksYS5kb21CdWlsZGVyPXIuZG9tQnVpbGRlcnx8bixkJiYoY1tcIlwiXT1sLkhUTUwpLGMueG1sPWMueG1sfHxsLlhNTDt2YXIgeD1yLm5vcm1hbGl6ZUxpbmVFbmRpbmdzfHxoO3JldHVybiBlJiZcInN0cmluZ1wiPT10eXBlb2YgZT9hLnBhcnNlKHgoZSksYyxwKTphLmVycm9ySGFuZGxlci5lcnJvcihcImludmFsaWQgZG9jIHNvdXJjZVwiKSxuLmRvY30sbS5wcm90b3R5cGU9e3N0YXJ0RG9jdW1lbnQ6ZnVuY3Rpb24oKXt0aGlzLmRvYz0obmV3IHMpLmNyZWF0ZURvY3VtZW50KG51bGwsbnVsbCxudWxsKSx0aGlzLmxvY2F0b3ImJih0aGlzLmRvYy5kb2N1bWVudFVSST10aGlzLmxvY2F0b3Iuc3lzdGVtSWQpfSxzdGFydEVsZW1lbnQ6ZnVuY3Rpb24oZSx0LHIsYSl7dmFyIG49dGhpcy5kb2Msbz1uLmNyZWF0ZUVsZW1lbnROUyhlLHJ8fHQpLGk9YS5sZW5ndGg7Zyh0aGlzLG8pLHRoaXMuY3VycmVudEVsZW1lbnQ9byx0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLG8pO2Zvcih2YXIgcz0wO3M8aTtzKyspe2U9YS5nZXRVUkkocyk7dmFyIGw9YS5nZXRWYWx1ZShzKSxjPShyPWEuZ2V0UU5hbWUocyksbi5jcmVhdGVBdHRyaWJ1dGVOUyhlLHIpKTt0aGlzLmxvY2F0b3ImJnAoYS5nZXRMb2NhdG9yKHMpLGMpLGMudmFsdWU9Yy5ub2RlVmFsdWU9bCxvLnNldEF0dHJpYnV0ZU5vZGUoYyl9fSxlbmRFbGVtZW50OmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT10aGlzLmN1cnJlbnRFbGVtZW50O2EudGFnTmFtZSx0aGlzLmN1cnJlbnRFbGVtZW50PWEucGFyZW50Tm9kZX0sc3RhcnRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKGUsdCl7fSxlbmRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKGUpe30scHJvY2Vzc2luZ0luc3RydWN0aW9uOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5kb2MuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKGUsdCk7dGhpcy5sb2NhdG9yJiZwKHRoaXMubG9jYXRvcixyKSxnKHRoaXMscil9LGlnbm9yYWJsZVdoaXRlc3BhY2U6ZnVuY3Rpb24oZSx0LHIpe30sY2hhcmFjdGVyczpmdW5jdGlvbihlLHQscil7aWYoZT14LmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7aWYodGhpcy5jZGF0YSl2YXIgYT10aGlzLmRvYy5jcmVhdGVDREFUQVNlY3Rpb24oZSk7ZWxzZSBhPXRoaXMuZG9jLmNyZWF0ZVRleHROb2RlKGUpO3RoaXMuY3VycmVudEVsZW1lbnQ/dGhpcy5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChhKTovXlxccyokLy50ZXN0KGUpJiZ0aGlzLmRvYy5hcHBlbmRDaGlsZChhKSx0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLGEpfX0sc2tpcHBlZEVudGl0eTpmdW5jdGlvbihlKXt9LGVuZERvY3VtZW50OmZ1bmN0aW9uKCl7dGhpcy5kb2Mubm9ybWFsaXplKCl9LHNldERvY3VtZW50TG9jYXRvcjpmdW5jdGlvbihlKXsodGhpcy5sb2NhdG9yPWUpJiYoZS5saW5lTnVtYmVyPTApfSxjb21tZW50OmZ1bmN0aW9uKGUsdCxyKXtlPXguYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBhPXRoaXMuZG9jLmNyZWF0ZUNvbW1lbnQoZSk7dGhpcy5sb2NhdG9yJiZwKHRoaXMubG9jYXRvcixhKSxnKHRoaXMsYSl9LHN0YXJ0Q0RBVEE6ZnVuY3Rpb24oKXt0aGlzLmNkYXRhPSEwfSxlbmRDREFUQTpmdW5jdGlvbigpe3RoaXMuY2RhdGE9ITF9LHN0YXJ0RFREOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT10aGlzLmRvYy5pbXBsZW1lbnRhdGlvbjtpZihhJiZhLmNyZWF0ZURvY3VtZW50VHlwZSl7dmFyIG49YS5jcmVhdGVEb2N1bWVudFR5cGUoZSx0LHIpO3RoaXMubG9jYXRvciYmcCh0aGlzLmxvY2F0b3IsbiksZyh0aGlzLG4pLHRoaXMuZG9jLmRvY3R5cGU9bn19LHdhcm5pbmc6ZnVuY3Rpb24oZSl7Y29uc29sZS53YXJuKFwiW3htbGRvbSB3YXJuaW5nXVxcdFwiK2UsZih0aGlzLmxvY2F0b3IpKX0sZXJyb3I6ZnVuY3Rpb24oZSl7Y29uc29sZS5lcnJvcihcIlt4bWxkb20gZXJyb3JdXFx0XCIrZSxmKHRoaXMubG9jYXRvcikpfSxmYXRhbEVycm9yOmZ1bmN0aW9uKGUpe3Rocm93IG5ldyBjKGUsdGhpcy5sb2NhdG9yKX19LFwiZW5kRFRELHN0YXJ0RW50aXR5LGVuZEVudGl0eSxhdHRyaWJ1dGVEZWNsLGVsZW1lbnREZWNsLGV4dGVybmFsRW50aXR5RGVjbCxpbnRlcm5hbEVudGl0eURlY2wscmVzb2x2ZUVudGl0eSxnZXRFeHRlcm5hbFN1YnNldCxub3RhdGlvbkRlY2wsdW5wYXJzZWRFbnRpdHlEZWNsXCIucmVwbGFjZSgvXFx3Ky9nLChmdW5jdGlvbihlKXttLnByb3RvdHlwZVtlXT1mdW5jdGlvbigpe3JldHVybiBudWxsfX0pKSx0LkRPTVBhcnNlcj1kfSw0NzIyOihlLHQscik9Pnt2YXIgYT1yKDQ1ODIpLG49YS5maW5kLG89YS5OQU1FU1BBQ0U7ZnVuY3Rpb24gaShlKXtyZXR1cm5cIlwiIT09ZX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGUuaGFzT3duUHJvcGVydHkodCl8fChlW3RdPSEwKSxlfWZ1bmN0aW9uIGwoZSl7aWYoIWUpcmV0dXJuW107dmFyIHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/ZS5zcGxpdCgvW1xcdFxcblxcZlxcciBdKy8pLmZpbHRlcihpKTpbXX0oZSk7cmV0dXJuIE9iamVjdC5rZXlzKHQucmVkdWNlKHMse30pKX1mdW5jdGlvbiBjKGUsdCl7Zm9yKHZhciByIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pfWZ1bmN0aW9uIHUoZSx0KXt2YXIgcj1lLnByb3RvdHlwZTtpZighKHIgaW5zdGFuY2VvZiB0KSl7ZnVuY3Rpb24gYSgpe31hLnByb3RvdHlwZT10LnByb3RvdHlwZSxjKHIsYT1uZXcgYSksZS5wcm90b3R5cGU9cj1hfXIuY29uc3RydWN0b3IhPWUmJihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZjb25zb2xlLmVycm9yKFwidW5rbm93biBDbGFzczpcIitlKSxyLmNvbnN0cnVjdG9yPWUpfXZhciBoPXt9LGQ9aC5FTEVNRU5UX05PREU9MSxtPWguQVRUUklCVVRFX05PREU9MixwPWguVEVYVF9OT0RFPTMsZj1oLkNEQVRBX1NFQ1RJT05fTk9ERT00LHg9aC5FTlRJVFlfUkVGRVJFTkNFX05PREU9NSxnPWguRU5USVRZX05PREU9Nix3PWguUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFPTcsYj1oLkNPTU1FTlRfTk9ERT04LHY9aC5ET0NVTUVOVF9OT0RFPTksQz1oLkRPQ1VNRU5UX1RZUEVfTk9ERT0xMCxBPWguRE9DVU1FTlRfRlJBR01FTlRfTk9ERT0xMSxFPWguTk9UQVRJT05fTk9ERT0xMixfPXt9LHk9e30scT0oXy5JTkRFWF9TSVpFX0VSUj0oeVsxXT1cIkluZGV4IHNpemUgZXJyb3JcIiwxKSxfLkRPTVNUUklOR19TSVpFX0VSUj0oeVsyXT1cIkRPTVN0cmluZyBzaXplIGVycm9yXCIsMiksXy5ISUVSQVJDSFlfUkVRVUVTVF9FUlI9KHlbM109XCJIaWVyYXJjaHkgcmVxdWVzdCBlcnJvclwiLDMpKSxEPShfLldST05HX0RPQ1VNRU5UX0VSUj0oeVs0XT1cIldyb25nIGRvY3VtZW50XCIsNCksXy5JTlZBTElEX0NIQVJBQ1RFUl9FUlI9KHlbNV09XCJJbnZhbGlkIGNoYXJhY3RlclwiLDUpLF8uTk9fREFUQV9BTExPV0VEX0VSUj0oeVs2XT1cIk5vIGRhdGEgYWxsb3dlZFwiLDYpLF8uTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSPSh5WzddPVwiTm8gbW9kaWZpY2F0aW9uIGFsbG93ZWRcIiw3KSxfLk5PVF9GT1VORF9FUlI9KHlbOF09XCJOb3QgZm91bmRcIiw4KSksTT0oXy5OT1RfU1VQUE9SVEVEX0VSUj0oeVs5XT1cIk5vdCBzdXBwb3J0ZWRcIiw5KSxfLklOVVNFX0FUVFJJQlVURV9FUlI9KHlbMTBdPVwiQXR0cmlidXRlIGluIHVzZVwiLDEwKSk7ZnVuY3Rpb24gVChlLHQpe2lmKHQgaW5zdGFuY2VvZiBFcnJvcil2YXIgcj10O2Vsc2Ugcj10aGlzLEVycm9yLmNhbGwodGhpcyx5W2VdKSx0aGlzLm1lc3NhZ2U9eVtlXSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyxUKTtyZXR1cm4gci5jb2RlPWUsdCYmKHRoaXMubWVzc2FnZT10aGlzLm1lc3NhZ2UrXCI6IFwiK3QpLHJ9ZnVuY3Rpb24gTigpe31mdW5jdGlvbiBPKGUsdCl7dGhpcy5fbm9kZT1lLHRoaXMuX3JlZnJlc2g9dCxMKHRoaXMpfWZ1bmN0aW9uIEwoZSl7dmFyIHQ9ZS5fbm9kZS5faW5jfHxlLl9ub2RlLm93bmVyRG9jdW1lbnQuX2luYztpZihlLl9pbmMhPT10KXt2YXIgcj1lLl9yZWZyZXNoKGUuX25vZGUpO2lmKHdlKGUsXCJsZW5ndGhcIixyLmxlbmd0aCksIWUuJCRsZW5ndGh8fHIubGVuZ3RoPGUuJCRsZW5ndGgpZm9yKHZhciBhPXIubGVuZ3RoO2EgaW4gZTthKyspT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYSkmJmRlbGV0ZSBlW2FdO2MocixlKSxlLl9pbmM9dH19ZnVuY3Rpb24gQigpe31mdW5jdGlvbiBTKGUsdCl7Zm9yKHZhciByPWUubGVuZ3RoO3ItLTspaWYoZVtyXT09PXQpcmV0dXJuIHJ9ZnVuY3Rpb24gRihlLHQscixhKXtpZihhP3RbUyh0LGEpXT1yOnRbdC5sZW5ndGgrK109cixlKXtyLm93bmVyRWxlbWVudD1lO3ZhciBuPWUub3duZXJEb2N1bWVudDtuJiYoYSYmVihuLGUsYSksZnVuY3Rpb24oZSx0LHIpe2UmJmUuX2luYysrLHIubmFtZXNwYWNlVVJJPT09by5YTUxOUyYmKHQuX25zTWFwW3IucHJlZml4P3IubG9jYWxOYW1lOlwiXCJdPXIudmFsdWUpfShuLGUscikpfX1mdW5jdGlvbiBQKGUsdCxyKXt2YXIgYT1TKHQscik7aWYoIShhPj0wKSl0aHJvdyBuZXcgVChELG5ldyBFcnJvcihlLnRhZ05hbWUrXCJAXCIrcikpO2Zvcih2YXIgbj10Lmxlbmd0aC0xO2E8bjspdFthXT10WysrYV07aWYodC5sZW5ndGg9bixlKXt2YXIgbz1lLm93bmVyRG9jdW1lbnQ7byYmKFYobyxlLHIpLHIub3duZXJFbGVtZW50PW51bGwpfX1mdW5jdGlvbiBrKCl7fWZ1bmN0aW9uIFIoKXt9ZnVuY3Rpb24gSShlKXtyZXR1cm4oXCI8XCI9PWU/XCImbHQ7XCI6XCI+XCI9PWUmJlwiJmd0O1wiKXx8XCImXCI9PWUmJlwiJmFtcDtcInx8J1wiJz09ZSYmXCImcXVvdDtcInx8XCImI1wiK2UuY2hhckNvZGVBdCgpK1wiO1wifWZ1bmN0aW9uIFUoZSx0KXtpZih0KGUpKXJldHVybiEwO2lmKGU9ZS5maXJzdENoaWxkKWRve2lmKFUoZSx0KSlyZXR1cm4hMH13aGlsZShlPWUubmV4dFNpYmxpbmcpfWZ1bmN0aW9uIGooKXt0aGlzLm93bmVyRG9jdW1lbnQ9dGhpc31mdW5jdGlvbiBWKGUsdCxyLGEpe2UmJmUuX2luYysrLHIubmFtZXNwYWNlVVJJPT09by5YTUxOUyYmZGVsZXRlIHQuX25zTWFwW3IucHJlZml4P3IubG9jYWxOYW1lOlwiXCJdfWZ1bmN0aW9uIEcoZSx0LHIpe2lmKGUmJmUuX2luYyl7ZS5faW5jKys7dmFyIGE9dC5jaGlsZE5vZGVzO2lmKHIpYVthLmxlbmd0aCsrXT1yO2Vsc2V7Zm9yKHZhciBuPXQuZmlyc3RDaGlsZCxvPTA7bjspYVtvKytdPW4sbj1uLm5leHRTaWJsaW5nO2EubGVuZ3RoPW8sZGVsZXRlIGFbYS5sZW5ndGhdfX19ZnVuY3Rpb24gJChlLHQpe3ZhciByPXQucHJldmlvdXNTaWJsaW5nLGE9dC5uZXh0U2libGluZztyZXR1cm4gcj9yLm5leHRTaWJsaW5nPWE6ZS5maXJzdENoaWxkPWEsYT9hLnByZXZpb3VzU2libGluZz1yOmUubGFzdENoaWxkPXIsdC5wYXJlbnROb2RlPW51bGwsdC5wcmV2aW91c1NpYmxpbmc9bnVsbCx0Lm5leHRTaWJsaW5nPW51bGwsRyhlLm93bmVyRG9jdW1lbnQsZSksdH1mdW5jdGlvbiBYKGUpe3JldHVybiBlJiZlLm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9UWVBFX05PREV9ZnVuY3Rpb24gSChlKXtyZXR1cm4gZSYmZS5ub2RlVHlwZT09PVIuRUxFTUVOVF9OT0RFfWZ1bmN0aW9uIFcoZSl7cmV0dXJuIGUmJmUubm9kZVR5cGU9PT1SLlRFWFRfTk9ERX1mdW5jdGlvbiB6KGUsdCl7dmFyIHI9ZS5jaGlsZE5vZGVzfHxbXTtpZihuKHIsSCl8fFgodCkpcmV0dXJuITE7dmFyIGE9bihyLFgpO3JldHVybiEodCYmYSYmci5pbmRleE9mKGEpPnIuaW5kZXhPZih0KSl9ZnVuY3Rpb24gWShlLHQpe3ZhciByPWUuY2hpbGROb2Rlc3x8W107aWYobihyLChmdW5jdGlvbihlKXtyZXR1cm4gSChlKSYmZSE9PXR9KSkpcmV0dXJuITE7dmFyIGE9bihyLFgpO3JldHVybiEodCYmYSYmci5pbmRleE9mKGEpPnIuaW5kZXhPZih0KSl9ZnVuY3Rpb24gSihlLHQscil7dmFyIGE9ZS5jaGlsZE5vZGVzfHxbXSxvPXQuY2hpbGROb2Rlc3x8W107aWYodC5ub2RlVHlwZT09PVIuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7dmFyIGk9by5maWx0ZXIoSCk7aWYoaS5sZW5ndGg+MXx8bihvLFcpKXRocm93IG5ldyBUKHEsXCJNb3JlIHRoYW4gb25lIGVsZW1lbnQgb3IgdGV4dCBpbiBmcmFnbWVudFwiKTtpZigxPT09aS5sZW5ndGgmJiF6KGUscikpdGhyb3cgbmV3IFQocSxcIkVsZW1lbnQgaW4gZnJhZ21lbnQgY2FuIG5vdCBiZSBpbnNlcnRlZCBiZWZvcmUgZG9jdHlwZVwiKX1pZihIKHQpJiYheihlLHIpKXRocm93IG5ldyBUKHEsXCJPbmx5IG9uZSBlbGVtZW50IGNhbiBiZSBhZGRlZCBhbmQgb25seSBhZnRlciBkb2N0eXBlXCIpO2lmKFgodCkpe2lmKG4oYSxYKSl0aHJvdyBuZXcgVChxLFwiT25seSBvbmUgZG9jdHlwZSBpcyBhbGxvd2VkXCIpO3ZhciBzPW4oYSxIKTtpZihyJiZhLmluZGV4T2Yocyk8YS5pbmRleE9mKHIpKXRocm93IG5ldyBUKHEsXCJEb2N0eXBlIGNhbiBvbmx5IGJlIGluc2VydGVkIGJlZm9yZSBhbiBlbGVtZW50XCIpO2lmKCFyJiZzKXRocm93IG5ldyBUKHEsXCJEb2N0eXBlIGNhbiBub3QgYmUgYXBwZW5kZWQgc2luY2UgZWxlbWVudCBpcyBwcmVzZW50XCIpfX1mdW5jdGlvbiBaKGUsdCxyKXt2YXIgYT1lLmNoaWxkTm9kZXN8fFtdLG89dC5jaGlsZE5vZGVzfHxbXTtpZih0Lm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXt2YXIgaT1vLmZpbHRlcihIKTtpZihpLmxlbmd0aD4xfHxuKG8sVykpdGhyb3cgbmV3IFQocSxcIk1vcmUgdGhhbiBvbmUgZWxlbWVudCBvciB0ZXh0IGluIGZyYWdtZW50XCIpO2lmKDE9PT1pLmxlbmd0aCYmIVkoZSxyKSl0aHJvdyBuZXcgVChxLFwiRWxlbWVudCBpbiBmcmFnbWVudCBjYW4gbm90IGJlIGluc2VydGVkIGJlZm9yZSBkb2N0eXBlXCIpfWlmKEgodCkmJiFZKGUscikpdGhyb3cgbmV3IFQocSxcIk9ubHkgb25lIGVsZW1lbnQgY2FuIGJlIGFkZGVkIGFuZCBvbmx5IGFmdGVyIGRvY3R5cGVcIik7aWYoWCh0KSl7aWYobihhLChmdW5jdGlvbihlKXtyZXR1cm4gWChlKSYmZSE9PXJ9KSkpdGhyb3cgbmV3IFQocSxcIk9ubHkgb25lIGRvY3R5cGUgaXMgYWxsb3dlZFwiKTt2YXIgcz1uKGEsSCk7aWYociYmYS5pbmRleE9mKHMpPGEuaW5kZXhPZihyKSl0aHJvdyBuZXcgVChxLFwiRG9jdHlwZSBjYW4gb25seSBiZSBpbnNlcnRlZCBiZWZvcmUgYW4gZWxlbWVudFwiKX19ZnVuY3Rpb24gUShlLHQscixhKXsoZnVuY3Rpb24oZSx0LHIpe2lmKCFmdW5jdGlvbihlKXtyZXR1cm4gZSYmKGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLkVMRU1FTlRfTk9ERSl9KGUpKXRocm93IG5ldyBUKHEsXCJVbmV4cGVjdGVkIHBhcmVudCBub2RlIHR5cGUgXCIrZS5ub2RlVHlwZSk7aWYociYmci5wYXJlbnROb2RlIT09ZSl0aHJvdyBuZXcgVChELFwiY2hpbGQgbm90IGluIHBhcmVudFwiKTtpZighZnVuY3Rpb24oZSl7cmV0dXJuIGUmJihIKGUpfHxXKGUpfHxYKGUpfHxlLm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFfHxlLm5vZGVUeXBlPT09Ui5DT01NRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSl9KHQpfHxYKHQpJiZlLm5vZGVUeXBlIT09Ui5ET0NVTUVOVF9OT0RFKXRocm93IG5ldyBUKHEsXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIit0Lm5vZGVUeXBlK1wiIGZvciBwYXJlbnQgbm9kZSB0eXBlIFwiK2Uubm9kZVR5cGUpfSkoZSx0LHIpLGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX05PREUmJihhfHxKKShlLHQscik7dmFyIG49dC5wYXJlbnROb2RlO2lmKG4mJm4ucmVtb3ZlQ2hpbGQodCksdC5ub2RlVHlwZT09PUEpe3ZhciBvPXQuZmlyc3RDaGlsZDtpZihudWxsPT1vKXJldHVybiB0O3ZhciBpPXQubGFzdENoaWxkfWVsc2Ugbz1pPXQ7dmFyIHM9cj9yLnByZXZpb3VzU2libGluZzplLmxhc3RDaGlsZDtvLnByZXZpb3VzU2libGluZz1zLGkubmV4dFNpYmxpbmc9cixzP3MubmV4dFNpYmxpbmc9bzplLmZpcnN0Q2hpbGQ9byxudWxsPT1yP2UubGFzdENoaWxkPWk6ci5wcmV2aW91c1NpYmxpbmc9aTtkb3tvLnBhcmVudE5vZGU9ZX13aGlsZShvIT09aSYmKG89by5uZXh0U2libGluZykpO3JldHVybiBHKGUub3duZXJEb2N1bWVudHx8ZSxlKSx0Lm5vZGVUeXBlPT1BJiYodC5maXJzdENoaWxkPXQubGFzdENoaWxkPW51bGwpLHR9ZnVuY3Rpb24gSygpe3RoaXMuX25zTWFwPXt9fWZ1bmN0aW9uIGVlKCl7fWZ1bmN0aW9uIHRlKCl7fWZ1bmN0aW9uIHJlKCl7fWZ1bmN0aW9uIGFlKCl7fWZ1bmN0aW9uIG5lKCl7fWZ1bmN0aW9uIG9lKCl7fWZ1bmN0aW9uIGllKCl7fWZ1bmN0aW9uIHNlKCl7fWZ1bmN0aW9uIGxlKCl7fWZ1bmN0aW9uIGNlKCl7fWZ1bmN0aW9uIHVlKCl7fWZ1bmN0aW9uIGhlKCl7fWZ1bmN0aW9uIGRlKGUsdCl7dmFyIHI9W10sYT05PT10aGlzLm5vZGVUeXBlJiZ0aGlzLmRvY3VtZW50RWxlbWVudHx8dGhpcyxuPWEucHJlZml4LG89YS5uYW1lc3BhY2VVUkk7aWYobyYmbnVsbD09biYmbnVsbD09KG49YS5sb29rdXBQcmVmaXgobykpKXZhciBpPVt7bmFtZXNwYWNlOm8scHJlZml4Om51bGx9XTtyZXR1cm4gZmUodGhpcyxyLGUsdCxpKSxyLmpvaW4oXCJcIil9ZnVuY3Rpb24gbWUoZSx0LHIpe3ZhciBhPWUucHJlZml4fHxcIlwiLG49ZS5uYW1lc3BhY2VVUkk7aWYoIW4pcmV0dXJuITE7aWYoXCJ4bWxcIj09PWEmJm49PT1vLlhNTHx8bj09PW8uWE1MTlMpcmV0dXJuITE7Zm9yKHZhciBpPXIubGVuZ3RoO2ktLTspe3ZhciBzPXJbaV07aWYocy5wcmVmaXg9PT1hKXJldHVybiBzLm5hbWVzcGFjZSE9PW59cmV0dXJuITB9ZnVuY3Rpb24gcGUoZSx0LHIpe2UucHVzaChcIiBcIix0LCc9XCInLHIucmVwbGFjZSgvWzw+JlwiXFx0XFxuXFxyXS9nLEkpLCdcIicpfWZ1bmN0aW9uIGZlKGUsdCxyLGEsbil7aWYobnx8KG49W10pLGEpe2lmKCEoZT1hKGUpKSlyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIHZvaWQgdC5wdXNoKGUpfXN3aXRjaChlLm5vZGVUeXBlKXtjYXNlIGQ6dmFyIGk9ZS5hdHRyaWJ1dGVzLHM9aS5sZW5ndGgsbD1lLmZpcnN0Q2hpbGQsYz1lLnRhZ05hbWUsdT1jO2lmKCEocj1vLmlzSFRNTChlLm5hbWVzcGFjZVVSSSl8fHIpJiYhZS5wcmVmaXgmJmUubmFtZXNwYWNlVVJJKXtmb3IodmFyIGgsZz0wO2c8aS5sZW5ndGg7ZysrKWlmKFwieG1sbnNcIj09PWkuaXRlbShnKS5uYW1lKXtoPWkuaXRlbShnKS52YWx1ZTticmVha31pZighaClmb3IodmFyIEU9bi5sZW5ndGgtMTtFPj0wO0UtLSlpZihcIlwiPT09KF89bltFXSkucHJlZml4JiZfLm5hbWVzcGFjZT09PWUubmFtZXNwYWNlVVJJKXtoPV8ubmFtZXNwYWNlO2JyZWFrfWlmKGghPT1lLm5hbWVzcGFjZVVSSSlmb3IoRT1uLmxlbmd0aC0xO0U+PTA7RS0tKXt2YXIgXztpZigoXz1uW0VdKS5uYW1lc3BhY2U9PT1lLm5hbWVzcGFjZVVSSSl7Xy5wcmVmaXgmJih1PV8ucHJlZml4K1wiOlwiK2MpO2JyZWFrfX19dC5wdXNoKFwiPFwiLHUpO2Zvcih2YXIgeT0wO3k8czt5KyspXCJ4bWxuc1wiPT0ocT1pLml0ZW0oeSkpLnByZWZpeD9uLnB1c2goe3ByZWZpeDpxLmxvY2FsTmFtZSxuYW1lc3BhY2U6cS52YWx1ZX0pOlwieG1sbnNcIj09cS5ub2RlTmFtZSYmbi5wdXNoKHtwcmVmaXg6XCJcIixuYW1lc3BhY2U6cS52YWx1ZX0pO2Zvcih5PTA7eTxzO3krKyl7dmFyIHEsRCxNO21lKHE9aS5pdGVtKHkpLDAsbikmJihwZSh0LChEPXEucHJlZml4fHxcIlwiKT9cInhtbG5zOlwiK0Q6XCJ4bWxuc1wiLE09cS5uYW1lc3BhY2VVUkkpLG4ucHVzaCh7cHJlZml4OkQsbmFtZXNwYWNlOk19KSksZmUocSx0LHIsYSxuKX1pZihjPT09dSYmbWUoZSwwLG4pJiYocGUodCwoRD1lLnByZWZpeHx8XCJcIik/XCJ4bWxuczpcIitEOlwieG1sbnNcIixNPWUubmFtZXNwYWNlVVJJKSxuLnB1c2goe3ByZWZpeDpELG5hbWVzcGFjZTpNfSkpLGx8fHImJiEvXig/Om1ldGF8bGlua3xpbWd8YnJ8aHJ8aW5wdXQpJC9pLnRlc3QoYykpe2lmKHQucHVzaChcIj5cIiksciYmL15zY3JpcHQkL2kudGVzdChjKSlmb3IoO2w7KWwuZGF0YT90LnB1c2gobC5kYXRhKTpmZShsLHQscixhLG4uc2xpY2UoKSksbD1sLm5leHRTaWJsaW5nO2Vsc2UgZm9yKDtsOylmZShsLHQscixhLG4uc2xpY2UoKSksbD1sLm5leHRTaWJsaW5nO3QucHVzaChcIjwvXCIsdSxcIj5cIil9ZWxzZSB0LnB1c2goXCIvPlwiKTtyZXR1cm47Y2FzZSB2OmNhc2UgQTpmb3IobD1lLmZpcnN0Q2hpbGQ7bDspZmUobCx0LHIsYSxuLnNsaWNlKCkpLGw9bC5uZXh0U2libGluZztyZXR1cm47Y2FzZSBtOnJldHVybiBwZSh0LGUubmFtZSxlLnZhbHVlKTtjYXNlIHA6cmV0dXJuIHQucHVzaChlLmRhdGEucmVwbGFjZSgvWzwmPl0vZyxJKSk7Y2FzZSBmOnJldHVybiB0LnB1c2goXCI8IVtDREFUQVtcIixlLmRhdGEsXCJdXT5cIik7Y2FzZSBiOnJldHVybiB0LnB1c2goXCJcXHgzYyEtLVwiLGUuZGF0YSxcIi0tXFx4M2VcIik7Y2FzZSBDOnZhciBUPWUucHVibGljSWQsTj1lLnN5c3RlbUlkO2lmKHQucHVzaChcIjwhRE9DVFlQRSBcIixlLm5hbWUpLFQpdC5wdXNoKFwiIFBVQkxJQyBcIixUKSxOJiZcIi5cIiE9TiYmdC5wdXNoKFwiIFwiLE4pLHQucHVzaChcIj5cIik7ZWxzZSBpZihOJiZcIi5cIiE9Til0LnB1c2goXCIgU1lTVEVNIFwiLE4sXCI+XCIpO2Vsc2V7dmFyIE89ZS5pbnRlcm5hbFN1YnNldDtPJiZ0LnB1c2goXCIgW1wiLE8sXCJdXCIpLHQucHVzaChcIj5cIil9cmV0dXJuO2Nhc2UgdzpyZXR1cm4gdC5wdXNoKFwiPD9cIixlLnRhcmdldCxcIiBcIixlLmRhdGEsXCI/PlwiKTtjYXNlIHg6cmV0dXJuIHQucHVzaChcIiZcIixlLm5vZGVOYW1lLFwiO1wiKTtkZWZhdWx0OnQucHVzaChcIj8/XCIsZS5ub2RlTmFtZSl9fWZ1bmN0aW9uIHhlKGUsdCxyKXt2YXIgYTtzd2l0Y2godC5ub2RlVHlwZSl7Y2FzZSBkOihhPXQuY2xvbmVOb2RlKCExKSkub3duZXJEb2N1bWVudD1lO2Nhc2UgQTpicmVhaztjYXNlIG06cj0hMH1pZihhfHwoYT10LmNsb25lTm9kZSghMSkpLGEub3duZXJEb2N1bWVudD1lLGEucGFyZW50Tm9kZT1udWxsLHIpZm9yKHZhciBuPXQuZmlyc3RDaGlsZDtuOylhLmFwcGVuZENoaWxkKHhlKGUsbixyKSksbj1uLm5leHRTaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGdlKGUsdCxyKXt2YXIgYT1uZXcgdC5jb25zdHJ1Y3Rvcjtmb3IodmFyIG4gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSl7dmFyIG89dFtuXTtcIm9iamVjdFwiIT10eXBlb2YgbyYmbyE9YVtuXSYmKGFbbl09byl9c3dpdGNoKHQuY2hpbGROb2RlcyYmKGEuY2hpbGROb2Rlcz1uZXcgTiksYS5vd25lckRvY3VtZW50PWUsYS5ub2RlVHlwZSl7Y2FzZSBkOnZhciBpPXQuYXR0cmlidXRlcyxzPWEuYXR0cmlidXRlcz1uZXcgQixsPWkubGVuZ3RoO3MuX293bmVyRWxlbWVudD1hO2Zvcih2YXIgYz0wO2M8bDtjKyspYS5zZXRBdHRyaWJ1dGVOb2RlKGdlKGUsaS5pdGVtKGMpLCEwKSk7YnJlYWs7Y2FzZSBtOnI9ITB9aWYocilmb3IodmFyIHU9dC5maXJzdENoaWxkO3U7KWEuYXBwZW5kQ2hpbGQoZ2UoZSx1LHIpKSx1PXUubmV4dFNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gd2UoZSx0LHIpe2VbdF09cn1fLklOVkFMSURfU1RBVEVfRVJSPSh5WzExXT1cIkludmFsaWQgc3RhdGVcIiwxMSksXy5TWU5UQVhfRVJSPSh5WzEyXT1cIlN5bnRheCBlcnJvclwiLDEyKSxfLklOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUj0oeVsxM109XCJJbnZhbGlkIG1vZGlmaWNhdGlvblwiLDEzKSxfLk5BTUVTUEFDRV9FUlI9KHlbMTRdPVwiSW52YWxpZCBuYW1lc3BhY2VcIiwxNCksXy5JTlZBTElEX0FDQ0VTU19FUlI9KHlbMTVdPVwiSW52YWxpZCBhY2Nlc3NcIiwxNSksVC5wcm90b3R5cGU9RXJyb3IucHJvdG90eXBlLGMoXyxUKSxOLnByb3RvdHlwZT17bGVuZ3RoOjAsaXRlbTpmdW5jdGlvbihlKXtyZXR1cm4gZT49MCYmZTx0aGlzLmxlbmd0aD90aGlzW2VdOm51bGx9LHRvU3RyaW5nOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPVtdLGE9MDthPHRoaXMubGVuZ3RoO2ErKylmZSh0aGlzW2FdLHIsZSx0KTtyZXR1cm4gci5qb2luKFwiXCIpfSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0aGlzLGUpfSxpbmRleE9mOmZ1bmN0aW9uKGUpe3JldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsZSl9fSxPLnByb3RvdHlwZS5pdGVtPWZ1bmN0aW9uKGUpe3JldHVybiBMKHRoaXMpLHRoaXNbZV18fG51bGx9LHUoTyxOKSxCLnByb3RvdHlwZT17bGVuZ3RoOjAsaXRlbTpOLnByb3RvdHlwZS5pdGVtLGdldE5hbWVkSXRlbTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5sZW5ndGg7dC0tOyl7dmFyIHI9dGhpc1t0XTtpZihyLm5vZGVOYW1lPT1lKXJldHVybiByfX0sc2V0TmFtZWRJdGVtOmZ1bmN0aW9uKGUpe3ZhciB0PWUub3duZXJFbGVtZW50O2lmKHQmJnQhPXRoaXMuX293bmVyRWxlbWVudCl0aHJvdyBuZXcgVChNKTt2YXIgcj10aGlzLmdldE5hbWVkSXRlbShlLm5vZGVOYW1lKTtyZXR1cm4gRih0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxlLHIpLHJ9LHNldE5hbWVkSXRlbU5TOmZ1bmN0aW9uKGUpe3ZhciB0LHI9ZS5vd25lckVsZW1lbnQ7aWYociYmciE9dGhpcy5fb3duZXJFbGVtZW50KXRocm93IG5ldyBUKE0pO3JldHVybiB0PXRoaXMuZ2V0TmFtZWRJdGVtTlMoZS5uYW1lc3BhY2VVUkksZS5sb2NhbE5hbWUpLEYodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsZSx0KSx0fSxyZW1vdmVOYW1lZEl0ZW06ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXROYW1lZEl0ZW0oZSk7cmV0dXJuIFAodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsdCksdH0scmVtb3ZlTmFtZWRJdGVtTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmdldE5hbWVkSXRlbU5TKGUsdCk7cmV0dXJuIFAodGhpcy5fb3duZXJFbGVtZW50LHRoaXMscikscn0sZ2V0TmFtZWRJdGVtTlM6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9dGhpcy5sZW5ndGg7ci0tOyl7dmFyIGE9dGhpc1tyXTtpZihhLmxvY2FsTmFtZT09dCYmYS5uYW1lc3BhY2VVUkk9PWUpcmV0dXJuIGF9cmV0dXJuIG51bGx9fSxrLnByb3RvdHlwZT17aGFzRmVhdHVyZTpmdW5jdGlvbihlLHQpe3JldHVybiEwfSxjcmVhdGVEb2N1bWVudDpmdW5jdGlvbihlLHQscil7dmFyIGE9bmV3IGo7aWYoYS5pbXBsZW1lbnRhdGlvbj10aGlzLGEuY2hpbGROb2Rlcz1uZXcgTixhLmRvY3R5cGU9cnx8bnVsbCxyJiZhLmFwcGVuZENoaWxkKHIpLHQpe3ZhciBuPWEuY3JlYXRlRWxlbWVudE5TKGUsdCk7YS5hcHBlbmRDaGlsZChuKX1yZXR1cm4gYX0sY3JlYXRlRG9jdW1lbnRUeXBlOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1uZXcgb2U7cmV0dXJuIGEubmFtZT1lLGEubm9kZU5hbWU9ZSxhLnB1YmxpY0lkPXR8fFwiXCIsYS5zeXN0ZW1JZD1yfHxcIlwiLGF9fSxSLnByb3RvdHlwZT17Zmlyc3RDaGlsZDpudWxsLGxhc3RDaGlsZDpudWxsLHByZXZpb3VzU2libGluZzpudWxsLG5leHRTaWJsaW5nOm51bGwsYXR0cmlidXRlczpudWxsLHBhcmVudE5vZGU6bnVsbCxjaGlsZE5vZGVzOm51bGwsb3duZXJEb2N1bWVudDpudWxsLG5vZGVWYWx1ZTpudWxsLG5hbWVzcGFjZVVSSTpudWxsLHByZWZpeDpudWxsLGxvY2FsTmFtZTpudWxsLGluc2VydEJlZm9yZTpmdW5jdGlvbihlLHQpe3JldHVybiBRKHRoaXMsZSx0KX0scmVwbGFjZUNoaWxkOmZ1bmN0aW9uKGUsdCl7USh0aGlzLGUsdCxaKSx0JiZ0aGlzLnJlbW92ZUNoaWxkKHQpfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihlKXtyZXR1cm4gJCh0aGlzLGUpfSxhcHBlbmRDaGlsZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoZSxudWxsKX0saGFzQ2hpbGROb2RlczpmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmZpcnN0Q2hpbGR9LGNsb25lTm9kZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UodGhpcy5vd25lckRvY3VtZW50fHx0aGlzLHRoaXMsZSl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLmZpcnN0Q2hpbGQ7ZTspe3ZhciB0PWUubmV4dFNpYmxpbmc7dCYmdC5ub2RlVHlwZT09cCYmZS5ub2RlVHlwZT09cD8odGhpcy5yZW1vdmVDaGlsZCh0KSxlLmFwcGVuZERhdGEodC5kYXRhKSk6KGUubm9ybWFsaXplKCksZT10KX19LGlzU3VwcG9ydGVkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKGUsdCl9LGhhc0F0dHJpYnV0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aD4wfSxsb29rdXBQcmVmaXg6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXM7dDspe3ZhciByPXQuX25zTWFwO2lmKHIpZm9yKHZhciBhIGluIHIpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsYSkmJnJbYV09PT1lKXJldHVybiBhO3Q9dC5ub2RlVHlwZT09bT90Lm93bmVyRG9jdW1lbnQ6dC5wYXJlbnROb2RlfXJldHVybiBudWxsfSxsb29rdXBOYW1lc3BhY2VVUkk6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXM7dDspe3ZhciByPXQuX25zTWFwO2lmKHImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpKXJldHVybiByW2VdO3Q9dC5ub2RlVHlwZT09bT90Lm93bmVyRG9jdW1lbnQ6dC5wYXJlbnROb2RlfXJldHVybiBudWxsfSxpc0RlZmF1bHROYW1lc3BhY2U6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PXRoaXMubG9va3VwUHJlZml4KGUpfX0sYyhoLFIpLGMoaCxSLnByb3RvdHlwZSksai5wcm90b3R5cGU9e25vZGVOYW1lOlwiI2RvY3VtZW50XCIsbm9kZVR5cGU6dixkb2N0eXBlOm51bGwsZG9jdW1lbnRFbGVtZW50Om51bGwsX2luYzoxLGluc2VydEJlZm9yZTpmdW5jdGlvbihlLHQpe2lmKGUubm9kZVR5cGU9PUEpe2Zvcih2YXIgcj1lLmZpcnN0Q2hpbGQ7cjspe3ZhciBhPXIubmV4dFNpYmxpbmc7dGhpcy5pbnNlcnRCZWZvcmUocix0KSxyPWF9cmV0dXJuIGV9cmV0dXJuIFEodGhpcyxlLHQpLGUub3duZXJEb2N1bWVudD10aGlzLG51bGw9PT10aGlzLmRvY3VtZW50RWxlbWVudCYmZS5ub2RlVHlwZT09PWQmJih0aGlzLmRvY3VtZW50RWxlbWVudD1lKSxlfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnQ9PWUmJih0aGlzLmRvY3VtZW50RWxlbWVudD1udWxsKSwkKHRoaXMsZSl9LHJlcGxhY2VDaGlsZDpmdW5jdGlvbihlLHQpe1EodGhpcyxlLHQsWiksZS5vd25lckRvY3VtZW50PXRoaXMsdCYmdGhpcy5yZW1vdmVDaGlsZCh0KSxIKGUpJiYodGhpcy5kb2N1bWVudEVsZW1lbnQ9ZSl9LGltcG9ydE5vZGU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4geGUodGhpcyxlLHQpfSxnZXRFbGVtZW50QnlJZDpmdW5jdGlvbihlKXt2YXIgdD1udWxsO3JldHVybiBVKHRoaXMuZG9jdW1lbnRFbGVtZW50LChmdW5jdGlvbihyKXtpZihyLm5vZGVUeXBlPT1kJiZyLmdldEF0dHJpYnV0ZShcImlkXCIpPT1lKXJldHVybiB0PXIsITB9KSksdH0sZ2V0RWxlbWVudHNCeUNsYXNzTmFtZTpmdW5jdGlvbihlKXt2YXIgdD1sKGUpO3JldHVybiBuZXcgTyh0aGlzLChmdW5jdGlvbihyKXt2YXIgYT1bXTtyZXR1cm4gdC5sZW5ndGg+MCYmVShyLmRvY3VtZW50RWxlbWVudCwoZnVuY3Rpb24obil7aWYobiE9PXImJm4ubm9kZVR5cGU9PT1kKXt2YXIgbz1uLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO2lmKG8pe3ZhciBpPWU9PT1vO2lmKCFpKXt2YXIgcz1sKG8pO2k9dC5ldmVyeSgoYz1zLGZ1bmN0aW9uKGUpe3JldHVybiBjJiYtMSE9PWMuaW5kZXhPZihlKX0pKX1pJiZhLnB1c2gobil9fXZhciBjfSkpLGF9KSl9LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEs7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQubm9kZU5hbWU9ZSx0LnRhZ05hbWU9ZSx0LmxvY2FsTmFtZT1lLHQuY2hpbGROb2Rlcz1uZXcgTiwodC5hdHRyaWJ1dGVzPW5ldyBCKS5fb3duZXJFbGVtZW50PXQsdH0sY3JlYXRlRG9jdW1lbnRGcmFnbWVudDpmdW5jdGlvbigpe3ZhciBlPW5ldyBjZTtyZXR1cm4gZS5vd25lckRvY3VtZW50PXRoaXMsZS5jaGlsZE5vZGVzPW5ldyBOLGV9LGNyZWF0ZVRleHROb2RlOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyByZTtyZXR1cm4gdC5vd25lckRvY3VtZW50PXRoaXMsdC5hcHBlbmREYXRhKGUpLHR9LGNyZWF0ZUNvbW1lbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGFlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0LmFwcGVuZERhdGEoZSksdH0sY3JlYXRlQ0RBVEFTZWN0aW9uOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuZTtyZXR1cm4gdC5vd25lckRvY3VtZW50PXRoaXMsdC5hcHBlbmREYXRhKGUpLHR9LGNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbjpmdW5jdGlvbihlLHQpe3ZhciByPW5ldyB1ZTtyZXR1cm4gci5vd25lckRvY3VtZW50PXRoaXMsci50YWdOYW1lPXIubm9kZU5hbWU9ci50YXJnZXQ9ZSxyLm5vZGVWYWx1ZT1yLmRhdGE9dCxyfSxjcmVhdGVBdHRyaWJ1dGU6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGVlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0Lm5hbWU9ZSx0Lm5vZGVOYW1lPWUsdC5sb2NhbE5hbWU9ZSx0LnNwZWNpZmllZD0hMCx0fSxjcmVhdGVFbnRpdHlSZWZlcmVuY2U6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGxlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0Lm5vZGVOYW1lPWUsdH0sY3JlYXRlRWxlbWVudE5TOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEssYT10LnNwbGl0KFwiOlwiKSxuPXIuYXR0cmlidXRlcz1uZXcgQjtyZXR1cm4gci5jaGlsZE5vZGVzPW5ldyBOLHIub3duZXJEb2N1bWVudD10aGlzLHIubm9kZU5hbWU9dCxyLnRhZ05hbWU9dCxyLm5hbWVzcGFjZVVSST1lLDI9PWEubGVuZ3RoPyhyLnByZWZpeD1hWzBdLHIubG9jYWxOYW1lPWFbMV0pOnIubG9jYWxOYW1lPXQsbi5fb3duZXJFbGVtZW50PXIscn0sY3JlYXRlQXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgZWUsYT10LnNwbGl0KFwiOlwiKTtyZXR1cm4gci5vd25lckRvY3VtZW50PXRoaXMsci5ub2RlTmFtZT10LHIubmFtZT10LHIubmFtZXNwYWNlVVJJPWUsci5zcGVjaWZpZWQ9ITAsMj09YS5sZW5ndGg/KHIucHJlZml4PWFbMF0sci5sb2NhbE5hbWU9YVsxXSk6ci5sb2NhbE5hbWU9dCxyfX0sdShqLFIpLEsucHJvdG90eXBlPXtub2RlVHlwZTpkLGhhc0F0dHJpYnV0ZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlKGUpfSxnZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlKGUpO3JldHVybiB0JiZ0LnZhbHVlfHxcIlwifSxnZXRBdHRyaWJ1dGVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKGUpfSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKGUpO3IudmFsdWU9ci5ub2RlVmFsdWU9XCJcIit0LHRoaXMuc2V0QXR0cmlidXRlTm9kZShyKX0scmVtb3ZlQXR0cmlidXRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0QXR0cmlidXRlTm9kZShlKTt0JiZ0aGlzLnJlbW92ZUF0dHJpYnV0ZU5vZGUodCl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVUeXBlPT09QT90aGlzLmluc2VydEJlZm9yZShlLG51bGwpOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLHQucGFyZW50Tm9kZT1lLHQucHJldmlvdXNTaWJsaW5nPWUubGFzdENoaWxkLHQubmV4dFNpYmxpbmc9bnVsbCx0LnByZXZpb3VzU2libGluZz90LnByZXZpb3VzU2libGluZy5uZXh0U2libGluZz10OmUuZmlyc3RDaGlsZD10LGUubGFzdENoaWxkPXQsRyhlLm93bmVyRG9jdW1lbnQsZSx0KSx0fSh0aGlzLGUpfSxzZXRBdHRyaWJ1dGVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtKGUpfSxzZXRBdHRyaWJ1dGVOb2RlTlM6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW1OUyhlKX0scmVtb3ZlQXR0cmlidXRlTm9kZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbShlLm5vZGVOYW1lKX0scmVtb3ZlQXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhlLHQpO3ImJnRoaXMucmVtb3ZlQXR0cmlidXRlTm9kZShyKX0saGFzQXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlTlMoZSx0KX0sZ2V0QXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhlLHQpO3JldHVybiByJiZyLnZhbHVlfHxcIlwifSxzZXRBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQscil7dmFyIGE9dGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZU5TKGUsdCk7YS52YWx1ZT1hLm5vZGVWYWx1ZT1cIlwiK3IsdGhpcy5zZXRBdHRyaWJ1dGVOb2RlKGEpfSxnZXRBdHRyaWJ1dGVOb2RlTlM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbU5TKGUsdCl9LGdldEVsZW1lbnRzQnlUYWdOYW1lOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgTyh0aGlzLChmdW5jdGlvbih0KXt2YXIgcj1bXTtyZXR1cm4gVSh0LChmdW5jdGlvbihhKXthPT09dHx8YS5ub2RlVHlwZSE9ZHx8XCIqXCIhPT1lJiZhLnRhZ05hbWUhPWV8fHIucHVzaChhKX0pKSxyfSkpfSxnZXRFbGVtZW50c0J5VGFnTmFtZU5TOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBPKHRoaXMsKGZ1bmN0aW9uKHIpe3ZhciBhPVtdO3JldHVybiBVKHIsKGZ1bmN0aW9uKG4pe249PT1yfHxuLm5vZGVUeXBlIT09ZHx8XCIqXCIhPT1lJiZuLm5hbWVzcGFjZVVSSSE9PWV8fFwiKlwiIT09dCYmbi5sb2NhbE5hbWUhPXR8fGEucHVzaChuKX0pKSxhfSkpfX0sai5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU9Sy5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUsai5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUz1LLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TLHUoSyxSKSxlZS5wcm90b3R5cGUubm9kZVR5cGU9bSx1KGVlLFIpLHRlLnByb3RvdHlwZT17ZGF0YTpcIlwiLHN1YnN0cmluZ0RhdGE6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5kYXRhLnN1YnN0cmluZyhlLGUrdCl9LGFwcGVuZERhdGE6ZnVuY3Rpb24oZSl7ZT10aGlzLmRhdGErZSx0aGlzLm5vZGVWYWx1ZT10aGlzLmRhdGE9ZSx0aGlzLmxlbmd0aD1lLmxlbmd0aH0saW5zZXJ0RGF0YTpmdW5jdGlvbihlLHQpe3RoaXMucmVwbGFjZURhdGEoZSwwLHQpfSxhcHBlbmRDaGlsZDpmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoeVtxXSl9LGRlbGV0ZURhdGE6ZnVuY3Rpb24oZSx0KXt0aGlzLnJlcGxhY2VEYXRhKGUsdCxcIlwiKX0scmVwbGFjZURhdGE6ZnVuY3Rpb24oZSx0LHIpe3I9dGhpcy5kYXRhLnN1YnN0cmluZygwLGUpK3IrdGhpcy5kYXRhLnN1YnN0cmluZyhlK3QpLHRoaXMubm9kZVZhbHVlPXRoaXMuZGF0YT1yLHRoaXMubGVuZ3RoPXIubGVuZ3RofX0sdSh0ZSxSKSxyZS5wcm90b3R5cGU9e25vZGVOYW1lOlwiI3RleHRcIixub2RlVHlwZTpwLHNwbGl0VGV4dDpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmRhdGEscj10LnN1YnN0cmluZyhlKTt0PXQuc3Vic3RyaW5nKDAsZSksdGhpcy5kYXRhPXRoaXMubm9kZVZhbHVlPXQsdGhpcy5sZW5ndGg9dC5sZW5ndGg7dmFyIGE9dGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHIpO3JldHVybiB0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSx0aGlzLm5leHRTaWJsaW5nKSxhfX0sdShyZSx0ZSksYWUucHJvdG90eXBlPXtub2RlTmFtZTpcIiNjb21tZW50XCIsbm9kZVR5cGU6Yn0sdShhZSx0ZSksbmUucHJvdG90eXBlPXtub2RlTmFtZTpcIiNjZGF0YS1zZWN0aW9uXCIsbm9kZVR5cGU6Zn0sdShuZSx0ZSksb2UucHJvdG90eXBlLm5vZGVUeXBlPUMsdShvZSxSKSxpZS5wcm90b3R5cGUubm9kZVR5cGU9RSx1KGllLFIpLHNlLnByb3RvdHlwZS5ub2RlVHlwZT1nLHUoc2UsUiksbGUucHJvdG90eXBlLm5vZGVUeXBlPXgsdShsZSxSKSxjZS5wcm90b3R5cGUubm9kZU5hbWU9XCIjZG9jdW1lbnQtZnJhZ21lbnRcIixjZS5wcm90b3R5cGUubm9kZVR5cGU9QSx1KGNlLFIpLHVlLnByb3RvdHlwZS5ub2RlVHlwZT13LHUodWUsUiksaGUucHJvdG90eXBlLnNlcmlhbGl6ZVRvU3RyaW5nPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZGUuY2FsbChlLHQscil9LFIucHJvdG90eXBlLnRvU3RyaW5nPWRlO3RyeXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe2Z1bmN0aW9uIGJlKGUpe3N3aXRjaChlLm5vZGVUeXBlKXtjYXNlIGQ6Y2FzZSBBOnZhciB0PVtdO2ZvcihlPWUuZmlyc3RDaGlsZDtlOyk3IT09ZS5ub2RlVHlwZSYmOCE9PWUubm9kZVR5cGUmJnQucHVzaChiZShlKSksZT1lLm5leHRTaWJsaW5nO3JldHVybiB0LmpvaW4oXCJcIik7ZGVmYXVsdDpyZXR1cm4gZS5ub2RlVmFsdWV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLnByb3RvdHlwZSxcImxlbmd0aFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTCh0aGlzKSx0aGlzLiQkbGVuZ3RofX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSLnByb3RvdHlwZSxcInRleHRDb250ZW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiZSh0aGlzKX0sc2V0OmZ1bmN0aW9uKGUpe3N3aXRjaCh0aGlzLm5vZGVUeXBlKXtjYXNlIGQ6Y2FzZSBBOmZvcig7dGhpcy5maXJzdENoaWxkOyl0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7KGV8fFN0cmluZyhlKSkmJnRoaXMuYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGUpKTticmVhaztkZWZhdWx0OnRoaXMuZGF0YT1lLHRoaXMudmFsdWU9ZSx0aGlzLm5vZGVWYWx1ZT1lfX19KSx3ZT1mdW5jdGlvbihlLHQscil7ZVtcIiQkXCIrdF09cn19fWNhdGNoKHZlKXt9dC5Eb2N1bWVudFR5cGU9b2UsdC5ET01FeGNlcHRpb249VCx0LkRPTUltcGxlbWVudGF0aW9uPWssdC5FbGVtZW50PUssdC5Ob2RlPVIsdC5Ob2RlTGlzdD1OLHQuWE1MU2VyaWFsaXplcj1oZX0sNjU1OTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9cig0NTgyKS5mcmVlemU7dC5YTUxfRU5USVRJRVM9YSh7YW1wOlwiJlwiLGFwb3M6XCInXCIsZ3Q6XCI+XCIsbHQ6XCI8XCIscXVvdDonXCInfSksdC5IVE1MX0VOVElUSUVTPWEoe0FhY3V0ZTpcIsOBXCIsYWFjdXRlOlwiw6FcIixBYnJldmU6XCLEglwiLGFicmV2ZTpcIsSDXCIsYWM6XCLiiL5cIixhY2Q6XCLiiL9cIixhY0U6XCLiiL7Ms1wiLEFjaXJjOlwiw4JcIixhY2lyYzpcIsOiXCIsYWN1dGU6XCLCtFwiLEFjeTpcItCQXCIsYWN5Olwi0LBcIixBRWxpZzpcIsOGXCIsYWVsaWc6XCLDplwiLGFmOlwi4oGhXCIsQWZyOlwi8J2UhFwiLGFmcjpcIvCdlJ5cIixBZ3JhdmU6XCLDgFwiLGFncmF2ZTpcIsOgXCIsYWxlZnN5bTpcIuKEtVwiLGFsZXBoOlwi4oS1XCIsQWxwaGE6XCLOkVwiLGFscGhhOlwizrFcIixBbWFjcjpcIsSAXCIsYW1hY3I6XCLEgVwiLGFtYWxnOlwi4qi/XCIsQU1QOlwiJlwiLGFtcDpcIiZcIixBbmQ6XCLiqZNcIixhbmQ6XCLiiKdcIixhbmRhbmQ6XCLiqZVcIixhbmRkOlwi4qmcXCIsYW5kc2xvcGU6XCLiqZhcIixhbmR2Olwi4qmaXCIsYW5nOlwi4oigXCIsYW5nZTpcIuKmpFwiLGFuZ2xlOlwi4oigXCIsYW5nbXNkOlwi4oihXCIsYW5nbXNkYWE6XCLipqhcIixhbmdtc2RhYjpcIuKmqVwiLGFuZ21zZGFjOlwi4qaqXCIsYW5nbXNkYWQ6XCLipqtcIixhbmdtc2RhZTpcIuKmrFwiLGFuZ21zZGFmOlwi4qatXCIsYW5nbXNkYWc6XCLipq5cIixhbmdtc2RhaDpcIuKmr1wiLGFuZ3J0Olwi4oifXCIsYW5ncnR2YjpcIuKKvlwiLGFuZ3J0dmJkOlwi4qadXCIsYW5nc3BoOlwi4oiiXCIsYW5nc3Q6XCLDhVwiLGFuZ3phcnI6XCLijbxcIixBb2dvbjpcIsSEXCIsYW9nb246XCLEhVwiLEFvcGY6XCLwnZS4XCIsYW9wZjpcIvCdlZJcIixhcDpcIuKJiFwiLGFwYWNpcjpcIuKpr1wiLGFwRTpcIuKpsFwiLGFwZTpcIuKJilwiLGFwaWQ6XCLiiYtcIixhcG9zOlwiJ1wiLEFwcGx5RnVuY3Rpb246XCLigaFcIixhcHByb3g6XCLiiYhcIixhcHByb3hlcTpcIuKJilwiLEFyaW5nOlwiw4VcIixhcmluZzpcIsOlXCIsQXNjcjpcIvCdkpxcIixhc2NyOlwi8J2StlwiLEFzc2lnbjpcIuKJlFwiLGFzdDpcIipcIixhc3ltcDpcIuKJiFwiLGFzeW1wZXE6XCLiiY1cIixBdGlsZGU6XCLDg1wiLGF0aWxkZTpcIsOjXCIsQXVtbDpcIsOEXCIsYXVtbDpcIsOkXCIsYXdjb25pbnQ6XCLiiLNcIixhd2ludDpcIuKokVwiLGJhY2tjb25nOlwi4omMXCIsYmFja2Vwc2lsb246XCLPtlwiLGJhY2twcmltZTpcIuKAtVwiLGJhY2tzaW06XCLiiL1cIixiYWNrc2ltZXE6XCLii41cIixCYWNrc2xhc2g6XCLiiJZcIixCYXJ2Olwi4qunXCIsYmFydmVlOlwi4oq9XCIsQmFyd2VkOlwi4oyGXCIsYmFyd2VkOlwi4oyFXCIsYmFyd2VkZ2U6XCLijIVcIixiYnJrOlwi4o61XCIsYmJya3Ricms6XCLijrZcIixiY29uZzpcIuKJjFwiLEJjeTpcItCRXCIsYmN5Olwi0LFcIixiZHF1bzpcIuKAnlwiLGJlY2F1czpcIuKItVwiLEJlY2F1c2U6XCLiiLVcIixiZWNhdXNlOlwi4oi1XCIsYmVtcHR5djpcIuKmsFwiLGJlcHNpOlwiz7ZcIixiZXJub3U6XCLihKxcIixCZXJub3VsbGlzOlwi4oSsXCIsQmV0YTpcIs6SXCIsYmV0YTpcIs6yXCIsYmV0aDpcIuKEtlwiLGJldHdlZW46XCLiiaxcIixCZnI6XCLwnZSFXCIsYmZyOlwi8J2Un1wiLGJpZ2NhcDpcIuKLglwiLGJpZ2NpcmM6XCLil69cIixiaWdjdXA6XCLii4NcIixiaWdvZG90Olwi4qiAXCIsYmlnb3BsdXM6XCLiqIFcIixiaWdvdGltZXM6XCLiqIJcIixiaWdzcWN1cDpcIuKohlwiLGJpZ3N0YXI6XCLimIVcIixiaWd0cmlhbmdsZWRvd246XCLilr1cIixiaWd0cmlhbmdsZXVwOlwi4pazXCIsYmlndXBsdXM6XCLiqIRcIixiaWd2ZWU6XCLii4FcIixiaWd3ZWRnZTpcIuKLgFwiLGJrYXJvdzpcIuKkjVwiLGJsYWNrbG96ZW5nZTpcIuKnq1wiLGJsYWNrc3F1YXJlOlwi4paqXCIsYmxhY2t0cmlhbmdsZTpcIuKWtFwiLGJsYWNrdHJpYW5nbGVkb3duOlwi4pa+XCIsYmxhY2t0cmlhbmdsZWxlZnQ6XCLil4JcIixibGFja3RyaWFuZ2xlcmlnaHQ6XCLilrhcIixibGFuazpcIuKQo1wiLGJsazEyOlwi4paSXCIsYmxrMTQ6XCLilpFcIixibGszNDpcIuKWk1wiLGJsb2NrOlwi4paIXCIsYm5lOlwiPeKDpVwiLGJuZXF1aXY6XCLiiaHig6VcIixiTm90Olwi4qutXCIsYm5vdDpcIuKMkFwiLEJvcGY6XCLwnZS5XCIsYm9wZjpcIvCdlZNcIixib3Q6XCLiiqVcIixib3R0b206XCLiiqVcIixib3d0aWU6XCLii4hcIixib3hib3g6XCLip4lcIixib3hETDpcIuKVl1wiLGJveERsOlwi4pWWXCIsYm94ZEw6XCLilZVcIixib3hkbDpcIuKUkFwiLGJveERSOlwi4pWUXCIsYm94RHI6XCLilZNcIixib3hkUjpcIuKVklwiLGJveGRyOlwi4pSMXCIsYm94SDpcIuKVkFwiLGJveGg6XCLilIBcIixib3hIRDpcIuKVplwiLGJveEhkOlwi4pWkXCIsYm94aEQ6XCLilaVcIixib3hoZDpcIuKUrFwiLGJveEhVOlwi4pWpXCIsYm94SHU6XCLiladcIixib3hoVTpcIuKVqFwiLGJveGh1Olwi4pS0XCIsYm94bWludXM6XCLiip9cIixib3hwbHVzOlwi4oqeXCIsYm94dGltZXM6XCLiiqBcIixib3hVTDpcIuKVnVwiLGJveFVsOlwi4pWcXCIsYm94dUw6XCLilZtcIixib3h1bDpcIuKUmFwiLGJveFVSOlwi4pWaXCIsYm94VXI6XCLilZlcIixib3h1UjpcIuKVmFwiLGJveHVyOlwi4pSUXCIsYm94VjpcIuKVkVwiLGJveHY6XCLilIJcIixib3hWSDpcIuKVrFwiLGJveFZoOlwi4pWrXCIsYm94dkg6XCLilapcIixib3h2aDpcIuKUvFwiLGJveFZMOlwi4pWjXCIsYm94Vmw6XCLilaJcIixib3h2TDpcIuKVoVwiLGJveHZsOlwi4pSkXCIsYm94VlI6XCLilaBcIixib3hWcjpcIuKVn1wiLGJveHZSOlwi4pWeXCIsYm94dnI6XCLilJxcIixicHJpbWU6XCLigLVcIixCcmV2ZTpcIsuYXCIsYnJldmU6XCLLmFwiLGJydmJhcjpcIsKmXCIsQnNjcjpcIuKErFwiLGJzY3I6XCLwnZK3XCIsYnNlbWk6XCLigY9cIixic2ltOlwi4oi9XCIsYnNpbWU6XCLii41cIixic29sOlwiXFxcXFwiLGJzb2xiOlwi4qeFXCIsYnNvbGhzdWI6XCLin4hcIixidWxsOlwi4oCiXCIsYnVsbGV0Olwi4oCiXCIsYnVtcDpcIuKJjlwiLGJ1bXBFOlwi4qquXCIsYnVtcGU6XCLiiY9cIixCdW1wZXE6XCLiiY5cIixidW1wZXE6XCLiiY9cIixDYWN1dGU6XCLEhlwiLGNhY3V0ZTpcIsSHXCIsQ2FwOlwi4ouSXCIsY2FwOlwi4oipXCIsY2FwYW5kOlwi4qmEXCIsY2FwYnJjdXA6XCLiqYlcIixjYXBjYXA6XCLiqYtcIixjYXBjdXA6XCLiqYdcIixjYXBkb3Q6XCLiqYBcIixDYXBpdGFsRGlmZmVyZW50aWFsRDpcIuKFhVwiLGNhcHM6XCLiiKnvuIBcIixjYXJldDpcIuKBgVwiLGNhcm9uOlwiy4dcIixDYXlsZXlzOlwi4oStXCIsY2NhcHM6XCLiqY1cIixDY2Fyb246XCLEjFwiLGNjYXJvbjpcIsSNXCIsQ2NlZGlsOlwiw4dcIixjY2VkaWw6XCLDp1wiLENjaXJjOlwixIhcIixjY2lyYzpcIsSJXCIsQ2NvbmludDpcIuKIsFwiLGNjdXBzOlwi4qmMXCIsY2N1cHNzbTpcIuKpkFwiLENkb3Q6XCLEilwiLGNkb3Q6XCLEi1wiLGNlZGlsOlwiwrhcIixDZWRpbGxhOlwiwrhcIixjZW1wdHl2Olwi4qayXCIsY2VudDpcIsKiXCIsQ2VudGVyRG90OlwiwrdcIixjZW50ZXJkb3Q6XCLCt1wiLENmcjpcIuKErVwiLGNmcjpcIvCdlKBcIixDSGN5Olwi0KdcIixjaGN5Olwi0YdcIixjaGVjazpcIuKck1wiLGNoZWNrbWFyazpcIuKck1wiLENoaTpcIs6nXCIsY2hpOlwiz4dcIixjaXI6XCLil4tcIixjaXJjOlwiy4ZcIixjaXJjZXE6XCLiiZdcIixjaXJjbGVhcnJvd2xlZnQ6XCLihrpcIixjaXJjbGVhcnJvd3JpZ2h0Olwi4oa7XCIsY2lyY2xlZGFzdDpcIuKKm1wiLGNpcmNsZWRjaXJjOlwi4oqaXCIsY2lyY2xlZGRhc2g6XCLiip1cIixDaXJjbGVEb3Q6XCLiiplcIixjaXJjbGVkUjpcIsKuXCIsY2lyY2xlZFM6XCLik4hcIixDaXJjbGVNaW51czpcIuKKllwiLENpcmNsZVBsdXM6XCLiipVcIixDaXJjbGVUaW1lczpcIuKKl1wiLGNpckU6XCLip4NcIixjaXJlOlwi4omXXCIsY2lyZm5pbnQ6XCLiqJBcIixjaXJtaWQ6XCLiq69cIixjaXJzY2lyOlwi4qeCXCIsQ2xvY2t3aXNlQ29udG91ckludGVncmFsOlwi4oiyXCIsQ2xvc2VDdXJseURvdWJsZVF1b3RlOlwi4oCdXCIsQ2xvc2VDdXJseVF1b3RlOlwi4oCZXCIsY2x1YnM6XCLimaNcIixjbHVic3VpdDpcIuKZo1wiLENvbG9uOlwi4oi3XCIsY29sb246XCI6XCIsQ29sb25lOlwi4qm0XCIsY29sb25lOlwi4omUXCIsY29sb25lcTpcIuKJlFwiLGNvbW1hOlwiLFwiLGNvbW1hdDpcIkBcIixjb21wOlwi4oiBXCIsY29tcGZuOlwi4oiYXCIsY29tcGxlbWVudDpcIuKIgVwiLGNvbXBsZXhlczpcIuKEglwiLGNvbmc6XCLiiYVcIixjb25nZG90Olwi4qmtXCIsQ29uZ3J1ZW50Olwi4omhXCIsQ29uaW50Olwi4oivXCIsY29uaW50Olwi4oiuXCIsQ29udG91ckludGVncmFsOlwi4oiuXCIsQ29wZjpcIuKEglwiLGNvcGY6XCLwnZWUXCIsY29wcm9kOlwi4oiQXCIsQ29wcm9kdWN0Olwi4oiQXCIsQ09QWTpcIsKpXCIsY29weTpcIsKpXCIsY29weXNyOlwi4oSXXCIsQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDpcIuKIs1wiLGNyYXJyOlwi4oa1XCIsQ3Jvc3M6XCLiqK9cIixjcm9zczpcIuKcl1wiLENzY3I6XCLwnZKeXCIsY3NjcjpcIvCdkrhcIixjc3ViOlwi4quPXCIsY3N1YmU6XCLiq5FcIixjc3VwOlwi4quQXCIsY3N1cGU6XCLiq5JcIixjdGRvdDpcIuKLr1wiLGN1ZGFycmw6XCLipLhcIixjdWRhcnJyOlwi4qS1XCIsY3VlcHI6XCLii55cIixjdWVzYzpcIuKLn1wiLGN1bGFycjpcIuKGtlwiLGN1bGFycnA6XCLipL1cIixDdXA6XCLii5NcIixjdXA6XCLiiKpcIixjdXBicmNhcDpcIuKpiFwiLEN1cENhcDpcIuKJjVwiLGN1cGNhcDpcIuKphlwiLGN1cGN1cDpcIuKpilwiLGN1cGRvdDpcIuKKjVwiLGN1cG9yOlwi4qmFXCIsY3VwczpcIuKIqu+4gFwiLGN1cmFycjpcIuKGt1wiLGN1cmFycm06XCLipLxcIixjdXJseWVxcHJlYzpcIuKLnlwiLGN1cmx5ZXFzdWNjOlwi4oufXCIsY3VybHl2ZWU6XCLii45cIixjdXJseXdlZGdlOlwi4ouPXCIsY3VycmVuOlwiwqRcIixjdXJ2ZWFycm93bGVmdDpcIuKGtlwiLGN1cnZlYXJyb3dyaWdodDpcIuKGt1wiLGN1dmVlOlwi4ouOXCIsY3V3ZWQ6XCLii49cIixjd2NvbmludDpcIuKIslwiLGN3aW50Olwi4oixXCIsY3lsY3R5Olwi4oytXCIsRGFnZ2VyOlwi4oChXCIsZGFnZ2VyOlwi4oCgXCIsZGFsZXRoOlwi4oS4XCIsRGFycjpcIuKGoVwiLGRBcnI6XCLih5NcIixkYXJyOlwi4oaTXCIsZGFzaDpcIuKAkFwiLERhc2h2Olwi4qukXCIsZGFzaHY6XCLiiqNcIixkYmthcm93Olwi4qSPXCIsZGJsYWM6XCLLnVwiLERjYXJvbjpcIsSOXCIsZGNhcm9uOlwixI9cIixEY3k6XCLQlFwiLGRjeTpcItC0XCIsREQ6XCLihYVcIixkZDpcIuKFhlwiLGRkYWdnZXI6XCLigKFcIixkZGFycjpcIuKHilwiLEREb3RyYWhkOlwi4qSRXCIsZGRvdHNlcTpcIuKpt1wiLGRlZzpcIsKwXCIsRGVsOlwi4oiHXCIsRGVsdGE6XCLOlFwiLGRlbHRhOlwizrRcIixkZW1wdHl2Olwi4qaxXCIsZGZpc2h0Olwi4qW/XCIsRGZyOlwi8J2Uh1wiLGRmcjpcIvCdlKFcIixkSGFyOlwi4qWlXCIsZGhhcmw6XCLih4NcIixkaGFycjpcIuKHglwiLERpYWNyaXRpY2FsQWN1dGU6XCLCtFwiLERpYWNyaXRpY2FsRG90Olwiy5lcIixEaWFjcml0aWNhbERvdWJsZUFjdXRlOlwiy51cIixEaWFjcml0aWNhbEdyYXZlOlwiYFwiLERpYWNyaXRpY2FsVGlsZGU6XCLLnFwiLGRpYW06XCLii4RcIixEaWFtb25kOlwi4ouEXCIsZGlhbW9uZDpcIuKLhFwiLGRpYW1vbmRzdWl0Olwi4pmmXCIsZGlhbXM6XCLimaZcIixkaWU6XCLCqFwiLERpZmZlcmVudGlhbEQ6XCLihYZcIixkaWdhbW1hOlwiz51cIixkaXNpbjpcIuKLslwiLGRpdjpcIsO3XCIsZGl2aWRlOlwiw7dcIixkaXZpZGVvbnRpbWVzOlwi4ouHXCIsZGl2b254Olwi4ouHXCIsREpjeTpcItCCXCIsZGpjeTpcItGSXCIsZGxjb3JuOlwi4oyeXCIsZGxjcm9wOlwi4oyNXCIsZG9sbGFyOlwiJFwiLERvcGY6XCLwnZS7XCIsZG9wZjpcIvCdlZVcIixEb3Q6XCLCqFwiLGRvdDpcIsuZXCIsRG90RG90Olwi4oOcXCIsZG90ZXE6XCLiiZBcIixkb3RlcWRvdDpcIuKJkVwiLERvdEVxdWFsOlwi4omQXCIsZG90bWludXM6XCLiiLhcIixkb3RwbHVzOlwi4oiUXCIsZG90c3F1YXJlOlwi4oqhXCIsZG91YmxlYmFyd2VkZ2U6XCLijIZcIixEb3VibGVDb250b3VySW50ZWdyYWw6XCLiiK9cIixEb3VibGVEb3Q6XCLCqFwiLERvdWJsZURvd25BcnJvdzpcIuKHk1wiLERvdWJsZUxlZnRBcnJvdzpcIuKHkFwiLERvdWJsZUxlZnRSaWdodEFycm93Olwi4oeUXCIsRG91YmxlTGVmdFRlZTpcIuKrpFwiLERvdWJsZUxvbmdMZWZ0QXJyb3c6XCLin7hcIixEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c6XCLin7pcIixEb3VibGVMb25nUmlnaHRBcnJvdzpcIuKfuVwiLERvdWJsZVJpZ2h0QXJyb3c6XCLih5JcIixEb3VibGVSaWdodFRlZTpcIuKKqFwiLERvdWJsZVVwQXJyb3c6XCLih5FcIixEb3VibGVVcERvd25BcnJvdzpcIuKHlVwiLERvdWJsZVZlcnRpY2FsQmFyOlwi4oilXCIsRG93bkFycm93Olwi4oaTXCIsRG93bmFycm93Olwi4oeTXCIsZG93bmFycm93Olwi4oaTXCIsRG93bkFycm93QmFyOlwi4qSTXCIsRG93bkFycm93VXBBcnJvdzpcIuKHtVwiLERvd25CcmV2ZTpcIsyRXCIsZG93bmRvd25hcnJvd3M6XCLih4pcIixkb3duaGFycG9vbmxlZnQ6XCLih4NcIixkb3duaGFycG9vbnJpZ2h0Olwi4oeCXCIsRG93bkxlZnRSaWdodFZlY3RvcjpcIuKlkFwiLERvd25MZWZ0VGVlVmVjdG9yOlwi4qWeXCIsRG93bkxlZnRWZWN0b3I6XCLihr1cIixEb3duTGVmdFZlY3RvckJhcjpcIuKlllwiLERvd25SaWdodFRlZVZlY3RvcjpcIuKln1wiLERvd25SaWdodFZlY3RvcjpcIuKHgVwiLERvd25SaWdodFZlY3RvckJhcjpcIuKll1wiLERvd25UZWU6XCLiiqRcIixEb3duVGVlQXJyb3c6XCLihqdcIixkcmJrYXJvdzpcIuKkkFwiLGRyY29ybjpcIuKMn1wiLGRyY3JvcDpcIuKMjFwiLERzY3I6XCLwnZKfXCIsZHNjcjpcIvCdkrlcIixEU2N5Olwi0IVcIixkc2N5Olwi0ZVcIixkc29sOlwi4qe2XCIsRHN0cm9rOlwixJBcIixkc3Ryb2s6XCLEkVwiLGR0ZG90Olwi4ouxXCIsZHRyaTpcIuKWv1wiLGR0cmlmOlwi4pa+XCIsZHVhcnI6XCLih7VcIixkdWhhcjpcIuKlr1wiLGR3YW5nbGU6XCLipqZcIixEWmN5Olwi0I9cIixkemN5Olwi0Z9cIixkemlncmFycjpcIuKfv1wiLEVhY3V0ZTpcIsOJXCIsZWFjdXRlOlwiw6lcIixlYXN0ZXI6XCLiqa5cIixFY2Fyb246XCLEmlwiLGVjYXJvbjpcIsSbXCIsZWNpcjpcIuKJllwiLEVjaXJjOlwiw4pcIixlY2lyYzpcIsOqXCIsZWNvbG9uOlwi4omVXCIsRWN5Olwi0K1cIixlY3k6XCLRjVwiLGVERG90Olwi4qm3XCIsRWRvdDpcIsSWXCIsZURvdDpcIuKJkVwiLGVkb3Q6XCLEl1wiLGVlOlwi4oWHXCIsZWZEb3Q6XCLiiZJcIixFZnI6XCLwnZSIXCIsZWZyOlwi8J2UolwiLGVnOlwi4qqaXCIsRWdyYXZlOlwiw4hcIixlZ3JhdmU6XCLDqFwiLGVnczpcIuKqllwiLGVnc2RvdDpcIuKqmFwiLGVsOlwi4qqZXCIsRWxlbWVudDpcIuKIiFwiLGVsaW50ZXJzOlwi4o+nXCIsZWxsOlwi4oSTXCIsZWxzOlwi4qqVXCIsZWxzZG90Olwi4qqXXCIsRW1hY3I6XCLEklwiLGVtYWNyOlwixJNcIixlbXB0eTpcIuKIhVwiLGVtcHR5c2V0Olwi4oiFXCIsRW1wdHlTbWFsbFNxdWFyZTpcIuKXu1wiLGVtcHR5djpcIuKIhVwiLEVtcHR5VmVyeVNtYWxsU3F1YXJlOlwi4parXCIsZW1zcDpcIuKAg1wiLGVtc3AxMzpcIuKAhFwiLGVtc3AxNDpcIuKAhVwiLEVORzpcIsWKXCIsZW5nOlwixYtcIixlbnNwOlwi4oCCXCIsRW9nb246XCLEmFwiLGVvZ29uOlwixJlcIixFb3BmOlwi8J2UvFwiLGVvcGY6XCLwnZWWXCIsZXBhcjpcIuKLlVwiLGVwYXJzbDpcIuKno1wiLGVwbHVzOlwi4qmxXCIsZXBzaTpcIs61XCIsRXBzaWxvbjpcIs6VXCIsZXBzaWxvbjpcIs61XCIsZXBzaXY6XCLPtVwiLGVxY2lyYzpcIuKJllwiLGVxY29sb246XCLiiZVcIixlcXNpbTpcIuKJglwiLGVxc2xhbnRndHI6XCLiqpZcIixlcXNsYW50bGVzczpcIuKqlVwiLEVxdWFsOlwi4qm1XCIsZXF1YWxzOlwiPVwiLEVxdWFsVGlsZGU6XCLiiYJcIixlcXVlc3Q6XCLiiZ9cIixFcXVpbGlicml1bTpcIuKHjFwiLGVxdWl2Olwi4omhXCIsZXF1aXZERDpcIuKpuFwiLGVxdnBhcnNsOlwi4qelXCIsZXJhcnI6XCLipbFcIixlckRvdDpcIuKJk1wiLEVzY3I6XCLihLBcIixlc2NyOlwi4oSvXCIsZXNkb3Q6XCLiiZBcIixFc2ltOlwi4qmzXCIsZXNpbTpcIuKJglwiLEV0YTpcIs6XXCIsZXRhOlwizrdcIixFVEg6XCLDkFwiLGV0aDpcIsOwXCIsRXVtbDpcIsOLXCIsZXVtbDpcIsOrXCIsZXVybzpcIuKCrFwiLGV4Y2w6XCIhXCIsZXhpc3Q6XCLiiINcIixFeGlzdHM6XCLiiINcIixleHBlY3RhdGlvbjpcIuKEsFwiLEV4cG9uZW50aWFsRTpcIuKFh1wiLGV4cG9uZW50aWFsZTpcIuKFh1wiLGZhbGxpbmdkb3RzZXE6XCLiiZJcIixGY3k6XCLQpFwiLGZjeTpcItGEXCIsZmVtYWxlOlwi4pmAXCIsZmZpbGlnOlwi76yDXCIsZmZsaWc6XCLvrIBcIixmZmxsaWc6XCLvrIRcIixGZnI6XCLwnZSJXCIsZmZyOlwi8J2Uo1wiLGZpbGlnOlwi76yBXCIsRmlsbGVkU21hbGxTcXVhcmU6XCLil7xcIixGaWxsZWRWZXJ5U21hbGxTcXVhcmU6XCLilqpcIixmamxpZzpcImZqXCIsZmxhdDpcIuKZrVwiLGZsbGlnOlwi76yCXCIsZmx0bnM6XCLilrFcIixmbm9mOlwixpJcIixGb3BmOlwi8J2UvVwiLGZvcGY6XCLwnZWXXCIsRm9yQWxsOlwi4oiAXCIsZm9yYWxsOlwi4oiAXCIsZm9yazpcIuKLlFwiLGZvcmt2Olwi4quZXCIsRm91cmllcnRyZjpcIuKEsVwiLGZwYXJ0aW50Olwi4qiNXCIsZnJhYzEyOlwiwr1cIixmcmFjMTM6XCLihZNcIixmcmFjMTQ6XCLCvFwiLGZyYWMxNTpcIuKFlVwiLGZyYWMxNjpcIuKFmVwiLGZyYWMxODpcIuKFm1wiLGZyYWMyMzpcIuKFlFwiLGZyYWMyNTpcIuKFllwiLGZyYWMzNDpcIsK+XCIsZnJhYzM1Olwi4oWXXCIsZnJhYzM4Olwi4oWcXCIsZnJhYzQ1Olwi4oWYXCIsZnJhYzU2Olwi4oWaXCIsZnJhYzU4Olwi4oWdXCIsZnJhYzc4Olwi4oWeXCIsZnJhc2w6XCLigYRcIixmcm93bjpcIuKMolwiLEZzY3I6XCLihLFcIixmc2NyOlwi8J2Su1wiLGdhY3V0ZTpcIse1XCIsR2FtbWE6XCLOk1wiLGdhbW1hOlwizrNcIixHYW1tYWQ6XCLPnFwiLGdhbW1hZDpcIs+dXCIsZ2FwOlwi4qqGXCIsR2JyZXZlOlwixJ5cIixnYnJldmU6XCLEn1wiLEdjZWRpbDpcIsSiXCIsR2NpcmM6XCLEnFwiLGdjaXJjOlwixJ1cIixHY3k6XCLQk1wiLGdjeTpcItCzXCIsR2RvdDpcIsSgXCIsZ2RvdDpcIsShXCIsZ0U6XCLiiadcIixnZTpcIuKJpVwiLGdFbDpcIuKqjFwiLGdlbDpcIuKLm1wiLGdlcTpcIuKJpVwiLGdlcXE6XCLiiadcIixnZXFzbGFudDpcIuKpvlwiLGdlczpcIuKpvlwiLGdlc2NjOlwi4qqpXCIsZ2VzZG90Olwi4qqAXCIsZ2VzZG90bzpcIuKqglwiLGdlc2RvdG9sOlwi4qqEXCIsZ2VzbDpcIuKLm++4gFwiLGdlc2xlczpcIuKqlFwiLEdmcjpcIvCdlIpcIixnZnI6XCLwnZSkXCIsR2c6XCLii5lcIixnZzpcIuKJq1wiLGdnZzpcIuKLmVwiLGdpbWVsOlwi4oS3XCIsR0pjeTpcItCDXCIsZ2pjeTpcItGTXCIsZ2w6XCLiibdcIixnbGE6XCLiqqVcIixnbEU6XCLiqpJcIixnbGo6XCLiqqRcIixnbmFwOlwi4qqKXCIsZ25hcHByb3g6XCLiqopcIixnbkU6XCLiialcIixnbmU6XCLiqohcIixnbmVxOlwi4qqIXCIsZ25lcXE6XCLiialcIixnbnNpbTpcIuKLp1wiLEdvcGY6XCLwnZS+XCIsZ29wZjpcIvCdlZhcIixncmF2ZTpcImBcIixHcmVhdGVyRXF1YWw6XCLiiaVcIixHcmVhdGVyRXF1YWxMZXNzOlwi4oubXCIsR3JlYXRlckZ1bGxFcXVhbDpcIuKJp1wiLEdyZWF0ZXJHcmVhdGVyOlwi4qqiXCIsR3JlYXRlckxlc3M6XCLiibdcIixHcmVhdGVyU2xhbnRFcXVhbDpcIuKpvlwiLEdyZWF0ZXJUaWxkZTpcIuKJs1wiLEdzY3I6XCLwnZKiXCIsZ3NjcjpcIuKEilwiLGdzaW06XCLiibNcIixnc2ltZTpcIuKqjlwiLGdzaW1sOlwi4qqQXCIsR3Q6XCLiiatcIixHVDpcIj5cIixndDpcIj5cIixndGNjOlwi4qqnXCIsZ3RjaXI6XCLiqbpcIixndGRvdDpcIuKLl1wiLGd0bFBhcjpcIuKmlVwiLGd0cXVlc3Q6XCLiqbxcIixndHJhcHByb3g6XCLiqoZcIixndHJhcnI6XCLipbhcIixndHJkb3Q6XCLii5dcIixndHJlcWxlc3M6XCLii5tcIixndHJlcXFsZXNzOlwi4qqMXCIsZ3RybGVzczpcIuKJt1wiLGd0cnNpbTpcIuKJs1wiLGd2ZXJ0bmVxcTpcIuKJqe+4gFwiLGd2bkU6XCLiianvuIBcIixIYWNlazpcIsuHXCIsaGFpcnNwOlwi4oCKXCIsaGFsZjpcIsK9XCIsaGFtaWx0Olwi4oSLXCIsSEFSRGN5Olwi0KpcIixoYXJkY3k6XCLRilwiLGhBcnI6XCLih5RcIixoYXJyOlwi4oaUXCIsaGFycmNpcjpcIuKliFwiLGhhcnJ3Olwi4oatXCIsSGF0OlwiXlwiLGhiYXI6XCLihI9cIixIY2lyYzpcIsSkXCIsaGNpcmM6XCLEpVwiLGhlYXJ0czpcIuKZpVwiLGhlYXJ0c3VpdDpcIuKZpVwiLGhlbGxpcDpcIuKAplwiLGhlcmNvbjpcIuKKuVwiLEhmcjpcIuKEjFwiLGhmcjpcIvCdlKVcIixIaWxiZXJ0U3BhY2U6XCLihItcIixoa3NlYXJvdzpcIuKkpVwiLGhrc3dhcm93Olwi4qSmXCIsaG9hcnI6XCLih79cIixob210aHQ6XCLiiLtcIixob29rbGVmdGFycm93Olwi4oapXCIsaG9va3JpZ2h0YXJyb3c6XCLihqpcIixIb3BmOlwi4oSNXCIsaG9wZjpcIvCdlZlcIixob3JiYXI6XCLigJVcIixIb3Jpem9udGFsTGluZTpcIuKUgFwiLEhzY3I6XCLihItcIixoc2NyOlwi8J2SvVwiLGhzbGFzaDpcIuKEj1wiLEhzdHJvazpcIsSmXCIsaHN0cm9rOlwixKdcIixIdW1wRG93bkh1bXA6XCLiiY5cIixIdW1wRXF1YWw6XCLiiY9cIixoeWJ1bGw6XCLigYNcIixoeXBoZW46XCLigJBcIixJYWN1dGU6XCLDjVwiLGlhY3V0ZTpcIsOtXCIsaWM6XCLigaNcIixJY2lyYzpcIsOOXCIsaWNpcmM6XCLDrlwiLEljeTpcItCYXCIsaWN5Olwi0LhcIixJZG90OlwixLBcIixJRWN5Olwi0JVcIixpZWN5Olwi0LVcIixpZXhjbDpcIsKhXCIsaWZmOlwi4oeUXCIsSWZyOlwi4oSRXCIsaWZyOlwi8J2UplwiLElncmF2ZTpcIsOMXCIsaWdyYXZlOlwiw6xcIixpaTpcIuKFiFwiLGlpaWludDpcIuKojFwiLGlpaW50Olwi4oitXCIsaWluZmluOlwi4qecXCIsaWlvdGE6XCLihKlcIixJSmxpZzpcIsSyXCIsaWpsaWc6XCLEs1wiLEltOlwi4oSRXCIsSW1hY3I6XCLEqlwiLGltYWNyOlwixKtcIixpbWFnZTpcIuKEkVwiLEltYWdpbmFyeUk6XCLihYhcIixpbWFnbGluZTpcIuKEkFwiLGltYWdwYXJ0Olwi4oSRXCIsaW1hdGg6XCLEsVwiLGltb2Y6XCLiirdcIixpbXBlZDpcIsa1XCIsSW1wbGllczpcIuKHklwiLGluOlwi4oiIXCIsaW5jYXJlOlwi4oSFXCIsaW5maW46XCLiiJ5cIixpbmZpbnRpZTpcIuKnnVwiLGlub2RvdDpcIsSxXCIsSW50Olwi4oisXCIsaW50Olwi4oirXCIsaW50Y2FsOlwi4oq6XCIsaW50ZWdlcnM6XCLihKRcIixJbnRlZ3JhbDpcIuKIq1wiLGludGVyY2FsOlwi4oq6XCIsSW50ZXJzZWN0aW9uOlwi4ouCXCIsaW50bGFyaGs6XCLiqJdcIixpbnRwcm9kOlwi4qi8XCIsSW52aXNpYmxlQ29tbWE6XCLigaNcIixJbnZpc2libGVUaW1lczpcIuKBolwiLElPY3k6XCLQgVwiLGlvY3k6XCLRkVwiLElvZ29uOlwixK5cIixpb2dvbjpcIsSvXCIsSW9wZjpcIvCdlYBcIixpb3BmOlwi8J2VmlwiLElvdGE6XCLOmVwiLGlvdGE6XCLOuVwiLGlwcm9kOlwi4qi8XCIsaXF1ZXN0Olwiwr9cIixJc2NyOlwi4oSQXCIsaXNjcjpcIvCdkr5cIixpc2luOlwi4oiIXCIsaXNpbmRvdDpcIuKLtVwiLGlzaW5FOlwi4ou5XCIsaXNpbnM6XCLii7RcIixpc2luc3Y6XCLii7NcIixpc2ludjpcIuKIiFwiLGl0Olwi4oGiXCIsSXRpbGRlOlwixKhcIixpdGlsZGU6XCLEqVwiLEl1a2N5Olwi0IZcIixpdWtjeTpcItGWXCIsSXVtbDpcIsOPXCIsaXVtbDpcIsOvXCIsSmNpcmM6XCLEtFwiLGpjaXJjOlwixLVcIixKY3k6XCLQmVwiLGpjeTpcItC5XCIsSmZyOlwi8J2UjVwiLGpmcjpcIvCdlKdcIixqbWF0aDpcIsi3XCIsSm9wZjpcIvCdlYFcIixqb3BmOlwi8J2Vm1wiLEpzY3I6XCLwnZKlXCIsanNjcjpcIvCdkr9cIixKc2VyY3k6XCLQiFwiLGpzZXJjeTpcItGYXCIsSnVrY3k6XCLQhFwiLGp1a2N5Olwi0ZRcIixLYXBwYTpcIs6aXCIsa2FwcGE6XCLOulwiLGthcHBhdjpcIs+wXCIsS2NlZGlsOlwixLZcIixrY2VkaWw6XCLEt1wiLEtjeTpcItCaXCIsa2N5Olwi0LpcIixLZnI6XCLwnZSOXCIsa2ZyOlwi8J2UqFwiLGtncmVlbjpcIsS4XCIsS0hjeTpcItClXCIsa2hjeTpcItGFXCIsS0pjeTpcItCMXCIsa2pjeTpcItGcXCIsS29wZjpcIvCdlYJcIixrb3BmOlwi8J2VnFwiLEtzY3I6XCLwnZKmXCIsa3NjcjpcIvCdk4BcIixsQWFycjpcIuKHmlwiLExhY3V0ZTpcIsS5XCIsbGFjdXRlOlwixLpcIixsYWVtcHR5djpcIuKmtFwiLGxhZ3JhbjpcIuKEklwiLExhbWJkYTpcIs6bXCIsbGFtYmRhOlwizrtcIixMYW5nOlwi4p+qXCIsbGFuZzpcIuKfqFwiLGxhbmdkOlwi4qaRXCIsbGFuZ2xlOlwi4p+oXCIsbGFwOlwi4qqFXCIsTGFwbGFjZXRyZjpcIuKEklwiLGxhcXVvOlwiwqtcIixMYXJyOlwi4oaeXCIsbEFycjpcIuKHkFwiLGxhcnI6XCLihpBcIixsYXJyYjpcIuKHpFwiLGxhcnJiZnM6XCLipJ9cIixsYXJyZnM6XCLipJ1cIixsYXJyaGs6XCLihqlcIixsYXJybHA6XCLihqtcIixsYXJycGw6XCLipLlcIixsYXJyc2ltOlwi4qWzXCIsbGFycnRsOlwi4oaiXCIsbGF0Olwi4qqrXCIsbEF0YWlsOlwi4qSbXCIsbGF0YWlsOlwi4qSZXCIsbGF0ZTpcIuKqrVwiLGxhdGVzOlwi4qqt77iAXCIsbEJhcnI6XCLipI5cIixsYmFycjpcIuKkjFwiLGxiYnJrOlwi4p2yXCIsbGJyYWNlOlwie1wiLGxicmFjazpcIltcIixsYnJrZTpcIuKmi1wiLGxicmtzbGQ6XCLipo9cIixsYnJrc2x1Olwi4qaNXCIsTGNhcm9uOlwixL1cIixsY2Fyb246XCLEvlwiLExjZWRpbDpcIsS7XCIsbGNlZGlsOlwixLxcIixsY2VpbDpcIuKMiFwiLGxjdWI6XCJ7XCIsTGN5Olwi0JtcIixsY3k6XCLQu1wiLGxkY2E6XCLipLZcIixsZHF1bzpcIuKAnFwiLGxkcXVvcjpcIuKAnlwiLGxkcmRoYXI6XCLipadcIixsZHJ1c2hhcjpcIuKli1wiLGxkc2g6XCLihrJcIixsRTpcIuKJplwiLGxlOlwi4omkXCIsTGVmdEFuZ2xlQnJhY2tldDpcIuKfqFwiLExlZnRBcnJvdzpcIuKGkFwiLExlZnRhcnJvdzpcIuKHkFwiLGxlZnRhcnJvdzpcIuKGkFwiLExlZnRBcnJvd0JhcjpcIuKHpFwiLExlZnRBcnJvd1JpZ2h0QXJyb3c6XCLih4ZcIixsZWZ0YXJyb3d0YWlsOlwi4oaiXCIsTGVmdENlaWxpbmc6XCLijIhcIixMZWZ0RG91YmxlQnJhY2tldDpcIuKfplwiLExlZnREb3duVGVlVmVjdG9yOlwi4qWhXCIsTGVmdERvd25WZWN0b3I6XCLih4NcIixMZWZ0RG93blZlY3RvckJhcjpcIuKlmVwiLExlZnRGbG9vcjpcIuKMilwiLGxlZnRoYXJwb29uZG93bjpcIuKGvVwiLGxlZnRoYXJwb29udXA6XCLihrxcIixsZWZ0bGVmdGFycm93czpcIuKHh1wiLExlZnRSaWdodEFycm93Olwi4oaUXCIsTGVmdHJpZ2h0YXJyb3c6XCLih5RcIixsZWZ0cmlnaHRhcnJvdzpcIuKGlFwiLGxlZnRyaWdodGFycm93czpcIuKHhlwiLGxlZnRyaWdodGhhcnBvb25zOlwi4oeLXCIsbGVmdHJpZ2h0c3F1aWdhcnJvdzpcIuKGrVwiLExlZnRSaWdodFZlY3RvcjpcIuKljlwiLExlZnRUZWU6XCLiiqNcIixMZWZ0VGVlQXJyb3c6XCLihqRcIixMZWZ0VGVlVmVjdG9yOlwi4qWaXCIsbGVmdHRocmVldGltZXM6XCLii4tcIixMZWZ0VHJpYW5nbGU6XCLiirJcIixMZWZ0VHJpYW5nbGVCYXI6XCLip49cIixMZWZ0VHJpYW5nbGVFcXVhbDpcIuKKtFwiLExlZnRVcERvd25WZWN0b3I6XCLipZFcIixMZWZ0VXBUZWVWZWN0b3I6XCLipaBcIixMZWZ0VXBWZWN0b3I6XCLihr9cIixMZWZ0VXBWZWN0b3JCYXI6XCLipZhcIixMZWZ0VmVjdG9yOlwi4oa8XCIsTGVmdFZlY3RvckJhcjpcIuKlklwiLGxFZzpcIuKqi1wiLGxlZzpcIuKLmlwiLGxlcTpcIuKJpFwiLGxlcXE6XCLiiaZcIixsZXFzbGFudDpcIuKpvVwiLGxlczpcIuKpvVwiLGxlc2NjOlwi4qqoXCIsbGVzZG90Olwi4qm/XCIsbGVzZG90bzpcIuKqgVwiLGxlc2RvdG9yOlwi4qqDXCIsbGVzZzpcIuKLmu+4gFwiLGxlc2dlczpcIuKqk1wiLGxlc3NhcHByb3g6XCLiqoVcIixsZXNzZG90Olwi4ouWXCIsbGVzc2VxZ3RyOlwi4ouaXCIsbGVzc2VxcWd0cjpcIuKqi1wiLExlc3NFcXVhbEdyZWF0ZXI6XCLii5pcIixMZXNzRnVsbEVxdWFsOlwi4ommXCIsTGVzc0dyZWF0ZXI6XCLiibZcIixsZXNzZ3RyOlwi4om2XCIsTGVzc0xlc3M6XCLiqqFcIixsZXNzc2ltOlwi4omyXCIsTGVzc1NsYW50RXF1YWw6XCLiqb1cIixMZXNzVGlsZGU6XCLiibJcIixsZmlzaHQ6XCLipbxcIixsZmxvb3I6XCLijIpcIixMZnI6XCLwnZSPXCIsbGZyOlwi8J2UqVwiLGxnOlwi4om2XCIsbGdFOlwi4qqRXCIsbEhhcjpcIuKlolwiLGxoYXJkOlwi4oa9XCIsbGhhcnU6XCLihrxcIixsaGFydWw6XCLipapcIixsaGJsazpcIuKWhFwiLExKY3k6XCLQiVwiLGxqY3k6XCLRmVwiLExsOlwi4ouYXCIsbGw6XCLiiapcIixsbGFycjpcIuKHh1wiLGxsY29ybmVyOlwi4oyeXCIsTGxlZnRhcnJvdzpcIuKHmlwiLGxsaGFyZDpcIuKlq1wiLGxsdHJpOlwi4pe6XCIsTG1pZG90OlwixL9cIixsbWlkb3Q6XCLFgFwiLGxtb3VzdDpcIuKOsFwiLGxtb3VzdGFjaGU6XCLijrBcIixsbmFwOlwi4qqJXCIsbG5hcHByb3g6XCLiqolcIixsbkU6XCLiiahcIixsbmU6XCLiqodcIixsbmVxOlwi4qqHXCIsbG5lcXE6XCLiiahcIixsbnNpbTpcIuKLplwiLGxvYW5nOlwi4p+sXCIsbG9hcnI6XCLih71cIixsb2JyazpcIuKfplwiLExvbmdMZWZ0QXJyb3c6XCLin7VcIixMb25nbGVmdGFycm93Olwi4p+4XCIsbG9uZ2xlZnRhcnJvdzpcIuKftVwiLExvbmdMZWZ0UmlnaHRBcnJvdzpcIuKft1wiLExvbmdsZWZ0cmlnaHRhcnJvdzpcIuKfulwiLGxvbmdsZWZ0cmlnaHRhcnJvdzpcIuKft1wiLGxvbmdtYXBzdG86XCLin7xcIixMb25nUmlnaHRBcnJvdzpcIuKftlwiLExvbmdyaWdodGFycm93Olwi4p+5XCIsbG9uZ3JpZ2h0YXJyb3c6XCLin7ZcIixsb29wYXJyb3dsZWZ0Olwi4oarXCIsbG9vcGFycm93cmlnaHQ6XCLihqxcIixsb3BhcjpcIuKmhVwiLExvcGY6XCLwnZWDXCIsbG9wZjpcIvCdlZ1cIixsb3BsdXM6XCLiqK1cIixsb3RpbWVzOlwi4qi0XCIsbG93YXN0Olwi4oiXXCIsbG93YmFyOlwiX1wiLExvd2VyTGVmdEFycm93Olwi4oaZXCIsTG93ZXJSaWdodEFycm93Olwi4oaYXCIsbG96Olwi4peKXCIsbG96ZW5nZTpcIuKXilwiLGxvemY6XCLip6tcIixscGFyOlwiKFwiLGxwYXJsdDpcIuKmk1wiLGxyYXJyOlwi4oeGXCIsbHJjb3JuZXI6XCLijJ9cIixscmhhcjpcIuKHi1wiLGxyaGFyZDpcIuKlrVwiLGxybTpcIuKAjlwiLGxydHJpOlwi4oq/XCIsbHNhcXVvOlwi4oC5XCIsTHNjcjpcIuKEklwiLGxzY3I6XCLwnZOBXCIsTHNoOlwi4oawXCIsbHNoOlwi4oawXCIsbHNpbTpcIuKJslwiLGxzaW1lOlwi4qqNXCIsbHNpbWc6XCLiqo9cIixsc3FiOlwiW1wiLGxzcXVvOlwi4oCYXCIsbHNxdW9yOlwi4oCaXCIsTHN0cm9rOlwixYFcIixsc3Ryb2s6XCLFglwiLEx0Olwi4omqXCIsTFQ6XCI8XCIsbHQ6XCI8XCIsbHRjYzpcIuKqplwiLGx0Y2lyOlwi4qm5XCIsbHRkb3Q6XCLii5ZcIixsdGhyZWU6XCLii4tcIixsdGltZXM6XCLii4lcIixsdGxhcnI6XCLipbZcIixsdHF1ZXN0Olwi4qm7XCIsbHRyaTpcIuKXg1wiLGx0cmllOlwi4oq0XCIsbHRyaWY6XCLil4JcIixsdHJQYXI6XCLippZcIixsdXJkc2hhcjpcIuKlilwiLGx1cnVoYXI6XCLipaZcIixsdmVydG5lcXE6XCLiiajvuIBcIixsdm5FOlwi4omo77iAXCIsbWFjcjpcIsKvXCIsbWFsZTpcIuKZglwiLG1hbHQ6XCLinKBcIixtYWx0ZXNlOlwi4pygXCIsTWFwOlwi4qSFXCIsbWFwOlwi4oamXCIsbWFwc3RvOlwi4oamXCIsbWFwc3RvZG93bjpcIuKGp1wiLG1hcHN0b2xlZnQ6XCLihqRcIixtYXBzdG91cDpcIuKGpVwiLG1hcmtlcjpcIuKWrlwiLG1jb21tYTpcIuKoqVwiLE1jeTpcItCcXCIsbWN5Olwi0LxcIixtZGFzaDpcIuKAlFwiLG1ERG90Olwi4oi6XCIsbWVhc3VyZWRhbmdsZTpcIuKIoVwiLE1lZGl1bVNwYWNlOlwi4oGfXCIsTWVsbGludHJmOlwi4oSzXCIsTWZyOlwi8J2UkFwiLG1mcjpcIvCdlKpcIixtaG86XCLihKdcIixtaWNybzpcIsK1XCIsbWlkOlwi4oijXCIsbWlkYXN0OlwiKlwiLG1pZGNpcjpcIuKrsFwiLG1pZGRvdDpcIsK3XCIsbWludXM6XCLiiJJcIixtaW51c2I6XCLiip9cIixtaW51c2Q6XCLiiLhcIixtaW51c2R1Olwi4qiqXCIsTWludXNQbHVzOlwi4oiTXCIsbWxjcDpcIuKrm1wiLG1sZHI6XCLigKZcIixtbnBsdXM6XCLiiJNcIixtb2RlbHM6XCLiiqdcIixNb3BmOlwi8J2VhFwiLG1vcGY6XCLwnZWeXCIsbXA6XCLiiJNcIixNc2NyOlwi4oSzXCIsbXNjcjpcIvCdk4JcIixtc3Rwb3M6XCLiiL5cIixNdTpcIs6cXCIsbXU6XCLOvFwiLG11bHRpbWFwOlwi4oq4XCIsbXVtYXA6XCLiirhcIixuYWJsYTpcIuKIh1wiLE5hY3V0ZTpcIsWDXCIsbmFjdXRlOlwixYRcIixuYW5nOlwi4oig4oOSXCIsbmFwOlwi4omJXCIsbmFwRTpcIuKpsMy4XCIsbmFwaWQ6XCLiiYvMuFwiLG5hcG9zOlwixYlcIixuYXBwcm94Olwi4omJXCIsbmF0dXI6XCLima5cIixuYXR1cmFsOlwi4pmuXCIsbmF0dXJhbHM6XCLihJVcIixuYnNwOlwiwqBcIixuYnVtcDpcIuKJjsy4XCIsbmJ1bXBlOlwi4omPzLhcIixuY2FwOlwi4qmDXCIsTmNhcm9uOlwixYdcIixuY2Fyb246XCLFiFwiLE5jZWRpbDpcIsWFXCIsbmNlZGlsOlwixYZcIixuY29uZzpcIuKJh1wiLG5jb25nZG90Olwi4qmtzLhcIixuY3VwOlwi4qmCXCIsTmN5Olwi0J1cIixuY3k6XCLQvVwiLG5kYXNoOlwi4oCTXCIsbmU6XCLiiaBcIixuZWFyaGs6XCLipKRcIixuZUFycjpcIuKHl1wiLG5lYXJyOlwi4oaXXCIsbmVhcnJvdzpcIuKGl1wiLG5lZG90Olwi4omQzLhcIixOZWdhdGl2ZU1lZGl1bVNwYWNlOlwi4oCLXCIsTmVnYXRpdmVUaGlja1NwYWNlOlwi4oCLXCIsTmVnYXRpdmVUaGluU3BhY2U6XCLigItcIixOZWdhdGl2ZVZlcnlUaGluU3BhY2U6XCLigItcIixuZXF1aXY6XCLiiaJcIixuZXNlYXI6XCLipKhcIixuZXNpbTpcIuKJgsy4XCIsTmVzdGVkR3JlYXRlckdyZWF0ZXI6XCLiiatcIixOZXN0ZWRMZXNzTGVzczpcIuKJqlwiLE5ld0xpbmU6XCJcXG5cIixuZXhpc3Q6XCLiiIRcIixuZXhpc3RzOlwi4oiEXCIsTmZyOlwi8J2UkVwiLG5mcjpcIvCdlKtcIixuZ0U6XCLiiafMuFwiLG5nZTpcIuKJsVwiLG5nZXE6XCLiibFcIixuZ2VxcTpcIuKJp8y4XCIsbmdlcXNsYW50Olwi4qm+zLhcIixuZ2VzOlwi4qm+zLhcIixuR2c6XCLii5nMuFwiLG5nc2ltOlwi4om1XCIsbkd0Olwi4omr4oOSXCIsbmd0Olwi4omvXCIsbmd0cjpcIuKJr1wiLG5HdHY6XCLiiavMuFwiLG5oQXJyOlwi4oeOXCIsbmhhcnI6XCLihq5cIixuaHBhcjpcIuKrslwiLG5pOlwi4oiLXCIsbmlzOlwi4ou8XCIsbmlzZDpcIuKLulwiLG5pdjpcIuKIi1wiLE5KY3k6XCLQilwiLG5qY3k6XCLRmlwiLG5sQXJyOlwi4oeNXCIsbmxhcnI6XCLihppcIixubGRyOlwi4oClXCIsbmxFOlwi4ommzLhcIixubGU6XCLiibBcIixuTGVmdGFycm93Olwi4oeNXCIsbmxlZnRhcnJvdzpcIuKGmlwiLG5MZWZ0cmlnaHRhcnJvdzpcIuKHjlwiLG5sZWZ0cmlnaHRhcnJvdzpcIuKGrlwiLG5sZXE6XCLiibBcIixubGVxcTpcIuKJpsy4XCIsbmxlcXNsYW50Olwi4qm9zLhcIixubGVzOlwi4qm9zLhcIixubGVzczpcIuKJrlwiLG5MbDpcIuKLmMy4XCIsbmxzaW06XCLiibRcIixuTHQ6XCLiiarig5JcIixubHQ6XCLiia5cIixubHRyaTpcIuKLqlwiLG5sdHJpZTpcIuKLrFwiLG5MdHY6XCLiiarMuFwiLG5taWQ6XCLiiKRcIixOb0JyZWFrOlwi4oGgXCIsTm9uQnJlYWtpbmdTcGFjZTpcIsKgXCIsTm9wZjpcIuKElVwiLG5vcGY6XCLwnZWfXCIsTm90Olwi4qusXCIsbm90OlwiwqxcIixOb3RDb25ncnVlbnQ6XCLiiaJcIixOb3RDdXBDYXA6XCLiia1cIixOb3REb3VibGVWZXJ0aWNhbEJhcjpcIuKIplwiLE5vdEVsZW1lbnQ6XCLiiIlcIixOb3RFcXVhbDpcIuKJoFwiLE5vdEVxdWFsVGlsZGU6XCLiiYLMuFwiLE5vdEV4aXN0czpcIuKIhFwiLE5vdEdyZWF0ZXI6XCLiia9cIixOb3RHcmVhdGVyRXF1YWw6XCLiibFcIixOb3RHcmVhdGVyRnVsbEVxdWFsOlwi4omnzLhcIixOb3RHcmVhdGVyR3JlYXRlcjpcIuKJq8y4XCIsTm90R3JlYXRlckxlc3M6XCLiiblcIixOb3RHcmVhdGVyU2xhbnRFcXVhbDpcIuKpvsy4XCIsTm90R3JlYXRlclRpbGRlOlwi4om1XCIsTm90SHVtcERvd25IdW1wOlwi4omOzLhcIixOb3RIdW1wRXF1YWw6XCLiiY/MuFwiLG5vdGluOlwi4oiJXCIsbm90aW5kb3Q6XCLii7XMuFwiLG5vdGluRTpcIuKLucy4XCIsbm90aW52YTpcIuKIiVwiLG5vdGludmI6XCLii7dcIixub3RpbnZjOlwi4ou2XCIsTm90TGVmdFRyaWFuZ2xlOlwi4ouqXCIsTm90TGVmdFRyaWFuZ2xlQmFyOlwi4qePzLhcIixOb3RMZWZ0VHJpYW5nbGVFcXVhbDpcIuKLrFwiLE5vdExlc3M6XCLiia5cIixOb3RMZXNzRXF1YWw6XCLiibBcIixOb3RMZXNzR3JlYXRlcjpcIuKJuFwiLE5vdExlc3NMZXNzOlwi4omqzLhcIixOb3RMZXNzU2xhbnRFcXVhbDpcIuKpvcy4XCIsTm90TGVzc1RpbGRlOlwi4om0XCIsTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI6XCLiqqLMuFwiLE5vdE5lc3RlZExlc3NMZXNzOlwi4qqhzLhcIixub3RuaTpcIuKIjFwiLG5vdG5pdmE6XCLiiIxcIixub3RuaXZiOlwi4ou+XCIsbm90bml2YzpcIuKLvVwiLE5vdFByZWNlZGVzOlwi4oqAXCIsTm90UHJlY2VkZXNFcXVhbDpcIuKqr8y4XCIsTm90UHJlY2VkZXNTbGFudEVxdWFsOlwi4ougXCIsTm90UmV2ZXJzZUVsZW1lbnQ6XCLiiIxcIixOb3RSaWdodFRyaWFuZ2xlOlwi4ourXCIsTm90UmlnaHRUcmlhbmdsZUJhcjpcIuKnkMy4XCIsTm90UmlnaHRUcmlhbmdsZUVxdWFsOlwi4outXCIsTm90U3F1YXJlU3Vic2V0Olwi4oqPzLhcIixOb3RTcXVhcmVTdWJzZXRFcXVhbDpcIuKLolwiLE5vdFNxdWFyZVN1cGVyc2V0Olwi4oqQzLhcIixOb3RTcXVhcmVTdXBlcnNldEVxdWFsOlwi4oujXCIsTm90U3Vic2V0Olwi4oqC4oOSXCIsTm90U3Vic2V0RXF1YWw6XCLiiohcIixOb3RTdWNjZWVkczpcIuKKgVwiLE5vdFN1Y2NlZWRzRXF1YWw6XCLiqrDMuFwiLE5vdFN1Y2NlZWRzU2xhbnRFcXVhbDpcIuKLoVwiLE5vdFN1Y2NlZWRzVGlsZGU6XCLiib/MuFwiLE5vdFN1cGVyc2V0Olwi4oqD4oOSXCIsTm90U3VwZXJzZXRFcXVhbDpcIuKKiVwiLE5vdFRpbGRlOlwi4omBXCIsTm90VGlsZGVFcXVhbDpcIuKJhFwiLE5vdFRpbGRlRnVsbEVxdWFsOlwi4omHXCIsTm90VGlsZGVUaWxkZTpcIuKJiVwiLE5vdFZlcnRpY2FsQmFyOlwi4oikXCIsbnBhcjpcIuKIplwiLG5wYXJhbGxlbDpcIuKIplwiLG5wYXJzbDpcIuKrveKDpVwiLG5wYXJ0Olwi4oiCzLhcIixucG9saW50Olwi4qiUXCIsbnByOlwi4oqAXCIsbnByY3VlOlwi4ougXCIsbnByZTpcIuKqr8y4XCIsbnByZWM6XCLiioBcIixucHJlY2VxOlwi4qqvzLhcIixuckFycjpcIuKHj1wiLG5yYXJyOlwi4oabXCIsbnJhcnJjOlwi4qSzzLhcIixucmFycnc6XCLihp3MuFwiLG5SaWdodGFycm93Olwi4oePXCIsbnJpZ2h0YXJyb3c6XCLihptcIixucnRyaTpcIuKLq1wiLG5ydHJpZTpcIuKLrVwiLG5zYzpcIuKKgVwiLG5zY2N1ZTpcIuKLoVwiLG5zY2U6XCLiqrDMuFwiLE5zY3I6XCLwnZKpXCIsbnNjcjpcIvCdk4NcIixuc2hvcnRtaWQ6XCLiiKRcIixuc2hvcnRwYXJhbGxlbDpcIuKIplwiLG5zaW06XCLiiYFcIixuc2ltZTpcIuKJhFwiLG5zaW1lcTpcIuKJhFwiLG5zbWlkOlwi4oikXCIsbnNwYXI6XCLiiKZcIixuc3FzdWJlOlwi4ouiXCIsbnNxc3VwZTpcIuKLo1wiLG5zdWI6XCLiioRcIixuc3ViRTpcIuKrhcy4XCIsbnN1YmU6XCLiiohcIixuc3Vic2V0Olwi4oqC4oOSXCIsbnN1YnNldGVxOlwi4oqIXCIsbnN1YnNldGVxcTpcIuKrhcy4XCIsbnN1Y2M6XCLiioFcIixuc3VjY2VxOlwi4qqwzLhcIixuc3VwOlwi4oqFXCIsbnN1cEU6XCLiq4bMuFwiLG5zdXBlOlwi4oqJXCIsbnN1cHNldDpcIuKKg+KDklwiLG5zdXBzZXRlcTpcIuKKiVwiLG5zdXBzZXRlcXE6XCLiq4bMuFwiLG50Z2w6XCLiiblcIixOdGlsZGU6XCLDkVwiLG50aWxkZTpcIsOxXCIsbnRsZzpcIuKJuFwiLG50cmlhbmdsZWxlZnQ6XCLii6pcIixudHJpYW5nbGVsZWZ0ZXE6XCLii6xcIixudHJpYW5nbGVyaWdodDpcIuKLq1wiLG50cmlhbmdsZXJpZ2h0ZXE6XCLii61cIixOdTpcIs6dXCIsbnU6XCLOvVwiLG51bTpcIiNcIixudW1lcm86XCLihJZcIixudW1zcDpcIuKAh1wiLG52YXA6XCLiiY3ig5JcIixuVkRhc2g6XCLiiq9cIixuVmRhc2g6XCLiiq5cIixudkRhc2g6XCLiiq1cIixudmRhc2g6XCLiiqxcIixudmdlOlwi4oml4oOSXCIsbnZndDpcIj7ig5JcIixudkhhcnI6XCLipIRcIixudmluZmluOlwi4qeeXCIsbnZsQXJyOlwi4qSCXCIsbnZsZTpcIuKJpOKDklwiLG52bHQ6XCI84oOSXCIsbnZsdHJpZTpcIuKKtOKDklwiLG52ckFycjpcIuKkg1wiLG52cnRyaWU6XCLiirXig5JcIixudnNpbTpcIuKIvOKDklwiLG53YXJoazpcIuKko1wiLG53QXJyOlwi4oeWXCIsbndhcnI6XCLihpZcIixud2Fycm93Olwi4oaWXCIsbnduZWFyOlwi4qSnXCIsT2FjdXRlOlwiw5NcIixvYWN1dGU6XCLDs1wiLG9hc3Q6XCLiiptcIixvY2lyOlwi4oqaXCIsT2NpcmM6XCLDlFwiLG9jaXJjOlwiw7RcIixPY3k6XCLQnlwiLG9jeTpcItC+XCIsb2Rhc2g6XCLiip1cIixPZGJsYWM6XCLFkFwiLG9kYmxhYzpcIsWRXCIsb2RpdjpcIuKouFwiLG9kb3Q6XCLiiplcIixvZHNvbGQ6XCLiprxcIixPRWxpZzpcIsWSXCIsb2VsaWc6XCLFk1wiLG9mY2lyOlwi4qa/XCIsT2ZyOlwi8J2UklwiLG9mcjpcIvCdlKxcIixvZ29uOlwiy5tcIixPZ3JhdmU6XCLDklwiLG9ncmF2ZTpcIsOyXCIsb2d0Olwi4qeBXCIsb2hiYXI6XCLiprVcIixvaG06XCLOqVwiLG9pbnQ6XCLiiK5cIixvbGFycjpcIuKGulwiLG9sY2lyOlwi4qa+XCIsb2xjcm9zczpcIuKmu1wiLG9saW5lOlwi4oC+XCIsb2x0Olwi4qeAXCIsT21hY3I6XCLFjFwiLG9tYWNyOlwixY1cIixPbWVnYTpcIs6pXCIsb21lZ2E6XCLPiVwiLE9taWNyb246XCLOn1wiLG9taWNyb246XCLOv1wiLG9taWQ6XCLiprZcIixvbWludXM6XCLiipZcIixPb3BmOlwi8J2VhlwiLG9vcGY6XCLwnZWgXCIsb3BhcjpcIuKmt1wiLE9wZW5DdXJseURvdWJsZVF1b3RlOlwi4oCcXCIsT3BlbkN1cmx5UXVvdGU6XCLigJhcIixvcGVycDpcIuKmuVwiLG9wbHVzOlwi4oqVXCIsT3I6XCLiqZRcIixvcjpcIuKIqFwiLG9yYXJyOlwi4oa7XCIsb3JkOlwi4qmdXCIsb3JkZXI6XCLihLRcIixvcmRlcm9mOlwi4oS0XCIsb3JkZjpcIsKqXCIsb3JkbTpcIsK6XCIsb3JpZ29mOlwi4oq2XCIsb3JvcjpcIuKpllwiLG9yc2xvcGU6XCLiqZdcIixvcnY6XCLiqZtcIixvUzpcIuKTiFwiLE9zY3I6XCLwnZKqXCIsb3NjcjpcIuKEtFwiLE9zbGFzaDpcIsOYXCIsb3NsYXNoOlwiw7hcIixvc29sOlwi4oqYXCIsT3RpbGRlOlwiw5VcIixvdGlsZGU6XCLDtVwiLE90aW1lczpcIuKot1wiLG90aW1lczpcIuKKl1wiLG90aW1lc2FzOlwi4qi2XCIsT3VtbDpcIsOWXCIsb3VtbDpcIsO2XCIsb3ZiYXI6XCLijL1cIixPdmVyQmFyOlwi4oC+XCIsT3ZlckJyYWNlOlwi4o+eXCIsT3ZlckJyYWNrZXQ6XCLijrRcIixPdmVyUGFyZW50aGVzaXM6XCLij5xcIixwYXI6XCLiiKVcIixwYXJhOlwiwrZcIixwYXJhbGxlbDpcIuKIpVwiLHBhcnNpbTpcIuKrs1wiLHBhcnNsOlwi4qu9XCIscGFydDpcIuKIglwiLFBhcnRpYWxEOlwi4oiCXCIsUGN5Olwi0J9cIixwY3k6XCLQv1wiLHBlcmNudDpcIiVcIixwZXJpb2Q6XCIuXCIscGVybWlsOlwi4oCwXCIscGVycDpcIuKKpVwiLHBlcnRlbms6XCLigLFcIixQZnI6XCLwnZSTXCIscGZyOlwi8J2UrVwiLFBoaTpcIs6mXCIscGhpOlwiz4ZcIixwaGl2Olwiz5VcIixwaG1tYXQ6XCLihLNcIixwaG9uZTpcIuKYjlwiLFBpOlwizqBcIixwaTpcIs+AXCIscGl0Y2hmb3JrOlwi4ouUXCIscGl2Olwiz5ZcIixwbGFuY2s6XCLihI9cIixwbGFuY2toOlwi4oSOXCIscGxhbmt2Olwi4oSPXCIscGx1czpcIitcIixwbHVzYWNpcjpcIuKoo1wiLHBsdXNiOlwi4oqeXCIscGx1c2NpcjpcIuKoolwiLHBsdXNkbzpcIuKIlFwiLHBsdXNkdTpcIuKopVwiLHBsdXNlOlwi4qmyXCIsUGx1c01pbnVzOlwiwrFcIixwbHVzbW46XCLCsVwiLHBsdXNzaW06XCLiqKZcIixwbHVzdHdvOlwi4qinXCIscG06XCLCsVwiLFBvaW5jYXJlcGxhbmU6XCLihIxcIixwb2ludGludDpcIuKolVwiLFBvcGY6XCLihJlcIixwb3BmOlwi8J2VoVwiLHBvdW5kOlwiwqNcIixQcjpcIuKqu1wiLHByOlwi4om6XCIscHJhcDpcIuKqt1wiLHByY3VlOlwi4om8XCIscHJFOlwi4qqzXCIscHJlOlwi4qqvXCIscHJlYzpcIuKJulwiLHByZWNhcHByb3g6XCLiqrdcIixwcmVjY3VybHllcTpcIuKJvFwiLFByZWNlZGVzOlwi4om6XCIsUHJlY2VkZXNFcXVhbDpcIuKqr1wiLFByZWNlZGVzU2xhbnRFcXVhbDpcIuKJvFwiLFByZWNlZGVzVGlsZGU6XCLiib5cIixwcmVjZXE6XCLiqq9cIixwcmVjbmFwcHJveDpcIuKquVwiLHByZWNuZXFxOlwi4qq1XCIscHJlY25zaW06XCLii6hcIixwcmVjc2ltOlwi4om+XCIsUHJpbWU6XCLigLNcIixwcmltZTpcIuKAslwiLHByaW1lczpcIuKEmVwiLHBybmFwOlwi4qq5XCIscHJuRTpcIuKqtVwiLHBybnNpbTpcIuKLqFwiLHByb2Q6XCLiiI9cIixQcm9kdWN0Olwi4oiPXCIscHJvZmFsYXI6XCLijK5cIixwcm9mbGluZTpcIuKMklwiLHByb2ZzdXJmOlwi4oyTXCIscHJvcDpcIuKInVwiLFByb3BvcnRpb246XCLiiLdcIixQcm9wb3J0aW9uYWw6XCLiiJ1cIixwcm9wdG86XCLiiJ1cIixwcnNpbTpcIuKJvlwiLHBydXJlbDpcIuKKsFwiLFBzY3I6XCLwnZKrXCIscHNjcjpcIvCdk4VcIixQc2k6XCLOqFwiLHBzaTpcIs+IXCIscHVuY3NwOlwi4oCIXCIsUWZyOlwi8J2UlFwiLHFmcjpcIvCdlK5cIixxaW50Olwi4qiMXCIsUW9wZjpcIuKEmlwiLHFvcGY6XCLwnZWiXCIscXByaW1lOlwi4oGXXCIsUXNjcjpcIvCdkqxcIixxc2NyOlwi8J2ThlwiLHF1YXRlcm5pb25zOlwi4oSNXCIscXVhdGludDpcIuKollwiLHF1ZXN0OlwiP1wiLHF1ZXN0ZXE6XCLiiZ9cIixRVU9UOidcIicscXVvdDonXCInLHJBYXJyOlwi4oebXCIscmFjZTpcIuKIvcyxXCIsUmFjdXRlOlwixZRcIixyYWN1dGU6XCLFlVwiLHJhZGljOlwi4oiaXCIscmFlbXB0eXY6XCLiprNcIixSYW5nOlwi4p+rXCIscmFuZzpcIuKfqVwiLHJhbmdkOlwi4qaSXCIscmFuZ2U6XCLipqVcIixyYW5nbGU6XCLin6lcIixyYXF1bzpcIsK7XCIsUmFycjpcIuKGoFwiLHJBcnI6XCLih5JcIixyYXJyOlwi4oaSXCIscmFycmFwOlwi4qW1XCIscmFycmI6XCLih6VcIixyYXJyYmZzOlwi4qSgXCIscmFycmM6XCLipLNcIixyYXJyZnM6XCLipJ5cIixyYXJyaGs6XCLihqpcIixyYXJybHA6XCLihqxcIixyYXJycGw6XCLipYVcIixyYXJyc2ltOlwi4qW0XCIsUmFycnRsOlwi4qSWXCIscmFycnRsOlwi4oajXCIscmFycnc6XCLihp1cIixyQXRhaWw6XCLipJxcIixyYXRhaWw6XCLipJpcIixyYXRpbzpcIuKItlwiLHJhdGlvbmFsczpcIuKEmlwiLFJCYXJyOlwi4qSQXCIsckJhcnI6XCLipI9cIixyYmFycjpcIuKkjVwiLHJiYnJrOlwi4p2zXCIscmJyYWNlOlwifVwiLHJicmFjazpcIl1cIixyYnJrZTpcIuKmjFwiLHJicmtzbGQ6XCLipo5cIixyYnJrc2x1Olwi4qaQXCIsUmNhcm9uOlwixZhcIixyY2Fyb246XCLFmVwiLFJjZWRpbDpcIsWWXCIscmNlZGlsOlwixZdcIixyY2VpbDpcIuKMiVwiLHJjdWI6XCJ9XCIsUmN5Olwi0KBcIixyY3k6XCLRgFwiLHJkY2E6XCLipLdcIixyZGxkaGFyOlwi4qWpXCIscmRxdW86XCLigJ1cIixyZHF1b3I6XCLigJ1cIixyZHNoOlwi4oazXCIsUmU6XCLihJxcIixyZWFsOlwi4oScXCIscmVhbGluZTpcIuKEm1wiLHJlYWxwYXJ0Olwi4oScXCIscmVhbHM6XCLihJ1cIixyZWN0Olwi4patXCIsUkVHOlwiwq5cIixyZWc6XCLCrlwiLFJldmVyc2VFbGVtZW50Olwi4oiLXCIsUmV2ZXJzZUVxdWlsaWJyaXVtOlwi4oeLXCIsUmV2ZXJzZVVwRXF1aWxpYnJpdW06XCLipa9cIixyZmlzaHQ6XCLipb1cIixyZmxvb3I6XCLijItcIixSZnI6XCLihJxcIixyZnI6XCLwnZSvXCIsckhhcjpcIuKlpFwiLHJoYXJkOlwi4oeBXCIscmhhcnU6XCLih4BcIixyaGFydWw6XCLipaxcIixSaG86XCLOoVwiLHJobzpcIs+BXCIscmhvdjpcIs+xXCIsUmlnaHRBbmdsZUJyYWNrZXQ6XCLin6lcIixSaWdodEFycm93Olwi4oaSXCIsUmlnaHRhcnJvdzpcIuKHklwiLHJpZ2h0YXJyb3c6XCLihpJcIixSaWdodEFycm93QmFyOlwi4oelXCIsUmlnaHRBcnJvd0xlZnRBcnJvdzpcIuKHhFwiLHJpZ2h0YXJyb3d0YWlsOlwi4oajXCIsUmlnaHRDZWlsaW5nOlwi4oyJXCIsUmlnaHREb3VibGVCcmFja2V0Olwi4p+nXCIsUmlnaHREb3duVGVlVmVjdG9yOlwi4qWdXCIsUmlnaHREb3duVmVjdG9yOlwi4oeCXCIsUmlnaHREb3duVmVjdG9yQmFyOlwi4qWVXCIsUmlnaHRGbG9vcjpcIuKMi1wiLHJpZ2h0aGFycG9vbmRvd246XCLih4FcIixyaWdodGhhcnBvb251cDpcIuKHgFwiLHJpZ2h0bGVmdGFycm93czpcIuKHhFwiLHJpZ2h0bGVmdGhhcnBvb25zOlwi4oeMXCIscmlnaHRyaWdodGFycm93czpcIuKHiVwiLHJpZ2h0c3F1aWdhcnJvdzpcIuKGnVwiLFJpZ2h0VGVlOlwi4oqiXCIsUmlnaHRUZWVBcnJvdzpcIuKGplwiLFJpZ2h0VGVlVmVjdG9yOlwi4qWbXCIscmlnaHR0aHJlZXRpbWVzOlwi4ouMXCIsUmlnaHRUcmlhbmdsZTpcIuKKs1wiLFJpZ2h0VHJpYW5nbGVCYXI6XCLip5BcIixSaWdodFRyaWFuZ2xlRXF1YWw6XCLiirVcIixSaWdodFVwRG93blZlY3RvcjpcIuKlj1wiLFJpZ2h0VXBUZWVWZWN0b3I6XCLipZxcIixSaWdodFVwVmVjdG9yOlwi4oa+XCIsUmlnaHRVcFZlY3RvckJhcjpcIuKllFwiLFJpZ2h0VmVjdG9yOlwi4oeAXCIsUmlnaHRWZWN0b3JCYXI6XCLipZNcIixyaW5nOlwiy5pcIixyaXNpbmdkb3RzZXE6XCLiiZNcIixybGFycjpcIuKHhFwiLHJsaGFyOlwi4oeMXCIscmxtOlwi4oCPXCIscm1vdXN0Olwi4o6xXCIscm1vdXN0YWNoZTpcIuKOsVwiLHJubWlkOlwi4quuXCIscm9hbmc6XCLin61cIixyb2FycjpcIuKHvlwiLHJvYnJrOlwi4p+nXCIscm9wYXI6XCLipoZcIixSb3BmOlwi4oSdXCIscm9wZjpcIvCdlaNcIixyb3BsdXM6XCLiqK5cIixyb3RpbWVzOlwi4qi1XCIsUm91bmRJbXBsaWVzOlwi4qWwXCIscnBhcjpcIilcIixycGFyZ3Q6XCLippRcIixycHBvbGludDpcIuKoklwiLHJyYXJyOlwi4oeJXCIsUnJpZ2h0YXJyb3c6XCLih5tcIixyc2FxdW86XCLigLpcIixSc2NyOlwi4oSbXCIscnNjcjpcIvCdk4dcIixSc2g6XCLihrFcIixyc2g6XCLihrFcIixyc3FiOlwiXVwiLHJzcXVvOlwi4oCZXCIscnNxdW9yOlwi4oCZXCIscnRocmVlOlwi4ouMXCIscnRpbWVzOlwi4ouKXCIscnRyaTpcIuKWuVwiLHJ0cmllOlwi4oq1XCIscnRyaWY6XCLilrhcIixydHJpbHRyaTpcIuKnjlwiLFJ1bGVEZWxheWVkOlwi4qe0XCIscnVsdWhhcjpcIuKlqFwiLHJ4Olwi4oSeXCIsU2FjdXRlOlwixZpcIixzYWN1dGU6XCLFm1wiLHNicXVvOlwi4oCaXCIsU2M6XCLiqrxcIixzYzpcIuKJu1wiLHNjYXA6XCLiqrhcIixTY2Fyb246XCLFoFwiLHNjYXJvbjpcIsWhXCIsc2NjdWU6XCLiib1cIixzY0U6XCLiqrRcIixzY2U6XCLiqrBcIixTY2VkaWw6XCLFnlwiLHNjZWRpbDpcIsWfXCIsU2NpcmM6XCLFnFwiLHNjaXJjOlwixZ1cIixzY25hcDpcIuKqulwiLHNjbkU6XCLiqrZcIixzY25zaW06XCLii6lcIixzY3BvbGludDpcIuKok1wiLHNjc2ltOlwi4om/XCIsU2N5Olwi0KFcIixzY3k6XCLRgVwiLHNkb3Q6XCLii4VcIixzZG90YjpcIuKKoVwiLHNkb3RlOlwi4qmmXCIsc2VhcmhrOlwi4qSlXCIsc2VBcnI6XCLih5hcIixzZWFycjpcIuKGmFwiLHNlYXJyb3c6XCLihphcIixzZWN0OlwiwqdcIixzZW1pOlwiO1wiLHNlc3dhcjpcIuKkqVwiLHNldG1pbnVzOlwi4oiWXCIsc2V0bW46XCLiiJZcIixzZXh0Olwi4py2XCIsU2ZyOlwi8J2UllwiLHNmcjpcIvCdlLBcIixzZnJvd246XCLijKJcIixzaGFycDpcIuKZr1wiLFNIQ0hjeTpcItCpXCIsc2hjaGN5Olwi0YlcIixTSGN5Olwi0KhcIixzaGN5Olwi0YhcIixTaG9ydERvd25BcnJvdzpcIuKGk1wiLFNob3J0TGVmdEFycm93Olwi4oaQXCIsc2hvcnRtaWQ6XCLiiKNcIixzaG9ydHBhcmFsbGVsOlwi4oilXCIsU2hvcnRSaWdodEFycm93Olwi4oaSXCIsU2hvcnRVcEFycm93Olwi4oaRXCIsc2h5Olwiwq1cIixTaWdtYTpcIs6jXCIsc2lnbWE6XCLPg1wiLHNpZ21hZjpcIs+CXCIsc2lnbWF2Olwiz4JcIixzaW06XCLiiLxcIixzaW1kb3Q6XCLiqapcIixzaW1lOlwi4omDXCIsc2ltZXE6XCLiiYNcIixzaW1nOlwi4qqeXCIsc2ltZ0U6XCLiqqBcIixzaW1sOlwi4qqdXCIsc2ltbEU6XCLiqp9cIixzaW1uZTpcIuKJhlwiLHNpbXBsdXM6XCLiqKRcIixzaW1yYXJyOlwi4qWyXCIsc2xhcnI6XCLihpBcIixTbWFsbENpcmNsZTpcIuKImFwiLHNtYWxsc2V0bWludXM6XCLiiJZcIixzbWFzaHA6XCLiqLNcIixzbWVwYXJzbDpcIuKnpFwiLHNtaWQ6XCLiiKNcIixzbWlsZTpcIuKMo1wiLHNtdDpcIuKqqlwiLHNtdGU6XCLiqqxcIixzbXRlczpcIuKqrO+4gFwiLFNPRlRjeTpcItCsXCIsc29mdGN5Olwi0YxcIixzb2w6XCIvXCIsc29sYjpcIuKnhFwiLHNvbGJhcjpcIuKMv1wiLFNvcGY6XCLwnZWKXCIsc29wZjpcIvCdlaRcIixzcGFkZXM6XCLimaBcIixzcGFkZXN1aXQ6XCLimaBcIixzcGFyOlwi4oilXCIsc3FjYXA6XCLiipNcIixzcWNhcHM6XCLiipPvuIBcIixzcWN1cDpcIuKKlFwiLHNxY3VwczpcIuKKlO+4gFwiLFNxcnQ6XCLiiJpcIixzcXN1YjpcIuKKj1wiLHNxc3ViZTpcIuKKkVwiLHNxc3Vic2V0Olwi4oqPXCIsc3FzdWJzZXRlcTpcIuKKkVwiLHNxc3VwOlwi4oqQXCIsc3FzdXBlOlwi4oqSXCIsc3FzdXBzZXQ6XCLiipBcIixzcXN1cHNldGVxOlwi4oqSXCIsc3F1Olwi4pahXCIsU3F1YXJlOlwi4pahXCIsc3F1YXJlOlwi4pahXCIsU3F1YXJlSW50ZXJzZWN0aW9uOlwi4oqTXCIsU3F1YXJlU3Vic2V0Olwi4oqPXCIsU3F1YXJlU3Vic2V0RXF1YWw6XCLiipFcIixTcXVhcmVTdXBlcnNldDpcIuKKkFwiLFNxdWFyZVN1cGVyc2V0RXF1YWw6XCLiipJcIixTcXVhcmVVbmlvbjpcIuKKlFwiLHNxdWFyZjpcIuKWqlwiLHNxdWY6XCLilqpcIixzcmFycjpcIuKGklwiLFNzY3I6XCLwnZKuXCIsc3NjcjpcIvCdk4hcIixzc2V0bW46XCLiiJZcIixzc21pbGU6XCLijKNcIixzc3RhcmY6XCLii4ZcIixTdGFyOlwi4ouGXCIsc3RhcjpcIuKYhlwiLHN0YXJmOlwi4piFXCIsc3RyYWlnaHRlcHNpbG9uOlwiz7VcIixzdHJhaWdodHBoaTpcIs+VXCIsc3RybnM6XCLCr1wiLFN1YjpcIuKLkFwiLHN1YjpcIuKKglwiLHN1YmRvdDpcIuKqvVwiLHN1YkU6XCLiq4VcIixzdWJlOlwi4oqGXCIsc3ViZWRvdDpcIuKrg1wiLHN1Ym11bHQ6XCLiq4FcIixzdWJuRTpcIuKri1wiLHN1Ym5lOlwi4oqKXCIsc3VicGx1czpcIuKqv1wiLHN1YnJhcnI6XCLipblcIixTdWJzZXQ6XCLii5BcIixzdWJzZXQ6XCLiioJcIixzdWJzZXRlcTpcIuKKhlwiLHN1YnNldGVxcTpcIuKrhVwiLFN1YnNldEVxdWFsOlwi4oqGXCIsc3Vic2V0bmVxOlwi4oqKXCIsc3Vic2V0bmVxcTpcIuKri1wiLHN1YnNpbTpcIuKrh1wiLHN1YnN1YjpcIuKrlVwiLHN1YnN1cDpcIuKrk1wiLHN1Y2M6XCLiibtcIixzdWNjYXBwcm94Olwi4qq4XCIsc3VjY2N1cmx5ZXE6XCLiib1cIixTdWNjZWVkczpcIuKJu1wiLFN1Y2NlZWRzRXF1YWw6XCLiqrBcIixTdWNjZWVkc1NsYW50RXF1YWw6XCLiib1cIixTdWNjZWVkc1RpbGRlOlwi4om/XCIsc3VjY2VxOlwi4qqwXCIsc3VjY25hcHByb3g6XCLiqrpcIixzdWNjbmVxcTpcIuKqtlwiLHN1Y2Nuc2ltOlwi4oupXCIsc3VjY3NpbTpcIuKJv1wiLFN1Y2hUaGF0Olwi4oiLXCIsU3VtOlwi4oiRXCIsc3VtOlwi4oiRXCIsc3VuZzpcIuKZqlwiLFN1cDpcIuKLkVwiLHN1cDpcIuKKg1wiLHN1cDE6XCLCuVwiLHN1cDI6XCLCslwiLHN1cDM6XCLCs1wiLHN1cGRvdDpcIuKqvlwiLHN1cGRzdWI6XCLiq5hcIixzdXBFOlwi4quGXCIsc3VwZTpcIuKKh1wiLHN1cGVkb3Q6XCLiq4RcIixTdXBlcnNldDpcIuKKg1wiLFN1cGVyc2V0RXF1YWw6XCLiiodcIixzdXBoc29sOlwi4p+JXCIsc3VwaHN1YjpcIuKrl1wiLHN1cGxhcnI6XCLipbtcIixzdXBtdWx0Olwi4quCXCIsc3VwbkU6XCLiq4xcIixzdXBuZTpcIuKKi1wiLHN1cHBsdXM6XCLiq4BcIixTdXBzZXQ6XCLii5FcIixzdXBzZXQ6XCLiioNcIixzdXBzZXRlcTpcIuKKh1wiLHN1cHNldGVxcTpcIuKrhlwiLHN1cHNldG5lcTpcIuKKi1wiLHN1cHNldG5lcXE6XCLiq4xcIixzdXBzaW06XCLiq4hcIixzdXBzdWI6XCLiq5RcIixzdXBzdXA6XCLiq5ZcIixzd2FyaGs6XCLipKZcIixzd0FycjpcIuKHmVwiLHN3YXJyOlwi4oaZXCIsc3dhcnJvdzpcIuKGmVwiLHN3bndhcjpcIuKkqlwiLHN6bGlnOlwiw59cIixUYWI6XCJcXHRcIix0YXJnZXQ6XCLijJZcIixUYXU6XCLOpFwiLHRhdTpcIs+EXCIsdGJyazpcIuKOtFwiLFRjYXJvbjpcIsWkXCIsdGNhcm9uOlwixaVcIixUY2VkaWw6XCLFolwiLHRjZWRpbDpcIsWjXCIsVGN5Olwi0KJcIix0Y3k6XCLRglwiLHRkb3Q6XCLig5tcIix0ZWxyZWM6XCLijJVcIixUZnI6XCLwnZSXXCIsdGZyOlwi8J2UsVwiLHRoZXJlNDpcIuKItFwiLFRoZXJlZm9yZTpcIuKItFwiLHRoZXJlZm9yZTpcIuKItFwiLFRoZXRhOlwizphcIix0aGV0YTpcIs64XCIsdGhldGFzeW06XCLPkVwiLHRoZXRhdjpcIs+RXCIsdGhpY2thcHByb3g6XCLiiYhcIix0aGlja3NpbTpcIuKIvFwiLFRoaWNrU3BhY2U6XCLigZ/igIpcIix0aGluc3A6XCLigIlcIixUaGluU3BhY2U6XCLigIlcIix0aGthcDpcIuKJiFwiLHRoa3NpbTpcIuKIvFwiLFRIT1JOOlwiw55cIix0aG9ybjpcIsO+XCIsVGlsZGU6XCLiiLxcIix0aWxkZTpcIsucXCIsVGlsZGVFcXVhbDpcIuKJg1wiLFRpbGRlRnVsbEVxdWFsOlwi4omFXCIsVGlsZGVUaWxkZTpcIuKJiFwiLHRpbWVzOlwiw5dcIix0aW1lc2I6XCLiiqBcIix0aW1lc2JhcjpcIuKosVwiLHRpbWVzZDpcIuKosFwiLHRpbnQ6XCLiiK1cIix0b2VhOlwi4qSoXCIsdG9wOlwi4oqkXCIsdG9wYm90Olwi4oy2XCIsdG9wY2lyOlwi4quxXCIsVG9wZjpcIvCdlYtcIix0b3BmOlwi8J2VpVwiLHRvcGZvcms6XCLiq5pcIix0b3NhOlwi4qSpXCIsdHByaW1lOlwi4oC0XCIsVFJBREU6XCLihKJcIix0cmFkZTpcIuKEolwiLHRyaWFuZ2xlOlwi4pa1XCIsdHJpYW5nbGVkb3duOlwi4pa/XCIsdHJpYW5nbGVsZWZ0Olwi4peDXCIsdHJpYW5nbGVsZWZ0ZXE6XCLiirRcIix0cmlhbmdsZXE6XCLiiZxcIix0cmlhbmdsZXJpZ2h0Olwi4pa5XCIsdHJpYW5nbGVyaWdodGVxOlwi4oq1XCIsdHJpZG90Olwi4pesXCIsdHJpZTpcIuKJnFwiLHRyaW1pbnVzOlwi4qi6XCIsVHJpcGxlRG90Olwi4oObXCIsdHJpcGx1czpcIuKouVwiLHRyaXNiOlwi4qeNXCIsdHJpdGltZTpcIuKou1wiLHRycGV6aXVtOlwi4o+iXCIsVHNjcjpcIvCdkq9cIix0c2NyOlwi8J2TiVwiLFRTY3k6XCLQplwiLHRzY3k6XCLRhlwiLFRTSGN5Olwi0ItcIix0c2hjeTpcItGbXCIsVHN0cm9rOlwixaZcIix0c3Ryb2s6XCLFp1wiLHR3aXh0Olwi4omsXCIsdHdvaGVhZGxlZnRhcnJvdzpcIuKGnlwiLHR3b2hlYWRyaWdodGFycm93Olwi4oagXCIsVWFjdXRlOlwiw5pcIix1YWN1dGU6XCLDulwiLFVhcnI6XCLihp9cIix1QXJyOlwi4oeRXCIsdWFycjpcIuKGkVwiLFVhcnJvY2lyOlwi4qWJXCIsVWJyY3k6XCLQjlwiLHVicmN5Olwi0Z5cIixVYnJldmU6XCLFrFwiLHVicmV2ZTpcIsWtXCIsVWNpcmM6XCLDm1wiLHVjaXJjOlwiw7tcIixVY3k6XCLQo1wiLHVjeTpcItGDXCIsdWRhcnI6XCLih4VcIixVZGJsYWM6XCLFsFwiLHVkYmxhYzpcIsWxXCIsdWRoYXI6XCLipa5cIix1ZmlzaHQ6XCLipb5cIixVZnI6XCLwnZSYXCIsdWZyOlwi8J2UslwiLFVncmF2ZTpcIsOZXCIsdWdyYXZlOlwiw7lcIix1SGFyOlwi4qWjXCIsdWhhcmw6XCLihr9cIix1aGFycjpcIuKGvlwiLHVoYmxrOlwi4paAXCIsdWxjb3JuOlwi4oycXCIsdWxjb3JuZXI6XCLijJxcIix1bGNyb3A6XCLijI9cIix1bHRyaTpcIuKXuFwiLFVtYWNyOlwixapcIix1bWFjcjpcIsWrXCIsdW1sOlwiwqhcIixVbmRlckJhcjpcIl9cIixVbmRlckJyYWNlOlwi4o+fXCIsVW5kZXJCcmFja2V0Olwi4o61XCIsVW5kZXJQYXJlbnRoZXNpczpcIuKPnVwiLFVuaW9uOlwi4ouDXCIsVW5pb25QbHVzOlwi4oqOXCIsVW9nb246XCLFslwiLHVvZ29uOlwixbNcIixVb3BmOlwi8J2VjFwiLHVvcGY6XCLwnZWmXCIsVXBBcnJvdzpcIuKGkVwiLFVwYXJyb3c6XCLih5FcIix1cGFycm93Olwi4oaRXCIsVXBBcnJvd0JhcjpcIuKkklwiLFVwQXJyb3dEb3duQXJyb3c6XCLih4VcIixVcERvd25BcnJvdzpcIuKGlVwiLFVwZG93bmFycm93Olwi4oeVXCIsdXBkb3duYXJyb3c6XCLihpVcIixVcEVxdWlsaWJyaXVtOlwi4qWuXCIsdXBoYXJwb29ubGVmdDpcIuKGv1wiLHVwaGFycG9vbnJpZ2h0Olwi4oa+XCIsdXBsdXM6XCLiio5cIixVcHBlckxlZnRBcnJvdzpcIuKGllwiLFVwcGVyUmlnaHRBcnJvdzpcIuKGl1wiLFVwc2k6XCLPklwiLHVwc2k6XCLPhVwiLHVwc2loOlwiz5JcIixVcHNpbG9uOlwizqVcIix1cHNpbG9uOlwiz4VcIixVcFRlZTpcIuKKpVwiLFVwVGVlQXJyb3c6XCLihqVcIix1cHVwYXJyb3dzOlwi4oeIXCIsdXJjb3JuOlwi4oydXCIsdXJjb3JuZXI6XCLijJ1cIix1cmNyb3A6XCLijI5cIixVcmluZzpcIsWuXCIsdXJpbmc6XCLFr1wiLHVydHJpOlwi4pe5XCIsVXNjcjpcIvCdkrBcIix1c2NyOlwi8J2TilwiLHV0ZG90Olwi4ouwXCIsVXRpbGRlOlwixahcIix1dGlsZGU6XCLFqVwiLHV0cmk6XCLilrVcIix1dHJpZjpcIuKWtFwiLHV1YXJyOlwi4oeIXCIsVXVtbDpcIsOcXCIsdXVtbDpcIsO8XCIsdXdhbmdsZTpcIuKmp1wiLHZhbmdydDpcIuKmnFwiLHZhcmVwc2lsb246XCLPtVwiLHZhcmthcHBhOlwiz7BcIix2YXJub3RoaW5nOlwi4oiFXCIsdmFycGhpOlwiz5VcIix2YXJwaTpcIs+WXCIsdmFycHJvcHRvOlwi4oidXCIsdkFycjpcIuKHlVwiLHZhcnI6XCLihpVcIix2YXJyaG86XCLPsVwiLHZhcnNpZ21hOlwiz4JcIix2YXJzdWJzZXRuZXE6XCLiiorvuIBcIix2YXJzdWJzZXRuZXFxOlwi4quL77iAXCIsdmFyc3Vwc2V0bmVxOlwi4oqL77iAXCIsdmFyc3Vwc2V0bmVxcTpcIuKrjO+4gFwiLHZhcnRoZXRhOlwiz5FcIix2YXJ0cmlhbmdsZWxlZnQ6XCLiirJcIix2YXJ0cmlhbmdsZXJpZ2h0Olwi4oqzXCIsVmJhcjpcIuKrq1wiLHZCYXI6XCLiq6hcIix2QmFydjpcIuKrqVwiLFZjeTpcItCSXCIsdmN5Olwi0LJcIixWRGFzaDpcIuKKq1wiLFZkYXNoOlwi4oqpXCIsdkRhc2g6XCLiiqhcIix2ZGFzaDpcIuKKolwiLFZkYXNobDpcIuKrplwiLFZlZTpcIuKLgVwiLHZlZTpcIuKIqFwiLHZlZWJhcjpcIuKKu1wiLHZlZWVxOlwi4omaXCIsdmVsbGlwOlwi4ouuXCIsVmVyYmFyOlwi4oCWXCIsdmVyYmFyOlwifFwiLFZlcnQ6XCLigJZcIix2ZXJ0OlwifFwiLFZlcnRpY2FsQmFyOlwi4oijXCIsVmVydGljYWxMaW5lOlwifFwiLFZlcnRpY2FsU2VwYXJhdG9yOlwi4p2YXCIsVmVydGljYWxUaWxkZTpcIuKJgFwiLFZlcnlUaGluU3BhY2U6XCLigIpcIixWZnI6XCLwnZSZXCIsdmZyOlwi8J2Us1wiLHZsdHJpOlwi4oqyXCIsdm5zdWI6XCLiioLig5JcIix2bnN1cDpcIuKKg+KDklwiLFZvcGY6XCLwnZWNXCIsdm9wZjpcIvCdladcIix2cHJvcDpcIuKInVwiLHZydHJpOlwi4oqzXCIsVnNjcjpcIvCdkrFcIix2c2NyOlwi8J2Ti1wiLHZzdWJuRTpcIuKri++4gFwiLHZzdWJuZTpcIuKKiu+4gFwiLHZzdXBuRTpcIuKrjO+4gFwiLHZzdXBuZTpcIuKKi++4gFwiLFZ2ZGFzaDpcIuKKqlwiLHZ6aWd6YWc6XCLipppcIixXY2lyYzpcIsW0XCIsd2NpcmM6XCLFtVwiLHdlZGJhcjpcIuKpn1wiLFdlZGdlOlwi4ouAXCIsd2VkZ2U6XCLiiKdcIix3ZWRnZXE6XCLiiZlcIix3ZWllcnA6XCLihJhcIixXZnI6XCLwnZSaXCIsd2ZyOlwi8J2UtFwiLFdvcGY6XCLwnZWOXCIsd29wZjpcIvCdlahcIix3cDpcIuKEmFwiLHdyOlwi4omAXCIsd3JlYXRoOlwi4omAXCIsV3NjcjpcIvCdkrJcIix3c2NyOlwi8J2TjFwiLHhjYXA6XCLii4JcIix4Y2lyYzpcIuKXr1wiLHhjdXA6XCLii4NcIix4ZHRyaTpcIuKWvVwiLFhmcjpcIvCdlJtcIix4ZnI6XCLwnZS1XCIseGhBcnI6XCLin7pcIix4aGFycjpcIuKft1wiLFhpOlwizp5cIix4aTpcIs6+XCIseGxBcnI6XCLin7hcIix4bGFycjpcIuKftVwiLHhtYXA6XCLin7xcIix4bmlzOlwi4ou7XCIseG9kb3Q6XCLiqIBcIixYb3BmOlwi8J2Vj1wiLHhvcGY6XCLwnZWpXCIseG9wbHVzOlwi4qiBXCIseG90aW1lOlwi4qiCXCIseHJBcnI6XCLin7lcIix4cmFycjpcIuKftlwiLFhzY3I6XCLwnZKzXCIseHNjcjpcIvCdk41cIix4c3FjdXA6XCLiqIZcIix4dXBsdXM6XCLiqIRcIix4dXRyaTpcIuKWs1wiLHh2ZWU6XCLii4FcIix4d2VkZ2U6XCLii4BcIixZYWN1dGU6XCLDnVwiLHlhY3V0ZTpcIsO9XCIsWUFjeTpcItCvXCIseWFjeTpcItGPXCIsWWNpcmM6XCLFtlwiLHljaXJjOlwixbdcIixZY3k6XCLQq1wiLHljeTpcItGLXCIseWVuOlwiwqVcIixZZnI6XCLwnZScXCIseWZyOlwi8J2UtlwiLFlJY3k6XCLQh1wiLHlpY3k6XCLRl1wiLFlvcGY6XCLwnZWQXCIseW9wZjpcIvCdlapcIixZc2NyOlwi8J2StFwiLHlzY3I6XCLwnZOOXCIsWVVjeTpcItCuXCIseXVjeTpcItGOXCIsWXVtbDpcIsW4XCIseXVtbDpcIsO/XCIsWmFjdXRlOlwixblcIix6YWN1dGU6XCLFulwiLFpjYXJvbjpcIsW9XCIsemNhcm9uOlwixb5cIixaY3k6XCLQl1wiLHpjeTpcItC3XCIsWmRvdDpcIsW7XCIsemRvdDpcIsW8XCIsemVldHJmOlwi4oSoXCIsWmVyb1dpZHRoU3BhY2U6XCLigItcIixaZXRhOlwizpZcIix6ZXRhOlwizrZcIixaZnI6XCLihKhcIix6ZnI6XCLwnZS3XCIsWkhjeTpcItCWXCIsemhjeTpcItC2XCIsemlncmFycjpcIuKHnVwiLFpvcGY6XCLihKRcIix6b3BmOlwi8J2Vq1wiLFpzY3I6XCLwnZK1XCIsenNjcjpcIvCdk49cIix6d2o6XCLigI1cIix6d25qOlwi4oCMXCJ9KSx0LmVudGl0eU1hcD10LkhUTUxfRU5USVRJRVN9LDg5Nzg6KGUsdCxyKT0+e3ZhciBhPXIoNDcyMik7dC5ET01JbXBsZW1lbnRhdGlvbj1hLkRPTUltcGxlbWVudGF0aW9uLHQuWE1MU2VyaWFsaXplcj1hLlhNTFNlcmlhbGl6ZXIsdC5ET01QYXJzZXI9cig1NzUyKS5ET01QYXJzZXJ9LDQ0NjY6KGUsdCxyKT0+e3ZhciBhPXIoNDU4MikuTkFNRVNQQUNFLG49L1tBLVpfYS16XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vLG89bmV3IFJlZ0V4cChcIltcXFxcLVxcXFwuMC05XCIrbi5zb3VyY2Uuc2xpY2UoMSwtMSkrXCJcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF1cIiksaT1uZXcgUmVnRXhwKFwiXlwiK24uc291cmNlK28uc291cmNlK1wiKig/OjpcIituLnNvdXJjZStvLnNvdXJjZStcIiopPyRcIik7ZnVuY3Rpb24gcyhlLHQpe3RoaXMubWVzc2FnZT1lLHRoaXMubG9jYXRvcj10LEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHMpfWZ1bmN0aW9uIGwoKXt9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiB0LmxpbmVOdW1iZXI9ZS5saW5lTnVtYmVyLHQuY29sdW1uTnVtYmVyPWUuY29sdW1uTnVtYmVyLHR9ZnVuY3Rpb24gdShlLHQscixuLG8saSl7ZnVuY3Rpb24gcyhlLHQsYSl7ci5hdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShlKSYmaS5mYXRhbEVycm9yKFwiQXR0cmlidXRlIFwiK2UrXCIgcmVkZWZpbmVkXCIpLHIuYWRkVmFsdWUoZSx0LnJlcGxhY2UoL1tcXHRcXG5cXHJdL2csXCIgXCIpLnJlcGxhY2UoLyYjP1xcdys7L2csbyksYSl9Zm9yKHZhciBsLGM9Kyt0LHU9MDs7KXt2YXIgaD1lLmNoYXJBdChjKTtzd2l0Y2goaCl7Y2FzZVwiPVwiOmlmKDE9PT11KWw9ZS5zbGljZSh0LGMpLHU9MztlbHNle2lmKDIhPT11KXRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBlcXVhbCBtdXN0IGFmdGVyIGF0dHJOYW1lXCIpO3U9M31icmVhaztjYXNlXCInXCI6Y2FzZSdcIic6aWYoMz09PXV8fDE9PT11KXtpZigxPT09dSYmKGkud2FybmluZygnYXR0cmlidXRlIHZhbHVlIG11c3QgYWZ0ZXIgXCI9XCInKSxsPWUuc2xpY2UodCxjKSksdD1jKzEsISgoYz1lLmluZGV4T2YoaCx0KSk+MCkpdGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIHZhbHVlIG5vIGVuZCAnXCIraCtcIicgbWF0Y2hcIik7cyhsLGQ9ZS5zbGljZSh0LGMpLHQtMSksdT01fWVsc2V7aWYoNCE9dSl0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSB2YWx1ZSBtdXN0IGFmdGVyIFwiPVwiJyk7cyhsLGQ9ZS5zbGljZSh0LGMpLHQpLGkud2FybmluZygnYXR0cmlidXRlIFwiJytsKydcIiBtaXNzZWQgc3RhcnQgcXVvdCgnK2grXCIpISFcIiksdD1jKzEsdT01fWJyZWFrO2Nhc2VcIi9cIjpzd2l0Y2godSl7Y2FzZSAwOnIuc2V0VGFnTmFtZShlLnNsaWNlKHQsYykpO2Nhc2UgNTpjYXNlIDY6Y2FzZSA3OnU9NyxyLmNsb3NlZD0hMDtjYXNlIDQ6Y2FzZSAxOmJyZWFrO2Nhc2UgMjpyLmNsb3NlZD0hMDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBpbnZhbGlkIGNsb3NlIGNoYXIoJy8nKVwiKX1icmVhaztjYXNlXCJcIjpyZXR1cm4gaS5lcnJvcihcInVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpLDA9PXUmJnIuc2V0VGFnTmFtZShlLnNsaWNlKHQsYykpLGM7Y2FzZVwiPlwiOnN3aXRjaCh1KXtjYXNlIDA6ci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSk7Y2FzZSA1OmNhc2UgNjpjYXNlIDc6YnJlYWs7Y2FzZSA0OmNhc2UgMTpcIi9cIj09PShkPWUuc2xpY2UodCxjKSkuc2xpY2UoLTEpJiYoci5jbG9zZWQ9ITAsZD1kLnNsaWNlKDAsLTEpKTtjYXNlIDI6Mj09PXUmJihkPWwpLDQ9PXU/KGkud2FybmluZygnYXR0cmlidXRlIFwiJytkKydcIiBtaXNzZWQgcXVvdChcIikhJykscyhsLGQsdCkpOihhLmlzSFRNTChuW1wiXCJdKSYmZC5tYXRjaCgvXig/OmRpc2FibGVkfGNoZWNrZWR8c2VsZWN0ZWQpJC9pKXx8aS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2QrJ1wiIG1pc3NlZCB2YWx1ZSEhIFwiJytkKydcIiBpbnN0ZWFkISEnKSxzKGQsZCx0KSk7YnJlYWs7Y2FzZSAzOnRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSB2YWx1ZSBtaXNzZWQhIVwiKX1yZXR1cm4gYztjYXNlXCLCgFwiOmg9XCIgXCI7ZGVmYXVsdDppZihoPD1cIiBcIilzd2l0Y2godSl7Y2FzZSAwOnIuc2V0VGFnTmFtZShlLnNsaWNlKHQsYykpLHU9NjticmVhaztjYXNlIDE6bD1lLnNsaWNlKHQsYyksdT0yO2JyZWFrO2Nhc2UgNDp2YXIgZD1lLnNsaWNlKHQsYyk7aS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2QrJ1wiIG1pc3NlZCBxdW90KFwiKSEhJykscyhsLGQsdCk7Y2FzZSA1OnU9Nn1lbHNlIHN3aXRjaCh1KXtjYXNlIDI6ci50YWdOYW1lLGEuaXNIVE1MKG5bXCJcIl0pJiZsLm1hdGNoKC9eKD86ZGlzYWJsZWR8Y2hlY2tlZHxzZWxlY3RlZCkkL2kpfHxpLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrbCsnXCIgbWlzc2VkIHZhbHVlISEgXCInK2wrJ1wiIGluc3RlYWQyISEnKSxzKGwsbCx0KSx0PWMsdT0xO2JyZWFrO2Nhc2UgNTppLndhcm5pbmcoJ2F0dHJpYnV0ZSBzcGFjZSBpcyByZXF1aXJlZFwiJytsKydcIiEhJyk7Y2FzZSA2OnU9MSx0PWM7YnJlYWs7Y2FzZSAzOnU9NCx0PWM7YnJlYWs7Y2FzZSA3OnRocm93IG5ldyBFcnJvcihcImVsZW1lbnRzIGNsb3NlZCBjaGFyYWN0ZXIgJy8nIGFuZCAnPicgbXVzdCBiZSBjb25uZWN0ZWQgdG9cIil9fWMrK319ZnVuY3Rpb24gaChlLHQscil7Zm9yKHZhciBuPWUudGFnTmFtZSxvPW51bGwsaT1lLmxlbmd0aDtpLS07KXt2YXIgcz1lW2ldLGw9cy5xTmFtZSxjPXMudmFsdWU7aWYoKG09bC5pbmRleE9mKFwiOlwiKSk+MCl2YXIgdT1zLnByZWZpeD1sLnNsaWNlKDAsbSksaD1sLnNsaWNlKG0rMSksZD1cInhtbG5zXCI9PT11JiZoO2Vsc2UgaD1sLHU9bnVsbCxkPVwieG1sbnNcIj09PWwmJlwiXCI7cy5sb2NhbE5hbWU9aCwhMSE9PWQmJihudWxsPT1vJiYobz17fSxwKHIscj17fSkpLHJbZF09b1tkXT1jLHMudXJpPWEuWE1MTlMsdC5zdGFydFByZWZpeE1hcHBpbmcoZCxjKSl9Zm9yKGk9ZS5sZW5ndGg7aS0tOykodT0ocz1lW2ldKS5wcmVmaXgpJiYoXCJ4bWxcIj09PXUmJihzLnVyaT1hLlhNTCksXCJ4bWxuc1wiIT09dSYmKHMudXJpPXJbdXx8XCJcIl0pKTt2YXIgbTsobT1uLmluZGV4T2YoXCI6XCIpKT4wPyh1PWUucHJlZml4PW4uc2xpY2UoMCxtKSxoPWUubG9jYWxOYW1lPW4uc2xpY2UobSsxKSk6KHU9bnVsbCxoPWUubG9jYWxOYW1lPW4pO3ZhciBmPWUudXJpPXJbdXx8XCJcIl07aWYodC5zdGFydEVsZW1lbnQoZixoLG4sZSksIWUuY2xvc2VkKXJldHVybiBlLmN1cnJlbnROU01hcD1yLGUubG9jYWxOU01hcD1vLCEwO2lmKHQuZW5kRWxlbWVudChmLGgsbiksbylmb3IodSBpbiBvKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLHUpJiZ0LmVuZFByZWZpeE1hcHBpbmcodSl9ZnVuY3Rpb24gZChlLHQscixhLG4pe2lmKC9eKD86c2NyaXB0fHRleHRhcmVhKSQvaS50ZXN0KHIpKXt2YXIgbz1lLmluZGV4T2YoXCI8L1wiK3IrXCI+XCIsdCksaT1lLnN1YnN0cmluZyh0KzEsbyk7aWYoL1smPF0vLnRlc3QoaSkpcmV0dXJuL15zY3JpcHQkL2kudGVzdChyKT8obi5jaGFyYWN0ZXJzKGksMCxpLmxlbmd0aCksbyk6KGk9aS5yZXBsYWNlKC8mIz9cXHcrOy9nLGEpLG4uY2hhcmFjdGVycyhpLDAsaS5sZW5ndGgpLG8pfXJldHVybiB0KzF9ZnVuY3Rpb24gbShlLHQscixhKXt2YXIgbj1hW3JdO3JldHVybiBudWxsPT1uJiYoKG49ZS5sYXN0SW5kZXhPZihcIjwvXCIrcitcIj5cIikpPHQmJihuPWUubGFzdEluZGV4T2YoXCI8L1wiK3IpKSxhW3JdPW4pLG48dH1mdW5jdGlvbiBwKGUsdCl7Zm9yKHZhciByIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pfWZ1bmN0aW9uIGYoZSx0LHIsYSl7aWYoXCItXCI9PT1lLmNoYXJBdCh0KzIpKXJldHVyblwiLVwiPT09ZS5jaGFyQXQodCszKT8obj1lLmluZGV4T2YoXCItLVxceDNlXCIsdCs0KSk+dD8oci5jb21tZW50KGUsdCs0LG4tdC00KSxuKzMpOihhLmVycm9yKFwiVW5jbG9zZWQgY29tbWVudFwiKSwtMSk6LTE7aWYoXCJDREFUQVtcIj09ZS5zdWJzdHIodCszLDYpKXt2YXIgbj1lLmluZGV4T2YoXCJdXT5cIix0KzkpO3JldHVybiByLnN0YXJ0Q0RBVEEoKSxyLmNoYXJhY3RlcnMoZSx0Kzksbi10LTkpLHIuZW5kQ0RBVEEoKSxuKzN9dmFyIG89ZnVuY3Rpb24oZSx0KXt2YXIgcixhPVtdLG49LydbXiddKyd8XCJbXlwiXStcInxbXlxcczw+XFwvPV0rPT98KFxcLz9cXHMqPnw8KS9nO2ZvcihuLmxhc3RJbmRleD10LG4uZXhlYyhlKTtyPW4uZXhlYyhlKTspaWYoYS5wdXNoKHIpLHJbMV0pcmV0dXJuIGF9KGUsdCksaT1vLmxlbmd0aDtpZihpPjEmJi8hZG9jdHlwZS9pLnRlc3Qob1swXVswXSkpe3ZhciBzPW9bMV1bMF0sbD0hMSxjPSExO2k+MyYmKC9ecHVibGljJC9pLnRlc3Qob1syXVswXSk/KGw9b1szXVswXSxjPWk+NCYmb1s0XVswXSk6L15zeXN0ZW0kL2kudGVzdChvWzJdWzBdKSYmKGM9b1szXVswXSkpO3ZhciB1PW9baS0xXTtyZXR1cm4gci5zdGFydERURChzLGwsYyksci5lbmREVEQoKSx1LmluZGV4K3VbMF0ubGVuZ3RofXJldHVybi0xfWZ1bmN0aW9uIHgoZSx0LHIpe3ZhciBhPWUuaW5kZXhPZihcIj8+XCIsdCk7aWYoYSl7dmFyIG49ZS5zdWJzdHJpbmcodCxhKS5tYXRjaCgvXjxcXD8oXFxTKilcXHMqKFtcXHNcXFNdKj8pXFxzKiQvKTtyZXR1cm4gbj8oblswXS5sZW5ndGgsci5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oblsxXSxuWzJdKSxhKzIpOi0xfXJldHVybi0xfWZ1bmN0aW9uIGcoKXt0aGlzLmF0dHJpYnV0ZU5hbWVzPXt9fXMucHJvdG90eXBlPW5ldyBFcnJvcixzLnByb3RvdHlwZS5uYW1lPXMubmFtZSxsLnByb3RvdHlwZT17cGFyc2U6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMuZG9tQnVpbGRlcjtuLnN0YXJ0RG9jdW1lbnQoKSxwKHQsdD17fSksZnVuY3Rpb24oZSx0LHIsbixvKXtmdW5jdGlvbiBpKGUpe3ZhciB0PWUuc2xpY2UoMSwtMSk7cmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsdCk/clt0XTpcIiNcIj09PXQuY2hhckF0KDApP2Z1bmN0aW9uKGUpe2lmKGU+NjU1MzUpe3ZhciB0PTU1Mjk2KygoZS09NjU1MzYpPj4xMCkscj01NjMyMCsoMTAyMyZlKTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0LHIpfXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpfShwYXJzZUludCh0LnN1YnN0cigxKS5yZXBsYWNlKFwieFwiLFwiMHhcIikpKTooby5lcnJvcihcImVudGl0eSBub3QgZm91bmQ6XCIrZSksZSl9ZnVuY3Rpb24gbCh0KXtpZih0Pl8pe3ZhciByPWUuc3Vic3RyaW5nKF8sdCkucmVwbGFjZSgvJiM/XFx3KzsvZyxpKTtDJiZwKF8pLG4uY2hhcmFjdGVycyhyLDAsdC1fKSxfPXR9fWZ1bmN0aW9uIHAodCxyKXtmb3IoO3Q+PWImJihyPXYuZXhlYyhlKSk7KXc9ci5pbmRleCxiPXcrclswXS5sZW5ndGgsQy5saW5lTnVtYmVyKys7Qy5jb2x1bW5OdW1iZXI9dC13KzF9Zm9yKHZhciB3PTAsYj0wLHY9Ly4qKD86XFxyXFxuP3xcXG4pfC4qJC9nLEM9bi5sb2NhdG9yLEE9W3tjdXJyZW50TlNNYXA6dH1dLEU9e30sXz0wOzspe3RyeXt2YXIgeT1lLmluZGV4T2YoXCI8XCIsXyk7aWYoeTwwKXtpZighZS5zdWJzdHIoXykubWF0Y2goL15cXHMqJC8pKXt2YXIgcT1uLmRvYyxEPXEuY3JlYXRlVGV4dE5vZGUoZS5zdWJzdHIoXykpO3EuYXBwZW5kQ2hpbGQoRCksbi5jdXJyZW50RWxlbWVudD1EfXJldHVybn1zd2l0Y2goeT5fJiZsKHkpLGUuY2hhckF0KHkrMSkpe2Nhc2VcIi9cIjp2YXIgTT1lLmluZGV4T2YoXCI+XCIseSszKSxUPWUuc3Vic3RyaW5nKHkrMixNKS5yZXBsYWNlKC9bIFxcdFxcblxccl0rJC9nLFwiXCIpLE49QS5wb3AoKTtNPDA/KFQ9ZS5zdWJzdHJpbmcoeSsyKS5yZXBsYWNlKC9bXFxzPF0uKi8sXCJcIiksby5lcnJvcihcImVuZCB0YWcgbmFtZTogXCIrVCtcIiBpcyBub3QgY29tcGxldGU6XCIrTi50YWdOYW1lKSxNPXkrMStULmxlbmd0aCk6VC5tYXRjaCgvXFxzPC8pJiYoVD1ULnJlcGxhY2UoL1tcXHM8XS4qLyxcIlwiKSxvLmVycm9yKFwiZW5kIHRhZyBuYW1lOiBcIitUK1wiIG1heWJlIG5vdCBjb21wbGV0ZVwiKSxNPXkrMStULmxlbmd0aCk7dmFyIE89Ti5sb2NhbE5TTWFwLEw9Ti50YWdOYW1lPT1UO2lmKEx8fE4udGFnTmFtZSYmTi50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PVQudG9Mb3dlckNhc2UoKSl7aWYobi5lbmRFbGVtZW50KE4udXJpLE4ubG9jYWxOYW1lLFQpLE8pZm9yKHZhciBCIGluIE8pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE8sQikmJm4uZW5kUHJlZml4TWFwcGluZyhCKTtMfHxvLmZhdGFsRXJyb3IoXCJlbmQgdGFnIG5hbWU6IFwiK1QrXCIgaXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IHN0YXJ0IHRhZ05hbWU6XCIrTi50YWdOYW1lKX1lbHNlIEEucHVzaChOKTtNKys7YnJlYWs7Y2FzZVwiP1wiOkMmJnAoeSksTT14KGUseSxuKTticmVhaztjYXNlXCIhXCI6QyYmcCh5KSxNPWYoZSx5LG4sbyk7YnJlYWs7ZGVmYXVsdDpDJiZwKHkpO3ZhciBTPW5ldyBnLEY9QVtBLmxlbmd0aC0xXS5jdXJyZW50TlNNYXAsUD0oTT11KGUseSxTLEYsaSxvKSxTLmxlbmd0aCk7aWYoIVMuY2xvc2VkJiZtKGUsTSxTLnRhZ05hbWUsRSkmJihTLmNsb3NlZD0hMCxyLm5ic3B8fG8ud2FybmluZyhcInVuY2xvc2VkIHhtbCBhdHRyaWJ1dGVcIikpLEMmJlApe2Zvcih2YXIgaz1jKEMse30pLFI9MDtSPFA7UisrKXt2YXIgST1TW1JdO3AoSS5vZmZzZXQpLEkubG9jYXRvcj1jKEMse30pfW4ubG9jYXRvcj1rLGgoUyxuLEYpJiZBLnB1c2goUyksbi5sb2NhdG9yPUN9ZWxzZSBoKFMsbixGKSYmQS5wdXNoKFMpO2EuaXNIVE1MKFMudXJpKSYmIVMuY2xvc2VkP009ZChlLE0sUy50YWdOYW1lLGksbik6TSsrfX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2Ygcyl0aHJvdyBlO28uZXJyb3IoXCJlbGVtZW50IHBhcnNlIGVycm9yOiBcIitlKSxNPS0xfU0+Xz9fPU06bChNYXRoLm1heCh5LF8pKzEpfX0oZSx0LHIsbix0aGlzLmVycm9ySGFuZGxlciksbi5lbmREb2N1bWVudCgpfX0sZy5wcm90b3R5cGU9e3NldFRhZ05hbWU6ZnVuY3Rpb24oZSl7aWYoIWkudGVzdChlKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRhZ05hbWU6XCIrZSk7dGhpcy50YWdOYW1lPWV9LGFkZFZhbHVlOmZ1bmN0aW9uKGUsdCxyKXtpZighaS50ZXN0KGUpKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXR0cmlidXRlOlwiK2UpO3RoaXMuYXR0cmlidXRlTmFtZXNbZV09dGhpcy5sZW5ndGgsdGhpc1t0aGlzLmxlbmd0aCsrXT17cU5hbWU6ZSx2YWx1ZTp0LG9mZnNldDpyfX0sbGVuZ3RoOjAsZ2V0TG9jYWxOYW1lOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLmxvY2FsTmFtZX0sZ2V0TG9jYXRvcjpmdW5jdGlvbihlKXtyZXR1cm4gdGhpc1tlXS5sb2NhdG9yfSxnZXRRTmFtZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpc1tlXS5xTmFtZX0sZ2V0VVJJOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLnVyaX0sZ2V0VmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXNbZV0udmFsdWV9fSx0LlhNTFJlYWRlcj1sLHQuUGFyc2VFcnJvcj1zfSw4OTE3OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3I9dm9pZCAwO3ZhciBhPXIoNjIwMCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJJbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcn19KX0sNjIwMDooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcj12b2lkIDA7Y2xhc3MgciBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGUsdCxyLGE9XCJleGFjdGx5XCIpe3N1cGVyKGAke2V9IHRhZyBtdXN0IGhhdmUgJHthfSAke3R9IGNoaWxkcmVuLiBJdCdzIGFjdHVhbGx5ICR7cn1gKSx0aGlzLm5hbWU9XCJJbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yXCJ9fXQuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcj1yfSw0Mjc5OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocig4MjgpLHQpLG4ocig1OTc1KSx0KSxuKHIoNzk5KSx0KSxuKHIoMjQyNCksdCl9LDU5NzU6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkpvaW5XaXRoTWFueVNlcGFyYXRvcnM9dm9pZCAwO2NsYXNzIHJ7Y29uc3RydWN0b3IoZSl7dGhpcy5fc2VwYXJhdG9ycz1lfXN0YXRpYyBqb2luKGUsdCl7cmV0dXJuIG5ldyByKHQpLl9qb2luKGUpfV9qb2luKGUpe3JldHVybiBlLnJlZHVjZSgoKGUsdCxyLGEpPT5lK3QrKHI9PT1hLmxlbmd0aC0xP1wiXCI6dGhpcy5fZ2V0KHIpKSksXCJcIil9X2dldChlKXtyZXR1cm4gdGhpcy5fc2VwYXJhdG9yc1tlXT90aGlzLl9zZXBhcmF0b3JzW2VdOnRoaXMuX3NlcGFyYXRvcnMubGVuZ3RoPjA/dGhpcy5fc2VwYXJhdG9yc1t0aGlzLl9zZXBhcmF0b3JzLmxlbmd0aC0xXTpcIixcIn19dC5Kb2luV2l0aE1hbnlTZXBhcmF0b3JzPXJ9LDc5OTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcj12b2lkIDA7Y29uc3QgYT1yKDU0NDMpO3QubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXI9ZT0+bmV3IGEuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyKGUpLnRvTGF0ZXhDb252ZXJ0ZXIoKX0sMjQyNDooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubm9ybWFsaXplV2hpdGVTcGFjZXM9dm9pZCAwLHQubm9ybWFsaXplV2hpdGVTcGFjZXM9ZT0+ZS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpfSw3MTkyOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkJyYWNrZXRXcmFwcGVyPXZvaWQgMDtjb25zdCBhPXIoMTg1NSk7dC5CcmFja2V0V3JhcHBlcj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX29wZW49XCJ7XCIsdGhpcy5fY2xvc2U9XCJ9XCJ9d3JhcChlKXtyZXR1cm4gbmV3IGEuV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfX19LDUwMjU6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuR2VuZXJpY1dyYXBwZXI9dm9pZCAwO2NvbnN0IGE9cigxODU1KTt0LkdlbmVyaWNXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5fb3Blbj1cIlxcXFxsZWZ0XCIrZSx0aGlzLl9jbG9zZT1cIlxcXFxyaWdodFwiK3R9d3JhcChlKXtyZXR1cm4gbmV3IGEuV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfX19LDgyODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljV3JhcHBlcj10LlBhcmVudGhlc2lzV3JhcHBlcj10LkJyYWNrZXRXcmFwcGVyPXZvaWQgMDt2YXIgYT1yKDcxOTIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiQnJhY2tldFdyYXBwZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5CcmFja2V0V3JhcHBlcn19KTt2YXIgbj1yKDExNjgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiUGFyZW50aGVzaXNXcmFwcGVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uUGFyZW50aGVzaXNXcmFwcGVyfX0pO3ZhciBvPXIoNTAyNSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJHZW5lcmljV3JhcHBlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLkdlbmVyaWNXcmFwcGVyfX0pfSwxMTY4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlBhcmVudGhlc2lzV3JhcHBlcj12b2lkIDA7Y29uc3QgYT1yKDE4NTUpO3QuUGFyZW50aGVzaXNXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fb3Blbj1cIlxcXFxsZWZ0KFwiLHRoaXMuX2Nsb3NlPVwiXFxcXHJpZ2h0KVwifXdyYXAoZSl7cmV0dXJuIG5ldyBhLldyYXBwZXIodGhpcy5fb3Blbix0aGlzLl9jbG9zZSkud3JhcChlKX13cmFwSWZNb3JlVGhhbk9uZUNoYXIoZSl7cmV0dXJuIGUubGVuZ3RoPD0xP2U6dGhpcy53cmFwKGUpfX19LDE4NTU6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldyYXBwZXI9dm9pZCAwLHQuV3JhcHBlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX29wZW49ZSx0aGlzLl9jbG9zZT10fXdyYXAoZSl7cmV0dXJuIHRoaXMuX29wZW4rZSt0aGlzLl9jbG9zZX19fSwyNjk3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Wb2lkTWF0aE1MRWxlbWVudD12b2lkIDAsdC5Wb2lkTWF0aE1MRWxlbWVudD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMubmFtZT1cInZvaWRcIix0aGlzLnZhbHVlPVwiXCIsdGhpcy5jaGlsZHJlbj1bXSx0aGlzLmF0dHJpYnV0ZXM9e319fX0sNDc2MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljU3BhY2luZ1dyYXBwZXI9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0LkdlbmVyaWNTcGFjaW5nV3JhcHBlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe3JldHVybiB0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIil9fX0sOTM3NjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljVW5kZXJPdmVyPXZvaWQgMDtjb25zdCBhPXIoNzk5KSxuPXIoODkxNyksbz1yKDQ3Mik7dC5HZW5lcmljVW5kZXJPdmVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMixyKTtjb25zdCBvPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMF0pLmNvbnZlcnQoKSxpPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMV0pLmNvbnZlcnQoKTtyZXR1cm4gdGhpcy5fYXBwbHlDb21tYW5kKG8saSl9X2FwcGx5Q29tbWFuZChlLHQpe2NvbnN0IHI9dGhpcy5fbWF0aG1sRWxlbWVudC5uYW1lLm1hdGNoKC91bmRlci8pP3MuVW5kZXI6cy5PdmVyO3JldHVybiBuZXcgaShyKS5hcHBseShlLHQpfX07Y2xhc3MgaXtjb25zdHJ1Y3RvcihlKXt0aGlzLl90eXBlPWV9YXBwbHkoZSx0KXtyZXR1cm4gby5sYXRleEFjY2VudHMuaW5jbHVkZXModCk/YCR7dH17JHtlfX1gOmAke3RoaXMuX2RlZmF1bHRDb21tYW5kfXske3R9fXske2V9fWB9Z2V0IF9kZWZhdWx0Q29tbWFuZCgpe3JldHVybiB0aGlzLl90eXBlPT09cy5VbmRlcj9cIlxcXFx1bmRlcnNldFwiOlwiXFxcXG92ZXJzZXRcIn19dmFyIHM7IWZ1bmN0aW9uKGUpe2VbZS5VbmRlcj0wXT1cIlVuZGVyXCIsZVtlLk92ZXI9MV09XCJPdmVyXCJ9KHN8fChzPXt9KSl9LDY5NTk6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVm9pZD10LkdlbmVyaWNVbmRlck92ZXI9dC5HZW5lcmljU3BhY2luZ1dyYXBwZXI9dC5NVHI9dC5NVGFibGU9dC5NVW5kZXJvdmVyPXQuTVRleHQ9dC5NTXVsdGlzY3JpcHRzPXQuTVN1YnN1cD10Lk1TdWI9dC5NU3VwPXQuTVBoYW50b209dC5NRXJyb3I9dC5NRW5jbG9zZT10Lk1BY3Rpb249dC5NUm9vdD10Lk1GcmFjPXQuTUZlbmNlZD10Lk1TcXJ0PXQuTU49dC5NTz10Lk1JPXQuTWF0aD12b2lkIDA7dmFyIGE9cigzOTMpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTWF0aFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLk1hdGh9fSk7dmFyIG49cig3MDM3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1JXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uTUl9fSk7dmFyIG89cigzNDg3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1PXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uTU99fSk7dmFyIGk9cig0NDY0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1OXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuTU59fSk7dmFyIHM9cig4Njg2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1TcXJ0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuTVNxcnR9fSk7dmFyIGw9cig5NTExKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1GZW5jZWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5NRmVuY2VkfX0pO3ZhciBjPXIoNjQ0MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNRnJhY1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLk1GcmFjfX0pO3ZhciB1PXIoNjA1Mik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNUm9vdFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1Lk1Sb290fX0pO3ZhciBoPXIoMTY3OCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNQWN0aW9uXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguTUFjdGlvbn19KTt2YXIgZD1yKDI2MzEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUVuY2xvc2VcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5NRW5jbG9zZX19KTt2YXIgbT1yKDE4NDApO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUVycm9yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG0uTUVycm9yfX0pO3ZhciBwPXIoNzQ0Myk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNUGhhbnRvbVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBwLk1QaGFudG9tfX0pO3ZhciBmPXIoNjkyNik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNU3VwXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuTVN1cH19KTt2YXIgeD1yKDI1NjQpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVN1YlwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB4Lk1TdWJ9fSk7dmFyIGc9cigxMzU4KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1TdWJzdXBcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZy5NU3Vic3VwfX0pO3ZhciB3PXIoODMwMyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNTXVsdGlzY3JpcHRzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHcuTU11bHRpc2NyaXB0c319KTt2YXIgYj1yKDM5NTEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVRleHRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5NVGV4dH19KTt2YXIgdj1yKDEyMjIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVVuZGVyb3ZlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB2Lk1VbmRlcm92ZXJ9fSk7dmFyIEM9cigyMzUwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1UYWJsZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBDLk1UYWJsZX19KTt2YXIgQT1yKDE1ODYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVRyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEEuTVRyfX0pO3ZhciBFPXIoNDc2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJHZW5lcmljU3BhY2luZ1dyYXBwZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRS5HZW5lcmljU3BhY2luZ1dyYXBwZXJ9fSk7dmFyIF89cig5Mzc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkdlbmVyaWNVbmRlck92ZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gXy5HZW5lcmljVW5kZXJPdmVyfX0pO3ZhciB5PXIoOTE2NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJWb2lkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHkuVm9pZH19KX0sMTY3ODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NQWN0aW9uPXZvaWQgMDtjb25zdCBhPXIoNzk5KTt0Lk1BY3Rpb249Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtjaGlsZHJlbjplfT10aGlzLl9tYXRobWxFbGVtZW50O3JldHVybiB0aGlzLl9pc1RvZ2dsZSgpP2UubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFxcXFxMb25ncmlnaHRhcnJvdyBcIik6KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZVswXSkuY29udmVydCgpfV9pc1RvZ2dsZSgpe2NvbnN0e2FjdGlvbnR5cGU6ZX09dGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzO3JldHVyblwidG9nZ2xlXCI9PT1lfHwhZX19fSwzOTM6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTWF0aD12b2lkIDA7Y29uc3QgYT1yKDc5OSksbj1yKDI0MjQpO3QuTWF0aD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0IGU9dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpO3JldHVybigwLG4ubm9ybWFsaXplV2hpdGVTcGFjZXMpKGUpfX19LDI2MzE6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTUVuY2xvc2U9dm9pZCAwO2NvbnN0IGE9cig3OTkpO3QuTUVuY2xvc2U9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdCBlPXRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFwiKTtyZXR1cm5cImFjdHVhcmlhbFwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxvdmVybGluZXtcXFxcbGVmdC4ke2V9XFxcXHJpZ2h0fH1gOlwicmFkaWNhbFwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxzcXJ0eyR7ZX19YDpbXCJib3hcIixcInJvdW5kZWRib3hcIixcImNpcmNsZVwiXS5pbmNsdWRlcyh0aGlzLl9ub3RhdGlvbik/YFxcXFxib3hlZHske2V9fWA6XCJsZWZ0XCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXGxlZnR8JHtlfWA6XCJyaWdodFwiPT09dGhpcy5fbm90YXRpb24/YCR7ZX1cXFxccmlnaHR8YDpcInRvcFwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxvdmVybGluZXske2V9fWA6XCJib3R0b21cIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcdW5kZXJsaW5leyR7ZX19YDpcInVwZGlhZ29uYWxzdHJpa2VcIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcY2FuY2VseyR7ZX19YDpcImRvd25kaWFnb25hbHN0cmlrZVwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxiY2FuY2VseyR7ZX19YDpcInVwZGlhZ29uYWxhcnJvd1wiPT09dGhpcy5fbm90YXRpb24/YFxcXFxjYW5jZWx0b3t9eyR7ZX19YDpbXCJ2ZXJ0aWNhbHN0cmlrZVwiLFwiaG9yaXpvbnRhbHN0cmlrZVwiXS5pbmNsdWRlcyh0aGlzLl9ub3RhdGlvbik/YFxcXFxoY2FuY2VseyR7ZX19YDpcIm1hZHJ1d2JcIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcdW5kZXJsaW5leyR7ZX1cXFxccmlnaHR8fWA6XCJwaGFzb3JhbmdsZVwiPT09dGhpcy5fbm90YXRpb24/YHtcXFxcYW5nbGUgXFxcXHVuZGVybGluZXske2V9fX1gOmBcXFxcb3ZlcmxpbmV7XFxcXGxlZnQuXFxcXHJpZ2h0KSR7ZX19YH1nZXQgX25vdGF0aW9uKCl7cmV0dXJuIHRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5ub3RhdGlvbnx8XCJsb25nZGl2XCJ9fX0sMTg0MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRXJyb3I9dm9pZCAwO2NvbnN0IGE9cig3OTkpO3QuTUVycm9yPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuYFxcXFxjb2xvcntyZWR9eyR7dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpfX1gfX19LDk1MTE6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTUZlbmNlZD12b2lkIDA7Y29uc3QgYT1yKDc5OSksbj1yKDQyNzkpO3QuTUZlbmNlZD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWUsdGhpcy5fb3Blbj10aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMub3Blbnx8XCJcIix0aGlzLl9jbG9zZT10aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMuY2xvc2V8fFwiXCIsdGhpcy5fc2VwYXJhdG9ycz1BcnJheS5mcm9tKHRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5zZXBhcmF0b3JzfHxcIlwiKX1jb252ZXJ0KCl7Y29uc3QgZT10aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSk7cmV0dXJuIHRoaXMuX2lzVGhlcmVSZWxhdGl2ZU9mTmFtZSh0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLFwibXRhYmxlXCIpP25ldyBpKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLmFwcGx5KGUpOm5ldyBvKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UsdGhpcy5fc2VwYXJhdG9ycykuYXBwbHkoZSl9X2lzVGhlcmVSZWxhdGl2ZU9mTmFtZShlLHQpe3JldHVybiBlLnNvbWUoKGU9PmUubmFtZT09PXR8fHRoaXMuX2lzVGhlcmVSZWxhdGl2ZU9mTmFtZShlLmNoaWxkcmVuLHQpKSl9fTtjbGFzcyBve2NvbnN0cnVjdG9yKGUsdCxyKXt0aGlzLl9vcGVuPWV8fFwiKFwiLHRoaXMuX2Nsb3NlPXR8fFwiKVwiLHRoaXMuX3NlcGFyYXRvcnM9cn1hcHBseShlKXtjb25zdCB0PW4uSm9pbldpdGhNYW55U2VwYXJhdG9ycy5qb2luKGUsdGhpcy5fc2VwYXJhdG9ycyk7cmV0dXJuIG5ldyBuLkdlbmVyaWNXcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAodCl9fWNsYXNzIGl7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9nZW5lcmljQ29tbWFuZD1cIm1hdHJpeFwiLHRoaXMuX3NlcGFyYXRvcnM9bmV3IHMoZSx0KX1hcHBseShlKXtjb25zdCB0PXRoaXMuX2NvbW1hbmQscj1gXFxcXGJlZ2lueyR7dH19XFxuJHtlLmpvaW4oXCJcIil9XFxuXFxcXGVuZHske3R9fWA7cmV0dXJuIHQ9PT10aGlzLl9nZW5lcmljQ29tbWFuZD90aGlzLl9zZXBhcmF0b3JzLndyYXAocik6cn1nZXQgX2NvbW1hbmQoKXtyZXR1cm4gdGhpcy5fc2VwYXJhdG9ycy5hcmVQYXJlbnRoZXNlcygpP1wicG1hdHJpeFwiOnRoaXMuX3NlcGFyYXRvcnMuYXJlU3F1YXJlQnJhY2tldHMoKT9cImJtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZUJyYWNrZXRzKCk/XCJCbWF0cml4XCI6dGhpcy5fc2VwYXJhdG9ycy5hcmVEaXZpZGVzKCk/XCJ2bWF0cml4XCI6dGhpcy5fc2VwYXJhdG9ycy5hcmVQYXJhbGxlbHMoKT9cIlZtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZU5vdEVxdWFsKCk/dGhpcy5fZ2VuZXJpY0NvbW1hbmQ6XCJibWF0cml4XCJ9fWNsYXNzIHN7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9vcGVuPWUsdGhpcy5fY2xvc2U9dH13cmFwKGUpe3JldHVybiBuZXcgbi5HZW5lcmljV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfWFyZVBhcmVudGhlc2VzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCIoXCIsXCIpXCIpfWFyZVNxdWFyZUJyYWNrZXRzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCJbXCIsXCJdXCIpfWFyZUJyYWNrZXRzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCJ7XCIsXCJ9XCIpfWFyZURpdmlkZXMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcInxcIixcInxcIil9YXJlUGFyYWxsZWxzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCJ8fFwiLFwifHxcIil9YXJlTm90RXF1YWwoKXtyZXR1cm4gdGhpcy5fb3BlbiE9PXRoaXMuX2Nsb3NlfV9jb21wYXJlKGUsdCl7cmV0dXJuIHRoaXMuX29wZW49PT1lJiZ0aGlzLl9jbG9zZT09PXR9fX0sNjQ0MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRnJhYz12b2lkIDA7Y29uc3QgYT1yKDg5MTcpLG49cig0Mjc5KTt0Lk1GcmFjPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7Y2hpbGRyZW46ZSxuYW1lOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj1lLmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgYS5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKHQsMixyKTtjb25zdCBvPSgwLG4ubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGVbMF0pLmNvbnZlcnQoKSxpPSgwLG4ubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGVbMV0pLmNvbnZlcnQoKTtyZXR1cm4gdGhpcy5faXNCZXZlbGxlZCgpP2Ake3RoaXMuX3dyYXBJZk1vcmVUaGFuT25lQ2hhcihvKX0vJHt0aGlzLl93cmFwSWZNb3JlVGhhbk9uZUNoYXIoaSl9YDpgXFxcXGZyYWN7JHtvfX17JHtpfX1gfV93cmFwSWZNb3JlVGhhbk9uZUNoYXIoZSl7cmV0dXJuKG5ldyBuLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcElmTW9yZVRoYW5PbmVDaGFyKGUpfV9pc0JldmVsbGVkKCl7cmV0dXJuISF0aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMuYmV2ZWxsZWR9fX0sNzAzNzooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NST12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig1NDA2KSxvPXIoNjEyMik7dC5NST1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnV0ZjhDb252ZXJ0ZXI9bmV3IG8uSGFzaFVURjhUb0x0WENvbnZlcnRlcix0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0IGU9KDAsYS5ub3JtYWxpemVXaGl0ZVNwYWNlcykodGhpcy5fbWF0aG1sRWxlbWVudC52YWx1ZSk7aWYoXCIgXCI9PT1lKXJldHVybiBpLmFwcGx5KGUpO2NvbnN0IHQ9ZS50cmltKCkscj1pLmFwcGx5KHQpLG49dGhpcy51dGY4Q29udmVydGVyLmNvbnZlcnQocik7cmV0dXJuIG4hPT1yP246dGhpcy53cmFwSW5NYXRoVmFyaWFudChyLHRoaXMuZ2V0TWF0aFZhcmlhbnQodGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzKSl9Z2V0TWF0aFZhcmlhbnQoZSl7aWYoZSYmZS5tYXRodmFyaWFudClyZXR1cm4gZS5tYXRodmFyaWFudH13cmFwSW5NYXRoVmFyaWFudChlLHQpe3N3aXRjaCh0KXtjYXNlXCJib2xkXCI6cmV0dXJuYFxcXFxtYXRoYmZ7JHtlfX1gO2Nhc2VcIml0YWxpY1wiOnJldHVybmBcXFxcbWF0aGl0eyR7ZX19YDtjYXNlXCJib2xkLWl0YWxpY1wiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoaXR7JHtlfX19YDtjYXNlXCJkb3VibGUtc3RydWNrXCI6cmV0dXJuYFxcXFxtYXRoYmJ7JHtlfX1gO2Nhc2VcImJvbGQtZnJha3R1clwiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoZnJha3ske2V9fX1gO2Nhc2VcInNjcmlwdFwiOnJldHVybmBcXFxcbWF0aGNhbHske2V9fWA7Y2FzZVwiYm9sZC1zY3JpcHRcIjpyZXR1cm5gXFxcXG1hdGhiZntcXFxcbWF0aGNhbHske2V9fX1gO2Nhc2VcImZyYWt0dXJcIjpyZXR1cm5gXFxcXG1hdGhmcmFreyR7ZX19YDtjYXNlXCJzYW5zLXNlcmlmXCI6cmV0dXJuYFxcXFxtYXRoc2Z7JHtlfX1gO2Nhc2VcImJvbGQtc2Fucy1zZXJpZlwiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoc2Z7JHtlfX19YDtjYXNlXCJzYW5zLXNlcmlmLWl0YWxpY1wiOnJldHVybmBcXFxcbWF0aHNme1xcXFxtYXRoaXR7JHtlfX19YDtjYXNlXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhzZntcXFxcbWF0aGl0eyR7ZX19fX1gO2Nhc2VcIm1vbm9zcGFjZVwiOnJldHVybmBcXFxcbWF0aHR0eyR7ZX19YDtkZWZhdWx0OnJldHVybiBlfX19O2NsYXNzIGl7Y29uc3RydWN0b3IoZSl7dGhpcy5fdmFsdWU9ZX1zdGF0aWMgYXBwbHkoZSl7cmV0dXJuIG5ldyBpKGUpLl9hcHBseSgpfV9hcHBseSgpe3JldHVybiB0aGlzLl9maW5kQnlDaGFyYWN0ZXIoKXx8dGhpcy5fZmluZEJ5R2x5cGgoKXx8dGhpcy5fZmluZEJ5TnVtYmVyKCl8fChuZXcgby5IYXNoVVRGOFRvTHRYQ29udmVydGVyKS5jb252ZXJ0KHRoaXMuX3ZhbHVlKX1fZmluZEJ5Q2hhcmFjdGVyKCl7cmV0dXJuIG4uYWxsTWF0aFN5bWJvbHNCeUNoYXJbdGhpcy5fdmFsdWVdfV9maW5kQnlHbHlwaCgpe3JldHVybiBuLmFsbE1hdGhTeW1ib2xzQnlHbHlwaFt0aGlzLl92YWx1ZV19X2ZpbmRCeU51bWJlcigpe3JldHVybiBuLm1hdGhOdW1iZXJCeUdseXBoW3RoaXMuX3ZhbHVlXX19fSw4MzAzOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1NdWx0aXNjcmlwdHM9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NTXVsdGlzY3JpcHRzPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZihyPDMpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDMscixcImF0IGxlYXN0XCIpO2NvbnN0IG89KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFswXSkuY29udmVydCgpO3JldHVybiB0aGlzLl9wcmVzY3JpcHRMYXRleCgpK3RoaXMuX3dyYXBJblBhcmVudGhlc2lzSWZUaGVyZUlzU3BhY2UobykrdGhpcy5fcG9zdHNjcmlwdExhdGV4KCl9X3ByZXNjcmlwdExhdGV4KCl7Y29uc3R7Y2hpbGRyZW46ZX09dGhpcy5fbWF0aG1sRWxlbWVudDtsZXQgdCxyO2lmKHRoaXMuX2lzUHJlc2NyaXB0cyhlWzFdKSl0PWVbMl0scj1lWzNdO2Vsc2V7aWYoIXRoaXMuX2lzUHJlc2NyaXB0cyhlWzNdKSlyZXR1cm5cIlwiO3Q9ZVs0XSxyPWVbNV19cmV0dXJuYFxcXFxfeyR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodCkuY29udmVydCgpfX1eeyR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikocikuY29udmVydCgpfX1gfV9wb3N0c2NyaXB0TGF0ZXgoKXtjb25zdHtjaGlsZHJlbjplfT10aGlzLl9tYXRobWxFbGVtZW50O2lmKHRoaXMuX2lzUHJlc2NyaXB0cyhlWzFdKSlyZXR1cm5cIlwiO2NvbnN0IHQ9ZVsxXSxyPWVbMl07cmV0dXJuYF97JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0KS5jb252ZXJ0KCl9fV57JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShyKS5jb252ZXJ0KCl9fWB9X3dyYXBJblBhcmVudGhlc2lzSWZUaGVyZUlzU3BhY2UoZSl7cmV0dXJuIGUubWF0Y2goL1xccysvZyk/KG5ldyBhLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcChlKTplfV9pc1ByZXNjcmlwdHMoZSl7cmV0dXJuXCJtcHJlc2NyaXB0c1wiPT09KG51bGw9PWU/dm9pZCAwOmUubmFtZSl9fX0sNDQ2NDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NTj12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig1NDA2KTt0Lk1OPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT0oMCxhLm5vcm1hbGl6ZVdoaXRlU3BhY2VzKSh0aGlzLl9tYXRobWxFbGVtZW50LnZhbHVlKS50cmltKCk7cmV0dXJuIG4ubWF0aE51bWJlckJ5R2x5cGhbZV18fGV9fX0sMzQ4NzooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NTz12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig1NDA2KTt0Lk1PPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT0oMCxhLm5vcm1hbGl6ZVdoaXRlU3BhY2VzKSh0aGlzLl9tYXRobWxFbGVtZW50LnZhbHVlKS50cmltKCk7cmV0dXJuIG8ub3BlcmF0ZShlKX19O2NsYXNzIG97Y29uc3RydWN0b3IoZSl7dGhpcy5fdmFsdWU9ZX1zdGF0aWMgb3BlcmF0ZShlKXtyZXR1cm4gbmV3IG8oZSkuX29wZXJhdGUoKX1fb3BlcmF0ZSgpe3JldHVybiB0aGlzLl9maW5kQnlDaGFyYWN0ZXIoKXx8dGhpcy5fZmluZEJ5R2x5cGgoKXx8dGhpcy5fZmluZEJ5TnVtYmVyKCl8fChuZXcgbi5IYXNoVVRGOFRvTHRYQ29udmVydGVyKS5jb252ZXJ0KHRoaXMuX3ZhbHVlKX1fZmluZEJ5Q2hhcmFjdGVyKCl7cmV0dXJuIG4uYWxsTWF0aE9wZXJhdG9yc0J5Q2hhclt0aGlzLl92YWx1ZV19X2ZpbmRCeUdseXBoKCl7cmV0dXJuIG4uYWxsTWF0aE9wZXJhdG9yc0J5R2x5cGhbdGhpcy5fdmFsdWVdfV9maW5kQnlOdW1iZXIoKXtyZXR1cm4gbi5tYXRoTnVtYmVyQnlHbHlwaFt0aGlzLl92YWx1ZV19fX0sNzQ0MzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVBoYW50b209dm9pZCAwLHQuTVBoYW50b209Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5cIlwifX19LDYwNTI6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVJvb3Q9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NUm9vdD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMiE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDIscik7Y29uc3Qgbz0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzBdKS5jb252ZXJ0KCk7cmV0dXJuYFxcXFxzcXJ0WyR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFsxXSkuY29udmVydCgpfV17JHtvfX1gfX19LDg2ODY6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVNxcnQ9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0Lk1TcXJ0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuYFxcXFxzcXJ0eyR7dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpfX1gfX19LDI1NjQ6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVN1Yj12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig4OTE3KTt0Lk1TdWI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtuYW1lOmUsY2hpbGRyZW46dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPXQubGVuZ3RoO2lmKDIhPT1yKXRocm93IG5ldyBuLkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3IoZSwyLHIpO2NvbnN0IGE9dFswXSxvPXRbMV07cmV0dXJuYCR7dGhpcy5faGFuZGxlQmFzZUNoaWxkKGEpfV8ke3RoaXMuX2hhbmRsZVN1YnNjcmlwdENoaWxkKG8pfWB9X2hhbmRsZUJhc2VDaGlsZChlKXtjb25zdCB0PWUuY2hpbGRyZW4scj0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKS5jb252ZXJ0KCk7cmV0dXJuIHQubGVuZ3RoPD0xP3I6KG5ldyBhLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcElmTW9yZVRoYW5PbmVDaGFyKHIpfV9oYW5kbGVTdWJzY3JpcHRDaGlsZChlKXtjb25zdCB0PSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4obmV3IGEuQnJhY2tldFdyYXBwZXIpLndyYXAodCl9fX0sMTM1ODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3Vic3VwPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVN1YnN1cD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMyE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDMscik7Y29uc3QgYT10WzBdLG89dFsxXSxpPXRbMl07cmV0dXJuYCR7dGhpcy5faGFuZGxlQmFzZUNoaWxkKGEpfV8ke3RoaXMuX2hhbmRsZVN1YnNjcmlwdENoaWxkKG8pfV4ke3RoaXMuX2hhbmRsZVN1cGVyc2NyaXB0Q2hpbGQoaSl9YH1faGFuZGxlQmFzZUNoaWxkKGUpe2NvbnN0IHQ9ZS5jaGlsZHJlbixyPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4gdC5sZW5ndGg8PTE/cjoobmV3IGEuUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwSWZNb3JlVGhhbk9uZUNoYXIocil9X2hhbmRsZVN1YnNjcmlwdENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX1faGFuZGxlU3VwZXJzY3JpcHRDaGlsZChlKXtjb25zdCB0PSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4obmV3IGEuQnJhY2tldFdyYXBwZXIpLndyYXAodCl9fX0sNjkyNjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3VwPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVN1cD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMiE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDIscik7Y29uc3QgYT10WzBdLG89dFsxXTtyZXR1cm5gJHt0aGlzLl9oYW5kbGVCYXNlQ2hpbGQoYSl9XiR7dGhpcy5faGFuZGxlRXhwb25lbnRDaGlsZChvKX1gfV9oYW5kbGVCYXNlQ2hpbGQoZSl7Y29uc3QgdD1lLmNoaWxkcmVuLHI9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybiB0Lmxlbmd0aDw9MT9yOihuZXcgYS5QYXJlbnRoZXNpc1dyYXBwZXIpLndyYXBJZk1vcmVUaGFuT25lQ2hhcihyKX1faGFuZGxlRXhwb25lbnRDaGlsZChlKXtjb25zdCB0PSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4obmV3IGEuQnJhY2tldFdyYXBwZXIpLndyYXAodCl9fX0sMjM1MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVGFibGU9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0Lk1UYWJsZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWUsdGhpcy5fYWRkRmxhZ1JlY3Vyc2l2ZUlmTmFtZSh0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLFwibXRhYmxlXCIsXCJpbm5lclRhYmxlXCIpfWNvbnZlcnQoKXtjb25zdCBlPXRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFxcXFxcXFxcXFxuXCIpO3JldHVybiB0aGlzLl9oYXNGbGFnKFwiaW5uZXJUYWJsZVwiKT90aGlzLl93cmFwKGUpOmV9X3dyYXAoZSl7cmV0dXJuYFxcXFxiZWdpbnttYXRyaXh9JHtlfVxcXFxlbmR7bWF0cml4fWB9X2FkZEZsYWdSZWN1cnNpdmVJZk5hbWUoZSx0LHIpe2UuZm9yRWFjaCgoZT0+e2UubmFtZT09PXQmJihlLmF0dHJpYnV0ZXNbcl09ciksdGhpcy5fYWRkRmxhZ1JlY3Vyc2l2ZUlmTmFtZShlLmNoaWxkcmVuLHQscil9KSl9X2hhc0ZsYWcoZSl7cmV0dXJuISF0aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXNbZV19fX0sMzk1MTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVGV4dD12b2lkIDA7Y29uc3QgYT1yKDcwMzcpO3QuTVRleHQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHthdHRyaWJ1dGVzOmUsdmFsdWU6dH09dGhpcy5fbWF0aG1sRWxlbWVudDtyZXR1cm5bLi4udF0ubWFwKChlPT4vXlthLXpBLVowLTldJC8udGVzdChlKXx8XCIgXCI9PT1lP3t2YWx1ZTplLGlzQWxwaGFudW1lcmljOiEwfTp7dmFsdWU6ZSxpc0FscGhhbnVtZXJpYzohMX0pKS5yZWR1Y2UoKChlLHQpPT57aWYodC5pc0FscGhhbnVtZXJpYyl7Y29uc3Qgcj1lW2UubGVuZ3RoLTFdO2lmKHImJnIuaXNBbHBoYW51bWVyaWMpcmV0dXJuIHIudmFsdWUrPXQudmFsdWUsZX1yZXR1cm5bLi4uZSx0XX0pLFtdKS5tYXAoKHQ9PnQuaXNBbHBoYW51bWVyaWM/bmV3IG4oZS5tYXRodmFyaWFudCkuYXBwbHkodC52YWx1ZSk6bmV3IGEuTUkoe25hbWU6XCJtaVwiLGF0dHJpYnV0ZXM6e30sY2hpbGRyZW46W10sdmFsdWU6dC52YWx1ZX0pLmNvbnZlcnQoKSkpLmpvaW4oXCJcIil9fTtjbGFzcyBue2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGh2YXJpYW50PWV8fFwibm9ybWFsXCJ9YXBwbHkoZSl7cmV0dXJuIHRoaXMuX2NvbW1hbmRzLnJlZHVjZSgoKHQscixhKT0+MD09PWE/YCR7cn17JHtlfX1gOmAke3J9eyR7dH19YCksXCJcIil9Z2V0IF9jb21tYW5kcygpe3N3aXRjaCh0aGlzLl9tYXRodmFyaWFudCl7Y2FzZVwiYm9sZFwiOnJldHVybltcIlxcXFx0ZXh0YmZcIl07Y2FzZVwiaXRhbGljXCI6cmV0dXJuW1wiXFxcXHRleHRpdFwiXTtjYXNlXCJib2xkLWl0YWxpY1wiOnJldHVybltcIlxcXFx0ZXh0aXRcIixcIlxcXFx0ZXh0YmZcIl07Y2FzZVwiZG91YmxlLXN0cnVja1wiOnJldHVybltcIlxcXFxtYXRoYmJcIl07Y2FzZVwibW9ub3NwYWNlXCI6cmV0dXJuW1wiXFxcXG1hdGh0dFwiXTtjYXNlXCJib2xkLWZyYWt0dXJcIjpjYXNlXCJmcmFrdHVyXCI6cmV0dXJuW1wiXFxcXG1hdGhmcmFrXCJdO2RlZmF1bHQ6cmV0dXJuW1wiXFxcXHRleHRcIl19fX19LDE1ODY6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVRyPXZvaWQgMDtjb25zdCBhPXIoNDI3OSk7dC5NVHI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm4gdGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgJiBcIil9fX0sMTIyMjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVW5kZXJvdmVyPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVVuZGVyb3Zlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMyE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDMscik7cmV0dXJuYCR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFswXSkuY29udmVydCgpfV97JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzFdKS5jb252ZXJ0KCl9fV57JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzJdKS5jb252ZXJ0KCl9fWB9fX0sOTE2NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVm9pZD12b2lkIDAsdC5Wb2lkPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuXCJcIn19fSw1NDQzOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCIhPT1yJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmYSh0LGUscik7cmV0dXJuIG4odCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1hdGhNTEVsZW1lbnRUb0xhdGV4Q29udmVydGVyQWRhcHRlcj12b2lkIDA7Y29uc3QgaT1vKHIoNjk1OSkpLHM9cigyNjk3KTt0Lk1hdGhNTEVsZW1lbnRUb0xhdGV4Q29udmVydGVyQWRhcHRlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRoTUxFbGVtZW50PW51bGwhPWU/ZTpuZXcgcy5Wb2lkTWF0aE1MRWxlbWVudH10b0xhdGV4Q29udmVydGVyKCl7Y29uc3R7bmFtZTplfT10aGlzLl9tYXRoTUxFbGVtZW50O3JldHVybiBuZXcobFtlXXx8aS5HZW5lcmljU3BhY2luZ1dyYXBwZXIpKHRoaXMuX21hdGhNTEVsZW1lbnQpfX07Y29uc3QgbD17bWF0aDppLk1hdGgsbWk6aS5NSSxtbzppLk1PLG1uOmkuTU4sbXNxcnQ6aS5NU3FydCxtZmVuY2VkOmkuTUZlbmNlZCxtZnJhYzppLk1GcmFjLG1yb290OmkuTVJvb3QsbWFjdGlvbjppLk1BY3Rpb24sbWVuY2xvc2U6aS5NRW5jbG9zZSxtZXJyb3I6aS5NRXJyb3IsbXBoYW50b206aS5NUGhhbnRvbSxtc3VwOmkuTVN1cCxtc3ViOmkuTVN1Yixtc3Vic3VwOmkuTVN1YnN1cCxtbXVsdGlzY3JpcHRzOmkuTU11bHRpc2NyaXB0cyxtdGV4dDppLk1UZXh0LG11bmRlcm92ZXI6aS5NVW5kZXJvdmVyLG10YWJsZTppLk1UYWJsZSxtdHI6aS5NVHIsbW92ZXI6aS5HZW5lcmljVW5kZXJPdmVyLG11bmRlcjppLkdlbmVyaWNVbmRlck92ZXIsbXJvdzppLkdlbmVyaWNTcGFjaW5nV3JhcHBlcixtcGFkZGVkOmkuR2VuZXJpY1NwYWNpbmdXcmFwcGVyLHZvaWQ6aS5Wb2lkfX0sNTI0MzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRXJyb3JIYW5kbGVyPXZvaWQgMCx0LkVycm9ySGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX2Vycm9ycz1bXSx0aGlzLmVycm9yTG9jYXRvcj17fX1maXhFcnJvcihlLHQpe3JldHVybiB0aGlzLl9pc01pc3NpbmdBdHRyaWJ1dGVWYWx1ZUVycm9yKHQpPyh0aGlzLl9lcnJvcnMucHVzaCh0KSx0aGlzLl9maXhNaXNzaW5nQXR0cmlidXRlKHQsZSkpOmV9aXNUaGVyZUFueUVycm9ycygpe3JldHVybiB0aGlzLl9lcnJvcnMubGVuZ3RoPjB9Y2xlYW5FcnJvcnMoKXt0aGlzLl9lcnJvcnM9W119X2ZpeE1pc3NpbmdBdHRyaWJ1dGUoZSx0KXtjb25zdCByPWUuc3BsaXQoJ1wiJylbMV07aWYocilyZXR1cm4gdC5yZXBsYWNlKHRoaXMuX21hdGNoTWlzc2luZ1ZhbHVlRm9yQXR0cmlidXRlKHIpLFwiXCIpO2Zvcig7dGhpcy5fbWF0aEdlbmVyaWNNaXNzaW5nVmFsdWUoKS5leGVjKHQpOyl0PXQucmVwbGFjZSh0aGlzLl9tYXRoR2VuZXJpY01pc3NpbmdWYWx1ZSgpLFwiJDEkM1wiKTtyZXR1cm4gdH1fbWF0Y2hNaXNzaW5nVmFsdWVGb3JBdHRyaWJ1dGUoZSl7cmV0dXJuIG5ldyBSZWdFeHAoYCgke2V9PSg/IShcInwnKSkpfCgke2V9KD8hKFwifCcpKSlgLFwiZ21cIil9X21hdGhHZW5lcmljTWlzc2luZ1ZhbHVlKCl7cmV0dXJuLyhcXDwuKiApKFxcdys9KD8hXFxcInxcXCcpKSguKlxcPikvZ219X2lzTWlzc2luZ0F0dHJpYnV0ZVZhbHVlRXJyb3IoZSl7cmV0dXJuISFlLmluY2x1ZGVzKFwiYXR0cmlidXRlXCIpJiYhIWUuaW5jbHVkZXMoXCJtaXNzZWRcIil8fGUuaW5jbHVkZXMoXCJhdHRyaWJ1dGUgdmFsdWUgbWlzc2VkXCIpfX19LDkyMDg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDk1NDgpLHQpLG4ocig1MjQzKSx0KSxuKHIoMTEwMSksdCl9LDExMDE6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkVsZW1lbnRzVG9NYXRoTUxBZGFwdGVyPXZvaWQgMCx0LkVsZW1lbnRzVG9NYXRoTUxBZGFwdGVyPWNsYXNze2NvbnZlcnQoZSl7cmV0dXJuIGUuZmlsdGVyKChlPT52b2lkIDAhPT1lLnRhZ05hbWUpKS5tYXAoKGU9PnRoaXMuX2NvbnZlcnRFbGVtZW50KGUpKSl9X2NvbnZlcnRFbGVtZW50KGUpe3JldHVybntuYW1lOmUudGFnTmFtZSxhdHRyaWJ1dGVzOnRoaXMuX2NvbnZlcnRFbGVtZW50QXR0cmlidXRlcyhlLmF0dHJpYnV0ZXMpLHZhbHVlOnRoaXMuX2hhc0VsZW1lbnRDaGlsZChlKT9cIlwiOmUudGV4dENvbnRlbnR8fFwiXCIsY2hpbGRyZW46dGhpcy5faGFzRWxlbWVudENoaWxkKGUpP3RoaXMuY29udmVydChBcnJheS5mcm9tKGUuY2hpbGROb2RlcykpOltdfX1fY29udmVydEVsZW1lbnRBdHRyaWJ1dGVzKGUpe3JldHVybiBBcnJheS5mcm9tKGUpLnJlZHVjZSgoKGUsdCk9Pk9iamVjdC5hc3NpZ24oe1t0Lm5vZGVOYW1lXTp0Lm5vZGVWYWx1ZT09PXQubm9kZU5hbWU/XCJcIjp0Lm5vZGVWYWx1ZX0sZSkpLHt9KX1faGFzRWxlbWVudENoaWxkKGUpe2NvbnN0IHQ9ZS5jaGlsZE5vZGVzO3JldHVybiEhdCYmMCE9PXQubGVuZ3RoJiZ0aGlzLl9pc1RoZXJlQW55Tm9UZXh0Tm9kZSh0KX1faXNUaGVyZUFueU5vVGV4dE5vZGUoZSl7cmV0dXJuIEFycmF5LmZyb20oZSkuc29tZSgoZT0+XCIjdGV4dFwiIT09ZS5ub2RlTmFtZSkpfX19LDk1NDg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuWG1sVG9NYXRoTUxBZGFwdGVyPXZvaWQgMDtjb25zdCBuPWEocig4OTc4KSk7dC5YbWxUb01hdGhNTEFkYXB0ZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl94bWw9XCJcIix0aGlzLl9lbGVtZW50c0NvbnZlcnRvcj1lLHRoaXMuX2Vycm9ySGFuZGxlcj10LHRoaXMuX3htbERPTT1uZXcgbi5kZWZhdWx0LkRPTVBhcnNlcih7bG9jYXRvcjp0aGlzLl9lcnJvckhhbmRsZXIuZXJyb3JMb2NhdG9yLGVycm9ySGFuZGxlcjp0aGlzLl9maXhFcnJvci5iaW5kKHRoaXMpfSl9Y29udmVydChlKXtyZXR1cm4gdGhpcy5feG1sPXRoaXMuX3JlbW92ZUxpbmVCcmVha3MoZSksdGhpcy5feG1sPXRoaXMuX3JlbW92ZU1zV29yZFByZWZpeGVzKHRoaXMuX3htbCksdGhpcy5fZWxlbWVudHNDb252ZXJ0b3IuY29udmVydCh0aGlzLl9tYXRoTUxFbGVtZW50cyl9X2ZpeEVycm9yKGUpe3RoaXMuX3htbD10aGlzLl9lcnJvckhhbmRsZXIuZml4RXJyb3IodGhpcy5feG1sLGUpfV9yZW1vdmVMaW5lQnJlYWtzKGUpe3JldHVybiBlLnJlcGxhY2UoL1xcbnxcXHJcXG58XFxyL2csXCJcIil9X3JlbW92ZU1zV29yZFByZWZpeGVzKGUpe3JldHVybiBlLnJlcGxhY2UoL21tbDovZyxcIlwiKX1nZXQgX21hdGhNTEVsZW1lbnRzKCl7bGV0IGU9dGhpcy5feG1sRE9NLnBhcnNlRnJvbVN0cmluZyh0aGlzLl94bWwpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibWF0aFwiKTtyZXR1cm4gdGhpcy5fZXJyb3JIYW5kbGVyLmlzVGhlcmVBbnlFcnJvcnMoKSYmKHRoaXMuX2Vycm9ySGFuZGxlci5jbGVhbkVycm9ycygpLGU9dGhpcy5feG1sRE9NLnBhcnNlRnJvbVN0cmluZyh0aGlzLl94bWwpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibWF0aFwiKSksQXJyYXkuZnJvbShlKX19fSw3OTQxOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocig4NTg1KSx0KX0sODU4NTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tYWtlVG9NYXRoRWxlbWVudHNDb252ZXJ0ZXI9dm9pZCAwO2NvbnN0IGE9cig5MjA4KTt0Lm1ha2VUb01hdGhFbGVtZW50c0NvbnZlcnRlcj0oKT0+e2NvbnN0IGU9bmV3IGEuRWxlbWVudHNUb01hdGhNTEFkYXB0ZXIsdD1uZXcgYS5FcnJvckhhbmRsZXI7cmV0dXJuIG5ldyBhLlhtbFRvTWF0aE1MQWRhcHRlcihlLHQpfX0sODY3MjpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpO3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtuJiYhKFwiZ2V0XCJpbiBuPyF0Ll9fZXNNb2R1bGU6bi53cml0YWJsZXx8bi5jb25maWd1cmFibGUpfHwobj17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLG4pfTpmdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKSxlW2FdPXRbcl19KSxuPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiBlKVwiZGVmYXVsdFwiPT09cnx8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscil8fGEodCxlLHIpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuKHIoMzc5OCksdCl9LDM3OTg6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTWF0aE1MVG9MYVRlWD12b2lkIDA7Y29uc3QgYT1yKDU0NDMpLG49cig3OTQxKTt0Lk1hdGhNTFRvTGFUZVg9Y2xhc3N7c3RhdGljIGNvbnZlcnQoZSl7cmV0dXJuKDAsbi5tYWtlVG9NYXRoRWxlbWVudHNDb252ZXJ0ZXIpKCkuY29udmVydChlKS5tYXAoKGU9Pm5ldyBhLk1hdGhNTEVsZW1lbnRUb0xhdGV4Q29udmVydGVyQWRhcHRlcihlKS50b0xhdGV4Q29udmVydGVyKCkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIlwiKS50cmltKCl9fX0sMjk2NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYWxsTWF0aE9wZXJhdG9yc0J5Q2hhcj12b2lkIDAsdC5hbGxNYXRoT3BlcmF0b3JzQnlDaGFyPXtfOlwiXFxcXHVuZGVybGluZVwiLFwiJiN4MjNFMTtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0UwO1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjNERjtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0RFO1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjNERDtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0RDO1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjNCNTtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0I0O1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjBEQztcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIwREI7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyMDY0O1wiOlwiXCIsXCImI3gyMDU3O1wiOlwiJycnJ1wiLFwiJiN4MjAzRTtcIjpcIlxcXFxiYXJcIixcIiYjeDIwMzc7XCI6XCJgYGBcIixcIiYjeDIwMzY7XCI6XCJgYFwiLFwiJiN4MjAzNTtcIjpcImBcIixcIiYjeDIwMzQ7XCI6XCInJydcIixcIiYjeDIwMzM7XCI6XCInJ1wiLFwiJiN4MjAxRjtcIjpcImBgXCIsXCImI3gyMDFFO1wiOlwiLCxcIixcIiYjeDIwMUI7XCI6XCJgXCIsXCImI3gyMDFBO1wiOlwiLFwiLFwiJiN4MzAyO1wiOlwiXFxcXGhhdFwiLFwiJiN4MkY3O1wiOlwiXFxcXHNpbVwiLFwiJiN4MkREO1wiOlwiXFxcXHNpbVwiLFwiJiN4MkRDO1wiOlwiXFxcXHNpbVwiLFwiJiN4MkRBO1wiOlwiXFxcXGNpcmNcIixcIiYjeDJEOTtcIjpcIlxcXFxjZG90XCIsXCImI3gyRDg7XCI6XCJcIixcIiYjeDJDRDtcIjpcIlxcXFxfXCIsXCImI3gyQ0I7XCI6XCLLi1wiLFwiJiN4MkNBO1wiOlwiy4pcIixcIiYjeDJDOTtcIjpcIsuJXCIsXCImI3gyQzc7XCI6XCJcIixcIiYjeDJDNjtcIjpcIlxcXFxoYXRcIixcIiYjeEJBO1wiOlwib1wiLFwiJiN4Qjk7XCI6XCIxXCIsXCImI3hCODtcIjpcIsK4XCIsXCImI3hCNDtcIjpcIsK0XCIsXCImI3hCMztcIjpcIjNcIixcIiYjeEIyO1wiOlwiMlwiLFwiJiN4QjA7XCI6XCJcXFxcY2lyY1wiLFwiJiN4QUY7XCI6XCJcXFxcYmFyXCIsXCImI3hBQTtcIjpcImFcIixcIiYjeEE4O1wiOlwiXFxcXGNkb3RcXFxcY2RvdFwiLFwiflwiOlwiXFxcXHNpbVwiLFwiYFwiOlwiYFwiLFwiXlwiOlwiXFxcXGhhdFwiLFwiLS1cIjpcIi0tXCIsXCIrK1wiOlwiKytcIixcIiZhbXA7XCI6XCJcXFxcJlwiLFwiJiN4MjA2MTtcIjpcIlwiLFwiJiN4MjIxQztcIjpcIlxcXFxzcXJ0WzRde31cIixcIiYjeDIyMUI7XCI6XCJcXFxcc3FydFszXXt9XCIsXCImI3gyMjFBO1wiOlwiXFxcXHNxcnR7fVwiLFwiJiN4MjE0NjtcIjpcImRcIixcIiYjeDIxNDU7XCI6XCJcXFxcbWF0aGJie0R9XCIsXCI/XCI6XCI/XCIsXCJAXCI6XCJAXCIsXCIvL1wiOlwiLy9cIixcIiEhXCI6XCIhIVwiLFwiIVwiOlwiIVwiLFwiJiN4MjY2RjtcIjpcIlxcXFwjXCIsXCImI3gyNjZFO1wiOlwiXCIsXCImI3gyNjZEO1wiOlwiXCIsXCImI3gyMDMyO1wiOlwiJ1wiLFwiJmx0Oz5cIjpcIjw+XCIsXCIqKlwiOlwiXFxcXHN0YXJcXFxcc3RhclwiLFwiJiN4MjIwNztcIjpcIlxcXFxuYWJsYVwiLFwiJiN4MjIwMjtcIjpcIlxcXFxwYXJ0aWFsXCIsXCImI3gyMjk5O1wiOlwiXFxcXGJpZ29kb3RcIixcIiYjeEFDO1wiOlwiXFxcXG5lZ1wiLFwiJiN4MjIyMjtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCImI3gyMjIxO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDIyMjA7XCI6XCJcXFxcYW5nbGVcIixcIiYjeEY3O1wiOlwiXFxcXGRpdlwiLFwiL1wiOlwiL1wiLFwiJiN4MjIxNjtcIjpcIlxcXFxiYWNrc2xhc2hcIixcIlxcXFxcIjpcIlxcXFxiYWNrc2xhc2hcIixcIiVcIjpcIlxcXFwlXCIsXCImI3gyMjk3O1wiOlwiXFxcXGJpZ290aW1lc1wiLFwiJiN4Qjc7XCI6XCJcXFxcY2RvdFwiLFwiJiN4MkEzRjtcIjpcIlxcXFxjb3Byb2RcIixcIiYjeDJBMkY7XCI6XCJcXFxcdGltZXNcIixcIiYjeDIyQzU7XCI6XCJcXFxcY2RvdFwiLFwiJiN4MjJBMTtcIjpcIlxcXFxib3hkb3RcIixcIiYjeDIyQTA7XCI6XCJcXFxcYm94dGltZXNcIixcIiYjeDIwNjI7XCI6XCJcIixcIiYjeDIwNDM7XCI6XCItXCIsXCImI3gyMDIyO1wiOlwiXFxcXGNkb3RcIixcIiYjeEQ3O1wiOlwiXFxcXHRpbWVzXCIsXCIuXCI6XCIuXCIsXCIqXCI6XCJcXFxcc3RhclwiLFwiJiN4MjIyQTtcIjpcIlxcXFxjdXBcIixcIiYjeDIyMjk7XCI6XCJcXFxcY2FwXCIsXCImI3gyMjEwO1wiOlwiXFxcXGNvcHJvZFwiLFwiJiN4MjIwRjtcIjpcIlxcXFxwcm9kXCIsXCImI3gyMjQwO1wiOlwiXCIsXCImI3gyQUZGO1wiOlwiXCIsXCImI3gyQUZDO1wiOlwiXFxcXG1pZFxcXFxtaWRcXFxcbWlkXCIsXCImI3gyQTA5O1wiOlwiXFxcXHRpbWVzXCIsXCImI3gyQTA4O1wiOlwiXCIsXCImI3gyQTA3O1wiOlwiXCIsXCImI3gyQTA2O1wiOlwiXFxcXHNxY3VwXCIsXCImI3gyQTA1O1wiOlwiXFxcXHNxY2FwXCIsXCImI3gyQTAyO1wiOlwiXFxcXG90aW1lc1wiLFwiJiN4MkEwMDtcIjpcIlxcXFxvZG90XCIsXCImI3gyMkMyO1wiOlwiXFxcXGNhcFwiLFwiJiN4MjJDMTtcIjpcIlxcXFx2ZWVcIixcIiYjeDIyQzA7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDJBMDQ7XCI6XCJcXFxcdXBsdXNcIixcIiYjeDJBMDM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMkMzO1wiOlwiXFxcXGN1cFwiLFwiJiN4MkExQztcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGludH1cIixcIiYjeDJBMUI7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGludH1cIixcIiYjeDJBMUE7XCI6XCJcXFxcaW50XCIsXCImI3gyQTE5O1wiOlwiXFxcXGludFwiLFwiJiN4MkExODtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTc7XCI6XCJcXFxcaW50XCIsXCImI3gyQTE2O1wiOlwiXFxcXG9pbnRcIixcIiYjeDJBMTU7XCI6XCJcXFxcb2ludFwiLFwiJiN4MkExNDtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTM7XCI6XCJcXFxcaW50XCIsXCImI3gyQTEyO1wiOlwiXFxcXGludFwiLFwiJiN4MkExMTtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTA7XCI6XCJcXFxcaW50XCIsXCImI3gyQTBGO1wiOlwiXFxcXGJjYW5jZWx7XFxcXGludH1cIixcIiYjeDJBMEU7XCI6XCJcIixcIiYjeDJBMEQ7XCI6XCJcXFxcaGNhbmNlbHtcXFxcaW50fVwiLFwiJiN4MkEwQztcIjpcIlxcXFxpaWlpbnRcIixcIiYjeDIyMzM7XCI6XCJcXFxcb2ludFwiLFwiJiN4MjIzMjtcIjpcIlxcXFxvaW50XCIsXCImI3gyMjMxO1wiOlwiXFxcXGludFwiLFwiJiN4MjIzMDtcIjpcIlxcXFxvaWludFwiLFwiJiN4MjIyRjtcIjpcIlxcXFxvaWludFwiLFwiJiN4MjIyRTtcIjpcIlxcXFxvaW50XCIsXCImI3gyMjJCO1wiOlwiXFxcXGludFwiLFwiJiN4MkEwMTtcIjpcIlxcXFxvcGx1c1wiLFwiJiN4MjI5ODtcIjpcIlxcXFxvc2xhc2hcIixcIiYjeDIyOTY7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyMjk1O1wiOlwiXFxcXG9wbHVzXCIsXCImI3gyMjJEO1wiOlwiXFxcXGlpaW50XCIsXCImI3gyMjJDO1wiOlwiXFxcXGlpbnRcIixcIiYjeDJBMEI7XCI6XCJcIixcIiYjeDJBMEE7XCI6XCJcIixcIiYjeDIyMTE7XCI6XCJcXFxcc3VtXCIsXCImI3gyMjlGO1wiOlwiXFxcXGJveG1pbnVzXCIsXCImI3gyMjlFO1wiOlwiXFxcXGJveHBsdXNcIixcIiYjeDIyMTQ7XCI6XCJcXFxcZG90eyt9XCIsXCImI3gyMjEzO1wiOlwiKy1cIixcIiYjeDIyMTI7XCI6XCItXCIsXCImI3hCMTtcIjpcIlxcXFxwbVwiLFwiLVwiOlwiLVwiLFwiK1wiOlwiK1wiLFwiJiN4MkI0NjtcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwiJiN4MkI0NTtcIjpcIlxcXFxMbGVmdGFycm93XCIsXCImI3gyOUY0O1wiOlwiOlxcXFxyaWdodGFycm93XCIsXCImI3gyOUVGO1wiOlwiXCIsXCImI3gyOURGO1wiOlwiXFxcXGJ1bGxldC1cXFxcYnVsbGV0XCIsXCImI3gyOTlGO1wiOlwiXFxcXGFuZ2xlXCIsXCImI3gyOTlFO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDI5OUQ7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4Mjk5QztcIjpcIlxcXFxwZXJwXCIsXCImI3gyOTlCO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDI5OUE7XCI6XCJcIixcIiYjeDI5OTk7XCI6XCJcXFxcdmRvdHNcIixcIiYjeDI5N0Y7XCI6XCJcIixcIiYjeDI5N0U7XCI6XCJcIixcIiYjeDI5N0Q7XCI6XCJcXFxccHJlY1wiLFwiJiN4Mjk3QztcIjpcIlxcXFxzdWNjXCIsXCImI3gyOTdCO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vwc2V0fVwiLFwiJiN4Mjk3QTtcIjpcIlwiLFwiJiN4Mjk3OTtcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317XFxcXHN1YnNldH1cIixcIiYjeDI5Nzg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHJpZ2h0YXJyb3d9ez59XCIsXCImI3gyOTc3O1wiOlwiXCIsXCImI3gyOTc2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxsZWZ0YXJyb3d9ezx9XCIsXCImI3gyOTc1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3NDtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5NzM7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXGxlZnRhcnJvd31cIixcIiYjeDI5NzI7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5NzE7XCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5NzA7XCI6XCJcIixcIiYjeDI5NkY7XCI6XCJcIixcIiYjeDI5NkU7XCI6XCJcIixcIiYjeDI5NkQ7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHJpZ2h0aGFycG9vbmRvd259XCIsXCImI3gyOTZDO1wiOlwiXFxcXHVuZGVybGluZXtcXFxccmlnaHRoYXJwb29udXB9XCIsXCImI3gyOTZCO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxsZWZ0aGFycG9vbmRvd259XCIsXCImI3gyOTZBO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbGVmdGhhcnBvb251cH1cIixcIiYjeDI5Njk7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5Njg7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5Njc7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5NjY7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5NjU7XCI6XCJcXFxcRG93bmFycm93XCIsXCImI3gyOTY0O1wiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIiYjeDI5NjM7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4Mjk2MjtcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIiYjeDI5NjE7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTYwO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NUY7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1RTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NUQ7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTVDO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NUI7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1QTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NTk7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTU4O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NTc7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1NjtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NTU7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTU0O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NTM7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1MjtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NTE7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NTA7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NEY7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NEU7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NEQ7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NEM7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NEI7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NEE7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NDk7XCI6XCJcIixcIiYjeDI5NDg7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NDc7XCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIiYjeDI5NDY7XCI6XCJcIixcIiYjeDI5NDU7XCI6XCJcIixcIiYjeDI5NDQ7XCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCImI3gyOTQzO1wiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwiJiN4Mjk0MjtcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIiYjeDI5NDE7XCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLFwiJiN4Mjk0MDtcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIiYjeDI5M0Y7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkzRTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5M0Q7XCI6XCJcIixcIiYjeDI5M0M7XCI6XCJcIixcIiYjeDI5M0I7XCI6XCJcIixcIiYjeDI5M0E7XCI6XCJcIixcIiYjeDI5Mzk7XCI6XCJcIixcIiYjeDI5Mzg7XCI6XCJcIixcIiYjeDI5Mzc7XCI6XCJcXFxcUnNoXCIsXCImI3gyOTM2O1wiOlwiXFxcXExzaFwiLFwiJiN4MjkzNTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5MzQ7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjkzMztcIjpcIlxcXFxsZWFkc3RvXCIsXCImI3gyOTMyO1wiOlwiXCIsXCImI3gyOTMxO1wiOlwiXCIsXCImI3gyOTMwO1wiOlwiXCIsXCImI3gyOTJGO1wiOlwiXCIsXCImI3gyOTJFO1wiOlwiXCIsXCImI3gyOTJEO1wiOlwiXCIsXCImI3gyOTJDO1wiOlwiXFxcXHRpbWVzXCIsXCImI3gyOTJCO1wiOlwiXFxcXHRpbWVzXCIsXCImI3gyOTJBO1wiOlwiXCIsXCImI3gyOTI5O1wiOlwiXCIsXCImI3gyOTI4O1wiOlwiXCIsXCImI3gyOTI3O1wiOlwiXCIsXCImI3gyOTI2O1wiOlwiXCIsXCImI3gyOTI1O1wiOlwiXCIsXCImI3gyOTI0O1wiOlwiXCIsXCImI3gyOTIzO1wiOlwiXCIsXCImI3gyOTIyO1wiOlwiXCIsXCImI3gyOTIxO1wiOlwiXCIsXCImI3gyOTIwO1wiOlwiXFxcXG1hcHN0b1xcXFxjZG90XCIsXCImI3gyOTFGO1wiOlwiXFxcXGNkb3RcXFxcbGVmdGFycm93XCIsXCImI3gyOTFFO1wiOlwiXFxcXHJpZ2h0YXJyb3dcXFxcY2RvdFwiLFwiJiN4MjkxRDtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MUM7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxQjtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MUE7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxOTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MTg7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxNztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE2O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTU7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxNDtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTEzO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjkxMjtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyOTExO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTA7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkwRjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTBFO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkwRDtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTBDO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkwQjtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDI5MEE7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjkwOTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyOTA4O1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjkwNztcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyOTA2O1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjkwNTtcIjpcIlxcXFxtYXBzdG9cIixcIiYjeDI5MDQ7XCI6XCJcXFxcbkxlZnRyaWdodGFycm93XCIsXCImI3gyOTAzO1wiOlwiXFxcXG5SaWdodGFycm93XCIsXCImI3gyOTAyO1wiOlwiXFxcXG5MZWZ0YXJyb3dcIixcIiYjeDI5MDE7XCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCImI3gyOTAwO1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjdGRjtcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIiYjeDI3RkU7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4MjdGRDtcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIiYjeDI3RkM7XCI6XCJcXFxcbWFwc3RvXCIsXCImI3gyN0ZCO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjdGQTtcIjpcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI3Rjk7XCI6XCJcXFxcTG9uZ3JpZ2h0YXJyb3dcIixcIiYjeDI3Rjg7XCI6XCJcXFxcTG9uZ2xlZnRhcnJvd1wiLFwiJiN4MjdGNztcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjdGNjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyN0Y1O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjdGMTtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDI3RjA7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjJCODtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMUZGO1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCImI3gyMUZFO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRkQ7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMUZDO1wiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFGQjtcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiJiN4MjFGQTtcIjpcIlxcXFxubGVmdGFycm93XCIsXCImI3gyMUY5O1wiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFGODtcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiJiN4MjFGNztcIjpcIlxcXFxubGVmdGFycm93XCIsXCImI3gyMUY2O1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCImI3gyMUY1O1wiOlwiXCIsXCImI3gyMUY0O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRjM7XCI6XCJcXFxcVXBkb3duYXJyb3dcIixcIiYjeDIxRjI7XCI6XCJcXFxcc2VhcnJvd1wiLFwiJiN4MjFGMTtcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMUYwO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjFFRjtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUVFO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUQ7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFQztcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUVCO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUE7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFOTtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDIxRTg7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4MjFFNztcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUU2O1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjFFNTtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMUU0O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjFFMztcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDIxRTI7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjFFMTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMUUwO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjFERjtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDIxREU7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjFERDtcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIiYjeDIxREM7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMURCO1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCImI3gyMURBO1wiOlwiXFxcXExsZWZ0YXJyb3dcIixcIiYjeDIxRDk7XCI6XCJcXFxcc3dhcnJvd1wiLFwiJiN4MjFEODtcIjpcIlxcXFxzZWFycm93XCIsXCImI3gyMUQ3O1wiOlwiXFxcXG5lYXJyb3dcIixcIiYjeDIxRDY7XCI6XCJcXFxcbndhcnJvd1wiLFwiJiN4MjFENTtcIjpcIlxcXFxVcGRvd25hcnJvd1wiLFwiJiN4MjFENDtcIjpcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFEMztcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDIxRDI7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4MjFEMTtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUQwO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjFDRjtcIjpcIlxcXFxuUmlnaHRhcnJvd1wiLFwiJiN4MjFDRTtcIjpcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIixcIiYjeDIxQ0Q7XCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwiJiN4MjFDQztcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4MjFDQjtcIjpcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiLFwiJiN4MjFDQTtcIjpcIlxcXFxkb3duZG93bmFycm93c1wiLFwiJiN4MjFDOTtcIjpcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIsXCImI3gyMUM4O1wiOlwiXFxcXHVwdXBhcnJvd3NcIixcIiYjeDIxQzc7XCI6XCJcXFxcbGVmdGxlZnRhcnJvd3NcIixcIiYjeDIxQzY7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCImI3gyMUM1O1wiOlwiXCIsXCImI3gyMUM0O1wiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwiJiN4MjFDMztcIjpcIlxcXFxkb3duaGFycG9vbmxlZnRcIixcIiYjeDIxQzI7XCI6XCJcXFxcZG93bmhhcnBvb25yaWdodFwiLFwiJiN4MjFDMTtcIjpcIlxcXFxyaWdodGhhcnBvb25kb3duXCIsXCImI3gyMUMwO1wiOlwiXFxcXHJpZ2h0aGFycG9vbnVwXCIsXCImI3gyMUJGO1wiOlwiXFxcXHVwaGFycG9vbmxlZnRcIixcIiYjeDIxQkU7XCI6XCJcXFxcdXBoYXJwb29ucmlnaHRcIixcIiYjeDIxQkQ7XCI6XCJcXFxcbGVmdGhhcnBvb25kb3duXCIsXCImI3gyMUJDO1wiOlwiXFxcXGxlZnRoYXJwb29udXBcIixcIiYjeDIxQkI7XCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLFwiJiN4MjFCQTtcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIiYjeDIxQjk7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCImI3gyMUI4O1wiOlwiXFxcXG92ZXJsaW5le1xcXFxud2Fycm93fVwiLFwiJiN4MjFCNztcIjpcIlxcXFxjdXJ2ZWFycm93cmlnaHRcIixcIiYjeDIxQjY7XCI6XCJcXFxcY3VydmVhcnJvd2xlZnRcIixcIiYjeDIxQjU7XCI6XCJcXFxcc3dhcnJvd1wiLFwiJiN4MjFCNDtcIjpcIlxcXFxzZWFycm93XCIsXCImI3gyMUIzO1wiOlwiXFxcXFJzaFwiLFwiJiN4MjFCMjtcIjpcIlxcXFxMc2hcIixcIiYjeDIxQjE7XCI6XCJcXFxcUnNoXCIsXCImI3gyMUIwO1wiOlwiXFxcXExzaFwiLFwiJiN4MjFBRjtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMUFFO1wiOlwiXCIsXCImI3gyMUFEO1wiOlwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIixcIiYjeDIxQUM7XCI6XCJcXFxcbG9vcGFycm93cmlnaHRcIixcIiYjeDIxQUI7XCI6XCJcXFxcbG9vcGFycm93bGVmdFwiLFwiJiN4MjFBQTtcIjpcIlxcXFxob29rcmlnaHRhcnJvd1wiLFwiJiN4MjFBOTtcIjpcIlxcXFxob29rbGVmdGFycm93XCIsXCImI3gyMUE4O1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdXBkb3duYXJyb3d9XCIsXCImI3gyMUE3O1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFBNjtcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwiJiN4MjFBNTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMUE0O1wiOlwiXFxcXGxlZnRhcnJvd3RhaWxcIixcIiYjeDIxQTM7XCI6XCJcXFxccmlnaHRhcnJvd3RhaWxcIixcIiYjeDIxQTI7XCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwiJiN4MjFBMTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDIxQTA7XCI6XCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIixcIiYjeDIxOUY7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjE5RTtcIjpcIlxcXFx0d29oZWFkbGVmdGFycm93XCIsXCImI3gyMTlEO1wiOlwiXFxcXG5lYXJyb3dcIixcIiYjeDIxOUM7XCI6XCJcXFxcbndhcnJvd1wiLFwiJiN4MjE5QjtcIjpcIlwiLFwiJiN4MjE5QTtcIjpcIlwiLFwiJiN4MjE5OTtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMTk4O1wiOlwiXFxcXHNlYXJyb3dcIixcIiYjeDIxOTc7XCI6XCJcXFxcbmVhcnJvd1wiLFwiJiN4MjE5NjtcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMTk1O1wiOlwiXFxcXHVwZG93bmFycm93XCIsXCImI3gyMTk0O1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCImI3gyMTkzO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjE5MjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMTkxO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDIxOTA7XCI6XCJcXFxcbGVmdGFycm93XCIsXCJ8fHxcIjpcIlxcXFxsZWZ0fHx8XFxcXHJpZ2h0LlwiLFwifHxcIjpcIlxcXFxsZWZ0fHxcXFxccmlnaHQuXCIsXCJ8XCI6XCJcXFxcbGVmdHxcXFxccmlnaHQuXCIsXCImI3gyQUZFO1wiOlwiXCIsXCImI3gyQUZEO1wiOlwiLy9cIixcIiYjeDJBRkI7XCI6XCIvLy9cIixcIiYjeDJBRkE7XCI6XCJcIixcIiYjeDJBRjk7XCI6XCJcIixcIiYjeDJBRjg7XCI6XCJcIixcIiYjeDJBRjc7XCI6XCJcIixcIiYjeDJBRjY7XCI6XCJcXFxcdmRvdHNcIixcIiYjeDJBRjU7XCI6XCJcIixcIiYjeDJBRjQ7XCI6XCJcIixcIiYjeDJBRjM7XCI6XCJcIixcIiYjeDJBRjI7XCI6XCJcXFxcbnBhcmFsbGVsXCIsXCImI3gyQUYxO1wiOlwiXCIsXCImI3gyQUYwO1wiOlwiXCIsXCImI3gyQUVGO1wiOlwiXCIsXCImI3gyQUVFO1wiOlwiXFxcXGJjYW5jZWx7XFxcXG1pZH1cIixcIiYjeDJBRUQ7XCI6XCJcIixcIiYjeDJBRUM7XCI6XCJcIixcIiYjeDJBRUI7XCI6XCJcIixcIiYjeDJBRUE7XCI6XCJcIixcIiYjeDJBRTk7XCI6XCJcIixcIiYjeDJBRTg7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxwZXJwfVwiLFwiJiN4MkFFNztcIjpcIlxcXFxvdmVybGluZXtcXFxcdG9wfVwiLFwiJiN4MkFFNjtcIjpcIlwiLFwiJiN4MkFFNTtcIjpcIlwiLFwiJiN4MkFFNDtcIjpcIlwiLFwiJiN4MkFFMztcIjpcIlwiLFwiJiN4MkFFMjtcIjpcIlwiLFwiJiN4MkFFMTtcIjpcIlwiLFwiJiN4MkFFMDtcIjpcIlxcXFxwZXJwXCIsXCImI3gyQURGO1wiOlwiXFxcXHRvcFwiLFwiJiN4MkFERTtcIjpcIlxcXFxkYXNodlwiLFwiJiN4MkFERDsmI3gzMzg7XCI6XCJcIixcIiYjeDJBREQ7XCI6XCJcIixcIiYjeDJBREI7XCI6XCJcXFxccGl0Y2hmb3JrXCIsXCImI3gyQURBO1wiOlwiXCIsXCImI3gyQUQ5O1wiOlwiXCIsXCImI3gyQUQ4O1wiOlwiXCIsXCImI3gyQUQ3O1wiOlwiXCIsXCImI3gyQUQ2O1wiOlwiXCIsXCImI3gyQUQ1O1wiOlwiXCIsXCImI3gyQUQ0O1wiOlwiXCIsXCImI3gyQUQzO1wiOlwiXCIsXCImI3gyQUQyO1wiOlwiXCIsXCImI3gyQUQxO1wiOlwiXCIsXCImI3gyQUQwO1wiOlwiXCIsXCImI3gyQUNGO1wiOlwiXCIsXCImI3gyQUNFO1wiOlwiXCIsXCImI3gyQUNEO1wiOlwiXCIsXCImI3gyQUNDO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUNCO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUNBO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUM5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUM4O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdXBzZXR9XCIsXCImI3gyQUM3O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdWJzZXR9XCIsXCImI3gyQUM2O1wiOlwiXFxcXHN1cHNldGVxcVwiLFwiJiN4MkFDNTtcIjpcIlxcXFxzdWJzZXRlcXFcIixcIiYjeDJBQzQ7XCI6XCJcXFxcZG90e1xcXFxzdXBzZXRlcX1cIixcIiYjeDJBQzM7XCI6XCJcXFxcZG90e1xcXFxzdWJzZXRlcX1cIixcIiYjeDJBQzI7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHRpbWVzfXtcXFxcc3Vwc2V0fVwiLFwiJiN4MkFDMTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcdGltZXN9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUMwO1wiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUJGO1wiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUJFO1wiOlwiXCIsXCImI3gyQUJEO1wiOlwiXCIsXCImI3gyQUJDO1wiOlwiXFxcXGdnIFwiLFwiJiN4MkFCQjtcIjpcIlxcXFxsbFwiLFwiJiN4MkFCQTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXtcXFxcc3VjY31cIixcIiYjeDJBQjk7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17XFxcXHByZWN9XCIsXCImI3gyQUI4O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdWNjfVwiLFwiJiN4MkFCNztcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxccHJlY31cIixcIiYjeDJBQjY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHN1Y2N9XCIsXCImI3gyQUI1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7PX19e1xcXFxwcmVjfVwiLFwiJiN4MkFCNDtcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcc3VjY31cIixcIiYjeDJBQjM7XCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHByZWN9XCIsXCImI3gyQUIyO1wiOlwiXCIsXCImI3gyQUIxO1wiOlwiXCIsXCImI3gyQUFFO1wiOlwiXCIsXCImI3gyQUFEO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaGNhbmNlbHs+fX1cIixcIiYjeDJBQUM7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwiJiN4MkFBQjtcIjpcIlxcXFxoY2FuY2Vsez59XCIsXCImI3gyQUFBO1wiOlwiXFxcXGhjYW5jZWx7PH1cIixcIiYjeDJBQTk7XCI6XCJcIixcIiYjeDJBQTg7XCI6XCJcIixcIiYjeDJBQTc7XCI6XCJcXFxcdmFydHJpYW5nbGVyaWdodFwiLFwiJiN4MkFBNjtcIjpcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIixcIiYjeDJBQTU7XCI6XCI+PFwiLFwiJiN4MkFBNDtcIjpcIj48XCIsXCImI3gyQUEzO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbGx9XCIsXCImI3gyQUEyOyYjeDMzODtcIjpcIlxcXFxjYW5jZWx7XFxcXGdnfVwiLFwiJiN4MkFBMjtcIjpcIlxcXFxnZ1wiLFwiJiN4MkFBMTsmI3gzMzg7XCI6XCJcXFxcY2FuY2Vse1xcXFxsbH1cIixcIiYjeDJBQTE7XCI6XCJcXFxcbGxcIixcIiYjeDJBQTA7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxcZ2VxcX1cIixcIiYjeDJBOUY7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxcbGVxcX1cIixcIiYjeDJBOUU7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXs+fVwiLFwiJiN4MkE5RDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ezx9XCIsXCImI3gyQTlDO1wiOlwiXCIsXCImI3gyQTlCO1wiOlwiXCIsXCImI3gyQTlBO1wiOlwiXFxcXG92ZXJzZXR7PX17Pn1cIixcIiYjeDJBOTk7XCI6XCJcXFxcb3ZlcnNldHs9fXs8fVwiLFwiJiN4MkE5ODtcIjpcIlwiLFwiJiN4MkE5NztcIjpcIlwiLFwiJiN4MkE5NjtcIjpcIlwiLFwiJiN4MkE5NTtcIjpcIlwiLFwiJiN4MkE5NDtcIjpcIlwiLFwiJiN4MkE5MztcIjpcIlwiLFwiJiN4MkE5MjtcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcZ3RybGVzc31cIixcIiYjeDJBOTE7XCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXGxlc3NndHJ9XCIsXCImI3gyQTkwO1wiOlwiXFxcXHVuZGVyc2V0ezx9e1xcXFxndHJzaW19XCIsXCImI3gyQThGO1wiOlwiXFxcXHVuZGVyc2V0ez59e1xcXFxsZXNzc2ltfVwiLFwiJiN4MkE4RTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltZXF9ez59XCIsXCImI3gyQThEO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW1lcX17PH1cIixcIiYjeDJBOEM7XCI6XCJcXFxcZ3RyZXFxbGVzc1wiLFwiJiN4MkE4QjtcIjpcIlxcXFxsZXNzZXFxZ3RyXCIsXCImI3gyQThBO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19ez59XCIsXCImI3gyQTg5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ezx9XCIsXCImI3gyQTg2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ez59XCIsXCImI3gyQTg1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ezx9XCIsXCImI3gyQTg0O1wiOlwiXCIsXCImI3gyQTgzO1wiOlwiXCIsXCImI3gyQTgyO1wiOlwiXCIsXCImI3gyQTgxO1wiOlwiXCIsXCImI3gyQTgwO1wiOlwiXCIsXCImI3gyQTdGO1wiOlwiXCIsXCImI3gyQTdFOyYjeDMzODtcIjpcIlxcXFxiY2FuY2Vse1xcXFxnZXF9XCIsXCImI3gyQTdFO1wiOlwiXFxcXGdlcVwiLFwiJiN4MkE3RDsmI3gzMzg7XCI6XCJcXFxcYmNhbmNlbHtcXFxcbGVxfVwiLFwiJiN4MkE3RDtcIjpcIlxcXFxsZXFcIixcIiYjeDJBN0M7XCI6XCJcIixcIiYjeDJBN0I7XCI6XCJcIixcIiYjeDJBN0E7XCI6XCJcIixcIiYjeDJBNzk7XCI6XCJcIixcIiYjeDJBNzg7XCI6XCJcXFxcb3ZlcnNldHtcXFxcZG90c317XFxcXGVxdWl2fVwiLFwiJiN4MkE3NztcIjpcIlwiLFwiJiN4MkE3NjtcIjpcIj09PVwiLFwiJiN4MkE3NTtcIjpcIj09XCIsXCImI3gyQTc0O1wiOlwiOjo9XCIsXCImI3gyQTczO1wiOlwiXCIsXCImI3gyQTcyO1wiOlwiXFxcXHVuZGVyc2V0ez19eyt9XCIsXCImI3gyQTcxO1wiOlwiXFxcXG92ZXJzZXR7PX17K31cIixcIiYjeDJBNzA7XCI6XCJcXFxcb3ZlcnNldHtcXFxcYXBwcm94fXs9fVwiLFwiJiN4MkE2RjtcIjpcIlxcXFxvdmVyc2V0e1xcXFx3ZWRnZX17PX1cIixcIiYjeDJBNkU7XCI6XCJcXFxcb3ZlcnNldHsqfXs9fVwiLFwiJiN4MkE2RDtcIjpcIlxcXFxkb3R7XFxcXGFwcHJveH1cIixcIiYjeDJBNkM7XCI6XCJcIixcIiYjeDJBNkI7XCI6XCJcIixcIiYjeDJBNkE7XCI6XCJcXFxcZG90e1xcXFxzaW19XCIsXCImI3gyQTY5O1wiOlwiXCIsXCImI3gyQTY4O1wiOlwiXCIsXCImI3gyQTY3O1wiOlwiXFxcXGRvdHtcXFxcZXF1aXZ9XCIsXCImI3gyQTY2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjZG90fXs9fVwiLFwiJiN4MkE2NTtcIjpcIlwiLFwiJiN4MkE2NDtcIjpcIlwiLFwiJiN4MkE2MztcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcdmVlfVwiLFwiJiN4MkE2MjtcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFx2ZWV9XCIsXCImI3gyQTYxO1wiOlwidWwodnYpXCIsXCImI3gyQTYwO1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIiYjeDJBNUY7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx3ZWRnZX1cIixcIiYjeDJBNUU7XCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxcd2VkZ2V9XCIsXCImI3gyQTVEO1wiOlwiXFxcXGhjYW5jZWx7XFxcXHZlZX1cIixcIiYjeDJBNUM7XCI6XCJcXFxcaGNhbmNlbHtcXFxcd2VkZ2V9XCIsXCImI3gyQTVCO1wiOlwiXCIsXCImI3gyQTVBO1wiOlwiXCIsXCImI3gyQTU5O1wiOlwiXCIsXCImI3gyQTU4O1wiOlwiXFxcXHZlZVwiLFwiJiN4MkE1NztcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MkE1NjtcIjpcIlwiLFwiJiN4MkE1NTtcIjpcIlwiLFwiJiN4MkE1NDtcIjpcIlwiLFwiJiN4MkE1MztcIjpcIlwiLFwiJiN4MkE1MjtcIjpcIlxcXFxkb3R7XFxcXHZlZX1cIixcIiYjeDJBNTE7XCI6XCJcXFxcZG90e1xcXFx3ZWRnZX1cIixcIiYjeDJBNTA7XCI6XCJcIixcIiYjeDJBNEY7XCI6XCJcIixcIiYjeDJBNEU7XCI6XCJcIixcIiYjeDJBNEQ7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGNhcH1cIixcIiYjeDJBNEM7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIiYjeDJBNEI7XCI6XCJcIixcIiYjeDJBNEE7XCI6XCJcIixcIiYjeDJBNDk7XCI6XCJcIixcIiYjeDJBNDg7XCI6XCJcIixcIiYjeDJBNDc7XCI6XCJcIixcIiYjeDJBNDY7XCI6XCJcIixcIiYjeDJBNDU7XCI6XCJcIixcIiYjeDJBNDQ7XCI6XCJcIixcIiYjeDJBNDM7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGNhcH1cIixcIiYjeDJBNDI7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIiYjeDJBNDE7XCI6XCJcIixcIiYjeDJBNDA7XCI6XCJcIixcIiYjeDJBM0U7XCI6XCJcIixcIiYjeDJBM0Q7XCI6XCJcXFxcbGxjb3JuZXJcIixcIiYjeDJBM0M7XCI6XCJcXFxcbHJjb3JuZXJcIixcIiYjeDJBM0I7XCI6XCJcIixcIiYjeDJBM0E7XCI6XCJcIixcIiYjeDJBMzk7XCI6XCJcIixcIiYjeDJBMzg7XCI6XCJcIixcIiYjeDJBMzc7XCI6XCJcIixcIiYjeDJBMzY7XCI6XCJcXFxcaGF0e1xcXFxvdGltZXN9XCIsXCImI3gyQTM1O1wiOlwiXCIsXCImI3gyQTM0O1wiOlwiXCIsXCImI3gyQTMzO1wiOlwiXCIsXCImI3gyQTMyO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdGltZXN9XCIsXCImI3gyQTMxO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdGltZXN9XCIsXCImI3gyQTMwO1wiOlwiXFxcXGRvdHtcXFxcdGltZXN9XCIsXCImI3gyQTJFO1wiOlwiXCIsXCImI3gyQTJEO1wiOlwiXCIsXCImI3gyQTJDO1wiOlwiXCIsXCImI3gyQTJCO1wiOlwiXCIsXCImI3gyQTJBO1wiOlwiXCIsXCImI3gyQTI5O1wiOlwiXCIsXCImI3gyQTI4O1wiOlwiXCIsXCImI3gyQTI3O1wiOlwiXCIsXCImI3gyQTI2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19eyt9XCIsXCImI3gyQTI1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjaXJjfXsrfVwiLFwiJiN4MkEyNDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19eyt9XCIsXCImI3gyQTIzO1wiOlwiXFxcXGhhdHsrfVwiLFwiJiN4MkEyMjtcIjpcIlxcXFxkb3R7K31cIixcIiYjeDJBMjE7XCI6XCJcXFxcdXBoYXJwb29ucmlnaHRcIixcIiYjeDJBMjA7XCI6XCI+PlwiLFwiJiN4MkExRjtcIjpcIlwiLFwiJiN4MkExRTtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDJBMUQ7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUZGO1wiOlwiXCIsXCImI3gyOUZFO1wiOlwiK1wiLFwiJiN4MjlGQjtcIjpcIlxcXFxoY2FuY2Vse3x8fH1cIixcIiYjeDI5RkE7XCI6XCJcXFxcaGNhbmNlbHt8fH1cIixcIiYjeDI5Rjk7XCI6XCJcXFxcYmFja3NsYXNoXCIsXCImI3gyOUY4O1wiOlwiL1wiLFwiJiN4MjlGNztcIjpcImhjYW5jZWx7XFxiYWNrc2xhc2h9XCIsXCImI3gyOUY2O1wiOlwiXCIsXCImI3gyOUY1O1wiOlwiXFxcXGJhY2tzbGFzaFwiLFwiJiN4MjlGMjtcIjpcIlxcXFxQaGlcIixcIiYjeDI5RjE7XCI6XCJcIixcIiYjeDI5RjA7XCI6XCJcIixcIiYjeDI5RUU7XCI6XCJcIixcIiYjeDI5RUQ7XCI6XCJcIixcIiYjeDI5RUM7XCI6XCJcIixcIiYjeDI5RUI7XCI6XCJcXFxcbG96ZW5nZVwiLFwiJiN4MjlFQTtcIjpcIlwiLFwiJiN4MjlFOTtcIjpcIlwiLFwiJiN4MjlFODtcIjpcIlwiLFwiJiN4MjlFNztcIjpcIlxcXFxkZGFnZ2VyXCIsXCImI3gyOUUyO1wiOlwiXFxcXHNxY3VwXFxcXHNxY3VwXCIsXCImI3gyOUUxO1wiOlwiXCIsXCImI3gyOUUwO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjlERTtcIjpcIlwiLFwiJiN4MjlERDtcIjpcIlwiLFwiJiN4MjlEQztcIjpcIlwiLFwiJiN4MjlEQjtcIjpcIlxcXFx7XFxcXHtcIixcIiYjeDI5RDk7XCI6XCJcXFxce1wiLFwiJiN4MjlEODtcIjpcIlxcXFx9XCIsXCImI3gyOUQ3O1wiOlwiXCIsXCImI3gyOUQ2O1wiOlwiXCIsXCImI3gyOUQ1O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlENDtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RDM7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUQyO1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlEMTtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RDA7JiN4MzM4O1wiOlwifCBcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI5RDA7XCI6XCJ8IFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyOUNGOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0IHxcIixcIiYjeDI5Q0Y7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0IHxcIixcIiYjeDI5Q0U7XCI6XCJcIixcIiYjeDI5Q0Q7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI5Q0M7XCI6XCJcIixcIiYjeDI5Q0I7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0cmlhbmdsZX1cIixcIiYjeDI5Q0E7XCI6XCJcXFxcZG90e1xcXFx0cmlhbmdsZX1cIixcIiYjeDI5Qzk7XCI6XCJcIixcIiYjeDI5Qzg7XCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCImI3gyOUM3O1wiOlwiXFxcXGJveGVke1xcXFxjaXJjfVwiLFwiJiN4MjlDNjtcIjpcIlxcXFxib3hlZHtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5QzU7XCI6XCJcXFxcYmNhbmNlbHtcXFxcc3F1YXJlfVwiLFwiJiN4MjlDNDtcIjpcIlxcXFxjYW5jZWx7XFxcXHNxdWFyZX1cIixcIiYjeDI5QzM7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjlDMjtcIjpcIlxcXFxvZG90XCIsXCImI3gyOUJGO1wiOlwiXFxcXG9kb3RcIixcIiYjeDI5QkU7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjlCRDtcIjpcIlxcXFx2YXJub3RoaW5nXCIsXCImI3gyOUJDO1wiOlwiXFxcXG9wbHVzXCIsXCImI3gyOUJCO1wiOlwiXFxcXG90aW1lc1wiLFwiJiN4MjlCQTtcIjpcIlwiLFwiJiN4MjlCOTtcIjpcIlxcXFx2YXJub3RoaW5nXCIsXCImI3gyOUI4O1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5Qjc7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyOUI2O1wiOlwiXFxcXG9taW51c1wiLFwiJiN4MjlCNTtcIjpcIlxcXFxvbWludXNcIixcIiYjeDI5QjQ7XCI6XCJcXFxcdmVje1xcXFx2YXJub3RoaW5nfVwiLFwiJiN4MjlCMztcIjpcIlxcXFx2ZWN7XFxcXHZhcm5vdGhpbmd9XCIsXCImI3gyOUIyO1wiOlwiXFxcXGRvdHtcXFxcdmFybm90aGluZ31cIixcIiYjeDI5QjE7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHZhcm5vdGhpbmd9XCIsXCImI3gyOUIwO1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5QUY7XCI6XCJcIixcIiYjeDI5QUU7XCI6XCJcIixcIiYjeDI5QUQ7XCI6XCJcIixcIiYjeDI5QUM7XCI6XCJcIixcIiYjeDI5QUI7XCI6XCJcIixcIiYjeDI5QUE7XCI6XCJcIixcIiYjeDI5QTk7XCI6XCJcIixcIiYjeDI5QTg7XCI6XCJcIixcIiYjeDI5QTc7XCI6XCJcIixcIiYjeDI5QTY7XCI6XCJcIixcIiYjeDI5QTU7XCI6XCJcIixcIiYjeDI5QTQ7XCI6XCJcIixcIiYjeDI5QTM7XCI6XCJcIixcIiYjeDI5QTI7XCI6XCJcIixcIiYjeDI5QTE7XCI6XCJcXFxcbm90XFxcXGxvclwiLFwiJiN4MjlBMDtcIjpcIlxcXFxiY2FuY2Vsez59XCIsXCImI3gyOTgyO1wiOlwiOlwiLFwiJiN4Mjk4MTtcIjpcIlxcXFxjaXJjXCIsXCImI3gyNzU4O1wiOlwifFwiLFwiJiN4MjVCMjtcIjpcIlxcXFxiaWd0cmlhbmdsZXVwXCIsXCImI3gyMkZGO1wiOlwiXFxcXEVwc2lsb25cIixcIiYjeDIyRkU7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG5pfVwiLFwiJiN4MjJGRDtcIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCImI3gyMkZDO1wiOlwiXFxcXGluXCIsXCImI3gyMkZCO1wiOlwiXFxcXGluXCIsXCImI3gyMkZBO1wiOlwiXFxcXGluXCIsXCImI3gyMkY5O1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaW59XCIsXCImI3gyMkY4O1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaW59XCIsXCImI3gyMkY3O1wiOlwiXFxcXG92ZXJsaW5le1xcXFxpbn1cIixcIiYjeDIyRjY7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGlufVwiLFwiJiN4MjJGNTtcIjpcIlxcXFxkb3R7XFxcXGlufVwiLFwiJiN4MjJGNDtcIjpcIlxcXFxpblwiLFwiJiN4MjJGMztcIjpcIlxcXFxpblwiLFwiJiN4MjJGMjtcIjpcIlxcXFxpblwiLFwiJiN4MjJGMDtcIjpcIlxcXFxkZG90c1wiLFwiJiN4MjJFOTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3VjY31cIixcIiYjeDIyRTg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHByZWN9XCIsXCImI3gyMkU3O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxub3RcXFxcc2ltfXs+fVwiLFwiJiN4MjJFNjtcIjpcIlxcXFx1bmRlcnNldHtcXFxcbm90XFxcXHNpbX17PH1cIixcIiYjeDIyRTU7XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIiYjeDIyRTQ7XCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0ZXFcIixcIiYjeDIyRTM7XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIiYjeDIyRTI7XCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0ZXFcIixcIiYjeDIyRTE7XCI6XCJcXFxcbnN1Y2NcIixcIiYjeDIyRTA7XCI6XCJcXFxcbnByZWNcIixcIiYjeDIyREY7XCI6XCJcXFxcc3VjY1wiLFwiJiN4MjJERTtcIjpcIlxcXFxwcmVjXCIsXCImI3gyMkREO1wiOlwiXFxcXG92ZXJsaW5lez59XCIsXCImI3gyMkRDO1wiOlwiXFxcXG92ZXJsaW5lezx9XCIsXCImI3gyMkRCO1wiOlwiXFxcXHVuZGVyc2V0ez59e1xcXFxsZXF9XCIsXCImI3gyMkRBO1wiOlwiXFxcXHVuZGVyc2V0ezx9e1xcXFxnZXF9XCIsXCImI3gyMkQ1O1wiOlwiXFxcXCNcIixcIiYjeDIyRDM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMkQyO1wiOlwiXFxcXGNhcFwiLFwiJiN4MjJEMTtcIjpcIlxcXFxzdXBzZXRcIixcIiYjeDIyRDA7XCI6XCJcXFxcc3Vic2V0XCIsXCImI3gyMkNGO1wiOlwiXFxcXHdlZGdlXCIsXCImI3gyMkNFO1wiOlwiXFxcXHZlZVwiLFwiJiN4MjJDRDtcIjpcIlxcXFxzaW1lcVwiLFwiJiN4MjJDODtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDIyQzc7XCI6XCJcXFxcYXN0XCIsXCImI3gyMkM2O1wiOlwiXFxcXHN0YXJcIixcIiYjeDIyQzQ7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjJCRjtcIjpcIlxcXFx0cmlhbmdsZVwiLFwiJiN4MjJCRTtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCImI3gyMkJEO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxsb3J9XCIsXCImI3gyMkJDO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxsYW5kfVwiLFwiJiN4MjJCQjtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGxvcn1cIixcIiYjeDIyQkE7XCI6XCJcXFxcdG9wXCIsXCImI3gyMkI5O1wiOlwiXCIsXCImI3gyMkI3O1wiOlwiXFxcXGNpcmNcXFxcbXVsdGltYXBcIixcIiYjeDIyQjY7XCI6XCJcXFxcY2lyY1xcXFxtdWx0aW1hcFwiLFwiJiN4MjJCMztcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyMkIyO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjJCMTtcIjpcIlxcXFxzdWNjXCIsXCImI3gyMkIwO1wiOlwiXFxcXHByZWNcIixcIiYjeDIyQUI7XCI6XCJ8XFxcXG1vZGVsc1wiLFwiJiN4MjJBQTtcIjpcInxcXFxcbW9kZWxzXCIsXCImI3gyMkE3O1wiOlwiXFxcXG1vZGVsc1wiLFwiJiN4MjJBNjtcIjpcIlxcXFx2ZGFzaFwiLFwiJiN4MjI5RDtcIjpcIlxcXFxvbWludXNcIixcIiYjeDIyOUM7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyMjlCO1wiOlwiXFxcXG9kb3RcIixcIiYjeDIyOUE7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjI5NDtcIjpcIlxcXFxzcWN1cFwiLFwiJiN4MjI5MztcIjpcIlxcXFxzcWNhcFwiLFwiJiN4MjI5MjtcIjpcIlxcXFxzcXN1cHNldGVxXCIsXCImI3gyMjkxO1wiOlwiXFxcXHNxc3Vic2V0ZXFcIixcIiYjeDIyOTA7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFxzcXN1cHNldFwiLFwiJiN4MjI5MDtcIjpcIlxcXFxzcXN1cHNldFwiLFwiJiN4MjI4RjsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0XCIsXCImI3gyMjhGO1wiOlwiXFxcXHNxc3Vic2V0XCIsXCImI3gyMjhFO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjI4RDtcIjpcIlxcXFxjdXBcIixcIiYjeDIyOEM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMjdGOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcc3VjY3NpbVwiLFwiJiN4MjI3RjtcIjpcIlxcXFxzdWNjc2ltXCIsXCImI3gyMjdFO1wiOlwiXFxcXHByZWNzaW1cIixcIiYjeDIyNzk7XCI6XCJcXFxcbm90XFxcXG92ZXJzZXR7Pn17PH1cIixcIiYjeDIyNzg7XCI6XCJcXFxcbm90XFxcXG92ZXJzZXR7Pn17PH1cIixcIiYjeDIyNzc7XCI6XCJcXFxcb3ZlcnNldHs+fXs8fVwiLFwiJiN4MjI3NjtcIjpcIlxcXFxvdmVyc2V0ezx9ez59XCIsXCImI3gyMjc1O1wiOlwiXFxcXG5vdFxcXFxnZWdcIixcIiYjeDIyNzQ7XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwiJiN4MjI3MztcIjpcIlxcXFxnZWdcIixcIiYjeDIyNzI7XCI6XCJcXFxcbGVxXCIsXCImI3gyMjZDO1wiOlwiXCIsXCImI3gyMjY3O1wiOlwiXFxcXGdlZ1wiLFwiJiN4MjI2NjsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwiJiN4MjI2NjtcIjpcIlxcXFxsZXFcIixcIiYjeDIyNjM7XCI6XCJcXFxcb3ZlcnNldHs9fXs9fSBcIixcIiYjeDIyNUU7XCI6XCJcXFxcb3ZlcnNldHttfXs9fSBcIixcIiYjeDIyNUQ7XCI6XCJcXFxcb3ZlcnNldHtkZWZ9ez19XCIsXCImI3gyMjU4O1wiOlwiPVwiLFwiJiN4MjI1NjtcIjpcIj1cIixcIiYjeDIyNTU7XCI6XCI9OlwiLFwiJiN4MjI1MztcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1MjtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1MTtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1MDtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI0RjsmI3gzMzg7XCI6XCJcIixcIiYjeDIyNEY7XCI6XCJcIixcIiYjeDIyNEU7JiN4MzM4O1wiOlwiXCIsXCImI3gyMjRFO1wiOlwiXCIsXCImI3gyMjRDO1wiOlwiXFxcXGFwcHJveFwiLFwiJiN4MjI0QjtcIjpcIlxcXFxhcHByb3hcIixcIiYjeDIyNEE7XCI6XCJcXFxcYXBwcm94XCIsXCImI3gyMjQyOyYjeDMzODtcIjpcIlxcXFxuZXFcIixcIiYjeDIyNDI7XCI6XCI9XCIsXCImI3gyMjNGO1wiOlwiXFxcXHNpbVwiLFwiJiN4MjIzRTtcIjpcIlxcXFxpbmZ0eVwiLFwiJiN4MjIzRDsmI3gzMzE7XCI6XCJcXFxcc2ltXCIsXCImI3gyMjNEO1wiOlwiXFxcXHNpbVwiLFwiJiN4MjIzQjtcIjpcIlxcXFxzaW1cIixcIiYjeDIyM0E7XCI6XCI6LTpcIixcIiYjeDIyMzk7XCI6XCItOlwiLFwiJiN4MjIzODtcIjpcIlxcXFxib3RcIixcIiYjeDIyMzc7XCI6XCI6OlwiLFwiJiN4MjIzNjtcIjpcIjpcIixcIiYjeDIyMjM7XCI6XCJ8XCIsXCImI3gyMjFGO1wiOlwiXFxcXGxsY29ybmVyXCIsXCImI3gyMjE5O1wiOlwiXFxcXGNkb3RcIixcIiYjeDIyMTg7XCI6XCJcXFxcY2lyY1wiLFwiJiN4MjIxNztcIjpcIipcIixcIiYjeDIyMTU7XCI6XCIvXCIsXCImI3gyMjBFO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjIwRDtcIjpcIlxcXFxuaVwiLFwiJiN4MjIwQTtcIjpcIlxcXFxpblwiLFwiJiN4MjIwNjtcIjpcIlxcXFxEZWx0YVwiLFwiJiN4MjA0NDtcIjpcIi9cIixcIiYjeDJBQjA7JiN4MzM4O1wiOlwiXFxcXG5zdWNjZXFcIixcIiYjeDJBQjA7XCI6XCJcXFxcc3VjY2VxXCIsXCImI3gyQUFGOyYjeDMzODtcIjpcIlxcXFxucHJlY2VxXCIsXCImI3gyQUFGO1wiOlwiXFxcXHByZWNlcVwiLFwiJiN4MkE4ODtcIjpcIlxcXFxuZ2Vxc2xhbnRcIixcIiYjeDJBODc7XCI6XCJcXFxcbmxlcXNsYW50XCIsXCImI3gyOUYzO1wiOlwiXFxcXFBoaVwiLFwiJiN4MjlFNjtcIjpcIlxcXFxtb2RlbHNcIixcIiYjeDI5RTU7XCI6XCJcXFxcbm90XFxcXGVxdWl2XCIsXCImI3gyOUU0O1wiOlwiXFxcXGFwcHJveFxcXFxuZXFcIixcIiYjeDI5RTM7XCI6XCJcXFxcbmVxXCIsXCImI3gyOUMxO1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjlDMDtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1RTY7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyNUQ3O1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjVENjtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1Q0Y7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyNUNFO1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUNEO1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUNDO1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUM5O1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUM4O1wiOlwiXFxcXGRpYW1vbmRcIixcIiYjeDI1Qzc7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjVDNjtcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyNUM1O1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDNDtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QzM7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUMyO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDMTtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QzA7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUJGO1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwiJiN4MjVCRTtcIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIiYjeDI1QkQ7XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCImI3gyNUJDO1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwiJiN4MjVCOTtcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyNUI4O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI1Qjc7XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjVCNjtcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyNUI1O1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyNUI0O1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyNUIzO1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyNUIxO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVCMDtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUY7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUFFO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBRDtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUI7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUFBO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBMTtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QTA7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyMkVEO1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyMkVDO1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDIyRUI7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyRUE7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjJEOTtcIjpcIlxcXFxnZ2dcIixcIiYjeDIyRDg7XCI6XCJcXFxcbGxsXCIsXCImI3gyMkQ3O1wiOlwiKj5cIixcIiYjeDIyRDY7XCI6XCI8KlwiLFwiJiN4MjJENDtcIjpcIlxcXFxwaXRjaGZvcmtcIixcIiYjeDIyQ0M7XCI6XCJcIixcIiYjeDIyQ0I7XCI6XCJcIixcIiYjeDIyQ0E7XCI6XCJcXFxccnRpbWVzXCIsXCImI3gyMkM5O1wiOlwiXFxcXGx0aW1lc1wiLFwiJiN4MjJCNTtcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyMkI0O1wiOlwiXCIsXCImI3gyMkE1O1wiOlwiXFxcXGJvdFwiLFwiJiN4MjI4MTtcIjpcIlxcXFxuc3VjY1wiLFwiJiN4MjI4MDtcIjpcIlxcXFxwcmVjZXFcIixcIiYjeDIyN0Q7XCI6XCJcXFxcc3VjY2VxXCIsXCImI3gyMjdDO1wiOlwiXFxcXHByZWNlcVwiLFwiJiN4MjI3QjtcIjpcIlxcXFxzdWNjXCIsXCImI3gyMjdBO1wiOlwiXFxcXHByZWNcIixcIiYjeDIyNzE7XCI6XCJcXFxcZ2VxL1wiLFwiJiN4MjI3MDtcIjpcIlxcXFxsZXEvXCIsXCImI3gyMjZEO1wiOlwiXFxcXG5lcVwiLFwiJiN4MjI2QjsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXGdnXCIsXCImI3gyMjZCO1wiOlwiXFxcXGdnXCIsXCImI3gyMjZBOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcbGxcIixcIiYjeDIyNkE7XCI6XCJcXFxcbGxcIixcIiYjeDIyNjk7XCI6XCJcXFxcbmdlcXNsYW50XCIsXCImI3gyMjY4O1wiOlwiXFxcXG5sZXFzbGFudFwiLFwiJiN4MjI2MTtcIjpcIlxcXFxlcXVpdlwiLFwiJiN4MjI1RjtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1QztcIjpcIlxcXFx0cmlhbmdsZXFcIixcIiYjeDIyNUI7XCI6XCJcXFxcZG90ZXFcIixcIiYjeDIyNUE7XCI6XCJcXFxcdHJpYW5nbGVxXCIsXCImI3gyMjU5O1wiOlwiXFxcXHRyaWFuZ2xlcVwiLFwiJiN4MjI1NztcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1NDtcIjpcIjo9XCIsXCImI3gyMjREO1wiOlwiXFxcXGFzeW1wXCIsXCImI3gyMjQ3O1wiOlwiXFxcXG5jb25nXCIsXCImI3gyMjQ2O1wiOlwiXFxcXG5jb25nXCIsXCImI3gyMjQ1O1wiOlwiXFxcXGNvbmdcIixcIiYjeDIyNDQ7XCI6XCJcXFxcbm90XFxcXHNpbWVxXCIsXCImI3gyMjQzO1wiOlwiXFxcXHNpbWVxXCIsXCImI3gyMjQxO1wiOlwiXFxcXG5vdFxcXFxzaW1cIixcIiYjeDIyMjY7XCI6XCJcXFxcbm90XFxcXHBhcmFsbGVsXCIsXCImI3gyMjI1O1wiOlwiXFxcXHBhcmFsbGVsXCIsXCImI3gyMjI0O1wiOlwiXFxcXG5vdHxcIixcIiYjeDIyMUQ7XCI6XCJcXFxccHJvcHRvXCIsXCI9PVwiOlwiPT1cIixcIj1cIjpcIj1cIixcIjo9XCI6XCI6PVwiLFwiLz1cIjpcIj1cIixcIi09XCI6XCItPVwiLFwiKz1cIjpcIis9XCIsXCIqPVwiOlwiKj1cIixcIiE9XCI6XCIhPVwiLFwiJiN4MjI2MDtcIjpcIlxcXFxuZXFcIixcIiYjeDIyNjI7XCI6XCJcXFxcZXF1aXYgL1wiLFwiJiN4MjI0OTtcIjpcIlxcXFxhcHByb3ggL1wiLFwiJiN4MjIzQztcIjpcInNpbVwiLFwiJiN4MjI0ODtcIjpcIlxcXFxhcHByb3hcIixcIiYjeDIyNkU7XCI6XCI8L1wiLFwiJmx0O1wiOlwiPFwiLFwiJiN4MjI2RjtcIjpcIj4vXCIsXCI+PVwiOlwiPj1cIixcIj5cIjpcIj5cIixcIiYjeDIyNjU7XCI6XCJcXFxcZ2VxXCIsXCImI3gyMjY0O1wiOlwiXFxcXGxlcVwiLFwiJmx0Oz1cIjpcIjw9XCIsXCImI3gyMjhCO1wiOlwiXFxcXHN1cHNldG5lcVwiLFwiJiN4MjI4QTtcIjpcIlxcXFxzdWJzZXRuZXFcIixcIiYjeDIyODk7XCI6XCJcXFxcbnN1cHNldGVxXCIsXCImI3gyMjg4O1wiOlwiXFxcXG5zdWJzZXRlcVwiLFwiJiN4MjI4NztcIjpcIlxcXFxzdXBzZXRlcVwiLFwiJiN4MjI4NjtcIjpcIlxcXFxzdWJzZXRlcVwiLFwiJiN4MjI4NTtcIjpcIlxcXFxub3RcXFxcc3Vwc2V0XCIsXCImI3gyMjg0O1wiOlwiXFxcXG5vdFxcXFxzdWJzZXRcIixcIiYjeDIyODM7JiN4MjBEMjtcIjpcIlxcXFxzdXBzZXQgfFwiLFwiJiN4MjI4MztcIjpcIlxcXFxzdXBzZXRcIixcIiYjeDIyODI7JiN4MjBEMjtcIjpcIlxcXFxzdWJzZXQgfFwiLFwiJiN4MjI4MjtcIjpcIlxcXFxzdWJzZXRcIixcIiYjeDIyMEM7XCI6XCJcXFxcbm90XFxcXGluXCIsXCImI3gyMjA5O1wiOlwiXFxcXG5vdGluXCIsXCImI3gyMjA4O1wiOlwiXFxcXGluXCIsXCImI3gyMjAxO1wiOlwiQ1wiLFwiJiN4MjIwNDtcIjpcIlxcXFxuZXhpc3RzXCIsXCImI3gyMjAzO1wiOlwiXFxcXGV4aXN0c1wiLFwiJiN4MjIwMDtcIjpcIlxcXFxmb3JhbGxcIixcIiYjeDIyMjc7XCI6XCJcXFxcbGFuZFwiLFwiJmFtcDsmYW1wO1wiOlwiXFxcXCZcXFxcJlwiLFwiJiN4MjIyODtcIjpcIlxcXFxsb3JcIixcIiYjeDIyQUY7XCI6XCJcXFxcY2FuY2Vse1xcXFx2RGFzaH1cIixcIiYjeDIyQUU7XCI6XCJcXFxcY2FuY2Vse1xcXFxWZGFzaH1cIixcIiYjeDIyQUQ7XCI6XCJcXFxcbnZEYXNoXCIsXCImI3gyMkFDO1wiOlwiXFxcXG52RGFzaFwiLFwiJiN4MjJBOTtcIjpcIlxcXFxWZGFzaFwiLFwiJiN4MjJBODtcIjpcIlxcXFx2RGFzaFwiLFwiJiN4MjJBNDtcIjpcIlxcXFx0b3BcIixcIiYjeDIyQTM7XCI6XCJcXFxcZGFzaHZcIixcIiYjeDIyQTI7XCI6XCJcXFxcdmRhc2hcIixcIiYjeDIyMEI7XCI6XCJcXFxcbmlcIixcIiYjeDIyRjE7XCI6XCJcXFxcZGRvdHNcIixcIiYjeDIyRUY7XCI6XCJcXFxcaGRvdHNcIixcIiYjeDIyRUU7XCI6XCJcXFxcdmRvdHNcIixcIiYjeDIwMjY7XCI6XCJcXFxcaGRvdHNcIixcIiYjeDNGNjtcIjpcIlxcXFxuaVwiLFwiOlwiOlwiOlwiLFwiLi4uXCI6XCJcXFxcY2RvdHNcIixcIi4uXCI6XCIuLlwiLFwiLT5cIjpcIi0+XCIsXCImI3gyMjM1O1wiOlwiXFxcXGJlY2F1c2VcIixcIiYjeDIyMzQ7XCI6XCJcXFxcdGhlcmVmb3JlIFwiLFwiJiN4MjA2MztcIjpcIlwiLFwiLFwiOlwiLFwiLFwiO1wiOlwiO1wiLFwiJiN4MjlGRDtcIjpcIlxcXFx9XCIsXCImI3gyOUZDO1wiOlwiXFxcXHtcIixcIiYjeDI5OTg7XCI6XCJcXFxcXVwiLFwiJiN4Mjk5NztcIjpcIlxcXFxbXCIsXCImI3gyOTk2O1wiOlwiXFxcXGxsXCIsXCImI3gyOTk1O1wiOlwiXFxcXGdnXCIsXCImI3gyOTk0O1wiOlwiXFxcXGdnXCIsXCImI3gyOTkzO1wiOlwiXFxcXGxsXCIsXCImI3gyOTkyO1wiOlwiXFxcXGdnXCIsXCImI3gyOTkxO1wiOlwiXFxcXGxsXCIsXCImI3gyOTkwO1wiOlwiXFxcXF1cIixcIiYjeDI5OEY7XCI6XCJcXFxcXVwiLFwiJiN4Mjk4RTtcIjpcIlxcXFxdXCIsXCImI3gyOThEO1wiOlwiXFxcXFtcIixcIiYjeDI5OEM7XCI6XCJcXFxcW1wiLFwiJiN4Mjk4QjtcIjpcIlxcXFxdXCIsXCImI3gyOThBO1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI5ODk7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyOTg4O1wiOlwifFxcXFwpXCIsXCImI3gyOTg3O1wiOlwiXFxcXCh8XCIsXCImI3gyOTg2O1wiOlwifFxcXFwpXCIsXCImI3gyOTg1O1wiOlwiXFxcXChcXFxcKFwiLFwiJiN4Mjk4NDtcIjpcInxcXFxcfVwiLFwiJiN4Mjk4MztcIjpcIlxcXFx7fFwiLFwiJiN4Mjk4MDtcIjpcIlxcXFx8fFwiLFwiJiN4MjdFRjtcIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXCIsXCImI3gyN0VFO1wiOlwiXFxcXGxlZnRbIFxcXFxyaWdodC5cIixcIiYjeDI3RUQ7XCI6XCJcXFxcbGVmdC4gXFxcXHJpZ2h0XV1cIixcIiYjeDI3RUM7XCI6XCJcXFxcbGVmdFtbIFxcXFxyaWdodC5cIixcIiYjeDI3RUI7XCI6XCJcXFxcZ2dcIixcIiYjeDI3RUE7XCI6XCJcXFxcbGxcIixcIiYjeDI3RTk7XCI6XCJcXFxccmFuZ2xlXCIsXCImI3gyN0U4O1wiOlwiXFxcXGxhbmdsZVwiLFwiJiN4MjdFNztcIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXVwiLFwiJiN4MjdFNjtcIjpcIlxcXFxsZWZ0W1sgXFxcXHJpZ2h0LlwiLFwiJiN4Mjc3MztcIjpcIlxcXFxsZWZ0LlxcXFxyaWdodClcIixcIiYjeDI3NzI7XCI6XCJcXFxcbGVmdChcXFxccmlnaHQuXCIsXCImI3gyMzJBO1wiOlwiXFxcXHJhbmdsZVwiLFwiJiN4MjMyOTtcIjpcIlxcXFxsYW5nbGVcIixcIiYjeDIzMEI7XCI6XCJcXFxccmZsb29yXCIsXCImI3gyMzBBO1wiOlwiXFxcXGxmbG9vclwiLFwiJiN4MjMwOTtcIjpcIlxcXFxyY2VpbFwiLFwiJiN4MjMwODtcIjpcIlxcXFxsY2VpbFwiLFwiJiN4MjAxNjtcIjpcIlxcXFxwYXJhbGxlbFwiLFwifVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0fVwiLFwie1wiOlwiXFxcXGxlZnR7XFxcXHJpZ2h0LlwiLFwiXVwiOlwiXFxcXGxlZnRdXFxcXHJpZ2h0LlwiLFwiW1wiOlwiXFxcXGxlZnRbXFxcXHJpZ2h0LlwiLFwiKVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0KVwiLFwiKFwiOlwiXFxcXGxlZnQoXFxcXHJpZ2h0LlwiLFwiJiN4MjAxRDtcIjonXCInLFwiJiN4MjAxQztcIjpcImBgXCIsXCImI3gyMDE5O1wiOlwiJ1wiLFwiJiN4MjAxODtcIjpcImBcIixcIiVDRSVCMVwiOlwiXFxcXGFscGhhXCIsXCIlQ0UlQjJcIjpcIlxcXFxiZXRhXCIsXCIlQ0UlQjNcIjpcIlxcXFxnYW1tYVwiLFwiJUNFJTkzXCI6XCJcXFxcR2FtbWFcIixcIiVDRSVCNFwiOlwiXFxcXGRlbHRhXCIsXCIlQ0UlOTRcIjpcIlxcXFxEZWx0YVwiLFwiJUNGJUI1XCI6XCJcXFxcZXBzaWxvblwiLFwiJUNFJUI2XCI6XCJcXFxcemV0YVwiLFwiJUNFJUI3XCI6XCJcXFxcZXRhXCIsXCIlQ0UlQjhcIjpcIlxcXFx0aGV0YVwiLFwiJUNFJTk4XCI6XCJcXFxcVGhldGFcIixcIiVDRSVCOVwiOlwiXFxcXGlvdGFcIixcIiVDRSVCQVwiOlwiXFxcXGthcHBhXCIsXCIlQ0UlQkJcIjpcIlxcXFxsYW1iZGFcIixcIiVDRSVCQ1wiOlwiXFxcXG11XCIsXCIlQ0UlQkRcIjpcIlxcXFxudVwiLFwiJUNFJUJGXCI6XCJcXFxcb21pY3JvblwiLFwiJUNGJTgwXCI6XCJcXFxccGlcIixcIiVDRSVBMFwiOlwiXFxcXFBpXCIsXCIlQ0YlODFcIjpcIlxcXFxwaG9cIixcIiVDRiU4M1wiOlwiXFxcXHNpZ21hXCIsXCIlQ0UlQTNcIjpcIlxcXFxTaWdtYVwiLFwiJUNGJTg0XCI6XCJcXFxcdGF1XCIsXCIlQ0YlODVcIjpcIlxcXFx1cHNpbG9uXCIsXCIlQ0UlQTVcIjpcIlxcXFxVcHNpbG9uXCIsXCIlQ0YlOTVcIjpcIlxcXFxwaGlcIixcIiVDRSVBNlwiOlwiXFxcXFBoaVwiLFwiJUNGJTg3XCI6XCJcXFxcY2hpXCIsXCIlQ0YlODhcIjpcIlxcXFxwc2lcIixcIiVDRSVBOFwiOlwiXFxcXFBzaVwiLFwiJUNGJTg5XCI6XCJcXFxcb21lZ2FcIixcIiVDRSVBOVwiOlwiXFxcXE9tZWdhXCJ9fSw5MDM5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoT3BlcmF0b3JzQnlHbHlwaD12b2lkIDAsdC5hbGxNYXRoT3BlcmF0b3JzQnlHbHlwaD17XzpcIlxcXFx1bmRlcmxpbmVcIixcIuKPoVwiOlwiXFxcXHVuZGVyYnJhY2VcIixcIuKPoFwiOlwiXFxcXG92ZXJicmFjZVwiLFwi4o+fXCI6XCJcXFxcdW5kZXJicmFjZVwiLFwi4o+eXCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCLij51cIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCLij5xcIjpcIlxcXFxvdmVyYnJhY2VcIixcIuKOtVwiOlwiXFxcXHVuZGVyYnJhY2VcIixcIuKOtFwiOlwiXFxcXG92ZXJicmFjZVwiLFwi4oOcXCI6XCJcXFxcc3F1YXJlXCIsXCLig5tcIjpcIlxcXFxzcXVhcmVcIixcIuKBpFwiOlwiXCIsXCLigZdcIjpcIicnJydcIixcIuKAvlwiOlwiXFxcXG92ZXJsaW5lXCIsXCLigLdcIjpcImBgYFwiLFwi4oC2XCI6XCJgYFwiLFwi4oC1XCI6XCJgXCIsXCLigLRcIjpcIicnJ1wiLFwi4oCzXCI6XCInJ1wiLFwi4oCfXCI6XCJgYFwiLFwi4oCeXCI6XCIsLFwiLFwi4oCbXCI6XCJgXCIsXCLigJpcIjpcIixcIixcIl5cIjpcIlxcXFxoYXRcIixcIsu3XCI6XCJcXFxcc2ltXCIsXCLLnVwiOlwiXFxcXHNpbVwiLFwiy5xcIjpcIlxcXFxzaW1cIixcIsuaXCI6XCJcXFxcY2lyY1wiLFwiy5lcIjpcIlxcXFxjZG90XCIsXCLLmFwiOlwiIFwiLMuNOlwiXFxcXF9cIizLizpcIsuLXCIsy4o6XCLLilwiLMuJOlwiy4lcIizLhzpcIlwiLMuGOlwiXFxcXGhhdFwiLMK6Olwib1wiLFwiwrlcIjpcIjFcIixcIsK4XCI6XCIsXCIsXCLCtFwiOlwiwrRcIixcIsKzXCI6XCIzXCIsXCLCslwiOlwiMlwiLFwiwrBcIjpcIlxcXFxjaXJjXCIsXCLCr1wiOlwiXFxcXGJhclwiLMKqOlwiYVwiLFwi4oabXCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIsKoXCI6XCJcXFxcY2RvdFxcXFxjZG90XCIsXCJ+XCI6XCJcXFxcc2ltXCIsXCJgXCI6XCJgXCIsXCItLVwiOlwiLS1cIixcIisrXCI6XCIrK1wiLFwiJlwiOlwiXFxcXCZcIixcIuKInFwiOlwiXFxcXHNxcnRbNF17fVwiLFwi4oibXCI6XCJcXFxcc3FydFszXXt9XCIsXCLiiJpcIjpcIlxcXFxzcXJ0e31cIizihYY6XCJkXCIs4oWFOlwiXFxcXG1hdGhiYntEfVwiLFwiP1wiOlwiP1wiLFwiQFwiOlwiQFwiLFwiLy9cIjpcIi8vXCIsXCIhIVwiOlwiISFcIixcIiFcIjpcIiFcIixcIuKZr1wiOlwiXFxcXCNcIixcIuKZrlwiOlwiXCIsXCLima1cIjpcIlwiLFwi4oCyXCI6XCInXCIsXCI8PlwiOlwiPD5cIixcIioqXCI6XCJcXFxcc3RhclxcXFxzdGFyXCIsXCLiiIdcIjpcIlxcXFxuYWJsYVwiLFwi4oiCXCI6XCJcXFxccGFydGlhbFwiLFwi4oqZXCI6XCJcXFxcYmlnb2RvdFwiLFwiwqxcIjpcIlxcXFxuZWdcIixcIuKIolwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKIoVwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKIoFwiOlwiXFxcXGFuZ2xlXCIsXCLDt1wiOlwiXFxcXGRpdlwiLFwiL1wiOlwiL1wiLFwi4oiWXCI6XCJcXFxcYmFja3NsYXNoXCIsXCJcXFxcXCI6XCJcXFxcYmFja3NsYXNoXCIsXCIlXCI6XCJcXFxcJVwiLFwi4oqXXCI6XCJcXFxcYmlnb3RpbWVzXCIsXCLCt1wiOlwiXFxcXGNkb3RcIixcIuKov1wiOlwiXFxcXGNvcHJvZFwiLFwi4qivXCI6XCJcXFxcdGltZXNcIixcIuKLhVwiOlwiXFxcXGNkb3RcIixcIuKKoVwiOlwiXFxcXGJveGRvdFwiLFwi4oqgXCI6XCJcXFxcYm94dGltZXNcIixcIuKBolwiOlwiXCIsXCLigYNcIjpcIi1cIixcIuKAolwiOlwiXFxcXGNkb3RcIixcIi5cIjpcIi5cIixcIipcIjpcIlxcXFxzdGFyXCIsXCLiiKpcIjpcIlxcXFxjdXBcIixcIuKIqVwiOlwiXFxcXGNhcFwiLFwi4oiQXCI6XCJcXFxcY29wcm9kXCIsXCLiiI9cIjpcIlxcXFxwcm9kXCIsXCLiiYBcIjpcIlwiLFwi4qu/XCI6XCJcIixcIuKrvFwiOlwiXFxcXG1pZFxcXFxtaWRcXFxcbWlkXCIsXCLiqIlcIjpcIlxcXFx0aW1lc1wiLFwi4qiIXCI6XCJcIixcIuKoh1wiOlwiXCIsXCLiqIZcIjpcIlxcXFxzcWN1cFwiLFwi4qiFXCI6XCJcXFxcc3FjYXBcIixcIuKoglwiOlwiXFxcXG90aW1lc1wiLFwi4qiAXCI6XCJcXFxcb2RvdFwiLFwi4ouCXCI6XCJcXFxcY2FwXCIsXCLii4FcIjpcIlxcXFx2ZWVcIixcIuKLgFwiOlwiXFxcXHdlZGdlXCIsXCLiqIRcIjpcIlxcXFx1cGx1c1wiLFwi4qiDXCI6XCJcXFxcY3VwXCIsXCLii4NcIjpcIlxcXFxjdXBcIixcIuKonFwiOlwiXFxcXHVuZGVybGluZXtcXFxcaW50fVwiLFwi4qibXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGludH1cIixcIuKomlwiOlwiXFxcXGludFwiLFwi4qiZXCI6XCJcXFxcaW50XCIsXCLiqJhcIjpcIlxcXFxpbnRcIixcIuKol1wiOlwiXFxcXGludFwiLFwi4qiWXCI6XCJcXFxcb2ludFwiLFwi4qiVXCI6XCJcXFxcb2ludFwiLFwi4qiUXCI6XCJcXFxcaW50XCIsXCLiqJNcIjpcIlxcXFxpbnRcIixcIuKoklwiOlwiXFxcXGludFwiLFwi4qiRXCI6XCJcXFxcaW50XCIsXCLiqJBcIjpcIlxcXFxpbnRcIixcIuKoj1wiOlwiXFxcXGJjYW5jZWx7XFxcXGludH1cIixcIuKojlwiOlwiXCIsXCLiqI1cIjpcIlxcXFxoY2FuY2Vse1xcXFxpbnR9XCIsXCLiqIxcIjpcIlxcXFxpaWlpbnRcIixcIuKIs1wiOlwiXFxcXG9pbnRcIixcIuKIslwiOlwiXFxcXG9pbnRcIixcIuKIsVwiOlwiXFxcXGludFwiLFwi4oiwXCI6XCJcXFxcb2lpbnRcIixcIuKIr1wiOlwiXFxcXG9paW50XCIsXCLiiK5cIjpcIlxcXFxvaW50XCIsXCLiiKtcIjpcIlxcXFxpbnRcIixcIuKogVwiOlwiXFxcXG9wbHVzXCIsXCLiiphcIjpcIlxcXFxvc2xhc2hcIixcIuKKllwiOlwiXFxcXG9taW51c1wiLFwi4oqVXCI6XCJcXFxcb3BsdXNcIixcIuKIrVwiOlwiXFxcXGlpaW50XCIsXCLiiKxcIjpcIlxcXFxpaW50XCIsXCLiqItcIjpcIlwiLFwi4qiKXCI6XCJcIixcIuKIkVwiOlwiXFxcXHN1bVwiLFwi4oqfXCI6XCJcXFxcYm94bWludXNcIixcIuKKnlwiOlwiXFxcXGJveHBsdXNcIixcIuKIlFwiOlwiXFxcXGRvdHsrfVwiLFwi4oiTXCI6XCIrLVwiLFwi4oiSXCI6XCItXCIsXCLCsVwiOlwiXFxcXHBtXCIsXCItXCI6XCItXCIsXCIrXCI6XCIrXCIsXCLirYZcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwi4q2FXCI6XCJcXFxcTGxlZnRhcnJvd1wiLFwi4qe0XCI6XCI6XFxcXHJpZ2h0YXJyb3dcIixcIuKnr1wiOlwiXCIsXCLip59cIjpcIlxcXFxidWxsZXQtXFxcXGJ1bGxldFwiLFwi4qafXCI6XCJcXFxcYW5nbGVcIixcIuKmnlwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmnVwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmnFwiOlwiXFxcXHBlcnBcIixcIuKmm1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmmlwiOlwiXCIsXCLipplcIjpcIlxcXFx2ZG90c1wiLFwi4qW/XCI6XCJcIixcIuKlvlwiOlwiXCIsXCLipb1cIjpcIlxcXFxwcmVjXCIsXCLipbxcIjpcIlxcXFxzdWNjXCIsXCLipbtcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317XFxcXHN1cHNldH1cIixcIuKlulwiOlwiXCIsXCLipblcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317XFxcXHN1YnNldH1cIixcIuKluFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXs+fVwiLFwi4qW3XCI6XCJcIixcIuKltlwiOlwiXFxcXHVuZGVyc2V0e1xcXFxsZWZ0YXJyb3d9ezx9XCIsXCLipbVcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxccmlnaHRhcnJvd31cIixcIuKltFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxyaWdodGFycm93fVwiLFwi4qWzXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXGxlZnRhcnJvd31cIixcIuKlslwiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17XFxcXHJpZ2h0YXJyb3d9XCIsXCLipbFcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFxyaWdodGFycm93fVwiLFwi4qWwXCI6XCJcIixcIuKlr1wiOlwiXCIsXCLipa5cIjpcIlwiLFwi4qWtXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHJpZ2h0aGFycG9vbmRvd259XCIsXCLipaxcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHJpZ2h0aGFycG9vbnVwfVwiLFwi4qWrXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxlZnRoYXJwb29uZG93bn1cIixcIuKlqlwiOlwiXFxcXHVuZGVybGluZXtcXFxcbGVmdGhhcnBvb251cH1cIixcIuKlqVwiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCLipahcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwi4qWnXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKlplwiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCLipaVcIjpcIlxcXFxEb3duYXJyb3dcIixcIuKlpFwiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIuKlo1wiOlwiXFxcXFVwYXJyb3dcIixcIuKlolwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4qWhXCI6XCJcXFxcZG93bmFycm93XCIsXCLipaBcIjpcIlxcXFx1cGFycm93XCIsXCLipZ9cIjpcIlxcXFxyaWdodGFycm93XCIsXCLipZ5cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKlnVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qWcXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qWbXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qWaXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipZlcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKlmFwiOlwiXFxcXHVwYXJyb3dcIixcIuKll1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKlllwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qWVXCI6XCJcXFxcZG93bmFycm93XCIsXCLipZRcIjpcIlxcXFx1cGFycm93XCIsXCLipZNcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipZJcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKlkVwiOlwiXFxcXHVwZG93bmFycm93XCIsXCLipZBcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4qWPXCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIuKljlwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipY1cIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4qWMXCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIuKli1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipYpcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4qWJXCI6XCJcIixcIuKliFwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipYdcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwi4qWGXCI6XCJcIixcIuKlhVwiOlwiXCIsXCLipYRcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIuKlg1wiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwi4qWCXCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCLipYFcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCLipYBcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKkv1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkvlwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qS9XCI6XCJcXFxcbGVmdGFycm93XCIsXCLipLxcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipLtcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipLpcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkuVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qS4XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLdcIjpcIlxcXFxSc2hcIixcIuKktlwiOlwiXFxcXExzaFwiLFwi4qS1XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLRcIjpcIlxcXFx1cGFycm93XCIsXCLipLNcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipLJcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKksVwiOlwiIFwiLFwi4qSwXCI6XCIgXCIsXCLipK9cIjpcIiBcIixcIuKkrlwiOlwiIFwiLFwi4qStXCI6XCIgXCIsXCLipKxcIjpcIlxcXFx0aW1lc1wiLFwi4qSrXCI6XCJcXFxcdGltZXNcIixcIuKkqlwiOlwiIFwiLFwi4qSpXCI6XCIgXCIsXCLipKhcIjpcIiBcIixcIuKkp1wiOlwiIFwiLFwi4qSmXCI6XCIgXCIsXCLipKVcIjpcIiBcIixcIuKkpFwiOlwiIFwiLFwi4qSjXCI6XCIgXCIsXCLipKJcIjpcIiBcIixcIuKkoVwiOlwiIFwiLFwi4qSgXCI6XCJcXFxcbWFwc3RvXFxcXGNkb3RcIixcIuKkn1wiOlwiXFxcXGNkb3RcXFxcbGVmdGFycm93XCIsXCLipJ5cIjpcIlxcXFxyaWdodGFycm93XFxcXGNkb3RcIixcIuKknVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qScXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSbXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipJpcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipJlcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkmFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkl1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkllwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKklVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKklFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkk1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qSSXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qSRXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSQXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSPXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSOXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipI1cIjpcIlxcXFxyaWdodGFycm93XCIsXCLipIxcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKki1wiOlwiXFxcXERvd25hcnJvd1wiLFwi4qSKXCI6XCJcXFxcVXBhcnJvd1wiLFwi4qSJXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qSIXCI6XCJcXFxcZG93bmFycm93XCIsXCLipIdcIjpcIlxcXFxSaWdodGFycm93XCIsXCLipIZcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKkhVwiOlwiXFxcXG1hcHN0b1wiLFwi4qSEXCI6XCJcXFxcbkxlZnRyaWdodGFycm93XCIsXCLipINcIjpcIlxcXFxuUmlnaHRhcnJvd1wiLFwi4qSCXCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwi4qSBXCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCLipIBcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIuKfv1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwi4p++XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4p+9XCI6XCJcXFxcTGVmdGFycm93XCIsXCLin7xcIjpcIlxcXFxtYXBzdG9cIixcIuKfu1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4p+6XCI6XCJcXFxcTG9uZ2xlZnRyaWdodGFycm93XCIsXCLin7lcIjpcIlxcXFxMb25ncmlnaHRhcnJvd1wiLFwi4p+4XCI6XCJcXFxcTG9uZ2xlZnRhcnJvd1wiLFwi4p+3XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKftlwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKftVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4p+xXCI6XCJcXFxcRG93bmFycm93XCIsXCLin7BcIjpcIlxcXFxVcGFycm93XCIsXCLiirhcIjpcIlxcXFxyaWdodGFycm93XCIsXCLih79cIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4oe+XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oe9XCI6XCJcXFxcbGVmdGFycm93XCIsXCLih7xcIjpcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIixcIuKHu1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCLih7pcIjpcIlxcXFxubGVmdGFycm93XCIsXCLih7lcIjpcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIixcIuKHuFwiOlwiXFxcXG5yaWdodGFycm93XCIsXCLih7dcIjpcIlxcXFxubGVmdGFycm93XCIsXCLih7ZcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwi4oe1XCI6XCJcIixcIuKHtFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKHs1wiOlwiXFxcXFVwZG93bmFycm93XCIsXCLih7JcIjpcIlxcXFxzZWFycm93XCIsXCLih7FcIjpcIlxcXFxud2Fycm93XCIsXCLih7BcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKHr1wiOlwiXFxcXFVwYXJyb3dcIixcIuKHrlwiOlwiXFxcXFVwYXJyb3dcIixcIuKHrVwiOlwiXFxcXFVwYXJyb3dcIixcIuKHrFwiOlwiXFxcXFVwYXJyb3dcIixcIuKHq1wiOlwiXFxcXFVwYXJyb3dcIixcIuKHqlwiOlwiXFxcXFVwYXJyb3dcIixcIuKHqVwiOlwiXFxcXERvd25hcnJvd1wiLFwi4oeoXCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4oenXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oemXCI6XCJcXFxcTGVmdGFycm93XCIsXCLih6VcIjpcIlxcXFxyaWdodGFycm93XCIsXCLih6RcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHo1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oeiXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oehXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oegXCI6XCJcXFxcbGVmdGFycm93XCIsXCLih59cIjpcIlxcXFxkb3duYXJyb3dcIixcIuKHnlwiOlwiXFxcXHVwYXJyb3dcIixcIuKHnVwiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwi4oecXCI6XCJcXFxcbGVmdGFycm93XCIsXCLih5tcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwi4oeaXCI6XCJcXFxcTGxlZnRhcnJvd1wiLFwi4oeZXCI6XCJcXFxcc3dhcnJvd1wiLFwi4oeYXCI6XCJcXFxcc2VhcnJvd1wiLFwi4oeXXCI6XCJcXFxcbmVhcnJvd1wiLFwi4oeWXCI6XCJcXFxcbndhcnJvd1wiLFwi4oeVXCI6XCJcXFxcVXBkb3duYXJyb3dcIixcIuKHlFwiOlwiXFxcXExlZnRyaWdodGFycm93XCIsXCLih5NcIjpcIlxcXFxEb3duYXJyb3dcIixcIuKHklwiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIuKHkVwiOlwiXFxcXFVwYXJyb3dcIixcIuKHkFwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4oePXCI6XCJcXFxcblJpZ2h0YXJyb3dcIixcIuKHjlwiOlwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLFwi4oeNXCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwi4oeMXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKHi1wiOlwiXFxcXGxlZnRyaWdodGhhcnBvb25zXCIsXCLih4pcIjpcIlxcXFxkb3duZG93bmFycm93c1wiLFwi4oeJXCI6XCJcXFxccmlnaHRyaWdodGFycm93c1wiLFwi4oeIXCI6XCJcXFxcdXB1cGFycm93c1wiLFwi4oeHXCI6XCJcXFxcbGVmdGxlZnRhcnJvd3NcIixcIuKHhlwiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwi4oeFXCI6XCJcIixcIuKHhFwiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwi4oeDXCI6XCJcXFxcZG93bmhhcnBvb25sZWZ0XCIsXCLih4JcIjpcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIsXCLih4FcIjpcIlxcXFxyaWdodGhhcnBvb25kb3duXCIsXCLih4BcIjpcIlxcXFxyaWdodGhhcnBvb251cFwiLFwi4oa/XCI6XCJcXFxcdXBoYXJwb29ubGVmdFwiLFwi4oa+XCI6XCJcXFxcdXBoYXJwb29ucmlnaHRcIixcIuKGvVwiOlwiXFxcXGxlZnRoYXJwb29uZG93blwiLFwi4oa8XCI6XCJcXFxcbGVmdGhhcnBvb251cFwiLFwi4oa7XCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLFwi4oa6XCI6XCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsXCLihrlcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIixcIuKGuFwiOlwiXFxcXG92ZXJsaW5le1xcXFxud2Fycm93fVwiLFwi4oa3XCI6XCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIsXCLihrZcIjpcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLFwi4oa1XCI6XCJcXFxcc3dhcnJvd1wiLFwi4oa0XCI6XCJcXFxcc2VhcnJvd1wiLFwi4oazXCI6XCJcXFxcUnNoXCIsXCLihrJcIjpcIlxcXFxMc2hcIixcIuKGsVwiOlwiXFxcXFJzaFwiLFwi4oawXCI6XCJcXFxcTHNoXCIsXCLihq9cIjpcIlxcXFxzd2Fycm93XCIsXCLihq5cIjpcIlwiLFwi4oatXCI6XCJcXFxcbGVmdHJpZ2h0c3F1aWdhcnJvd1wiLFwi4oasXCI6XCJcXFxcbG9vcGFycm93cmlnaHRcIixcIuKGq1wiOlwiXFxcXGxvb3BhcnJvd2xlZnRcIixcIuKGqlwiOlwiXFxcXGhvb2tyaWdodGFycm93XCIsXCLihqlcIjpcIlxcXFxob29rbGVmdGFycm93XCIsXCLihqhcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHVwZG93bmFycm93fVwiLFwi4oanXCI6XCJcXFxcZG93bmFycm93XCIsXCLihqZcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwi4oalXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oakXCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwi4oajXCI6XCJcXFxccmlnaHRhcnJvd3RhaWxcIixcIuKGolwiOlwiXFxcXGxlZnRhcnJvd3RhaWxcIixcIuKGoVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oagXCI6XCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIixcIuKGn1wiOlwiXFxcXHVwYXJyb3dcIixcIuKGnlwiOlwiXFxcXHR3b2hlYWRsZWZ0YXJyb3dcIixcIuKGnVwiOlwiXFxcXG5lYXJyb3dcIixcIuKGnFwiOlwiXFxcXG53YXJyb3dcIixcIuKGmlwiOlwiXCIsXCLihplcIjpcIlxcXFxzd2Fycm93XCIsXCLihphcIjpcIlxcXFxzZWFycm93XCIsXCLihpdcIjpcIlxcXFxuZWFycm93XCIsXCLihpZcIjpcIlxcXFxud2Fycm93XCIsXCLihpVcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4oaUXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKGk1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oaSXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oaRXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oaQXCI6XCJcXFxcbGVmdGFycm93XCIsXCJ8fHxcIjpcIlxcXFxsZWZ0fHx8XFxcXHJpZ2h0LlwiLFwifHxcIjpcIlxcXFxsZWZ0fHxcXFxccmlnaHQuXCIsXCJ8XCI6XCJcXFxcbWlkXCIsXCLiq75cIjpcIlwiLFwi4qu9XCI6XCIvL1wiLFwi4qu7XCI6XCIvLy9cIixcIuKrulwiOlwiXCIsXCLiq7lcIjpcIlwiLFwi4qu4XCI6XCJcIixcIuKrt1wiOlwiXCIsXCLiq7ZcIjpcIlxcXFx2ZG90c1wiLFwi4qu1XCI6XCJcIixcIuKrtFwiOlwiXCIsXCLiq7NcIjpcIlwiLFwi4quyXCI6XCJcXFxcbnBhcmFsbGVsXCIsXCLiq7FcIjpcIlwiLFwi4quwXCI6XCJcIixcIuKrr1wiOlwiXCIsXCLiq65cIjpcIlxcXFxiY2FuY2Vse1xcXFxtaWR9XCIsXCLiq61cIjpcIlwiLFwi4qusXCI6XCJcIixcIuKrq1wiOlwiXCIsXCLiq6pcIjpcIlwiLFwi4qupXCI6XCJcIixcIuKrqFwiOlwiXFxcXHVuZGVybGluZXtcXFxccGVycH1cIixcIuKrp1wiOlwiXFxcXG92ZXJsaW5le1xcXFx0b3B9XCIsXCLiq6ZcIjpcIlwiLFwi4qulXCI6XCJcIixcIuKrpFwiOlwiXCIsXCLiq6NcIjpcIlwiLFwi4quiXCI6XCJcIixcIuKroVwiOlwiXCIsXCLiq6BcIjpcIlxcXFxwZXJwXCIsXCLiq59cIjpcIlxcXFx0b3BcIixcIuKrnlwiOlwiXFxcXGRhc2h2XCIsXCLiq53MuFwiOlwiXCIsXCLiq51cIjpcIlwiLFwi4qubXCI6XCJcXFxccGl0Y2hmb3JrXCIsXCLiq5pcIjpcIlwiLFwi4quZXCI6XCJcIixcIuKrmFwiOlwiXCIsXCLiq5dcIjpcIlwiLFwi4quWXCI6XCJcIixcIuKrlVwiOlwiXCIsXCLiq5RcIjpcIlwiLFwi4quTXCI6XCJcIixcIuKrklwiOlwiXCIsXCLiq5FcIjpcIlwiLFwi4quQXCI6XCJcIixcIuKrj1wiOlwiXCIsXCLiq45cIjpcIlwiLFwi4quNXCI6XCJcIixcIuKrjFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdXBzZXR9XCIsXCLiq4tcIjpcIlxcXFx1bmRlcnNldHtcXFxcbmVxfXtcXFxcc3Vic2V0fVwiLFwi4quKXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1cHNldH1cIixcIuKriVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdWJzZXR9XCIsXCLiq4hcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3Vwc2V0fVwiLFwi4quHXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHN1YnNldH1cIixcIuKrhlwiOlwiXFxcXHN1cHNldGVxcVwiLFwi4quFXCI6XCJcXFxcc3Vic2V0ZXFxXCIsXCLiq4RcIjpcIlxcXFxkb3R7XFxcXHN1cHNldGVxfVwiLFwi4quDXCI6XCJcXFxcZG90e1xcXFxzdWJzZXRlcX1cIixcIuKrglwiOlwiXFxcXHVuZGVyc2V0e1xcXFx0aW1lc317XFxcXHN1cHNldH1cIixcIuKrgVwiOlwiXFxcXHVuZGVyc2V0e1xcXFx0aW1lc317XFxcXHN1YnNldH1cIixcIuKrgFwiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdXBzZXR9XCIsXCLiqr9cIjpcIlxcXFx1bmRlcnNldHsrfXtcXFxcc3Vic2V0fVwiLFwi4qq+XCI6XCJcIixcIuKqvVwiOlwiXCIsXCLiqrxcIjpcIlxcXFxnZyBcIixcIuKqu1wiOlwiXFxcXGxsXCIsXCLiqrpcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXtcXFxcc3VjY31cIixcIuKquVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19e1xcXFxwcmVjfVwiLFwi4qq4XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1Y2N9XCIsXCLiqrdcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxccHJlY31cIixcIuKqtlwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7PX19e1xcXFxzdWNjfVwiLFwi4qq1XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHByZWN9XCIsXCLiqrRcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcc3VjY31cIixcIuKqs1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxwcmVjfVwiLFwi4qqyXCI6XCJcIixcIuKqsVwiOlwiXCIsXCLiqq5cIjpcIlwiLFwi4qqtXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwi4qqsXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwi4qqrXCI6XCJcXFxcaGNhbmNlbHs+fVwiLFwi4qqqXCI6XCJcXFxcaGNhbmNlbHs8fVwiLFwi4qqpXCI6XCJcIixcIuKqqFwiOlwiXCIsXCLiqqdcIjpcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIsXCLiqqZcIjpcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIixcIuKqpVwiOlwiPjxcIixcIuKqpFwiOlwiPjxcIixcIuKqo1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbGx9XCIsXCLiqqLMuFwiOlwiXFxcXGNhbmNlbHtcXFxcZ2d9XCIsXCLiqqJcIjpcIlxcXFxnZ1wiLFwi4qqhzLhcIjpcIlxcXFxjYW5jZWx7XFxcXGxsfVwiLFwi4qqhXCI6XCJcXFxcbGxcIixcIuKqoFwiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17XFxcXGdlcXF9XCIsXCLiqp9cIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxsZXFxfVwiLFwi4qqeXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXs+fVwiLFwi4qqdXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXs8fVwiLFwi4qqcXCI6XCJcIixcIuKqm1wiOlwiXCIsXCLiqppcIjpcIlxcXFxvdmVyc2V0ez19ez59XCIsXCLiqplcIjpcIlxcXFxvdmVyc2V0ez19ezx9XCIsXCLiqphcIjpcIlwiLFwi4qqXXCI6XCJcIixcIuKqllwiOlwiXCIsXCLiqpVcIjpcIlwiLFwi4qqUXCI6XCJcIixcIuKqk1wiOlwiXCIsXCLiqpJcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcZ3RybGVzc31cIixcIuKqkVwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxsZXNzZ3RyfVwiLFwi4qqQXCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGd0cnNpbX1cIixcIuKqj1wiOlwiXFxcXHVuZGVyc2V0ez59e1xcXFxsZXNzc2ltfVwiLFwi4qqOXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbWVxfXs+fVwiLFwi4qqNXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbWVxfXs8fVwiLFwi4qqMXCI6XCJcXFxcZ3RyZXFxbGVzc1wiLFwi4qqLXCI6XCJcXFxcbGVzc2VxcWd0clwiLFwi4qqKXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17Pn1cIixcIuKqiVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ezx9XCIsXCLiqoZcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXs+fVwiLFwi4qqFXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIuKqhFwiOlwiXCIsXCLiqoNcIjpcIlwiLFwi4qqCXCI6XCJcIixcIuKqgVwiOlwiXCIsXCLiqoBcIjpcIlwiLFwi4qm/XCI6XCJcIixcIuKpvsy4XCI6XCJcXFxcYmNhbmNlbHtcXFxcZ2VxfVwiLFwi4qm+XCI6XCJcXFxcZ2VxXCIsXCLiqb3MuFwiOlwiXFxcXGJjYW5jZWx7XFxcXGxlcX1cIixcIuKpvVwiOlwiXFxcXGxlcVwiLFwi4qm8XCI6XCJcIixcIuKpu1wiOlwiXCIsXCLiqbpcIjpcIlwiLFwi4qm5XCI6XCJcIixcIuKpuFwiOlwiXFxcXG92ZXJzZXR7XFxcXGRvdHN9e1xcXFxlcXVpdn1cIixcIuKpt1wiOlwiXCIsXCLiqbZcIjpcIj09PVwiLFwi4qm1XCI6XCI9PVwiLFwi4qm0XCI6XCI6Oj1cIixcIuKps1wiOlwiXCIsXCLiqbJcIjpcIlxcXFx1bmRlcnNldHs9fXsrfVwiLFwi4qmxXCI6XCJcXFxcb3ZlcnNldHs9fXsrfVwiLFwi4qmwXCI6XCJcXFxcb3ZlcnNldHtcXFxcYXBwcm94fXs9fVwiLFwi4qmvXCI6XCJcXFxcb3ZlcnNldHtcXFxcd2VkZ2V9ez19XCIsXCLiqa5cIjpcIlxcXFxvdmVyc2V0eyp9ez19XCIsXCLiqa1cIjpcIlxcXFxkb3R7XFxcXGFwcHJveH1cIixcIuKprFwiOlwiXCIsXCLiqatcIjpcIlwiLFwi4qmqXCI6XCJcXFxcZG90e1xcXFxzaW19XCIsXCLiqalcIjpcIlwiLFwi4qmoXCI6XCJcIixcIuKpp1wiOlwiXFxcXGRvdHtcXFxcZXF1aXZ9XCIsXCLiqaZcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2RvdH17PX1cIixcIuKppVwiOlwiXCIsXCLiqaRcIjpcIlwiLFwi4qmjXCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHZlZX1cIixcIuKpolwiOlwiXFxcXG92ZXJzZXR7PX17XFxcXHZlZX1cIixcIuKpoVwiOlwidWwodnYpXCIsXCLiqaBcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcd2VkZ2V9XCIsXCLiqZ9cIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHdlZGdlfVwiLFwi4qmeXCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxcd2VkZ2V9XCIsXCLiqZ1cIjpcIlxcXFxoY2FuY2Vse1xcXFx2ZWV9XCIsXCLiqZxcIjpcIlxcXFxoY2FuY2Vse1xcXFx3ZWRnZX1cIixcIuKpm1wiOlwiXCIsXCLiqZpcIjpcIlwiLFwi4qmZXCI6XCJcIixcIuKpmFwiOlwiXFxcXHZlZVwiLFwi4qmXXCI6XCJcXFxcd2VkZ2VcIixcIuKpllwiOlwiXCIsXCLiqZVcIjpcIlwiLFwi4qmUXCI6XCJcIixcIuKpk1wiOlwiXCIsXCLiqZJcIjpcIlxcXFxkb3R7XFxcXHZlZX1cIixcIuKpkVwiOlwiXFxcXGRvdHtcXFxcd2VkZ2V9XCIsXCLiqZBcIjpcIlwiLFwi4qmPXCI6XCJcIixcIuKpjlwiOlwiXCIsXCLiqY1cIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwi4qmMXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIuKpi1wiOlwiXCIsXCLiqYpcIjpcIlwiLFwi4qmJXCI6XCJcIixcIuKpiFwiOlwiXCIsXCLiqYdcIjpcIlwiLFwi4qmGXCI6XCJcIixcIuKphVwiOlwiXCIsXCLiqYRcIjpcIlwiLFwi4qmDXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGNhcH1cIixcIuKpglwiOlwiXFxcXG92ZXJsaW5le1xcXFxjdXB9XCIsXCLiqYFcIjpcIlwiLFwi4qmAXCI6XCJcIixcIuKovlwiOlwiXCIsXCLiqL1cIjpcIlxcXFxsbGNvcm5lclwiLFwi4qi8XCI6XCJcXFxcbHJjb3JuZXJcIixcIuKou1wiOlwiXCIsXCLiqLpcIjpcIlwiLFwi4qi5XCI6XCJcIixcIuKouFwiOlwiXCIsXCLiqLdcIjpcIlwiLFwi4qi2XCI6XCJcXFxcaGF0e1xcXFxvdGltZXN9XCIsXCLiqLVcIjpcIlwiLFwi4qi0XCI6XCJcIixcIuKos1wiOlwiXCIsXCLiqLJcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHRpbWVzfVwiLFwi4qixXCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0aW1lc31cIixcIuKosFwiOlwiXFxcXGRvdHtcXFxcdGltZXN9XCIsXCLiqK5cIjpcIlxcXFxiaWdvZG90XCIsXCLiqK1cIjpcIlxcXFxiaWdvZG90XCIsXCLiqKxcIjpcIlwiLFwi4qirXCI6XCJcIixcIuKoqlwiOlwiXCIsXCLiqKlcIjpcIlwiLFwi4qioXCI6XCJcIixcIuKop1wiOlwiXCIsXCLil7tcIjpcIlxcXFxCb3hcIixcIuKoplwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19eyt9XCIsXCLiqKVcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2lyY317K31cIixcIuKopFwiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17K31cIixcIuKoo1wiOlwiXFxcXGhhdHsrfVwiLFwi4qiiXCI6XCJcXFxcZG90eyt9XCIsXCLiqKFcIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwi4qigXCI6XCI+PlwiLFwi4qifXCI6XCJcIixcIuKonlwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4qidXCI6XCJcXFxcYm93dGllXCIsXCLip79cIjpcIlwiLFwi4qe+XCI6XCIrXCIsXCLip7tcIjpcIlxcXFxoY2FuY2Vse3x8fH1cIixcIuKnulwiOlwiXFxcXGhjYW5jZWx7fHx9XCIsXCLip7lcIjpcIlxcXFxiYWNrc2xhc2hcIixcIuKnuFwiOlwiL1wiLFwi4qe3XCI6XCJoY2FuY2Vse1xcYmFja3NsYXNofVwiLFwi4qe2XCI6XCJcIixcIuKntVwiOlwiXFxcXGJhY2tzbGFzaFwiLFwi4qeyXCI6XCJcXFxcUGhpXCIsXCLip7FcIjpcIlwiLFwi4qewXCI6XCJcIixcIuKnrlwiOlwiXCIsXCLip61cIjpcIlwiLFwi4qesXCI6XCJcIixcIuKnq1wiOlwiXFxcXGxvemVuZ2VcIixcIuKnqlwiOlwiXCIsXCLip6lcIjpcIlwiLFwi4qeoXCI6XCJcIixcIuKnp1wiOlwiXFxcXGRkYWdnZXJcIixcIuKnolwiOlwiXFxcXHNxY3VwXFxcXHNxY3VwXCIsXCLip6FcIjpcIlwiLFwi4qegXCI6XCJcXFxcc3F1YXJlXCIsXCLip55cIjpcIlwiLFwi4qedXCI6XCJcIixcIuKnnFwiOlwiXCIsXCLip5tcIjpcIlxcXFx7XFxcXHtcIixcIuKnmVwiOlwiXFxcXHtcIixcIuKnmFwiOlwiXFxcXH1cIixcIuKnl1wiOlwiXCIsXCLip5ZcIjpcIlwiLFwi4qeVXCI6XCJcXFxcYm93dGllXCIsXCLip5RcIjpcIlxcXFxib3d0aWVcIixcIuKnk1wiOlwiXFxcXGJvd3RpZVwiLFwi4qeSXCI6XCJcXFxcYm93dGllXCIsXCLip5FcIjpcIlxcXFxib3d0aWVcIixcIuKnkMy4XCI6XCJ8IFxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwi4qeQXCI6XCJ8IFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLip4/MuFwiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnQgfFwiLFwi4qePXCI6XCJcXFxcdHJpYW5nbGVsZWZ0IHxcIixcIuKnjlwiOlwiXCIsXCLip41cIjpcIlxcXFx0cmlhbmdsZVwiLFwi4qeMXCI6XCJcIixcIuKni1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdHJpYW5nbGV9XCIsXCLip4pcIjpcIlxcXFxkb3R7XFxcXHRyaWFuZ2xlfVwiLFwi4qeJXCI6XCJcIixcIuKniFwiOlwiXFxcXGJveGVke1xcXFxjaXJjfVwiLFwi4qeHXCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCLip4ZcIjpcIlxcXFxib3hlZHtcXFxccmlnaHRhcnJvd31cIixcIuKnhVwiOlwiXFxcXGJjYW5jZWx7XFxcXHNxdWFyZX1cIixcIuKnhFwiOlwiXFxcXGNhbmNlbHtcXFxcc3F1YXJlfVwiLFwi4qeDXCI6XCJcXFxcb2RvdFwiLFwi4qeCXCI6XCJcXFxcb2RvdFwiLFwi4qa/XCI6XCJcXFxcb2RvdFwiLFwi4qa+XCI6XCJcXFxcb2RvdFwiLFwi4qa9XCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qa8XCI6XCJcXFxcb3BsdXNcIixcIuKmu1wiOlwiXFxcXG90aW1lc1wiLFwi4qa6XCI6XCJcIixcIuKmuVwiOlwiXFxcXHZhcm5vdGhpbmdcIixcIuKmuFwiOlwiXFxcXHZhcm5vdGhpbmdcIixcIuKmt1wiOlwiXFxcXG9taW51c1wiLFwi4qa2XCI6XCJcXFxcb21pbnVzXCIsXCLiprVcIjpcIlxcXFxvbWludXNcIixcIuKmtFwiOlwiXFxcXHZlY3tcXFxcdmFybm90aGluZ31cIixcIuKms1wiOlwiXFxcXHZlY3tcXFxcdmFybm90aGluZ31cIixcIuKmslwiOlwiXFxcXGRvdHtcXFxcdmFybm90aGluZ31cIixcIuKmsVwiOlwiXFxcXG92ZXJsaW5le1xcXFx2YXJub3RoaW5nfVwiLFwi4qawXCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qavXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qauXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qatXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qasXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qarXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qaqXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qapXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qaoXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qanXCI6XCJcIixcIuKmplwiOlwiXCIsXCLipqVcIjpcIlwiLFwi4qakXCI6XCJcIixcIuKmo1wiOlwiXFxcXHVsY29ybmVyXCIsXCLipqJcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqFcIjpcIlxcXFxub3RcXFxcbG9yXCIsXCLipqBcIjpcIlxcXFxiY2FuY2Vsez59XCIsXCLipoJcIjpcIjpcIixcIuKmgVwiOlwiXFxcXGNkb3RcIixcIuKdmFwiOlwiXFxcXG1pZFwiLFwi4payXCI6XCJcXFxcYmlndHJpYW5nbGV1cFwiLFwi4ou/XCI6XCJcXFxcRXBzaWxvblwiLFwi4ou+XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG5pfVwiLFwi4ou9XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG5pfVwiLFwi4ou8XCI6XCJcXFxcaW5cIixcIuKLu1wiOlwiXFxcXGluXCIsXCLii7pcIjpcIlxcXFxpblwiLFwi4ou5XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIuKLuFwiOlwiXFxcXHVuZGVybGluZXtcXFxcaW59XCIsXCLii7dcIjpcIlxcXFxvdmVybGluZXtcXFxcaW59XCIsXCLii7ZcIjpcIlxcXFxvdmVybGluZXtcXFxcaW59XCIsXCLii7VcIjpcIlxcXFxkb3R7XFxcXGlufVwiLFwi4ou0XCI6XCJcXFxcaW5cIixcIuKLs1wiOlwiXFxcXGluXCIsXCLii7JcIjpcIlxcXFxpblwiLFwi4ouwXCI6XCJcXFxcZGRvdHNcIixcItaJXCI6XCI6XCIsXCLii6lcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3VjY31cIixcIuKLqFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxwcmVjfVwiLFwi4ounXCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5vdFxcXFxzaW19ez59XCIsXCLii6ZcIjpcIlxcXFx1bmRlcnNldHtcXFxcbm90XFxcXHNpbX17PH1cIixcIuKLpVwiOlwiXFxcXG5vdFxcXFxzcXN1cHNldGVxXCIsXCLii6RcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRlcVwiLFwi4oujXCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIuKLolwiOlwiXFxcXG5vdFxcXFxzcXN1YnNldGVxXCIsXCLii6FcIjpcIlxcXFxuc3VjY1wiLFwi4ougXCI6XCJcXFxcbnByZWNcIixcIuKLn1wiOlwiXFxcXHN1Y2NcIixcIuKLnlwiOlwiXFxcXHByZWNcIixcIuKLnVwiOlwiXFxcXG92ZXJsaW5lez59XCIsXCLii5xcIjpcIlxcXFxvdmVybGluZXs8fVwiLFwi4oubXCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlcX1cIixcIuKLmlwiOlwiXFxcXHVuZGVyc2V0ezx9e1xcXFxnZXF9XCIsXCLii5VcIjpcIlxcXFwjXCIsXCLii5NcIjpcIlxcXFxjdXBcIixcIuKLklwiOlwiXFxcXGNhcFwiLFwi4ouRXCI6XCJcXFxcc3Vwc2V0XCIsXCLii5BcIjpcIlxcXFxzdWJzZXRcIixcIuKLj1wiOlwiXFxcXHdlZGdlXCIsXCLii45cIjpcIlxcXFx2ZWVcIixcIuKLjVwiOlwiXFxcXHNpbWVxXCIsXCLii4hcIjpcIlxcXFxKb2luXCIsXCLii4dcIjpcIlxcXFxhc3RcIixcIuKLhlwiOlwiXFxcXHN0YXJcIixcIuKLhFwiOlwiXFxcXGRpYW1vbmRcIixcIuKKv1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCLiir5cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLiir1cIjpcIlxcXFxvdmVybGluZXtcXFxcbG9yfVwiLFwi4oq8XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxhbmR9XCIsXCLiirtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGxvcn1cIixcIuKKulwiOlwiXFxcXHRvcFwiLOWcnzpcIlxcXFxwbVwiLOWNgTpcIitcIixcIuKKuVwiOlwiXCIsXCLiirdcIjpcIlxcXFxjaXJjXFxcXG11bHRpbWFwXCIsXCLiirZcIjpcIlxcXFxjaXJjXFxcXG11bHRpbWFwXCIsXCLiirNcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLiirJcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKKsVwiOlwiXFxcXHN1Y2NcIixcIuKKsFwiOlwiXFxcXHByZWNcIixcIuKKq1wiOlwifFxcXFxtb2RlbHNcIixcIuKKqlwiOlwifFxcXFxtb2RlbHNcIixcIuKKp1wiOlwiXFxcXG1vZGVsc1wiLFwi4oqmXCI6XCJcXFxcdmRhc2hcIixcIuKKnVwiOlwiXFxcXG9taW51c1wiLFwi4oqcXCI6XCJcXFxcb21pbnVzXCIsXCLiiptcIjpcIlxcXFxvZG90XCIsXCLiippcIjpcIlxcXFxvZG90XCIsXCLiipRcIjpcIlxcXFxzcWN1cFwiLFwi4oqTXCI6XCJcXFxcc3FjYXBcIixcIuKKklwiOlwiXFxcXHNxc3Vwc2V0ZXFcIixcIuKKkVwiOlwiXFxcXHNxc3Vic2V0ZXFcIixcIuKKkMy4XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0XCIsXCLiipBcIjpcIlxcXFxzcXN1cHNldFwiLFwi4oqPzLhcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRcIixcIuKKj1wiOlwiXFxcXHNxc3Vic2V0XCIsXCLiio5cIjpcIlxcXFxjdXBcIixcIuKKjVwiOlwiXFxcXGN1cFwiLFwi4oqMXCI6XCJcXFxcY3VwXCIsXCLiib/MuFwiOlwiXFxcXG5vdFxcXFxzdWNjc2ltXCIsXCLiib9cIjpcIlxcXFxzdWNjc2ltXCIsXCLiib5cIjpcIlxcXFxwcmVjc2ltXCIsXCLiiblcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwi4om4XCI6XCJcXFxcbm90XFxcXG92ZXJzZXR7Pn17PH1cIixcIuKJt1wiOlwiXFxcXG92ZXJzZXR7Pn17PH1cIixcIuKJtlwiOlwiXFxcXG92ZXJzZXR7PH17Pn1cIixcIuKJtVwiOlwiXFxcXG5vdFxcXFxnZWdcIixcIuKJtFwiOlwiXFxcXG5vdFxcXFxsZXFcIixcIuKJs1wiOlwiXFxcXGdlZ1wiLFwi4omyXCI6XCJcXFxcbGVxXCIsXCLiiaxcIjpcIlwiLFwi4omnXCI6XCJcXFxcZ2VnXCIsXCLiiabMuFwiOlwiXFxcXG5vdFxcXFxsZXFcIixcIuKJplwiOlwiXFxcXGxlcVwiLFwi4omjXCI6XCJcXFxcb3ZlcnNldHs9fXs9fSBcIixcIuKJnlwiOlwiXFxcXG92ZXJzZXR7bX17PX0gXCIsXCLiiZ1cIjpcIlxcXFxvdmVyc2V0e2RlZn17PX1cIixcIuKJmFwiOlwiPVwiLFwi4omWXCI6XCI9XCIsXCLiiZVcIjpcIj06XCIsXCLiiZNcIjpcIlxcXFxkb3RlcVwiLFwi4omSXCI6XCJcXFxcZG90ZXFcIixcIuKJkVwiOlwiXFxcXGRvdGVxXCIsXCLiiZBcIjpcIlxcXFxkb3RlcVwiLFwi4omPzLhcIjpcIlwiLFwi4omPXCI6XCJcIixcIuKJjsy4XCI6XCJcIixcIuKJjlwiOlwiXCIsXCLiiYxcIjpcIlxcXFxhcHByb3hcIixcIuKJi1wiOlwiXFxcXGFwcHJveFwiLFwi4omKXCI6XCJcXFxcYXBwcm94XCIsXCLiiYLMuFwiOlwiXFxcXG5lcVwiLFwi4omCXCI6XCI9XCIsXCLiiL9cIjpcIlxcXFxzaW1cIixcIuKIvlwiOlwiXFxcXGluZnR5XCIsXCLiiL3MsVwiOlwiXFxcXHNpbVwiLFwi4oi9XCI6XCJcXFxcc2ltXCIsXCLiiLtcIjpcIlxcXFxzaW1cIixcIuKIulwiOlwiOi06XCIsXCLiiLlcIjpcIi06XCIsXCLiiLhcIjpcIlxcXFxib3RcIixcIuKIt1wiOlwiOjpcIixcIuKItlwiOlwiOlwiLFwi4oijXCI6XCJcXFxcbWlkXCIsXCLiiJ9cIjpcIlxcXFxsbGNvcm5lclwiLFwi4oiYXCI6XCJcXFxcY2lyY1wiLFwi4oiXXCI6XCIqXCIsXCLiiJVcIjpcIi9cIixcIuKIjlwiOlwiXFxcXHNxdWFyZVwiLFwi4oiNXCI6XCJcXFxcbmlcIixcIuKIilwiOlwiXFxcXGluXCIsXCLiiIZcIjpcIlxcXFxEZWx0YVwiLFwi4oGEXCI6XCIvXCIsXCLiqrDMuFwiOlwiXFxcXG5zdWNjZXFcIixcIuKqsFwiOlwiXFxcXHN1Y2NlcVwiLFwi4qqvzLhcIjpcIlxcXFxucHJlY2VxXCIsXCLiqq9cIjpcIlxcXFxwcmVjZXFcIixcIuKqiFwiOlwiXFxcXG5nZXFzbGFudFwiLFwi4qqHXCI6XCJcXFxcbmxlcXNsYW50XCIsXCLip7NcIjpcIlxcXFxQaGlcIixcIuKnplwiOlwiXFxcXG1vZGVsc1wiLFwi4qelXCI6XCJcXFxcbm90XFxcXGVxdWl2XCIsXCLip6RcIjpcIlxcXFxhcHByb3hcXFxcbmVxXCIsXCLip6NcIjpcIlxcXFxuZXFcIixcIuKngVwiOlwiXFxcXGNpcmNsZVwiLFwi4qeAXCI6XCJcXFxcY2lyY2xlXCIsXCLil6ZcIjpcIlxcXFxjaXJjbGVcIixcIuKXl1wiOlwiXFxcXGNpcmNsZVwiLFwi4peWXCI6XCJcXFxcY2lyY2xlXCIsXCLil49cIjpcIlxcXFxjaXJjbGVcIixcIuKXjlwiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCLil41cIjpcIlxcXFxjaXJjbGVkY2lyY1wiLFwi4peMXCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIuKXiVwiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCLil4hcIjpcIlxcXFxkaWFtb25kXCIsXCLil4dcIjpcIlxcXFxkaWFtb25kXCIsXCLil4ZcIjpcIlxcXFxkaWFtb25kXCIsXCLil4VcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKXhFwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peDXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLil4JcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKXgVwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peAXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLilr9cIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIuKWvlwiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwi4pa9XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCLilrxcIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIuKWuVwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWuFwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWt1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWtlwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWtVwiOlwiXFxcXHRyaWFuZ2xlXCIsXCLilrRcIjpcIlxcXFx0cmlhbmdsZVwiLFwi4pazXCI6XCJcXFxcdHJpYW5nbGVcIixcIuKWsVwiOlwiXFxcXHNxdWFyZVwiLFwi4pawXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKWr1wiOlwiXFxcXHNxdWFyZVwiLFwi4pauXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKWrVwiOlwiXFxcXHNxdWFyZVwiLFwi4parXCI6XCJcXFxcc3F1YXJlXCIsXCLilqpcIjpcIlxcXFxzcXVhcmVcIixcIuKWoVwiOlwiXFxcXHNxdWFyZVwiLFwi4pagXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKLrVwiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLii6xcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0XCIsXCLii6tcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwi4ouqXCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdFwiLFwi4ouZXCI6XCJcXFxcZ2dnXCIsXCLii5hcIjpcIlxcXFxsbGxcIixcIuKLl1wiOlwiKj5cIixcIuKLllwiOlwiPCpcIixcIuKLlFwiOlwiXFxcXHBpdGNoZm9ya1wiLFwi4ouMXCI6XCJcIixcIuKLi1wiOlwiXFxcXGJvd3RpZVwiLFwi4ouKXCI6XCJcXFxcbHRpbWVzXCIsXCLii4lcIjpcIlxcXFxydGltZXNcIixcIuKKtVwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIlxcXFx0cmlhbmdsZWxlZnRcIjpcIlwiLFwi4oqlXCI6XCJcXFxcYm90XCIsXCLiioFcIjpcIlxcXFxuc3VjY1wiLFwi4oqAXCI6XCJcXFxccHJlY2VxXCIsXCLiib1cIjpcIlxcXFxzdWNjZXFcIixcIuKJvFwiOlwiXFxcXHByZWNlcVwiLFwi4om7XCI6XCJcXFxcc3VjY1wiLFwi4om6XCI6XCJcXFxccHJlY1wiLFwi4omxXCI6XCJcXFxcZ2VxL1wiLFwi4omwXCI6XCJcXFxcbGVxL1wiLFwi4omtXCI6XCJcXFxcbmVxXCIsXCLiiavMuFwiOlwiXFxcXG5vdFxcXFxnZ1wiLFwi4omrXCI6XCJcXFxcZ2dcIixcIuKJqsy4XCI6XCJcXFxcbm90XFxcXGxsXCIsXCLiiapcIjpcIlxcXFxsbFwiLFwi4ompXCI6XCJcXFxcbmdlcXNsYW50XCIsXCLiiahcIjpcIlxcXFxubGVxc2xhbnRcIixcIuKJoVwiOlwiXFxcXGVxdWl2XCIsXCLiiZ9cIjpcIlxcXFxkb3RlcVwiLFwi4omcXCI6XCJcXFxcdHJpYW5nbGVxXCIsXCLiiZtcIjpcIlxcXFxkb3RlcVwiLFwi4omaXCI6XCJcXFxcdHJpYW5nbGVxXCIsXCLiiZlcIjpcIlxcXFx0cmlhbmdsZXFcIixcIuKJl1wiOlwiXFxcXGRvdGVxXCIsXCLiiZRcIjpcIjo9XCIsXCLiiY1cIjpcIlxcXFxhc3ltcFwiLFwi4omHXCI6XCJcXFxcbmNvbmdcIixcIuKJhlwiOlwiXFxcXG5jb25nXCIsXCLiiYVcIjpcIlxcXFxjb25nXCIsXCLiiYRcIjpcIlxcXFxub3RcXFxcc2ltZXFcIixcIuKJg1wiOlwiXFxcXHNpbWVxXCIsXCLiiYFcIjpcIlxcXFxub3RcXFxcc2ltXCIsXCLiiKZcIjpcIlxcXFxub3RcXFxccGFyYWxsZWxcIixcIuKIpVwiOlwiXFxcXHBhcmFsbGVsXCIsXCLiiKRcIjpcIlxcXFxub3R8XCIsXCLiiJ1cIjpcIlxcXFxwcm9wdG9cIixcIj09XCI6XCI9PVwiLFwiPVwiOlwiPVwiLFwiOj1cIjpcIjo9XCIsXCIvPVwiOlwiPVwiLFwiLT1cIjpcIi09XCIsXCIrPVwiOlwiKz1cIixcIio9XCI6XCIqPVwiLFwiIT1cIjpcIiE9XCIsXCLiiaBcIjpcIlxcXFxuZXFcIixcIuKJolwiOlwiXFxcXGVxdWl2IC9cIixcIuKJiVwiOlwiXFxcXGFwcHJveCAvXCIsXCLiiLxcIjpcInNpbVwiLFwi4omIXCI6XCJcXFxcYXBwcm94XCIsXCLiia5cIjpcIjwvXCIsXCI8XCI6XCI8XCIsXCLiia9cIjpcIj4vXCIsXCI+PVwiOlwiPj1cIixcIj5cIjpcIj5cIixcIuKJpVwiOlwiXFxcXGdlcVwiLFwi4omkXCI6XCJcXFxcbGVxXCIsXCI8PVwiOlwiPD1cIixcIuKKi1wiOlwiXFxcXHN1cHNldG5lcVwiLFwi4oqKXCI6XCJcXFxcc3Vic2V0bmVxXCIsXCLiiolcIjpcIlxcXFxuc3Vwc2V0ZXFcIixcIuKKiFwiOlwiXFxcXG5zdWJzZXRlcVwiLFwi4oqHXCI6XCJcXFxcc3Vwc2V0ZXFcIixcIuKKhlwiOlwiXFxcXHN1YnNldGVxXCIsXCLiioVcIjpcIlxcXFxub3RcXFxcc3Vwc2V0XCIsXCLiioRcIjpcIlxcXFxub3RcXFxcc3Vic2V0XCIsXCLiioPig5JcIjpcIlxcXFxzdXBzZXQgfFwiLFwi4oqDXCI6XCJcXFxcc3Vwc2V0XCIsXCLiioLig5JcIjpcIlxcXFxzdWJzZXQgfFwiLFwi4oqCXCI6XCJcXFxcc3Vic2V0XCIsXCLiiIxcIjpcIlxcXFxub3RcXFxcaW5cIixcIuKIiVwiOlwiXFxcXG5vdGluXCIsXCLiiIhcIjpcIlxcXFxpblwiLFwi4oiBXCI6XCJDXCIsXCLiiIRcIjpcIlxcXFxuZXhpc3RzXCIsXCLiiINcIjpcIlxcXFxleGlzdHNcIixcIuKIgFwiOlwiXFxcXGZvcmFsbFwiLFwi4oinXCI6XCJcXFxcbGFuZFwiLFwiJiZcIjpcIlxcXFwmXFxcXCZcIixcIuKIqFwiOlwiXFxcXGxvclwiLFwi4oqvXCI6XCJcXFxcY2FuY2Vse1xcXFx2RGFzaH1cIixcIuKKrlwiOlwiXFxcXGNhbmNlbHtcXFxcVmRhc2h9XCIsXCLiiq1cIjpcIlxcXFxudkRhc2hcIixcIuKKrFwiOlwiXFxcXG52RGFzaFwiLFwi4oqpXCI6XCJcXFxcVmRhc2hcIixcIuKKqFwiOlwiXFxcXHZEYXNoXCIsXCLiiqRcIjpcIlxcXFx0b3BcIixcIuKKo1wiOlwiXFxcXGRhc2h2XCIsXCLiiqJcIjpcIlxcXFx2ZGFzaFwiLFwi4oiLXCI6XCJcXFxcbmlcIixcIuKLsVwiOlwiXFxcXGRkb3RzXCIsXCLii69cIjpcIlxcXFxoZG90c1wiLFwi4ouuXCI6XCJcXFxcdmRvdHNcIixcIs+2XCI6XCJcXFxcbmlcIixcIjpcIjpcIjpcIixcIi4uLlwiOlwiXFxcXGNkb3RzXCIsXCIuLlwiOlwiLi5cIixcIi0+XCI6XCItPlwiLFwi4oi1XCI6XCJcXFxcYmVjYXVzZVwiLFwi4oi0XCI6XCJcXFxcdGhlcmVmb3JlIFwiLFwi4oGjXCI6XCJcXFxcbGxicmFja2V0XCIsXCIsXCI6XCIsXCIsXCI7XCI6XCI7XCIsXCLip71cIjpcIlxcXFx9XCIsXCLip7xcIjpcIlxcXFx7XCIsXCLipphcIjpcIlxcXFxdXCIsXCLippdcIjpcIlxcXFxbXCIsXCLippZcIjpcIlxcXFxsbFwiLFwi4qaVXCI6XCJcXFxcZ2dcIixcIuKmlFwiOlwiXFxcXGdnXCIsXCLippNcIjpcIlxcXFxsbFwiLFwi4qaSXCI6XCJcXFxcZ2dcIixcIuKmkVwiOlwiXFxcXGxsXCIsXCLippBcIjpcIlxcXFxdXCIsXCLipo9cIjpcIlxcXFxdXCIsXCLipo5cIjpcIlxcXFxdXCIsXCLipo1cIjpcIlxcXFxbXCIsXCLipoxcIjpcIlxcXFxbXCIsXCLipotcIjpcIlxcXFxdXCIsXCLipopcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLipolcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKmiFwiOlwifFxcXFwpXCIsXCLipodcIjpcIlxcXFwofFwiLFwi4qaGXCI6XCJ8XFxcXClcIixcIuKmhVwiOlwiXFxcXChcXFxcKFwiLFwi4qaEXCI6XCJ8XFxcXH1cIixcIuKmg1wiOlwiXFxcXHt8XCIsXCLipoBcIjpcIlxcXFx8fFwiLFwi4p+vXCI6XCJcXFxcbGVmdC4gXFxcXHJpZ2h0XVwiLFwi4p+uXCI6XCJcXFxcbGVmdFsgXFxcXHJpZ2h0LlwiLFwi4p+tXCI6XCJcXFxcbGVmdC4gXFxcXHJpZ2h0XV1cIixcIuKfrFwiOlwiXFxcXGxlZnRbWyBcXFxccmlnaHQuXCIsXCLin6tcIjpcIlxcXFxnZ1wiLFwi4p+qXCI6XCJcXFxcbGxcIixcIuKfp1wiOlwiXFxcXCl8XCIsXCLin6ZcIjpcIlxcXFwofFwiLFwi4p2zXCI6XCJcXFxcbGVmdC5cXFxccmlnaHQpXCIsXCLinbJcIjpcIlxcXFxsZWZ0KFxcXFxyaWdodC5cIixcIuKMqlwiOlwiXFxcXHJhbmdsZVwiLFwi4oypXCI6XCJcXFxcbGFuZ2xlXCIsXCLijItcIjpcIlxcXFxyZmxvb3JcIixcIuKMilwiOlwiXFxcXGxmbG9vclwiLFwi4oyJXCI6XCJcXFxccmNlaWxcIixcIuKMiFwiOlwiXFxcXGxjZWlsXCIsXCLigJZcIjpcIlxcXFxwYXJhbGxlbFwiLFwifVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0fVwiLFwie1wiOlwiXFxcXGxlZnR7XFxcXHJpZ2h0LlwiLFwiXVwiOlwiXFxcXGxlZnRdXFxcXHJpZ2h0LlwiLFwiW1wiOlwiXFxcXGxlZnRbXFxcXHJpZ2h0LlwiLFwiKVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0KVwiLFwiKFwiOlwiXFxcXGxlZnQoXFxcXHJpZ2h0LlwiLFwi4oCdXCI6J1xcXFxcIicsXCLigJxcIjpcIlxcXFx0ZXh0e2BgfVwiLFwi4oCZXCI6XCInXCIsXCLigJhcIjpcImBcIizOsTpcIlxcXFxhbHBoYVwiLM6yOlwiXFxcXGJldGFcIizOszpcIlxcXFxnYW1tYVwiLM6TOlwiXFxcXEdhbW1hXCIszrQ6XCJcXFxcZGVsdGFcIizOlDpcIlxcXFxEZWx0YVwiLM+1OlwiXFxcXGVwc2lsb25cIizOtjpcIlxcXFx6ZXRhXCIszrc6XCJcXFxcZXRhXCIszrg6XCJcXFxcdGhldGFcIizOmDpcIlxcXFxUaGV0YVwiLM65OlwiXFxcXGlvdGFcIizOujpcIlxcXFxrYXBwYVwiLM67OlwiXFxcXGxhbWJkYVwiLM69OlwiXFxcXG51XCIszr86XCJcXFxcb21pY3JvblwiLM+AOlwiXFxcXHBpXCIszqA6XCJcXFxcUGlcIizPgTpcIlxcXFxyaG9cIizPgzpcIlxcXFxzaWdtYVwiLM6jOlwiXFxcXFNpZ21hXCIsz4Q6XCJcXFxcdGF1XCIsz4U6XCJcXFxcdXBzaWxvblwiLM6lOlwiXFxcXFVwc2lsb25cIizPlTpcIlxcXFxwaGlcIizOpjpcIlxcXFxQaGlcIizPhzpcIlxcXFxjaGlcIizPiDpcIlxcXFxwc2lcIizOqDpcIlxcXFxQc2lcIizPiTpcIlxcXFxvbWVnYVwiLM6pOlwiXFxcXE9tZWdhXCIs4oSmOlwiXFxcXE9tZWdhXCIsXCLiiIVcIjpcIlxcXFxlbXB0eXNldFwiLFwi4p+yXCI6XCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsXCLin7NcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCLDl1wiOlwiXFxcXHRpbWVzXCIsXCLCvVwiOlwiXFxcXGRmcmFjezF9ezJ9XCIszrw6XCJcXFxcbXVcIizTqDpcIlxcXFx0aGV0YVwiLFwi4pyTXCI6XCJcXFxcY2hlY2ttYXJrXCIsXCLin6lcIjpcIlxcXFxyYW5nbGVcIixcIuKfqFwiOlwiXFxcXGxhbmdsZVwiLFwiwrxcIjpcIlxcXFxkZnJhY3sxfXs0fVwiLFwi4oCmXCI6XCJcXFxcbGRvdHNcIizihI86XCJcXFxcaGJhclwiLOKEnDpcIlxcXFxtYXRoZnJha3tSfVwiLNGyOlwiXFxcXHRoZXRhXCIsw5g6XCJcXFxcZW1wdHlzZXRcIizPsTpcIlxcXFx2YXJyaG9cIizRhDpcIlxcXFxwaGlcIizihIc6XCJcXFxcdmFyZXBzaWxvblwiLFQ6XCJUXCIsXCLiiJlcIjpcIlxcXFxjZG90XCIszqE6XCJQXCIsXCLiiJ5cIjpcIlxcXFxpbmZ0eVwiLOGQgTpcIlxcXFxuYWJsYVwiLMaeOlwiXFxcXGV0YVwiLFwi4oG6XCI6XCJeeyt9XCIsXCLigbtcIjpcIl57LX1cIixcIuKBvFwiOlwiXns9fVwiLFwi4oG9XCI6XCJeeyh9XCIsXCLigb5cIjpcIl57KX1cIixcIuOAl1wiOlwiXFxcXCl8XCIsXCLjgJZcIjpcIlxcXFxsYW5nbGVcIixcIs2+XCI6XCI7XCIsXCLgtaZcIjpcIlxcXFxjaXJjXCIsXCLilLRcIjpcIlxcXFxwZXJwXCIsXCLinJVcIjpcIlxcXFx0aW1lc1wiLFwi4o67XCI6XCItXCIsXCLCu1wiOlwiXFxcXGdnXCIsXCLirIZcIjpcIlxcXFx1cGFycm93XCIsXCLirIdcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKshVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4p6hXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4o68XCI6XCItXCIsXCLijpxcIjpcIlxcXFxtaWRcIixcIuKOpVwiOlwiXFxcXG1pZFwiLMSnOlwiXFxcXGhiYXJcIixcIuKulVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuODu1wiOlwiXFxcXGNkb3RcIixcIsKmXCI6XCJcXFxcbWlkXCIsXCLCo1wiOlwiXFxcXHBvdW5kc1wiLFwiwqVcIjpcIlxcXFx5ZW5cIixcIuKcl1wiOlwiXFxcXHRpbWVzXCIsXCLinJRcIjpcIlxcXFxjaGVja21hcmtcIizigb86XCJee259XCIsXCLCq1wiOlwiXFxcXGxsXCIs4LmAOlwiXFxcXHByaW1lXCIsXCLigKBcIjpcIlxcXFxkYWdnZXJcIixcIuKUglwiOlwiXFxcXG1pZFwiLCQ6XCJcXFxcJFwiLFwiI1wiOlwiXFxcXCNcIixcIuKEg1wiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgQ31cIixcIuKEiVwiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgRn1cIixcIuKWiFwiOlwiXFxcXGJsYWNrc3F1YXJlXCIsXCLihKdcIjpcIlxcXFxtaG9cIizihYc6XCJcXFxcdGV4dHtlfVwiLMm8OlwiclwiLFwi4oChXCI6XCJcXFxcZGRhZ2dlclwiLOG8sTpcImlcIizPkjpcIlxcXFxVcHNpbG9uXCIs8J2bvzpcIlxcXFxkZWx0YVwiLFwiy7NcIjpcIlxcXFxjZG90XCIs0bM6XCJcXFxcdGhldGFcIizwnZyZOlwiXFxcXHBoaVwiLNCfOlwiXFxcXHByb2RcIizQvjpcIm9cIizRkjpcIlxcXFxoYmFyXCIsyYU6XCJcXFxcTGFtYmRhXCIsXCLgpaRcIjpcIlxcXFxtaWRcIixcIuKCrFwiOlwiXFxcXGV1cm9cIizhv6E6XCJcXFxcYmFye3V9XCIsz4Y6XCJcXFxcdmFycGhpXCIsyLw6XCJjXCIs8J2erjpcIlxcXFxlcHNpbG9uXCIszqc6XCJcXFxcbWF0aHNme1h9XCIs4oKZOlwiX3tufVwifX0sODI0OTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYWxsTWF0aFN5bWJvbHNCeUNoYXI9dm9pZCAwLHQuYWxsTWF0aFN5bWJvbHNCeUNoYXI9e1wiJiN4QTA7XCI6XCJcXFxcdGV4dHJteyB9XCIsXCImI3gyMjAzO1wiOlwiXFxcXGV4aXN0c1wiLFwiJiN4MjIwMDtcIjpcIlxcXFxmb3JhbGxcIixcIiYjeDIxRDQ7XCI6XCJcXFxcaWZmXCIsXCImI3gyMUQyO1wiOlwiPT5cIixcIiYjeEFDO1wiOlwiXFxcXG5lZ1wiLFwiJiN4MjEyNDtcIjpcIlxcXFxtYXRoYmJ7Wn1cIixcIiYjeDIxMUQ7XCI6XCJcXFxcbWF0aGJie1J9XCIsXCImI3gyMTFBO1wiOlwiXFxcXG1hdGhiYntRfVwiLFwiJiN4MjExNTtcIjpcIlxcXFxtYXRoYmJ7Tn1cIixcIiYjeDIxMDI7XCI6XCJDQ1wiLFwiJiN4MjVBMTtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIyQzQ7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjVCMztcIjpcIlxcXFx0cmlhbmdsZVwiLFwiJiN4MjMyMjtcIjpcIlxcXFxmcm93blwiLFwiJiN4MjIyMDtcIjpcIlxcXFxhbmdsZVwiLFwiJiN4MjJGMTtcIjpcIlxcXFxkZG90c1wiLFwiJiN4MjJFRTtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4MjIzNTtcIjpcIlxcXFxiZWNhdXNlXCIsXCImI3gyMjM0O1wiOlwiXFxcXHRoZXJlZm9yZVwiLFwiJiN4MjEzNTtcIjpcIlxcXFxhbGVwaFwiLFwiJiN4MjIwNTtcIjpcIlxcXFxvc2xhc2hcIixcIiYjeEIxO1wiOlwiXFxcXHBtXCIsXCImI3gyMjA3O1wiOlwiXFxcXG5hYmxhXCIsXCImI3gyMjAyO1wiOlwiXFxcXHBhcnRpYWxcIixcIiYjeDIyMkU7XCI6XCJcXFxcb2ludFwiLFwiJiN4MjIyQjtcIjpcIlxcXFxpbnRcIixcIiYjeDIyQzM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMjJBO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjJDMjtcIjpcIlxcXFxjYXBcIixcIiYjeDIyMjk7XCI6XCJcXFxcY2FwXCIsXCImI3gyMkMxO1wiOlwiXFxcXHZlZVwiLFwiJiN4MjIyODtcIjpcIlxcXFx2ZWVcIixcIiYjeDIyQzA7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDIyMjc7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDIyMEY7XCI6XCJcXFxccHJvZFwiLFwiJiN4MjIxMTtcIjpcIlxcXFxzdW1cIixcIiYjeDIyOTk7XCI6XCJcXFxcYmlnb2RvdFwiLFwiJiN4MjI5NztcIjpcIlxcXFxiaWdvcGx1c1wiLFwiJiN4MjI5NTtcIjpcIm8rXCIsXCImI3gyMjE4O1wiOlwiQFwiLFwiJiN4MjJDODtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDIyQ0E7XCI6XCJcXFxccnRpbWVzXCIsXCImI3gyMkM5O1wiOlwiXFxcXGx0aW1lc1wiLFwiJiN4Rjc7XCI6XCJcXFxcZGl2XCIsXCImI3hENztcIjpcIlxcXFx0aW1lc1wiLFwiXFxcXFwiOlwiXFxcXGJhY2tzbGFzaFwiLFwiJiN4MjJDNjtcIjpcIlxcXFxzdGFyXCIsXCImI3gyMjE3O1wiOlwiXFxcXHN0YXJcIixcIiYjeDIyQzU7XCI6XCJcXFxcY2RvdFwiLFwiJiN4M0E5O1wiOlwiXFxcXE9tZWdhXCIsXCImI3gzQzk7XCI6XCJcXFxcb21lZ2FcIixcIiYjeDNBODtcIjpcIlxcXFxQc2lcIixcIiYjeDNDODtcIjpcIlxcXFxwc2lcIixcIiYjeDNDNztcIjpcIlxcXFxjaGlcIixcIiYjeDNDNjtcIjpcIlxcXFx2YXJwaGlcIixcIiYjeDNBNjtcIjpcIlxcXFxQaGlcIixcIiYjeDNENTtcIjpcIlxcXFxwaGlcIixcIiYjeDNDNTtcIjpcIlxcXFx1cHNpbG9uXCIsXCImI3gzQzQ7XCI6XCJcXFxcdGF1XCIsXCImI3gzQTM7XCI6XCJcXFxcU2lnbWFcIixcIiYjeDNDMztcIjpcIlxcXFxzaWdtYVwiLFwiJiN4M0MxO1wiOlwiXFxcXHJob1wiLFwiJiN4M0EwO1wiOlwiXFxcXFBpXCIsXCImI3gzQzA7XCI6XCJcXFxccGlcIixcIiYjeDM5RTtcIjpcIlxcXFxYaVwiLFwiJiN4M0JFO1wiOlwiXFxcXHhpXCIsXCImI3gzQkQ7XCI6XCJcXFxcbnVcIixcIiYjeDNCQztcIjpcIlxcXFxtdVwiLFwiJiN4MzlCO1wiOlwiXFxcXExhbWJkYVwiLFwiJiN4M0JCO1wiOlwiXFxcXGxhbWJkYVwiLFwiJiN4M0JBO1wiOlwiXFxcXGthcHBhXCIsXCImI3gzQjk7XCI6XCJcXFxcaW90YVwiLFwiJiN4M0QxO1wiOlwiXFxcXHZhcnRoZXRhXCIsXCImI3gzOTg7XCI6XCJcXFxcVGhldGFcIixcIiYjeDNCODtcIjpcIlxcXFx0aGV0YVwiLFwiJiN4M0I3O1wiOlwiXFxcXGV0YVwiLFwiJiN4M0I2O1wiOlwiXFxcXHpldGFcIixcIiYjeDI1QjtcIjpcIlxcXFx2YXJlcHNpbG9uXCIsXCImI3gzQjU7XCI6XCJcXFxcZXBzaWxvblwiLFwiJiN4Mzk0O1wiOlwiXFxcXERlbHRhXCIsXCImI3gzQjQ7XCI6XCJcXFxcZGVsdGFcIixcIiYjeDM5MztcIjpcIlxcXFxHYW1tYVwiLFwiJiN4M0IzO1wiOlwiXFxcXGdhbW1hXCIsXCImI3gzQjI7XCI6XCJcXFxcYmV0YVwiLFwiJiN4M0IxO1wiOlwiXFxcXGFscGhhXCIsXCImI3gyMjFFO1wiOlwiXFxcXGluZnR5XCIsXCLigKxcIjpcIlxcXFx0ZXh0e1xcXFx0ZXh0ZGlyIFRSVH1cIixcIuKAjlwiOlwiXFxcXHRleHR7XFxcXHRleHRkaXIgTFRSfVwifX0sODE3MTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYWxsTWF0aFN5bWJvbHNCeUdseXBoPXZvaWQgMCx0LmFsbE1hdGhTeW1ib2xzQnlHbHlwaD17XCIgXCI6XCJcXFxcdGV4dHJteyB9XCIsXCLiiINcIjpcIlxcXFxleGlzdHNcIixcIuKIgFwiOlwiXFxcXGZvcmFsbFwiLFwi4oeUXCI6XCJcXFxcaWZmXCIsXCLih5JcIjpcIlxcXFxSaWdodGFycm93XCIsXCLCrFwiOlwiXFxcXG5lZ1wiLFwi4pahXCI6XCJcXFxcc3F1YXJlXCIsXCLii4RcIjpcIlxcXFxkaWFtb25kXCIsXCLilrNcIjpcIlxcXFx0cmlhbmdsZVwiLFwi4oyiXCI6XCJcXFxcZnJvd25cIixcIuKIoFwiOlwiXFxcXGFuZ2xlXCIsXCLii7FcIjpcIlxcXFxkZG90c1wiLFwi4ouuXCI6XCJcXFxcdmRvdHNcIixcIuKItVwiOlwiXFxcXGJlY2F1c2VcIixcIuKItFwiOlwiXFxcXHRoZXJlZm9yZVwiLOKEtTpcIlxcXFxhbGVwaFwiLFwi4oiFXCI6XCJcXFxcZW1wdHlzZXRcIixcIsKxXCI6XCJcXFxccG1cIixcIuKIh1wiOlwiXFxcXG5hYmxhXCIsXCLiiIJcIjpcIlxcXFxwYXJ0aWFsXCIsXCLiiK5cIjpcIlxcXFxvaW50XCIsXCLiiKtcIjpcIlxcXFxpbnRcIixcIuKLg1wiOlwiXFxcXGN1cFwiLFwi4oiqXCI6XCJcXFxcY3VwXCIsXCLii4JcIjpcIlxcXFxjYXBcIixcIuKIqVwiOlwiXFxcXGNhcFwiLFwi4ouBXCI6XCJcXFxcdmVlXCIsXCLiiKhcIjpcIlxcXFx2ZWVcIixcIuKLgFwiOlwiXFxcXHdlZGdlXCIsXCLiiKdcIjpcIlxcXFx3ZWRnZVwiLFwi4oiPXCI6XCJcXFxccHJvZFwiLFwi4oiRXCI6XCJcXFxcc3VtXCIsXCLiiplcIjpcIlxcXFxiaWdvZG90XCIsXCLiipdcIjpcIlxcXFxiaWdvcGx1c1wiLFwi4oqVXCI6XCJvK1wiLFwi4oiYXCI6XCJAXCIsXCLii4hcIjpcIlxcXFxib3d0aWVcIixcIuKLilwiOlwiXFxcXHJ0aW1lc1wiLFwi4ouJXCI6XCJcXFxcbHRpbWVzXCIsXCLDt1wiOlwiXFxcXGRpdlwiLFwiw5dcIjpcIlxcXFx0aW1lc1wiLFwiXFxcXFwiOlwiXFxcXGJhY2tzbGFzaFwiLFwi4ouGXCI6XCJcXFxcc3RhclwiLFwi4oiXXCI6XCJcXFxcc3RhclwiLFwi4ouFXCI6XCJcXFxcY2RvdFwiLM6pOlwiXFxcXE9tZWdhXCIsz4k6XCJcXFxcb21lZ2FcIizOqDpcIlxcXFxQc2lcIizPiDpcIlxcXFxwc2lcIizPhzpcIlxcXFxjaGlcIizPhjpcIlxcXFx2YXJwaGlcIizOpjpcIlxcXFxQaGlcIizPlTpcIlxcXFxwaGlcIizPhTpcIlxcXFx1cHNpbG9uXCIsz4Q6XCJcXFxcdGF1XCIszqM6XCJcXFxcU2lnbWFcIizPgzpcIlxcXFxzaWdtYVwiLM+BOlwiXFxcXHJob1wiLM6gOlwiXFxcXFBpXCIsz4A6XCJcXFxccGlcIizOnjpcIlxcXFxYaVwiLM6+OlwiXFxcXHhpXCIszr06XCJcXFxcbnVcIizOvDpcIlxcXFxtdVwiLM6bOlwiXFxcXExhbWJkYVwiLM67OlwiXFxcXGxhbWJkYVwiLM66OlwiXFxcXGthcHBhXCIszrk6XCJcXFxcaW90YVwiLM+ROlwiXFxcXHZhcnRoZXRhXCIszpg6XCJcXFxcVGhldGFcIizOuDpcIlxcXFx0aGV0YVwiLM63OlwiXFxcXGV0YVwiLM62OlwiXFxcXHpldGFcIizJmzpcIlxcXFx2YXJlcHNpbG9uXCIszrU6XCJcXFxcZXBzaWxvblwiLM6UOlwiXFxcXERlbHRhXCIszrQ6XCJcXFxcZGVsdGFcIizOkzpcIlxcXFxHYW1tYVwiLM6zOlwiXFxcXGdhbW1hXCIszrI6XCJcXFxcYmV0YVwiLM6xOlwiXFxcXGFscGhhXCIsXCLiiJ5cIjpcIlxcXFxpbmZ0eVwiLM+1OlwiXFxcXGVwc2lsb25cIizCtTpcIlxcXFxtdVwiLFwiwrJcIjpcIl57Mn1cIizEsTpcIlxcXFxpbWF0aFwiLFwi4oiOXCI6XCJcXFxcYmxhY2tzcXVhcmVcIizguKE6XCJcXFxcbWF0aGJme219XCIs4oSmOlwiXFxcXE9tZWdhXCIsXCLin7JcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKfs1wiOlwiXFxcXGNpcmNsZWFycm93cmlnaHRcIizgpKQ6XCIgXCIsXCLCpVwiOlwiXFxcXHllblwiLFwi4oG9XCI6XCJeeyh9XCIsXCLigb5cIjpcIl57KX1cIizDnzpcIlxcXFxzc1wiLNCLOlwiXFxcXGhiYXJcIixcIuKmtVwiOlwiXFxcXG9taW51c1wiLFwi4oq/XCI6XCJcXFxcYmlndHJpYW5nbGV1cFwiLFwi4oabJ1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCLigKBcIjpcIlxcXFxkYWdnZXJcIizguYA6XCJcXFxccHJpbWVcIiznmb06XCIgXCIsXCLiv7FcIjpcIiBcIizihLg6XCJcXFxcd3BcIiztk7A6XCIgXCIs4oG/OlwiXntufVwiLFwi4pyUXCI6XCJcXFxcY2hlY2ttYXJrXCIsXCLinJdcIjpcIlxcXFx0aW1lc1wiLFwiwr1cIjpcIlxcXFxkZnJhY3sxfXsyfVwiLNOoOlwiXFxcXHRoZXRhXCIsXCLinJNcIjpcIlxcXFxjaGVja21hcmtcIixcIuKfqVwiOlwiXFxcXHJhbmdsZVwiLFwi4p+oXCI6XCJcXFxcbGFuZ2xlXCIsXCLijKlcIjpcIlxcXFxsYW5nbGVcIixcIsK8XCI6XCJcXFxcZGZyYWN7MX17NH1cIixcIuKAplwiOlwiXFxcXGxkb3RzXCIs4oSPOlwiXFxcXGhiYXJcIizihJw6XCJcXFxcbWF0aGZyYWt7Un1cIizRsjpcIlxcXFx0aGV0YVwiLMOYOlwiXFxcXGVtcHR5c2V0XCIsz7E6XCJcXFxcdmFycmhvXCIs0YQ6XCJcXFxccGhpXCIsVDpcIlRcIixcIuKImVwiOlwiXFxcXGNkb3RcIizOoTpcIlBcIizhkIE6XCJcXFxcbmFibGFcIizGnjpcIlxcXFxldGFcIizJozpcIlxcXFxnYW1tYVwiLNGbOlwiXFxcXGhiYXJcIizGkDpcIlxcXFx2YXJlcHNpbG9uXCIs4oWFOlwiXFxcXF97RH1cIizwnZyGOlwiXFxcXGxhbWJkYVwiLFwi44CXXCI6XCJcXFxccmFuZ2xlXCIsXCLjgJZcIjpcIlxcXFxsYW5nbGVcIixcIs2+XCI6XCI7XCIs8J2RpTpcInhcIizwnZGmOlwieVwiLPCdkac6XCJ6XCIs8J2RljpcImlcIizwnZGXOlwialwiLPCdkZg6XCJrXCIs8J2RmjpcIm1cIizwnZGSOlwiZVwiLPCdkZ86XCJyXCIsybM6XCJcXFxcZXRhXCIs8J2bvTpcIlxcXFxiZXRhXCIsXCLijbVcIjpcIlxcXFxvbWVnYVwiLOKEmDpcIlxcXFx3cFwiLPCdnIs6XCJcXFxccGlcIizQhDpcIlxcXFxlcHNpbG9uXCIs0ZQ6XCJcXFxcZXBzaWxvblwiLPCdnIA6XCJcXFxcZXBzaWxvblwiLNC/OlwiXFxcXHBpXCIszp06XCJcXFxcbnVcIizJtTpcIlxcXFx0aGV0YVwiLPCdnJM6XCJcXFxccHNpXCIsz7Q6XCJcXFxcdGhldGFcIizJuDpcIlxcXFxwaGlcIizTtjpcIlxcXFxHYW1tYVwiLMmtOlwiXFxcXGVsbFwiLMqLOlwiXFxcXHVwc2lsb25cIizwnZufOlwiXFxcXHZhcnBoaVwiLFwi4o2sXCI6XCJcXFxcdGhldGFcIizQpDpcIlxcXFxQaGlcIizwnZyROlwiXFxcXHZhcnBoaVwiLOKFiDpcImlcIizOvzpcIm9cIizGoTpcIm9cIizGkjpcImZcIixcIuKNtFwiOlwiXFxcXHJob1wiLFwi8J+HvVwiOlwieFwiLPCdkZ06XCJwXCIs8J2RnjpcInFcIizwnZGgOlwic1wiLPCdkaE6XCJ0XCIs8J2RojpcInVcIizwnZGjOlwidlwiLPCdkaQ6XCJ3XCIs8J2RjjpcImFcIizwnZGPOlwiYlwiLPCdkZA6XCJjXCIs8J2RkTpcImRcIizwnZGTOlwiZlwiLPCdkZQ6XCJnXCIs8J2RmTpcImxcIizwnZGbOlwiblwiLPCdkZw6XCJvXCIs8J2UgDpcIndcIizwnZqfOlwidlwiLOG5gTpcIm1cIixcIuC1plwiOlwiXFxcXGNpcmNcIixcIuKUtFwiOlwiXFxcXHBlcnBcIixcIuKclVwiOlwiXFxcXHRpbWVzXCIsXCLiiKNcIjpcIlxcXFxtaWRcIizVkzpcIlxcXFxQaGlcIixcIuKOnFwiOlwiXFxcXG1pZFwiLMSnOlwiXFxcXGhiYXJcIizhjYg6XCIgXCIsXCLipqhcIjpcIlxcXFxsbGJyYWNrZXRcIizhur86XCJcXFxcaGF0e2V9XCIsXCLColwiOlwiXFxcXGNlbnRcIixcIuKkuVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qS4XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLdcIjpcIlxcXFxSc2hcIixcIuKktlwiOlwiXFxcXExzaFwiLFwi4qS1XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLRcIjpcIlxcXFx1cGFycm93XCIsXCLipLNcIjpcIlxcXFxyaWdodGFycm93XCIsXCJ8XCI6XCJcXFxcbWlkXCIsXCLijqVcIjpcIlxcXFxtaWRcIixcIuKZpVwiOlwiXFxcXGhlYXJ0c3VpdFwiLNCeOlwiMFwiLM6lOlwiWVwiLNGFOlwieFwiLPCdk486XCJ6XCIs8J2TjjpcInlcIizwnZONOlwieFwiLNGAOlwicFwiLNCwOlwiYVwiLFwiwqNcIjpcIlxcXFxwb3VuZHNcIixtOlwibVwiLPCdmrU6XCJcXFxcWGlcIixcIuKTqlwiOlwiXFxcXHRleHRjaXJjbGVkezB9XCIsXCLikaBcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxfVwiLFwi4pGhXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mn1cIixcIuKRolwiOlwiXFxcXHRleHRjaXJjbGVkezN9XCIsXCLikaNcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0fVwiLFwi4pGkXCI6XCJcXFxcdGV4dGNpcmNsZWR7NX1cIixcIuKRpVwiOlwiXFxcXHRleHRjaXJjbGVkezZ9XCIsXCLikaZcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs3fVwiLFwi4pGnXCI6XCJcXFxcdGV4dGNpcmNsZWR7OH1cIixcIuKRqFwiOlwiXFxcXHRleHRjaXJjbGVkezl9XCIsXCLikalcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMH1cIixcIuKRqlwiOlwiXFxcXHRleHRjaXJjbGVkezExfVwiLFwi4pGrXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTJ9XCIsXCLikaxcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxM31cIixcIuKRrVwiOlwiXFxcXHRleHRjaXJjbGVkezE0fVwiLFwi4pGuXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTV9XCIsXCLika9cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNn1cIixcIuKRsFwiOlwiXFxcXHRleHRjaXJjbGVkezE3fVwiLFwi4pGxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTh9XCIsXCLikbJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOX1cIixcIuKRs1wiOlwiXFxcXHRleHRjaXJjbGVkezIwfVwiLFwi44mRXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjF9XCIsXCLjiZJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMn1cIixcIuOJk1wiOlwiXFxcXHRleHRjaXJjbGVkezIzfVwiLFwi44mUXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjR9XCIsXCLjiZVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNX1cIixcIuOJllwiOlwiXFxcXHRleHRjaXJjbGVkezI2fVwiLFwi44mXXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjd9XCIsXCLjiZhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyOH1cIixcIuOJmVwiOlwiXFxcXHRleHRjaXJjbGVkezI5fVwiLFwi44maXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzB9XCIsXCLjiZtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMX1cIixcIuOJnFwiOlwiXFxcXHRleHRjaXJjbGVkezMyfVwiLFwi44mdXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzN9XCIsXCLjiZ5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNH1cIixcIuOJn1wiOlwiXFxcXHRleHRjaXJjbGVkezM1fVwiLFwi44qxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzZ9XCIsXCLjirJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszN31cIixcIuOKs1wiOlwiXFxcXHRleHRjaXJjbGVkezM4fVwiLFwi44q0XCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzl9XCIsXCLjirVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0MH1cIixcIuOKtlwiOlwiXFxcXHRleHRjaXJjbGVkezQxfVwiLFwi44q3XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDJ9XCIsXCLjirhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0M31cIixcIuOKuVwiOlwiXFxcXHRleHRjaXJjbGVkezQ0fVwiLFwi44q6XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDV9XCIsXCLjirtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Nn1cIixcIuOKvFwiOlwiXFxcXHRleHRjaXJjbGVkezQ3fVwiLFwi44q9XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDh9XCIsXCLjir5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OX1cIixcIuOKv1wiOlwiXFxcXHRleHRjaXJjbGVkezUwfVwiLFwiJlwiOlwiXFxcXCZcIixcIuKAllwiOlwiXFxcXHBhcmFsbGVsXCIsXCIlXCI6XCJcXFxcJVwiLFwi4oCcXCI6XCJcXFxcdGV4dHtgYH1cIiwkOlwiXFxcXCRcIixcIiNcIjpcIlxcXFwjXCIsXCLihINcIjpcIlxcXFx0ZXh0e1xcXFx0ZXh0ZGVncmVlIEN9XCIsXCLihIlcIjpcIlxcXFx0ZXh0e1xcXFx0ZXh0ZGVncmVlIEZ9XCIsXCLilohcIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4oSnXCI6XCJcXFxcbWhvXCIsXCLijItcIjpcIlxcXFxyZmxvb3JcIixcIuKMilwiOlwiXFxcXGxmbG9vclwiLFwi4oyJXCI6XCJcXFxccmNlaWxcIixcIuKMiFwiOlwiXFxcXGxjZWlsXCIs4oSHOlwiXFxcXHZhcmVwc2lsb25cIizihYc6XCJcXFxcdGV4dHtlfVwiLMm8OlwiclwiLFwi4oabXCI6XCJcXFxcbnJpZ2h0YXJyb3dcIizLhjpcIlxcXFxoYXR7fVwiLFwi4oC+XCI6XCJcXFxcb3ZlcmxpbmVcIixcIuKGklwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKAoVwiOlwiXFxcXGRkYWdnZXJcIixcIuODu1wiOlwiXFxcXGNkb3RcIixcIuKWsVwiOlwiXFxcXHNxdWFyZVwiLFwi4oiGXCI6XCJcXFxcRGVsdGFcIizhvLE6XCJpXCIsXCLiiKFcIjpcIlxcXFxhbmdsZVwiLM+SOlwiXFxcXFVwc2lsb25cIixcIuKGk1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oaRXCI6XCJcXFxcdXBhcnJvd1wiLFwiwrtcIjpcIlxcXFxnZ1wiLFwi4oqkXCI6XCJcXFxcdG9wXCIsXCLip7hcIjpcIi9cIizwnZu/OlwiXFxcXGRlbHRhXCIsXCLLs1wiOlwiXFxcXGNkb3RcIixcItaJXCI6XCI6XCIsXCLipqpcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqlcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipoFcIjpcIlxcXFxjZG90XCIs0bM6XCJcXFxcdGhldGFcIixcIuKmolwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIsK4XCI6XCIsXCIsXCLijrtcIjpcIlxcXFxvdmVybGluZVwiLFwi4p+mXCI6XCJcXFxcbGxicmFja2V0XCIs8J2cmTpcIlxcXFxwaGlcIizQnzpcIlxcXFxwcm9kXCIs0L46XCJvXCIsXCLiiYhcIjpcIlxcXFxhcHByb3hcIixcIuKJpFwiOlwiXFxcXGxlcVwiLNGSOlwiXFxcXGhiYXJcIizJhTpcIlxcXFxMYW1iZGFcIizlnJ86XCJcXFxccG1cIixcIuKOvFwiOlwiLVwiLOWNgTpcIitcIixcIuKJoFwiOlwiXFxcXG5lcVwiLFwi4oaQXCI6XCJcXFxcbGVmdGFycm93XCIsXCLgpaRcIjpcIlxcXFxtaWRcIixcIuKCrFwiOlwiXFxcXGV1cm9cIixcIsuYXCI6XCIgXCIs4b+hOlwiXFxcXGJhcnt1fVwiLFwi4oilXCI6XCJcXFxccGFyYWxsZWxcIixcIuKGlFwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLiiJpcIjpcIlxcXFxzcXJ0e31cIizIvDpcImNcIizwnZ6uOlwiXFxcXGVwc2lsb25cIixcIsK3XCI6XCJcXFxcY2RvdFwiLFwi4qasXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qauXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qatXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiwqtcIjpcIlxcXFxsbFwiLM6nOlwiXFxcXG1hdGhzZntYfVwiLFwi4pSCXCI6XCJcXFxcbWlkXCIsXCLijKpcIjpcIlxcXFxyYW5nbGVcIizigpk6XCJfe259XCIsXCLilqtcIjpcIlxcXFxzcXVhcmVcIixcIuKXj1wiOlwiXFxcXGNpcmNsZVwiLFwi4oCdXCI6J1xcXFxcIid9fSw1NDA2OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocigyOTY1KSx0KSxuKHIoOTAzOSksdCksbihyKDgyNDkpLHQpLG4ocig4MTcxKSx0KSxuKHIoNDcyKSx0KSxuKHIoNDMyMCksdCksbihyKDYxMjIpLHQpfSw0NzI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmxhdGV4QWNjZW50cz12b2lkIDAsdC5sYXRleEFjY2VudHM9W1wiXFxcXGhhdFwiLFwiXFxcXGJhclwiLFwiXFxcXHVuZGVyYnJhY2VcIixcIlxcXFxvdmVyYnJhY2VcIl19LDQzMjA6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm1hdGhOdW1iZXJCeUdseXBoPXZvaWQgMCx0Lm1hdGhOdW1iZXJCeUdseXBoPXtcIuKCgFwiOlwiX3swfVwiLFwi4oKBXCI6XCJfezF9XCIsXCLigoJcIjpcIl97Mn1cIixcIuKCg1wiOlwiX3szfVwiLFwi4oKEXCI6XCJfezR9XCIsXCLigoVcIjpcIl97NX1cIixcIuKChlwiOlwiX3s2fVwiLFwi4oKHXCI6XCJfezd9XCIsXCLigohcIjpcIl97OH1cIixcIuKCiVwiOlwiX3s5fVwiLFwi4oGwXCI6XCJeezB9XCIsXCLCuVwiOlwiXnsxfVwiLFwiwrJcIjpcIl57Mn1cIixcIsKzXCI6XCJeezN9XCIsXCLigbRcIjpcIl57NH1cIixcIuKBtVwiOlwiXns1fVwiLFwi4oG2XCI6XCJeezZ9XCIsXCLigbdcIjpcIl57N31cIixcIuKBuFwiOlwiXns4fVwiLFwi4oG5XCI6XCJeezl9XCIs4oG/OlwiXntufVwiLOKCmTpcIl97bn1cIixcIuKTqlwiOlwiXFxcXHRleHRjaXJjbGVkezB9XCIsXCLikaBcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxfVwiLFwi4pGhXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mn1cIixcIuKRolwiOlwiXFxcXHRleHRjaXJjbGVkezN9XCIsXCLikaNcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0fVwiLFwi4pGkXCI6XCJcXFxcdGV4dGNpcmNsZWR7NX1cIixcIuKRpVwiOlwiXFxcXHRleHRjaXJjbGVkezZ9XCIsXCLikaZcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs3fVwiLFwi4pGnXCI6XCJcXFxcdGV4dGNpcmNsZWR7OH1cIixcIuKRqFwiOlwiXFxcXHRleHRjaXJjbGVkezl9XCIsXCLikalcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMH1cIixcIuKRqlwiOlwiXFxcXHRleHRjaXJjbGVkezExfVwiLFwi4pGrXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTJ9XCIsXCLikaxcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxM31cIixcIuKRrVwiOlwiXFxcXHRleHRjaXJjbGVkezE0fVwiLFwi4pGuXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTV9XCIsXCLika9cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNn1cIixcIuKRsFwiOlwiXFxcXHRleHRjaXJjbGVkezE3fVwiLFwi4pGxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTh9XCIsXCLikbJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOX1cIixcIuKRs1wiOlwiXFxcXHRleHRjaXJjbGVkezIwfVwiLFwi44mRXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjF9XCIsXCLjiZJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMn1cIixcIuOJk1wiOlwiXFxcXHRleHRjaXJjbGVkezIzfVwiLFwi44mUXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjR9XCIsXCLjiZVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNX1cIixcIuOJllwiOlwiXFxcXHRleHRjaXJjbGVkezI2fVwiLFwi44mXXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjd9XCIsXCLjiZhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyOH1cIixcIuOJmVwiOlwiXFxcXHRleHRjaXJjbGVkezI5fVwiLFwi44maXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzB9XCIsXCLjiZtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMX1cIixcIuOJnFwiOlwiXFxcXHRleHRjaXJjbGVkezMyfVwiLFwi44mdXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzN9XCIsXCLjiZ5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNH1cIixcIuOJn1wiOlwiXFxcXHRleHRjaXJjbGVkezM1fVwiLFwi44qxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzZ9XCIsXCLjirJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszN31cIixcIuOKs1wiOlwiXFxcXHRleHRjaXJjbGVkezM4fVwiLFwi44q0XCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzl9XCIsXCLjirVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0MH1cIixcIuOKtlwiOlwiXFxcXHRleHRjaXJjbGVkezQxfVwiLFwi44q3XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDJ9XCIsXCLjirhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0M31cIixcIuOKuVwiOlwiXFxcXHRleHRjaXJjbGVkezQ0fVwiLFwi44q6XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDV9XCIsXCLjirtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Nn1cIixcIuOKvFwiOlwiXFxcXHRleHRjaXJjbGVkezQ3fVwiLFwi44q9XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDh9XCIsXCLjir5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OX1cIixcIuOKv1wiOlwiXFxcXHRleHRjaXJjbGVkezUwfVwiLFwiwr1cIjpcIlxcXFxkZnJhY3sxfXsyfVwiLFwi4oWTXCI6XCJcXFxcZGZyYWN7MX17M31cIixcIuKFlFwiOlwiXFxcXGRmcmFjezJ9ezN9XCIsXCLCvFwiOlwiXFxcXGRmcmFjezF9ezR9XCIsXCLCvlwiOlwiXFxcXGRmcmFjezN9ezR9XCIsXCLihZVcIjpcIlxcXFxkZnJhY3sxfXs1fVwiLFwi4oWWXCI6XCJcXFxcZGZyYWN7Mn17NX1cIixcIuKFl1wiOlwiXFxcXGRmcmFjezN9ezV9XCIsXCLihZhcIjpcIlxcXFxkZnJhY3s0fXs1fVwiLFwi4oWZXCI6XCJcXFxcZGZyYWN7MX17Nn1cIixcIuKFmlwiOlwiXFxcXGRmcmFjezV9ezZ9XCIsXCLihZBcIjpcIlxcXFxkZnJhY3sxfXs3fVwiLFwi4oWbXCI6XCJcXFxcZGZyYWN7MX17OH1cIixcIuKFnFwiOlwiXFxcXGRmcmFjezN9ezh9XCIsXCLihZ1cIjpcIlxcXFxkZnJhY3s1fXs4fVwiLFwi4oWeXCI6XCJcXFxcZGZyYWN7N317OH1cIixcIuKFkVwiOlwiXFxcXGRmcmFjezF9ezl9XCIsXCLihZJcIjpcIlxcXFxkZnJhY3sxfXsxMH1cIn19LDYxMjI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lkhhc2hVVEY4VG9MdFhDb252ZXJ0ZXI9dm9pZCAwLHQuSGFzaFVURjhUb0x0WENvbnZlcnRlcj1jbGFzc3tjb252ZXJ0KGUpe2lmKGUubWF0Y2goL1thLXowLTldL2kpKXJldHVybiBlO2NvbnN0IHQ9cltlXTtpZih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0QWNjZW50Q2hhclRvTHRYKHQpfHxlfXJldHVybiB0aGlzLmNvbnZlcnRTcGVjaWFsQ2hhclRvTHRYKGUpfHxlfWNvbnZlcnRBY2NlbnRDaGFyVG9MdFgoZSl7Y29uc3R7Y2hhcjp0LGFjY2VudDpyfT1lLG49YVtyXTtyZXR1cm4gbj9gXFxcXCR7bn17JHt0fX1gOm51bGx9Y29udmVydFNwZWNpYWxDaGFyVG9MdFgoZSl7Y29uc3QgdD1uW2VdO2lmKCF0KXJldHVybiBudWxsO2NvbnN0e2xldHRlcjpyLGZvbnRDbWQ6YX09dDtyZXR1cm5gXFxcXCR7YX17JHtyfX1gfX07Y29uc3Qgcj17w6E6e2NoYXI6XCJhXCIsYWNjZW50OlwiwrRcIn0sw6A6e2NoYXI6XCJhXCIsYWNjZW50OlwiYFwifSzDojp7Y2hhcjpcImFcIixhY2NlbnQ6XCJeXCJ9LMOjOntjaGFyOlwiYVwiLGFjY2VudDpcIn5cIn0sw6Q6e2NoYXI6XCJhXCIsYWNjZW50OlwiwqhcIn0sw6U6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5pcIn0sxIU6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5lcIn0sxIM6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5hcIn0sx446e2NoYXI6XCJhXCIsYWNjZW50Olwiy4dcIn0sx586e2NoYXI6XCJhXCIsYWNjZW50Olwiy4ZcIn0sx7s6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5lcIn0sx6E6e2NoYXI6XCJhXCIsYWNjZW50OlwiLVwifSzEgTp7Y2hhcjpcImFcIixhY2NlbnQ6XCItXCJ9LMOpOntjaGFyOlwiZVwiLGFjY2VudDpcIsK0XCJ9LMOoOntjaGFyOlwiZVwiLGFjY2VudDpcImBcIn0sw6o6e2NoYXI6XCJlXCIsYWNjZW50OlwiXlwifSzDqzp7Y2hhcjpcImVcIixhY2NlbnQ6XCLCqFwifSzEmTp7Y2hhcjpcImVcIixhY2NlbnQ6XCLLmVwifSzEmzp7Y2hhcjpcImVcIixhY2NlbnQ6XCLLh1wifSzIhzp7Y2hhcjpcImlcIixhY2NlbnQ6XCJeXCJ9LNGROntjaGFyOlwiZVwiLGFjY2VudDpcIsKoXCJ9LMSTOntjaGFyOlwiZVwiLGFjY2VudDpcIi1cIn0sw606e2NoYXI6XCJpXCIsYWNjZW50OlwiwrRcIn0sw6w6e2NoYXI6XCJpXCIsYWNjZW50OlwiYFwifSzDrjp7Y2hhcjpcImlcIixhY2NlbnQ6XCJeXCJ9LMOvOntjaGFyOlwiaVwiLGFjY2VudDpcIsKoXCJ9LMSvOntjaGFyOlwiaVwiLGFjY2VudDpcIsuZXCJ9LMeQOntjaGFyOlwiaVwiLGFjY2VudDpcIsuHXCJ9LMiJOntjaGFyOlwiaVwiLGFjY2VudDpcImBcIn0syIs6e2NoYXI6XCJpXCIsYWNjZW50OlwiwqhcIn0sxKs6e2NoYXI6XCJpXCIsYWNjZW50OlwiLVwifSzDszp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLCtFwifSzDsjp7Y2hhcjpcIm9cIixhY2NlbnQ6XCJgXCJ9LMO0OntjaGFyOlwib1wiLGFjY2VudDpcIl5cIn0sw7U6e2NoYXI6XCJvXCIsYWNjZW50OlwiflwifSzDtjp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLCqFwifSzFkTp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLLnVwifSzHkjp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLLh1wifSzIjTp7Y2hhcjpcIm9cIixhY2NlbnQ6XCJgXCJ9LMiPOntjaGFyOlwib1wiLGFjY2VudDpcIsKoXCJ9LMirOntjaGFyOlwib1wiLGFjY2VudDpcIsuYXCJ9LMitOntjaGFyOlwib1wiLGFjY2VudDpcIsudXCJ9LMivOntjaGFyOlwib1wiLGFjY2VudDpcIsuZXCJ9LMWNOntjaGFyOlwib1wiLGFjY2VudDpcIi1cIn0sw7o6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwrRcIn0sw7k6e2NoYXI6XCJ1XCIsYWNjZW50OlwiYFwifSzDuzp7Y2hhcjpcInVcIixhY2NlbnQ6XCJeXCJ9LMO8OntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMWxOntjaGFyOlwidVwiLGFjY2VudDpcIsudXCJ9LMeUOntjaGFyOlwidVwiLGFjY2VudDpcIsuHXCJ9LMeWOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMeYOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMeaOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMecOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMiVOntjaGFyOlwidVwiLGFjY2VudDpcImBcIn0syJc6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sxas6e2NoYXI6XCJ1XCIsYWNjZW50OlwiLVwifSzDvTp7Y2hhcjpcInlcIixhY2NlbnQ6XCLCtFwifSzhu7M6e2NoYXI6XCJ5XCIsYWNjZW50OlwiYFwifSzFtzp7Y2hhcjpcInlcIixhY2NlbnQ6XCJeXCJ9LMO/OntjaGFyOlwieVwiLGFjY2VudDpcIsKoXCJ9LMizOntjaGFyOlwieVwiLGFjY2VudDpcIi1cIn0sw4E6e2NoYXI6XCJBXCIsYWNjZW50OlwiwrRcIn0sw4A6e2NoYXI6XCJBXCIsYWNjZW50OlwiYFwifSzDgjp7Y2hhcjpcIkFcIixhY2NlbnQ6XCJeXCJ9LMODOntjaGFyOlwiQVwiLGFjY2VudDpcIn5cIn0sw4Q6e2NoYXI6XCJBXCIsYWNjZW50OlwiwqhcIn0sw4U6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5pcIn0s4oSrOntjaGFyOlwiQVwiLGFjY2VudDpcIsuaXCJ9LMimOntjaGFyOlwiQVwiLGFjY2VudDpcIsuZXCJ9LMSCOntjaGFyOlwiQVwiLGFjY2VudDpcIsuYXCJ9LMeNOntjaGFyOlwiQVwiLGFjY2VudDpcIsuHXCJ9LMeeOntjaGFyOlwiQVwiLGFjY2VudDpcIsudXCJ9LMe6OntjaGFyOlwiQVwiLGFjY2VudDpcIsuaXCJ9LMegOntjaGFyOlwiQVwiLGFjY2VudDpcIi1cIn0sxIA6e2NoYXI6XCJBXCIsYWNjZW50OlwiLVwifSzDiTp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLCtFwifSzDiDp7Y2hhcjpcIkVcIixhY2NlbnQ6XCJgXCJ9LMSWOntjaGFyOlwiRVwiLGFjY2VudDpcIsuZXCJ9LMOKOntjaGFyOlwiRVwiLGFjY2VudDpcIl5cIn0sw4s6e2NoYXI6XCJFXCIsYWNjZW50OlwiwqhcIn0sxJo6e2NoYXI6XCJFXCIsYWNjZW50Olwiy4dcIn0syIQ6e2NoYXI6XCJFXCIsYWNjZW50OlwiYFwifSzIhjp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLCqFwifSzEkjp7Y2hhcjpcIkVcIixhY2NlbnQ6XCItXCJ9LMONOntjaGFyOlwiSVwiLGFjY2VudDpcIsK0XCJ9LMOMOntjaGFyOlwiSVwiLGFjY2VudDpcImBcIn0sw446e2NoYXI6XCJJXCIsYWNjZW50OlwiXlwifSzDjzp7Y2hhcjpcIklcIixhY2NlbnQ6XCLCqFwifSzErDp7Y2hhcjpcIklcIixhY2NlbnQ6XCLLmFwifSzHjzp7Y2hhcjpcIklcIixhY2NlbnQ6XCLLh1wifSzIiDp7Y2hhcjpcIklcIixhY2NlbnQ6XCJgXCJ9LMiKOntjaGFyOlwiSVwiLGFjY2VudDpcIsKoXCJ9LMSqOntjaGFyOlwiSVwiLGFjY2VudDpcIi1cIn0sw5M6e2NoYXI6XCJPXCIsYWNjZW50OlwiwrRcIn0sw5I6e2NoYXI6XCJPXCIsYWNjZW50OlwiYFwifSzDlDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCJeXCJ9LMOVOntjaGFyOlwiT1wiLGFjY2VudDpcIn5cIn0sw5Y6e2NoYXI6XCJPXCIsYWNjZW50OlwiwqhcIn0sxZA6e2NoYXI6XCJPXCIsYWNjZW50Olwiy51cIn0sx5E6e2NoYXI6XCJPXCIsYWNjZW50Olwiy4dcIn0syIw6e2NoYXI6XCJPXCIsYWNjZW50OlwiYFwifSzIjjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLCqFwifSzIqjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLmFwifSzIrDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLnVwifSzIrjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLmVwifSzFjDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCItXCJ9LMOaOntjaGFyOlwiVVwiLGFjY2VudDpcIsK0XCJ9LMOZOntjaGFyOlwiVVwiLGFjY2VudDpcImBcIn0sw5s6e2NoYXI6XCJVXCIsYWNjZW50OlwiXlwifSzDnDp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLCqFwifSzFsDp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLLnVwifSzHkzp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLLh1wifSzHlTp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLCqFwifSzIlDp7Y2hhcjpcIlVcIixhY2NlbnQ6XCJgXCJ9LMiWOntjaGFyOlwiVVwiLGFjY2VudDpcIsKoXCJ9LMWqOntjaGFyOlwiVVwiLGFjY2VudDpcIi1cIn0sw506e2NoYXI6XCJZXCIsYWNjZW50OlwiwrRcIn0s4buyOntjaGFyOlwiWVwiLGFjY2VudDpcImBcIn0sxbY6e2NoYXI6XCJZXCIsYWNjZW50OlwiXlwifSzFuDp7Y2hhcjpcIllcIixhY2NlbnQ6XCLCqFwifSzIsjp7Y2hhcjpcIllcIixhY2NlbnQ6XCItXCJ9LMOxOntjaGFyOlwiblwiLGFjY2VudDpcIn5cIn0sw5E6e2NoYXI6XCJOXCIsYWNjZW50OlwiflwifSzDpzp7Y2hhcjpcImNcIixhY2NlbnQ6XCLLmVwifSzDhzp7Y2hhcjpcIkNcIixhY2NlbnQ6XCLLmVwifSzhub06e2NoYXI6XCJ2XCIsYWNjZW50OlwiflwifSzhubw6e2NoYXI6XCJWXCIsYWNjZW50OlwiflwifSzEtTp7Y2hhcjpcImpcIixhY2NlbnQ6XCJeXCJ9LMS0OntjaGFyOlwiSlwiLGFjY2VudDpcIl5cIn0sxbo6e2NoYXI6XCJ6XCIsYWNjZW50OlwiwrRcIn0sxbk6e2NoYXI6XCJaXCIsYWNjZW50OlwiwrRcIn0sxbs6e2NoYXI6XCJaXCIsYWNjZW50OlwiXlwifSzFvDp7Y2hhcjpcInpcIixhY2NlbnQ6XCJeXCJ9LMW9OntjaGFyOlwiWlwiLGFjY2VudDpcIsuHXCJ9LMW+OntjaGFyOlwielwiLGFjY2VudDpcIsuHXCJ9LOG6kTp7Y2hhcjpcInpcIixhY2NlbnQ6XCLLhlwifX0sYT17XCLCtFwiOlwiZ3JhdmVcIixcImBcIjpcImFjdXRlXCIsXCJeXCI6XCJoYXRcIixcIn5cIjpcInRpbGRlXCIsXCLCqFwiOlwiZGRvdFwiLFwiy5pcIjpcIm1hdGhyaW5nXCIsXCLLmFwiOlwiYnJldmVcIizLhzpcImNoZWNrXCIsXCLLnVwiOlwiZGRvdFwiLFwiy5lcIjpcImRvdFwiLFwiLVwiOlwiYmFyXCIsy4Y6XCJoYXRcIixcIsucXCI6XCJ0aWxkZVwifSxuPXvwnZCAOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCBOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCCOntsZXR0ZXI6XCJDXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCDOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCEOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGhiZlwifSzOlTp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QhTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qhjp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qhzp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QiDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QiTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qijp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qizp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QjDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QjTp7bGV0dGVyOlwiTlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qjjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qjzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QkDp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QkTp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qkjp7bGV0dGVyOlwiU1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qkzp7bGV0dGVyOlwiVFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QlDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QlTp7bGV0dGVyOlwiVlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qljp7bGV0dGVyOlwiV1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qlzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2ehjp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QmDp7bGV0dGVyOlwiWVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QmTp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+OXCI6e2xldHRlcjpcIjBcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fj1wiOntsZXR0ZXI6XCIxXCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5BcIjp7bGV0dGVyOlwiMlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+RXCI6e2xldHRlcjpcIjNcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fklwiOntsZXR0ZXI6XCI0XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5NcIjp7bGV0dGVyOlwiNVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+UXCI6e2xldHRlcjpcIjZcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2flVwiOntsZXR0ZXI6XCI3XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5ZcIjp7bGV0dGVyOlwiOFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+XXCI6e2xldHRlcjpcIjlcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkLQ6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLU6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLY6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLc6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLg6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLk6e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLo6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLs6e2xldHRlcjpcIkhcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLw6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGl0XCJ9LM6ZOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZC9OntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZC+OntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZC/OntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGAOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGBOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGCOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGDOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGEOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGFOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGGOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGHOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGIOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGJOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGKOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGLOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGMOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGNOntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZS4OntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZS5OntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhiYlwifSzihII6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlLs6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlLw6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlL06e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlL46e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEjTp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2VgDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2VgTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Vgjp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Vgzp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2VhDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSVOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWGOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhiYlwifSzihJk6e2xldHRlcjpcIlBcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEmjp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSdOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWKOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWLOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWMOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWNOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWOOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWPOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWQOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhiYlwifSzihKQ6e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fmFwiOntsZXR0ZXI6XCIwXCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn5lcIjp7bGV0dGVyOlwiMVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+aXCI6e2xldHRlcjpcIjJcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fm1wiOntsZXR0ZXI6XCIzXCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn5xcIjp7bGV0dGVyOlwiNFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+dXCI6e2xldHRlcjpcIjVcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fnlwiOntsZXR0ZXI6XCI2XCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn59cIjp7bGV0dGVyOlwiN1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+gXCI6e2xldHRlcjpcIjhcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2foVwiOntsZXR0ZXI6XCI5XCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZKcOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2TkDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKErDp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkp46e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKfOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Tkzp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEsDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEsTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdk5U6e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKiOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSLOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSQOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SpTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqY6e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aGNhbFwifSzihJI6e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZObOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSzOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SqTp7bGV0dGVyOlwiTlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqo6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGNhbFwifSzwnZOeOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Sqzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqw6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aGNhbFwifSzihJs6e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZW9OntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhjYWxcIn0sXCLihJ9cIjp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkq46e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKvOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SsDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrE6e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKyOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Sszp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrQ6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZK1OntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2UhDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSFOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKErTp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSHOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIg6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UiTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSKOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEjDp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzihJE6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UjTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSOOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlI86e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UkDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSROntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJI6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ukzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSUOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEnDp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSWOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJc6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UmDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSZOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJo6e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Umzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZScOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEqDp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZagOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhzZlwifSzOkTp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WoTp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0szpI6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqI6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqM6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqQ6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqU6e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqY6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqc6e2xldHRlcjpcIkhcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqg6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqk6e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aHNmXCJ9LMi3OntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZaqOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhzZlwifSzOmjp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wqzp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WrDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WrTp7bGV0dGVyOlwiTlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wrjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wrzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WsDp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WsTp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wsjp7bGV0dGVyOlwiU1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wszp7bGV0dGVyOlwiVFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WtDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WtTp7bGV0dGVyOlwiVlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wtjp7bGV0dGVyOlwiV1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wtzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0szqc6e2xldHRlcjpcIlhcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlrg6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlrk6e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdmqg6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmqk6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmqo6e2xldHRlcjpcIlxcXFxHYW1tYVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aqzp7bGV0dGVyOlwiXFxcXERlbHRhXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqsOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqtOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZquOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqvOntsZXR0ZXI6XCJcXFxcVGhldGFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrA6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrE6e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrI6e2xldHRlcjpcIlxcXFxMYW1iZGFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrM6e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrQ6e2xldHRlcjpcIk1cIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrU6e2xldHRlcjpcIlxcXFxQaVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atzp7bGV0dGVyOlwiXFxcXFBpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq4OntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq5OntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq6OntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq7OntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq8OntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq9OntsZXR0ZXI6XCJcXFxcUGhpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq+OntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq/OntsZXR0ZXI6XCJcXFxcUHNpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZuAOntsZXR0ZXI6XCJcXFxcT21lZ2FcIixmb250Q21kOlwibWF0aHR0XCJ9fX19LHQ9e307ZnVuY3Rpb24gcihhKXt2YXIgbj10W2FdO2lmKHZvaWQgMCE9PW4pcmV0dXJuIG4uZXhwb3J0czt2YXIgbz10W2FdPXtleHBvcnRzOnt9fTtyZXR1cm4gZVthXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxyKSxvLmV4cG9ydHN9dmFyIGE9e307cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9YTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLk1hdGhNTFRvTGFUZVg9dm9pZCAwO3ZhciB0PXIoODY3Mik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJNYXRoTUxUb0xhVGVYXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuTWF0aE1MVG9MYVRlWH19KX0pKCksYX0pKCkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5taW4uanMubWFwIiwiaW1wb3J0IHsgRGVmdWRkbGVNZXRhZGF0YSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTWV0YWRhdGFFeHRyYWN0b3Ige1xuXHRzdGF0aWMgZXh0cmFjdChkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBEZWZ1ZGRsZU1ldGFkYXRhIHtcblx0XHRsZXQgZG9tYWluID0gJyc7XG5cdFx0bGV0IHVybCA9ICcnO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSB0byBnZXQgVVJMIGZyb20gZG9jdW1lbnQgbG9jYXRpb25cblx0XHRcdHVybCA9IGRvYy5sb2NhdGlvbj8uaHJlZiB8fCAnJztcblx0XHRcdFxuXHRcdFx0Ly8gSWYgbm8gVVJMIGZyb20gbG9jYXRpb24sIHRyeSBvdGhlciBzb3VyY2VzXG5cdFx0XHRpZiAoIXVybCkge1xuXHRcdFx0XHR1cmwgPSB0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOnVybFwiKSB8fFxuXHRcdFx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwidHdpdHRlcjp1cmxcIikgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3VybCcpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdtYWluRW50aXR5T2ZQYWdlLnVybCcpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdtYWluRW50aXR5LnVybCcpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdXZWJTaXRlLnVybCcpIHx8XG5cdFx0XHRcdFx0ZG9jLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbcmVsPVwiY2Fub25pY2FsXCJdJyk/LmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodXJsKSB7XG5cdFx0XHRcdGRvbWFpbiA9IG5ldyBVUkwodXJsKS5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIElmIFVSTCBwYXJzaW5nIGZhaWxzLCB0cnkgdG8gZ2V0IGZyb20gYmFzZSB0YWdcblx0XHRcdGNvbnN0IGJhc2VUYWcgPSBkb2MucXVlcnlTZWxlY3RvcignYmFzZVtocmVmXScpO1xuXHRcdFx0aWYgKGJhc2VUYWcpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR1cmwgPSBiYXNlVGFnLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnO1xuXHRcdFx0XHRcdGRvbWFpbiA9IG5ldyBVUkwodXJsKS5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgYmFzZSBVUkw6JywgZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGl0bGU6IHRoaXMuZ2V0VGl0bGUoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdGRlc2NyaXB0aW9uOiB0aGlzLmdldERlc2NyaXB0aW9uKGRvYywgc2NoZW1hT3JnRGF0YSksXG5cdFx0XHRkb21haW4sXG5cdFx0XHRmYXZpY29uOiB0aGlzLmdldEZhdmljb24oZG9jLCB1cmwpLFxuXHRcdFx0aW1hZ2U6IHRoaXMuZ2V0SW1hZ2UoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdHB1Ymxpc2hlZDogdGhpcy5nZXRQdWJsaXNoZWQoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdGF1dGhvcjogdGhpcy5nZXRBdXRob3IoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdHNpdGU6IHRoaXMuZ2V0U2l0ZShkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0c2NoZW1hT3JnRGF0YSxcblx0XHRcdHdvcmRDb3VudDogMCxcblx0XHRcdHBhcnNlVGltZTogMFxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRBdXRob3IoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmF1dGhvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdhdXRob3IubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcImF1dGhvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImJ5bFwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImF1dGhvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImF1dGhvckxpc3RcIikgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJjb3B5cmlnaHRcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnY29weXJpZ2h0SG9sZGVyLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJvZzpzaXRlX25hbWVcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAncHVibGlzaGVyLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdzb3VyY2VPcmdhbml6YXRpb24ubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2lzUGFydE9mLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInR3aXR0ZXI6Y3JlYXRvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImFwcGxpY2F0aW9uLW5hbWVcIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldFNpdGUoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdwdWJsaXNoZXIubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOnNpdGVfbmFtZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdXZWJTaXRlLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdzb3VyY2VPcmdhbml6YXRpb24ubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiY29weXJpZ2h0XCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2NvcHlyaWdodEhvbGRlci5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnaXNQYXJ0T2YubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXBwbGljYXRpb24tbmFtZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRBdXRob3IoZG9jLCBzY2hlbWFPcmdEYXRhKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0VGl0bGUoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRjb25zdCByYXdUaXRsZSA9IChcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6dGl0bGVcIikgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0d2l0dGVyOnRpdGxlXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2hlYWRsaW5lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0aXRsZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LnRpdGxlXCIpIHx8XG5cdFx0XHRkb2MucXVlcnlTZWxlY3RvcigndGl0bGUnKT8udGV4dENvbnRlbnQ/LnRyaW0oKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xlYW5UaXRsZShyYXdUaXRsZSwgdGhpcy5nZXRTaXRlKGRvYywgc2NoZW1hT3JnRGF0YSkpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgY2xlYW5UaXRsZSh0aXRsZTogc3RyaW5nLCBzaXRlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRpZiAoIXRpdGxlIHx8ICFzaXRlTmFtZSkgcmV0dXJuIHRpdGxlO1xuXG5cdFx0Ly8gUmVtb3ZlIHNpdGUgbmFtZSBpZiBpdCBleGlzdHNcblx0XHRjb25zdCBzaXRlTmFtZUVzY2FwZWQgPSBzaXRlTmFtZS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuXHRcdGNvbnN0IHBhdHRlcm5zID0gW1xuXHRcdFx0YFxcXFxzKltcXFxcfFxcXFwt4oCT4oCUXVxcXFxzKiR7c2l0ZU5hbWVFc2NhcGVkfVxcXFxzKiRgLCAvLyBUaXRsZSB8IFNpdGUgTmFtZVxuXHRcdFx0YF5cXFxccyoke3NpdGVOYW1lRXNjYXBlZH1cXFxccypbXFxcXHxcXFxcLeKAk+KAlF1cXFxccypgLCAvLyBTaXRlIE5hbWUgfCBUaXRsZVxuXHRcdF07XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG5cdFx0XHRjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ2knKTtcblx0XHRcdGlmIChyZWdleC50ZXN0KHRpdGxlKSkge1xuXHRcdFx0XHR0aXRsZSA9IHRpdGxlLnJlcGxhY2UocmVnZXgsICcnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpdGxlLnRyaW0oKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldERlc2NyaXB0aW9uKGRvYzogRG9jdW1lbnQsIHNjaGVtYU9yZ0RhdGE6IGFueSk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJvZzpkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdkZXNjcmlwdGlvbicpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwidHdpdHRlcjpkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRJbWFnZShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOmltYWdlXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwidHdpdHRlcjppbWFnZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdpbWFnZS51cmwnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmltYWdlLmZ1bGxcIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldEZhdmljb24oZG9jOiBEb2N1bWVudCwgYmFzZVVybDogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRjb25zdCBpY29uRnJvbU1ldGEgPSB0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOmltYWdlOmZhdmljb25cIik7XG5cdFx0aWYgKGljb25Gcm9tTWV0YSkgcmV0dXJuIGljb25Gcm9tTWV0YTtcblxuXHRcdGNvbnN0IGljb25MaW5rID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCJsaW5rW3JlbD0naWNvbiddXCIpPy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuXHRcdGlmIChpY29uTGluaykgcmV0dXJuIGljb25MaW5rO1xuXG5cdFx0Y29uc3Qgc2hvcnRjdXRMaW5rID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCJsaW5rW3JlbD0nc2hvcnRjdXQgaWNvbiddXCIpPy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuXHRcdGlmIChzaG9ydGN1dExpbmspIHJldHVybiBzaG9ydGN1dExpbms7XG5cblx0XHQvLyBPbmx5IHRyeSB0byBjb25zdHJ1Y3QgZmF2aWNvbiBVUkwgaWYgd2UgaGF2ZSBhIHZhbGlkIGJhc2UgVVJMXG5cdFx0aWYgKGJhc2VVcmwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVVJMKFwiL2Zhdmljb24uaWNvXCIsIGJhc2VVcmwpLmhyZWY7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNvbnN0cnVjdCBmYXZpY29uIFVSTDonLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRQdWJsaXNoZWQoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdkYXRlUHVibGlzaGVkJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJwdWJsaXNoRGF0ZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJhcnRpY2xlOnB1Ymxpc2hlZF90aW1lXCIpIHx8XG5cdFx0XHR0aGlzLmdldFRpbWVFbGVtZW50KGRvYykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJzYWlsdGhydS5kYXRlXCIpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRNZXRhQ29udGVudChkb2M6IERvY3VtZW50LCBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHNlbGVjdG9yID0gYG1ldGFbJHthdHRyfV1gO1xuXHRcdGNvbnN0IGVsZW1lbnQgPSBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcblx0XHRcdC5maW5kKGVsID0+IGVsLmdldEF0dHJpYnV0ZShhdHRyKT8udG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUudG9Mb3dlckNhc2UoKSk7XG5cdFx0Y29uc3QgY29udGVudCA9IGVsZW1lbnQgPyBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIik/LnRyaW0oKSA/PyBcIlwiIDogXCJcIjtcblx0XHRyZXR1cm4gdGhpcy5kZWNvZGVIVE1MRW50aXRpZXMoY29udGVudCwgZG9jKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldFRpbWVFbGVtZW50KGRvYzogRG9jdW1lbnQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHNlbGVjdG9yID0gYHRpbWVgO1xuXHRcdGNvbnN0IGVsZW1lbnQgPSBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlbMF07XG5cdFx0Y29uc3QgY29udGVudCA9IGVsZW1lbnQgPyAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRldGltZVwiKT8udHJpbSgpID8/IGVsZW1lbnQudGV4dENvbnRlbnQ/LnRyaW0oKSA/PyBcIlwiKSA6IFwiXCI7XG5cdFx0cmV0dXJuIHRoaXMuZGVjb2RlSFRNTEVudGl0aWVzKGNvbnRlbnQsIGRvYyk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBkZWNvZGVIVE1MRW50aXRpZXModGV4dDogc3RyaW5nLCBkb2M6IERvY3VtZW50KTogc3RyaW5nIHtcblx0XHRjb25zdCB0ZXh0YXJlYSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuXHRcdHRleHRhcmVhLmlubmVySFRNTCA9IHRleHQ7XG5cdFx0cmV0dXJuIHRleHRhcmVhLnZhbHVlO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0U2NoZW1hUHJvcGVydHkoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55LCBwcm9wZXJ0eTogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcblx0XHRpZiAoIXNjaGVtYU9yZ0RhdGEpIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cblx0XHRjb25zdCBzZWFyY2hTY2hlbWEgPSAoZGF0YTogYW55LCBwcm9wczogc3RyaW5nW10sIGZ1bGxQYXRoOiBzdHJpbmcsIGlzRXhhY3RNYXRjaDogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmdbXSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wcy5sZW5ndGggPT09IDAgPyBbZGF0YV0gOiBbXTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRQcm9wID0gcHJvcHNbMF07XG5cdFx0XHRcdGlmICgvXlxcW1xcZCtcXF0kLy50ZXN0KGN1cnJlbnRQcm9wKSkge1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY3VycmVudFByb3Auc2xpY2UoMSwgLTEpKTtcblx0XHRcdFx0XHRpZiAoZGF0YVtpbmRleF0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBzZWFyY2hTY2hlbWEoZGF0YVtpbmRleF0sIHByb3BzLnNsaWNlKDEpLCBmdWxsUGF0aCwgaXNFeGFjdE1hdGNoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocHJvcHMubGVuZ3RoID09PSAwICYmIGRhdGEuZXZlcnkoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInKSkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLm1hcChTdHJpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZGF0YS5mbGF0TWFwKGl0ZW0gPT4gc2VhcmNoU2NoZW1hKGl0ZW0sIHByb3BzLCBmdWxsUGF0aCwgaXNFeGFjdE1hdGNoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IFtjdXJyZW50UHJvcCwgLi4ucmVtYWluaW5nUHJvcHNdID0gcHJvcHM7XG5cdFx0XHRcblx0XHRcdGlmICghY3VycmVudFByb3ApIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgcmV0dXJuIFtkYXRhXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhLm5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gW2RhdGEubmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShjdXJyZW50UHJvcCkpIHtcblx0XHRcdFx0cmV0dXJuIHNlYXJjaFNjaGVtYShkYXRhW2N1cnJlbnRQcm9wXSwgcmVtYWluaW5nUHJvcHMsIFxuXHRcdFx0XHRcdGZ1bGxQYXRoID8gYCR7ZnVsbFBhdGh9LiR7Y3VycmVudFByb3B9YCA6IGN1cnJlbnRQcm9wLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc0V4YWN0TWF0Y2gpIHtcblx0XHRcdFx0Y29uc3QgbmVzdGVkUmVzdWx0czogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IHNlYXJjaFNjaGVtYShkYXRhW2tleV0sIHByb3BzLCBcblx0XHRcdFx0XHRcdFx0ZnVsbFBhdGggPyBgJHtmdWxsUGF0aH0uJHtrZXl9YCA6IGtleSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0bmVzdGVkUmVzdWx0cy5wdXNoKC4uLnJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmVzdGVkUmVzdWx0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5lc3RlZFJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH07XG5cblx0XHR0cnkge1xuXHRcdFx0bGV0IHJlc3VsdHMgPSBzZWFyY2hTY2hlbWEoc2NoZW1hT3JnRGF0YSwgcHJvcGVydHkuc3BsaXQoJy4nKSwgJycsIHRydWUpO1xuXHRcdFx0aWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJlc3VsdHMgPSBzZWFyY2hTY2hlbWEoc2NoZW1hT3JnRGF0YSwgcHJvcGVydHkuc3BsaXQoJy4nKSwgJycsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID4gMCA/IHJlc3VsdHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykgOiBkZWZhdWx0VmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWNvZGVIVE1MRW50aXRpZXMocmVzdWx0LCBkb2MpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBFcnJvciBpbiBnZXRTY2hlbWFQcm9wZXJ0eSBmb3IgJHtwcm9wZXJ0eX06YCwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdFNjaGVtYU9yZ0RhdGEoZG9jOiBEb2N1bWVudCk6IGFueSB7XG5cdFx0Y29uc3Qgc2NoZW1hU2NyaXB0cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbdHlwZT1cImFwcGxpY2F0aW9uL2xkK2pzb25cIl0nKTtcblx0XHRjb25zdCBzY2hlbWFEYXRhOiBhbnlbXSA9IFtdO1xuXG5cdFx0c2NoZW1hU2NyaXB0cy5mb3JFYWNoKHNjcmlwdCA9PiB7XG5cdFx0XHRsZXQganNvbkNvbnRlbnQgPSBzY3JpcHQudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGpzb25Db250ZW50ID0ganNvbkNvbnRlbnRcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3xeXFxzKlxcL1xcLy4qJC9nbSwgJycpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMqPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KVxcXVxcXT5cXHMqJC8sICckMScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMqKFxcKlxcL3xcXC9cXCopXFxzKnxcXHMqKFxcKlxcL3xcXC9cXCopXFxzKiQvZywgJycpXG5cdFx0XHRcdFx0LnRyaW0oKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0Y29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGpzb25Db250ZW50KTtcblxuXHRcdFx0XHRpZiAoanNvbkRhdGFbJ0BncmFwaCddICYmIEFycmF5LmlzQXJyYXkoanNvbkRhdGFbJ0BncmFwaCddKSkge1xuXHRcdFx0XHRcdHNjaGVtYURhdGEucHVzaCguLi5qc29uRGF0YVsnQGdyYXBoJ10pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNjaGVtYURhdGEucHVzaChqc29uRGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgc2NoZW1hLm9yZyBkYXRhOicsIGVycm9yKTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignUHJvYmxlbWF0aWMgSlNPTiBjb250ZW50OicsIGpzb25Db250ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBzY2hlbWFEYXRhO1xuXHR9XG59IiwiaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL21ldGFkYXRhJztcbmltcG9ydCB7IERlZnVkZGxlT3B0aW9ucywgRGVmdWRkbGVSZXNwb25zZSwgRGVmdWRkbGVNZXRhZGF0YSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgXG5cdEhJRERFTl9FTEVNRU5UX1NFTEVDVE9SUyxcblx0TU9CSUxFX1dJRFRILFxuXHRCTE9DS19FTEVNRU5UUyxcblx0UFJFU0VSVkVfRUxFTUVOVFMsXG5cdElOTElORV9FTEVNRU5UUyxcblx0U1VQUE9SVEVEX0xBTkdVQUdFUyxcblx0QUxMT1dFRF9BVFRSSUJVVEVTLFxuXHRBTExPV0VEX0FUVFJJQlVURVNfREVCVUcsXG5cdEVYQUNUX1NFTEVDVE9SUyxcblx0UEFSVElBTF9TRUxFQ1RPUlMsXG5cdEZPT1ROT1RFX0xJU1RfU0VMRUNUT1JTLFxuXHRGT09UTk9URV9JTkxJTkVfUkVGRVJFTkNFUyxcblx0RU5UUllfUE9JTlRfRUxFTUVOVFMsXG5cdEFMTE9XRURfRU1QVFlfRUxFTUVOVFNcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgbWF0aFN0YW5kYXJkaXphdGlvblJ1bGVzIH0gZnJvbSAnLi9tYXRoJztcblxuLy8gRWxlbWVudCBzdGFuZGFyZGl6YXRpb24gcnVsZXNcbi8vIE1hcHMgc2VsZWN0b3JzIHRvIHRoZWlyIHRhcmdldCBIVE1MIGVsZW1lbnQgbmFtZVxuaW50ZXJmYWNlIFN0YW5kYXJkaXphdGlvblJ1bGUge1xuXHRzZWxlY3Rvcjogc3RyaW5nO1xuXHRlbGVtZW50OiBzdHJpbmc7XG5cdHRyYW5zZm9ybT86IChlbDogRWxlbWVudCkgPT4gRWxlbWVudDtcbn1cblxuY29uc3QgRUxFTUVOVF9TVEFOREFSRElaQVRJT05fUlVMRVM6IFN0YW5kYXJkaXphdGlvblJ1bGVbXSA9IFtcblx0Ly8gTWF0aCBlbGVtZW50c1xuXHQuLi5tYXRoU3RhbmRhcmRpemF0aW9uUnVsZXMsXG5cdC8vIENvZGUgYmxvY2tzXG5cdHtcblx0XHRzZWxlY3RvcjogJ3ByZScsXG5cdFx0ZWxlbWVudDogJ3ByZScsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIEZ1bmN0aW9uIHRvIGdldCBsYW5ndWFnZSBmcm9tIGNsYXNzXG5cdFx0XHRjb25zdCBnZXRMYW5ndWFnZUZyb21DbGFzcyA9IChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHN0cmluZyA9PiB7XG5cdFx0XHRcdC8vIENoZWNrIGRhdGEtbGFuZyBhdHRyaWJ1dGUgZmlyc3Rcblx0XHRcdFx0Y29uc3QgZGF0YUxhbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1sYW5nJyk7XG5cdFx0XHRcdGlmIChkYXRhTGFuZykge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGVmaW5lIGxhbmd1YWdlIHBhdHRlcm5zXG5cdFx0XHRcdGNvbnN0IGxhbmd1YWdlUGF0dGVybnMgPSBbXG5cdFx0XHRcdFx0L15sYW5ndWFnZS0oXFx3KykkLywgICAgICAgICAgLy8gbGFuZ3VhZ2UtamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9ebGFuZy0oXFx3KykkLywgICAgICAgICAgICAgIC8vIGxhbmctamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9eKFxcdyspLWNvZGUkLywgICAgICAgICAgICAgIC8vIGphdmFzY3JpcHQtY29kZVxuXHRcdFx0XHRcdC9eY29kZS0oXFx3KykkLywgICAgICAgICAgICAgIC8vIGNvZGUtamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9ec3ludGF4LShcXHcrKSQvLCAgICAgICAgICAgIC8vIHN5bnRheC1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15jb2RlLXNuaXBwZXRfXyhcXHcrKSQvLCAgICAgLy8gY29kZS1zbmlwcGV0X19qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15oaWdobGlnaHQtKFxcdyspJC8sICAgICAgICAgLy8gaGlnaGxpZ2h0LWphdmFzY3JpcHRcblx0XHRcdFx0XHQvXihcXHcrKS1zbmlwcGV0JC8gICAgICAgICAgICAvLyBqYXZhc2NyaXB0LXNuaXBwZXRcblx0XHRcdFx0XTtcblxuXHRcdFx0XHQvLyBUaGVuIGNoZWNrIHRoZSBjbGFzcyBhdHRyaWJ1dGUgZm9yIHBhdHRlcm5zXG5cdFx0XHRcdGlmIChlbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBwYXR0ZXJuIG9mIGxhbmd1YWdlUGF0dGVybnMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gZWxlbWVudC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKS5tYXRjaChwYXR0ZXJuKTtcblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gVGhlbiBjaGVjayBmb3Igc3VwcG9ydGVkIGxhbmd1YWdlXG5cdFx0XHRcdFx0aWYgKFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKGVsZW1lbnQuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjbGFzc05hbWVzID0gQXJyYXkuZnJvbShlbGVtZW50LmNsYXNzTGlzdCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGF0dGVybnMgZmlyc3Rcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ3VhZ2VQYXR0ZXJucykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBjbGFzc05hbWUubWF0Y2gocGF0dGVybik7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT25seSBjaGVjayBiYXJlIGxhbmd1YWdlIG5hbWVzIGlmIG5vIHBhdHRlcm5zIHdlcmUgZm91bmRcblx0XHRcdFx0Zm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuXHRcdFx0XHRcdGlmIChTVVBQT1JURURfTEFOR1VBR0VTLmhhcyhjbGFzc05hbWUudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBUcnkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBmcm9tIHRoZSBlbGVtZW50IGFuZCBpdHMgYW5jZXN0b3JzXG5cdFx0XHRsZXQgbGFuZ3VhZ2UgPSAnJztcblx0XHRcdGxldCBjdXJyZW50RWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gZWw7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChjdXJyZW50RWxlbWVudCAmJiAhbGFuZ3VhZ2UpIHtcblx0XHRcdFx0bGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZUZyb21DbGFzcyhjdXJyZW50RWxlbWVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBbHNvIGNoZWNrIGZvciBjb2RlIGVsZW1lbnRzIHdpdGhpbiB0aGUgY3VycmVudCBlbGVtZW50XG5cdFx0XHRcdGlmICghbGFuZ3VhZ2UgJiYgY3VycmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignY29kZScpKSB7XG5cdFx0XHRcdFx0bGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZUZyb21DbGFzcyhjdXJyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJykhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGdW5jdGlvbiB0byByZWN1cnNpdmVseSBleHRyYWN0IHRleHQgY29udGVudCB3aGlsZSBwcmVzZXJ2aW5nIHN0cnVjdHVyZVxuXHRcdFx0Y29uc3QgZXh0cmFjdFN0cnVjdHVyZWRUZXh0ID0gKGVsZW1lbnQ6IE5vZGUpOiBzdHJpbmcgPT4ge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0bGV0IHRleHQgPSAnJztcblx0XHRcdFx0aWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHRcdFx0XHRcdC8vIEhhbmRsZSBsaW5lIGJyZWFrc1xuXHRcdFx0XHRcdGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdCUicpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnXFxuJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNvZGUgZWxlbWVudHMgYW5kIHRoZWlyIGNoaWxkcmVuXG5cdFx0XHRcdFx0ZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRcdFx0dGV4dCArPSBleHRyYWN0U3RydWN0dXJlZFRleHQoY2hpbGQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEFkZCBuZXdsaW5lIGFmdGVyIGVhY2ggY29kZSBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0NPREUnKSB7XG5cdFx0XHRcdFx0XHR0ZXh0ICs9ICdcXG4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGV4dDtcblx0XHRcdH07XG5cblx0XHRcdC8vIEV4dHJhY3QgYWxsIHRleHQgY29udGVudFxuXHRcdFx0bGV0IGNvZGVDb250ZW50ID0gZXh0cmFjdFN0cnVjdHVyZWRUZXh0KGVsKTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgdGhlIGNvbnRlbnRcblx0XHRcdGNvZGVDb250ZW50ID0gY29kZUNvbnRlbnRcblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSBleHRyYSBuZXdsaW5lcyBhdCB0aGUgc3RhcnRcblx0XHRcdFx0LnJlcGxhY2UoL15cXG4rLywgJycpXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgZXh0cmEgbmV3bGluZXMgYXQgdGhlIGVuZFxuXHRcdFx0XHQucmVwbGFjZSgvXFxuKyQvLCAnJylcblx0XHRcdFx0Ly8gUmVwbGFjZSBtdWx0aXBsZSBjb25zZWN1dGl2ZSBuZXdsaW5lcyB3aXRoIGEgc2luZ2xlIG5ld2xpbmVcblx0XHRcdFx0LnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpO1xuXG5cdFx0XHQvLyBDcmVhdGUgbmV3IHByZSBlbGVtZW50XG5cdFx0XHRjb25zdCBuZXdQcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXNcblx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdG5ld1ByZS5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIENyZWF0ZSBjb2RlIGVsZW1lbnRcblx0XHRcdGNvbnN0IGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cdFx0XHRpZiAobGFuZ3VhZ2UpIHtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZycsIGxhbmd1YWdlKTtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYGxhbmd1YWdlLSR7bGFuZ3VhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0XHRjb2RlLnRleHRDb250ZW50ID0gY29kZUNvbnRlbnQ7XG5cdFx0XHRcblx0XHRcdG5ld1ByZS5hcHBlbmRDaGlsZChjb2RlKTtcblx0XHRcdHJldHVybiBuZXdQcmU7XG5cdFx0fVxuXHR9LFxuXHQvLyBTaW1wbGlmeSBoZWFkaW5ncyBieSByZW1vdmluZyBpbnRlcm5hbCBuYXZpZ2F0aW9uIGVsZW1lbnRzXG5cdHtcblx0XHRzZWxlY3RvcjogJ2gxLCBoMiwgaDMsIGg0LCBoNSwgaDYnLFxuXHRcdGVsZW1lbnQ6ICdrZWVwJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0Ly8gSWYgaGVhZGluZyBvbmx5IGNvbnRhaW5zIGEgc2luZ2xlIGFuY2hvciB3aXRoIGludGVybmFsIGxpbmtcblx0XHRcdGlmIChlbC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgXG5cdFx0XHRcdGVsLmZpcnN0RWxlbWVudENoaWxkPy50YWdOYW1lID09PSAnQScgJiZcblx0XHRcdFx0KGVsLmZpcnN0RWxlbWVudENoaWxkLmdldEF0dHJpYnV0ZSgnaHJlZicpPy5pbmNsdWRlcygnIycpIHx8IFxuXHRcdFx0XHQgZWwuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0QXR0cmlidXRlKCdocmVmJyk/LnN0YXJ0c1dpdGgoJyMnKSkpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENyZWF0ZSBuZXcgaGVhZGluZyBvZiBzYW1lIGxldmVsXG5cdFx0XHRcdGNvbnN0IG5ld0hlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsLnRhZ05hbWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXMgZnJvbSBvcmlnaW5hbCBoZWFkaW5nXG5cdFx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRuZXdIZWFkaW5nLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBKdXN0IHVzZSB0aGUgdGV4dCBjb250ZW50XG5cdFx0XHRcdG5ld0hlYWRpbmcudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ld0hlYWRpbmc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIElmIGhlYWRpbmcgY29udGFpbnMgbmF2aWdhdGlvbiBidXR0b25zIG9yIG90aGVyIHV0aWxpdHkgZWxlbWVudHNcblx0XHRcdGNvbnN0IGJ1dHRvbnMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKTtcblx0XHRcdGlmIChidXR0b25zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgbmV3SGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwudGFnTmFtZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlc1xuXHRcdFx0XHRBcnJheS5mcm9tKGVsLmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdFx0bmV3SGVhZGluZy5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSnVzdCB1c2UgdGhlIHRleHQgY29udGVudFxuXHRcdFx0XHRuZXdIZWFkaW5nLnRleHRDb250ZW50ID0gZWwudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXdIZWFkaW5nO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fVxuXHR9LFxuXHQvLyBDb252ZXJ0IGRpdnMgd2l0aCBwYXJhZ3JhcGggcm9sZSB0byBhY3R1YWwgcGFyYWdyYXBoc1xuXHR7IFxuXHRcdHNlbGVjdG9yOiAnZGl2W2RhdGEtdGVzdGlkXj1cInBhcmFncmFwaFwiXSwgZGl2W3JvbGU9XCJwYXJhZ3JhcGhcIl0nLCBcblx0XHRlbGVtZW50OiAncCcsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcblx0XHRcdC8vIENvcHkgaW5uZXJIVE1MXG5cdFx0XHRwLmlubmVySFRNTCA9IGVsLmlubmVySFRNTDtcblx0XHRcdFxuXHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXNcblx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdHAuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9XG5cdH0sXG5cdC8vIENvbnZlcnQgZGl2cyB3aXRoIGxpc3Qgcm9sZXMgdG8gYWN0dWFsIGxpc3RzXG5cdHsgXG5cdFx0c2VsZWN0b3I6ICdkaXZbcm9sZT1cImxpc3RcIl0nLCBcblx0XHRlbGVtZW50OiAndWwnLFxuXHRcdC8vIEN1c3RvbSBoYW5kbGVyIGZvciBsaXN0IHR5cGUgZGV0ZWN0aW9uIGFuZCB0cmFuc2Zvcm1hdGlvblxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHQvLyBGaXJzdCBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhbiBvcmRlcmVkIGxpc3Rcblx0XHRcdGNvbnN0IGZpcnN0SXRlbSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0gLmxhYmVsJyk7XG5cdFx0XHRjb25zdCBsYWJlbCA9IGZpcnN0SXRlbT8udGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdGNvbnN0IGlzT3JkZXJlZCA9IGxhYmVsLm1hdGNoKC9eXFxkK1xcKS8pO1xuXHRcdFx0XG5cdFx0XHQvLyBDcmVhdGUgdGhlIGFwcHJvcHJpYXRlIGxpc3QgdHlwZVxuXHRcdFx0Y29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXNPcmRlcmVkID8gJ29sJyA6ICd1bCcpO1xuXHRcdFx0XG5cdFx0XHQvLyBQcm9jZXNzIGVhY2ggbGlzdCBpdGVtXG5cdFx0XHRjb25zdCBpdGVtcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0nKTtcblx0XHRcdGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGl0ZW0ucXVlcnlTZWxlY3RvcignLmNvbnRlbnQnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjb250ZW50KSB7XG5cdFx0XHRcdFx0Ly8gQ29udmVydCBhbnkgcGFyYWdyYXBoIGRpdnMgaW5zaWRlIGNvbnRlbnRcblx0XHRcdFx0XHRjb25zdCBwYXJhZ3JhcGhEaXZzID0gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cInBhcmFncmFwaFwiXScpO1xuXHRcdFx0XHRcdHBhcmFncmFwaERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0XHRcdHAuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChwKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBDb252ZXJ0IGFueSBuZXN0ZWQgbGlzdHMgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRjb25zdCBuZXN0ZWRMaXN0cyA9IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJsaXN0XCJdJyk7XG5cdFx0XHRcdFx0bmVzdGVkTGlzdHMuZm9yRWFjaChuZXN0ZWRMaXN0ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGZpcnN0TmVzdGVkSXRlbSA9IG5lc3RlZExpc3QucXVlcnlTZWxlY3RvcignZGl2W3JvbGU9XCJsaXN0aXRlbVwiXSAubGFiZWwnKTtcblx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZExhYmVsID0gZmlyc3ROZXN0ZWRJdGVtPy50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRcdFx0Y29uc3QgaXNOZXN0ZWRPcmRlcmVkID0gbmVzdGVkTGFiZWwubWF0Y2goL15cXGQrXFwpLyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IG5ld05lc3RlZExpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzTmVzdGVkT3JkZXJlZCA/ICdvbCcgOiAndWwnKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyBuZXN0ZWQgaXRlbXNcblx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZEl0ZW1zID0gbmVzdGVkTGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cImxpc3RpdGVtXCJdJyk7XG5cdFx0XHRcdFx0XHRuZXN0ZWRJdGVtcy5mb3JFYWNoKG5lc3RlZEl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuZXN0ZWRMaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZENvbnRlbnQgPSBuZXN0ZWRJdGVtLnF1ZXJ5U2VsZWN0b3IoJy5jb250ZW50Jyk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAobmVzdGVkQ29udGVudCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbnZlcnQgcGFyYWdyYXBoIGRpdnMgaW4gbmVzdGVkIGl0ZW1zXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkUGFyYWdyYXBocyA9IG5lc3RlZENvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJwYXJhZ3JhcGhcIl0nKTtcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWRQYXJhZ3JhcGhzLmZvckVhY2goZGl2ID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRwLmlubmVySFRNTCA9IGRpdi5pbm5lckhUTUw7XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgocCk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkTGkuaW5uZXJIVE1MID0gbmVzdGVkQ29udGVudC5pbm5lckhUTUw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdG5ld05lc3RlZExpc3QuYXBwZW5kQ2hpbGQobmVzdGVkTGkpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdG5lc3RlZExpc3QucmVwbGFjZVdpdGgobmV3TmVzdGVkTGlzdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGkuaW5uZXJIVE1MID0gY29udGVudC5pbm5lckhUTUw7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGxpc3QuYXBwZW5kQ2hpbGQobGkpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH1cblx0fSxcblx0eyBcblx0XHRzZWxlY3RvcjogJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0nLCBcblx0XHRlbGVtZW50OiAnbGknLFxuXHRcdC8vIEN1c3RvbSBoYW5kbGVyIGZvciBsaXN0IGl0ZW0gY29udGVudFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gZWwucXVlcnlTZWxlY3RvcignLmNvbnRlbnQnKTtcblx0XHRcdGlmICghY29udGVudCkgcmV0dXJuIGVsO1xuXHRcdFx0XG5cdFx0XHQvLyBDb252ZXJ0IGFueSBwYXJhZ3JhcGggZGl2cyBpbnNpZGUgY29udGVudFxuXHRcdFx0Y29uc3QgcGFyYWdyYXBoRGl2cyA9IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJwYXJhZ3JhcGhcIl0nKTtcblx0XHRcdHBhcmFncmFwaERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRwLmlubmVySFRNTCA9IGRpdi5pbm5lckhUTUw7XG5cdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChwKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHR9XG5cdH0sXG5cdC8vIENvZGUgYmxvY2tzIHdpdGggc3ludGF4IGhpZ2hsaWdodGluZ1xuXHR7XG5cdFx0c2VsZWN0b3I6ICcud3AtYmxvY2stc3ludGF4aGlnaGxpZ2h0ZXItY29kZSwgLnN5bnRheGhpZ2hsaWdodGVyLCAuaGlnaGxpZ2h0LCAuaGlnaGxpZ2h0LXNvdXJjZSwgLndwLWJsb2NrLWNvZGUsIHByZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIHByZVtjbGFzcyo9XCJicnVzaDpcIl0nLFxuXHRcdGVsZW1lbnQ6ICdwcmUnLFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHRpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuIGVsO1xuXG5cdFx0XHQvLyBDcmVhdGUgbmV3IHByZSBlbGVtZW50XG5cdFx0XHRjb25zdCBuZXdQcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcblx0XHRcdFxuXHRcdFx0Ly8gVHJ5IHRvIGRldGVjdCBsYW5ndWFnZVxuXHRcdFx0bGV0IGxhbmd1YWdlID0gJyc7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBXb3JkUHJlc3Mgc3ludGF4IGhpZ2hsaWdodGVyIHNwZWNpZmljIGZvcm1hdFxuXHRcdFx0Y29uc3Qgc3ludGF4RWwgPSBlbC5xdWVyeVNlbGVjdG9yKCcuc3ludGF4aGlnaGxpZ2h0ZXInKTtcblx0XHRcdGlmIChzeW50YXhFbCkge1xuXHRcdFx0XHQvLyBHZXQgbGFuZ3VhZ2UgZnJvbSBzeW50YXhoaWdobGlnaHRlciBjbGFzc1xuXHRcdFx0XHRjb25zdCBjbGFzc2VzID0gQXJyYXkuZnJvbShzeW50YXhFbC5jbGFzc0xpc3QpO1xuXHRcdFx0XHRjb25zdCBsYW5nQ2xhc3MgPSBjbGFzc2VzLmZpbmQoYyA9PiAhWydzeW50YXhoaWdobGlnaHRlcicsICdub2d1dHRlciddLmluY2x1ZGVzKGMpKTtcblx0XHRcdFx0aWYgKGxhbmdDbGFzcyAmJiBTVVBQT1JURURfTEFOR1VBR0VTLmhhcyhsYW5nQ2xhc3MudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRsYW5ndWFnZSA9IGxhbmdDbGFzcy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vIGxhbmd1YWdlIGZvdW5kIHlldCwgY2hlY2sgb3RoZXIgY29tbW9uIHBhdHRlcm5zXG5cdFx0XHRpZiAoIWxhbmd1YWdlKSB7XG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZXMgPSBBcnJheS5mcm9tKGVsLmNsYXNzTGlzdCk7XG5cdFx0XHRcdGNvbnN0IGxhbmd1YWdlUGF0dGVybnMgPSBbXG5cdFx0XHRcdFx0Lyg/Ol58XFxzKSg/Omxhbmd1YWdlfGxhbmd8YnJ1c2h8c3ludGF4KS0oXFx3KykoPzpcXHN8JCkvaSxcblx0XHRcdFx0XHQvKD86XnxcXHMpKFxcdyspKD86XFxzfCQpL2lcblx0XHRcdFx0XTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBwYXR0ZXJuIG9mIGxhbmd1YWdlUGF0dGVybnMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gY2xhc3NOYW1lLm1hdGNoKHBhdHRlcm4pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoICYmIG1hdGNoWzFdICYmIFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRcdFx0XHRcdGxhbmd1YWdlID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChsYW5ndWFnZSkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRXh0cmFjdCBjb2RlIGNvbnRlbnQsIGhhbmRsaW5nIHZhcmlvdXMgZm9ybWF0c1xuXHRcdFx0bGV0IGNvZGVDb250ZW50ID0gJyc7XG5cblx0XHRcdC8vIEhhbmRsZSBXb3JkUHJlc3Mgc3ludGF4IGhpZ2hsaWdodGVyIHRhYmxlIGZvcm1hdFxuXHRcdFx0Y29uc3QgY29kZUNvbnRhaW5lciA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zeW50YXhoaWdobGlnaHRlciB0YWJsZSAuY29kZSAuY29udGFpbmVyJyk7XG5cdFx0XHRpZiAoY29kZUNvbnRhaW5lcikge1xuXHRcdFx0XHQvLyBQcm9jZXNzIGVhY2ggbGluZVxuXHRcdFx0XHRjb25zdCBsaW5lcyA9IEFycmF5LmZyb20oY29kZUNvbnRhaW5lci5jaGlsZHJlbik7XG5cdFx0XHRcdGNvZGVDb250ZW50ID0gbGluZXNcblx0XHRcdFx0XHQubWFwKGxpbmUgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gR2V0IGFsbCBjb2RlIGVsZW1lbnRzIGluIHRoaXMgbGluZVxuXHRcdFx0XHRcdFx0Y29uc3QgY29kZVBhcnRzID0gQXJyYXkuZnJvbShsaW5lLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvZGUnKSlcblx0XHRcdFx0XHRcdFx0Lm1hcChjb2RlID0+IHtcblx0XHRcdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHRleHQgY29udGVudCwgcHJlc2VydmluZyBzcGFjZXNcblx0XHRcdFx0XHRcdFx0XHRsZXQgdGV4dCA9IGNvZGUudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhICdzcGFjZXMnIGNsYXNzIGVsZW1lbnQsIGNvbnZlcnQgdG8gYWN0dWFsIHNwYWNlc1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjb2RlLmNsYXNzTGlzdC5jb250YWlucygnc3BhY2VzJykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRleHQgPSAnICcucmVwZWF0KHRleHQubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdC5qb2luKCcnKTtcblx0XHRcdFx0XHRcdHJldHVybiBjb2RlUGFydHMgfHwgbGluZS50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5qb2luKCdcXG4nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEhhbmRsZSBXb3JkUHJlc3Mgc3ludGF4IGhpZ2hsaWdodGVyIG5vbi10YWJsZSBmb3JtYXRcblx0XHRcdFx0Y29uc3QgY29kZUxpbmVzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnLmNvZGUgLmxpbmUnKTtcblx0XHRcdFx0aWYgKGNvZGVMaW5lcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29kZUNvbnRlbnQgPSBBcnJheS5mcm9tKGNvZGVMaW5lcylcblx0XHRcdFx0XHRcdC5tYXAobGluZSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNvZGVQYXJ0cyA9IEFycmF5LmZyb20obGluZS5xdWVyeVNlbGVjdG9yQWxsKCdjb2RlJykpXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcChjb2RlID0+IGNvZGUudGV4dENvbnRlbnQgfHwgJycpXG5cdFx0XHRcdFx0XHRcdFx0LmpvaW4oJycpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY29kZVBhcnRzIHx8IGxpbmUudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmpvaW4oJ1xcbicpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHJlZ3VsYXIgdGV4dCBjb250ZW50XG5cdFx0XHRcdFx0Y29kZUNvbnRlbnQgPSBlbC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgY29udGVudFxuXHRcdFx0Y29kZUNvbnRlbnQgPSBjb2RlQ29udGVudFxuXHRcdFx0XHQucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpIC8vIFRyaW0gc3RhcnQvZW5kIHdoaXRlc3BhY2Vcblx0XHRcdFx0LnJlcGxhY2UoL1xcdC9nLCAnICAgICcpIC8vIENvbnZlcnQgdGFicyB0byBzcGFjZXNcblx0XHRcdFx0LnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpIC8vIE5vcm1hbGl6ZSBtdWx0aXBsZSBuZXdsaW5lc1xuXHRcdFx0XHQucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpOyAvLyBSZXBsYWNlIG5vbi1icmVha2luZyBzcGFjZXMgd2l0aCByZWd1bGFyIHNwYWNlc1xuXG5cdFx0XHQvLyBDcmVhdGUgY29kZSBlbGVtZW50IHdpdGggbGFuZ3VhZ2UgY2xhc3MgaWYgZGV0ZWN0ZWRcblx0XHRcdGNvbnN0IGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cdFx0XHRpZiAobGFuZ3VhZ2UpIHtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZycsIGxhbmd1YWdlKTtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYGxhbmd1YWdlLSR7bGFuZ3VhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0XHRjb2RlLnRleHRDb250ZW50ID0gY29kZUNvbnRlbnQ7XG5cdFx0XHRcblx0XHRcdG5ld1ByZS5hcHBlbmRDaGlsZChjb2RlKTtcblx0XHRcdHJldHVybiBuZXdQcmU7XG5cdFx0fVxuXHR9XG5dO1xuXG5pbnRlcmZhY2UgRm9vdG5vdGVEYXRhIHtcblx0Y29udGVudDogRWxlbWVudCB8IHN0cmluZztcblx0b3JpZ2luYWxJZDogc3RyaW5nO1xuXHRyZWZzOiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIEZvb3Rub3RlQ29sbGVjdGlvbiB7XG5cdFtmb290bm90ZU51bWJlcjogbnVtYmVyXTogRm9vdG5vdGVEYXRhO1xufVxuXG5pbnRlcmZhY2UgQ29udGVudFNjb3JlIHtcblx0c2NvcmU6IG51bWJlcjtcblx0ZWxlbWVudDogRWxlbWVudDtcbn1cblxuaW50ZXJmYWNlIFN0eWxlQ2hhbmdlIHtcblx0c2VsZWN0b3I6IHN0cmluZztcblx0c3R5bGVzOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBEZWZ1ZGRsZSB7XG5cdHByaXZhdGUgZG9jOiBEb2N1bWVudDtcblx0cHJpdmF0ZSBvcHRpb25zOiBEZWZ1ZGRsZU9wdGlvbnM7XG5cdHByaXZhdGUgZGVidWc6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBEZWZ1ZGRsZSBpbnN0YW5jZVxuXHQgKiBAcGFyYW0gZG9jIC0gVGhlIGRvY3VtZW50IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgcGFyc2luZ1xuXHQgKi9cblx0Y29uc3RydWN0b3IoZG9jOiBEb2N1bWVudCwgb3B0aW9uczogRGVmdWRkbGVPcHRpb25zID0ge30pIHtcblx0XHR0aGlzLmRvYyA9IGRvYztcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuZGVidWcgPSBvcHRpb25zLmRlYnVnIHx8IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBkb2N1bWVudCBhbmQgZXh0cmFjdCBpdHMgbWFpbiBjb250ZW50XG5cdCAqL1xuXHRwYXJzZSgpOiBEZWZ1ZGRsZVJlc3BvbnNlIHtcblx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdC8vIEV4dHJhY3QgbWV0YWRhdGEgZmlyc3Qgc2luY2Ugd2UnbGwgbmVlZCBpdCBpbiBtdWx0aXBsZSBwbGFjZXNcblx0XHRjb25zdCBzY2hlbWFPcmdEYXRhID0gTWV0YWRhdGFFeHRyYWN0b3IuZXh0cmFjdFNjaGVtYU9yZ0RhdGEodGhpcy5kb2MpO1xuXHRcdGNvbnN0IG1ldGFkYXRhID0gTWV0YWRhdGFFeHRyYWN0b3IuZXh0cmFjdCh0aGlzLmRvYywgc2NoZW1hT3JnRGF0YSk7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gRXZhbHVhdGUgc3R5bGVzIGFuZCBzaXplcyBvbiBvcmlnaW5hbCBkb2N1bWVudFxuXHRcdFx0Y29uc3QgbW9iaWxlU3R5bGVzID0gdGhpcy5fZXZhbHVhdGVNZWRpYVF1ZXJpZXModGhpcy5kb2MpO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBmb3Igc21hbGwgaW1hZ2VzIGluIG9yaWdpbmFsIGRvY3VtZW50LCBleGNsdWRpbmcgbGF6eS1sb2FkZWQgb25lc1xuXHRcdFx0Y29uc3Qgc21hbGxJbWFnZXMgPSB0aGlzLmZpbmRTbWFsbEltYWdlcyh0aGlzLmRvYyk7XG5cdFx0XHRcblx0XHRcdC8vIENsb25lIGRvY3VtZW50XG5cdFx0XHRjb25zdCBjbG9uZSA9IHRoaXMuZG9jLmNsb25lTm9kZSh0cnVlKSBhcyBEb2N1bWVudDtcblx0XHRcdFxuXHRcdFx0Ly8gQXBwbHkgbW9iaWxlIHN0eWxlIHRvIGNsb25lXG5cdFx0XHR0aGlzLmFwcGx5TW9iaWxlU3R5bGVzKGNsb25lLCBtb2JpbGVTdHlsZXMpO1xuXG5cdFx0XHQvLyBGaW5kIG1haW4gY29udGVudFxuXHRcdFx0Y29uc3QgbWFpbkNvbnRlbnQgPSB0aGlzLmZpbmRNYWluQ29udGVudChjbG9uZSk7XG5cdFx0XHRpZiAoIW1haW5Db250ZW50KSB7XG5cdFx0XHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjb250ZW50OiB0aGlzLmRvYy5ib2R5LmlubmVySFRNTCxcblx0XHRcdFx0XHQuLi5tZXRhZGF0YSxcblx0XHRcdFx0XHR3b3JkQ291bnQ6IHRoaXMuY291bnRXb3Jkcyh0aGlzLmRvYy5ib2R5LmlubmVySFRNTCksXG5cdFx0XHRcdFx0cGFyc2VUaW1lOiBNYXRoLnJvdW5kKGVuZFRpbWUgLSBzdGFydFRpbWUpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBzbWFsbCBpbWFnZXMgaWRlbnRpZmllZCBmcm9tIG9yaWdpbmFsIGRvY3VtZW50XG5cdFx0XHR0aGlzLnJlbW92ZVNtYWxsSW1hZ2VzKGNsb25lLCBzbWFsbEltYWdlcyk7XG5cdFx0XHRcblx0XHRcdC8vIFBlcmZvcm0gb3RoZXIgZGVzdHJ1Y3RpdmUgb3BlcmF0aW9ucyBvbiB0aGUgY2xvbmVcblx0XHRcdHRoaXMucmVtb3ZlSGlkZGVuRWxlbWVudHMoY2xvbmUpO1xuXHRcdFx0dGhpcy5yZW1vdmVDbHV0dGVyKGNsb25lKTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgdGhlIG1haW4gY29udGVudFxuXHRcdFx0dGhpcy5jbGVhbkNvbnRlbnQobWFpbkNvbnRlbnQsIG1ldGFkYXRhKTtcblxuXHRcdFx0Y29uc3QgY29udGVudCA9IG1haW5Db250ZW50ID8gbWFpbkNvbnRlbnQub3V0ZXJIVE1MIDogdGhpcy5kb2MuYm9keS5pbm5lckhUTUw7XG5cdFx0XHRjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvbnRlbnQsXG5cdFx0XHRcdC4uLm1ldGFkYXRhLFxuXHRcdFx0XHR3b3JkQ291bnQ6IHRoaXMuY291bnRXb3Jkcyhjb250ZW50KSxcblx0XHRcdFx0cGFyc2VUaW1lOiBNYXRoLnJvdW5kKGVuZFRpbWUgLSBzdGFydFRpbWUpXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdEZWZ1ZGRsZScsICdFcnJvciBwcm9jZXNzaW5nIGRvY3VtZW50OicsIGVycm9yKTtcblx0XHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvbnRlbnQ6IHRoaXMuZG9jLmJvZHkuaW5uZXJIVE1MLFxuXHRcdFx0XHQuLi5tZXRhZGF0YSxcblx0XHRcdFx0d29yZENvdW50OiB0aGlzLmNvdW50V29yZHModGhpcy5kb2MuYm9keS5pbm5lckhUTUwpLFxuXHRcdFx0XHRwYXJzZVRpbWU6IE1hdGgucm91bmQoZW5kVGltZSAtIHN0YXJ0VGltZSlcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBjb3VudFdvcmRzKGNvbnRlbnQ6IHN0cmluZyk6IG51bWJlciB7XG5cdFx0Ly8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGRpdiB0byBwYXJzZSBIVE1MIGNvbnRlbnRcblx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGVtcERpdi5pbm5lckhUTUwgPSBjb250ZW50O1xuXG5cdFx0Ly8gR2V0IHRleHQgY29udGVudCwgcmVtb3ZpbmcgZXh0cmEgd2hpdGVzcGFjZVxuXHRcdGNvbnN0IHRleHQgPSB0ZW1wRGl2LnRleHRDb250ZW50IHx8ICcnO1xuXHRcdGNvbnN0IHdvcmRzID0gdGV4dFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBSZXBsYWNlIG11bHRpcGxlIHNwYWNlcyB3aXRoIHNpbmdsZSBzcGFjZVxuXHRcdFx0LnNwbGl0KCcgJylcblx0XHRcdC5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDApOyAvLyBGaWx0ZXIgb3V0IGVtcHR5IHN0cmluZ3NcblxuXHRcdHJldHVybiB3b3Jkcy5sZW5ndGg7XG5cdH1cblxuXHQvLyBNYWtlIGFsbCBvdGhlciBtZXRob2RzIHByaXZhdGUgYnkgcmVtb3ZpbmcgdGhlIHN0YXRpYyBrZXl3b3JkIGFuZCB1c2luZyBwcml2YXRlXG5cdHByaXZhdGUgX2xvZyguLi5hcmdzOiBhbnlbXSk6IHZvaWQge1xuXHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnRGVmdWRkbGU6JywgLi4uYXJncyk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBfZXZhbHVhdGVNZWRpYVF1ZXJpZXMoZG9jOiBEb2N1bWVudCk6IFN0eWxlQ2hhbmdlW10ge1xuXHRcdGNvbnN0IG1vYmlsZVN0eWxlczogU3R5bGVDaGFuZ2VbXSA9IFtdO1xuXHRcdGNvbnN0IG1heFdpZHRoUmVnZXggPSAvbWF4LXdpZHRoW146XSo6XFxzKihcXGQrKS87XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gR2V0IGFsbCBzdHlsZXMsIGluY2x1ZGluZyBpbmxpbmUgc3R5bGVzXG5cdFx0XHRjb25zdCBzaGVldHMgPSBBcnJheS5mcm9tKGRvYy5zdHlsZVNoZWV0cykuZmlsdGVyKHNoZWV0ID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBBY2Nlc3MgcnVsZXMgb25jZSB0byBjaGVjayB2YWxpZGl0eVxuXHRcdFx0XHRcdHNoZWV0LmNzc1J1bGVzO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly8gRXhwZWN0ZWQgZXJyb3IgZm9yIGNyb3NzLW9yaWdpbiBzdHlsZXNoZWV0c1xuXHRcdFx0XHRcdGlmIChlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGUubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBQcm9jZXNzIGFsbCBzaGVldHMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdFx0Y29uc3QgbWVkaWFSdWxlcyA9IHNoZWV0cy5mbGF0TWFwKHNoZWV0ID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gQXJyYXkuZnJvbShzaGVldC5jc3NSdWxlcylcblx0XHRcdFx0XHRcdC5maWx0ZXIoKHJ1bGUpOiBydWxlIGlzIENTU01lZGlhUnVsZSA9PiBcblx0XHRcdFx0XHRcdFx0cnVsZSBpbnN0YW5jZW9mIENTU01lZGlhUnVsZSAmJlxuXHRcdFx0XHRcdFx0XHRydWxlLmNvbmRpdGlvblRleHQuaW5jbHVkZXMoJ21heC13aWR0aCcpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIHN0eWxlc2hlZXQ6JywgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFByb2Nlc3MgYWxsIG1lZGlhIHJ1bGVzIGluIGEgc2luZ2xlIHBhc3Ncblx0XHRcdG1lZGlhUnVsZXMuZm9yRWFjaChydWxlID0+IHtcblx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBydWxlLmNvbmRpdGlvblRleHQubWF0Y2gobWF4V2lkdGhSZWdleCk7XG5cdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdGNvbnN0IG1heFdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChNT0JJTEVfV0lEVEggPD0gbWF4V2lkdGgpIHtcblx0XHRcdFx0XHRcdC8vIEJhdGNoIHByb2Nlc3MgYWxsIHN0eWxlIHJ1bGVzXG5cdFx0XHRcdFx0XHRjb25zdCBzdHlsZVJ1bGVzID0gQXJyYXkuZnJvbShydWxlLmNzc1J1bGVzKVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKChyKTogciBpcyBDU1NTdHlsZVJ1bGUgPT4gciBpbnN0YW5jZW9mIENTU1N0eWxlUnVsZSk7XG5cblx0XHRcdFx0XHRcdHN0eWxlUnVsZXMuZm9yRWFjaChjc3NSdWxlID0+IHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRtb2JpbGVTdHlsZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RvcjogY3NzUnVsZS5zZWxlY3RvclRleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZXM6IGNzc1J1bGUuc3R5bGUuY3NzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIENTUyBydWxlOicsIGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdEZWZ1ZGRsZTogRXJyb3IgZXZhbHVhdGluZyBtZWRpYSBxdWVyaWVzOicsIGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtb2JpbGVTdHlsZXM7XG5cdH1cblxuXHRwcml2YXRlIGFwcGx5TW9iaWxlU3R5bGVzKGRvYzogRG9jdW1lbnQsIG1vYmlsZVN0eWxlczogU3R5bGVDaGFuZ2VbXSkge1xuXHRcdGxldCBhcHBsaWVkQ291bnQgPSAwO1xuXG5cdFx0bW9iaWxlU3R5bGVzLmZvckVhY2goKHtzZWxlY3Rvciwgc3R5bGVzfSkgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHRcdGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXG5cdFx0XHRcdFx0XHQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJycpICsgc3R5bGVzXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRhcHBsaWVkQ291bnQrKztcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0RlZnVkZGxlJywgJ0Vycm9yIGFwcGx5aW5nIHN0eWxlcyBmb3Igc2VsZWN0b3I6Jywgc2VsZWN0b3IsIGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUhpZGRlbkVsZW1lbnRzKGRvYzogRG9jdW1lbnQpIHtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGNvbnN0IGVsZW1lbnRzVG9SZW1vdmUgPSBuZXcgU2V0PEVsZW1lbnQ+KCk7XG5cblx0XHQvLyBGaXJzdCBwYXNzOiBHZXQgYWxsIGVsZW1lbnRzIG1hdGNoaW5nIGhpZGRlbiBzZWxlY3RvcnNcblx0XHRjb25zdCBoaWRkZW5FbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKEhJRERFTl9FTEVNRU5UX1NFTEVDVE9SUyk7XG5cdFx0aGlkZGVuRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbGVtZW50c1RvUmVtb3ZlLmFkZChlbCkpO1xuXHRcdGNvdW50ICs9IGhpZGRlbkVsZW1lbnRzLmxlbmd0aDtcblxuXHRcdC8vIFNlY29uZCBwYXNzOiBVc2UgVHJlZVdhbGtlciBmb3IgZWZmaWNpZW50IHRyYXZlcnNhbFxuXHRcdGNvbnN0IHRyZWVXYWxrZXIgPSBkb2MuY3JlYXRlVHJlZVdhbGtlcihcblx0XHRcdGRvYy5ib2R5LFxuXHRcdFx0Tm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXG5cdFx0XHR7XG5cdFx0XHRcdGFjY2VwdE5vZGU6IChub2RlOiBFbGVtZW50KSA9PiB7XG5cdFx0XHRcdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IG1hcmtlZCBmb3IgcmVtb3ZhbFxuXHRcdFx0XHRcdGlmIChlbGVtZW50c1RvUmVtb3ZlLmhhcyhub2RlKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHQvLyBCYXRjaCBzdHlsZSBjb21wdXRhdGlvbnNcblx0XHRjb25zdCBlbGVtZW50czogRWxlbWVudFtdID0gW107XG5cdFx0bGV0IGN1cnJlbnROb2RlOiBFbGVtZW50IHwgbnVsbDtcblx0XHR3aGlsZSAoY3VycmVudE5vZGUgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCkgYXMgRWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudHMucHVzaChjdXJyZW50Tm9kZSk7XG5cdFx0fVxuXG5cdFx0Ly8gUHJvY2VzcyBzdHlsZXMgaW4gYmF0Y2hlcyB0byBtaW5pbWl6ZSBsYXlvdXQgdGhyYXNoaW5nXG5cdFx0Y29uc3QgQkFUQ0hfU0laRSA9IDEwMDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XG5cdFx0XHRjb25zdCBiYXRjaCA9IGVsZW1lbnRzLnNsaWNlKGksIGkgKyBCQVRDSF9TSVpFKTtcblx0XHRcdFxuXHRcdFx0Ly8gUmVhZCBwaGFzZSAtIGdhdGhlciBhbGwgY29tcHV0ZWRTdHlsZXNcblx0XHRcdGNvbnN0IHN0eWxlcyA9IGJhdGNoLm1hcChlbCA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkpO1xuXHRcdFx0XG5cdFx0XHQvLyBXcml0ZSBwaGFzZSAtIG1hcmsgZWxlbWVudHMgZm9yIHJlbW92YWxcblx0XHRcdGJhdGNoLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBzdHlsZXNbaW5kZXhdO1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHxcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nIHx8XG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZS5vcGFjaXR5ID09PSAnMCdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZWxlbWVudHNUb1JlbW92ZS5hZGQoZWxlbWVudCk7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gRmluYWwgcGFzczogQmF0Y2ggcmVtb3ZlIGFsbCBoaWRkZW4gZWxlbWVudHNcblx0XHRlbGVtZW50c1RvUmVtb3ZlLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuXG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIGhpZGRlbiBlbGVtZW50czonLCBjb3VudCk7XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUNsdXR0ZXIoZG9jOiBEb2N1bWVudCkge1xuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdGxldCBleGFjdFNlbGVjdG9yQ291bnQgPSAwO1xuXHRcdGxldCBwYXJ0aWFsU2VsZWN0b3JDb3VudCA9IDA7XG5cblx0XHQvLyBUcmFjayBhbGwgZWxlbWVudHMgdG8gYmUgcmVtb3ZlZFxuXHRcdGNvbnN0IGVsZW1lbnRzVG9SZW1vdmUgPSBuZXcgU2V0PEVsZW1lbnQ+KCk7XG5cblx0XHQvLyBGaXJzdCBjb2xsZWN0IGVsZW1lbnRzIG1hdGNoaW5nIGV4YWN0IHNlbGVjdG9yc1xuXHRcdGNvbnN0IGV4YWN0RWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChFWEFDVF9TRUxFQ1RPUlMuam9pbignLCcpKTtcblx0XHRleGFjdEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0aWYgKGVsPy5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGVsZW1lbnRzVG9SZW1vdmUuYWRkKGVsKTtcblx0XHRcdFx0ZXhhY3RTZWxlY3RvckNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBQcmUtY29tcGlsZSByZWdleGVzIGFuZCBjb21iaW5lIGludG8gYSBzaW5nbGUgcmVnZXggZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXHRcdGNvbnN0IGNvbWJpbmVkUGF0dGVybiA9IFBBUlRJQUxfU0VMRUNUT1JTLmpvaW4oJ3wnKTtcblx0XHRjb25zdCBwYXJ0aWFsUmVnZXggPSBuZXcgUmVnRXhwKGNvbWJpbmVkUGF0dGVybiwgJ2knKTtcblxuXHRcdC8vIENyZWF0ZSBhbiBlZmZpY2llbnQgYXR0cmlidXRlIHNlbGVjdG9yIGZvciBlbGVtZW50cyB3ZSBjYXJlIGFib3V0XG5cdFx0Y29uc3QgYXR0cmlidXRlU2VsZWN0b3IgPSAnW2NsYXNzXSxbaWRdLFtkYXRhLXRlc3RpZF0sW2RhdGEtcWFdLFtkYXRhLWN5XSc7XG5cdFx0Y29uc3QgYWxsRWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChhdHRyaWJ1dGVTZWxlY3Rvcik7XG5cblx0XHQvLyBQcm9jZXNzIGVsZW1lbnRzIGZvciBwYXJ0aWFsIG1hdGNoZXNcblx0XHRhbGxFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcblx0XHRcdC8vIFNraXAgaWYgYWxyZWFkeSBtYXJrZWQgZm9yIHJlbW92YWxcblx0XHRcdGlmIChlbGVtZW50c1RvUmVtb3ZlLmhhcyhlbCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZXMgYW5kIGNvbWJpbmUgaW50byBhIHNpbmdsZSBzdHJpbmdcblx0XHRcdGNvbnN0IGF0dHJzID0gW1xuXHRcdFx0XHRlbC5jbGFzc05hbWUgJiYgdHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiAnJyxcblx0XHRcdFx0ZWwuaWQgfHwgJycsXG5cdFx0XHRcdGVsLmdldEF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnKSB8fCAnJyxcblx0XHRcdFx0ZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXFhJykgfHwgJycsXG5cdFx0XHRcdGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jeScpIHx8ICcnXG5cdFx0XHRdLmpvaW4oJyAnKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHQvLyBTa2lwIGlmIG5vIGF0dHJpYnV0ZXMgdG8gY2hlY2tcblx0XHRcdGlmICghYXR0cnMudHJpbSgpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2ggdXNpbmcgc2luZ2xlIHJlZ2V4IHRlc3Rcblx0XHRcdGlmIChwYXJ0aWFsUmVnZXgudGVzdChhdHRycykpIHtcblx0XHRcdFx0ZWxlbWVudHNUb1JlbW92ZS5hZGQoZWwpO1xuXHRcdFx0XHRwYXJ0aWFsU2VsZWN0b3JDb3VudCsrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIGFsbCBjb2xsZWN0ZWQgZWxlbWVudHMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdGVsZW1lbnRzVG9SZW1vdmUuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG5cblx0XHRjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIGNsdXR0ZXIgZWxlbWVudHM6Jywge1xuXHRcdFx0ZXhhY3RTZWxlY3RvcnM6IGV4YWN0U2VsZWN0b3JDb3VudCxcblx0XHRcdHBhcnRpYWxTZWxlY3RvcnM6IHBhcnRpYWxTZWxlY3RvckNvdW50LFxuXHRcdFx0dG90YWw6IGVsZW1lbnRzVG9SZW1vdmUuc2l6ZSxcblx0XHRcdHByb2Nlc3NpbmdUaW1lOiBgJHsoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgyKX1tc2Bcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZmxhdHRlbkRpdnMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCBwcm9jZXNzZWRDb3VudCA9IDA7XG5cdFx0Y29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHQvLyBQcm9jZXNzIGluIGJhdGNoZXMgdG8gbWFpbnRhaW4gcGVyZm9ybWFuY2Vcblx0XHRsZXQga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXG5cdFx0Y29uc3Qgc2hvdWxkUHJlc2VydmVFbGVtZW50ID0gKGVsOiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHRjb25zdCB0YWdOYW1lID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBpZiBlbGVtZW50IHNob3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdGlmIChQUkVTRVJWRV9FTEVNRU5UUy5oYXModGFnTmFtZSkpIHJldHVybiB0cnVlO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBmb3Igc2VtYW50aWMgcm9sZXNcblx0XHRcdGNvbnN0IHJvbGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKTtcblx0XHRcdGlmIChyb2xlICYmIFsnYXJ0aWNsZScsICdtYWluJywgJ25hdmlnYXRpb24nLCAnYmFubmVyJywgJ2NvbnRlbnRpbmZvJ10uaW5jbHVkZXMocm9sZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBzZW1hbnRpYyBjbGFzc2VzXG5cdFx0XHRjb25zdCBjbGFzc05hbWUgPSBlbC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChjbGFzc05hbWUubWF0Y2goLyg/OmFydGljbGV8bWFpbnxjb250ZW50fGZvb3Rub3RlfHJlZmVyZW5jZXxiaWJsaW9ncmFwaHkpLykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIGRpdiBjb250YWlucyBtaXhlZCBjb250ZW50IHR5cGVzIHRoYXQgc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0aWYgKHRhZ05hbWUgPT09ICdkaXYnKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IGhhc1ByZXNlcnZlZEVsZW1lbnRzID0gY2hpbGRyZW4uc29tZShjaGlsZCA9PiBcblx0XHRcdFx0XHRQUkVTRVJWRV9FTEVNRU5UUy5oYXMoY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB8fFxuXHRcdFx0XHRcdGNoaWxkLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnYXJ0aWNsZScgfHxcblx0XHRcdFx0XHRjaGlsZC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYXJ0aWNsZScpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGlmIChoYXNQcmVzZXJ2ZWRFbGVtZW50cykgcmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgaXNXcmFwcGVyRGl2ID0gKGRpdjogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xuXHRcdFx0Ly8gQ2hlY2sgaWYgaXQncyBqdXN0IGVtcHR5IHNwYWNlXG5cdFx0XHRpZiAoIWRpdi50ZXh0Q29udGVudD8udHJpbSgpKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaXQgb25seSBjb250YWlucyBvdGhlciBkaXZzIG9yIGJsb2NrIGVsZW1lbnRzXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IEFycmF5LmZyb20oZGl2LmNoaWxkcmVuKTtcblx0XHRcdGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBpZiBhbGwgY2hpbGRyZW4gYXJlIGJsb2NrIGVsZW1lbnRzXG5cdFx0XHRjb25zdCBhbGxCbG9ja0VsZW1lbnRzID0gY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4ge1xuXHRcdFx0XHRjb25zdCB0YWcgPSBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHJldHVybiB0YWcgPT09ICdkaXYnIHx8IHRhZyA9PT0gJ3AnIHx8IHRhZyA9PT0gJ2gxJyB8fCB0YWcgPT09ICdoMicgfHwgXG5cdFx0XHRcdFx0ICAgdGFnID09PSAnaDMnIHx8IHRhZyA9PT0gJ2g0JyB8fCB0YWcgPT09ICdoNScgfHwgdGFnID09PSAnaDYnIHx8XG5cdFx0XHRcdFx0ICAgdGFnID09PSAndWwnIHx8IHRhZyA9PT0gJ29sJyB8fCB0YWcgPT09ICdwcmUnIHx8IHRhZyA9PT0gJ2Jsb2NrcXVvdGUnIHx8XG5cdFx0XHRcdFx0ICAgdGFnID09PSAnZmlndXJlJztcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGFsbEJsb2NrRWxlbWVudHMpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgY29tbW9uIHdyYXBwZXIgcGF0dGVybnNcblx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9IGRpdi5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvbnN0IGlzV3JhcHBlciA9IC8oPzp3cmFwcGVyfGNvbnRhaW5lcnxsYXlvdXR8cm93fGNvbHxncmlkfGZsZXh8b3V0ZXJ8aW5uZXJ8Y29udGVudC1hcmVhKS9pLnRlc3QoY2xhc3NOYW1lKTtcblx0XHRcdGlmIChpc1dyYXBwZXIpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdCBoYXMgZXhjZXNzaXZlIHdoaXRlc3BhY2Ugb3IgZW1wdHkgdGV4dCBub2Rlc1xuXHRcdFx0Y29uc3QgdGV4dE5vZGVzID0gQXJyYXkuZnJvbShkaXYuY2hpbGROb2RlcykuZmlsdGVyKG5vZGUgPT4gXG5cdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKVxuXHRcdFx0KTtcblx0XHRcdGlmICh0ZXh0Tm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaXQncyBhIGRpdiB0aGF0IG9ubHkgY29udGFpbnMgYmxvY2sgZWxlbWVudHNcblx0XHRcdGNvbnN0IGhhc09ubHlCbG9ja0VsZW1lbnRzID0gY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhY2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0cmV0dXJuIElOTElORV9FTEVNRU5UUy5oYXModGFnKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGhhc09ubHlCbG9ja0VsZW1lbnRzKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBGdW5jdGlvbiB0byBwcm9jZXNzIGEgc2luZ2xlIGRpdlxuXHRcdGNvbnN0IHByb2Nlc3NEaXYgPSAoZGl2OiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHQvLyBTa2lwIHByb2Nlc3NpbmcgaWYgZGl2IGhhcyBiZWVuIHJlbW92ZWQgb3Igc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0aWYgKCFkaXYuaXNDb25uZWN0ZWQgfHwgc2hvdWxkUHJlc2VydmVFbGVtZW50KGRpdikpIHJldHVybiBmYWxzZTtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBFbXB0eSBkaXYgb3IgZGl2IHdpdGggb25seSB3aGl0ZXNwYWNlXG5cdFx0XHRpZiAoIWRpdi5oYXNDaGlsZE5vZGVzKCkgfHwgIWRpdi50ZXh0Q29udGVudD8udHJpbSgpKSB7XG5cdFx0XHRcdGRpdi5yZW1vdmUoKTtcblx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgMjogVG9wLWxldmVsIGRpdiAtIGJlIG1vcmUgYWdncmVzc2l2ZVxuXHRcdFx0aWYgKGRpdi5wYXJlbnRFbGVtZW50ID09PSBlbGVtZW50KSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0XHRjb25zdCBoYXNPbmx5QmxvY2tFbGVtZW50cyA9IGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIWNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRyZXR1cm4gSU5MSU5FX0VMRU1FTlRTLmhhcyh0YWcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoaGFzT25seUJsb2NrRWxlbWVudHMpIHtcblx0XHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XHR3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdi5maXJzdENoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgMzogV3JhcHBlciBkaXYgLSBtZXJnZSB1cCBhZ2dyZXNzaXZlbHlcblx0XHRcdGlmIChpc1dyYXBwZXJEaXYoZGl2KSkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2U6IGlmIGRpdiBvbmx5IGNvbnRhaW5zIGJsb2NrIGVsZW1lbnRzLCBtZXJnZSB0aGVtIHVwXG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0XHRjb25zdCBvbmx5QmxvY2tFbGVtZW50cyA9ICFjaGlsZHJlbi5zb21lKGNoaWxkID0+IHtcblx0XHRcdFx0XHRjb25zdCB0YWcgPSBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0cmV0dXJuIElOTElORV9FTEVNRU5UUy5oYXModGFnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAob25seUJsb2NrRWxlbWVudHMpIHtcblx0XHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XHR3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdi5maXJzdENoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGhhbmRsZSBhcyBub3JtYWwgd3JhcHBlclxuXHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG5cdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChmcmFnbWVudCk7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXNlIDQ6IERpdiBvbmx5IGNvbnRhaW5zIHRleHQgY29udGVudCAtIGNvbnZlcnQgdG8gcGFyYWdyYXBoXG5cdFx0XHRpZiAoIWRpdi5jaGlsZHJlbi5sZW5ndGggJiYgZGl2LnRleHRDb250ZW50Py50cmltKCkpIHtcblx0XHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0cC50ZXh0Q29udGVudCA9IGRpdi50ZXh0Q29udGVudDtcblx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKHApO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSA1OiBEaXYgaGFzIHNpbmdsZSBjaGlsZFxuXHRcdFx0aWYgKGRpdi5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBkaXYuZmlyc3RFbGVtZW50Q2hpbGQhO1xuXHRcdFx0XHRjb25zdCBjaGlsZFRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIERvbid0IHVud3JhcCBpZiBjaGlsZCBpcyBpbmxpbmUgb3Igc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRpZiAoIUlOTElORV9FTEVNRU5UUy5oYXMoY2hpbGRUYWcpICYmICFzaG91bGRQcmVzZXJ2ZUVsZW1lbnQoY2hpbGQpKSB7XG5cdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGNoaWxkKTtcblx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgNjogRGVlcGx5IG5lc3RlZCBkaXYgLSBtZXJnZSB1cFxuXHRcdFx0bGV0IG5lc3RpbmdEZXB0aCA9IDA7XG5cdFx0XHRsZXQgcGFyZW50ID0gZGl2LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2Jykge1xuXHRcdFx0XHRcdG5lc3RpbmdEZXB0aCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmVzdGluZ0RlcHRoID4gMCkgeyAvLyBDaGFuZ2VkIGZyb20gPiAxIHRvID4gMCB0byBiZSBtb3JlIGFnZ3Jlc3NpdmVcblx0XHRcdFx0Y29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdi5maXJzdENoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBGaXJzdCBwYXNzOiBQcm9jZXNzIHRvcC1sZXZlbCBkaXZzXG5cdFx0Y29uc3QgcHJvY2Vzc1RvcExldmVsRGl2cyA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHRvcERpdnMgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZpbHRlcihcblx0XHRcdFx0ZWwgPT4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2J1xuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cdFx0XHR0b3BEaXZzLmZvckVhY2goZGl2ID0+IHtcblx0XHRcdFx0aWYgKHByb2Nlc3NEaXYoZGl2KSkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbW9kaWZpZWQ7XG5cdFx0fTtcblxuXHRcdC8vIFNlY29uZCBwYXNzOiBQcm9jZXNzIHJlbWFpbmluZyBkaXZzIGZyb20gZGVlcGVzdCB0byBzaGFsbG93ZXN0XG5cdFx0Y29uc3QgcHJvY2Vzc1JlbWFpbmluZ0RpdnMgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBhbGxEaXZzID0gQXJyYXkuZnJvbShlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKSlcblx0XHRcdFx0LnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0XHQvLyBDb3VudCBuZXN0aW5nIGRlcHRoXG5cdFx0XHRcdFx0Y29uc3QgZ2V0RGVwdGggPSAoZWw6IEVsZW1lbnQpOiBudW1iZXIgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IGRlcHRoID0gMDtcblx0XHRcdFx0XHRcdGxldCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHBhcmVudCkge1xuXHRcdFx0XHRcdFx0XHRpZiAocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RpdicpIGRlcHRoKys7XG5cdFx0XHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGRlcHRoO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIGdldERlcHRoKGIpIC0gZ2V0RGVwdGgoYSk7IC8vIFByb2Nlc3MgZGVlcGVzdCBmaXJzdFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cdFx0XHRhbGxEaXZzLmZvckVhY2goZGl2ID0+IHtcblx0XHRcdFx0aWYgKHByb2Nlc3NEaXYoZGl2KSkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbW9kaWZpZWQ7XG5cdFx0fTtcblxuXHRcdC8vIEZpbmFsIGNsZWFudXAgcGFzcyAtIGFnZ3Jlc3NpdmVseSBmbGF0dGVuIHJlbWFpbmluZyBkaXZzXG5cdFx0Y29uc3QgZmluYWxDbGVhbnVwID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgcmVtYWluaW5nRGl2cyA9IEFycmF5LmZyb20oZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JykpO1xuXHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJlbWFpbmluZ0RpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHQvLyBDaGVjayBpZiBkaXYgb25seSBjb250YWlucyBwYXJhZ3JhcGhzXG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0XHRjb25zdCBvbmx5UGFyYWdyYXBocyA9IGNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3AnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChvbmx5UGFyYWdyYXBocyB8fCAoIXNob3VsZFByZXNlcnZlRWxlbWVudChkaXYpICYmIGlzV3JhcHBlckRpdihkaXYpKSkge1xuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBtb2RpZmllZDtcblx0XHR9O1xuXG5cdFx0Ly8gRXhlY3V0ZSBhbGwgcGFzc2VzIHVudGlsIG5vIG1vcmUgY2hhbmdlc1xuXHRcdGRvIHtcblx0XHRcdFx0a2VlcFByb2Nlc3NpbmcgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHByb2Nlc3NUb3BMZXZlbERpdnMoKSkga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAocHJvY2Vzc1JlbWFpbmluZ0RpdnMoKSkga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAoZmluYWxDbGVhbnVwKCkpIGtlZXBQcm9jZXNzaW5nID0gdHJ1ZTtcblx0XHRcdH0gd2hpbGUgKGtlZXBQcm9jZXNzaW5nKTtcblxuXHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHR0aGlzLl9sb2coJ0ZsYXR0ZW5lZCBkaXZzOicsIHtcblx0XHRcdGNvdW50OiBwcm9jZXNzZWRDb3VudCxcblx0XHRcdHByb2Nlc3NpbmdUaW1lOiBgJHsoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgyKX1tc2Bcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgY2xlYW5Db250ZW50KGVsZW1lbnQ6IEVsZW1lbnQsIG1ldGFkYXRhOiBEZWZ1ZGRsZU1ldGFkYXRhKSB7XG5cdFx0Ly8gUmVtb3ZlIEhUTUwgY29tbWVudHNcblx0XHR0aGlzLnJlbW92ZUh0bWxDb21tZW50cyhlbGVtZW50KTtcblx0XHRcblx0XHQvLyBIYW5kbGUgSDEgZWxlbWVudHMgLSByZW1vdmUgZmlyc3Qgb25lIGFuZCBjb252ZXJ0IG90aGVycyB0byBIMlxuXHRcdHRoaXMuaGFuZGxlSGVhZGluZ3MoZWxlbWVudCwgbWV0YWRhdGEudGl0bGUpO1xuXHRcdFxuXHRcdC8vIFN0YW5kYXJkaXplIGZvb3Rub3RlcyBhbmQgY2l0YXRpb25zXG5cdFx0dGhpcy5zdGFuZGFyZGl6ZUZvb3Rub3RlcyhlbGVtZW50KTtcblxuXHRcdC8vIEhhbmRsZSBsYXp5LWxvYWRlZCBpbWFnZXNcblx0XHR0aGlzLmhhbmRsZUxhenlJbWFnZXMoZWxlbWVudCk7XG5cblx0XHQvLyBDb252ZXJ0IGVtYmVkZGVkIGNvbnRlbnQgdG8gc3RhbmRhcmQgZm9ybWF0c1xuXHRcdHRoaXMuc3RhbmRhcmRpemVFbGVtZW50cyhlbGVtZW50KTtcblxuXHRcdC8vIFNraXAgZGl2IGZsYXR0ZW5pbmcgaW4gZGVidWcgbW9kZVxuXHRcdGlmICghdGhpcy5kZWJ1Zykge1xuXHRcdFx0Ly8gRmlyc3QgcGFzcyBvZiBkaXYgZmxhdHRlbmluZ1xuXHRcdFx0dGhpcy5mbGF0dGVuRGl2cyhlbGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RyaXAgdW53YW50ZWQgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5zdHJpcFVud2FudGVkQXR0cmlidXRlcyhlbGVtZW50KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGVtcHR5IGVsZW1lbnRzXG5cdFx0XHR0aGlzLnJlbW92ZUVtcHR5RWxlbWVudHMoZWxlbWVudCk7XG5cblx0XHRcdC8vIFJlbW92ZSB0cmFpbGluZyBoZWFkaW5nc1xuXHRcdFx0dGhpcy5yZW1vdmVUcmFpbGluZ0hlYWRpbmdzKGVsZW1lbnQpO1xuXG5cdFx0XHQvLyBGaW5hbCBwYXNzIG9mIGRpdiBmbGF0dGVuaW5nIGFmdGVyIGNsZWFudXAgb3BlcmF0aW9uc1xuXHRcdFx0dGhpcy5mbGF0dGVuRGl2cyhlbGVtZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSW4gZGVidWcgbW9kZSwgc3RpbGwgZG8gYmFzaWMgY2xlYW51cCBidXQgcHJlc2VydmUgc3RydWN0dXJlXG5cdFx0XHR0aGlzLnN0cmlwVW53YW50ZWRBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5yZW1vdmVFbXB0eUVsZW1lbnRzKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5yZW1vdmVUcmFpbGluZ0hlYWRpbmdzKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5fbG9nKCdEZWJ1ZyBtb2RlOiBTa2lwcGluZyBkaXYgZmxhdHRlbmluZyB0byBwcmVzZXJ2ZSBzdHJ1Y3R1cmUnKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZVRyYWlsaW5nSGVhZGluZ3MoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCByZW1vdmVkQ291bnQgPSAwO1xuXG5cdFx0Y29uc3QgaGFzQ29udGVudEFmdGVyID0gKGVsOiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHQvLyBDaGVjayBpZiB0aGVyZSdzIGFueSBtZWFuaW5nZnVsIGNvbnRlbnQgYWZ0ZXIgdGhpcyBlbGVtZW50XG5cdFx0XHRsZXQgbmV4dENvbnRlbnQgPSAnJztcblx0XHRcdGxldCBzaWJsaW5nID0gZWwubmV4dFNpYmxpbmc7XG5cblx0XHRcdC8vIEZpcnN0IGNoZWNrIGRpcmVjdCBzaWJsaW5nc1xuXHRcdFx0d2hpbGUgKHNpYmxpbmcpIHtcblx0XHRcdFx0aWYgKHNpYmxpbmcubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cdFx0XHRcdFx0bmV4dENvbnRlbnQgKz0gc2libGluZy50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0fSBlbHNlIGlmIChzaWJsaW5nLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHRcdFx0XHRcdC8vIElmIHdlIGZpbmQgYW4gZWxlbWVudCBzaWJsaW5nLCBjaGVjayBpdHMgY29udGVudFxuXHRcdFx0XHRcdG5leHRDb250ZW50ICs9IChzaWJsaW5nIGFzIEVsZW1lbnQpLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBmb3VuZCBtZWFuaW5nZnVsIGNvbnRlbnQgYXQgdGhpcyBsZXZlbCwgcmV0dXJuIHRydWVcblx0XHRcdGlmIChuZXh0Q29udGVudC50cmltKCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vIGNvbnRlbnQgZm91bmQgYXQgdGhpcyBsZXZlbCBhbmQgd2UgaGF2ZSBhIHBhcmVudCxcblx0XHRcdC8vIGNoZWNrIGZvciBjb250ZW50IGFmdGVyIHRoZSBwYXJlbnRcblx0XHRcdGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gZWxlbWVudCkge1xuXHRcdFx0XHRyZXR1cm4gaGFzQ29udGVudEFmdGVyKHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gUHJvY2VzcyBhbGwgaGVhZGluZ3MgZnJvbSBib3R0b20gdG8gdG9wXG5cdFx0Y29uc3QgaGVhZGluZ3MgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicpKVxuXHRcdFx0LnJldmVyc2UoKTtcblxuXHRcdGhlYWRpbmdzLmZvckVhY2goaGVhZGluZyA9PiB7XG5cdFx0XHRpZiAoIWhhc0NvbnRlbnRBZnRlcihoZWFkaW5nKSkge1xuXHRcdFx0XHRoZWFkaW5nLnJlbW92ZSgpO1xuXHRcdFx0XHRyZW1vdmVkQ291bnQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFN0b3AgcHJvY2Vzc2luZyBvbmNlIHdlIGZpbmQgYSBoZWFkaW5nIHdpdGggY29udGVudCBhZnRlciBpdFxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAocmVtb3ZlZENvdW50ID4gMCkge1xuXHRcdFx0dGhpcy5fbG9nKCdSZW1vdmVkIHRyYWlsaW5nIGhlYWRpbmdzOicsIHJlbW92ZWRDb3VudCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBoYW5kbGVIZWFkaW5ncyhlbGVtZW50OiBFbGVtZW50LCB0aXRsZTogc3RyaW5nKSB7XG5cdFx0Y29uc3QgaDFzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDEnKTtcblxuXHRcdEFycmF5LmZyb20oaDFzKS5mb3JFYWNoKGgxID0+IHtcblx0XHRcdGNvbnN0IGgyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcblx0XHRcdGgyLmlubmVySFRNTCA9IGgxLmlubmVySFRNTDtcblx0XHRcdC8vIENvcHkgYWxsb3dlZCBhdHRyaWJ1dGVzXG5cdFx0XHRBcnJheS5mcm9tKGgxLmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdGlmIChBTExPV0VEX0FUVFJJQlVURVMuaGFzKGF0dHIubmFtZSkpIHtcblx0XHRcdFx0XHRoMi5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRoMS5wYXJlbnROb2RlPy5yZXBsYWNlQ2hpbGQoaDIsIGgxKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlbW92ZSBmaXJzdCBIMiBpZiBpdCBtYXRjaGVzIHRpdGxlXG5cdFx0Y29uc3QgaDJzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDInKTtcblx0XHRpZiAoaDJzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IGZpcnN0SDIgPSBoMnNbMF07XG5cdFx0XHRjb25zdCBmaXJzdEgyVGV4dCA9IGZpcnN0SDIudGV4dENvbnRlbnQ/LnRyaW0oKS50b0xvd2VyQ2FzZSgpIHx8ICcnO1xuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZFRpdGxlID0gdGl0bGUudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cdFx0XHRpZiAobm9ybWFsaXplZFRpdGxlICYmIG5vcm1hbGl6ZWRUaXRsZSA9PT0gZmlyc3RIMlRleHQpIHtcblx0XHRcdFx0Zmlyc3RIMi5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUh0bWxDb21tZW50cyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0Y29uc3QgY29tbWVudHM6IENvbW1lbnRbXSA9IFtdO1xuXHRcdGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG5cdFx0XHRlbGVtZW50LFxuXHRcdFx0Tm9kZUZpbHRlci5TSE9XX0NPTU1FTlQsXG5cdFx0XHRudWxsXG5cdFx0KTtcblxuXHRcdGxldCBub2RlO1xuXHRcdHdoaWxlIChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkpIHtcblx0XHRcdGNvbW1lbnRzLnB1c2gobm9kZSBhcyBDb21tZW50KTtcblx0XHR9XG5cblx0XHRjb21tZW50cy5mb3JFYWNoKGNvbW1lbnQgPT4ge1xuXHRcdFx0Y29tbWVudC5yZW1vdmUoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2xvZygnUmVtb3ZlZCBIVE1MIGNvbW1lbnRzOicsIGNvbW1lbnRzLmxlbmd0aCk7XG5cdH1cblxuXHRwcml2YXRlIHN0cmlwVW53YW50ZWRBdHRyaWJ1dGVzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgYXR0cmlidXRlQ291bnQgPSAwO1xuXG5cdFx0Y29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAoZWw6IEVsZW1lbnQpID0+IHtcblx0XHRcdC8vIFNraXAgU1ZHIGVsZW1lbnRzIC0gcHJlc2VydmUgYWxsIHRoZWlyIGF0dHJpYnV0ZXNcblx0XHRcdGlmIChlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gQXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKTtcblx0XHRcdFxuXHRcdFx0YXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRjb25zdCBhdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHQvLyBJbiBkZWJ1ZyBtb2RlLCBhbGxvdyBkZWJ1ZyBhdHRyaWJ1dGVzIGFuZCBkYXRhLSBhdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRcdFx0aWYgKCFBTExPV0VEX0FUVFJJQlVURVMuaGFzKGF0dHJOYW1lKSAmJiBcblx0XHRcdFx0XHRcdCFBTExPV0VEX0FUVFJJQlVURVNfREVCVUcuaGFzKGF0dHJOYW1lKSAmJiBcblx0XHRcdFx0XHRcdCFhdHRyTmFtZS5zdGFydHNXaXRoKCdkYXRhLScpKSB7XG5cdFx0XHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKTtcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZUNvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEluIG5vcm1hbCBtb2RlLCBvbmx5IGFsbG93IHN0YW5kYXJkIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRpZiAoIUFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ck5hbWUpKSB7XG5cdFx0XHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKTtcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZUNvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0cHJvY2Vzc0VsZW1lbnQoZWxlbWVudCk7XG5cdFx0ZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykuZm9yRWFjaChwcm9jZXNzRWxlbWVudCk7XG5cblx0XHR0aGlzLl9sb2coJ1N0cmlwcGVkIGF0dHJpYnV0ZXM6JywgYXR0cmlidXRlQ291bnQpO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVFbXB0eUVsZW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgcmVtb3ZlZENvdW50ID0gMDtcblx0XHRsZXQgaXRlcmF0aW9ucyA9IDA7XG5cdFx0bGV0IGtlZXBSZW1vdmluZyA9IHRydWU7XG5cblx0XHR3aGlsZSAoa2VlcFJlbW92aW5nKSB7XG5cdFx0XHRpdGVyYXRpb25zKys7XG5cdFx0XHRrZWVwUmVtb3ZpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEdldCBhbGwgZWxlbWVudHMgd2l0aG91dCBjaGlsZHJlbiwgd29ya2luZyBmcm9tIGRlZXBlc3QgZmlyc3Rcblx0XHRcdGNvbnN0IGVtcHR5RWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSkuZmlsdGVyKGVsID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfRU1QVFlfRUxFTUVOVFMuaGFzKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnQgaGFzIG9ubHkgd2hpdGVzcGFjZSBvciAmbmJzcDtcblx0XHRcdFx0Y29uc3QgdGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0Y29uc3QgaGFzT25seVdoaXRlc3BhY2UgPSB0ZXh0Q29udGVudC50cmltKCkubGVuZ3RoID09PSAwO1xuXHRcdFx0XHRjb25zdCBoYXNOYnNwID0gdGV4dENvbnRlbnQuaW5jbHVkZXMoJ1xcdTAwQTAnKTsgLy8gVW5pY29kZSBub24tYnJlYWtpbmcgc3BhY2Vcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnQgaGFzIG5vIG1lYW5pbmdmdWwgY2hpbGRyZW5cblx0XHRcdFx0Y29uc3QgaGFzTm9DaGlsZHJlbiA9ICFlbC5oYXNDaGlsZE5vZGVzKCkgfHwgXG5cdFx0XHRcdFx0KEFycmF5LmZyb20oZWwuY2hpbGROb2RlcykuZXZlcnkobm9kZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgbm9kZVRleHQgPSBub2RlLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZVRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCAmJiAhbm9kZVRleHQuaW5jbHVkZXMoJ1xcdTAwQTAnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlOiBDaGVjayBmb3IgZGl2cyB0aGF0IG9ubHkgY29udGFpbiBzcGFucyB3aXRoIGNvbW1hc1xuXHRcdFx0XHRpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2Jykge1xuXHRcdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbik7XG5cdFx0XHRcdFx0Y29uc3QgaGFzT25seUNvbW1hU3BhbnMgPSBjaGlsZHJlbi5sZW5ndGggPiAwICYmIGNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdzcGFuJykgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGNoaWxkLnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY29udGVudCA9PT0gJywnIHx8IGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICcgJztcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoaGFzT25seUNvbW1hU3BhbnMpIHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGhhc09ubHlXaGl0ZXNwYWNlICYmICFoYXNOYnNwICYmIGhhc05vQ2hpbGRyZW47XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGVtcHR5RWxlbWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRlbXB0eUVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0XHRcdGVsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdHJlbW92ZWRDb3VudCsrO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0a2VlcFJlbW92aW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgZW1wdHkgZWxlbWVudHM6Jywge1xuXHRcdFx0Y291bnQ6IHJlbW92ZWRDb3VudCxcblx0XHRcdGl0ZXJhdGlvbnNcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgY3JlYXRlRm9vdG5vdGVJdGVtKFxuXHRcdGZvb3Rub3RlTnVtYmVyOiBudW1iZXIsXG5cdFx0Y29udGVudDogc3RyaW5nIHwgRWxlbWVudCxcblx0XHRyZWZzOiBzdHJpbmdbXVxuXHQpOiBIVE1MTElFbGVtZW50IHtcblx0XHRjb25zdCBuZXdJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblx0XHRuZXdJdGVtLmNsYXNzTmFtZSA9ICdmb290bm90ZSc7XG5cdFx0bmV3SXRlbS5pZCA9IGBmbjoke2Zvb3Rub3RlTnVtYmVyfWA7XG5cblx0XHQvLyBIYW5kbGUgY29udGVudFxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGNvbnN0IHBhcmFncmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdHBhcmFncmFwaC5pbm5lckhUTUwgPSBjb250ZW50O1xuXHRcdFx0bmV3SXRlbS5hcHBlbmRDaGlsZChwYXJhZ3JhcGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgYWxsIHBhcmFncmFwaHMgZnJvbSB0aGUgY29udGVudFxuXHRcdFx0Y29uc3QgcGFyYWdyYXBocyA9IEFycmF5LmZyb20oY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdwJykpO1xuXHRcdFx0aWYgKHBhcmFncmFwaHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdC8vIElmIG5vIHBhcmFncmFwaHMsIHdyYXAgY29udGVudCBpbiBhIHBhcmFncmFwaFxuXHRcdFx0XHRjb25zdCBwYXJhZ3JhcGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdHBhcmFncmFwaC5pbm5lckhUTUwgPSBjb250ZW50LmlubmVySFRNTDtcblx0XHRcdFx0bmV3SXRlbS5hcHBlbmRDaGlsZChwYXJhZ3JhcGgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQ29weSBleGlzdGluZyBwYXJhZ3JhcGhzXG5cdFx0XHRcdHBhcmFncmFwaHMuZm9yRWFjaChwID0+IHtcblx0XHRcdFx0XHRjb25zdCBuZXdQID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRcdG5ld1AuaW5uZXJIVE1MID0gcC5pbm5lckhUTUw7XG5cdFx0XHRcdFx0bmV3SXRlbS5hcHBlbmRDaGlsZChuZXdQKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGJhY2tsaW5rKHMpIHRvIHRoZSBsYXN0IHBhcmFncmFwaFxuXHRcdGNvbnN0IGxhc3RQYXJhZ3JhcGggPSBuZXdJdGVtLnF1ZXJ5U2VsZWN0b3IoJ3A6bGFzdC1vZi10eXBlJykgfHwgbmV3SXRlbTtcblx0XHRyZWZzLmZvckVhY2goKHJlZklkLCBpbmRleCkgPT4ge1xuXHRcdFx0Y29uc3QgYmFja2xpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0XHRiYWNrbGluay5ocmVmID0gYCMke3JlZklkfWA7XG5cdFx0XHRiYWNrbGluay50aXRsZSA9ICdyZXR1cm4gdG8gYXJ0aWNsZSc7XG5cdFx0XHRiYWNrbGluay5jbGFzc05hbWUgPSAnZm9vdG5vdGUtYmFja3JlZic7XG5cdFx0XHRiYWNrbGluay5pbm5lckhUTUwgPSAn4oapJztcblx0XHRcdGlmIChpbmRleCA8IHJlZnMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRiYWNrbGluay5pbm5lckhUTUwgKz0gJyAnO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFBhcmFncmFwaC5hcHBlbmRDaGlsZChiYWNrbGluayk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gbmV3SXRlbTtcblx0fVxuXG5cdHByaXZhdGUgY29sbGVjdEZvb3Rub3RlcyhlbGVtZW50OiBFbGVtZW50KTogRm9vdG5vdGVDb2xsZWN0aW9uIHtcblx0XHRjb25zdCBmb290bm90ZXM6IEZvb3Rub3RlQ29sbGVjdGlvbiA9IHt9O1xuXHRcdGxldCBmb290bm90ZUNvdW50ID0gMTtcblx0XHRjb25zdCBwcm9jZXNzZWRJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gVHJhY2sgcHJvY2Vzc2VkIElEc1xuXG5cdFx0Ly8gQ29sbGVjdCBhbGwgZm9vdG5vdGVzIGFuZCB0aGVpciBJRHMgZnJvbSBmb290bm90ZSBsaXN0c1xuXHRcdGNvbnN0IGZvb3Rub3RlTGlzdHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMpO1xuXHRcdGZvb3Rub3RlTGlzdHMuZm9yRWFjaChsaXN0ID0+IHtcblx0XHRcdC8vIFN1YnN0YWNrIGhhcyBpbmRpdmlkdWFsIGZvb3Rub3RlIGRpdnMgd2l0aCBubyBwYXJlbnRcblx0XHRcdGlmIChsaXN0Lm1hdGNoZXMoJ2Rpdi5mb290bm90ZVtkYXRhLWNvbXBvbmVudC1uYW1lPVwiRm9vdG5vdGVUb0RPTVwiXScpKSB7XG5cdFx0XHRcdGNvbnN0IGFuY2hvciA9IGxpc3QucXVlcnlTZWxlY3RvcignYS5mb290bm90ZS1udW1iZXInKTtcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGxpc3QucXVlcnlTZWxlY3RvcignLmZvb3Rub3RlLWNvbnRlbnQnKTtcblx0XHRcdFx0aWYgKGFuY2hvciAmJiBjb250ZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgaWQgPSBhbmNob3IuaWQucmVwbGFjZSgnZm9vdG5vdGUtJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKGlkICYmICFwcm9jZXNzZWRJZHMuaGFzKGlkKSkge1xuXHRcdFx0XHRcdFx0Zm9vdG5vdGVzW2Zvb3Rub3RlQ291bnRdID0ge1xuXHRcdFx0XHRcdFx0XHRjb250ZW50OiBjb250ZW50LFxuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbElkOiBpZCxcblx0XHRcdFx0XHRcdFx0cmVmczogW11cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRwcm9jZXNzZWRJZHMuYWRkKGlkKTtcblx0XHRcdFx0XHRcdGZvb3Rub3RlQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21tb24gZm9ybWF0IHVzaW5nIE9ML1VMIGFuZCBMSSBlbGVtZW50c1xuXHRcdFx0Y29uc3QgaXRlbXMgPSBsaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpLCBkaXZbcm9sZT1cImxpc3RpdGVtXCJdJyk7XG5cdFx0XHRpdGVtcy5mb3JFYWNoKGxpID0+IHtcblx0XHRcdFx0bGV0IGlkID0gJyc7XG5cdFx0XHRcdGxldCBjb250ZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNpdGF0aW9ucyB3aXRoIC5jaXRhdGlvbnMgY2xhc3Ncblx0XHRcdFx0Y29uc3QgY2l0YXRpb25zRGl2ID0gbGkucXVlcnlTZWxlY3RvcignLmNpdGF0aW9ucycpO1xuXHRcdFx0XHRpZiAoY2l0YXRpb25zRGl2Py5pZD8udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdyJykpIHtcblx0XHRcdFx0XHRpZCA9IGNpdGF0aW9uc0Rpdi5pZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdC8vIExvb2sgZm9yIGNpdGF0aW9uIGNvbnRlbnQgd2l0aGluIHRoZSBjaXRhdGlvbnMgZGl2XG5cdFx0XHRcdFx0Y29uc3QgY2l0YXRpb25Db250ZW50ID0gY2l0YXRpb25zRGl2LnF1ZXJ5U2VsZWN0b3IoJy5jaXRhdGlvbi1jb250ZW50Jyk7XG5cdFx0XHRcdFx0aWYgKGNpdGF0aW9uQ29udGVudCkge1xuXHRcdFx0XHRcdFx0Y29udGVudCA9IGNpdGF0aW9uQ29udGVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCBJRCBmcm9tIHZhcmlvdXMgZm9ybWF0c1xuXHRcdFx0XHRcdGlmIChsaS5pZC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2JpYi5iaWInKSkge1xuXHRcdFx0XHRcdFx0aWQgPSBsaS5pZC5yZXBsYWNlKCdiaWIuYmliJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsaS5pZC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2ZuOicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmlkLnJlcGxhY2UoJ2ZuOicsICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGkuaWQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdmbicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmlkLnJlcGxhY2UoJ2ZuJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0Ly8gTmF0dXJlLmNvbVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGkuaGFzQXR0cmlidXRlKCdkYXRhLWNvdW50ZXInKSkge1xuXHRcdFx0XHRcdFx0aWQgPSBsaS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY291bnRlcicpPy5yZXBsYWNlKC9cXC4kLywgJycpPy50b0xvd2VyQ2FzZSgpIHx8ICcnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGxpLmlkLnNwbGl0KCcvJykucG9wKCk/Lm1hdGNoKC9jaXRlX25vdGUtKC4rKS8pO1xuXHRcdFx0XHRcdFx0aWQgPSBtYXRjaCA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiBsaS5pZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZW50ID0gbGk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaWQgJiYgIXByb2Nlc3NlZElkcy5oYXMoaWQpKSB7XG5cdFx0XHRcdFx0Zm9vdG5vdGVzW2Zvb3Rub3RlQ291bnRdID0ge1xuXHRcdFx0XHRcdFx0Y29udGVudDogY29udGVudCB8fCBsaSxcblx0XHRcdFx0XHRcdG9yaWdpbmFsSWQ6IGlkLFxuXHRcdFx0XHRcdFx0cmVmczogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHByb2Nlc3NlZElkcy5hZGQoaWQpO1xuXHRcdFx0XHRcdGZvb3Rub3RlQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZm9vdG5vdGVzO1xuXHR9XG5cblx0cHJpdmF0ZSBmaW5kT3V0ZXJGb290bm90ZUNvbnRhaW5lcihlbDogRWxlbWVudCk6IEVsZW1lbnQge1xuXHRcdGxldCBjdXJyZW50OiBFbGVtZW50IHwgbnVsbCA9IGVsO1xuXHRcdGxldCBwYXJlbnQ6IEVsZW1lbnQgfCBudWxsID0gZWwucGFyZW50RWxlbWVudDtcblx0XHRcblx0XHQvLyBLZWVwIGdvaW5nIHVwIHVudGlsIHdlIGZpbmQgYW4gZWxlbWVudCB0aGF0J3Mgbm90IGEgc3BhbiBvciBzdXBcblx0XHR3aGlsZSAocGFyZW50ICYmIChcblx0XHRcdHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzcGFuJyB8fCBcblx0XHRcdHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdXAnXG5cdFx0KSkge1xuXHRcdFx0Y3VycmVudCA9IHBhcmVudDtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gY3VycmVudDtcblx0fVxuXG5cdC8vIEV2ZXJ5IGZvb3Rub3RlIHJlZmVyZW5jZSBzaG91bGQgYmUgYSBzdXAgZWxlbWVudCB3aXRoIGFuIGFuY2hvciBpbnNpZGVcblx0Ly8gZS5nLiA8c3VwIGlkPVwiZm5yZWY6MVwiPjxhIGhyZWY9XCIjZm46MVwiPjE8L2E+PC9zdXA+XG5cdHByaXZhdGUgY3JlYXRlRm9vdG5vdGVSZWZlcmVuY2UoZm9vdG5vdGVOdW1iZXI6IHN0cmluZywgcmVmSWQ6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcblx0XHRjb25zdCBzdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdXAnKTtcblx0XHRzdXAuaWQgPSByZWZJZDtcblx0XHRjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdGxpbmsuaHJlZiA9IGAjZm46JHtmb290bm90ZU51bWJlcn1gO1xuXHRcdGxpbmsudGV4dENvbnRlbnQgPSBmb290bm90ZU51bWJlcjtcblx0XHRzdXAuYXBwZW5kQ2hpbGQobGluayk7XG5cdFx0cmV0dXJuIHN1cDtcblx0fVxuXG5cdHByaXZhdGUgc3RhbmRhcmRpemVGb290bm90ZXMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGNvbnN0IGZvb3Rub3RlcyA9IHRoaXMuY29sbGVjdEZvb3Rub3RlcyhlbGVtZW50KTtcblxuXHRcdC8vIFN0YW5kYXJkaXplIGlubGluZSBmb290bm90ZXMgdXNpbmcgdGhlIGNvbGxlY3RlZCBJRHNcblx0XHRjb25zdCBmb290bm90ZUlubGluZVJlZmVyZW5jZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRk9PVE5PVEVfSU5MSU5FX1JFRkVSRU5DRVMpO1xuXHRcdFxuXHRcdC8vIEdyb3VwIHJlZmVyZW5jZXMgYnkgdGhlaXIgcGFyZW50IHN1cCBlbGVtZW50XG5cdFx0Y29uc3Qgc3VwR3JvdXBzID0gbmV3IE1hcDxFbGVtZW50LCBFbGVtZW50W10+KCk7XG5cdFx0XG5cdFx0Zm9vdG5vdGVJbmxpbmVSZWZlcmVuY2VzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcblxuXHRcdFx0bGV0IGZvb3Rub3RlSWQgPSAnJztcblx0XHRcdGxldCBmb290bm90ZUNvbnRlbnQgPSAnJztcblxuXHRcdFx0Ly8gRXh0cmFjdCBmb290bm90ZSBJRCBiYXNlZCBvbiBlbGVtZW50IHR5cGVcblx0XHRcdC8vIE5hdHVyZS5jb21cblx0XHRcdGlmIChlbC5tYXRjaGVzKCdhW2lkXj1cInJlZi1saW5rXCJdJykpIHtcblx0XHRcdFx0Zm9vdG5vdGVJZCA9IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHQvLyBTY2llbmNlLm9yZ1xuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdhW3JvbGU9XCJkb2MtYmlibGlvcmVmXCJdJykpIHtcblx0XHRcdFx0Y29uc3QgeG1sUmlkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXhtbC1yaWQnKTtcblx0XHRcdFx0aWYgKHhtbFJpZCkge1xuXHRcdFx0XHRcdGZvb3Rub3RlSWQgPSB4bWxSaWQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3QgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRcdGlmIChocmVmPy5zdGFydHNXaXRoKCcjY29yZS1SJykpIHtcblx0XHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBocmVmLnJlcGxhY2UoJyNjb3JlLScsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIFN1YnN0YWNrXG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2EuZm9vdG5vdGUtYW5jaG9yLCBzcGFuLmZvb3Rub3RlLWhvdmVyY2FyZC10YXJnZXQgYScpKSB7XG5cdFx0XHRcdGNvbnN0IGlkID0gZWwuaWQ/LnJlcGxhY2UoJ2Zvb3Rub3RlLWFuY2hvci0nLCAnJykgfHwgJyc7XG5cdFx0XHRcdGlmIChpZCkge1xuXHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHQvLyBBcnhpdlxuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdjaXRlLmx0eF9jaXRlJykpIHtcblx0XHRcdFx0Y29uc3QgbGluayA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2EnKTtcblx0XHRcdFx0aWYgKGxpbmspIHtcblx0XHRcdFx0XHRjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblx0XHRcdFx0XHRpZiAoaHJlZikge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBocmVmLnNwbGl0KCcvJykucG9wKCk/Lm1hdGNoKC9iaWJcXC5iaWIoXFxkKykvKTtcblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRmb290bm90ZUlkID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3VwLnJlZmVyZW5jZScpKSB7XG5cdFx0XHRcdGNvbnN0IGxpbmtzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYScpO1xuXHRcdFx0XHRBcnJheS5mcm9tKGxpbmtzKS5mb3JFYWNoKGxpbmsgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRcdGlmIChocmVmKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGhyZWYuc3BsaXQoJy8nKS5wb3AoKT8ubWF0Y2goLyg/OmNpdGVfbm90ZXxjaXRlX3JlZiktKC4rKS8pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3N1cFtpZF49XCJmbnJlZjpcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuaWQucmVwbGFjZSgnZm5yZWY6JywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3N1cFtpZF49XCJmbnJcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuaWQucmVwbGFjZSgnZm5yJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3NwYW4uZm9vdG5vdGUtcmVmZXJlbmNlJykpIHtcblx0XHRcdFx0Zm9vdG5vdGVJZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1mb290bm90ZS1pZCcpIHx8ICcnO1xuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdzcGFuLmZvb3Rub3RlLWxpbmsnKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWZvb3Rub3RlLWlkJykgfHwgJyc7XG5cdFx0XHRcdGZvb3Rub3RlQ29udGVudCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1mb290bm90ZS1jb250ZW50JykgfHwgJyc7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2EuY2l0YXRpb24nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdFx0Zm9vdG5vdGVDb250ZW50ID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2FbaWRePVwiZm5yZWZcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuaWQucmVwbGFjZSgnZm5yZWYnLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyIGNpdGF0aW9uIHR5cGVzXG5cdFx0XHRcdGNvbnN0IGhyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblx0XHRcdFx0aWYgKGhyZWYpIHtcblx0XHRcdFx0XHRjb25zdCBpZCA9IGhyZWYucmVwbGFjZSgvXlsjXS8sICcnKTtcblx0XHRcdFx0XHRmb290bm90ZUlkID0gaWQudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZm9vdG5vdGVJZCkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBmb290bm90ZSBudW1iZXIgYnkgbWF0Y2hpbmcgdGhlIG9yaWdpbmFsIElEXG5cdFx0XHRcdGNvbnN0IGZvb3Rub3RlRW50cnkgPSBPYmplY3QuZW50cmllcyhmb290bm90ZXMpLmZpbmQoXG5cdFx0XHRcdFx0KFtfLCBkYXRhXSkgPT4gZGF0YS5vcmlnaW5hbElkID09PSBmb290bm90ZUlkLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoZm9vdG5vdGVFbnRyeSkge1xuXHRcdFx0XHRcdGNvbnN0IFtmb290bm90ZU51bWJlciwgZm9vdG5vdGVEYXRhXSA9IGZvb3Rub3RlRW50cnk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGZvb3Rub3RlIHJlZmVyZW5jZSBJRFxuXHRcdFx0XHRcdGNvbnN0IHJlZklkID0gZm9vdG5vdGVEYXRhLnJlZnMubGVuZ3RoID4gMCA/IFxuXHRcdFx0XHRcdFx0YGZucmVmOiR7Zm9vdG5vdGVOdW1iZXJ9LSR7Zm9vdG5vdGVEYXRhLnJlZnMubGVuZ3RoICsgMX1gIDogXG5cdFx0XHRcdFx0XHRgZm5yZWY6JHtmb290bm90ZU51bWJlcn1gO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvb3Rub3RlRGF0YS5yZWZzLnB1c2gocmVmSWQpO1xuXG5cdFx0XHRcdFx0Ly8gRmluZCB0aGUgb3V0ZXJtb3N0IGNvbnRhaW5lciAoc3BhbiBvciBzdXApXG5cdFx0XHRcdFx0Y29uc3QgY29udGFpbmVyID0gdGhpcy5maW5kT3V0ZXJGb290bm90ZUNvbnRhaW5lcihlbCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgY29udGFpbmVyIGlzIGEgc3VwLCBncm91cCByZWZlcmVuY2VzXG5cdFx0XHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdXAnKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXN1cEdyb3Vwcy5oYXMoY29udGFpbmVyKSkge1xuXHRcdFx0XHRcdFx0XHRzdXBHcm91cHMuc2V0KGNvbnRhaW5lciwgW10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBzdXBHcm91cHMuZ2V0KGNvbnRhaW5lcikhO1xuXHRcdFx0XHRcdFx0Z3JvdXAucHVzaCh0aGlzLmNyZWF0ZUZvb3Rub3RlUmVmZXJlbmNlKGZvb3Rub3RlTnVtYmVyLCByZWZJZCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBSZXBsYWNlIHRoZSBjb250YWluZXIgZGlyZWN0bHlcblx0XHRcdFx0XHRcdGNvbnRhaW5lci5yZXBsYWNlV2l0aCh0aGlzLmNyZWF0ZUZvb3Rub3RlUmVmZXJlbmNlKGZvb3Rub3RlTnVtYmVyLCByZWZJZCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gSGFuZGxlIGdyb3VwZWQgcmVmZXJlbmNlc1xuXHRcdHN1cEdyb3Vwcy5mb3JFYWNoKChyZWZlcmVuY2VzLCBjb250YWluZXIpID0+IHtcblx0XHRcdGlmIChyZWZlcmVuY2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gQ3JlYXRlIGEgZG9jdW1lbnQgZnJhZ21lbnQgdG8gaG9sZCBhbGwgdGhlIHJlZmVyZW5jZXNcblx0XHRcdFx0Y29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgZWFjaCByZWZlcmVuY2UgYXMgaXRzIG93biBzdXAgZWxlbWVudFxuXHRcdFx0XHRyZWZlcmVuY2VzLmZvckVhY2goKHJlZiwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBsaW5rID0gcmVmLnF1ZXJ5U2VsZWN0b3IoJ2EnKTtcblx0XHRcdFx0XHRpZiAobGluaykge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3VwJyk7XG5cdFx0XHRcdFx0XHRzdXAuaWQgPSByZWYuaWQ7XG5cdFx0XHRcdFx0XHRzdXAuYXBwZW5kQ2hpbGQobGluay5jbG9uZU5vZGUodHJ1ZSkpO1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3VwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29udGFpbmVyLnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIENyZWF0ZSB0aGUgc3RhbmRhcmRpemVkIGZvb3Rub3RlIGxpc3Rcblx0XHRjb25zdCBuZXdMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9vdG5vdGVzJyk7XG5cdFx0bmV3TGlzdC5jbGFzc05hbWUgPSAnZm9vdG5vdGVzJztcblx0XHRjb25zdCBvcmRlcmVkTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyk7XG5cblx0XHQvLyBDcmVhdGUgZm9vdG5vdGUgaXRlbXMgaW4gb3JkZXJcblx0XHRPYmplY3QuZW50cmllcyhmb290bm90ZXMpLmZvckVhY2goKFtudW1iZXIsIGRhdGFdKSA9PiB7XG5cdFx0XHRjb25zdCBuZXdJdGVtID0gdGhpcy5jcmVhdGVGb290bm90ZUl0ZW0oXG5cdFx0XHRcdHBhcnNlSW50KG51bWJlciksXG5cdFx0XHRcdGRhdGEuY29udGVudCxcblx0XHRcdFx0ZGF0YS5yZWZzXG5cdFx0XHQpO1xuXHRcdFx0b3JkZXJlZExpc3QuYXBwZW5kQ2hpbGQobmV3SXRlbSk7XG5cdFx0fSk7XG5cblx0XHQvLyBSZW1vdmUgb3JpZ2luYWwgZm9vdG5vdGUgbGlzdHNcblx0XHRjb25zdCBmb290bm90ZUxpc3RzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKEZPT1ROT1RFX0xJU1RfU0VMRUNUT1JTKTtcblx0XHRmb290bm90ZUxpc3RzLmZvckVhY2gobGlzdCA9PiBsaXN0LnJlbW92ZSgpKTtcblxuXHRcdC8vIElmIHdlIGhhdmUgYW55IGZvb3Rub3RlcywgYWRkIHRoZSBuZXcgbGlzdCB0byB0aGUgZG9jdW1lbnRcblx0XHRpZiAob3JkZXJlZExpc3QuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0bmV3TGlzdC5hcHBlbmRDaGlsZChvcmRlcmVkTGlzdCk7XG5cdFx0XHRlbGVtZW50LmFwcGVuZENoaWxkKG5ld0xpc3QpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgaGFuZGxlTGF6eUltYWdlcyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblx0XHRjb25zdCBsYXp5SW1hZ2VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbZGF0YS1zcmNdLCBpbWdbZGF0YS1zcmNzZXRdJyk7XG5cblx0XHRsYXp5SW1hZ2VzLmZvckVhY2goaW1nID0+IHtcblx0XHRcdGlmICghKGltZyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpKSByZXR1cm47XG5cblx0XHRcdC8vIEhhbmRsZSBkYXRhLXNyY1xuXHRcdFx0Y29uc3QgZGF0YVNyYyA9IGltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG5cdFx0XHRpZiAoZGF0YVNyYyAmJiAhaW1nLnNyYykge1xuXHRcdFx0XHRpbWcuc3JjID0gZGF0YVNyYztcblx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGRhdGEtc3Jjc2V0XG5cdFx0XHRjb25zdCBkYXRhU3Jjc2V0ID0gaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmNzZXQnKTtcblx0XHRcdGlmIChkYXRhU3Jjc2V0ICYmICFpbWcuc3Jjc2V0KSB7XG5cdFx0XHRcdGltZy5zcmNzZXQgPSBkYXRhU3Jjc2V0O1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgbGF6eSBsb2FkaW5nIHJlbGF0ZWQgY2xhc3NlcyBhbmQgYXR0cmlidXRlc1xuXHRcdFx0aW1nLmNsYXNzTGlzdC5yZW1vdmUoJ2xhenknLCAnbGF6eWxvYWQnKTtcblx0XHRcdGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbGwtc3RhdHVzJyk7XG5cdFx0XHRpbWcucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXHRcdFx0aW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zcmNzZXQnKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2xvZygnUHJvY2Vzc2VkIGxhenkgaW1hZ2VzOicsIHByb2Nlc3NlZENvdW50KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhbmRhcmRpemVFbGVtZW50cyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblxuXHRcdC8vIENvbnZlcnQgZWxlbWVudHMgYmFzZWQgb24gc3RhbmRhcmRpemF0aW9uIHJ1bGVzXG5cdFx0RUxFTUVOVF9TVEFOREFSRElaQVRJT05fUlVMRVMuZm9yRWFjaChydWxlID0+IHtcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHJ1bGUuc2VsZWN0b3IpO1xuXHRcdFx0ZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRcdGlmIChydWxlLnRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdC8vIElmIHRoZXJlJ3MgYSB0cmFuc2Zvcm0gZnVuY3Rpb24sIHVzZSBpdCB0byBjcmVhdGUgdGhlIG5ldyBlbGVtZW50XG5cdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtZWQgPSBydWxlLnRyYW5zZm9ybShlbCk7XG5cdFx0XHRcdFx0ZWwucmVwbGFjZVdpdGgodHJhbnNmb3JtZWQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ29udmVydCBsaXRlLXlvdXR1YmUgZWxlbWVudHNcblx0XHRjb25zdCBsaXRlWW91dHViZUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaXRlLXlvdXR1YmUnKTtcblx0XHRsaXRlWW91dHViZUVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0Y29uc3QgdmlkZW9JZCA9IGVsLmdldEF0dHJpYnV0ZSgndmlkZW9pZCcpO1xuXHRcdFx0aWYgKCF2aWRlb0lkKSByZXR1cm47XG5cblx0XHRcdGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLndpZHRoID0gJzU2MCc7XG5cdFx0XHRpZnJhbWUuaGVpZ2h0ID0gJzMxNSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLyR7dmlkZW9JZH1gO1xuXHRcdFx0aWZyYW1lLnRpdGxlID0gZWwuZ2V0QXR0cmlidXRlKCd2aWRlb3RpdGxlJykgfHwgJ1lvdVR1YmUgdmlkZW8gcGxheWVyJztcblx0XHRcdGlmcmFtZS5mcmFtZUJvcmRlciA9ICcwJztcblx0XHRcdGlmcmFtZS5hbGxvdyA9ICdhY2NlbGVyb21ldGVyOyBhdXRvcGxheTsgY2xpcGJvYXJkLXdyaXRlOyBlbmNyeXB0ZWQtbWVkaWE7IGd5cm9zY29wZTsgcGljdHVyZS1pbi1waWN0dXJlOyB3ZWItc2hhcmUnO1xuXHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSgnYWxsb3dmdWxsc2NyZWVuJywgJycpO1xuXG5cdFx0XHRlbC5yZXBsYWNlV2l0aChpZnJhbWUpO1xuXHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHR9KTtcblxuXHRcdHRoaXMuX2xvZygnQ29udmVydGVkIGVtYmVkZGVkIGVsZW1lbnRzOicsIHByb2Nlc3NlZENvdW50KTtcblx0fVxuXG5cdC8vIEZpbmQgc21hbGwgSU1HIGFuZCBTVkcgZWxlbWVudHNcblx0cHJpdmF0ZSBmaW5kU21hbGxJbWFnZXMoZG9jOiBEb2N1bWVudCk6IFNldDxzdHJpbmc+IHtcblx0XHRjb25zdCBNSU5fRElNRU5TSU9OID0gMzM7XG5cdFx0Y29uc3Qgc21hbGxJbWFnZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblx0XHRjb25zdCB0cmFuc2Zvcm1SZWdleCA9IC9zY2FsZVxcKChbXFxkLl0rKVxcKS87XG5cdFx0Y29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblxuXHRcdC8vIDEuIFJlYWQgcGhhc2UgLSBHYXRoZXIgYWxsIGVsZW1lbnRzIGluIGEgc2luZ2xlIHBhc3Ncblx0XHRjb25zdCBlbGVtZW50cyA9IFtcblx0XHRcdC4uLkFycmF5LmZyb20oZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSksXG5cdFx0XHQuLi5BcnJheS5mcm9tKGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJykpXG5cdFx0XS5maWx0ZXIoZWxlbWVudCA9PiB7XG5cdFx0XHQvLyBTa2lwIGxhenktbG9hZGVkIGltYWdlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0XG5cdFx0XHQvLyBhbmQgbWF0aCBpbWFnZXMgd2hpY2ggbWF5IGJlIHNtYWxsXG5cdFx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0Y29uc3QgaWdub3JlZEltYWdlID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2xhenknKSB8fCBcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbGF6eWxvYWQnKSB8fFxuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXRleCcpIHx8XG5cdFx0XHRcdFx0ZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RlY29kaW5nJykgfHxcblx0XHRcdFx0XHRlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zcmMnKSB8fFxuXHRcdFx0XHRcdGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdFx0XHRyZXR1cm4gIWlnbm9yZWRJbWFnZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0aWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHNtYWxsSW1hZ2VzO1xuXHRcdH1cblxuXHRcdC8vIDIuIEJhdGNoIHByb2Nlc3MgLSBDb2xsZWN0IGFsbCBtZWFzdXJlbWVudHMgaW4gb25lIGdvXG5cdFx0Y29uc3QgbWVhc3VyZW1lbnRzID0gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gKHtcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHQvLyBTdGF0aWMgYXR0cmlidXRlcyAobm8gcmVmbG93KVxuXHRcdFx0bmF0dXJhbFdpZHRoOiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCA/IGVsZW1lbnQubmF0dXJhbFdpZHRoIDogMCxcblx0XHRcdG5hdHVyYWxIZWlnaHQ6IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID8gZWxlbWVudC5uYXR1cmFsSGVpZ2h0IDogMCxcblx0XHRcdGF0dHJXaWR0aDogcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJzAnKSxcblx0XHRcdGF0dHJIZWlnaHQ6IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnMCcpXG5cdFx0fSkpO1xuXG5cdFx0Ly8gMy4gQmF0Y2ggY29tcHV0ZSBzdHlsZXMgLSBQcm9jZXNzIGluIGNodW5rcyB0byBhdm9pZCBsb25nIHRhc2tzXG5cdFx0Y29uc3QgQkFUQ0hfU0laRSA9IDUwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XG5cdFx0XHRjb25zdCBiYXRjaCA9IG1lYXN1cmVtZW50cy5zbGljZShpLCBpICsgQkFUQ0hfU0laRSk7XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIFJlYWQgcGhhc2UgLSBjb21wdXRlIGFsbCBzdHlsZXMgYXQgb25jZVxuXHRcdFx0XHRjb25zdCBzdHlsZXMgPSBiYXRjaC5tYXAoKHsgZWxlbWVudCB9KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSk7XG5cdFx0XHRcdGNvbnN0IHJlY3RzID0gYmF0Y2gubWFwKCh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBQcm9jZXNzIHBoYXNlIC0gbm8gRE9NIG9wZXJhdGlvbnNcblx0XHRcdFx0YmF0Y2guZm9yRWFjaCgobWVhc3VyZW1lbnQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0eWxlID0gc3R5bGVzW2luZGV4XTtcblx0XHRcdFx0XHRcdGNvbnN0IHJlY3QgPSByZWN0c1tpbmRleF07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEdldCB0cmFuc2Zvcm0gc2NhbGUgaW4gdGhlIHNhbWUgYmF0Y2hcblx0XHRcdFx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybTtcblx0XHRcdFx0XHRcdGNvbnN0IHNjYWxlID0gdHJhbnNmb3JtID8gXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQodHJhbnNmb3JtLm1hdGNoKHRyYW5zZm9ybVJlZ2V4KT8uWzFdIHx8ICcxJykgOiAxO1xuXG5cdFx0XHRcdFx0XHQvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGRpbWVuc2lvbnNcblx0XHRcdFx0XHRcdGNvbnN0IHdpZHRocyA9IFtcblx0XHRcdFx0XHRcdFx0bWVhc3VyZW1lbnQubmF0dXJhbFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5hdHRyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdHBhcnNlSW50KHN0eWxlLndpZHRoKSB8fCAwLFxuXHRcdFx0XHRcdFx0XHRyZWN0LndpZHRoICogc2NhbGVcblx0XHRcdFx0XHRcdF0uZmlsdGVyKGRpbSA9PiB0eXBlb2YgZGltID09PSAnbnVtYmVyJyAmJiBkaW0gPiAwKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaGVpZ2h0cyA9IFtcblx0XHRcdFx0XHRcdFx0bWVhc3VyZW1lbnQubmF0dXJhbEhlaWdodCxcblx0XHRcdFx0XHRcdFx0bWVhc3VyZW1lbnQuYXR0ckhlaWdodCxcblx0XHRcdFx0XHRcdFx0cGFyc2VJbnQoc3R5bGUuaGVpZ2h0KSB8fCAwLFxuXHRcdFx0XHRcdFx0XHRyZWN0LmhlaWdodCAqIHNjYWxlXG5cdFx0XHRcdFx0XHRdLmZpbHRlcihkaW0gPT4gdHlwZW9mIGRpbSA9PT0gJ251bWJlcicgJiYgZGltID4gMCk7XG5cblx0XHRcdFx0XHRcdC8vIERlY2lzaW9uIHBoYXNlIC0gbm8gRE9NIG9wZXJhdGlvbnNcblx0XHRcdFx0XHRcdGlmICh3aWR0aHMubGVuZ3RoID4gMCAmJiBoZWlnaHRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZWZmZWN0aXZlV2lkdGggPSBNYXRoLm1pbiguLi53aWR0aHMpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlZmZlY3RpdmVIZWlnaHQgPSBNYXRoLm1pbiguLi5oZWlnaHRzKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoZWZmZWN0aXZlV2lkdGggPCBNSU5fRElNRU5TSU9OIHx8IGVmZmVjdGl2ZUhlaWdodCA8IE1JTl9ESU1FTlNJT04pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBpZGVudGlmaWVyID0gdGhpcy5nZXRFbGVtZW50SWRlbnRpZmllcihtZWFzdXJlbWVudC5lbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaWRlbnRpZmllcikge1xuXHRcdFx0XHRcdFx0XHRcdFx0c21hbGxJbWFnZXMuYWRkKGlkZW50aWZpZXIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0RlZnVkZGxlOiBGYWlsZWQgdG8gcHJvY2VzcyBlbGVtZW50IGRpbWVuc2lvbnM6JywgZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0RlZnVkZGxlOiBGYWlsZWQgdG8gcHJvY2VzcyBiYXRjaDonLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHR0aGlzLl9sb2coJ0ZvdW5kIHNtYWxsIGVsZW1lbnRzOicsIHtcblx0XHRcdGNvdW50OiBwcm9jZXNzZWRDb3VudCxcblx0XHRcdHRvdGFsRWxlbWVudHM6IGVsZW1lbnRzLmxlbmd0aCxcblx0XHRcdHByb2Nlc3NpbmdUaW1lOiBgJHsoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgyKX1tc2Bcblx0XHR9KTtcblxuXHRcdHJldHVybiBzbWFsbEltYWdlcztcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlU21hbGxJbWFnZXMoZG9jOiBEb2N1bWVudCwgc21hbGxJbWFnZXM6IFNldDxzdHJpbmc+KSB7XG5cdFx0bGV0IHJlbW92ZWRDb3VudCA9IDA7XG5cblx0XHRbJ2ltZycsICdzdmcnXS5mb3JFYWNoKHRhZyA9PiB7XG5cdFx0XHRjb25zdCBlbGVtZW50cyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuXHRcdFx0QXJyYXkuZnJvbShlbGVtZW50cykuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdFx0Y29uc3QgaWRlbnRpZmllciA9IHRoaXMuZ2V0RWxlbWVudElkZW50aWZpZXIoZWxlbWVudCk7XG5cdFx0XHRcdGlmIChpZGVudGlmaWVyICYmIHNtYWxsSW1hZ2VzLmhhcyhpZGVudGlmaWVyKSkge1xuXHRcdFx0XHRcdGVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0cmVtb3ZlZENvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIHNtYWxsIGVsZW1lbnRzOicsIHJlbW92ZWRDb3VudCk7XG5cdH1cblxuXHRwcml2YXRlIGdldEVsZW1lbnRJZGVudGlmaWVyKGVsZW1lbnQ6IEVsZW1lbnQpOiBzdHJpbmcgfCBudWxsIHtcblx0XHQvLyBUcnkgdG8gY3JlYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIgdXNpbmcgdmFyaW91cyBhdHRyaWJ1dGVzXG5cdFx0aWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG5cdFx0XHQvLyBGb3IgbGF6eS1sb2FkZWQgaW1hZ2VzLCB1c2UgZGF0YS1zcmMgYXMgaWRlbnRpZmllciBpZiBhdmFpbGFibGVcblx0XHRcdGNvbnN0IGRhdGFTcmMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblx0XHRcdGlmIChkYXRhU3JjKSByZXR1cm4gYHNyYzoke2RhdGFTcmN9YDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3JjID0gZWxlbWVudC5zcmMgfHwgJyc7XG5cdFx0XHRjb25zdCBzcmNzZXQgPSBlbGVtZW50LnNyY3NldCB8fCAnJztcblx0XHRcdGNvbnN0IGRhdGFTcmNzZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmNzZXQnKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNyYykgcmV0dXJuIGBzcmM6JHtzcmN9YDtcblx0XHRcdGlmIChzcmNzZXQpIHJldHVybiBgc3Jjc2V0OiR7c3Jjc2V0fWA7XG5cdFx0XHRpZiAoZGF0YVNyY3NldCkgcmV0dXJuIGBzcmNzZXQ6JHtkYXRhU3Jjc2V0fWA7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaWQgPSBlbGVtZW50LmlkIHx8ICcnO1xuXHRcdGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lIHx8ICcnO1xuXHRcdGNvbnN0IHZpZXdCb3ggPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJycgOiAnJztcblx0XHRcblx0XHRpZiAoaWQpIHJldHVybiBgaWQ6JHtpZH1gO1xuXHRcdGlmICh2aWV3Qm94KSByZXR1cm4gYHZpZXdCb3g6JHt2aWV3Qm94fWA7XG5cdFx0aWYgKGNsYXNzTmFtZSkgcmV0dXJuIGBjbGFzczoke2NsYXNzTmFtZX1gO1xuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cHJpdmF0ZSBmaW5kTWFpbkNvbnRlbnQoZG9jOiBEb2N1bWVudCk6IEVsZW1lbnQgfCBudWxsIHtcblxuXHRcdC8vIEZpbmQgYWxsIHBvdGVudGlhbCBjb250ZW50IGNvbnRhaW5lcnNcblx0XHRjb25zdCBjYW5kaWRhdGVzOiB7IGVsZW1lbnQ6IEVsZW1lbnQ7IHNjb3JlOiBudW1iZXIgfVtdID0gW107XG5cblx0XHRFTlRSWV9QT0lOVF9FTEVNRU5UUy5mb3JFYWNoKChzZWxlY3RvciwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdFx0ZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdFx0Ly8gQmFzZSBzY29yZSBmcm9tIHNlbGVjdG9yIHByaW9yaXR5IChlYXJsaWVyID0gaGlnaGVyKVxuXHRcdFx0XHRsZXQgc2NvcmUgPSAoRU5UUllfUE9JTlRfRUxFTUVOVFMubGVuZ3RoIC0gaW5kZXgpICogMTA7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgc2NvcmUgYmFzZWQgb24gY29udGVudCBhbmFseXNpc1xuXHRcdFx0XHRzY29yZSArPSB0aGlzLnNjb3JlRWxlbWVudChlbGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNhbmRpZGF0ZXMucHVzaCh7IGVsZW1lbnQsIHNjb3JlIH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdC8vIEZhbGwgYmFjayB0byBzY29yaW5nIGJsb2NrIGVsZW1lbnRzXG5cdFx0XHQvLyBDdXJyZW50bHkgPGJvZHk+IGVsZW1lbnQgaXMgdXNlZCBhcyB0aGUgZmFsbGJhY2ssIHNvIHRoaXMgaXMgbm90IHVzZWRcblx0XHRcdHJldHVybiB0aGlzLmZpbmRDb250ZW50QnlTY29yaW5nKGRvYyk7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBieSBzY29yZSBkZXNjZW5kaW5nXG5cdFx0Y2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG5cdFx0XG5cdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdHRoaXMuX2xvZygnQ29udGVudCBjYW5kaWRhdGVzOicsIGNhbmRpZGF0ZXMubWFwKGMgPT4gKHtcblx0XHRcdFx0ZWxlbWVudDogYy5lbGVtZW50LnRhZ05hbWUsXG5cdFx0XHRcdHNlbGVjdG9yOiB0aGlzLmdldEVsZW1lbnRTZWxlY3RvcihjLmVsZW1lbnQpLFxuXHRcdFx0XHRzY29yZTogYy5zY29yZVxuXHRcdFx0fSkpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2FuZGlkYXRlc1swXS5lbGVtZW50O1xuXHR9XG5cblx0cHJpdmF0ZSBmaW5kQ29udGVudEJ5U2NvcmluZyhkb2M6IERvY3VtZW50KTogRWxlbWVudCB8IG51bGwge1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnNjb3JlRWxlbWVudHMoZG9jKTtcblx0XHRyZXR1cm4gY2FuZGlkYXRlcy5sZW5ndGggPiAwID8gY2FuZGlkYXRlc1swXS5lbGVtZW50IDogbnVsbDtcblx0fVxuXG5cdHByaXZhdGUgZ2V0RWxlbWVudFNlbGVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGxldCBjdXJyZW50OiBFbGVtZW50IHwgbnVsbCA9IGVsZW1lbnQ7XG5cdFx0XG5cdFx0d2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gdGhpcy5kb2MuZG9jdW1lbnRFbGVtZW50KSB7XG5cdFx0XHRsZXQgc2VsZWN0b3IgPSBjdXJyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChjdXJyZW50LmlkKSB7XG5cdFx0XHRcdHNlbGVjdG9yICs9ICcjJyArIGN1cnJlbnQuaWQ7XG5cdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnQuY2xhc3NOYW1lICYmIHR5cGVvZiBjdXJyZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0c2VsZWN0b3IgKz0gJy4nICsgY3VycmVudC5jbGFzc05hbWUudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbignLicpO1xuXHRcdFx0fVxuXHRcdFx0cGFydHMudW5zaGlmdChzZWxlY3Rvcik7XG5cdFx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcGFydHMuam9pbignID4gJyk7XG5cdH1cblxuXHRwcml2YXRlIHNjb3JlRWxlbWVudHMoZG9jOiBEb2N1bWVudCk6IENvbnRlbnRTY29yZVtdIHtcblx0XHRjb25zdCBjYW5kaWRhdGVzOiBDb250ZW50U2NvcmVbXSA9IFtdO1xuXG5cdFx0QkxPQ0tfRUxFTUVOVFMuZm9yRWFjaCgodGFnOiBzdHJpbmcpID0+IHtcblx0XHRcdEFycmF5LmZyb20oZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZykpLmZvckVhY2goKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2NvcmUgPSB0aGlzLnNjb3JlRWxlbWVudChlbGVtZW50KTtcblx0XHRcdFx0aWYgKHNjb3JlID4gMCkge1xuXHRcdFx0XHRcdGNhbmRpZGF0ZXMucHVzaCh7IHNjb3JlLCBlbGVtZW50IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcblx0fVxuXG5cdHByaXZhdGUgc2NvcmVFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiBudW1iZXIge1xuXHRcdGxldCBzY29yZSA9IDA7XG5cblx0XHQvLyBTY29yZSBiYXNlZCBvbiBlbGVtZW50IHByb3BlcnRpZXNcblx0XHRjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gXG5cdFx0XHRlbGVtZW50LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpIDogJyc7XG5cdFx0Y29uc3QgaWQgPSBlbGVtZW50LmlkID8gZWxlbWVudC5pZC50b0xvd2VyQ2FzZSgpIDogJyc7XG5cblx0XHQvLyBTY29yZSBiYXNlZCBvbiBjb250ZW50XG5cdFx0Y29uc3QgdGV4dCA9IGVsZW1lbnQudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0Y29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLykubGVuZ3RoO1xuXHRcdHNjb3JlICs9IE1hdGgubWluKE1hdGguZmxvb3Iod29yZHMgLyAxMDApLCAzKTtcblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIGxpbmsgZGVuc2l0eVxuXHRcdGNvbnN0IGxpbmtzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXHRcdGNvbnN0IGxpbmtUZXh0ID0gQXJyYXkuZnJvbShsaW5rcykucmVkdWNlKChhY2MsIGxpbmspID0+IGFjYyArIChsaW5rLnRleHRDb250ZW50Py5sZW5ndGggfHwgMCksIDApO1xuXHRcdGNvbnN0IGxpbmtEZW5zaXR5ID0gdGV4dC5sZW5ndGggPyBsaW5rVGV4dCAvIHRleHQubGVuZ3RoIDogMDtcblx0XHRpZiAobGlua0RlbnNpdHkgPiAwLjUpIHtcblx0XHRcdHNjb3JlIC09IDEwO1xuXHRcdH1cblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIHByZXNlbmNlIG9mIG1lYW5pbmdmdWwgZWxlbWVudHNcblx0XHRjb25zdCBwYXJhZ3JhcGhzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncCcpLmxlbmd0aDtcblx0XHRzY29yZSArPSBwYXJhZ3JhcGhzO1xuXG5cdFx0Y29uc3QgaW1hZ2VzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJykubGVuZ3RoO1xuXHRcdHNjb3JlICs9IE1hdGgubWluKGltYWdlcyAqIDMsIDkpO1xuXG5cdFx0cmV0dXJuIHNjb3JlO1xuXHR9XG59ICIsIi8vIEVudHJ5IHBvaW50IGVsZW1lbnRzXG4vLyBUaGVzZSBhcmUgdGhlIGVsZW1lbnRzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgdGhlIG1haW4gY29udGVudFxuZXhwb3J0IGNvbnN0IEVOVFJZX1BPSU5UX0VMRU1FTlRTID0gW1xuXHQnYXJ0aWNsZScsXG5cdCdbcm9sZT1cImFydGljbGVcIl0nLFxuXHQnLnBvc3QtY29udGVudCcsXG5cdCcuYXJ0aWNsZS1jb250ZW50Jyxcblx0JyNhcnRpY2xlLWNvbnRlbnQnLFxuXHQnLmNvbnRlbnQtYXJ0aWNsZScsXG5cdCdtYWluJyxcblx0J1tyb2xlPVwibWFpblwiXScsXG5cdCdib2R5JyAvLyBlbnN1cmVzIHRoZXJlIGlzIGFsd2F5cyBhIG1hdGNoXG5dO1xuXG5leHBvcnQgY29uc3QgTU9CSUxFX1dJRFRIID0gNjAwO1xuZXhwb3J0IGNvbnN0IEJMT0NLX0VMRU1FTlRTID0gWydkaXYnLCAnc2VjdGlvbicsICdhcnRpY2xlJywgJ21haW4nXTtcblxuLy8gRWxlbWVudHMgdGhhdCBzaG91bGQgbm90IGJlIHVud3JhcHBlZFxuZXhwb3J0IGNvbnN0IFBSRVNFUlZFX0VMRU1FTlRTID0gbmV3IFNldChbXG5cdCdwcmUnLCAnY29kZScsICd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0cicsICd0ZCcsICd0aCcsXG5cdCd1bCcsICdvbCcsICdsaScsICdkbCcsICdkdCcsICdkZCcsXG5cdCdmaWd1cmUnLCAnZmlnY2FwdGlvbicsICdwaWN0dXJlJyxcblx0J2RldGFpbHMnLCAnc3VtbWFyeScsXG5cdCdibG9ja3F1b3RlJyxcblx0J2Zvcm0nLCAnZmllbGRzZXQnXG5dKTtcblxuLy8gSW5saW5lIGVsZW1lbnRzIHRoYXQgc2hvdWxkIG5vdCBiZSB1bndyYXBwZWRcbmV4cG9ydCBjb25zdCBJTkxJTkVfRUxFTUVOVFMgPSBuZXcgU2V0KFtcblx0J2EnLCAnc3BhbicsICdzdHJvbmcnLCAnZW0nLCAnaScsICdiJywgJ3UnLCAnY29kZScsICdicicsICdzbWFsbCcsXG5cdCdzdWInLCAnc3VwJywgJ21hcmsnLCAnZGVsJywgJ2lucycsICdxJywgJ2FiYnInLCAnY2l0ZScsICd0aW1lJ1xuXSk7XG5cbi8vIEhpZGRlbiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkXG5leHBvcnQgY29uc3QgSElEREVOX0VMRU1FTlRfU0VMRUNUT1JTID0gW1xuXHQnW2hpZGRlbl0nLFxuLy9cdCdbYXJpYS1oaWRkZW49XCJ0cnVlXCJdJywgbmVlZGVkIGZvciBtYXRoIGZvcm11bGFzXG4vL1x0J1tzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdJywgbmVlZGVkIGZvciBmb3IgbWF0aCBmb3JtdWxhc1xuLy9cdCdbc3R5bGUqPVwiZGlzcGxheTpub25lXCJdJyxcblx0J1tzdHlsZSo9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIl0nLFxuXHQnW3N0eWxlKj1cInZpc2liaWxpdHk6aGlkZGVuXCJdJyxcblx0Jy5oaWRkZW4nLFxuXHQnLmludmlzaWJsZSdcbl0uam9pbignLCcpO1xuXG4vLyBTZWxlY3RvcnMgdG8gYmUgcmVtb3ZlZFxuZXhwb3J0IGNvbnN0IEVYQUNUX1NFTEVDVE9SUyA9IFtcblx0Ly8gc2NyaXB0cywgc3R5bGVzXG5cdCdub3NjcmlwdCcsXG5cdCdzY3JpcHQ6bm90KFt0eXBlXj1cIm1hdGgvXCJdKScsXG5cdCdzdHlsZScsXG5cblx0Ly8gYWRzXG5cdCcuYWQ6bm90KFtjbGFzcyo9XCJncmFkaWVudFwiXSknLFxuXHQnW2NsYXNzXj1cImFkLVwiIGldJyxcblx0J1tjbGFzcyQ9XCItYWRcIiBpXScsXG5cdCdbaWRePVwiYWQtXCIgaV0nLFxuXHQnW2lkJD1cIi1hZFwiIGldJyxcblx0J1tyb2xlPVwiYmFubmVyXCIgaV0nLFxuXHQnLnByb21vJyxcblx0Jy5Qcm9tbycsXG5cdCcjYmFycmllci1wYWdlJywgLy8gZnQuY29tXG5cblx0Ly8gY29tbWVudHNcblx0J1tpZD1cImNvbW1lbnRzXCIgaV0nLFxuXG5cdC8vIGhlYWRlciwgbmF2XG5cdCdoZWFkZXInLFxuXHQnLmhlYWRlcicsXG5cdCcjaGVhZGVyJyxcblx0J25hdicsXG5cdCcubmF2aWdhdGlvbicsXG5cdCcjbmF2aWdhdGlvbicsXG5cdCdbcm9sZT1cIm5hdmlnYXRpb25cIiBpXScsXG5cdCdbcm9sZT1cImRpYWxvZ1wiIGldJyxcblx0J1tyb2xlKj1cImNvbXBsZW1lbnRhcnlcIiBpXScsXG5cdCdbY2xhc3MqPVwicGFnaW5hdGlvblwiIGldJyxcblx0Jy5tZW51Jyxcblx0JyNtZW51Jyxcblx0JyNzaXRlU3ViJyxcblxuXHQvLyBtZXRhZGF0YVxuXHQnLmF1dGhvcicsXG5cdCcuQXV0aG9yJyxcblx0Jy5jb250cmlidXRvcicsXG5cdCcuZGF0ZScsXG5cdCcubWV0YScsXG5cdCcudGFncycsXG5cdCcudG9jJyxcblx0Jy5Ub2MnLFxuXHQnI3RvYycsXG5cdCcjdGl0bGUnLFxuXHQnI1RpdGxlJyxcblx0J1tocmVmKj1cIi9jYXRlZ29yeVwiXScsXG5cdCdbaHJlZio9XCIvY2F0ZWdvcmllc1wiXScsXG5cdCdbaHJlZio9XCIvdGFnL1wiXScsXG5cdCdbaHJlZio9XCIvdGFncy9cIl0nLFxuXHQnW2hyZWYqPVwiL3RvcGljc1wiXScsXG5cdCdbaHJlZio9XCJhdXRob3JcIl0nLFxuXHQnW2hyZWY9XCIjc2l0ZS1jb250ZW50XCJdJyxcblx0J1tzcmMqPVwiYXV0aG9yXCJdJyxcblxuXHQvLyBmb290ZXJcblx0J2Zvb3RlcicsXG5cblx0Ly8gaW5wdXRzLCBmb3JtcywgZWxlbWVudHNcblx0J2FzaWRlJyxcblx0J2J1dHRvbicsXG5cdFx0Ly8gJ1tyb2xlPVwiYnV0dG9uXCJdJywgTWVkaXVtIGltYWdlc1xuXHQnY2FudmFzJyxcblx0J2RpYWxvZycsXG5cdCdmaWVsZHNldCcsXG5cdCdmb3JtJyxcblx0J2lucHV0Om5vdChbdHlwZT1cImNoZWNrYm94XCJdKScsXG5cdCdsYWJlbCcsXG5cdCdsaW5rJyxcblx0J29wdGlvbicsXG5cdCdzZWxlY3QnLFxuXHQndGV4dGFyZWEnLFxuXHQndGltZScsXG5cblx0Ly8gaWZyYW1lc1xuXHQnaW5zdGFyZWFkLXBsYXllcicsXG5cdCdpZnJhbWU6bm90KFtzcmMqPVwieW91dHViZVwiXSk6bm90KFtzcmMqPVwieW91dHUuYmVcIl0pOm5vdChbc3JjKj1cInZpbWVvXCJdKTpub3QoW3NyYyo9XCJ0d2l0dGVyXCJdKScsXG5cblx0Ly8gbG9nb3Ncblx0J1tjbGFzcz1cImxvZ29cIiBpXScsXG5cdCcjbG9nbycsXG5cdCcjTG9nbycsXG5cblx0Ly8gbmV3c2xldHRlclxuXHQnI25ld3NsZXR0ZXInLFxuXHQnI05ld3NsZXR0ZXInLFxuXG5cdC8vIGhpZGRlbiBmb3IgcHJpbnRcblx0Jy5ub3ByaW50Jyxcblx0J1tkYXRhLWxpbmstbmFtZSo9XCJza2lwXCIgaV0nLFxuXHQnW2RhdGEtcHJpbnQtbGF5b3V0PVwiaGlkZVwiIGldJyxcblx0J1tkYXRhLWJsb2NrPVwiZG9ub3RwcmludFwiIGldJyxcblxuXHQvLyBmb290bm90ZXMsIGNpdGF0aW9uc1xuXHQnW2NsYXNzKj1cImNsaWNrYWJsZS1pY29uXCIgaV0nLFxuXHQnbGkgc3BhbltjbGFzcyo9XCJsdHhfdGFnXCIgaV1bY2xhc3MqPVwibHR4X3RhZ19pdGVtXCIgaV0nLFxuXHQnYVtocmVmXj1cIiNcIl1bY2xhc3MqPVwiYW5jaG9yXCIgaV0nLFxuXHQnYVtocmVmXj1cIiNcIl1bY2xhc3MqPVwicmVmXCIgaV0nLFxuXG5cdC8vIGxpbmsgbGlzdHNcblx0J1tkYXRhLWNvbnRhaW5lcio9XCJtb3N0LXZpZXdlZFwiIGldJyxcblxuXHQvLyBzaWRlYmFyXG5cdCcuc2lkZWJhcicsXG5cdCcuU2lkZWJhcicsXG5cdCcjc2lkZWJhcicsXG5cdCcjU2lkZWJhcicsXG5cdCcjc2l0ZXN1YicsXG5cdFxuXHQvLyBvdGhlclxuXHQnI3ByaW1hcnlhdWRpbycsIC8vIE5QUlxuXHQnI05ZVF9BQk9WRV9NQUlOX0NPTlRFTlRfUkVHSU9OJyxcblx0J1tkYXRhLXRlc3RpZD1cInBob3Rvdmlld2VyLWNoaWxkcmVuLWZpZ3VyZVwiXSA+IHNwYW4nLCAvLyBOZXcgWW9yayBUaW1lc1xuXHQndGFibGUuaW5mb2JveCcsXG5cdCcucGVuY3JhZnQ6bm90KC5wYy1kaXNwbGF5LWNvbnRlbnRzKScsIC8vIFN1YnN0YWNrXG5cdCdbZGF0YS1vcHRpbWl6ZWx5PVwicmVsYXRlZC1hcnRpY2xlcy1zZWN0aW9uXCIgaV0nIC8vIFRoZSBFY29ub21pc3Rcbl07XG5cbi8vIFJlbW92YWwgcGF0dGVybnMgdGVzdGVkIGFnYWluc3QgYXR0cmlidXRlczogY2xhc3MsIGlkLCBkYXRhLXRlc3RpZCwgYW5kIGRhdGEtcWFcbi8vIENhc2UgaW5zZW5zaXRpdmUsIHBhcnRpYWwgbWF0Y2hlcyBhbGxvd2VkXG5leHBvcnQgY29uc3QgUEFSVElBTF9TRUxFQ1RPUlMgPSBbXG5cdCdhY2Nlc3Mtd2FsbCcsXG5cdCdhY3Rpdml0eXB1YicsXG5cdCdhY3Rpb25jYWxsJyxcblx0J2FwcGVuZGl4Jyxcblx0J2F2YXRhcicsXG5cdCdhZHZlcnQnLFxuXHQnLWFkLScsXG5cdCdfYWRfJyxcblx0J2FsbHRlcm1zJyxcblx0J2FsZXJ0LWJveCcsXG5cdCdhcm91bmQtdGhlLXdlYicsXG5cdCdhcnRpY2xlLWJvdHRvbS1zZWN0aW9uJyxcblx0J2FydGljbGVfX2NvcHknLFxuXHQnYXJ0aWNsZV9kYXRlJyxcblx0J2FydGljbGUtZW5kICcsXG5cdCdhcnRpY2xlX2hlYWRlcicsXG5cdCdhcnRpY2xlX19oZWFkZXInLFxuXHQnYXJ0aWNsZV9faW5mbycsXG5cdCdhcnRpY2xlLWluZm8nLFxuXHQnYXJ0aWNsZV9fbWV0YScsXG5cdCdhcnRpY2xlLXN1YmplY3QnLFxuXHQnYXJ0aWNsZV9zdWJqZWN0Jyxcblx0J2FydGljbGUtc25pcHBldCcsXG5cdCdhcnRpY2xlLXNlcGFyYXRvcicsXG5cdCdhcnRpY2xlLS1zaGFyZScsXG5cdCdhcnRpY2xlLS10b3BpY3MnLFxuXHQnYXJ0aWNsZXRhZ3MnLFxuXHQnYXJ0aWNsZS10YWdzJyxcblx0J2FydGljbGVfdGFncycsXG5cdCdhcnRpY2xlLXRpdGxlJyxcblx0J2FydGljbGVfdGl0bGUnLFxuXHQnYXJ0aWNsZXRvcGljcycsXG5cdCdhcnRpY2xlLXRvcGljcycsXG5cdCdhcnRpY2xlLXR5cGUnLFxuXHQnYXJ0aWNsZS0tbGVkZScsIC8vIFRoZSBWZXJnZVxuXHQnYXJ0aWNsZXdlbGwnLFxuXHQnYXNzb2NpYXRlZC1wZW9wbGUnLFxuXHQnYXVkaW8tY2FyZCcsXG4vL1x0J2F1dGhvcicsIEd3ZXJuXG5cdCdhdXRob3JlZC1ieScsXG5cdCdhdXRob3ItYm94Jyxcblx0J2F1dGhvci1uYW1lJyxcblx0J2F1dGhvci1iaW8nLFxuXHQnYXV0aG9yLW1pbmktYmlvJyxcblx0J2JhY2stdG8tdG9wJyxcblx0J2JhY2tsaW5rcy1zZWN0aW9uJyxcblx0J2Jhbm5lcicsXG5cdCdiaW8tYmxvY2snLFxuXHQnYmxvZy1wYWdlcicsXG5cdCdib29rbWFyay0nLFxuXHQnLWJvb2ttYXJrJyxcblx0J2JvdHRvbS1vZi1hcnRpY2xlJyxcblx0J2JyYW5kLWJhcicsXG5cdCdicmVhZGNydW1iJyxcblx0J2J1dHRvbi13cmFwcGVyJyxcblx0J2J0bi0nLFxuXHQnLWJ0bicsXG5cdCdieWxpbmUnLFxuXHQnY2FwdGNoYScsXG5cdCdjYXJkLXRleHQnLFxuXHQnY2FyZC1tZWRpYScsXG5cdCdjYXRfaGVhZGVyJyxcblx0J2NhdGxpbmtzJyxcblx0J2NoYXB0ZXItbGlzdCcsIC8vIFRoZSBFY29ub21pc3Rcblx0J2NvbGxlY3Rpb25zJyxcblx0J2NvbW1lbnRzJyxcbi8vXHQnLWNvbW1lbnQnLCBTeW50YXggaGlnaGxpZ2h0aW5nXG5cdCdjb21tZW50Ym94Jyxcblx0J2NvbW1lbnQtY291bnQnLFxuXHQnY29tbWVudC1jb250ZW50Jyxcblx0J2NvbW1lbnQtZm9ybScsXG5cdCdjb21tZW50LW51bWJlcicsXG5cdCdjb21tZW50LXJlc3BvbmQnLFxuXHQnY29tbWVudC10aHJlYWQnLFxuXHQnY29tcGxlbWVudGFyeScsXG5cdCdjb25zZW50Jyxcblx0J2NvbnRlbnQtY2FyZCcsIC8vIFRoZSBWZXJnZVxuXHQnY29udGVudC10b3BpY3MnLFxuXHQnY29udGVudHByb21vJyxcblx0J2NvbnRleHQtd2lkZ2V0JywgLy8gUmV1dGVyc1xuXHQnY29yZS1jb2xsYXRlcmFsJyxcblx0J19jdGEnLFxuXHQnLWN0YScsXG5cdCdjdGEtJyxcblx0J2N0YV8nLFxuXHQnY3VycmVudC1pc3N1ZScsIC8vIFRoZSBOYXRpb25cblx0J2N1c3RvbS1saXN0LW51bWJlcicsXG5cdCdkYXRlbGluZScsXG5cdCdkYXRlaGVhZGVyJyxcblx0J2RhdGUtaGVhZGVyJyxcblx0J2RhdGVfaGVhZGVyLScsXG4vL1x0J2RpYWxvZycsXG5cdCdkaXNjbGFpbWVyJyxcblx0J2Rpc2Nsb3N1cmUnLFxuXHQnZGlzY3Vzc2lvbicsXG5cdCdkaXNjdXNzXycsXG5cdCdkaXNxdXMnLFxuXHQnZG9uYXRlJyxcblx0J2Ryb3Bkb3duJywgLy8gQXJzIFRlY2huaWNhXG5cdCdlbGV0dGVycycsXG5cdCdlbWFpbHNpZ251cCcsXG5cdCdlbmdhZ2VtZW50LXdpZGdldCcsXG5cdCdlbnRyeS1hdXRob3ItaW5mbycsXG5cdCdlbnRyeS1jYXRlZ29yaWVzJyxcblx0J2VudHJ5LWRhdGUnLFxuXHQnZW50cnktbWV0YScsXG5cdCdlbnRyeS10aXRsZScsXG5cdCdlbnRyeS11dGlsaXR5Jyxcblx0J2V5ZWJyb3cnLFxuXHQnZXhwYW5kLXJlZHVjZScsXG5cdCdleHRlcm5hbGxpbmtlbWJlZHdyYXBwZXInLCAvLyBUaGUgTmV3IFlvcmtlclxuXHQnZXh0cmEtc2VydmljZXMnLFxuXHQnZXh0cmEtdGl0bGUnLFxuXHQnZmFjZWJvb2snLFxuXHQnZmF2b3JpdGUnLFxuXHQnZmVlZGJhY2snLFxuXHQnZmVlZC1saW5rcycsXG5cdCdmaWVsZC1zaXRlLXNlY3Rpb25zJyxcblx0J2ZpeGVkJyxcblx0J2Zsb2F0aW5nLXZpZCcsXG5cdCdmb2xsb3cnLFxuXHQnZm9vdGVyJyxcblx0J2Zvb3Rub3RlLWJhY2snLFxuXHQnZm9vdG5vdGViYWNrJyxcblx0J2Zvci15b3UnLFxuXHQnZnJvbnRtYXR0ZXInLFxuXHQnZnVydGhlci1yZWFkaW5nJyxcblx0J2dpc3QtbWV0YScsXG4vL1x0J2dsb2JhbCcsXG5cdCdnb29nbGUnLFxuXHQnZ29vZy0nLFxuXHQnZ3JhcGgtdmlldycsXG5cdCdoZWFkZXItbG9nbycsXG5cdCdoZWFkZXItcGF0dGVybicsIC8vIFRoZSBWZXJnZVxuXHQnaGVyby1saXN0Jyxcblx0J2hpZGUtZm9yLXByaW50Jyxcblx0J2hpZGUtcHJpbnQnLFxuXHQnaGlkZS13aGVuLW5vLXNjcmlwdCcsXG5cdCdoaWRkZW4tc2lkZW5vdGUnLFxuXHQnaW50ZXJsdWRlJyxcblx0J2ludGVyYWN0aW9uJyxcblx0J2p1bXBsaW5rJyxcblx0J2p1bXAtdG8tJyxcbi8vXHQna2V5d29yZCcsIC8vIHVzZWQgaW4gc3ludGF4IGhpZ2hsaWdodGluZ1xuXHQna2lja2VyJyxcblx0J2xhYnN0YWInLCAvLyBBcnhpdlxuXHQnLWxhYmVscycsXG5cdCdsYW5ndWFnZS1uYW1lJyxcblx0J2xhdGVzdC1jb250ZW50Jyxcblx0Jy1sZWRlcy0nLCAvLyBUaGUgVmVyZ2Vcblx0Jy1saWNlbnNlJyxcblx0J2xpbmstYm94Jyxcblx0J2xpbmtzLWdyaWQnLCAvLyBCQkNcblx0J2xpbmtzLXRpdGxlJywgLy8gQkJDXG5cdCdsaXN0aW5nLWR5bmFtaWMtdGVybXMnLCAvLyBCb3N0b24gUmV2aWV3XG5cdCdsaXN0LXRhZ3MnLFxuXHQnbG9hZGluZycsXG5cdCdsb2EtaW5mbycsXG5cdCdsb2dvX2NvbnRhaW5lcicsXG5cdCdsdHhfcm9sZV9yZWZudW0nLCAvLyBBcnhpdlxuXHQnbHR4X3RhZ19iaWJpdGVtJyxcblx0J2x0eF9lcnJvcicsXG5cdCdtYXJrZXRpbmcnLFxuXHQnbWVkaWEtaW5xdWlyeScsXG5cdCdtZW51LScsXG5cdCdtZXRhLScsXG5cdCdtZXRhZGF0YScsXG5cdCdtaWdodC1saWtlJyxcblx0J19tb2RhbCcsXG5cdCctbW9kYWwnLFxuXHQnbW9yZS0nLFxuXHQnbW9yZW5ld3MnLFxuXHQnbW9yZXN0b3JpZXMnLFxuXHQnbW92ZS1oZWxwZXInLFxuXHQnbXctZWRpdHNlY3Rpb24nLFxuXHQnbXctY2l0ZS1iYWNrbGluaycsXG5cdCdtdy1pbmRpY2F0b3JzJyxcblx0J213LWp1bXAtbGluaycsXG5cdCduYXYtJyxcblx0J25hdl8nLFxuXHQnbmF2YmFyJyxcbi8vXHQnbmF2aWdhdGlvbicsXG5cdCduZXh0LScsXG5cdCduZXdzLXN0b3J5LXRpdGxlJyxcbi8vXHQnbmV3c2xldHRlcicsIHVzZWQgb24gU3Vic3RhY2tcblx0J25ld3NsZXR0ZXJfJyxcblx0J25ld3NsZXR0ZXItc2lnbnVwJyxcblx0J25ld3NsZXR0ZXJzaWdudXAnLFxuXHQnbmV3c2xldHRlcndpZGdldCcsXG5cdCduZXdzbGV0dGVyd3JhcHBlcicsXG5cdCdub3QtZm91bmQnLFxuXHQnbm9tb2JpbGUnLFxuXHQnbm9wcmludCcsXG5cdCdvcmlnaW5hbGx5LXB1Ymxpc2hlZCcsIC8vIE1lcmN1cnkgTmV3c1xuXHQnb3V0bGluZS12aWV3Jyxcblx0J292ZXJsYXknLFxuXHQncGFnZS10aXRsZScsXG5cdCctcGFydG5lcnMnLFxuXHQncGxlYScsXG5cdCdwb3B1bGFyJyxcbi8vXHQncG9wdXAnLCBHd2VyblxuXHQncG9wLXVwJyxcblx0J3BvcG92ZXInLFxuXHQncG9zdC1ib3R0b20nLFxuXHQncG9zdF9fY2F0ZWdvcnknLFxuXHQncG9zdGNvbW1lbnQnLFxuXHQncG9zdGRhdGUnLFxuXHQncG9zdC1hdXRob3InLFxuXHQncG9zdC1kYXRlJyxcblx0J3Bvc3RfZGF0ZScsXG5cdCdwb3N0LWZlZWRzJyxcblx0J3Bvc3RpbmZvJyxcblx0J3Bvc3QtaW5mbycsXG5cdCdwb3N0X2luZm8nLFxuXHQncG9zdC1pbmxpbmUtZGF0ZScsXG5cdCdwb3N0LWxpbmtzJyxcblx0J3Bvc3QtbWV0YScsXG5cdCdwb3N0bWV0YScsXG5cdCdwb3N0c25pcHBldCcsXG5cdCdwb3N0X3NuaXBwZXQnLFxuXHQncG9zdC1zbmlwcGV0Jyxcblx0J3Bvc3R0aXRsZScsXG5cdCdwb3N0LXRpdGxlJyxcblx0J3Bvc3RfdGl0bGUnLFxuXHQncG9zdHRheCcsXG5cdCdwb3N0LXRheCcsXG5cdCdwb3N0X3RheCcsXG5cdCdwb3N0dGFnJyxcblx0J3Bvc3RfdGFnJyxcblx0J3Bvc3QtdGFnJyxcbi8vXHQncHJldmlldycsIHVzZWQgb24gT2JzaWRpYW4gUHVibGlzaFxuXHQncHJldm5leHQnLFxuXHQncHJldmlvdXNuZXh0Jyxcblx0J3ByZXNzLWlucXVpcmllcycsXG5cdCdwcmludC1ub25lJyxcblx0J3ByaW50LWhlYWRlcicsXG5cdCdwcm9maWxlJyxcbi8vXHQncHJvbW8nLFxuXHQncHJvbW8tYm94Jyxcblx0J3B1YmRhdGUnLFxuXHQncHViX2RhdGUnLFxuXHQncHViLWRhdGUnLFxuXHQncHVibGljYXRpb24tZGF0ZScsXG5cdCdwdWJsaWNhdGlvbk5hbWUnLCAvLyBNZWRpdW1cblx0J3FyLWNvZGUnLFxuXHQncXJfY29kZScsXG5cdCdfcmFpbCcsXG5cdCdyZWFkbW9yZScsXG5cdCdyZWFkLW5leHQnLFxuXHQncmVhZF9uZXh0Jyxcblx0J3JlYWRfdGltZScsXG5cdCdyZWFkLXRpbWUnLFxuXHQncmVhZGluZ190aW1lJyxcblx0J3JlYWRpbmctdGltZScsXG5cdCdyZWFkaW5nLWxpc3QnLFxuXHQncmVjZW50cG9zdCcsXG5cdCdyZWNlbnRfcG9zdCcsXG5cdCdyZWNlbnQtcG9zdCcsXG5cdCdyZWNvbW1lbmQnLFxuXHQncmVkaXJlY3RlZGZyb20nLFxuXHQncmVjaXJjJyxcblx0J3JlZ2lzdGVyJyxcblx0J3JlbGF0ZWQnLFxuXHQncmVsZXZhbnQnLFxuXHQncmV2ZXJzZWZvb3Rub3RlJyxcblx0J3NjcmVlbi1yZWFkZXItdGV4dCcsXG4vL1x0J3NoYXJlJyxcbi8vXHQnLXNoYXJlJywgc2NpdGVjaGRhaWx5LmNvbVxuXHQnc2hhcmUtYm94Jyxcblx0J3NoYXJlZGFkZHknLFxuXHQnc2hhcmUtaWNvbnMnLFxuXHQnc2hhcmVsaW5rcycsXG5cdCdzaGFyZS1zZWN0aW9uJyxcblx0J3NpZGViYXJ0aXRsZScsXG5cdCdzaWRlYmFyXycsXG5cdCdzaWRlYmFyLWNvbnRlbnQnLFxuXHQnc2ltaWxhci0nLFxuXHQnc2ltaWxhcl8nLFxuXHQnc2ltaWxhcnMtJyxcblx0J3NpZGVpdGVtcycsXG5cdCdzaWRlLWJveCcsXG5cdCdzaXRlLWluZGV4Jyxcblx0J3NpdGUtaGVhZGVyJyxcblx0J3NpdGUtbG9nbycsXG5cdCdzaXRlLW5hbWUnLFxuLy9cdCdza2lwLScsXG4vL1x0J3NraXAtbGluaycsIFRlY2hDcnVuY2hcblx0J19za2lwLWxpbmsnLFxuXHQnc2x1Zy13cmFwJyxcblx0J3NvY2lhbCcsXG5cdCdzcGVlY2hpZnktaWdub3JlJyxcblx0J3Nwb25zb3InLFxuXHQnc3ByaW5nZXJjaXRhdGlvbicsXG4vL1x0Jy1zdGF0cycsXG5cdCdfc3RhdHMnLFxuXHQnc3RpY2t5Jyxcblx0J3N0b3J5cmVhZHRpbWUnLCAvLyBNZWRpdW1cblx0J3N0b3J5cHVibGlzaGRhdGUnLCAvLyBNZWRpdW1cblx0J3N1YmplY3QtbGFiZWwnLFxuXHQnc3Vic2NyaWJlJyxcblx0J190YWdzJyxcblx0J3RhZ3NfX2l0ZW0nLFxuXHQndGFnX2xpc3QnLFxuXHQndGF4b25vbXknLFxuXHQndGFibGUtb2YtY29udGVudHMnLFxuXHQndGFicy0nLFxuLy9cdCd0ZWFzZXInLCBOYXR1cmVcblx0J3Rlcm1pbmFsdG91dCcsXG5cdCd0aW1lLXJ1YnJpYycsXG5cdCd0aW1lc3RhbXAnLFxuXHQndGlwX29mZicsXG5cdCd0aXB0b3V0Jyxcblx0Jy10b3V0LScsXG5cdCctdG9jJyxcblx0J3RvZ2dsZS1jYXB0aW9uJyxcblx0J3RvcGljLWxpc3QnLFxuXHQndG9vbGJhcicsXG5cdCd0b29sdGlwJyxcblx0J3RvcC13cmFwcGVyJyxcblx0J3RyZWUtaXRlbScsXG5cdCd0cmVuZGluZycsXG5cdCd0cnVzdC1mZWF0Jyxcblx0J3RydXN0LWJhZGdlJyxcblx0J3R3aXR0ZXInLFxuXHQndmlzdWFsbHktaGlkZGVuJyxcblx0J3dlbGNvbWVib3gnXG4vL1x0J3dpZGdldC0nXG5dO1xuXG4vLyBTZWxlY3RvcnMgZm9yIGZvb3Rub3RlcyBhbmQgY2l0YXRpb25zXG5leHBvcnQgY29uc3QgRk9PVE5PVEVfSU5MSU5FX1JFRkVSRU5DRVMgPSBbXG5cdCdzdXAucmVmZXJlbmNlJyxcblx0J2NpdGUubHR4X2NpdGUnLFxuXHQnc3VwW2lkXj1cImZuclwiXScsXG5cdCdzdXBbaWRePVwiZm5yZWY6XCJdJyxcblx0J3NwYW4uZm9vdG5vdGUtbGluaycsXG5cdCdhLmNpdGF0aW9uJyxcblx0J2FbaWRePVwicmVmLWxpbmtcIl0nLFxuXHQnYVtocmVmXj1cIiNmblwiXScsXG5cdCdhW2hyZWZePVwiI2NpdGVcIl0nLFxuXHQnYVtocmVmXj1cIiNyZWZlcmVuY2VcIl0nLFxuXHQnYVtocmVmXj1cIiNmb290bm90ZVwiXScsXG5cdCdhW2hyZWZePVwiI3JcIl0nLCAvLyBDb21tb24gaW4gYWNhZGVtaWMgcGFwZXJzXG5cdCdhW2hyZWZePVwiI2JcIl0nLCAvLyBDb21tb24gZm9yIGJpYmxpb2dyYXBoeSByZWZlcmVuY2VzXG5cdCdhW2hyZWYqPVwiY2l0ZV9ub3RlXCJdJyxcblx0J2FbaHJlZio9XCJjaXRlX3JlZlwiXScsXG5cdCdhLmZvb3Rub3RlLWFuY2hvcicsIC8vIFN1YnN0YWNrXG5cdCdzcGFuLmZvb3Rub3RlLWhvdmVyY2FyZC10YXJnZXQgYScsIC8vIFN1YnN0YWNrXG5cdCdhW3JvbGU9XCJkb2MtYmlibGlvcmVmXCJdJywgLy8gU2NpZW5jZS5vcmdcblx0J2FbaWRePVwiZm5yZWZcIl0nLFxuXHQnYVtpZF49XCJyZWYtbGlua1wiXScsIC8vIE5hdHVyZS5jb21cbl0uam9pbignLCcpO1xuXG5leHBvcnQgY29uc3QgRk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMgPSBbXG5cdCdkaXYuZm9vdG5vdGUgb2wnLFxuXHQnZGl2LmZvb3Rub3RlcyBvbCcsXG5cdCdkaXZbcm9sZT1cImRvYy1lbmRub3Rlc1wiXScsXG5cdCdkaXZbcm9sZT1cImRvYy1mb290bm90ZXNcIl0nLFxuXHQnb2wuZm9vdG5vdGVzLWxpc3QnLFxuXHQnb2wuZm9vdG5vdGVzJyxcblx0J29sLnJlZmVyZW5jZXMnLFxuXHQnb2xbY2xhc3MqPVwiYXJ0aWNsZS1yZWZlcmVuY2VzXCJdJyxcblx0J3NlY3Rpb24uZm9vdG5vdGVzIG9sJyxcblx0J3NlY3Rpb25bcm9sZT1cImRvYy1lbmRub3Rlc1wiXScsXG5cdCdzZWN0aW9uW3JvbGU9XCJkb2MtZm9vdG5vdGVzXCJdJyxcblx0J3NlY3Rpb25bcm9sZT1cImRvYy1iaWJsaW9ncmFwaHlcIl0nLFxuXHQndWwuZm9vdG5vdGVzLWxpc3QnLFxuXHQndWwubHR4X2JpYmxpc3QnLFxuXHQnZGl2LmZvb3Rub3RlW2RhdGEtY29tcG9uZW50LW5hbWU9XCJGb290bm90ZVRvRE9NXCJdJyAvLyBTdWJzdGFja1xuXS5qb2luKCcsJyk7XG5cbi8vIEVsZW1lbnRzIHRoYXQgYXJlIGFsbG93ZWQgdG8gYmUgZW1wdHlcbi8vIFRoZXNlIGFyZSBub3QgcmVtb3ZlZCBldmVuIGlmIHRoZXkgaGF2ZSBubyBjb250ZW50XG5leHBvcnQgY29uc3QgQUxMT1dFRF9FTVBUWV9FTEVNRU5UUyA9IG5ldyBTZXQoW1xuXHQnYXJlYScsXG5cdCdhdWRpbycsXG5cdCdiYXNlJyxcblx0J2JyJyxcblx0J2NpcmNsZScsXG5cdCdjb2wnLFxuXHQnZGVmcycsXG5cdCdlbGxpcHNlJyxcblx0J2VtYmVkJyxcblx0J2ZpZ3VyZScsXG5cdCdnJyxcblx0J2hyJyxcblx0J2lmcmFtZScsXG5cdCdpbWcnLFxuXHQnaW5wdXQnLFxuXHQnbGluZScsXG5cdCdsaW5rJyxcblx0J21hc2snLFxuXHQnbWV0YScsXG5cdCdvYmplY3QnLFxuXHQncGFyYW0nLFxuXHQncGF0aCcsXG5cdCdwYXR0ZXJuJyxcblx0J3BpY3R1cmUnLFxuXHQncG9seWdvbicsXG5cdCdwb2x5bGluZScsXG5cdCdyZWN0Jyxcblx0J3NvdXJjZScsXG5cdCdzdG9wJyxcblx0J3N2ZycsXG5cdCd0ZCcsXG5cdCd0aCcsXG5cdCd0cmFjaycsXG5cdCd1c2UnLFxuXHQndmlkZW8nLFxuXHQnd2JyJ1xuXSk7XG5cbi8vIEF0dHJpYnV0ZXMgdG8ga2VlcFxuZXhwb3J0IGNvbnN0IEFMTE9XRURfQVRUUklCVVRFUyA9IG5ldyBTZXQoW1xuXHQnYWx0Jyxcblx0J2FsbG93Jyxcblx0J2FsbG93ZnVsbHNjcmVlbicsXG5cdCdhcmlhLWxhYmVsJyxcblx0J2NoZWNrZWQnLFxuXHQnY29sc3BhbicsXG5cdCdjb250cm9scycsXG5cdCdkYXRhLWxhdGV4Jyxcblx0J2RhdGEtc3JjJyxcblx0J2RhdGEtc3Jjc2V0Jyxcblx0J2RhdGEtbGFuZycsXG5cdCdkaXInLFxuXHQnZGlzcGxheScsXG5cdCdmcmFtZWJvcmRlcicsXG5cdCdoZWFkZXJzJyxcblx0J2hlaWdodCcsXG5cdCdocmVmJyxcblx0J2xhbmcnLFxuXHQncm9sZScsXG5cdCdyb3dzcGFuJyxcblx0J3NyYycsXG5cdCdzcmNzZXQnLFxuXHQndGl0bGUnLFxuXHQndHlwZScsXG5cdCd3aWR0aCcsXG5cblx0Ly8gTWF0aE1MIGF0dHJpYnV0ZXNcblx0J2FjY2VudCcsXG5cdCdhY2NlbnR1bmRlcicsXG5cdCdhbGlnbicsXG5cdCdjb2x1bW5hbGlnbicsXG5cdCdjb2x1bW5saW5lcycsXG5cdCdjb2x1bW5zcGFjaW5nJyxcblx0J2NvbHVtbnNwYW4nLFxuXHQnZGF0YS1tangtdGV4Y2xhc3MnLFxuXHQnZGVwdGgnLFxuXHQnZGlzcGxheXN0eWxlJyxcblx0J2ZlbmNlJyxcblx0J2ZyYW1lJyxcblx0J2ZyYW1lc3BhY2luZycsXG5cdCdsaW5ldGhpY2tuZXNzJyxcblx0J2xzcGFjZScsXG5cdCdtYXRoc2l6ZScsXG5cdCdtYXRodmFyaWFudCcsXG5cdCdtYXhzaXplJyxcblx0J21pbnNpemUnLFxuXHQnbW92YWJsZWxpbWl0cycsXG5cdCdub3RhdGlvbicsXG5cdCdyb3dhbGlnbicsXG5cdCdyb3dsaW5lcycsXG5cdCdyb3dzcGFjaW5nJyxcblx0J3Jvd3NwYW4nLFxuXHQncnNwYWNlJyxcblx0J3NjcmlwdGxldmVsJyxcblx0J3NlcGFyYXRvcicsXG5cdCdzdHJldGNoeScsXG5cdCdzeW1tZXRyaWMnLFxuXHQndm9mZnNldCcsXG5cdCd4bWxucydcbl0pO1xuZXhwb3J0IGNvbnN0IEFMTE9XRURfQVRUUklCVVRFU19ERUJVRyA9IG5ldyBTZXQoW1xuXHQnY2xhc3MnLFxuXHQnaWQnLFxuXSk7XG5cbi8vIFN1cHBvcnRlZCBsYW5ndWFnZXMgZm9yIGNvZGUgYmxvY2tzXG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0xBTkdVQUdFUyA9IG5ldyBTZXQoW1xuXHQvLyBNYXJrdXAgJiBXZWJcblx0J21hcmt1cCcsICdodG1sJywgJ3htbCcsICdzdmcnLCAnbWF0aG1sJywgJ3NzbWwnLCAnYXRvbScsICdyc3MnLFxuXHQnamF2YXNjcmlwdCcsICdqcycsICdqc3gnLCAndHlwZXNjcmlwdCcsICd0cycsICd0c3gnLFxuXHQnd2ViYXNzZW1ibHknLCAnd2FzbScsXG5cdFxuXHQvLyBDb21tb24gUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzXG5cdCdweXRob24nLFxuXHQnamF2YScsXG5cdCdjc2hhcnAnLCAnY3MnLCAnZG90bmV0JywgJ2FzcG5ldCcsXG5cdCdjcHAnLCAnYysrJywgJ2MnLCAnb2JqYycsXG5cdCdydWJ5JywgJ3JiJyxcblx0J3BocCcsXG5cdCdnb2xhbmcnLFxuXHQncnVzdCcsXG5cdCdzd2lmdCcsXG5cdCdrb3RsaW4nLFxuXHQnc2NhbGEnLFxuXHQnZGFydCcsXG5cdFxuXHQvLyBTaGVsbCAmIFNjcmlwdGluZ1xuXHQnYmFzaCcsICdzaGVsbCcsICdzaCcsXG5cdCdwb3dlcnNoZWxsJyxcblx0J2JhdGNoJyxcblx0XG5cdC8vIERhdGEgJiBDb25maWdcblx0J2pzb24nLCAnanNvbnAnLFxuXHQneWFtbCcsICd5bWwnLFxuXHQndG9tbCcsXG5cdCdkb2NrZXJmaWxlJyxcblx0J2dpdGlnbm9yZScsXG5cdFxuXHQvLyBRdWVyeSBMYW5ndWFnZXNcblx0J3NxbCcsICdteXNxbCcsICdwb3N0Z3Jlc3FsJyxcblx0J2dyYXBocWwnLFxuXHQnbW9uZ29kYicsXG5cdCdzcGFycWwnLFxuXHRcblx0Ly8gTWFya3VwICYgRG9jdW1lbnRhdGlvblxuXHQnbWFya2Rvd24nLCAnbWQnLFxuXHQnbGF0ZXgnLCAndGV4Jyxcblx0J2FzY2lpZG9jJywgJ2Fkb2MnLFxuXHQnanNkb2MnLFxuXHRcblx0Ly8gRnVuY3Rpb25hbCBMYW5ndWFnZXNcblx0J2hhc2tlbGwnLCAnaHMnLFxuXHQnZWxtJyxcblx0J2VsaXhpcicsXG5cdCdlcmxhbmcnLFxuXHQnb2NhbWwnLFxuXHQnZnNoYXJwJyxcblx0J3NjaGVtZScsXG5cdCdsaXNwJywgJ2VsaXNwJyxcblx0J2Nsb2p1cmUnLFxuXHRcblx0Ly8gT3RoZXIgTGFuZ3VhZ2VzXG5cdCdtYXRsYWInLFxuXHQnZm9ydHJhbicsXG5cdCdjb2JvbCcsXG5cdCdwYXNjYWwnLFxuXHQncGVybCcsXG5cdCdsdWEnLFxuXHQnanVsaWEnLFxuXHQnZ3Jvb3Z5Jyxcblx0J2NyeXN0YWwnLFxuXHQnbmltJyxcblx0J3ppZycsXG5cdFxuXHQvLyBEb21haW4gU3BlY2lmaWNcblx0J3JlZ2V4Jyxcblx0J2dyYWRsZScsXG5cdCdjbWFrZScsXG5cdCdtYWtlZmlsZScsXG5cdCduaXgnLFxuXHQndGVycmFmb3JtJyxcblx0J3NvbGlkaXR5Jyxcblx0J2dsc2wnLFxuXHQnaGxzbCcsXG5cdFxuXHQvLyBBc3NlbWJseVxuXHQnbmFzbScsXG5cdCdtYXNtJyxcblx0J2FybWFzbScsXG5cdFxuXHQvLyBHYW1lIERldmVsb3BtZW50XG5cdCdnZHNjcmlwdCcsXG5cdCd1bnJlYWxzY3JpcHQnLFxuXHRcblx0Ly8gT3RoZXJzXG5cdCdhYmFwJyxcblx0J2FjdGlvbnNjcmlwdCcsXG5cdCdhZGEnLFxuXHQnYWdkYScsXG5cdCdhbnRscjQnLFxuXHQnYXBwbGVzY3JpcHQnLFxuXHQnYXJkdWlubycsXG5cdCdjb2ZmZWVzY3JpcHQnLFxuXHQnZGphbmdvJyxcblx0J2VybGFuZycsXG5cdCdmb3J0cmFuJyxcblx0J2hheGUnLFxuXHQnaWRyaXMnLFxuXHQna290bGluJyxcblx0J2xpdmVzY3JpcHQnLFxuXHQnbWF0bGFiJyxcblx0J25naW54Jyxcblx0J3Bhc2NhbCcsXG5cdCdwcm9sb2cnLFxuXHQncHVwcGV0Jyxcblx0J3NjYWxhJyxcblx0J3NjaGVtZScsXG5cdCd0Y2wnLFxuXHQndmVyaWxvZycsXG5cdCd2aGRsJ1xuXSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgVGVtbWxcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKi9cbmNsYXNzIFBhcnNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlLCAvLyBUaGUgZXJyb3IgbWVzc2FnZVxuICAgIHRva2VuIC8vIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgKSB7XG4gICAgbGV0IGVycm9yID0gXCIgXCIgKyBtZXNzYWdlO1xuICAgIGxldCBzdGFydDtcblxuICAgIGNvbnN0IGxvYyA9IHRva2VuICYmIHRva2VuLmxvYztcbiAgICBpZiAobG9jICYmIGxvYy5zdGFydCA8PSBsb2MuZW5kKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRoZSBpbnB1dCBhbmQgYSBwb3NpdGlvbiwgbWFrZSB0aGUgZXJyb3IgYSBiaXQgZmFuY2llclxuXG4gICAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgICBjb25zdCBpbnB1dCA9IGxvYy5sZXhlci5pbnB1dDtcblxuICAgICAgLy8gUHJlcGVuZCBzb21lIGluZm9ybWF0aW9uXG4gICAgICBzdGFydCA9IGxvYy5zdGFydDtcbiAgICAgIGNvbnN0IGVuZCA9IGxvYy5lbmQ7XG4gICAgICBpZiAoc3RhcnQgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBlcnJvciArPSBcIiBhdCBlbmQgb2YgaW5wdXQ6IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgKz0gXCIgYXQgcG9zaXRpb24gXCIgKyAoc3RhcnQgKyAxKSArIFwiOiBcXG5cIjtcbiAgICAgIH1cblxuICAgICAgLy8gVW5kZXJsaW5lIHRva2VuIGluIHF1ZXN0aW9uIHVzaW5nIGNvbWJpbmluZyB1bmRlcnNjb3Jlc1xuICAgICAgY29uc3QgdW5kZXJsaW5lZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLnJlcGxhY2UoL1teXS9nLCBcIiQmXFx1MDMzMlwiKTtcblxuICAgICAgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcbiAgICAgIGxldCBsZWZ0O1xuICAgICAgaWYgKHN0YXJ0ID4gMTUpIHtcbiAgICAgICAgbGVmdCA9IFwi4oCmXCIgKyBpbnB1dC5zbGljZShzdGFydCAtIDE1LCBzdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gaW5wdXQuc2xpY2UoMCwgc3RhcnQpO1xuICAgICAgfVxuICAgICAgbGV0IHJpZ2h0O1xuICAgICAgaWYgKGVuZCArIDE1IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kLCBlbmQgKyAxNSkgKyBcIuKAplwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpO1xuICAgICAgfVxuICAgICAgZXJyb3IgKz0gbGVmdCArIHVuZGVybGluZWQgKyByaWdodDtcbiAgICB9XG5cbiAgICAvLyBTb21lIGhhY2tlcnkgdG8gbWFrZSBQYXJzZUVycm9yIGEgcHJvdG90eXBlIG9mIEVycm9yXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg0NjA3NTNcbiAgICBjb25zdCBzZWxmID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICBzZWxmLm5hbWUgPSBcIlBhcnNlRXJyb3JcIjtcbiAgICBzZWxmLl9fcHJvdG9fXyA9IFBhcnNlRXJyb3IucHJvdG90eXBlO1xuICAgIHNlbGYucG9zaXRpb24gPSBzdGFydDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufVxuXG5QYXJzZUVycm9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8vXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIGxpc3Qgb2YgdXRpbGl0eSBmdW5jdGlvbnMgd2hpY2ggYXJlIHVzZWZ1bCBpbiBvdGhlclxuICogZmlsZXMuXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlIGEgZGVmYXVsdCB2YWx1ZSBpZiBhIHNldHRpbmcgaXMgdW5kZWZpbmVkXG4gKi9cbmNvbnN0IGRlZmx0ID0gZnVuY3Rpb24oc2V0dGluZywgZGVmYXVsdElmVW5kZWZpbmVkKSB7XG4gIHJldHVybiBzZXR0aW5nID09PSB1bmRlZmluZWQgPyBkZWZhdWx0SWZVbmRlZmluZWQgOiBzZXR0aW5nO1xufTtcblxuLy8gaHlwaGVuYXRlIGFuZCBlc2NhcGUgYWRhcHRlZCBmcm9tIEZhY2Vib29rJ3MgUmVhY3QgdW5kZXIgQXBhY2hlIDIgbGljZW5zZVxuXG5jb25zdCB1cHBlcmNhc2UgPSAvKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh1cHBlcmNhc2UsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5jb25zdCBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiN4Mjc7XCJcbn07XG5cbmNvbnN0IEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICovXG5mdW5jdGlvbiBlc2NhcGUodGV4dCkge1xuICByZXR1cm4gU3RyaW5nKHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cblxuLyoqXG4gKiBTb21ldGltZXMgd2Ugd2FudCB0byBwdWxsIG91dCB0aGUgaW5uZXJtb3N0IGVsZW1lbnQgb2YgYSBncm91cC4gSW4gbW9zdFxuICogY2FzZXMsIHRoaXMgd2lsbCBqdXN0IGJlIHRoZSBncm91cCBpdHNlbGYsIGJ1dCB3aGVuIG9yZGdyb3VwcyBhbmQgY29sb3JzIGhhdmVcbiAqIGEgc2luZ2xlIGVsZW1lbnQsIHdlIHdhbnQgdG8gcHVsbCB0aGF0IG91dC5cbiAqL1xuY29uc3QgZ2V0QmFzZUVsZW0gPSBmdW5jdGlvbihncm91cCkge1xuICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJmb250XCIpIHtcbiAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG59O1xuXG4vKipcbiAqIFRlWGJvb2sgYWxnb3JpdGhtcyBvZnRlbiByZWZlcmVuY2UgXCJjaGFyYWN0ZXIgYm94ZXNcIiwgd2hpY2ggYXJlIHNpbXBseSBncm91cHNcbiAqIHdpdGggYSBzaW5nbGUgY2hhcmFjdGVyIGluIHRoZW0uIFRvIGRlY2lkZSBpZiBzb21ldGhpbmcgaXMgYSBjaGFyYWN0ZXIgYm94LFxuICogd2UgZmluZCBpdHMgaW5uZXJtb3N0IGdyb3VwLCBhbmQgc2VlIGlmIGl0IGlzIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgaXNDaGFyYWN0ZXJCb3ggPSBmdW5jdGlvbihncm91cCkge1xuICBjb25zdCBiYXNlRWxlbSA9IGdldEJhc2VFbGVtKGdyb3VwKTtcblxuICAvLyBUaGVzZSBhcmUgYWxsIHRoZSB0eXBlcyBvZiBncm91cHMgd2hpY2ggaG9sZCBzaW5nbGUgY2hhcmFjdGVyc1xuICByZXR1cm4gYmFzZUVsZW0udHlwZSA9PT0gXCJtYXRob3JkXCIgfHwgYmFzZUVsZW0udHlwZSA9PT0gXCJ0ZXh0b3JkXCIgfHwgYmFzZUVsZW0udHlwZSA9PT0gXCJhdG9tXCJcbn07XG5cbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub24tbnVsbCwgYnV0IGdvdCBcIiArIFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcm90b2NvbCBvZiBhIFVSTCwgb3IgXCJfcmVsYXRpdmVcIiBpZiB0aGUgVVJMIGRvZXMgbm90IHNwZWNpZnkgYVxuICogcHJvdG9jb2wgKGFuZCB0aHVzIGlzIHJlbGF0aXZlKSwgb3IgYG51bGxgIGlmIFVSTCBoYXMgaW52YWxpZCBwcm90b2NvbFxuICogKHNvIHNob3VsZCBiZSBvdXRyaWdodCByZWplY3RlZCkuXG4gKi9cbmNvbnN0IHByb3RvY29sRnJvbVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAvLyBDaGVjayBmb3IgcG9zc2libGUgbGVhZGluZyBwcm90b2NvbC5cbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZyBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlXG4gIC8vIChcXHgwMCkgb3IgQzAgY29udHJvbCAoXFx4MDAtXFx4MUYpIGNoYXJhY3RlcnMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gIGNvbnN0IHByb3RvY29sID0gL15bXFx4MDAtXFx4MjBdKihbXlxcXFwvIz9dKj8pKDp8JiMwKjU4fCYjeDAqM2F8JmNvbG9uKS9pLmV4ZWModXJsKTtcbiAgaWYgKCFwcm90b2NvbCkge1xuICAgIHJldHVybiBcIl9yZWxhdGl2ZVwiO1xuICB9XG4gIC8vIFJlamVjdCB3ZWlyZCBjb2xvbnNcbiAgaWYgKHByb3RvY29sWzJdICE9PSBcIjpcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFJlamVjdCBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gc2NoZW1lIGFjY29yZGluZyB0b1xuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcbiAgaWYgKCEvXlthLXpBLVpdW2EtekEtWjAtOStcXC0uXSokLy50ZXN0KHByb3RvY29sWzFdKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIExvd2VyY2FzZSB0aGUgcHJvdG9jb2xcbiAgcmV0dXJuIHByb3RvY29sWzFdLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFJvdW5kIGBuYCB0byA0IGRlY2ltYWwgcGxhY2VzLCBvciB0byB0aGUgbmVhcmVzdCAxLzEwLDAwMHRoIGVtLiBUaGUgVGVYYm9va1xuICogZ2l2ZXMgYW4gYWNjZXB0YWJsZSByb3VuZGluZyBlcnJvciBvZiAxMDBzcCAod2hpY2ggd291bGQgYmUgdGhlIG5lYXJlc3RcbiAqIDEvNjU1MS42ZW0gd2l0aCBvdXIgcHRQZXJFbSA9IDEwKTpcbiAqIGh0dHA6Ly93d3cuY3RleC5vcmcvZG9jdW1lbnRzL3NocmVkZGVyL3NyYy90ZXhib29rLnBkZiNwYWdlPTY5XG4gKi9cbmNvbnN0IHJvdW5kID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gK24udG9GaXhlZCg0KTtcbn07XG5cbnZhciB1dGlscyA9IHtcbiAgZGVmbHQsXG4gIGVzY2FwZSxcbiAgaHlwaGVuYXRlLFxuICBnZXRCYXNlRWxlbSxcbiAgaXNDaGFyYWN0ZXJCb3gsXG4gIHByb3RvY29sRnJvbVVybCxcbiAgcm91bmRcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIG1vZHVsZSBmb3Igc3RvcmluZyBzZXR0aW5ncyBwYXNzZWQgaW50byBUZW1tbC4gSXQgY29ycmVjdGx5IGhhbmRsZXNcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBtYWluIFNldHRpbmdzIG9iamVjdFxuICovXG5jbGFzcyBTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvLyBhbGxvdyBudWxsIG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmRpc3BsYXlNb2RlID0gdXRpbHMuZGVmbHQob3B0aW9ucy5kaXNwbGF5TW9kZSwgZmFsc2UpOyAgICAvLyBib29sZWFuXG4gICAgdGhpcy5hbm5vdGF0ZSA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuYW5ub3RhdGUsIGZhbHNlKTsgICAgICAgICAgIC8vIGJvb2xlYW5cbiAgICB0aGlzLmxlcW5vID0gdXRpbHMuZGVmbHQob3B0aW9ucy5sZXFubywgZmFsc2UpOyAgICAgICAgICAgICAgICAvLyBib29sZWFuXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB1dGlscy5kZWZsdChvcHRpb25zLnRocm93T25FcnJvciwgZmFsc2UpOyAgLy8gYm9vbGVhblxuICAgIHRoaXMuZXJyb3JDb2xvciA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuZXJyb3JDb2xvciwgXCIjYjIyMjIyXCIpOyAgLy8gc3RyaW5nXG4gICAgdGhpcy5tYWNyb3MgPSBvcHRpb25zLm1hY3JvcyB8fCB7fTtcbiAgICB0aGlzLndyYXAgPSB1dGlscy5kZWZsdChvcHRpb25zLndyYXAsIFwidGV4XCIpOyAgICAgICAgICAgICAgICAgICAgLy8gXCJ0ZXhcIiB8IFwiPVwiXG4gICAgdGhpcy54bWwgPSB1dGlscy5kZWZsdChvcHRpb25zLnhtbCwgZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgIC8vIGJvb2xlYW5cbiAgICB0aGlzLmNvbG9ySXNUZXh0Q29sb3IgPSB1dGlscy5kZWZsdChvcHRpb25zLmNvbG9ySXNUZXh0Q29sb3IsIGZhbHNlKTsgIC8vIGJvb2VsZWFuXG4gICAgdGhpcy5zdHJpY3QgPSB1dGlscy5kZWZsdChvcHRpb25zLnN0cmljdCwgZmFsc2UpOyAgICAvLyBib29sZWFuXG4gICAgdGhpcy50cnVzdCA9IHV0aWxzLmRlZmx0KG9wdGlvbnMudHJ1c3QsIGZhbHNlKTsgIC8vIHRydXN0IGNvbnRleHQuIFNlZSBodG1sLmpzLlxuICAgIHRoaXMubWF4U2l6ZSA9IChvcHRpb25zLm1heFNpemUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBbSW5maW5pdHksIEluZmluaXR5XVxuICAgICAgOiBBcnJheS5pc0FycmF5KG9wdGlvbnMubWF4U2l6ZSlcbiAgICAgID8gb3B0aW9ucy5tYXhTaXplXG4gICAgICA6IFtJbmZpbml0eSwgSW5maW5pdHldXG4gICAgKTtcbiAgICB0aGlzLm1heEV4cGFuZCA9IE1hdGgubWF4KDAsIHV0aWxzLmRlZmx0KG9wdGlvbnMubWF4RXhwYW5kLCAxMDAwKSk7IC8vIG51bWJlclxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gdGVzdCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgaW5wdXQsIGFuZCByZXR1cm5cbiAgICogYHRydWVgICh0cnVzdGVkKSBvciBgZmFsc2VgICh1bnRydXN0ZWQpLiAgVGhlIHNvbGUgYXJndW1lbnQgYGNvbnRleHRgXG4gICAqIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBgY29tbWFuZGAgZmllbGQgc3BlY2lmeWluZyB0aGUgcmVsZXZhbnQgTGFUZVhcbiAgICogY29tbWFuZCAoYXMgYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgXFxgKSwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMsIGV0Yy5cbiAgICogSWYgYGNvbnRleHRgIGhhcyBhIGB1cmxgIGZpZWxkLCBhIGBwcm90b2NvbGAgZmllbGQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAqIGdldCBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uIChjaGFuZ2luZyB0aGUgc3BlY2lmaWVkIG9iamVjdCkuXG4gICAqL1xuICBpc1RydXN0ZWQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LnVybCAmJiAhY29udGV4dC5wcm90b2NvbCkge1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB1dGlscy5wcm90b2NvbEZyb21VcmwoY29udGV4dC51cmwpO1xuICAgICAgaWYgKHByb3RvY29sID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBjb250ZXh0LnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuICAgIGNvbnN0IHRydXN0ID0gdHlwZW9mIHRoaXMudHJ1c3QgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMudHJ1c3QoY29udGV4dCkgOiB0aGlzLnRydXN0O1xuICAgIHJldHVybiBCb29sZWFuKHRydXN0KTtcbiAgfVxufVxuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGZ1bmN0aW9ucy5cbiAqIGBmdW5jdGlvbnMuanNgIGp1c3QgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5LlxuICovXG5jb25zdCBfZnVuY3Rpb25zID0ge307XG5cbi8qKlxuICogQWxsIE1hdGhNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5jb25zdCBfbWF0aG1sR3JvdXBCdWlsZGVycyA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbih7XG4gIHR5cGUsXG4gIG5hbWVzLFxuICBwcm9wcyxcbiAgaGFuZGxlcixcbiAgbWF0aG1sQnVpbGRlclxufSkge1xuICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgZnVuY3Rpb25zXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdHlwZSxcbiAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzLFxuICAgIGFyZ1R5cGVzOiBwcm9wcy5hcmdUeXBlcyxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogISFwcm9wcy5hbGxvd2VkSW5Bcmd1bWVudCxcbiAgICBhbGxvd2VkSW5UZXh0OiAhIXByb3BzLmFsbG93ZWRJblRleHQsXG4gICAgYWxsb3dlZEluTWF0aDogcHJvcHMuYWxsb3dlZEluTWF0aCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHByb3BzLmFsbG93ZWRJbk1hdGgsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICBpbmZpeDogISFwcm9wcy5pbmZpeCxcbiAgICBwcmltaXRpdmU6ICEhcHJvcHMucHJpbWl0aXZlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIF9mdW5jdGlvbnNbbmFtZXNbaV1dID0gZGF0YTtcbiAgfVxuICBpZiAodHlwZSkge1xuICAgIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgICBfbWF0aG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IG1hdGhtbEJ1aWxkZXI7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXNlIHRoaXMgdG8gcmVnaXN0ZXIgb25seSB0aGUgTWF0aE1MIGJ1aWxkZXIgZm9yIGEgZnVuY3Rpb24oZS5nLlxuICogaWYgdGhlIGZ1bmN0aW9uJ3MgUGFyc2VOb2RlIGlzIGdlbmVyYXRlZCBpbiBQYXJzZXIuanMgcmF0aGVyIHRoYW4gdmlhIGFcbiAqIHN0YW5kLWFsb25lIGhhbmRsZXIgcHJvdmlkZWQgdG8gYGRlZmluZUZ1bmN0aW9uYCkuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoeyB0eXBlLCBtYXRobWxCdWlsZGVyIH0pIHtcbiAgZGVmaW5lRnVuY3Rpb24oe1xuICAgIHR5cGUsXG4gICAgbmFtZXM6IFtdLFxuICAgIHByb3BzOiB7IG51bUFyZ3M6IDAgfSxcbiAgICBoYW5kbGVyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cIilcbiAgICB9LFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSk7XG59XG5cbmNvbnN0IG5vcm1hbGl6ZUFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiICYmIGFyZy5ib2R5Lmxlbmd0aCA9PT0gMSA/IGFyZy5ib2R5WzBdIDogYXJnXG59O1xuXG4vLyBTaW5jZSB0aGUgY29ycmVzcG9uZGluZyBidWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xuY29uc3Qgb3JkYXJndW1lbnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgPyBhcmcuYm9keSA6IFthcmddXG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gSXQgb25seSBjb250YWluc1xuICogY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgRE9NIG5vZGUgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgRG9jdW1lbnRGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgIHRoaXMuc3R5bGUgPSB7fTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzZXMuaW5jbHVkZXMoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIGEgbm9kZS4gKi9cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICAvKiogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBIVE1MIG1hcmt1cC4gKi9cbiAgdG9NYXJrdXAoKSB7XG4gICAgbGV0IG1hcmt1cCA9IFwiXCI7XG5cbiAgICAvLyBTaW1wbHkgY29uY2F0ZW5hdGUgdGhlIG1hcmt1cCBmb3IgdGhlIGNoaWxkcmVuIHRvZ2V0aGVyLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQuIEFwcGxpZXMgdG9cbiAgICogTWF0aERvbU5vZGUncyBvbmx5LlxuICAgKi9cbiAgdG9UZXh0KCkge1xuICAgIC8vIFRvIGF2b2lkIHRoaXMsIHdlIHdvdWxkIHN1YmNsYXNzIGRvY3VtZW50RnJhZ21lbnQgc2VwYXJhdGVseSBmb3JcbiAgICAvLyBNYXRoTUwsIGJ1dCBwb2x5ZmlsbHMgZm9yIHN1YmNsYXNzaW5nIGlzIGV4cGVuc2l2ZSBwZXIgUFIgMTQ2OS5cbiAgICBjb25zdCB0b1RleHQgPSAoY2hpbGQpID0+IGNoaWxkLnRvVGV4dCgpO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcCh0b1RleHQpLmpvaW4oXCJcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIHRoZSBkYXRhIGFib3V0IHRoZSBET00gbm9kZXMgd2UgY3JlYXRlLCBhcyB3ZWxsIGFzIHNvbWVcbiAqIGV4dHJhIGRhdGEuIFRoZXkgY2FuIHRoZW4gYmUgdHJhbnNmb3JtZWQgaW50byByZWFsIERPTSBub2RlcyB3aXRoIHRoZVxuICogYHRvTm9kZWAgZnVuY3Rpb24gb3IgSFRNTCBtYXJrdXAgdXNpbmcgYHRvTWFya3VwYC4gVGhleSBhcmUgdXNlZnVsIGZvciBib3RoXG4gKiBzdG9yaW5nIGV4dHJhIHByb3BlcnRpZXMgb24gdGhlIG5vZGVzLCBhcyB3ZWxsIGFzIHByb3ZpZGluZyBhIHdheSB0byBlYXNpbHlcbiAqIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIFNpbWlsYXIgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggTWF0aE1MIG5vZGVzIGV4aXN0IGluIG1hdGhNTFRyZWUuanMuXG4gKlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgY2xhc3NOYW1lIGJhc2VkIG9uIGEgbGlzdCBvZiBjbGFzc2VzLiBJbiBhZGRpdGlvbiB0byBqb2luaW5nXG4gKiB3aXRoIHNwYWNlcywgd2UgYWxzbyByZW1vdmUgZW1wdHkgY2xhc3Nlcy5cbiAqL1xuY29uc3QgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbihjbGFzc2VzKSB7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcigoY2xzKSA9PiBjbHMpLmpvaW4oXCIgXCIpO1xufTtcblxuY29uc3QgaW5pdE5vZGUgPSBmdW5jdGlvbihjbGFzc2VzLCBzdHlsZSkge1xuICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBub2RlXG4gKi9cbmNvbnN0IHRvTm9kZSA9IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgLy8gQXBwbHkgdGhlIGNsYXNzXG4gIG5vZGUuY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcblxuICAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgbm9kZS5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICB9XG4gIH1cblxuICAvLyBBcHBseSBhdHRyaWJ1dGVzXG4gIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0ciApKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGVuZCB0aGUgY2hpbGRyZW4sIGFsc28gYXMgSFRNTCBub2Rlc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuY29uc3QgdG9NYXJrdXAgPSBmdW5jdGlvbih0YWdOYW1lKSB7XG4gIGxldCBtYXJrdXAgPSBgPCR7dGFnTmFtZX1gO1xuXG4gIC8vIEFkZCB0aGUgY2xhc3NcbiAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBtYXJrdXAgKz0gYCBjbGFzcz1cIiR7dXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpfVwiYDtcbiAgfVxuXG4gIGxldCBzdHlsZXMgPSBcIlwiO1xuXG4gIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgIHN0eWxlcyArPSBgJHt1dGlscy5oeXBoZW5hdGUoc3R5bGUpfToke3RoaXMuc3R5bGVbc3R5bGVdfTtgO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHlsZXMpIHtcbiAgICBtYXJrdXAgKz0gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYDtcbiAgfVxuXG4gIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIgKSkge1xuICAgICAgbWFya3VwICs9IGAgJHthdHRyfT1cIiR7dXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSl9XCJgO1xuICAgIH1cbiAgfVxuXG4gIG1hcmt1cCArPSBcIj5cIjtcblxuICAvLyBBZGQgdGhlIG1hcmt1cCBvZiB0aGUgY2hpbGRyZW4sIGFsc28gYXMgbWFya3VwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gIH1cblxuICBtYXJrdXAgKz0gYDwvJHt0YWdOYW1lfT5gO1xuXG4gIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhbiBub2RlLCB3aXRoIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZFxuICogYW4gaW5saW5lIHN0eWxlLlxuICpcbiAqL1xuY2xhc3MgU3BhbiB7XG4gIGNvbnN0cnVjdG9yKGNsYXNzZXMsIGNoaWxkcmVuLCBzdHlsZSkge1xuICAgIGluaXROb2RlLmNhbGwodGhpcywgY2xhc3Nlcywgc3R5bGUpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gdG9Ob2RlLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHRvTWFya3VwLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG59XG5cbmxldCBUZXh0Tm9kZSQxID0gY2xhc3MgVGV4dE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIH1cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRleHQpO1xuICB9XG59O1xuXG4vLyBDcmVhdGUgYW4gPGEgaHJlZj1cIuKAplwiPiBub2RlLlxuY2xhc3MgQW5jaG9yTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuKSB7XG4gICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHRoaXMuaHJlZik7XG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIGxldCBtYXJrdXAgPSBgPGEgaHJlZj0nJHt1dGlscy5lc2NhcGUodGhpcy5ocmVmKX0nYDtcbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hcmt1cCArPSBgIGNsYXNzPVwiJHt1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSl9XCJgO1xuICAgIH1cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cbiAgICBtYXJrdXAgKz0gXCI8L2E+XCI7XG4gICAgcmV0dXJuIG1hcmt1cFxuICB9XG59XG5cbi8qXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhbiBpbWFnZSBlbWJlZCAoPGltZz4pIGVsZW1lbnQuXG4gKi9cbmNsYXNzIEltZyB7XG4gIGNvbnN0cnVjdG9yKHNyYywgYWx0LCBzdHlsZSkge1xuICAgIHRoaXMuYWx0ID0gYWx0O1xuICAgIHRoaXMuc3JjID0gc3JjO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtcIm1vcmRcIl07XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3Nlcy5pbmNsdWRlcyhjbGFzc05hbWUpO1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIG5vZGUuc3JjID0gdGhpcy5zcmM7XG4gICAgbm9kZS5hbHQgPSB0aGlzLmFsdDtcbiAgICBub2RlLmNsYXNzTmFtZSA9IFwibW9yZFwiO1xuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gYDxpbWcgc3JjPScke3RoaXMuc3JjfScgYWx0PScke3RoaXMuYWx0fSdgO1xuXG4gICAgLy8gQWRkIHRoZSBzdHlsZXMsIGFmdGVyIGh5cGhlbmF0aW9uXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgICAgc3R5bGVzICs9IGAke3V0aWxzLmh5cGhlbmF0ZShzdHlsZSl9OiR7dGhpcy5zdHlsZVtzdHlsZV19O2A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgIG1hcmt1cCArPSBgIHN0eWxlPVwiJHt1dGlscy5lc2NhcGUoc3R5bGVzKX1cImA7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cbn1cblxuLy9cbi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSBkYXRhIGFib3V0IE1hdGhNTCBub2Rlcy5cbiAqIFRoZSBgdG9Ob2RlYCBhbmQgYHRvTWFya3VwYCBmdW5jdGlvbnMgIGNyZWF0ZSBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmRcbiAqIEhUTUwgdGV4dCBtYXJrdXAgcmVzcGVjdGl2ZWx5LlxuICovXG5cblxuZnVuY3Rpb24gbmV3RG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xufVxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZ2VuZXJhbCBwdXJwb3NlIE1hdGhNTCBub2RlIG9mIGFueSB0eXBlLFxuICogZm9yIGV4YW1wbGUsIGBcIm1vXCJgIG9yIGBcIm1zcGFjZVwiYCwgY29ycmVzcG9uZGluZyB0byBgPG1vPmAgYW5kXG4gKiBgPG1zcGFjZT5gIHRhZ3MpLlxuICovXG5jbGFzcyBNYXRoTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNoaWxkcmVuLCBjbGFzc2VzLCBzdHlsZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9OyAgIC8vIFVzZWQgZm9yIDxtc3R5bGU+IGVsZW1lbnRzXG4gICAgdGhpcy5sYWJlbCA9IFwiXCI7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS4gTWF0aE1MIGRlcGVuZHMgb24gYXR0cmlidXRlcyB0byBjb252ZXkgYVxuICAgKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAgICovXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXR0cmlidXRlIG9uIGEgTWF0aE1MIG5vZGUuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH1cblxuICBzZXRMYWJlbCh2YWx1ZSkge1xuICAgIHRoaXMubGFiZWwgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8XCIgKyB0aGlzLnR5cGU7XG5cbiAgICAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArICc9XCInO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICAgIG1hcmt1cCArPSAnXCInO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWFya3VwICs9IGAgY2xhc3M9XCIke3V0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKX1cImA7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG5cbiAgICAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgICBzdHlsZXMgKz0gYCR7dXRpbHMuaHlwaGVuYXRlKHN0eWxlKX06JHt0aGlzLnN0eWxlW3N0eWxlXX07YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBtYXJrdXAgKz0gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYDtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiO1xuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LCBidXQgZXNjYXBlZC5cbiAgICovXG4gIHRvVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC50b1RleHQoKSkuam9pbihcIlwiKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGV4dC5cbiAqL1xuY2xhc3MgVGV4dE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gYSBET00gdGV4dCBub2RlLlxuICAgKi9cbiAgdG9Ob2RlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBlc2NhcGVkIEhUTUwgbWFya3VwXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB1dGlscy5lc2NhcGUodGhpcy50b1RleHQoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgc3RyaW5nXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG4gIHRvVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG59XG5cbi8vIERvIG5vdCBtYWtlIGFuIDxtcm93PiB0aGUgb25seSBjaGlsZCBvZiBhIDxtc3R5bGU+LlxuLy8gQW4gPG1zdHlsZT4gYWN0cyBhcyBpdHMgb3duIGltcGxpY2l0IDxtcm93Pi5cbmNvbnN0IHdyYXBXaXRoTXN0eWxlID0gZXhwcmVzc2lvbiA9PiB7XG4gIGxldCBub2RlO1xuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvblswXS50eXBlID09PSBcIm1yb3dcIikge1xuICAgIG5vZGUgPSBleHByZXNzaW9uLnBvcCgpO1xuICAgIG5vZGUudHlwZSA9IFwibXN0eWxlXCI7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1zdHlsZVwiLCBleHByZXNzaW9uKTtcbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxudmFyIG1hdGhNTFRyZWUgPSB7XG4gIE1hdGhOb2RlLFxuICBUZXh0Tm9kZSxcbiAgbmV3RG9jdW1lbnRGcmFnbWVudFxufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgc3VwcG9ydCBmb3IgYnVpbGRpbmcgaG9yaXpvbnRhbCBzdHJldGNoeSBlbGVtZW50cy5cbiAqL1xuXG5cbi8vIFRPRE86IFJlbW92ZSB3aGVuIENocm9taXVtIHN0cmV0Y2hlcyBcXHdpZGV0aWxkZSAmIFxcd2lkZWhhdFxuY29uc3QgZXN0aW1hdGVkV2lkdGggPSBub2RlID0+IHtcbiAgbGV0IHdpZHRoID0gMDtcbiAgaWYgKG5vZGUuYm9keSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLmJvZHkpIHtcbiAgICAgIHdpZHRoICs9IGVzdGltYXRlZFdpZHRoKGl0ZW0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICB3aWR0aCArPSBlc3RpbWF0ZWRXaWR0aChub2RlLmJhc2UpO1xuICAgIGlmIChub2RlLnN1YikgeyB3aWR0aCArPSAwLjcgKiBlc3RpbWF0ZWRXaWR0aChub2RlLnN1Yik7IH1cbiAgICBpZiAobm9kZS5zdXApIHsgd2lkdGggKz0gMC43ICogZXN0aW1hdGVkV2lkdGgobm9kZS5zdXApOyB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBub2RlLnR5cGUgPT09IFwidGV4dG9yZFwiKSB7XG4gICAgZm9yIChjb25zdCBjaCBvZiBub2RlLnRleHQuc3BsaXQoJycpKSB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaC5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIGlmICgoMHg2MCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDdCKSB8fCAoMHgwM0IwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4M0NBKSkge1xuICAgICAgICB3aWR0aCArPSAwLjU2OyAvLyBsb3dlciBjYXNlIGxhdGluIG9yIGdyZWVrLiBVc2UgYWR2YW5jZSB3aWR0aCBvZiBsZXR0ZXIgblxuICAgICAgfSBlbHNlIGlmICgweDJGIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4M0EpIHtcbiAgICAgICAgd2lkdGggKz0gMC41MDsgLy8gbnVtZXJhbHMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCArPSAwLjkyOyAvLyBhZHZhbmNlIHdpZHRoIG9mIGxldHRlciBNXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdpZHRoICs9IDEuMDtcbiAgfVxuICByZXR1cm4gd2lkdGhcbn07XG5cbmNvbnN0IHN0cmV0Y2h5Q29kZVBvaW50ID0ge1xuICB3aWRlaGF0OiBcIl5cIixcbiAgd2lkZWNoZWNrOiBcIsuHXCIsXG4gIHdpZGV0aWxkZTogXCJ+XCIsXG4gIHdpZGVwYXJlbjogXCLij5xcIiwgLy8gXFx1MjNkY1xuICB1dGlsZGU6IFwiflwiLFxuICBvdmVybGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgdW5kZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB4bGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgb3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB4cmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVyYnJhY2U6IFwiXFx1MjNkZlwiLFxuICBvdmVyYnJhY2U6IFwiXFx1MjNkZVwiLFxuICBvdmVyZ3JvdXA6IFwiXFx1MjNlMFwiLFxuICBvdmVycGFyZW46IFwi4o+cXCIsXG4gIHVuZGVyZ3JvdXA6IFwiXFx1MjNlMVwiLFxuICB1bmRlcnBhcmVuOiBcIlxcdTIzZGRcIixcbiAgb3ZlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIHhsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIE92ZXJyaWdodGFycm93OiBcIlxcdTIxZDJcIixcbiAgeFJpZ2h0YXJyb3c6IFwiXFx1MjFkMlwiLFxuICBvdmVybGVmdGhhcnBvb246IFwiXFx1MjFiY1wiLFxuICB4bGVmdGhhcnBvb251cDogXCJcXHUyMWJjXCIsXG4gIG92ZXJyaWdodGhhcnBvb246IFwiXFx1MjFjMFwiLFxuICB4cmlnaHRoYXJwb29udXA6IFwiXFx1MjFjMFwiLFxuICB4TGVmdGFycm93OiBcIlxcdTIxZDBcIixcbiAgeExlZnRyaWdodGFycm93OiBcIlxcdTIxZDRcIixcbiAgeGhvb2tsZWZ0YXJyb3c6IFwiXFx1MjFhOVwiLFxuICB4aG9va3JpZ2h0YXJyb3c6IFwiXFx1MjFhYVwiLFxuICB4bWFwc3RvOiBcIlxcdTIxYTZcIixcbiAgeHJpZ2h0aGFycG9vbmRvd246IFwiXFx1MjFjMVwiLFxuICB4bGVmdGhhcnBvb25kb3duOiBcIlxcdTIxYmRcIixcbiAgeHR3b2hlYWRsZWZ0YXJyb3c6IFwiXFx1MjE5ZVwiLFxuICB4dHdvaGVhZHJpZ2h0YXJyb3c6IFwiXFx1MjFhMFwiLFxuICB4bG9uZ2VxdWFsOiBcIj1cIixcbiAgeHJpZ2h0bGVmdGFycm93czogXCJcXHUyMWM0XCIsXG4gIHlpZWxkczogXCJcXHUyMTkyXCIsXG4gIHlpZWxkc0xlZnQ6IFwiXFx1MjE5MFwiLFxuICBtZXNvbWVyaXNtOiBcIlxcdTIxOTRcIixcbiAgbG9uZ3JpZ2h0aGFycG9vbnVwOiBcIlxcdTIxYzBcIixcbiAgbG9uZ2xlZnRoYXJwb29uZG93bjogXCJcXHUyMWJkXCIsXG4gIGVxcmlnaHRoYXJwb29udXA6IFwiXFx1MjFjMFwiLFxuICBlcWxlZnRoYXJwb29uZG93bjogXCJcXHUyMWJkXCIsXG4gIFwiXFxcXGNkcmlnaHRhcnJvd1wiOiBcIlxcdTIxOTJcIixcbiAgXCJcXFxcY2RsZWZ0YXJyb3dcIjogXCJcXHUyMTkwXCIsXG4gIFwiXFxcXGNkbG9uZ2VxdWFsXCI6IFwiPVwiXG59O1xuXG5jb25zdCBtYXRoTUxub2RlID0gZnVuY3Rpb24obGFiZWwpIHtcbiAgY29uc3QgY2hpbGQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShzdHJldGNoeUNvZGVQb2ludFtsYWJlbC5zbGljZSgxKV0pO1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbY2hpbGRdKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gIHJldHVybiBub2RlXG59O1xuXG5jb25zdCBjcm9va2VkV2lkZXMgPSBbXCJcXFxcd2lkZXRpbGRlXCIsIFwiXFxcXHdpZGVoYXRcIiwgXCJcXFxcd2lkZWNoZWNrXCIsIFwiXFxcXHV0aWxkZVwiXTtcblxuLy8gVE9ETzogUmVtb3ZlIHdoZW4gQ2hyb21pdW0gc3RyZXRjaGVzIFxcd2lkZXRpbGRlICYgXFx3aWRlaGF0XG5jb25zdCBhY2NlbnROb2RlID0gKGdyb3VwKSA9PiB7XG4gIGNvbnN0IG1vID0gbWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gIGlmIChjcm9va2VkV2lkZXMuaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XG4gICAgY29uc3Qgd2lkdGggPSBlc3RpbWF0ZWRXaWR0aChncm91cC5iYXNlKTtcbiAgICBpZiAoMSA8IHdpZHRoICYmIHdpZHRoIDwgMS42KSB7XG4gICAgICBtby5jbGFzc2VzLnB1c2goXCJ0bWwtY3Jvb2tlZC0yXCIpO1xuICAgIH0gZWxzZSBpZiAoMS42IDw9IHdpZHRoICYmIHdpZHRoIDwgMi41KSB7XG4gICAgICBtby5jbGFzc2VzLnB1c2goXCJ0bWwtY3Jvb2tlZC0zXCIpO1xuICAgIH0gZWxzZSBpZiAoMi41IDw9IHdpZHRoKSB7XG4gICAgICBtby5jbGFzc2VzLnB1c2goXCJ0bWwtY3Jvb2tlZC00XCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9cbn07XG5cbnZhciBzdHJldGNoeSA9IHtcbiAgbWF0aE1Mbm9kZSxcbiAgYWNjZW50Tm9kZVxufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBuby1hcmd1bWVudCBmdW5jdGlvbnMgYW5kIHNpbmdsZS1jaGFyYWN0ZXJcbiAqIHN5bWJvbHMgKGxpa2UgJ2EnIG9yICc7JykuXG4gKlxuICogRm9yIGVhY2ggb2YgdGhlIHN5bWJvbHMsIHRoZXJlIGFyZSB0d28gcHJvcGVydGllcyB0aGV5IGNhbiBoYXZlOlxuICogLSBncm91cCAocmVxdWlyZWQpOiB0aGUgUGFyc2VOb2RlIGdyb3VwIHR5cGUgdGhlIHN5bWJvbCBzaG91bGQgaGF2ZSAoaS5lLlxuICAgICBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIGV0YykuXG4gKiAtIHJlcGxhY2U6IHRoZSBjaGFyYWN0ZXIgdGhhdCB0aGlzIHN5bWJvbCBvciBmdW5jdGlvbiBzaG91bGQgYmVcbiAqICAgcmVwbGFjZWQgd2l0aCAoaS5lLiBcIlxccGhpXCIgaGFzIGEgcmVwbGFjZSB2YWx1ZSBvZiBcIlxcdTAzZDVcIiwgdGhlIHBoaVxuICogICBjaGFyYWN0ZXIgaW4gdGhlIG1haW4gZm9udCkuXG4gKlxuICogVGhlIG91dGVybW9zdCBtYXAgaW4gdGhlIHRhYmxlIGluZGljYXRlcyB3aGF0IG1vZGUgdGhlIHN5bWJvbHMgc2hvdWxkIGJlXG4gKiBhY2NlcHRlZCBpbiAoZS5nLiBcIm1hdGhcIiBvciBcInRleHRcIikuXG4gKi9cblxuLy8gU29tZSBvZiB0aGVzZSBoYXZlIGEgXCItdG9rZW5cIiBzdWZmaXggc2luY2UgdGhlc2UgYXJlIGFsc28gdXNlZCBhcyBgUGFyc2VOb2RlYFxuLy8gdHlwZXMgZm9yIHJhdyB0ZXh0IHRva2VucywgYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaGlnaGVyLWxldmVsXG4vLyBgUGFyc2VOb2RlYCB0eXBlcy4gVGhlc2UgYFBhcnNlTm9kZWBzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoaW4gYFBhcnNlcmAgYnlcbi8vIGxvb2tpbmcgdXAgdGhlIGBzeW1ib2xzYCBtYXAuXG5jb25zdCBBVE9NUyA9IHtcbiAgYmluOiAxLFxuICBjbG9zZTogMSxcbiAgaW5uZXI6IDEsXG4gIG9wZW46IDEsXG4gIHB1bmN0OiAxLFxuICByZWw6IDFcbn07XG5jb25zdCBOT05fQVRPTVMgPSB7XG4gIFwiYWNjZW50LXRva2VuXCI6IDEsXG4gIG1hdGhvcmQ6IDEsXG4gIFwib3AtdG9rZW5cIjogMSxcbiAgc3BhY2luZzogMSxcbiAgdGV4dG9yZDogMVxufTtcblxuY29uc3Qgc3ltYm9scyA9IHtcbiAgbWF0aDoge30sXG4gIHRleHQ6IHt9XG59O1xuXG4vKiogYGFjY2VwdFVuaWNvZGVDaGFyID0gdHJ1ZWAgaXMgb25seSBhcHBsaWNhYmxlIGlmIGByZXBsYWNlYCBpcyBzZXQuICovXG5mdW5jdGlvbiBkZWZpbmVTeW1ib2wobW9kZSwgZ3JvdXAsIHJlcGxhY2UsIG5hbWUsIGFjY2VwdFVuaWNvZGVDaGFyKSB7XG4gIHN5bWJvbHNbbW9kZV1bbmFtZV0gPSB7IGdyb3VwLCByZXBsYWNlIH07XG5cbiAgaWYgKGFjY2VwdFVuaWNvZGVDaGFyICYmIHJlcGxhY2UpIHtcbiAgICBzeW1ib2xzW21vZGVdW3JlcGxhY2VdID0gc3ltYm9sc1ttb2RlXVtuYW1lXTtcbiAgfVxufVxuXG4vLyBTb21lIGFiYnJldmlhdGlvbnMgZm9yIGNvbW1vbmx5IHVzZWQgc3RyaW5ncy5cbi8vIFRoaXMgaGVscHMgbWluaWZ5IHRoZSBjb2RlLCBhbmQgYWxzbyBzcG90dGluZyB0eXBvcyB1c2luZyBqc2hpbnQuXG5cbi8vIG1vZGVzOlxuY29uc3QgbWF0aCA9IFwibWF0aFwiO1xuY29uc3QgdGV4dCA9IFwidGV4dFwiO1xuXG4vLyBncm91cHM6XG5jb25zdCBhY2NlbnQgPSBcImFjY2VudC10b2tlblwiO1xuY29uc3QgYmluID0gXCJiaW5cIjtcbmNvbnN0IGNsb3NlID0gXCJjbG9zZVwiO1xuY29uc3QgaW5uZXIgPSBcImlubmVyXCI7XG5jb25zdCBtYXRob3JkID0gXCJtYXRob3JkXCI7XG5jb25zdCBvcCA9IFwib3AtdG9rZW5cIjtcbmNvbnN0IG9wZW4gPSBcIm9wZW5cIjtcbmNvbnN0IHB1bmN0ID0gXCJwdW5jdFwiO1xuY29uc3QgcmVsID0gXCJyZWxcIjtcbmNvbnN0IHNwYWNpbmcgPSBcInNwYWNpbmdcIjtcbmNvbnN0IHRleHRvcmQgPSBcInRleHRvcmRcIjtcblxuLy8gTm93IGNvbWVzIHRoZSBzeW1ib2wgdGFibGVcblxuLy8gUmVsYXRpb24gU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjYxXCIsIFwiXFxcXGVxdWl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdhXCIsIFwiXFxcXHByZWNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyN2JcIiwgXCJcXFxcc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFxzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3YzJcIiwgXCJcXFxccGVycFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFhZlwiLCBcIlxcXFxwcmVjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjBcIiwgXCJcXFxcc3VjY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQzXCIsIFwiXFxcXHNpbWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjRjXCIsIFwiXFxcXGJhY2tjb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJ8XCIsIFwiXFxcXG1pZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2YVwiLCBcIlxcXFxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2YlwiLCBcIlxcXFxnZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0ZFwiLCBcIlxcXFxhc3ltcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjMyM1wiLCBcIlxcXFxzbWlsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI5MVwiLCBcIlxcXFxzcXN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjkyXCIsIFwiXFxcXHNxc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTBcIiwgXCJcXFxcZG90ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcZnJvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcbmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMGNcIiwgXCJcXFxcbm90bmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxccHJvcHRvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmEyXCIsIFwiXFxcXHZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmEzXCIsIFwiXFxcXGRhc2h2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjBiXCIsIFwiXFxcXG93bnNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNThcIiwgXCJcXFxcYXJjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTlcIiwgXCJcXFxcd2VkZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjVhXCIsIFwiXFxcXHZlZWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjViXCIsIFwiXFxcXHN0YXJlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1ZFwiLCBcIlxcXFxlcWRlZlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1ZVwiLCBcIlxcXFxtZWFzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNWZcIiwgXCJcXFxccXVlc3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2MFwiLCBcIlxcXFxuZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2MFwiLCBcIlxcXFxuZXFcIik7XG4vLyB1bmljb2RlbWF0aFxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTc1XCIsIFwiXFxcXGVxZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhNzZcIiwgXCJcXFxcZXFlcWVxXCIsIHRydWUpO1xuLy8gbWF0aHRvb2xzLnN0eVxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjM3XCIsIFwiXFxcXGRibGNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU0XCIsIFwiXFxcXGNvbG9uZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU1XCIsIFwiXFxcXGVxcWNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjM5XCIsIFwiXFxcXGVxY29sb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJBNzRcIiwgXCJcXFxcQ29sb25lcXFcIiwgdHJ1ZSk7XG5cbi8vIFB1bmN0dWF0aW9uXG5kZWZpbmVTeW1ib2wobWF0aCwgcHVuY3QsIFwiXFx1MDAyZVwiLCBcIlxcXFxsZG90cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBwdW5jdCwgXCJcXHUwMGI3XCIsIFwiXFxcXGNkb3RwXCIpO1xuXG4vLyBNaXNjIFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMzVcIiwgXCJcXFxcYWxlcGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjAwXCIsIFwiXFxcXGZvcmFsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMGZcIiwgXCJcXFxcaGJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDNcIiwgXCJcXFxcZXhpc3RzXCIsIHRydWUpO1xuLy8g4oiHIGlzIGFjdHVhbGx5IGEgdW5hcnkgb3BlcmF0b3IsIG5vdCBiaW5hcnkuIEJ1dCB0aGlzIHdvcmtzLlxuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLihKtcIiwgXCJcXFxcQW5nc3Ryb21cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLihKtcIiwgXCJcXFxcQW5nc3Ryb21cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2N1wiLCBcIlxcXFx2YXJjbHVic3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMThcIiwgXCJcXFxcd3BcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjZmXCIsIFwiXFxcXHNoYXJwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2MlwiLCBcIlxcXFxkaWFtb25kc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjZcIiwgXCJcXFxcdmFyZGlhbW9uZHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTFjXCIsIFwiXFxcXFJlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2MVwiLCBcIlxcXFxoZWFydHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjY1XCIsIFwiXFxcXHZhcmhlYXJ0c3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMTFcIiwgXCJcXFxcSW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjYwXCIsIFwiXFxcXHNwYWRlc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjRcIiwgXCJcXFxcdmFyc3BhZGVzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY0MFwiLCBcIlxcXFxmZW1hbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjQyXCIsIFwiXFxcXG1hbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGE3XCIsIFwiXFxcXFNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGE3XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGI2XCIsIFwiXFxcXFBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGI2XCIsIFwiXFxcXFBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNjNhXCIsIFwiXFxcXHNtaWxleVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2M2FcIiwgXCJcXFxcc21pbGV5XCIsIHRydWUpO1xuXG4vLyBNYXRoIGFuZCBUZXh0XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFx0ZXh0ZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFx0ZXh0ZGFnZ2VyZGJsXCIpO1xuXG4vLyBMYXJnZSBEZWxpbWl0ZXJzXG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjNiMVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjNiMFwiLCBcIlxcXFxsbW91c3RhY2hlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI3ZWZcIiwgXCJcXFxccmdyb3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjdlZVwiLCBcIlxcXFxsZ3JvdXBcIiwgdHJ1ZSk7XG5cbi8vIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxM1wiLCBcIlxcXFxtcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5NlwiLCBcIlxcXFxvbWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOGVcIiwgXCJcXFxcdXBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTNcIiwgXCJcXFxcc3FjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTdcIiwgXCJcXFxcYXN0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk0XCIsIFwiXFxcXHNxY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNWVmXCIsIFwiXFxcXGJpZ2NpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTlcIiwgXCJcXFxcYnVsbGV0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyNDBcIiwgXCJcXFxcd3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJhM2ZcIiwgXCJcXFxcYW1hbGdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTAwMjZcIiwgXCJcXFxcQW5kXCIpOyAvLyBmcm9tIGFtc21hdGhcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkFGRFwiLCBcIlxcXFxzc2xhc2hcIiwgdHJ1ZSk7IC8vIGZyb20gc3RtYXJ5cmRcblxuLy8gQXJyb3cgU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2Y1XCIsIFwiXFxcXGxvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDBcIiwgXCJcXFxcTGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2Y4XCIsIFwiXFxcXExvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZjZcIiwgXCJcXFxcbG9uZ3JpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmOVwiLCBcIlxcXFxMb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5NFwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmN1wiLCBcIlxcXFxsb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDRcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZmFcIiwgXCJcXFxcTG9uZ2xlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWE0XCIsIFwiXFxcXG1hcHNmcm9tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWE2XCIsIFwiXFxcXG1hcHN0b1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmY1wiLCBcIlxcXFxsb25nbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk3XCIsIFwiXFxcXG5lYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYTlcIiwgXCJcXFxcaG9va2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhYVwiLCBcIlxcXFxob29rcmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5OFwiLCBcIlxcXFxzZWFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJjXCIsIFwiXFxcXGxlZnRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzBcIiwgXCJcXFxccmlnaHRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTlcIiwgXCJcXFxcc3dhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiZFwiLCBcIlxcXFxsZWZ0aGFycG9vbmRvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzFcIiwgXCJcXFxccmlnaHRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5NlwiLCBcIlxcXFxud2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNjXCIsIFwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjFhZlwiLCBcIlxcXFxsaWdodG5pbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyMjBFXCIsIFwiXFxcXFFFRFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTIwMzBcIiwgXCJcXFxccGVybWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAzMFwiLCBcIlxcXFxwZXJtaWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyNjA5XCIsIFwiXFxcXGFzdHJvc3VuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjYzY1wiLCBcIlxcXFxzdW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyNjNlXCIsIFwiXFxcXGxlZnRtb29uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjYzZFwiLCBcIlxcXFxyaWdodG1vb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyMjk1XCIsIFwiXFxcXEVhcnRoXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNmVcIiwgXCJcXFxcbmxlc3NcIiwgdHJ1ZSk7XG4vLyBTeW1ib2wgbmFtZXMgcHJlY2VlZGVkIGJ5IFwiQFwiIGVhY2ggaGF2ZSBhIGNvcnJlc3BvbmRpbmcgbWFjcm8uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhODdcIiwgXCJcXFxcbG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2OFwiLCBcIlxcXFxsbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2OFxcdWZlMDBcIiwgXCJcXFxcbHZlcnRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmU2XCIsIFwiXFxcXGxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg5XCIsIFwiXFxcXGxuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjgwXCIsIFwiXFxcXG5wcmVjXCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMCB0byBcXG5wcmVjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlMFwiLCBcIlxcXFxucHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmU4XCIsIFwiXFxcXHByZWNuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI5XCIsIFwiXFxcXHByZWNuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjRcIiwgXCJcXFxcbm1pZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWNcIiwgXCJcXFxcbnZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmFkXCIsIFwiXFxcXG52RGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlYVwiLCBcIlxcXFxudHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmVjXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4NFwiLCBcIlxcXFxuc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg1XCIsIFwiXFxcXG5zdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOGFcIiwgXCJcXFxcc3Vic2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjhhXFx1ZmUwMFwiLCBcIlxcXFx2YXJzdWJzZXRuZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhY2JcIiwgXCJcXFxcc3Vic2V0bmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjYlxcdWZlMDBcIiwgXCJcXFxcdmFyc3Vic2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2ZlwiLCBcIlxcXFxuZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg4XCIsIFwiXFxcXGduZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjlcIiwgXCJcXFxcZ25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjlcXHVmZTAwXCIsIFwiXFxcXGd2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlN1wiLCBcIlxcXFxnbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4YVwiLCBcIlxcXFxnbmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4MVwiLCBcIlxcXFxuc3VjY1wiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyZTEgdG8gXFxuc3VjY2N1cmx5ZXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlOVwiLCBcIlxcXFxzdWNjbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiYVwiLCBcIlxcXFxzdWNjbmFwcHJveFwiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyNDYgdG8gXFxzaW1uZXFxLiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQ2XCIsIFwiXFxcXG5jb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjI2XCIsIFwiXFxcXG5wYXJhbGxlbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNlwiLCBcIlxcXFxuc2hvcnRwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhZlwiLCBcIlxcXFxuVkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZWJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZWRcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4YlwiLCBcIlxcXFxzdXBzZXRuZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOGJcIiwgXCJcXFxcdmFyc3Vwc2V0bmVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhY2NcXHVmZTAwXCIsIFwiXFxcXHZhcnN1cHNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWVcIiwgXCJcXFxcblZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI1XCIsIFwiXFxcXHByZWNuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI2XCIsIFwiXFxcXHN1Y2NuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmI0XCIsIFwiXFxcXHVubGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmI1XCIsIFwiXFxcXHVucmhkXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBBcnJvd3NcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5YVwiLCBcIlxcXFxubGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTliXCIsIFwiXFxcXG5yaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNkXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2ZcIiwgXCJcXFxcblJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYWVcIiwgXCJcXFxcbmxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNlXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcblxuLy8gQU1TIE1pc2NcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjViM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMGZcIiwgXCJcXFxcaHNsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXGxvemVuZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNGM4XCIsIFwiXFxcXGNpcmNsZWRTXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYWVcIiwgXCJcXFxcY2lyY2xlZFJcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGFlXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIyMVwiLCBcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwNFwiLCBcIlxcXFxuZXhpc3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEyN1wiLCBcIlxcXFxtaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTMyXCIsIFwiXFxcXEZpbnZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTQxXCIsIFwiXFxcXEdhbWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzZcIiwgXCJcXFxcYmFja2RwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzdcIiwgXCJcXFxcYmFja3RycHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWIyXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjVhMFwiLCBcIlxcXFxibGFja3NxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI5ZWJcIiwgXCJcXFxcYmxhY2tsb3plbmdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIyMlwiLCBcIlxcXFxzcGhlcmljYWxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDFcIiwgXCJcXFxcY29tcGxlbWVudFwiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrRjAgdG8gXFxtYXRoZXRoLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxcZXRoXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGYwXCIsIFwiXFxcXGV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXHUwMGYwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjU3MVwiLCBcIlxcXFxkaWFndXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNTcyXCIsIFwiXFxcXGRpYWdkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWExXCIsIFwiXFxcXEJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcRGlhbW9uZFwiKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrQTUgdG8gXFxtYXRoeWVuLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxceWVuXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGE1XCIsIFwiXFxcXHllblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjcxM1wiLCBcIlxcXFxjaGVja21hcmtcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI3MTdcIiwgXCJcXFxcYmFsbG90eFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTI3MTdcIiwgXCJcXFxcYmFsbG90eFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMjJcIiwgXCJcXFxcdGV4dGJ1bGxldFwiKTtcblxuLy8gQU1TIEhlYnJld1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEzNlwiLCBcIlxcXFxiZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEzOFwiLCBcIlxcXFxkYWxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTM3XCIsIFwiXFxcXGdpbWVsXCIsIHRydWUpO1xuXG4vLyBBTVMgR3JlZWtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAzZGRcIiwgXCJcXFxcZGlnYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAzZjBcIiwgXCJcXFxcdmFya2FwcGFcIik7XG5cbi8vIEFNUyBEZWxpbWl0ZXJzXG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyMzFDXCIsIFwiXFxcXHVsY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzMURcIiwgXCJcXFxcdXJjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyMzFFXCIsIFwiXFxcXGxsY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzMUZcIiwgXCJcXFxcbHJjb3JuZXJcIiwgdHJ1ZSk7XG5cbi8vIEFNUyBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjZcIiwgXCJcXFxcbGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE3ZFwiLCBcIlxcXFxsZXFzbGFudFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE5NVwiLCBcIlxcXFxlcXNsYW50bGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MlwiLCBcIlxcXFxsZXNzc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg1XCIsIFwiXFxcXGxlc3NhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNGFcIiwgXCJcXFxcYXBwcm94ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDZcIiwgXCJcXFxcbGVzc2RvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzZcIiwgXCJcXFxcbGVzc2d0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkYVwiLCBcIlxcXFxsZXNzZXFndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOGJcIiwgXCJcXFxcbGVzc2VxcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxkb3RlcWRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1M1wiLCBcIlxcXFxyaXNpbmdkb3RzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTJcIiwgXCJcXFxcZmFsbGluZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzZFwiLCBcIlxcXFxiYWNrc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmNkXCIsIFwiXFxcXGJhY2tzaW1lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjNVwiLCBcIlxcXFxzdWJzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDBcIiwgXCJcXFxcU3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjhmXCIsIFwiXFxcXHNxc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdjXCIsIFwiXFxcXHByZWNjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmRlXCIsIFwiXFxcXGN1cmx5ZXFwcmVjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdlXCIsIFwiXFxcXHByZWNzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjdcIiwgXCJcXFxccHJlY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiMlwiLCBcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjRcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYThcIiwgXCJcXFxcdkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWJcIiwgXCJcXFxcVkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWFcIiwgXCJcXFxcVnZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtYWxsc21pbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcc21hbGxmcm93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0ZlwiLCBcIlxcXFxidW1wZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNGVcIiwgXCJcXFxcQnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY3XCIsIFwiXFxcXGdlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhN2VcIiwgXCJcXFxcZ2Vxc2xhbnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOTZcIiwgXCJcXFxcZXFzbGFudGd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3M1wiLCBcIlxcXFxndHJzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhODZcIiwgXCJcXFxcZ3RyYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQ3XCIsIFwiXFxcXGd0cmRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkOVwiLCBcIlxcXFxnZ2dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzdcIiwgXCJcXFxcZ3RybGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkYlwiLCBcIlxcXFxndHJlcWxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOGNcIiwgXCJcXFxcZ3RyZXFxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1NlwiLCBcIlxcXFxlcWNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTdcIiwgXCJcXFxcY2lyY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjVjXCIsIFwiXFxcXHRyaWFuZ2xlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFx0aGlja3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFx0aGlja2FwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjNlwiLCBcIlxcXFxzdXBzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDFcIiwgXCJcXFxcU3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjkwXCIsIFwiXFxcXHNxc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdkXCIsIFwiXFxcXHN1Y2NjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmRmXCIsIFwiXFxcXGN1cmx5ZXFzdWNjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdmXCIsIFwiXFxcXHN1Y2NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjhcIiwgXCJcXFxcc3VjY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmI1XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhOVwiLCBcIlxcXFxWZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxzaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxzaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjZjXCIsIFwiXFxcXGJldHdlZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDRcIiwgXCJcXFxccGl0Y2hmb3JrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjFkXCIsIFwiXFxcXHZhcnByb3B0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjVjMFwiLCBcIlxcXFxibGFja3RyaWFuZ2xlbGVmdFwiKTtcbi8vIHVuaWNvZGUtbWF0aCBzYXlzIHRoYXQgXFx0aGVyZWZvcmUgaXMgYSBtYXRob3JkIGF0b20uXG4vLyBXZSBrZXB0IHRoZSBhbXNzeW1iIGF0b20gdHlwZSwgd2hpY2ggaXMgcmVsLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjM0XCIsIFwiXFxcXHRoZXJlZm9yZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwZFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjViNlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlcmlnaHRcIik7XG4vLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcYmVjYXVzZSBpcyBhIG1hdGhvcmQgYXRvbS5cbi8vIFdlIGtlcHQgdGhlIGFtc3N5bWIgYXRvbSB0eXBlLCB3aGljaCBpcyByZWwuXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMzVcIiwgXCJcXFxcYmVjYXVzZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dndHJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYjJcIiwgXCJcXFxcbGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmIzXCIsIFwiXFxcXHJoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0MlwiLCBcIlxcXFxlcXNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxEb3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1Mjk3ZFwiLCBcIlxcXFxzdHJpY3RpZlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1Mjk3Y1wiLCBcIlxcXFxzdHJpY3RmaVwiLCB0cnVlKTtcblxuLy8gQU1TIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxNFwiLCBcIlxcXFxkb3RwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE2XCIsIFwiXFxcXHNtYWxsc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcQ2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXEN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MmE1ZVwiLCBcIlxcXFxkb3VibGViYXJ3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5ZlwiLCBcIlxcXFxib3htaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5ZVwiLCBcIlxcXFxib3hwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUM0XCIsIFwiXFxcXGJveHNsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM3XCIsIFwiXFxcXGRpdmlkZW9udGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzlcIiwgXCJcXFxcbHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmNhXCIsIFwiXFxcXHJ0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjYlwiLCBcIlxcXFxsZWZ0dGhyZWV0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjY1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyY2ZcIiwgXCJcXFxcY3VybHl3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjZVwiLCBcIlxcXFxjdXJseXZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5ZFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5YlwiLCBcIlxcXFxjaXJjbGVkYXN0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmJhXCIsIFwiXFxcXGludGVyY2FsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXGRvdWJsZWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJkM1wiLCBcIlxcXFxkb3VibGVjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYTBcIiwgXCJcXFxcYm94dGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzhcIiwgXCJcXFxcYm93dGllXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM4XCIsIFwiXFxcXEpvaW5cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3ZDVcIiwgXCJcXFxcbGVmdG91dGVyam9pblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdkNlwiLCBcIlxcXFxyaWdodG91dGVyam9pblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdkN1wiLCBcIlxcXFxmdWxsb3V0ZXJqb2luXCIsIHRydWUpO1xuXG4vLyBzdGl4IEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIzOFwiLCBcIlxcXFxkb3RtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdEMVwiLCBcIlxcXFx3ZWRnZWRvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdDN1wiLCBcIlxcXFx2ZWVkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNjJcIiwgXCJcXFxcZG91YmxlYmFydmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTYzXCIsIFwiXFxcXHZlZWRvdWJsZWJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE1RlwiLCBcIlxcXFx3ZWRnZWJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE2MFwiLCBcIlxcXFx3ZWRnZWRvdWJsZWJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE1NFwiLCBcIlxcXFxWZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNTNcIiwgXCJcXFxcV2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDNcIiwgXCJcXFxcYmFyY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQyXCIsIFwiXFxcXGJhcmN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0OFwiLCBcIlxcXFxjYXBiYXJjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDBcIiwgXCJcXFxcY2FwZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQ3XCIsIFwiXFxcXGNhcG92ZXJjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDZcIiwgXCJcXFxcY3Vwb3ZlcmNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0RFwiLCBcIlxcXFxjbG9zZWR2YXJjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNENcIiwgXCJcXFxcY2xvc2VkdmFyY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTJBXCIsIFwiXFxcXG1pbnVzZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTJCXCIsIFwiXFxcXG1pbnVzZmRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMkNcIiwgXCJcXFxcbWludXNyZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJCQlwiLCBcIlxcXFxYb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQkNcIiwgXCJcXFxcTmFuZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJCRFwiLCBcIlxcXFxOb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQkRcIiwgXCJcXFxcYmFydmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQUY0XCIsIFwiXFxcXGludGVybGVhdmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5RTJcIiwgXCJcXFxcc2h1ZmZsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkFGNlwiLCBcIlxcXFx0aHJlZWRvdGNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOTgyXCIsIFwiXFxcXHR5cGVjb2xvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIzRVwiLCBcIlxcXFxpbnZsYXp5c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0QlwiLCBcIlxcXFx0d29jYXBzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTRBXCIsIFwiXFxcXHR3b2N1cHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNEVcIiwgXCJcXFxcU3FjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNEZcIiwgXCJcXFxcU3FjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNTZcIiwgXCJcXFxcdmVlb252ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNTVcIiwgXCJcXFxcd2VkZ2VvbndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUQ3XCIsIFwiXFxcXGJsYWNraG91cmdsYXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUM2XCIsIFwiXFxcXGJveGFzdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDOFwiLCBcIlxcXFxib3hib3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzdcIiwgXCJcXFxcYm94Y2lyY2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjlDXCIsIFwiXFxcXGNpcmNsZWRlcXVhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlCN1wiLCBcIlxcXFxjaXJjbGVkcGFyYWxsZWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QjZcIiwgXCJcXFxcY2lyY2xlZHZlcnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QjVcIiwgXCJcXFxcY2lyY2xlaGJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFMVwiLCBcIlxcXFxjb25jYXZlZGlhbW9uZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFMlwiLCBcIlxcXFxjb25jYXZlZGlhbW9uZHRpY2tsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0UzXCIsIFwiXFxcXGNvbmNhdmVkaWFtb25kdGlja3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMkM0XCIsIFwiXFxcXGRpYW1vbmRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5RDZcIiwgXCJcXFxcaG91cmdsYXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0UwXCIsIFwiXFxcXGxvemVuZ2VtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjMzRFwiLCBcIlxcXFxvYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUI4XCIsIFwiXFxcXG9ic2xhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMzhcIiwgXCJcXFxcb2RpdlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDMVwiLCBcIlxcXFxvZ3JlYXRlcnRoYW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzBcIiwgXCJcXFxcb2xlc3N0aGFuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUI5XCIsIFwiXFxcXG9wZXJwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTM3XCIsIFwiXFxcXE90aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzNlwiLCBcIlxcXFxvdGltZXNoYXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQzZcIiwgXCJcXFxcc3RhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjVCM1wiLCBcIlxcXFx0cmlhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzQVwiLCBcIlxcXFx0cmlhbmdsZW1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTM5XCIsIFwiXFxcXHRyaWFuZ2xlcGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzQlwiLCBcIlxcXFx0cmlhbmdsZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0U0XCIsIFwiXFxcXHdoaXRlc3F1YXJldGlja2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RTVcIiwgXCJcXFxcd2hpdGVzcXVhcmV0aWNrcmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMzNcIiwgXCJcXFxcc21hc2h0aW1lc1wiLCB0cnVlKTtcblxuLy8gQU1TIEFycm93c1xuLy8gTm90ZTogdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFlMiB0byB0aGVpciBvd24gZnVuY3Rpb24gXFxyaWdodGRhc2hhcnJvdy5cbi8vIFdlJ2xsIG1hcCBpdCB0byBBTVMgZnVuY3Rpb24gXFxkYXNocmlnaHRhcnJvdy4gSXQgcHJvZHVjZXMgdGhlIHNhbWUgYXRvbS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFlMlwiLCBcIlxcXFxkYXNocmlnaHRhcnJvd1wiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxZTAgdG8gXFxsZWZ0ZGFzaGFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWUwXCIsIFwiXFxcXGRhc2hsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzdcIiwgXCJcXFxcbGVmdGxlZnRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzZcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWRhXCIsIFwiXFxcXExsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOWVcIiwgXCJcXFxcdHdvaGVhZGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhMlwiLCBcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWFiXCIsIFwiXFxcXGxvb3BhcnJvd2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2JcIiwgXCJcXFxcbGVmdHJpZ2h0aGFycG9vbnNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYjZcIiwgXCJcXFxcY3VydmVhcnJvd2xlZnRcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWJhIHRvIFxcYWN3b3BlbmNpcmNsZWFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJhXCIsIFwiXFxcXGNpcmNsZWFycm93bGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiMFwiLCBcIlxcXFxMc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiZlwiLCBcIlxcXFx1cGhhcnBvb25sZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWMzXCIsIFwiXFxcXGRvd25oYXJwb29ubGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiNlwiLCBcIlxcXFxvcmlnb2ZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjdcIiwgXCJcXFxcaW1hZ2VvZlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiOFwiLCBcIlxcXFxtdWx0aW1hcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhZFwiLCBcIlxcXFxsZWZ0cmlnaHRzcXVpZ2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWM5XCIsIFwiXFxcXHJpZ2h0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzRcIiwgXCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWEwXCIsIFwiXFxcXHR3b2hlYWRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWEzXCIsIFwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWFjXCIsIFwiXFxcXGxvb3BhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWI3XCIsIFwiXFxcXGN1cnZlYXJyb3dyaWdodFwiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxYmIgdG8gXFxjd29wZW5jaXJjbGVhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiYlwiLCBcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWIxXCIsIFwiXFxcXFJzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjYVwiLCBcIlxcXFxkb3duZG93bmFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFx1cGhhcnBvb25yaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjMlwiLCBcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWRkXCIsIFwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxsZWFkc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWRiXCIsIFwiXFxcXFJyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJlXCIsIFwiXFxcXHJlc3RyaWN0aW9uXCIpO1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiYFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcJFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcJFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcdGV4dGRvbGxhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIsKiXCIsIFwiXFxcXGNlbnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLColwiLCBcIlxcXFxjZW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiX1wiLCBcIlxcXFx0ZXh0dW5kZXJzY29yZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTI0MjNcIiwgXCJcXFxcdGV4dHZpc2libGVzcGFjZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMjBcIiwgXCJcXFxcYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjFlXCIsIFwiXFxcXGluZnR5XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzMlwiLCBcIlxcXFxwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzNcIiwgXCJcXFxcZHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzNFwiLCBcIlxcXFx0cnByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjA1N1wiLCBcIlxcXFxxcHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWIzXCIsIFwiXFxcXHRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5MVwiLCBcIlxcXFxBbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTJcIiwgXCJcXFxcQmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5NVwiLCBcIlxcXFxFcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5NlwiLCBcIlxcXFxaZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5N1wiLCBcIlxcXFxFdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk4XCIsIFwiXFxcXFRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5OVwiLCBcIlxcXFxJb3RhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5YVwiLCBcIlxcXFxLYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5Y1wiLCBcIlxcXFxNdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWRcIiwgXCJcXFxcTnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzllXCIsIFwiXFxcXFhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5ZlwiLCBcIlxcXFxPbWljcm9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhMFwiLCBcIlxcXFxQaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTFcIiwgXCJcXFxcUmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhM1wiLCBcIlxcXFxTaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTRcIiwgXCJcXFxcVGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2E3XCIsIFwiXFxcXENoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYThcIiwgXCJcXFxcUHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhOVwiLCBcIlxcXFxPbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTFcIiwgXCJcXFxcQWxwaGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzkyXCIsIFwiXFxcXEJldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzkzXCIsIFwiXFxcXEdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5NFwiLCBcIlxcXFxEZWx0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTVcIiwgXCJcXFxcRXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTZcIiwgXCJcXFxcWmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTdcIiwgXCJcXFxcRXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTlcIiwgXCJcXFxcSW90YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWFcIiwgXCJcXFxcS2FwcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzliXCIsIFwiXFxcXExhbWJkYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWNcIiwgXCJcXFxcTXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzlkXCIsIFwiXFxcXE51XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWZcIiwgXCJcXFxcT21pY3JvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2ExXCIsIFwiXFxcXFJob1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTNcIiwgXCJcXFxcU2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E0XCIsIFwiXFxcXFRhdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTVcIiwgXCJcXFxcVXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTZcIiwgXCJcXFxcUGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhN1wiLCBcIlxcXFxDaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUwMGFjXCIsIFwiXFxcXG5lZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTAwYWNcIiwgXCJcXFxcbG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyYTRcIiwgXCJcXFxcdG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjJhNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjMwMFwiLCBcIlxcXFx2YXJub3RoaW5nXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiMVwiLCBcIlxcXFxhbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjJcIiwgXCJcXFxcYmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjNcIiwgXCJcXFxcZ2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I0XCIsIFwiXFxcXGRlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNmNVwiLCBcIlxcXFxlcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiNlwiLCBcIlxcXFx6ZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiN1wiLCBcIlxcXFxldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I4XCIsIFwiXFxcXHRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiOVwiLCBcIlxcXFxpb3RhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiYVwiLCBcIlxcXFxrYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmJcIiwgXCJcXFxcbGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiY1wiLCBcIlxcXFxtdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmRcIiwgXCJcXFxcbnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2JlXCIsIFwiXFxcXHhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiZlwiLCBcIlxcXFxvbWljcm9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjMFwiLCBcIlxcXFxwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzFcIiwgXCJcXFxccmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjM1wiLCBcIlxcXFxzaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzRcIiwgXCJcXFxcdGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjNVwiLCBcIlxcXFx1cHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkNVwiLCBcIlxcXFxwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2M3XCIsIFwiXFxcXGNoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzhcIiwgXCJcXFxccHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjOVwiLCBcIlxcXFxvbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjVcIiwgXCJcXFxcdmFyZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDFcIiwgXCJcXFxcdmFydGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Q2XCIsIFwiXFxcXHZhcnBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNmMVwiLCBcIlxcXFx2YXJyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2MyXCIsIFwiXFxcXHZhcnNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjNlwiLCBcIlxcXFx2YXJwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Q4XCIsIFwiXFxcXENvcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkOVwiLCBcIlxcXFxjb3BwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDlcIiwgXCJcXFxcdmFyY29wcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2RlXCIsIFwiXFxcXEtvcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkZlwiLCBcIlxcXFxrb3BwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZTBcIiwgXCJcXFxcU2FtcGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2UxXCIsIFwiXFxcXHNhbXBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkYVwiLCBcIlxcXFxTdGlnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2RiXCIsIFwiXFxcXHN0aWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTJhZWJcIiwgXCJcXFxcQm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFx1MjIxN1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiK1wiLCBcIitcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTdcIiwgXCIqXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMDQ0XCIsIFwiL1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjA0NFwiLCBcIlxcdTIwNDRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTJcIiwgXCItXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM1XCIsIFwiXFxcXGNkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMThcIiwgXCJcXFxcY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MDBmN1wiLCBcIlxcXFxkaXZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTAwYjFcIiwgXCJcXFxccG1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTAwZDdcIiwgXCJcXFxcdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMjlcIiwgXCJcXFxcY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjJhXCIsIFwiXFxcXGN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzZXRtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFxsYW5kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjI4XCIsIFwiXFxcXGxvclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFx3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFx2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyN2U2XCIsIFwiXFxcXGxsYnJhY2tldFwiLCB0cnVlKTsgLy8gc3RtYXJ5cmQvc2VtYW50aWMgcGFja2FnZXNcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyN2U3XCIsIFwiXFxcXHJyYnJhY2tldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI3ZThcIiwgXCJcXFxcbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjdlYVwiLCBcIlxcXFxsQW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyOTg5XCIsIFwiXFxcXGxsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJ8XCIsIFwiXFxcXGx2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjAxNlwiLCBcIlxcXFxsVmVydFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIiFcIiwgXCJcXFxcb2NcIik7IC8vIGNtbGwgcGFja2FnZVxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiP1wiLCBcIlxcXFx3blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxOTNcIiwgXCJcXFxcc2hwb3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTk1XCIsIFwiXFxcXHNoaWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjE5MVwiLCBcIlxcXFxzaG5lZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCI/XCIsIFwiP1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCIhXCIsIFwiIVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCLigLxcIiwgXCLigLxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjdlYlwiLCBcIlxcXFxyQW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1Mjk4YVwiLCBcIlxcXFxycmFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcInxcIiwgXCJcXFxccnZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjAxNlwiLCBcIlxcXFxyVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI5ODNcIiwgXCJcXFxcbEJyYWNlXCIsIHRydWUpOyAvLyBzdG1hcnlyZC9zZW1hbnRpYyBwYWNrYWdlc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI5ODRcIiwgXCJcXFxcckJyYWNlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCI9XCIsIFwiXFxcXGVxdWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFxhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiPlwiLCBcIlxcXFxndFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwOFwiLCBcIlxcXFxpblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwOVwiLCBcIlxcXFxub3RpblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1ZTAyMFwiLCBcIlxcXFxAbm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjgyXCIsIFwiXFxcXHN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4M1wiLCBcIlxcXFxzdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODZcIiwgXCJcXFxcc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODdcIiwgXCJcXFxcc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg4XCIsIFwiXFxcXG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODlcIiwgXCJcXFxcbnN1cHNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg5XCIsIFwiXFxcXG5zdXBzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYThcIiwgXCJcXFxcbW9kZWxzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkwXCIsIFwiXFxcXGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIjxcIiwgXCJcXFxcbHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTJcIiwgXCJcXFxccmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFx0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MVwiLCBcIlxcXFxuZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcxXCIsIFwiXFxcXG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcxXCIsIFwiXFxcXG5nZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MFwiLCBcIlxcXFxubGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFlYlwiLCBcIlxcXFxQZXJwXCIsIHRydWUpOyAvL2NtbGwgcGFja2FnZVxuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFwgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTtcbi8vIFJlZjogTGFUZVggU291cmNlIDJlOiBcXERlY2xhcmVSb2J1c3RDb21tYW5ke1xcbm9icmVha3NwYWNlfXslXG5kZWZpbmVTeW1ib2wobWF0aCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCIgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIG51bGwsIFwiXFxcXG5vYnJlYWtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgc3BhY2luZywgbnVsbCwgXCJcXFxcYWxsb3dicmVha1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBwdW5jdCwgXCIsXCIsIFwiLFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBwdW5jdCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBwdW5jdCwgXCI7XCIsIFwiO1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiY1wiLCBcIlxcXFxiYXJ3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiYlwiLCBcIlxcXFx2ZWViYXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTlcIiwgXCJcXFxcb2RvdFwiLCB0cnVlKTtcbi8vIEZpcmVmb3ggdHVybnMg4oqVIGludG8gYW4gZW1vamkuIFNvIGFwcGVuZCBcXHVGRTBFLiBEZWZpbmUgVW5pY29kZSBjaGFyYWN0ZXIgaW4gbWFjcm9zLCBub3QgaGVyZS5cbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5NVxcdUZFMEVcIiwgXCJcXFxcb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTdcIiwgXCJcXFxcb3RpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk4XCIsIFwiXFxcXG9zbGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5YVwiLCBcIlxcXFxjaXJjbGVkY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJhMVwiLCBcIlxcXFxib3hkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1YjNcIiwgXCJcXFxcYmlndHJpYW5nbGV1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjViZFwiLCBcIlxcXFxiaWd0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM0XCIsIFwiXFxcXGRpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1YzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNWI5XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHRleHRicmFjZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwifVwiLCBcIlxcXFx0ZXh0YnJhY2VyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIntcIiwgXCJcXFxcbGJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIn1cIiwgXCJcXFxccmJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiKFwiLCBcIlxcXFxscGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCLipodcIiwgXCJcXFxcbGxwYXJlbnRoZXNpc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCLipohcIiwgXCJcXFxccnJwYXJlbnRoZXNpc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIjxcIiwgXCJcXFxcdGV4dGxlc3NcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIj5cIiwgXCJcXFxcdGV4dGdyZWF0ZXJcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTIzMGFcIiwgXCJcXFxcbGZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzMGJcIiwgXCJcXFxccmZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFxiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJ8XCIsIFwifFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcInxcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcInxcIiwgXCJcXFxcdGV4dGJhclwiLCB0cnVlKTsgLy8gaW4gVDEgZm9udGVuY1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAxNlwiLCBcIlxcXFx8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAxNlwiLCBcIlxcXFxWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxNlwiLCBcIlxcXFx0ZXh0YmFyZGJsXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiflwiLCBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcXFxcIiwgXCJcXFxcdGV4dGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIl5cIiwgXCJcXFxcdGV4dGFzY2lpY2lyY3VtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkxXCIsIFwiXFxcXHVwYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDFcIiwgXCJcXFxcVXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5M1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDNcIiwgXCJcXFxcRG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk1XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWQ1XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMTBcIiwgXCJcXFxcY29wcm9kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyYzFcIiwgXCJcXFxcYmlndmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyYzBcIiwgXCJcXFxcYmlnd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwNFwiLCBcIlxcXFxiaWd1cGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA0XCIsIFwiXFxcXGJpZ2N1cHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwM1wiLCBcIlxcXFxiaWdjdXBkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwN1wiLCBcIlxcXFxiaWdkb3VibGV2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwOFwiLCBcIlxcXFxiaWdkb3VibGV3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMmMyXCIsIFwiXFxcXGJpZ2NhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMmMzXCIsIFwiXFxcXGJpZ2N1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJiXCIsIFwiXFxcXGludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJiXCIsIFwiXFxcXGludG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmNcIiwgXCJcXFxcaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJkXCIsIFwiXFxcXGlpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMGZcIiwgXCJcXFxccHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjExXCIsIFwiXFxcXHN1bVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTAyXCIsIFwiXFxcXGJpZ290aW1lc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTAxXCIsIFwiXFxcXGJpZ29wbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDBcIiwgXCJcXFxcYmlnb2RvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA5XCIsIFwiXFxcXGJpZ3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmVcIiwgXCJcXFxcb2ludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJmXCIsIFwiXFxcXG9paW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMzBcIiwgXCJcXFxcb2lpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMzFcIiwgXCJcXFxcaW50Y2xvY2t3aXNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMzJcIiwgXCJcXFxcdmFyb2ludGNsb2Nrd2lzZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBjXCIsIFwiXFxcXGlpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBkXCIsIFwiXFxcXGludGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBlXCIsIFwiXFxcXGludEJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBmXCIsIFwiXFxcXGZpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExMlwiLCBcIlxcXFxycHBvbGludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTEzXCIsIFwiXFxcXHNjcG9saW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMTVcIiwgXCJcXFxccG9pbnRpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExNlwiLCBcIlxcXFxzcWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTE3XCIsIFwiXFxcXGludGxhcmhrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMThcIiwgXCJcXFxcaW50eFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTE5XCIsIFwiXFxcXGludGNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTFhXCIsIFwiXFxcXGludGN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA1XCIsIFwiXFxcXGJpZ3NxY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXG1hdGhlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjJmMFwiLCBcIlxcXFxpZGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjJlZlwiLCBcIlxcXFxAY2RvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjJmMVwiLCBcIlxcXFxkZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyZWVcIiwgXCJcXFxcdmFydmRvdHNcIik7IC8vIFxcdmRvdHMgaXMgYSBtYWNyb1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2YXJ2ZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjYVwiLCBcIlxcXFxhY3V0ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDA2MFwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCBcIlxcXFxkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUyMDI2XCIsIFwiXFxcXGRkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUyMDI2XFx1MDAyZVwiLCBcIlxcXFxkZGRkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwN2VcIiwgXCJcXFxcdGlsZGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTIwM2VcIiwgXCJcXFxcYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXGJyZXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXGNoZWNrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMDVlXCIsIFwiXFxcXGhhdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MjE5MlwiLCBcIlxcXFx2ZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXG1hdGhyaW5nXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDEzMVwiLCBcIlxcXFxpbWF0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcam1hdGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFx1MDEzMVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXHUwMjM3XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDEzMVwiLCBcIlxcXFxpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDIzN1wiLCBcIlxcXFxqXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBkZlwiLCBcIlxcXFxzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwZTZcIiwgXCJcXFxcYWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMTUzXCIsIFwiXFxcXG9lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBmOFwiLCBcIlxcXFxvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDBmOFwiLCBcIlxcXFxvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBjNlwiLCBcIlxcXFxBRVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAxNTJcIiwgXCJcXFxcT0VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGQ4XCIsIFwiXFxcXE9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMGQ4XCIsIFwiXFxcXE9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyY2FcIiwgXCJcXFxcJ1wiKTsgLy8gYWN1dGVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxgXCIpOyAvLyBncmF2ZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmM2XCIsIFwiXFxcXF5cIik7IC8vIGNpcmN1bWZsZXhcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJkY1wiLCBcIlxcXFx+XCIpOyAvLyB0aWxkZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXD1cIik7IC8vIG1hY3JvblxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXHVcIik7IC8vIGJyZXZlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcLlwiKTsgLy8gZG90IGFib3ZlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAwYjhcIiwgXCJcXFxcY1wiKTsgLy8gY2VkaWxsYVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXHJcIik7IC8vIHJpbmcgYWJvdmVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFx2XCIpOyAvLyBjYXJvblxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMGE4XCIsICdcXFxcXCInKTsgLy8gZGlhZXJlc2lzXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyZGRcIiwgXCJcXFxcSFwiKTsgLy8gZG91YmxlIGFjdXRlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyY2FcIiwgXCJcXFxcJ1wiKTsgLy8gYWN1dGVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxgXCIpOyAvLyBncmF2ZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmM2XCIsIFwiXFxcXF5cIik7IC8vIGNpcmN1bWZsZXhcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkY1wiLCBcIlxcXFx+XCIpOyAvLyB0aWxkZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXD1cIik7IC8vIG1hY3JvblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXHVcIik7IC8vIGJyZXZlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcLlwiKTsgLy8gZG90IGFib3ZlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwYjhcIiwgXCJcXFxcY1wiKTsgLy8gY2VkaWxsYVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXHJcIik7IC8vIHJpbmcgYWJvdmVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFx2XCIpOyAvLyBjYXJvblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMGE4XCIsICdcXFxcXCInKTsgLy8gZGlhZXJlc2lzXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZGRcIiwgXCJcXFxcSFwiKTsgLy8gZG91YmxlIGFjdXRlXG5cbi8vIFRoZXNlIGxpZ2F0dXJlcyBhcmUgZGV0ZWN0ZWQgYW5kIGNyZWF0ZWQgaW4gUGFyc2VyLmpzJ3MgYGZvcm1MaWdhdHVyZXNgLlxuY29uc3QgbGlnYXR1cmVzID0ge1xuICBcIi0tXCI6IHRydWUsXG4gIFwiLS0tXCI6IHRydWUsXG4gIFwiYGBcIjogdHJ1ZSxcbiAgXCInJ1wiOiB0cnVlXG59O1xuXG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiXFxcXHRleHRlbmRhc2hcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIlxcXFx0ZXh0ZW1kYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiXFxcXHRleHRxdW90ZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCJcXFxcdGV4dHF1b3RlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiYGBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiXFxcXHRleHRxdW90ZWRibGxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiJydcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiXFxcXHRleHRxdW90ZWRibHJpZ2h0XCIpO1xuLy8gIFxcZGVncmVlIGZyb20gZ2Vuc3ltYiBwYWNrYWdlXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXGRlZ3JlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpO1xuLy8gXFx0ZXh0ZGVncmVlIGZyb20gaW5wdXRlbmMgcGFja2FnZVxuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFx0ZXh0ZGVncmVlXCIsIHRydWUpO1xuLy8gVE9ETzogSW4gTGFUZVgsIFxccG91bmRzIGNhbiBnZW5lcmF0ZSBhIGRpZmZlcmVudCBjaGFyYWN0ZXIgaW4gdGV4dCBhbmQgbWF0aFxuLy8gbW9kZSwgYnV0IGFtb25nIG91ciBmb250cywgb25seSBNYWluLVJlZ3VsYXIgZGVmaW5lcyB0aGlzIGNoYXJhY3RlciBcIjE2M1wiLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxwb3VuZHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXG1hdGhzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFx0ZXh0c3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMGFjXCIsIFwiXFxcXGV1cm9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMGFjXCIsIFwiXFxcXGV1cm9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMGFjXCIsIFwiXFxcXHRleHRldXJvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhOVwiLCBcIlxcXFxjb3B5cmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGE5XCIsIFwiXFxcXHRleHRjb3B5cmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMzAwXCIsIFwiXFxcXGRpYW1ldGVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjMwMFwiLCBcIlxcXFxkaWFtZXRlclwiKTtcblxuLy8gSXRhbGljIEdyZWVrXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZukXCIsIFwiXFxcXHZhckdhbW1hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2bpVwiLCBcIlxcXFx2YXJEZWx0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm6lcIiwgXCJcXFxcdmFyVGhldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZusXCIsIFwiXFxcXHZhckxhbWJkYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm69cIiwgXCJcXFxcdmFyWGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZuxXCIsIFwiXFxcXHZhclBpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2btFwiLCBcIlxcXFx2YXJTaWdtYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7ZcIiwgXCJcXFxcdmFyVXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7dcIiwgXCJcXFxcdmFyUGhpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2buVwiLCBcIlxcXFx2YXJQc2lcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZu6XCIsIFwiXFxcXHZhck9tZWdhXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bpFwiLCBcIlxcXFx2YXJHYW1tYVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm6VcIiwgXCJcXFxcdmFyRGVsdGFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZupXCIsIFwiXFxcXHZhclRoZXRhXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2brFwiLCBcIlxcXFx2YXJMYW1iZGFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZuvXCIsIFwiXFxcXHZhclhpXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bsVwiLCBcIlxcXFx2YXJQaVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7RcIiwgXCJcXFxcdmFyU2lnbWFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZu2XCIsIFwiXFxcXHZhclVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZu3XCIsIFwiXFxcXHZhclBoaVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7lcIiwgXCJcXFxcdmFyUHNpXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bulwiLCBcIlxcXFx2YXJPbWVnYVwiKTtcblxuXG4vLyBUaGVyZSBhcmUgbG90cyBvZiBzeW1ib2xzIHdoaWNoIGFyZSB0aGUgc2FtZSwgc28gd2UgYWRkIHRoZW0gaW4gYWZ0ZXJ3YXJkcy5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG5jb25zdCBtYXRoVGV4dFN5bWJvbHMgPSAnMDEyMzQ1Njc4OS9ALlwiJztcbmZvciAobGV0IGkgPSAwOyBpIDwgbWF0aFRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gdGV4dCBtb2RlXG5jb25zdCB0ZXh0U3ltYm9scyA9ICcwMTIzNDU2Nzg5IUAqKCktPStcIjs6Py8uLCc7XG5mb3IgKGxldCBpID0gMDsgaSA8IHRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gdGV4dFN5bWJvbHMuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcbmNvbnN0IGxldHRlcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbmZvciAobGV0IGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IGxldHRlcnMuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgY2gsIGNoKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIFNvbWUgbW9yZSBsZXR0ZXJzIGluIFVuaWNvZGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lLlxuY29uc3QgbmFycm93ID0gXCLDh8OQw57Dp8O+4oSC4oSN4oSV4oSZ4oSa4oSd4oSk4oSO4oSP4oSK4oSL4oSM4oSQ4oSR4oSS4oST4oSY4oSb4oSc4oSs4oSw4oSx4oSz4oSt4oSoXCI7XG5mb3IgKGxldCBpID0gMDsgaSA8IG5hcnJvdy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IG5hcnJvdy5jaGFyQXQoaSk7XG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBjaCwgY2gpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gVGhlIG5leHQgbG9vcCBsb2FkcyB3aWRlIChzdXJyb2dhdGUgcGFpcikgY2hhcmFjdGVycy5cbi8vIFdlIHN1cHBvcnQgc29tZSBsZXR0ZXJzIGluIHRoZSBVbmljb2RlIHJhbmdlIFUrMUQ0MDAgdG8gVSsxRDdGRixcbi8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9scy5cbmxldCB3aWRlQ2hhciA9IFwiXCI7XG5mb3IgKGxldCBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgLy8gVGhlIGhleCBudW1iZXJzIGluIHRoZSBuZXh0IGxpbmUgYXJlIGEgc3Vycm9nYXRlIHBhaXIuXG4gIC8vIDB4RDgzNSBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgZm9yIGFsbCBsZXR0ZXJzIGluIHRoZSByYW5nZSB3ZSBzdXBwb3J0LlxuICAvLyAweERDMDAgaXMgdGhlIGxvdyBzdXJyb2dhdGUgZm9yIGJvbGQgQS5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkYzAwICsgaSk7IC8vIEEtWiBhLXogYm9sZFxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkYzM0ICsgaSk7IC8vIEEtWiBhLXogaXRhbGljXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRjNjggKyBpKTsgLy8gQS1aIGEteiBib2xkIGl0YWxpY1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZDA0ICsgaSk7IC8vIEEtWiBhLXogRnJhY3R1clxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZGEwICsgaSk7IC8vIEEtWiBhLXogc2Fucy1zZXJpZlxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZGQ0ICsgaSk7IC8vIEEtWiBhLXogc2FucyBib2xkXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRlMDggKyBpKTsgLy8gQS1aIGEteiBzYW5zIGl0YWxpY1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZTcwICsgaSk7IC8vIEEtWiBhLXogbW9ub3NwYWNlXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRkMzggKyBpKTsgLy8gQS1aIGEteiBkb3VibGUgc3RydWNrXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICBjb25zdCBjaCA9IGxldHRlcnMuY2hhckF0KGkpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRjOWMgKyBpKTsgLy8gQS1aIGEteiBjYWxsaWdyYXBoaWNcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xufVxuXG4vLyBOZXh0LCBzb21lIHdpZGUgY2hhcmFjdGVyIG51bWVyYWxzXG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZmNlICsgaSk7IC8vIDAtOSBib2xkXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRmZTIgKyBpKTsgLy8gMC05IHNhbnMgc2VyaWZcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGZlYyArIGkpOyAvLyAwLTkgYm9sZCBzYW5zXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRmZjYgKyBpKTsgLy8gMC05IG1vbm9zcGFjZVxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG59XG5cbi8qXG4gKiBOZWl0aGVyIEZpcmVmb3ggbm9yIENocm9tZSBzdXBwb3J0IGhhcmQgbGluZSBicmVha3Mgb3Igc29mdCBsaW5lIGJyZWFrcy5cbiAqIChEZXNwaXRlIGh0dHBzOi8vd3d3LnczLm9yZy9NYXRoL2RyYWZ0LXNwZWMvbWF0aG1sLmh0bWwjY2hhcHRlcjNfcHJlc20ubGJhdHRycylcbiAqIFNvIFRlbW1sIGhhcyB3b3JrLWFyb3VuZHMgZm9yIGJvdGggaGFyZCBhbmQgc29mdCBicmVha3MuXG4gKiBUaGUgd29yay1hcm91bmRzIHNhZGx5IGRvIG5vdCB3b3JrIHNpbXVsdGFuZW91c2x5LiBBbnkgdG9wLWxldmVsIGhhcmRcbiAqIGJyZWFrIG1ha2VzIHNvZnQgbGluZSBicmVha3MgaW1wb3NzaWJsZS5cbiAqXG4gKiBIYXJkIGJyZWFrcyBhcmUgc2ltdWxhdGVkIGJ5IGNyZWF0aW5nIGEgPG10YWJsZT4gYW5kIHB1dHRpbmcgZWFjaCBsaW5lIGluIGl0cyBvd24gPG10cj4uXG4gKlxuICogVG8gY3JlYXRlIHNvZnQgbGluZSBicmVha3MsIFRlbW1sIGF2b2lkcyB1c2luZyB0aGUgPHNlbWFudGljcz4gYW5kIDxhbm5vdGF0aW9uPiB0YWdzLlxuICogVGhlbiB0aGUgdG9wIGxldmVsIG9mIGEgPG1hdGg+IGVsZW1lbnQgY2FuIGJlIG9jY3VwaWVkIGJ5IDxtcm93PiBlbGVtZW50cywgYW5kIHRoZSBicm93c2VyXG4gKiB3aWxsIGJyZWFrIGFmdGVyIGEgPG1yb3c+IGlmIHRoZSBleHByZXNzaW9uIGV4dGVuZHMgYmV5b25kIHRoZSBjb250YWluZXIgbGltaXQuXG4gKlxuICogVGhlIGRlZmF1bHQgaXMgZm9yIHNvZnQgbGluZSBicmVha3MgYWZ0ZXIgZWFjaCB0b3AtbGV2ZWwgYmluYXJ5IG9yXG4gKiByZWxhdGlvbmFsIG9wZXJhdG9yLCBwZXIgVGVYYm9vayBwLiAxNzMuIFNvIHdlIGdhdGhlciB0aGUgZXhwcmVzc2lvbiBpbnRvIDxtcm93PnMgc28gdGhhdFxuICogZWFjaCA8bXJvdz4gZW5kcyBpbiBhIGJpbmFyeSBvciByZWxhdGlvbmFsIG9wZXJhdG9yLlxuICpcbiAqIEFuIG9wdGlvbiBpcyBmb3Igc29mdCBsaW5lIGJyZWFrcyBiZWZvcmUgYW4gXCI9XCIgc2lnbi4gVGhhdCBjaGFuZ2VzIHRoZSA8bXJvdz5zLlxuICpcbiAqIFNvZnQgbGluZSBicmVha3Mgd2lsbCBub3Qgd29yayBpbiBDaHJvbWl1bSBhbmQgU2FmYXJpLCBvbmx5IEZpcmVmb3guXG4gKlxuICogSG9wZWZ1bGx5IGJyb3dzZXJzIHdpbGwgc29tZWRheSBkbyB0aGVpciBvd24gbGluZWJyZWFraW5nIGFuZCB3ZSB3aWxsIGJlIGFibGUgdG8gZGVsZXRlXG4gKiBtdWNoIG9mIHRoaXMgbW9kdWxlLlxuICovXG5cbmNvbnN0IG9wZW5EZWxpbXMgPSBcIihbe+KMiuKMiOKfqOKfruKOsOKfpuKmg1wiO1xuY29uc3QgY2xvc2VEZWxpbXMgPSBcIildfeKMi+KMieKfqeKfr+KOseKfpuKmhFwiO1xuXG5mdW5jdGlvbiBzZXRMaW5lQnJlYWtzKGV4cHJlc3Npb24sIHdyYXBNb2RlLCBpc0Rpc3BsYXlNb2RlKSB7XG4gIGNvbnN0IG10cnMgPSBbXTtcbiAgbGV0IG1yb3dzID0gW107XG4gIGxldCBibG9jayA9IFtdO1xuICBsZXQgbnVtVG9wTGV2ZWxFcXVhbHMgPSAwO1xuICBsZXQgaSA9IDA7XG4gIGxldCBsZXZlbCA9IDA7XG4gIHdoaWxlIChpIDwgZXhwcmVzc2lvbi5sZW5ndGgpIHtcbiAgICB3aGlsZSAoZXhwcmVzc2lvbltpXSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgIGV4cHJlc3Npb24uc3BsaWNlKGksIDEsIC4uLmV4cHJlc3Npb25baV0uY2hpbGRyZW4pOyAvLyBFeHBhbmQgdGhlIGZyYWdtZW50LlxuICAgIH1cbiAgICBjb25zdCBub2RlID0gZXhwcmVzc2lvbltpXTtcbiAgICBpZiAobm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy5saW5lYnJlYWsgJiZcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5saW5lYnJlYWsgPT09IFwibmV3bGluZVwiKSB7XG4gICAgICAvLyBBIGhhcmQgbGluZSBicmVhay4gQ3JlYXRlIGEgPG10cj4gZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgaWYgKGJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXJvd3MucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYmxvY2spKTtcbiAgICAgIH1cbiAgICAgIG1yb3dzLnB1c2gobm9kZSk7XG4gICAgICBibG9jayA9IFtdO1xuICAgICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgbXJvd3MpO1xuICAgICAgbXRkLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgbXRycy5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFttdGRdKSk7XG4gICAgICBtcm93cyA9IFtdO1xuICAgICAgaSArPSAxO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgYmxvY2sucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS50eXBlICYmIG5vZGUudHlwZSA9PT0gXCJtb1wiICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZS5hdHRyaWJ1dGVzLCBcIm1vdmFibGVsaW1pdHNcIikpIHtcbiAgICAgIGNvbnN0IGNoID0gbm9kZS5jaGlsZHJlblswXS50ZXh0O1xuICAgICAgaWYgKG9wZW5EZWxpbXMuaW5kZXhPZihjaCkgPiAtMSkge1xuICAgICAgICBsZXZlbCArPSAxO1xuICAgICAgfSBlbHNlIGlmIChjbG9zZURlbGltcy5pbmRleE9mKGNoKSA+IC0xKSB7XG4gICAgICAgIGxldmVsIC09IDE7XG4gICAgICB9IGVsc2UgaWYgKGxldmVsID09PSAwICYmIHdyYXBNb2RlID09PSBcIj1cIiAmJiBjaCA9PT0gXCI9XCIpIHtcbiAgICAgICAgbnVtVG9wTGV2ZWxFcXVhbHMgKz0gMTtcbiAgICAgICAgaWYgKG51bVRvcExldmVsRXF1YWxzID4gMSkge1xuICAgICAgICAgIGJsb2NrLnBvcCgpO1xuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGJsb2NrLiAoSW5zZXJ0IGEgc29mdCBsaW5lYnJlYWsuKVxuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYmxvY2spO1xuICAgICAgICAgIG1yb3dzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgYmxvY2sgPSBbbm9kZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGV2ZWwgPT09IDAgJiYgd3JhcE1vZGUgPT09IFwidGV4XCIgJiYgY2ggIT09IFwi4oiHXCIpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZvbGxvd2luZyBub2RlIGlzIGEgXFxub2JyZWFrIHRleHQgbm9kZSwgZS5nLiBcIn5cIlwiXG4gICAgICAgIGNvbnN0IG5leHQgPSBpIDwgZXhwcmVzc2lvbi5sZW5ndGggLSAxID8gZXhwcmVzc2lvbltpICsgMV0gOiBudWxsO1xuICAgICAgICBsZXQgZ2x1ZUlzRnJlZU9mTm9icmVhayA9IHRydWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKFxuICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgbmV4dC50eXBlID09PSBcIm10ZXh0XCIgJiZcbiAgICAgICAgICAgIG5leHQuYXR0cmlidXRlcy5saW5lYnJlYWsgJiZcbiAgICAgICAgICAgIG5leHQuYXR0cmlidXRlcy5saW5lYnJlYWsgPT09IFwibm9icmVha1wiXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBXZSBtYXkgbmVlZCB0byBzdGFydCBhIG5ldyBibG9jay5cbiAgICAgICAgICAvLyBGaXJzdCwgcHV0IGFueSBwb3N0LW9wZXJhdG9yIGdsdWUgb24gc2FtZSBsaW5lIGFzIG9wZXJhdG9yLlxuICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGV4cHJlc3Npb24ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5kID0gZXhwcmVzc2lvbltqXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbmQudHlwZSAmJlxuICAgICAgICAgICAgICBuZC50eXBlID09PSBcIm1zcGFjZVwiICYmXG4gICAgICAgICAgICAgICEobmQuYXR0cmlidXRlcy5saW5lYnJlYWsgJiYgbmQuYXR0cmlidXRlcy5saW5lYnJlYWsgPT09IFwibmV3bGluZVwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJsb2NrLnB1c2gobmQpO1xuICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBuZC5hdHRyaWJ1dGVzICYmXG4gICAgICAgICAgICAgICAgbmQuYXR0cmlidXRlcy5saW5lYnJlYWsgJiZcbiAgICAgICAgICAgICAgICBuZC5hdHRyaWJ1dGVzLmxpbmVicmVhayA9PT0gXCJub2JyZWFrXCJcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2x1ZUlzRnJlZU9mTm9icmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsdWVJc0ZyZWVPZk5vYnJlYWspIHtcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBibG9jay4gKEluc2VydCBhIHNvZnQgbGluZWJyZWFrLilcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJsb2NrKTtcbiAgICAgICAgICBtcm93cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGJsb2NrID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSArPSAxO1xuICB9XG4gIGlmIChibG9jay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBibG9jayk7XG4gICAgbXJvd3MucHVzaChlbGVtZW50KTtcbiAgfVxuICBpZiAobXRycy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgbXJvd3MpO1xuICAgIG10ZC5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICBjb25zdCBtdHIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbbXRkXSk7XG4gICAgbXRycy5wdXNoKG10cik7XG4gICAgY29uc3QgbXRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgbXRycyk7XG4gICAgaWYgKCFpc0Rpc3BsYXlNb2RlKSB7XG4gICAgICBtdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uYWxpZ25cIiwgXCJsZWZ0XCIpO1xuICAgICAgbXRhYmxlLnNldEF0dHJpYnV0ZShcInJvd3NwYWNpbmdcIiwgXCIwZW1cIik7XG4gICAgfVxuICAgIHJldHVybiBtdGFibGVcbiAgfVxuICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KG1yb3dzKTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udmVydHMgYSBwYXJzZSB0cmVlIGludG8gYSBjb3JyZXNwb25kaW5nIE1hdGhNTCB0cmVlLiBUaGUgbWFpblxuICogZW50cnkgcG9pbnQgaXMgdGhlIGBidWlsZE1hdGhNTGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcGFyc2UgdHJlZSBmcm9tIHRoZVxuICogcGFyc2VyLlxuICovXG5cblxuLyoqXG4gKiBUYWtlcyBhIHN5bWJvbCBhbmQgY29udmVydHMgaXQgaW50byBhIE1hdGhNTCB0ZXh0IG5vZGUgYWZ0ZXIgcGVyZm9ybWluZ1xuICogb3B0aW9uYWwgcmVwbGFjZW1lbnQgZnJvbSBzeW1ib2xzLmpzLlxuICovXG5jb25zdCBtYWtlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG1vZGUsIHN0eWxlKSB7XG4gIGlmIChcbiAgICBzeW1ib2xzW21vZGVdW3RleHRdICYmXG4gICAgc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlICYmXG4gICAgdGV4dC5jaGFyQ29kZUF0KDApICE9PSAweGQ4MzUgJiZcbiAgICAhKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxpZ2F0dXJlcywgdGV4dCkgJiZcbiAgICAgIHN0eWxlICYmXG4gICAgICAoKHN0eWxlLmZvbnRGYW1pbHkgJiYgc3R5bGUuZm9udEZhbWlseS5zbGljZSg0LCA2KSA9PT0gXCJ0dFwiKSB8fFxuICAgICAgICAoc3R5bGUuZm9udCAmJiBzdHlsZS5mb250LnNsaWNlKDQsIDYpID09PSBcInR0XCIpKVxuICAgIClcbiAgKSB7XG4gICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh0ZXh0KTtcbn07XG5cbmNvbnN0IGNvcHlDaGFyID0gKG5ld1JvdywgY2hpbGQpID0+IHtcbiAgaWYgKG5ld1Jvdy5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHxcbiAgICAgIG5ld1Jvdy5jaGlsZHJlbltuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJtdGV4dFwiKSB7XG4gICAgY29uc3QgbXRleHQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgIFwibXRleHRcIixcbiAgICAgIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShjaGlsZC5jaGlsZHJlblswXS50ZXh0KV1cbiAgICApO1xuICAgIG5ld1Jvdy5jaGlsZHJlbi5wdXNoKG10ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBuZXdSb3cuY2hpbGRyZW5bbmV3Um93LmNoaWxkcmVuLmxlbmd0aCAtIDFdLmNoaWxkcmVuWzBdLnRleHQgKz0gY2hpbGQuY2hpbGRyZW5bMF0udGV4dDtcbiAgfVxufTtcblxuY29uc3QgY29uc29saWRhdGVUZXh0ID0gbXJvdyA9PiB7XG4gIC8vIElmIHBvc3NpYmxlLCBjb25zb2xpZGF0ZSBhZGphY2VudCA8bXRleHQ+IGVsZW1lbnRzIGludG8gYSBzaW5nbGUgZWxlbWVudC5cbiAgaWYgKG1yb3cudHlwZSAhPT0gXCJtcm93XCIgJiYgbXJvdy50eXBlICE9PSBcIm1zdHlsZVwiKSB7IHJldHVybiBtcm93IH1cbiAgaWYgKG1yb3cuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7IHJldHVybiBtcm93IH0gLy8gZW1wdHkgZ3JvdXAsIGUuZy4sIFxcdGV4dHt9XG4gIGNvbnN0IG5ld1JvdyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtcm93LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBtcm93LmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBcIm10ZXh0XCIgJiYgT2JqZWN0LmtleXMoY2hpbGQuYXR0cmlidXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb3B5Q2hhcihuZXdSb3csIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IFwibXJvd1wiKSB7XG4gICAgICAvLyBXZSdsbCBhbHNvIGNoZWNrIHRoZSBjaGlsZHJlbiBvZiBhbiBtcm93LiBPbmUgbGV2ZWwgb25seS4gTm8gcmVjdXJzaW9uLlxuICAgICAgbGV0IGNhbkNvbnNvbGlkYXRlID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgZ3JhbmRDaGlsZCA9IGNoaWxkLmNoaWxkcmVuW2pdO1xuICAgICAgICBpZiAoZ3JhbmRDaGlsZC50eXBlICE9PSBcIm10ZXh0XCIgfHwgT2JqZWN0LmtleXMoY2hpbGQuYXR0cmlidXRlcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY2FuQ29uc29saWRhdGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FuQ29uc29saWRhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGdyYW5kQ2hpbGQgPSBjaGlsZC5jaGlsZHJlbltqXTtcbiAgICAgICAgICBjb3B5Q2hhcihuZXdSb3csIGdyYW5kQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdSb3cuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Jvdy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmV3Um93LmNoaWxkcmVuW2ldLnR5cGUgPT09IFwibXRleHRcIikge1xuICAgICAgY29uc3QgbXRleHQgPSBuZXdSb3cuY2hpbGRyZW5baV07XG4gICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlbmRlciBhIHNwYWNlIGF0IGVpdGhlciBlbmQgb2YgYW4gPG10ZXh0PiBzdHJpbmcuXG4gICAgICAvLyBUbyBnZXQgcHJvcGVyIHJlbmRlcmluZywgd2UgcmVwbGFjZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlcyB3aXRoIG5vLWJyZWFrIHNwYWNlcy5cbiAgICAgIGlmIChtdGV4dC5jaGlsZHJlblswXS50ZXh0LmNoYXJBdCgwKSA9PT0gXCIgXCIpIHtcbiAgICAgICAgbXRleHQuY2hpbGRyZW5bMF0udGV4dCA9IFwiXFx1MDBhMFwiICsgbXRleHQuY2hpbGRyZW5bMF0udGV4dC5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEwgPSBtdGV4dC5jaGlsZHJlblswXS50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChMID4gMCAmJiBtdGV4dC5jaGlsZHJlblswXS50ZXh0LmNoYXJBdChMIC0gMSkgPT09IFwiIFwiKSB7XG4gICAgICAgIG10ZXh0LmNoaWxkcmVuWzBdLnRleHQgPSBtdGV4dC5jaGlsZHJlblswXS50ZXh0LnNsaWNlKDAsIC0xKSArIFwiXFx1MDBhMFwiO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobXJvdy5hdHRyaWJ1dGVzKSkge1xuICAgICAgICBtdGV4dC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5ld1Jvdy5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbmV3Um93LmNoaWxkcmVuWzBdLnR5cGUgPT09IFwibXRleHRcIikge1xuICAgIHJldHVybiBuZXdSb3cuY2hpbGRyZW5bMF07IC8vIEEgY29uc29saWRhdGVkIDxtdGV4dD5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3Um93XG4gIH1cbn07XG5cbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMgaW4gYW4gPG1yb3c+IG5vZGUgaWYgbmVlZGVkLCBpLmUuLFxuICogdW5sZXNzIHRoZSBhcnJheSBoYXMgbGVuZ3RoIDEuICBBbHdheXMgcmV0dXJucyBhIHNpbmdsZSBub2RlLlxuICovXG5jb25zdCBtYWtlUm93ID0gZnVuY3Rpb24oYm9keSwgc2VtaXNpbXBsZSA9IGZhbHNlKSB7XG4gIGlmIChib2R5Lmxlbmd0aCA9PT0gMSAmJiAhKGJvZHlbMF0gaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSkge1xuICAgIHJldHVybiBib2R5WzBdO1xuICB9IGVsc2UgaWYgKCFzZW1pc2ltcGxlKSB7XG4gICAgLy8gU3VwcHJlc3Mgc3BhY2luZyBvbiA8bW8+IG5vZGVzIGF0IGJvdGggZW5kcyBvZiB0aGUgcm93LlxuICAgIGlmIChib2R5WzBdIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgYm9keVswXS50eXBlID09PSBcIm1vXCIgJiYgIWJvZHlbMF0uYXR0cmlidXRlcy5mZW5jZSkge1xuICAgICAgYm9keVswXS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBib2R5WzBdLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICB9XG4gICAgY29uc3QgZW5kID0gYm9keS5sZW5ndGggLSAxO1xuICAgIGlmIChib2R5W2VuZF0gaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBib2R5W2VuZF0udHlwZSA9PT0gXCJtb1wiICYmICFib2R5W2VuZF0uYXR0cmlidXRlcy5mZW5jZSkge1xuICAgICAgYm9keVtlbmRdLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgIGJvZHlbZW5kXS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMGVtXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYm9keSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGZvciA8bWk+LjwvbWk+IHdoaWNoIGlzIGhvdyBhIGRvdCByZW5kZXJzIGluIE1hdGhNTCxcbiAqIG9yIDxtbyBzZXBhcmF0b3I9XCJ0cnVlXCIgbHNwYWNlPVwiMGVtXCIgcnNwYWNlPVwiMGVtXCI+LDwvbW8+XG4gKiB3aGljaCBpcyBob3cgYSBicmFjZWQgY29tbWEgeyx9IHJlbmRlcnMgaW4gTWF0aE1MXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyUHVuY3R1YXRpb24oZ3JvdXApIHtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChncm91cC50eXBlID09PSAnbWknICYmIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJy4nXG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJtdGV4dFwiICYmIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJ1xcdTIwMDgnIC8vIHB1bmN0dWF0aW9uIHNwYWNlXG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gJ21vJyAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICBncm91cC5nZXRBdHRyaWJ1dGUoJ3NlcGFyYXRvcicpID09PSAndHJ1ZScgJiZcbiAgICBncm91cC5nZXRBdHRyaWJ1dGUoJ2xzcGFjZScpID09PSAnMGVtJyAmJlxuICAgIGdyb3VwLmdldEF0dHJpYnV0ZSgncnNwYWNlJykgPT09ICcwZW0nKSB7XG4gICAgY29uc3QgY2hpbGQgPSBncm91cC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBjaGlsZC50ZXh0ID09PSAnLCdcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuY29uc3QgaXNDb21tYSA9IChleHByZXNzaW9uLCBpKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBleHByZXNzaW9uW2ldO1xuICBjb25zdCBmb2xsb3dpbmdOb2RlID0gZXhwcmVzc2lvbltpICsgMV07XG4gIHJldHVybiAobm9kZS50eXBlID09PSBcImF0b21cIiAmJiBub2RlLnRleHQgPT09IFwiLFwiKSAmJlxuICAgIC8vIERvbid0IGNvbnNvbGlkYXRlIGlmIHRoZXJlIGlzIGEgc3BhY2UgYWZ0ZXIgdGhlIGNvbW1hLlxuICAgIG5vZGUubG9jICYmIGZvbGxvd2luZ05vZGUubG9jICYmIG5vZGUubG9jLmVuZCA9PT0gZm9sbG93aW5nTm9kZS5sb2Muc3RhcnRcbn07XG5cbmNvbnN0IGlzUmVsID0gaXRlbSA9PiB7XG4gIHJldHVybiAoaXRlbS50eXBlID09PSBcImF0b21cIiAmJiBpdGVtLmZhbWlseSA9PT0gXCJyZWxcIikgfHxcbiAgICAgIChpdGVtLnR5cGUgPT09IFwibWNsYXNzXCIgJiYgaXRlbS5tY2xhc3MgPT09IFwibXJlbFwiKVxufTtcblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2Ygbm9kZXMsIGJ1aWxkcyB0aGVtLCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdGhlIGdlbmVyYXRlZFxuICogTWF0aE1MIG5vZGVzLiAgQWxzbyBkbyBhIGNvdXBsZSBjaG9yZXMgYWxvbmcgdGhlIHdheTpcbiAqICgxKSBTdXBwcmVzcyBzcGFjaW5nIHdoZW4gYW4gYXV0aG9yIHdyYXBzIGFuIG9wZXJhdG9yIHcvYnJhY2VzLCBhcyBpbiB7PX0uXG4gKiAoMikgU3VwcHJlc3Mgc3BhY2luZyBiZXR3ZWVuIHR3byBhZGphY2VudCByZWxhdGlvbnMuXG4gKi9cbmNvbnN0IGJ1aWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHN0eWxlLCBzZW1pc2ltcGxlID0gZmFsc2UpIHtcbiAgaWYgKCFzZW1pc2ltcGxlICYmIGV4cHJlc3Npb24ubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBidWlsZEdyb3VwJDEoZXhwcmVzc2lvblswXSwgc3R5bGUpO1xuICAgIGlmIChncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGdyb3VwLnR5cGUgPT09IFwibW9cIikge1xuICAgICAgLy8gV2hlbiBUZVggd3JpdGVycyB3YW50IHRvIHN1cHByZXNzIHNwYWNpbmcgb24gYW4gb3BlcmF0b3IsXG4gICAgICAvLyB0aGV5IG9mdGVuIHB1dCB0aGUgb3BlcmF0b3IgYnkgaXRzZWxmIGluc2lkZSBicmFjZXMuXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuICAgIHJldHVybiBbZ3JvdXBdO1xuICB9XG5cbiAgY29uc3QgZ3JvdXBzID0gW107XG4gIGNvbnN0IGdyb3VwQXJyYXkgPSBbXTtcbiAgbGV0IGxhc3RHcm91cDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgZ3JvdXBBcnJheS5wdXNoKGJ1aWxkR3JvdXAkMShleHByZXNzaW9uW2ldLCBzdHlsZSkpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBncm91cEFycmF5W2ldO1xuXG4gICAgLy8gU3VwcHJlc3Mgc3BhY2luZyBiZXR3ZWVuIGFkamFjZW50IHJlbGF0aW9uc1xuICAgIGlmIChpIDwgZXhwcmVzc2lvbi5sZW5ndGggLSAxICYmIGlzUmVsKGV4cHJlc3Npb25baV0pICYmIGlzUmVsKGV4cHJlc3Npb25baSArIDFdKSkge1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMGVtXCIpO1xuICAgIH1cbiAgICBpZiAoaSA+IDAgJiYgaXNSZWwoZXhwcmVzc2lvbltpXSkgJiYgaXNSZWwoZXhwcmVzc2lvbltpIC0gMV0pKSB7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuXG4gICAgLy8gQ29uY2F0ZW5hdGUgbnVtYmVyc1xuICAgIGlmIChncm91cC50eXBlID09PSAnbW4nICYmIGxhc3RHcm91cCAmJiBsYXN0R3JvdXAudHlwZSA9PT0gJ21uJykge1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgPG1uPi4uLjwvbW4+IGZvbGxvd2VkIGJ5IDxtaT4uPC9taT5cbiAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLmdyb3VwLmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChpc051bWJlclB1bmN0dWF0aW9uKGdyb3VwKSAmJiBsYXN0R3JvdXAgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgIC8vIENvbmNhdGVuYXRlIDxtbj4uLi48L21uPiBmb2xsb3dlZCBieSA8bWk+LjwvbWk+XG4gICAgICBsYXN0R3JvdXAuY2hpbGRyZW4ucHVzaCguLi5ncm91cC5jaGlsZHJlbik7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAobGFzdEdyb3VwICYmIGxhc3RHcm91cC50eXBlID09PSBcIm1uXCIgJiYgaSA8IGdyb3VwQXJyYXkubGVuZ3RoIC0gMSAmJlxuICAgICAgZ3JvdXBBcnJheVtpICsgMV0udHlwZSA9PT0gXCJtblwiICYmIGlzQ29tbWEoZXhwcmVzc2lvbiwgaSkpIHtcbiAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLmdyb3VwLmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSAnbW4nICYmIGlzTnVtYmVyUHVuY3R1YXRpb24obGFzdEdyb3VwKSkge1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgPG1pPi48L21pPiBmb2xsb3dlZCBieSA8bW4+Li4uPC9tbj5cbiAgICAgIGdyb3VwLmNoaWxkcmVuID0gWy4uLmxhc3RHcm91cC5jaGlsZHJlbiwgLi4uZ3JvdXAuY2hpbGRyZW5dO1xuICAgICAgZ3JvdXBzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoKGdyb3VwLnR5cGUgPT09ICdtc3VwJyB8fCBncm91cC50eXBlID09PSAnbXN1YicpICYmXG4gICAgICAgIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA+PSAxICYmIGxhc3RHcm91cCAmJlxuICAgICAgICAobGFzdEdyb3VwLnR5cGUgPT09ICdtbicgfHwgaXNOdW1iZXJQdW5jdHVhdGlvbihsYXN0R3JvdXApKSkge1xuICAgICAgLy8gUHV0IHByZWNlZGluZyA8bW4+Li4uPC9tbj4gb3IgPG1pPi48L21pPiBpbnNpZGUgYmFzZSBvZlxuICAgICAgLy8gPG1zdXA+PG1uPi4uLmJhc2UuLi48L21uPi4uLmV4cG9uZW50Li4uPC9tc3VwPiAob3IgPG1zdWI+KVxuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBiYXNlLnR5cGUgPT09ICdtbicgJiYgbGFzdEdyb3VwKSB7XG4gICAgICAgIGJhc2UuY2hpbGRyZW4gPSBbLi4ubGFzdEdyb3VwLmNoaWxkcmVuLCAuLi5iYXNlLmNoaWxkcmVuXTtcbiAgICAgICAgZ3JvdXBzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgbGFzdEdyb3VwID0gZ3JvdXA7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwc1xufTtcblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGJ1aWxkRXhwcmVzc2lvbiwgYnV0IHdyYXBzIHRoZSBlbGVtZW50cyBpbiBhbiA8bXJvdz5cbiAqIGlmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZS4gIFJldHVybnMgYSBzaW5nbGUgbm9kZSBpbnN0ZWFkIG9mIGFuIGFycmF5LlxuICovXG5jb25zdCBidWlsZEV4cHJlc3Npb25Sb3cgPSBmdW5jdGlvbihleHByZXNzaW9uLCBzdHlsZSwgc2VtaXNpbXBsZSA9IGZhbHNlKSB7XG4gIHJldHVybiBtYWtlUm93KGJ1aWxkRXhwcmVzc2lvbihleHByZXNzaW9uLCBzdHlsZSwgc2VtaXNpbXBsZSksIHNlbWlzaW1wbGUpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGdyb3VwIGZyb20gdGhlIHBhcnNlciBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAqIG9uIGl0IHRvIHByb2R1Y2UgYSBNYXRoTUwgbm9kZS5cbiAqL1xuY29uc3QgYnVpbGRHcm91cCQxID0gZnVuY3Rpb24oZ3JvdXAsIHN0eWxlKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG5cbiAgaWYgKF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7XG4gICAgLy8gQ2FsbCB0aGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICAgIGNvbnN0IHJlc3VsdCA9IF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKGdyb3VwLCBzdHlsZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkdvdCBncm91cCBvZiB1bmtub3duIHR5cGU6ICdcIiArIGdyb3VwLnR5cGUgKyBcIidcIik7XG4gIH1cbn07XG5cbmNvbnN0IGdsdWUkMSA9IF8gPT4ge1xuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10sIFtdLCB7IHBhZGRpbmc6IFwiMFwiLCB3aWR0aDogXCI1MCVcIiB9KVxufTtcblxuY29uc3QgbGFiZWxDb250YWluZXJzID0gW1wibXJvd1wiLCBcIm10ZFwiLCBcIm10YWJsZVwiLCBcIm10clwiXTtcbmNvbnN0IGdldExhYmVsID0gcGFyZW50ID0+IHtcbiAgZm9yIChjb25zdCBub2RlIG9mIHBhcmVudC5jaGlsZHJlbikge1xuICAgIGlmIChub2RlLnR5cGUgJiYgbGFiZWxDb250YWluZXJzLmluY2x1ZGVzKG5vZGUudHlwZSkpIHtcbiAgICAgIGlmIChub2RlLmNsYXNzZXMgJiYgbm9kZS5jbGFzc2VzWzBdID09PSBcInRtbC1sYWJlbFwiKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gbm9kZS5sYWJlbDtcbiAgICAgICAgcmV0dXJuIGxhYmVsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGdldExhYmVsKG5vZGUpO1xuICAgICAgICBpZiAobGFiZWwpIHsgcmV0dXJuIGxhYmVsIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFub2RlLnR5cGUpIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZ2V0TGFiZWwobm9kZSk7XG4gICAgICBpZiAobGFiZWwpIHsgcmV0dXJuIGxhYmVsIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHRhZ2dlZEV4cHJlc3Npb24gPSAoZXhwcmVzc2lvbiwgdGFnLCBzdHlsZSwgbGVxbm8pID0+IHtcbiAgdGFnID0gYnVpbGRFeHByZXNzaW9uUm93KHRhZ1swXS5ib2R5LCBzdHlsZSk7XG4gIHRhZyA9IGNvbnNvbGlkYXRlVGV4dCh0YWcpO1xuICB0YWcuY2xhc3Nlcy5wdXNoKFwidG1sLXRhZ1wiKTtcblxuICBjb25zdCBsYWJlbCA9IGdldExhYmVsKGV4cHJlc3Npb24pOyAvLyBmcm9tIGEgXFxsYWJlbHt9IGZ1bmN0aW9uLlxuICBleHByZXNzaW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2V4cHJlc3Npb25dKTtcbiAgY29uc3Qgcm93QXJyYXkgPSBbZ2x1ZSQxKCksIGV4cHJlc3Npb24sIGdsdWUkMSgpXTtcbiAgcm93QXJyYXlbbGVxbm8gPyAwIDogMl0uY2xhc3Nlcy5wdXNoKGxlcW5vID8gXCJ0bWwtbGVmdFwiIDogXCJ0bWwtcmlnaHRcIik7XG4gIHJvd0FycmF5W2xlcW5vID8gMCA6IDJdLmNoaWxkcmVuLnB1c2godGFnKTtcbiAgY29uc3QgbXRyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgcm93QXJyYXksIFtcInRtbC10YWdlcW5cIl0pO1xuICBpZiAobGFiZWwpIHsgbXRyLnNldEF0dHJpYnV0ZShcImlkXCIsIGxhYmVsKTsgfVxuICBjb25zdCB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFttdHJdKTtcbiAgdGFibGUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgdGFibGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHRhYmxlXG59O1xuXG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRNYXRoTUwodHJlZSwgdGV4RXhwcmVzc2lvbiwgc3R5bGUsIHNldHRpbmdzKSB7XG4gIC8vIFN0cmlwIG9mZiBvdXRlciB0YWcgd3JhcHBlciBmb3IgcHJvY2Vzc2luZyBiZWxvdy5cbiAgbGV0IHRhZyA9IG51bGw7XG4gIGlmICh0cmVlLmxlbmd0aCA9PT0gMSAmJiB0cmVlWzBdLnR5cGUgPT09IFwidGFnXCIpIHtcbiAgICB0YWcgPSB0cmVlWzBdLnRhZztcbiAgICB0cmVlID0gdHJlZVswXS5ib2R5O1xuICB9XG5cbiAgY29uc3QgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbih0cmVlLCBzdHlsZSk7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxICYmIGV4cHJlc3Npb25bMF0gaW5zdGFuY2VvZiBBbmNob3JOb2RlKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25bMF1cbiAgfVxuXG4gIGNvbnN0IHdyYXAgPSAoc2V0dGluZ3MuZGlzcGxheU1vZGUgfHwgc2V0dGluZ3MuYW5ub3RhdGUpID8gXCJub25lXCIgOiBzZXR0aW5ncy53cmFwO1xuXG4gIGNvbnN0IG4xID0gZXhwcmVzc2lvbi5sZW5ndGggPT09IDAgPyBudWxsIDogZXhwcmVzc2lvblswXTtcbiAgbGV0IHdyYXBwZXIgPSBleHByZXNzaW9uLmxlbmd0aCA9PT0gMSAmJiB0YWcgPT09IG51bGwgJiYgKG4xIGluc3RhbmNlb2YgTWF0aE5vZGUpXG4gICAgICA/IGV4cHJlc3Npb25bMF1cbiAgICAgIDogc2V0TGluZUJyZWFrcyhleHByZXNzaW9uLCB3cmFwLCBzZXR0aW5ncy5kaXNwbGF5TW9kZSk7XG5cbiAgaWYgKHRhZykge1xuICAgIHdyYXBwZXIgPSB0YWdnZWRFeHByZXNzaW9uKHdyYXBwZXIsIHRhZywgc3R5bGUsIHNldHRpbmdzLmxlcW5vKTtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5hbm5vdGF0ZSkge1xuICAgIC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuICAgIGNvbnN0IGFubm90YXRpb24gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgIFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcbiAgICBhbm5vdGF0aW9uLnNldEF0dHJpYnV0ZShcImVuY29kaW5nXCIsIFwiYXBwbGljYXRpb24veC10ZXhcIik7XG4gICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwic2VtYW50aWNzXCIsIFt3cmFwcGVyLCBhbm5vdGF0aW9uXSk7XG4gIH1cblxuICBjb25zdCBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFt3cmFwcGVyXSk7XG5cbiAgaWYgKHNldHRpbmdzLnhtbCkge1xuICAgIG1hdGguc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIpO1xuICB9XG4gIGlmICh3cmFwcGVyLnN0eWxlLndpZHRoKSB7XG4gICAgbWF0aC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICB9XG4gIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgIG1hdGguc2V0QXR0cmlidXRlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgIG1hdGguc3R5bGUuZGlzcGxheSA9IFwiYmxvY2sgbWF0aFwiOyAvLyBuZWNlc3NhcnkgaW4gQ2hyb21pdW0uXG4gICAgLy8gRmlyZWZveCBhbmQgU2FmYXJpIGRvIG5vdCByZWNvZ25pemUgZGlzcGxheTogXCJibG9jayBtYXRoXCIuXG4gICAgLy8gU2V0IGEgY2xhc3Mgc28gdGhhdCB0aGUgQ1NTIGZpbGUgY2FuIHNldCBkaXNwbGF5OiBibG9jay5cbiAgICBtYXRoLmNsYXNzZXMgPSBbXCJ0bWwtZGlzcGxheVwiXTtcbiAgfVxuICByZXR1cm4gbWF0aDtcbn1cblxuY29uc3Qgc21hbGxzID0gXCJhY2VnxLHIt21ub3BxcnN1dnd4eXrOsc6zzrXOt865zrrOvM69zr/PgM+Bz4LPg8+Ez4XPh8+Jz5XwnZCa8J2QnPCdkJ7wnZCg8J2QpvCdkKfwnZCo8J2QqfCdkKrwnZCr8J2QrPCdkK7wnZCv8J2QsPCdkLHwnZCy8J2Qs1wiO1xuY29uc3QgdGFsbHMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYmRmaGtsdM6RzpLOk86UzpXOls6XzpjOmc6azpvOnM6dzp7On86gzqHOo86kzqXOps6nzqjOqc6yzrTOu862z4bOuM+IXCJcbiAgICAgICAgICAgICArIFwi8J2QgPCdkIHwnZCC8J2Qg/CdkITwnZCF8J2QhvCdkIfwnZCI8J2QifCdkIrwnZCL8J2QjPCdkI3wnZCO8J2Qj/CdkJDwnZCR8J2QkvCdkJPwnZCU8J2QlfCdkJbwnZCX8J2QmPCdkJnwnZCb8J2QnfCdkJ/wnZCh8J2QpPCdkKXwnZCtXCI7XG5jb25zdCBsb25nU21hbGxzID0gbmV3IFNldChbXCJcXFxcYWxwaGFcIiwgXCJcXFxcZ2FtbWFcIiwgXCJcXFxcZGVsdGFcIiwgXCJcXFxcZXBzaWxvblwiLCBcIlxcXFxldGFcIiwgXCJcXFxcaW90YVwiLFxuICBcIlxcXFxrYXBwYVwiLCBcIlxcXFxtdVwiLCBcIlxcXFxudVwiLCBcIlxcXFxwaVwiLCBcIlxcXFxyaG9cIiwgXCJcXFxcc2lnbWFcIiwgXCJcXFxcdGF1XCIsIFwiXFxcXHVwc2lsb25cIiwgXCJcXFxcY2hpXCIsIFwiXFxcXHBzaVwiLFxuICBcIlxcXFxvbWVnYVwiLCBcIlxcXFxpbWF0aFwiLCBcIlxcXFxqbWF0aFwiXSk7XG5jb25zdCBsb25nVGFsbHMgPSBuZXcgU2V0KFtcIlxcXFxHYW1tYVwiLCBcIlxcXFxEZWx0YVwiLCBcIlxcXFxTaWdtYVwiLCBcIlxcXFxPbWVnYVwiLCBcIlxcXFxiZXRhXCIsIFwiXFxcXGRlbHRhXCIsXG4gIFwiXFxcXGxhbWJkYVwiLCBcIlxcXFx0aGV0YVwiLCBcIlxcXFxwc2lcIl0pO1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJGEgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGFjY2VudE5vZGUgPSBncm91cC5pc1N0cmV0Y2h5XG4gICAgPyBzdHJldGNoeS5hY2NlbnROb2RlKGdyb3VwKVxuICAgIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAubGFiZWwsIGdyb3VwLm1vZGUpXSk7XG5cbiAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFx2ZWNcIikge1xuICAgIGFjY2VudE5vZGUuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZSgwLjc1KSB0cmFuc2xhdGUoMTAlLCAzMCUpXCI7XG4gIH0gZWxzZSB7XG4gICAgYWNjZW50Tm9kZS5zdHlsZS5tYXRoU3R5bGUgPSBcIm5vcm1hbFwiO1xuICAgIGFjY2VudE5vZGUuc3R5bGUubWF0aERlcHRoID0gXCIwXCI7XG4gICAgaWYgKG5lZWRXZWJraXRTaGlmdC5oYXMoZ3JvdXAubGFiZWwpICYmICB1dGlscy5pc0NoYXJhY3RlckJveChncm91cC5iYXNlKSkge1xuICAgICAgbGV0IHNoaWZ0ID0gXCJcIjtcbiAgICAgIGNvbnN0IGNoID0gZ3JvdXAuYmFzZS50ZXh0O1xuICAgICAgaWYgKHNtYWxscy5pbmRleE9mKGNoKSA+IC0xIHx8IGxvbmdTbWFsbHMuaGFzKGNoKSkgeyBzaGlmdCA9IFwidG1sLXhzaGlmdFwiOyB9XG4gICAgICBpZiAodGFsbHMuaW5kZXhPZihjaCkgPiAtMSAgfHwgbG9uZ1RhbGxzLmhhcyhjaCkpICB7IHNoaWZ0ID0gXCJ0bWwtY2Fwc2hpZnRcIjsgfVxuICAgICAgaWYgKHNoaWZ0KSB7IGFjY2VudE5vZGUuY2xhc3Nlcy5wdXNoKHNoaWZ0KTsgfVxuICAgIH1cbiAgfVxuICBpZiAoIWdyb3VwLmlzU3RyZXRjaHkpIHtcbiAgICBhY2NlbnROb2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gIH1cblxuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoKGdyb3VwLmxhYmVsID09PSBcIlxcXFxjXCIgPyBcIm11bmRlclwiIDogXCJtb3ZlclwiKSxcbiAgICBbYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UsIHN0eWxlKSwgYWNjZW50Tm9kZV1cbiAgKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IG5vblN0cmV0Y2h5QWNjZW50cyA9IG5ldyBTZXQoW1xuICBcIlxcXFxhY3V0ZVwiLFxuICBcIlxcXFxncmF2ZVwiLFxuICBcIlxcXFxkZG90XCIsXG4gIFwiXFxcXGRkZG90XCIsXG4gIFwiXFxcXGRkZGRvdFwiLFxuICBcIlxcXFx0aWxkZVwiLFxuICBcIlxcXFxiYXJcIixcbiAgXCJcXFxcYnJldmVcIixcbiAgXCJcXFxcY2hlY2tcIixcbiAgXCJcXFxcaGF0XCIsXG4gIFwiXFxcXHZlY1wiLFxuICBcIlxcXFxkb3RcIixcbiAgXCJcXFxcbWF0aHJpbmdcIlxuXSk7XG5cbmNvbnN0IG5lZWRXZWJraXRTaGlmdCA9IG5ldyBTZXQoW1xuICBcIlxcXFxhY3V0ZVwiLFxuICBcIlxcXFxiYXJcIixcbiAgXCJcXFxcYnJldmVcIixcbiAgXCJcXFxcY2hlY2tcIixcbiAgXCJcXFxcZG90XCIsXG4gIFwiXFxcXGRkb3RcIixcbiAgXCJcXFxcZ3JhdmVcIixcbiAgXCJcXFxcaGF0XCIsXG4gIFwiXFxcXG1hdGhyaW5nXCIsXG4gIFwiXFxcXCdcIiwgXCJcXFxcXlwiLCBcIlxcXFx+XCIsIFwiXFxcXD1cIiwgXCJcXFxcdVwiLCBcIlxcXFwuXCIsICdcXFxcXCInLCBcIlxcXFxyXCIsIFwiXFxcXEhcIiwgXCJcXFxcdlwiXG5dKTtcblxuY29uc3QgY29tYmluaW5nQ2hhciA9IHtcbiAgXCJcXFxcYFwiOiBcIlxcdTAzMDBcIixcbiAgXCJcXFxcJ1wiOiBcIlxcdTAzMDFcIixcbiAgXCJcXFxcXlwiOiBcIlxcdTAzMDJcIixcbiAgXCJcXFxcflwiOiBcIlxcdTAzMDNcIixcbiAgXCJcXFxcPVwiOiBcIlxcdTAzMDRcIixcbiAgXCJcXFxcdVwiOiBcIlxcdTAzMDZcIixcbiAgXCJcXFxcLlwiOiBcIlxcdTAzMDdcIixcbiAgJ1xcXFxcIic6IFwiXFx1MDMwOFwiLFxuICBcIlxcXFxyXCI6IFwiXFx1MDMwQVwiLFxuICBcIlxcXFxIXCI6IFwiXFx1MDMwQlwiLFxuICBcIlxcXFx2XCI6IFwiXFx1MDMwQ1wiXG59O1xuXG4vLyBBY2NlbnRzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcYWN1dGVcIixcbiAgICBcIlxcXFxncmF2ZVwiLFxuICAgIFwiXFxcXGRkb3RcIixcbiAgICBcIlxcXFxkZGRvdFwiLFxuICAgIFwiXFxcXGRkZGRvdFwiLFxuICAgIFwiXFxcXHRpbGRlXCIsXG4gICAgXCJcXFxcYmFyXCIsXG4gICAgXCJcXFxcYnJldmVcIixcbiAgICBcIlxcXFxjaGVja1wiLFxuICAgIFwiXFxcXGhhdFwiLFxuICAgIFwiXFxcXHZlY1wiLFxuICAgIFwiXFxcXGRvdFwiLFxuICAgIFwiXFxcXG1hdGhyaW5nXCIsXG4gICAgXCJcXFxcb3ZlcnBhcmVuXCIsXG4gICAgXCJcXFxcd2lkZWNoZWNrXCIsXG4gICAgXCJcXFxcd2lkZWhhdFwiLFxuICAgIFwiXFxcXHdpZGVwYXJlblwiLFxuICAgIFwiXFxcXHdpZGV0aWxkZVwiLFxuICAgIFwiXFxcXG92ZXJyaWdodGFycm93XCIsXG4gICAgXCJcXFxcb3ZlcmxlZnRhcnJvd1wiLFxuICAgIFwiXFxcXE92ZXJyaWdodGFycm93XCIsXG4gICAgXCJcXFxcb3ZlcmxlZnRyaWdodGFycm93XCIsXG4gICAgXCJcXFxcb3Zlcmdyb3VwXCIsXG4gICAgXCJcXFxcb3ZlcmxlZnRoYXJwb29uXCIsXG4gICAgXCJcXFxcb3ZlcnJpZ2h0aGFycG9vblwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcblxuICAgIGNvbnN0IGlzU3RyZXRjaHkgPSAhbm9uU3RyZXRjaHlBY2NlbnRzLmhhcyhjb250ZXh0LmZ1bmNOYW1lKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBjb250ZXh0LmZ1bmNOYW1lLFxuICAgICAgaXNTdHJldGNoeTogaXNTdHJldGNoeSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJGFcbn0pO1xuXG4vLyBUZXh0LW1vZGUgYWNjZW50c1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFwiLFxuICBuYW1lczogW1wiXFxcXCdcIiwgXCJcXFxcYFwiLCBcIlxcXFxeXCIsIFwiXFxcXH5cIiwgXCJcXFxcPVwiLCBcIlxcXFxjXCIsIFwiXFxcXHVcIiwgXCJcXFxcLlwiLCAnXFxcXFwiJywgXCJcXFxcclwiLCBcIlxcXFxIXCIsIFwiXFxcXHZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcbiAgICBjb25zdCBtb2RlID0gY29udGV4dC5wYXJzZXIubW9kZTtcblxuICAgIGlmIChtb2RlID09PSBcIm1hdGhcIiAmJiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIC8vIExhVGVYIG9ubHkgd3JpdGVzIGEgd2FybmluZy4gSXQgZG9lc24ndCBzdG9wLiBXZSdsbCBpc3N1ZSB0aGUgc2FtZSB3YXJuaW5nLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKGBUZW1tbCBwYXJzZSBlcnJvcjogQ29tbWFuZCAke2NvbnRleHQuZnVuY05hbWV9IGlzIGludmFsaWQgaW4gbWF0aCBtb2RlLmApO1xuICAgIH1cblxuICAgIGlmIChtb2RlID09PSBcInRleHRcIiAmJiBiYXNlLnRleHQgJiYgYmFzZS50ZXh0Lmxlbmd0aCA9PT0gMVxuICAgICAgICAmJiBjb250ZXh0LmZ1bmNOYW1lIGluIGNvbWJpbmluZ0NoYXIgICYmIHNtYWxscy5pbmRleE9mKGJhc2UudGV4dCkgPiAtMSkge1xuICAgICAgLy8gUmV0dXJuIGEgY29tYmluaW5nIGFjY2VudCBjaGFyYWN0ZXJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogYmFzZS50ZXh0ICsgY29tYmluaW5nQ2hhcltjb250ZXh0LmZ1bmNOYW1lXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCdWlsZCB1cCB0aGUgYWNjZW50XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgICAgaXNTdHJldGNoeTogZmFsc2UsXG4gICAgICAgIGJhc2U6IGJhc2VcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkYVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJhY2NlbnRVbmRlclwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXHVuZGVybGVmdGFycm93XCIsXG4gICAgXCJcXFxcdW5kZXJyaWdodGFycm93XCIsXG4gICAgXCJcXFxcdW5kZXJsZWZ0cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHVuZGVyZ3JvdXBcIixcbiAgICBcIlxcXFx1bmRlcnBhcmVuXCIsXG4gICAgXCJcXFxcdXRpbGRlXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5LmFjY2VudE5vZGUoZ3JvdXApO1xuICAgIGFjY2VudE5vZGUuc3R5bGVbXCJtYXRoLWRlcHRoXCJdID0gMDtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW1xuICAgICAgYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UsIHN0eWxlKSxcbiAgICAgIGFjY2VudE5vZGVcbiAgICBdKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgY29udmVyc2lvbiBiZXR3ZWVuIHVuaXRzLiAgSW4gcGFydGljdWxhciwgaXQgcHJvdmlkZXNcbiAqIGNhbGN1bGF0ZVNpemUgdG8gY29udmVydCBvdGhlciB1bml0cyBpbnRvIENTUyB1bml0cy5cbiAqL1xuXG5cbmNvbnN0IHB0UGVyVW5pdCA9IHtcbiAgLy8gQ29udmVydCB0byBDU1MgKFBvc3RzY2lwdCkgcG9pbnRzLCBub3QgVGVYIHBvaW50c1xuICAvLyBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9MYVRlWC9MZW5ndGhzIGFuZFxuICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzgyNjNcbiAgcHQ6IDgwMCAvIDgwMywgLy8gY29udmVydCBUZVggcG9pbnQgdG8gQ1NTIChQb3N0c2NyaXB0KSBwb2ludFxuICBwYzogKDEyICogODAwKSAvIDgwMywgLy8gcGljYVxuICBkZDogKCgxMjM4IC8gMTE1NykgKiA4MDApIC8gODAzLCAvLyBkaWRvdFxuICBjYzogKCgxNDg1NiAvIDExNTcpICogODAwKSAvIDgwMywgLy8gY2ljZXJvICgxMiBkaWRvdClcbiAgbmQ6ICgoNjg1IC8gNjQyKSAqIDgwMCkgLyA4MDMsIC8vIG5ldyBkaWRvdFxuICBuYzogKCgxMzcwIC8gMTA3KSAqIDgwMCkgLyA4MDMsIC8vIG5ldyBjaWNlcm8gKDEyIG5ldyBkaWRvdClcbiAgc3A6ICgoMSAvIDY1NTM2KSAqIDgwMCkgLyA4MDMsIC8vIHNjYWxlZCBwb2ludCAoVGVYJ3MgaW50ZXJuYWwgc21hbGxlc3QgdW5pdClcbiAgbW06ICgyNS40IC8gNzIpLFxuICBjbTogKDIuNTQgLyA3MiksXG4gIGluOiAoMSAvIDcyKSxcbiAgcHg6ICg5NiAvIDcyKVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3BlY2lmaWVkIHVuaXQgKGVpdGhlciBhIHN0cmluZyBkZWZpbmluZyB0aGUgdW5pdFxuICogb3IgYSBcInNpemVcIiBwYXJzZSBub2RlIGNvbnRhaW5pbmcgYSB1bml0IGZpZWxkKSBpcyB2YWxpZC5cbiAqL1xuY29uc3QgdmFsaWRVbml0cyA9IFtcbiAgXCJlbVwiLFxuICBcImV4XCIsXG4gIFwibXVcIixcbiAgXCJwdFwiLFxuICBcIm1tXCIsXG4gIFwiY21cIixcbiAgXCJpblwiLFxuICBcInB4XCIsXG4gIFwiYnBcIixcbiAgXCJwY1wiLFxuICBcImRkXCIsXG4gIFwiY2NcIixcbiAgXCJuZFwiLFxuICBcIm5jXCIsXG4gIFwic3BcIlxuXTtcblxuY29uc3QgdmFsaWRVbml0ID0gZnVuY3Rpb24odW5pdCkge1xuICBpZiAodHlwZW9mIHVuaXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bml0ID0gdW5pdC51bml0O1xuICB9XG4gIHJldHVybiB2YWxpZFVuaXRzLmluZGV4T2YodW5pdCkgPiAtMVxufTtcblxuY29uc3QgZW1TY2FsZSA9IHN0eWxlTGV2ZWwgPT4ge1xuICBjb25zdCBzY3JpcHRMZXZlbCA9IE1hdGgubWF4KHN0eWxlTGV2ZWwgLSAxLCAwKTtcbiAgcmV0dXJuIFsxLCAwLjcsIDAuNV1bc2NyaXB0TGV2ZWxdXG59O1xuXG4vKlxuICogQ29udmVydCBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgKHdpdGggbnVtZXJpYyBcIm51bWJlclwiIGFuZCBzdHJpbmcgXCJ1bml0XCIgZmllbGRzLFxuICogYXMgcGFyc2VkIGJ5IGZ1bmN0aW9ucy5qcyBhcmdUeXBlIFwic2l6ZVwiKSBpbnRvIGEgQ1NTIHZhbHVlLlxuICovXG5jb25zdCBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24oc2l6ZVZhbHVlLCBzdHlsZSkge1xuICBsZXQgbnVtYmVyID0gc2l6ZVZhbHVlLm51bWJlcjtcbiAgaWYgKHN0eWxlLm1heFNpemVbMF0gPCAwICYmIG51bWJlciA+IDApIHtcbiAgICByZXR1cm4geyBudW1iZXI6IDAsIHVuaXQ6IFwiZW1cIiB9XG4gIH1cbiAgY29uc3QgdW5pdCA9IHNpemVWYWx1ZS51bml0O1xuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlIFwibW1cIjpcbiAgICBjYXNlIFwiY21cIjpcbiAgICBjYXNlIFwiaW5cIjpcbiAgICBjYXNlIFwicHhcIjoge1xuICAgICAgY29uc3QgbnVtSW5Dc3NQdHMgPSBudW1iZXIgKiBwdFBlclVuaXRbdW5pdF07XG4gICAgICBpZiAobnVtSW5Dc3NQdHMgPiBzdHlsZS5tYXhTaXplWzFdKSB7XG4gICAgICAgIHJldHVybiB7IG51bWJlcjogc3R5bGUubWF4U2l6ZVsxXSwgdW5pdDogXCJwdFwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG51bWJlciwgdW5pdCB9OyAvLyBhYnNvbHV0ZSBDU1MgdW5pdHMuXG4gICAgfVxuICAgIGNhc2UgXCJlbVwiOlxuICAgIGNhc2UgXCJleFwiOiB7XG4gICAgICAvLyBJbiBUZVgsIGVtIGFuZCBleCBkbyBub3QgY2hhbmdlIHNpemUgaW4gXFxzY3JpcHRzdHlsZS5cbiAgICAgIGlmICh1bml0ID09PSBcImV4XCIpIHsgbnVtYmVyICo9IDAuNDMxOyB9XG4gICAgICBudW1iZXIgPSBNYXRoLm1pbihudW1iZXIgLyBlbVNjYWxlKHN0eWxlLmxldmVsKSwgc3R5bGUubWF4U2l6ZVswXSk7XG4gICAgICByZXR1cm4geyBudW1iZXI6IHV0aWxzLnJvdW5kKG51bWJlciksIHVuaXQ6IFwiZW1cIiB9O1xuICAgIH1cbiAgICBjYXNlIFwiYnBcIjoge1xuICAgICAgaWYgKG51bWJlciA+IHN0eWxlLm1heFNpemVbMV0pIHsgbnVtYmVyID0gc3R5bGUubWF4U2l6ZVsxXTsgfVxuICAgICAgcmV0dXJuIHsgbnVtYmVyLCB1bml0OiBcInB0XCIgfTsgLy8gVGVYIGJwIGlzIGEgQ1NTIHB0LiAoMS83MiBpbmNoKS5cbiAgICB9XG4gICAgY2FzZSBcInB0XCI6XG4gICAgY2FzZSBcInBjXCI6XG4gICAgY2FzZSBcImRkXCI6XG4gICAgY2FzZSBcImNjXCI6XG4gICAgY2FzZSBcIm5kXCI6XG4gICAgY2FzZSBcIm5jXCI6XG4gICAgY2FzZSBcInNwXCI6IHtcbiAgICAgIG51bWJlciA9IE1hdGgubWluKG51bWJlciAqIHB0UGVyVW5pdFt1bml0XSwgc3R5bGUubWF4U2l6ZVsxXSk7XG4gICAgICByZXR1cm4geyBudW1iZXI6IHV0aWxzLnJvdW5kKG51bWJlciksIHVuaXQ6IFwicHRcIiB9XG4gICAgfVxuICAgIGNhc2UgXCJtdVwiOiB7XG4gICAgICBudW1iZXIgPSBNYXRoLm1pbihudW1iZXIgLyAxOCwgc3R5bGUubWF4U2l6ZVswXSk7XG4gICAgICByZXR1cm4geyBudW1iZXI6IHV0aWxzLnJvdW5kKG51bWJlciksIHVuaXQ6IFwiZW1cIiB9XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgdW5pdCArIFwiJ1wiKVxuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5cbmNvbnN0IHBhZGRpbmckMSA9IHdpZHRoID0+IHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoICsgXCJlbVwiKTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmNvbnN0IHBhZGRlZE5vZGUgPSAoZ3JvdXAsIGxzcGFjZSA9IDAuMywgcnNwYWNlID0gMCwgbXVzdFNtYXNoID0gZmFsc2UpID0+IHtcbiAgaWYgKGdyb3VwID09IG51bGwgJiYgcnNwYWNlID09PSAwKSB7IHJldHVybiBwYWRkaW5nJDEobHNwYWNlKSB9XG4gIGNvbnN0IHJvdyA9IGdyb3VwID8gW2dyb3VwXSA6IFtdO1xuICBpZiAobHNwYWNlICE9PSAwKSAgIHsgcm93LnVuc2hpZnQocGFkZGluZyQxKGxzcGFjZSkpOyB9XG4gIGlmIChyc3BhY2UgPiAwKSB7IHJvdy5wdXNoKHBhZGRpbmckMShyc3BhY2UpKTsgfVxuICBpZiAobXVzdFNtYXNoKSB7XG4gICAgLy8gVXNlZCBmb3IgdGhlIGJvdHRvbSBhcnJvdyBpbiBhIHtDRH0gZW52aXJvbm1lbnRcbiAgICBjb25zdCBtcGFkZGVkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIHJvdyk7XG4gICAgbXBhZGRlZC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwXCIpO1xuICAgIHJldHVybiBtcGFkZGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCByb3cpXG4gIH1cbn07XG5cbmNvbnN0IGxhYmVsU2l6ZSA9IChzaXplLCBzY3JpcHRMZXZlbCkgPT4gIE51bWJlcihzaXplKSAvIGVtU2NhbGUoc2NyaXB0TGV2ZWwpO1xuXG5jb25zdCBtdW5kZXJvdmVyTm9kZSA9IChmTmFtZSwgYm9keSwgYmVsb3csIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGFycm93Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZk5hbWUpO1xuICAvLyBJcyB0aGlzIHRoZSBzaG9ydCBwYXJ0IG9mIGEgbWhjaGVtIGVxdWlsaWJyaXVtIGFycm93P1xuICBjb25zdCBpc0VxID0gZk5hbWUuc2xpY2UoMSwgMykgPT09IFwiZXFcIjtcbiAgY29uc3QgbWluV2lkdGggPSBmTmFtZS5jaGFyQXQoMSkgPT09IFwieFwiXG4gICAgPyBcIjEuNzVcIiAgLy8gbWF0aHRvb2xzIGV4dGVuc2libGUgYXJyb3dzIGFyZSDiiaUgMS43NWVtIGxvbmdcbiAgICA6IGZOYW1lLnNsaWNlKDIsIDQpID09PSBcImNkXCJcbiAgICA/IFwiMy4wXCIgIC8vIGNkIHBhY2thZ2UgYXJyb3dzXG4gICAgOiBpc0VxXG4gICAgPyBcIjEuMFwiICAvLyBUaGUgc2hvcnRlciBoYXJwb29uIG9mIGEgbWhjaGVtIGVxdWlsaWJyaXVtIGFycm93XG4gICAgOiBcIjIuMFwiOyAvLyBvdGhlciBtaGNoZW0gYXJyb3dzXG4gIC8vIFRPRE86IFdoZW4gRmlyZWZveCBzdXBwb3J0cyBtaW5zaXplLCB1c2UgdGhlIG5leHQgbGluZS5cbiAgLy9hcnJvd05vZGUuc2V0QXR0cmlidXRlKFwibWluc2l6ZVwiLCBTdHJpbmcobWluV2lkdGgpICsgXCJlbVwiKVxuICBhcnJvd05vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMFwiKTtcbiAgYXJyb3dOb2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCAoaXNFcSA/IFwiMC41ZW1cIiA6IFwiMFwiKSk7XG5cbiAgLy8gPG11bmRlcm92ZXI+IHVwcGVyIGFuZCBsb3dlciBsYWJlbHMgYXJlIHNldCB0byBzY3JpcHRsZXZlbCBieSBNYXRoTUxcbiAgLy8gU28gd2UgaGF2ZSB0byBhZGp1c3Qgb3VyIGxhYmVsIGRpbWVuc2lvbnMgYWNjb3JkaW5nbHkuXG4gIGNvbnN0IGxhYmVsU3R5bGUgPSBzdHlsZS53aXRoTGV2ZWwoc3R5bGUubGV2ZWwgPCAyID8gMiA6IDMpO1xuICBjb25zdCBtaW5BcnJvd1dpZHRoID0gbGFiZWxTaXplKG1pbldpZHRoLCBsYWJlbFN0eWxlLmxldmVsKTtcbiAgLy8gVGhlIGR1bW15Tm9kZSB3aWxsIGJlIGluc2lkZSBhIDxtb3Zlcj4gaW5zaWRlIGEgPG1vdmVyPlxuICAvLyBTbyBpdCB3aWxsIGJlIGF0IHNjcmlwdGxldmVsIDNcbiAgY29uc3QgZHVtbXlXaWR0aCA9IGxhYmVsU2l6ZShtaW5XaWR0aCwgMyk7XG4gIGNvbnN0IGVtcHR5TGFiZWwgPSBwYWRkZWROb2RlKG51bGwsIG1pbkFycm93V2lkdGgudG9GaXhlZCg0KSwgMCk7XG4gIGNvbnN0IGR1bW15Tm9kZSA9IHBhZGRlZE5vZGUobnVsbCwgZHVtbXlXaWR0aC50b0ZpeGVkKDQpLCAwKTtcbiAgLy8gVGhlIGFycm93IGlzIGEgbGl0dGxlIGxvbmdlciB0aGFuIHRoZSBsYWJlbC4gU2V0IGEgc3BhY2VyIGxlbmd0aC5cbiAgY29uc3Qgc3BhY2UgPSBsYWJlbFNpemUoKGlzRXEgPyAwIDogMC4zKSwgbGFiZWxTdHlsZS5sZXZlbCkudG9GaXhlZCg0KTtcbiAgbGV0IHVwcGVyTm9kZTtcbiAgbGV0IGxvd2VyTm9kZTtcblxuICBjb25zdCBnb3RVcHBlciA9IChib2R5ICYmIGJvZHkuYm9keSAmJlxuICAgIC8vIFxcaHBoYW50b20gICAgICAgIHZpc2libGUgY29udGVudFxuICAgIChib2R5LmJvZHkuYm9keSB8fCBib2R5LmJvZHkubGVuZ3RoID4gMCkpO1xuICBpZiAoZ290VXBwZXIpIHtcbiAgICBsZXQgbGFiZWwgPSAgYnVpbGRHcm91cCQxKGJvZHksIGxhYmVsU3R5bGUpO1xuICAgIGNvbnN0IG11c3RTbWFzaCA9IChmTmFtZSA9PT0gXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiIHx8IGZOYW1lID09PSBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIik7XG4gICAgbGFiZWwgPSBwYWRkZWROb2RlKGxhYmVsLCBzcGFjZSwgc3BhY2UsIG11c3RTbWFzaCk7XG4gICAgLy8gU2luY2UgRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IG1pbnNpemUsIHN0YWNrIGEgaW52aXNpYmxlIG5vZGVcbiAgICAvLyBvbiB0b3Agb2YgdGhlIGxhYmVsLiBJdHMgd2lkdGggd2lsbCBzZXJ2ZSBhcyBhIG1pbi13aWR0aC5cbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGlzIGFmdGVyIEZpcmVmb3ggc3VwcG9ydHMgbWluc2l6ZS5cbiAgICB1cHBlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFtsYWJlbCwgZHVtbXlOb2RlXSk7XG4gIH1cbiAgY29uc3QgZ290TG93ZXIgPSAoYmVsb3cgJiYgYmVsb3cuYm9keSAmJlxuICAgIChiZWxvdy5ib2R5LmJvZHkgfHwgYmVsb3cuYm9keS5sZW5ndGggPiAwKSk7XG4gIGlmIChnb3RMb3dlcikge1xuICAgIGxldCBsYWJlbCA9ICBidWlsZEdyb3VwJDEoYmVsb3csIGxhYmVsU3R5bGUpO1xuICAgIGxhYmVsID0gcGFkZGVkTm9kZShsYWJlbCwgc3BhY2UsIHNwYWNlKTtcbiAgICBsb3dlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbbGFiZWwsIGR1bW15Tm9kZV0pO1xuICB9XG5cbiAgbGV0IG5vZGU7XG4gIGlmICghZ290VXBwZXIgJiYgIWdvdExvd2VyKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgZW1wdHlMYWJlbF0pO1xuICB9IGVsc2UgaWYgKGdvdFVwcGVyICYmIGdvdExvd2VyKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyb3ZlclwiLCBbYXJyb3dOb2RlLCBsb3dlck5vZGUsIHVwcGVyTm9kZV0pO1xuICB9IGVsc2UgaWYgKGdvdFVwcGVyKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgdXBwZXJOb2RlXSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFthcnJvd05vZGUsIGxvd2VyTm9kZV0pO1xuICB9XG4gIGlmIChtaW5XaWR0aCA9PT0gXCIzLjBcIikgeyBub2RlLnN0eWxlLmhlaWdodCA9IFwiMWVtXCI7IH0gLy8gQ0QgZW52aXJvbm1lbnRcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJmYWxzZVwiKTsgLy8gTmVjZXNzYXJ5IGZvciBNUyBXb3JkXG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBTdHJldGNoeSBhcnJvd3Mgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudFxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInhBcnJvd1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXHhsZWZ0YXJyb3dcIixcbiAgICBcIlxcXFx4cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhMZWZ0YXJyb3dcIixcbiAgICBcIlxcXFx4UmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhsZWZ0cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhMZWZ0cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhob29rbGVmdGFycm93XCIsXG4gICAgXCJcXFxceGhvb2tyaWdodGFycm93XCIsXG4gICAgXCJcXFxceG1hcHN0b1wiLFxuICAgIFwiXFxcXHhyaWdodGhhcnBvb25kb3duXCIsXG4gICAgXCJcXFxceHJpZ2h0aGFycG9vbnVwXCIsXG4gICAgXCJcXFxceGxlZnRoYXJwb29uZG93blwiLFxuICAgIFwiXFxcXHhsZWZ0aGFycG9vbnVwXCIsXG4gICAgXCJcXFxceGxvbmdlcXVhbFwiLFxuICAgIFwiXFxcXHh0d29oZWFkcmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHh0d29oZWFkbGVmdGFycm93XCIsXG4gICAgLy8gVGhlIG5leHQgNSBmdW5jdGlvbnMgYXJlIGhlcmUgb25seSB0byBzdXBwb3J0IG1oY2hlbVxuICAgIFwiXFxcXHlpZWxkc1wiLFxuICAgIFwiXFxcXHlpZWxkc0xlZnRcIixcbiAgICBcIlxcXFxtZXNvbWVyaXNtXCIsXG4gICAgXCJcXFxcbG9uZ3JpZ2h0aGFycG9vbnVwXCIsXG4gICAgXCJcXFxcbG9uZ2xlZnRoYXJwb29uZG93blwiLFxuICAgIC8vIFRoZSBuZXh0IDMgZnVuY3Rpb25zIGFyZSBoZXJlIG9ubHkgdG8gc3VwcG9ydCB0aGUge0NEfSBlbnZpcm9ubWVudC5cbiAgICBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsXG4gICAgXCJcXFxcXFxcXGNkbGVmdGFycm93XCIsXG4gICAgXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwieEFycm93XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYXJnc1swXSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBCdWlsZCB0aGUgYXJyb3cgYW5kIGl0cyBsYWJlbHMuXG4gICAgY29uc3Qgbm9kZSA9IG11bmRlcm92ZXJOb2RlKGdyb3VwLm5hbWUsIGdyb3VwLmJvZHksIGdyb3VwLmJlbG93LCBzdHlsZSk7XG4gICAgLy8gQ3JlYXRlIG9wZXJhdG9yIHNwYWNpbmcgZm9yIGEgcmVsYXRpb24uXG4gICAgY29uc3Qgcm93ID0gW25vZGVdO1xuICAgIHJvdy51bnNoaWZ0KHBhZGRpbmckMSgwLjI3NzgpKTtcbiAgICByb3cucHVzaChwYWRkaW5nJDEoMC4yNzc4KSk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCByb3cpXG4gIH1cbn0pO1xuXG5jb25zdCBhcnJvd0NvbXBvbmVudCA9IHtcbiAgXCJcXFxceHRvZnJvbVwiOiBbXCJcXFxceHJpZ2h0YXJyb3dcIiwgXCJcXFxceGxlZnRhcnJvd1wiXSxcbiAgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCI6IFtcIlxcXFx4bGVmdGhhcnBvb251cFwiLCBcIlxcXFx4cmlnaHRoYXJwb29uZG93blwiXSxcbiAgXCJcXFxceHJpZ2h0bGVmdGhhcnBvb25zXCI6IFtcIlxcXFx4cmlnaHRoYXJwb29udXBcIiwgXCJcXFxceGxlZnRoYXJwb29uZG93blwiXSxcbiAgXCJcXFxceWllbGRzTGVmdFJpZ2h0XCI6IFtcIlxcXFx5aWVsZHNcIiwgXCJcXFxceWllbGRzTGVmdFwiXSxcbiAgLy8gVGhlIG5leHQgdGhyZWUgYWxsIGdldCB0aGUgc2FtZSBoYXJwb29uIGdseXBocy4gT25seSB0aGUgbGVuZ3RocyBhbmQgcGFkZGluZ3MgZGlmZmVyLlxuICBcIlxcXFxlcXVpbGlicml1bVwiOiBbXCJcXFxcbG9uZ3JpZ2h0aGFycG9vbnVwXCIsIFwiXFxcXGxvbmdsZWZ0aGFycG9vbmRvd25cIl0sXG4gIFwiXFxcXGVxdWlsaWJyaXVtUmlnaHRcIjogW1wiXFxcXGxvbmdyaWdodGhhcnBvb251cFwiLCBcIlxcXFxlcWxlZnRoYXJwb29uZG93blwiXSxcbiAgXCJcXFxcZXF1aWxpYnJpdW1MZWZ0XCI6IFtcIlxcXFxlcXJpZ2h0aGFycG9vbnVwXCIsIFwiXFxcXGxvbmdsZWZ0aGFycG9vbmRvd25cIl1cbn07XG5cbi8vIEJyb3dzZXJzIGFyZSBub3QgZ29vZCBhdCBzdHJldGNoaW5nIGEgZ2x5cGggdGhhdCBjb250YWlucyBhIHBhaXIgb2Ygc3RhY2tlZCBhcnJvd3Mgc3VjaCBhcyDih4QuXG4vLyBTbyB3ZSBzdGFjayBhIHBhaXIgb2Ygc2luZ2xlIGFycm93cy5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzdGFja2VkQXJyb3dcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFx4dG9mcm9tXCIsICAgICAgICAgICAgICAvLyBleHBmZWlsXG4gICAgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCIsICAgLy8gbWF0aHRvb2xzXG4gICAgXCJcXFxceHJpZ2h0bGVmdGhhcnBvb25zXCIsICAgLy8gbWF0aHRvb2xzXG4gICAgXCJcXFxceWllbGRzTGVmdFJpZ2h0XCIsICAgICAgLy8gbWhjaGVtXG4gICAgXCJcXFxcZXF1aWxpYnJpdW1cIiwgICAgICAgICAgLy8gbWhjaGVtXG4gICAgXCJcXFxcZXF1aWxpYnJpdW1SaWdodFwiLFxuICAgIFwiXFxcXGVxdWlsaWJyaXVtTGVmdFwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IGxvd2VyQXJyb3dCb2R5ID0gYXJnc1swXVxuICAgICAgPyB7XG4gICAgICAgIHR5cGU6IFwiaHBoYW50b21cIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICAgIH1cbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCB1cHBlckFycm93QmVsb3cgPSBvcHRBcmdzWzBdXG4gICAgICA/IHtcbiAgICAgICAgdHlwZTogXCJocGhhbnRvbVwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgYm9keTogb3B0QXJnc1swXVxuICAgICAgfVxuICAgICAgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0YWNrZWRBcnJvd1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuYW1lOiBmdW5jTmFtZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF0sXG4gICAgICB1cHBlckFycm93QmVsb3csXG4gICAgICBsb3dlckFycm93Qm9keSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCB0b3BMYWJlbCA9IGFycm93Q29tcG9uZW50W2dyb3VwLm5hbWVdWzBdO1xuICAgIGNvbnN0IGJvdExhYmVsID0gYXJyb3dDb21wb25lbnRbZ3JvdXAubmFtZV1bMV07XG4gICAgY29uc3QgdG9wQXJyb3cgPSBtdW5kZXJvdmVyTm9kZSh0b3BMYWJlbCwgZ3JvdXAuYm9keSwgZ3JvdXAudXBwZXJBcnJvd0JlbG93LCBzdHlsZSk7XG4gICAgY29uc3QgYm90QXJyb3cgPSBtdW5kZXJvdmVyTm9kZShib3RMYWJlbCwgZ3JvdXAubG93ZXJBcnJvd0JvZHksIGdyb3VwLmJlbG93LCBzdHlsZSk7XG4gICAgbGV0IHdyYXBwZXI7XG5cbiAgICBjb25zdCByYWlzZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3RvcEFycm93XSk7XG4gICAgcmFpc2VOb2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgXCIwLjNlbVwiKTtcbiAgICByYWlzZU5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiKzAuM2VtXCIpO1xuICAgIHJhaXNlTm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIi0wLjNlbVwiKTtcbiAgICAvLyBPbmUgb2YgdGhlIGFycm93cyBpcyBnaXZlbiB+emVybyB3aWR0aC4gc28gdGhlIG90aGVyIGhhcyB0aGUgc2FtZSBob3J6b250YWwgYWxpZ25tZW50LlxuICAgIGlmIChncm91cC5uYW1lID09PSBcIlxcXFxlcXVpbGlicml1bUxlZnRcIikge1xuICAgICAgY29uc3QgYm90Tm9kZSA9ICBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2JvdEFycm93XSk7XG4gICAgICBib3ROb2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC41ZW1cIik7XG4gICAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLFxuICAgICAgICBbcGFkZGluZyQxKDAuMjc3OCksIGJvdE5vZGUsIHJhaXNlTm9kZSwgcGFkZGluZyQxKDAuMjc3OCldXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByYWlzZU5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgKGdyb3VwLm5hbWUgPT09IFwiXFxcXGVxdWlsaWJyaXVtUmlnaHRcIiA/IFwiMC41ZW1cIiA6IFwiMFwiKSk7XG4gICAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLFxuICAgICAgICBbcGFkZGluZyQxKDAuMjc3OCksIHJhaXNlTm9kZSwgYm90QXJyb3csIHBhZGRpbmckMSgwLjI3NzgpXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgXCItMC4xOGVtXCIpO1xuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiLTAuMThlbVwiKTtcbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiKzAuMThlbVwiKTtcbiAgICByZXR1cm4gd3JhcHBlclxuICB9XG59KTtcblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBgZW52aXJvbm1lbnRzLmpzYCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkgdmlhIGBlbnZpcm9ubWVudHMuanNgLlxuICovXG5jb25zdCBfZW52aXJvbm1lbnRzID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZUVudmlyb25tZW50KHsgdHlwZSwgbmFtZXMsIHByb3BzLCBoYW5kbGVyLCBtYXRobWxCdWlsZGVyIH0pIHtcbiAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGVudmlyb25tZW50cy5cbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0eXBlLFxuICAgIG51bUFyZ3M6IHByb3BzLm51bUFyZ3MgfHwgMCxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDAsXG4gICAgaGFuZGxlclxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgX2Vudmlyb25tZW50c1tuYW1lc1tpXV0gPSBkYXRhO1xuICB9XG4gIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBub2RlIGlzIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCByZXR1cm5zIGl0IHdpdGggc3RyaWN0ZXJcbiAqIHR5cGluZy4gVGhyb3dzIGlmIHRoZSBub2RlJ3MgdHlwZSBkb2VzIG5vdCBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZVR5cGUobm9kZSwgdHlwZSkge1xuICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSB0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIG5vZGUgb2YgdHlwZSAke3R5cGV9LCBidXQgZ290IGAgK1xuICAgICAgICAobm9kZSA/IGBub2RlIG9mIHR5cGUgJHtub2RlLnR5cGV9YCA6IFN0cmluZyhub2RlKSlcbiAgICApO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbW9yZSBzdHJpY3RseSB0eXBlZCBpZmYgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuIE90aGVyd2lzZSxcbiAqIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBjb25zdCB0eXBlZE5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKG5vZGUpO1xuICBpZiAoIXR5cGVkTm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBub2RlIG9mIHN5bWJvbCBncm91cCB0eXBlLCBidXQgZ290IGAgK1xuICAgICAgICAobm9kZSA/IGBub2RlIG9mIHR5cGUgJHtub2RlLnR5cGV9YCA6IFN0cmluZyhub2RlKSlcbiAgICApO1xuICB9XG4gIHJldHVybiB0eXBlZE5vZGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBjaGVja1N5bWJvbE5vZGVUeXBlKG5vZGUpIHtcbiAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJhdG9tXCIgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChOT05fQVRPTVMsIG5vZGUudHlwZSkpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGNkQXJyb3dGdW5jdGlvbk5hbWUgPSB7XG4gIFwiPlwiOiBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsXG4gIFwiPFwiOiBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIixcbiAgXCI9XCI6IFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiLFxuICBBOiBcIlxcXFx1cGFycm93XCIsXG4gIFY6IFwiXFxcXGRvd25hcnJvd1wiLFxuICBcInxcIjogXCJcXFxcVmVydFwiLFxuICBcIi5cIjogXCJubyBhcnJvd1wiXG59O1xuXG5jb25zdCBuZXdDZWxsID0gKCkgPT4ge1xuICAvLyBDcmVhdGUgYW4gZW1wdHkgY2VsbCwgdG8gYmUgZmlsbGVkIGJlbG93IHdpdGggcGFyc2Ugbm9kZXMuXG4gIHJldHVybiB7IHR5cGU6IFwic3R5bGluZ1wiLCBib2R5OiBbXSwgbW9kZTogXCJtYXRoXCIsIHNjcmlwdExldmVsOiBcImRpc3BsYXlcIiB9O1xufTtcblxuY29uc3QgaXNTdGFydE9mQXJyb3cgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInRleHRvcmRcIiAmJiBub2RlLnRleHQgPT09IFwiQFwiO1xufTtcblxuY29uc3QgaXNMYWJlbEVuZCA9IChub2RlLCBlbmRDaGFyKSA9PiB7XG4gIHJldHVybiAobm9kZS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBub2RlLnR5cGUgPT09IFwiYXRvbVwiKSAmJiBub2RlLnRleHQgPT09IGVuZENoYXI7XG59O1xuXG5mdW5jdGlvbiBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGEgcGFyc2UgdHJlZSBvZiBhbiBhcnJvdyBhbmQgaXRzIGxhYmVscy5cbiAgLy8gVGhpcyBhY3RzIGluIGEgd2F5IHNpbWlsYXIgdG8gYSBtYWNybyBleHBhbnNpb24uXG4gIGNvbnN0IGZ1bmNOYW1lID0gY2RBcnJvd0Z1bmN0aW9uTmFtZVthcnJvd0NoYXJdO1xuICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgY2FzZSBcIlxcXFxcXFxcY2RyaWdodGFycm93XCI6XG4gICAgY2FzZSBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIjpcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbGFiZWxzWzBdXSwgW2xhYmVsc1sxXV0pO1xuICAgIGNhc2UgXCJcXFxcdXBhcnJvd1wiOlxuICAgIGNhc2UgXCJcXFxcZG93bmFycm93XCI6IHtcbiAgICAgIGNvbnN0IGxlZnRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkbGVmdFwiLCBbbGFiZWxzWzBdXSwgW10pO1xuICAgICAgY29uc3QgYmFyZUFycm93ID0ge1xuICAgICAgICB0eXBlOiBcImF0b21cIixcbiAgICAgICAgdGV4dDogZnVuY05hbWUsXG4gICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICBmYW1pbHk6IFwicmVsXCJcbiAgICAgIH07XG4gICAgICBjb25zdCBzaXplZEFycm93ID0gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxCaWdcIiwgW2JhcmVBcnJvd10sIFtdKTtcbiAgICAgIGNvbnN0IHJpZ2h0TGFiZWwgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZHJpZ2h0XCIsIFtsYWJlbHNbMV1dLCBbXSk7XG4gICAgICBjb25zdCBhcnJvd0dyb3VwID0ge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICBib2R5OiBbbGVmdExhYmVsLCBzaXplZEFycm93LCByaWdodExhYmVsXSxcbiAgICAgICAgc2VtaXNpbXBsZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZHBhcmVudFwiLCBbYXJyb3dHcm91cF0sIFtdKTtcbiAgICB9XG4gICAgY2FzZSBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIjpcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiLCBbXSwgW10pO1xuICAgIGNhc2UgXCJcXFxcVmVydFwiOiB7XG4gICAgICBjb25zdCBhcnJvdyA9IHsgdHlwZTogXCJ0ZXh0b3JkXCIsIHRleHQ6IFwiXFxcXFZlcnRcIiwgbW9kZTogXCJtYXRoXCIgfTtcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXEJpZ1wiLCBbYXJyb3ddLCBbXSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRleHRvcmRcIiwgdGV4dDogXCIgXCIsIG1vZGU6IFwibWF0aFwiIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDRChwYXJzZXIpIHtcbiAgLy8gR2V0IHRoZSBhcnJheSdzIHBhcnNlIG5vZGVzIHdpdGggXFxcXCB0ZW1wb3JhcmlseSBtYXBwZWQgdG8gXFxjci5cbiAgY29uc3QgcGFyc2VkUm93cyA9IFtdO1xuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNyXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIEdldCB0aGUgcGFyc2Ugbm9kZXMgZm9yIHRoZSBuZXh0IHJvdy5cbiAgICBwYXJzZWRSb3dzLnB1c2gocGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJcXFxcXFxcXFwiKSk7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICAgIGlmIChuZXh0ID09PSBcIiZcIiB8fCBuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgaWYgKHBhcnNlZFJvd3NbcGFyc2VkUm93cy5sZW5ndGggLSAxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyc2VkUm93cy5wb3AoKTsgLy8gZmluYWwgcm93IGVuZGVkIGluIFxcXFxcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIFxcXFxcXFxcIG9yIFxcXFxjciBvciBcXFxcZW5kXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIGxldCByb3cgPSBbXTtcbiAgY29uc3QgYm9keSA9IFtyb3ddO1xuXG4gIC8vIExvb3AgdGhydSB0aGUgcGFyc2Ugbm9kZXMuIENvbGxlY3QgdGhlbSBpbnRvIGNlbGxzIGFuZCBhcnJvd3MuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkUm93cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFN0YXJ0IGEgbmV3IHJvdy5cbiAgICBjb25zdCByb3dOb2RlcyA9IHBhcnNlZFJvd3NbaV07XG4gICAgLy8gQ3JlYXRlIHRoZSBmaXJzdCBjZWxsLlxuICAgIGxldCBjZWxsID0gbmV3Q2VsbCgpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKCFpc1N0YXJ0T2ZBcnJvdyhyb3dOb2Rlc1tqXSkpIHtcbiAgICAgICAgLy8gSWYgYSBwYXJzZU5vZGUgaXMgbm90IGFuIGFycm93LCBpdCBnb2VzIGludG8gYSBjZWxsLlxuICAgICAgICBjZWxsLmJvZHkucHVzaChyb3dOb2Rlc1tqXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJzZSBub2RlIGogaXMgYW4gXCJAXCIsIHRoZSBzdGFydCBvZiBhbiBhcnJvdy5cbiAgICAgICAgLy8gQmVmb3JlIHN0YXJ0aW5nIG9uIHRoZSBhcnJvdywgcHVzaCB0aGUgY2VsbCBpbnRvIGByb3dgLlxuICAgICAgICByb3cucHVzaChjZWxsKTtcblxuICAgICAgICAvLyBOb3cgY29sbGVjdCBwYXJzZU5vZGVzIGludG8gYW4gYXJyb3cuXG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYWZ0ZXIgXCJAXCIgZGVmaW5lcyB0aGUgYXJyb3cgdHlwZS5cbiAgICAgICAgaiArPSAxO1xuICAgICAgICBjb25zdCBhcnJvd0NoYXIgPSBhc3NlcnRTeW1ib2xOb2RlVHlwZShyb3dOb2Rlc1tqXSkudGV4dDtcblxuICAgICAgICAvLyBDcmVhdGUgdHdvIGVtcHR5IGxhYmVsIG5vZGVzLiBXZSBtYXkgb3IgbWF5IG5vdCB1c2UgdGhlbS5cbiAgICAgICAgY29uc3QgbGFiZWxzID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBsYWJlbHNbMF0gPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogXCJtYXRoXCIsIGJvZHk6IFtdIH07XG4gICAgICAgIGxhYmVsc1sxXSA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiBcIm1hdGhcIiwgYm9keTogW10gfTtcblxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBhcnJvdy5cbiAgICAgICAgaWYgKFwiPXwuXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIDsgZWxzZSBpZiAoXCI8PkFWXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIHtcbiAgICAgICAgICAvLyBGb3VyIGFycm93cywgYEA+Pj5gLCBgQDw8PGAsIGBAQUFBYCwgYW5kIGBAVlZWYCwgZWFjaCB0YWtlXG4gICAgICAgICAgLy8gdHdvIG9wdGlvbmFsIGxhYmVscy4gRS5nLiB0aGUgcmlnaHQtcG9pbnQgYXJyb3cgc3ludGF4IGlzXG4gICAgICAgICAgLy8gcmVhbGx5OiAgQD57b3B0aW9uYWwgbGFiZWx9PntvcHRpb25hbCBsYWJlbH0+XG4gICAgICAgICAgLy8gQ29sbGVjdCBwYXJzZU5vZGVzIGludG8gbGFiZWxzLlxuICAgICAgICAgIGZvciAobGV0IGxhYmVsTnVtID0gMDsgbGFiZWxOdW0gPCAyOyBsYWJlbE51bSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5MYWJlbCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gaiArIDE7IGsgPCByb3dOb2Rlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoaXNMYWJlbEVuZChyb3dOb2Rlc1trXSwgYXJyb3dDaGFyKSkge1xuICAgICAgICAgICAgICAgIGluTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBqID0gaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdGFydE9mQXJyb3cocm93Tm9kZXNba10pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIk1pc3NpbmcgYSBcIiArIGFycm93Q2hhciArIFwiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LlwiLFxuICAgICAgICAgICAgICAgICAgcm93Tm9kZXNba11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGFiZWxzW2xhYmVsTnVtXS5ib2R5LnB1c2gocm93Tm9kZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluTGFiZWwpIHtcbiAgICAgICAgICAgICAgLy8gaXNMYWJlbEVuZCBuZXZlciByZXR1cm5lZCBhIHRydWUuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiTWlzc2luZyBhIFwiICsgYXJyb3dDaGFyICsgXCIgY2hhcmFjdGVyIHRvIGNvbXBsZXRlIGEgQ0QgYXJyb3cuXCIsXG4gICAgICAgICAgICAgICAgcm93Tm9kZXNbal1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEV4cGVjdGVkIG9uZSBvZiBcIjw+QVY9fC5cIiBhZnRlciBALmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IGpvaW4gdGhlIGFycm93IHRvIGl0cyBsYWJlbHMuXG4gICAgICAgIGNvbnN0IGFycm93ID0gY2RBcnJvdyhhcnJvd0NoYXIsIGxhYmVscywgcGFyc2VyKTtcblxuICAgICAgICAvLyBXcmFwIHRoZSBhcnJvdyBpbiBhIHN0eWxpbmcgbm9kZVxuICAgICAgICByb3cucHVzaChhcnJvdyk7XG4gICAgICAgIC8vIEluIENEJ3Mgc3ludGF4LCBjZWxscyBhcmUgaW1wbGljaXQuIFRoYXQgaXMsIGV2ZXJ5dGhpbmcgdGhhdFxuICAgICAgICAvLyBpcyBub3QgYW4gYXJyb3cgZ2V0cyBjb2xsZWN0ZWQgaW50byBhIGNlbGwuIFNvIGNyZWF0ZSBhbiBlbXB0eVxuICAgICAgICAvLyBjZWxsIG5vdy4gSXQgd2lsbCBjb2xsZWN0IHVwY29taW5nIHBhcnNlTm9kZXMuXG4gICAgICAgIGNlbGwgPSBuZXdDZWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgLy8gRXZlbi1udW1iZXJlZCByb3dzIGNvbnNpc3Qgb2Y6IGNlbGwsIGFycm93LCBjZWxsLCBhcnJvdywgLi4uIGNlbGxcbiAgICAgIC8vIFRoZSBsYXN0IGNlbGwgaXMgbm90IHlldCBwdXNoZWQgaW50byBgcm93YCwgc286XG4gICAgICByb3cucHVzaChjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2RkLW51bWJlcmVkIHJvd3MgY29uc2lzdCBvZjogdmVydCBhcnJvdywgZW1wdHkgY2VsbCwgLi4uIHZlcnQgYXJyb3dcbiAgICAgIC8vIFJlbW92ZSB0aGUgZW1wdHkgY2VsbCB0aGF0IHdhcyBwbGFjZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBgcm93YC5cbiAgICAgIHJvdy5zaGlmdCgpO1xuICAgIH1cbiAgICByb3cgPSBbXTtcbiAgICBib2R5LnB1c2gocm93KTtcbiAgfVxuICBib2R5LnBvcCgpO1xuXG4gIC8vIEVuZCByb3cgZ3JvdXBcbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAvLyBFbmQgYXJyYXkgZ3JvdXAgZGVmaW5pbmcgXFxcXFxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgYm9keSxcbiAgICB0YWdzOiBudWxsLFxuICAgIGxhYmVsczogbmV3IEFycmF5KGJvZHkubGVuZ3RoICsgMSkuZmlsbChcIlwiKSxcbiAgICBlbnZDbGFzc2VzOiBbXCJqb3RcIiwgXCJjZFwiXSxcbiAgICBjb2xzOiBbXSxcbiAgICBoTGluZXNCZWZvcmVSb3c6IG5ldyBBcnJheShib2R5Lmxlbmd0aCArIDEpLmZpbGwoW10pXG4gIH07XG59XG5cbi8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIG5vdCBhdmFpbGFibGUgZm9yIGdlbmVyYWwgdXNlLlxuLy8gVGhleSBhcmUgaGVyZSBvbmx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIHtDRH0gZW52aXJvbm1lbnQgaW4gcGxhY2luZyBsYWJlbHNcbi8vIG5leHQgdG8gdmVydGljYWwgYXJyb3dzLlxuXG4vLyBXZSBkb24ndCBuZWVkIGFueSBzdWNoIGZ1bmN0aW9ucyBmb3IgaG9yaXpvbnRhbCBhcnJvd3MgYmVjYXVzZSB3ZSBjYW4gcmV1c2Vcbi8vIHRoZSBmdW5jdGlvbmFsaXR5IHRoYXQgYWxyZWFkeSBleGlzdHMgZm9yIGV4dGVuc2libGUgYXJyb3dzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY2RsYWJlbFwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxjZGxlZnRcIiwgXCJcXFxcXFxcXGNkcmlnaHRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2RsYWJlbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaWRlOiBmdW5jTmFtZS5zbGljZSg0KSxcbiAgICAgIGxhYmVsOiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBpZiAoZ3JvdXAubGFiZWwuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgc3R5bGUpICAvLyBlbXB0eSBsYWJlbFxuICAgIH1cbiAgICAvLyBBYnVzZSBhbiA8bXRhYmxlPiB0byBjcmVhdGUgdmVydGljYWxseSBjZW50ZXJlZCBjb250ZW50LlxuICAgIGNvbnN0IG10ZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAubGFiZWwsIHN0eWxlKV0pO1xuICAgIG10ZC5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XG4gICAgY29uc3QgbXRyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgW210ZF0pO1xuICAgIGNvbnN0IG10YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFttdHJdKTtcbiAgICBjb25zdCBsYWJlbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbbXRhYmxlXSk7XG4gICAgLy8gU2V0IHRoZSBsYWJlbCB3aWR0aCB0byB6ZXJvIHNvIHRoYXQgdGhlIGFycm93IHdpbGwgYmUgY2VudGVyZWQgdW5kZXIgdGhlIGNvcm5lciBjZWxsLlxuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMFwiKTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgXCJmYWxzZVwiKTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjFcIik7XG4gICAgaWYgKGdyb3VwLnNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICBsYWJlbC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICBsYWJlbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNkbGFiZWxwYXJlbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcY2RwYXJlbnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjZGxhYmVscGFyZW50XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZyYWdtZW50OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAuZnJhZ21lbnQsIHN0eWxlKV0pO1xuICB9XG59KTtcblxuY29uc3Qgb3JkR3JvdXAgPSAoYm9keSkgPT4ge1xuICByZXR1cm4ge1xuICAgIFwidHlwZVwiOiBcIm9yZGdyb3VwXCIsXG4gICAgXCJtb2RlXCI6IFwibWF0aFwiLFxuICAgIFwiYm9keVwiOiBib2R5LFxuICAgIFwic2VtaXNpbXBsZVwiOiB0cnVlXG4gIH1cbn07XG5cbmNvbnN0IHBoYW50b20gPSAoYm9keSwgdHlwZSkgPT4ge1xuICByZXR1cm4ge1xuICAgIFwidHlwZVwiOiB0eXBlLFxuICAgIFwibW9kZVwiOiBcIm1hdGhcIixcbiAgICBcImJvZHlcIjogb3JkR3JvdXAoYm9keSlcbiAgfVxufTtcblxuLypcbiAqIEEgaGVscGVyIGZvciBcXGJvcmRlcm1hdHJpeC5cbiAqIHBhcnNlQXJyYXkoKSBoYXMgcGFyc2VkIHRoZSB0b2tlbnMgYXMgaWYgdGhlIGVudmlyb25tZW50XG4gKiB3YXMgXFxiZWdpbnttYXRyaXh9LiBUaGF0IHBhcnNlIHRyZWUgaXMgdGhpcyBmdW5jdGlvbuKAmXMgaW5wdXQuXG4gKiBIZXJlLCB3ZSByZWFycmFuZ2UgdGhlIHBhcnNlIHRyZWUgdG8gZ2V0IG9uZSB0aGF0IHdpbGxcbiAqIHJlc3VsdCBpbiBUZVggXFxib3JkZXJtYXRyaXguXG4gKiBUaGUgZmluYWwgcmVzdWx0IGluY2x1ZGVzIGEge3BtYXRyaXh9LCB3aGljaCBpcyB0aGUgYm90dG9tXG4gKiBoYWxmIG9mIGEgPG1vdmVyPiBlbGVtZW50LiBUaGUgdG9wIG9mIHRoZSA8bW92ZXI+IGNvbnRhaW5zXG4gKiB0aGUgXFxib3JkZXJtYXRyaXggaGVhZGluZ3MuIFRoZSB0b3Agc2VjdGlvbiBhbHNvIGNvbnRhaW5zIHRoZVxuICogY29udGVudHMgb2YgdGhlIGJvdHRvbSB7cG1hdHJpeH0uIFRob3NlIGVsZW1lbnRzIGFyZSBoaWRkZW4gdmlhXG4gKiBcXGhwaGFudG9tLCBidXQgdGhleSBlbnN1cmUgdGhhdCBjb2x1bW4gd2lkdGhzIGFyZSB0aGUgc2FtZSB0b3AgYW5kXG4gKiBib3R0b20uXG4gKlxuICogV2UgYWxzbyBjcmVhdGUgYSBsZWZ0IHttYXRyaXh9IHdpdGggYSBzaW5nbGUgY29sdW1uIHRoYXQgY29udGFpbnNcbiAqIGVsZW1lbnRzIHNoaWZ0ZWQgb3V0IG9mIHRoZSBtYXRyaXguIFRoZSBsZWZ0IHttYXRyaXh9IGFsc29cbiAqIGNvbnRhaW5zIFxcdnBoYW50b20gY29waWVzIG9mIHRoZSBvdGhlciB7cG1hdHJpeH0gZWxlbWVudHMuXG4gKiBBcyBiZWZvcmUsIHRoaXMgZW5zdXJlcyBjb25zaXN0ZW50IHJvdyBoZWlnaHRzIG9mIGxlZnQgYW5kIG1haW4uXG4gKi9cblxuY29uc3QgYm9yZGVybWF0cml4UGFyc2VUcmVlID0gKG1hdHJpeCwgZGVsaW1pdGVycykgPT4ge1xuICBjb25zdCBib2R5ID0gbWF0cml4LmJvZHk7XG4gIGJvZHlbMF0uc2hpZnQoKTsgLy8gZGlzcG9zZSBvZiB0b3AgbGVmdCBjZWxsXG5cbiAgLy8gQ3JlYXRlIGFuIGFycmF5IGZvciB0aGUgbGVmdCBjb2x1bW5cbiAgY29uc3QgbGVmdENvbHVtbkJvZHkgPSBuZXcgQXJyYXkoYm9keS5sZW5ndGggLSAxKS5maWxsKCkubWFwKCgpID0+IFtdKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gVGhlIHZpc2libGUgcGFydCBvZiB0aGUgY2VsbFxuICAgIGxlZnRDb2x1bW5Cb2R5W2kgLSAxXS5wdXNoKGJvZHlbaV0uc2hpZnQoKSk7XG4gICAgLy8gQSB2cGhhbnRvbSB3aXRoIGNvbnRlbnRzIGZyb20gdGhlIHBtYXRyaXgsIHRvIHNldCBtaW5pbXVtIGNlbGwgaGVpZ2h0XG4gICAgY29uc3QgcGhhbnRvbUJvZHkgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJvZHlbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHBoYW50b21Cb2R5LnB1c2goc3RydWN0dXJlZENsb25lKGJvZHlbaV1bal0pKTtcbiAgICB9XG4gICAgbGVmdENvbHVtbkJvZHlbaSAtIDFdLnB1c2gocGhhbnRvbShwaGFudG9tQm9keSwgXCJ2cGhhbnRvbVwiKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYW4gYXJyYXkgZm9yIHRoZSB0b3Agcm93XG4gIGNvbnN0IHRvcFJvd0JvZHkgPSBuZXcgQXJyYXkoYm9keS5sZW5ndGgpLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGJvZHlbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICB0b3BSb3dCb2R5WzBdLnB1c2goc3RydWN0dXJlZENsb25lKGJvZHlbMF1bal0pKTtcbiAgfVxuICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSBwbWF0cml4LCBidXQgc3F1YXNoZWQgdmlhIFxcaHBoYW50b21cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBib2R5WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICB0b3BSb3dCb2R5W2ldLnB1c2gocGhhbnRvbShzdHJ1Y3R1cmVkQ2xvbmUoYm9keVtpXVtqXSkuYm9keSwgXCJocGhhbnRvbVwiKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3F1YXNoIHRoZSB0b3Agcm93IG9mIHRoZSBtYWluIHtwbWF0cml4fVxuICBmb3IgKGxldCBqID0gMDsgaiA8IGJvZHlbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICBib2R5WzBdW2pdID0gcGhhbnRvbShzdHJ1Y3R1cmVkQ2xvbmUoYm9keVswXVtqXSkuYm9keSwgXCJocGhhbnRvbVwiKTtcbiAgfVxuXG4gIC8vIE5vdyB3cmFwIHRoZSBhcnJheXMgaW4gdGhlIHByb3BlciBwYXJzZSBub2Rlcy5cblxuICBjb25zdCBsZWZ0Q29sdW1uID0ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBib2R5OiBsZWZ0Q29sdW1uQm9keSxcbiAgICBjb2xzOiBbeyB0eXBlOiBcImFsaWduXCIsIGFsaWduOiBcImNcIiB9XSxcbiAgICByb3dHYXBzOiBuZXcgQXJyYXkobGVmdENvbHVtbkJvZHkubGVuZ3RoIC0gMSkuZmlsbChudWxsKSxcbiAgICBoTGluZXNCZWZvcmVSb3c6IG5ldyBBcnJheShsZWZ0Q29sdW1uQm9keS5sZW5ndGggKyAxKS5maWxsKCkubWFwKCgpID0+IFtdKSxcbiAgICBlbnZDbGFzc2VzOiBbXSxcbiAgICBzY3JpcHRMZXZlbDogXCJ0ZXh0XCIsXG4gICAgYXJyYXlzdHJldGNoOiAxLFxuICAgIGxhYmVsczogbmV3IEFycmF5KGxlZnRDb2x1bW5Cb2R5Lmxlbmd0aCkuZmlsbChcIlwiKSxcbiAgICBhcnJheWNvbHNlcDogeyBcIm51bWJlclwiOiAwLjA0LCB1bml0OiBcImVtXCIgfVxuICB9O1xuXG4gIGNvbnN0IHRvcFJvdyA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgYm9keTogdG9wUm93Qm9keSxcbiAgICBjb2xzOiBuZXcgQXJyYXkodG9wUm93Qm9keS5sZW5ndGgpLmZpbGwoeyB0eXBlOiBcImFsaWduXCIsIGFsaWduOiBcImNcIiB9KSxcbiAgICByb3dHYXBzOiBuZXcgQXJyYXkodG9wUm93Qm9keS5sZW5ndGggLSAxKS5maWxsKG51bGwpLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogbmV3IEFycmF5KHRvcFJvd0JvZHkubGVuZ3RoICsgMSkuZmlsbCgpLm1hcCgoKSA9PiBbXSksXG4gICAgZW52Q2xhc3NlczogW10sXG4gICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiLFxuICAgIGFycmF5c3RyZXRjaDogMSxcbiAgICBsYWJlbHM6IG5ldyBBcnJheSh0b3BSb3dCb2R5Lmxlbmd0aCkuZmlsbChcIlwiKSxcbiAgICBhcnJheWNvbHNlcDogbnVsbFxuICB9O1xuXG4gIGNvbnN0IHRvcFdyYXBwZXIgPSB7XG4gICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiLCAvLyBNdXN0IHNldCB0aGlzIGV4cGxpY2l0bHkuXG4gICAgYm9keTogW3RvcFJvd10gICAgICAgLy8gRGVmYXVsdCBsZXZlbCBpcyBcInNjcmlwdFwiLlxuICB9O1xuXG4gIGNvbnN0IGNvbnRhaW5lciA9IHtcbiAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGJvZHk6IFttYXRyaXhdLFxuICAgIGxlZnQ6IGRlbGltaXRlcnMgPyBkZWxpbWl0ZXJzWzBdIDogXCIoXCIsXG4gICAgcmlnaHQ6IGRlbGltaXRlcnMgPyBkZWxpbWl0ZXJzWzFdIDogXCIpXCIsXG4gICAgcmlnaHRDb2xvcjogdW5kZWZpbmVkXG4gIH07XG5cbiAgY29uc3QgYmFzZSA9IHtcbiAgICB0eXBlOiBcIm9wXCIsICAgLy8gVGhlIGJhc2Ugb2YgYSBUZVggXFxvdmVyc2V0XG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgbGltaXRzOiB0cnVlLFxuICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogdHJ1ZSxcbiAgICBwYXJlbnRJc1N1cFN1YjogdHJ1ZSxcbiAgICBzeW1ib2w6IGZhbHNlLFxuICAgIHN0YWNrOiB0cnVlLFxuICAgIHN1cHByZXNzQmFzZVNoaWZ0OiB0cnVlLFxuICAgIGJvZHk6IFtjb250YWluZXJdXG4gIH07XG5cbiAgY29uc3QgbW92ZXIgPSB7XG4gICAgdHlwZTogXCJzdXBzdWJcIiwgIC8vIFdlJ3JlIHVzaW5nIHRoZSBNYXRoTUwgZXF1aXZhbGVudFxuICAgIG1vZGU6IFwibWF0aFwiLCAgICAvLyBvZiBUZVggXFxvdmVyc2V0LlxuICAgIGJhc2U6IGJhc2UsICAgICAgLy8gVGhhdCBrZWVwcyB0aGUge3BtYXRyaXh9IGFsaWduZWQgd2l0aFxuICAgIHN1cDogdG9wV3JhcHBlciwgLy8gdGhlIG1hdGggY2VudGVybGluZS5cbiAgICBzdWI6IG51bGxcbiAgfTtcblxuICByZXR1cm4gb3JkR3JvdXAoW2xlZnRDb2x1bW4sIG1vdmVyXSlcbn07XG5cbi8qKlxuICogTGV4aW5nIG9yIHBhcnNpbmcgcG9zaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgZXJyb3IgcmVwb3J0aW5nLlxuICogVGhpcyBvYmplY3QgaXMgaW1tdXRhYmxlLlxuICovXG5jbGFzcyBTb3VyY2VMb2NhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGxleGVyLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyOyAvLyBMZXhlciBob2xkaW5nIHRoZSBpbnB1dCBzdHJpbmcuXG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0OyAvLyBTdGFydCBvZmZzZXQsIHplcm8tYmFzZWQgaW5jbHVzaXZlLlxuICAgIHRoaXMuZW5kID0gZW5kOyAgICAgLy8gRW5kIG9mZnNldCwgemVyby1iYXNlZCBleGNsdXNpdmUuXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIHR3byBgU291cmNlTG9jYXRpb25gcyBmcm9tIGxvY2F0aW9uIHByb3ZpZGVycywgZ2l2ZW4gdGhleSBhcmVcbiAgICogcHJvdmlkZWQgaW4gb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAgICogLSBSZXR1cm5zIHRoZSBmaXJzdCBvbmUncyBsb2NhdGlvbiBpZiBvbmx5IHRoZSBmaXJzdCBpcyBwcm92aWRlZC5cbiAgICogLSBSZXR1cm5zIGEgbWVyZ2VkIHJhbmdlIG9mIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgaWYgYm90aCBhcmUgcHJvdmlkZWRcbiAgICogICBhbmQgdGhlaXIgbGV4ZXJzIG1hdGNoLlxuICAgKiAtIE90aGVyd2lzZSwgcmV0dXJucyBudWxsLlxuICAgKi9cbiAgc3RhdGljIHJhbmdlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoIXNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmxvYztcbiAgICB9IGVsc2UgaWYgKCFmaXJzdCB8fCAhZmlyc3QubG9jIHx8ICFzZWNvbmQubG9jIHx8IGZpcnN0LmxvYy5sZXhlciAhPT0gc2Vjb25kLmxvYy5sZXhlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlTG9jYXRpb24oZmlyc3QubG9jLmxleGVyLCBmaXJzdC5sb2Muc3RhcnQsIHNlY29uZC5sb2MuZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVxdWlyZWQgdG8gYnJlYWsgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIFRva2VuLCBMZXhlciwgYW5kXG4gKiBQYXJzZUVycm9yLlxuICovXG5cbi8qKlxuICogVGhlIHJlc3VsdGluZyB0b2tlbiByZXR1cm5lZCBmcm9tIGBsZXhgLlxuICpcbiAqIEl0IGNvbnNpc3RzIG9mIHRoZSB0b2tlbiB0ZXh0IHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBlc3NlbnRpYWxseSBhIHJhbmdlIGluIGFuIGlucHV0IHN0cmluZyxcbiAqIGJ1dCBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIHRoZSBiYXJlIGlucHV0IHN0cmluZywgd2UgcmVmZXIgdG8gdGhlIGxleGVyLlxuICogVGhhdCB3YXkgaXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGV4dHJhIG1ldGFkYXRhIHRvIHRoZSBpbnB1dCBzdHJpbmcsXG4gKiBsaWtlIGZvciBleGFtcGxlIGEgZmlsZSBuYW1lIG9yIHNpbWlsYXIuXG4gKlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIG9wdGlvbmFsLCBzbyBpdCBpcyBPSyB0byBjb25zdHJ1Y3Qgc3ludGhldGljXG4gKiB0b2tlbnMgaWYgYXBwcm9wcmlhdGUuIE5vdCBwcm92aWRpbmcgYXZhaWxhYmxlIHBvc2l0aW9uIGluZm9ybWF0aW9uIG1heVxuICogbGVhZCB0byBkZWdyYWRlZCBlcnJvciByZXBvcnRpbmcsIHRob3VnaC5cbiAqL1xuY2xhc3MgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB0ZXh0LCAvLyB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gICAgbG9jXG4gICkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5sb2MgPSBsb2M7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwYWlyIG9mIHRva2VucyAodGhpcyBhbmQgZW5kVG9rZW4pLCBjb21wdXRlIGEgYFRva2VuYCBlbmNvbXBhc3NpbmdcbiAgICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAgICovXG4gIHJhbmdlKFxuICAgIGVuZFRva2VuLCAvLyBsYXN0IHRva2VuIG9mIHRoZSByYW5nZSwgaW5jbHVzaXZlXG4gICAgdGV4dCAvLyB0aGUgdGV4dCBvZiB0aGUgbmV3bHkgY29uc3RydWN0ZWQgdG9rZW5cbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCBTb3VyY2VMb2NhdGlvbi5yYW5nZSh0aGlzLCBlbmRUb2tlbikpO1xuICB9XG59XG5cbi8vIEluIFRlWCwgdGhlcmUgYXJlIGFjdHVhbGx5IHRocmVlIHNldHMgb2YgZGltZW5zaW9ucywgb25lIGZvciBlYWNoIG9mXG4vLyB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBhbmQgc2NyaXB0c2NyaXB0c3R5bGUuICBUaGVzZSBhcmVcbi8vIHByb3ZpZGVkIGluIHRoZSB0aGUgYXJyYXlzIGJlbG93LCBpbiB0aGF0IG9yZGVyLlxuLy9cblxuLy8gTWF0aCBzdHlsZSBpcyBub3QgcXVpdGUgdGhlIHNhbWUgdGhpbmcgYXMgc2NyaXB0IGxldmVsLlxuY29uc3QgU3R5bGVMZXZlbCA9IHtcbiAgRElTUExBWTogMCxcbiAgVEVYVDogMSxcbiAgU0NSSVBUOiAyLFxuICBTQ1JJUFRTQ1JJUFQ6IDNcbn07XG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZ2xvYmFsL2J1aWx0LWluIG1hY3Jvcy5cbiAqIGBtYWNyb3MuanNgIGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeSB2aWEgYG1hY3Jvcy5qc2AuXG4gKi9cbmNvbnN0IF9tYWNyb3MgPSB7fTtcblxuLy8gVGhpcyBmdW5jdGlvbiBtaWdodCBvbmUgZGF5IGFjY2VwdCBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IGFuZCBkbyBtb3JlIHRoaW5ncy5cbmZ1bmN0aW9uIGRlZmluZU1hY3JvKG5hbWUsIGJvZHkpIHtcbiAgX21hY3Jvc1tuYW1lXSA9IGJvZHk7XG59XG5cbi8qKlxuICogUHJlZGVmaW5lZCBtYWNyb3MgZm9yIFRlbW1sLlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBkZWZpbmUgc29tZSBjb21tYW5kcyBpbiB0ZXJtcyBvZiBvdGhlcnMuXG4gKi9cblxuY29uc3QgbWFjcm9zID0gX21hY3JvcztcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gbWFjcm8gdG9vbHNcblxuZGVmaW5lTWFjcm8oXCJcXFxcbm9leHBhbmRcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICAvLyBUaGUgZXhwYW5zaW9uIGlzIHRoZSB0b2tlbiBpdHNlbGY7IGJ1dCB0aGF0IHRva2VuIGlzIGludGVycHJldGVkXG4gIC8vIGFzIGlmIGl0cyBtZWFuaW5nIHdlcmUg4oCYXFxyZWxheOKAmSBpZiBpdCBpcyBhIGNvbnRyb2wgc2VxdWVuY2UgdGhhdFxuICAvLyB3b3VsZCBvcmRpbmFyaWx5IGJlIGV4cGFuZGVkIGJ5IFRlWOKAmXMgZXhwYW5zaW9uIHJ1bGVzLlxuICBjb25zdCB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuICBpZiAoY29udGV4dC5pc0V4cGFuZGFibGUodC50ZXh0KSkge1xuICAgIHQubm9leHBhbmQgPSB0cnVlO1xuICAgIHQudHJlYXRBc1JlbGF4ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4geyB0b2tlbnM6IFt0XSwgbnVtQXJnczogMCB9O1xufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGV4cGFuZGFmdGVyXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgLy8gVGVYIGZpcnN0IHJlYWRzIHRoZSB0b2tlbiB0aGF0IGNvbWVzIGltbWVkaWF0ZWx5IGFmdGVyIFxcZXhwYW5kYWZ0ZXIsXG4gIC8vIHdpdGhvdXQgZXhwYW5kaW5nIGl0OyBsZXTigJlzIGNhbGwgdGhpcyB0b2tlbiB0LiBUaGVuIFRlWCByZWFkcyB0aGVcbiAgLy8gdG9rZW4gdGhhdCBjb21lcyBhZnRlciB0IChhbmQgcG9zc2libHkgbW9yZSB0b2tlbnMsIGlmIHRoYXQgdG9rZW5cbiAgLy8gaGFzIGFuIGFyZ3VtZW50KSwgcmVwbGFjaW5nIGl0IGJ5IGl0cyBleHBhbnNpb24uIEZpbmFsbHkgVGVYIHB1dHNcbiAgLy8gdCBiYWNrIGluIGZyb250IG9mIHRoYXQgZXhwYW5zaW9uLlxuICBjb25zdCB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuICBjb250ZXh0LmV4cGFuZE9uY2UodHJ1ZSk7IC8vIGV4cGFuZCBvbmx5IGFuIGV4cGFuZGFibGUgdG9rZW5cbiAgcmV0dXJuIHsgdG9rZW5zOiBbdF0sIG51bUFyZ3M6IDAgfTtcbn0pO1xuXG4vLyBMYVRlWCdzIFxcQGZpcnN0b2Z0d297IzF9eyMyfSBleHBhbmRzIHRvICMxLCBza2lwcGluZyAjMlxuLy8gVGVYIHNvdXJjZTogXFxsb25nXFxkZWZcXEBmaXJzdG9mdHdvIzEjMnsjMX1cbmRlZmluZU1hY3JvKFwiXFxcXEBmaXJzdG9mdHdvXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIHJldHVybiB7IHRva2VuczogYXJnc1swXSwgbnVtQXJnczogMCB9O1xufSk7XG5cbi8vIExhVGVYJ3MgXFxAc2Vjb25kb2Z0d297IzF9eyMyfSBleHBhbmRzIHRvICMyLCBza2lwcGluZyAjMVxuLy8gVGVYIHNvdXJjZTogXFxsb25nXFxkZWZcXEBzZWNvbmRvZnR3byMxIzJ7IzJ9XG5kZWZpbmVNYWNybyhcIlxcXFxAc2Vjb25kb2Z0d29cIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcbiAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzFdLCBudW1BcmdzOiAwIH07XG59KTtcblxuLy8gTGFUZVgncyBcXEBpZm5leHRjaGFyeyMxfXsjMn17IzN9IGxvb2tzIGFoZWFkIHRvIHRoZSBuZXh0ICh1bmV4cGFuZGVkKVxuLy8gc3ltYm9sIHRoYXQgaXNuJ3QgYSBzcGFjZSwgY29uc3VtaW5nIGFueSBzcGFjZXMgYnV0IG5vdCBjb25zdW1pbmcgdGhlXG4vLyBmaXJzdCBub25zcGFjZSBjaGFyYWN0ZXIuICBJZiB0aGF0IG5vbnNwYWNlIGNoYXJhY3RlciBtYXRjaGVzICMxLCB0aGVuXG4vLyB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMjsgb3RoZXJ3aXNlLCBpdCBleHBhbmRzIHRvICMzLlxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmbmV4dGNoYXJcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygzKTsgLy8gc3ltYm9sLCBpZiwgZWxzZVxuICBjb250ZXh0LmNvbnN1bWVTcGFjZXMoKTtcbiAgY29uc3QgbmV4dFRva2VuID0gY29udGV4dC5mdXR1cmUoKTtcbiAgaWYgKGFyZ3NbMF0ubGVuZ3RoID09PSAxICYmIGFyZ3NbMF1bMF0udGV4dCA9PT0gbmV4dFRva2VuLnRleHQpIHtcbiAgICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMV0sIG51bUFyZ3M6IDAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMl0sIG51bUFyZ3M6IDAgfTtcbiAgfVxufSk7XG5cbi8vIExhVGVYJ3MgXFxAaWZzdGFyeyMxfXsjMn0gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpIHN5bWJvbC5cbi8vIElmIGl0IGlzIGAqYCwgdGhlbiBpdCBjb25zdW1lcyB0aGUgc3ltYm9sLCBhbmQgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzE7XG4vLyBvdGhlcndpc2UsIHRoZSBtYWNybyBleHBhbmRzIHRvICMyICh3aXRob3V0IGNvbnN1bWluZyB0aGUgc3ltYm9sKS5cbi8vIFRlWCBzb3VyY2U6IFxcZGVmXFxAaWZzdGFyIzF7XFxAaWZuZXh0Y2hhciAqe1xcQGZpcnN0b2Z0d297IzF9fX1cbmRlZmluZU1hY3JvKFwiXFxcXEBpZnN0YXJcIiwgXCJcXFxcQGlmbmV4dGNoYXIgKntcXFxcQGZpcnN0b2Z0d297IzF9fVwiKTtcblxuLy8gTGFUZVgncyBcXFRleHRPck1hdGh7IzF9eyMyfSBleHBhbmRzIHRvICMxIGluIHRleHQgbW9kZSwgIzIgaW4gbWF0aCBtb2RlXG5kZWZpbmVNYWNybyhcIlxcXFxUZXh0T3JNYXRoXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIGlmIChjb250ZXh0Lm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzBdLCBudW1BcmdzOiAwIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzFdLCBudW1BcmdzOiAwIH07XG4gIH1cbn0pO1xuXG5jb25zdCBzdHJpbmdGcm9tQXJnID0gYXJnID0+IHtcbiAgLy8gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgdGhlIGFyZyBhbmQgcmV0dXJuIGEgc3RyaW5nLlxuICBsZXQgc3RyID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IGFyZy5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHN0ciArPSBhcmdbaV0udGV4dDtcbiAgfVxuICByZXR1cm4gc3RyXG59O1xuXG4vLyBMb29rdXAgdGFibGUgZm9yIHBhcnNpbmcgbnVtYmVycyBpbiBiYXNlIDggdGhyb3VnaCAxNlxuY29uc3QgZGlnaXRUb051bWJlciA9IHtcbiAgMDogMCxcbiAgMTogMSxcbiAgMjogMixcbiAgMzogMyxcbiAgNDogNCxcbiAgNTogNSxcbiAgNjogNixcbiAgNzogNyxcbiAgODogOCxcbiAgOTogOSxcbiAgYTogMTAsXG4gIEE6IDEwLFxuICBiOiAxMSxcbiAgQjogMTEsXG4gIGM6IDEyLFxuICBDOiAxMixcbiAgZDogMTMsXG4gIEQ6IDEzLFxuICBlOiAxNCxcbiAgRTogMTQsXG4gIGY6IDE1LFxuICBGOiAxNVxufTtcblxuY29uc3QgbmV4dENoYXJOdW1iZXIgPSBjb250ZXh0ID0+IHtcbiAgY29uc3QgbnVtU3RyID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuICBpZiAobnVtU3RyID09PSBcIkVPRlwiKSB7IHJldHVybiBbbnVsbCwgXCJcIl0gfVxuICByZXR1cm4gW2RpZ2l0VG9OdW1iZXJbbnVtU3RyLmNoYXJBdCgwKV0sIG51bVN0cl1cbn07XG5cbmNvbnN0IGFwcGVuZENoYXJOdW1iZXJzID0gKG51bWJlciwgbnVtU3RyLCBiYXNlKSA9PiB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGlnaXQgPSBkaWdpdFRvTnVtYmVyW251bVN0ci5jaGFyQXQoaSldO1xuICAgIG51bWJlciAqPSBiYXNlO1xuICAgIG51bWJlciArPSBkaWdpdDtcbiAgfVxuICByZXR1cm4gbnVtYmVyXG59O1xuXG4vLyBUZVggXFxjaGFyIG1ha2VzIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgKGNhdGNvZGUgMTIpIHVzaW5nIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4vLyAoc2VlIFRoZSBUZVhCb29rLCBwLiA0Mylcbi8vICAgXFxjaGFyMTIzICAtLSBkZWNpbWFsXG4vLyAgIFxcY2hhcicxMjMgLS0gb2N0YWxcbi8vICAgXFxjaGFyXCIxMjMgLS0gaGV4XG4vLyAgIFxcY2hhcmB4ICAgLS0gY2hhcmFjdGVyIHRoYXQgY2FuIGJlIHdyaXR0ZW4gKGkuZS4gaXNuJ3QgYWN0aXZlKVxuLy8gICBcXGNoYXJgXFx4ICAtLSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgd3JpdHRlbiAoZS5nLiAlKVxuLy8gVGhlc2UgYWxsIHJlZmVyIHRvIGNoYXJhY3RlcnMgZnJvbSB0aGUgZm9udCwgc28gd2UgdHVybiB0aGVtIGludG8gc3BlY2lhbFxuLy8gY2FsbHMgdG8gYSBmdW5jdGlvbiBcXEBjaGFyIGRlYWx0IHdpdGggaW4gdGhlIFBhcnNlci5cbmRlZmluZU1hY3JvKFwiXFxcXGNoYXJcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBsZXQgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIGxldCBiYXNlO1xuICBsZXQgbnVtYmVyID0gXCJcIjtcbiAgaWYgKHRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgYmFzZSA9IDg7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gJ1wiJykge1xuICAgIGJhc2UgPSAxNjtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSBcImBcIikge1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICAgIGlmICh0b2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDEpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcY2hhcmAgbWlzc2luZyBhcmd1bWVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gMTA7XG4gIH1cbiAgaWYgKGJhc2UpIHtcbiAgICAvLyBQYXJzZSBhIG51bWJlciBpbiB0aGUgZ2l2ZW4gYmFzZSwgc3RhcnRpbmcgd2l0aCBmaXJzdCBgdG9rZW5gLlxuICAgIGxldCBudW1TdHIgPSB0b2tlbi50ZXh0O1xuICAgIG51bWJlciA9IGRpZ2l0VG9OdW1iZXJbbnVtU3RyLmNoYXJBdCgwKV07XG4gICAgaWYgKG51bWJlciA9PSBudWxsIHx8IG51bWJlciA+PSBiYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBiYXNlLSR7YmFzZX0gZGlnaXQgJHt0b2tlbi50ZXh0fWApO1xuICAgIH1cbiAgICBudW1iZXIgPSBhcHBlbmRDaGFyTnVtYmVycyhudW1iZXIsIG51bVN0ciwgYmFzZSk7XG4gICAgbGV0IGRpZ2l0O1xuICAgIFtkaWdpdCwgbnVtU3RyXSA9IG5leHRDaGFyTnVtYmVyKGNvbnRleHQpO1xuICAgIHdoaWxlIChkaWdpdCAhPSBudWxsICYmIGRpZ2l0IDwgYmFzZSkge1xuICAgICAgbnVtYmVyICo9IGJhc2U7XG4gICAgICBudW1iZXIgKz0gZGlnaXQ7XG4gICAgICBudW1iZXIgPSBhcHBlbmRDaGFyTnVtYmVycyhudW1iZXIsIG51bVN0ciwgYmFzZSk7XG4gICAgICBjb250ZXh0LnBvcFRva2VuKCk7XG4gICAgICBbZGlnaXQsIG51bVN0cl0gPSBuZXh0Q2hhck51bWJlcihjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGBcXFxcQGNoYXJ7JHtudW1iZXJ9fWA7XG59KTtcblxuZnVuY3Rpb24gcmVjcmVhdGVBcmdTdHIoY29udGV4dCkge1xuICAvLyBSZWNyZWF0ZSB0aGUgbWFjcm8ncyBvcmlnaW5hbCBhcmd1bWVudCBzdHJpbmcgZnJvbSB0aGUgYXJyYXkgb2YgcGFyc2UgdG9rZW5zLlxuICBjb25zdCB0b2tlbnMgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuICBsZXQgc3RyID0gXCJcIjtcbiAgbGV0IGV4cGVjdGVkTG9jID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5sb2Muc3RhcnQ7XG4gIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBhY3R1YWxMb2MgPSB0b2tlbnNbaV0ubG9jLnN0YXJ0O1xuICAgIGlmIChhY3R1YWxMb2MgPiBleHBlY3RlZExvYykge1xuICAgICAgLy8gY29udGV4dC5jb25zdW1lQXJncyBoYXMgZWF0ZW4gYSBzcGFjZS5cbiAgICAgIHN0ciArPSBcIiBcIjtcbiAgICAgIGV4cGVjdGVkTG9jID0gYWN0dWFsTG9jO1xuICAgIH1cbiAgICBzdHIgKz0gdG9rZW5zW2ldLnRleHQ7XG4gICAgZXhwZWN0ZWRMb2MgKz0gdG9rZW5zW2ldLnRleHQubGVuZ3RoO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuLy8gVGhlIExhdGluIE1vZGVybiBmb250IHJlbmRlcnMgPG1pPuKImjwvbWk+IGF0IHRoZSB3cm9uZyB2ZXJ0aWNhbCBhbGlnbm1lbnQuXG4vLyBUaGlzIG1hY3JvIHByb3ZpZGVzIGEgYmV0dGVyIHJlbmRlcmluZy5cbmRlZmluZU1hY3JvKFwiXFxcXHN1cmRcIiwgJ1xcXFxzcXJ0e1xcXFx2cGhhbnRvbXt8fX0nKTtcblxuLy8gU2VlIGNvbW1lbnQgZm9yIFxcb3BsdXMgaW4gc3ltYm9scy5qcy5cbmRlZmluZU1hY3JvKFwiXFx1MjI5NVwiLCBcIlxcXFxvcGx1c1wiKTtcblxuLy8gU2luY2UgVGVtbWwgaGFzIG5vIFxccGFyLCBpZ25vcmUgXFxsb25nLlxuZGVmaW5lTWFjcm8oXCJcXFxcbG9uZ1wiLCBcIlwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gR3JvdXBpbmdcbi8vIFxcbGV0XFxiZ3JvdXA9eyBcXGxldFxcZWdyb3VwPX1cbmRlZmluZU1hY3JvKFwiXFxcXGJncm91cFwiLCBcIntcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlZ3JvdXBcIiwgXCJ9XCIpO1xuXG4vLyBTeW1ib2xzIGZyb20gbGF0ZXgubHR4OlxuLy8gXFxkZWZ+e1xcbm9icmVha3NwYWNle319XG4vLyBcXGRlZlxcbHF7YH1cbi8vIFxcZGVmXFxycXsnfVxuLy8gXFxkZWYgXFxhYSB7XFxyIGF9XG5kZWZpbmVNYWNybyhcIn5cIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHFcIiwgXCJgXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccnFcIiwgXCInXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWFcIiwgXCJcXFxcciBhXCIpO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxCYmJrXCIsIFwiXFxcXEJiYntrfVwiKTtcblxuLy8gXFxtYXRoc3RydXQgZnJvbSB0aGUgVGVYYm9vaywgcCAzNjBcbmRlZmluZU1hY3JvKFwiXFxcXG1hdGhzdHJ1dFwiLCBcIlxcXFx2cGhhbnRvbXsofVwiKTtcblxuLy8gXFx1bmRlcmJhciBmcm9tIFRlWGJvb2sgcCAzNTNcbmRlZmluZU1hY3JvKFwiXFxcXHVuZGVyYmFyXCIsIFwiXFxcXHVuZGVybGluZXtcXFxcdGV4dHsjMX19XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMYVRlWF8yzrVcblxuLy8gXFx2ZG90c3tcXHZib3h7XFxiYXNlbGluZXNraXA0XFxwQCAgXFxsaW5lc2tpcGxpbWl0XFx6QFxuLy8gXFxrZXJuNlxccEBcXGhib3h7Ln1cXGhib3h7Ln1cXGhib3h7Ln19fVxuLy8gV2UnbGwgY2FsbCBcXHZhcnZkb3RzLCB3aGljaCBnZXRzIGEgZ2x5cGggZnJvbSBzeW1ib2xzLmpzLlxuLy8gVGhlIHplcm8td2lkdGggcnVsZSBnZXRzIHVzIGFuIGVxdWl2YWxlbnQgdG8gdGhlIHZlcnRpY2FsIDZwdCBrZXJuLlxuZGVmaW5lTWFjcm8oXCJcXFxcdmRvdHNcIiwgXCJ7XFxcXHZhcnZkb3RzXFxcXHJ1bGV7MHB0fXsxNXB0fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyZWVcIiwgXCJcXFxcdmRvdHNcIik7XG5cbi8vIHthcnJheX0gZW52aXJvbm1lbnQgZ2Fwc1xuZGVmaW5lTWFjcm8oXCJcXFxcYXJyYXlzdHJldGNoXCIsIFwiMVwiKTsgICAgIC8vIGxpbmUgc3BhY2luZyBmYWN0b3IgdGltZXMgMTJwdFxuZGVmaW5lTWFjcm8oXCJcXFxcYXJyYXljb2xzZXBcIiwgXCI2cHRcIik7ICAgIC8vIGhhbGYgdGhlIHdpZHRoIHNlcGFyYXRpbmcgY29sdW1uc1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhbXNtYXRoLnN0eVxuLy8gaHR0cDovL21pcnJvcnMuY29uY2VydHBhc3MuY29tL3RleC1hcmNoaXZlL21hY3Jvcy9sYXRleC9yZXF1aXJlZC9hbXNtYXRoL2Ftc21hdGgucGRmXG5cbi8vXFxuZXdjb21tYW5ke1xcc3Vic3RhY2t9WzFde1xcc3ViYXJyYXl7Y30jMVxcZW5kc3ViYXJyYXl9XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJzdGFja1wiLCBcIlxcXFxiZWdpbntzdWJhcnJheX17Y30jMVxcXFxlbmR7c3ViYXJyYXl9XCIpO1xuXG4vLyBcXGRlZlxcaWZme1xcRE9UU0JcXDtcXExvbmdsZWZ0cmlnaHRhcnJvd1xcO31cbi8vIFxcZGVmXFxpbXBsaWVze1xcRE9UU0JcXDtcXExvbmdyaWdodGFycm93XFw7fVxuLy8gXFxkZWZcXGltcGxpZWRieXtcXERPVFNCXFw7XFxMb25nbGVmdGFycm93XFw7fVxuZGVmaW5lTWFjcm8oXCJcXFxcaWZmXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ2xlZnRyaWdodGFycm93XFxcXDtcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbXBsaWVzXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ3JpZ2h0YXJyb3dcXFxcO1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltcGxpZWRieVwiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdsZWZ0YXJyb3dcXFxcO1wiKTtcblxuLy8gQU1TTWF0aCdzIGF1dG9tYXRpYyBcXGRvdHMsIGJhc2VkIG9uIFxcbWRvdHNAQCBtYWNyby5cbmNvbnN0IGRvdHNCeVRva2VuID0ge1xuICBcIixcIjogXCJcXFxcZG90c2NcIixcbiAgXCJcXFxcbm90XCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFxca2V5YmluQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gIFwiK1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIj1cIjogXCJcXFxcZG90c2JcIixcbiAgXCI8XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiPlwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIi1cIjogXCJcXFxcZG90c2JcIixcbiAgXCIqXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiOlwiOiBcIlxcXFxkb3RzYlwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTQjpcbiAgXCJcXFxcRE9UU0JcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcY29wcm9kXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3ZlZVwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWd3ZWRnZVwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWd1cGx1c1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdjYXBcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnY3VwXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXHByb2RcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcc3VtXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ290aW1lc1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdvcGx1c1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdvZG90XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3NxY2FwXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3NxY3VwXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3RpbWVzXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXEFuZFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxsb25ncmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxMb25ncmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxsb25nbGVmdGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXExvbmdsZWZ0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcbG9uZ2xlZnRyaWdodGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXExvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxtYXBzdG9cIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcbG9uZ21hcHN0b1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxob29rcmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxkb3RlcVwiOiBcIlxcXFxkb3RzYlwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxtYXRoYmluOlxuICBcIlxcXFxtYXRoYmluXCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXG1hdGhyZWw6XG4gIFwiXFxcXG1hdGhyZWxcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxccmVsYmFyXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXFJlbGJhclwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFx4cmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFx4bGVmdGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNJOlxuICBcIlxcXFxET1RTSVwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpbnRcIjogXCJcXFxcZG90c2lcIixcbiAgXCJcXFxcb2ludFwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXGlpaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXGlpaWludFwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpZG90c2ludFwiOiBcIlxcXFxkb3RzaVwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTWDpcbiAgXCJcXFxcRE9UU1hcIjogXCJcXFxcZG90c3hcIlxufTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIC8vIFRPRE86IElmIHVzZWQgaW4gdGV4dCBtb2RlLCBzaG91bGQgZXhwYW5kIHRvIFxcdGV4dGVsbGlwc2lzLlxuICAvLyBIb3dldmVyLCBpbiBUZW1tbCwgXFx0ZXh0ZWxsaXBzaXMgYW5kIFxcbGRvdHMgYmVoYXZlIHRoZSBzYW1lXG4gIC8vIChpbiB0ZXh0IG1vZGUpLCBhbmQgaXQncyB1bmxpa2VseSB3ZSdkIHNlZSBhbnkgb2YgdGhlIG1hdGggY29tbWFuZHNcbiAgLy8gdGhhdCBhZmZlY3QgdGhlIGJlaGF2aW9yIG9mIFxcZG90cyB3aGVuIGluIHRleHQgbW9kZS4gIFNvIGZpbmUgZm9yIG5vd1xuICAvLyAodW50aWwgd2Ugc3VwcG9ydCBcXGlmbW1vZGUgLi4uIFxcZWxzZSAuLi4gXFxmaSkuXG4gIGxldCB0aGVkb3RzID0gXCJcXFxcZG90c29cIjtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZXhwYW5kQWZ0ZXJGdXR1cmUoKS50ZXh0O1xuICBpZiAobmV4dCBpbiBkb3RzQnlUb2tlbikge1xuICAgIHRoZWRvdHMgPSBkb3RzQnlUb2tlbltuZXh0XTtcbiAgfSBlbHNlIGlmIChuZXh0LnNsaWNlKDAsIDQpID09PSBcIlxcXFxub3RcIikge1xuICAgIHRoZWRvdHMgPSBcIlxcXFxkb3RzYlwiO1xuICB9IGVsc2UgaWYgKG5leHQgaW4gc3ltYm9scy5tYXRoKSB7XG4gICAgaWYgKFtcImJpblwiLCBcInJlbFwiXS5pbmNsdWRlcyhzeW1ib2xzLm1hdGhbbmV4dF0uZ3JvdXApKSB7XG4gICAgICB0aGVkb3RzID0gXCJcXFxcZG90c2JcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoZWRvdHM7XG59KTtcblxuY29uc3Qgc3BhY2VBZnRlckRvdHMgPSB7XG4gIC8vIFxccmlnaHRkZWxpbUAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICBcIilcIjogdHJ1ZSxcbiAgXCJdXCI6IHRydWUsXG4gIFwiXFxcXHJicmFja1wiOiB0cnVlLFxuICBcIlxcXFx9XCI6IHRydWUsXG4gIFwiXFxcXHJicmFjZVwiOiB0cnVlLFxuICBcIlxcXFxyYW5nbGVcIjogdHJ1ZSxcbiAgXCJcXFxccmNlaWxcIjogdHJ1ZSxcbiAgXCJcXFxccmZsb29yXCI6IHRydWUsXG4gIFwiXFxcXHJncm91cFwiOiB0cnVlLFxuICBcIlxcXFxybW91c3RhY2hlXCI6IHRydWUsXG4gIFwiXFxcXHJpZ2h0XCI6IHRydWUsXG4gIFwiXFxcXGJpZ3JcIjogdHJ1ZSxcbiAgXCJcXFxcYmlnZ3JcIjogdHJ1ZSxcbiAgXCJcXFxcQmlnclwiOiB0cnVlLFxuICBcIlxcXFxCaWdnclwiOiB0cnVlLFxuICAvLyBcXGV4dHJhQCBhbHNvIHRlc3RzIGZvciB0aGUgZm9sbG93aW5nOlxuICAkOiB0cnVlLFxuICAvLyBcXGV4dHJhcEAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICBcIjtcIjogdHJ1ZSxcbiAgXCIuXCI6IHRydWUsXG4gIFwiLFwiOiB0cnVlXG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3Rzb1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNjXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcbiAgLy8gXFxkb3RzYyB1c2VzIFxcZXh0cmFAIGJ1dCBub3QgXFxleHRyYXBALCBpbnN0ZWFkIHNwZWNpYWxseSBjaGVja2luZyBmb3JcbiAgLy8gJzsnIGFuZCAnLicsIGJ1dCBkb2Vzbid0IGNoZWNrIGZvciAnLCcuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzICYmIG5leHQgIT09IFwiLFwiKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNkb3RzXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXCI7XG4gIH1cbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzYlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNtXCIsIFwiXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2lcIiwgXCJcXFxcIVxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlkb3RzaW50XCIsIFwiXFxcXGRvdHNpXCIpO1xuLy8gYW1zbWF0aCBkb2Vzbid0IGFjdHVhbGx5IGRlZmluZSBcXGRvdHN4LCBidXQgXFxkb3RzIGZvbGxvd2VkIGJ5IGEgbWFjcm9cbi8vIHN0YXJ0aW5nIHdpdGggXFxET1RTWCBpbXBsaWVzIFxcZG90c28sIGFuZCB0aGVuIFxcZXh0cmFAIGRldGVjdHMgdGhpcyBjYXNlXG4vLyBhbmQgZm9yY2VzIHRoZSBhZGRlZCBgXFwsYC5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHN4XCIsIFwiXFxcXGxkb3RzXFxcXCxcIik7XG5cbi8vIFxcbGV0XFxET1RTSVxccmVsYXhcbi8vIFxcbGV0XFxET1RTQlxccmVsYXhcbi8vIFxcbGV0XFxET1RTWFxccmVsYXhcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNJXCIsIFwiXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU0JcIiwgXCJcXFxccmVsYXhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxET1RTWFwiLCBcIlxcXFxyZWxheFwiKTtcblxuLy8gU3BhY2luZywgYmFzZWQgb24gYW1zbWF0aC5zdHkncyBvdmVycmlkZSBvZiBMYVRlWCBkZWZhdWx0c1xuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXHRtc3BhY2V9WzNdeyVcbi8vICAgXFxpZm1tb2RlXFxtc2tpcCMxIzJcXGVsc2VcXGtlcm4jMSMzXFxmaVxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFx0bXNwYWNlXCIsIFwiXFxcXFRleHRPck1hdGh7XFxcXGtlcm4jMSMzfXtcXFxcbXNraXAjMSMyfVxcXFxyZWxheFwiKTtcbi8vIFxccmVuZXdjb21tYW5ke1xcLH17XFx0bXNwYWNlK1xcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuZGVmaW5lTWFjcm8oXCJcXFxcLFwiLCBcIntcXFxcdG1zcGFjZSt7M211fXsuMTY2N2VtfX1cIik7XG4vLyBcXGxldFxcdGhpbnNwYWNlXFwsXG5kZWZpbmVNYWNybyhcIlxcXFx0aGluc3BhY2VcIiwgXCJcXFxcLFwiKTtcbi8vIFxcZGVmXFw+e1xcbXNraXBcXG1lZG11c2tpcH1cbi8vIFxccmVuZXdjb21tYW5ke1xcOn17XFx0bXNwYWNlK1xcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogXFw+IGFuZCBtYXRoIG1vZGUgb2YgXFw6IHNob3VsZCB1c2UgXFxtZWRtdXNraXAgPSA0bXUgcGx1cyAybXUgbWludXMgNG11XG5kZWZpbmVNYWNybyhcIlxcXFw+XCIsIFwiXFxcXG1za2lwezRtdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFw6XCIsIFwie1xcXFx0bXNwYWNlK3s0bXV9ey4yMjIyZW19fVwiKTtcbi8vIFxcbGV0XFxtZWRzcGFjZVxcOlxuZGVmaW5lTWFjcm8oXCJcXFxcbWVkc3BhY2VcIiwgXCJcXFxcOlwiKTtcbi8vIFxccmVuZXdjb21tYW5ke1xcO317XFx0bXNwYWNlK1xcdGhpY2ttdXNraXB7LjI3NzdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaWNrbXVza2lwID0gNW11IHBsdXMgNW11XG5kZWZpbmVNYWNybyhcIlxcXFw7XCIsIFwie1xcXFx0bXNwYWNlK3s1bXV9ey4yNzc3ZW19fVwiKTtcbi8vIFxcbGV0XFx0aGlja3NwYWNlXFw7XG5kZWZpbmVNYWNybyhcIlxcXFx0aGlja3NwYWNlXCIsIFwiXFxcXDtcIik7XG4vLyBcXHJlbmV3Y29tbWFuZHtcXCF9e1xcdG1zcGFjZS1cXHRoaW5tdXNraXB7LjE2NjdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaW5tdXNraXBcbmRlZmluZU1hY3JvKFwiXFxcXCFcIiwgXCJ7XFxcXHRtc3BhY2UtezNtdX17LjE2NjdlbX19XCIpO1xuLy8gXFxsZXRcXG5lZ3RoaW5zcGFjZVxcIVxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpbnNwYWNlXCIsIFwiXFxcXCFcIik7XG4vLyBcXG5ld2NvbW1hbmR7XFxuZWdtZWRzcGFjZX17XFx0bXNwYWNlLVxcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFxtZWRtdXNraXBcbmRlZmluZU1hY3JvKFwiXFxcXG5lZ21lZHNwYWNlXCIsIFwie1xcXFx0bXNwYWNlLXs0bXV9ey4yMjIyZW19fVwiKTtcbi8vIFxcbmV3Y29tbWFuZHtcXG5lZ3RoaWNrc3BhY2V9e1xcdG1zcGFjZS1cXHRoaWNrbXVza2lwey4yNzc3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlja211c2tpcFxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpY2tzcGFjZVwiLCBcIntcXFxcdG1zcGFjZS17NW11fXsuMjc3ZW19fVwiKTtcbi8vIFxcZGVmXFxlbnNwYWNle1xca2Vybi41ZW0gfVxuZGVmaW5lTWFjcm8oXCJcXFxcZW5zcGFjZVwiLCBcIlxcXFxrZXJuLjVlbSBcIik7XG4vLyBcXGRlZlxcZW5za2lwe1xcaHNraXAuNWVtXFxyZWxheH1cbmRlZmluZU1hY3JvKFwiXFxcXGVuc2tpcFwiLCBcIlxcXFxoc2tpcC41ZW1cXFxccmVsYXhcIik7XG4vLyBcXGRlZlxccXVhZHtcXGhza2lwMWVtXFxyZWxheH1cbmRlZmluZU1hY3JvKFwiXFxcXHF1YWRcIiwgXCJcXFxcaHNraXAxZW1cXFxccmVsYXhcIik7XG4vLyBcXGRlZlxccXF1YWR7XFxoc2tpcDJlbVxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFxxcXVhZFwiLCBcIlxcXFxoc2tpcDJlbVxcXFxyZWxheFwiKTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcQUFcIiwgXCJcXFxcVGV4dE9yTWF0aHtcXFxcQW5nc3Ryb219e1xcXFxtYXRocmluZ3tBfX1cXFxccmVsYXhcIik7XG5cbi8vIFxcdGFnQGluQGRpc3BsYXkgZm9ybSBvZiBcXHRhZ1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnXCIsIFwiXFxcXEBpZnN0YXJcXFxcdGFnQGxpdGVyYWxcXFxcdGFnQHBhcmVuXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQHBhcmVuXCIsIFwiXFxcXHRhZ0BsaXRlcmFseyh7IzF9KX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0YWdAbGl0ZXJhbFwiLCAoY29udGV4dCkgPT4ge1xuICBpZiAoY29udGV4dC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTXVsdGlwbGUgXFxcXHRhZ1wiKTtcbiAgfVxuICByZXR1cm4gXCJcXFxcZ2RlZlxcXFxkZkB0YWd7XFxcXHRleHR7IzF9fVwiO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxub3RhZ1wiLCBcIlxcXFxub251bWJlclwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vbnVtYmVyXCIsIFwiXFxcXGdkZWZcXFxcQGVxbnN3ezB9XCIpO1xuXG4vLyBcXHJlbmV3Y29tbWFuZHtcXGJtb2R9e1xcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXVcXG1hdGhiaW5cbi8vICAge1xcb3BlcmF0b3JAZm9udCBtb2R9XFxwZW5hbHR5OTAwXG4vLyAgIFxcbWtlcm41bXVcXG5vbnNjcmlwdFxcbXNraXAtXFxtZWRtdXNraXB9XG4vLyBcXG5ld2NvbW1hbmR7XFxwb2R9WzFde1xcYWxsb3dicmVha1xuLy8gICBcXGlmQGRpc3BsYXlcXG1rZXJuMThtdVxcZWxzZVxcbWtlcm44bXVcXGZpKCMxKX1cbi8vIFxccmVuZXdjb21tYW5ke1xccG1vZH1bMV17XFxwb2R7e1xcb3BlcmF0b3JAZm9udCBtb2R9XFxta2VybjZtdSMxfX1cbi8vIFxcbmV3Y29tbWFuZHtcXG1vZH1bMV17XFxhbGxvd2JyZWFrXFxpZkBkaXNwbGF5XFxta2VybjE4bXVcbi8vICAgXFxlbHNlXFxta2VybjEybXVcXGZpe1xcb3BlcmF0b3JAZm9udCBtb2R9XFwsXFwsIzF9XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcbmRlZmluZU1hY3JvKFwiXFxcXGJtb2RcIiwgXCJcXFxcbWF0aGJpbntcXFxcdGV4dHttb2R9fVwiKTtcbmRlZmluZU1hY3JvKFxuICBcIlxcXFxwb2RcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4xOG11fXtcXFxcbWtlcm44bXV9e1xcXFxta2VybjhtdX17XFxcXG1rZXJuOG11fSgjMSlcIlxuKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBtb2RcIiwgXCJcXFxccG9ke3tcXFxccm0gbW9kfVxcXFxta2VybjZtdSMxfVwiKTtcbmRlZmluZU1hY3JvKFxuICBcIlxcXFxtb2RcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiICtcbiAgICBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2VybjE4bXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9XCIgK1xuICAgIFwie1xcXFxybSBtb2R9XFxcXCxcXFxcLCMxXCJcbik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExhVGVYIHNvdXJjZTJlXG5cbi8vIFxcZXhwYW5kYWZ0ZXJcXGxldFxcZXhwYW5kYWZ0ZXJcXEBub3JtYWxjclxuLy8gICAgIFxcY3NuYW1lXFxleHBhbmRhZnRlclxcQGdvYmJsZVxcc3RyaW5nXFxcXCBcXGVuZGNzbmFtZVxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcbmV3bGluZXtcXEBub3JtYWxjclxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFxuZXdsaW5lXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG5cbi8vIFxcZGVmXFxUZVh7VFxca2Vybi0uMTY2N2VtXFxsb3dlci41ZXhcXGhib3h7RX1cXGtlcm4tLjEyNWVtWFxcQH1cbi8vIFRPRE86IERvZXNuJ3Qgbm9ybWFsbHkgd29yayBpbiBtYXRoIG1vZGUgYmVjYXVzZSBcXEAgZmFpbHMuXG5kZWZpbmVNYWNybyhcIlxcXFxUZVhcIiwgXCJcXFxcdGV4dHJte1R9XFxcXGtlcm4tLjE2NjdlbVxcXFxyYWlzZWJveHstLjVleH17RX1cXFxca2Vybi0uMTI1ZW1cXFxcdGV4dHJte1h9XCIpO1xuXG5kZWZpbmVNYWNybyhcbiAgXCJcXFxcTGFUZVhcIixcbiAgICBcIlxcXFx0ZXh0cm17TH1cXFxca2Vybi0uMzVlbVxcXFxyYWlzZWJveHswLjJlbX17XFxcXHNjcmlwdHN0eWxlIEF9XFxcXGtlcm4tLjE1ZW1cXFxcVGVYXCJcbik7XG5cbmRlZmluZU1hY3JvKFxuICBcIlxcXFxUZW1tbFwiLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBcIlxcXFx0ZXh0cm17VH1cXFxca2Vybi0wLjJlbVxcXFxsb3dlcnswLjJlbX17XFxcXHRleHRybXtFfX1cXFxca2Vybi0wLjA4ZW17XFxcXHRleHRybXtNfVxcXFxrZXJuLTAuMDhlbVxcXFxyYWlzZXswLjJlbX1cXFxcdGV4dHJte019XFxcXGtlcm4tMC4wOGVtXFxcXHRleHRybXtMfX1cIlxuKTtcblxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcaHNwYWNle1xcQGlmc3RhclxcQGhzcGFjZXJcXEBoc3BhY2V9XG4vLyBcXGRlZlxcQGhzcGFjZSMxe1xcaHNraXAgICMxXFxyZWxheH1cbi8vIFxcZGVmXFxAaHNwYWNlciMxe1xcdnJ1bGUgXFxAd2lkdGhcXHpAXFxub2JyZWFrXG4vLyAgICAgICAgICAgICAgICAgXFxoc2tpcCAjMVxcaHNraXAgXFx6QHNraXB9XG5kZWZpbmVNYWNybyhcIlxcXFxoc3BhY2VcIiwgXCJcXFxcQGlmc3RhclxcXFxAaHNwYWNlclxcXFxAaHNwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZVwiLCBcIlxcXFxoc2tpcCAjMVxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEBoc3BhY2VyXCIsIFwiXFxcXHJ1bGV7MHB0fXswcHR9XFxcXGhza2lwICMxXFxcXHJlbGF4XCIpO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvblwiLCBgXFxcXG1hdGhwdW5jdHtcXFxcY2hhclwiM2F9YCk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIG1hdGh0b29scy5zdHlcblxuZGVmaW5lTWFjcm8oXCJcXFxccHJlc2NyaXB0XCIsIFwiXFxcXHByZXNAY3JpcHR7X3sjMX1eeyMyfX17fXsjM31cIik7XG5cbi8vXFxwcm92aWRlY29tbWFuZFxcb3JkaW5hcnljb2xvbns6fVxuZGVmaW5lTWFjcm8oXCJcXFxcb3JkaW5hcnljb2xvblwiLCBgXFxcXGNoYXJcIjNhYCk7XG4vLyBSYWlzZSB0byBjZW50ZXIgb24gdGhlIG1hdGggYXhpcywgYXMgY2xvc2VseSBhcyBwb3NzaWJsZS5cbmRlZmluZU1hY3JvKFwiXFxcXHZjZW50Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxccmFpc2Vib3h7MC4wMzVlbX17XFxcXG9yZGluYXJ5Y29sb259fVwiKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbmVxe1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcbWF0aHJlbHstfX1cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uZXFcIiwgJ1xcXFxtYXRocmVse1xcXFxyYWlzZWJveHswLjAzNWVtfXtcXFxcb3JkaW5hcnljb2xvbn1cXFxcY2hhclwiMjIxMn0nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbmVxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXG1hdGhyZWx7LX19XG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxXCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjIzN1xcXFxjaGFyXCIyMjEyfScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxcWNvbG9uez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuZGVmaW5lTWFjcm8oXCJcXFxcRXFxY29sb25cIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIzZFxcXFxjaGFyXCIyMjM3fScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn1cbmRlZmluZU1hY3JvKFwiXFxcXEVxY29sb25cIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIyMjEyXFxcXGNoYXJcIjIyMzd9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25hcHByb3h7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmFwcHJveFwiLCAnXFxcXG1hdGhyZWx7XFxcXHJhaXNlYm94ezAuMDM1ZW19e1xcXFxvcmRpbmFyeWNvbG9ufVxcXFxjaGFyXCIyMjQ4fScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uYXBwcm94e1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGFwcHJveH1cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uYXBwcm94XCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjIzN1xcXFxjaGFyXCIyMjQ4fScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uc2lte1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcc2ltfVxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25zaW1cIiwgJ1xcXFxtYXRocmVse1xcXFxyYWlzZWJveHswLjAzNWVtfXtcXFxcb3JkaW5hcnljb2xvbn1cXFxcY2hhclwiMjIzY30nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbnNpbXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbnNpbVwiLCAnXFxcXG1hdGhyZWx7XFxcXHJhaXNlYm94ezAuMDM1ZW19e1xcXFxvcmRpbmFyeWNvbG9ufVxcXFxjaGFyXCIyMjNjfScpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjb2xvbmVxdWFscy5zdHlcblxuLy8gQWx0ZXJuYXRlIG5hbWVzIGZvciBtYXRodG9vbHMncyBtYWNyb3M6XG5kZWZpbmVNYWNybyhcIlxcXFxyYXRpb1wiLCBcIlxcXFx2Y2VudGNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvblwiLCBcIlxcXFxkYmxjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uZXF1YWxzXCIsIFwiXFxcXGNvbG9uZXFxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmVxdWFsc1wiLCBcIlxcXFxDb2xvbmVxcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVxdWFsc2NvbG9uXCIsIFwiXFxcXGVxcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXF1YWxzY29sb25jb2xvblwiLCBcIlxcXFxFcXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9ubWludXNcIiwgXCJcXFxcY29sb25lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25taW51c1wiLCBcIlxcXFxDb2xvbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludXNjb2xvblwiLCBcIlxcXFxlcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludXNjb2xvbmNvbG9uXCIsIFwiXFxcXEVxY29sb25cIik7XG4vLyBcXGNvbG9uYXBwcm94IG5hbWUgaXMgc2FtZSBpbiBtYXRodG9vbHMgYW5kIGNvbG9uZXF1YWxzLlxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmFwcHJveFwiLCBcIlxcXFxDb2xvbmFwcHJveFwiKTtcbi8vIFxcY29sb25zaW0gbmFtZSBpcyBzYW1lIGluIG1hdGh0b29scyBhbmQgY29sb25lcXVhbHMuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uc2ltXCIsIFwiXFxcXENvbG9uc2ltXCIpO1xuXG4vLyBQcmVzZW50IGluIG5ld3R4bWF0aCwgcHhmb250cyBhbmQgdHhmb250c1xuZGVmaW5lTWFjcm8oXCJcXFxcbm90bmlcIiwgXCJcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjBDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsc3VwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbWluZlwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsaW5mfVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRnJvbSBhbXNvcG4uc3R5XG5kZWZpbmVNYWNybyhcIlxcXFxpbmpsaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntpbmpcXFxcLGxpbX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwcm9qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7cHJvalxcXFwsbGltfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFxvdmVybGluZXtcXFxcdGV4dHtsaW19fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJsaW1pbmZcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJsaW5le1xcXFx0ZXh0e2xpbX19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmluamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFx1bmRlcnJpZ2h0YXJyb3d7XFxcXHRleHR7bGltfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFycHJvamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFx1bmRlcmxlZnRhcnJvd3tcXFxcdGV4dHtsaW19fX1cIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNlbnRlcmRvdFwiLCBcIntcXFxcbWVkc3BhY2VcXFxccnVsZXswLjE2N2VtfXswLjE4OWVtfVxcXFxtZWRzcGFjZX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHN0YXRtYXRoLnN0eVxuLy8gaHR0cHM6Ly9jdGFuLm1hdGguaWxsaW5vaXMuZWR1L21hY3Jvcy9sYXRleC9jb250cmliL3N0YXRtYXRoL3N0YXRtYXRoLnBkZlxuXG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtaW5cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1pbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtYXhcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1heH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7cGxpbX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1uU3ltYm9sLnN0eVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsZWZ0bW9kZWxzXCIsIFwiXFxcXG1hdGhvcHtcXFxccmVmbGVjdGJveHskXFxcXG1vZGVscyR9fVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYnJha2V0LnN0eVxuLy8gaHR0cDovL2N0YW4ubWF0aC53YXNoaW5ndG9uLmVkdS90ZXgtYXJjaGl2ZS9tYWNyb3MvbGF0ZXgvY29udHJpYi9icmFrZXQvYnJha2V0LnBkZlxuXG5kZWZpbmVNYWNybyhcIlxcXFxicmFcIiwgXCJcXFxcbWF0aGlubmVye1xcXFxsYW5nbGV7IzF9fH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxrZXRcIiwgXCJcXFxcbWF0aGlubmVye3x7IzF9XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxicmFrZXRcIiwgXCJcXFxcbWF0aGlubmVye1xcXFxsYW5nbGV7IzF9XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxCcmFcIiwgXCJcXFxcbGVmdFxcXFxsYW5nbGUjMVxcXFxyaWdodHxcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxLZXRcIiwgXCJcXFxcbGVmdHwjMVxcXFxyaWdodFxcXFxyYW5nbGVcIik7XG4vLyBBIGhlbHBlciBmb3IgXFxCcmFrZXQgYW5kIFxcU2V0XG5jb25zdCByZXBsYWNlVmVydCA9IChhcmdTdHIsIG1hdGNoKSA9PiB7XG4gIGNvbnN0IGNoID0gbWF0Y2hbMF0gPT09IFwifFwiID8gXCJcXFxcdmVydFwiIDogXCJcXFxcVmVydFwiO1xuICBjb25zdCByZXBsYWNlU3RyID0gYH1cXFxcLFxcXFxtaWRkbGUke2NofVxcXFwse2A7XG4gIHJldHVybiBhcmdTdHIuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgcmVwbGFjZVN0ciArIGFyZ1N0ci5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aClcbn07XG5kZWZpbmVNYWNybyhcIlxcXFxCcmFrZXRcIiwgIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgbGV0IGFyZ1N0ciA9IHJlY3JlYXRlQXJnU3RyKGNvbnRleHQpO1xuICBjb25zdCByZWdFeCA9IC9cXHxcXHx8XFx8fFxcXFxcXHwvZztcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gcmVnRXguZXhlYyhhcmdTdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyZ1N0ciA9IHJlcGxhY2VWZXJ0KGFyZ1N0ciwgbWF0Y2gpO1xuICB9XG4gIHJldHVybiBcIlxcXFxsZWZ0XFxcXGxhbmdsZXtcIiArIGFyZ1N0ciArIFwifVxcXFxyaWdodFxcXFxyYW5nbGVcIlxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxTZXRcIiwgIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgbGV0IGFyZ1N0ciA9IHJlY3JlYXRlQXJnU3RyKGNvbnRleHQpO1xuICBjb25zdCBtYXRjaCA9IC9cXHxcXHx8XFx8fFxcXFxcXHwvLmV4ZWMoYXJnU3RyKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgYXJnU3RyID0gcmVwbGFjZVZlcnQoYXJnU3RyLCBtYXRjaCk7XG4gIH1cbiAgcmV0dXJuIFwiXFxcXGxlZnRcXFxce1xcXFw6e1wiICsgYXJnU3RyICsgXCJ9XFxcXDpcXFxccmlnaHRcXFxcfVwiXG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXHNldFwiLCAgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdTdHIgPSByZWNyZWF0ZUFyZ1N0cihjb250ZXh0KTtcbiAgcmV0dXJuIFwiXFxcXHt7XCIgKyBhcmdTdHIucmVwbGFjZSgvXFx8LywgXCJ9XFxcXG1pZHtcIikgKyBcIn1cXFxcfVwiXG59KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYWN0dWFyaWFsYW5nbGUuZHR4XG5kZWZpbmVNYWNybyhcIlxcXFxhbmdsblwiLCBcIntcXFxcYW5nbCBufVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gZGVyaXZhdGl2ZS5zdHlcbmRlZmluZU1hY3JvKFwiXFxcXG9kdlwiLCBcIlxcXFxAaWZzdGFyXFxcXG9kdkBuZXh0XFxcXG9kdkBudW1lcmF0b3JcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxvZHZAbnVtZXJhdG9yXCIsIFwiXFxcXGZyYWN7XFxcXG1hdGhybXtkfSMxfXtcXFxcbWF0aHJte2R9IzJ9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb2R2QG5leHRcIiwgXCJcXFxcZnJhY3tcXFxcbWF0aHJte2R9fXtcXFxcbWF0aHJte2R9IzJ9IzFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwZHZcIiwgXCJcXFxcQGlmc3RhclxcXFxwZHZAbmV4dFxcXFxwZHZAbnVtZXJhdG9yXCIpO1xuXG5jb25zdCBwZHZIZWxwZXIgPSBhcmdzID0+IHtcbiAgY29uc3QgbnVtZXJhdG9yID0gYXJnc1swXVswXS50ZXh0O1xuICBjb25zdCBkZW5vbXMgPSBzdHJpbmdGcm9tQXJnKGFyZ3NbMV0pLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgcG93ZXIgPSBTdHJpbmcoZGVub21zLmxlbmd0aCk7XG4gIGNvbnN0IG51bU9wID0gcG93ZXIgPT09IFwiMVwiID8gXCJcXFxccGFydGlhbFwiIDogYFxcXFxwYXJ0aWFsXiR7cG93ZXJ9YDtcbiAgbGV0IGRlbm9taW5hdG9yID0gXCJcIjtcbiAgZGVub21zLm1hcChlID0+IHsgZGVub21pbmF0b3IgKz0gXCJcXFxccGFydGlhbCBcIiArIGUudHJpbSgpICsgIFwiXFxcXCxcIjt9KTtcbiAgcmV0dXJuIFtudW1lcmF0b3IsIG51bU9wLCAgZGVub21pbmF0b3IucmVwbGFjZSgvXFxcXCwkLywgXCJcIildXG59O1xuZGVmaW5lTWFjcm8oXCJcXFxccGR2QG51bWVyYXRvclwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IFtudW1lcmF0b3IsIG51bU9wLCBkZW5vbWluYXRvcl0gPSBwZHZIZWxwZXIoY29udGV4dC5jb25zdW1lQXJncygyKSk7XG4gIHJldHVybiBgXFxcXGZyYWN7JHtudW1PcH0gJHtudW1lcmF0b3J9fXske2Rlbm9taW5hdG9yfX1gXG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXHBkdkBuZXh0XCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgW251bWVyYXRvciwgbnVtT3AsIGRlbm9taW5hdG9yXSA9IHBkdkhlbHBlcihjb250ZXh0LmNvbnN1bWVBcmdzKDIpKTtcbiAgcmV0dXJuIGBcXFxcZnJhY3ske251bU9wfX17JHtkZW5vbWluYXRvcn19ICR7bnVtZXJhdG9yfWBcbn0pO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB1cGdyZWVrLmR0eFxuZGVmaW5lTWFjcm8oXCJcXFxcdXBhbHBoYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcYWxwaGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBiZXRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxiZXRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwZ2FtbWFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGdhbW1hfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwZGVsdGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGRlbHRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwZXBzaWxvblwiLCBcIlxcXFx1cEBncmVla3tcXFxcZXBzaWxvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHpldGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHpldGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBldGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHRoZXRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFx0aGV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGlvdGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGlvdGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBrYXBwYVwiLCBcIlxcXFx1cEBncmVla3tcXFxca2FwcGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBsYW1iZGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGxhbWJkYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG11XCIsIFwiXFxcXHVwQGdyZWVre1xcXFxtdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG51XCIsIFwiXFxcXHVwQGdyZWVre1xcXFxudX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHhpXCIsIFwiXFxcXHVwQGdyZWVre1xcXFx4aX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG9taWNyb25cIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXG9taWNyb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBwaVwiLCBcIlxcXFx1cEBncmVla3tcXFxccGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBhbHBoYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcYWxwaGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXByaG9cIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHJob31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHNpZ21hXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxzaWdtYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHRhdVwiLCBcIlxcXFx1cEBncmVla3tcXFxcdGF1fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwdXBzaWxvblwiLCBcIlxcXFx1cEBncmVla3tcXFxcdXBzaWxvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHBoaVwiLCBcIlxcXFx1cEBncmVla3tcXFxccGhpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwY2hpXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxjaGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBwc2lcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHBzaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG9tZWdhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxvbWVnYX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNtbGwgcGFja2FnZVxuZGVmaW5lTWFjcm8oXCJcXFxcaW52YW1wXCIsICdcXFxcbWF0aGJpbntcXFxcY2hhclwiMjE0Yn0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBhcnJcIiwgJ1xcXFxtYXRoYmlue1xcXFxjaGFyXCIyMTRifScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcd2l0aFwiLCAnXFxcXG1hdGhiaW57XFxcXGNoYXJcIjI2fScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbXVsdGltYXBpbnZcIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIyN2RjfScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbXVsdGltYXBib3RoXCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjlkZn0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNjb2hcIiwgJ3tcXFxcbWtlcm41bXVcXFxcY2hhclwiMjMyMlxcXFxta2VybjVtdX0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNpbmNvaFwiLCAne1xcXFxta2VybjVtdVxcXFxjaGFyXCIyMzIzXFxcXG1rZXJuNW11fScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29oXCIsIGB7XFxcXG1rZXJuNW11XFxcXHJ1bGV7fXswLjdlbX1cXFxcbWF0aHJsYXB7XFxcXHNtYXNoe1xcXFxyYWlzZTJtdXtcXFxcY2hhclwiMjMyMn19fVxue1xcXFxzbWFzaHtcXFxcbG93ZXI0bXV7XFxcXGNoYXJcIjIzMjN9fX1cXFxcbWtlcm41bXV9YCk7XG5kZWZpbmVNYWNybyhcIlxcXFxpbmNvaFwiLCBge1xcXFxta2VybjVtdVxcXFxydWxle317MC43ZW19XFxcXG1hdGhybGFwe1xcXFxzbWFzaHtcXFxccmFpc2UybXV7XFxcXGNoYXJcIjIzMjN9fX1cbntcXFxcc21hc2h7XFxcXGxvd2VyNG11e1xcXFxjaGFyXCIyMzIyfX19XFxcXG1rZXJuNW11fWApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNoZW1zdHlsZSBwYWNrYWdlXG5kZWZpbmVNYWNybyhcIlxcXFxzdGFuZGFyZHN0YXRlXCIsIFwiXFxcXHRleHR7XFxcXHRpbnlcXFxcY2hhcmDiprV9XCIpO1xuXG7vu78vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyogLSotIE1vZGU6IEphdmFTY3JpcHQ7IGluZGVudC10YWJzLW1vZGU6bmlsOyBqcy1pbmRlbnQtbGV2ZWw6IDIgLSotICovXG4vKiB2aW06IHNldCB0cz0yIGV0IHN3PTIgdHc9ODA6ICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogIFRlbW1sIG1oY2hlbS5qc1xuICpcbiAqICBUaGlzIGZpbGUgaW1wbGVtZW50cyBhIFRlbW1sIHZlcnNpb24gb2YgbWhjaGVtIHZlcnNpb24gMy4zLjAuXG4gKiAgSXQgaXMgYWRhcHRlZCBmcm9tIE1hdGhKYXgvZXh0ZW5zaW9ucy9UZVgvbWhjaGVtLmpzXG4gKiAgSXQgZGlmZmVycyBmcm9tIHRoZSBNYXRoSmF4IHZlcnNpb24gYXMgZm9sbG93czpcbiAqICAgIDEuIFRoZSBpbnRlcmZhY2UgaXMgY2hhbmdlZCBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBUZW1tbCwgbm90IE1hdGhKYXguXG4gKiAgICAyLiBcXHJsYXAgYW5kIFxcbGxhcCBhcmUgcmVwbGFjZWQgd2l0aCBcXG1hdGhybGFwIGFuZCBcXG1hdGhsbGFwLlxuICogICAgMy4gVGhlIHJlYWN0aW9uIGFycm93IGNvZGUgaXMgc2ltcGxpZmllZC4gQWxsIHJlYWN0aW9uIGFycm93cyBhcmUgcmVuZGVyZWRcbiAqICAgICAgIHVzaW5nIFRlbW1sIGV4dGVuc2libGUgYXJyb3dzIGluc3RlYWQgb2YgYnVpbGRpbmcgbm9uLWV4dGVuc2libGUgYXJyb3dzLlxuICogICAgNC4gVGhlIH5ib25kIGZvcm1zIGFyZSBjb21wb3NlZCBlbnRpcmVseSBvZiBcXHJ1bGUgZWxlbWVudHMuXG4gKiAgICA1LiBUd28gZGFzaGVzIGluIF9nZXRCb25kIGFyZSB3cmFwcGVkIGluIGJyYWNlcyB0byBzdXBwcmVzcyBzcGFjaW5nLiBpLmUuLCB7LX1cbiAqICAgIDYuIFRoZSBlbGVjdHJvbiBkb3QgdXNlcyBcXHRleHRidWxsZXQgaW5zdGVhZCBvZiBcXGJ1bGxldC5cbiAqICAgIDcuIFxcc21hc2hbVF0gaGFzIGJlZW4gcmVtb3ZlZC4gKFdlYktpdCBoaWRlcyBhbnl0aGluZyBpbnNpZGUgXFxzbWFzaHvigKZ9KVxuICpcbiAqICAgIFRoaXMgY29kZSwgYXMgb3RoZXIgVGVtbWwgY29kZSwgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogXG4gKiAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcbiAqICBNYXRoSmF4L2V4dGVuc2lvbnMvVGVYL21oY2hlbS5qc1xuICpcbiAqICBJbXBsZW1lbnRzIHRoZSBcXGNlIGNvbW1hbmQgZm9yIGhhbmRsaW5nIGNoZW1pY2FsIGZvcm11bGFzXG4gKiAgZnJvbSB0aGUgbWhjaGVtIExhVGVYIHBhY2thZ2UuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNSBUaGUgTWF0aEpheCBDb25zb3J0aXVtXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE1LTIwMTggTWFydGluIEhlbnNlbFxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vL1xuLy8gQ29kaW5nIFN0eWxlXG4vLyAgIC0gdXNlICcnIGZvciBpZGVudGlmaWVycyB0aGF0IGNhbiBieSBtaW5pZmllZC91Z2xpZmllZFxuLy8gICAtIHVzZSBcIlwiIGZvciBzdHJpbmdzIHRoYXQgbmVlZCB0byBzdGF5IHVudG91Y2hlZFxuXG4vLyB2ZXJzaW9uOiBcIjMuMy4wXCIgZm9yIE1hdGhKYXggYW5kIFRlbW1sXG5cblxuLy8gQWRkIFxcY2UsIFxccHUsIGFuZCBcXHRyaXBsZURhc2ggdG8gdGhlIFRlbW1sIG1hY3Jvcy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY2VcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gY2hlbVBhcnNlKGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF0sIFwiY2VcIilcbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxwdVwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBjaGVtUGFyc2UoY29udGV4dC5jb25zdW1lQXJncygxKVswXSwgXCJwdVwiKTtcbn0pO1xuXG4vLyBNYXRoIGZvbnRzIGRvIG5vdCBpbmNsdWRlIGdseXBocyBmb3IgdGhlIH4gZm9ybSBvZiBib25kcy4gU28gd2UnbGwgc2VuZCBwYXRoIGdlb21ldHJ5XG4vLyBTbyB3ZSdsbCBjb21wb3NlIGNoYXJhY3RlcnMgYnVpbHQgZnJvbSBcXHJ1bGUgZWxlbWVudHMuXG5kZWZpbmVNYWNybyhcIlxcXFx1bmlEYXNoXCIsIGB7XFxcXHJ1bGV7MC42NzJlbX17MC4wNmVtfX1gKVxuZGVmaW5lTWFjcm8oXCJcXFxcdHJpRGFzaFwiLCBge1xcXFxydWxlezAuMTVlbX17MC4wNmVtfVxcXFxrZXJuMm11XFxcXHJ1bGV7MC4xNWVtfXswLjA2ZW19XFxcXGtlcm4ybXVcXFxccnVsZXswLjE1ZW19ezAuMDZlbX19YClcbmRlZmluZU1hY3JvKFwiXFxcXHRyaXBsZURhc2hcIiwgYFxcXFxrZXJuMC4wNzVlbVxcXFxyYWlzZTAuMjVlbXtcXFxcdHJpRGFzaH1cXFxca2VybjAuMDc1ZW1gKVxuZGVmaW5lTWFjcm8oXCJcXFxcdHJpcGxlRGFzaE92ZXJMaW5lXCIsIGBcXFxca2VybjAuMDc1ZW1cXFxcbWF0aHJsYXB7XFxcXHJhaXNlMC4xMjVlbXtcXFxcdW5pRGFzaH19XFxcXHJhaXNlMC4zNGVte1xcXFx0cmlEYXNofVxcXFxrZXJuMC4wNzVlbWApXG5kZWZpbmVNYWNybyhcIlxcXFx0cmlwbGVEYXNoT3ZlckRvdWJsZUxpbmVcIiwgYFxcXFxrZXJuMC4wNzVlbVxcXFxtYXRocmxhcHtcXFxcbWF0aHJsYXB7XFxcXHJhaXNlMC40OGVte1xcXFx0cmlEYXNofX1cXFxccmFpc2UwLjI3ZW17XFxcXHVuaURhc2h9fXtcXFxccmFpc2UwLjA1ZW17XFxcXHVuaURhc2h9fVxcXFxrZXJuMC4wNzVlbWApXG5kZWZpbmVNYWNybyhcIlxcXFx0cmlwbGVEYXNoQmV0d2VlbkRvdWJsZUxpbmVcIiwgYFxcXFxrZXJuMC4wNzVlbVxcXFxtYXRocmxhcHtcXFxcbWF0aHJsYXB7XFxcXHJhaXNlMC40OGVte1xcXFx1bmlEYXNofX1cXFxccmFpc2UwLjI3ZW17XFxcXHRyaURhc2h9fXtcXFxccmFpc2UwLjA1ZW17XFxcXHVuaURhc2h9fVxcXFxrZXJuMC4wNzVlbWApXG5cbiAgLy9cbiAgLy8gIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIGhhbmRpbmcgdGhlIFxcY2UgYW5kIFxccHUgY29tbWFuZHMuXG4gIC8vICBJdCB0YWtlcyB0aGUgYXJndW1lbnQgdG8gXFxjZSBvciBcXHB1IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIFRlWCBzdHJpbmcuXG4gIC8vXG5cbiAgdmFyIGNoZW1QYXJzZSA9IGZ1bmN0aW9uICh0b2tlbnMsIHN0YXRlTWFjaGluZSkge1xuICAgIC8vIFJlY3JlYXRlIHRoZSBhcmd1bWVudCBzdHJpbmcgZnJvbSBUZW1tbCdzIGFycmF5IG9mIHRva2Vucy5cbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgZXhwZWN0ZWRMb2MgPSB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ubG9jLnN0YXJ0XG4gICAgZm9yICh2YXIgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYodG9rZW5zW2ldLmxvYy5zdGFydCA+IGV4cGVjdGVkTG9jKSB7XG4gICAgICAgIC8vIGNvbnRleHQuY29uc3VtZUFyZ3MgaGFzIGVhdGVuIGEgc3BhY2UuXG4gICAgICAgIHN0ciArPSBcIiBcIjtcbiAgICAgICAgZXhwZWN0ZWRMb2MgPSB0b2tlbnNbaV0ubG9jLnN0YXJ0O1xuICAgICAgfVxuICAgICAgc3RyICs9IHRva2Vuc1tpXS50ZXh0O1xuICAgICAgZXhwZWN0ZWRMb2MgKz0gdG9rZW5zW2ldLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBDYWxsIHRoZSBtaGNoZW0gY29yZSBwYXJzZXIuXG4gICAgdmFyIHRleCA9IHRleGlmeS5nbyhtaGNoZW1QYXJzZXIuZ28oc3RyLCBzdGF0ZU1hY2hpbmUpKTtcbiAgICByZXR1cm4gdGV4O1xuICB9O1xuXG4gIC8vXG4gIC8vIENvcmUgcGFyc2VyIGZvciBtaGNoZW0gc3ludGF4ICAocmVjdXJzaXZlKVxuICAvL1xuICAvKiogQHR5cGUge01oY2hlbVBhcnNlcn0gKi9cbiAgdmFyIG1oY2hlbVBhcnNlciA9IHtcbiAgICAvL1xuICAgIC8vIFBhcnNlcyBtY2hlbSBcXGNlIHN5bnRheFxuICAgIC8vXG4gICAgLy8gQ2FsbCBsaWtlXG4gICAgLy8gICBnbyhcIkgyT1wiKTtcbiAgICAvL1xuICAgIGdvOiBmdW5jdGlvbiAoaW5wdXQsIHN0YXRlTWFjaGluZSkge1xuICAgICAgaWYgKCFpbnB1dCkgeyByZXR1cm4gW107IH1cbiAgICAgIGlmIChzdGF0ZU1hY2hpbmUgPT09IHVuZGVmaW5lZCkgeyBzdGF0ZU1hY2hpbmUgPSAnY2UnOyB9XG4gICAgICB2YXIgc3RhdGUgPSAnMCc7XG5cbiAgICAgIC8vXG4gICAgICAvLyBTdHJpbmcgYnVmZmVycyBmb3IgcGFyc2luZzpcbiAgICAgIC8vXG4gICAgICAvLyBidWZmZXIuYSA9PSBhbW91bnRcbiAgICAgIC8vIGJ1ZmZlci5vID09IGVsZW1lbnRcbiAgICAgIC8vIGJ1ZmZlci5iID09IGxlZnQtc2lkZSBzdXBlcnNjcmlwdFxuICAgICAgLy8gYnVmZmVyLnAgPT0gbGVmdC1zaWRlIHN1YnNjcmlwdFxuICAgICAgLy8gYnVmZmVyLnEgPT0gcmlnaHQtc2lkZSBzdWJzY3JpcHRcbiAgICAgIC8vIGJ1ZmZlci5kID09IHJpZ2h0LXNpZGUgc3VwZXJzY3JpcHRcbiAgICAgIC8vXG4gICAgICAvLyBidWZmZXIuciA9PSBhcnJvd1xuICAgICAgLy8gYnVmZmVyLnJkdCA9PSBhcnJvdywgc2NyaXB0IGFib3ZlLCB0eXBlXG4gICAgICAvLyBidWZmZXIucmQgPT0gYXJyb3csIHNjcmlwdCBhYm92ZSwgY29udGVudFxuICAgICAgLy8gYnVmZmVyLnJxdCA9PSBhcnJvdywgc2NyaXB0IGJlbG93LCB0eXBlXG4gICAgICAvLyBidWZmZXIucnEgPT0gYXJyb3csIHNjcmlwdCBiZWxvdywgY29udGVudFxuICAgICAgLy9cbiAgICAgIC8vIGJ1ZmZlci50ZXh0X1xuICAgICAgLy8gYnVmZmVyLnJtXG4gICAgICAvLyBldGMuXG4gICAgICAvL1xuICAgICAgLy8gYnVmZmVyLnBhcmVudGhlc2lzTGV2ZWwgPT0gaW50LCBzdGFydGluZyBhdCAwXG4gICAgICAvLyBidWZmZXIuc2IgPT0gYm9vbCwgc3BhY2UgYmVmb3JlXG4gICAgICAvLyBidWZmZXIuYmVnaW5zV2l0aEJvbmQgPT0gYm9vbFxuICAgICAgLy9cbiAgICAgIC8vIFRoZXNlIGxldHRlcnMgYXJlIGFsc28gdXNlZCBhcyBzdGF0ZSBuYW1lcy5cbiAgICAgIC8vXG4gICAgICAvLyBPdGhlciBzdGF0ZXM6XG4gICAgICAvLyAwID09IGJlZ2luIG9mIG1haW4gcGFydCAoYXJyb3cvb3BlcmF0b3IgdW5saWtlbHkpXG4gICAgICAvLyAxID09IG5leHQgZW50aXR5XG4gICAgICAvLyAyID09IG5leHQgZW50aXR5IChhcnJvdy9vcGVyYXRvciB1bmxpa2VseSlcbiAgICAgIC8vIDMgPT0gbmV4dCBhdG9tXG4gICAgICAvLyBjID09IG1hY3JvXG4gICAgICAvL1xuICAgICAgLyoqIEB0eXBlIHtCdWZmZXJ9ICovXG4gICAgICB2YXIgYnVmZmVyID0ge307XG4gICAgICBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXSA9IDA7XG5cbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxuL2csIFwiIFwiKTtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW1xcdTIyMTJcXHUyMDEzXFx1MjAxNFxcdTIwMTBdL2csIFwiLVwiKTtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW1xcdTIwMjZdL2csIFwiLi4uXCIpO1xuXG4gICAgICAvL1xuICAgICAgLy8gTG9va3MgdGhyb3VnaCBtaGNoZW1QYXJzZXIudHJhbnNpdGlvbnMsIHRvIGV4ZWN1dGUgYSBtYXRjaGluZyBhY3Rpb25cbiAgICAgIC8vIChyZWN1cnNpdmUpXG4gICAgICAvL1xuICAgICAgdmFyIGxhc3RJbnB1dDtcbiAgICAgIHZhciB3YXRjaGRvZyA9IDEwO1xuICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChsYXN0SW5wdXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgd2F0Y2hkb2cgPSAxMDtcbiAgICAgICAgICBsYXN0SW5wdXQgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXRjaGRvZy0tO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpbmQgYWN0aW9ucyBpbiB0cmFuc2l0aW9uIHRhYmxlXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBtYWNoaW5lID0gbWhjaGVtUGFyc2VyLnN0YXRlTWFjaGluZXNbc3RhdGVNYWNoaW5lXTtcbiAgICAgICAgdmFyIHQgPSBtYWNoaW5lLnRyYW5zaXRpb25zW3N0YXRlXSB8fCBtYWNoaW5lLnRyYW5zaXRpb25zWycqJ107XG4gICAgICAgIGl0ZXJhdGVUcmFuc2l0aW9uczpcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8odFtpXS5wYXR0ZXJuLCBpbnB1dCk7XG4gICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGFjdGlvbnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgdGFzayA9IHRbaV0udGFzaztcbiAgICAgICAgICAgIGZvciAodmFyIGlBPTA7IGlBPHRhc2suYWN0aW9uXy5sZW5ndGg7IGlBKyspIHtcbiAgICAgICAgICAgICAgdmFyIG87XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIEZpbmQgYW5kIGV4ZWN1dGUgYWN0aW9uXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIGlmIChtYWNoaW5lLmFjdGlvbnNbdGFzay5hY3Rpb25fW2lBXS50eXBlX10pIHtcbiAgICAgICAgICAgICAgICBvID0gbWFjaGluZS5hY3Rpb25zW3Rhc2suYWN0aW9uX1tpQV0udHlwZV9dKGJ1ZmZlciwgbWF0Y2hlcy5tYXRjaF8sIHRhc2suYWN0aW9uX1tpQV0ub3B0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtaGNoZW1QYXJzZXIuYWN0aW9uc1t0YXNrLmFjdGlvbl9baUFdLnR5cGVfXSkge1xuICAgICAgICAgICAgICAgIG8gPSBtaGNoZW1QYXJzZXIuYWN0aW9uc1t0YXNrLmFjdGlvbl9baUFdLnR5cGVfXShidWZmZXIsIG1hdGNoZXMubWF0Y2hfLCB0YXNrLmFjdGlvbl9baUFdLm9wdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnQVwiLCBcIm1oY2hlbSBidWcgQS4gUGxlYXNlIHJlcG9ydC4gKFwiICsgdGFzay5hY3Rpb25fW2lBXS50eXBlXyArIFwiKVwiXTsgIC8vIFRyeWluZyB0byB1c2Ugbm9uLWV4aXN0aW5nIGFjdGlvblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIEFkZCBvdXRwdXRcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KG91dHB1dCwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU2V0IG5leHQgc3RhdGUsXG4gICAgICAgICAgICAvLyBTaG9ydGVuIGlucHV0LFxuICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gICAoPSBhcHBseSBvbmx5IG9uZSB0cmFuc2l0aW9uIHBlciBwb3NpdGlvbilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBzdGF0ZSA9IHRhc2submV4dFN0YXRlIHx8IHN0YXRlO1xuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKCF0YXNrLnJldmlzaXQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1hdGNoZXMucmVtYWluZGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGFzay50b0NvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgaXRlcmF0ZVRyYW5zaXRpb25zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHdhdGNoZG9nIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdVXCIsIFwibWhjaGVtIGJ1ZyBVLiBQbGVhc2UgcmVwb3J0LlwiXTsgIC8vIFVuZXhwZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmNhdEFycmF5OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICBmb3IgKHZhciBpQj0wOyBpQjxiLmxlbmd0aDsgaUIrKykge1xuICAgICAgICAgICAgYS5wdXNoKGJbaUJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYS5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBhdHRlcm5zOiB7XG4gICAgICAvL1xuICAgICAgLy8gTWF0Y2hpbmcgcGF0dGVybnNcbiAgICAgIC8vIGVpdGhlciByZWdleHBzIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJuIG51bGwgb3Ige21hdGNoXzpcImFcIiwgcmVtYWluZGVyOlwiYmNcIn1cbiAgICAgIC8vXG4gICAgICBwYXR0ZXJuczoge1xuICAgICAgICAvLyBwcm9wZXJ0eSBuYW1lcyBtdXN0IG5vdCBsb29rIGxpa2UgaW50ZWdlcnMgKFwiMlwiKSBmb3IgY29ycmVjdCBwcm9wZXJ0eSB0cmF2ZXJzYWwgb3JkZXIsIGxhdGVyIG9uXG4gICAgICAgICdlbXB0eSc6IC9eJC8sXG4gICAgICAgICdlbHNlJzogL14uLyxcbiAgICAgICAgJ2Vsc2UyJzogL14uLyxcbiAgICAgICAgJ3NwYWNlJzogL15cXHMvLFxuICAgICAgICAnc3BhY2UgQSc6IC9eXFxzKD89W0EtWlxcXFwkXSkvLFxuICAgICAgICAnc3BhY2UkJzogL15cXHMkLyxcbiAgICAgICAgJ2Eteic6IC9eW2Etel0vLFxuICAgICAgICAneCc6IC9eeC8sXG4gICAgICAgICd4JCc6IC9eeCQvLFxuICAgICAgICAnaSQnOiAvXmkkLyxcbiAgICAgICAgJ2xldHRlcnMnOiAvXig/OlthLXpBLVpcXHUwM0IxLVxcdTAzQzlcXHUwMzkxLVxcdTAzQTk/QF18KD86XFxcXCg/OmFscGhhfGJldGF8Z2FtbWF8ZGVsdGF8ZXBzaWxvbnx6ZXRhfGV0YXx0aGV0YXxpb3RhfGthcHBhfGxhbWJkYXxtdXxudXx4aXxvbWljcm9ufHBpfHJob3xzaWdtYXx0YXV8dXBzaWxvbnxwaGl8Y2hpfHBzaXxvbWVnYXxHYW1tYXxEZWx0YXxUaGV0YXxMYW1iZGF8WGl8UGl8U2lnbWF8VXBzaWxvbnxQaGl8UHNpfE9tZWdhKSg/Olxccyt8XFx7XFx9fCg/IVthLXpBLVpdKSkpKSsvLFxuICAgICAgICAnXFxcXGdyZWVrJzogL15cXFxcKD86YWxwaGF8YmV0YXxnYW1tYXxkZWx0YXxlcHNpbG9ufHpldGF8ZXRhfHRoZXRhfGlvdGF8a2FwcGF8bGFtYmRhfG11fG51fHhpfG9taWNyb258cGl8cmhvfHNpZ21hfHRhdXx1cHNpbG9ufHBoaXxjaGl8cHNpfG9tZWdhfEdhbW1hfERlbHRhfFRoZXRhfExhbWJkYXxYaXxQaXxTaWdtYXxVcHNpbG9ufFBoaXxQc2l8T21lZ2EpKD86XFxzK3xcXHtcXH18KD8hW2EtekEtWl0pKS8sXG4gICAgICAgICdvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciAkJzogL14oPzooW2Etel0pKD86JHxbXmEtekEtWl0pKSQvLFxuICAgICAgICAnJG9uZSBsb3dlcmNhc2UgbGF0aW4gbGV0dGVyJCAkJzogL15cXCQoPzooW2Etel0pKD86JHxbXmEtekEtWl0pKVxcJCQvLFxuICAgICAgICAnb25lIGxvd2VyY2FzZSBncmVlayBsZXR0ZXIgJCc6IC9eKD86XFwkP1tcXHUwM0IxLVxcdTAzQzldXFwkP3xcXCQ/XFxcXCg/OmFscGhhfGJldGF8Z2FtbWF8ZGVsdGF8ZXBzaWxvbnx6ZXRhfGV0YXx0aGV0YXxpb3RhfGthcHBhfGxhbWJkYXxtdXxudXx4aXxvbWljcm9ufHBpfHJob3xzaWdtYXx0YXV8dXBzaWxvbnxwaGl8Y2hpfHBzaXxvbWVnYSlcXHMqXFwkPykoPzpcXHMrfFxce1xcfXwoPyFbYS16QS1aXSkpJC8sXG4gICAgICAgICdkaWdpdHMnOiAvXlswLTldKy8sXG4gICAgICAgICctOS4sOSc6IC9eWytcXC1dPyg/OlswLTldKyg/OlssLl1bMC05XSspP3xbMC05XSooPzpcXC5bMC05XSspKS8sXG4gICAgICAgICctOS4sOSBubyBtaXNzaW5nIDAnOiAvXlsrXFwtXT9bMC05XSsoPzpbLixdWzAtOV0rKT8vLFxuICAgICAgICAnKC0pKDkuLDkpKGUpKDk5KSc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oXFwrXFwtfFxcK1xcL1xcLXxcXCt8XFwtfFxcXFxwbVxccz8pPyhbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKSk/KFxcKCg/OlswLTldKyg/OlssLl1bMC05XSspP3xbMC05XSooPzpcXC5bMC05XSspKVxcKSk/KD86KFtlRV18XFxzKihcXCp8eHxcXFxcdGltZXN8XFx1MDBENylcXHMqMTBcXF4pKFsrXFwtXT9bMC05XSt8XFx7WytcXC1dP1swLTldK1xcfSkpPy8pO1xuICAgICAgICAgIGlmIChtICYmIG1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbS5zcGxpY2UoMSksIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1bMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJygtKSg5KV4oLTkpJzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXCtcXC18XFwrXFwvXFwtfFxcK3xcXC18XFxcXHBtXFxzPyk/KFswLTldKyg/OlssLl1bMC05XSspP3xbMC05XSooPzpcXC5bMC05XSspPylcXF4oWytcXC1dP1swLTldK3xcXHtbK1xcLV0/WzAtOV0rXFx9KS8pO1xuICAgICAgICAgIGlmIChtICYmIG1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbS5zcGxpY2UoMSksIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1bMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uICQnOiBmdW5jdGlvbiAoaW5wdXQpIHsgIC8vIC4uLiBvciBjcnlzdGFsIHN5c3RlbVxuICAgICAgICAgIHZhciBhID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCAvXlxcKFthLXpdezEsM30oPz1bXFwpLF0pLywgXCIpXCIsIFwiXCIpOyAgLy8gKGFxKSwgKGFxLCRcXGluZnR5JCksIChhcSwgc2F0KVxuICAgICAgICAgIGlmIChhICAmJiAgYS5yZW1haW5kZXIubWF0Y2goL14oJHxbXFxzLDtcXClcXF1cXH1dKS8pKSB7IHJldHVybiBhOyB9ICAvLyAgQU5EIGVuZCBvZiAncGhyYXNlJ1xuICAgICAgICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oPzpcXCgoPzpcXFxcY2FcXHM/KT9cXCRbYW1vdGhjXVxcJFxcKSkvKTsgIC8vIE9SIGNyeXN0YWwgc3lzdGVtICgkbyQpIChcXGNhJGMkKVxuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1bMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1bMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ197KHN0YXRlIG9mIGFnZ3JlZ2F0aW9uKX0kJzogL15fXFx7KFxcKFthLXpdezEsM31cXCkpXFx9LyxcbiAgICAgICAgJ3tbKCc6IC9eKD86XFxcXFxce3xcXFt8XFwoKS8sXG4gICAgICAgICcpXX0nOiAvXig/OlxcKXxcXF18XFxcXFxcfSkvLFxuICAgICAgICAnLCAnOiAvXlssO11cXHMqLyxcbiAgICAgICAgJywnOiAvXlssO10vLFxuICAgICAgICAnLic6IC9eWy5dLyxcbiAgICAgICAgJy4gJzogL14oWy5cXHUyMkM1XFx1MDBCN1xcdTIwMjJdKVxccyovLFxuICAgICAgICAnLi4uJzogL15cXC5cXC5cXC4oPz0kfFteLl0pLyxcbiAgICAgICAgJyogJzogL14oWypdKVxccyovLFxuICAgICAgICAnXnsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJee1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdeKCQuLi4kKSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl5cIiwgXCIkXCIsIFwiJFwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ15hJzogL15cXF4oWzAtOV0rfFteXFxcXF9dKS8sXG4gICAgICAgICdeXFxcXHh7fXt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgJ15cXFxceHt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIik7IH0sXG4gICAgICAgICdeXFxcXHgnOiAvXlxcXihcXFxcW2EtekEtWl0rKVxccyovLFxuICAgICAgICAnXigtMSknOiAvXlxcXigtP1xcZCspLyxcbiAgICAgICAgJ1xcJyc6IC9eJy8sXG4gICAgICAgICdfeyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl97XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ18oJC4uLiQpJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCBcIiRcIiwgXCIkXCIsIFwiXCIpOyB9LFxuICAgICAgICAnXzknOiAvXl8oWytcXC1dP1swLTldK3xbXlxcXFxdKS8sXG4gICAgICAgICdfXFxcXHh7fXt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgJ19cXFxceHt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIik7IH0sXG4gICAgICAgICdfXFxcXHgnOiAvXl8oXFxcXFthLXpBLVpdKylcXHMqLyxcbiAgICAgICAgJ15fJzogL14oPzpcXF4oPz1fKXxcXF8oPz1cXF4pfFtcXF5fXSQpLyxcbiAgICAgICAgJ3t9JzogL15cXHtcXH0vLFxuICAgICAgICAney4uLn0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ3soLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJyQuLi4kJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIFwiJFwiLCBcIiRcIiwgXCJcIik7IH0sXG4gICAgICAgICckeyguLi4pfSQnOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCIke1wiLCBcIlwiLCBcIlwiLCBcIn0kXCIpOyB9LFxuICAgICAgICAnJCguLi4pJCc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIiRcIiwgXCJcIiwgXCJcIiwgXCIkXCIpOyB9LFxuICAgICAgICAnPTw+JzogL15bPTw+XS8sXG4gICAgICAgICcjJzogL15bI1xcdTIyNjFdLyxcbiAgICAgICAgJysnOiAvXlxcKy8sXG4gICAgICAgICctJCc6IC9eLSg/PVtcXHNffSw7XFxdL118JHxcXChbYS16XStcXCkpLywgIC8vIC1zcGFjZSAtLCAtOyAtXSAtLyAtJCAtc3RhdGUtb2YtYWdncmVnYXRpb25cbiAgICAgICAgJy05JzogL14tKD89WzAtOV0pLyxcbiAgICAgICAgJy0gb3JiaXRhbCBvdmVybGFwJzogL14tKD89KD86W3NwZF18c3ApKD86JHxbXFxzLDtcXClcXF1cXH1dKSkvLFxuICAgICAgICAnLSc6IC9eLS8sXG4gICAgICAgICdwbS1vcGVyYXRvcic6IC9eKD86XFxcXHBtfFxcJFxcXFxwbVxcJHxcXCstfFxcK1xcLy0pLyxcbiAgICAgICAgJ29wZXJhdG9yJzogL14oPzpcXCt8KD86W1xcLT08Pl18PDx8Pj58XFxcXGFwcHJveHxcXCRcXFxcYXBwcm94XFwkKSg/PVxcc3wkfC0/WzAtOV0pKS8sXG4gICAgICAgICdhcnJvd1VwRG93bic6IC9eKD86dnxcXCh2XFwpfFxcXnxcXChcXF5cXCkpKD89JHxbXFxzLDtcXClcXF1cXH1dKS8sXG4gICAgICAgICdcXFxcYm9uZHsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcYm9uZHtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnLT4nOiAvXig/OjwtPnw8LS0+fC0+fDwtfDw9Pj58PDw9Pnw8PT58W1xcdTIxOTJcXHUyN0Y2XFx1MjFDQ10pLyxcbiAgICAgICAgJ0NNVCc6IC9eW0NNVF0oPz1cXFspLyxcbiAgICAgICAgJ1soLi4uKV0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJbXCIsIFwiXCIsIFwiXCIsIFwiXVwiKTsgfSxcbiAgICAgICAgJzFzdC1sZXZlbCBlc2NhcGUnOiAvXigmfFxcXFxcXFxcfFxcXFxobGluZSlcXHMqLyxcbiAgICAgICAgJ1xcXFwsJzogL14oPzpcXFxcWyxcXCA7Ol0pLywgIC8vIFxcXFx4IC0gYnV0IG91dHB1dCBubyBzcGFjZSBiZWZvcmVcbiAgICAgICAgJ1xcXFx4e317fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgJ1xcXFx4e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIpOyB9LFxuICAgICAgICAnXFxcXGNhJzogL15cXFxcY2EoPzpcXHMrfCg/IVthLXpBLVpdKSkvLFxuICAgICAgICAnXFxcXHgnOiAvXig/OlxcXFxbYS16QS1aXStcXHMqfFxcXFxbXyZ7fSVdKS8sXG4gICAgICAgICdvcmJpdGFsJzogL14oPzpbMC05XXsxLDJ9W3NwZGZnaF18WzAtOV17MCwyfXNwKSg/PSR8W15hLXpBLVpdKS8sICAvLyBvbmx5IHRob3NlIHdpdGggbnVtYmVycyBpbiBmcm9udCwgYmVjYXVzZSB0aGUgb3RoZXJzIHdpbGwgYmUgZm9ybWF0dGVkIGNvcnJlY3RseSBhbnl3YXlcbiAgICAgICAgJ290aGVycyc6IC9eW1xcL358XS8sXG4gICAgICAgICdcXFxcZnJhY3soLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcZnJhY3tcIiwgXCJcIiwgXCJcIiwgXCJ9XCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcb3ZlcnNldHsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcb3ZlcnNldHtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcdW5kZXJzZXR7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXHVuZGVyc2V0e1wiLCBcIlwiLCBcIlwiLCBcIn1cIiwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFx1bmRlcmJyYWNleyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFx1bmRlcmJyYWNle1wiLCBcIlwiLCBcIlwiLCBcIn1fXCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9MCc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxjb2xvcntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0xJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNvbG9ye1wiLCBcIlwiLCBcIlwiLCBcIn1cIiwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFxjb2xvciguLi4peyguLi4pfTInOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcY29sb3JcIiwgXCJcXFxcXCIsIFwiXCIsIC9eKD89XFx7KS8sIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNle1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdveGlkYXRpb24kJzogL14oPzpbKy1dW0lWWF0rfFxcXFxwbVxccyowfFxcJFxcXFxwbVxcJFxccyowKSQvLFxuICAgICAgICAnZC1veGlkYXRpb24kJzogL14oPzpbKy1dP1xccz9bSVZYXSt8XFxcXHBtXFxzKjB8XFwkXFxcXHBtXFwkXFxzKjApJC8sICAvLyAwIGNvdWxkIGJlIG94aWRhdGlvbiBvciBjaGFyZ2VcbiAgICAgICAgJ3JvbWFuIG51bWVyYWwnOiAvXltJVlhdKy8sXG4gICAgICAgICcxLzIkJzogL15bK1xcLV0/KD86WzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcL1swLTldKyg/OlxcJFthLXpdXFwkfFthLXpdKT8kLyxcbiAgICAgICAgJ2Ftb3VudCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICAvLyBlLmcuIDIsIDAuNSwgMS8yLCAtMiwgbi8yLCArOyAgJGEkIGNvdWxkIGJlIGFkZGVkIGxhdGVyIGluIHBhcnNpbmdcbiAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKC9eKD86KD86KD86XFwoWytcXC1dP1swLTldK1xcL1swLTldK1xcKXxbK1xcLV0/KD86WzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcL1swLTldK3xbK1xcLV0/WzAtOV0rWy4sXVswLTldK3xbK1xcLV0/XFwuWzAtOV0rfFsrXFwtXT9bMC05XSspKD86W2Etel0oPz1cXHMqW0EtWl0pKT8pfFsrXFwtXT9bYS16XSg/PVxccypbQS1aXSl8XFwrKD8hXFxzKSkvKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbWF0Y2hbMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIFwiJFwiLCBcIiRcIiwgXCJcIik7XG4gICAgICAgICAgaWYgKGEpIHsgIC8vIGUuZy4gJDJuLTEkLCAkLSRcbiAgICAgICAgICAgIG1hdGNoID0gYS5tYXRjaF8ubWF0Y2goL15cXCQoPzpcXCg/WytcXC1dPyg/OlswLTldKlthLXpdP1srXFwtXSk/WzAtOV0qW2Etel0oPzpbK1xcLV1bMC05XSpbYS16XT8pP1xcKT98XFwrfC0pXFwkJC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbWF0Y2hbMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgICdhbW91bnQyJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiB0aGlzWydhbW91bnQnXShpbnB1dCk7IH0sXG4gICAgICAgICcoS1YgbGV0dGVycyksJzogL14oPzpbQS1aXVthLXpdezAsMn18aSkoPz0sKS8sXG4gICAgICAgICdmb3JtdWxhJCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXlxcKFthLXpdK1xcKSQvKSkgeyByZXR1cm4gbnVsbDsgfSAgLy8gc3RhdGUgb2YgYWdncmVnYXRpb24gPSBubyBmb3JtdWxhXG4gICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goL14oPzpbYS16XXwoPzpbMC05XFwgXFwrXFwtXFwsXFwuXFwoXFwpXStbYS16XSkrWzAtOVxcIFxcK1xcLVxcLFxcLlxcKFxcKV0qfCg/OlthLXpdWzAtOVxcIFxcK1xcLVxcLFxcLlxcKFxcKV0rKStbYS16XT8pJC8pO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtYXRjaFswXSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ3VwcmlnaHRFbnRpdGllcyc6IC9eKD86cEh8cE9IfHBDfHBLfGlQcnxpQnUpKD89JHxbXmEtekEtWl0pLyxcbiAgICAgICAgJy8nOiAvXlxccyooXFwvKVxccyovLFxuICAgICAgICAnLy8nOiAvXlxccyooXFwvXFwvKVxccyovLFxuICAgICAgICAnKic6IC9eXFxzKlsqLl1cXHMqL1xuICAgICAgfSxcbiAgICAgIGZpbmRPYnNlcnZlR3JvdXBzOiBmdW5jdGlvbiAoaW5wdXQsIGJlZ0V4Y2wsIGJlZ0luY2wsIGVuZEluY2wsIGVuZEV4Y2wsIGJlZzJFeGNsLCBiZWcySW5jbCwgZW5kMkluY2wsIGVuZDJFeGNsLCBjb21iaW5lKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7eyhpbnB1dDogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcgfCBSZWdFeHApOiBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bGw7fX0gKi9cbiAgICAgICAgdmFyIF9tYXRjaCA9IGZ1bmN0aW9uIChpbnB1dCwgcGF0dGVybikge1xuICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlucHV0LmluZGV4T2YocGF0dGVybikgIT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaFswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAdHlwZSB7eyhpbnB1dDogc3RyaW5nLCBpOiBudW1iZXIsIGVuZENoYXJzOiBzdHJpbmcgfCBSZWdFeHApOiB7ZW5kTWF0Y2hCZWdpbjogbnVtYmVyLCBlbmRNYXRjaEVuZDogbnVtYmVyfSB8IG51bGw7fX0gKi9cbiAgICAgICAgdmFyIF9maW5kT2JzZXJ2ZUdyb3VwcyA9IGZ1bmN0aW9uIChpbnB1dCwgaSwgZW5kQ2hhcnMpIHtcbiAgICAgICAgICB2YXIgYnJhY2VzID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGEgPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBfbWF0Y2goaW5wdXQuc3Vic3RyKGkpLCBlbmRDaGFycyk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgICYmICBicmFjZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW5kTWF0Y2hCZWdpbjogaSwgZW5kTWF0Y2hFbmQ6IGkgKyBtYXRjaC5sZW5ndGggfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgYnJhY2VzKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgIGlmIChicmFjZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBbXCJFeHRyYUNsb3NlTWlzc2luZ09wZW5cIiwgXCJFeHRyYSBjbG9zZSBicmFjZSBvciBtaXNzaW5nIG9wZW4gYnJhY2VcIl07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJhY2VzLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJyYWNlcyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1hdGNoID0gX21hdGNoKGlucHV0LCBiZWdFeGNsKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKG1hdGNoLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoID0gX21hdGNoKGlucHV0LCBiZWdJbmNsKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBlID0gX2ZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBtYXRjaC5sZW5ndGgsIGVuZEluY2wgfHwgZW5kRXhjbCk7XG4gICAgICAgIGlmIChlID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBtYXRjaDEgPSBpbnB1dC5zdWJzdHJpbmcoMCwgKGVuZEluY2wgPyBlLmVuZE1hdGNoRW5kIDogZS5lbmRNYXRjaEJlZ2luKSk7XG4gICAgICAgIGlmICghKGJlZzJFeGNsIHx8IGJlZzJJbmNsKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXRjaF86IG1hdGNoMSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKGUuZW5kTWF0Y2hFbmQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZ3JvdXAyID0gdGhpcy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dC5zdWJzdHIoZS5lbmRNYXRjaEVuZCksIGJlZzJFeGNsLCBiZWcySW5jbCwgZW5kMkluY2wsIGVuZDJFeGNsKTtcbiAgICAgICAgICBpZiAoZ3JvdXAyID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgICAgICB2YXIgbWF0Y2hSZXQgPSBbbWF0Y2gxLCBncm91cDIubWF0Y2hfXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2hfOiAoY29tYmluZSA/IG1hdGNoUmV0LmpvaW4oXCJcIikgOiBtYXRjaFJldCksXG4gICAgICAgICAgICByZW1haW5kZXI6IGdyb3VwMi5yZW1haW5kZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvL1xuICAgICAgLy8gTWF0Y2hpbmcgZnVuY3Rpb25cbiAgICAgIC8vIGUuZy4gbWF0Y2goXCJhXCIsIGlucHV0KSB3aWxsIGxvb2sgZm9yIHRoZSByZWdleHAgY2FsbGVkIFwiYVwiIGFuZCBzZWUgaWYgaXQgbWF0Y2hlc1xuICAgICAgLy8gcmV0dXJucyBudWxsIG9yIHttYXRjaF86XCJhXCIsIHJlbWFpbmRlcjpcImJjXCJ9XG4gICAgICAvL1xuICAgICAgbWF0Y2hfOiBmdW5jdGlvbiAobSwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBtaGNoZW1QYXJzZXIucGF0dGVybnMucGF0dGVybnNbbV07XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdQXCIsIFwibWhjaGVtIGJ1ZyBQLiBQbGVhc2UgcmVwb3J0LiAoXCIgKyBtICsgXCIpXCJdOyAgLy8gVHJ5aW5nIHRvIHVzZSBub24tZXhpc3RpbmcgcGF0dGVyblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLnBhdHRlcm5zW21dKGlucHV0KTsgIC8vIGNhbm5vdCB1c2UgY2FjaGVkIHZhciBwYXR0ZXJuIGhlcmUsIGJlY2F1c2Ugc29tZSBwYXR0ZXJuIGZ1bmN0aW9ucyBuZWVkIHRoaXM9PT1taGNoZW1QYXJzZXJcbiAgICAgICAgfSBlbHNlIHsgIC8vIFJlZ0V4cFxuICAgICAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIG1tO1xuICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgIG1tID0gWyBtYXRjaFsxXSwgbWF0Y2hbMl0gXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgbW0gPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1tID0gbWF0Y2hbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1tLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vXG4gICAgLy8gR2VuZXJpYyBzdGF0ZSBtYWNoaW5lIGFjdGlvbnNcbiAgICAvL1xuICAgIGFjdGlvbnM6IHtcbiAgICAgICdhPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLmEgPSAoYnVmZmVyLmEgfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ2I9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuYiA9IChidWZmZXIuYiB8fCBcIlwiKSArIG07IH0sXG4gICAgICAncD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5wID0gKGJ1ZmZlci5wIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdvPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLm8gPSAoYnVmZmVyLm8gfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ3E9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucSA9IChidWZmZXIucSB8fCBcIlwiKSArIG07IH0sXG4gICAgICAnZD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5kID0gKGJ1ZmZlci5kIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdybT0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ybSA9IChidWZmZXIucm0gfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ3RleHQ9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIudGV4dF8gPSAoYnVmZmVyLnRleHRfIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdpbnNlcnQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBhKSB7IHJldHVybiB7IHR5cGVfOiBhIH07IH0sXG4gICAgICAnaW5zZXJ0K3AxJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgYSkgeyByZXR1cm4geyB0eXBlXzogYSwgcDE6IG0gfTsgfSxcbiAgICAgICdpbnNlcnQrcDErcDInOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBhKSB7IHJldHVybiB7IHR5cGVfOiBhLCBwMTogbVswXSwgcDI6IG1bMV0gfTsgfSxcbiAgICAgICdjb3B5JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbTsgfSxcbiAgICAgICdybSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIHsgdHlwZV86ICdybScsIHAxOiBtIHx8IFwiXCJ9OyB9LFxuICAgICAgJ3RleHQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiBtaGNoZW1QYXJzZXIuZ28obSwgJ3RleHQnKTsgfSxcbiAgICAgICd7dGV4dH0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgIHZhciByZXQgPSBbIFwie1wiIF07XG4gICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtLCAndGV4dCcpKTtcbiAgICAgICAgcmV0LnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICAgICd0ZXgtbWF0aCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtLCAndGV4LW1hdGgnKTsgfSxcbiAgICAgICd0ZXgtbWF0aCB0aWdodCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtLCAndGV4LW1hdGggdGlnaHQnKTsgfSxcbiAgICAgICdib25kJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgaykgeyByZXR1cm4geyB0eXBlXzogJ2JvbmQnLCBraW5kXzogayB8fCBtIH07IH0sXG4gICAgICAnY29sb3IwLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIHsgdHlwZV86ICdjb2xvcjAnLCBjb2xvcjogbVswXSB9OyB9LFxuICAgICAgJ2NlJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLmdvKG0pOyB9LFxuICAgICAgJzEvMic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBpZiAobS5tYXRjaCgvXlsrXFwtXS8pKSB7XG4gICAgICAgICAgcmV0LnB1c2gobS5zdWJzdHIoMCwgMSkpO1xuICAgICAgICAgIG0gPSBtLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IG0ubWF0Y2goL14oWzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcLyhbMC05XSspKFxcJFthLXpdXFwkfFthLXpdKT8kLyk7XG4gICAgICAgIG5bMV0gPSBuWzFdLnJlcGxhY2UoL1xcJC9nLCBcIlwiKTtcbiAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2ZyYWMnLCBwMTogblsxXSwgcDI6IG5bMl0gfSk7XG4gICAgICAgIGlmIChuWzNdKSB7XG4gICAgICAgICAgblszXSA9IG5bM10ucmVwbGFjZSgvXFwkL2csIFwiXCIpO1xuICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICd0ZXgtbWF0aCcsIHAxOiBuWzNdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgJzksOSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtLCAnOSw5Jyk7IH1cbiAgICB9LFxuICAgIC8vXG4gICAgLy8gY3JlYXRlVHJhbnNpdGlvbnNcbiAgICAvLyBjb252ZXJ0ICB7ICdsZXR0ZXInOiB7ICdzdGF0ZSc6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9IH0gIHRvICB7ICdzdGF0ZScgPT4gWyB7IHBhdHRlcm46ICdsZXR0ZXInLCB0YXNrOiB7IGFjdGlvbl86IFt7dHlwZV86ICdvdXRwdXQnfV0gfSB9IF0gfVxuICAgIC8vIHdpdGggZXhwYW5zaW9uIG9mICdhfGInIHRvICdhJyBhbmQgJ2InIChhdCAyIHBsYWNlcylcbiAgICAvL1xuICAgIGNyZWF0ZVRyYW5zaXRpb25zOiBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHBhdHRlcm4sIHN0YXRlO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgIHZhciBzdGF0ZUFycmF5O1xuICAgICAgdmFyIGk7XG4gICAgICAvL1xuICAgICAgLy8gMS4gQ29sbGVjdCBhbGwgc3RhdGVzXG4gICAgICAvL1xuICAgICAgLyoqIEB0eXBlIHtUcmFuc2l0aW9uc30gKi9cbiAgICAgIHZhciB0cmFuc2l0aW9ucyA9IHt9O1xuICAgICAgZm9yIChwYXR0ZXJuIGluIG8pIHtcbiAgICAgICAgZm9yIChzdGF0ZSBpbiBvW3BhdHRlcm5dKSB7XG4gICAgICAgICAgc3RhdGVBcnJheSA9IHN0YXRlLnNwbGl0KFwifFwiKTtcbiAgICAgICAgICBvW3BhdHRlcm5dW3N0YXRlXS5zdGF0ZUFycmF5ID0gc3RhdGVBcnJheTtcbiAgICAgICAgICBmb3IgKGk9MDsgaTxzdGF0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uc1tzdGF0ZUFycmF5W2ldXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9cbiAgICAgIC8vIDIuIEZpbGwgc3RhdGVzXG4gICAgICAvL1xuICAgICAgZm9yIChwYXR0ZXJuIGluIG8pIHtcbiAgICAgICAgZm9yIChzdGF0ZSBpbiBvW3BhdHRlcm5dKSB7XG4gICAgICAgICAgc3RhdGVBcnJheSA9IG9bcGF0dGVybl1bc3RhdGVdLnN0YXRlQXJyYXkgfHwgW107XG4gICAgICAgICAgZm9yIChpPTA7IGk8c3RhdGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDJhLiBOb3JtYWxpemUgYWN0aW9ucyBpbnRvIGFycmF5OiAgJ3RleHQ9JyA9PT4gW3t0eXBlXzondGV4dD0nfV1cbiAgICAgICAgICAgIC8vIChOb3RlIHRvIG15c2VsZjogUmVzb2x2aW5nIHRoZSBmdW5jdGlvbiBoZXJlIHdvdWxkIGJlIHByb2JsZW1hdGljLiBJdCB3b3VsZCBuZWVkIC5iaW5kIChmb3IgKnRoaXMqKSBhbmQgY3VycnlpbmcgKGZvciAqb3B0aW9uKikuKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgICAgICAgICAgdmFyIHAgPSBvW3BhdHRlcm5dW3N0YXRlXTtcbiAgICAgICAgICAgIGlmIChwLmFjdGlvbl8pIHtcbiAgICAgICAgICAgICAgcC5hY3Rpb25fID0gW10uY29uY2F0KHAuYWN0aW9uXyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGs9MDsgazxwLmFjdGlvbl8ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHAuYWN0aW9uX1trXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgcC5hY3Rpb25fW2tdID0geyB0eXBlXzogcC5hY3Rpb25fW2tdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLmFjdGlvbl8gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAyLmIgTXVsdGktaW5zZXJ0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5BcnJheSA9IHBhdHRlcm4uc3BsaXQoXCJ8XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHBhdHRlcm5BcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVBcnJheVtpXSA9PT0gJyonKSB7ICAvLyBpbnNlcnQgaW50byBhbGxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1t0XS5wdXNoKHsgcGF0dGVybjogcGF0dGVybkFycmF5W2pdLCB0YXNrOiBwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1tzdGF0ZUFycmF5W2ldXS5wdXNoKHsgcGF0dGVybjogcGF0dGVybkFycmF5W2pdLCB0YXNrOiBwIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbnM7XG4gICAgfSxcbiAgICBzdGF0ZU1hY2hpbmVzOiB7fVxuICB9O1xuXG4gIC8vXG4gIC8vIERlZmluaXRpb24gb2Ygc3RhdGUgbWFjaGluZXNcbiAgLy9cbiAgbWhjaGVtUGFyc2VyLnN0YXRlTWFjaGluZXMgPSB7XG4gICAgLy9cbiAgICAvLyBcXGNlIHN0YXRlIG1hY2hpbmVzXG4gICAgLy9cbiAgICAvLyNyZWdpb24gY2VcbiAgICAnY2UnOiB7ICAvLyBtYWluIHBhcnNlclxuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnZWxzZSc6ICB7XG4gICAgICAgICAgJzB8MXwyJzogeyBhY3Rpb25fOiAnYmVnaW5zV2l0aEJvbmQ9ZmFsc2UnLCByZXZpc2l0OiB0cnVlLCB0b0NvbnRpbnVlOiB0cnVlIH0gfSxcbiAgICAgICAgJ294aWRhdGlvbiQnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdveGlkYXRpb24tb3V0cHV0JyB9IH0sXG4gICAgICAgICdDTVQnOiB7XG4gICAgICAgICAgJ3InOiB7IGFjdGlvbl86ICdyZHQ9JywgbmV4dFN0YXRlOiAncnQnIH0sXG4gICAgICAgICAgJ3JkJzogeyBhY3Rpb25fOiAncnF0PScsIG5leHRTdGF0ZTogJ3JkdCcgfSB9LFxuICAgICAgICAnYXJyb3dVcERvd24nOiB7XG4gICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiBbICdzYj1mYWxzZScsICdvdXRwdXQnLCAnb3BlcmF0b3InIF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ3VwcmlnaHRFbnRpdGllcyc6IHtcbiAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86IFsgJ289JywgJ291dHB1dCcgXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnb3JiaXRhbCc6IHtcbiAgICAgICAgICAnMHwxfDJ8Myc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnLT4nOiB7XG4gICAgICAgICAgJzB8MXwyfDMnOiB7IGFjdGlvbl86ICdyPScsIG5leHRTdGF0ZTogJ3InIH0sXG4gICAgICAgICAgJ2F8YXMnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdyPScgXSwgbmV4dFN0YXRlOiAncicgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3I9JyBdLCBuZXh0U3RhdGU6ICdyJyB9IH0sXG4gICAgICAgICcrJzoge1xuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiAnZD0ga3YnLCAgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnZHxEJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiAnZD0nLCAgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ3FkfHFEJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAnZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdkPScgXSwgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnMyc6IHsgYWN0aW9uXzogWyAnc2I9ZmFsc2UnLCAnb3V0cHV0JywgJ29wZXJhdG9yJyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgJzB8Mic6IHsgYWN0aW9uXzogJ2E9JywgbmV4dFN0YXRlOiAnYScgfSB9LFxuICAgICAgICAncG0tb3BlcmF0b3InOiB7XG4gICAgICAgICAgJzB8MXwyfGF8YXMnOiB7IGFjdGlvbl86IFsgJ3NiPWZhbHNlJywgJ291dHB1dCcsIHsgdHlwZV86ICdvcGVyYXRvcicsIG9wdGlvbjogJ1xcXFxwbScgfSBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdvcGVyYXRvcic6IHtcbiAgICAgICAgICAnMHwxfDJ8YXxhcyc6IHsgYWN0aW9uXzogWyAnc2I9ZmFsc2UnLCAnb3V0cHV0JywgJ29wZXJhdG9yJyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICctJCc6IHtcbiAgICAgICAgICAnb3xxJzogeyBhY3Rpb25fOiBbICdjaGFyZ2Ugb3IgYm9uZCcsICdvdXRwdXQnIF0sICBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnRCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogJ2Q9JywgIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdxZCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ3FEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICctOSc6IHtcbiAgICAgICAgICAnM3xvJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9IF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJy0gb3JiaXRhbCBvdmVybGFwJzoge1xuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9IF0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJ2QnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdoeXBoZW4nIH0gXSwgbmV4dFN0YXRlOiAnMicgfSB9LFxuICAgICAgICAnLSc6IHtcbiAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnYmVnaW5zV2l0aEJvbmQ9dHJ1ZScsIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgJzMnOiB7IGFjdGlvbl86IHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IH0sXG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdoeXBoZW4nIH0gXSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnYXMnOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICdiJzogeyBhY3Rpb25fOiAnYj0nIH0sXG4gICAgICAgICAgJ28nOiB7IGFjdGlvbl86IHsgdHlwZV86ICctIGFmdGVyIG8vZCcsIG9wdGlvbjogZmFsc2UgfSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogeyB0eXBlXzogJy0gYWZ0ZXIgby9kJywgb3B0aW9uOiBmYWxzZSB9LCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICdkfHFkfGRxJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnLSBhZnRlciBvL2QnLCBvcHRpb246IHRydWUgfSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnRHxxRHxwJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdhbW91bnQyJzoge1xuICAgICAgICAgICcxfDMnOiB7IGFjdGlvbl86ICdhPScsIG5leHRTdGF0ZTogJ2EnIH0gfSxcbiAgICAgICAgJ2xldHRlcnMnOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xifHB8YnB8byc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAncXxkcSc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnbz0nXSwgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAnZHxEfHFkfHFEJzogeyBhY3Rpb25fOiAnbyBhZnRlciBkJywgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnZGlnaXRzJzoge1xuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdxJyB9LFxuICAgICAgICAgICdkfEQnOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ2RxJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nIF0sIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJ3NwYWNlIEEnOiB7XG4gICAgICAgICAgJ2J8cHxicCc6IHt9IH0sXG4gICAgICAgICdzcGFjZSc6IHtcbiAgICAgICAgICAnYSc6IHsgbmV4dFN0YXRlOiAnYXMnIH0sXG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdzYj1mYWxzZScgfSxcbiAgICAgICAgICAnMXwyJzogeyBhY3Rpb25fOiAnc2I9dHJ1ZScgfSxcbiAgICAgICAgICAncnxydHxyZHxyZHR8cmRxJzogeyBhY3Rpb25fOiAnb3V0cHV0JywgbmV4dFN0YXRlOiAnMCcgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3NiPXRydWUnIF0sIG5leHRTdGF0ZTogJzEnfSB9LFxuICAgICAgICAnMXN0LWxldmVsIGVzY2FwZSc6IHtcbiAgICAgICAgICAnMXwyJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0K3AxJywgb3B0aW9uOiAnMXN0LWxldmVsIGVzY2FwZScgfSBdIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQrcDEnLCBvcHRpb246ICcxc3QtbGV2ZWwgZXNjYXBlJyB9IF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ1soLi4uKV0nOiB7XG4gICAgICAgICAgJ3J8cnQnOiB7IGFjdGlvbl86ICdyZD0nLCBuZXh0U3RhdGU6ICdyZCcgfSxcbiAgICAgICAgICAncmR8cmR0JzogeyBhY3Rpb25fOiAncnE9JywgbmV4dFN0YXRlOiAncmRxJyB9IH0sXG4gICAgICAgICcuLi4nOiB7XG4gICAgICAgICAgJ298ZHxEfGRxfHFkfHFEJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCIuLi5cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnZWxsaXBzaXMnIH0gXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnLiB8KiAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdhZGRpdGlvbiBjb21wb3VuZCcgfSBdLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbiAkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnc3RhdGUgb2YgYWdncmVnYXRpb24nIF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ3tbKCc6IHtcbiAgICAgICAgICAnYXxhc3xvJzogeyBhY3Rpb25fOiBbICdvPScsICdvdXRwdXQnLCAncGFyZW50aGVzaXNMZXZlbCsrJyBdLCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICcwfDF8MnwzJzogeyBhY3Rpb25fOiBbICdvPScsICdvdXRwdXQnLCAncGFyZW50aGVzaXNMZXZlbCsrJyBdLCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nLCAnb3V0cHV0JywgJ3BhcmVudGhlc2lzTGV2ZWwrKycgXSwgbmV4dFN0YXRlOiAnMicgfSB9LFxuICAgICAgICAnKV19Jzoge1xuICAgICAgICAgICcwfDF8MnwzfGJ8cHxicHxvJzogeyBhY3Rpb25fOiBbICdvPScsICdwYXJlbnRoZXNpc0xldmVsLS0nIF0sIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgJ2F8YXN8ZHxEfHF8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdvPScsICdwYXJlbnRoZXNpc0xldmVsLS0nIF0sIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJywgJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY29tbWEnIF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ15fJzogeyAgLy8gXiBhbmQgXyB3aXRob3V0IGEgc2Vuc2libGUgYXJndW1lbnRcbiAgICAgICAgICAnKic6IHsgfSB9LFxuICAgICAgICAnXnsoLi4uKX18XigkLi4uJCknOiB7XG4gICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdiJyB9LFxuICAgICAgICAgICdwJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdicCcgfSxcbiAgICAgICAgICAnM3xvJzogeyBhY3Rpb25fOiAnZD0ga3YnLCBuZXh0U3RhdGU6ICdEJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxRCcgfSxcbiAgICAgICAgICAnZHxEfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnZD0nIF0sIG5leHRTdGF0ZTogJ0QnIH0gfSxcbiAgICAgICAgJ15hfF5cXFxceHt9e318XlxcXFx4e318XlxcXFx4fFxcJyc6IHtcbiAgICAgICAgICAnMHwxfDJ8YXMnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2InIH0sXG4gICAgICAgICAgJ3AnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2JwJyB9LFxuICAgICAgICAgICczfG8nOiB7IGFjdGlvbl86ICdkPSBrdicsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJ3EnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdkfHFkfER8cUQnOiB7IGFjdGlvbl86ICdkPScgfSxcbiAgICAgICAgICAnZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdkPScgXSwgbmV4dFN0YXRlOiAnZCcgfSB9LFxuICAgICAgICAnX3soc3RhdGUgb2YgYWdncmVnYXRpb24pfSQnOiB7XG4gICAgICAgICAgJ2R8RHxxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAncT0nIF0sIG5leHRTdGF0ZTogJ3EnIH0gfSxcbiAgICAgICAgJ197KC4uLil9fF8oJC4uLiQpfF85fF9cXFxceHt9e318X1xcXFx4e318X1xcXFx4Jzoge1xuICAgICAgICAgICcwfDF8Mnxhcyc6IHsgYWN0aW9uXzogJ3A9JywgbmV4dFN0YXRlOiAncCcgfSxcbiAgICAgICAgICAnYic6IHsgYWN0aW9uXzogJ3A9JywgbmV4dFN0YXRlOiAnYnAnIH0sXG4gICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogJ3E9JywgbmV4dFN0YXRlOiAncScgfSxcbiAgICAgICAgICAnZHxEJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdkcScgfSxcbiAgICAgICAgICAncXxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3E9JyBdLCBuZXh0U3RhdGU6ICdxJyB9IH0sXG4gICAgICAgICc9PD4nOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xvfHF8ZHxEfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ2JvbmQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJyMnOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xvJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiI1wiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAne30nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ3suLi59Jzoge1xuICAgICAgICAgICcwfDF8MnwzfGF8YXN8YnxwfGJwJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICdvfGR8RHxxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nIF0sIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJyQuLi4kJzoge1xuICAgICAgICAgICdhJzogeyBhY3Rpb25fOiAnYT0nIH0sICAvLyAyJG4kXG4gICAgICAgICAgJzB8MXwyfDN8YXN8YnxwfGJwfG8nOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0sICAvLyBub3QgJ2Ftb3VudCdcbiAgICAgICAgICAnYXN8byc6IHsgYWN0aW9uXzogJ289JyB9LFxuICAgICAgICAgICdxfGR8RHxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ289JyBdLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICdcXFxcYm9uZHsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnYm9uZCcgXSwgbmV4dFN0YXRlOiBcIjNcIiB9IH0sXG4gICAgICAgICdcXFxcZnJhY3soLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnZnJhYy1vdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFxvdmVyc2V0eyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdvdmVyc2V0LW91dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXHVuZGVyc2V0eyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICd1bmRlcnNldC1vdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFx1bmRlcmJyYWNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICd1bmRlcmJyYWNlLW91dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0xfFxcXFxjb2xvciguLi4peyguLi4pfTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnY29sb3Itb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9MCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdjb2xvcjAtb3V0cHV0JyBdIH0gfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnY2UnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFwsJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgJ2NvcHknIF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ1xcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcwfDF8MnwzfGF8YXN8YnxwfGJwfG98YzAnOiB7IGFjdGlvbl86IFsgJ289JywgJ291dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnbz0nLCAnb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdvdGhlcnMnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnY29weScgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86ICdhIHRvIG8nLCBuZXh0U3RhdGU6ICdvJywgcmV2aXNpdDogdHJ1ZSB9LFxuICAgICAgICAgICdhcyc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3NiPXRydWUnIF0sIG5leHRTdGF0ZTogJzEnLCByZXZpc2l0OiB0cnVlIH0sXG4gICAgICAgICAgJ3J8cnR8cmR8cmR0fHJkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICcwJywgcmV2aXNpdDogdHJ1ZSB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY29weScgXSwgbmV4dFN0YXRlOiAnMycgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ28gYWZ0ZXIgZCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIGlmICgoYnVmZmVyLmQgfHwgXCJcIikubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBidWZmZXIuZDtcbiAgICAgICAgICAgIGJ1ZmZlci5kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0ID0gdGhpc1snb3V0cHV0J10oYnVmZmVyKTtcbiAgICAgICAgICAgIGJ1ZmZlci5iID0gdG1wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzWydvdXRwdXQnXShidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaGNoZW1QYXJzZXIuYWN0aW9uc1snbz0nXShidWZmZXIsIG0pO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdkPSBrdic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICBidWZmZXIuZCA9IG07XG4gICAgICAgICAgYnVmZmVyLmRUeXBlID0gJ2t2JztcbiAgICAgICAgfSxcbiAgICAgICAgJ2NoYXJnZSBvciBib25kJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIGlmIChidWZmZXJbJ2JlZ2luc1dpdGhCb25kJ10pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCB0aGlzWydvdXRwdXQnXShidWZmZXIpKTtcbiAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5hY3Rpb25zWydib25kJ10oYnVmZmVyLCBtLCBcIi1cIikpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLmQgPSBtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJy0gYWZ0ZXIgby9kJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgaXNBZnRlckQpIHtcbiAgICAgICAgICB2YXIgYzEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdvcmJpdGFsJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgdmFyIGMyID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnb25lIGxvd2VyY2FzZSBncmVlayBsZXR0ZXIgJCcsIGJ1ZmZlci5vIHx8IFwiXCIpO1xuICAgICAgICAgIHZhciBjMyA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ29uZSBsb3dlcmNhc2UgbGF0aW4gbGV0dGVyICQnLCBidWZmZXIubyB8fCBcIlwiKTtcbiAgICAgICAgICB2YXIgYzQgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCckb25lIGxvd2VyY2FzZSBsYXRpbiBsZXR0ZXIkICQnLCBidWZmZXIubyB8fCBcIlwiKTtcbiAgICAgICAgICB2YXIgaHlwaGVuRm9sbG93cyA9ICBtPT09XCItXCIgJiYgKCBjMSAmJiBjMS5yZW1haW5kZXI9PT1cIlwiICB8fCAgYzIgIHx8ICBjMyAgfHwgIGM0ICk7XG4gICAgICAgICAgaWYgKGh5cGhlbkZvbGxvd3MgJiYgIWJ1ZmZlci5hICYmICFidWZmZXIuYiAmJiAhYnVmZmVyLnAgJiYgIWJ1ZmZlci5kICYmICFidWZmZXIucSAmJiAhYzEgJiYgYzMpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5vID0gJyQnICsgYnVmZmVyLm8gKyAnJCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgIGlmIChoeXBoZW5Gb2xsb3dzKSB7XG4gICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCB0aGlzWydvdXRwdXQnXShidWZmZXIpKTtcbiAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICdoeXBoZW4nIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjMSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ2RpZ2l0cycsIGJ1ZmZlci5kIHx8IFwiXCIpO1xuICAgICAgICAgICAgaWYgKGlzQWZ0ZXJEICYmIGMxICYmIGMxLnJlbWFpbmRlcj09PScnKSB7XG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5hY3Rpb25zWydkPSddKGJ1ZmZlciwgbSkpO1xuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCB0aGlzWydvdXRwdXQnXShidWZmZXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIHRoaXNbJ291dHB1dCddKGJ1ZmZlcikpO1xuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuYWN0aW9uc1snYm9uZCddKGJ1ZmZlciwgbSwgXCItXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ2EgdG8gbyc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICBidWZmZXIubyA9IGJ1ZmZlci5hO1xuICAgICAgICAgIGJ1ZmZlci5hID0gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICAnc2I9dHJ1ZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyLnNiID0gdHJ1ZTsgfSxcbiAgICAgICAgJ3NiPWZhbHNlJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXIuc2IgPSBmYWxzZTsgfSxcbiAgICAgICAgJ2JlZ2luc1dpdGhCb25kPXRydWUnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlclsnYmVnaW5zV2l0aEJvbmQnXSA9IHRydWU7IH0sXG4gICAgICAgICdiZWdpbnNXaXRoQm9uZD1mYWxzZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyWydiZWdpbnNXaXRoQm9uZCddID0gZmFsc2U7IH0sXG4gICAgICAgICdwYXJlbnRoZXNpc0xldmVsKysnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlclsncGFyZW50aGVzaXNMZXZlbCddKys7IH0sXG4gICAgICAgICdwYXJlbnRoZXNpc0xldmVsLS0nOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlclsncGFyZW50aGVzaXNMZXZlbCddLS07IH0sXG4gICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJywgcDE6IG1oY2hlbVBhcnNlci5nbyhtLCAnbycpIH07XG4gICAgICAgIH0sXG4gICAgICAgICdjb21tYSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICB2YXIgYSA9IG0ucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG4gICAgICAgICAgdmFyIHdpdGhTcGFjZSA9IChhICE9PSBtKTtcbiAgICAgICAgICBpZiAod2l0aFNwYWNlICAmJiAgYnVmZmVyWydwYXJlbnRoZXNpc0xldmVsJ10gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29tbWEgZW51bWVyYXRpb24gTCcsIHAxOiBhIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29tbWEgZW51bWVyYXRpb24gTScsIHAxOiBhIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgZW50aXR5Rm9sbG93cykge1xuICAgICAgICAgIC8vIGVudGl0eUZvbGxvd3M6XG4gICAgICAgICAgLy8gICB1bmRlZmluZWQgPSBpZiB3ZSBoYXZlIG5vdGhpbmcgZWxzZSB0byBvdXRwdXQsIGFsc28gaWdub3JlIHRoZSBqdXN0IHJlYWQgc3BhY2UgKGJ1ZmZlci5zYilcbiAgICAgICAgICAvLyAgIDEgPSBhbiBlbnRpdHkgZm9sbG93cywgbmV2ZXIgb21pdCB0aGUgc3BhY2UgaWYgdGhlcmUgd2FzIG9uZSBqdXN0IHJlYWQgYmVmb3JlIChjYW4gb25seSBhcHBseSB0byBzdGF0ZSAxKVxuICAgICAgICAgIC8vICAgMiA9IDEgKyB0aGUgZW50aXR5IGNhbiBoYXZlIGFuIGFtb3VudCwgc28gb3V0cHV0IGFcXCwgaW5zdGVhZCBvZiBjb252ZXJ0aW5nIGl0IHRvIG8gKGNhbiBvbmx5IGFwcGx5IHRvIHN0YXRlcyBhfGFzKVxuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0IHwgUGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICBpZiAoIWJ1ZmZlci5yKSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIGlmICghYnVmZmVyLmEgJiYgIWJ1ZmZlci5iICYmICFidWZmZXIucCAmJiAhYnVmZmVyLm8gJiYgIWJ1ZmZlci5xICYmICFidWZmZXIuZCAmJiAhZW50aXR5Rm9sbG93cykge1xuICAgICAgICAgICAgICAvL3JldCA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5zYikge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICdlbnRpdHlTa2lwJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWJ1ZmZlci5vICYmICFidWZmZXIucSAmJiAhYnVmZmVyLmQgJiYgIWJ1ZmZlci5iICYmICFidWZmZXIucCAmJiBlbnRpdHlGb2xsb3dzIT09Mikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5vID0gYnVmZmVyLmE7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJ1ZmZlci5vICYmICFidWZmZXIucSAmJiAhYnVmZmVyLmQgJiYgKGJ1ZmZlci5iIHx8IGJ1ZmZlci5wKSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5vID0gYnVmZmVyLmE7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmQgPSBidWZmZXIuYjtcbiAgICAgICAgICAgICAgICBidWZmZXIucSA9IGJ1ZmZlci5wO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hID0gYnVmZmVyLmIgPSBidWZmZXIucCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLm8gJiYgYnVmZmVyLmRUeXBlPT09J2t2JyAmJiBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdkLW94aWRhdGlvbiQnLCBidWZmZXIuZCB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyLmRUeXBlID0gJ294aWRhdGlvbic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIubyAmJiBidWZmZXIuZFR5cGU9PT0na3YnICYmICFidWZmZXIucSkge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyLmRUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZV86ICdjaGVtZml2ZScsXG4gICAgICAgICAgICAgICAgYTogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5hLCAnYScpLFxuICAgICAgICAgICAgICAgIGI6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIuYiwgJ2JkJyksXG4gICAgICAgICAgICAgICAgcDogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5wLCAncHEnKSxcbiAgICAgICAgICAgICAgICBvOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLm8sICdvJyksXG4gICAgICAgICAgICAgICAgcTogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5xLCAncHEnKSxcbiAgICAgICAgICAgICAgICBkOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLmQsIChidWZmZXIuZFR5cGUgPT09ICdveGlkYXRpb24nID8gJ294aWRhdGlvbicgOiAnYmQnKSksXG4gICAgICAgICAgICAgICAgZFR5cGU6IGJ1ZmZlci5kVHlwZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgeyAgLy8gclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICAgIHZhciByZDtcbiAgICAgICAgICAgIGlmIChidWZmZXIucmR0ID09PSAnTScpIHtcbiAgICAgICAgICAgICAgcmQgPSBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnJkLCAndGV4LW1hdGgnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLnJkdCA9PT0gJ1QnKSB7XG4gICAgICAgICAgICAgIHJkID0gWyB7IHR5cGVfOiAndGV4dCcsIHAxOiBidWZmZXIucmQgfHwgXCJcIiB9IF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZCA9IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICAgIHZhciBycTtcbiAgICAgICAgICAgIGlmIChidWZmZXIucnF0ID09PSAnTScpIHtcbiAgICAgICAgICAgICAgcnEgPSBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnJxLCAndGV4LW1hdGgnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLnJxdCA9PT0gJ1QnKSB7XG4gICAgICAgICAgICAgIHJxID0gWyB7IHR5cGVfOiAndGV4dCcsIHAxOiBidWZmZXIucnEgfHwgXCJcIn0gXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJxID0gbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5ycSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQgPSB7XG4gICAgICAgICAgICAgIHR5cGVfOiAnYXJyb3cnLFxuICAgICAgICAgICAgICByOiBidWZmZXIucixcbiAgICAgICAgICAgICAgcmQ6IHJkLFxuICAgICAgICAgICAgICBycTogcnFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAocCAhPT0gJ3BhcmVudGhlc2lzTGV2ZWwnICAmJiAgcCAhPT0gJ2JlZ2luc1dpdGhCb25kJykge1xuICAgICAgICAgICAgICBkZWxldGUgYnVmZmVyW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnb3hpZGF0aW9uLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICB2YXIgcmV0ID0gWyBcIntcIiBdO1xuICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtLCAnb3hpZGF0aW9uJykpO1xuICAgICAgICAgIHJldC5wdXNoKFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnZnJhYy1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdmcmFjLWNlJywgcDE6IG1oY2hlbVBhcnNlci5nbyhtWzBdKSwgcDI6IG1oY2hlbVBhcnNlci5nbyhtWzFdKSB9O1xuICAgICAgICB9LFxuICAgICAgICAnb3ZlcnNldC1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdvdmVyc2V0JywgcDE6IG1oY2hlbVBhcnNlci5nbyhtWzBdKSwgcDI6IG1oY2hlbVBhcnNlci5nbyhtWzFdKSB9O1xuICAgICAgICB9LFxuICAgICAgICAndW5kZXJzZXQtb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAndW5kZXJzZXQnLCBwMTogbWhjaGVtUGFyc2VyLmdvKG1bMF0pLCBwMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0pIH07XG4gICAgICAgIH0sXG4gICAgICAgICd1bmRlcmJyYWNlLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ3VuZGVyYnJhY2UnLCBwMTogbWhjaGVtUGFyc2VyLmdvKG1bMF0pLCBwMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0pIH07XG4gICAgICAgIH0sXG4gICAgICAgICdjb2xvci1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb2xvcicsIGNvbG9yMTogbVswXSwgY29sb3IyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3I9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuciA9IG07IH0sXG4gICAgICAgICdyZHQ9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucmR0ID0gbTsgfSxcbiAgICAgICAgJ3JkPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJkID0gbTsgfSxcbiAgICAgICAgJ3JxdD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ycXQgPSBtOyB9LFxuICAgICAgICAncnE9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucnEgPSBtOyB9LFxuICAgICAgICAnb3BlcmF0b3InOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBwMSkgeyByZXR1cm4geyB0eXBlXzogJ29wZXJhdG9yJywga2luZF86IChwMSB8fCBtKSB9OyB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnYSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAnMS8yJCc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJzEvMicgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnMScsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnJCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoIHRpZ2h0JywgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnLCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2NvbW1hRGVjaW1hbCcgfSB9IH0sXG4gICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7fVxuICAgIH0sXG4gICAgJ28nOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJzEvMiQnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICcxLzInIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJzEnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJ2xldHRlcnMnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybScgfSB9LFxuICAgICAgICAnXFxcXGNhJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnY2lyY2EnIH0gfSB9LFxuICAgICAgICAnXFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICd7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAne3RleHR9JyB9IH0sXG4gICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7fVxuICAgIH0sXG4gICAgJ3RleHQnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0sXG4gICAgICAgICd7Li4ufSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQ9JyB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICdcXFxcZ3JlZWsnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdybScgXSB9IH0sXG4gICAgICAgICdcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2NvcHknIF0gfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQ9JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIGlmIChidWZmZXIudGV4dF8pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0fSAqL1xuICAgICAgICAgICAgdmFyIHJldCA9IHsgdHlwZV86ICd0ZXh0JywgcDE6IGJ1ZmZlci50ZXh0XyB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdwcSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAnc3RhdGUgb2YgYWdncmVnYXRpb24gJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJyB9IH0sXG4gICAgICAgICdpJCc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnIWYnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJyhLViBsZXR0ZXJzKSwnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdybScsIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ2Zvcm11bGEkJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICdmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICcxLzIkJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnMS8yJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICchZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnJHsoLi4uKX0kfCQoLi4uKSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAneyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQnIH0gfSxcbiAgICAgICAgJ2Eteic6IHtcbiAgICAgICAgICAnZic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICdsZXR0ZXJzJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm0nIH0gfSxcbiAgICAgICAgJy05Liw5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnOSw5JyAgfSB9LFxuICAgICAgICAnLCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCtwMScsIG9wdGlvbjogJ2NvbW1hIGVudW1lcmF0aW9uIFMnIH0gfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0xfFxcXFxjb2xvciguLi4peyguLi4pfTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvci1vdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX0wJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29sb3IwLW91dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NlJyB9IH0sXG4gICAgICAgICdcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfSxcbiAgICAgICAgJ2Vsc2UyJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnc3RhdGUgb2YgYWdncmVnYXRpb24gc3Vic2NyaXB0JywgcDE6IG1oY2hlbVBhcnNlci5nbyhtLCAnbycpIH07XG4gICAgICAgIH0sXG4gICAgICAgICdjb2xvci1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb2xvcicsIGNvbG9yMTogbVswXSwgY29sb3IyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSwgJ3BxJykgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2JkJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHt9IH0sXG4gICAgICAgICd4JCc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnIWYnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJ2Zvcm11bGEkJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICdmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICchZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnLTkuLDkgbm8gbWlzc2luZyAwJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnOSw5JyB9IH0sXG4gICAgICAgICcuJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnZWxlY3Ryb24gZG90JyB9IH0gfSxcbiAgICAgICAgJ2Eteic6IHtcbiAgICAgICAgICAnZic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICd4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnS1YgeCcgfSB9IH0sXG4gICAgICAgICdsZXR0ZXJzJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm0nIH0gfSxcbiAgICAgICAgJ1xcJyc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ3ByaW1lJyB9IH0gfSxcbiAgICAgICAgJyR7KC4uLil9JHwkKC4uLikkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ3soLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0JyB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9eyguLi4pfTF8XFxcXGNvbG9yKC4uLil7KC4uLil9Mic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvbG9yLW91dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfTAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvcjAtb3V0cHV0JyB9IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY2UnIH0gfSxcbiAgICAgICAgJ1xcXFwsfFxcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9LFxuICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnY29sb3Itb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29sb3InLCBjb2xvcjE6IG1bMF0sIGNvbG9yMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0sICdiZCcpIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdveGlkYXRpb24nOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJ3JvbWFuIG51bWVyYWwnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdyb21hbi1udW1lcmFsJyB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ3JvbWFuLW51bWVyYWwnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiB7IHR5cGVfOiAncm9tYW4gbnVtZXJhbCcsIHAxOiBtIHx8IFwiXCIgfTsgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3RleC1tYXRoJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2NlJyBdIH0gfSxcbiAgICAgICAgJ3suLi59fFxcXFwsfFxcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnbz0nIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvPScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLm8pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0fSAqL1xuICAgICAgICAgICAgdmFyIHJldCA9IHsgdHlwZV86ICd0ZXgtbWF0aCcsIHAxOiBidWZmZXIubyB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICd0ZXgtbWF0aCB0aWdodCc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdjZScgXSB9IH0sXG4gICAgICAgICd7Li4ufXxcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ289JyB9IH0sXG4gICAgICAgICctfCsnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0aWdodCBvcGVyYXRvcicgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ289JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAndGlnaHQgb3BlcmF0b3InOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5vID0gKGJ1ZmZlci5vIHx8IFwiXCIpICsgXCJ7XCIrbStcIn1cIjsgfSxcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLm8pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0fSAqL1xuICAgICAgICAgICAgdmFyIHJldCA9IHsgdHlwZV86ICd0ZXgtbWF0aCcsIHAxOiBidWZmZXIubyB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICc5LDknOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJywnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb21tYScgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdjb21tYSc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICdjb21tYURlY2ltYWwnIH07IH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vI2VuZHJlZ2lvblxuICAgIC8vXG4gICAgLy8gXFxwdSBzdGF0ZSBtYWNoaW5lc1xuICAgIC8vXG4gICAgLy8jcmVnaW9uIHB1XG4gICAgJ3B1Jzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnc3BhY2UkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnc3BhY2UnIF0gfSB9LFxuICAgICAgICAne1sofCldfSc6IHtcbiAgICAgICAgICAnMHxhJzogeyBhY3Rpb25fOiAnY29weScgfSB9LFxuICAgICAgICAnKC0pKDkpXigtOSknOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdudW1iZXJeJywgbmV4dFN0YXRlOiAnYScgfSB9LFxuICAgICAgICAnKC0pKDkuLDkpKGUpKDk5KSc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ2VudW1iZXInLCBuZXh0U3RhdGU6ICdhJyB9IH0sXG4gICAgICAgICdzcGFjZSc6IHtcbiAgICAgICAgICAnMHxhJzoge30gfSxcbiAgICAgICAgJ3BtLW9wZXJhdG9yJzoge1xuICAgICAgICAgICcwfGEnOiB7IGFjdGlvbl86IHsgdHlwZV86ICdvcGVyYXRvcicsIG9wdGlvbjogJ1xcXFxwbScgfSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnb3BlcmF0b3InOiB7XG4gICAgICAgICAgJzB8YSc6IHsgYWN0aW9uXzogJ2NvcHknLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICcvLyc6IHtcbiAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnLycgfSB9LFxuICAgICAgICAnLyc6IHtcbiAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnLycgfSB9LFxuICAgICAgICAney4uLn18ZWxzZSc6IHtcbiAgICAgICAgICAnMHxkJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICdhJzogeyBhY3Rpb25fOiBbICdzcGFjZScsICdkPScgXSwgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnL3xxJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdxJyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnZW51bWJlcic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBpZiAobVswXSA9PT0gXCIrLVwiICB8fCAgbVswXSA9PT0gXCIrLy1cIikge1xuICAgICAgICAgICAgcmV0LnB1c2goXCJcXFxccG0gXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobVswXSkge1xuICAgICAgICAgICAgcmV0LnB1c2gobVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtWzFdKSB7XG4gICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuZ28obVsxXSwgJ3B1LTksOScpKTtcbiAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgIGlmIChtWzJdLm1hdGNoKC9bLC5dLykpIHtcbiAgICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuZ28obVsyXSwgJ3B1LTksOScpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChtWzJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVszXSA9IG1bNF0gfHwgbVszXTtcbiAgICAgICAgICAgIGlmIChtWzNdKSB7XG4gICAgICAgICAgICAgIG1bM10gPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKG1bM10gPT09IFwiZVwiICB8fCAgbVszXS5zdWJzdHIoMCwgMSkgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2Nkb3QnIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICd0aW1lcycgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1bM10pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKFwiMTBee1wiK21bNV0rXCJ9XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnbnVtYmVyXic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBpZiAobVswXSA9PT0gXCIrLVwiICB8fCAgbVswXSA9PT0gXCIrLy1cIikge1xuICAgICAgICAgICAgcmV0LnB1c2goXCJcXFxccG0gXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobVswXSkge1xuICAgICAgICAgICAgcmV0LnB1c2gobVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtWzFdLCAncHUtOSw5JykpO1xuICAgICAgICAgIHJldC5wdXNoKFwiXntcIittWzJdK1wifVwiKTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnb3BlcmF0b3InOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBwMSkgeyByZXR1cm4geyB0eXBlXzogJ29wZXJhdG9yJywga2luZF86IChwMSB8fCBtKSB9OyB9LFxuICAgICAgICAnc3BhY2UnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAncHUtc3BhY2UtMScgfTsgfSxcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dCB8IFBhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgdmFyIG1kID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygneyguLi4pfScsIGJ1ZmZlci5kIHx8IFwiXCIpO1xuICAgICAgICAgIGlmIChtZCAgJiYgIG1kLnJlbWFpbmRlciA9PT0gJycpIHsgYnVmZmVyLmQgPSBtZC5tYXRjaF87IH1cbiAgICAgICAgICB2YXIgbXEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCd7KC4uLil9JywgYnVmZmVyLnEgfHwgXCJcIik7XG4gICAgICAgICAgaWYgKG1xICAmJiAgbXEucmVtYWluZGVyID09PSAnJykgeyBidWZmZXIucSA9IG1xLm1hdGNoXzsgfVxuICAgICAgICAgIGlmIChidWZmZXIuZCkge1xuICAgICAgICAgICAgYnVmZmVyLmQgPSBidWZmZXIuZC5yZXBsYWNlKC9cXHUwMEIwQ3xcXF5vQ3xcXF57b31DL2csIFwie31ee1xcXFxjaXJjfUNcIik7XG4gICAgICAgICAgICBidWZmZXIuZCA9IGJ1ZmZlci5kLnJlcGxhY2UoL1xcdTAwQjBGfFxcXm9GfFxcXntvfUYvZywgXCJ7fV57XFxcXGNpcmN9RlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ1ZmZlci5xKSB7ICAvLyBmcmFjdGlvblxuICAgICAgICAgICAgYnVmZmVyLnEgPSBidWZmZXIucS5yZXBsYWNlKC9cXHUwMEIwQ3xcXF5vQ3xcXF57b31DL2csIFwie31ee1xcXFxjaXJjfUNcIik7XG4gICAgICAgICAgICBidWZmZXIucSA9IGJ1ZmZlci5xLnJlcGxhY2UoL1xcdTAwQjBGfFxcXm9GfFxcXntvfUYvZywgXCJ7fV57XFxcXGNpcmN9RlwiKTtcbiAgICAgICAgICAgIHZhciBiNSA9IHtcbiAgICAgICAgICAgICAgZDogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5kLCAncHUnKSxcbiAgICAgICAgICAgICAgcTogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5xLCAncHUnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubyA9PT0gJy8vJykge1xuICAgICAgICAgICAgICByZXQgPSB7IHR5cGVfOiAncHUtZnJhYycsIHAxOiBiNS5kLCBwMjogYjUucSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0gYjUuZDtcbiAgICAgICAgICAgICAgaWYgKGI1LmQubGVuZ3RoID4gMSAgfHwgIGI1LnEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcgLyAnIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcvJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBiNS5xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgeyAgLy8gbm8gZnJhY3Rpb25cbiAgICAgICAgICAgIHJldCA9IG1oY2hlbVBhcnNlci5nbyhidWZmZXIuZCwgJ3B1LTInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdwdS0yJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnKic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2Nkb3QnIF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ1xcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm09JyB9IH0sXG4gICAgICAgICdzcGFjZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3NwYWNlJyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdeeyguLi4pfXxeKC0xKSc6IHtcbiAgICAgICAgICAnMSc6IHsgYWN0aW9uXzogJ14oLTEpJyB9IH0sXG4gICAgICAgICctOS4sOSc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ3JtPScsIG5leHRTdGF0ZTogJzAnIH0sXG4gICAgICAgICAgJzEnOiB7IGFjdGlvbl86ICdeKC0xKScsIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ3suLi59fGVsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybT0nLCBuZXh0U3RhdGU6ICcxJyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnY2RvdCc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICd0aWdodCBjZG90JyB9OyB9LFxuICAgICAgICAnXigtMSknOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ybSArPSBcIl57XCIrbStcIn1cIjsgfSxcbiAgICAgICAgJ3NwYWNlJzogZnVuY3Rpb24gKCkgeyByZXR1cm4geyB0eXBlXzogJ3B1LXNwYWNlLTInIH07IH0sXG4gICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXQgfCBQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgaWYgKGJ1ZmZlci5ybSkge1xuICAgICAgICAgICAgdmFyIG1ybSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ3soLi4uKX0nLCBidWZmZXIucm0gfHwgXCJcIik7XG4gICAgICAgICAgICBpZiAobXJtICAmJiAgbXJtLnJlbWFpbmRlciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0ID0gbWhjaGVtUGFyc2VyLmdvKG1ybS5tYXRjaF8sICdwdScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0geyB0eXBlXzogJ3JtJywgcDE6IGJ1ZmZlci5ybSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3B1LTksOSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdvdXRwdXQtMCcgfSxcbiAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogJ291dHB1dC1vJyB9IH0sXG4gICAgICAgICcsJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiBbICdvdXRwdXQtMCcsICdjb21tYScgXSwgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnLic6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0LTAnLCAnY29weScgXSwgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQ9JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnY29tbWEnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAnY29tbWFEZWNpbWFsJyB9OyB9LFxuICAgICAgICAnb3V0cHV0LTAnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgYnVmZmVyLnRleHRfID0gYnVmZmVyLnRleHRfIHx8IFwiXCI7XG4gICAgICAgICAgaWYgKGJ1ZmZlci50ZXh0Xy5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGJ1ZmZlci50ZXh0Xy5sZW5ndGggJSAzO1xuICAgICAgICAgICAgaWYgKGEgPT09IDApIHsgYSA9IDM7IH1cbiAgICAgICAgICAgIGZvciAodmFyIGk9YnVmZmVyLnRleHRfLmxlbmd0aC0zOyBpPjA7IGktPTMpIHtcbiAgICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfLnN1YnN0cihpLCAzKSk7XG4gICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcxMDAwIHNlcGFyYXRvcicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKDAsIGEpKTtcbiAgICAgICAgICAgIHJldC5yZXZlcnNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnb3V0cHV0LW8nOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgYnVmZmVyLnRleHRfID0gYnVmZmVyLnRleHRfIHx8IFwiXCI7XG4gICAgICAgICAgaWYgKGJ1ZmZlci50ZXh0Xy5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGJ1ZmZlci50ZXh0Xy5sZW5ndGggLSAzO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGE7IGkrPTMpIHtcbiAgICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfLnN1YnN0cihpLCAzKSk7XG4gICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcxMDAwIHNlcGFyYXRvcicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKGkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gIH07XG5cbiAgLy9cbiAgLy8gdGV4aWZ5OiBUYWtlIE1oY2hlbVBhcnNlciBvdXRwdXQgYW5kIGNvbnZlcnQgaXQgdG8gVGVYXG4gIC8vXG4gIC8qKiBAdHlwZSB7VGV4aWZ5fSAqL1xuICB2YXIgdGV4aWZ5ID0ge1xuICAgIGdvOiBmdW5jdGlvbiAoaW5wdXQsIGlzSW5uZXIpIHsgIC8vIChyZWN1cnNpdmUsIG1heCA0IGxldmVscylcbiAgICAgIGlmICghaW5wdXQpIHsgcmV0dXJuIFwiXCI7IH1cbiAgICAgIHZhciByZXMgPSBcIlwiO1xuICAgICAgdmFyIGNlZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaT0wOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0aSA9IGlucHV0W2ldO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0aSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJlcyArPSBpbnB1dGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzICs9IHRleGlmeS5fZ28yKGlucHV0aSk7XG4gICAgICAgICAgaWYgKGlucHV0aS50eXBlXyA9PT0gJzFzdC1sZXZlbCBlc2NhcGUnKSB7IGNlZSA9IHRydWU7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc0lubmVyICYmICFjZWUgJiYgcmVzKSB7XG4gICAgICAgIHJlcyA9IFwie1wiICsgcmVzICsgXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgX2dvSW5uZXI6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaWYgKCFpbnB1dCkgeyByZXR1cm4gaW5wdXQ7IH1cbiAgICAgIHJldHVybiB0ZXhpZnkuZ28oaW5wdXQsIHRydWUpO1xuICAgIH0sXG4gICAgX2dvMjogZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgLyoqIEB0eXBlIHt1bmRlZmluZWQgfCBzdHJpbmd9ICovXG4gICAgICB2YXIgcmVzO1xuICAgICAgc3dpdGNoIChidWYudHlwZV8pIHtcbiAgICAgICAgY2FzZSAnY2hlbWZpdmUnOlxuICAgICAgICAgIHJlcyA9IFwiXCI7XG4gICAgICAgICAgdmFyIGI1ID0ge1xuICAgICAgICAgICAgYTogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5hKSxcbiAgICAgICAgICAgIGI6IHRleGlmeS5fZ29Jbm5lcihidWYuYiksXG4gICAgICAgICAgICBwOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLnApLFxuICAgICAgICAgICAgbzogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5vKSxcbiAgICAgICAgICAgIHE6IHRleGlmeS5fZ29Jbm5lcihidWYucSksXG4gICAgICAgICAgICBkOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLmQpXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGFcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChiNS5hKSB7XG4gICAgICAgICAgICBpZiAoYjUuYS5tYXRjaCgvXlsrXFwtXS8pKSB7IGI1LmEgPSBcIntcIitiNS5hK1wifVwiOyB9XG4gICAgICAgICAgICByZXMgKz0gYjUuYSArIFwiXFxcXCxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBiIGFuZCBwXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoYjUuYiB8fCBiNS5wKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgcmVzICs9IFwiXntcXFxcaHBoYW50b217XCIrKGI1LmJ8fFwiXCIpK1wifX1fe1xcXFxocGhhbnRvbXtcIisoYjUucHx8XCJcIikrXCJ9fVwiO1xuICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgIC8vIEluIHRoZSBuZXh0IHR3byBsaW5lcywgSSd2ZSByZW1vdmVkIFxcc21hc2hbdF0gKHJvbilcbiAgICAgICAgICAgIC8vIFRPRE86IFJldmVydCBcXHNtYXNoW3RdIHdoZW4gV2ViS2l0IHByb3Blcmx5IHJlbmRlcnMgPG1wYWRkZWQ+IHcvaGVpZ2h0PVwiMFwiXG4gICAgICAgICAgICAvL3JlcyArPSBcIl57XFxcXHNtYXNoW3Rde1xcXFx2cGhhbnRvbXsyfX1cXFxcbWF0aGxsYXB7XCIrKGI1LmJ8fFwiXCIpK1wifX1cIjtcbiAgICAgICAgICAgIHJlcyArPSBcIl57XFxcXHZwaGFudG9tezJ9XFxcXG1hdGhsbGFwe1wiKyhiNS5ifHxcIlwiKStcIn19XCI7XG4gICAgICAgICAgICAvL3JlcyArPSBcIl97XFxcXHZwaGFudG9tezJ9XFxcXG1hdGhsbGFwe1xcXFxzbWFzaFt0XXtcIisoYjUucHx8XCJcIikrXCJ9fX1cIjtcbiAgICAgICAgICAgIHJlcyArPSBcIl97XFxcXHZwaGFudG9tezJ9XFxcXG1hdGhsbGFwe1wiKyhiNS5wfHxcIlwiKStcIn19XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gb1xuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKGI1Lm8pIHtcbiAgICAgICAgICAgIGlmIChiNS5vLm1hdGNoKC9eWytcXC1dLykpIHsgYjUubyA9IFwie1wiK2I1Lm8rXCJ9XCI7IH1cbiAgICAgICAgICAgIHJlcyArPSBiNS5vO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIHEgYW5kIGRcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChidWYuZFR5cGUgPT09ICdrdicpIHtcbiAgICAgICAgICAgIGlmIChiNS5kIHx8IGI1LnEpIHtcbiAgICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5kKSB7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl57XCIrYjUuZCtcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5xKSB7XG4gICAgICAgICAgICAgIC8vIEluIHRoZSBuZXh0IGxpbmUsIEkndmUgcmVtb3ZlZCBcXHNtYXNoW3RdIChyb24pXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJldmVydCBcXHNtYXNoW3RdIHdoZW4gV2ViS2l0IHByb3Blcmx5IHJlbmRlcnMgPG1wYWRkZWQ+IHcvaGVpZ2h0PVwiMFwiXG4gICAgICAgICAgICAgIC8vcmVzICs9IFwiX3tcXFxcc21hc2hbdF17XCIrYjUucStcIn19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl97XCIrYjUucStcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGJ1Zi5kVHlwZSA9PT0gJ294aWRhdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChiNS5kKSB7XG4gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl57XCIrYjUuZCtcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5xKSB7XG4gICAgICAgICAgICAgIC8vIEEgRmlyZWZveCBidWcgYWRkcyBhIGJvZ3VzIGRlcHRoIHRvIDxtcGhhbnRvbT4sIHNvIHdlIGNoYW5nZSBcXHZwaGFudG9te1h9IHRvIHt9XG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlaW5zdGF0ZSBcXHZwaGFudG9te1h9IHdoZW4gdGhlIEZpcmVmb3ggYnVnIGlzIGZpeGVkLlxuLy8gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcInt7fX1cIjtcbiAgICAgICAgICAgICAgLy8gSW4gdGhlIG5leHQgbGluZSwgSSd2ZSByZW1vdmVkIFxcc21hc2hbdF0gKHJvbilcbiAgICAgICAgICAgICAgLy8gVE9ETzogUmV2ZXJ0IFxcc21hc2hbdF0gd2hlbiBXZWJLaXQgcHJvcGVybHkgcmVuZGVycyA8bXBhZGRlZD4gdy9oZWlnaHQ9XCIwXCJcbiAgICAgICAgICAgICAgLy9yZXMgKz0gXCJfe1xcXFxzbWFzaFt0XXtcIitiNS5xK1wifX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwiX3tcIitiNS5xK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYjUucSkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBSZWluc3RhdGUgXFx2cGhhbnRvbXtYfSB3aGVuIHRoZSBGaXJlZm94IGJ1ZyBpcyBmaXhlZC5cbi8vICAgICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJ7e319XCI7XG4gICAgICAgICAgICAgIC8vIEluIHRoZSBuZXh0IGxpbmUsIEkndmUgcmVtb3ZlZCBcXHNtYXNoW3RdIChyb24pXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJldmVydCBcXHNtYXNoW3RdIHdoZW4gV2ViS2l0IHByb3Blcmx5IHJlbmRlcnMgPG1wYWRkZWQ+IHcvaGVpZ2h0PVwiMFwiXG4gICAgICAgICAgICAgIC8vcmVzICs9IFwiX3tcXFxcc21hc2hbdF17XCIrYjUucStcIn19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl97XCIrYjUucStcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5kKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlaW5zdGF0ZSBcXHZwaGFudG9te1h9IHdoZW4gdGhlIEZpcmVmb3ggYnVnIGlzIGZpeGVkLlxuLy8gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcInt7fX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwiXntcIitiNS5kK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncm0nOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhybXtcIitidWYucDErXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIGlmIChidWYucDEubWF0Y2goL1tcXF5fXS8pKSB7XG4gICAgICAgICAgICBidWYucDEgPSBidWYucDEucmVwbGFjZShcIiBcIiwgXCJ+XCIpLnJlcGxhY2UoXCItXCIsIFwiXFxcXHRleHR7LX1cIik7XG4gICAgICAgICAgICByZXMgPSBcIlxcXFxtYXRocm17XCIrYnVmLnAxK1wifVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBcIlxcXFx0ZXh0e1wiK2J1Zi5wMStcIn1cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JvbWFuIG51bWVyYWwnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhybXtcIitidWYucDErXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxtc2tpcDJtdSBcIit0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RhdGUgb2YgYWdncmVnYXRpb24gc3Vic2NyaXB0JzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxtc2tpcDFtdSBcIit0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm9uZCc6XG4gICAgICAgICAgcmVzID0gdGV4aWZ5Ll9nZXRCb25kKGJ1Zi5raW5kXyk7XG4gICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IFtcIk1oY2hlbUVycm9yQm9uZFwiLCBcIm1oY2hlbSBFcnJvci4gVW5rbm93biBib25kIHR5cGUgKFwiICsgYnVmLmtpbmRfICsgXCIpXCJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnJhYyc6XG4gICAgICAgICAgdmFyIGMgPSBcIlxcXFxmcmFje1wiICsgYnVmLnAxICsgXCJ9e1wiICsgYnVmLnAyICsgXCJ9XCI7XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWF0aGNob2ljZXtcXFxcdGV4dHN0eWxlXCIrYytcIn17XCIrYytcIn17XCIrYytcIn17XCIrYytcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHUtZnJhYyc6XG4gICAgICAgICAgdmFyIGQgPSBcIlxcXFxmcmFje1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhjaG9pY2V7XFxcXHRleHRzdHlsZVwiK2QrXCJ9e1wiK2QrXCJ9e1wiK2QrXCJ9e1wiK2QrXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RleC1tYXRoJzpcbiAgICAgICAgICByZXMgPSBidWYucDEgKyBcIiBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnJhYy1jZSc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcZnJhY3tcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3ZlcnNldCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcb3ZlcnNldHtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndW5kZXJzZXQnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXHVuZGVyc2V0e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1bmRlcmJyYWNlJzpcbiAgICAgICAgICByZXMgPSAgXCJcXFxcdW5kZXJicmFjZXtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9X3tcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDIpICsgXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICByZXMgPSBcIntcXFxcY29sb3J7XCIgKyBidWYuY29sb3IxICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5jb2xvcjIpICsgXCJ9fVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2xvcjAnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXGNvbG9ye1wiICsgYnVmLmNvbG9yICsgXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Fycm93JzpcbiAgICAgICAgICB2YXIgYjYgPSB7XG4gICAgICAgICAgICByZDogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5yZCksXG4gICAgICAgICAgICBycTogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5ycSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBhcnJvdyA9IHRleGlmeS5fZ2V0QXJyb3coYnVmLnIpO1xuICAgICAgICAgIGlmIChiNi5ycSkgeyBhcnJvdyArPSBcIlt7XFxcXHJtIFwiICsgYjYucnEgKyBcIn1dXCI7IH1cbiAgICAgICAgICBpZiAoYjYucmQpIHtcbiAgICAgICAgICAgIGFycm93ICs9IFwie1xcXFxybSBcIiArIGI2LnJkICsgXCJ9XCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93ICs9IFwie31cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzID0gYXJyb3c7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29wZXJhdG9yJzpcbiAgICAgICAgICByZXMgPSB0ZXhpZnkuX2dldE9wZXJhdG9yKGJ1Zi5raW5kXyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzFzdC1sZXZlbCBlc2NhcGUnOlxuICAgICAgICAgIHJlcyA9IGJ1Zi5wMStcIiBcIjsgIC8vICYsIFxcXFxcXFxcLCBcXFxcaGxpblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgcmVzID0gXCIgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VudGl0eVNraXAnOlxuICAgICAgICAgIHJlcyA9IFwiflwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwdS1zcGFjZS0xJzpcbiAgICAgICAgICByZXMgPSBcIn5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHUtc3BhY2UtMic6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWtlcm4zbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzEwMDAgc2VwYXJhdG9yJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjJtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29tbWFEZWNpbWFsJzpcbiAgICAgICAgICByZXMgPSBcInssfVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NvbW1hIGVudW1lcmF0aW9uIEwnOlxuICAgICAgICAgIHJlcyA9IFwie1wiK2J1Zi5wMStcIn1cXFxcbWtlcm42bXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbW1hIGVudW1lcmF0aW9uIE0nOlxuICAgICAgICAgIHJlcyA9IFwie1wiK2J1Zi5wMStcIn1cXFxcbWtlcm4zbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbW1hIGVudW1lcmF0aW9uIFMnOlxuICAgICAgICAgIHJlcyA9IFwie1wiK2J1Zi5wMStcIn1cXFxcbWtlcm4xbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2h5cGhlbic6XG4gICAgICAgICAgcmVzID0gXCJcXFxcdGV4dHstfVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhZGRpdGlvbiBjb21wb3VuZCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcLHtcXFxcY2RvdH1cXFxcLFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbGVjdHJvbiBkb3QnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1rZXJuMW11IFxcXFx0ZXh0e1xcXFx0ZXh0YnVsbGV0fVxcXFxta2VybjFtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS1YgeCc6XG4gICAgICAgICAgcmVzID0gXCJ7XFxcXHRpbWVzfVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcmltZSc6XG4gICAgICAgICAgcmVzID0gXCJcXFxccHJpbWUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Nkb3QnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXGNkb3QgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RpZ2h0IGNkb3QnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1rZXJuMW11e1xcXFxjZG90fVxcXFxta2VybjFtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGltZXMnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXHRpbWVzIFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaXJjYSc6XG4gICAgICAgICAgcmVzID0gXCJ7XFxcXHNpbX1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgcmVzID0gXCJ1cGFycm93XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgIHJlcyA9IFwiZG93bmFycm93XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VsbGlwc2lzJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxsZG90cyBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgcmVzID0gXCIvXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyAvICc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcLC9cXFxcLFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydE5ldmVyKGJ1Zik7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07ICAvLyBNaXNzaW5nIHRleGlmeSBydWxlIG9yIHVua25vd24gTWhjaGVtUGFyc2VyIG91dHB1dFxuICAgICAgfVxuICAgICAgYXNzZXJ0U3RyaW5nKHJlcyk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgX2dldEFycm93OiBmdW5jdGlvbiAoYSkge1xuICAgICAgc3dpdGNoIChhKSB7XG4gICAgICAgIGNhc2UgXCItPlwiOiByZXR1cm4gXCJcXFxceWllbGRzXCI7XG4gICAgICAgIGNhc2UgXCJcXHUyMTkyXCI6IHJldHVybiBcIlxcXFx5aWVsZHNcIjtcbiAgICAgICAgY2FzZSBcIlxcdTI3RjZcIjogcmV0dXJuIFwiXFxcXHlpZWxkc1wiO1xuICAgICAgICBjYXNlIFwiPC1cIjogcmV0dXJuIFwiXFxcXHlpZWxkc0xlZnRcIjtcbiAgICAgICAgY2FzZSBcIjwtPlwiOiByZXR1cm4gXCJcXFxcbWVzb21lcmlzbVwiO1xuICAgICAgICBjYXNlIFwiPC0tPlwiOiByZXR1cm4gXCJcXFxceWllbGRzTGVmdFJpZ2h0XCI7XG4gICAgICAgIGNhc2UgXCI8PT5cIjogcmV0dXJuIFwiXFxcXGVxdWlsaWJyaXVtXCI7XG4gICAgICAgIGNhc2UgXCJcXHUyMUNDXCI6IHJldHVybiBcIlxcXFxlcXVpbGlicml1bVwiO1xuICAgICAgICBjYXNlIFwiPD0+PlwiOiByZXR1cm4gXCJcXFxcZXF1aWxpYnJpdW1SaWdodFwiO1xuICAgICAgICBjYXNlIFwiPDw9PlwiOiByZXR1cm4gXCJcXFxcZXF1aWxpYnJpdW1MZWZ0XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXNzZXJ0TmV2ZXIoYSk7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0Qm9uZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gXCJ7LX1cIjtcbiAgICAgICAgY2FzZSBcIjFcIjogcmV0dXJuIFwiey19XCI7XG4gICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiBcIns9fVwiO1xuICAgICAgICBjYXNlIFwiMlwiOiByZXR1cm4gXCJ7PX1cIjtcbiAgICAgICAgY2FzZSBcIiNcIjogcmV0dXJuIFwie1xcXFxlcXVpdn1cIjtcbiAgICAgICAgY2FzZSBcIjNcIjogcmV0dXJuIFwie1xcXFxlcXVpdn1cIjtcbiAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVEYXNofVwiO1xuICAgICAgICBjYXNlIFwifi1cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVEYXNoT3ZlckxpbmV9XCI7XG4gICAgICAgIGNhc2UgXCJ+PVwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2hPdmVyRG91YmxlTGluZX1cIjtcbiAgICAgICAgY2FzZSBcIn4tLVwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2hPdmVyRG91YmxlTGluZX1cIjtcbiAgICAgICAgY2FzZSBcIi1+LVwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2hCZXR3ZWVuRG91YmxlTGluZX1cIjtcbiAgICAgICAgY2FzZSBcIi4uLlwiOiByZXR1cm4gXCJ7e1xcXFxjZG90fXtcXFxcY2RvdH17XFxcXGNkb3R9fVwiO1xuICAgICAgICBjYXNlIFwiLi4uLlwiOiByZXR1cm4gXCJ7e1xcXFxjZG90fXtcXFxcY2RvdH17XFxcXGNkb3R9e1xcXFxjZG90fX1cIjtcbiAgICAgICAgY2FzZSBcIi0+XCI6IHJldHVybiBcIntcXFxccmlnaHRhcnJvd31cIjtcbiAgICAgICAgY2FzZSBcIjwtXCI6IHJldHVybiBcIntcXFxcbGVmdGFycm93fVwiO1xuICAgICAgICBjYXNlIFwiPFwiOiByZXR1cm4gXCJ7PH1cIjtcbiAgICAgICAgY2FzZSBcIj5cIjogcmV0dXJuIFwiez59XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXNzZXJ0TmV2ZXIoYSk7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0T3BlcmF0b3I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgY2FzZSBcIitcIjogcmV0dXJuIFwiIHt9K3t9IFwiO1xuICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gXCIge30te30gXCI7XG4gICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiBcIiB7fT17fSBcIjtcbiAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIFwiIHt9PHt9IFwiO1xuICAgICAgICBjYXNlIFwiPlwiOiByZXR1cm4gXCIge30+e30gXCI7XG4gICAgICAgIGNhc2UgXCI8PFwiOiByZXR1cm4gXCIge31cXFxcbGx7fSBcIjtcbiAgICAgICAgY2FzZSBcIj4+XCI6IHJldHVybiBcIiB7fVxcXFxnZ3t9IFwiO1xuICAgICAgICBjYXNlIFwiXFxcXHBtXCI6IHJldHVybiBcIiB7fVxcXFxwbXt9IFwiO1xuICAgICAgICBjYXNlIFwiXFxcXGFwcHJveFwiOiByZXR1cm4gXCIge31cXFxcYXBwcm94e30gXCI7XG4gICAgICAgIGNhc2UgXCIkXFxcXGFwcHJveCRcIjogcmV0dXJuIFwiIHt9XFxcXGFwcHJveHt9IFwiO1xuICAgICAgICBjYXNlIFwidlwiOiByZXR1cm4gXCIgXFxcXGRvd25hcnJvd3t9IFwiO1xuICAgICAgICBjYXNlIFwiKHYpXCI6IHJldHVybiBcIiBcXFxcZG93bmFycm93e30gXCI7XG4gICAgICAgIGNhc2UgXCJeXCI6IHJldHVybiBcIiBcXFxcdXBhcnJvd3t9IFwiO1xuICAgICAgICBjYXNlIFwiKF4pXCI6IHJldHVybiBcIiBcXFxcdXBhcnJvd3t9IFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydE5ldmVyKGEpO1xuICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1RcIiwgXCJtaGNoZW0gYnVnIFQuIFBsZWFzZSByZXBvcnQuXCJdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvL1xuICAvLyBIZWxwZXJzIGZvciBjb2RlIGFuYWx5c2lzXG4gIC8vIFdpbGwgc2hvdyB0eXBlIGVycm9yIGF0IGNhbGxpbmcgcG9zaXRpb25cbiAgLy9cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBhICovXG4gIGZ1bmN0aW9uIGFzc2VydE5ldmVyKGEpIHt9XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gYSAqL1xuICBmdW5jdGlvbiBhc3NlcnRTdHJpbmcoYSkge31cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdGV4dmMuc3R5XG5cbi8vIFRoZSB0ZXh2YyBwYWNrYWdlIGNvbnRhaW5zIG1hY3JvcyBhdmFpbGFibGUgaW4gbWVkaWF3aWtpIHBhZ2VzLlxuLy8gV2Ugb21pdCB0aGUgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgYXRcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlbHA6RGlzcGxheWluZ19hX2Zvcm11bGEjRGVwcmVjYXRlZF9zeW50YXhcblxuLy8gV2UgYWxzbyBvbWl0IHRleHZjJ3MgXFxPLCB3aGljaCBjb25mbGljdHMgd2l0aCBcXHRleHR7XFxPfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxkYXJyXCIsIFwiXFxcXGRvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRBcnJcIiwgXCJcXFxcRG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRGFyclwiLCBcIlxcXFxEb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYW5nXCIsIFwiXFxcXGxhbmdsZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhbmdcIiwgXCJcXFxccmFuZ2xlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdWFyclwiLCBcIlxcXFx1cGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdUFyclwiLCBcIlxcXFxVcGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcVWFyclwiLCBcIlxcXFxVcGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTlwiLCBcIlxcXFxtYXRoYmJ7Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFpcIiwgXCJcXFxcbWF0aGJie1p9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWxlZlwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFsZWZzeW1cIiwgXCJcXFxcYWxlcGhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxidWxsXCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNsdWJzXCIsIFwiXFxcXGNsdWJzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY251bXNcIiwgXCJcXFxcbWF0aGJie0N9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQ29tcGxleFwiLCBcIlxcXFxtYXRoYmJ7Q31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxEYWdnZXJcIiwgXCJcXFxcZGRhZ2dlclwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRpYW1vbmRzXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZW1wdHlcIiwgXCJcXFxcZW1wdHlzZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxleGlzdFwiLCBcIlxcXFxleGlzdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoYXJyXCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaEFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEhhcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoZWFydHNcIiwgXCJcXFxcaGVhcnRzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1hZ2VcIiwgXCJcXFxcSW1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbmZpblwiLCBcIlxcXFxpbmZ0eVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlzaW5cIiwgXCJcXFxcaW5cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYXJyXCIsIFwiXFxcXGxlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxBcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTGFyclwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxscmFyclwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTHJhcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuYXRudW1zXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBsdXNtblwiLCBcIlxcXFxwbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhcnJcIiwgXCJcXFxccmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJBcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJhcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxcIiwgXCJcXFxcUmVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZG90XCIsIFwiXFxcXGNkb3RcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZWN0XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzcGFkZXNcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3ViXCIsIFwiXFxcXHN1YnNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YmVcIiwgXCJcXFxcc3Vic2V0ZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdXBlXCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGhldGFzeW1cIiwgXCJcXFxcdmFydGhldGFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx3ZWllcnBcIiwgXCJcXFxcd3BcIik7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogIHBoeXNpY3MuanNcbiAqXG4gKiAgSW1wbGVtZW50cyB0aGUgUGh5c2ljcyBQYWNrYWdlIGZvciBMYVRlWCBpbnB1dC5cbiAqXG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogIFRoZSBvcmlnaW5hbCB2ZXJzaW9uIG9mIHRoaXMgZmlsZSBpcyBsaWNlbnNlZCBhcyBmb2xsb3dzOlxuICogIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IEtvbGVuIENoZXVuZyA8aHR0cHM6Ly9naXRodWIuY29tL2lja2MvTWF0aEpheC10aGlyZC1wYXJ0eS1leHRlbnNpb25zPi5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICBUaGlzIGZpbGUgaGFzIGJlZW4gcmV2aXNlZCBmcm9tIHRoZSBvcmlnaW5hbCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAgMS4gVGhlIGludGVyZmFjZSBpcyBjaGFuZ2VkIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIFRlbW1sLCBub3QgTWF0aEpheC5cbiAqICAyLiBcXFJlIGFuZCBcXEltIGFyZSBub3QgdXNlZCwgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBleGlzdGluZyBMYVRlWCBsZXR0ZXJzLlxuICpcbiAqICBUaGlzIHJldmlzaW9uIG9mIHRoZSBmaWxlIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqICBodHRwczovL21pdC1saWNlbnNlLm9yZy9cbiAqL1xuZGVmaW5lTWFjcm8oXCJcXFxccXVhbnRpdHlcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxdHlcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwcXR5XCIsIFwie1xcXFxsZWZ0KCAjMSBcXFxccmlnaHQpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJxdHlcIiwgXCJ7XFxcXGxlZnRbICMxIFxcXFxyaWdodF19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdnF0eVwiLCBcIntcXFxcbGVmdFxcXFx2ZXJ0ICMxIFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJxdHlcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhYnNvbHV0ZXZhbHVlXCIsIFwie1xcXFxsZWZ0XFxcXHZlcnQgIzEgXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWJzXCIsIFwie1xcXFxsZWZ0XFxcXHZlcnQgIzEgXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbm9ybVwiLCBcIntcXFxcbGVmdFxcXFxWZXJ0ICMxIFxcXFxyaWdodFxcXFxWZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV2YWx1YXRlZFwiLCBcIntcXFxcbGVmdC4jMSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxldmFsXCIsIFwie1xcXFxsZWZ0LiMxIFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9yZGVyXCIsIFwie1xcXFxtYXRoY2Fse099IFxcXFxsZWZ0KCAjMSBcXFxccmlnaHQpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbW11dGF0b3JcIiwgXCJ7XFxcXGxlZnRbICMxICwgIzIgXFxcXHJpZ2h0XX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb21tXCIsIFwie1xcXFxsZWZ0WyAjMSAsICMyIFxcXFxyaWdodF19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYW50aWNvbW11dGF0b3JcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSAsICMyIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFjb21tXCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgLCAjMiBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwb2lzc29uYnJhY2tldFwiLCBcIntcXFxcbGVmdFxcXFx7ICMxICwgIzIgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGJcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSAsICMyIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZlY3RvcmJvbGRcIiwgXCJ7XFxcXGJvbGRzeW1ib2x7ICMxIH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmJcIiwgXCJ7XFxcXGJvbGRzeW1ib2x7ICMxIH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmVjdG9yYXJyb3dcIiwgXCJ7XFxcXHZlY3tcXFxcYm9sZHN5bWJvbHsgIzEgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFcIiwgXCJ7XFxcXHZlY3tcXFxcYm9sZHN5bWJvbHsgIzEgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmVjdG9ydW5pdFwiLCBcInt7XFxcXGJvbGRzeW1ib2x7XFxcXGhhdHsgIzEgfX19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZ1XCIsIFwie3tcXFxcYm9sZHN5bWJvbHtcXFxcaGF0eyAjMSB9fX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90cHJvZHVjdFwiLCBcIlxcXFxtYXRoYmlue1xcXFxib2xkc3ltYm9sXFxcXGNkb3R9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmRvdFwiLCBcIntcXFxcYm9sZHN5bWJvbFxcXFxjZG90fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNyb3NzcHJvZHVjdFwiLCBcIlxcXFxtYXRoYmlue1xcXFxib2xkc3ltYm9sXFxcXHRpbWVzfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNyb3NzXCIsIFwiXFxcXG1hdGhiaW57XFxcXGJvbGRzeW1ib2xcXFxcdGltZXN9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY3BcIiwgXCJcXFxcbWF0aGJpbntcXFxcYm9sZHN5bWJvbFxcXFx0aW1lc31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmFkaWVudFwiLCBcIntcXFxcYm9sZHN5bWJvbFxcXFxuYWJsYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmFkXCIsIFwie1xcXFxib2xkc3ltYm9sXFxcXG5hYmxhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRpdmVyZ2VuY2VcIiwgXCJ7XFxcXGdyYWRcXFxcdmRvdH1cIik7XG4vL2RlZmluZU1hY3JvKFwiXFxcXGRpdlwiLCBcIntcXFxcZ3JhZFxcXFx2ZG90fVwiKTsgTm90IGluY2x1ZGVkIGluIFRlbW1sLiBDb25mbGljdHMgdy9MYVRlWCBcXGRpdlxuZGVmaW5lTWFjcm8oXCJcXFxcY3VybFwiLCBcIntcXFxcZ3JhZFxcXFxjcm9zc31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYXBsYWNpYW5cIiwgXCJcXFxcbmFibGFeMlwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRyXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7dHJ9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFRyXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7VHJ9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhbmtcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtyYW5rfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcmZcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtlcmZ9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJlc1wiLCBcIntcXFxcb3BlcmF0b3JuYW1le1Jlc319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHJpbmNpcGFsdmFsdWVcIiwgXCJ7XFxcXG1hdGhjYWx7UH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHZcIiwgXCJ7XFxcXG1hdGhjYWx7UH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUFZcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtQLlYufX1cIik7XG4vLyBUZW1tbCBkb2VzIG5vdCB1c2UgdGhlIG5leHQgdHdvIGxpbmVzLiBUaGV5IGNvbmZsaWN0IHdpdGggTGFUZVggbGV0dGVycy5cbi8vZGVmaW5lTWFjcm8oXCJcXFxcUmVcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtSZX0gXFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG4vL2RlZmluZU1hY3JvKFwiXFxcXEltXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7SW19IFxcXFxsZWZ0XFxcXHsgIzEgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXF0ZXh0XCIsIFwie1xcXFxxdWFkXFxcXHRleHR7ICMxIH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxcVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0eyAjMSB9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWNvbW1hXCIsIFwie1xcXFx0ZXh0eyx9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWNcIiwgXCJ7XFxcXHRleHR7LH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxY2NcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtjLmMufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFpZlwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2lmfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHF0aGVuXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7dGhlbn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxZWxzZVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2Vsc2V9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccW90aGVyd2lzZVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e290aGVyd2lzZX1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxdW5sZXNzXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7dW5sZXNzfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFnaXZlblwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2dpdmVufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHF1c2luZ1wiLCBcIntcXFxccXVhZFxcXFx0ZXh0e3VzaW5nfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFhc3N1bWVcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHthc3N1bWV9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXNpbmNlXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7c2luY2V9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWxldFwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2xldH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxZm9yXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7Zm9yfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFhbGxcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHthbGx9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWV2ZW5cIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtldmVufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFvZGRcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtvZGR9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWludGVnZXJcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtpbnRlZ2VyfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFhbmRcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHthbmR9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccW9yXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7b3J9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWFzXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7YXN9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWluXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7aW59XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGlmZmVyZW50aWFsXCIsIFwie1xcXFx0ZXh0e2R9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRkXCIsIFwie1xcXFx0ZXh0e2R9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRlcml2YXRpdmVcIiwgXCJ7XFxcXGZyYWN7XFxcXHRleHR7ZH17ICMxIH19e1xcXFx0ZXh0e2R9eyAjMiB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkdlwiLCBcIntcXFxcZnJhY3tcXFxcdGV4dHtkfXsgIzEgfX17XFxcXHRleHR7ZH17ICMyIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBhcnRpYWxkZXJpdmF0aXZlXCIsIFwie1xcXFxmcmFje1xcXFxwYXJ0aWFseyAjMSB9fXtcXFxccGFydGlhbHsgIzIgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyaWF0aW9uXCIsIFwie1xcXFxkZWx0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJcIiwgXCJ7XFxcXGRlbHRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGZ1bmN0aW9uYWxkZXJpdmF0aXZlXCIsIFwie1xcXFxmcmFje1xcXFxkZWx0YXsgIzEgfX17XFxcXGRlbHRheyAjMiB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxmZHZcIiwgXCJ7XFxcXGZyYWN7XFxcXGRlbHRheyAjMSB9fXtcXFxcZGVsdGF7ICMyIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlubmVycHJvZHVjdFwiLCBcIntcXFxcbGVmdFxcXFxsYW5nbGUgeyMxfSBcXFxcbWlkIHsgIzJ9IFxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb3V0ZXJwcm9kdWN0XCIsXG4gIFwie1xcXFxsZWZ0XFxcXHZlcnQgeyAjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGVcXFxcbGVmdFxcXFxsYW5nbGUgeyAjMn0gXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZHlhZFwiLFxuICBcIntcXFxcbGVmdFxcXFx2ZXJ0IHsgIzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlXFxcXGxlZnRcXFxcbGFuZ2xlIHsgIzJ9IFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGtldGJyYVwiLFxuICBcIntcXFxcbGVmdFxcXFx2ZXJ0IHsgIzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlXFxcXGxlZnRcXFxcbGFuZ2xlIHsgIzJ9IFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9wXCIsXG4gIFwie1xcXFxsZWZ0XFxcXHZlcnQgeyAjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGVcXFxcbGVmdFxcXFxsYW5nbGUgeyAjMn0gXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXhwZWN0YXRpb252YWx1ZVwiLCBcIntcXFxcbGVmdFxcXFxsYW5nbGUgeyMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxleHB2YWxcIiwgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xlIHsjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXZcIiwgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xlIHsjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWF0cml4ZWxlbWVudFwiLFxuICBcIntcXFxcbGVmdFxcXFxsYW5nbGV7ICMxIH1cXFxccmlnaHRcXFxcdmVydHsgIzIgfVxcXFxsZWZ0XFxcXHZlcnR7IzN9XFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXRyaXhlbFwiLFxuICBcIntcXFxcbGVmdFxcXFxsYW5nbGV7ICMxIH1cXFxccmlnaHRcXFxcdmVydHsgIzIgfVxcXFxsZWZ0XFxcXHZlcnR7IzN9XFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtZWxcIixcbiAgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xleyAjMSB9XFxcXHJpZ2h0XFxcXHZlcnR7ICMyIH1cXFxcbGVmdFxcXFx2ZXJ0eyMzfVxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBnZXRITGluZXMocGFyc2VyKSB7XG4gIC8vIFJldHVybiBhbiBhcnJheS4gVGhlIGFycmF5IGxlbmd0aCA9IG51bWJlciBvZiBobGluZXMuXG4gIC8vIEVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdGVsbHMgaWYgdGhlIGxpbmUgaXMgZGFzaGVkLlxuICBjb25zdCBobGluZUluZm8gPSBbXTtcbiAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgbGV0IG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gIGlmIChueHQgPT09IFwiXFxcXHJlbGF4XCIpIHtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgfVxuICB3aGlsZSAobnh0ID09PSBcIlxcXFxobGluZVwiIHx8IG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpIHtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIGhsaW5lSW5mby5wdXNoKG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgfVxuICByZXR1cm4gaGxpbmVJbmZvO1xufVxuXG5jb25zdCB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dCA9IGNvbnRleHQgPT4ge1xuICBjb25zdCBzZXR0aW5ncyA9IGNvbnRleHQucGFyc2VyLnNldHRpbmdzO1xuICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYHske2NvbnRleHQuZW52TmFtZX19IGNhbiBiZSB1c2VkIG9ubHkgaW4gZGlzcGxheSBtb2RlLmApO1xuICB9XG59O1xuXG5jb25zdCBzaXplUmVnRXgkMSA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS87XG5jb25zdCBhcnJheUdhcHMgPSBtYWNyb3MgPT4ge1xuICBsZXQgYXJyYXlzdHJldGNoID0gbWFjcm9zLmdldChcIlxcXFxhcnJheXN0cmV0Y2hcIik7XG4gIGlmICh0eXBlb2YgYXJyYXlzdHJldGNoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgYXJyYXlzdHJldGNoID0gc3RyaW5nRnJvbUFyZyhhcnJheXN0cmV0Y2gudG9rZW5zKTtcbiAgfVxuICBhcnJheXN0cmV0Y2ggPSBpc05hTihhcnJheXN0cmV0Y2gpID8gbnVsbCA6IE51bWJlcihhcnJheXN0cmV0Y2gpO1xuICBsZXQgYXJyYXljb2xzZXBTdHIgPSBtYWNyb3MuZ2V0KFwiXFxcXGFycmF5Y29sc2VwXCIpO1xuICBpZiAodHlwZW9mIGFycmF5Y29sc2VwU3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgYXJyYXljb2xzZXBTdHIgPSBzdHJpbmdGcm9tQXJnKGFycmF5Y29sc2VwU3RyLnRva2Vucyk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBzaXplUmVnRXgkMS5leGVjKGFycmF5Y29sc2VwU3RyKTtcbiAgY29uc3QgYXJyYXljb2xzZXAgPSBtYXRjaFxuICAgID8geyBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksIHVuaXQ6IG1hdGNoWzNdIH1cbiAgICA6IG51bGw7XG4gIHJldHVybiBbYXJyYXlzdHJldGNoLCBhcnJheWNvbHNlcF1cbn07XG5cbmNvbnN0IGNoZWNrQ2VsbEZvckxhYmVscyA9IGNlbGwgPT4ge1xuICAvLyBDaGVjayBpZiB0aGUgYXV0aG9yIHdyb3RlIGEgXFx0YWd7fSBpbnNpZGUgdGhpcyBjZWxsLlxuICBsZXQgcm93TGFiZWwgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGwubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2VsbFtpXS50eXBlID09PSBcImxhYmVsXCIpIHtcbiAgICAgIGlmIChyb3dMYWJlbCkgeyB0aHJvdyBuZXcgUGFyc2VFcnJvcigoXCJNdWx0aXBsZSBcXFxcbGFiZWxzIGluIG9uZSByb3dcIikpIH1cbiAgICAgIHJvd0xhYmVsID0gY2VsbFtpXS5zdHJpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiByb3dMYWJlbFxufTtcblxuLy8gYXV0b1RhZyAoYW4gYXJndW1lbnQgdG8gcGFyc2VBcnJheSkgY2FuIGJlIG9uZSBvZiB0aHJlZSB2YWx1ZXM6XG4vLyAqIHVuZGVmaW5lZDogUmVndWxhciAobm90LXRvcC1sZXZlbCkgYXJyYXk7IG5vIHRhZ3Mgb24gZWFjaCByb3dcbi8vICogdHJ1ZTogQXV0b21hdGljIGVxdWF0aW9uIG51bWJlcmluZywgb3ZlcnJpZGFibGUgYnkgXFx0YWdcbi8vICogZmFsc2U6IFRhZ3MgYWxsb3dlZCBvbiBlYWNoIHJvdywgYnV0IG5vIGF1dG9tYXRpYyBudW1iZXJpbmdcbi8vIFRoaXMgZnVuY3Rpb24gKmRvZXNuJ3QqIHdvcmsgd2l0aCB0aGUgXCJzcGxpdFwiIGVudmlyb25tZW50IG5hbWUuXG5mdW5jdGlvbiBnZXRBdXRvVGFnKG5hbWUpIHtcbiAgaWYgKG5hbWUuaW5kZXhPZihcImVkXCIpID09PSAtMSkge1xuICAgIHJldHVybiBuYW1lLmluZGV4T2YoXCIqXCIpID09PSAtMTtcbiAgfVxuICAvLyByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBib2R5IG9mIHRoZSBlbnZpcm9ubWVudCwgd2l0aCByb3dzIGRlbGltaXRlZCBieSBcXFxcIGFuZFxuICogY29sdW1ucyBkZWxpbWl0ZWQgYnkgJiwgYW5kIGNyZWF0ZSBhIG5lc3RlZCBsaXN0IGluIHJvdy1tYWpvciBvcmRlclxuICogd2l0aCBvbmUgZ3JvdXAgcGVyIGNlbGwuICBJZiBnaXZlbiBhbiBvcHRpb25hbCBhcmd1bWVudCBzY3JpcHRMZXZlbFxuICogKFwidGV4dFwiLCBcImRpc3BsYXlcIiwgZXRjLiksIHRoZW4gZWFjaCBjZWxsIGlzIGNhc3QgaW50byB0aGF0IHNjcmlwdExldmVsLlxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5KFxuICBwYXJzZXIsXG4gIHtcbiAgICBjb2xzLCAvLyBbeyB0eXBlOiBzdHJpbmcgLCBhbGlnbjogbHxjfHJ8bnVsbCB9XVxuICAgIGVudkNsYXNzZXMsIC8vIGFsaWduKGVkfGF0fGVkYXQpIHwgYXJyYXkgfCBjYXNlcyB8IGNkIHwgc21hbGwgfCBtdWx0bGluZVxuICAgIGF1dG9UYWcsICAgICAgICAvLyBib29sZWFuXG4gICAgc2luZ2xlUm93LCAgICAgIC8vIGJvb2xlYW5cbiAgICBlbXB0eVNpbmdsZVJvdywgLy8gYm9vbGVhblxuICAgIG1heE51bUNvbHMsICAgICAvLyBudW1iZXJcbiAgICBsZXFubywgICAgICAgICAgLy8gYm9vbGVhblxuICAgIGFycmF5c3RyZXRjaCwgICAvLyBudW1iZXIgIHwgbnVsbFxuICAgIGFycmF5Y29sc2VwICAgICAvLyBzaXplIHZhbHVlIHwgbnVsbFxufSxcbiAgc2NyaXB0TGV2ZWxcbikge1xuICBjb25zdCBlbmRUb2tlbiA9IGVudkNsYXNzZXMgJiYgZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImJvcmRlcm1hdHJpeFwiKSA/IFwifVwiIDogXCJcXFxcZW5kXCI7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICBpZiAoIXNpbmdsZVJvdykge1xuICAgIC8vIFxcY3IgaXMgZXF1aXZhbGVudCB0byBcXFxcIHdpdGhvdXQgdGhlIG9wdGlvbmFsIHNpemUgYXJndW1lbnQgKHNlZSBiZWxvdylcbiAgICAvLyBUT0RPOiBwcm92aWRlIGhlbHBmdWwgZXJyb3Igd2hlbiBcXGNyIGlzIHVzZWQgb3V0c2lkZSBhcnJheSBlbnZpcm9ubWVudFxuICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjclwiLCBcIlxcXFxcXFxcXFxcXHJlbGF4XCIpO1xuICB9XG5cbiAgLy8gU3RhcnQgZ3JvdXAgZm9yIGZpcnN0IGNlbGxcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgbGV0IHJvdyA9IFtdO1xuICBjb25zdCBib2R5ID0gW3Jvd107XG4gIGNvbnN0IHJvd0dhcHMgPSBbXTtcbiAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgY29uc3QgaExpbmVzQmVmb3JlUm93ID0gW107XG5cbiAgY29uc3QgdGFncyA9IChhdXRvVGFnICE9IG51bGwgPyBbXSA6IHVuZGVmaW5lZCk7XG5cbiAgLy8gYW1zbWF0aCB1c2VzIFxcZ2xvYmFsXFxAZXFuc3d0cnVlIGFuZCBcXGdsb2JhbFxcQGVxbnN3ZmFsc2UgdG8gcmVwcmVzZW50XG4gIC8vIHdoZXRoZXIgdGhpcyByb3cgc2hvdWxkIGhhdmUgYW4gZXF1YXRpb24gbnVtYmVyLiAgU2ltdWxhdGUgdGhpcyB3aXRoXG4gIC8vIGEgXFxAZXFuc3cgbWFjcm8gc2V0IHRvIDEgb3IgMC5cbiAgZnVuY3Rpb24gYmVnaW5Sb3coKSB7XG4gICAgaWYgKGF1dG9UYWcpIHtcbiAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxAZXFuc3dcIiwgXCIxXCIsIHRydWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlbmRSb3coKSB7XG4gICAgaWYgKHRhZ3MpIHtcbiAgICAgIGlmIChwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgICAgIHRhZ3MucHVzaChwYXJzZXIuc3VicGFyc2UoW25ldyBUb2tlbihcIlxcXFxkZkB0YWdcIildKSk7XG4gICAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxkZkB0YWdcIiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ3MucHVzaChCb29sZWFuKGF1dG9UYWcpICYmXG4gICAgICAgICAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcQGVxbnN3XCIpID09PSBcIjFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJlZ2luUm93KCk7XG5cbiAgLy8gVGVzdCBmb3IgXFxobGluZSBhdCB0aGUgdG9wIG9mIHRoZSBhcnJheS5cbiAgaExpbmVzQmVmb3JlUm93LnB1c2goZ2V0SExpbmVzKHBhcnNlcikpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gUGFyc2UgZWFjaCBjZWxsIGluIGl0cyBvd24gZ3JvdXAgKG5hbWVzcGFjZSlcbiAgICBsZXQgY2VsbCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIHNpbmdsZVJvdyA/IFwiXFxcXGVuZFwiIDogXCJcXFxcXFxcXFwiKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgICBjZWxsID0ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBjZWxsLFxuICAgICAgc2VtaXNpbXBsZTogdHJ1ZVxuICAgIH07XG4gICAgcm93LnB1c2goY2VsbCk7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gICAgaWYgKG5leHQgPT09IFwiJlwiKSB7XG4gICAgICBpZiAobWF4TnVtQ29scyAmJiByb3cubGVuZ3RoID09PSBtYXhOdW1Db2xzKSB7XG4gICAgICAgIGlmIChlbnZDbGFzc2VzLmluY2x1ZGVzKFwiYXJyYXlcIikpIHtcbiAgICAgICAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUb28gZmV3IGNvbHVtbnMgXCIgKyBcInNwZWNpZmllZCBpbiB0aGUge2FycmF5fSBjb2x1bW4gYXJndW1lbnQuXCIsXG4gICAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1heE51bUNvbHMgPT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRoZSBzcGxpdCBlbnZpcm9ubWVudCBhY2NlcHRzIG5vIG1vcmUgdGhhbiB0d28gY29sdW1uc1wiLFxuICAgICAgICAgICAgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUaGUgZXF1YXRpb24gZW52aXJvbm1lbnQgYWNjZXB0cyBvbmx5IG9uZSBjb2x1bW5cIixcbiAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBlbmRUb2tlbikge1xuICAgICAgZW5kUm93KCk7XG4gICAgICAvLyBBcnJheXMgdGVybWluYXRlIG5ld2xpbmVzIHdpdGggYFxcY3JjcmAgd2hpY2ggY29uc3VtZXMgYSBgXFxjcmAgaWZcbiAgICAgIC8vIHRoZSBsYXN0IGxpbmUgaXMgZW1wdHkuICBIb3dldmVyLCBBTVMgZW52aXJvbm1lbnRzIGtlZXAgdGhlXG4gICAgICAvLyBlbXB0eSByb3cgaWYgaXQncyB0aGUgb25seSBvbmUuXG4gICAgICAvLyBOT1RFOiBDdXJyZW50bHksIGBjZWxsYCBpcyB0aGUgbGFzdCBpdGVtIGFkZGVkIGludG8gYHJvd2AuXG4gICAgICBpZiAocm93Lmxlbmd0aCA9PT0gMSAmJiBjZWxsLmJvZHkubGVuZ3RoID09PSAwICYmIChib2R5Lmxlbmd0aCA+IDEgfHwgIWVtcHR5U2luZ2xlUm93KSkge1xuICAgICAgICBib2R5LnBvcCgpO1xuICAgICAgfVxuICAgICAgbGFiZWxzLnB1c2goY2hlY2tDZWxsRm9yTGFiZWxzKGNlbGwuYm9keSkpO1xuICAgICAgaWYgKGhMaW5lc0JlZm9yZVJvdy5sZW5ndGggPCBib2R5Lmxlbmd0aCArIDEpIHtcbiAgICAgICAgaExpbmVzQmVmb3JlUm93LnB1c2goW10pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICBsZXQgc2l6ZTtcbiAgICAgIC8vIFxcZGVmXFxMZXRAe1xcbGV0XFxcXFxcbWF0aEBjcn1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyey4uLlxcbWF0aEBjckB9XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjckB7XFxuZXdAaWZuZXh0Y2hhcltcXG1hdGhAY3JAQHtcXG1hdGhAY3JAQFtcXHpAXX19XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjckBAWyMxXXsuLi5cXG1hdGhAY3JAQEAuLi59XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjckBAQHtcXGNyfVxuICAgICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCIgXCIpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlci5wYXJzZVNpemVHcm91cCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJvd0dhcHMucHVzaChzaXplID8gc2l6ZS52YWx1ZSA6IG51bGwpO1xuICAgICAgZW5kUm93KCk7XG5cbiAgICAgIGxhYmVscy5wdXNoKGNoZWNrQ2VsbEZvckxhYmVscyhjZWxsLmJvZHkpKTtcblxuICAgICAgLy8gY2hlY2sgZm9yIFxcaGxpbmUocykgZm9sbG93aW5nIHRoZSByb3cgc2VwYXJhdG9yXG4gICAgICBoTGluZXNCZWZvcmVSb3cucHVzaChnZXRITGluZXMocGFyc2VyKSk7XG5cbiAgICAgIHJvdyA9IFtdO1xuICAgICAgYm9keS5wdXNoKHJvdyk7XG4gICAgICBiZWdpblJvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkICYgb3IgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFwiICsgZW5kVG9rZW4sIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVuZCBjZWxsIGdyb3VwXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgLy8gRW5kIGFycmF5IGdyb3VwIGRlZmluaW5nIFxcY3JcbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgIGJvZHksXG4gICAgY29scyxcbiAgICByb3dHYXBzLFxuICAgIGhMaW5lc0JlZm9yZVJvdyxcbiAgICBlbnZDbGFzc2VzLFxuICAgIGF1dG9UYWcsXG4gICAgc2NyaXB0TGV2ZWwsXG4gICAgdGFncyxcbiAgICBsYWJlbHMsXG4gICAgbGVxbm8sXG4gICAgYXJyYXlzdHJldGNoLFxuICAgIGFycmF5Y29sc2VwXG4gIH07XG59XG5cbi8vIERlY2lkZXMgb24gYSBzY3JpcHRMZXZlbCBmb3IgY2VsbHMgaW4gYW4gYXJyYXkgYWNjb3JkaW5nIHRvIHdoZXRoZXIgdGhlIGdpdmVuXG4vLyBlbnZpcm9ubWVudCBuYW1lIHN0YXJ0cyB3aXRoIHRoZSBsZXR0ZXIgJ2QnLlxuZnVuY3Rpb24gZENlbGxTdHlsZShlbnZOYW1lKSB7XG4gIHJldHVybiBlbnZOYW1lLnNsaWNlKDAsIDEpID09PSBcImRcIiA/IFwiZGlzcGxheVwiIDogXCJ0ZXh0XCJcbn1cblxuY29uc3QgYWxpZ25NYXAgPSB7XG4gIGM6IFwiY2VudGVyIFwiLFxuICBsOiBcImxlZnQgXCIsXG4gIHI6IFwicmlnaHQgXCJcbn07XG5cbmNvbnN0IGdsdWUgPSBncm91cCA9PiB7XG4gIGNvbnN0IGdsdWVOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10pO1xuICBnbHVlTm9kZS5zdHlsZSA9IHsgcGFkZGluZzogXCIwXCIsIHdpZHRoOiBcIjUwJVwiIH07XG4gIGlmIChncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwibXVsdGxpbmVcIikpIHtcbiAgICBnbHVlTm9kZS5zdHlsZS53aWR0aCA9IFwiNy41JVwiO1xuICB9XG4gIHJldHVybiBnbHVlTm9kZVxufTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ5ID0gZnVuY3Rpb24oZ3JvdXAsIHN0eWxlKSB7XG4gIGNvbnN0IHRibCA9IFtdO1xuICBjb25zdCBudW1Sb3dzID0gZ3JvdXAuYm9keS5sZW5ndGg7XG4gIGNvbnN0IGhsaW5lcyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVJvd3M7IGkrKykge1xuICAgIGNvbnN0IHJ3ID0gZ3JvdXAuYm9keVtpXTtcbiAgICBjb25zdCByb3cgPSBbXTtcbiAgICBjb25zdCBjZWxsTGV2ZWwgPSBncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJ0ZXh0XCJcbiAgICAgID8gU3R5bGVMZXZlbC5URVhUXG4gICAgICA6IGdyb3VwLnNjcmlwdExldmVsID09PSBcInNjcmlwdFwiXG4gICAgICA/IFN0eWxlTGV2ZWwuU0NSSVBUXG4gICAgICA6IFN0eWxlTGV2ZWwuRElTUExBWTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcncubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IG10ZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm10ZFwiLFxuICAgICAgICBbYnVpbGRHcm91cCQxKHJ3W2pdLCBzdHlsZS53aXRoTGV2ZWwoY2VsbExldmVsKSldXG4gICAgICApO1xuXG4gICAgICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcIm11bHRsaW5lXCIpKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gaSA9PT0gMCA/IFwibGVmdFwiIDogaSA9PT0gbnVtUm93cyAtIDEgPyBcInJpZ2h0XCIgOiBcImNlbnRlclwiO1xuICAgICAgICBtdGQuc2V0QXR0cmlidXRlKFwiY29sdW1uYWxpZ25cIiwgYWxpZ24pO1xuICAgICAgICBpZiAoYWxpZ24gIT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICBtdGQuY2xhc3Nlcy5wdXNoKFwidG1sLVwiICsgYWxpZ24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByb3cucHVzaChtdGQpO1xuICAgIH1cbiAgICBjb25zdCBudW1Db2x1bW5zID0gZ3JvdXAuYm9keVswXS5sZW5ndGg7XG4gICAgLy8gRmlsbCBvdXQgYSBzaG9ydCByb3cgd2l0aCBlbXB0eSA8bXRkPiBlbGVtZW50cy5cbiAgICBmb3IgKGxldCBrID0gMDsgayA8IG51bUNvbHVtbnMgLSBydy5sZW5ndGg7IGsrKykge1xuICAgICAgcm93LnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10sIHN0eWxlKSk7XG4gICAgfVxuICAgIGlmIChncm91cC5hdXRvVGFnKSB7XG4gICAgICBjb25zdCB0YWcgPSBncm91cC50YWdzW2ldO1xuICAgICAgbGV0IHRhZ0VsZW1lbnQ7XG4gICAgICBpZiAodGFnID09PSB0cnVlKSB7ICAvLyBhdXRvbWF0aWMgbnVtYmVyaW5nXG4gICAgICAgIHRhZ0VsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgU3BhbihbXCJ0bWwtZXFuXCJdKV0pO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFxcbm9udW1iZXIvXFxub3RhZyBvciBzdGFycmVkIGVudmlyb25tZW50XG4gICAgICAgIHRhZ0VsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtdLCBbXSk7XG4gICAgICB9IGVsc2UgeyAgLy8gbWFudWFsIFxcdGFnXG4gICAgICAgIHRhZ0VsZW1lbnQgPSBidWlsZEV4cHJlc3Npb25Sb3codGFnWzBdLmJvZHksIHN0eWxlLndpdGhMZXZlbChjZWxsTGV2ZWwpLCB0cnVlKTtcbiAgICAgICAgdGFnRWxlbWVudCA9IGNvbnNvbGlkYXRlVGV4dCh0YWdFbGVtZW50KTtcbiAgICAgICAgdGFnRWxlbWVudC5jbGFzc2VzID0gW1widG1sLXRhZ1wiXTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWdFbGVtZW50KSB7XG4gICAgICAgIHJvdy51bnNoaWZ0KGdsdWUoZ3JvdXApKTtcbiAgICAgICAgcm93LnB1c2goZ2x1ZShncm91cCkpO1xuICAgICAgICBpZiAoZ3JvdXAubGVxbm8pIHtcbiAgICAgICAgICByb3dbMF0uY2hpbGRyZW4ucHVzaCh0YWdFbGVtZW50KTtcbiAgICAgICAgICByb3dbMF0uY2xhc3Nlcy5wdXNoKFwidG1sLWxlZnRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5jaGlsZHJlbi5wdXNoKHRhZ0VsZW1lbnQpO1xuICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0uY2xhc3Nlcy5wdXNoKFwidG1sLXJpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG10ciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIHJvdywgW10pO1xuICAgIGNvbnN0IGxhYmVsID0gZ3JvdXAubGFiZWxzLnNoaWZ0KCk7XG4gICAgaWYgKGxhYmVsICYmIGdyb3VwLnRhZ3MgJiYgZ3JvdXAudGFnc1tpXSkge1xuICAgICAgbXRyLnNldEF0dHJpYnV0ZShcImlkXCIsIGxhYmVsKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwLnRhZ3NbaV0pKSB7IG10ci5jbGFzc2VzLnB1c2goXCJ0bWwtdGFnZXFuXCIpOyB9XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgaG9yaXpvbnRhbCBydWxlc1xuICAgIGlmIChpID09PSAwICYmIGhsaW5lc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaGxpbmVzWzBdLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHsgY2VsbC5zdHlsZS5ib3JkZXJUb3AgPSBcIjAuMTVlbSBkb3VibGVcIjsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICBjZWxsLnN0eWxlLmJvcmRlclRvcCA9IGhsaW5lc1swXVswXSA/IFwiMC4wNmVtIGRhc2hlZFwiIDogXCIwLjA2ZW0gc29saWRcIjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChobGluZXNbaSArIDFdLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChobGluZXNbaSArIDFdLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHsgY2VsbC5zdHlsZS5ib3JkZXJCb3R0b20gPSBcIjAuMTVlbSBkb3VibGVcIjsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICBjZWxsLnN0eWxlLmJvcmRlckJvdHRvbSA9IGhsaW5lc1tpICsgMV1bMF0gPyBcIjAuMDZlbSBkYXNoZWRcIiA6IFwiMC4wNmVtIHNvbGlkXCI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBcXGhwaGFudG9tIFxcZnJvbSBcXGJvcmRlcm1hdHJpeFxuICAgIGxldCBtdXN0U3F1YXNoUm93ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG10ci5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBtdHIuY2hpbGRyZW5bal0uY2hpbGRyZW5bMF07XG4gICAgICBpZiAoIShjaGlsZCAmJiBjaGlsZC50eXBlID09PSBcIm1wYWRkZWRcIiAmJiBjaGlsZC5hdHRyaWJ1dGVzLmhlaWdodCA9PT0gXCIwcHhcIikpIHtcbiAgICAgICAgbXVzdFNxdWFzaFJvdyA9IGZhbHNlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobXVzdFNxdWFzaFJvdykge1xuICAgICAgLy8gQWxsIHRoZSBjZWxsIGNvbnRlbnRzIGFyZSBcXGhwaGFudG9tLiBTcXVhc2ggdGhlIHBhZGRpbmcuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG10ci5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBtdHIuY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ1RvcCA9IFwiMFwiO1xuICAgICAgICBtdHIuY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRibC5wdXNoKG10cik7XG4gIH1cblxuICBpZiAoZ3JvdXAuYXJyYXlzdHJldGNoICYmIGdyb3VwLmFycmF5c3RyZXRjaCAhPT0gMSkge1xuICAgIC8vIEluIExhVGVYLCBcXGFycmF5c3RyZXRjaCBpcyBhIGZhY3RvciBhcHBsaWVkIHRvIGEgMTJwdCBzdHJ1dCBoZWlnaHQuXG4gICAgLy8gSXQgZGVmaW5lcyBhIGJhc2VsaW5lIHRvIGJhc2VsaW5lIGRpc3RhbmNlLlxuICAgIC8vIEhlcmUsIHdlIGRvIGFuIGFwcHJveGltYXRpb24gb2YgdGhhdCBhcHByb2FjaC5cbiAgICBjb25zdCBwYWQgPSBTdHJpbmcoMS40ICogZ3JvdXAuYXJyYXlzdHJldGNoIC0gMC44KSArIFwiZXhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRibC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGJsW2ldLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdUb3AgPSBwYWQ7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nQm90dG9tID0gcGFkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBzaWRlUGFkZGluZztcbiAgbGV0IHNpZGVQYWRVbml0O1xuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgc2lkZVBhZGRpbmcgPSBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiYWJ1dFwiKVxuICAgICAgPyBcIjBcIlxuICAgICAgOiBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiY2FzZXNcIilcbiAgICAgID8gXCIwXCJcbiAgICAgIDogZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcInNtYWxsXCIpXG4gICAgICA/IFwiMC4xMzg5XCJcbiAgICAgIDogZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImNkXCIpXG4gICAgICA/IFwiMC4yNVwiXG4gICAgICA6IFwiMC40XCI7IC8vIGRlZmF1bHQgc2lkZSBwYWRkaW5nXG4gICAgc2lkZVBhZFVuaXQgPSBcImVtXCI7XG4gIH1cbiAgaWYgKGdyb3VwLmFycmF5Y29sc2VwKSB7XG4gICAgY29uc3QgYXJyYXlTaWRlUGFkID0gY2FsY3VsYXRlU2l6ZShncm91cC5hcnJheWNvbHNlcCwgc3R5bGUpO1xuICAgIHNpZGVQYWRkaW5nID0gYXJyYXlTaWRlUGFkLm51bWJlci50b0ZpeGVkKDQpO1xuICAgIHNpZGVQYWRVbml0ID0gYXJyYXlTaWRlUGFkLnVuaXQ7XG4gIH1cbiAgaWYgKHNpZGVQYWRkaW5nKSB7XG4gICAgY29uc3QgbnVtQ29scyA9IHRibC5sZW5ndGggPT09IDAgPyAwIDogdGJsWzBdLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGNvbnN0IHNpZGVQYWQgPSAoaiwgaGFuZCkgPT4ge1xuICAgICAgaWYgKGogPT09IDAgJiYgaGFuZCA9PT0gMCkgeyByZXR1cm4gXCIwXCIgfVxuICAgICAgaWYgKGogPT09IG51bUNvbHMgLSAxICYmIGhhbmQgPT09IDEpIHsgcmV0dXJuIFwiMFwiIH1cbiAgICAgIGlmIChncm91cC5lbnZDbGFzc2VzWzBdICE9PSBcImFsaWduXCIpIHsgcmV0dXJuIHNpZGVQYWRkaW5nIH1cbiAgICAgIGlmIChoYW5kID09PSAxKSB7IHJldHVybiBcIjBcIiB9XG4gICAgICBpZiAoZ3JvdXAuYXV0b1RhZykge1xuICAgICAgICByZXR1cm4gKGogJSAyKSA/IFwiMVwiIDogXCIwXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoaiAlIDIpID8gXCIwXCIgOiBcIjFcIlxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTaWRlIHBhZGRpbmdcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRibC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGJsW2ldLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7c2lkZVBhZChqLCAwKX0ke3NpZGVQYWRVbml0fWA7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtzaWRlUGFkKGosIDEpfSR7c2lkZVBhZFVuaXR9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gU2V0IHplcm8gcGFkZGluZyBvbiBzaWRlIG9mIHRoZSBtYXRyaXhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRibC5sZW5ndGg7IGkrKykge1xuICAgICAgdGJsW2ldLmNoaWxkcmVuWzBdLnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIwZW1cIjtcbiAgICAgIGlmICh0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSB0YmxbMF0uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlblt0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwZW1cIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gSnVzdGlmaWNhdGlvblxuICAgIGNvbnN0IGFsaWduID0gZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImFsaWduXCIpIHx8IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJhbGlnbmF0XCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGJsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByb3cgPSB0YmxbaV07XG4gICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3cuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAvLyBDaHJvbWl1bSBkb2VzIG5vdCByZWNvZ25pemUgdGV4dC1hbGlnbjogbGVmdC4gVXNlIC13ZWJraXQtXG4gICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIC13ZWJraXQtIHdoZW4gQ2hyb21pdW0gbm8gbG9uZ2VyIG5lZWRzIGl0LlxuICAgICAgICAgIHJvdy5jaGlsZHJlbltqXS5jbGFzc2VzID0gW1widG1sLVwiICsgKGogJSAyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAuYXV0b1RhZykge1xuICAgICAgICAgIGNvbnN0IGsgPSBncm91cC5sZXFubyA/IDAgOiByb3cuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgICByb3cuY2hpbGRyZW5ba10uY2xhc3NlcyA9IFtcInRtbC1cIiArIChncm91cC5sZXFubyA/IFwibGVmdFwiIDogXCJyaWdodFwiKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyb3cuY2hpbGRyZW4ubGVuZ3RoID4gMSAmJiBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiY2FzZXNcIikpIHtcbiAgICAgICAgcm93LmNoaWxkcmVuWzFdLnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIxZW1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJjYXNlc1wiKSB8fCBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwic3ViYXJyYXlcIikpIHtcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdy5jaGlsZHJlbikge1xuICAgICAgICAgIGNlbGwuY2xhc3Nlcy5wdXNoKFwidG1sLWxlZnRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCB0YmwpO1xuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gVG9wICYgYm90dG9tIHBhZGRpbmdcbiAgICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImpvdFwiKSkge1xuICAgICAgdGFibGUuY2xhc3Nlcy5wdXNoKFwidG1sLWpvdFwiKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJzbWFsbFwiKSkge1xuICAgICAgdGFibGUuY2xhc3Nlcy5wdXNoKFwidG1sLXNtYWxsXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwiZGlzcGxheVwiKSB7IHRhYmxlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcInRydWVcIik7IH1cblxuICBpZiAoZ3JvdXAuYXV0b1RhZyB8fCBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwibXVsdGxpbmVcIikpIHtcbiAgICB0YWJsZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICB9XG5cbiAgLy8gQ29sdW1uIHNlcGFyYXRvciBsaW5lcyBhbmQgY29sdW1uIGFsaWdubWVudFxuICBsZXQgYWxpZ24gPSBcIlwiO1xuXG4gIGlmIChncm91cC5jb2xzICYmIGdyb3VwLmNvbHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNvbHMgPSBncm91cC5jb2xzO1xuICAgIGxldCBwcmV2VHlwZVdhc0FsaWduID0gZmFsc2U7XG4gICAgbGV0IGlTdGFydCA9IDA7XG4gICAgbGV0IGlFbmQgPSBjb2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChjb2xzW2lTdGFydF0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgaVN0YXJ0ICs9IDE7XG4gICAgfVxuICAgIHdoaWxlIChjb2xzW2lFbmQgLSAxXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBpRW5kIC09IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbHNbMF0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgY29uc3Qgc2VwID0gY29sc1sxXS50eXBlID09PSBcInNlcGFyYXRvclwiXG4gICAgICAgID8gXCIwLjE1ZW0gZG91YmxlXCJcbiAgICAgICAgOiBjb2xzWzBdLnNlcGFyYXRvciA9PT0gXCJ8XCJcbiAgICAgICAgPyBcIjAuMDZlbSBzb2xpZCBcIlxuICAgICAgICA6IFwiMC4wNmVtIGRhc2hlZCBcIjtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJvdy5jaGlsZHJlblswXS5zdHlsZS5ib3JkZXJMZWZ0ID0gc2VwO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaUNvbCA9IGdyb3VwLmF1dG9UYWcgPyAwIDogLTE7XG4gICAgZm9yIChsZXQgaSA9IGlTdGFydDsgaSA8IGlFbmQ7IGkrKykge1xuICAgICAgaWYgKGNvbHNbaV0udHlwZSA9PT0gXCJhbGlnblwiKSB7XG4gICAgICAgIGNvbnN0IGNvbEFsaWduID0gYWxpZ25NYXBbY29sc1tpXS5hbGlnbl07XG4gICAgICAgIGFsaWduICs9IGNvbEFsaWduO1xuICAgICAgICBpQ29sICs9IDE7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNvbEFsaWduLnRyaW0oKSAhPT0gXCJjZW50ZXJcIiAmJiBpQ29sIDwgcm93LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93LmNoaWxkcmVuW2lDb2xdLmNsYXNzZXMgPSBbXCJ0bWwtXCIgKyBjb2xBbGlnbi50cmltKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2VHlwZVdhc0FsaWduID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY29sc1tpXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgIC8vIE1hdGhNTCBhY2NlcHRzIG9ubHkgc2luZ2xlIGxpbmVzIGJldHdlZW4gY2VsbHMuXG4gICAgICAgIC8vIFNvIHdlIHJlYWQgb25seSB0aGUgZmlyc3Qgb2YgY29uc2VjdXRpdmUgc2VwYXJhdG9ycy5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb25zdCBzZXAgPSBjb2xzW2kgKyAxXS50eXBlID09PSBcInNlcGFyYXRvclwiXG4gICAgICAgICAgICA/IFwiMC4xNWVtIGRvdWJsZVwiXG4gICAgICAgICAgICA6IGNvbHNbaV0uc2VwYXJhdG9yID09PSBcInxcIlxuICAgICAgICAgICAgPyBcIjAuMDZlbSBzb2xpZFwiXG4gICAgICAgICAgICA6IFwiMC4wNmVtIGRhc2hlZFwiO1xuICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoaUNvbCA8IHJvdy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcm93LmNoaWxkcmVuW2lDb2xdLnN0eWxlLmJvcmRlclJpZ2h0ID0gc2VwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2VHlwZVdhc0FsaWduID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2xzW2NvbHMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgY29uc3Qgc2VwID0gY29sc1tjb2xzLmxlbmd0aCAtIDJdLnR5cGUgPT09IFwic2VwYXJhdG9yXCJcbiAgICAgICAgPyBcIjAuMTVlbSBkb3VibGVcIlxuICAgICAgICA6IGNvbHNbY29scy5sZW5ndGggLSAxXS5zZXBhcmF0b3IgPT09IFwifFwiXG4gICAgICAgID8gXCIwLjA2ZW0gc29saWRcIlxuICAgICAgICA6IFwiMC4wNmVtIGRhc2hlZFwiO1xuICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcm93LmNoaWxkcmVuW3Jvdy5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdHlsZS5ib3JkZXJSaWdodCA9IHNlcDtcbiAgICAgICAgcm93LmNoaWxkcmVuW3Jvdy5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIjAuNGVtXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChncm91cC5hdXRvVGFnKSB7XG4gICAgIC8vIGFsbG93IGZvciBnbHVlIGNlbGxzIG9uIGVhY2ggc2lkZVxuICAgIGFsaWduID0gXCJsZWZ0IFwiICsgKGFsaWduLmxlbmd0aCA+IDAgPyBhbGlnbiA6IFwiY2VudGVyIFwiKSArIFwicmlnaHQgXCI7XG4gIH1cbiAgaWYgKGFsaWduKSB7XG4gICAgLy8gRmlyZWZveCByZWFkcyB0aGlzIGF0dHJpYnV0ZSwgbm90IHRoZSAtd2Via2l0LWxlZnR8cmlnaHQgd3JpdHRlbiBhYm92ZS5cbiAgICAvLyBUT0RPOiBXaGVuIENocm9tZSBubyBsb25nZXIgbmVlZHMgXCItd2Via2l0LVwiLCB1c2UgQ1NTIGFuZCBkZWxldGUgdGhlIG5leHQgbGluZS5cbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5hbGlnblwiLCBhbGlnbi50cmltKCkpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJzbWFsbFwiKSkge1xuICAgIC8vIEEgc21hbGwgYXJyYXkuIFdyYXAgaW4gc2NyaXB0c3R5bGUuXG4gICAgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbdGFibGVdKTtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjFcIik7XG4gIH1cblxuICByZXR1cm4gdGFibGVcbn07XG5cbi8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBhbGlnbiwgYWxpZ24qLCBhbGlnbmVkLCBhbGlnbmF0LCBhbGlnbmF0KiwgYWxpZ25lZGF0LCBzcGxpdC5cbmNvbnN0IGFsaWduZWRIYW5kbGVyID0gZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICBpZiAoY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJlZFwiKSA9PT0gLTEpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgfVxuICBjb25zdCBpc1NwbGl0ID0gY29udGV4dC5lbnZOYW1lID09PSBcInNwbGl0XCI7XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgY29uc3QgcmVzID0gcGFyc2VBcnJheShcbiAgICBjb250ZXh0LnBhcnNlcixcbiAgICB7XG4gICAgICBjb2xzLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBhdXRvVGFnOiBpc1NwbGl0ID8gdW5kZWZpbmVkIDogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW52Q2xhc3NlczogW1wiYWJ1dFwiLCBcImpvdFwiXSwgLy8gc2V0IHJvdyBzcGFjaW5nICYgcHJvdmlzaW9uYWwgY29sdW1uIHNwYWNpbmdcbiAgICAgIG1heE51bUNvbHM6IGNvbnRleHQuZW52TmFtZSA9PT0gXCJzcGxpdFwiID8gMiA6IHVuZGVmaW5lZCxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH0sXG4gICAgXCJkaXNwbGF5XCJcbiAgKTtcblxuICAvLyBEZXRlcm1pbmluZyBudW1iZXIgb2YgY29sdW1ucy5cbiAgLy8gMS4gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdpdmVuLCB3ZSB1c2UgaXQgYXMgYSBudW1iZXIgb2YgY29sdW1ucyxcbiAgLy8gICAgYW5kIG1ha2VzIHN1cmUgdGhhdCBlYWNoIHJvdyBkb2Vzbid0IGV4Y2VlZCB0aGF0IG51bWJlci5cbiAgLy8gMi4gT3RoZXJ3aXNlLCBqdXN0IGNvdW50IG51bWJlciBvZiBjb2x1bW5zID0gbWF4aW11bSBudW1iZXJcbiAgLy8gICAgb2YgY2VsbHMgaW4gZWFjaCByb3cgKFwiYWxpZ25lZFwiIG1vZGUgLS0gaXNBbGlnbmVkIHdpbGwgYmUgdHJ1ZSkuXG4gIC8vXG4gIC8vIEF0IHRoZSBzYW1lIHRpbWUsIHByZXBlbmQgZW1wdHkgZ3JvdXAge30gYXQgYmVnaW5uaW5nIG9mIGV2ZXJ5IHNlY29uZFxuICAvLyBjZWxsIGluIGVhY2ggcm93IChzdGFydGluZyB3aXRoIHNlY29uZCBjZWxsKSBzbyB0aGF0IG9wZXJhdG9ycyBiZWNvbWVcbiAgLy8gYmluYXJ5LiAgVGhpcyBiZWhhdmlvciBpcyBpbXBsZW1lbnRlZCBpbiBhbXNtYXRoJ3MgXFxzdGFydEBhbGlnbmVkLlxuICBsZXQgbnVtTWF0aHM7XG4gIGxldCBudW1Db2xzID0gMDtcbiAgY29uc3QgaXNBbGlnbmVkQXQgPSBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcImF0XCIpID4gLTE7XG4gIGlmIChhcmdzWzBdICYmIGlzQWxpZ25lZEF0KSB7XG4gICAgLy8gYWxpZ25hdCBlbnZpcm9ubWVudCB0YWtlcyBhbiBhcmd1bWVudCB3LyBudW1iZXIgb2YgY29sdW1uc1xuICAgIGxldCBhcmcwID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3NbMF0uYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dG9yZCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0uYm9keVtpXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgYXJnMCArPSB0ZXh0b3JkLnRleHQ7XG4gICAgfVxuICAgIGlmIChpc05hTihhcmcwKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUaGUgYWxpZ25hdCBlbnZpcm9tZW50IHJlcXVpcmVzIGEgbnVtZXJpYyBmaXJzdCBhcmd1bWVudC5cIilcbiAgICB9XG4gICAgbnVtTWF0aHMgPSBOdW1iZXIoYXJnMCk7XG4gICAgbnVtQ29scyA9IG51bU1hdGhzICogMjtcbiAgfVxuICByZXMuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGlmIChpc0FsaWduZWRBdCkge1xuICAgICAgLy8gQ2FzZSAxXG4gICAgICBjb25zdCBjdXJNYXRocyA9IHJvdy5sZW5ndGggLyAyO1xuICAgICAgaWYgKG51bU1hdGhzIDwgY3VyTWF0aHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgXCJUb28gbWFueSBtYXRoIGluIGEgcm93OiBcIiArIGBleHBlY3RlZCAke251bU1hdGhzfSwgYnV0IGdvdCAke2N1ck1hdGhzfWAsXG4gICAgICAgICAgcm93WzBdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChudW1Db2xzIDwgcm93Lmxlbmd0aCkge1xuICAgICAgLy8gQ2FzZSAyXG4gICAgICBudW1Db2xzID0gcm93Lmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEFkanVzdGluZyBhbGlnbm1lbnQuXG4gIC8vIEluIGFsaWduZWQgbW9kZSwgd2UgYWRkIG9uZSBcXHFxdWFkIGJldHdlZW4gY29sdW1ucztcbiAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBub3RoaW5nLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvbHM7ICsraSkge1xuICAgIGxldCBhbGlnbiA9IFwiclwiO1xuICAgIGlmIChpICUgMiA9PT0gMSkge1xuICAgICAgYWxpZ24gPSBcImxcIjtcbiAgICB9XG4gICAgY29sc1tpXSA9IHtcbiAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgIGFsaWduOiBhbGlnblxuICAgIH07XG4gIH1cbiAgaWYgKGNvbnRleHQuZW52TmFtZSA9PT0gXCJzcGxpdFwiKSA7IGVsc2UgaWYgKGlzQWxpZ25lZEF0KSB7XG4gICAgcmVzLmVudkNsYXNzZXMucHVzaChcImFsaWduYXRcIik7IC8vIFNldHMganVzdGlmaWNhdGlvblxuICB9IGVsc2Uge1xuICAgIHJlcy5lbnZDbGFzc2VzWzBdID0gXCJhbGlnblwiOyAvLyBTZXRzIGNvbHVtbiBzcGFjaW5nICYganVzdGlmaWNhdGlvblxuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBBcnJheXMgYXJlIHBhcnQgb2YgTGFUZVgsIGRlZmluZWQgaW4gbHR0YWIuZHR4IHNvIGl0cyBkb2N1bWVudGF0aW9uXG4vLyBpcyBwYXJ0IG9mIHRoZSBzb3VyY2UyZS5wZGYgZmlsZSBvZiBMYVRlWDJlIHNvdXJjZSBkb2N1bWVudGF0aW9uLlxuLy8ge2RhcnJheX0gaXMgYW4ge2FycmF5fSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBuY2NtYXRoLnN0eS5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYXJyYXlcIiwgXCJkYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBTaW5jZSBubyB0eXBlcyBhcmUgc3BlY2lmaWVkIGFib3ZlLCB0aGUgdHdvIHBvc3NpYmlsaXRpZXMgYXJlXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgd3JhcHBlZCBpbiB7fSBvciBbXSwgaW4gd2hpY2ggY2FzZSBQYXJzZXInc1xuICAgIC8vICAgcGFyc2VHcm91cCgpIHJldHVybnMgYW4gXCJvcmRncm91cFwiIHdyYXBwaW5nIHNvbWUgc3ltYm9sIG5vZGUuXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgYSBiYXJlIHN5bWJvbCBub2RlLlxuICAgIGNvbnN0IHN5bU5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKGFyZ3NbMF0pO1xuICAgIGNvbnN0IGNvbGFsaWduID0gc3ltTm9kZSA/IFthcmdzWzBdXSA6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIikuYm9keTtcbiAgICBjb25zdCBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5kZSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7XG4gICAgICBjb25zdCBjYSA9IG5vZGUudGV4dDtcbiAgICAgIGlmIChcImxjclwiLmluZGV4T2YoY2EpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwifFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwifFwiXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGNhID09PSBcIjpcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgc2VwYXJhdG9yOiBcIjpcIlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmtub3duIGNvbHVtbiBhbGlnbm1lbnQ6IFwiICsgY2EsIG5kZSk7XG4gICAgfSk7XG4gICAgY29uc3QgW2FycmF5c3RyZXRjaCwgYXJyYXljb2xzZXBdID0gYXJyYXlHYXBzKGNvbnRleHQucGFyc2VyLmd1bGxldC5tYWNyb3MpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGNvbHMsXG4gICAgICBlbnZDbGFzc2VzOiBbXCJhcnJheVwiXSxcbiAgICAgIG1heE51bUNvbHM6IGNvbHMubGVuZ3RoLFxuICAgICAgYXJyYXlzdHJldGNoLFxuICAgICAgYXJyYXljb2xzZXBcbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIFRoZSBtYXRyaXggZW52aXJvbm1lbnRzIG9mIGFtc21hdGggYnVpbGQgb24gdGhlIGFycmF5IGVudmlyb25tZW50XG4vLyBvZiBMYVRlWCwgd2hpY2ggaXMgZGlzY3Vzc2VkIGFib3ZlLlxuLy8gVGhlIG1hdGh0b29scyBwYWNrYWdlIGFkZHMgc3RhcnJlZCB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBlbnZpcm9ubWVudHMuXG4vLyBUaGVzZSBoYXZlIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGNob29zZSBsZWZ0fGNlbnRlcnxyaWdodCBqdXN0aWZpY2F0aW9uLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXG4gICAgXCJtYXRyaXhcIixcbiAgICBcInBtYXRyaXhcIixcbiAgICBcImJtYXRyaXhcIixcbiAgICBcIkJtYXRyaXhcIixcbiAgICBcInZtYXRyaXhcIixcbiAgICBcIlZtYXRyaXhcIixcbiAgICBcIm1hdHJpeCpcIixcbiAgICBcInBtYXRyaXgqXCIsXG4gICAgXCJibWF0cml4KlwiLFxuICAgIFwiQm1hdHJpeCpcIixcbiAgICBcInZtYXRyaXgqXCIsXG4gICAgXCJWbWF0cml4KlwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBkZWxpbWl0ZXJzID0ge1xuICAgICAgbWF0cml4OiBudWxsLFxuICAgICAgcG1hdHJpeDogW1wiKFwiLCBcIilcIl0sXG4gICAgICBibWF0cml4OiBbXCJbXCIsIFwiXVwiXSxcbiAgICAgIEJtYXRyaXg6IFtcIlxcXFx7XCIsIFwiXFxcXH1cIl0sXG4gICAgICB2bWF0cml4OiBbXCJ8XCIsIFwifFwiXSxcbiAgICAgIFZtYXRyaXg6IFtcIlxcXFxWZXJ0XCIsIFwiXFxcXFZlcnRcIl1cbiAgICB9W2NvbnRleHQuZW52TmFtZS5yZXBsYWNlKFwiKlwiLCBcIlwiKV07XG4gICAgLy8gXFxoc2tpcCAtXFxhcnJheWNvbHNlcCBpbiBhbXNtYXRoXG4gICAgbGV0IGNvbEFsaWduID0gXCJjXCI7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGVudkNsYXNzZXM6IFtdLFxuICAgICAgY29sczogW11cbiAgICB9O1xuICAgIGlmIChjb250ZXh0LmVudk5hbWUuY2hhckF0KGNvbnRleHQuZW52TmFtZS5sZW5ndGggLSAxKSA9PT0gXCIqXCIpIHtcbiAgICAgIC8vIEl0J3Mgb25lIG9mIHRoZSBtYXRodG9vbHMgc3RhcnJlZCBmdW5jdGlvbnMuXG4gICAgICAvLyBQYXJzZSB0aGUgb3B0aW9uYWwgYWxpZ25tZW50IGFyZ3VtZW50LlxuICAgICAgY29uc3QgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7XG4gICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgaWYgKHBhcnNlci5mZXRjaCgpLnRleHQgPT09IFwiW1wiKSB7XG4gICAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgICAgIGNvbEFsaWduID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjb2xBbGlnbikgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBsIG9yIGMgb3IgclwiLCBwYXJzZXIubmV4dFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICBwYXJzZXIuZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGF5bG9hZC5jb2xzID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIFwidGV4dFwiKTtcbiAgICByZXMuY29scyA9IG5ldyBBcnJheShyZXMuYm9keVswXS5sZW5ndGgpLmZpbGwoeyB0eXBlOiBcImFsaWduXCIsIGFsaWduOiBjb2xBbGlnbiB9KTtcbiAgICBjb25zdCBbYXJyYXlzdHJldGNoLCBhcnJheWNvbHNlcF0gPSBhcnJheUdhcHMoY29udGV4dC5wYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgcmVzLmFycmF5c3RyZXRjaCA9IGFycmF5c3RyZXRjaDtcbiAgICBpZiAoYXJyYXljb2xzZXAgJiYgIShhcnJheWNvbHNlcCA9PT0gNiAmJiBhcnJheWNvbHNlcCA9PT0gXCJwdFwiKSkge1xuICAgICAgcmVzLmFycmF5Y29sc2VwID0gYXJyYXljb2xzZXA7XG4gICAgfVxuICAgIHJldHVybiBkZWxpbWl0ZXJzXG4gICAgICA/IHtcbiAgICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgICBib2R5OiBbcmVzXSxcbiAgICAgICAgbGVmdDogZGVsaW1pdGVyc1swXSxcbiAgICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV0sXG4gICAgICAgIHJpZ2h0Q29sb3I6IHVuZGVmaW5lZCAvLyBcXHJpZ2h0IHVuaW5mbHVlbmNlZCBieSBcXGNvbG9yIGluIGFycmF5XG4gICAgICB9XG4gICAgICA6IHJlcztcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJib3JkZXJtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXlsb2FkID0geyBjb2xzOiBbXSwgZW52Q2xhc3NlczogW1wiYm9yZGVybWF0cml4XCJdIH07XG4gICAgY29uc3QgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgXCJ0ZXh0XCIpO1xuICAgIHJlcy5jb2xzID0gbmV3IEFycmF5KHJlcy5ib2R5WzBdLmxlbmd0aCkuZmlsbCh7IHR5cGU6IFwiYWxpZ25cIiwgYWxpZ246IFwiY1wiIH0pO1xuICAgIHJlcy5lbnZDbGFzc2VzID0gW107XG4gICAgcmVzLmFycmF5c3RyZXRjaCA9IDE7XG4gICAgaWYgKGNvbnRleHQuZW52TmFtZSA9PT0gXCJtYXRyaXhcIikgeyByZXR1cm4gcmVzfVxuICAgIHJldHVybiBib3JkZXJtYXRyaXhQYXJzZVRyZWUocmVzLCBjb250ZXh0LmRlbGltaXRlcnMpXG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic21hbGxtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXlsb2FkID0geyB0eXBlOiBcInNtYWxsXCIgfTtcbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBcInNjcmlwdFwiKTtcbiAgICByZXMuZW52Q2xhc3NlcyA9IFtcInNtYWxsXCJdO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic3ViYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBQYXJzaW5nIG9mIHtzdWJhcnJheX0gaXMgc2ltaWxhciB0byB7YXJyYXl9XG4gICAgY29uc3Qgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7XG4gICAgY29uc3QgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIGNvbnN0IGNvbHMgPSBjb2xhbGlnbi5tYXAoZnVuY3Rpb24obmRlKSB7XG4gICAgICBjb25zdCBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIGNvbnN0IGNhID0gbm9kZS50ZXh0O1xuICAgICAgLy8ge3N1YmFycmF5fSBvbmx5IHJlY29nbml6ZXMgXCJsXCIgJiBcImNcIlxuICAgICAgaWYgKFwibGNcIi5pbmRleE9mKGNhKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gY29sdW1uIGFsaWdubWVudDogXCIgKyBjYSwgbmRlKTtcbiAgICB9KTtcbiAgICBpZiAoY29scy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIntzdWJhcnJheX0gY2FuIGNvbnRhaW4gb25seSBvbmUgY29sdW1uXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzID0ge1xuICAgICAgY29scyxcbiAgICAgIGVudkNsYXNzZXM6IFtcInNtYWxsXCJdXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwic2NyaXB0XCIpO1xuICAgIGlmIChyZXMuYm9keS5sZW5ndGggPiAwICYmIHJlcy5ib2R5WzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwie3N1YmFycmF5fSBjYW4gY29udGFpbiBvbmx5IG9uZSBjb2x1bW5cIik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIEEgY2FzZXMgZW52aXJvbm1lbnQgKGluIGFtc21hdGguc3R5KSBpcyBhbG1vc3QgZXF1aXZhbGVudCB0b1xuLy8gXFxkZWZcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbi8vIHtkY2FzZXN9IGlzIGEge2Nhc2VzfSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBtYXRodG9vbHMuc3R5LlxuLy8ge3JjYXNlc30gaXMgYW5vdGhlciBtYXRodG9vbHMgZW52aXJvbm1lbnQuIEl0J3MgYnJhY2UgaXMgb24gdGhlIHJpZ2h0IHNpZGUuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImNhc2VzXCIsIFwiZGNhc2VzXCIsIFwicmNhc2VzXCIsIFwiZHJjYXNlc1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBjb2xzOiBbXSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImNhc2VzXCJdXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcInJcIikgPiAtMSA/IFwiLlwiIDogXCJcXFxce1wiLFxuICAgICAgcmlnaHQ6IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiclwiKSA+IC0xID8gXCJcXFxcfVwiIDogXCIuXCIsXG4gICAgICByaWdodENvbG9yOiB1bmRlZmluZWRcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBJbiB0aGUgYWxpZ24gZW52aXJvbm1lbnQsIG9uZSB1c2VzIGFtcGVyc2FuZHMsICYsIHRvIHNwZWNpZnkgbnVtYmVyIG9mXG4vLyBjb2x1bW5zIGluIGVhY2ggcm93LCBhbmQgdG8gbG9jYXRlIHNwYWNpbmcgYmV0d2VlbiBlYWNoIGNvbHVtbi5cbi8vIGFsaWduIGdldHMgYXV0b21hdGljIG51bWJlcmluZy4gYWxpZ24qIGFuZCBhbGlnbmVkIGRvIG5vdC5cbi8vIFRoZSBhbGlnbmVkYXQgZW52aXJvbm1lbnQgY2FuIGJlIHVzZWQgaW4gbWF0aCBtb2RlLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnblwiLCBcImFsaWduKlwiLCBcImFsaWduZWRcIiwgXCJzcGxpdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBhbGlnbmF0IGVudmlyb25tZW50IGlzIGxpa2UgYW4gYWxpZ24gZW52aXJvbm1lbnQsIGJ1dCBvbmUgbXVzdCBleHBsaWNpdGx5XG4vLyBzcGVjaWZ5IG1heGltdW0gbnVtYmVyIG9mIGNvbHVtbnMgaW4gZWFjaCByb3csIGFuZCBjYW4gYWRqdXN0IHdoZXJlIHNwYWNpbmcgb2NjdXJzLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnbmF0XCIsIFwiYWxpZ25hdCpcIiwgXCJhbGlnbmVkYXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBhbGlnbmVkSGFuZGxlcixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gQSBnYXRoZXJlZCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFycmF5IGVudmlyb25tZW50IHdpdGggb25lIGNlbnRlcmVkXG4vLyBjb2x1bW4sIGJ1dCB3aGVyZSByb3dzIGFyZSBjb25zaWRlcmVkIGxpbmVzIHNvIGdldCBcXGpvdCBsaW5lIHNwYWNpbmdcbi8vIGFuZCBjb250ZW50cyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJnYXRoZXJlZFwiLCBcImdhdGhlclwiLCBcImdhdGhlcipcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5lbnZOYW1lICE9PSBcImdhdGhlcmVkXCIpIHtcbiAgICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBjb2xzOiBbXSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImFidXRcIiwgXCJqb3RcIl0sXG4gICAgICBhdXRvVGFnOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgICBlbXB0eVNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJkaXNwbGF5XCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImVxdWF0aW9uXCIsIFwiZXF1YXRpb24qXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBzaW5nbGVSb3c6IHRydWUsXG4gICAgICBtYXhOdW1Db2xzOiAxLFxuICAgICAgZW52Q2xhc3NlczogW1wiYWxpZ25cIl0sXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJtdWx0bGluZVwiLCBcIm11bHRsaW5lKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGF1dG9UYWc6IGNvbnRleHQuZW52TmFtZSA9PT0gXCJtdWx0bGluZVwiLFxuICAgICAgbWF4TnVtQ29sczogMSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImpvdFwiLCBcIm11bHRsaW5lXCJdLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiQ0RcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VDRChjb250ZXh0LnBhcnNlcik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIENhdGNoIFxcaGxpbmUgb3V0c2lkZSBhcnJheSBlbnZpcm9ubWVudFxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIiwgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXGhsaW5lXCIsIFwiXFxcXGhkYXNobGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgJHtjb250ZXh0LmZ1bmNOYW1lfSB2YWxpZCBvbmx5IHdpdGhpbiBhcnJheSBlbnZpcm9ubWVudGApO1xuICB9XG59KTtcblxuY29uc3QgZW52aXJvbm1lbnRzID0gX2Vudmlyb25tZW50cztcblxuLy8gXFxib3JkZXJtYXRyaXggIGZyb20gVGVYYm9vayBwcCAxNzcgJiAzNjFcbi8vIE9wdGlvbmFsIGFyZ3VtZW50IGZyb20gSGVyYmVydCBWb8OfLCBNYXRoIG1vZGUsIHAgMjBcbi8vIFJlZjogaHR0cHM6Ly90dWcuY3Rhbi5vcmcvb2Jzb2xldGUvaW5mby9tYXRoL3Zvc3MvbWF0aG1vZGUvTWF0aG1vZGUucGRmXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJib3JkZXJtYXRyaXhcIixcbiAgbmFtZXM6IFtcIlxcXFxib3JkZXJtYXRyaXhcIiwgXCJcXFxcbWF0cml4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykgPT4ge1xuICAgIC8vIEZpbmQgb3V0IGlmIHRoZSBhdXRob3IgaGFzIGRlZmluZWQgY3VzdG9tIGRlbGltaXRlcnNcbiAgICBsZXQgZGVsaW1pdGVycyA9IFtcIihcIiwgXCIpXCJdO1xuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcYm9yZGVybWF0cml4XCIgJiYgb3B0QXJnc1swXSAmJiBvcHRBcmdzWzBdLmJvZHkpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRBcmdzWzBdLmJvZHk7XG4gICAgICBpZiAoYm9keS5sZW5ndGggPT09IDIgJiYgYm9keVswXS50eXBlID09PSBcImF0b21cIiAmJiBib2R5WzFdLnR5cGUgPT09IFwiYXRvbVwiKSB7XG4gICAgICAgIGlmIChib2R5WzBdLmZhbWlseSA9PT0gXCJvcGVuXCIgJiYgYm9keVsxXS5mYW1pbHkgPT09IFwiY2xvc2VcIikge1xuICAgICAgICAgIGRlbGltaXRlcnMgPSBbYm9keVswXS50ZXh0LCBib2R5WzFdLnRleHRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnN1bWUgdGhlIG9wZW5pbmcgYnJhY2VcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIHBhcnNlci5jb25zdW1lKCk7XG5cbiAgICAvLyBQYXNzIGNvbnRyb2wgdG8gdGhlIGVudmlyb25tZW50IGhhbmRsZXIgaW4gYXJyYXkuanMuXG4gICAgY29uc3QgZW52ID0gZW52aXJvbm1lbnRzW1wiYm9yZGVybWF0cml4XCJdO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGVudk5hbWU6IGZ1bmNOYW1lLnNsaWNlKDEpLFxuICAgICAgZGVsaW1pdGVycyxcbiAgICAgIHBhcnNlclxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCk7XG4gICAgcGFyc2VyLmV4cGVjdChcIn1cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KTtcblxuLy8gXFxAY2hhciBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZ3JvdXBlZCBkZWNpbWFsIGFyZ3VtZW50IGxpa2Vcbi8vIHsxMjN9IGFuZCBjb252ZXJ0cyBpbnRvIHN5bWJvbCB3aXRoIGNvZGUgMTIzLiAgSXQgaXMgdXNlZCBieSB0aGUgKm1hY3JvKlxuLy8gXFxjaGFyIGRlZmluZWQgaW4gbWFjcm9zLmpzLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRvcmRcIixcbiAgbmFtZXM6IFtcIlxcXFxAY2hhclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgdG9rZW4gfSwgYXJncykge1xuICAgIGNvbnN0IGFyZyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG4gICAgY29uc3QgZ3JvdXAgPSBhcmcuYm9keTtcbiAgICBsZXQgbnVtYmVyID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gYXNzZXJ0Tm9kZVR5cGUoZ3JvdXBbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIG51bWJlciArPSBub2RlLnRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBwYXJzZUludChudW1iZXIpO1xuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFxcXFxAY2hhciBoYXMgbm9uLW51bWVyaWMgYXJndW1lbnQgJHtudW1iZXJ9YCwgdG9rZW4pXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgdGV4dDogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBIZWxwZXJzXG5jb25zdCBodG1sUmVnRXggPSAvXigjW2EtZjAtOV17M318Iz9bYS1mMC05XXs2fSkkL2k7XG5jb25zdCBodG1sT3JOYW1lUmVnRXggPSAvXigjW2EtZjAtOV17M318Iz9bYS1mMC05XXs2fXxbYS16XSspJC9pO1xuY29uc3QgUkdCcmVnRXggPSAvXiAqXFxkezEsM30gKig/OiwgKlxcZHsxLDN9ICopezJ9JC87XG5jb25zdCByZ2JSZWdFeCA9IC9eICpbMTBdKD86XFwuXFxkKik/ICooPzosICpbMTBdKD86XFwuXFxkKik/ICopezJ9JC87XG5jb25zdCB4Y29sb3JIdG1sUmVnRXggPSAvXlthLWYwLTldezZ9JC9pO1xuY29uc3QgdG9IZXggPSBudW0gPT4ge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDEpIHsgc3RyID0gXCIwXCIgKyBzdHI7IH1cbiAgcmV0dXJuIHN0clxufTtcblxuLy8gQ29sb3JzIGZyb20gVGFibGVzIDQuMSBhbmQgNC4yIG9mIHRoZSB4Y29sb3IgcGFja2FnZS5cbi8vIFRhYmxlIDQuMSAobG93ZXIgY2FzZSkgUkdCIHZhbHVlcyBhcmUgdGFrZW4gZnJvbSBjaHJvbWEgYW5kIHhjb2xvci5kdHguXG4vLyBUYWJsZSA0LjIgKENhcGl0YWxpenplZCkgdmFsdWVzIHdlcmUgc2FtcGxlZCwgYmVjYXVzZSBDaHJvbWEgY29udGFpbnMgYSB1bnJlbGlhYmxlXG4vLyBjb252ZXJzaW9uIGZyb20gY215ayB0byBSR0IuIFNlZSBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzUzNzI3NC5cbmNvbnN0IHhjb2xvcnMgPSBKU09OLnBhcnNlKGB7XG4gIFwiQXByaWNvdFwiOiBcIiNmZmI0ODRcIixcbiAgXCJBcXVhbWFyaW5lXCI6IFwiIzA4YjRiY1wiLFxuICBcIkJpdHRlcnN3ZWV0XCI6IFwiI2M4NGMxNFwiLFxuICBcImJsdWVcIjogXCIjMDAwMEZGXCIsXG4gIFwiQmx1ZVwiOiBcIiMzMDM0OTRcIixcbiAgXCJCbHVlR3JlZW5cIjogXCIjMDhiNGJjXCIsXG4gIFwiQmx1ZVZpb2xldFwiOiBcIiM1MDNjOTRcIixcbiAgXCJCcmlja1JlZFwiOiBcIiNiODM0MWNcIixcbiAgXCJicm93blwiOiBcIiNCRjgwNDBcIixcbiAgXCJCcm93blwiOiBcIiM4MDI0MDRcIixcbiAgXCJCdXJudE9yYW5nZVwiOiBcIiNmODk0MWNcIixcbiAgXCJDYWRldEJsdWVcIjogXCIjNzg3NDljXCIsXG4gIFwiQ2FybmF0aW9uUGlua1wiOiBcIiNmODg0YjRcIixcbiAgXCJDZXJ1bGVhblwiOiBcIiMwOGE0ZTRcIixcbiAgXCJDb3JuZmxvd2VyQmx1ZVwiOiBcIiM0MGFjZTRcIixcbiAgXCJjeWFuXCI6IFwiIzAwRkZGRlwiLFxuICBcIkN5YW5cIjogXCIjMDhhY2VjXCIsXG4gIFwiRGFuZGVsaW9uXCI6IFwiI2ZmYmM0NFwiLFxuICBcImRhcmtncmF5XCI6IFwiIzQwNDA0MFwiLFxuICBcIkRhcmtPcmNoaWRcIjogXCIjYTg1NDhjXCIsXG4gIFwiRW1lcmFsZFwiOiBcIiMwOGFjOWNcIixcbiAgXCJGb3Jlc3RHcmVlblwiOiBcIiMwODljNTRcIixcbiAgXCJGdWNoc2lhXCI6IFwiIzkwMzQ4Y1wiLFxuICBcIkdvbGRlbnJvZFwiOiBcIiNmZmRjNDRcIixcbiAgXCJncmF5XCI6IFwiIzgwODA4MFwiLFxuICBcIkdyYXlcIjogXCIjOTg5NDljXCIsXG4gIFwiZ3JlZW5cIjogXCIjMDBGRjAwXCIsXG4gIFwiR3JlZW5cIjogXCIjMDhhNDRjXCIsXG4gIFwiR3JlZW5ZZWxsb3dcIjogXCIjZTBlNDc0XCIsXG4gIFwiSnVuZ2xlR3JlZW5cIjogXCIjMDhhYzljXCIsXG4gIFwiTGF2ZW5kZXJcIjogXCIjZjg5Y2M0XCIsXG4gIFwibGlnaHRncmF5XCI6IFwiI2MwYzBjMFwiLFxuICBcImxpbWVcIjogXCIjQkZGRjAwXCIsXG4gIFwiTGltZUdyZWVuXCI6IFwiIzkwYzQzY1wiLFxuICBcIm1hZ2VudGFcIjogXCIjRkYwMEZGXCIsXG4gIFwiTWFnZW50YVwiOiBcIiNmMDA0OGNcIixcbiAgXCJNYWhvZ2FueVwiOiBcIiNiMDM0MWNcIixcbiAgXCJNYXJvb25cIjogXCIjYjAzNDM0XCIsXG4gIFwiTWVsb25cIjogXCIjZjg5YzdjXCIsXG4gIFwiTWlkbmlnaHRCbHVlXCI6IFwiIzA4NjQ5NFwiLFxuICBcIk11bGJlcnJ5XCI6IFwiI2IwM2M5NFwiLFxuICBcIk5hdnlCbHVlXCI6IFwiIzA4NmNiY1wiLFxuICBcIm9saXZlXCI6IFwiIzdGN0YwMFwiLFxuICBcIk9saXZlR3JlZW5cIjogXCIjNDA3YzM0XCIsXG4gIFwib3JhbmdlXCI6IFwiI0ZGODAwMFwiLFxuICBcIk9yYW5nZVwiOiBcIiNmODg0M2NcIixcbiAgXCJPcmFuZ2VSZWRcIjogXCIjZjAxNDVjXCIsXG4gIFwiT3JjaGlkXCI6IFwiI2IwNzRhY1wiLFxuICBcIlBlYWNoXCI6IFwiI2Y4OTQ1Y1wiLFxuICBcIlBlcml3aW5rbGVcIjogXCIjODA3NGJjXCIsXG4gIFwiUGluZUdyZWVuXCI6IFwiIzA4OGM3NFwiLFxuICBcInBpbmtcIjogXCIjZmY3ZjdmXCIsXG4gIFwiUGx1bVwiOiBcIiM5ODI0OGNcIixcbiAgXCJQcm9jZXNzQmx1ZVwiOiBcIiMwOGI0ZWNcIixcbiAgXCJwdXJwbGVcIjogXCIjQkYwMDQwXCIsXG4gIFwiUHVycGxlXCI6IFwiI2EwNDQ5Y1wiLFxuICBcIlJhd1NpZW5uYVwiOiBcIiM5ODNjMDRcIixcbiAgXCJyZWRcIjogXCIjZmYwMDAwXCIsXG4gIFwiUmVkXCI6IFwiI2YwMWMyNFwiLFxuICBcIlJlZE9yYW5nZVwiOiBcIiNmODY0MzRcIixcbiAgXCJSZWRWaW9sZXRcIjogXCIjYTAyNDZjXCIsXG4gIFwiUmhvZGFtaW5lXCI6IFwiI2YwNTQ5Y1wiLFxuICBcIlJveWFsbHVlXCI6IFwiIzA4NzRiY1wiLFxuICBcIlJveWFsUHVycGxlXCI6IFwiIzY4M2M5Y1wiLFxuICBcIlJ1YmluZVJlZFwiOiBcIiNmMDA0N2NcIixcbiAgXCJTYWxtb25cIjogXCIjZjg5NDhjXCIsXG4gIFwiU2VhR3JlZW5cIjogXCIjMzBiYzljXCIsXG4gIFwiU2VwaWFcIjogXCIjNzAxNDA0XCIsXG4gIFwiU2t5Qmx1ZVwiOiBcIiM0OGM0ZGNcIixcbiAgXCJTcHJpbmdHcmVlblwiOiBcIiNjOGRjNjRcIixcbiAgXCJUYW5cIjogXCIjZTA5Yzc0XCIsXG4gIFwidGVhbFwiOiBcIiMwMDdGN0ZcIixcbiAgXCJUZWFsQmx1ZVwiOiBcIiMwOGFjYjRcIixcbiAgXCJUaGlzdGxlXCI6IFwiI2Q4ODRiNFwiLFxuICBcIlR1cnF1b2lzZVwiOiBcIiMwOGI0Y2NcIixcbiAgXCJ2aW9sZXRcIjogXCIjODAwMDgwXCIsXG4gIFwiVmlvbGV0XCI6IFwiIzYwNDQ5Y1wiLFxuICBcIlZpb2xldFJlZFwiOiBcIiNmMDU0YTRcIixcbiAgXCJXaWxkU3RyYXdiZXJyeVwiOiBcIiNmMDI0NmNcIixcbiAgXCJ5ZWxsb3dcIjogXCIjRkZGRjAwXCIsXG4gIFwiWWVsbG93XCI6IFwiI2ZmZjQwNFwiLFxuICBcIlllbGxvd0dyZWVuXCI6IFwiIzk4Y2M2Y1wiLFxuICBcIlllbGxvd09yYW5nZVwiOiBcIiNmZmE0MWNcIlxufWApO1xuXG5jb25zdCBjb2xvckZyb21TcGVjID0gKG1vZGVsLCBzcGVjKSA9PiB7XG4gIGxldCBjb2xvciA9IFwiXCI7XG4gIGlmIChtb2RlbCA9PT0gXCJIVE1MXCIpIHtcbiAgICBpZiAoIWh0bWxSZWdFeC50ZXN0KHNwZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgSFRNTCBpbnB1dC5cIilcbiAgICB9XG4gICAgY29sb3IgPSBzcGVjO1xuICB9IGVsc2UgaWYgKG1vZGVsID09PSBcIlJHQlwiKSB7XG4gICAgaWYgKCFSR0JyZWdFeC50ZXN0KHNwZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgUkdCIGlucHV0LlwiKVxuICAgIH1cbiAgICBzcGVjLnNwbGl0KFwiLFwiKS5tYXAoZSA9PiB7IGNvbG9yICs9IHRvSGV4KE51bWJlcihlLnRyaW0oKSkpOyB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXJnYlJlZ0V4LnRlc3Qoc3BlYykpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCByYmcgaW5wdXQuXCIpXG4gICAgfVxuICAgIHNwZWMuc3BsaXQoXCIsXCIpLm1hcChlID0+IHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihlLnRyaW0oKSk7XG4gICAgICBpZiAobnVtID4gMSkgeyB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNvbG9yIHJnYiBpbnB1dCBtdXN0IGJlIDwgMS5cIikgfVxuICAgICAgY29sb3IgKz0gdG9IZXgoTnVtYmVyKChudW0gKiAyNTUpLnRvRml4ZWQoMCkpKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY29sb3IuY2hhckF0KDApICE9PSBcIiNcIikgeyBjb2xvciA9IFwiI1wiICsgY29sb3I7IH1cbiAgcmV0dXJuIGNvbG9yXG59O1xuXG5jb25zdCB2YWxpZGF0ZUNvbG9yID0gKGNvbG9yLCBtYWNyb3MsIHRva2VuKSA9PiB7XG4gIGNvbnN0IG1hY3JvTmFtZSA9IGBcXFxcXFxcXGNvbG9yQCR7Y29sb3J9YDsgLy8gZnJvbSBcXGRlZmluZUNvbG9yLlxuICBjb25zdCBtYXRjaCA9IGh0bWxPck5hbWVSZWdFeC5leGVjKGNvbG9yKTtcbiAgaWYgKCFtYXRjaCkgeyB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgY29sb3I6ICdcIiArIGNvbG9yICsgXCInXCIsIHRva2VuKSB9XG4gIC8vIFdlIGFsbG93IGEgNi1kaWdpdCBIVE1MIGNvbG9yIHNwZWMgd2l0aG91dCBhIGxlYWRpbmcgXCIjXCIuXG4gIC8vIFRoaXMgZm9sbG93cyB0aGUgeGNvbG9yIHBhY2thZ2UncyBIVE1MIGNvbG9yIG1vZGVsLlxuICAvLyBQcmVkZWZpbmVkIGNvbG9yIG5hbWVzIGFyZSBhbGwgbWlzc2VkIGJ5IHRoaXMgUmVnRXggcGF0dGVybi5cbiAgaWYgKHhjb2xvckh0bWxSZWdFeC50ZXN0KGNvbG9yKSkge1xuICAgIHJldHVybiBcIiNcIiArIGNvbG9yXG4gIH0gZWxzZSBpZiAoY29sb3IuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgIHJldHVybiBjb2xvclxuICB9IGVsc2UgaWYgKG1hY3Jvcy5oYXMobWFjcm9OYW1lKSkge1xuICAgIGNvbG9yID0gbWFjcm9zLmdldChtYWNyb05hbWUpLnRva2Vuc1swXS50ZXh0O1xuICB9IGVsc2UgaWYgKHhjb2xvcnNbY29sb3JdKSB7XG4gICAgY29sb3IgPSB4Y29sb3JzW2NvbG9yXTtcbiAgfVxuICByZXR1cm4gY29sb3Jcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkOCA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgLy8gSW4gTGFUZVgsIGNvbG9yIGlzIG5vdCBzdXBwb3NlZCB0byBjaGFuZ2UgdGhlIHNwYWNpbmcgb2YgYW55IG5vZGUuXG4gIC8vIFNvIGluc3RlYWQgb2Ygd3JhcHBpbmcgdGhlIGdyb3VwIGluIGFuIDxtc3R5bGU+LCB3ZSBhcHBseVxuICAvLyB0aGUgY29sb3IgaW5kaXZpZHVhbGx5IHRvIGVhY2ggbm9kZSBhbmQgcmV0dXJuIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG4gIGxldCBleHByID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlLndpdGhDb2xvcihncm91cC5jb2xvcikpO1xuICBleHByID0gZXhwci5tYXAoZSA9PiB7XG4gICAgZS5zdHlsZS5jb2xvciA9IGdyb3VwLmNvbG9yO1xuICAgIHJldHVybiBlXG4gIH0pO1xuICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KGV4cHIpXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFx0ZXh0Y29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwicmF3XCIsIFwib3JpZ2luYWxcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgdG9rZW4gfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0QXJnc1swXSAmJiBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgbGV0IGNvbG9yID0gXCJcIjtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IHNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBjb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIHNwZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3JvcywgdG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb2xvcixcbiAgICAgIGlzVGV4dENvbG9yOiB0cnVlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInJhd1wiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBicmVha09uVG9rZW5UZXh0LCB0b2tlbiB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBsZXQgY29sb3IgPSBcIlwiO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3Qgc3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICAgIGNvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgc3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gdmFsaWRhdGVDb2xvcihhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmcsIHBhcnNlci5ndWxsZXQubWFjcm9zLCB0b2tlbik7XG4gICAgfVxuXG4gICAgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5IHRoYXQgc2hvdWxkIGJlIGNvbG9yZWQuXG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb2xvcixcbiAgICAgIGlzVGV4dENvbG9yOiBmYWxzZSxcbiAgICAgIGJvZHlcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXGRlZmluZWNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwicmF3XCIsIFwicmF3XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSB7XG4gICAgY29uc3QgbmFtZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBpZiAoIS9eW0EtWmEtel0rJC8udGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDb2xvciBuYW1lIG11c3QgYmUgbGF0aW4gbGV0dGVycy5cIiwgdG9rZW4pXG4gICAgfVxuICAgIGNvbnN0IG1vZGVsID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGlmICghW1wiSFRNTFwiLCBcIlJHQlwiLCBcInJnYlwiXS5pbmNsdWRlcyhtb2RlbCkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ29sb3IgbW9kZWwgbXVzdCBiZSBIVE1MLCBSR0IsIG9yIHJnYi5cIiwgdG9rZW4pXG4gICAgfVxuICAgIGNvbnN0IHNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzJdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgY29uc3QgY29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBzcGVjKTtcbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoYFxcXFxcXFxcY29sb3JAJHtuYW1lfWAsIHsgdG9rZW5zOiBbeyB0ZXh0OiBjb2xvciB9XSwgbnVtQXJnczogMCB9KTtcbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH1cbiAgfVxuICAvLyBObyBtYXRobWxCdWlsZGVyLiBUaGUgcG9pbnQgb2YgXFxkZWZpbmVjb2xvciBpcyB0byBzZXQgYSBtYWNyby5cbn0pO1xuXG4vLyBSb3cgYnJlYWtzIHdpdGhpbiB0YWJ1bGFyIGVudmlyb25tZW50cywgYW5kIGxpbmUgYnJlYWtzIGF0IHRvcCBsZXZlbFxuXG5cbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXFxcey4uLlxcQHhuZXdsaW5lfVxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNyXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCA9PT0gXCJbXCIgPyBwYXJzZXIucGFyc2VTaXplR3JvdXAodHJ1ZSkgOiBudWxsO1xuICAgIGNvbnN0IG5ld0xpbmUgPSAhcGFyc2VyLnNldHRpbmdzLmRpc3BsYXlNb2RlO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5ld0xpbmUsXG4gICAgICBzaXplOiBzaXplICYmIGFzc2VydE5vZGVUeXBlKHNpemUsIFwic2l6ZVwiKS52YWx1ZVxuICAgIH1cbiAgfSxcblxuICAvLyBUaGUgZm9sbG93aW5nIGJ1aWxkZXIgaXMgY2FsbGVkIG9ubHkgYXQgdGhlIHRvcCBsZXZlbCxcbiAgLy8gbm90IHdpdGhpbiB0YWJ1bGFyL2FycmF5IGVudmlyb25tZW50cy5cblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIE1hdGhNTCAzLjAgY2FsbHMgZm9yIG5ld2xpbmUgdG8gb2NjdXIgaW4gYW4gPG1vPiBvciBhbiA8bXNwYWNlPi5cbiAgICAvLyBSZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9NYXRoTUwzL2NoYXB0ZXIzLmh0bWwjcHJlc20ubGluZWJyZWFraW5nXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIik7XG4gICAgaWYgKGdyb3VwLm5ld0xpbmUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZWJyZWFrXCIsIFwibmV3bGluZVwiKTtcbiAgICAgIGlmIChncm91cC5zaXplKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVTaXplKGdyb3VwLnNpemUsIHN0eWxlKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc2l6ZS5udW1iZXIgKyBzaXplLnVuaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuY29uc3QgZ2xvYmFsTWFwID0ge1xuICBcIlxcXFxnbG9iYWxcIjogXCJcXFxcZ2xvYmFsXCIsXG4gIFwiXFxcXGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcZGVmXCI6IFwiXFxcXGdkZWZcIixcbiAgXCJcXFxcZ2RlZlwiOiBcIlxcXFxnZGVmXCIsXG4gIFwiXFxcXGVkZWZcIjogXCJcXFxceGRlZlwiLFxuICBcIlxcXFx4ZGVmXCI6IFwiXFxcXHhkZWZcIixcbiAgXCJcXFxcbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxsZXRcIixcbiAgXCJcXFxcZnV0dXJlbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIlxufTtcblxuY29uc3QgY2hlY2tDb250cm9sU2VxdWVuY2UgPSAodG9rKSA9PiB7XG4gIGNvbnN0IG5hbWUgPSB0b2sudGV4dDtcbiAgaWYgKC9eKD86W1xcXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBjb250cm9sIHNlcXVlbmNlXCIsIHRvayk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG5jb25zdCBnZXRSSFMgPSAocGFyc2VyKSA9PiB7XG4gIGxldCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gIGlmICh0b2sudGV4dCA9PT0gXCI9XCIpIHtcbiAgICAvLyBjb25zdW1lIG9wdGlvbmFsIGVxdWFsc1xuICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBpZiAodG9rLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAvLyBjb25zdW1lIG9uZSBvcHRpb25hbCBzcGFjZVxuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rO1xufTtcblxuY29uc3QgbGV0Q29tbWFuZCA9IChwYXJzZXIsIG5hbWUsIHRvaywgZ2xvYmFsKSA9PiB7XG4gIGxldCBtYWNybyA9IHBhcnNlci5ndWxsZXQubWFjcm9zLmdldCh0b2sudGV4dCk7XG4gIGlmIChtYWNybyA9PSBudWxsKSB7XG4gICAgLy8gZG9uJ3QgZXhwYW5kIGl0IGxhdGVyIGV2ZW4gaWYgYSBtYWNybyB3aXRoIHRoZSBzYW1lIG5hbWUgaXMgZGVmaW5lZFxuICAgIC8vIGUuZy4sIFxcbGV0XFxmb289XFxmcmFjIFxcZGVmXFxmcmFje1xccmVsYXh9IFxcZnJhYzEyXG4gICAgdG9rLm5vZXhwYW5kID0gdHJ1ZTtcbiAgICBtYWNybyA9IHtcbiAgICAgIHRva2VuczogW3Rva10sXG4gICAgICBudW1BcmdzOiAwLFxuICAgICAgLy8gcmVwcm9kdWNlIHRoZSBzYW1lIGJlaGF2aW9yIGluIGV4cGFuc2lvblxuICAgICAgdW5leHBhbmRhYmxlOiAhcGFyc2VyLmd1bGxldC5pc0V4cGFuZGFibGUodG9rLnRleHQpXG4gICAgfTtcbiAgfVxuICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQobmFtZSwgbWFjcm8sIGdsb2JhbCk7XG59O1xuXG4vLyA8YXNzaWdubWVudD4gLT4gPG5vbi1tYWNybyBhc3NpZ25tZW50Pnw8bWFjcm8gYXNzaWdubWVudD5cbi8vIDxub24tbWFjcm8gYXNzaWdubWVudD4gLT4gPHNpbXBsZSBhc3NpZ25tZW50PnxcXGdsb2JhbDxub24tbWFjcm8gYXNzaWdubWVudD5cbi8vIDxtYWNybyBhc3NpZ25tZW50PiAtPiA8ZGVmaW5pdGlvbj58PHByZWZpeD48bWFjcm8gYXNzaWdubWVudD5cbi8vIDxwcmVmaXg+IC0+IFxcZ2xvYmFsfFxcbG9uZ3xcXG91dGVyXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxnbG9iYWxcIixcbiAgICBcIlxcXFxsb25nXCIsXG4gICAgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgY29uc3QgdG9rZW4gPSBwYXJzZXIuZmV0Y2goKTtcbiAgICBpZiAoZ2xvYmFsTWFwW3Rva2VuLnRleHRdKSB7XG4gICAgICAvLyBUZW1tbCBkb2Vzbid0IGhhdmUgXFxwYXIsIHNvIGlnbm9yZSBcXGxvbmdcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcZ2xvYmFsXCIgfHwgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIpIHtcbiAgICAgICAgdG9rZW4udGV4dCA9IGdsb2JhbE1hcFt0b2tlbi50ZXh0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImludGVybmFsXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCB0b2tlbiBhZnRlciBtYWNybyBwcmVmaXhgLCB0b2tlbik7XG4gIH1cbn0pO1xuXG4vLyBCYXNpYyBzdXBwb3J0IGZvciBtYWNybyBkZWZpbml0aW9uczogXFxkZWYsIFxcZ2RlZiwgXFxlZGVmLCBcXHhkZWZcbi8vIDxkZWZpbml0aW9uPiAtPiA8ZGVmPjxjb250cm9sIHNlcXVlbmNlPjxkZWZpbml0aW9uIHRleHQ+XG4vLyA8ZGVmPiAtPiBcXGRlZnxcXGdkZWZ8XFxlZGVmfFxceGRlZlxuLy8gPGRlZmluaXRpb24gdGV4dD4gLT4gPHBhcmFtZXRlciB0ZXh0PjxsZWZ0IGJyYWNlPjxiYWxhbmNlZCB0ZXh0PjxyaWdodCBicmFjZT5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXGRlZlwiLCBcIlxcXFxnZGVmXCIsIFwiXFxcXGVkZWZcIiwgXCJcXFxceGRlZlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBsZXQgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGNvbnN0IG5hbWUgPSB0b2sudGV4dDtcbiAgICBpZiAoL14oPzpbXFxcXHt9JCYjXl9dfEVPRikkLy50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGEgY29udHJvbCBzZXF1ZW5jZVwiLCB0b2spO1xuICAgIH1cblxuICAgIGxldCBudW1BcmdzID0gMDtcbiAgICBsZXQgaW5zZXJ0O1xuICAgIGNvbnN0IGRlbGltaXRlcnMgPSBbW11dO1xuICAgIC8vIDxwYXJhbWV0ZXIgdGV4dD4gY29udGFpbnMgbm8gYnJhY2VzXG4gICAgd2hpbGUgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCJ7XCIpIHtcbiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICAgIGlmICh0b2sudGV4dCA9PT0gXCIjXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZlcnkgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIDxwYXJhbWV0ZXIgdGV4dD4gaXMgIywgc28gdGhhdFxuICAgICAgICAvLyB0aGlzICMgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgeywgVGVYIHdpbGwgYmVoYXZlIGFzIGlmIHRoZSB7XG4gICAgICAgIC8vIGhhZCBiZWVuIGluc2VydGVkIGF0IHRoZSByaWdodCBlbmQgb2YgYm90aCB0aGUgcGFyYW1ldGVyIHRleHRcbiAgICAgICAgLy8gYW5kIHRoZSByZXBsYWNlbWVudCB0ZXh0LlxuICAgICAgICBpZiAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ID09PSBcIntcIikge1xuICAgICAgICAgIGluc2VydCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCk7XG4gICAgICAgICAgZGVsaW1pdGVyc1tudW1BcmdzXS5wdXNoKFwie1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgcGFyYW1ldGVyLCB0aGUgZmlyc3QgYXBwZWFyYW5jZSBvZiAjIG11c3QgYmUgZm9sbG93ZWQgYnkgMSxcbiAgICAgICAgLy8gdGhlIG5leHQgYnkgMiwgYW5kIHNvIG9uOyB1cCB0byBuaW5lICPigJlzIGFyZSBhbGxvd2VkXG4gICAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICAgICAgaWYgKCEvXlsxLTldJC8udGVzdCh0b2sudGV4dCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBhcmd1bWVudCBudW1iZXIgXCIke3Rvay50ZXh0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlSW50KHRvay50ZXh0KSAhPT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgQXJndW1lbnQgbnVtYmVyIFwiJHt0b2sudGV4dH1cIiBvdXQgb2Ygb3JkZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBudW1BcmdzKys7XG4gICAgICAgIGRlbGltaXRlcnMucHVzaChbXSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBtYWNybyBkZWZpbml0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsaW1pdGVyc1tudW1BcmdzXS5wdXNoKHRvay50ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVwbGFjZW1lbnQgdGV4dCwgZW5jbG9zZWQgaW4gJ3snIGFuZCAnfScgYW5kIHByb3Blcmx5IG5lc3RlZFxuICAgIGxldCB7IHRva2VucyB9ID0gcGFyc2VyLmd1bGxldC5jb25zdW1lQXJnKCk7XG4gICAgaWYgKGluc2VydCkge1xuICAgICAgdG9rZW5zLnVuc2hpZnQoaW5zZXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGVkZWZcIiB8fCBmdW5jTmFtZSA9PT0gXCJcXFxceGRlZlwiKSB7XG4gICAgICB0b2tlbnMgPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZFRva2Vucyh0b2tlbnMpO1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiBwYXJzZXIuZ3VsbGV0LnNldHRpbmdzLm1heEV4cGFuZCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRvbyBtYW55IGV4cGFuc2lvbnMgaW4gYW4gXCIgKyBmdW5jTmFtZSk7XG4gICAgICB9XG4gICAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayBvcmRlclxuICAgIH1cbiAgICAvLyBGaW5hbCBhcmcgaXMgdGhlIGV4cGFuc2lvbiBvZiB0aGUgbWFjcm9cbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXG4gICAgICBuYW1lLFxuICAgICAgeyB0b2tlbnMsIG51bUFyZ3MsIGRlbGltaXRlcnMgfSxcbiAgICAgIGZ1bmNOYW1lID09PSBnbG9iYWxNYXBbZnVuY05hbWVdXG4gICAgKTtcbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG4gIH1cbn0pO1xuXG4vLyA8c2ltcGxlIGFzc2lnbm1lbnQ+IC0+IDxsZXQgYXNzaWdubWVudD5cbi8vIDxsZXQgYXNzaWdubWVudD4gLT4gXFxmdXR1cmVsZXQ8Y29udHJvbCBzZXF1ZW5jZT48dG9rZW4+PHRva2VuPlxuLy8gICAgIHwgXFxsZXQ8Y29udHJvbCBzZXF1ZW5jZT48ZXF1YWxzPjxvbmUgb3B0aW9uYWwgc3BhY2U+PHRva2VuPlxuLy8gPGVxdWFscz4gLT4gPG9wdGlvbmFsIHNwYWNlcz58PG9wdGlvbmFsIHNwYWNlcz49XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxsZXRcIixcbiAgICBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgY29uc3QgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgcGFyc2VyLmd1bGxldC5jb25zdW1lU3BhY2VzKCk7XG4gICAgY29uc3QgdG9rID0gZ2V0UkhTKHBhcnNlcik7XG4gICAgbGV0Q29tbWFuZChwYXJzZXIsIG5hbWUsIHRvaywgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsZXRcIik7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcm5hbFwiLCBtb2RlOiBwYXJzZXIubW9kZSB9O1xuICB9XG59KTtcblxuLy8gcmVmOiBodHRwczovL3d3dy50dWcub3JnL1RVR2JvYXQvdGIwOS0zL3RiMjJiZWNodG9sc2hlaW0ucGRmXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxmdXR1cmVsZXRcIixcbiAgICBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgY29uc3QgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgY29uc3QgbWlkZGxlID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGNvbnN0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBsZXRDb21tYW5kKHBhcnNlciwgbmFtZSwgdG9rLCBmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiKTtcbiAgICBwYXJzZXIuZ3VsbGV0LnB1c2hUb2tlbih0b2spO1xuICAgIHBhcnNlci5ndWxsZXQucHVzaFRva2VuKG1pZGRsZSk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcm5hbFwiLCBtb2RlOiBwYXJzZXIubW9kZSB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcbmV3Y29tbWFuZFwiLCBcIlxcXFxyZW5ld2NvbW1hbmRcIiwgXCJcXFxccHJvdmlkZWNvbW1hbmRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgbGV0IG5hbWUgPSBcIlwiO1xuICAgIGNvbnN0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBpZiAodG9rLnRleHQgPT09IFwie1wiKSB7XG4gICAgICBuYW1lID0gY2hlY2tDb250cm9sU2VxdWVuY2UocGFyc2VyLmd1bGxldC5wb3BUb2tlbigpKTtcbiAgICAgIHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHRvayk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RzID0gcGFyc2VyLmd1bGxldC5pc0RlZmluZWQobmFtZSk7XG4gICAgaWYgKGV4aXN0cyAmJiBmdW5jTmFtZSA9PT0gXCJcXFxcbmV3Y29tbWFuZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgYFxcXFxuZXdjb21tYW5keyR7bmFtZX19IGF0dGVtcHRpbmcgdG8gcmVkZWZpbmUgJHtuYW1lfTsgdXNlIFxcXFxyZW5ld2NvbW1hbmRgXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWV4aXN0cyAmJiBmdW5jTmFtZSA9PT0gXCJcXFxccmVuZXdjb21tYW5kXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBgXFxcXHJlbmV3Y29tbWFuZHske25hbWV9fSB3aGVuIGNvbW1hbmQgJHtuYW1lfSBkb2VzIG5vdCB5ZXQgZXhpc3Q7IHVzZSBcXFxcbmV3Y29tbWFuZGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG51bUFyZ3MgPSAwO1xuICAgIGlmIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgPT09IFwiW1wiKSB7XG4gICAgICBsZXQgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgaWYgKCEvXlswLTldJC8udGVzdCh0b2sudGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50czogXCIke3Rvay50ZXh0fVwiYCk7XG4gICAgICB9XG4gICAgICBudW1BcmdzID0gcGFyc2VJbnQodG9rLnRleHQpO1xuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgaWYgKHRvay50ZXh0ICE9PSBcIl1cIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBhcmd1bWVudCBcIiR7dG9rLnRleHR9XCJgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXBsYWNlbWVudCB0ZXh0LCBlbmNsb3NlZCBpbiAneycgYW5kICd9JyBhbmQgcHJvcGVybHkgbmVzdGVkXG4gICAgY29uc3QgeyB0b2tlbnMgfSA9IHBhcnNlci5ndWxsZXQuY29uc3VtZUFyZygpO1xuXG4gICAgaWYgKCEoZnVuY05hbWUgPT09IFwiXFxcXHByb3ZpZGVjb21tYW5kXCIgJiYgcGFyc2VyLmd1bGxldC5tYWNyb3MuaGFzKG5hbWUpKSkge1xuICAgICAgLy8gSWdub3JlIFxccHJvdmlkZWNvbW1hbmRcbiAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcbiAgICAgICAgbmFtZSxcbiAgICAgICAgeyB0b2tlbnMsIG51bUFyZ3MgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG5cbiAgfVxufSk7XG5cbi8vIEV4dHJhIGRhdGEgbmVlZGVkIGZvciB0aGUgZGVsaW1pdGVyIGhhbmRsZXIgZG93biBiZWxvd1xuY29uc3QgZGVsaW1pdGVyU2l6ZXMgPSB7XG4gIFwiXFxcXGJpZ2xcIjogeyBtY2xhc3M6IFwibW9wZW5cIiwgc2l6ZTogMSB9LFxuICBcIlxcXFxCaWdsXCI6IHsgbWNsYXNzOiBcIm1vcGVuXCIsIHNpemU6IDIgfSxcbiAgXCJcXFxcYmlnZ2xcIjogeyBtY2xhc3M6IFwibW9wZW5cIiwgc2l6ZTogMyB9LFxuICBcIlxcXFxCaWdnbFwiOiB7IG1jbGFzczogXCJtb3BlblwiLCBzaXplOiA0IH0sXG4gIFwiXFxcXGJpZ3JcIjogeyBtY2xhc3M6IFwibWNsb3NlXCIsIHNpemU6IDEgfSxcbiAgXCJcXFxcQmlnclwiOiB7IG1jbGFzczogXCJtY2xvc2VcIiwgc2l6ZTogMiB9LFxuICBcIlxcXFxiaWdnclwiOiB7IG1jbGFzczogXCJtY2xvc2VcIiwgc2l6ZTogMyB9LFxuICBcIlxcXFxCaWdnclwiOiB7IG1jbGFzczogXCJtY2xvc2VcIiwgc2l6ZTogNCB9LFxuICBcIlxcXFxiaWdtXCI6IHsgbWNsYXNzOiBcIm1yZWxcIiwgc2l6ZTogMSB9LFxuICBcIlxcXFxCaWdtXCI6IHsgbWNsYXNzOiBcIm1yZWxcIiwgc2l6ZTogMiB9LFxuICBcIlxcXFxiaWdnbVwiOiB7IG1jbGFzczogXCJtcmVsXCIsIHNpemU6IDMgfSxcbiAgXCJcXFxcQmlnZ21cIjogeyBtY2xhc3M6IFwibXJlbFwiLCBzaXplOiA0IH0sXG4gIFwiXFxcXGJpZ1wiOiB7IG1jbGFzczogXCJtb3JkXCIsIHNpemU6IDEgfSxcbiAgXCJcXFxcQmlnXCI6IHsgbWNsYXNzOiBcIm1vcmRcIiwgc2l6ZTogMiB9LFxuICBcIlxcXFxiaWdnXCI6IHsgbWNsYXNzOiBcIm1vcmRcIiwgc2l6ZTogMyB9LFxuICBcIlxcXFxCaWdnXCI6IHsgbWNsYXNzOiBcIm1vcmRcIiwgc2l6ZTogNCB9XG59O1xuXG5jb25zdCBkZWxpbWl0ZXJzID0gW1xuICBcIihcIixcbiAgXCJcXFxcbHBhcmVuXCIsXG4gIFwiKVwiLFxuICBcIlxcXFxycGFyZW5cIixcbiAgXCJbXCIsXG4gIFwiXFxcXGxicmFja1wiLFxuICBcIl1cIixcbiAgXCJcXFxccmJyYWNrXCIsXG4gIFwiXFxcXHtcIixcbiAgXCJcXFxcbGJyYWNlXCIsXG4gIFwiXFxcXH1cIixcbiAgXCJcXFxccmJyYWNlXCIsXG4gIFwi4qaHXCIsXG4gIFwiXFxcXGxscGFyZW50aGVzaXNcIixcbiAgXCLipohcIixcbiAgXCJcXFxccnJwYXJlbnRoZXNpc1wiLFxuICBcIlxcXFxsZmxvb3JcIixcbiAgXCJcXFxccmZsb29yXCIsXG4gIFwiXFx1MjMwYVwiLFxuICBcIlxcdTIzMGJcIixcbiAgXCJcXFxcbGNlaWxcIixcbiAgXCJcXFxccmNlaWxcIixcbiAgXCJcXHUyMzA4XCIsXG4gIFwiXFx1MjMwOVwiLFxuICBcIjxcIixcbiAgXCI+XCIsXG4gIFwiXFxcXGxhbmdsZVwiLFxuICBcIlxcdTI3ZThcIixcbiAgXCJcXFxccmFuZ2xlXCIsXG4gIFwiXFx1MjdlOVwiLFxuICBcIlxcXFxsQW5nbGVcIixcbiAgXCJcXHUyN2VhXCIsXG4gIFwiXFxcXHJBbmdsZVwiLFxuICBcIlxcdTI3ZWJcIixcbiAgXCJcXFxcbGxhbmdsZVwiLFxuICBcIuKmiVwiLFxuICBcIlxcXFxycmFuZ2xlXCIsXG4gIFwi4qaKXCIsXG4gIFwiXFxcXGx0XCIsXG4gIFwiXFxcXGd0XCIsXG4gIFwiXFxcXGx2ZXJ0XCIsXG4gIFwiXFxcXHJ2ZXJ0XCIsXG4gIFwiXFxcXGxWZXJ0XCIsXG4gIFwiXFxcXHJWZXJ0XCIsXG4gIFwiXFxcXGxncm91cFwiLFxuICBcIlxcXFxyZ3JvdXBcIixcbiAgXCJcXHUyN2VlXCIsXG4gIFwiXFx1MjdlZlwiLFxuICBcIlxcXFxsbW91c3RhY2hlXCIsXG4gIFwiXFxcXHJtb3VzdGFjaGVcIixcbiAgXCJcXHUyM2IwXCIsXG4gIFwiXFx1MjNiMVwiLFxuICBcIlxcXFxsbGJyYWNrZXRcIixcbiAgXCJcXFxccnJicmFja2V0XCIsXG4gIFwiXFx1MjdlNlwiLFxuICBcIlxcdTI3ZTZcIixcbiAgXCJcXFxcbEJyYWNlXCIsXG4gIFwiXFxcXHJCcmFjZVwiLFxuICBcIlxcdTI5ODNcIixcbiAgXCJcXHUyOTg0XCIsXG4gIFwiL1wiLFxuICBcIlxcXFxiYWNrc2xhc2hcIixcbiAgXCJ8XCIsXG4gIFwiXFxcXHZlcnRcIixcbiAgXCJcXFxcfFwiLFxuICBcIlxcXFxWZXJ0XCIsXG4gIFwiXFx1MjAxNlwiLFxuICBcIlxcXFx1cGFycm93XCIsXG4gIFwiXFxcXFVwYXJyb3dcIixcbiAgXCJcXFxcZG93bmFycm93XCIsXG4gIFwiXFxcXERvd25hcnJvd1wiLFxuICBcIlxcXFx1cGRvd25hcnJvd1wiLFxuICBcIlxcXFxVcGRvd25hcnJvd1wiLFxuICBcIi5cIlxuXTtcblxuLy8gRXhwb3J0IGlzRGVsaW1pdGVyIGZvciBiZW5lZml0IG9mIHBhcnNlci5cbmNvbnN0IGRlbHMgPSBbXCJ9XCIsIFwiXFxcXGxlZnRcIiwgXCJcXFxcbWlkZGxlXCIsIFwiXFxcXHJpZ2h0XCJdO1xuY29uc3QgaXNEZWxpbWl0ZXIgPSBzdHIgPT4gc3RyLmxlbmd0aCA+IDAgJiZcbiAgKGRlbGltaXRlcnMuaW5jbHVkZXMoc3RyKSB8fCBkZWxpbWl0ZXJTaXplc1tzdHJdIHx8IGRlbHMuaW5jbHVkZXMoc3RyKSk7XG5cbi8vIE1ldHJpY3Mgb2YgdGhlIGRpZmZlcmVudCBzaXplcy4gRm91bmQgYnkgbG9va2luZyBhdCBUZVgncyBvdXRwdXQgb2Zcbi8vICRcXGJpZ2x8IC8vIFxcQmlnbHwgXFxiaWdnbHwgXFxCaWdnbHwgXFxzaG93bGlzdHMkXG4vLyBVc2VkIHRvIGNyZWF0ZSBzdGFja2VkIGRlbGltaXRlcnMgb2YgYXBwcm9wcmlhdGUgc2l6ZXMgaW4gbWFrZVNpemVkRGVsaW0uXG5jb25zdCBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcblxuLy8gRGVsaW1pdGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gY2hlY2tEZWxpbWl0ZXIoZGVsaW0sIGNvbnRleHQpIHtcbiAgY29uc3Qgc3ltRGVsaW0gPSBjaGVja1N5bWJvbE5vZGVUeXBlKGRlbGltKTtcbiAgaWYgKHN5bURlbGltICYmIGRlbGltaXRlcnMuaW5jbHVkZXMoc3ltRGVsaW0udGV4dCkpIHtcbiAgICAvLyBJZiBhIGNoYXJhY3RlciBpcyBub3QgaW4gdGhlIE1hdGhNTCBvcGVyYXRvciBkaWN0aW9uYXJ5LCBpdCB3aWxsIG5vdCBzdHJldGNoLlxuICAgIC8vIFJlcGxhY2Ugc3VjaCBjaGFyYWN0ZXJzIHcvY2hhcmFjdGVycyB0aGF0IHdpbGwgc3RyZXRjaC5cbiAgICBpZiAoW1wiPFwiLCBcIlxcXFxsdFwiXS5pbmNsdWRlcyhzeW1EZWxpbS50ZXh0KSkgeyBzeW1EZWxpbS50ZXh0ID0gXCLin6hcIjsgfVxuICAgIGlmIChbXCI+XCIsIFwiXFxcXGd0XCJdLmluY2x1ZGVzKHN5bURlbGltLnRleHQpKSB7IHN5bURlbGltLnRleHQgPSBcIuKfqVwiOyB9XG4gICAgcmV0dXJuIHN5bURlbGltO1xuICB9IGVsc2UgaWYgKHN5bURlbGltKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgZGVsaW1pdGVyICcke3N5bURlbGltLnRleHR9JyBhZnRlciAnJHtjb250ZXh0LmZ1bmNOYW1lfSdgLCBkZWxpbSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgZGVsaW1pdGVyIHR5cGUgJyR7ZGVsaW0udHlwZX0nYCwgZGVsaW0pO1xuICB9XG59XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICBcXFxuY29uc3QgbmVlZEV4cGxpY2l0U3RyZXRjaCA9IFtcIlxcdTAwMkZcIiwgXCJcXHUwMDVDXCIsIFwiXFxcXGJhY2tzbGFzaFwiLCBcIlxcXFx2ZXJ0XCIsIFwifFwiXTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcYmlnbFwiLFxuICAgIFwiXFxcXEJpZ2xcIixcbiAgICBcIlxcXFxiaWdnbFwiLFxuICAgIFwiXFxcXEJpZ2dsXCIsXG4gICAgXCJcXFxcYmlnclwiLFxuICAgIFwiXFxcXEJpZ3JcIixcbiAgICBcIlxcXFxiaWdnclwiLFxuICAgIFwiXFxcXEJpZ2dyXCIsXG4gICAgXCJcXFxcYmlnbVwiLFxuICAgIFwiXFxcXEJpZ21cIixcbiAgICBcIlxcXFxiaWdnbVwiLFxuICAgIFwiXFxcXEJpZ2dtXCIsXG4gICAgXCJcXFxcYmlnXCIsXG4gICAgXCJcXFxcQmlnXCIsXG4gICAgXCJcXFxcYmlnZ1wiLFxuICAgIFwiXFxcXEJpZ2dcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkZWxpbXNpemluZ1wiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICBtY2xhc3M6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLm1jbGFzcyxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwKSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC5kZWxpbSA9PT0gXCIuXCIpIHsgZ3JvdXAuZGVsaW0gPSBcIlwiOyB9XG4gICAgY2hpbGRyZW4ucHVzaChtYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSkpO1xuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgY2hpbGRyZW4pO1xuXG4gICAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgLy8gT25seSBzb21lIG9mIHRoZSBkZWxpbXNpemluZyBmdW5jdGlvbnMgYWN0IGFzIGZlbmNlcywgYW5kIHRoZXlcbiAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXhwbGljaXRseSBkaXNhYmxlIGZlbmNpbmcgaWYgaXQncyBub3QgYSBmZW5jZSwgdG8gb3ZlcnJpZGUgdGhlXG4gICAgICAvLyBkZWZhdWx0cy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG4gICAgaWYgKG5lZWRFeHBsaWNpdFN0cmV0Y2guaW5jbHVkZXMoZ3JvdXAuZGVsaW0pIHx8IGdyb3VwLmRlbGltLmluZGV4T2YoXCJhcnJvd1wiKSA+IC0xKSB7XG4gICAgICAvLyBXZSBoYXZlIHRvIGV4cGxpY2l0bHkgc2V0IHN0cmV0Y2h5IHRvIHRydWUuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzeW1tZXRyaWNcIiwgXCJ0cnVlXCIpOyAvLyBOZWVkZWQgZm9yIHRhbGwgYXJyb3dzIGluIEZpcmVmb3guXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtaW5zaXplXCIsIHNpemVUb01heEhlaWdodFtncm91cC5zaXplXSArIFwiZW1cIik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXhzaXplXCIsIHNpemVUb01heEhlaWdodFtncm91cC5zaXplXSArIFwiZW1cIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXJzZWQoZ3JvdXApIHtcbiAgaWYgKCFncm91cC5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnOiBUaGUgbGVmdHJpZ2h0IFBhcnNlTm9kZSB3YXNuJ3QgZnVsbHkgcGFyc2VkLlwiKTtcbiAgfVxufVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gIG5hbWVzOiBbXCJcXFxccmlnaHRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpLnRleHRcbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICBuYW1lczogW1wiXFxcXGxlZnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHBhcnNlciA9IGNvbnRleHQucGFyc2VyO1xuICAgIC8vIFBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keVxuICAgICsrcGFyc2VyLmxlZnRyaWdodERlcHRoO1xuICAgIC8vIHBhcnNlRXhwcmVzc2lvbiBzdG9wcyBiZWZvcmUgJ1xcXFxyaWdodCcgb3IgYFxcXFxtaWRkbGVgXG4gICAgbGV0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBudWxsLCB0cnVlKTtcbiAgICBsZXQgbmV4dFRva2VuID0gcGFyc2VyLmZldGNoKCk7XG4gICAgd2hpbGUgKG5leHRUb2tlbi50ZXh0ID09PSBcIlxcXFxtaWRkbGVcIikge1xuICAgICAgLy8gYFxcbWlkZGxlYCwgZnJvbSB0aGUgzrUtVGVYIHBhY2thZ2UsIGVuZHMgb25lIGdyb3VwIGFuZCBzdGFydHMgYW5vdGhlciBncm91cC5cbiAgICAgIC8vIFdlIGhhZCB0byBwYXJzZSB0aGlzIGV4cHJlc3Npb24gd2l0aCBgYnJlYWtPbk1pZGRsZWAgZW5hYmxlZCBpbiBvcmRlclxuICAgICAgLy8gdG8gZ2V0IFRlWC1jb21wbGlhbnQgcGFyc2luZyBvZiBcXG92ZXIuXG4gICAgICAvLyBCdXQgd2UgZG8gbm90IHdhbnQsIGF0IHRoaXMgcG9pbnQsIHRvIGVuZCBvbiBcXG1pZGRsZSwgc28gY29udGludWVcbiAgICAgIC8vIHRvIHBhcnNlIHVudGlsIHdlIGZldGNoIGEgYFxccmlnaHRgLlxuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gICAgICBpZiAoIXN5bWJvbHMubWF0aFttaWRkbGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIGRlbGltaXRlciAnJHttaWRkbGV9JyBhZnRlciAnXFxcXG1pZGRsZSdgKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrRGVsaW1pdGVyKHsgdHlwZTogXCJhdG9tXCIsIG1vZGU6IFwibWF0aFwiLCB0ZXh0OiBtaWRkbGUgfSwgeyBmdW5jTmFtZTogXCJcXFxcbWlkZGxlXCIgfSk7XG4gICAgICBib2R5LnB1c2goeyB0eXBlOiBcIm1pZGRsZVwiLCBtb2RlOiBcIm1hdGhcIiwgZGVsaW06IG1pZGRsZSB9KTtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICBib2R5ID0gYm9keS5jb25jYXQocGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgbmV4dFRva2VuID0gcGFyc2VyLmZldGNoKCk7XG4gICAgfVxuICAgIC0tcGFyc2VyLmxlZnRyaWdodERlcHRoO1xuICAgIC8vIENoZWNrIHRoZSBuZXh0IHRva2VuXG4gICAgcGFyc2VyLmV4cGVjdChcIlxcXFxyaWdodFwiLCBmYWxzZSk7XG4gICAgY29uc3QgcmlnaHQgPSBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImxlZnRyaWdodC1yaWdodFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIGxlZnQ6IGRlbGltLnRleHQsXG4gICAgICByaWdodDogcmlnaHQuZGVsaW1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgYXNzZXJ0UGFyc2VkKGdyb3VwKTtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSk7XG5cbiAgICBpZiAoZ3JvdXAubGVmdCA9PT0gXCIuXCIpIHsgZ3JvdXAubGVmdCA9IFwiXCI7IH1cbiAgICBjb25zdCBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLmxlZnQsIGdyb3VwLm1vZGUpXSk7XG4gICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIGxlZnROb2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwcmVmaXhcIik7XG4gICAgaWYgKGdyb3VwLmxlZnQgPT09IFwiL1wiIHx8IGdyb3VwLmxlZnQgPT09IFwiXFx1MDA1Q1wiIHx8IGdyb3VwLmxlZnQuaW5kZXhPZihcImFycm93XCIpID4gLTEpIHtcbiAgICAgIGxlZnROb2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG5cbiAgICBpZiAoZ3JvdXAucmlnaHQgPT09IFwiLlwiKSB7IGdyb3VwLnJpZ2h0ID0gXCJcIjsgfVxuICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnJpZ2h0LCBncm91cC5tb2RlKV0pO1xuICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwb3N0Zml4XCIpO1xuICAgIGlmIChncm91cC5yaWdodCA9PT0gXCJcXHUyMjE2XCIgfHwgZ3JvdXAucmlnaHQuaW5kZXhPZihcImFycm93XCIpID4gLTEpIHtcbiAgICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxhc3RFbGVtZW50ID0gZ3JvdXAuYm9keVtncm91cC5ib2R5Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RFbGVtZW50LnR5cGUgPT09IFwiY29sb3JcIiAmJiAhbGFzdEVsZW1lbnQuaXNUZXh0Q29sb3IpIHtcbiAgICAgICAgLy8gXFxjb2xvciBpcyBhIHN3aXRjaC4gSWYgdGhlIGxhc3QgZWxlbWVudCBpcyBvZiB0eXBlIFwiY29sb3JcIiB0aGVuXG4gICAgICAgIC8vIHRoZSB1c2VyIHNldCB0aGUgXFxjb2xvciBzd2l0Y2ggYW5kIGxlZnQgaXQgb24uXG4gICAgICAgIC8vIEEgXFxyaWdodCBkZWxpbWl0ZXIgdHVybnMgdGhlIHN3aXRjaCBvZmYsIGJ1dCB0aGUgZGVsaW1pdGVyIGl0c2VsZiBnZXRzIHRoZSBjb2xvci5cbiAgICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBsYXN0RWxlbWVudC5jb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcblxuICAgIHJldHVybiBtYWtlUm93KGlubmVyKTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtaWRkbGVcIixcbiAgbmFtZXM6IFtcIlxcXFxtaWRkbGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQucGFyc2VyLmxlZnRyaWdodERlcHRoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxtaWRkbGUgd2l0aG91dCBwcmVjZWRpbmcgXFxcXGxlZnRcIiwgZGVsaW0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IHRleHROb2RlID0gbWFrZVRleHQoZ3JvdXAuZGVsaW0sIGdyb3VwLm1vZGUpO1xuICAgIGNvbnN0IG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFt0ZXh0Tm9kZV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIGlmIChncm91cC5kZWxpbS5pbmRleE9mKFwiYXJyb3dcIikgPiAtMSkge1xuICAgICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIC8vIFRoZSBuZXh0IGxpbmUgaXMgbm90IHNlbWFudGljYWxseSBjb3JyZWN0LCBidXRcbiAgICAvLyBDaHJvbWl1bSBmYWlscyB0byBzdHJldGNoIGlmIGl0IGlzIG5vdCB0aGVyZS5cbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwcmVmaXhcIik7XG4gICAgLy8gTWF0aE1MIGdpdmVzIDUvMThlbSBzcGFjaW5nIHRvIGVhY2ggPG1vPiBlbGVtZW50LlxuICAgIC8vIFxcbWlkZGxlIHNob3VsZCBnZXQgZGVsaW1pdGVyIHNwYWNpbmcgaW5zdGVhZC5cbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICByZXR1cm4gbWlkZGxlTm9kZTtcbiAgfVxufSk7XG5cbmNvbnN0IHBhZGRpbmcgPSBfID0+IHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiM3B0XCIpO1xuICByZXR1cm4gbm9kZVxufTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ3ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBsZXQgbm9kZTtcbiAgaWYgKGdyb3VwLmxhYmVsLmluZGV4T2YoXCJjb2xvcmJveFwiKSA+IC0xIHx8IGdyb3VwLmxhYmVsID09PSBcIlxcXFxib3hlZFwiKSB7XG4gICAgLy8gTWF0aE1MIGNvcmUgZG9lcyBub3Qgc3VwcG9ydCArd2lkdGggYXR0cmlidXRlIGluIDxtcGFkZGVkPi5cbiAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlbGlhYmx5IGFkZCBzaWRlIHBhZGRpbmcuXG4gICAgLy8gSW5zZXJ0IDxtc3BhY2U+XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXG4gICAgICBwYWRkaW5nKCksXG4gICAgICBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpLFxuICAgICAgcGFkZGluZygpXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWVuY2xvc2VcIiwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSldKTtcbiAgfVxuICBzd2l0Y2ggKGdyb3VwLmxhYmVsKSB7XG4gICAgY2FzZSBcIlxcXFxvdmVybGluZVwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInRvcFwiKTsgLy8gZm9yIEZpcmVmb3ggJiBXZWJLaXRcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLW92ZXJsaW5lXCIpOyAgICAvLyBmb3IgQ2hyb21pdW1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFx1bmRlcmxpbmVcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJib3R0b21cIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC11bmRlcmxpbmVcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInRtbC1jYW5jZWxcIiwgXCJ1cHN0cmlrZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGJjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJ0bWwtY2FuY2VsXCIsIFwiZG93bnN0cmlrZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXHNvdXRcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJob3Jpem9udGFsc3RyaWtlXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1widG1sLWNhbmNlbFwiLCBcInNvdXRcIl0pKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFx4Y2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZSBkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC14Y2FuY2VsXCIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGxvbmdkaXZcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJsb25nZGl2XCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJsb25nZGl2LXRvcFwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcImxvbmdkaXYtYXJjXCJdKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxccGhhc2VcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJwaGFzb3JhbmdsZVwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwicGhhc29yLWJvdHRvbVwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInBoYXNvci1hbmdsZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXHRleHRjaXJjbGVkXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiY2lyY2xlXCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJjaXJjbGUtcGFkXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1widGV4dGNpcmNsZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGFuZ2xcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJhY3R1YXJpYWxcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcImFjdHVhcmlhbFwiKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxib3hlZFwiOlxuICAgICAgLy8gXFxuZXdjb21tYW5ke1xcYm94ZWR9WzFde1xcZmJveHtcXG1AdGgkXFxkaXNwbGF5c3R5bGUjMSR9fSBmcm9tIGFtc21hdGguc3R5XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYm94XCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJ0bWwtYm94XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjBcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcInRydWVcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcZmJveFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImJveFwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLWZib3hcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcZmNvbG9yYm94XCI6XG4gICAgY2FzZSBcIlxcXFxjb2xvcmJveFwiOiB7XG4gICAgICAvLyA8bWVuY2xvc2U+IGRvZXNuJ3QgaGF2ZSBhIGdvb2Qgbm90YXRpb24gb3B0aW9uIGZvciBcXGNvbG9yYm94LlxuICAgICAgLy8gU28gdXNlIDxtcGFkZGVkPiBpbnN0ZWFkLiBTZXQgc29tZSBhdHRyaWJ1dGVzIHRoYXQgY29tZVxuICAgICAgLy8gaW5jbHVkZWQgd2l0aCA8bWVuY2xvc2U+LlxuICAgICAgLy9jb25zdCBmYm94c2VwID0gMzsgLy8gMyBwdCBmcm9tIExhVGVYIHNvdXJjZTJlXG4gICAgICAvL25vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGArJHsyICogZmJveHNlcH1wdGApXG4gICAgICAvL25vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBgJHtmYm94c2VwfXB0YClcbiAgICAgIGNvbnN0IHN0eWxlID0geyBwYWRkaW5nOiBcIjNwdCAwIDNwdCAwXCIgfTtcblxuICAgICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFxmY29sb3Jib3hcIikge1xuICAgICAgICBzdHlsZS5ib3JkZXIgPSBcIjAuMDY2N2VtIHNvbGlkIFwiICsgU3RyaW5nKGdyb3VwLmJvcmRlckNvbG9yKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUgPSBzdHlsZTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhiYWNrZ3JvdW5kXCIsIGdyb3VwLmJhY2tncm91bmRDb2xvcik7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInJhd1wiLCBcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0QXJnc1swXSAmJiBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgbGV0IGNvbG9yID0gXCJcIjtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IHNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBjb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIHNwZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZjb2xvcmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJyYXdcIiwgXCJyYXdcIiwgXCJ0ZXh0XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBtb2RlbCA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGxldCBib3JkZXJDb2xvciA9IFwiXCI7XG4gICAgbGV0IGJhY2tncm91bmRDb2xvcjtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IGJvcmRlclNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kU3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICAgIGJvcmRlckNvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgYm9yZGVyU3BlYyk7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBiYWNrZ3JvdW5kU3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcmRlckNvbG9yID0gdmFsaWRhdGVDb2xvcihhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmcsIHBhcnNlci5ndWxsZXQubWFjcm9zKTtcbiAgICAgIGJhY2tncm91bmRDb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxmYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcImhib3hcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBcIlxcXFxmYm94XCIsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcYW5nbFwiLCBcIlxcXFxjYW5jZWxcIiwgXCJcXFxcYmNhbmNlbFwiLCBcIlxcXFx4Y2FuY2VsXCIsIFwiXFxcXHNvdXRcIiwgXCJcXFxcb3ZlcmxpbmVcIixcbiAgICBcIlxcXFxib3hlZFwiLCBcIlxcXFxsb25nZGl2XCIsIFwiXFxcXHBoYXNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkN1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXHRleHRjaXJjbGVkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl0sXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuLy8gRW52aXJvbm1lbnQgZGVsaW1pdGVycy4gSFRNTC9NYXRoTUwgcmVuZGVyaW5nIGlzIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmdcbi8vIGRlZmluZUVudmlyb25tZW50IGRlZmluaXRpb25zLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYmVnaW5cIiwgXCJcXFxcZW5kXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IG5hbWVHcm91cCA9IGFyZ3NbMF07XG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBlbnZpcm9ubWVudCBuYW1lXCIsIG5hbWVHcm91cCk7XG4gICAgfVxuICAgIGxldCBlbnZOYW1lID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVHcm91cC5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBlbnZOYW1lICs9IGFzc2VydE5vZGVUeXBlKG5hbWVHcm91cC5ib2R5W2ldLCBcInRleHRvcmRcIikudGV4dDtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGJlZ2luXCIpIHtcbiAgICAgIC8vIGJlZ2luLi4uZW5kIGlzIHNpbWlsYXIgdG8gbGVmdC4uLnJpZ2h0XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbnZpcm9ubWVudHMsIGVudk5hbWUgKSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgbmFtZUdyb3VwKTtcbiAgICAgIH1cbiAgICAgIC8vIEJ1aWxkIHRoZSBlbnZpcm9ubWVudCBvYmplY3QuIEFyZ3VtZW50cyBhbmQgb3RoZXIgaW5mb3JtYXRpb24gd2lsbFxuICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuICAgICAgY29uc3QgZW52ID0gZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuICAgICAgY29uc3QgeyBhcmdzLCBvcHRBcmdzIH0gPSBwYXJzZXIucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgZW52TmFtZSxcbiAgICAgICAgcGFyc2VyXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgICBwYXJzZXIuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmROYW1lVG9rZW4gPSBwYXJzZXIubmV4dFRva2VuO1xuICAgICAgY29uc3QgZW5kID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJlbnZpcm9ubWVudFwiKTtcbiAgICAgIGlmIChlbmQubmFtZSAhPT0gZW52TmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICBgTWlzbWF0Y2g6IFxcXFxiZWdpbnske2Vudk5hbWV9fSBtYXRjaGVkIGJ5IFxcXFxlbmR7JHtlbmQubmFtZX19YCxcbiAgICAgICAgICBlbmROYW1lVG9rZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW52aXJvbm1lbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmFtZTogZW52TmFtZSxcbiAgICAgIG5hbWVHcm91cFxuICAgIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW52VGFnXCIsXG4gIG5hbWVzOiBbXCJcXFxcZW52QHRhZ1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVudlRhZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm5vVGFnXCIsXG4gIG5hbWVzOiBbXCJcXFxcZW52QG5vdGFnXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibm9UYWdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG59KTtcblxuY29uc3QgaXNMb25nVmFyaWFibGVOYW1lID0gKGdyb3VwLCBmb250KSA9PiB7XG4gIGlmIChmb250ICE9PSBcIm1hdGhybVwiIHx8IGdyb3VwLmJvZHkudHlwZSAhPT0gXCJvcmRncm91cFwiIHx8IGdyb3VwLmJvZHkuYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoZ3JvdXAuYm9keS5ib2R5WzBdLnR5cGUgIT09IFwibWF0aG9yZFwiKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgZ3JvdXAuYm9keS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFyc2VOb2RlVHlwZSA9IGdyb3VwLmJvZHkuYm9keVtpXS50eXBlO1xuICAgIGlmICghKHBhcnNlTm9kZVR5cGUgPT09ICBcIm1hdGhvcmRcIiB8fFxuICAgIChwYXJzZU5vZGVUeXBlID09PSAgXCJ0ZXh0b3JkXCIgJiYgIWlzTmFOKGdyb3VwLmJvZHkuYm9keVtpXS50ZXh0KSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkNiA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgY29uc3QgZm9udCA9IGdyb3VwLmZvbnQ7XG4gIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aEZvbnQoZm9udCk7XG4gIGNvbnN0IG1hdGhHcm91cCA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBuZXdTdHlsZSk7XG5cbiAgaWYgKG1hdGhHcm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHsgcmV0dXJuIG1hdGhHcm91cCB9IC8vIGVtcHR5IGdyb3VwLCBlLmcuLCBcXG1hdGhybXt9XG4gIGlmIChmb250ID09PSBcImJvbGRzeW1ib2xcIiAmJiBbXCJtb1wiLCBcIm1wYWRkZWRcIiwgXCJtcm93XCJdLmluY2x1ZGVzKG1hdGhHcm91cC50eXBlKSkge1xuICAgIG1hdGhHcm91cC5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgcmV0dXJuIG1hdGhHcm91cFxuICB9XG4gIC8vIENoZWNrIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGNvbnNvbGlkYXRlIGVsZW1lbnRzIGludG8gYSBzaW5nbGUgPG1pPiBlbGVtZW50LlxuICBpZiAoaXNMb25nVmFyaWFibGVOYW1lKGdyb3VwLCBmb250KSkge1xuICAgIC8vIFRoaXMgaXMgYSBcXG1hdGhybXvigKZ9IGdyb3VwLiBJdCBnZXRzIHNwZWNpYWwgdHJlYXRtZW50IGJlY2F1c2Ugc3ltYm9sc09yZC5qc1xuICAgIC8vIHdyYXBzIDxtaT4gZWxlbWVudHMgd2l0aCA8bXJvdz5zIHRvIHdvcmsgYXJvdW5kIGEgRmlyZWZveCBidWcuXG4gICAgY29uc3QgbWkgPSBtYXRoR3JvdXAuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF07XG4gICAgZGVsZXRlIG1pLmF0dHJpYnV0ZXMubWF0aHZhcmlhbnQ7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRoR3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1pLmNoaWxkcmVuWzBdLnRleHQgKz0gbWF0aEdyb3VwLmNoaWxkcmVuW2ldLnR5cGUgPT09IFwibW5cIlxuICAgICAgICA/IG1hdGhHcm91cC5jaGlsZHJlbltpXS5jaGlsZHJlblswXS50ZXh0XG4gICAgICAgIDogbWF0aEdyb3VwLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnRleHQ7XG4gICAgfVxuICAgIC8vIFdyYXAgaW4gYSA8bXJvdz4gdG8gcHJldmVudCB0aGUgc2FtZSBGaXJlZm94IGJ1Zy5cbiAgICBjb25zdCBib2d1cyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDBiXCIpKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtib2d1cywgbWldKVxuICB9XG4gIGxldCBjYW5Db25zb2xpZGF0ZSA9IG1hdGhHcm91cC5jaGlsZHJlblswXS50eXBlID09PSBcIm1vXCI7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0aEdyb3VwLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1hdGhHcm91cC5jaGlsZHJlbltpXS50eXBlID09PSBcIm1vXCIgJiYgZm9udCA9PT0gXCJib2xkc3ltYm9sXCIpIHtcbiAgICAgIG1hdGhHcm91cC5jaGlsZHJlbltpXS5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGlmIChtYXRoR3JvdXAuY2hpbGRyZW5baV0udHlwZSAhPT0gXCJtaVwiKSB7IGNhbkNvbnNvbGlkYXRlID0gZmFsc2U7IH1cbiAgICBjb25zdCBsb2NhbFZhcmlhbnQgPSBtYXRoR3JvdXAuY2hpbGRyZW5baV0uYXR0cmlidXRlcyAmJlxuICAgICAgbWF0aEdyb3VwLmNoaWxkcmVuW2ldLmF0dHJpYnV0ZXMubWF0aHZhcmlhbnQgfHwgXCJcIjtcbiAgICBpZiAobG9jYWxWYXJpYW50ICE9PSBcIm5vcm1hbFwiKSB7IGNhbkNvbnNvbGlkYXRlID0gZmFsc2U7IH1cbiAgfVxuICBpZiAoIWNhbkNvbnNvbGlkYXRlKSB7IHJldHVybiBtYXRoR3JvdXAgfVxuICAvLyBDb25zb2xpZGF0ZSB0aGUgPG1pPiBlbGVtZW50cy5cbiAgY29uc3QgbWkgPSBtYXRoR3JvdXAuY2hpbGRyZW5bMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0aEdyb3VwLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbWkuY2hpbGRyZW4ucHVzaChtYXRoR3JvdXAuY2hpbGRyZW5baV0uY2hpbGRyZW5bMF0pO1xuICB9XG4gIGlmIChtaS5hdHRyaWJ1dGVzLm1hdGh2YXJpYW50ICYmIG1pLmF0dHJpYnV0ZXMubWF0aHZhcmlhbnQgPT09IFwibm9ybWFsXCIpIHtcbiAgICAvLyBXb3JrYXJvdW5kIGZvciBhIEZpcmVmb3ggYnVnIHRoYXQgcmVuZGVycyBzcHVyaW91cyBzcGFjZSBhcm91bmRcbiAgICAvLyBhIDxtaSBtYXRodmFyaWFudD1cIm5vcm1hbFwiPlxuICAgIC8vIFJlZjogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTA5N1xuICAgIC8vIFdlIGluc2VydCBhIHRleHQgbm9kZSB0aGF0IGNvbnRhaW5zIGEgemVyby13aWR0aCBzcGFjZSBhbmQgd3JhcCBpbiBhbiBtcm93LlxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgdGhpcyA8bWk+IHdvcmthcm91bmQgd2hlbiB0aGUgRmlyZWZveCBidWcgaXMgZml4ZWQuXG4gICAgY29uc3QgYm9ndXMgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAwYlwiKSk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbYm9ndXMsIG1pXSlcbiAgfVxuICByZXR1cm4gbWlcbn07XG5cbmNvbnN0IGZvbnRBbGlhc2VzID0ge1xuICBcIlxcXFxCYmJcIjogXCJcXFxcbWF0aGJiXCIsXG4gIFwiXFxcXGJvbGRcIjogXCJcXFxcbWF0aGJmXCIsXG4gIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIixcbiAgXCJcXFxcYm1cIjogXCJcXFxcYm9sZHN5bWJvbFwiXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZm9udFwiLFxuICBuYW1lczogW1xuICAgIC8vIHN0eWxlc1xuICAgIFwiXFxcXG1hdGhybVwiLFxuICAgIFwiXFxcXG1hdGhpdFwiLFxuICAgIFwiXFxcXG1hdGhiZlwiLFxuICAgIFwiXFxcXG1hdGhub3JtYWxcIixcbiAgICBcIlxcXFx1cEBncmVla1wiLFxuICAgIFwiXFxcXGJvbGRzeW1ib2xcIixcblxuICAgIC8vIGZhbWlsaWVzXG4gICAgXCJcXFxcbWF0aGJiXCIsXG4gICAgXCJcXFxcbWF0aGNhbFwiLFxuICAgIFwiXFxcXG1hdGhmcmFrXCIsXG4gICAgXCJcXFxcbWF0aHNjclwiLFxuICAgIFwiXFxcXG1hdGhzZlwiLFxuICAgIFwiXFxcXG1hdGhzZml0XCIsXG4gICAgXCJcXFxcbWF0aHR0XCIsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgXCJcXFxcQmJiXCIsXG4gICAgXCJcXFxcYm1cIixcbiAgICBcIlxcXFxib2xkXCIsXG4gICAgXCJcXFxcZnJha1wiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgbGV0IGZ1bmMgPSBmdW5jTmFtZTtcbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgZnVuYyA9IGZvbnRBbGlhc2VzW2Z1bmNdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZvbnQ6IGZ1bmMuc2xpY2UoMSksXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTtcblxuLy8gT2xkIGZvbnQgY2hhbmdpbmcgZnVuY3Rpb25zXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZm9udFwiLFxuICBuYW1lczogW1wiXFxcXHJtXCIsIFwiXFxcXHNmXCIsIFwiXFxcXHR0XCIsIFwiXFxcXGJmXCIsIFwiXFxcXGl0XCIsIFwiXFxcXGNhbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSwgYnJlYWtPblRva2VuVGV4dCB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgeyBtb2RlIH0gPSBwYXJzZXI7XG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCwgdHJ1ZSk7XG4gICAgY29uc3QgZm9udFN0eWxlID0gYG1hdGgke2Z1bmNOYW1lLnNsaWNlKDEpfWA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgZm9udDogZm9udFN0eWxlLFxuICAgICAgYm9keToge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBib2R5XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTtcblxuY29uc3Qgc3R5bEFycmF5ID0gW1wiZGlzcGxheVwiLCBcInRleHRcIiwgXCJzY3JpcHRcIiwgXCJzY3JpcHRzY3JpcHRcIl07XG5jb25zdCBzY3JpcHRMZXZlbCA9IHsgYXV0bzogLTEsIGRpc3BsYXk6IDAsIHRleHQ6IDAsIHNjcmlwdDogMSwgc2NyaXB0c2NyaXB0OiAyIH07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkNSA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgLy8gVHJhY2sgdGhlIHNjcmlwdExldmVsIG9mIHRoZSBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yLlxuICAvLyBXZSBtYXkgbmVlZCB0aGF0IGluZm8gZm9yIFxcbWF0aGNob2ljZSBvciBmb3IgYWRqdXN0aW5nIGVtIGRpbWVuc2lvbnMuXG4gIGNvbnN0IGNoaWxkT3B0aW9ucyA9IGdyb3VwLnNjcmlwdExldmVsID09PSBcImF1dG9cIlxuICAgID8gc3R5bGUuaW5jcmVtZW50TGV2ZWwoKVxuICAgIDogZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwiZGlzcGxheVwiXG4gICAgPyBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5URVhUKVxuICAgIDogZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwidGV4dFwiXG4gICAgPyBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5TQ1JJUFQpXG4gICAgOiBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5TQ1JJUFRTQ1JJUFQpO1xuXG4gIC8vIENocm9taXVtICh3cm9uZ2x5KSBjb250aW51ZXMgdG8gc2hyaW5rIGZyYWN0aW9ucyBiZXlvbmQgc2NyaXB0c2NyaXB0bGV2ZWwuXG4gIC8vIFNvIHdlIGNoZWNrIGZvciBsZXZlbHMgdGhhdCBDaHJvbWl1bSBzaHJpbmtzIHRvbyBzbWFsbC5cbiAgLy8gSWYgbmVjZXNzYXJ5LCBzZXQgYW4gZXhwbGljaXQgZnJhY3Rpb24gZGVwdGguXG4gIGNvbnN0IG51bWVyID0gYnVpbGRHcm91cCQxKGdyb3VwLm51bWVyLCBjaGlsZE9wdGlvbnMpO1xuICBjb25zdCBkZW5vbSA9IGJ1aWxkR3JvdXAkMShncm91cC5kZW5vbSwgY2hpbGRPcHRpb25zKTtcbiAgaWYgKHN0eWxlLmxldmVsID09PSAzKSB7XG4gICAgbnVtZXIuc3R5bGUubWF0aERlcHRoID0gXCIyXCI7XG4gICAgbnVtZXIuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIyXCIpO1xuICAgIGRlbm9tLnN0eWxlLm1hdGhEZXB0aCA9IFwiMlwiO1xuICAgIGRlbm9tLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMlwiKTtcbiAgfVxuXG4gIGxldCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZnJhY1wiLCBbbnVtZXIsIGRlbm9tXSk7XG5cbiAgaWYgKCFncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICBjb25zdCBydWxlV2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLmJhclNpemUsIHN0eWxlKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmV0aGlja25lc3NcIiwgcnVsZVdpZHRoLm51bWJlciArIHJ1bGVXaWR0aC51bml0KTtcbiAgfVxuXG4gIGlmIChncm91cC5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICBjb25zdCB3aXRoRGVsaW1zID0gW107XG5cbiAgICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGxlZnRPcCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW1xuICAgICAgICBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5sZWZ0RGVsaW0ucmVwbGFjZShcIlxcXFxcIiwgXCJcIikpXG4gICAgICBdKTtcbiAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gobGVmdE9wKTtcbiAgICB9XG5cbiAgICB3aXRoRGVsaW1zLnB1c2gobm9kZSk7XG5cbiAgICBpZiAoZ3JvdXAucmlnaHREZWxpbSAhPSBudWxsKSB7XG4gICAgICBjb25zdCByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbXG4gICAgICAgIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKGdyb3VwLnJpZ2h0RGVsaW0ucmVwbGFjZShcIlxcXFxcIiwgXCJcIikpXG4gICAgICBdKTtcbiAgICAgIHJpZ2h0T3Auc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgd2l0aERlbGltcy5wdXNoKHJpZ2h0T3ApO1xuICAgIH1cblxuICAgIG5vZGUgPSBtYWtlUm93KHdpdGhEZWxpbXMpO1xuICB9XG5cbiAgaWYgKGdyb3VwLnNjcmlwdExldmVsICE9PSBcImF1dG9cIikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbbm9kZV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFN0cmluZyhncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJkaXNwbGF5XCIpKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIHNjcmlwdExldmVsW2dyb3VwLnNjcmlwdExldmVsXSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcZGZyYWNcIixcbiAgICBcIlxcXFxmcmFjXCIsXG4gICAgXCJcXFxcdGZyYWNcIixcbiAgICBcIlxcXFxkYmlub21cIixcbiAgICBcIlxcXFxiaW5vbVwiLFxuICAgIFwiXFxcXHRiaW5vbVwiLFxuICAgIFwiXFxcXFxcXFxhdG9wZnJhY1wiLCAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgICBcIlxcXFxcXFxcYnJhY2VmcmFjXCIsXG4gICAgXCJcXFxcXFxcXGJyYWNrZnJhY1wiIC8vIGRpdHRvXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbMF07XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzFdO1xuICAgIGxldCBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgbGV0IGxlZnREZWxpbSA9IG51bGw7XG4gICAgbGV0IHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIGxldCBzY3JpcHRMZXZlbCA9IFwiYXV0b1wiO1xuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXHRmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcXFxcXGF0b3BmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFxiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgbGVmdERlbGltID0gXCIoXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXFxcXFxicmFjZWZyYWNcIjpcbiAgICAgICAgbGVmdERlbGltID0gXCJcXFxce1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJcXFxcfVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcXFxcXGJyYWNrZnJhY1wiOlxuICAgICAgICBsZWZ0RGVsaW0gPSBcIltcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBnZW5mcmFjIGNvbW1hbmRcIik7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgICAgc2NyaXB0TGV2ZWwgPSBcImRpc3BsYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXHRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXHRiaW5vbVwiOlxuICAgICAgICBzY3JpcHRMZXZlbCA9IFwidGV4dFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW0sXG4gICAgICBzY3JpcHRMZXZlbCxcbiAgICAgIGJhclNpemU6IG51bGxcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDVcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGNmcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGRlbm9tID0gYXJnc1sxXTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29udGludWVkOiB0cnVlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGhhc0JhckxpbmU6IHRydWUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2NyaXB0TGV2ZWw6IFwiZGlzcGxheVwiLFxuICAgICAgYmFyU2l6ZTogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBJbmZpeCBnZW5lcmFsaXplZCBmcmFjdGlvbnMgLS0gdGhlc2UgYXJlIG5vdCByZW5kZXJlZCBkaXJlY3RseSwgYnV0IHJlcGxhY2VkXG4vLyBpbW1lZGlhdGVseSBieSBvbmUgb2YgdGhlIHZhcmlhbnRzIGFib3ZlLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlclwiLCBcIlxcXFxjaG9vc2VcIiwgXCJcXFxcYXRvcFwiLCBcIlxcXFxicmFjZVwiLCBcIlxcXFxicmFja1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9KSB7XG4gICAgbGV0IHJlcGxhY2VXaXRoO1xuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcb3ZlclwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGNob29zZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxhdG9wXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGF0b3BmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxicmFjZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxicmFjZWZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGJyYWNrXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGJyYWNrZnJhY1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBpbmZpeCBnZW5mcmFjIGNvbW1hbmRcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoLFxuICAgICAgdG9rZW5cbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgZGVsaW1Gcm9tVmFsdWUgPSBmdW5jdGlvbihkZWxpbVN0cmluZykge1xuICBsZXQgZGVsaW0gPSBudWxsO1xuICBpZiAoZGVsaW1TdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIGRlbGltID0gZGVsaW1TdHJpbmc7XG4gICAgZGVsaW0gPSBkZWxpbSA9PT0gXCIuXCIgPyBudWxsIDogZGVsaW07XG4gIH1cbiAgcmV0dXJuIGRlbGltO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxnZW5mcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDYsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIiwgXCJtYXRoXCIsIFwic2l6ZVwiLCBcInRleHRcIiwgXCJtYXRoXCIsIFwibWF0aFwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbNF07XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzVdO1xuXG4gICAgLy8gTG9vayBpbnRvIHRoZSBwYXJzZSBub2RlcyB0byBnZXQgdGhlIGRlc2lyZWQgZGVsaW1pdGVycy5cbiAgICBjb25zdCBsZWZ0Tm9kZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgIGNvbnN0IGxlZnREZWxpbSA9IGxlZnROb2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIGxlZnROb2RlLmZhbWlseSA9PT0gXCJvcGVuXCJcbiAgICAgID8gZGVsaW1Gcm9tVmFsdWUobGVmdE5vZGUudGV4dClcbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCByaWdodE5vZGUgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzFdKTtcbiAgICBjb25zdCByaWdodERlbGltID1cbiAgICAgIHJpZ2h0Tm9kZS50eXBlID09PSBcImF0b21cIiAmJiByaWdodE5vZGUuZmFtaWx5ID09PSBcImNsb3NlXCJcbiAgICAgICAgPyBkZWxpbUZyb21WYWx1ZShyaWdodE5vZGUudGV4dClcbiAgICAgICAgOiBudWxsO1xuXG4gICAgY29uc3QgYmFyTm9kZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMl0sIFwic2l6ZVwiKTtcbiAgICBsZXQgaGFzQmFyTGluZTtcbiAgICBsZXQgYmFyU2l6ZSA9IG51bGw7XG4gICAgaWYgKGJhck5vZGUuaXNCbGFuaykge1xuICAgICAgLy8gXFxnZW5mcmFjIGFjdHMgZGlmZmVyZW50bHkgdGhhbiBcXGFib3ZlLlxuICAgICAgLy8gXFxnZW5mcmFjIHRyZWF0cyBhbiBlbXB0eSBzaXplIGdyb3VwIGFzIGEgc2lnbmFsIHRvIHVzZSBhXG4gICAgICAvLyBzdGFuZGFyZCBiYXIgc2l6ZS4gXFxhYm92ZSB3b3VsZCBzZWUgc2l6ZSA9IDAgYW5kIG9taXQgdGhlIGJhci5cbiAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJTaXplID0gYmFyTm9kZS52YWx1ZTtcbiAgICAgIGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgfVxuXG4gICAgLy8gRmluZCBvdXQgaWYgd2Ugd2FudCBkaXNwbGF5c3R5bGUsIHRleHRzdHlsZSwgZXRjLlxuICAgIGxldCBzY3JpcHRMZXZlbCA9IFwiYXV0b1wiO1xuICAgIGxldCBzdHlsID0gYXJnc1szXTtcbiAgICBpZiAoc3R5bC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIGlmIChzdHlsLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0ZXh0T3JkID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bC5ib2R5WzBdLCBcInRleHRvcmRcIik7XG4gICAgICAgIHNjcmlwdExldmVsID0gc3R5bEFycmF5W051bWJlcih0ZXh0T3JkLnRleHQpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bCA9IGFzc2VydE5vZGVUeXBlKHN0eWwsIFwidGV4dG9yZFwiKTtcbiAgICAgIHNjcmlwdExldmVsID0gc3R5bEFycmF5W051bWJlcihzdHlsLnRleHQpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW0sXG4gICAgICByaWdodERlbGltLFxuICAgICAgc2NyaXB0TGV2ZWxcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDVcbn0pO1xuXG4vLyBcXGFib3ZlIGlzIGFuIGluZml4IGZyYWN0aW9uIHRoYXQgYWxzbyBkZWZpbmVzIGEgZnJhY3Rpb24gYmFyIHNpemUuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5maXhcIixcbiAgbmFtZXM6IFtcIlxcXFxhYm92ZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW5maXhcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgcmVwbGFjZVdpdGg6IFwiXFxcXFxcXFxhYm92ZWZyYWNcIixcbiAgICAgIGJhclNpemU6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKS52YWx1ZSxcbiAgICAgIHRva2VuXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXGFib3ZlZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCIsIFwic2l6ZVwiLCBcIm1hdGhcIl1cbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGJhclNpemUgPSBhc3NlcnQoYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJpbmZpeFwiKS5iYXJTaXplKTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbMl07XG5cbiAgICBjb25zdCBoYXNCYXJMaW5lID0gYmFyU2l6ZS5udW1iZXIgPiAwO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgYmFyU2l6ZSxcbiAgICAgIGxlZnREZWxpbTogbnVsbCxcbiAgICAgIHJpZ2h0RGVsaW06IG51bGwsXG4gICAgICBzY3JpcHRMZXZlbDogXCJhdXRvXCJcbiAgICB9O1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7XG5cbi8vIFxcaGJveCBpcyBwcm92aWRlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIExhVGVYIGZ1bmN0aW9ucyB0aGF0IGFjdCBvbiBhIGJveC5cbi8vIFRoaXMgZnVuY3Rpb24gYnkgaXRzZWxmIGRvZXNuJ3QgZG8gYW55dGhpbmcgYnV0IHNldCBzY3JpcHRsZXZlbCB0byBcXHRleHRzdHlsZVxuLy8gYW5kIHByZXZlbnQgYSBzb2Z0IGxpbmUgYnJlYWsuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJoYm94XCIsXG4gIG5hbWVzOiBbXCJcXFxcaGJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhib3hcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1swXSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aExldmVsKFN0eWxlTGV2ZWwuVEVYVCk7XG4gICAgY29uc3QgbXJvdyA9IGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBuZXdTdHlsZSk7XG4gICAgcmV0dXJuIGNvbnNvbGlkYXRlVGV4dChtcm93KVxuICB9XG59KTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ0ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBjb25zdCBhY2NlbnROb2RlID0gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gIGFjY2VudE5vZGUuc3R5bGVbXCJtYXRoLWRlcHRoXCJdID0gMDtcbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCIsIFtcbiAgICBidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgc3R5bGUpLFxuICAgIGFjY2VudE5vZGVcbiAgXSk7XG59O1xuXG4vLyBIb3Jpem9udGFsIHN0cmV0Y2h5IGJyYWNlc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgbmFtZXM6IFtcIlxcXFxvdmVyYnJhY2VcIiwgXCJcXFxcdW5kZXJicmFjZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJob3JpekJyYWNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGlzT3ZlcjogL15cXFxcb3Zlci8udGVzdChmdW5jTmFtZSksXG4gICAgICBiYXNlOiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ0XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFxocmVmXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInVybFwiLCBcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCB0b2tlbiB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgY29uc3QgaHJlZiA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmIChcbiAgICAgICFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgICAgY29tbWFuZDogXCJcXFxcaHJlZlwiLFxuICAgICAgICB1cmw6IGhyZWZcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCJcXFxcaHJlZlwiIGlzIG5vdCB0cnVzdGVkYCwgdG9rZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgbWF0aCA9IG5ldyBNYXRoTm9kZShcIm1hdGhcIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBzdHlsZSldKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gbmV3IEFuY2hvck5vZGUoZ3JvdXAuaHJlZiwgW10sIFttYXRoXSk7XG4gICAgcmV0dXJuIGFuY2hvck5vZGVcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxcdXJsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInVybFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgdG9rZW4gfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoXG4gICAgICAhcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICAgIGNvbW1hbmQ6IFwiXFxcXHVybFwiLFxuICAgICAgICB1cmw6IGhyZWZcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCJcXFxcdXJsXCIgaXMgbm90IHRydXN0ZWRgLCB0b2tlbilcbiAgICB9XG5cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGMgPSBocmVmW2ldO1xuICAgICAgaWYgKGMgPT09IFwiflwiKSB7XG4gICAgICAgIGMgPSBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogY1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZm9udDogXCJcXFxcdGV4dHR0XCIsXG4gICAgICBib2R5OiBjaGFyc1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImh0bWxcIixcbiAgbmFtZXM6IFtcIlxcXFxjbGFzc1wiLCBcIlxcXFxpZFwiLCBcIlxcXFxzdHlsZVwiLCBcIlxcXFxkYXRhXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuXG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBGdW5jdGlvbiBcIiR7ZnVuY05hbWV9XCIgaXMgZGlzYWJsZWQgaW4gc3RyaWN0IG1vZGVgLCB0b2tlbilcbiAgICB9XG5cbiAgICBsZXQgdHJ1c3RDb250ZXh0O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcY2xhc3NcIjpcbiAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcY2xhc3NcIixcbiAgICAgICAgICBjbGFzczogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGlkXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuaWQgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGlkXCIsXG4gICAgICAgICAgaWQ6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxzdHlsZVwiOlxuICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxzdHlsZVwiLFxuICAgICAgICAgIHN0eWxlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcZGF0YVwiOiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleVZhbCA9IGRhdGFbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgIGlmIChrZXlWYWwubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkVycm9yIHBhcnNpbmcga2V5LXZhbHVlIGZvciBcXFxcZGF0YVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlc1tcImRhdGEtXCIgKyBrZXlWYWxbMF0udHJpbSgpXSA9IGtleVZhbFsxXS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcZGF0YVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaHRtbCBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh0cnVzdENvbnRleHQpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCIke2Z1bmNOYW1lfVwiIGlzIG5vdCB0cnVzdGVkYCwgdG9rZW4pXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImh0bWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAgYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIHN0eWxlKTtcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICBpZiAoZ3JvdXAuYXR0cmlidXRlcy5jbGFzcykge1xuICAgICAgY2xhc3Nlcy5wdXNoKC4uLmdyb3VwLmF0dHJpYnV0ZXMuY2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzZXMgPSBjbGFzc2VzO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGdyb3VwLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChhdHRyICE9PSBcImNsYXNzXCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGdyb3VwLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIGdyb3VwLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59KTtcblxuY29uc3Qgc2l6ZURhdGEgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKC9eWy0rXT8gKihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKSQvLnRlc3Qoc3RyKSkge1xuICAgIC8vIHN0ciBpcyBhIG51bWJlciB3aXRoIG5vIHVuaXQgc3BlY2lmaWVkLlxuICAgIC8vIGRlZmF1bHQgdW5pdCBpcyBicCwgcGVyIGdyYXBoaXggcGFja2FnZS5cbiAgICByZXR1cm4geyBudW1iZXI6ICtzdHIsIHVuaXQ6IFwiYnBcIiB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2ggPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgc2l6ZTogJ1wiICsgc3RyICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3NcIik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyXG4gICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG4gICAgaWYgKCF2YWxpZFVuaXQoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljcy5cIik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmNsdWRlZ3JhcGhpY3NcIixcbiAgbmFtZXM6IFtcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInVybFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIHRva2VuIH0sIGFyZ3MsIG9wdEFyZ3MpID0+IHtcbiAgICBsZXQgd2lkdGggPSB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH07XG4gICAgbGV0IGhlaWdodCA9IHsgbnVtYmVyOiAwLjksIHVuaXQ6IFwiZW1cIiB9OyAgLy8gc29ydGEgY2hhcmFjdGVyIHNpemVkLlxuICAgIGxldCB0b3RhbGhlaWdodCA9IHsgbnVtYmVyOiAwLCB1bml0OiBcImVtXCIgfTtcbiAgICBsZXQgYWx0ID0gXCJcIjtcblxuICAgIGlmIChvcHRBcmdzWzBdKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVTdHIgPSBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG5cbiAgICAgIC8vIFBhcnNlci5qcyBkb2VzIG5vdCBwYXJzZSBrZXkvdmFsdWUgcGFpcnMuIFdlIGdldCBhIHN0cmluZy5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVTdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleVZhbCA9IGF0dHJpYnV0ZXNbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IGtleVZhbFsxXS50cmltKCk7XG4gICAgICAgICAgc3dpdGNoIChrZXlWYWxbMF0udHJpbSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWx0XCI6XG4gICAgICAgICAgICAgIGFsdCA9IHN0cjtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICB3aWR0aCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgICAgIGhlaWdodCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFwidG90YWxoZWlnaHRcIjpcbiAgICAgICAgICAgICAgdG90YWxoZWlnaHQgPSBzaXplRGF0YShzdHIpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGtleTogJ1wiICsga2V5VmFsWzBdICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3MuXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3JjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKGFsdCA9PT0gXCJcIikge1xuICAgICAgLy8gTm8gYWx0IGdpdmVuLiBVc2UgdGhlIGZpbGUgbmFtZS4gU3RyaXAgYXdheSB0aGUgcGF0aC5cbiAgICAgIGFsdCA9IHNyYztcbiAgICAgIGFsdCA9IGFsdC5yZXBsYWNlKC9eLipbXFxcXC9dLywgXCJcIik7XG4gICAgICBhbHQgPSBhbHQuc3Vic3RyaW5nKDAsIGFsdC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgICAgY29tbWFuZDogXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIsXG4gICAgICAgIHVybDogc3JjXG4gICAgICB9KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEZ1bmN0aW9uIFwiXFxcXGluY2x1ZGVncmFwaGljc1wiIGlzIG5vdCB0cnVzdGVkYCwgdG9rZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW5jbHVkZWdyYXBoaWNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGFsdDogYWx0LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB0b3RhbGhlaWdodDogdG90YWxoZWlnaHQsXG4gICAgICBzcmM6IHNyY1xuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBzdHlsZSk7XG4gICAgY29uc3QgZGVwdGggPSB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH07XG5cbiAgICBpZiAoZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyID4gMCkge1xuICAgICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0LnVuaXQgPT09IGhlaWdodC51bml0ICYmXG4gICAgICAgIGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IGhlaWdodC5udW1iZXIpIHtcbiAgICAgICAgZGVwdGgubnVtYmVyID0gZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyIC0gaGVpZ2h0Lm51bWJlcjtcbiAgICAgICAgZGVwdGgudW5pdCA9IGhlaWdodC51bml0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgaWYgKGdyb3VwLndpZHRoLm51bWJlciA+IDApIHtcbiAgICAgIHdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgc3R5bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyYXBoaWNTdHlsZSA9IHsgaGVpZ2h0OiBoZWlnaHQubnVtYmVyICsgZGVwdGgubnVtYmVyICsgXCJlbVwiIH07XG4gICAgaWYgKHdpZHRoLm51bWJlciA+IDApIHtcbiAgICAgIGdyYXBoaWNTdHlsZS53aWR0aCA9IHdpZHRoLm51bWJlciArIHdpZHRoLnVuaXQ7XG4gICAgfVxuICAgIGlmIChkZXB0aC5udW1iZXIgPiAwKSB7XG4gICAgICBncmFwaGljU3R5bGUudmVydGljYWxBbGlnbiA9IC1kZXB0aC5udW1iZXIgKyBkZXB0aC51bml0O1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBuZXcgSW1nKGdyb3VwLnNyYywgZ3JvdXAuYWx0LCBncmFwaGljU3R5bGUpO1xuICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIG5vZGUuZGVwdGggPSBkZXB0aDtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbbm9kZV0pXG4gIH1cbn0pO1xuXG4vLyBIb3Jpem9udGFsIHNwYWNpbmcgY29tbWFuZHNcblxuXG4vLyBUT0RPOiBcXGhza2lwIGFuZCBcXG1za2lwIHNob3VsZCBzdXBwb3J0IHBsdXMgYW5kIG1pbnVzIGluIGxlbmd0aHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImtlcm5cIixcbiAgbmFtZXM6IFtcIlxcXFxrZXJuXCIsIFwiXFxcXG1rZXJuXCIsIFwiXFxcXGhza2lwXCIsIFwiXFxcXG1za2lwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIl0sXG4gICAgcHJpbWl0aXZlOiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBzaXplID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpO1xuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICBjb25zdCBtYXRoRnVuY3Rpb24gPSBmdW5jTmFtZVsxXSA9PT0gXCJtXCI7IC8vIFxcbWtlcm4sIFxcbXNraXBcbiAgICAgIGNvbnN0IG11VW5pdCA9IHNpemUudmFsdWUudW5pdCA9PT0gXCJtdVwiO1xuICAgICAgaWYgKG1hdGhGdW5jdGlvbikge1xuICAgICAgICBpZiAoIW11VW5pdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBMYVRlWCdzICR7ZnVuY05hbWV9IHN1cHBvcnRzIG9ubHkgbXUgdW5pdHMsIGAgK1xuICAgICAgICAgICAgYG5vdCAke3NpemUudmFsdWUudW5pdH0gdW5pdHNgLCB0b2tlbilcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLm1vZGUgIT09IFwibWF0aFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYExhVGVYJ3MgJHtmdW5jTmFtZX0gd29ya3Mgb25seSBpbiBtYXRoIG1vZGVgLCB0b2tlbilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIW1hdGhGdW5jdGlvblxuICAgICAgICBpZiAobXVVbml0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYExhVGVYJ3MgJHtmdW5jTmFtZX0gZG9lc24ndCBzdXBwb3J0IG11IHVuaXRzYCwgdG9rZW4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaW1lbnNpb246IHNpemUudmFsdWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZGltZW5zaW9uLCBzdHlsZSk7XG4gICAgY29uc3QgY2ggPSBkaW1lbnNpb24udW5pdCA9PT0gXCJlbVwiID8gc3BhY2VDaGFyYWN0ZXIoZGltZW5zaW9uLm51bWJlcikgOiBcIlwiO1xuICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIiAmJiBjaC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShjaCk7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbY2hhcmFjdGVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgZGltZW5zaW9uLm51bWJlciArIGRpbWVuc2lvbi51bml0KTtcbiAgICAgIGlmIChkaW1lbnNpb24ubnVtYmVyIDwgMCkge1xuICAgICAgICBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBkaW1lbnNpb24ubnVtYmVyICsgZGltZW5zaW9uLnVuaXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5jb25zdCBzcGFjZUNoYXJhY3RlciA9IGZ1bmN0aW9uKHdpZHRoKSB7XG4gIGlmICh3aWR0aCA+PSAwLjA1NTU1ICYmIHdpZHRoIDw9IDAuMDU1NTYpIHtcbiAgICByZXR1cm4gXCJcXHUyMDBhXCI7IC8vICZWZXJ5VGhpblNwYWNlO1xuICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMTY2NiAmJiB3aWR0aCA8PSAwLjE2NjcpIHtcbiAgICByZXR1cm4gXCJcXHUyMDA5XCI7IC8vICZUaGluU3BhY2U7XG4gIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yMjIyICYmIHdpZHRoIDw9IDAuMjIyMykge1xuICAgIHJldHVybiBcIlxcdTIwMDVcIjsgLy8gJk1lZGl1bVNwYWNlO1xuICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMjc3NyAmJiB3aWR0aCA8PSAwLjI3NzgpIHtcbiAgICByZXR1cm4gXCJcXHUyMDA1XFx1MjAwYVwiOyAvLyAmVGhpY2tTcGFjZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcblxuLy8gTGltaXQgdmFsaWQgY2hhcmFjdGVycyB0byBhIHNtYWxsIHNldCwgZm9yIHNhZmV0eS5cbmNvbnN0IGludmFsaWRJZFJlZ0V4ID0gL1teQS1aYS16XzAtOS1dL2c7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsYWJlbFwiLFxuICBuYW1lczogW1wiXFxcXGxhYmVsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsYWJlbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzdHJpbmc6IGFyZ3NbMF0uc3RyaW5nLnJlcGxhY2UoaW52YWxpZElkUmVnRXgsIFwiXCIpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBSZXR1cm4gYSBuby13aWR0aCwgbm8taW5rIGVsZW1lbnQgd2l0aCBhbiBIVE1MIGlkLlxuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInRtbC1sYWJlbFwiXSk7XG4gICAgaWYgKGdyb3VwLnN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlLnNldExhYmVsKGdyb3VwLnN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG4vLyBIb3Jpem9udGFsIG92ZXJsYXAgZnVuY3Rpb25zXG5cbmNvbnN0IHRleHRNb2RlTGFwID0gW1wiXFxcXGNsYXBcIiwgXCJcXFxcbGxhcFwiLCBcIlxcXFxybGFwXCJdO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGFwXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGxsYXBcIiwgXCJcXFxcbWF0aHJsYXBcIiwgXCJcXFxcbWF0aGNsYXBcIiwgXCJcXFxcY2xhcFwiLCBcIlxcXFxsbGFwXCIsIFwiXFxcXHJsYXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpID0+IHtcbiAgICBpZiAodGV4dE1vZGVMYXAuaW5jbHVkZXMoZnVuY05hbWUpKSB7XG4gICAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCAmJiBwYXJzZXIubW9kZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYHske2Z1bmNOYW1lfX0gY2FuIGJlIHVzZWQgb25seSBpbiB0ZXh0IG1vZGUuXG4gVHJ5IFxcXFxtYXRoJHtmdW5jTmFtZS5zbGljZSgxKX1gLCB0b2tlbilcbiAgICAgIH1cbiAgICAgIGZ1bmNOYW1lID0gZnVuY05hbWUuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmNOYW1lID0gZnVuY05hbWUuc2xpY2UoNSk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxhcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbGlnbm1lbnQ6IGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIC8vIG1hdGhsbGFwLCBtYXRocmxhcCwgbWF0aGNsYXBcbiAgICBsZXQgc3RydXQ7XG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJsbGFwXCIpIHtcbiAgICAgIC8vIFdlIG5lZWQgYW4gaW52aXNpYmxlIHN0cnV0IHdpdGggdGhlIHNhbWUgZGVwdGggYXMgdGhlIGdyb3VwLlxuICAgICAgLy8gV2UgY2FuJ3QganVzdCByZWFkIHRoZSBkZXB0aCwgc28gd2UgdXNlIFxcdnBoYW50b20gbWV0aG9kcy5cbiAgICAgIGNvbnN0IHBoYW50b21Jbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgc3R5bGUpO1xuICAgICAgY29uc3QgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgcGhhbnRvbUlubmVyKTtcbiAgICAgIHN0cnV0ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgICBzdHJ1dC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSk7XG4gICAgbGV0IG5vZGU7XG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJsbGFwXCIpIHtcbiAgICAgIGlubmVyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgaW5uZXIuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICAgIGlubmVyLnN0eWxlLmJvdHRvbSA9IGAwYDsgLy8gSWYgd2UgY291bGQgaGF2ZSByZWFkIHRoZSBpbmsgZGVwdGgsIGl0IHdvdWxkIGdvIGhlcmUuXG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtzdHJ1dCwgaW5uZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbaW5uZXJdKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ID09PSBcInJsYXBcIikge1xuICAgICAgaWYgKGdyb3VwLmJvZHkuYm9keS5sZW5ndGggPiAwICYmIGdyb3VwLmJvZHkuYm9keVswXS50eXBlID09PSBcImdlbmZyYWNcIikge1xuICAgICAgICAvLyBJbiBGaXJlZm94LCBhIDxtcGFkZGVkPiBzcXVhc2hlcyB0aGUgMy8xOGVtIHBhZGRpbmcgb2YgYSBjaGlsZCBcXGZyYWMuIFB1dCBpdCBiYWNrLlxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMTY2NjdlbVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZ3JvdXAuYWxpZ25tZW50ID09PSBcImxsYXBcIiA/IFwiLTFcIiA6IFwiLTAuNVwiO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgb2Zmc2V0ICsgXCJ3aWR0aFwiKTtcbiAgICAgIGlmIChncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgICAgbm9kZS5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbi8vIFN3aXRjaGluZyBmcm9tIHRleHQgbW9kZSBiYWNrIHRvIG1hdGggbW9kZVxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gIG5hbWVzOiBbXCJcXFxcKFwiLCBcIiRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIoeyBmdW5jTmFtZSwgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBvdXRlck1vZGUgPSBwYXJzZXIubW9kZTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShcIm1hdGhcIik7XG4gICAgY29uc3QgY2xvc2UgPSBmdW5jTmFtZSA9PT0gXCJcXFxcKFwiID8gXCJcXFxcKVwiIDogXCIkXCI7XG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGNsb3NlKTtcbiAgICBwYXJzZXIuZXhwZWN0KGNsb3NlKTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gQ2hlY2sgZm9yIGV4dHJhIGNsb3NpbmcgbWF0aCBkZWxpbWl0ZXJzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLCAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgaXMuXG4gIG5hbWVzOiBbXCJcXFxcKVwiLCBcIlxcXFxdXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIHRva2VuKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYE1pc21hdGNoZWQgJHtjb250ZXh0LmZ1bmNOYW1lfWAsIHRva2VuKTtcbiAgfVxufSk7XG5cbmNvbnN0IGNob29zZVN0eWxlID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBzd2l0Y2ggKHN0eWxlLmxldmVsKSB7XG4gICAgY2FzZSBTdHlsZUxldmVsLkRJU1BMQVk6ICAgICAgIC8vIDBcbiAgICAgIHJldHVybiBncm91cC5kaXNwbGF5O1xuICAgIGNhc2UgU3R5bGVMZXZlbC5URVhUOiAgICAgICAgICAvLyAxXG4gICAgICByZXR1cm4gZ3JvdXAudGV4dDtcbiAgICBjYXNlIFN0eWxlTGV2ZWwuU0NSSVBUOiAgICAgICAgLy8gMlxuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdDtcbiAgICBjYXNlIFN0eWxlTGV2ZWwuU0NSSVBUU0NSSVBUOiAgLy8gM1xuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdHNjcmlwdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7XG4gIH1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtYXRoY2hvaWNlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGNob2ljZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA0LFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1hdGhjaG9pY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZGlzcGxheTogb3JkYXJndW1lbnQoYXJnc1swXSksXG4gICAgICB0ZXh0OiBvcmRhcmd1bWVudChhcmdzWzFdKSxcbiAgICAgIHNjcmlwdDogb3JkYXJndW1lbnQoYXJnc1syXSksXG4gICAgICBzY3JpcHRzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbM10pXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBjaG9vc2VTdHlsZShncm91cCwgc3R5bGUpO1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coYm9keSwgc3R5bGUpO1xuICB9XG59KTtcblxuY29uc3QgdGV4dEF0b21UeXBlcyA9IFtcInRleHRcIiwgXCJ0ZXh0b3JkXCIsIFwibWF0aG9yZFwiLCBcImF0b21cIl07XG5cbmZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIkMyhncm91cCwgc3R5bGUpIHtcbiAgbGV0IG5vZGU7XG4gIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlKTtcblxuICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1pbm5lclwiKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBpbm5lcik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcmRcIikge1xuICAgIGlmIChncm91cC5pc0NoYXJhY3RlckJveCB8fCBpbm5lclswXS50eXBlID09PSBcIm1hdGhvcmRcIikge1xuICAgICAgbm9kZSA9IGlubmVyWzBdO1xuICAgICAgbm9kZS50eXBlID0gXCJtaVwiO1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuY2hpbGRyZW5bMF0udGV4dCAmJiBub2RlLmNoaWxkcmVuWzBdLnRleHQgPT09IFwi4oiHXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm5vcm1hbFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgaW5uZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcbiAgICBpZiAoZ3JvdXAubXVzdFByb21vdGUpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibW9cIjtcbiAgICAgIGlmIChncm91cC5pc0NoYXJhY3RlckJveCAmJiBncm91cC5ib2R5WzBdLnRleHQgJiYgL1tBLVphLXpdLy50ZXN0KGdyb3VwLmJvZHlbMF0udGV4dCkpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIml0YWxpY1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBpbm5lcik7XG4gICAgfVxuXG4gICAgLy8gU2V0IHNwYWNpbmcgYmFzZWQgb24gd2hhdCBpcyB0aGUgbW9zdCBsaWtlbHkgYWRqYWNlbnQgYXRvbSB0eXBlLlxuICAgIC8vIFNlZSBUZVhib29rIHAxNzAuXG4gICAgY29uc3QgZG9TcGFjaW5nID0gc3R5bGUubGV2ZWwgPCAyOyAvLyBPcGVyYXRvciBzcGFjaW5nIGlzIHplcm8gaW5zaWRlIGEgKHN1YnxzdXBlcilzY3JpcHQuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJtcm93XCIpIHtcbiAgICAgIGlmIChkb1NwYWNpbmcgKSB7XG4gICAgICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibWJpblwiKSB7XG4gICAgICAgICAgLy8gbWVkaXVtIHNwYWNlXG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi51bnNoaWZ0KHBhZGRpbmckMSgwLjIyMjIpKTtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gocGFkZGluZyQxKDAuMjIyMikpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtcmVsXCIpIHtcbiAgICAgICAgICAvLyB0aGlja3NwYWNlXG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi51bnNoaWZ0KHBhZGRpbmckMSgwLjI3NzgpKTtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gocGFkZGluZyQxKDAuMjc3OCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtcHVuY3RcIikge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChwYWRkaW5nJDEoMC4xNjY3KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1pbm5lclwiKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi51bnNoaWZ0KHBhZGRpbmckMSgwLjA1NTYpKTsgIC8vIDEgbXUgaXMgdGhlIG1vc3QgbGlrZWx5IG9wdGlvblxuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChwYWRkaW5nJDEoMC4wNTU2KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtYmluXCIpIHtcbiAgICAgICAgLy8gbWVkaXVtIHNwYWNlXG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSAoZG9TcGFjaW5nID8gXCIwLjIyMjJlbVwiIDogXCIwXCIpO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4yMjIyZW1cIiA6IFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1yZWxcIikge1xuICAgICAgICAvLyB0aGlja3NwYWNlXG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSAoZG9TcGFjaW5nID8gXCIwLjI3NzhlbVwiIDogXCIwXCIpO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4yNzc4ZW1cIiA6IFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1wdW5jdFwiKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4xNjY3ZW1cIiA6IFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcGVuXCIgfHwgZ3JvdXAubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1pbm5lclwiICYmIGRvU3BhY2luZykge1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjA1NTZlbVwiOyAvLyAxIG11IGlzIHRoZSBtb3N0IGxpa2VseSBvcHRpb25cbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLndpZHRoID0gXCIrMC4xMTExZW1cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShncm91cC5tY2xhc3MgPT09IFwibW9wZW5cIiB8fCBncm91cC5tY2xhc3MgPT09IFwibWNsb3NlXCIpKSB7XG4gICAgICBkZWxldGUgbm9kZS5hdHRyaWJ1dGVzLnN0cmV0Y2h5O1xuICAgICAgZGVsZXRlIG5vZGUuYXR0cmlidXRlcy5mb3JtO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxtYXRob3JkXCIsXG4gICAgXCJcXFxcbWF0aGJpblwiLFxuICAgIFwiXFxcXG1hdGhyZWxcIixcbiAgICBcIlxcXFxtYXRob3BlblwiLFxuICAgIFwiXFxcXG1hdGhjbG9zZVwiLFxuICAgIFwiXFxcXG1hdGhwdW5jdFwiLFxuICAgIFwiXFxcXG1hdGhpbm5lclwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGlzQ2hhcmFjdGVyQm94ID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYm9keSk7XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCB3cmFwIGEgPG1vPiBhcm91bmQgYSA8bWk+IG9yIDxtb3JkPi4gVGhhdCB3b3VsZCBiZSBpbnZhbGlkIE1hdGhNTC5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIGluc3RlYWQgcHJvbW90ZSB0aGUgdGV4dCBjb250ZW50cyBvZiB0aGUgYm9keSB0byB0aGUgcGFyZW50LlxuICAgIGxldCBtdXN0UHJvbW90ZSA9IHRydWU7XG4gICAgY29uc3QgbW9yZCA9IHsgdHlwZTogXCJtYXRob3JkXCIsIHRleHQ6IFwiXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG4gICAgY29uc3QgYXJyID0gKGJvZHkuYm9keSkgPyBib2R5LmJvZHkgOiBbYm9keV07XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJyKSB7XG4gICAgICBpZiAodGV4dEF0b21UeXBlcy5pbmNsdWRlcyhhcmcudHlwZSkpIHtcbiAgICAgICAgaWYgKHN5bWJvbHNbcGFyc2VyLm1vZGVdW2FyZy50ZXh0XSkge1xuICAgICAgICAgIG1vcmQudGV4dCArPSBzeW1ib2xzW3BhcnNlci5tb2RlXVthcmcudGV4dF0ucmVwbGFjZTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcudGV4dCkge1xuICAgICAgICAgIG1vcmQudGV4dCArPSBhcmcudGV4dDtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcuYm9keSkge1xuICAgICAgICAgIGFyZy5ib2R5Lm1hcChlID0+IHsgbW9yZC50ZXh0ICs9IGUudGV4dDsgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11c3RQcm9tb3RlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtdXN0UHJvbW90ZSAmJiBmdW5jTmFtZSA9PT0gXCJcXFxcbWF0aG9yZFwiICYmIG1vcmQudHlwZSA9PT0gXCJtYXRob3JkXCJcbiAgICAgICAgICAgICAgICAgICAgJiYgbW9yZC50ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBtb3JkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBtY2xhc3M6IFwibVwiICsgZnVuY05hbWUuc2xpY2UoNSksXG4gICAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KG11c3RQcm9tb3RlID8gbW9yZCA6IGJvZHkpLFxuICAgICAgICBpc0NoYXJhY3RlckJveCxcbiAgICAgICAgbXVzdFByb21vdGVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDNcbn0pO1xuXG5jb25zdCBiaW5yZWxDbGFzcyA9IChhcmcpID0+IHtcbiAgLy8gXFxiaW5yZWxAIHNwYWNpbmcgdmFyaWVzIHdpdGggKGJpbnxyZWx8b3JkKSBvZiB0aGUgYXRvbSBpbiB0aGUgYXJndW1lbnQuXG4gIC8vIChieSByZW5kZXJpbmcgc2VwYXJhdGVseSBhbmQgd2l0aCB7fXMgYmVmb3JlIGFuZCBhZnRlciwgYW5kIG1lYXN1cmluZ1xuICAvLyB0aGUgY2hhbmdlIGluIHNwYWNpbmcpLiAgV2UnbGwgZG8gcm91Z2hseSB0aGUgc2FtZSBieSBkZXRlY3RpbmcgdGhlXG4gIC8vIGF0b20gdHlwZSBkaXJlY3RseS5cbiAgY29uc3QgYXRvbSA9IGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgJiYgYXJnLmJvZHkubGVuZ3RoID8gYXJnLmJvZHlbMF0gOiBhcmc7XG4gIGlmIChhdG9tLnR5cGUgPT09IFwiYXRvbVwiICYmIChhdG9tLmZhbWlseSA9PT0gXCJiaW5cIiB8fCBhdG9tLmZhbWlseSA9PT0gXCJyZWxcIikpIHtcbiAgICByZXR1cm4gXCJtXCIgKyBhdG9tLmZhbWlseTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJtb3JkXCI7XG4gIH1cbn07XG5cbi8vIFxcQGJpbnJlbHt4fXt5fSByZW5kZXJzIGxpa2UgeSBidXQgYXMgbWJpbi9tcmVsL21vcmQgaWYgeCBpcyBtYmluL21yZWwvbW9yZC5cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byBcXGJpbnJlbEB7eH1cXGJpbnJlbEBAe3l9IGluIEFNU1RlWC5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxAYmlucmVsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogYmlucmVsQ2xhc3MoYXJnc1swXSksXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChhcmdzWzFdKSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChhcmdzWzFdKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBCdWlsZCBhIHJlbGF0aW9uIG9yIHN0YWNrZWQgb3AgYnkgcGxhY2luZyBvbmUgc3ltYm9sIG9uIHRvcCBvZiBhbm90aGVyXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcc3RhY2tyZWxcIiwgXCJcXFxcb3ZlcnNldFwiLCBcIlxcXFx1bmRlcnNldFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBiYXNlQXJnID0gYXJnc1sxXTtcbiAgICBjb25zdCBzaGlmdGVkQXJnID0gYXJnc1swXTtcblxuICAgIGNvbnN0IGJhc2VPcCA9IHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IGJhc2VBcmcubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBzdGFjazogdHJ1ZSxcbiAgICAgIHN1cHByZXNzQmFzZVNoaWZ0OiBmdW5jTmFtZSAhPT0gXCJcXFxcc3RhY2tyZWxcIixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJhc2VBcmcpXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgbW9kZTogc2hpZnRlZEFyZy5tb2RlLFxuICAgICAgYmFzZTogYmFzZU9wLFxuICAgICAgc3VwOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IG51bGwgOiBzaGlmdGVkQXJnLFxuICAgICAgc3ViOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IHNoaWZ0ZWRBcmcgOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQzXG59KTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uXG5jb25zdCBidWlsZEdyb3VwID0gKGVsLCBzdHlsZSwgbm9uZU5vZGUpID0+IHtcbiAgaWYgKCFlbCkgeyByZXR1cm4gbm9uZU5vZGUgfVxuICBjb25zdCBub2RlID0gYnVpbGRHcm91cCQxKGVsLCBzdHlsZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IFwibXJvd1wiICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7IHJldHVybiBub25lTm9kZSB9XG4gIHJldHVybiBub2RlXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibXVsdGlzY3JpcHRcIixcbiAgbmFtZXM6IFtcIlxcXFxzaWRlc2V0XCIsIFwiXFxcXHByZXNAY3JpcHRcIl0sIC8vIFNlZSBtYWNyb3MuanMgZm9yIFxccHJlc2NyaXB0XG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogM1xuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykge1xuICAgIGlmIChhcmdzWzJdLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihmdW5jTmFtZSArIGBjYW5ub3QgcGFyc2UgYW4gZW1wdHkgYmFzZS5gKVxuICAgIH1cbiAgICBjb25zdCBiYXNlID0gYXJnc1syXS5ib2R5WzBdO1xuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0ICYmIGZ1bmNOYW1lID09PSBcIlxcXFxzaWRlc2V0XCIgJiYgIWJhc2Uuc3ltYm9sKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVGhlIGJhc2Ugb2YgXFxcXHNpZGVzZXQgbXVzdCBiZSBhIGJpZyBvcGVyYXRvci4gVHJ5IFxcXFxwcmVzY3JpcHQuYClcbiAgICB9XG5cbiAgICBpZiAoKGFyZ3NbMF0uYm9keS5sZW5ndGggPiAwICYmIGFyZ3NbMF0uYm9keVswXS50eXBlICE9PSBcInN1cHN1YlwiKSB8fFxuICAgICAgICAoYXJnc1sxXS5ib2R5Lmxlbmd0aCA+IDAgJiYgYXJnc1sxXS5ib2R5WzBdLnR5cGUgIT09IFwic3Vwc3ViXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxzaWRlc2V0IGNhbiBwYXJzZSBvbmx5IHN1YnNjcmlwdHMgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN1cGVyc2NyaXB0cyBpbiBpdHMgZmlyc3QgdHdvIGFyZ3VtZW50c1wiLCB0b2tlbilcbiAgICB9XG5cbiAgICAvLyBUaGUgcHJlc2NyaXB0cyBhbmQgcG9zdHNjcmlwdHMgY29tZSB3cmFwcGVkIGluIGEgc3Vwc3ViLlxuICAgIGNvbnN0IHByZXNjcmlwdHMgPSBhcmdzWzBdLmJvZHkubGVuZ3RoID4gMCA/IGFyZ3NbMF0uYm9keVswXSA6IG51bGw7XG4gICAgY29uc3QgcG9zdHNjcmlwdHMgPSBhcmdzWzFdLmJvZHkubGVuZ3RoID4gMCA/IGFyZ3NbMV0uYm9keVswXSA6IG51bGw7XG5cbiAgICBpZiAoIXByZXNjcmlwdHMgJiYgIXBvc3RzY3JpcHRzKSB7XG4gICAgICByZXR1cm4gYmFzZVxuICAgIH0gZWxzZSBpZiAoIXByZXNjcmlwdHMpIHtcbiAgICAgIC8vIEl0J3Mgbm90IGEgbXVsdGktc2NyaXB0LiBHZXQgYSBcXHRleHRzdHlsZSBzdXBzdWIuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIHNjcmlwdExldmVsOiBcInRleHRcIixcbiAgICAgICAgYm9keTogW3tcbiAgICAgICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgc3VwOiBwb3N0c2NyaXB0cy5zdXAsXG4gICAgICAgICAgc3ViOiBwb3N0c2NyaXB0cy5zdWJcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJtdWx0aXNjcmlwdFwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgaXNTaWRlc2V0OiBmdW5jTmFtZSA9PT0gXCJcXFxcc2lkZXNldFwiLFxuICAgICAgICBwcmVzY3JpcHRzLFxuICAgICAgICBwb3N0c2NyaXB0cyxcbiAgICAgICAgYmFzZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBiYXNlID0gIGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBzdHlsZSk7XG5cbiAgICBjb25zdCBwcmVzY3JpcHRzTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXByZXNjcmlwdHNcIik7XG4gICAgY29uc3Qgbm9uZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm5vbmVcIik7XG4gICAgbGV0IGNoaWxkcmVuID0gW107XG5cbiAgICBjb25zdCBwcmVTdWIgPSBidWlsZEdyb3VwKGdyb3VwLnByZXNjcmlwdHMuc3ViLCBzdHlsZSwgbm9uZU5vZGUpO1xuICAgIGNvbnN0IHByZVN1cCA9IGJ1aWxkR3JvdXAoZ3JvdXAucHJlc2NyaXB0cy5zdXAsIHN0eWxlLCBub25lTm9kZSk7XG4gICAgaWYgKGdyb3VwLmlzU2lkZXNldCkge1xuICAgICAgLy8gVGhpcyBzZWVtcyBzaWxseSwgYnV0IExhVGVYIGRvZXMgdGhpcy4gRmlyZWZveCBpZ25vcmVzIGl0LCB3aGljaCBkb2VzIG5vdCBtYWtlIG1lIHNhZC5cbiAgICAgIHByZVN1Yi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInRleHQtYWxpZ246IGxlZnQ7XCIpO1xuICAgICAgcHJlU3VwLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwidGV4dC1hbGlnbjogbGVmdDtcIik7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnBvc3RzY3JpcHRzKSB7XG4gICAgICBjb25zdCBwb3N0U3ViID0gYnVpbGRHcm91cChncm91cC5wb3N0c2NyaXB0cy5zdWIsIHN0eWxlLCBub25lTm9kZSk7XG4gICAgICBjb25zdCBwb3N0U3VwID0gYnVpbGRHcm91cChncm91cC5wb3N0c2NyaXB0cy5zdXAsIHN0eWxlLCBub25lTm9kZSk7XG4gICAgICBjaGlsZHJlbiA9IFtiYXNlLCBwb3N0U3ViLCBwb3N0U3VwLCBwcmVzY3JpcHRzTm9kZSwgcHJlU3ViLCBwcmVTdXBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbiA9IFtiYXNlLCBwcmVzY3JpcHRzTm9kZSwgcHJlU3ViLCBwcmVTdXBdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1tdWx0aXNjcmlwdHNcIiwgY2hpbGRyZW4pO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm5vdFwiLFxuICBuYW1lczogW1wiXFxcXG5vdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBpc0NoYXJhY3RlckJveCA9IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGFyZ3NbMF0pO1xuICAgIGxldCBib2R5O1xuICAgIGlmIChpc0NoYXJhY3RlckJveCkge1xuICAgICAgYm9keSA9IG9yZGFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgICAgaWYgKGJvZHlbMF0udGV4dC5jaGFyQXQoMCkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIGJvZHlbMF0udGV4dCA9IHN5bWJvbHMubWF0aFtib2R5WzBdLnRleHRdLnJlcGxhY2U7XG4gICAgICB9XG4gICAgICAvLyBcXHUwMzM4IGlzIHRoZSBVbmljb2RlIENvbWJpbmluZyBMb25nIFNvbGlkdXMgT3ZlcmxheVxuICAgICAgYm9keVswXS50ZXh0ID0gYm9keVswXS50ZXh0LnNsaWNlKDAsIDEpICsgXCJcXHUwMzM4XCIgKyBib2R5WzBdLnRleHQuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gdGhlIGFyZ3VtZW50IGlzIG5vdCBhIGNoYXJhY3RlciBib3gsIFRlWCBkb2VzIGFuIGF3a3dhcmQsIHBvb3JseSBwbGFjZWQgb3ZlcmxheS5cbiAgICAgIC8vIFdlJ2xsIGRvIHRoZSBzYW1lLlxuICAgICAgY29uc3Qgbm90Tm9kZSA9IHsgdHlwZTogXCJ0ZXh0b3JkXCIsIG1vZGU6IFwibWF0aFwiLCB0ZXh0OiBcIlxcdTAzMzhcIiB9O1xuICAgICAgY29uc3Qga2Vybk5vZGUgPSB7IHR5cGU6IFwia2VyblwiLCBtb2RlOiBcIm1hdGhcIiwgZGltZW5zaW9uOiB7IG51bWJlcjogLTAuNiwgdW5pdDogXCJlbVwiIH0gfTtcbiAgICAgIGJvZHkgPSBbbm90Tm9kZSwga2Vybk5vZGUsIGFyZ3NbMF1dO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJub3RcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlLCB0cnVlKTtcbiAgICAgIHJldHVybiBpbm5lclswXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIHN0eWxlKVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIExpbWl0cywgc3ltYm9sc1xuXG4vLyBTb21lIGhlbHBlcnNcblxuY29uc3Qgb3JkQXRvbVR5cGVzID0gW1widGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgXCJhdG9tXCJdO1xuXG4vLyBNb3N0IG9wZXJhdG9ycyBoYXZlIGEgbGFyZ2Ugc3VjY2Vzc29yIHN5bWJvbCwgYnV0IHRoZXNlIGRvbid0LlxuY29uc3Qgbm9TdWNjZXNzb3IgPSBbXCJcXFxcc21hbGxpbnRcIl07XG5cbi8vIE1hdGggb3BlcmF0b3JzIChlLmcuIFxcc2luKSBuZWVkIGEgc3BhY2UgYmV0d2VlbiB0aGVzZSB0eXBlcyBhbmQgdGhlbXNlbHZlczpcbmNvbnN0IG9yZFR5cGVzID0gW1widGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgXCJvcmRncm91cFwiLCBcImNsb3NlXCIsIFwibGVmdHJpZ2h0XCIsIFwiZm9udFwiXTtcblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGJ1aWxkZXJzYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJvcFwiLCBidXQgYWxzb1xuLy8gXCJzdXBzdWJcIiBzaW5jZSBzb21lIG9mIHRoZW0gKGxpa2UgXFxpbnQpIGNhbiBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxuXG5jb25zdCBzZXRTcGFjaW5nID0gbm9kZSA9PiB7XG4gIC8vIFRoZSB1c2VyIHdyb3RlIGEgXFxtYXRob3B74oCmfSBmdW5jdGlvbi4gQ2hhbmdlIHNwYWNpbmcgZnJvbSBkZWZhdWx0IHRvIE9QIHNwYWNpbmcuXG4gIC8vIFRoZSBtb3N0IGxpa2VseSBzcGFjaW5nIGZvciBhbiBPUCBpcyBhIHRoaW4gc3BhY2UgcGVyIFRlWGJvb2sgcDE3MC5cbiAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4xNjY3ZW1cIjtcbiAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMC4xNjY3ZW1cIjtcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkMiA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgbGV0IG5vZGU7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIFRoaXMgaXMgYSBzeW1ib2wuIEp1c3QgYWRkIHRoZSBzeW1ib2wuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5uYW1lLCBncm91cC5tb2RlKV0pO1xuICAgIGlmIChub1N1Y2Nlc3Nvci5pbmNsdWRlcyhncm91cC5uYW1lKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsYXJnZW9wXCIsIFwiZmFsc2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibW92YWJsZWxpbWl0c1wiLCBcImZhbHNlXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAuZnJvbU1hdGhPcCkgeyBzZXRTcGFjaW5nKG5vZGUpOyB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYm9keSkge1xuICAgIC8vIFRoaXMgaXMgYW4gb3BlcmF0b3Igd2l0aCBjaGlsZHJlbi4gQWRkIHRoZW0uXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSkpO1xuICAgIGlmIChncm91cC5mcm9tTWF0aE9wKSB7IHNldFNwYWNpbmcobm9kZSk7IH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQWRkIGFsbCBvZiB0aGUgY2hhcmFjdGVycyBmcm9tIHRoZSBvcGVyYXRvcidzIG5hbWUuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1pXCIsIFtuZXcgVGV4dE5vZGUoZ3JvdXAubmFtZS5zbGljZSgxKSldKTtcblxuICAgIGlmICghZ3JvdXAucGFyZW50SXNTdXBTdWIpIHtcbiAgICAgIC8vIEFwcGVuZCBhbiBpbnZpc2libGUgPG1vPiZBcHBseUZ1bmN0aW9uOzwvbW8+LlxuICAgICAgLy8gcmVmOiBodHRwczovL3d3dy53My5vcmcvVFIvUkVDLU1hdGhNTC9jaGFwM18yLmh0bWwjc2VjMy4yLjRcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcbiAgICAgIGNvbnN0IHJvdyA9IFtub2RlLCBvcGVyYXRvcl07XG4gICAgICAvLyBTZXQgc3BhY2luZ1xuICAgICAgaWYgKGdyb3VwLm5lZWRzTGVhZGluZ1NwYWNlKSB7XG4gICAgICAgIGNvbnN0IGxlYWQgPSBuZXcgTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIGxlYWQuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgICAgcm93LnVuc2hpZnQobGVhZCk7XG4gICAgICB9XG4gICAgICBpZiAoIWdyb3VwLmlzRm9sbG93ZWRCeURlbGltaXRlcikge1xuICAgICAgICBjb25zdCB0cmFpbCA9IG5ldyBNYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgICAgdHJhaWwuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgICAgcm93LnB1c2godHJhaWwpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1yb3dcIiwgcm93KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IHNpbmdsZUNoYXJCaWdPcHMgPSB7XG4gIFwiXFx1MjIwRlwiOiBcIlxcXFxwcm9kXCIsXG4gIFwiXFx1MjIxMFwiOiBcIlxcXFxjb3Byb2RcIixcbiAgXCJcXHUyMjExXCI6IFwiXFxcXHN1bVwiLFxuICBcIlxcdTIyYzBcIjogXCJcXFxcYmlnd2VkZ2VcIixcbiAgXCJcXHUyMmMxXCI6IFwiXFxcXGJpZ3ZlZVwiLFxuICBcIlxcdTIyYzJcIjogXCJcXFxcYmlnY2FwXCIsXG4gIFwiXFx1MjJjM1wiOiBcIlxcXFxiaWdjdXBcIixcbiAgXCJcXHUyYTAwXCI6IFwiXFxcXGJpZ29kb3RcIixcbiAgXCJcXHUyYTAxXCI6IFwiXFxcXGJpZ29wbHVzXCIsXG4gIFwiXFx1MmEwMlwiOiBcIlxcXFxiaWdvdGltZXNcIixcbiAgXCJcXHUyYTA0XCI6IFwiXFxcXGJpZ3VwbHVzXCIsXG4gIFwiXFx1MmEwNVwiOiBcIlxcXFxiaWdzcWNhcFwiLFxuICBcIlxcdTJhMDZcIjogXCJcXFxcYmlnc3FjdXBcIixcbiAgXCJcXHUyYTAzXCI6IFwiXFxcXGJpZ2N1cGRvdFwiLFxuICBcIlxcdTJhMDdcIjogXCJcXFxcYmlnZG91YmxldmVlXCIsXG4gIFwiXFx1MmEwOFwiOiBcIlxcXFxiaWdkb3VibGV3ZWRnZVwiLFxuICBcIlxcdTJhMDlcIjogXCJcXFxcYmlndGltZXNcIlxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcY29wcm9kXCIsXG4gICAgXCJcXFxcYmlndmVlXCIsXG4gICAgXCJcXFxcYmlnd2VkZ2VcIixcbiAgICBcIlxcXFxiaWd1cGx1c1wiLFxuICAgIFwiXFxcXGJpZ2N1cHBsdXNcIixcbiAgICBcIlxcXFxiaWdjdXBkb3RcIixcbiAgICBcIlxcXFxiaWdjYXBcIixcbiAgICBcIlxcXFxiaWdjdXBcIixcbiAgICBcIlxcXFxiaWdkb3VibGV2ZWVcIixcbiAgICBcIlxcXFxiaWdkb3VibGV3ZWRnZVwiLFxuICAgIFwiXFxcXGludG9wXCIsXG4gICAgXCJcXFxccHJvZFwiLFxuICAgIFwiXFxcXHN1bVwiLFxuICAgIFwiXFxcXGJpZ290aW1lc1wiLFxuICAgIFwiXFxcXGJpZ29wbHVzXCIsXG4gICAgXCJcXFxcYmlnb2RvdFwiLFxuICAgIFwiXFxcXGJpZ3NxY2FwXCIsXG4gICAgXCJcXFxcYmlnc3FjdXBcIixcbiAgICBcIlxcXFxiaWd0aW1lc1wiLFxuICAgIFwiXFxcXHNtYWxsaW50XCIsXG4gICAgXCJcXHUyMjBGXCIsXG4gICAgXCJcXHUyMjEwXCIsXG4gICAgXCJcXHUyMjExXCIsXG4gICAgXCJcXHUyMmMwXCIsXG4gICAgXCJcXHUyMmMxXCIsXG4gICAgXCJcXHUyMmMyXCIsXG4gICAgXCJcXHUyMmMzXCIsXG4gICAgXCJcXHUyYTAwXCIsXG4gICAgXCJcXHUyYTAxXCIsXG4gICAgXCJcXHUyYTAyXCIsXG4gICAgXCJcXHUyYTA0XCIsXG4gICAgXCJcXHUyYTA2XCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGxldCBmTmFtZSA9IGZ1bmNOYW1lO1xuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckJpZ09wc1tmTmFtZV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSwgLy8gVGhpcyBpcyB0cnVlIGZvciBcXHN0YWNrcmVse30sIG5vdCBoZXJlLlxuICAgICAgbmFtZTogZk5hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBOb3RlOiBjYWxsaW5nIGRlZmluZUZ1bmN0aW9uIHdpdGggYSB0eXBlIHRoYXQncyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBvbmx5XG4vLyB3b3JrcyBiZWNhdXNlIHRoZSBzYW1lIG1hdGhtbEJ1aWxkZXIgaXMgYmVpbmcgdXNlZC5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhvcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIC8vIEl0IHdvdWxkIGJlIGNvbnZpZW5pZW50IHRvIGp1c3Qgd3JhcCBhIDxtbz4gYXJvdW5kIHRoZSBhcmd1bWVudC5cbiAgICAvLyBCdXQgaWYgdGhlIGFyZ3VtZW50IGlzIGEgPG1pPiBvciA8bW9yZD4sIHRoYXQgd291bGQgYmUgaW52YWxpZCBNYXRoTUwuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBpbnN0ZWFkIHByb21vdGUgdGhlIHRleHQgY29udGVudHMgb2YgdGhlIGJvZHkgdG8gdGhlIHBhcmVudC5cbiAgICBjb25zdCBhcnIgPSAoYm9keS5ib2R5KSA/IGJvZHkuYm9keSA6IFtib2R5XTtcbiAgICBjb25zdCBpc1N5bWJvbCA9IGFyci5sZW5ndGggPT09IDEgJiYgb3JkQXRvbVR5cGVzLmluY2x1ZGVzKGFyclswXS50eXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGlzU3ltYm9sLFxuICAgICAgZnJvbU1hdGhPcDogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIG5hbWU6IGlzU3ltYm9sID8gYXJyWzBdLnRleHQgOiBudWxsLFxuICAgICAgYm9keTogaXNTeW1ib2wgPyBudWxsIDogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBUaGVyZSBhcmUgMiBmbGFncyBmb3Igb3BlcmF0b3JzOyB3aGV0aGVyIHRoZXkgcHJvZHVjZSBsaW1pdHMgaW5cbi8vIGRpc3BsYXlzdHlsZSwgYW5kIHdoZXRoZXIgdGhleSBhcmUgc3ltYm9scyBhbmQgc2hvdWxkIGdyb3cgaW5cbi8vIGRpc3BsYXlzdHlsZS4gVGhlc2UgZm91ciBncm91cHMgY292ZXIgdGhlIGZvdXIgcG9zc2libGUgY2hvaWNlcy5cblxuY29uc3Qgc2luZ2xlQ2hhckludGVncmFscyA9IHtcbiAgXCJcXHUyMjJiXCI6IFwiXFxcXGludFwiLFxuICBcIlxcdTIyMmNcIjogXCJcXFxcaWludFwiLFxuICBcIlxcdTIyMmRcIjogXCJcXFxcaWlpbnRcIixcbiAgXCJcXHUyMjJlXCI6IFwiXFxcXG9pbnRcIixcbiAgXCJcXHUyMjJmXCI6IFwiXFxcXG9paW50XCIsXG4gIFwiXFx1MjIzMFwiOiBcIlxcXFxvaWlpbnRcIixcbiAgXCJcXHUyMjMxXCI6IFwiXFxcXGludGNsb2Nrd2lzZVwiLFxuICBcIlxcdTIyMzJcIjogXCJcXFxcdmFyb2ludGNsb2Nrd2lzZVwiLFxuICBcIlxcdTJhMGNcIjogXCJcXFxcaWlpaW50XCIsXG4gIFwiXFx1MmEwZFwiOiBcIlxcXFxpbnRiYXJcIixcbiAgXCJcXHUyYTBlXCI6IFwiXFxcXGludEJhclwiLFxuICBcIlxcdTJhMGZcIjogXCJcXFxcZmludFwiLFxuICBcIlxcdTJhMTJcIjogXCJcXFxccnBwb2xpbnRcIixcbiAgXCJcXHUyYTEzXCI6IFwiXFxcXHNjcG9saW50XCIsXG4gIFwiXFx1MmExNVwiOiBcIlxcXFxwb2ludGludFwiLFxuICBcIlxcdTJhMTZcIjogXCJcXFxcc3FpbnRcIixcbiAgXCJcXHUyYTE3XCI6IFwiXFxcXGludGxhcmhrXCIsXG4gIFwiXFx1MmExOFwiOiBcIlxcXFxpbnR4XCIsXG4gIFwiXFx1MmExOVwiOiBcIlxcXFxpbnRjYXBcIixcbiAgXCJcXHUyYTFhXCI6IFwiXFxcXGludGN1cFwiXG59O1xuXG4vLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxhcmNzaW5cIixcbiAgICBcIlxcXFxhcmNjb3NcIixcbiAgICBcIlxcXFxhcmN0YW5cIixcbiAgICBcIlxcXFxhcmN0Z1wiLFxuICAgIFwiXFxcXGFyY2N0Z1wiLFxuICAgIFwiXFxcXGFyZ1wiLFxuICAgIFwiXFxcXGNoXCIsXG4gICAgXCJcXFxcY29zXCIsXG4gICAgXCJcXFxcY29zZWNcIixcbiAgICBcIlxcXFxjb3NoXCIsXG4gICAgXCJcXFxcY290XCIsXG4gICAgXCJcXFxcY290Z1wiLFxuICAgIFwiXFxcXGNvdGhcIixcbiAgICBcIlxcXFxjc2NcIixcbiAgICBcIlxcXFxjdGdcIixcbiAgICBcIlxcXFxjdGhcIixcbiAgICBcIlxcXFxkZWdcIixcbiAgICBcIlxcXFxkaW1cIixcbiAgICBcIlxcXFxleHBcIixcbiAgICBcIlxcXFxob21cIixcbiAgICBcIlxcXFxrZXJcIixcbiAgICBcIlxcXFxsZ1wiLFxuICAgIFwiXFxcXGxuXCIsXG4gICAgXCJcXFxcbG9nXCIsXG4gICAgXCJcXFxcc2VjXCIsXG4gICAgXCJcXFxcc2luXCIsXG4gICAgXCJcXFxcc2luaFwiLFxuICAgIFwiXFxcXHNoXCIsXG4gICAgXCJcXFxcc2duXCIsXG4gICAgXCJcXFxcdGFuXCIsXG4gICAgXCJcXFxcdGFuaFwiLFxuICAgIFwiXFxcXHRnXCIsXG4gICAgXCJcXFxcdGhcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGNvbnN0IHByZXZBdG9tVHlwZSA9IHBhcnNlci5wcmV2QXRvbVR5cGU7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIGlzRm9sbG93ZWRCeURlbGltaXRlcjogaXNEZWxpbWl0ZXIobmV4dCksXG4gICAgICBuZWVkc0xlYWRpbmdTcGFjZTogcHJldkF0b21UeXBlLmxlbmd0aCA+IDAgJiYgb3JkVHlwZXMuaW5jbHVkZXMocHJldkF0b21UeXBlKSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQyXG59KTtcblxuLy8gTGltaXRzLCBub3Qgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGV0XCIsIFwiXFxcXGdjZFwiLCBcIlxcXFxpbmZcIiwgXCJcXFxcbGltXCIsIFwiXFxcXG1heFwiLCBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGNvbnN0IHByZXZBdG9tVHlwZSA9IHBhcnNlci5wcmV2QXRvbVR5cGU7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyOiBpc0RlbGltaXRlcihuZXh0KSxcbiAgICAgIG5lZWRzTGVhZGluZ1NwYWNlOiBwcmV2QXRvbVR5cGUubGVuZ3RoID4gMCAmJiBvcmRUeXBlcy5pbmNsdWRlcyhwcmV2QXRvbVR5cGUpLFxuICAgICAgbmFtZTogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBObyBsaW1pdHMsIHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGludFwiLFxuICAgIFwiXFxcXGlpbnRcIixcbiAgICBcIlxcXFxpaWludFwiLFxuICAgIFwiXFxcXGlpaWludFwiLFxuICAgIFwiXFxcXG9pbnRcIixcbiAgICBcIlxcXFxvaWludFwiLFxuICAgIFwiXFxcXG9paWludFwiLFxuICAgIFwiXFxcXGludGNsb2Nrd2lzZVwiLFxuICAgIFwiXFxcXHZhcm9pbnRjbG9ja3dpc2VcIixcbiAgICBcIlxcXFxpbnRiYXJcIixcbiAgICBcIlxcXFxpbnRCYXJcIixcbiAgICBcIlxcXFxmaW50XCIsXG4gICAgXCJcXFxccnBwb2xpbnRcIixcbiAgICBcIlxcXFxzY3BvbGludFwiLFxuICAgIFwiXFxcXHBvaW50aW50XCIsXG4gICAgXCJcXFxcc3FpbnRcIixcbiAgICBcIlxcXFxpbnRsYXJoa1wiLFxuICAgIFwiXFxcXGludHhcIixcbiAgICBcIlxcXFxpbnRjYXBcIixcbiAgICBcIlxcXFxpbnRjdXBcIixcbiAgICBcIlxcdTIyMmJcIixcbiAgICBcIlxcdTIyMmNcIixcbiAgICBcIlxcdTIyMmRcIixcbiAgICBcIlxcdTIyMmVcIixcbiAgICBcIlxcdTIyMmZcIixcbiAgICBcIlxcdTIyMzBcIixcbiAgICBcIlxcdTIyMzFcIixcbiAgICBcIlxcdTIyMzJcIixcbiAgICBcIlxcdTJhMGNcIixcbiAgICBcIlxcdTJhMGRcIixcbiAgICBcIlxcdTJhMGVcIixcbiAgICBcIlxcdTJhMGZcIixcbiAgICBcIlxcdTJhMTJcIixcbiAgICBcIlxcdTJhMTNcIixcbiAgICBcIlxcdTJhMTVcIixcbiAgICBcIlxcdTJhMTZcIixcbiAgICBcIlxcdTJhMTdcIixcbiAgICBcIlxcdTJhMThcIixcbiAgICBcIlxcdTJhMTlcIixcbiAgICBcIlxcdTJhMWFcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGxldCBmTmFtZSA9IGZ1bmNOYW1lO1xuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckludGVncmFsc1tmTmFtZV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBzdGFjazogZmFsc2UsXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMlxufSk7XG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGJ1aWxkZXJzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5XG4vLyBcIm9wZXJhdG9ybmFtZVwiLCBidXQgYWxzbyAgXCJzdXBzdWJcIiBzaW5jZSBcXG9wZXJhdG9ybmFtZSogY2FuXG4vLyBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxuXG5jb25zdCBtYXRobWxCdWlsZGVyJDEgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGxldCBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlLndpdGhGb250KFwibWF0aHJtXCIpKTtcblxuICAvLyBJcyBleHByZXNzaW9uIGEgc3RyaW5nIG9yIGhhcyBpdCBzb21ldGhpbmcgbGlrZSBhIGZyYWN0aW9uP1xuICBsZXQgaXNBbGxTdHJpbmcgPSB0cnVlOyAvLyBkZWZhdWx0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBub2RlID0gZXhwcmVzc2lvbltpXTtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuTWF0aE5vZGUpIHtcbiAgICAgIGlmICgobm9kZS50eXBlID09PSBcIm1yb3dcIiB8fCBub2RlLnR5cGUgPT09IFwibXBhZGRlZFwiKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgIG5vZGUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBtYXRoTUxUcmVlLk1hdGhOb2RlKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1pXCI6XG4gICAgICAgIGNhc2UgXCJtblwiOlxuICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgY2FzZSBcIm10ZXh0XCI6XG4gICAgICAgICAgYnJlYWs7IC8vIERvIG5vdGhpbmcgeWV0LlxuICAgICAgICBjYXNlIFwibXNwYWNlXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5vZGUuYXR0cmlidXRlcy53aWR0aCkge1xuICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IG5vZGUuYXR0cmlidXRlcy53aWR0aC5yZXBsYWNlKFwiZW1cIiwgXCJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IGNoID0gc3BhY2VDaGFyYWN0ZXIoTnVtYmVyKHdpZHRoKSk7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbltpXSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKGNoKV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgXCJtb1wiOiB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuVGV4dE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1xcdTIyMTIvLCBcIi1cIikucmVwbGFjZSgvXFx1MjIxNy8sIFwiKlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzQWxsU3RyaW5nKSB7XG4gICAgLy8gV3JpdGUgYSBzaW5nbGUgVGV4dE5vZGUgaW5zdGVhZCBvZiBtdWx0aXBsZSBuZXN0ZWQgdGFncy5cbiAgICBjb25zdCB3b3JkID0gZXhwcmVzc2lvbi5tYXAoKG5vZGUpID0+IG5vZGUudG9UZXh0KCkpLmpvaW4oXCJcIik7XG4gICAgZXhwcmVzc2lvbiA9IFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh3b3JkKV07XG4gIH0gZWxzZSBpZiAoXG4gICAgZXhwcmVzc2lvbi5sZW5ndGggPT09IDFcbiAgICAmJiBbXCJtb3ZlclwiLCBcIm11bmRlclwiXS5pbmNsdWRlcyhleHByZXNzaW9uWzBdLnR5cGUpICYmXG4gICAgKGV4cHJlc3Npb25bMF0uY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJtaVwiIHx8IGV4cHJlc3Npb25bMF0uY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJtdGV4dFwiKVxuICApIHtcbiAgICBleHByZXNzaW9uWzBdLmNoaWxkcmVuWzBdLnR5cGUgPSBcIm1pXCI7XG4gICAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGV4cHJlc3Npb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuICAgICAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChbZXhwcmVzc2lvblswXSwgb3BlcmF0b3JdKVxuICAgIH1cbiAgfVxuXG4gIGxldCB3cmFwcGVyO1xuICBpZiAoaXNBbGxTdHJpbmcpIHtcbiAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBleHByZXNzaW9uKTtcbiAgICBpZiAoZXhwcmVzc2lvblswXS50ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm5vcm1hbFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKTtcbiAgfVxuXG4gIGlmICghZ3JvdXAucGFyZW50SXNTdXBTdWIpIHtcbiAgICAvLyBBcHBlbmQgYW4gPG1vPiZBcHBseUZ1bmN0aW9uOzwvbW8+LlxuICAgIC8vIHJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL1JFQy1NYXRoTUwvY2hhcDNfMi5odG1sI3NlYzMuMi40XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBbd3JhcHBlciwgb3BlcmF0b3JdO1xuICAgIGlmIChncm91cC5uZWVkc0xlYWRpbmdTcGFjZSkge1xuICAgICAgLy8gTGFUZVggZ2l2ZXMgb3BlcmF0b3Igc3BhY2luZywgYnV0IGEgPG1pPiBnZXRzIG9yZCBzcGFjaW5nLlxuICAgICAgLy8gU28gYWRkIGEgbGVhZGluZyBzcGFjZS5cbiAgICAgIGNvbnN0IHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICBzcGFjZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgZnJhZ21lbnQudW5zaGlmdChzcGFjZSk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuaXNGb2xsb3dlZEJ5RGVsaW1pdGVyKSB7XG4gICAgICBjb25zdCB0cmFpbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgdHJhaWwuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgIGZyYWdtZW50LnB1c2godHJhaWwpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KGZyYWdtZW50KVxuICB9XG5cbiAgcmV0dXJuIHdyYXBwZXJcbn07XG5cbi8vIFxcb3BlcmF0b3JuYW1lXG4vLyBhbXNvcG4uZHR4OiBcXG1hdGhvcHsjMVxca2VyblxcekBcXG9wZXJhdG9yQGZvbnQjM31cXG5ld21jb2Rlc0BcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcGVyYXRvcm5hbWVcIixcbiAgbmFtZXM6IFtcIlxcXFxvcGVyYXRvcm5hbWVAXCIsIFwiXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICBjb25zdCBwcmV2QXRvbVR5cGUgPSBwYXJzZXIucHJldkF0b21UeXBlO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BlcmF0b3JuYW1lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiAoZnVuY05hbWUgPT09IFwiXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcIiksXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyOiBpc0RlbGltaXRlcihuZXh0KSxcbiAgICAgIG5lZWRzTGVhZGluZ1NwYWNlOiBwcmV2QXRvbVR5cGUubGVuZ3RoID4gMCAmJiBvcmRUeXBlcy5pbmNsdWRlcyhwcmV2QXRvbVR5cGUpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxXG59KTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcb3BlcmF0b3JuYW1lXCIsXG4gIFwiXFxcXEBpZnN0YXJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1xcXFxvcGVyYXRvcm5hbWVAXCIpO1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJvcmRncm91cFwiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgc3R5bGUsIGdyb3VwLnNlbWlzaW1wbGUpO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFxwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXGhwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24ob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIHN0eWxlKTtcbiAgICBjb25zdCBwaGFudG9tID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcGhhbnRvbV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidnBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFx2cGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ2cGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKG9yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBzdHlsZSk7XG4gICAgY29uc3QgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLy8gSW4gTGFUZVgsIFxccG1iIGlzIGEgc2ltdWxhdGlvbiBvZiBib2xkIGZvbnQuXG4vLyBUaGUgdmVyc2lvbiBvZiBcXHBtYiBpbiBhbWJzeS5zdHkgd29ya3MgYnkgdHlwZXNldHRpbmcgdGhyZWUgY29waWVzIG9mIHRoZSBhcmd1bWVudFxuLy8gd2l0aCBzbWFsbCBvZmZzZXRzLiBXZSB1c2UgQ1NTIGZvbnQtd2VpZ2h0OmJvbGQuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJwbWJcIixcbiAgbmFtZXM6IFtcIlxcXFxwbWJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBtYlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChhcmdzWzBdKVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSk7XG4gICAgLy8gV3JhcCB3aXRoIGFuIDxtc3R5bGU+IGVsZW1lbnQuXG4gICAgY29uc3Qgbm9kZSA9IHdyYXBXaXRoTXN0eWxlKGlubmVyKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZm9udC13ZWlnaHQ6Ym9sZFwiKTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gXFxyYWlzZSwgXFxsb3dlciwgYW5kIFxccmFpc2Vib3hcblxuY29uc3QgbWF0aG1sQnVpbGRlciA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5URVhUKTtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG5ld1N0eWxlKV0pO1xuICBjb25zdCBkeSA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZHksIHN0eWxlKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIGR5Lm51bWJlciArIGR5LnVuaXQpO1xuICAvLyBBZGQgcGFkZGluZywgd2hpY2ggYWN0cyB0byBpbmNyZWFzZSBoZWlnaHQgaW4gQ2hyb21pdW0uXG4gIC8vIFRPRE86IEZpZ3VyZSBvdXQgc29tZSB3YXkgdG8gY2hhbmdlIGhlaWdodCBpbiBGaXJlZm94IHcvbyBicmVha2luZyBDaHJvbWl1bS5cbiAgaWYgKGR5Lm51bWJlciA+IDApIHtcbiAgICBub2RlLnN0eWxlLnBhZGRpbmcgPSBkeS5udW1iZXIgKyBkeS51bml0ICsgXCIgMCAwIDBcIjtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnN0eWxlLnBhZGRpbmcgPSBcIjAgMCBcIiArIE1hdGguYWJzKGR5Lm51bWJlcikgKyBkeS51bml0ICsgXCIgMFwiO1xuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmFpc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxyYWlzZVwiLCBcIlxcXFxsb3dlclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwicHJpbWl0aXZlXCJdLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYW1vdW50ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlO1xuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcbG93ZXJcIikgeyBhbW91bnQubnVtYmVyICo9IC0xOyB9XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmFpc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZHk6IGFtb3VudCxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyXG59KTtcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmFpc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxyYWlzZWJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBhbW91bnQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWU7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmFpc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZHk6IGFtb3VudCxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJlZlwiLFxuICBuYW1lczogW1wiXFxcXHJlZlwiLCBcIlxcXFxlcXJlZlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHN0cmluZzogYXJnc1swXS5zdHJpbmcucmVwbGFjZShpbnZhbGlkSWRSZWdFeCwgXCJcIilcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIENyZWF0ZSBhbiBlbXB0eSA8YT4gbm9kZS4gU2V0IGEgY2xhc3MgYW5kIGFuIGhyZWYgYXR0cmlidXRlLlxuICAgIC8vIFRoZSBwb3N0LXByb2Nlc3NvciB3aWxsIHBvcHVsYXRlIHdpdGggdGhlIHRhcmdldCdzIHRhZyBvciBlcXVhdGlvbiBudW1iZXIuXG4gICAgY29uc3QgY2xhc3NlcyA9IGdyb3VwLmZ1bmNOYW1lID09PSBcIlxcXFxyZWZcIiA/IFtcInRtbC1yZWZcIl0gOiBbXCJ0bWwtcmVmXCIsIFwidG1sLWVxcmVmXCJdO1xuICAgIHJldHVybiBuZXcgQW5jaG9yTm9kZShcIiNcIiArIGdyb3VwLnN0cmluZywgY2xhc3NlcywgbnVsbClcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJyZWZsZWN0XCIsXG4gIG5hbWVzOiBbXCJcXFxccmVmbGVjdGJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmVmbGVjdFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBub2RlID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIHN0eWxlKTtcbiAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGVYKC0xKVwiO1xuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxyZWxheFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJydWxlXCIsXG4gIG5hbWVzOiBbXCJcXFxccnVsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIiwgXCJzaXplXCIsIFwic2l6ZVwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBzaGlmdCA9IG9wdEFyZ3NbMF07XG4gICAgY29uc3Qgd2lkdGggPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIik7XG4gICAgY29uc3QgaGVpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJzaXplXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJ1bGVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc2hpZnQ6IHNoaWZ0ICYmIGFzc2VydE5vZGVUeXBlKHNoaWZ0LCBcInNpemVcIikudmFsdWUsXG4gICAgICB3aWR0aDogd2lkdGgudmFsdWUsXG4gICAgICBoZWlnaHQ6IGhlaWdodC52YWx1ZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBzdHlsZSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIHN0eWxlKTtcbiAgICBjb25zdCBzaGlmdCA9IGdyb3VwLnNoaWZ0XG4gICAgICA/IGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2hpZnQsIHN0eWxlKVxuICAgICAgOiB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH07XG4gICAgY29uc3QgY29sb3IgPSAoc3R5bGUuY29sb3IgJiYgc3R5bGUuZ2V0Q29sb3IoKSkgfHwgXCJibGFja1wiO1xuXG4gICAgY29uc3QgcnVsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgIGlmICh3aWR0aC5udW1iZXIgPiAwICYmIGhlaWdodC5udW1iZXIgPiAwKSB7XG4gICAgICBydWxlLnNldEF0dHJpYnV0ZShcIm1hdGhiYWNrZ3JvdW5kXCIsIGNvbG9yKTtcbiAgICB9XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aC5udW1iZXIgKyB3aWR0aC51bml0KTtcbiAgICBydWxlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQubnVtYmVyICsgaGVpZ2h0LnVuaXQpO1xuICAgIGlmIChzaGlmdC5udW1iZXIgPT09IDApIHsgcmV0dXJuIHJ1bGUgfVxuXG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcnVsZV0pO1xuICAgIGlmIChzaGlmdC5udW1iZXIgPj0gMCkge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIrXCIgKyBzaGlmdC5udW1iZXIgKyBzaGlmdC51bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc2hpZnQubnVtYmVyICsgc2hpZnQudW5pdCk7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiK1wiICsgLXNoaWZ0Lm51bWJlciArIHNoaWZ0LnVuaXQpO1xuICAgIH1cbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgc2hpZnQubnVtYmVyICsgc2hpZnQudW5pdCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cbn0pO1xuXG4vLyBUaGUgc2l6ZSBtYXBwaW5ncyBhcmUgdGFrZW4gZnJvbSBUZVggd2l0aCBcXG5vcm1hbHNpemU9MTBwdC5cbi8vIFdlIGRvbid0IGhhdmUgdG8gdHJhY2sgc2NyaXB0IGxldmVsLiBNYXRoTUwgZG9lcyB0aGF0LlxuY29uc3Qgc2l6ZU1hcCA9IHtcbiAgXCJcXFxcdGlueVwiOiAwLjUsXG4gIFwiXFxcXHNpeHB0c2l6ZVwiOiAwLjYsXG4gIFwiXFxcXFRpbnlcIjogMC42LFxuICBcIlxcXFxzY3JpcHRzaXplXCI6IDAuNyxcbiAgXCJcXFxcZm9vdG5vdGVzaXplXCI6IDAuOCxcbiAgXCJcXFxcc21hbGxcIjogMC45LFxuICBcIlxcXFxub3JtYWxzaXplXCI6IDEuMCxcbiAgXCJcXFxcbGFyZ2VcIjogMS4yLFxuICBcIlxcXFxMYXJnZVwiOiAxLjQ0LFxuICBcIlxcXFxMQVJHRVwiOiAxLjcyOCxcbiAgXCJcXFxcaHVnZVwiOiAyLjA3NCxcbiAgXCJcXFxcSHVnZVwiOiAyLjQ4OFxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNpemluZ1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXHRpbnlcIixcbiAgICBcIlxcXFxzaXhwdHNpemVcIixcbiAgICBcIlxcXFxUaW55XCIsXG4gICAgXCJcXFxcc2NyaXB0c2l6ZVwiLFxuICAgIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLFxuICAgIFwiXFxcXHNtYWxsXCIsXG4gICAgXCJcXFxcbm9ybWFsc2l6ZVwiLFxuICAgIFwiXFxcXGxhcmdlXCIsXG4gICAgXCJcXFxcTGFyZ2VcIixcbiAgICBcIlxcXFxMQVJHRVwiLFxuICAgIFwiXFxcXGh1Z2VcIixcbiAgICBcIlxcXFxIdWdlXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgYnJlYWtPblRva2VuVGV4dCwgZnVuY05hbWUsIHBhcnNlciB9LCBhcmdzKSA9PiB7XG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QgJiYgcGFyc2VyLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coYFRlbW1sIHN0cmljdC1tb2RlIHdhcm5pbmc6IENvbW1hbmQgJHtmdW5jTmFtZX0gaXMgaW52YWxpZCBpbiBtYXRoIG1vZGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBicmVha09uVG9rZW5UZXh0LCB0cnVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaXppbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aEZvbnRTaXplKHNpemVNYXBbZ3JvdXAuZnVuY05hbWVdKTtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBuZXdTdHlsZSk7XG4gICAgLy8gV3JhcCB3aXRoIGFuIDxtc3R5bGU+IGVsZW1lbnQuXG4gICAgY29uc3Qgbm9kZSA9IHdyYXBXaXRoTXN0eWxlKGlubmVyKTtcbiAgICBjb25zdCBmYWN0b3IgPSAoc2l6ZU1hcFtncm91cC5mdW5jTmFtZV0gLyBzdHlsZS5mb250U2l6ZSkudG9GaXhlZCg0KTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIGZhY3RvciArIFwiZW1cIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vLyBzbWFzaCwgd2l0aCBvcHRpb25hbCBbdGJdLCBhcyBpbiBBTVNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNtYXNoXCIsXG4gIG5hbWVzOiBbXCJcXFxcc21hc2hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncywgb3B0QXJncykgPT4ge1xuICAgIGxldCBzbWFzaEhlaWdodCA9IGZhbHNlO1xuICAgIGxldCBzbWFzaERlcHRoID0gZmFsc2U7XG4gICAgY29uc3QgdGJBcmcgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG4gICAgaWYgKHRiQXJnKSB7XG4gICAgICAvLyBPcHRpb25hbCBbdGJdIGFyZ3VtZW50IGlzIGVuZ2FnZWQuXG4gICAgICAvLyByZWY6IGFtc21hdGg6IFxccmVuZXdjb21tYW5ke1xcc21hc2h9WzFdW3RiXXslXG4gICAgICAvLyAgICAgICAgICAgICAgIGRlZlxcbWJAdHtcXGh0fVxcZGVmXFxtYkBie1xcZHB9XFxkZWZcXG1iQHRie1xcaHRcXHpAXFx6QFxcZHB9JVxuICAgICAgbGV0IGxldHRlciA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRiQXJnLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRiQXJnLmJvZHlbaV07XG4gICAgICAgIC8vIFRPRE86IFdyaXRlIGFuIEFzc2VydFN5bWJvbE5vZGVcbiAgICAgICAgbGV0dGVyID0gbm9kZS50ZXh0O1xuICAgICAgICBpZiAobGV0dGVyID09PSBcInRcIikge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiYlwiKSB7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc21hc2hIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgICBzbWFzaERlcHRoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc21hc2hIZWlnaHQgPSB0cnVlO1xuICAgICAgc21hc2hEZXB0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic21hc2hcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIHNtYXNoSGVpZ2h0LFxuICAgICAgc21hc2hEZXB0aFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpXSk7XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hIZWlnaHQpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zbWFzaERlcHRoKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNxcnRcIixcbiAgbmFtZXM6IFtcIlxcXFxzcXJ0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IGluZGV4ID0gb3B0QXJnc1swXTtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzcXJ0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBpbmRleFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgeyBib2R5LCBpbmRleCB9ID0gZ3JvdXA7XG4gICAgcmV0dXJuIGluZGV4XG4gICAgICA/IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvb3RcIiwgW1xuICAgICAgICBidWlsZEdyb3VwJDEoYm9keSwgc3R5bGUpLFxuICAgICAgICBidWlsZEdyb3VwJDEoaW5kZXgsIHN0eWxlLmluY3JlbWVudExldmVsKCkpXG4gICAgICBdKVxuICAgIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3FydFwiLCBbYnVpbGRHcm91cCQxKGJvZHksIHN0eWxlKV0pO1xuICB9XG59KTtcblxuY29uc3Qgc3R5bGVNYXAgPSB7XG4gIGRpc3BsYXk6IDAsXG4gIHRleHQ6IDEsXG4gIHNjcmlwdDogMixcbiAgc2NyaXB0c2NyaXB0OiAzXG59O1xuXG5jb25zdCBzdHlsZUF0dHJpYnV0ZXMgPSB7XG4gIGRpc3BsYXk6IFtcIjBcIiwgXCJ0cnVlXCJdLFxuICB0ZXh0OiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gIHNjcmlwdDogW1wiMVwiLCBcImZhbHNlXCJdLFxuICBzY3JpcHRzY3JpcHQ6IFtcIjJcIiwgXCJmYWxzZVwiXVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInN0eWxpbmdcIixcbiAgbmFtZXM6IFtcIlxcXFxkaXNwbGF5c3R5bGVcIiwgXCJcXFxcdGV4dHN0eWxlXCIsIFwiXFxcXHNjcmlwdHN0eWxlXCIsIFwiXFxcXHNjcmlwdHNjcmlwdHN0eWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IGJyZWFrT25Ub2tlblRleHQsIGZ1bmNOYW1lLCBwYXJzZXIgfSwgYXJncykge1xuICAgIC8vIHBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keVxuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQsIHRydWUpO1xuXG4gICAgY29uc3Qgc2NyaXB0TGV2ZWwgPSBmdW5jTmFtZS5zbGljZSgxLCBmdW5jTmFtZS5sZW5ndGggLSA1KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzY3JpcHRMZXZlbCB0byB1c2UgYnkgcHVsbGluZyBvdXQgdGhlIHNjcmlwdExldmVsIGZyb21cbiAgICAgIC8vIHRoZSBmdW5jdGlvbiBuYW1lXG4gICAgICBzY3JpcHRMZXZlbCxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzY3JpcHRMZXZlbCB3ZSdyZSBjaGFuZ2luZyB0by5cbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlLndpdGhMZXZlbChzdHlsZU1hcFtncm91cC5zY3JpcHRMZXZlbF0pO1xuICAgIC8vIFRoZSBzdHlsZSBhcmd1bWVudCBpbiB0aGUgbmV4dCBsaW5lIGRvZXMgTk9UIGRpcmVjdGx5IHNldCBhIE1hdGhNTCBzY3JpcHQgbGV2ZWwuXG4gICAgLy8gSXQganVzdCB0cmFja3MgdGhlIHN0eWxlIGxldmVsLCBpbiBjYXNlIHdlIG5lZWQgdG8ga25vdyBpdCBmb3Igc3Vwc3ViIG9yIG1hdGhjaG9pY2UuXG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3U3R5bGUpO1xuICAgIC8vIFdyYXAgd2l0aCBhbiA8bXN0eWxlPiBlbGVtZW50LlxuICAgIGNvbnN0IG5vZGUgPSB3cmFwV2l0aE1zdHlsZShpbm5lcik7XG5cbiAgICBjb25zdCBhdHRyID0gc3R5bGVBdHRyaWJ1dGVzW2dyb3VwLnNjcmlwdExldmVsXTtcblxuICAgIC8vIEhlcmUgaXMgd2hlcmUgd2Ugc2V0IHRoZSBNYXRoTUwgc2NyaXB0IGxldmVsLlxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG5cbi8vIEhlbHBlcnNcbmNvbnN0IHN5bWJvbFJlZ0V4ID0gL15tKG92ZXJ8dW5kZXJ8dW5kZXJvdmVyKSQvO1xuXG4vLyBTdXBlciBzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLCB3aG9zZSBwcmVjaXNlIHBsYWNlbWVudCBjYW4gZGVwZW5kIG9uIG90aGVyXG4vLyBmdW5jdGlvbnMgdGhhdCBwcmVjZWRlIHRoZW0uXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJzdXBzdWJcIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBJcyB0aGUgaW5uZXIgZ3JvdXAgYSByZWxldmFudCBob3Jpem9udGFsIGJyYWNlP1xuICAgIGxldCBpc0JyYWNlID0gZmFsc2U7XG4gICAgbGV0IGlzT3ZlcjtcbiAgICBsZXQgaXNTdXA7XG4gICAgbGV0IGFwcGVuZEFwcGx5RnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgYXBwZW5kU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgbmVlZHNMZWFkaW5nU3BhY2UgPSBmYWxzZTtcblxuICAgIGlmIChncm91cC5iYXNlICYmIGdyb3VwLmJhc2UudHlwZSA9PT0gXCJob3JpekJyYWNlXCIpIHtcbiAgICAgIGlzU3VwID0gISFncm91cC5zdXA7XG4gICAgICBpZiAoaXNTdXAgPT09IGdyb3VwLmJhc2UuaXNPdmVyKSB7XG4gICAgICAgIGlzQnJhY2UgPSB0cnVlO1xuICAgICAgICBpc092ZXIgPSBncm91cC5iYXNlLmlzT3ZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiAhZ3JvdXAuYmFzZS5zdGFjayAmJlxuICAgICAgKGdyb3VwLmJhc2UudHlwZSA9PT0gXCJvcFwiIHx8IGdyb3VwLmJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIikpIHtcbiAgICAgIGdyb3VwLmJhc2UucGFyZW50SXNTdXBTdWIgPSB0cnVlO1xuICAgICAgYXBwZW5kQXBwbHlGdW5jdGlvbiA9ICFncm91cC5iYXNlLnN5bWJvbDtcbiAgICAgIGFwcGVuZFNwYWNlID0gYXBwZW5kQXBwbHlGdW5jdGlvbiAmJiAhZ3JvdXAuaXNGb2xsb3dlZEJ5RGVsaW1pdGVyO1xuICAgICAgbmVlZHNMZWFkaW5nU3BhY2UgPSBncm91cC5iYXNlLm5lZWRzTGVhZGluZ1NwYWNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnN0YWNrXG4gICAgICA/IFtidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZS5ib2R5WzBdLCBzdHlsZSldXG4gICAgICA6IFtidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgc3R5bGUpXTtcblxuICAgIC8vIE5vdGUgcmVnYXJkaW5nIHNjcmlwdHN0eWxlIGxldmVsLlxuICAgIC8vIChTdWJ8c3VwZXIpc2NyaXB0cyBzaG91bGQgbm90IHNocmluayBiZXlvbmQgTWF0aE1MIHNjcmlwdGxldmVsIDIgYWthIFxcc2NyaXB0c2NyaXB0c3R5bGVcbiAgICAvLyBSZWY6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tYXRobWwtY29yZS8jdGhlLWRpc3BsYXlzdHlsZS1hbmQtc2NyaXB0bGV2ZWwtYXR0cmlidXRlc1xuICAgIC8vIChCVFcsIE1hdGhNTCBzY3JpcHRsZXZlbCAyIGlzIGVxdWFsIHRvIFRlbW1sIGxldmVsIDMuKVxuICAgIC8vIEJ1dCBDaHJvbWl1bSBjb250aW51ZXMgdG8gc2hyaW5rIHRoZSAoc3VifHN1cGVyKXNjcmlwdHMuIFNvIHdlIGV4cGxpY2l0bHkgc2V0IHNjcmlwdGxldmVsIDIuXG5cbiAgICBjb25zdCBjaGlsZFN0eWxlID0gc3R5bGUuaW5TdWJPclN1cCgpO1xuICAgIGlmIChncm91cC5zdWIpIHtcbiAgICAgIGNvbnN0IHN1YiA9IGJ1aWxkR3JvdXAkMShncm91cC5zdWIsIGNoaWxkU3R5bGUpO1xuICAgICAgaWYgKHN0eWxlLmxldmVsID09PSAzKSB7IHN1Yi5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjJcIik7IH1cbiAgICAgIGNoaWxkcmVuLnB1c2goc3ViKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc3VwKSB7XG4gICAgICBjb25zdCBzdXAgPSBidWlsZEdyb3VwJDEoZ3JvdXAuc3VwLCBjaGlsZFN0eWxlKTtcbiAgICAgIGlmIChzdHlsZS5sZXZlbCA9PT0gMykgeyBzdXAuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIyXCIpOyB9XG4gICAgICBjb25zdCB0ZXN0Tm9kZSA9IHN1cC50eXBlID09PSBcIm1yb3dcIiA/IHN1cC5jaGlsZHJlblswXSA6IHN1cDtcbiAgICAgIGlmICgodGVzdE5vZGUgJiYgdGVzdE5vZGUudHlwZSA9PT0gXCJtb1wiICYmIHRlc3ROb2RlLmNsYXNzZXMuaW5jbHVkZXMoXCJ0bWwtcHJpbWVcIikpXG4gICAgICAgICYmIGdyb3VwLmJhc2UgJiYgZ3JvdXAuYmFzZS50ZXh0ICYmIFwiZkZcIi5pbmRleE9mKGdyb3VwLmJhc2UudGV4dCkgPiAtMSkge1xuICAgICAgICAvLyBDaHJvbWl1bSBkb2VzIG5vdCBhZGRyZXNzIGl0YWxpYyBjb3JyZWN0aW9uIG9uIHByaW1lLiAgUHJldmVudCBm4oCyIGZyb20gb3ZlcmxhcHBpbmcuXG4gICAgICAgIHRlc3ROb2RlLmNsYXNzZXMucHVzaChcInByaW1lLXBhZFwiKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnB1c2goc3VwKTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZVR5cGU7XG4gICAgaWYgKGlzQnJhY2UpIHtcbiAgICAgIG5vZGVUeXBlID0gaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIjtcbiAgICB9IGVsc2UgaWYgKCFncm91cC5zdWIpIHtcbiAgICAgIGNvbnN0IGJhc2UgPSBncm91cC5iYXNlO1xuICAgICAgaWYgKFxuICAgICAgICBiYXNlICYmXG4gICAgICAgIGJhc2UudHlwZSA9PT0gXCJvcFwiICYmXG4gICAgICAgIGJhc2UubGltaXRzICYmXG4gICAgICAgIChzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtb3ZlclwiO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgYmFzZSAmJlxuICAgICAgICBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiZcbiAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiZcbiAgICAgICAgKGJhc2UubGltaXRzIHx8IHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1vdmVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1cFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1cCkge1xuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmJhc2U7XG4gICAgICBpZiAoXG4gICAgICAgIGJhc2UgJiZcbiAgICAgICAgYmFzZS50eXBlID09PSBcIm9wXCIgJiZcbiAgICAgICAgYmFzZS5saW1pdHMgJiZcbiAgICAgICAgKHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlclwiO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgYmFzZSAmJlxuICAgICAgICBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiZcbiAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiZcbiAgICAgICAgKGJhc2UubGltaXRzIHx8IHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmJhc2U7XG4gICAgICBpZiAoYmFzZSAmJiAoKGJhc2UudHlwZSA9PT0gXCJvcFwiICYmIGJhc2UubGltaXRzKSB8fCBiYXNlLnR5cGUgPT09IFwibXVsdGlzY3JpcHRcIikgJiZcbiAgICAgICAgKHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGJhc2UgJiZcbiAgICAgICAgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmXG4gICAgICAgIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmXG4gICAgICAgIChzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZIHx8IGJhc2UubGltaXRzKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJvdmVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YnN1cFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoYXBwZW5kQXBwbHlGdW5jdGlvbikge1xuICAgICAgLy8gQXBwZW5kIGFuIDxtbz4mQXBwbHlGdW5jdGlvbjs8L21vPi5cbiAgICAgIC8vIHJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL1JFQy1NYXRoTUwvY2hhcDNfMi5odG1sI3NlYzMuMi40XG4gICAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcbiAgICAgIGlmIChuZWVkc0xlYWRpbmdTcGFjZSkge1xuICAgICAgICBjb25zdCBzcGFjZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgICBzcGFjZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgICBub2RlID0gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KFtzcGFjZSwgbm9kZSwgb3BlcmF0b3JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoW25vZGUsIG9wZXJhdG9yXSk7XG4gICAgICB9XG4gICAgICBpZiAoYXBwZW5kU3BhY2UpIHtcbiAgICAgICAgY29uc3Qgc3BhY2UgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgICAgc3BhY2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHNwYWNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN5bWJvbFJlZ0V4LnRlc3Qobm9kZVR5cGUpKSB7XG4gICAgICAvLyBXcmFwIGluIGEgPG1yb3c+LiBPdGhlcndpc2UgRmlyZWZveCBzdHJldGNoeSBwYXJlbnMgd2lsbCBub3Qgc3RyZXRjaCB0byBpbmNsdWRlIGxpbWl0cy5cbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW25vZGVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gT3BlcmF0b3IgUGFyc2VOb2RlcyBjcmVhdGVkIGluIFBhcnNlci5qcyBmcm9tIHN5bWJvbCBHcm91cHMgaW4gc3JjL3N5bWJvbHMuanMuXG5cbmNvbnN0IHNob3J0ID0gW1wiXFxcXHNob3J0bWlkXCIsIFwiXFxcXG5zaG9ydG1pZFwiLCBcIlxcXFxzaG9ydHBhcmFsbGVsXCIsXG4gIFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIsIFwiXFxcXHNtYWxsc2V0bWludXNcIl07XG5cbmNvbnN0IGFycm93cyA9IFtcIlxcXFxSc2hcIiwgXCJcXFxcTHNoXCIsIFwiXFxcXHJlc3RyaWN0aW9uXCJdO1xuXG5jb25zdCBpc0Fycm93ID0gc3RyID0+IHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoMCk7XG4gICAgcmV0dXJuICgweDIxOGYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgyMjAwKVxuICB9XG4gIHJldHVybiBzdHIuaW5kZXhPZihcImFycm93XCIpID4gLTEgfHwgc3RyLmluZGV4T2YoXCJoYXJwb29uXCIpID4gLTEgfHwgYXJyb3dzLmluY2x1ZGVzKHN0cilcbn07XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcImF0b21cIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSldKTtcbiAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcInB1bmN0XCIpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2VwYXJhdG9yXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJvcGVuXCIgfHwgZ3JvdXAuZmFtaWx5ID09PSBcImNsb3NlXCIpIHtcbiAgICAgIC8vIERlbGltcyBidWlsdCBoZXJlIHNob3VsZCBub3Qgc3RyZXRjaCB2ZXJ0aWNhbGx5LlxuICAgICAgLy8gU2VlIGRlbGltc2l6aW5nLmpzIGZvciBzdHJldGNoeSBkZWxpbXMuXG4gICAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcIm9wZW5cIikge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwcmVmaXhcIik7XG4gICAgICAgIC8vIFNldCBhbiBleHBsaWNpdCBhdHRyaWJ1dGUgZm9yIHN0cmV0Y2guIE90aGVyd2lzZSBGaXJlZm94IG1heSBkbyBpdCB3cm9uZy5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwiY2xvc2VcIikge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwb3N0Zml4XCIpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChncm91cC50ZXh0ID09PSBcIlxcXFxtaWRcIikge1xuICAgICAgLy8gRmlyZWZveCBtZXNzZXMgdXAgdGhpcyBzcGFjaW5nIGlmIGF0IHRoZSBlbmQgb2YgYW4gPG1yb3c+LiBTZWUgaXQgZXhwbGljaXRseS5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMC4yMmVtXCIpOyAvLyBtZWRpdW0gc3BhY2VcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMC4yMmVtXCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcInJlbFwiICYmIGlzQXJyb3coZ3JvdXAudGV4dCkpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJmYWxzZVwiKTtcbiAgICB9IGVsc2UgaWYgKHNob3J0LmluY2x1ZGVzKGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIFwiNzAlXCIpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudGV4dCA9PT0gXCI6XCIpIHtcbiAgICAgIC8vIFwiOlwiIGlzIG5vdCBpbiB0aGUgTWF0aE1MIG9wZXJhdG9yIGRpY3Rpb25hcnkuIEdpdmUgaXQgQklOIHNwYWNpbmcuXG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjIyMjJlbVwiO1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMC4yMjIyZW1cIjtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm5lZWRzU3BhY2luZykge1xuICAgICAgLy8gRml4IGEgTWF0aE1MIGJ1ZyB0aGF0IG9jY3VycyB3aGVuIGEgPG1vPiBpcyBiZXR3ZWVuIHR3byA8bXRleHQ+IGVsZW1lbnRzLlxuICAgICAgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJiaW5cIikge1xuICAgICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtwYWRkaW5nJDEoMC4yMjIpLCBub2RlLCBwYWRkaW5nJDEoMC4yMjIpXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJFTCBzcGFjaW5nXG4gICAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW3BhZGRpbmckMSgwLjI3NzgpLCBub2RlLCBwYWRkaW5nJDEoMC4yNzc4KV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLyoqXG4gKiBNYXBzIFRlWCBmb250IGNvbW1hbmRzIHRvIFwibWF0aHZhcmlhbnRcIiBhdHRyaWJ1dGUgaW4gYnVpbGRNYXRoTUwuanNcbiAqL1xuY29uc3QgZm9udE1hcCA9IHtcbiAgLy8gc3R5bGVzXG4gIG1hdGhiZjogXCJib2xkXCIsXG4gIG1hdGhybTogXCJub3JtYWxcIixcbiAgdGV4dGl0OiBcIml0YWxpY1wiLFxuICBtYXRoaXQ6IFwiaXRhbGljXCIsXG4gIG1hdGhub3JtYWw6IFwiaXRhbGljXCIsXG5cbiAgLy8gZmFtaWxpZXNcbiAgbWF0aGJiOiBcImRvdWJsZS1zdHJ1Y2tcIixcbiAgbWF0aGNhbDogXCJzY3JpcHRcIixcbiAgbWF0aGZyYWs6IFwiZnJha3R1clwiLFxuICBtYXRoc2NyOiBcInNjcmlwdFwiLFxuICBtYXRoc2Y6IFwic2Fucy1zZXJpZlwiLFxuICBtYXRodHQ6IFwibW9ub3NwYWNlXCJcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF0aCB2YXJpYW50IGFzIGEgc3RyaW5nIG9yIG51bGwgaWYgbm9uZSBpcyByZXF1aXJlZC5cbiAqL1xuY29uc3QgZ2V0VmFyaWFudCA9IGZ1bmN0aW9uKGdyb3VwLCBzdHlsZSkge1xuICAvLyBIYW5kbGUgZm9udCBzcGVjaWZpZXJzIGFzIGJlc3Qgd2UgY2FuLlxuICAvLyBDaHJvbWl1bSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBNYXRoTUwgbWF0aHZhcmlhbnQgYXR0cmlidXRlLlxuICAvLyBTbyB3ZSdsbCB1c2UgVW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGluc3RlYWQuXG4gIC8vIEJ1dCBmaXJzdCwgZGV0ZXJtaW5lIHRoZSBtYXRoIHZhcmlhbnQuXG5cbiAgLy8gRGVhbCB3aXRoIHRoZSBcXHRleHRpdCwgXFx0ZXh0YmYsIGV0Yy4sIGZ1bmN0aW9ucy5cbiAgaWYgKHN0eWxlLmZvbnRGYW1pbHkgPT09IFwidGV4dHR0XCIpIHtcbiAgICByZXR1cm4gXCJtb25vc3BhY2VcIlxuICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRGYW1pbHkgPT09IFwidGV4dHNjXCIpIHtcbiAgICByZXR1cm4gXCJub3JtYWxcIjsgLy8gaGFuZGxlZCB2aWEgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbiBpbiBzeW1ib2xzT3JkLmpzLlxuICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRGYW1pbHkgPT09IFwidGV4dHNmXCIpIHtcbiAgICBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiICYmIHN0eWxlLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIlxuICAgIH0gZWxzZSBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWl0YWxpY1wiXG4gICAgfSBlbHNlIGlmIChzdHlsZS5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWJvbGRcIlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmXCJcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiICYmIHN0eWxlLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiXG4gIH0gZWxzZSBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgcmV0dXJuIFwiaXRhbGljXCJcbiAgfSBlbHNlIGlmIChzdHlsZS5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZFwiXG4gIH1cblxuICAvLyBEZWFsIHdpdGggdGhlIFxcbWF0aGl0LCBtYXRoYmYsIGV0YywgZnVuY3Rpb25zLlxuICBjb25zdCBmb250ID0gc3R5bGUuZm9udDtcbiAgaWYgKCFmb250IHx8IGZvbnQgPT09IFwibWF0aG5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IG1vZGUgPSBncm91cC5tb2RlO1xuICBzd2l0Y2ggKGZvbnQpIHtcbiAgICBjYXNlIFwibWF0aGl0XCI6XG4gICAgICByZXR1cm4gXCJpdGFsaWNcIlxuICAgIGNhc2UgXCJtYXRocm1cIjoge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gZ3JvdXAudGV4dC5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIC8vIExhVGVYIFxcbWF0aHJtIHJldHVybnMgaXRhbGljIGZvciBHcmVlayBjaGFyYWN0ZXJzLlxuICAgICAgcmV0dXJuICAoMHgwM2FiIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MDNjZikgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIlxuICAgIH1cbiAgICBjYXNlIFwiZ3JlZWtJdGFsaWNcIjpcbiAgICAgIHJldHVybiBcIml0YWxpY1wiXG4gICAgY2FzZSBcInVwQGdyZWVrXCI6XG4gICAgICByZXR1cm4gXCJub3JtYWxcIlxuICAgIGNhc2UgXCJib2xkc3ltYm9sXCI6XG4gICAgY2FzZSBcIm1hdGhib2xkc3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiXG4gICAgY2FzZSBcIm1hdGhiZlwiOlxuICAgICAgcmV0dXJuIFwiYm9sZFwiXG4gICAgY2FzZSBcIm1hdGhiYlwiOlxuICAgICAgcmV0dXJuIFwiZG91YmxlLXN0cnVja1wiXG4gICAgY2FzZSBcIm1hdGhmcmFrXCI6XG4gICAgICByZXR1cm4gXCJmcmFrdHVyXCJcbiAgICBjYXNlIFwibWF0aHNjclwiOlxuICAgIGNhc2UgXCJtYXRoY2FsXCI6XG4gICAgICByZXR1cm4gXCJzY3JpcHRcIlxuICAgIGNhc2UgXCJtYXRoc2ZcIjpcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWZcIlxuICAgIGNhc2UgXCJtYXRoc2ZpdFwiOlxuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1pdGFsaWNcIlxuICAgIGNhc2UgXCJtYXRodHRcIjpcbiAgICAgIHJldHVybiBcIm1vbm9zcGFjZVwiXG4gIH1cblxuICBsZXQgdGV4dCA9IGdyb3VwLnRleHQ7XG4gIGlmIChzeW1ib2xzW21vZGVdW3RleHRdICYmIHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZSkge1xuICAgIHRleHQgPSBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2U7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvbnRNYXAsIGZvbnQpID8gZm9udE1hcFtmb250XSA6IG51bGxcbn07XG5cbi8vIENocm9taXVtIGRvZXMgbm90IHN1cHBvcnQgdGhlIE1hdGhNTCBgbWF0aHZhcmlhbnRgIGF0dHJpYnV0ZS5cbi8vIEluc3RlYWQsIHdlIHJlcGxhY2UgQVNDSUkgY2hhcmFjdGVycyB3aXRoIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0XG4vLyBhcmUgZGVmaW5lZCBpbiB0aGUgZm9udCBhcyBib2xkLCBpdGFsaWMsIGRvdWJsZS1zdHJ1Y2ssIGV0Yy5cbi8vIFRoaXMgbW9kdWxlIGlkZW50aWZpZXMgdGhvc2UgVW5pY29kZSBjb2RlIHBvaW50cy5cblxuLy8gRmlyc3QsIGEgZmV3IGhlbHBlcnMuXG5jb25zdCBzY3JpcHQgPSBPYmplY3QuZnJlZXplKHtcbiAgQjogMHgyMEVBLCAvLyBPZmZzZXQgZnJvbSBBU0NJSSBCIHRvIFVuaWNvZGUgc2NyaXB0IEJcbiAgRTogMHgyMEVCLFxuICBGOiAweDIwRUIsXG4gIEg6IDB4MjBDMyxcbiAgSTogMHgyMEM3LFxuICBMOiAweDIwQzYsXG4gIE06IDB4MjBFNixcbiAgUjogMHgyMEM5LFxuICBlOiAweDIwQ0EsXG4gIGc6IDB4MjBBMyxcbiAgbzogMHgyMEM1XG59KTtcblxuY29uc3QgZnJhayA9IE9iamVjdC5mcmVlemUoe1xuICBDOiAweDIwRUEsXG4gIEg6IDB4MjBDNCxcbiAgSTogMHgyMEM4LFxuICBSOiAweDIwQ0EsXG4gIFo6IDB4MjBDRVxufSk7XG5cbmNvbnN0IGJiYiA9IE9iamVjdC5mcmVlemUoe1xuICBDOiAweDIwQkYsIC8vIGJsYWNrYm9hcmQgYm9sZFxuICBIOiAweDIwQzUsXG4gIE46IDB4MjBDNyxcbiAgUDogMHgyMEM5LFxuICBROiAweDIwQzksXG4gIFI6IDB4MjBDQixcbiAgWjogMHgyMENBXG59KTtcblxuY29uc3QgYm9sZCA9IE9iamVjdC5mcmVlemUoe1xuICBcIlxcdTAzZjVcIjogMHgxRDJFNywgLy8gbHVuYXRlIGVwc2lsb25cbiAgXCJcXHUwM2QxXCI6IDB4MUQzMEMsIC8vIHZhcnRoZXRhXG4gIFwiXFx1MDNmMFwiOiAweDFEMkVFLCAvLyB2YXJrYXBwYVxuICBcIlxcdTAzYzZcIjogMHgxRDMxOSwgLy8gdmFycGhpXG4gIFwiXFx1MDNmMVwiOiAweDFEMkVGLCAvLyB2YXJyaG9cbiAgXCJcXHUwM2Q2XCI6IDB4MUQzMEIgIC8vIHZhcnBpXG59KTtcblxuY29uc3QgYm9sZEl0YWxpYyA9IE9iamVjdC5mcmVlemUoe1xuICBcIlxcdTAzZjVcIjogMHgxRDM1QiwgLy8gbHVuYXRlIGVwc2lsb25cbiAgXCJcXHUwM2QxXCI6IDB4MUQzODAsIC8vIHZhcnRoZXRhXG4gIFwiXFx1MDNmMFwiOiAweDFEMzYyLCAvLyB2YXJrYXBwYVxuICBcIlxcdTAzYzZcIjogMHgxRDM4RCwgLy8gdmFycGhpXG4gIFwiXFx1MDNmMVwiOiAweDFEMzYzLCAvLyB2YXJyaG9cbiAgXCJcXHUwM2Q2XCI6IDB4MUQzN0YgIC8vIHZhcnBpXG59KTtcblxuY29uc3QgYm9sZHNmID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFwiXFx1MDNmNVwiOiAweDFEMzk1LCAvLyBsdW5hdGUgZXBzaWxvblxuICBcIlxcdTAzZDFcIjogMHgxRDNCQSwgLy8gdmFydGhldGFcbiAgXCJcXHUwM2YwXCI6IDB4MUQzOUMsIC8vIHZhcmthcHBhXG4gIFwiXFx1MDNjNlwiOiAweDFEM0M3LCAvLyB2YXJwaGlcbiAgXCJcXHUwM2YxXCI6IDB4MUQzOUQsIC8vIHZhcnJob1xuICBcIlxcdTAzZDZcIjogMHgxRDNCOSAgLy8gdmFycGlcbn0pO1xuXG5jb25zdCBiaXNmID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFwiXFx1MDNmNVwiOiAweDFEM0NGLCAvLyBsdW5hdGUgZXBzaWxvblxuICBcIlxcdTAzZDFcIjogMHgxRDNGNCwgLy8gdmFydGhldGFcbiAgXCJcXHUwM2YwXCI6IDB4MUQzRDYsIC8vIHZhcmthcHBhXG4gIFwiXFx1MDNjNlwiOiAweDFENDAxLCAvLyB2YXJwaGlcbiAgXCJcXHUwM2YxXCI6IDB4MUQzRDcsIC8vIHZhcnJob1xuICBcIlxcdTAzZDZcIjogMHgxRDNGMyAgLy8gdmFycGlcbn0pO1xuXG4vLyBDb2RlIHBvaW50IG9mZnNldHMgYmVsb3cgYXJlIGRlcml2ZWQgZnJvbSBodHRwczovL3d3dy51bmljb2RlLm9yZy9jaGFydHMvUERGL1UxRDQwMC5wZGZcbmNvbnN0IG9mZnNldCA9IE9iamVjdC5mcmVlemUoe1xuICB1cHBlckNhc2VMYXRpbjogeyAvLyBBLVpcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEM0JGIH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzRjMgfSxcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMHgxRDQyNyB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiBzY3JpcHRbY2hdIHx8IDB4MUQ0NUIgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMHgxRDQ4RiB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiBmcmFrW2NoXSB8fCAweDFENEMzIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDB4MUQ1MkIgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gYmJiW2NoXSB8fCAweDFENEY3IH0sXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ1NUYgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDU5MyB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAweDFENUM3IH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDB4MUQ2M0MgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDYyRiB9XG4gIH0sXG4gIGxvd2VyQ2FzZUxhdGluOiB7IC8vIGEtelxuICAgIFwibm9ybWFsXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkXCI6IGNoID0+ICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzQjkgfSxcbiAgICBcIml0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gY2ggPT09IFwiaFwiID8gMHgyMEE2IDogMHgxRDNFRCB9LFxuICAgIFwiYm9sZC1pdGFsaWNcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAweDFENDIxIH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIHNjcmlwdFtjaF0gfHwgMHgxRDQ1NSB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAweDFENDg5IH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ0QkQgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMHgxRDUyNSB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAweDFENEYxIH0sXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ1NTkgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDU4RCB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAweDFENUMxIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDB4MUQ1RjUgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDYyOSB9XG4gIH0sXG4gIHVwcGVyQ2FzZUdyZWVrOiB7IC8vIEEtzqlcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEMzE3IH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzNTEgfSxcbiAgICAvLyBcXGJvbGRzeW1ib2wgYWN0dWFsbHkgcmV0dXJucyB1cHJpZ2h0IGJvbGQgZm9yIHVwcGVyQ2FzZUdyZWVrXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzMTcgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgLy8gVW5pY29kZSBoYXMgbm8gY29kZSBwb2ludHMgZm9yIHJlZ3VsYXItd2VpZ2h0IHNhbi1zZXJpZiBHcmVlay4gVXNlIGJvbGQuXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzQzUgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDNDNSB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDB4MUQzRkYgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMCB9XG4gIH0sXG4gIGxvd2VyQ2FzZUdyZWVrOiB7IC8vIM6xLc+JXG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDMxMSB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEMzRCIH0sXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIGNoID09PSBcIlxcdTAzZDVcIiA/IDB4MUQzN0UgOiAweDFEMzg1IH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIC8vIFVuaWNvZGUgaGFzIG5vIGNvZGUgcG9pbnRzIGZvciByZWd1bGFyLXdlaWdodCBzYW4tc2VyaWYgR3JlZWsuIFVzZSBib2xkLlxuICAgIFwic2Fucy1zZXJpZlwiOiBjaCA9PiAgICAgICAgICAgICB7IHJldHVybiAweDFEM0JGIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIDB4MUQzQkYgfSxcbiAgICBcInNhbnMtc2VyaWYtaXRhbGljXCI6IGNoID0+ICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiOiBjaCA9PiB7IHJldHVybiAweDFEM0Y5IH0sXG4gICAgXCJtb25vc3BhY2VcIjogY2ggPT4gICAgICAgICAgICAgIHsgcmV0dXJuIDAgfVxuICB9LFxuICB2YXJHcmVlazogeyAvLyBcXHZhckdhbW1hLCBldGNcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAgYm9sZFtjaF0gfHwgLTUxIH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gYm9sZEl0YWxpY1tjaF0gfHwgMHgzQSB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzY3JpcHQtYm9sZFwiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXJcIjogY2ggPT4gICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1ci1ib2xkXCI6IGNoID0+ICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJkb3VibGUtc3RydWNrXCI6IGNoID0+ICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNhbnMtc2VyaWZcIjogY2ggPT4gICAgICAgICAgICAgeyByZXR1cm4gYm9sZHNmW2NoXSB8fCAweDc0IH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIGJvbGRzZltjaF0gfHwgMHg3NCB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIGJpc2ZbY2hdIHx8IDB4QUUgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMCB9XG4gIH0sXG4gIG51bWVyYWw6IHsgLy8gMC05XG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDc5RSB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAweDFEN0E4IH0sXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ3QjIgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDdCQyB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDAgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDdDNiB9XG4gIH1cbn0pO1xuXG5jb25zdCB2YXJpYW50Q2hhciA9IChjaCwgdmFyaWFudCkgPT4ge1xuICBjb25zdCBjb2RlUG9pbnQgPSBjaC5jb2RlUG9pbnRBdCgwKTtcbiAgY29uc3QgYmxvY2sgPSAweDQwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4NWJcbiAgICA/IFwidXBwZXJDYXNlTGF0aW5cIlxuICAgIDogMHg2MCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDdiXG4gICAgPyBcImxvd2VyQ2FzZUxhdGluXCJcbiAgICA6ICgweDM5MCAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgzQUEpXG4gICAgPyBcInVwcGVyQ2FzZUdyZWVrXCJcbiAgICA6IDB4M0IwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4M0NBIHx8IGNoID09PSBcIlxcdTAzZDVcIlxuICAgID8gXCJsb3dlckNhc2VHcmVla1wiXG4gICAgOiAweDFENkUxIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MUQ2RkMgIHx8IGJvbGRbY2hdXG4gICAgPyBcInZhckdyZWVrXCJcbiAgICA6ICgweDJGIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8ICAweDNBKVxuICAgID8gXCJudW1lcmFsXCJcbiAgICA6IFwib3RoZXJcIjtcbiAgcmV0dXJuIGJsb2NrID09PSBcIm90aGVyXCJcbiAgICA/IGNoXG4gICAgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQgKyBvZmZzZXRbYmxvY2tdW3ZhcmlhbnRdKGNoKSlcbn07XG5cbmNvbnN0IHNtYWxsQ2FwcyA9IE9iamVjdC5mcmVlemUoe1xuICBhOiBcIuG0gFwiLFxuICBiOiBcIsqZXCIsXG4gIGM6IFwi4bSEXCIsXG4gIGQ6IFwi4bSFXCIsXG4gIGU6IFwi4bSHXCIsXG4gIGY6IFwi6pywXCIsXG4gIGc6IFwiyaJcIixcbiAgaDogXCLKnFwiLFxuICBpOiBcIsmqXCIsXG4gIGo6IFwi4bSKXCIsXG4gIGs6IFwi4bSLXCIsXG4gIGw6IFwiyp9cIixcbiAgbTogXCLhtI1cIixcbiAgbjogXCLJtFwiLFxuICBvOiBcIuG0j1wiLFxuICBwOiBcIuG0mFwiLFxuICBxOiBcIserXCIsXG4gIHI6IFwiyoBcIixcbiAgczogXCJzXCIsXG4gIHQ6IFwi4bSbXCIsXG4gIHU6IFwi4bScXCIsXG4gIHY6IFwi4bSgXCIsXG4gIHc6IFwi4bShXCIsXG4gIHg6IFwieFwiLFxuICB5OiBcIsqPXCIsXG4gIHo6IFwi4bSiXCJcbn0pO1xuXG4vLyBcIm1hdGhvcmRcIiBhbmQgXCJ0ZXh0b3JkXCIgUGFyc2VOb2RlcyBjcmVhdGVkIGluIFBhcnNlci5qcyBmcm9tIHN5bWJvbCBHcm91cHMgaW5cbi8vIHNyYy9zeW1ib2xzLmpzLlxuXG5jb25zdCBudW1iZXJSZWdFeCA9IC9eXFxkKD86W1xcZCwuXSpcXGQpPyQvO1xuY29uc3QgbGF0aW5SZWdFeCA9IC9bQS1CYS16XS87XG5jb25zdCBwcmltZXMgPSBuZXcgU2V0KFtcIlxcXFxwcmltZVwiLCBcIlxcXFxkcHJpbWVcIiwgXCJcXFxcdHJwcmltZVwiLCBcIlxcXFxxcHJpbWVcIixcbiAgXCJcXFxcYmFja3ByaW1lXCIsIFwiXFxcXGJhY2tkcHJpbWVcIiwgXCJcXFxcYmFja3RycHJpbWVcIl0pO1xuXG5jb25zdCBpdGFsaWNOdW1iZXIgPSAodGV4dCwgdmFyaWFudCwgdGFnKSA9PiB7XG4gIGNvbnN0IG1uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUodGFnLCBbdGV4dF0pO1xuICBjb25zdCB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW21uXSk7XG4gIHdyYXBwZXIuc3R5bGVbXCJmb250LXN0eWxlXCJdID0gXCJpdGFsaWNcIjtcbiAgd3JhcHBlci5zdHlsZVtcImZvbnQtZmFtaWx5XCJdID0gXCJDYW1icmlhLCAnVGltZXMgTmV3IFJvbWFuJywgc2VyaWZcIjtcbiAgaWYgKHZhcmlhbnQgPT09IFwiYm9sZC1pdGFsaWNcIikgeyB3cmFwcGVyLnN0eWxlW1wiZm9udC13ZWlnaHRcIl0gPSBcImJvbGRcIjsgfVxuICByZXR1cm4gd3JhcHBlclxufTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwibWF0aG9yZFwiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IHRleHQgPSBtYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBzdHlsZSk7XG4gICAgY29uc3QgY29kZVBvaW50ID0gdGV4dC50ZXh0LmNvZGVQb2ludEF0KDApO1xuICAgIC8vIFRlc3QgZm9yIHVwcGVyLWNhc2UgR3JlZWtcbiAgICBjb25zdCBkZWZhdWx0VmFyaWFudCA9ICgweDAzOTAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgwM2FhKSA/IFwibm9ybWFsXCIgOiBcIml0YWxpY1wiO1xuICAgIGNvbnN0IHZhcmlhbnQgPSBnZXRWYXJpYW50KGdyb3VwLCBzdHlsZSkgfHwgZGVmYXVsdFZhcmlhbnQ7XG4gICAgaWYgKHZhcmlhbnQgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBbdGV4dF0sIFtzdHlsZS5mb250XSlcbiAgICB9IGVsc2UgaWYgKHZhcmlhbnQgIT09IFwiaXRhbGljXCIpIHtcbiAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBbdGV4dF0pO1xuICAgIC8vIFRPRE86IEhhbmRsZSBVKzFENDlDIC0gVSsxRDRDRiBwZXIgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG4gICAgaWYgKHZhcmlhbnQgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJub3JtYWxcIik7XG4gICAgICBpZiAodGV4dC50ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBBIEZpcmVmb3ggYnVnIHdpbGwgYXBwbHkgc3BhY2luZyBoZXJlLCBidXQgdGhlcmUgc2hvdWxkIGJlIG5vbmUuIEZpeCBpdC5cbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbbm9kZV0pO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjBcIik7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInRleHRvcmRcIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBsZXQgY2ggPSBncm91cC50ZXh0O1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoLmNvZGVQb2ludEF0KDApO1xuICAgIGlmIChzdHlsZS5mb250RmFtaWx5ID09PSBcInRleHRzY1wiKSB7XG4gICAgICAvLyBDb252ZXJ0IHNtYWxsIGxhdGluIGxldHRlcnMgdG8gc21hbGwgY2Fwcy5cbiAgICAgIGlmICg5NiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAxMjMpIHtcbiAgICAgICAgY2ggPSBzbWFsbENhcHNbY2hdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gbWFrZVRleHQoY2gsIGdyb3VwLm1vZGUsIHN0eWxlKTtcbiAgICBjb25zdCB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgc3R5bGUpIHx8IFwibm9ybWFsXCI7XG5cbiAgICBsZXQgbm9kZTtcbiAgICBpZiAobnVtYmVyUmVnRXgudGVzdChncm91cC50ZXh0KSkge1xuICAgICAgY29uc3QgdGFnID0gZ3JvdXAubW9kZSA9PT0gXCJ0ZXh0XCIgPyBcIm10ZXh0XCIgOiBcIm1uXCI7XG4gICAgICBpZiAodmFyaWFudCA9PT0gXCJpdGFsaWNcIiB8fCB2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0YWxpY051bWJlcih0ZXh0LCB2YXJpYW50LCB0YWcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFyaWFudCAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIHRleHQudGV4dCA9IHRleHQudGV4dC5zcGxpdChcIlwiKS5tYXAoYyA9PiB2YXJpYW50Q2hhcihjLCB2YXJpYW50KSkuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUodGFnLCBbdGV4dF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmICh2YXJpYW50ICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAocHJpbWVzLmhhcyhncm91cC50ZXh0KSkge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHRdKTtcbiAgICAgIC8vIFRPRE86IElmL3doZW4gQ2hyb21pdW0gdXNlcyBzc3R5IHZhcmlhbnQgZm9yIHByaW1lLCByZW1vdmUgdGhlIG5leHQgbGluZS5cbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLXByaW1lXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmlnVGV4dCA9IHRleHQudGV4dDtcbiAgICAgIGlmICh2YXJpYW50ICE9PSBcIml0YWxpY1wiKSB7XG4gICAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBbdGV4dF0pO1xuICAgICAgaWYgKHRleHQudGV4dCA9PT0gb3JpZ1RleHQgJiYgbGF0aW5SZWdFeC50ZXN0KG9yaWdUZXh0KSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwiaXRhbGljXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gQSBtYXAgb2YgQ1NTLWJhc2VkIHNwYWNpbmcgZnVuY3Rpb25zIHRvIHRoZWlyIENTUyBjbGFzcy5cbmNvbnN0IGNzc1NwYWNlID0ge1xuICBcIlxcXFxub2JyZWFrXCI6IFwibm9icmVha1wiLFxuICBcIlxcXFxhbGxvd2JyZWFrXCI6IFwiYWxsb3dicmVha1wiXG59O1xuXG4vLyBBIGxvb2t1cCB0YWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNwYWNpbmcgZnVuY3Rpb24vc3ltYm9sIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBsaWtlIGEgcmVndWxhciBzcGFjZSBjaGFyYWN0ZXIuICBJZiBhIHN5bWJvbCBvciBjb21tYW5kIGlzIGEga2V5XG4vLyBpbiB0aGlzIHRhYmxlLCB0aGVuIGl0IHNob3VsZCBiZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgRnVydGhlcm1vcmUsXG4vLyB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBtYXkgaGF2ZSBhIGBjbGFzc05hbWVgIHNwZWNpZnlpbmcgYW4gZXh0cmEgQ1NTIGNsYXNzXG4vLyB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgYHNwYW5gLlxuY29uc3QgcmVndWxhclNwYWNlID0ge1xuICBcIiBcIjoge30sXG4gIFwiXFxcXCBcIjoge30sXG4gIFwiflwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9LFxuICBcIlxcXFxzcGFjZVwiOiB7fSxcbiAgXCJcXFxcbm9icmVha3NwYWNlXCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH1cbn07XG5cbi8vIFBhcnNlTm9kZTxcInNwYWNpbmdcIj4gY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSB0aGUgXCJzcGFjaW5nXCIgc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJzcGFjaW5nXCIsXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZ3VsYXJTcGFjZSwgZ3JvdXAudGV4dCkpIHtcbiAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgcmVuZGVyIGEgc3BhY2UgaW4gYSA8bXRleHQ+IDwvbXRleHQ+LiBTbyB3cml0ZSBhIG5vLWJyZWFrIHNwYWNlLlxuICAgICAgLy8gVE9ETzogSWYgRmlyZWZveCBmaXhlcyB0aGF0IGJ1ZywgdW5jb21tZW50IHRoZSBuZXh0IGxpbmUgYW5kIHdyaXRlIGNoIGludG8gdGhlIG5vZGUuXG4gICAgICAvL2NvbnN0IGNoID0gKHJlZ3VsYXJTcGFjZVtncm91cC50ZXh0XS5jbGFzc05hbWUgPT09IFwibm9icmVha1wiKSA/IFwiXFx1MDBhMFwiIDogXCIgXCJcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTAwYTBcIildKTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjc3NTcGFjZSwgZ3JvdXAudGV4dCkpIHtcbiAgICAgIC8vIE1hdGhNTCAzLjAgY2FsbHMgZm9yIG5vYnJlYWsgdG8gb2NjdXIgaW4gYW4gPG1vPiwgbm90IGFuIDxtdGV4dD5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly93d3cudzMub3JnL01hdGgvZHJhZnQtc3BlYy9tYXRobWwuaHRtbCNjaGFwdGVyM19wcmVzbS5sYmF0dHJzXG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiKTtcbiAgICAgIGlmIChncm91cC50ZXh0ID09PSBcIlxcXFxub2JyZWFrXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5lYnJlYWtcIiwgXCJub2JyZWFrXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVW5rbm93biB0eXBlIG9mIHNwYWNlIFwiJHtncm91cC50ZXh0fVwiYClcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwidGFnXCJcbn0pO1xuXG4vLyBGb3IgYSBcXHRhZywgdGhlIHdvcmsgdXN1YWxseSBkb25lIGluIGEgbWF0aG1sQnVpbGRlciBpcyBpbnN0ZWFkIGRvbmUgaW4gYnVpbGRNYXRoTUwuanMuXG4vLyBUaGF0IHdheSwgYSBcXHRhZyBjYW4gYmUgcHVsbGVkIG91dCBvZiB0aGUgcGFyc2UgdHJlZSBhbmQgd3JhcHBlZCBhcm91bmQgdGhlIG91dGVyIG5vZGUuXG5cbi8vIE5vbi1tYXRoeSB0ZXh0LCBwb3NzaWJseSBpbiBhIGZvbnRcbmNvbnN0IHRleHRGb250RmFtaWxpZXMgPSB7XG4gIFwiXFxcXHRleHRcIjogdW5kZWZpbmVkLFxuICBcIlxcXFx0ZXh0cm1cIjogXCJ0ZXh0cm1cIixcbiAgXCJcXFxcdGV4dHNmXCI6IFwidGV4dHNmXCIsXG4gIFwiXFxcXHRleHR0dFwiOiBcInRleHR0dFwiLFxuICBcIlxcXFx0ZXh0bm9ybWFsXCI6IFwidGV4dHJtXCIsXG4gIFwiXFxcXHRleHRzY1wiOiBcInRleHRzY1wiICAgICAgLy8gc21hbGwgY2Fwc1xufTtcblxuY29uc3QgdGV4dEZvbnRXZWlnaHRzID0ge1xuICBcIlxcXFx0ZXh0YmZcIjogXCJ0ZXh0YmZcIixcbiAgXCJcXFxcdGV4dG1kXCI6IFwidGV4dG1kXCJcbn07XG5cbmNvbnN0IHRleHRGb250U2hhcGVzID0ge1xuICBcIlxcXFx0ZXh0aXRcIjogXCJ0ZXh0aXRcIixcbiAgXCJcXFxcdGV4dHVwXCI6IFwidGV4dHVwXCJcbn07XG5cbmNvbnN0IHN0eWxlV2l0aEZvbnQgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGZvbnQgPSBncm91cC5mb250O1xuICAvLyBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGEgZm9udCBmYW1pbHkgb3IgYSBmb250IHN0eWxlLlxuICBpZiAoIWZvbnQpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0gZWxzZSBpZiAodGV4dEZvbnRGYW1pbGllc1tmb250XSkge1xuICAgIHJldHVybiBzdHlsZS53aXRoVGV4dEZvbnRGYW1pbHkodGV4dEZvbnRGYW1pbGllc1tmb250XSk7XG4gIH0gZWxzZSBpZiAodGV4dEZvbnRXZWlnaHRzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIHN0eWxlLndpdGhUZXh0Rm9udFdlaWdodCh0ZXh0Rm9udFdlaWdodHNbZm9udF0pO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwiXFxcXGVtcGhcIikge1xuICAgIHJldHVybiBzdHlsZS5mb250U2hhcGUgPT09IFwidGV4dGl0XCJcbiAgICAgID8gc3R5bGUud2l0aFRleHRGb250U2hhcGUoXCJ0ZXh0dXBcIilcbiAgICAgIDogc3R5bGUud2l0aFRleHRGb250U2hhcGUoXCJ0ZXh0aXRcIilcbiAgfVxuICByZXR1cm4gc3R5bGUud2l0aFRleHRGb250U2hhcGUodGV4dEZvbnRTaGFwZXNbZm9udF0pXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICBuYW1lczogW1xuICAgIC8vIEZvbnQgZmFtaWxpZXNcbiAgICBcIlxcXFx0ZXh0XCIsXG4gICAgXCJcXFxcdGV4dHJtXCIsXG4gICAgXCJcXFxcdGV4dHNmXCIsXG4gICAgXCJcXFxcdGV4dHR0XCIsXG4gICAgXCJcXFxcdGV4dG5vcm1hbFwiLFxuICAgIFwiXFxcXHRleHRzY1wiLFxuICAgIC8vIEZvbnQgd2VpZ2h0c1xuICAgIFwiXFxcXHRleHRiZlwiLFxuICAgIFwiXFxcXHRleHRtZFwiLFxuICAgIC8vIEZvbnQgU2hhcGVzXG4gICAgXCJcXFxcdGV4dGl0XCIsXG4gICAgXCJcXFxcdGV4dHVwXCIsXG4gICAgXCJcXFxcZW1waFwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgZm9udDogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGVXaXRoRm9udChncm91cCwgc3R5bGUpO1xuICAgIGNvbnN0IG1yb3cgPSBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgbmV3U3R5bGUpO1xuICAgIHJldHVybiBjb25zb2xpZGF0ZVRleHQobXJvdylcbiAgfVxufSk7XG5cbi8vIFxcdmNlbnRlcjogIFZlcnRpY2FsbHkgY2VudGVyIHRoZSBhcmd1bWVudCBncm91cCBvbiB0aGUgbWF0aCBheGlzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmNlbnRlclwiLFxuICBuYW1lczogW1wiXFxcXHZjZW50ZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidmNlbnRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBVc2UgYSBtYXRoIHRhYmxlIHRvIGNyZWF0ZSB2ZXJ0aWNhbGx5IGNlbnRlcmVkIGNvbnRlbnQuXG4gICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSldKTtcbiAgICBtdGQuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xuICAgIGNvbnN0IG10ciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFttdGRdKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgW210cl0pXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmVyYlwiLFxuICBuYW1lczogW1wiXFxcXHZlcmJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncykge1xuICAgIC8vIFxcdmVyYiBhbmQgXFx2ZXJiKiBhcmUgZGVhbHQgd2l0aCBkaXJlY3RseSBpbiBQYXJzZXIuanMuXG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl0J3MgYmVjYXVzZSBvZiBhIGZhaWx1cmUgdG8gbWF0Y2ggdGhlIHR3byBkZWxpbWl0ZXJzXG4gICAgLy8gaW4gdGhlIHJlZ2V4IGluIExleGVyLmpzLiAgTGFUZVggcmFpc2VzIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2hlbiBcXHZlcmIgaXNcbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBsaW5lIChvciBmaWxlKS5cbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFx2ZXJiIGVuZGVkIGJ5IGVuZCBvZiBsaW5lIGluc3RlYWQgb2YgbWF0Y2hpbmcgZGVsaW1pdGVyXCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShtYWtlVmVyYihncm91cCkpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFt0ZXh0XSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm1vbm9zcGFjZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdmVyYiBncm91cCBpbnRvIGJvZHkgc3RyaW5nLlxuICpcbiAqIFxcdmVyYiogcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGFuIG9wZW4gYm94IFxcdTI0MjNcbiAqIFxcdmVyYiByZXBsYWNlcyBlYWNoIHNwYWNlIHdpdGggYSBuby1icmVhayBzcGFjZSBcXHhBMFxuICovXG5jb25zdCBtYWtlVmVyYiA9IChncm91cCkgPT4gZ3JvdXAuYm9keS5yZXBsYWNlKC8gL2csIGdyb3VwLnN0YXIgPyBcIlxcdTI0MjNcIiA6IFwiXFx4QTBcIik7XG5cbi8qKiBJbmNsdWRlIHRoaXMgdG8gZW5zdXJlIHRoYXQgYWxsIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZC4gKi9cblxuY29uc3QgZnVuY3Rpb25zID0gX2Z1bmN0aW9ucztcblxuLyoqXG4gKiBUaGUgTGV4ZXIgY2xhc3MgaGFuZGxlcyB0b2tlbml6aW5nIHRoZSBpbnB1dCBpbiB2YXJpb3VzIHdheXMuIFNpbmNlIG91clxuICogcGFyc2VyIGV4cGVjdHMgdXMgdG8gYmUgYWJsZSB0byBiYWNrdHJhY2ssIHRoZSBsZXhlciBhbGxvd3MgbGV4aW5nIGZyb20gYW55XG4gKiBnaXZlbiBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBJdHMgbWFpbiBleHBvc2VkIGZ1bmN0aW9uIGlzIHRoZSBgbGV4YCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwb3NpdGlvbiB0b1xuICogbGV4IGZyb20gYW5kIGEgdHlwZSBvZiB0b2tlbiB0byBsZXguIEl0IGRlZmVycyB0byB0aGUgYXBwcm9wcmlhdGUgYF9pbm5lckxleGBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSB2YXJpb3VzIGBfaW5uZXJMZXhgIGZ1bmN0aW9ucyBwZXJmb3JtIHRoZSBhY3R1YWwgbGV4aW5nIG9mIGRpZmZlcmVudFxuICoga2luZHMuXG4gKi9cblxuXG4vKiBUaGUgZm9sbG93aW5nIHRva2VuUmVnZXhcbiAqIC0gbWF0Y2hlcyB0eXBpY2FsIHdoaXRlc3BhY2UgKGJ1dCBub3QgTkJTUCBldGMuKSB1c2luZyBpdHMgZmlyc3QgdHdvIGdyb3Vwc1xuICogLSBkb2VzIG5vdCBtYXRjaCBhbnkgY29udHJvbCBjaGFyYWN0ZXIgXFx4MDAtXFx4MWYgZXhjZXB0IHdoaXRlc3BhY2VcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYSBiYXJlIGJhY2tzbGFzaFxuICogLSBtYXRjaGVzIGFueSBBU0NJSSBjaGFyYWN0ZXIgZXhjZXB0IHRob3NlIGp1c3QgbWVudGlvbmVkXG4gKiAtIGRvZXMgbm90IG1hdGNoIHRoZSBCTVAgcHJpdmF0ZSB1c2UgYXJlYSBcXHVFMDAwLVxcdUY4RkZcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYmFyZSBzdXJyb2dhdGUgY29kZSB1bml0c1xuICogLSBtYXRjaGVzIGFueSBCTVAgY2hhcmFjdGVyIGV4Y2VwdCBmb3IgdGhvc2UganVzdCBkZXNjcmliZWRcbiAqIC0gbWF0Y2hlcyBhbnkgdmFsaWQgVW5pY29kZSBzdXJyb2dhdGUgcGFpclxuICogLSBtYXRoY2hlcyBudW1lcmFsc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGxldHRlcnMgdGhlbiB3aGl0ZXNwYWNlXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgYW55IEJNUCBjaGFyYWN0ZXJcbiAqIENhcHR1cmluZyBncm91cHM6XG4gKiAgIFsxXSByZWd1bGFyIHdoaXRlc3BhY2VcbiAqICAgWzJdIGJhY2tzbGFzaCBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlXG4gKiAgIFszXSBhbnl0aGluZyBlbHNlLCB3aGljaCBtYXkgaW5jbHVkZTpcbiAqICAgICBbNF0gbGVmdCBjaGFyYWN0ZXIgb2YgXFx2ZXJiKlxuICogICAgIFs1XSBsZWZ0IGNoYXJhY3RlciBvZiBcXHZlcmJcbiAqICAgICBbNl0gYmFja3NsYXNoIGZvbGxvd2VkIGJ5IHdvcmQsIGV4Y2x1ZGluZyBhbnkgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICogSnVzdCBiZWNhdXNlIHRoZSBMZXhlciBtYXRjaGVzIHNvbWV0aGluZyBkb2Vzbid0IG1lYW4gaXQncyB2YWxpZCBpbnB1dDpcbiAqIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGZ1bmN0aW9uIG9yIHN5bWJvbCBkZWZpbml0aW9uLCB0aGUgUGFyc2VyIHdpbGxcbiAqIHN0aWxsIHJlamVjdCB0aGUgaW5wdXQuXG4gKi9cbmNvbnN0IHNwYWNlUmVnZXhTdHJpbmcgPSBcIlsgXFxyXFxuXFx0XVwiO1xuY29uc3QgY29udHJvbFdvcmRSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbYS16QS1aQF0rXCI7XG5jb25zdCBjb250cm9sU3ltYm9sUmVnZXhTdHJpbmcgPSBcIlxcXFxcXFxcW15cXHVEODAwLVxcdURGRkZdXCI7XG5jb25zdCBjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleFN0cmluZyA9IGAoJHtjb250cm9sV29yZFJlZ2V4U3RyaW5nfSkke3NwYWNlUmVnZXhTdHJpbmd9KmA7XG5jb25zdCBjb250cm9sU3BhY2VSZWdleFN0cmluZyA9IFwiXFxcXFxcXFwoXFxufFsgXFxyXFx0XStcXG4/KVsgXFxyXFx0XSpcIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyA9IFwiW1xcdTAzMDAtXFx1MDM2Zl1cIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleCA9IG5ldyBSZWdFeHAoYCR7Y29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nfSskYCk7XG5jb25zdCB0b2tlblJlZ2V4U3RyaW5nID1cbiAgYCgke3NwYWNlUmVnZXhTdHJpbmd9Kyl8YCArIC8vIHdoaXRlc3BhY2VcbiAgYCR7Y29udHJvbFNwYWNlUmVnZXhTdHJpbmd9fGAgKyAgLy8gd2hpdGVzcGFjZVxuICBcIihbIS1cXFxcW1xcXFxdLVxcdTIwMjdcXHUyMDJBLVxcdUQ3RkZcXHVGOTAwLVxcdUZGRkZdXCIgKyAvLyBzaW5nbGUgY29kZXBvaW50XG4gIGAke2NvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZ30qYCArIC8vIC4uLnBsdXMgYWNjZW50c1xuICBcInxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdXCIgKyAvLyBzdXJyb2dhdGUgcGFpclxuICBgJHtjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmd9KmAgKyAvLyAuLi5wbHVzIGFjY2VudHNcbiAgXCJ8XFxcXFxcXFx2ZXJiXFxcXCooW15dKS4qP1xcXFw0XCIgKyAvLyBcXHZlcmIqXG4gIFwifFxcXFxcXFxcdmVyYihbXiphLXpBLVpdKS4qP1xcXFw1XCIgKyAvLyBcXHZlcmIgdW5zdGFycmVkXG4gIGB8JHtjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleFN0cmluZ31gICsgLy8gXFxtYWNyb05hbWUgKyBzcGFjZXNcbiAgYHwke2NvbnRyb2xTeW1ib2xSZWdleFN0cmluZ30pYDsgLy8gXFxcXCwgXFwnLCBldGMuXG5cbi8qKiBNYWluIExleGVyIGNsYXNzICovXG5jbGFzcyBMZXhlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncykge1xuICAgIC8vIFNlcGFyYXRlIGFjY2VudHMgZnJvbSBjaGFyYWN0ZXJzXG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLnRva2VuUmVnZXggPSBuZXcgUmVnRXhwKHRva2VuUmVnZXhTdHJpbmcsICdnJyk7XG4gICAgLy8gQ2F0ZWdvcnkgY29kZXMuIFRoZSBsZXhlciBvbmx5IHN1cHBvcnRzIGNvbW1lbnQgY2hhcmFjdGVycyAoMTQpIGZvciBub3cuXG4gICAgLy8gTWFjcm9FeHBhbmRlciBhZGRpdGlvbmFsbHkgZGlzdGluZ3Vpc2hlcyBhY3RpdmUgKDEzKS5cbiAgICB0aGlzLmNhdGNvZGVzID0ge1xuICAgICAgXCIlXCI6IDE0LCAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgICAgXCJ+XCI6IDEzICAvLyBhY3RpdmUgY2hhcmFjdGVyXG4gICAgfTtcbiAgfVxuXG4gIHNldENhdGNvZGUoY2hhciwgY29kZSkge1xuICAgIHRoaXMuY2F0Y29kZXNbY2hhcl0gPSBjb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbGV4ZXMgYSBzaW5nbGUgdG9rZW4uXG4gICAqL1xuICBsZXgoKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgIGNvbnN0IHBvcyA9IHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXg7XG4gICAgaWYgKHBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKFwiRU9GXCIsIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHBvcykpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHRoaXMudG9rZW5SZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2guaW5kZXggIT09IHBvcykge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogJyR7aW5wdXRbcG9zXX0nYCxcbiAgICAgICAgbmV3IFRva2VuKGlucHV0W3Bvc10sIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHBvcyArIDEpKVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IG1hdGNoWzZdIHx8IG1hdGNoWzNdIHx8IChtYXRjaFsyXSA/IFwiXFxcXCBcIiA6IFwiIFwiKTtcblxuICAgIGlmICh0aGlzLmNhdGNvZGVzW3RleHRdID09PSAxNCkge1xuICAgICAgLy8gY29tbWVudCBjaGFyYWN0ZXJcbiAgICAgIGNvbnN0IG5sSW5kZXggPSBpbnB1dC5pbmRleE9mKFwiXFxuXCIsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpO1xuICAgICAgaWYgKG5sSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBpbnB1dC5sZW5ndGg7IC8vIEVPRlxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIiUgY29tbWVudCBoYXMgbm8gdGVybWluYXRpbmcgbmV3bGluZTsgTGFUZVggd291bGQgXCIgK1xuICAgICAgICAgICAgICBcImZhaWwgYmVjYXVzZSBvZiBjb21tZW50aW5nIHRoZSBlbmQgb2YgbWF0aCBtb2RlXCIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBubEluZGV4ICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCkpO1xuICB9XG59XG5cbi8qKlxuICogQSBgTmFtZXNwYWNlYCByZWZlcnMgdG8gYSBzcGFjZSBvZiBuYW1lYWJsZSB0aGluZ3MgbGlrZSBtYWNyb3Mgb3IgbGVuZ3RocyxcbiAqIHdoaWNoIGNhbiBiZSBgc2V0YCBlaXRoZXIgZ2xvYmFsbHkgb3IgbG9jYWwgdG8gYSBuZXN0ZWQgZ3JvdXAsIHVzaW5nIGFuXG4gKiB1bmRvIHN0YWNrIHNpbWlsYXIgdG8gaG93IFRlWCBpbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb25hbGl0eS5cbiAqIFBlcmZvcm1hbmNlLXdpc2UsIGBnZXRgIGFuZCBsb2NhbCBgc2V0YCB0YWtlIGNvbnN0YW50IHRpbWUsIHdoaWxlIGdsb2JhbFxuICogYHNldGAgdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gdGhlIGRlcHRoIG9mIGdyb3VwIG5lc3RpbmcuXG4gKi9cblxuXG5jbGFzcyBOYW1lc3BhY2Uge1xuICAvKipcbiAgICogQm90aCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiAgVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvZlxuICAgKiBidWlsdC1pbiBtYXBwaW5ncyB3aGljaCBuZXZlciBjaGFuZ2UuICBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiBvZiBpbml0aWFsIChnbG9iYWwtbGV2ZWwpIG1hcHBpbmdzLCB3aGljaCB3aWxsIGNvbnN0YW50bHkgY2hhbmdlXG4gICAqIGFjY29yZGluZyB0byBhbnkgZ2xvYmFsL3RvcC1sZXZlbCBgc2V0YHMgZG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1aWx0aW5zID0ge30sIGdsb2JhbE1hY3JvcyA9IHt9KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gZ2xvYmFsTWFjcm9zO1xuICAgIHRoaXMuYnVpbHRpbnMgPSBidWlsdGlucztcbiAgICB0aGlzLnVuZGVmU3RhY2sgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBuZXN0ZWQgZ3JvdXAsIGFmZmVjdGluZyBmdXR1cmUgbG9jYWwgYHNldGBzLlxuICAgKi9cbiAgYmVnaW5Hcm91cCgpIHtcbiAgICB0aGlzLnVuZGVmU3RhY2sucHVzaCh7fSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIGN1cnJlbnQgbmVzdGVkIGdyb3VwLCByZXN0b3JpbmcgdmFsdWVzIGJlZm9yZSB0aGUgZ3JvdXAgYmVnYW4uXG4gICAqL1xuICBlbmRHcm91cCgpIHtcbiAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIFwiVW5iYWxhbmNlZCBuYW1lc3BhY2UgZGVzdHJ1Y3Rpb246IGF0dGVtcHQgXCIgK1xuICAgICAgICAgIFwidG8gcG9wIGdsb2JhbCBuYW1lc3BhY2U7IHBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1Z1wiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1bmRlZnMgPSB0aGlzLnVuZGVmU3RhY2sucG9wKCk7XG4gICAgZm9yIChjb25zdCB1bmRlZiBpbiB1bmRlZnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodW5kZWZzLCB1bmRlZiApKSB7XG4gICAgICAgIGlmICh1bmRlZnNbdW5kZWZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50W3VuZGVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRbdW5kZWZdID0gdW5kZWZzW3VuZGVmXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3Qgd2hldGhlciBgbmFtZWAgaGFzIGEgZGVmaW5pdGlvbi4gIEVxdWl2YWxlbnQgdG9cbiAgICogYGdldChuYW1lKSAhPSBudWxsYC5cbiAgICovXG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1cnJlbnQsIG5hbWUgKSB8fFxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJ1aWx0aW5zLCBuYW1lICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgbmFtZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gdmFsdWUuXG4gICAqXG4gICAqIE5vdGU6IERvIG5vdCB1c2UgYGlmIChuYW1lc3BhY2UuZ2V0KC4uLikpYCB0byBkZXRlY3Qgd2hldGhlciBhIG1hY3JvXG4gICAqIGlzIGRlZmluZWQsIGFzIHRoZSBkZWZpbml0aW9uIG1heSBiZSB0aGUgZW1wdHkgc3RyaW5nIHdoaWNoIGV2YWx1YXRlc1xuICAgKiB0byBgZmFsc2VgIGluIEphdmFTY3JpcHQuICBVc2UgYGlmIChuYW1lc3BhY2UuZ2V0KC4uLikgIT0gbnVsbClgIG9yXG4gICAqIGBpZiAobmFtZXNwYWNlLmhhcyguLi4pKWAuXG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJyZW50LCBuYW1lICkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWx0aW5zW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBhbmQgb3B0aW9uYWxseSBzZXQgaXQgZ2xvYmFsbHkgdG9vLlxuICAgKiBMb2NhbCBzZXQoKSBzZXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCAod2hlbiBhcHByb3ByaWF0ZSkgYWRkcyBhbiB1bmRvXG4gICAqIG9wZXJhdGlvbiB0byB0aGUgdW5kbyBzdGFjay4gIEdsb2JhbCBzZXQoKSBtYXkgY2hhbmdlIHRoZSB1bmRvXG4gICAqIG9wZXJhdGlvbiBhdCBldmVyeSBsZXZlbCwgc28gdGFrZXMgdGltZSBsaW5lYXIgaW4gdGhlaXIgbnVtYmVyLlxuICAgKi9cbiAgc2V0KG5hbWUsIHZhbHVlLCBnbG9iYWwgPSBmYWxzZSkge1xuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIC8vIEdsb2JhbCBzZXQgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIGluIGFsbCBncm91cHMuICBTaW11bGF0ZSB0aGlzXG4gICAgICAvLyBieSBkZXN0cm95aW5nIGFueSB1bmRvcyBjdXJyZW50bHkgc2NoZWR1bGVkIGZvciB0aGlzIG5hbWUsXG4gICAgICAvLyBhbmQgYWRkaW5nIGFuIHVuZG8gd2l0aCB0aGUgKm5ldyogdmFsdWUgKGluIGNhc2UgaXQgbGF0ZXIgZ2V0c1xuICAgICAgLy8gbG9jYWxseSByZXNldCB3aXRoaW4gdGhpcyBlbnZpcm9ubWVudCkuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudW5kZWZTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhpcy51bmRlZlN0YWNrW2ldW25hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudW5kZWZTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMudW5kZWZTdGFja1t0aGlzLnVuZGVmU3RhY2subGVuZ3RoIC0gMV1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5kbyB0aGlzIHNldCBhdCBlbmQgb2YgdGhpcyBncm91cCAocG9zc2libHkgdG8gYHVuZGVmaW5lZGApLFxuICAgICAgLy8gdW5sZXNzIGFuIHVuZG8gaXMgYWxyZWFkeSBpbiBwbGFjZSwgaW4gd2hpY2ggY2FzZSB0aGF0IG9sZGVyXG4gICAgICAvLyB2YWx1ZSBpcyB0aGUgY29ycmVjdCBvbmUuXG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnVuZGVmU3RhY2tbdGhpcy51bmRlZlN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHRvcCAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvcCwgbmFtZSApKSB7XG4gICAgICAgIHRvcFtuYW1lXSA9IHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50W25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIOKAnGd1bGxldOKAnSB3aGVyZSBtYWNyb3MgYXJlIGV4cGFuZGVkXG4gKiB1bnRpbCBvbmx5IG5vbi1tYWNybyB0b2tlbnMgcmVtYWluLlxuICovXG5cblxuLy8gTGlzdCBvZiBjb21tYW5kcyB0aGF0IGFjdCBsaWtlIG1hY3JvcyBidXQgYXJlbid0IGRlZmluZWQgYXMgYSBtYWNybyxcbi8vIGZ1bmN0aW9uLCBvciBzeW1ib2wuICBVc2VkIGluIGBpc0RlZmluZWRgLlxuY29uc3QgaW1wbGljaXRDb21tYW5kcyA9IHtcbiAgXCJeXCI6IHRydWUsIC8vIFBhcnNlci5qc1xuICBfOiB0cnVlLCAvLyBQYXJzZXIuanNcbiAgXCJcXFxcbGltaXRzXCI6IHRydWUsIC8vIFBhcnNlci5qc1xuICBcIlxcXFxub2xpbWl0c1wiOiB0cnVlIC8vIFBhcnNlci5qc1xufTtcblxuY2xhc3MgTWFjcm9FeHBhbmRlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncywgbW9kZSkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ID0gMDtcbiAgICB0aGlzLmZlZWQoaW5wdXQpO1xuICAgIC8vIE1ha2UgbmV3IGdsb2JhbCBuYW1lc3BhY2VcbiAgICB0aGlzLm1hY3JvcyA9IG5ldyBOYW1lc3BhY2UobWFjcm9zLCBzZXR0aW5ncy5tYWNyb3MpO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICB9XG5cbiAgLyoqXG4gICAqIEZlZWQgYSBuZXcgaW5wdXQgc3RyaW5nIHRvIHRoZSBzYW1lIE1hY3JvRXhwYW5kZXJcbiAgICogKHdpdGggZXhpc3RpbmcgbWFjcm9zIGV0Yy4pLlxuICAgKi9cbiAgZmVlZChpbnB1dCkge1xuICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIoaW5wdXQsIHRoaXMuc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cbiAgc3dpdGNoTW9kZShuZXdNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBncm91cCBuZXN0aW5nIHdpdGhpbiBhbGwgbmFtZXNwYWNlcy5cbiAgICovXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuYmVnaW5Hcm91cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBjdXJyZW50IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cbiAgZW5kR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuZW5kR3JvdXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3Btb3N0IHRva2VuIG9uIHRoZSBzdGFjaywgd2l0aG91dCBleHBhbmRpbmcgaXQuXG4gICAqIFNpbWlsYXIgaW4gYmVoYXZpb3IgdG8gVGVYJ3MgYFxcZnV0dXJlbGV0YC5cbiAgICovXG4gIGZ1dHVyZSgpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRoaXMubGV4ZXIubGV4KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIG5leHQgdW5leHBhbmRlZCB0b2tlbi5cbiAgICovXG4gIHBvcFRva2VuKCkge1xuICAgIHRoaXMuZnV0dXJlKCk7IC8vIGVuc3VyZSBub24tZW1wdHkgc3RhY2tcbiAgICByZXR1cm4gdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBnaXZlbiB0b2tlbiB0byB0aGUgdG9rZW4gc3RhY2suICBJbiBwYXJ0aWN1bGFyLCB0aGlzIGdldCBiZSB1c2VkXG4gICAqIHRvIHB1dCBiYWNrIGEgdG9rZW4gcmV0dXJuZWQgZnJvbSBvbmUgb2YgdGhlIG90aGVyIG1ldGhvZHMuXG4gICAqL1xuICBwdXNoVG9rZW4odG9rZW4pIHtcbiAgICB0aGlzLnN0YWNrLnB1c2godG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhbiBhcnJheSBvZiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLlxuICAgKi9cbiAgcHVzaFRva2Vucyh0b2tlbnMpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goLi4udG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFuIG1hY3JvIGFyZ3VtZW50IHdpdGhvdXQgZXhwYW5kaW5nIHRva2VucyBhbmQgYXBwZW5kIHRoZSBhcnJheSBvZlxuICAgKiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLiBVc2VzIFRva2VuIGFzIGEgY29udGFpbmVyIGZvciB0aGUgcmVzdWx0LlxuICAgKi9cbiAgc2NhbkFyZ3VtZW50KGlzT3B0aW9uYWwpIHtcbiAgICBsZXQgc3RhcnQ7XG4gICAgbGV0IGVuZDtcbiAgICBsZXQgdG9rZW5zO1xuICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gXFxAaWZuZXh0Y2hhciBnb2JibGVzIGFueSBzcGFjZSBmb2xsb3dpbmcgaXRcbiAgICAgIGlmICh0aGlzLmZ1dHVyZSgpLnRleHQgIT09IFwiW1wiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSB0aGlzLnBvcFRva2VuKCk7IC8vIGRvbid0IGluY2x1ZGUgWyBpbiB0b2tlbnNcbiAgICAgICh7IHRva2VucywgZW5kIH0gPSB0aGlzLmNvbnN1bWVBcmcoW1wiXVwiXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoeyB0b2tlbnMsIHN0YXJ0LCBlbmQgfSA9IHRoaXMuY29uc3VtZUFyZygpKTtcbiAgICB9XG5cbiAgICAvLyBpbmRpY2F0ZSB0aGUgZW5kIG9mIGFuIGFyZ3VtZW50XG4gICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKFwiRU9GXCIsIGVuZC5sb2MpKTtcblxuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiBzdGFydC5yYW5nZShlbmQsIFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWUgYWxsIGZvbGxvd2luZyBzcGFjZSB0b2tlbnMsIHdpdGhvdXQgZXhwYW5zaW9uLlxuICAgKi9cbiAgY29uc3VtZVNwYWNlcygpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZnV0dXJlKCk7XG4gICAgICBpZiAodG9rZW4udGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lIGFuIGFyZ3VtZW50IGZyb20gdGhlIHRva2VuIHN0cmVhbSwgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAqIG9mIHRva2VucyBhbmQgc3RhcnQvZW5kIHRva2VuLlxuICAgKi9cbiAgY29uc3VtZUFyZyhkZWxpbXMpIHtcbiAgICAvLyBUaGUgYXJndW1lbnQgZm9yIGEgZGVsaW1pdGVkIHBhcmFtZXRlciBpcyB0aGUgc2hvcnRlc3QgKHBvc3NpYmx5XG4gICAgLy8gZW1wdHkpIHNlcXVlbmNlIG9mIHRva2VucyB3aXRoIHByb3Blcmx5IG5lc3RlZCB7Li4ufSBncm91cHMgdGhhdCBpc1xuICAgIC8vIGZvbGxvd2VkIC4uLiBieSB0aGlzIHBhcnRpY3VsYXIgbGlzdCBvZiBub24tcGFyYW1ldGVyIHRva2Vucy5cbiAgICAvLyBUaGUgYXJndW1lbnQgZm9yIGFuIHVuZGVsaW1pdGVkIHBhcmFtZXRlciBpcyB0aGUgbmV4dCBub25ibGFua1xuICAgIC8vIHRva2VuLCB1bmxlc3MgdGhhdCB0b2tlbiBpcyDigJh74oCZLCB3aGVuIHRoZSBhcmd1bWVudCB3aWxsIGJlIHRoZVxuICAgIC8vIGVudGlyZSB7Li4ufSBncm91cCB0aGF0IGZvbGxvd3MuXG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgaXNEZWxpbWl0ZWQgPSBkZWxpbXMgJiYgZGVsaW1zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCFpc0RlbGltaXRlZCkge1xuICAgICAgLy8gSWdub3JlIHNwYWNlcyBiZXR3ZWVuIGFyZ3VtZW50cy4gIEFzIHRoZSBUZVhib29rIHNheXM6XG4gICAgICAvLyBcIkFmdGVyIHlvdSBoYXZlIHNhaWQg4oCYXFxkZWZcXHJvdyMxIzJ7Li4ufeKAmSwgeW91IGFyZSBhbGxvd2VkIHRvXG4gICAgICAvLyAgcHV0IHNwYWNlcyBiZXR3ZWVuIHRoZSBhcmd1bWVudHMgKGUuZy4sIOKAmFxccm93IHggbuKAmSksIGJlY2F1c2VcbiAgICAgIC8vICBUZVggZG9lc27igJl0IHVzZSBzaW5nbGUgc3BhY2VzIGFzIHVuZGVsaW1pdGVkIGFyZ3VtZW50cy5cIlxuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5mdXR1cmUoKTtcbiAgICBsZXQgdG9rO1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICBkbyB7XG4gICAgICB0b2sgPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgICAgaWYgKHRvay50ZXh0ID09PSBcIntcIikge1xuICAgICAgICArK2RlcHRoO1xuICAgICAgfSBlbHNlIGlmICh0b2sudGV4dCA9PT0gXCJ9XCIpIHtcbiAgICAgICAgLS1kZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXh0cmEgfVwiLCB0b2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgIFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQgaW4gYSBtYWNybyBhcmd1bWVudFwiICtcbiAgICAgICAgICAgIFwiLCBleHBlY3RlZCAnXCIgK1xuICAgICAgICAgICAgKGRlbGltcyAmJiBpc0RlbGltaXRlZCA/IGRlbGltc1ttYXRjaF0gOiBcIn1cIikgK1xuICAgICAgICAgICAgXCInXCIsXG4gICAgICAgICAgdG9rXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGVsaW1zICYmIGlzRGVsaW1pdGVkKSB7XG4gICAgICAgIGlmICgoZGVwdGggPT09IDAgfHwgKGRlcHRoID09PSAxICYmIGRlbGltc1ttYXRjaF0gPT09IFwie1wiKSkgJiYgdG9rLnRleHQgPT09IGRlbGltc1ttYXRjaF0pIHtcbiAgICAgICAgICArK21hdGNoO1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gZGVsaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSBkZWxpbXMgaW4gdG9rZW5zXG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKC1tYXRjaCwgbWF0Y2gpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKGRlcHRoICE9PSAwIHx8IGlzRGVsaW1pdGVkKTtcbiAgICAvLyBJZiB0aGUgYXJndW1lbnQgZm91bmQgLi4uIGhhcyB0aGUgZm9ybSDigJh7PG5lc3RlZCB0b2tlbnM+feKAmSxcbiAgICAvLyAuLi4gdGhlIG91dGVybW9zdCBicmFjZXMgZW5jbG9zaW5nIHRoZSBhcmd1bWVudCBhcmUgcmVtb3ZlZFxuICAgIGlmIChzdGFydC50ZXh0ID09PSBcIntcIiAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnRleHQgPT09IFwifVwiKSB7XG4gICAgICB0b2tlbnMucG9wKCk7XG4gICAgICB0b2tlbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcbiAgICByZXR1cm4geyB0b2tlbnMsIHN0YXJ0LCBlbmQ6IHRvayB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWUgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgKGRlbGltaXRlZCkgYXJndW1lbnRzIGZyb20gdGhlIHRva2VuXG4gICAqIHN0cmVhbSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3VtZUFyZ3MobnVtQXJncywgZGVsaW1pdGVycykge1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICBpZiAoZGVsaW1pdGVycy5sZW5ndGggIT09IG51bUFyZ3MgKyAxKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVGhlIGxlbmd0aCBvZiBkZWxpbWl0ZXJzIGRvZXNuJ3QgbWF0Y2ggdGhlIG51bWJlciBvZiBhcmdzIVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbGltcyA9IGRlbGltaXRlcnNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2sgPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgICAgIGlmIChkZWxpbXNbaV0gIT09IHRvay50ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVc2Ugb2YgdGhlIG1hY3JvIGRvZXNuJ3QgbWF0Y2ggaXRzIGRlZmluaXRpb25cIiwgdG9rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUFyZ3M7IGkrKykge1xuICAgICAgYXJncy5wdXNoKHRoaXMuY29uc3VtZUFyZyhkZWxpbWl0ZXJzICYmIGRlbGltaXRlcnNbaSArIDFdKS50b2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBJZiB0aGUgdG9rZW4gaXMgZXhwYW5kZWQsIHRoZSByZXN1bHRpbmcgdG9rZW5zIHdpbGwgYmUgcHVzaGVkIG9udG9cbiAgICogdGhlIHN0YWNrIGluIHJldmVyc2Ugb3JkZXIsIGFuZCB0aGUgbnVtYmVyIG9mIHN1Y2ggdG9rZW5zIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuICBUaGlzIG51bWJlciBtaWdodCBiZSB6ZXJvIG9yIHBvc2l0aXZlLlxuICAgKlxuICAgKiBJZiBub3QsIHRoZSByZXR1cm4gdmFsdWUgaXMgYGZhbHNlYCwgYW5kIHRoZSBuZXh0IHRva2VuIHJlbWFpbnMgYXQgdGhlXG4gICAqIHRvcCBvZiB0aGUgc3RhY2suXG4gICAqXG4gICAqIEluIGVpdGhlciBjYXNlLCB0aGUgbmV4dCB0b2tlbiB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLFxuICAgKiBvciB0aGUgc3RhY2sgd2lsbCBiZSBlbXB0eSAoaW4gY2FzZSBvZiBlbXB0eSBleHBhbnNpb25cbiAgICogYW5kIG5vIG90aGVyIHRva2VucykuXG4gICAqXG4gICAqIFVzZWQgdG8gaW1wbGVtZW50IGBleHBhbmRBZnRlckZ1dHVyZWAgYW5kIGBleHBhbmROZXh0VG9rZW5gLlxuICAgKlxuICAgKiBJZiBleHBhbmRhYmxlT25seSwgb25seSBleHBhbmRhYmxlIHRva2VucyBhcmUgZXhwYW5kZWQgYW5kXG4gICAqIGFuIHVuZGVmaW5lZCBjb250cm9sIHNlcXVlbmNlIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAqL1xuICBleHBhbmRPbmNlKGV4cGFuZGFibGVPbmx5KSB7XG4gICAgY29uc3QgdG9wVG9rZW4gPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgY29uc3QgbmFtZSA9IHRvcFRva2VuLnRleHQ7XG4gICAgY29uc3QgZXhwYW5zaW9uID0gIXRvcFRva2VuLm5vZXhwYW5kID8gdGhpcy5fZ2V0RXhwYW5zaW9uKG5hbWUpIDogbnVsbDtcbiAgICBpZiAoZXhwYW5zaW9uID09IG51bGwgfHwgKGV4cGFuZGFibGVPbmx5ICYmIGV4cGFuc2lvbi51bmV4cGFuZGFibGUpKSB7XG4gICAgICBpZiAoZXhwYW5kYWJsZU9ubHkgJiYgZXhwYW5zaW9uID09IG51bGwgJiYgbmFtZVswXSA9PT0gXCJcXFxcXCIgJiYgIXRoaXMuaXNEZWZpbmVkKG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5kZWZpbmVkIGNvbnRyb2wgc2VxdWVuY2U6IFwiICsgbmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnB1c2hUb2tlbih0b3BUb2tlbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQrKztcbiAgICBpZiAodGhpcy5leHBhbnNpb25Db3VudCA+IHRoaXMuc2V0dGluZ3MubWF4RXhwYW5kKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgXCJUb28gbWFueSBleHBhbnNpb25zOiBpbmZpbml0ZSBsb29wIG9yIFwiICsgXCJuZWVkIHRvIGluY3JlYXNlIG1heEV4cGFuZCBzZXR0aW5nXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB0b2tlbnMgPSBleHBhbnNpb24udG9rZW5zO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmNvbnN1bWVBcmdzKGV4cGFuc2lvbi5udW1BcmdzLCBleHBhbnNpb24uZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cGFuc2lvbi5udW1BcmdzKSB7XG4gICAgICAvLyBwYXN0ZSBhcmd1bWVudHMgaW4gcGxhY2Ugb2YgdGhlIHBsYWNlaG9sZGVyc1xuICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7IC8vIG1ha2UgYSBzaGFsbG93IGNvcHlcbiAgICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbGV0IHRvayA9IHRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkluY29tcGxldGUgcGxhY2Vob2xkZXIgYXQgZW5kIG9mIG1hY3JvIGJvZHlcIiwgdG9rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rID0gdG9rZW5zWy0taV07IC8vIG5leHQgdG9rZW4gb24gc3RhY2tcbiAgICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAvLyAjIyDihpIgI1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMSk7IC8vIGRyb3AgZmlyc3QgI1xuICAgICAgICAgIH0gZWxzZSBpZiAoL15bMS05XSQvLnRlc3QodG9rLnRleHQpKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHRoZSBpbmRpY2F0ZWQgYXJndW1lbnRcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMiwgLi4uYXJnc1srdG9rLnRleHQgLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTm90IGEgdmFsaWQgYXJndW1lbnQgbnVtYmVyXCIsIHRvayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENvbmNhdGVuYXRlIGV4cGFuc2lvbiBvbnRvIHRvcCBvZiBzdGFjay5cbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIChpZiBwb3NzaWJsZSksIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZ1xuICAgKiB0b3AgdG9rZW4gb24gdGhlIHN0YWNrICh3aXRob3V0IHJlbW92aW5nIGFueXRoaW5nIGZyb20gdGhlIHN0YWNrKS5cbiAgICogU2ltaWxhciBpbiBiZWhhdmlvciB0byBUZVgncyBgXFxleHBhbmRhZnRlclxcZnV0dXJlbGV0YC5cbiAgICogRXF1aXZhbGVudCB0byBleHBhbmRPbmNlKCkgZm9sbG93ZWQgYnkgZnV0dXJlKCkuXG4gICAqL1xuICBleHBhbmRBZnRlckZ1dHVyZSgpIHtcbiAgICB0aGlzLmV4cGFuZE9uY2UoKTtcbiAgICByZXR1cm4gdGhpcy5mdXR1cmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBleHBhbmQgZmlyc3QgdG9rZW4sIHRoZW4gcmV0dXJuIGZpcnN0IG5vbi1leHBhbmRhYmxlIHRva2VuLlxuICAgKi9cbiAgZXhwYW5kTmV4dFRva2VuKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLmV4cGFuZE9uY2UoKSA9PT0gZmFsc2UpIHsgLy8gZnVsbHkgZXhwYW5kZWRcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvLyBUaGUgdG9rZW4gYWZ0ZXIgXFxub2V4cGFuZCBpcyBpbnRlcnByZXRlZCBhcyBpZiBpdHMgbWVhbmluZyB3ZXJlIOKAmFxccmVsYXjigJlcbiAgICAgICAgaWYgKHRva2VuLnRyZWF0QXNSZWxheCkge1xuICAgICAgICAgIHRva2VuLnRleHQgPSBcIlxcXFxyZWxheFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlblxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgcGF0aHdheSBpcyBpbXBvc3NpYmxlLlxuICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVucmVhY2hhYmxlXG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiBtYWNybyBuYW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBsaXN0IG9mXG4gICAqIHRva2Vucywgb3IgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggbWFjcm8gaXMgZGVmaW5lZC5cbiAgICovXG4gIGV4cGFuZE1hY3JvKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpID8gdGhpcy5leHBhbmRUb2tlbnMoW25ldyBUb2tlbihuYW1lKV0pIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gdG9rZW4gc3RyZWFtIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBsaXN0IG9mXG4gICAqIHRva2Vucy4gIE5vdGUgdGhhdCB0aGUgaW5wdXQgdG9rZW5zIGFyZSBpbiByZXZlcnNlIG9yZGVyLCBidXQgdGhlXG4gICAqIG91dHB1dCB0b2tlbnMgYXJlIGluIGZvcndhcmQgb3JkZXIuXG4gICAqL1xuICBleHBhbmRUb2tlbnModG9rZW5zKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3Qgb2xkU3RhY2tMZW5ndGggPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBvbGRTdGFja0xlbmd0aCkge1xuICAgICAgLy8gRXhwYW5kIG9ubHkgZXhwYW5kYWJsZSB0b2tlbnNcbiAgICAgIGlmICh0aGlzLmV4cGFuZE9uY2UodHJ1ZSkgPT09IGZhbHNlKSB7ICAvLyBmdWxseSBleHBhbmRlZFxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHtcbiAgICAgICAgICAvLyB0aGUgZXhwYW5zaW9uIG9mIFxcbm9leHBhbmQgaXMgdGhlIHRva2VuIGl0c2VsZlxuICAgICAgICAgIHRva2VuLm5vZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgdG9rZW4udHJlYXRBc1JlbGF4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBzdHJpbmcsXG4gICAqIG9yIHJldHVybiBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIG1hY3JvIGlzIGRlZmluZWQuXG4gICAqL1xuICBleHBhbmRNYWNyb0FzVGV4dChuYW1lKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy5leHBhbmRNYWNybyhuYW1lKTtcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4pID0+IHRva2VuLnRleHQpLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cGFuZGVkIG1hY3JvIGFzIGEgcmV2ZXJzZWQgYXJyYXkgb2YgdG9rZW5zIGFuZCBhIG1hY3JvXG4gICAqIGFyZ3VtZW50IGNvdW50LiAgT3IgcmV0dXJucyBgbnVsbGAgaWYgbm8gc3VjaCBtYWNyby5cbiAgICovXG4gIF9nZXRFeHBhbnNpb24obmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLm1hY3Jvcy5nZXQobmFtZSk7XG4gICAgaWYgKGRlZmluaXRpb24gPT0gbnVsbCkge1xuICAgICAgLy8gbWFpbmx5IGNoZWNraW5nIGZvciB1bmRlZmluZWQgaGVyZVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuICAgIC8vIElmIGEgc2luZ2xlIGNoYXJhY3RlciBoYXMgYW4gYXNzb2NpYXRlZCBjYXRjb2RlIG90aGVyIHRoYW4gMTNcbiAgICAvLyAoYWN0aXZlIGNoYXJhY3RlciksIHRoZW4gZG9uJ3QgZXhwYW5kIGl0LlxuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY2F0Y29kZSA9IHRoaXMubGV4ZXIuY2F0Y29kZXNbbmFtZV07XG4gICAgICBpZiAoY2F0Y29kZSAhPSBudWxsICYmIGNhdGNvZGUgIT09IDEzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBhbnNpb24gPSB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gZGVmaW5pdGlvbih0aGlzKSA6IGRlZmluaXRpb247XG4gICAgaWYgKHR5cGVvZiBleHBhbnNpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxldCBudW1BcmdzID0gMDtcbiAgICAgIGlmIChleHBhbnNpb24uaW5kZXhPZihcIiNcIikgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkID0gZXhwYW5zaW9uLnJlcGxhY2UoLyMjL2csIFwiXCIpO1xuICAgICAgICB3aGlsZSAoc3RyaXBwZWQuaW5kZXhPZihcIiNcIiArIChudW1BcmdzICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICsrbnVtQXJncztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYm9keUxleGVyID0gbmV3IExleGVyKGV4cGFuc2lvbiwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgIGxldCB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICB3aGlsZSAodG9rLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICAgICAgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgfVxuICAgICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgdXNpbmcgcHVzaCBhbmQgcG9wXG4gICAgICBjb25zdCBleHBhbmRlZCA9IHsgdG9rZW5zLCBudW1BcmdzIH07XG4gICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGFuc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgY3VycmVudGx5IFwiZGVmaW5lZFwiIChoYXMgc29tZVxuICAgKiBmdW5jdGlvbmFsaXR5KSwgbWVhbmluZyB0aGF0IGl0J3MgYSBtYWNybyAoaW4gdGhlIGN1cnJlbnQgZ3JvdXApLFxuICAgKiBhIGZ1bmN0aW9uLCBhIHN5bWJvbCwgb3Igb25lIG9mIHRoZSBzcGVjaWFsIGNvbW1hbmRzIGxpc3RlZCBpblxuICAgKiBgaW1wbGljaXRDb21tYW5kc2AuXG4gICAqL1xuICBpc0RlZmluZWQobmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1hY3Jvcy5oYXMobmFtZSkgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmdW5jdGlvbnMsIG5hbWUgKSB8fFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN5bWJvbHMubWF0aCwgbmFtZSApIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3ltYm9scy50ZXh0LCBuYW1lICkgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbXBsaWNpdENvbW1hbmRzLCBuYW1lIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBleHBhbmRhYmxlLlxuICAgKi9cbiAgaXNFeHBhbmRhYmxlKG5hbWUpIHtcbiAgICBjb25zdCBtYWNybyA9IHRoaXMubWFjcm9zLmdldChuYW1lKTtcbiAgICByZXR1cm4gbWFjcm8gIT0gbnVsbFxuICAgICAgPyB0eXBlb2YgbWFjcm8gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hY3JvID09PSBcImZ1bmN0aW9uXCIgfHwgIW1hY3JvLnVuZXhwYW5kYWJsZVxuICAgICAgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZnVuY3Rpb25zLCBuYW1lICkgJiYgIWZ1bmN0aW9uc1tuYW1lXS5wcmltaXRpdmU7XG4gIH1cbn1cblxuLy8gSGVscGVycyBmb3IgUGFyc2VyLmpzIGhhbmRsaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHQgY2hhcmFjdGVycy5cblxuY29uc3QgdW5pY29kZVN1YlJlZ0V4ID0gL15b4oKK4oKL4oKM4oKN4oKO4oKA4oKB4oKC4oKD4oKE4oKF4oKG4oKH4oKI4oKJ4oKQ4oKR4oKV4bWi4rG84oKW4oKX4oKY4oKZ4oKS4oKa4bWj4oKb4oKc4bWk4bWl4oKT4bWm4bWn4bWo4bWp4bWqXS87XG5cbmNvbnN0IHVTdWJzQW5kU3VwcyA9IE9iamVjdC5mcmVlemUoe1xuICAn4oKKJzogJysnLFxuICAn4oKLJzogJy0nLFxuICAn4oKMJzogJz0nLFxuICAn4oKNJzogJygnLFxuICAn4oKOJzogJyknLFxuICAn4oKAJzogJzAnLFxuICAn4oKBJzogJzEnLFxuICAn4oKCJzogJzInLFxuICAn4oKDJzogJzMnLFxuICAn4oKEJzogJzQnLFxuICAn4oKFJzogJzUnLFxuICAn4oKGJzogJzYnLFxuICAn4oKHJzogJzcnLFxuICAn4oKIJzogJzgnLFxuICAn4oKJJzogJzknLFxuICAnXFx1MjA5MCc6ICdhJyxcbiAgJ1xcdTIwOTEnOiAnZScsXG4gICdcXHUyMDk1JzogJ2gnLFxuICAnXFx1MUQ2Mic6ICdpJyxcbiAgJ1xcdTJDN0MnOiAnaicsXG4gICdcXHUyMDk2JzogJ2snLFxuICAnXFx1MjA5Nyc6ICdsJyxcbiAgJ1xcdTIwOTgnOiAnbScsXG4gICdcXHUyMDk5JzogJ24nLFxuICAnXFx1MjA5Mic6ICdvJyxcbiAgJ1xcdTIwOUEnOiAncCcsXG4gICdcXHUxRDYzJzogJ3InLFxuICAnXFx1MjA5Qic6ICdzJyxcbiAgJ1xcdTIwOUMnOiAndCcsXG4gICdcXHUxRDY0JzogJ3UnLFxuICAnXFx1MUQ2NSc6ICd2JyxcbiAgJ1xcdTIwOTMnOiAneCcsXG4gICdcXHUxRDY2JzogJ86yJyxcbiAgJ1xcdTFENjcnOiAnzrMnLFxuICAnXFx1MUQ2OCc6ICfPgScsXG4gICdcXHUxRDY5JzogJ1xcdTAzZDUnLFxuICAnXFx1MUQ2QSc6ICfPhycsXG4gICfigbonOiAnKycsXG4gICfigbsnOiAnLScsXG4gICfigbwnOiAnPScsXG4gICfigb0nOiAnKCcsXG4gICfigb4nOiAnKScsXG4gICfigbAnOiAnMCcsXG4gICfCuSc6ICcxJyxcbiAgJ8KyJzogJzInLFxuICAnwrMnOiAnMycsXG4gICfigbQnOiAnNCcsXG4gICfigbUnOiAnNScsXG4gICfigbYnOiAnNicsXG4gICfigbcnOiAnNycsXG4gICfigbgnOiAnOCcsXG4gICfigbknOiAnOScsXG4gICdcXHUxRDJDJzogJ0EnLFxuICAnXFx1MUQyRSc6ICdCJyxcbiAgJ1xcdTFEMzAnOiAnRCcsXG4gICdcXHUxRDMxJzogJ0UnLFxuICAnXFx1MUQzMyc6ICdHJyxcbiAgJ1xcdTFEMzQnOiAnSCcsXG4gICdcXHUxRDM1JzogJ0knLFxuICAnXFx1MUQzNic6ICdKJyxcbiAgJ1xcdTFEMzcnOiAnSycsXG4gICdcXHUxRDM4JzogJ0wnLFxuICAnXFx1MUQzOSc6ICdNJyxcbiAgJ1xcdTFEM0EnOiAnTicsXG4gICdcXHUxRDNDJzogJ08nLFxuICAnXFx1MUQzRSc6ICdQJyxcbiAgJ1xcdTFEM0YnOiAnUicsXG4gICdcXHUxRDQwJzogJ1QnLFxuICAnXFx1MUQ0MSc6ICdVJyxcbiAgJ1xcdTJDN0QnOiAnVicsXG4gICdcXHUxRDQyJzogJ1cnLFxuICAnXFx1MUQ0Myc6ICdhJyxcbiAgJ1xcdTFENDcnOiAnYicsXG4gICdcXHUxRDlDJzogJ2MnLFxuICAnXFx1MUQ0OCc6ICdkJyxcbiAgJ1xcdTFENDknOiAnZScsXG4gICdcXHUxREEwJzogJ2YnLFxuICAnXFx1MUQ0RCc6ICdnJyxcbiAgJ1xcdTAyQjAnOiAnaCcsXG4gICdcXHUyMDcxJzogJ2knLFxuICAnXFx1MDJCMic6ICdqJyxcbiAgJ1xcdTFENEYnOiAnaycsXG4gICdcXHUwMkUxJzogJ2wnLFxuICAnXFx1MUQ1MCc6ICdtJyxcbiAgJ1xcdTIwN0YnOiAnbicsXG4gICdcXHUxRDUyJzogJ28nLFxuICAnXFx1MUQ1Nic6ICdwJyxcbiAgJ1xcdTAyQjMnOiAncicsXG4gICdcXHUwMkUyJzogJ3MnLFxuICAnXFx1MUQ1Nyc6ICd0JyxcbiAgJ1xcdTFENTgnOiAndScsXG4gICdcXHUxRDVCJzogJ3YnLFxuICAnXFx1MDJCNyc6ICd3JyxcbiAgJ1xcdTAyRTMnOiAneCcsXG4gICdcXHUwMkI4JzogJ3knLFxuICAnXFx1MURCQic6ICd6JyxcbiAgJ1xcdTFENUQnOiAnzrInLFxuICAnXFx1MUQ1RSc6ICfOsycsXG4gICdcXHUxRDVGJzogJ860JyxcbiAgJ1xcdTFENjAnOiAnXFx1MDNkNScsXG4gICdcXHUxRDYxJzogJ8+HJyxcbiAgJ1xcdTFEQkYnOiAnzrgnXG59KTtcblxuLy8gVXNlZCBmb3IgVW5pY29kZSBpbnB1dCBvZiBjYWxsaWdyYXBoaWMgYW5kIHNjcmlwdCBsZXR0ZXJzXG5jb25zdCBhc2NpaUZyb21TY3JpcHQgPSBPYmplY3QuZnJlZXplKHtcbiAgXCJcXHVkODM1XFx1ZGM5Y1wiOiBcIkFcIixcbiAgXCJcXHUyMTJjXCI6IFwiQlwiLFxuICBcIlxcdWQ4MzVcXHVkYzllXCI6IFwiQ1wiLFxuICBcIlxcdWQ4MzVcXHVkYzlmXCI6IFwiRFwiLFxuICBcIlxcdTIxMzBcIjogXCJFXCIsXG4gIFwiXFx1MjEzMVwiOiBcIkZcIixcbiAgXCJcXHVkODM1XFx1ZGNhMlwiOiBcIkdcIixcbiAgXCJcXHUyMTBCXCI6IFwiSFwiLFxuICBcIlxcdTIxMTBcIjogXCJJXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYTVcIjogXCJKXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYTZcIjogXCJLXCIsXG4gIFwiXFx1MjExMlwiOiBcIkxcIixcbiAgXCJcXHUyMTMzXCI6IFwiTVwiLFxuICBcIlxcdWQ4MzVcXHVkY2E5XCI6IFwiTlwiLFxuICBcIlxcdWQ4MzVcXHVkY2FhXCI6IFwiT1wiLFxuICBcIlxcdWQ4MzVcXHVkY2FiXCI6IFwiUFwiLFxuICBcIlxcdWQ4MzVcXHVkY2FjXCI6IFwiUVwiLFxuICBcIlxcdTIxMUJcIjogXCJSXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYWVcIjogXCJTXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYWZcIjogXCJUXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjBcIjogXCJVXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjFcIjogXCJWXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjJcIjogXCJXXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjNcIjogXCJYXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjRcIjogXCJZXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjVcIjogXCJaXCJcbn0pO1xuXG4vLyBNYXBwaW5nIG9mIFVuaWNvZGUgYWNjZW50IGNoYXJhY3RlcnMgdG8gdGhlaXIgTGFUZVggZXF1aXZhbGVudCBpbiB0ZXh0IGFuZFxuLy8gbWF0aCBtb2RlICh3aGVuIHRoZXkgZXhpc3QpLlxudmFyIHVuaWNvZGVBY2NlbnRzID0ge1xuICBcIlxcdTAzMDFcIjogeyB0ZXh0OiBcIlxcXFwnXCIsIG1hdGg6IFwiXFxcXGFjdXRlXCIgfSxcbiAgXCJcXHUwMzAwXCI6IHsgdGV4dDogXCJcXFxcYFwiLCBtYXRoOiBcIlxcXFxncmF2ZVwiIH0sXG4gIFwiXFx1MDMwOFwiOiB7IHRleHQ6ICdcXFxcXCInLCBtYXRoOiBcIlxcXFxkZG90XCIgfSxcbiAgXCJcXHUwMzAzXCI6IHsgdGV4dDogXCJcXFxcflwiLCBtYXRoOiBcIlxcXFx0aWxkZVwiIH0sXG4gIFwiXFx1MDMwNFwiOiB7IHRleHQ6IFwiXFxcXD1cIiwgbWF0aDogXCJcXFxcYmFyXCIgfSxcbiAgXCJcXHUwMzA2XCI6IHsgdGV4dDogXCJcXFxcdVwiLCBtYXRoOiBcIlxcXFxicmV2ZVwiIH0sXG4gIFwiXFx1MDMwY1wiOiB7IHRleHQ6IFwiXFxcXHZcIiwgbWF0aDogXCJcXFxcY2hlY2tcIiB9LFxuICBcIlxcdTAzMDJcIjogeyB0ZXh0OiBcIlxcXFxeXCIsIG1hdGg6IFwiXFxcXGhhdFwiIH0sXG4gIFwiXFx1MDMwN1wiOiB7IHRleHQ6IFwiXFxcXC5cIiwgbWF0aDogXCJcXFxcZG90XCIgfSxcbiAgXCJcXHUwMzBhXCI6IHsgdGV4dDogXCJcXFxcclwiLCBtYXRoOiBcIlxcXFxtYXRocmluZ1wiIH0sXG4gIFwiXFx1MDMwYlwiOiB7IHRleHQ6IFwiXFxcXEhcIiB9LFxuICAnXFx1MDMyNyc6IHsgdGV4dDogJ1xcXFxjJyB9XG59O1xuXG52YXIgdW5pY29kZVN5bWJvbHMgPSB7XG4gIFwiw6FcIjogXCJhzIFcIixcbiAgXCLDoFwiOiBcImHMgFwiLFxuICBcIsOkXCI6IFwiYcyIXCIsXG4gIFwix59cIjogXCJhzIjMhFwiLFxuICBcIsOjXCI6IFwiYcyDXCIsXG4gIFwixIFcIjogXCJhzIRcIixcbiAgXCLEg1wiOiBcImHMhlwiLFxuICBcIuG6r1wiOiBcImHMhsyBXCIsXG4gIFwi4bqxXCI6IFwiYcyGzIBcIixcbiAgXCLhurVcIjogXCJhzIbMg1wiLFxuICBcIseOXCI6IFwiYcyMXCIsXG4gIFwiw6JcIjogXCJhzIJcIixcbiAgXCLhuqVcIjogXCJhzILMgVwiLFxuICBcIuG6p1wiOiBcImHMgsyAXCIsXG4gIFwi4bqrXCI6IFwiYcyCzINcIixcbiAgXCLIp1wiOiBcImHMh1wiLFxuICBcIsehXCI6IFwiYcyHzIRcIixcbiAgXCLDpVwiOiBcImHMilwiLFxuICBcIse7XCI6IFwiYcyKzIFcIixcbiAgXCLhuINcIjogXCJizIdcIixcbiAgXCLEh1wiOiBcImPMgVwiLFxuICBcIsSNXCI6IFwiY8yMXCIsXG4gIFwixIlcIjogXCJjzIJcIixcbiAgXCLEi1wiOiBcImPMh1wiLFxuICBcIsSPXCI6IFwiZMyMXCIsXG4gIFwi4biLXCI6IFwiZMyHXCIsXG4gIFwiw6lcIjogXCJlzIFcIixcbiAgXCLDqFwiOiBcImXMgFwiLFxuICBcIsOrXCI6IFwiZcyIXCIsXG4gIFwi4bq9XCI6IFwiZcyDXCIsXG4gIFwixJNcIjogXCJlzIRcIixcbiAgXCLhuJdcIjogXCJlzITMgVwiLFxuICBcIuG4lVwiOiBcImXMhMyAXCIsXG4gIFwixJVcIjogXCJlzIZcIixcbiAgXCLEm1wiOiBcImXMjFwiLFxuICBcIsOqXCI6IFwiZcyCXCIsXG4gIFwi4bq/XCI6IFwiZcyCzIFcIixcbiAgXCLhu4FcIjogXCJlzILMgFwiLFxuICBcIuG7hVwiOiBcImXMgsyDXCIsXG4gIFwixJdcIjogXCJlzIdcIixcbiAgXCLhuJ9cIjogXCJmzIdcIixcbiAgXCLHtVwiOiBcImfMgVwiLFxuICBcIuG4oVwiOiBcImfMhFwiLFxuICBcIsSfXCI6IFwiZ8yGXCIsXG4gIFwix6dcIjogXCJnzIxcIixcbiAgXCLEnVwiOiBcImfMglwiLFxuICBcIsShXCI6IFwiZ8yHXCIsXG4gIFwi4binXCI6IFwiaMyIXCIsXG4gIFwiyJ9cIjogXCJozIxcIixcbiAgXCLEpVwiOiBcImjMglwiLFxuICBcIuG4o1wiOiBcImjMh1wiLFxuICBcIsOtXCI6IFwiacyBXCIsXG4gIFwiw6xcIjogXCJpzIBcIixcbiAgXCLDr1wiOiBcImnMiFwiLFxuICBcIuG4r1wiOiBcImnMiMyBXCIsXG4gIFwixKlcIjogXCJpzINcIixcbiAgXCLEq1wiOiBcImnMhFwiLFxuICBcIsStXCI6IFwiacyGXCIsXG4gIFwix5BcIjogXCJpzIxcIixcbiAgXCLDrlwiOiBcImnMglwiLFxuICBcIsewXCI6IFwiasyMXCIsXG4gIFwixLVcIjogXCJqzIJcIixcbiAgXCLhuLFcIjogXCJrzIFcIixcbiAgXCLHqVwiOiBcImvMjFwiLFxuICBcIsS6XCI6IFwibMyBXCIsXG4gIFwixL5cIjogXCJszIxcIixcbiAgXCLhuL9cIjogXCJtzIFcIixcbiAgXCLhuYFcIjogXCJtzIdcIixcbiAgXCLFhFwiOiBcIm7MgVwiLFxuICBcIse5XCI6IFwibsyAXCIsXG4gIFwiw7FcIjogXCJuzINcIixcbiAgXCLFiFwiOiBcIm7MjFwiLFxuICBcIuG5hVwiOiBcIm7Mh1wiLFxuICBcIsOzXCI6IFwib8yBXCIsXG4gIFwiw7JcIjogXCJvzIBcIixcbiAgXCLDtlwiOiBcIm/MiFwiLFxuICBcIsirXCI6IFwib8yIzIRcIixcbiAgXCLDtVwiOiBcIm/Mg1wiLFxuICBcIuG5jVwiOiBcIm/Mg8yBXCIsXG4gIFwi4bmPXCI6IFwib8yDzIhcIixcbiAgXCLIrVwiOiBcIm/Mg8yEXCIsXG4gIFwixY1cIjogXCJvzIRcIixcbiAgXCLhuZNcIjogXCJvzITMgVwiLFxuICBcIuG5kVwiOiBcIm/MhMyAXCIsXG4gIFwixY9cIjogXCJvzIZcIixcbiAgXCLHklwiOiBcIm/MjFwiLFxuICBcIsO0XCI6IFwib8yCXCIsXG4gIFwi4buRXCI6IFwib8yCzIFcIixcbiAgXCLhu5NcIjogXCJvzILMgFwiLFxuICBcIuG7l1wiOiBcIm/MgsyDXCIsXG4gIFwiyK9cIjogXCJvzIdcIixcbiAgXCLIsVwiOiBcIm/Mh8yEXCIsXG4gIFwixZFcIjogXCJvzItcIixcbiAgXCLhuZVcIjogXCJwzIFcIixcbiAgXCLhuZdcIjogXCJwzIdcIixcbiAgXCLFlVwiOiBcInLMgVwiLFxuICBcIsWZXCI6IFwicsyMXCIsXG4gIFwi4bmZXCI6IFwicsyHXCIsXG4gIFwixZtcIjogXCJzzIFcIixcbiAgXCLhuaVcIjogXCJzzIHMh1wiLFxuICBcIsWhXCI6IFwic8yMXCIsXG4gIFwi4bmnXCI6IFwic8yMzIdcIixcbiAgXCLFnVwiOiBcInPMglwiLFxuICBcIuG5oVwiOiBcInPMh1wiLFxuICBcIuG6l1wiOiBcInTMiFwiLFxuICBcIsWlXCI6IFwidMyMXCIsXG4gIFwi4bmrXCI6IFwidMyHXCIsXG4gIFwiw7pcIjogXCJ1zIFcIixcbiAgXCLDuVwiOiBcInXMgFwiLFxuICBcIsO8XCI6IFwidcyIXCIsXG4gIFwix5hcIjogXCJ1zIjMgVwiLFxuICBcIsecXCI6IFwidcyIzIBcIixcbiAgXCLHllwiOiBcInXMiMyEXCIsXG4gIFwix5pcIjogXCJ1zIjMjFwiLFxuICBcIsWpXCI6IFwidcyDXCIsXG4gIFwi4bm5XCI6IFwidcyDzIFcIixcbiAgXCLFq1wiOiBcInXMhFwiLFxuICBcIuG5u1wiOiBcInXMhMyIXCIsXG4gIFwixa1cIjogXCJ1zIZcIixcbiAgXCLHlFwiOiBcInXMjFwiLFxuICBcIsO7XCI6IFwidcyCXCIsXG4gIFwixa9cIjogXCJ1zIpcIixcbiAgXCLFsVwiOiBcInXMi1wiLFxuICBcIuG5vVwiOiBcInbMg1wiLFxuICBcIuG6g1wiOiBcInfMgVwiLFxuICBcIuG6gVwiOiBcInfMgFwiLFxuICBcIuG6hVwiOiBcInfMiFwiLFxuICBcIsW1XCI6IFwid8yCXCIsXG4gIFwi4bqHXCI6IFwid8yHXCIsXG4gIFwi4bqYXCI6IFwid8yKXCIsXG4gIFwi4bqNXCI6IFwieMyIXCIsXG4gIFwi4bqLXCI6IFwieMyHXCIsXG4gIFwiw71cIjogXCJ5zIFcIixcbiAgXCLhu7NcIjogXCJ5zIBcIixcbiAgXCLDv1wiOiBcInnMiFwiLFxuICBcIuG7uVwiOiBcInnMg1wiLFxuICBcIsizXCI6IFwiecyEXCIsXG4gIFwixbdcIjogXCJ5zIJcIixcbiAgXCLhuo9cIjogXCJ5zIdcIixcbiAgXCLhuplcIjogXCJ5zIpcIixcbiAgXCLFulwiOiBcInrMgVwiLFxuICBcIsW+XCI6IFwiesyMXCIsXG4gIFwi4bqRXCI6IFwiesyCXCIsXG4gIFwixbxcIjogXCJ6zIdcIixcbiAgXCLDgVwiOiBcIkHMgVwiLFxuICBcIsOAXCI6IFwiQcyAXCIsXG4gIFwiw4RcIjogXCJBzIhcIixcbiAgXCLHnlwiOiBcIkHMiMyEXCIsXG4gIFwiw4NcIjogXCJBzINcIixcbiAgXCLEgFwiOiBcIkHMhFwiLFxuICBcIsSCXCI6IFwiQcyGXCIsXG4gIFwi4bquXCI6IFwiQcyGzIFcIixcbiAgXCLhurBcIjogXCJBzIbMgFwiLFxuICBcIuG6tFwiOiBcIkHMhsyDXCIsXG4gIFwix41cIjogXCJBzIxcIixcbiAgXCLDglwiOiBcIkHMglwiLFxuICBcIuG6pFwiOiBcIkHMgsyBXCIsXG4gIFwi4bqmXCI6IFwiQcyCzIBcIixcbiAgXCLhuqpcIjogXCJBzILMg1wiLFxuICBcIsimXCI6IFwiQcyHXCIsXG4gIFwix6BcIjogXCJBzIfMhFwiLFxuICBcIsOFXCI6IFwiQcyKXCIsXG4gIFwix7pcIjogXCJBzIrMgVwiLFxuICBcIuG4glwiOiBcIkLMh1wiLFxuICBcIsSGXCI6IFwiQ8yBXCIsXG4gIFwixIxcIjogXCJDzIxcIixcbiAgXCLEiFwiOiBcIkPMglwiLFxuICBcIsSKXCI6IFwiQ8yHXCIsXG4gIFwixI5cIjogXCJEzIxcIixcbiAgXCLhuIpcIjogXCJEzIdcIixcbiAgXCLDiVwiOiBcIkXMgVwiLFxuICBcIsOIXCI6IFwiRcyAXCIsXG4gIFwiw4tcIjogXCJFzIhcIixcbiAgXCLhurxcIjogXCJFzINcIixcbiAgXCLEklwiOiBcIkXMhFwiLFxuICBcIuG4llwiOiBcIkXMhMyBXCIsXG4gIFwi4biUXCI6IFwiRcyEzIBcIixcbiAgXCLElFwiOiBcIkXMhlwiLFxuICBcIsSaXCI6IFwiRcyMXCIsXG4gIFwiw4pcIjogXCJFzIJcIixcbiAgXCLhur5cIjogXCJFzILMgVwiLFxuICBcIuG7gFwiOiBcIkXMgsyAXCIsXG4gIFwi4buEXCI6IFwiRcyCzINcIixcbiAgXCLEllwiOiBcIkXMh1wiLFxuICBcIuG4nlwiOiBcIkbMh1wiLFxuICBcIse0XCI6IFwiR8yBXCIsXG4gIFwi4bigXCI6IFwiR8yEXCIsXG4gIFwixJ5cIjogXCJHzIZcIixcbiAgXCLHplwiOiBcIkfMjFwiLFxuICBcIsScXCI6IFwiR8yCXCIsXG4gIFwixKBcIjogXCJHzIdcIixcbiAgXCLhuKZcIjogXCJIzIhcIixcbiAgXCLInlwiOiBcIkjMjFwiLFxuICBcIsSkXCI6IFwiSMyCXCIsXG4gIFwi4biiXCI6IFwiSMyHXCIsXG4gIFwiw41cIjogXCJJzIFcIixcbiAgXCLDjFwiOiBcIknMgFwiLFxuICBcIsOPXCI6IFwiScyIXCIsXG4gIFwi4biuXCI6IFwiScyIzIFcIixcbiAgXCLEqFwiOiBcIknMg1wiLFxuICBcIsSqXCI6IFwiScyEXCIsXG4gIFwixKxcIjogXCJJzIZcIixcbiAgXCLHj1wiOiBcIknMjFwiLFxuICBcIsOOXCI6IFwiScyCXCIsXG4gIFwixLBcIjogXCJJzIdcIixcbiAgXCLEtFwiOiBcIkrMglwiLFxuICBcIuG4sFwiOiBcIkvMgVwiLFxuICBcIseoXCI6IFwiS8yMXCIsXG4gIFwixLlcIjogXCJMzIFcIixcbiAgXCLEvVwiOiBcIkzMjFwiLFxuICBcIuG4vlwiOiBcIk3MgVwiLFxuICBcIuG5gFwiOiBcIk3Mh1wiLFxuICBcIsWDXCI6IFwiTsyBXCIsXG4gIFwix7hcIjogXCJOzIBcIixcbiAgXCLDkVwiOiBcIk7Mg1wiLFxuICBcIsWHXCI6IFwiTsyMXCIsXG4gIFwi4bmEXCI6IFwiTsyHXCIsXG4gIFwiw5NcIjogXCJPzIFcIixcbiAgXCLDklwiOiBcIk/MgFwiLFxuICBcIsOWXCI6IFwiT8yIXCIsXG4gIFwiyKpcIjogXCJPzIjMhFwiLFxuICBcIsOVXCI6IFwiT8yDXCIsXG4gIFwi4bmMXCI6IFwiT8yDzIFcIixcbiAgXCLhuY5cIjogXCJPzIPMiFwiLFxuICBcIsisXCI6IFwiT8yDzIRcIixcbiAgXCLFjFwiOiBcIk/MhFwiLFxuICBcIuG5klwiOiBcIk/MhMyBXCIsXG4gIFwi4bmQXCI6IFwiT8yEzIBcIixcbiAgXCLFjlwiOiBcIk/MhlwiLFxuICBcIseRXCI6IFwiT8yMXCIsXG4gIFwiw5RcIjogXCJPzIJcIixcbiAgXCLhu5BcIjogXCJPzILMgVwiLFxuICBcIuG7klwiOiBcIk/MgsyAXCIsXG4gIFwi4buWXCI6IFwiT8yCzINcIixcbiAgXCLIrlwiOiBcIk/Mh1wiLFxuICBcIsiwXCI6IFwiT8yHzIRcIixcbiAgXCLFkFwiOiBcIk/Mi1wiLFxuICBcIuG5lFwiOiBcIlDMgVwiLFxuICBcIuG5llwiOiBcIlDMh1wiLFxuICBcIsWUXCI6IFwiUsyBXCIsXG4gIFwixZhcIjogXCJSzIxcIixcbiAgXCLhuZhcIjogXCJSzIdcIixcbiAgXCLFmlwiOiBcIlPMgVwiLFxuICBcIuG5pFwiOiBcIlPMgcyHXCIsXG4gIFwixaBcIjogXCJTzIxcIixcbiAgXCLhuaZcIjogXCJTzIzMh1wiLFxuICBcIsWcXCI6IFwiU8yCXCIsXG4gIFwi4bmgXCI6IFwiU8yHXCIsXG4gIFwixaRcIjogXCJUzIxcIixcbiAgXCLhuapcIjogXCJUzIdcIixcbiAgXCLDmlwiOiBcIlXMgVwiLFxuICBcIsOZXCI6IFwiVcyAXCIsXG4gIFwiw5xcIjogXCJVzIhcIixcbiAgXCLHl1wiOiBcIlXMiMyBXCIsXG4gIFwix5tcIjogXCJVzIjMgFwiLFxuICBcIseVXCI6IFwiVcyIzIRcIixcbiAgXCLHmVwiOiBcIlXMiMyMXCIsXG4gIFwixahcIjogXCJVzINcIixcbiAgXCLhubhcIjogXCJVzIPMgVwiLFxuICBcIsWqXCI6IFwiVcyEXCIsXG4gIFwi4bm6XCI6IFwiVcyEzIhcIixcbiAgXCLFrFwiOiBcIlXMhlwiLFxuICBcIseTXCI6IFwiVcyMXCIsXG4gIFwiw5tcIjogXCJVzIJcIixcbiAgXCLFrlwiOiBcIlXMilwiLFxuICBcIsWwXCI6IFwiVcyLXCIsXG4gIFwi4bm8XCI6IFwiVsyDXCIsXG4gIFwi4bqCXCI6IFwiV8yBXCIsXG4gIFwi4bqAXCI6IFwiV8yAXCIsXG4gIFwi4bqEXCI6IFwiV8yIXCIsXG4gIFwixbRcIjogXCJXzIJcIixcbiAgXCLhuoZcIjogXCJXzIdcIixcbiAgXCLhuoxcIjogXCJYzIhcIixcbiAgXCLhuopcIjogXCJYzIdcIixcbiAgXCLDnVwiOiBcIlnMgVwiLFxuICBcIuG7slwiOiBcIlnMgFwiLFxuICBcIsW4XCI6IFwiWcyIXCIsXG4gIFwi4bu4XCI6IFwiWcyDXCIsXG4gIFwiyLJcIjogXCJZzIRcIixcbiAgXCLFtlwiOiBcIlnMglwiLFxuICBcIuG6jlwiOiBcIlnMh1wiLFxuICBcIsW5XCI6IFwiWsyBXCIsXG4gIFwixb1cIjogXCJazIxcIixcbiAgXCLhupBcIjogXCJazIJcIixcbiAgXCLFu1wiOiBcIlrMh1wiLFxuICBcIs6sXCI6IFwizrHMgVwiLFxuICBcIuG9sFwiOiBcIs6xzIBcIixcbiAgXCLhvrFcIjogXCLOscyEXCIsXG4gIFwi4b6wXCI6IFwizrHMhlwiLFxuICBcIs6tXCI6IFwizrXMgVwiLFxuICBcIuG9slwiOiBcIs61zIBcIixcbiAgXCLOrlwiOiBcIs63zIFcIixcbiAgXCLhvbRcIjogXCLOt8yAXCIsXG4gIFwizq9cIjogXCLOucyBXCIsXG4gIFwi4b22XCI6IFwizrnMgFwiLFxuICBcIs+KXCI6IFwizrnMiFwiLFxuICBcIs6QXCI6IFwizrnMiMyBXCIsXG4gIFwi4b+SXCI6IFwizrnMiMyAXCIsXG4gIFwi4b+RXCI6IFwizrnMhFwiLFxuICBcIuG/kFwiOiBcIs65zIZcIixcbiAgXCLPjFwiOiBcIs6/zIFcIixcbiAgXCLhvbhcIjogXCLOv8yAXCIsXG4gIFwiz41cIjogXCLPhcyBXCIsXG4gIFwi4b26XCI6IFwiz4XMgFwiLFxuICBcIs+LXCI6IFwiz4XMiFwiLFxuICBcIs6wXCI6IFwiz4XMiMyBXCIsXG4gIFwi4b+iXCI6IFwiz4XMiMyAXCIsXG4gIFwi4b+hXCI6IFwiz4XMhFwiLFxuICBcIuG/oFwiOiBcIs+FzIZcIixcbiAgXCLPjlwiOiBcIs+JzIFcIixcbiAgXCLhvbxcIjogXCLPicyAXCIsXG4gIFwizo5cIjogXCLOpcyBXCIsXG4gIFwi4b+qXCI6IFwizqXMgFwiLFxuICBcIs6rXCI6IFwizqXMiFwiLFxuICBcIuG/qVwiOiBcIs6lzIRcIixcbiAgXCLhv6hcIjogXCLOpcyGXCIsXG4gIFwizo9cIjogXCLOqcyBXCIsXG4gIFwi4b+6XCI6IFwizqnMgFwiXG59O1xuXG4vKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOjAgKi9cblxuY29uc3QgYmluTGVmdENhbmNlbGxlcnMgPSBbXCJiaW5cIiwgXCJvcFwiLCBcIm9wZW5cIiwgXCJwdW5jdFwiLCBcInJlbFwiXTtcbmNvbnN0IHNpemVSZWdFeCA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS87XG5jb25zdCB0ZXh0UmVnRXggPSAvXiAqXFxcXHRleHQvO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgcGFyc2VyIHVzZWQgdG8gcGFyc2Ugb3V0IGEgVGVYIGV4cHJlc3Npb24gZnJvbSB0aGVcbiAqIGlucHV0LiBTaW5jZSBUZVggaXNuJ3QgY29udGV4dC1mcmVlLCBzdGFuZGFyZCBwYXJzZXJzIGRvbid0IHdvcmsgcGFydGljdWxhcmx5XG4gKiB3ZWxsLlxuICpcbiAqIFRoZSBzdHJhdGVneSBvZiB0aGlzIHBhcnNlciBpcyBhcyBzdWNoOlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyAodGhlIGAucGFyc2UuLi5gIG9uZXMpIHRha2UgYSBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxuICogcGFyc2Ugc3RyaW5nIHRvIHBhcnNlIHRva2VucyBmcm9tLiBUaGUgbGV4ZXIgKGZvdW5kIGluIExleGVyLmpzLCBzdG9yZWQgYXRcbiAqIHRoaXMuZ3VsbGV0LmxleGVyKSBhbHNvIHN1cHBvcnRzIHB1bGxpbmcgb3V0IHRva2VucyBhdCBhcmJpdHJhcnkgcGxhY2VzLiBXaGVuXG4gKiBpbmRpdmlkdWFsIHRva2VucyBhcmUgbmVlZGVkIGF0IGEgcG9zaXRpb24sIHRoZSBsZXhlciBpcyBjYWxsZWQgdG8gcHVsbCBvdXQgYVxuICogdG9rZW4sIHdoaWNoIGlzIHRoZW4gdXNlZC5cbiAqXG4gKiBUaGUgcGFyc2VyIGhhcyBhIHByb3BlcnR5IGNhbGxlZCBcIm1vZGVcIiBpbmRpY2F0aW5nIHRoZSBtb2RlIHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IGluLiBDdXJyZW50bHkgaXQgaGFzIHRvIGJlIG9uZSBvZiBcIm1hdGhcIiBvclxuICogXCJ0ZXh0XCIsIHdoaWNoIGRlbm90ZXMgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG1hdGgteVxuICogb25lIG9yIGEgdGV4dC15IG9uZSAoZS5nLiBpbnNpZGUgXFx0ZXh0KS4gQ3VycmVudGx5LCB0aGlzIHNlcnZlcyB0b1xuICogbGltaXQgdGhlIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0ZXh0IG1vZGUuXG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgdXNlZnVsIGRhdGEgdGhhdFxuICogd2FzIHBhcnNlZCBhdCBpdHMgZ2l2ZW4gcG9pbnQsIGFuZCBhIG5ldyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZWRcbiAqIGRhdGEuIFRoZSBtYWluIGZ1bmN0aW9ucyBjYW4gY2FsbCBlYWNoIG90aGVyIGFuZCBjb250aW51ZSB0aGUgcGFyc2luZyBieVxuICogdXNpbmcgdGhlIHJldHVybmVkIHBvc2l0aW9uIGFzIGEgbmV3IHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGV4dHJhIGAuaGFuZGxlLi4uYCBmdW5jdGlvbnMsIHdoaWNoIHB1bGwgb3V0IHNvbWUgcmV1c2VkXG4gKiBmdW5jdGlvbmFsaXR5IGludG8gc2VsZi1jb250YWluZWQgZnVuY3Rpb25zLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgcmV0dXJuIFBhcnNlTm9kZXMuXG4gKi9cblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzLCBpc1ByZWFtYmxlID0gZmFsc2UpIHtcbiAgICAvLyBTdGFydCBpbiBtYXRoIG1vZGVcbiAgICB0aGlzLm1vZGUgPSBcIm1hdGhcIjtcbiAgICAvLyBDcmVhdGUgYSBuZXcgbWFjcm8gZXhwYW5kZXIgKGd1bGxldCkgYW5kIChpbmRpcmVjdGx5IHZpYSB0aGF0KSBhbHNvIGFcbiAgICAvLyBuZXcgbGV4ZXIgKG1vdXRoKSBmb3IgdGhpcyBwYXJzZXIgKHN0b21hY2gsIGluIHRoZSBsYW5ndWFnZSBvZiBUZVgpXG4gICAgdGhpcy5ndWxsZXQgPSBuZXcgTWFjcm9FeHBhbmRlcihpbnB1dCwgc2V0dGluZ3MsIHRoaXMubW9kZSk7XG4gICAgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAvLyBBcmUgd2UgZGVmaW5pbmcgYSBwcmVhbWJsZT9cbiAgICB0aGlzLmlzUHJlYW1ibGUgPSBpc1ByZWFtYmxlO1xuICAgIC8vIENvdW50IGxlZnRyaWdodCBkZXB0aCAoZm9yIFxcbWlkZGxlIGVycm9ycylcbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gMDtcbiAgICB0aGlzLnByZXZBdG9tVHlwZSA9IFwiXCI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGEgcmVzdWx0IHRvIG1ha2Ugc3VyZSBpdCBoYXMgdGhlIHJpZ2h0IHR5cGUsIGFuZCB0aHJvd3MgYW5cbiAgICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICAgKi9cbiAgZXhwZWN0KHRleHQsIGNvbnN1bWUgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ICE9PSB0ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRXhwZWN0ZWQgJyR7dGV4dH0nLCBnb3QgJyR7dGhpcy5mZXRjaCgpLnRleHR9J2AsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzY2FyZHMgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBjb25zaWRlcmluZyBpdCBjb25zdW1lZC5cbiAgICovXG4gIGNvbnN1bWUoKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIG9yIGlmIHRoZXJlIGlzbid0IG9uZSAoYXQgdGhlXG4gICAqIGJlZ2lubmluZywgb3IgaWYgdGhlIHByZXZpb3VzIGxvb2thaGVhZCB0b2tlbiB3YXMgY29uc3VtZSgpZCksXG4gICAqIGZldGNoIHRoZSBuZXh0IHRva2VuIGFzIHRoZSBuZXcgbG9va2FoZWFkIHRva2VuIGFuZCByZXR1cm4gaXQuXG4gICAqL1xuICBmZXRjaCgpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5leHBhbmROZXh0VG9rZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cbiAgc3dpdGNoTW9kZShuZXdNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB0aGlzLmd1bGxldC5zd2l0Y2hNb2RlKG5ld01vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAgICovXG4gIHBhcnNlKCkge1xuICAgIC8vIENyZWF0ZSBhIGdyb3VwIG5hbWVzcGFjZSBmb3IgZXZlcnkgJC4uLiQsICQkLi4uJCQsIFxcWy4uLlxcXS4pXG4gICAgLy8gQSBcXGRlZiBpcyB0aGVuIHZhbGlkIG9ubHkgd2l0aGluIHRoYXQgcGFpciBvZiBkZWxpbWl0ZXJzLlxuICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcblxuICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbG9ySXNUZXh0Q29sb3IpIHtcbiAgICAgIC8vIFVzZSBvbGQgXFxjb2xvciBiZWhhdmlvciAoc2FtZSBhcyBMYVRlWCdzIFxcdGV4dGNvbG9yKSBpZiByZXF1ZXN0ZWQuXG4gICAgICAvLyBXZSBkbyB0aGlzIHdpdGhpbiB0aGUgZ3JvdXAgZm9yIHRoZSBtYXRoIGV4cHJlc3Npb24sIHNvIGl0IGRvZXNuJ3RcbiAgICAgIC8vIHBvbGx1dGUgc2V0dGluZ3MubWFjcm9zLlxuICAgICAgdGhpcy5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjb2xvclwiLCBcIlxcXFx0ZXh0Y29sb3JcIik7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSBpbnB1dFxuICAgIGNvbnN0IHBhcnNlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuXG4gICAgLy8gSWYgd2Ugc3VjY2VlZGVkLCBtYWtlIHN1cmUgdGhlcmUncyBhbiBFT0YgYXQgdGhlIGVuZFxuICAgIHRoaXMuZXhwZWN0KFwiRU9GXCIpO1xuXG4gICAgaWYgKHRoaXMuaXNQcmVhbWJsZSkge1xuICAgICAgY29uc3QgbWFjcm9zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgbWFjcm9zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIHJldHVybiBtYWNyb3NcbiAgICB9XG5cbiAgICAvLyBUaGUgb25seSBsb2NhbCBtYWNybyB0aGF0IHdlIHdhbnQgdG8gc2F2ZSBpcyBmcm9tIFxcdGFnLlxuICAgIGNvbnN0IHRhZyA9IHRoaXMuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpO1xuXG4gICAgLy8gRW5kIHRoZSBncm91cCBuYW1lc3BhY2UgZm9yIHRoZSBleHByZXNzaW9uXG4gICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcblxuICAgIGlmICh0YWcpIHsgdGhpcy5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdID0gdGFnOyB9XG5cbiAgICByZXR1cm4gcGFyc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGVuZE9mRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gW1wifVwiLCBcIlxcXFxlbmRncm91cFwiLCBcIlxcXFxlbmRcIiwgXCJcXFxccmlnaHRcIiwgXCJcXFxcZW5kdG9nZ2xlXCIsIFwiJlwiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxseSBwYXJzZSBhIHNlcGFyYXRlIHNlcXVlbmNlIG9mIHRva2VucyBhcyBhIHNlcGFyYXRlIGpvYi5cbiAgICogVG9rZW5zIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gcmV2ZXJzZSBvcmRlciwgYXMgaW4gYSBNYWNyb0RlZmluaXRpb24uXG4gICAqL1xuICBzdWJwYXJzZSh0b2tlbnMpIHtcbiAgICAvLyBTYXZlIHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIGN1cnJlbnQgam9iLlxuICAgIGNvbnN0IG9sZFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgdGhpcy5jb25zdW1lKCk7XG5cbiAgICAvLyBSdW4gdGhlIG5ldyBqb2IsIHRlcm1pbmF0aW5nIGl0IHdpdGggYW4gZXhjZXNzICd9J1xuICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbihuZXcgVG9rZW4oXCJ9XCIpKTtcbiAgICB0aGlzLmd1bGxldC5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgY29uc3QgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7XG4gICAgdGhpcy5leHBlY3QoXCJ9XCIpO1xuXG4gICAgLy8gUmVzdG9yZSB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBjdXJyZW50IGpvYi5cbiAgICB0aGlzLm5leHRUb2tlbiA9IG9sZFRva2VuO1xuXG4gICAgcmV0dXJuIHBhcnNlO1xuICB9XG5cbi8qKlxuICAgKiBQYXJzZXMgYW4gXCJleHByZXNzaW9uXCIsIHdoaWNoIGlzIGEgbGlzdCBvZiBhdG9tcy5cbiAgICpcbiAgICogYGJyZWFrT25JbmZpeGA6IFNob3VsZCB0aGUgcGFyc2luZyBzdG9wIHdoZW4gd2UgaGl0IGluZml4IG5vZGVzPyBUaGlzXG4gICAqICAgICAgICAgICAgICAgICBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlZGVuY2UgaGFuIGluZml4XG4gICAqICAgICAgICAgICAgICAgICBub2RlcyBpbiBpbXBsaWNpdCBwYXJzZXMuXG4gICAqXG4gICAqIGBicmVha09uVG9rZW5UZXh0YDogVGhlIHRleHQgb2YgdGhlIHRva2VuIHRoYXQgdGhlIGV4cHJlc3Npb24gc2hvdWxkIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHdpdGgsIG9yIGBudWxsYCBpZiBzb21ldGhpbmcgZWxzZSBzaG91bGQgZW5kIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIGBicmVha09uTWlkZGxlYDogXFxjb2xvciwgXFxvdmVyLCBhbmQgb2xkIHN0eWxpbmcgZnVuY3Rpb25zIHdvcmsgb24gYW4gaW1wbGljaXQgZ3JvdXAuXG4gICAqICAgICAgICAgICAgICAgICAgVGhlc2UgZ3JvdXBzIGVuZCBqdXN0IGJlZm9yZSB0aGUgdXN1YWwgdG9rZW5zLCBidXQgdGhleSBhbHNvXG4gICAqICAgICAgICAgICAgICAgICAgZW5kIGp1c3QgYmVmb3JlIGBcXG1pZGRsZWAuXG4gICAqL1xuICBwYXJzZUV4cHJlc3Npb24oYnJlYWtPbkluZml4LCBicmVha09uVG9rZW5UZXh0LCBicmVha09uTWlkZGxlKSB7XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHRoaXMucHJldkF0b21UeXBlID0gXCJcIjtcbiAgICAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWdub3JlIHNwYWNlcyBpbiBtYXRoIG1vZGVcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV4ID0gdGhpcy5mZXRjaCgpO1xuICAgICAgaWYgKFBhcnNlci5lbmRPZkV4cHJlc3Npb24uaW5kZXhPZihsZXgudGV4dCkgIT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGJyZWFrT25Ub2tlblRleHQgJiYgbGV4LnRleHQgPT09IGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYnJlYWtPbk1pZGRsZSAmJiBsZXgudGV4dCA9PT0gXCJcXFxcbWlkZGxlXCIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChicmVha09uSW5maXggJiYgZnVuY3Rpb25zW2xleC50ZXh0XSAmJiBmdW5jdGlvbnNbbGV4LnRleHRdLmluZml4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYXRvbSA9IHRoaXMucGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpO1xuICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChhdG9tLnR5cGUgPT09IFwiaW50ZXJuYWxcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJvZHkucHVzaChhdG9tKTtcbiAgICAgIC8vIEtlZXAgYSByZWNvcmQgb2YgdGhlIGF0b20gdHlwZSwgc28gdGhhdCBvcC5qcyBjYW4gc2V0IGNvcnJlY3Qgc3BhY2luZy5cbiAgICAgIHRoaXMucHJldkF0b21UeXBlID0gYXRvbS50eXBlID09PSBcImF0b21cIiA/IGF0b20uZmFtaWx5IDogYXRvbS50eXBlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgdGhpcy5mb3JtTGlnYXR1cmVzKGJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVJbmZpeE5vZGVzKGJvZHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJld3JpdGVzIGluZml4IG9wZXJhdG9ycyBzdWNoIGFzIFxcb3ZlciB3aXRoIGNvcnJlc3BvbmRpbmcgY29tbWFuZHMgc3VjaFxuICAgKiBhcyBcXGZyYWMuXG4gICAqXG4gICAqIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXAuICBJZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmVcbiAgICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uXG4gICAqL1xuICBoYW5kbGVJbmZpeE5vZGVzKGJvZHkpIHtcbiAgICBsZXQgb3ZlckluZGV4ID0gLTE7XG4gICAgbGV0IGZ1bmNOYW1lO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm9keVtpXS50eXBlID09PSBcImluZml4XCIpIHtcbiAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIm9ubHkgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cFwiLCBib2R5W2ldLnRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICBmdW5jTmFtZSA9IGJvZHlbaV0ucmVwbGFjZVdpdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEgJiYgZnVuY05hbWUpIHtcbiAgICAgIGxldCBudW1lck5vZGU7XG4gICAgICBsZXQgZGVub21Ob2RlO1xuXG4gICAgICBjb25zdCBudW1lckJvZHkgPSBib2R5LnNsaWNlKDAsIG92ZXJJbmRleCk7XG4gICAgICBjb25zdCBkZW5vbUJvZHkgPSBib2R5LnNsaWNlKG92ZXJJbmRleCArIDEpO1xuXG4gICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIG51bWVyTm9kZSA9IG51bWVyQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWVyTm9kZSA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiB0aGlzLm1vZGUsIGJvZHk6IG51bWVyQm9keSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVub21Cb2R5Lmxlbmd0aCA9PT0gMSAmJiBkZW5vbUJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IGRlbm9tQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiB0aGlzLm1vZGUsIGJvZHk6IGRlbm9tQm9keSB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGFib3ZlZnJhY1wiKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgYm9keVtvdmVySW5kZXhdLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzdWJzY3JpcHQgb3Igc3VwZXJzY3JpcHQgd2l0aCBuaWNlIGVycm9ycy5cbiAgICovXG4gIGhhbmRsZVN1cFN1YnNjcmlwdChcbiAgICBuYW1lIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gICkge1xuICAgIGNvbnN0IHN5bWJvbFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHN5bWJvbFRva2VuLnRleHQ7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIGlnbm9yZSBzcGFjZXMgYmVmb3JlIHN1cC9zdWJzY3JpcHQgYXJndW1lbnRcbiAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VHcm91cChuYW1lKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsIHN5bWJvbFRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHR1YWwgaW5wdXQgb2YgYW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBpbnRvIGEgdGV4dCBub2RlXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gYSBjb2xvciBub2RlIHdob3NlIGNvbG9yIGlzIGRldGVybWluZWQgYnkgZXJyb3JDb2xvclxuICAgKi9cbiAgZm9ybWF0VW5zdXBwb3J0ZWRDbWQodGV4dCkge1xuICAgIGNvbnN0IHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0b3JkQXJyYXkucHVzaCh7IHR5cGU6IFwidGV4dG9yZFwiLCBtb2RlOiBcInRleHRcIiwgdGV4dDogdGV4dFtpXSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0Tm9kZSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgYm9keTogdGV4dG9yZEFycmF5XG4gICAgfTtcblxuICAgIGNvbnN0IGNvbG9yTm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNvbG9yOiB0aGlzLnNldHRpbmdzLmVycm9yQ29sb3IsXG4gICAgICBib2R5OiBbdGV4dE5vZGVdXG4gICAgfTtcblxuICAgIHJldHVybiBjb2xvck5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2l0aCBvcHRpb25hbCBzdXBlci9zdWJzY3JpcHRzLlxuICAgKi9cbiAgcGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAvLyBUaGUgYm9keSBvZiBhbiBhdG9tIGlzIGFuIGltcGxpY2l0IGdyb3VwLCBzbyB0aGF0IHRoaW5ncyBsaWtlXG4gICAgLy8gXFxsZWZ0KHhcXHJpZ2h0KV4yIHdvcmsgY29ycmVjdGx5LlxuICAgIGNvbnN0IGJhc2UgPSB0aGlzLnBhcnNlR3JvdXAoXCJhdG9tXCIsIGJyZWFrT25Ub2tlblRleHQpO1xuXG4gICAgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIC8vIE5vdGUgdGhhdCBiYXNlIG1heSBiZSBlbXB0eSAoaS5lLiBudWxsKSBhdCB0aGlzIHBvaW50LlxuXG4gICAgbGV0IHN1cGVyc2NyaXB0O1xuICAgIGxldCBzdWJzY3JpcHQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIEd1YXJhbnRlZWQgaW4gbWF0aCBtb2RlLCBzbyBlYXQgYW55IHNwYWNlcyBmaXJzdC5cbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuXG4gICAgICAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG4gICAgICBjb25zdCBsZXggPSB0aGlzLmZldGNoKCk7XG5cbiAgICAgIGlmIChsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCIgfHwgbGV4LnRleHQgPT09IFwiXFxcXG5vbGltaXRzXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbGltaXQgY29udHJvbFxuICAgICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BcIikge1xuICAgICAgICAgIGNvbnN0IGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICBiYXNlLmxpbWl0cyA9IGxpbWl0cztcbiAgICAgICAgICBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIpIHtcbiAgICAgICAgICBpZiAoYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpIHtcbiAgICAgICAgICAgIGJhc2UubGltaXRzID0gbGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkxpbWl0IGNvbnRyb2xzIG11c3QgZm9sbG93IGEgbWF0aCBvcGVyYXRvclwiLCBsZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgc3VwZXJzY3JpcHQgc3RhcnRcbiAgICAgICAgaWYgKHN1cGVyc2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcnNjcmlwdCA9IHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3VwZXJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl9cIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBzdWJzY3JpcHQgc3RhcnRcbiAgICAgICAgaWYgKHN1YnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRG91YmxlIHN1YnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdCA9IHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3Vic2NyaXB0XCIpO1xuICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgcHJpbWVcbiAgICAgICAgaWYgKHN1cGVyc2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmltZSA9IHsgdHlwZTogXCJ0ZXh0b3JkXCIsIG1vZGU6IHRoaXMubW9kZSwgdGV4dDogXCJcXFxccHJpbWVcIiB9O1xuXG4gICAgICAgIC8vIE1hbnkgcHJpbWVzIGNhbiBiZSBncm91cGVkIHRvZ2V0aGVyLCBzbyB3ZSBoYW5kbGUgdGhpcyBoZXJlXG4gICAgICAgIGNvbnN0IHByaW1lcyA9IFtwcmltZV07XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBLZWVwIGxleGluZyB0b2tlbnMgdW50aWwgd2UgZ2V0IHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgcHJpbWVcbiAgICAgICAgd2hpbGUgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAgIC8vIEZvciBlYWNoIG9uZSwgYWRkIGFub3RoZXIgcHJpbWUgdG8gdGhlIGxpc3RcbiAgICAgICAgICBwcmltZXMucHVzaChwcmltZSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHN1cGVyc2NyaXB0IGZvbGxvd2luZyB0aGUgcHJpbWVzLCBjb21iaW5lIHRoYXRcbiAgICAgICAgLy8gc3VwZXJzY3JpcHQgaW4gd2l0aCB0aGUgcHJpbWVzLlxuICAgICAgICBpZiAodGhpcy5mZXRjaCgpLnRleHQgPT09IFwiXlwiKSB7XG4gICAgICAgICAgcHJpbWVzLnB1c2godGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHV0IGV2ZXJ5dGhpbmcgaW50byBhbiBvcmRncm91cCBhcyB0aGUgc3VwZXJzY3JpcHRcbiAgICAgICAgc3VwZXJzY3JpcHQgPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogdGhpcy5tb2RlLCBib2R5OiBwcmltZXMgfTtcbiAgICAgIH0gZWxzZSBpZiAodVN1YnNBbmRTdXBzW2xleC50ZXh0XSkge1xuICAgICAgICAvLyBBIFVuaWNvZGUgc3Vic2NyaXB0IG9yIHN1cGVyc2NyaXB0IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gV2UgdHJlYXQgdGhlc2Ugc2ltaWxhcmx5IHRvIHRoZSB1bmljb2RlLW1hdGggcGFja2FnZS5cbiAgICAgICAgLy8gU28gd2UgcmVuZGVyIGEgc3RyaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHRzIHRoZVxuICAgICAgICAvLyBzYW1lIGFzIGEgKHN1YnxzdXBlcilzY3JpcHQgb2YgcmVndWxhciBjaGFyYWN0ZXJzLlxuICAgICAgICBjb25zdCBpc1N1YiA9IHVuaWNvZGVTdWJSZWdFeC50ZXN0KGxleC50ZXh0KTtcbiAgICAgICAgY29uc3Qgc3Vic3VwVG9rZW5zID0gW107XG4gICAgICAgIHN1YnN1cFRva2Vucy5wdXNoKG5ldyBUb2tlbih1U3Vic0FuZFN1cHNbbGV4LnRleHRdKSk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBDb250aW51ZSBmZXRjaGluZyB0b2tlbnMgdG8gZmlsbCBvdXQgdGhlIGdyb3VwLlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5mZXRjaCgpLnRleHQ7XG4gICAgICAgICAgaWYgKCEodVN1YnNBbmRTdXBzW3Rva2VuXSkpIHsgYnJlYWsgfVxuICAgICAgICAgIGlmICh1bmljb2RlU3ViUmVnRXgudGVzdCh0b2tlbikgIT09IGlzU3ViKSB7IGJyZWFrIH1cbiAgICAgICAgICBzdWJzdXBUb2tlbnMudW5zaGlmdChuZXcgVG9rZW4odVN1YnNBbmRTdXBzW3Rva2VuXSkpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBjcmVhdGUgYSAoc3VifHN1cGVyKXNjcmlwdC5cbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuc3VicGFyc2Uoc3Vic3VwVG9rZW5zKTtcbiAgICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgICAgc3Vic2NyaXB0ID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IFwibWF0aFwiLCBib2R5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwZXJzY3JpcHQgPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogXCJtYXRoXCIsIGJvZHkgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQgd2Fzbid0IF4sIF8sIGEgVW5pY29kZSAoc3VifHN1cGVyKXNjcmlwdCwgb3IgJywgc3RvcCBwYXJzaW5nIHN1cGVyL3N1YnNjcmlwdHNcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm11bHRpc2NyaXB0XCIgJiYgIWJhc2UucG9zdHNjcmlwdHMpIHtcbiAgICAgICAgLy8gYmFzZSBpcyB0aGUgcmVzdWx0IG9mIGEgXFxwcmVzY3JpcHQgZnVuY3Rpb24uXG4gICAgICAgIC8vIFdyaXRlIHRoZSBzdWItICYgc3VwZXJzY3JpcHRzIGludG8gdGhlIG11bHRpc2NyaXB0IGVsZW1lbnQuXG4gICAgICAgIGJhc2UucG9zdHNjcmlwdHMgPSB7IHN1cDogc3VwZXJzY3JpcHQsIHN1Yjogc3Vic2NyaXB0IH07XG4gICAgICAgIHJldHVybiBiYXNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgICAgY29uc3QgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyID0gKCFiYXNlIHx8IGJhc2UudHlwZSAhPT0gXCJvcFwiICYmIGJhc2UudHlwZSAhPT0gXCJvcGVyYXRvcm5hbWVcIilcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogaXNEZWxpbWl0ZXIodGhpcy5uZXh0VG9rZW4udGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdXBzdWJcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICBzdXA6IHN1cGVyc2NyaXB0LFxuICAgICAgICAgIHN1Yjogc3Vic2NyaXB0LFxuICAgICAgICAgIGlzRm9sbG93ZWRCeURlbGltaXRlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gZW50aXJlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgaXRzIGJhc2UgYW5kIGFsbCBvZiBpdHMgYXJndW1lbnRzLlxuICAgKi9cbiAgcGFyc2VGdW5jdGlvbihcbiAgICBicmVha09uVG9rZW5UZXh0LFxuICAgIG5hbWUgLy8gRm9yIGRldGVybWluaW5nIGl0cyBjb250ZXh0XG4gICkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IGZ1bmMgPSB0b2tlbi50ZXh0O1xuICAgIGNvbnN0IGZ1bmNEYXRhID0gZnVuY3Rpb25zW2Z1bmNdO1xuICAgIGlmICghZnVuY0RhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gY29uc3VtZSBjb21tYW5kIHRva2VuXG5cbiAgICBpZiAobmFtZSAmJiBuYW1lICE9PSBcImF0b21cIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluQXJndW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIHdpdGggbm8gYXJndW1lbnRzXCIgKyAobmFtZSA/IFwiIGFzIFwiICsgbmFtZSA6IFwiXCIpLFxuICAgICAgICB0b2tlblxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIgJiYgIWZ1bmNEYXRhLmFsbG93ZWRJblRleHQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsIHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIgJiYgZnVuY0RhdGEuYWxsb3dlZEluTWF0aCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gbWF0aCBtb2RlXCIsIHRva2VuKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2QXRvbVR5cGUgPSB0aGlzLnByZXZBdG9tVHlwZTtcbiAgICBjb25zdCB7IGFyZ3MsIG9wdEFyZ3MgfSA9IHRoaXMucGFyc2VBcmd1bWVudHMoZnVuYywgZnVuY0RhdGEpO1xuICAgIHRoaXMucHJldkF0b21UeXBlID0gcHJldkF0b21UeXBlO1xuICAgIHJldHVybiB0aGlzLmNhbGxGdW5jdGlvbihmdW5jLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIGhhbmRsZXIgd2l0aCBhIHN1aXRhYmxlIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAgICovXG4gIGNhbGxGdW5jdGlvbihuYW1lLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBmdW5jTmFtZTogbmFtZSxcbiAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgIHRva2VuLFxuICAgICAgYnJlYWtPblRva2VuVGV4dFxuICAgIH07XG4gICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoZnVuYyAmJiBmdW5jLmhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBmdW5jLmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBObyBmdW5jdGlvbiBoYW5kbGVyIGZvciAke25hbWV9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gb3IgZW52aXJvbm1lbnRcbiAgICovXG4gIHBhcnNlQXJndW1lbnRzKFxuICAgIGZ1bmMsIC8vIFNob3VsZCBsb29rIGxpa2UgXCJcXG5hbWVcIiBvciBcIlxcYmVnaW57bmFtZX1cIi5cbiAgICBmdW5jRGF0YVxuICApIHtcbiAgICBjb25zdCB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgIHJldHVybiB7IGFyZ3M6IFtdLCBvcHRBcmdzOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBjb25zdCBvcHRBcmdzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQXJnczsgaSsrKSB7XG4gICAgICBsZXQgYXJnVHlwZSA9IGZ1bmNEYXRhLmFyZ1R5cGVzICYmIGZ1bmNEYXRhLmFyZ1R5cGVzW2ldO1xuICAgICAgY29uc3QgaXNPcHRpb25hbCA9IGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3M7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKGZ1bmNEYXRhLnByaW1pdGl2ZSAmJiBhcmdUeXBlID09IG51bGwpIHx8XG4gICAgICAgIC8vIFxcc3FydCBleHBhbmRzIGludG8gcHJpbWl0aXZlIGlmIG9wdGlvbmFsIGFyZ3VtZW50IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgKGZ1bmNEYXRhLnR5cGUgPT09IFwic3FydFwiICYmIGkgPT09IDEgJiYgb3B0QXJnc1swXSA9PSBudWxsKVxuICAgICAgKSB7XG4gICAgICAgIGFyZ1R5cGUgPSBcInByaW1pdGl2ZVwiO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmcgPSB0aGlzLnBhcnNlR3JvdXBPZlR5cGUoYGFyZ3VtZW50IHRvICcke2Z1bmN9J2AsIGFyZ1R5cGUsIGlzT3B0aW9uYWwpO1xuICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgb3B0QXJncy5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZyAhPSBudWxsKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlXG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTnVsbCBhcmd1bWVudCwgcGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGFyZ3MsIG9wdEFyZ3MgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCB3aGVuIHRoZSBtb2RlIGlzIGNoYW5naW5nLlxuICAgKi9cbiAgcGFyc2VHcm91cE9mVHlwZShuYW1lLCB0eXBlLCBvcHRpb25hbCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuICAgICAgY2FzZSBcInVybFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVybEdyb3VwKG9wdGlvbmFsKTtcbiAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIHR5cGUpO1xuICAgICAgY2FzZSBcImhib3hcIjoge1xuICAgICAgICAvLyBoYm94IGFyZ3VtZW50IHR5cGUgd3JhcHMgdGhlIGFyZ3VtZW50IGluIHRoZSBlcXVpdmFsZW50IG9mXG4gICAgICAgIC8vIFxcaGJveCwgd2hpY2ggaXMgbGlrZSBcXHRleHQgYnV0IHN3aXRjaGluZyB0byBcXHRleHRzdHlsZSBzaXplLlxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCBcInRleHRcIik7XG4gICAgICAgIHJldHVybiBncm91cCAhPSBudWxsXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgICAgIG1vZGU6IGdyb3VwLm1vZGUsXG4gICAgICAgICAgICBib2R5OiBbZ3JvdXBdLFxuICAgICAgICAgICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiIC8vIHNpbXVsYXRlIFxcdGV4dHN0eWxlXG4gICAgICAgICAgfVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyYXdcIjoge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInJhd1wiLCBvcHRpb25hbCk7XG4gICAgICAgIHJldHVybiB0b2tlbiAhPSBudWxsXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICB0eXBlOiBcInJhd1wiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBzdHJpbmc6IHRva2VuLnRleHRcbiAgICAgICAgICB9XG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuICAgICAgY2FzZSBcInByaW1pdGl2ZVwiOiB7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQSBwcmltaXRpdmUgYXJndW1lbnQgY2Fubm90IGJlIG9wdGlvbmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUpO1xuICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYXMgXCIgKyBuYW1lLCB0aGlzLmZldGNoKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvcmlnaW5hbFwiOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gZ3JvdXAgdHlwZSBhcyBcIiArIG5hbWUsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2NhcmQgYW55IHNwYWNlIHRva2VucywgZmV0Y2hpbmcgdGhlIG5leHQgbm9uLXNwYWNlIHRva2VuLlxuICAgKi9cbiAgY29uc3VtZVNwYWNlcygpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmZldGNoKCkudGV4dDtcbiAgICAgIC8vIFxcdWZlMGUgaXMgdGhlIFVuaWNvZGUgdmFyaWF0aW9uIHNlbGVjdG9yIHRvIHN1cHJlc3MgZW1vamkuIElnbm9yZSBpdC5cbiAgICAgIGlmIChjaCA9PT0gXCIgXCIgfHwgY2ggPT09IFwiXFx1MDBhMFwiIHx8IGNoID09PSBcIlxcdWZlMGVcIikge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwLCBlc3NlbnRpYWxseSByZXR1cm5pbmcgdGhlIHN0cmluZyBmb3JtZWQgYnkgdGhlXG4gICAqIGJyYWNlLWVuY2xvc2VkIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBwYXJzZVN0cmluZ0dyb3VwKFxuICAgIG1vZGVOYW1lLCAvLyBVc2VkIHRvIGRlc2NyaWJlIHRoZSBtb2RlIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgIG9wdGlvbmFsXG4gICkge1xuICAgIGNvbnN0IGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTtcbiAgICBpZiAoYXJnVG9rZW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGxldCBuZXh0VG9rZW47XG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgIHN0ciArPSBuZXh0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gY29uc3VtZSB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudFxuICAgIGFyZ1Rva2VuLnRleHQgPSBzdHI7XG4gICAgcmV0dXJuIGFyZ1Rva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gICAqIHdob3NlIGNvbmNhdGVuYXRlZCBzdHJpbmdzIG1hdGNoIGByZWdleGAuIFJldHVybnMgdGhlIHN0cmluZ1xuICAgKiBmb3JtZWQgYnkgdGhlIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBwYXJzZVJlZ2V4R3JvdXAoXG4gICAgcmVnZXgsXG4gICAgbW9kZU5hbWUgLy8gVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlcy5cbiAgKSB7XG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBsZXQgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBsZXQgbmV4dFRva2VuO1xuICAgIHdoaWxlICgobmV4dFRva2VuID0gdGhpcy5mZXRjaCgpKS50ZXh0ICE9PSBcIkVPRlwiICYmIHJlZ2V4LnRlc3Qoc3RyICsgbmV4dFRva2VuLnRleHQpKSB7XG4gICAgICBsYXN0VG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gICAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIFwiICsgbW9kZU5hbWUgKyBcIjogJ1wiICsgZmlyc3RUb2tlbi50ZXh0ICsgXCInXCIsIGZpcnN0VG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgc2l6ZSBzcGVjaWZpY2F0aW9uLCBjb25zaXN0aW5nIG9mIG1hZ25pdHVkZSBhbmQgdW5pdC5cbiAgICovXG4gIHBhcnNlU2l6ZUdyb3VwKG9wdGlvbmFsKSB7XG4gICAgbGV0IHJlcztcbiAgICBsZXQgaXNCbGFuayA9IGZhbHNlO1xuICAgIC8vIGRvbid0IGV4cGFuZCBiZWZvcmUgcGFyc2VTdHJpbmdHcm91cFxuICAgIHRoaXMuZ3VsbGV0LmNvbnN1bWVTcGFjZXMoKTtcbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwie1wiKSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlUmVnZXhHcm91cCgvXlstK10/ICooPzokfFxcZCt8XFxkK1xcLlxcZCp8XFwuXFxkKikgKlthLXpdezAsMn0gKiQvLCBcInNpemVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInNpemVcIiwgb3B0aW9uYWwpO1xuICAgIH1cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghb3B0aW9uYWwgJiYgcmVzLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBCZWNhdXNlIHdlJ3ZlIHRlc3RlZCBmb3Igd2hhdCBpcyAhb3B0aW9uYWwsIHRoaXMgYmxvY2sgd29uJ3RcbiAgICAgIC8vIGFmZmVjdCBcXGtlcm4sIFxcaHNwYWNlLCBldGMuIEl0IHdpbGwgY2FwdHVyZSB0aGUgbWFuZGF0b3J5IGFyZ3VtZW50c1xuICAgICAgLy8gdG8gXFxnZW5mcmFjIGFuZCBcXGFib3ZlLlxuICAgICAgcmVzLnRleHQgPSBcIjBwdFwiOyAvLyBFbmFibGUgXFxhYm92ZXt9XG4gICAgICBpc0JsYW5rID0gdHJ1ZTsgLy8gVGhpcyBpcyBoZXJlIHNwZWNpZmljYWxseSBmb3IgXFxnZW5mcmFjXG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gc2l6ZVJlZ0V4LmV4ZWMocmVzLnRleHQpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgdW5pdDogbWF0Y2hbM11cbiAgICB9O1xuICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgZGF0YS51bml0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemVcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgaXNCbGFua1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIFVSTCwgY2hlY2tpbmcgZXNjYXBlZCBsZXR0ZXJzIGFuZCBhbGxvd2VkIHByb3RvY29scyxcbiAgICogYW5kIHNldHRpbmcgdGhlIGNhdGNvZGUgb2YgJSBhcyBhbiBhY3RpdmUgY2hhcmFjdGVyIChhcyBpbiBcXGh5cGVycmVmKS5cbiAgICovXG4gIHBhcnNlVXJsR3JvdXAob3B0aW9uYWwpIHtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxMyk7IC8vIGFjdGl2ZSBjaGFyYWN0ZXJcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiflwiLCAxMik7IC8vIG90aGVyIGNoYXJhY3RlclxuICAgIGNvbnN0IHJlcyA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInVybFwiLCBvcHRpb25hbCk7XG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIiVcIiwgMTQpOyAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCJ+XCIsIDEzKTsgLy8gYWN0aXZlIGNoYXJhY3RlclxuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGh5cGVycmVmIHBhY2thZ2UgYWxsb3dzIGJhY2tzbGFzaGVzIGFsb25lIGluIGhyZWYsIGJ1dCBkb2Vzbid0XG4gICAgLy8gZ2VuZXJhdGUgdmFsaWQgbGlua3MgaW4gc3VjaCBjYXNlczsgd2UgaW50ZXJwcmV0IHRoaXMgYXNcbiAgICAvLyBcInVuZGVmaW5lZFwiIGJlaGF2aW91ciwgYW5kIGtlZXAgdGhlbSBhcy1pcy4gU29tZSBicm93c2VyIHdpbGxcbiAgICAvLyByZXBsYWNlIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZCBzbGFzaGVzLlxuICAgIGxldCB1cmwgPSByZXMudGV4dC5yZXBsYWNlKC9cXFxcKFsjJCUmfl9ee31dKS9nLCBcIiQxXCIpO1xuICAgIHVybCA9IHJlcy50ZXh0LnJlcGxhY2UoL3tcXHUyMDQ0fS9nLCBcIi9cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB1cmxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBhcmd1bWVudCB3aXRoIHRoZSBtb2RlIHNwZWNpZmllZC5cbiAgICovXG4gIHBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgbW9kZSkge1xuICAgIGNvbnN0IGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTtcbiAgICBpZiAoYXJnVG9rZW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG91dGVyTW9kZSA9IHRoaXMubW9kZTtcbiAgICBpZiAobW9kZSkge1xuICAgICAgLy8gU3dpdGNoIHRvIHNwZWNpZmllZCBtb2RlXG4gICAgICB0aGlzLnN3aXRjaE1vZGUobW9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJFT0ZcIik7XG4gICAgLy8gVE9ETzogZmluZCBhbiBhbHRlcm5hdGl2ZSB3YXkgdG8gZGVub3RlIHRoZSBlbmRcbiAgICB0aGlzLmV4cGVjdChcIkVPRlwiKTsgLy8gZXhwZWN0IHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50XG4gICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBsb2M6IGFyZ1Rva2VuLmxvYyxcbiAgICAgIGJvZHk6IGV4cHJlc3Npb25cbiAgICB9O1xuXG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIC8vIFN3aXRjaCBtb2RlIGJhY2tcbiAgICAgIHRoaXMuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCwgd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIG51Y2xldXMgKGxpa2UgXCJ4XCIpXG4gICAqIG9yIGFuIGV4cHJlc3Npb24gaW4gYnJhY2VzIChsaWtlIFwie3greX1cIikgb3IgYW4gaW1wbGljaXQgZ3JvdXAsIGEgZ3JvdXBcbiAgICogdGhhdCBzdGFydHMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCBlbmRzIHJpZ2h0IGJlZm9yZSBhIGhpZ2hlciBleHBsaWNpdFxuICAgKiBncm91cCBlbmRzLCBvciBhdCBFT0YuXG4gICAqL1xuICBwYXJzZUdyb3VwKFxuICAgIG5hbWUsIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gICAgYnJlYWtPblRva2VuVGV4dFxuICApIHtcbiAgICBjb25zdCBmaXJzdFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IHRleHQgPSBmaXJzdFRva2VuLnRleHQ7XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIC8vIFRyeSB0byBwYXJzZSBhbiBvcGVuIGJyYWNlIG9yIFxcYmVnaW5ncm91cFxuICAgIGlmICh0ZXh0ID09PSBcIntcIiB8fCB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIgfHwgdGV4dCA9PT0gXCJcXFxcdG9nZ2xlXCIpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgY29uc3QgZ3JvdXBFbmQgPSB0ZXh0ID09PSBcIntcIlxuICAgICAgICA/IFwifVwiXG4gICAgICAgIDogdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiXG4gICAgICAgID8gXCJcXFxcZW5kZ3JvdXBcIlxuICAgICAgICA6IFwiXFxcXGVuZHRvZ2dsZVwiO1xuXG4gICAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gICAgICAvLyBJZiB3ZSBnZXQgYSBicmFjZSwgcGFyc2UgYW4gZXhwcmVzc2lvblxuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBncm91cEVuZCk7XG4gICAgICBjb25zdCBsYXN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgICB0aGlzLmV4cGVjdChncm91cEVuZCk7IC8vIENoZWNrIHRoYXQgd2UgZ290IGEgbWF0Y2hpbmcgY2xvc2luZyBicmFjZVxuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogKGxhc3RUb2tlbi50ZXh0ID09PSBcIlxcXFxlbmR0b2dnbGVcIiA/IFwidG9nZ2xlXCIgOiBcIm9yZGdyb3VwXCIpLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoZmlyc3RUb2tlbiwgbGFzdFRva2VuKSxcbiAgICAgICAgYm9keTogZXhwcmVzc2lvbixcbiAgICAgICAgLy8gQSBncm91cCBmb3JtZWQgYnkgXFxiZWdpbmdyb3VwLi4uXFxlbmRncm91cCBpcyBhIHNlbWktc2ltcGxlIGdyb3VwXG4gICAgICAgIC8vIHdoaWNoIGRvZXNuJ3QgYWZmZWN0IHNwYWNpbmcgaW4gbWF0aCBtb2RlLCBpLmUuLCBpcyB0cmFuc3BhcmVudC5cbiAgICAgICAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE5MzAvXG4gICAgICAgIHNlbWlzaW1wbGU6IHRleHQgPT09IFwiXFxcXGJlZ2luZ3JvdXBcIiB8fCB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBhIGZ1bmN0aW9uIHdpdGggdGhpcyBuYW1lLCBwYXJzZSB0aGUgZnVuY3Rpb24uXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIGEgbnVjbGV1c1xuICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUpIHx8IHRoaXMucGFyc2VTeW1ib2woKTtcbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiB0ZXh0WzBdID09PSBcIlxcXFxcIiAmJlxuICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW1wbGljaXRDb21tYW5kcywgdGV4dCApKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZm9ybWF0VW5zdXBwb3J0ZWRDbWQodGV4dCk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm0gbGlnYXR1cmUtbGlrZSBjb21iaW5hdGlvbnMgb2YgY2hhcmFjdGVycyBmb3IgdGV4dCBtb2RlLlxuICAgKiBUaGlzIGluY2x1ZGVzIGlucHV0cyBsaWtlIFwiLS1cIiwgXCItLS1cIiwgXCJgYFwiIGFuZCBcIicnXCIuXG4gICAqIFRoZSByZXN1bHQgd2lsbCBzaW1wbHkgcmVwbGFjZSBtdWx0aXBsZSB0ZXh0b3JkIG5vZGVzIHdpdGggYSBzaW5nbGVcbiAgICogY2hhcmFjdGVyIGluIGVhY2ggdmFsdWUgYnkgYSBzaW5nbGUgdGV4dG9yZCBub2RlIGhhdmluZyBtdWx0aXBsZVxuICAgKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuXG4gICAqIFRoZSBncm91cCB3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKi9cbiAgZm9ybUxpZ2F0dXJlcyhncm91cCkge1xuICAgIGxldCBuID0gZ3JvdXAubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgYSA9IGdyb3VwW2ldO1xuICAgICAgY29uc3QgdiA9IGEudGV4dDtcbiAgICAgIGlmICh2ID09PSBcIi1cIiAmJiBncm91cFtpICsgMV0udGV4dCA9PT0gXCItXCIpIHtcbiAgICAgICAgaWYgKGkgKyAxIDwgbiAmJiBncm91cFtpICsgMl0udGV4dCA9PT0gXCItXCIpIHtcbiAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMywge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDJdKSxcbiAgICAgICAgICAgIHRleHQ6IFwiLS0tXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuIC09IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAxXSksXG4gICAgICAgICAgICB0ZXh0OiBcIi0tXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuIC09IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgodiA9PT0gXCInXCIgfHwgdiA9PT0gXCJgXCIpICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSB2KSB7XG4gICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgIHRleHQ6IHYgKyB2XG4gICAgICAgIH0pO1xuICAgICAgICBuIC09IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc2luZ2xlIHN5bWJvbCBvdXQgb2YgdGhlIHN0cmluZy4gSGVyZSwgd2UgaGFuZGxlIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICogc3ltYm9scyBhbmQgc3BlY2lhbCBmdW5jdGlvbnMgbGlrZSBcXHZlcmIuXG4gICAqL1xuICBwYXJzZVN5bWJvbCgpIHtcbiAgICBjb25zdCBudWNsZXVzID0gdGhpcy5mZXRjaCgpO1xuICAgIGxldCB0ZXh0ID0gbnVjbGV1cy50ZXh0O1xuXG4gICAgaWYgKC9eXFxcXHZlcmJbXmEtekEtWl0vLnRlc3QodGV4dCkpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgbGV0IGFyZyA9IHRleHQuc2xpY2UoNSk7XG4gICAgICBjb25zdCBzdGFyID0gYXJnLmNoYXJBdCgwKSA9PT0gXCIqXCI7XG4gICAgICBpZiAoc3Rhcikge1xuICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICAvLyBMZXhlcidzIHRva2VuUmVnZXggaXMgY29uc3RydWN0ZWQgdG8gYWx3YXlzIGhhdmUgbWF0Y2hpbmdcbiAgICAgIC8vIGZpcnN0L2xhc3QgY2hhcmFjdGVycy5cbiAgICAgIGlmIChhcmcubGVuZ3RoIDwgMiB8fCBhcmcuY2hhckF0KDApICE9PSBhcmcuc2xpY2UoLTEpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBcXFxcdmVyYiBhc3NlcnRpb24gZmFpbGVkIC0tXG4gICAgICAgICAgICAgICAgICAgIHBsZWFzZSByZXBvcnQgd2hhdCBpbnB1dCBjYXVzZWQgdGhpcyBidWdgKTtcbiAgICAgIH1cbiAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7IC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBjaGFyXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInZlcmJcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IGFyZyxcbiAgICAgICAgc3RhclxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYSBzeW1ib2wsIHBvc3NpYmx5IHdpdGggYWNjZW50cy5cbiAgICAvLyBGaXJzdCBleHBhbmQgYW55IGFjY2VudGVkIGJhc2Ugc3ltYm9sIGFjY29yZGluZyB0byB1bmljb2RlU3ltYm9scy5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHVuaWNvZGVTeW1ib2xzLCB0ZXh0WzBdKSAmJlxuICAgICAgdGhpcy5tb2RlID09PSBcIm1hdGhcIiAmJiAhc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRbMF1dKSB7XG4gICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIG5vdCBzdHJpY3QgKFhlVGVYLWNvbXBhdGlibGUpIGluIG1hdGggbW9kZS5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBBY2NlbnRlZCBVbmljb2RlIHRleHQgY2hhcmFjdGVyIFwiJHt0ZXh0WzBdfVwiIHVzZWQgaW4gYCArIGBtYXRoIG1vZGVgLFxuICAgICAgICAgIG51Y2xldXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRleHQgPSB1bmljb2RlU3ltYm9sc1t0ZXh0WzBdXSArIHRleHQuc2xpY2UoMSk7XG4gICAgfVxuICAgIC8vIFN0cmlwIG9mZiBhbnkgY29tYmluaW5nIGNoYXJhY3RlcnNcbiAgICBjb25zdCBtYXRjaCA9IHRoaXMubW9kZSA9PT0gXCJtYXRoXCJcbiAgICAgID8gY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4LmV4ZWModGV4dClcbiAgICAgIDogbnVsbDtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG4gICAgICBpZiAodGV4dCA9PT0gXCJpXCIpIHtcbiAgICAgICAgdGV4dCA9IFwiXFx1MDEzMVwiOyAvLyBkb3RsZXNzIGksIGluIG1hdGggYW5kIHRleHQgbW9kZVxuICAgICAgfSBlbHNlIGlmICh0ZXh0ID09PSBcImpcIikge1xuICAgICAgICB0ZXh0ID0gXCJcXHUwMjM3XCI7IC8vIGRvdGxlc3MgaiwgaW4gbWF0aCBhbmQgdGV4dCBtb2RlXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlY29nbml6ZSBiYXNlIHN5bWJvbFxuICAgIGxldCBzeW1ib2w7XG4gICAgaWYgKHN5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0XSkge1xuICAgICAgbGV0IGdyb3VwID0gc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRdLmdyb3VwO1xuICAgICAgaWYgKGdyb3VwID09PSBcImJpblwiICYmIGJpbkxlZnRDYW5jZWxsZXJzLmluY2x1ZGVzKHRoaXMucHJldkF0b21UeXBlKSkge1xuICAgICAgICAvLyBDaGFuZ2UgZnJvbSBhIGJpbmFyeSBvcGVyYXRvciB0byBhIHVuYXJ5IChwcmVmaXgpIG9wZXJhdG9yXG4gICAgICAgIGdyb3VwID0gXCJvcGVuXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2MgPSBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKTtcbiAgICAgIGxldCBzO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBVE9NUywgZ3JvdXAgKSkge1xuICAgICAgICBjb25zdCBmYW1pbHkgPSBncm91cDtcbiAgICAgICAgcyA9IHtcbiAgICAgICAgICB0eXBlOiBcImF0b21cIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgZmFtaWx5LFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICAgIGlmICgoZmFtaWx5ID09PSBcInJlbFwiIHx8IGZhbWlseSA9PT0gXCJiaW5cIikgJiYgdGhpcy5wcmV2QXRvbVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgaWYgKHRleHRSZWdFeC50ZXN0KGxvYy5sZXhlci5pbnB1dC5zbGljZShsb2MuZW5kKSkpIHtcbiAgICAgICAgICAgIHMubmVlZHNTcGFjaW5nID0gdHJ1ZTsgIC8vIEZpeCBhIE1hdGhNTCBidWcuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYXNjaWlGcm9tU2NyaXB0W3RleHRdKSB7XG4gICAgICAgICAgLy8gVW5pY29kZSAxNCBkaXNhbWJpZ3VhdGVzIGNoYW5jZXJ5IGZyb20gcm91bmRoYW5kLlxuICAgICAgICAgIC8vIFNlZSBodHRwczovL3d3dy51bmljb2RlLm9yZy9jaGFydHMvUERGL1UxRDQwMC5wZGZcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICBjb25zdCBuZXh0Q29kZSA9IHRoaXMuZmV0Y2goKS50ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgLy8gbWF0aGNhbCBpcyBUZW1tbCBkZWZhdWx0LiBVc2UgbWF0aHNjcmlwdCBpZiBjYWxsZWQgZm9yLlxuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXh0Q29kZSA9PT0gMHhmZTAxID8gXCJtYXRoc2NyXCIgOiBcIm1hdGhjYWxcIjtcbiAgICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4ZmUwMCB8fCBuZXh0Q29kZSA9PT0gMHhmZTAxKSB7IHRoaXMuY29uc3VtZSgpOyB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgYm9keTogeyB0eXBlOiBcIm1hdGhvcmRcIiwgbW9kZTogXCJtYXRoXCIsIGxvYywgdGV4dDogYXNjaWlGcm9tU2NyaXB0W3RleHRdIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBvcmQgY2hhcmFjdGVyLiBObyBkaXNhbWJpZ3VhdGlvbiBuZWNlc3NhcnkuXG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogZ3JvdXAsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzeW1ib2wgPSBzO1xuICAgIH0gZWxzZSBpZiAodGV4dC5jaGFyQ29kZUF0KDApID49IDB4ODAgfHwgY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4LmV4ZWModGV4dCkpIHtcbiAgICAgIC8vIG5vIHN5bWJvbCBmb3IgZS5nLiBeXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QgJiYgdGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcIiR7dGV4dFswXX1cIiB1c2VkIGluIG1hdGggbW9kZWAsIG51Y2xldXMpXG4gICAgICB9XG4gICAgICAvLyBBbGwgbm9ubWF0aGVtYXRpY2FsIFVuaWNvZGUgY2hhcmFjdGVycyBhcmUgcmVuZGVyZWQgYXMgaWYgdGhleVxuICAgICAgLy8gYXJlIGluIHRleHQgbW9kZSAod3JhcHBlZCBpbiBcXHRleHQpIGJlY2F1c2UgdGhhdCdzIHdoYXQgaXRcbiAgICAgIC8vIHRha2VzIHRvIHJlbmRlciB0aGVtIGluIExhVGVYLlxuICAgICAgc3ltYm9sID0ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBFT0YsIF4sIF8sIHssIH0sIGV0Yy5cbiAgICB9XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgLy8gVHJhbnNmb3JtIGNvbWJpbmluZyBjaGFyYWN0ZXJzIGludG8gYWNjZW50c1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaFswXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhY2NlbnQgPSBtYXRjaFswXVtpXTtcbiAgICAgICAgaWYgKCF1bmljb2RlQWNjZW50c1thY2NlbnRdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFVua25vd24gYWNjZW50ICcgJHthY2NlbnR9J2AsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB1bmljb2RlQWNjZW50c1thY2NlbnRdW3RoaXMubW9kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWNvZGVBY2NlbnRzW2FjY2VudF0udGV4dDtcbiAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEFjY2VudCAke2FjY2VudH0gdW5zdXBwb3J0ZWQgaW4gJHt0aGlzLm1vZGV9IG1vZGVgLCBudWNsZXVzKTtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2wgPSB7XG4gICAgICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgICBsYWJlbDogY29tbWFuZCxcbiAgICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgICAgICBiYXNlOiBzeW1ib2xcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbmNvbnN0IHBhcnNlVHJlZSA9IGZ1bmN0aW9uKHRvUGFyc2UsIHNldHRpbmdzKSB7XG4gIGlmICghKHR5cGVvZiB0b1BhcnNlID09PSBcInN0cmluZ1wiIHx8IHRvUGFyc2UgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbW1sIGNhbiBvbmx5IHBhcnNlIHN0cmluZyB0eXBlZCBleHByZXNzaW9uXCIpXG4gIH1cbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7XG4gIC8vIEJsYW5rIG91dCBhbnkgXFxkZkB0YWcgdG8gYXZvaWQgc3B1cmlvdXMgXCJEdXBsaWNhdGUgXFx0YWdcIiBlcnJvcnNcbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdO1xuXG4gIGxldCB0cmVlID0gcGFyc2VyLnBhcnNlKCk7XG5cbiAgLy8gTGFUZVggaWdub3JlcyBhIFxcdGFnIHBsYWNlZCBvdXRzaWRlIGFuIEFNUyBlbnZpcm9ubWVudC5cbiAgaWYgKCEodHJlZS5sZW5ndGggPiAwICYmICB0cmVlWzBdLnR5cGUgJiYgdHJlZVswXS50eXBlID09PSBcImFycmF5XCIgJiYgdHJlZVswXS5hZGRFcW5OdW0pKSB7XG4gICAgLy8gSWYgdGhlIGlucHV0IHVzZWQgXFx0YWcsIGl0IHdpbGwgc2V0IHRoZSBcXGRmQHRhZyBtYWNybyB0byB0aGUgdGFnLlxuICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugc2VwYXJhdGVseSBwYXJzZSB0aGUgdGFnIGFuZCB3cmFwIHRoZSB0cmVlLlxuICAgIGlmIChwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXHRhZyB3b3JrcyBvbmx5IGluIGRpc3BsYXkgbW9kZVwiKVxuICAgICAgfVxuICAgICAgcGFyc2VyLmd1bGxldC5mZWVkKFwiXFxcXGRmQHRhZ1wiKTtcbiAgICAgIHRyZWUgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRhZ1wiLFxuICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgIGJvZHk6IHRyZWUsXG4gICAgICAgICAgdGFnOiBwYXJzZXIucGFyc2UoKVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmVlXG59O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3R5bGUgdGhhdCB0aGUgbWF0aG1sQnVpbGRlciBjYXJyaWVzXG4gKiBhcm91bmQgd2l0aCBpdC4gRGF0YSBpcyBoZWxkIGluIGFuIGBTdHlsZWAgb2JqZWN0LCBhbmQgd2hlblxuICogcmVjdXJzaW5nLCBhIG5ldyBgU3R5bGVgIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZSBgLndpdGgqYCBmdW5jdGlvbnMuXG4gKi9cblxuY29uc3Qgc3ViT3JTdXBMZXZlbCA9IFsyLCAyLCAzLCAzXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIFN0eWxlIGNsYXNzLiBJdCBjb250YWlucyB0aGUgY3VycmVudCBzdHlsZS5sZXZlbCwgY29sb3IsIGFuZCBmb250LlxuICpcbiAqIFN0eWxlIG9iamVjdHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC4gVG8gY3JlYXRlIGEgbmV3IFN0eWxlIHdpdGhcbiAqIGRpZmZlcmVudCBwcm9wZXJ0aWVzLCBjYWxsIGEgYC53aXRoKmAgbWV0aG9kLlxuICovXG5jbGFzcyBTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAvLyBTdHlsZS5sZXZlbCBjYW4gYmUgMCB8IDEgfCAyIHwgMywgd2hpY2ggY29ycmVzcG9uZCB0b1xuICAgIC8vICAgICAgIGRpc3BsYXlzdHlsZSwgdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlLlxuICAgIC8vIHN0eWxlLmxldmVsIHVzdWFsbHkgZG9lcyBub3QgZGlyZWN0bHkgc2V0IE1hdGhNTCdzIHNjcmlwdCBsZXZlbC4gTWF0aE1MIGRvZXMgdGhhdCBpdHNlbGYuXG4gICAgLy8gSG93ZXZlciwgQ2hyb21pdW0gZG9lcyBub3Qgc3RvcCBzaHJpbmtpbmcgYWZ0ZXIgc2NyaXB0c2NyaXB0c3R5bGUsIHNvIHdlIGRvIGV4cGxpY2l0bHlcbiAgICAvLyBzZXQgYSBzY3JpcHRsZXZlbCBhdHRyaWJ1dGUgaW4gdGhvc2UgY29uZGl0aW9ucy5cbiAgICAvLyBXZSBhbHNvIHVzZSBzdHlsZS5sZXZlbCB0byB0cmFjayBtYXRoIHN0eWxlIHNvIHRoYXQgd2UgY2FuIGdldCB0aGUgY29ycmVjdFxuICAgIC8vIHNjcmlwdGxldmVsIHdoZW4gbmVlZGVkIGluIHN1cHN1Yi5qcywgbWF0aGNob2ljZS5qcywgb3IgZm9yIGRpbWVuc2lvbnMgaW4gZW0uXG4gICAgdGhpcy5sZXZlbCA9IGRhdGEubGV2ZWw7XG4gICAgdGhpcy5jb2xvciA9IGRhdGEuY29sb3I7ICAvLyBzdHJpbmcgfCB2b2lkXG4gICAgLy8gQSBmb250IGZhbWlseSBhcHBsaWVzIHRvIGEgZ3JvdXAgb2YgZm9udHMgKGkuZS4gU2Fuc1NlcmlmKSwgd2hpbGUgYSBmb250XG4gICAgLy8gcmVwcmVzZW50cyBhIHNwZWNpZmljIGZvbnQgKGkuZS4gU2Fuc1NlcmlmIEJvbGQpLlxuICAgIC8vIFNlZTogaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIyMzUwL2RpZmZlcmVuY2UtYmV0d2Vlbi10ZXh0cm0tYW5kLW1hdGhybVxuICAgIHRoaXMuZm9udCA9IGRhdGEuZm9udCB8fCBcIlwiOyAgICAgICAgICAgICAgICAvLyBzdHJpbmdcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBkYXRhLmZvbnRGYW1pbHkgfHwgXCJcIjsgICAgLy8gc3RyaW5nXG4gICAgdGhpcy5mb250U2l6ZSA9IGRhdGEuZm9udFNpemUgfHwgMS4wOyAgICAgICAvLyBudW1iZXJcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBkYXRhLmZvbnRXZWlnaHQgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRTaGFwZSA9IGRhdGEuZm9udFNoYXBlIHx8IFwiXCI7XG4gICAgdGhpcy5tYXhTaXplID0gZGF0YS5tYXhTaXplOyAgICAgICAgICAgICAgICAvLyBbbnVtYmVyLCBudW1iZXJdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIFwidGhpc1wiLiAgUHJvcGVydGllc1xuICAgKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBzdHlsZSBvYmplY3QuXG4gICAqL1xuICBleHRlbmQoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGxldmVsOiB0aGlzLmxldmVsLFxuICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGZvbnRTaGFwZTogdGhpcy5mb250U2hhcGUsXG4gICAgICBtYXhTaXplOiB0aGlzLm1heFNpemVcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4dGVuc2lvbiwga2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0eWxlKGRhdGEpO1xuICB9XG5cbiAgd2l0aExldmVsKG4pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgbGV2ZWw6IG5cbiAgICB9KTtcbiAgfVxuXG4gIGluY3JlbWVudExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBsZXZlbDogTWF0aC5taW4odGhpcy5sZXZlbCArIDEsIDMpXG4gICAgfSk7XG4gIH1cblxuICBpblN1Yk9yU3VwKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBsZXZlbDogc3ViT3JTdXBMZXZlbFt0aGlzLmxldmVsXVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2xvci5cbiAgICovXG4gIHdpdGhDb2xvcihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBtYXRoIGZvbnQgb3Igb2xkIHRleHQgZm9udC5cbiAgICogQHR5cGUge1t0eXBlXX1cbiAgICovXG4gIHdpdGhGb250KGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzdHlsZSBvYmplY3RzIHdpdGggdGhlIGdpdmVuIGZvbnRGYW1pbHkuXG4gICAqL1xuICB3aXRoVGV4dEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250RmFtaWx5LFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3R5bGUgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgc2l6ZVxuICAgKi9cbiAgd2l0aEZvbnRTaXplKG51bSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250U2l6ZTogbnVtXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG4gIHdpdGhUZXh0Rm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG4gIHdpdGhUZXh0Rm9udFNoYXBlKGZvbnRTaGFwZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250U2hhcGUsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgQ1NTIGNvbG9yIG9mIHRoZSBjdXJyZW50IHN0eWxlIG9iamVjdFxuICAgKi9cbiAgZ2V0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gIH1cbn1cblxuLyogVGVtbWwgUG9zdCBQcm9jZXNzXG4gKiBQb3B1bGF0ZSB0aGUgdGV4dCBjb250ZW50cyBvZiBlYWNoIFxccmVmICYgXFxlcXJlZlxuICpcbiAqIEFzIHdpdGggb3RoZXIgVGVtbWwgY29kZSwgdGhpcyBmaWxlIGlzIHJlbGVhc2VkIHVuZGVyIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHBzOi8vbWl0LWxpY2Vuc2Uub3JnL1xuICovXG5cbmNvbnN0IHZlcnNpb24gPSBcIjAuMTEuMDJcIjtcblxuZnVuY3Rpb24gcG9zdFByb2Nlc3MoYmxvY2spIHtcbiAgY29uc3QgbGFiZWxNYXAgPSB7fTtcbiAgbGV0IGkgPSAwO1xuXG4gIC8vIEdldCBhIGNvbGxlY3Rpb24gb2YgdGhlIHBhcmVudHMgb2YgZWFjaCBcXHRhZyAmIGF1dG8tbnVtYmVyZWQgZXF1YXRpb25cbiAgY29uc3QgYW1zRXFucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RtbC1lcW4nKTtcbiAgZm9yIChsZXQgcGFyZW50IG9mIGFtc0VxbnMpIHtcbiAgICAvLyBBTVMgYXV0b21hdGljYWxseSBudW1iZXJlZCBlcXVhdGlvbi5cbiAgICAvLyBBc3NpZ24gYW4gaWQuXG4gICAgaSArPSAxO1xuICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInRtbC1lcW4tXCIgKyBTdHJpbmcoaSkpO1xuICAgIC8vIE5vIG5lZWQgdG8gd3JpdGUgYSBudW1iZXIgaW50byB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBlbGVtZW50LlxuICAgIC8vIEEgQ1NTIGNvdW50ZXIgaGFzIGRvbmUgdGhhdCBldmVuIGlmIHRoaXMgcG9zdFByb2Nlc3MoKSBmdW5jdGlvbiBpcyBub3QgdXNlZC5cblxuICAgIC8vIEZpbmQgYW55IFxcbGFiZWwgdGhhdCByZWZlcnMgdG8gYW4gQU1TIGF1dG9tYXRpYyBlcW4gbnVtYmVyLlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09IFwibXRhYmxlXCIpIHsgYnJlYWsgfVxuICAgICAgY29uc3QgbGFiZWxzID0gcGFyZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0bWwtbGFiZWxcIik7XG4gICAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaWQgPSBwYXJlbnQuYXR0cmlidXRlcy5pZC52YWx1ZTtcbiAgICAgICAgbGFiZWxNYXBbaWRdID0gU3RyaW5nKGkpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBcXGxhYmVscyBhc3NvY2lhdGVkIHdpdGggXFx0YWdcbiAgY29uc3QgdGFnZ2VkRXFucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RtbC10YWdlcW4nKTtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgdGFnZ2VkRXFucykge1xuICAgIGNvbnN0IGxhYmVscyA9IHBhcmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG1sLWxhYmVsXCIpO1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGFncyA9IHBhcmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG1sLXRhZ1wiKTtcbiAgICAgIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaWQgPSBwYXJlbnQuYXR0cmlidXRlcy5pZC52YWx1ZTtcbiAgICAgICAgbGFiZWxNYXBbaWRdID0gdGFnc1swXS50ZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQb3B1bGF0ZSBcXHJlZiAmIFxcZXFyZWYgdGV4dCBjb250ZW50XG4gIGNvbnN0IHJlZnMgPSBibG9jay5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG1sLXJlZlwiKTtcbiAgWy4uLnJlZnNdLmZvckVhY2gocmVmID0+IHtcbiAgICBjb25zdCBhdHRyID0gcmVmLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgbGV0IHN0ciA9IGxhYmVsTWFwW2F0dHIuc2xpY2UoMSldO1xuICAgIGlmIChyZWYuY2xhc3NOYW1lLmluZGV4T2YoXCJ0bWwtZXFyZWZcIikgPT09IC0xKSB7XG4gICAgICAvLyBcXHJlZi4gT21pdCBwYXJlbnMuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXlxcKC8sIFwiXCIpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcKSQvLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXFxlcXJlZi4gSW5jbHVkZSBwYXJlbnNcbiAgICAgIGlmIChzdHIuY2hhckF0KDApICE9PSBcIihcIikgeyBzdHIgPSBcIihcIiArIHN0cjsgfVxuICAgICAgaWYgKHN0ci5zbGljZSgtMSkgIT09IFwiKVwiKSB7IHN0ciA9ICBzdHIgKyBcIilcIjsgfVxuICAgIH1cbiAgICBjb25zdCBtdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtdGV4dFwiKTtcbiAgICBtdGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHIpKTtcbiAgICBjb25zdCBtYXRoID0gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtYXRoXCIpO1xuICAgIG1hdGguYXBwZW5kQ2hpbGQobXRleHQpO1xuICAgIHJlZi50ZXh0Q29udGVudCA9ICcnO1xuICAgIHJlZi5hcHBlbmRDaGlsZChtYXRoKTtcbiAgfSk7XG59XG5cbmNvbnN0IGZpbmRFbmRPZk1hdGggPSBmdW5jdGlvbihkZWxpbWl0ZXIsIHRleHQsIHN0YXJ0SW5kZXgpIHtcbiAgLy8gQWRhcHRlZCBmcm9tXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaGFuL3BlcnNldXMvYmxvYi9tYXN0ZXIvc3JjL3BlcnNldXMtbWFya2Rvd24uanN4XG4gIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gIGxldCBicmFjZUxldmVsID0gMDtcblxuICBjb25zdCBkZWxpbUxlbmd0aCA9IGRlbGltaXRlci5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGFyYWN0ZXIgPSB0ZXh0W2luZGV4XTtcblxuICAgIGlmIChicmFjZUxldmVsIDw9IDAgJiYgdGV4dC5zbGljZShpbmRleCwgaW5kZXggKyBkZWxpbUxlbmd0aCkgPT09IGRlbGltaXRlcikge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBcIlxcXFxcIikge1xuICAgICAgaW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gXCJ7XCIpIHtcbiAgICAgIGJyYWNlTGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gXCJ9XCIpIHtcbiAgICAgIGJyYWNlTGV2ZWwtLTtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuY29uc3QgZXNjYXBlUmVnZXggPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKTtcbn07XG5cbmNvbnN0IGFtc1JlZ2V4ID0gL15cXFxcKD86YmVnaW58KD86ZXEpP3JlZil7LztcblxuY29uc3Qgc3BsaXRBdERlbGltaXRlcnMgPSBmdW5jdGlvbih0ZXh0LCBkZWxpbWl0ZXJzKSB7XG4gIGxldCBpbmRleDtcbiAgY29uc3QgZGF0YSA9IFtdO1xuXG4gIGNvbnN0IHJlZ2V4TGVmdCA9IG5ldyBSZWdFeHAoXG4gICAgXCIoXCIgKyBkZWxpbWl0ZXJzLm1hcCgoeCkgPT4gZXNjYXBlUmVnZXgoeC5sZWZ0KSkuam9pbihcInxcIikgKyBcIilcIlxuICApO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSB0ZXh0LnNlYXJjaChyZWdleExlZnQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgZGF0YTogdGV4dC5zbGljZSgwLCBpbmRleClcbiAgICAgIH0pO1xuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaW5kZXgpOyAvLyBub3cgdGV4dCBzdGFydHMgd2l0aCBkZWxpbWl0ZXJcbiAgICB9XG4gICAgLy8gLi4uIHNvIHRoaXMgYWx3YXlzIHN1Y2NlZWRzOlxuICAgIGNvbnN0IGkgPSBkZWxpbWl0ZXJzLmZpbmRJbmRleCgoZGVsaW0pID0+IHRleHQuc3RhcnRzV2l0aChkZWxpbS5sZWZ0KSk7XG4gICAgaW5kZXggPSBmaW5kRW5kT2ZNYXRoKGRlbGltaXRlcnNbaV0ucmlnaHQsIHRleHQsIGRlbGltaXRlcnNbaV0ubGVmdC5sZW5ndGgpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCByYXdEYXRhID0gdGV4dC5zbGljZSgwLCBpbmRleCArIGRlbGltaXRlcnNbaV0ucmlnaHQubGVuZ3RoKTtcbiAgICBjb25zdCBtYXRoID0gYW1zUmVnZXgudGVzdChyYXdEYXRhKVxuICAgICAgPyByYXdEYXRhXG4gICAgICA6IHRleHQuc2xpY2UoZGVsaW1pdGVyc1tpXS5sZWZ0Lmxlbmd0aCwgaW5kZXgpO1xuICAgIGRhdGEucHVzaCh7XG4gICAgICB0eXBlOiBcIm1hdGhcIixcbiAgICAgIGRhdGE6IG1hdGgsXG4gICAgICByYXdEYXRhLFxuICAgICAgZGlzcGxheTogZGVsaW1pdGVyc1tpXS5kaXNwbGF5XG4gICAgfSk7XG4gICAgdGV4dCA9IHRleHQuc2xpY2UoaW5kZXggKyBkZWxpbWl0ZXJzW2ldLnJpZ2h0Lmxlbmd0aCk7XG4gIH1cblxuICBpZiAodGV4dCAhPT0gXCJcIikge1xuICAgIGRhdGEucHVzaCh7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIGRhdGE6IHRleHRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuY29uc3QgZGVmYXVsdERlbGltaXRlcnMgPSBbXG4gIHsgbGVmdDogXCIkJFwiLCByaWdodDogXCIkJFwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcKFwiLCByaWdodDogXCJcXFxcKVwiLCBkaXNwbGF5OiBmYWxzZSB9LFxuICAvLyBMYVRlWCB1c2VzICTigKYkLCBidXQgaXQgcnVpbnMgdGhlIGRpc3BsYXkgb2Ygbm9ybWFsIGAkYCBpbiB0ZXh0OlxuICAvLyB7bGVmdDogXCIkXCIsIHJpZ2h0OiBcIiRcIiwgZGlzcGxheTogZmFsc2V9LFxuICAvLyAkIG11c3QgY29tZSBhZnRlciAkJFxuXG4gIC8vIFJlbmRlciBBTVMgZW52aXJvbm1lbnRzIGV2ZW4gaWYgb3V0c2lkZSAkJOKApiQkIGRlbGltaXRlcnMuXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57ZXF1YXRpb259XCIsIHJpZ2h0OiBcIlxcXFxlbmR7ZXF1YXRpb259XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntlcXVhdGlvbip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7ZXF1YXRpb24qfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ259XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ259XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ24qfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ25hdH1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbmF0fVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ25hdCp9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ25hdCp9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntnYXRoZXJ9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Z2F0aGVyfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Z2F0aGVyKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtnYXRoZXIqfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Q0R9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Q0R9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgLy8gRGl0dG8gXFxyZWYgJiBcXGVxcmVmXG4gIHsgbGVmdDogXCJcXFxccmVme1wiLCByaWdodDogXCJ9XCIsIGRpc3BsYXk6IGZhbHNlIH0sXG4gIHsgbGVmdDogXCJcXFxcZXFyZWZ7XCIsIHJpZ2h0OiBcIn1cIiwgZGlzcGxheTogZmFsc2UgfSxcblxuICB7IGxlZnQ6IFwiXFxcXFtcIiwgcmlnaHQ6IFwiXFxcXF1cIiwgZGlzcGxheTogdHJ1ZSB9XG5dO1xuXG5jb25zdCBmaXJzdERyYWZ0RGVsaW1pdGVycyA9IHtcbiAgXCIkXCI6IFtcbiAgICAgICAgIHsgbGVmdDogXCIkJFwiLCByaWdodDogXCIkJFwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gICAgICAgICB7IGxlZnQ6IFwiJGBcIiwgcmlnaHQ6IFwiYCRcIiwgZGlzcGxheTogZmFsc2UgfSxcbiAgICAgICAgIHsgbGVmdDogXCIkXCIsIHJpZ2h0OiBcIiRcIiwgZGlzcGxheTogZmFsc2UgfVxuICBdLFxuICBcIihcIjogW1xuICAgIHsgbGVmdDogXCJcXFxcW1wiLCByaWdodDogXCJcXFxcXVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gICAgeyBsZWZ0OiBcIlxcXFwoXCIsIHJpZ2h0OiBcIlxcXFwpXCIsIGRpc3BsYXk6IGZhbHNlIH1cbiAgXVxufTtcblxuY29uc3QgYW1zRGVsaW1pdGVycyA9IFtcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntlcXVhdGlvbn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtlcXVhdGlvbn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2VxdWF0aW9uKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtlcXVhdGlvbip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWduKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbmF0fVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWduYXR9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbmF0Kn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbmF0Kn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2dhdGhlcn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtnYXRoZXJ9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntnYXRoZXIqfVwiLCByaWdodDogXCJcXFxcZW5ke2dhdGhlcip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntDRH1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtDRH1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXHJlZntcIiwgcmlnaHQ6IFwifVwiLCBkaXNwbGF5OiBmYWxzZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGVxcmVme1wiLCByaWdodDogXCJ9XCIsIGRpc3BsYXk6IGZhbHNlIH1cbl07XG5cbmNvbnN0IGRlbGltaXRlcnNGcm9tS2V5ID0ga2V5ID0+IHtcbiAgaWYgKGtleSA9PT0gXCIkXCIgfHwga2V5ID09PSBcIihcIikge1xuICAgIHJldHVybiBmaXJzdERyYWZ0RGVsaW1pdGVyc1trZXldO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCIkK1wiIHx8IGtleSA9PT0gXCIoK1wiKSB7XG4gICAgY29uc3QgZmlyc3REcmFmdCA9IGZpcnN0RHJhZnREZWxpbWl0ZXJzW2tleS5zbGljZSgwLCAxKV07XG4gICAgcmV0dXJuIGZpcnN0RHJhZnQuY29uY2F0KGFtc0RlbGltaXRlcnMpXG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcImFtc1wiKSB7XG4gICAgcmV0dXJuIGFtc0RlbGltaXRlcnNcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwiYWxsXCIpIHtcbiAgICByZXR1cm4gKGZpcnN0RHJhZnREZWxpbWl0ZXJzW1wiKFwiXSkuY29uY2F0KGZpcnN0RHJhZnREZWxpbWl0ZXJzW1wiJFwiXSkuY29uY2F0KGFtc0RlbGltaXRlcnMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHREZWxpbWl0ZXJzXG4gIH1cbn07XG5cbi8qIE5vdGU6IG9wdGlvbnNDb3B5IGlzIG11dGF0ZWQgYnkgdGhpcyBtZXRob2QuIElmIGl0IGlzIGV2ZXIgZXhwb3NlZCBpbiB0aGVcbiAqIEFQSSwgd2Ugc2hvdWxkIGNvcHkgaXQgYmVmb3JlIG11dGF0aW5nLlxuICovXG5jb25zdCByZW5kZXJNYXRoSW5UZXh0ID0gZnVuY3Rpb24odGV4dCwgb3B0aW9uc0NvcHkpIHtcbiAgY29uc3QgZGF0YSA9IHNwbGl0QXREZWxpbWl0ZXJzKHRleHQsIG9wdGlvbnNDb3B5LmRlbGltaXRlcnMpO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXS50eXBlID09PSBcInRleHRcIikge1xuICAgIC8vIFRoZXJlIGlzIG5vIGZvcm11bGEgaW4gdGhlIHRleHQuXG4gICAgLy8gTGV0J3MgcmV0dXJuIG51bGwgd2hpY2ggbWVhbnMgdGhlcmUgaXMgbm8gbmVlZCB0byByZXBsYWNlXG4gICAgLy8gdGhlIGN1cnJlbnQgdGV4dCBub2RlIHdpdGggYSBuZXcgb25lLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGFbaV0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGFbaV0uZGF0YSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBsZXQgbWF0aCA9IGRhdGFbaV0uZGF0YTtcbiAgICAgIC8vIE92ZXJyaWRlIGFueSBkaXNwbGF5IG1vZGUgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3Mgd2l0aCB0aGF0XG4gICAgICAvLyBkZWZpbmVkIGJ5IHRoZSB0ZXh0IGl0c2VsZlxuICAgICAgb3B0aW9uc0NvcHkuZGlzcGxheU1vZGUgPSBkYXRhW2ldLmRpc3BsYXk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9uc0NvcHkucHJlUHJvY2Vzcykge1xuICAgICAgICAgIG1hdGggPSBvcHRpb25zQ29weS5wcmVQcm9jZXNzKG1hdGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEltcG9ydGluZyByZW5kZXIoKSBmcm9tIHRlbW1sLmpzIHdvdWxkIGJlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgICAgLy8gU28gY2FsbCB0aGUgZ2xvYmFsIHZlcnNpb24uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0ZW1tbC5yZW5kZXIobWF0aCwgc3Bhbiwgb3B0aW9uc0NvcHkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgUGFyc2VFcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNDb3B5LmVycm9yQ2FsbGJhY2soXG4gICAgICAgICAgXCJUZW1tbCBhdXRvLXJlbmRlcjogRmFpbGVkIHRvIHBhcnNlIGBcIiArIGRhdGFbaV0uZGF0YSArIFwiYCB3aXRoIFwiLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YVtpXS5yYXdEYXRhKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuY29uc3QgcmVuZGVyRWxlbSA9IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnNDb3B5KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gZWxlbS5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIC8vIFRleHQgbm9kZVxuICAgICAgY29uc3QgZnJhZyA9IHJlbmRlck1hdGhJblRleHQoY2hpbGROb2RlLnRleHRDb250ZW50LCBvcHRpb25zQ29weSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICBpICs9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBlbGVtLnJlcGxhY2VDaGlsZChmcmFnLCBjaGlsZE5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAvLyBFbGVtZW50IG5vZGVcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IFwiIFwiICsgY2hpbGROb2RlLmNsYXNzTmFtZSArIFwiIFwiO1xuICAgICAgY29uc3Qgc2hvdWxkUmVuZGVyID1cbiAgICAgICAgb3B0aW9uc0NvcHkuaWdub3JlZFRhZ3MuaW5kZXhPZihjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xICYmXG4gICAgICAgIG9wdGlvbnNDb3B5Lmlnbm9yZWRDbGFzc2VzLmV2ZXJ5KCh4KSA9PiBjbGFzc05hbWUuaW5kZXhPZihcIiBcIiArIHggKyBcIiBcIikgPT09IC0xKTtcblxuICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgICByZW5kZXJFbGVtKGNoaWxkTm9kZSwgb3B0aW9uc0NvcHkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGl0J3Mgc29tZXRoaW5nIGVsc2UsIGFuZCBpZ25vcmUgaXQuXG4gIH1cbn07XG5cbmNvbnN0IHJlbmRlck1hdGhJbkVsZW1lbnQgPSBmdW5jdGlvbihlbGVtLCBvcHRpb25zKSB7XG4gIGlmICghZWxlbSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyXCIpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uc0NvcHkgPSB7fTtcblxuICAvLyBPYmplY3QuYXNzaWduKG9wdGlvbnNDb3B5LCBvcHRpb24pXG4gIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgIG9wdGlvbnNDb3B5W29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnNDb3B5LmZlbmNlcykge1xuICAgIG9wdGlvbnNDb3B5LmRlbGltaXRlcnMgPSBkZWxpbWl0ZXJzRnJvbUtleShvcHRpb25zQ29weS5mZW5jZXMpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnNDb3B5LmRlbGltaXRlcnMgPSBvcHRpb25zQ29weS5kZWxpbWl0ZXJzIHx8IGRlZmF1bHREZWxpbWl0ZXJzO1xuICB9XG4gIG9wdGlvbnNDb3B5Lmlnbm9yZWRUYWdzID0gb3B0aW9uc0NvcHkuaWdub3JlZFRhZ3MgfHwgW1xuICAgIFwic2NyaXB0XCIsXG4gICAgXCJub3NjcmlwdFwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInRleHRhcmVhXCIsXG4gICAgXCJwcmVcIixcbiAgICBcImNvZGVcIixcbiAgICBcIm9wdGlvblwiXG4gIF07XG4gIG9wdGlvbnNDb3B5Lmlnbm9yZWRDbGFzc2VzID0gb3B0aW9uc0NvcHkuaWdub3JlZENsYXNzZXMgfHwgW107XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIG9wdGlvbnNDb3B5LmVycm9yQ2FsbGJhY2sgPSBvcHRpb25zQ29weS5lcnJvckNhbGxiYWNrIHx8IGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gRW5hYmxlIHNoYXJpbmcgb2YgZ2xvYmFsIG1hY3JvcyBkZWZpbmVkIHZpYSBgXFxnZGVmYCBiZXR3ZWVuIGRpZmZlcmVudFxuICAvLyBtYXRoIGVsZW1lbnRzIHdpdGhpbiBhIHNpbmdsZSBjYWxsIHRvIGByZW5kZXJNYXRoSW5FbGVtZW50YC5cbiAgb3B0aW9uc0NvcHkubWFjcm9zID0gb3B0aW9uc0NvcHkubWFjcm9zIHx8IHt9O1xuXG4gIHJlbmRlckVsZW0oZWxlbSwgb3B0aW9uc0NvcHkpO1xuICBwb3N0UHJvY2VzcyhlbGVtKTtcbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgVGVtbWwuIEhlcmUsIHdlIGV4cG9zZSBmdW5jdGlvbnMgZm9yXG4gKiByZW5kZXJpbmcgZXhwcmVzc2lvbnMgZWl0aGVyIHRvIERPTSBub2RlcyBvciB0byBtYXJrdXAgc3RyaW5ncy5cbiAqXG4gKiBXZSBhbHNvIGV4cG9zZSB0aGUgUGFyc2VFcnJvciBjbGFzcyB0byBjaGVjayBpZiBlcnJvcnMgdGhyb3duIGZyb20gVGVtbWwgYXJlXG4gKiBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24sIG9yIGVycm9ycyBpbiBqYXZhc2NyaXB0IGhhbmRsaW5nLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykucmVuZGVyfVxuICogUGFyc2UgYW5kIGJ1aWxkIGFuIGV4cHJlc3Npb24sIGFuZCBwbGFjZSB0aGF0IGV4cHJlc3Npb24gaW4gdGhlIERPTSBub2RlXG4gKiBnaXZlbi5cbiAqL1xubGV0IHJlbmRlciA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIGJhc2VOb2RlLCBvcHRpb25zID0ge30pIHtcbiAgYmFzZU5vZGUudGV4dENvbnRlbnQgPSBcIlwiO1xuICBjb25zdCBhbHJlYWR5SW5NYXRoRWxlbWVudCA9IGJhc2VOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJtYXRoXCI7XG4gIGlmIChhbHJlYWR5SW5NYXRoRWxlbWVudCkgeyBvcHRpb25zLndyYXAgPSBcIm5vbmVcIjsgfVxuICBjb25zdCBtYXRoID0gcmVuZGVyVG9NYXRoTUxUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpO1xuICBpZiAoYWxyZWFkeUluTWF0aEVsZW1lbnQpIHtcbiAgICAvLyBUaGUgPG1hdGg+IGVsZW1lbnQgYWxyZWFkeSBleGlzdHMuIFBvcHVsYXRlIGl0LlxuICAgIGJhc2VOb2RlLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICBtYXRoLmNoaWxkcmVuLmZvckVhY2goZSA9PiB7IGJhc2VOb2RlLmFwcGVuZENoaWxkKGUudG9Ob2RlKCkpOyB9KTtcbiAgfSBlbHNlIGlmIChtYXRoLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICBiYXNlTm9kZS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgbWF0aC5jaGlsZHJlbi5mb3JFYWNoKGUgPT4geyBiYXNlTm9kZS5hcHBlbmRDaGlsZChlLnRvTm9kZSgpKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobWF0aC50b05vZGUoKSk7XG4gIH1cbn07XG5cbi8vIFRlbW1sJ3Mgc3R5bGVzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gcXVpcmtzIG1vZGUuIFByaW50IG91dCBhbiBlcnJvciwgYW5kXG4vLyBkaXNhYmxlIHJlbmRlcmluZy5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJXYXJuaW5nOiBUZW1tbCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuIE1ha2Ugc3VyZSB5b3VyIFwiICtcbiAgICAgICAgICBcIndlYnNpdGUgaGFzIGEgc3VpdGFibGUgZG9jdHlwZS5cIlxuICAgICAgKTtcblxuICAgIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUZW1tbCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykucmVuZGVyVG9TdHJpbmd9XG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHJldHVybiB0aGUgbWFya3VwIGZvciB0aGF0LlxuICovXG5jb25zdCByZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgbWFya3VwID0gcmVuZGVyVG9NYXRoTUxUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpLnRvTWFya3VwKCk7XG4gIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5nZW5lcmF0ZVBhcnNlVHJlZX1cbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xuY29uc3QgZ2VuZXJhdGVQYXJzZVRyZWUgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90ZW1tbCcpLmRlZmluZVByZWFtYmxlfVxuICogVGFrZSBhbiBleHByZXNzaW9uIHdoaWNoIGNvbnRhaW5zIGEgcHJlYW1ibGUuXG4gKiBQYXJzZSBpdCBhbmQgcmV0dXJuIHRoZSBtYWNyb3MuXG4gKi9cbmNvbnN0IGRlZmluZVByZWFtYmxlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgc2V0dGluZ3MubWFjcm9zID0ge307XG4gIGlmICghKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbW1sIGNhbiBvbmx5IHBhcnNlIHN0cmluZyB0eXBlZCBleHByZXNzaW9uXCIpXG4gIH1cbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihleHByZXNzaW9uLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIC8vIEJsYW5rIG91dCBhbnkgXFxkZkB0YWcgdG8gYXZvaWQgc3B1cmlvdXMgXCJEdXBsaWNhdGUgXFx0YWdcIiBlcnJvcnNcbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdO1xuICBjb25zdCBtYWNyb3MgPSBwYXJzZXIucGFyc2UoKTtcbiAgcmV0dXJuIG1hY3Jvc1xufTtcblxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYSBUZW1tbCBQYXJzZUVycm9yLFxuICogcmVuZGVycyB0aGUgaW52YWxpZCBMYVRlWCBhcyBhIHNwYW4gd2l0aCBob3ZlciB0aXRsZSBnaXZpbmcgdGhlIFRlbW1sXG4gKiBlcnJvciBtZXNzYWdlLiAgT3RoZXJ3aXNlLCBzaW1wbHkgdGhyb3dzIHRoZSBlcnJvci5cbiAqL1xuY29uc3QgcmVuZGVyRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIFBhcnNlRXJyb3IpKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IG5ldyBTcGFuKFtcInRlbW1sLWVycm9yXCJdLCBbbmV3IFRleHROb2RlJDEoZXhwcmVzc2lvbiArIFwiXFxuXFxuXCIgKyBlcnJvci50b1N0cmluZygpKV0pO1xuICBub2RlLnN0eWxlLmNvbG9yID0gb3B0aW9ucy5lcnJvckNvbG9yO1xuICBub2RlLnN0eWxlLndoaXRlU3BhY2UgPSBcInByZS1saW5lXCI7XG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykucmVuZGVyVG9NYXRoTUxUcmVlfVxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIHRoZSBUZW1tbCBidWlsZCB0cmVlLiBUaGlzIGlzIHVzZWQgZm9yIGFkdmFuY2VkXG4gKiB1c2UgY2FzZXMgKGxpa2UgcmVuZGVyaW5nIHRvIGN1c3RvbSBvdXRwdXQpLlxuICovXG5jb25zdCByZW5kZXJUb01hdGhNTFRyZWUgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICB0cnkge1xuICAgIGNvbnN0IHRyZWUgPSBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IHN0eWxlID0gbmV3IFN0eWxlKHtcbiAgICAgIGxldmVsOiBzZXR0aW5ncy5kaXNwbGF5TW9kZSA/IFN0eWxlTGV2ZWwuRElTUExBWSA6IFN0eWxlTGV2ZWwuVEVYVCxcbiAgICAgIG1heFNpemU6IHNldHRpbmdzLm1heFNpemVcbiAgICB9KTtcbiAgICByZXR1cm4gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgc3R5bGUsIHNldHRpbmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gcmVuZGVyRXJyb3IoZXJyb3IsIGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgfVxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5kZWZhdWx0fSAqL1xudmFyIHRlbW1sJDEgPSB7XG4gIC8qKlxuICAgKiBDdXJyZW50IFRlbW1sIHZlcnNpb25cbiAgICovXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIE1hdGhNTCwgYW5kIGFkZHNcbiAgICogaXQgYXMgYSBjaGlsZCB0byB0aGUgc3BlY2lmaWVkIERPTSBub2RlLlxuICAgKi9cbiAgcmVuZGVyLFxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBNYXRoTUwgc3RyaW5nLFxuICAgKiBmb3Igc2VuZGluZyB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVuZGVyVG9TdHJpbmcsXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgdGhlIG1hdGggZGVsaW1pdGVycyBpbiBhIGdpdmVuIGVsZW1lbnQgb2YgYSBydW5uaW5nIEhUTUwgZG9jdW1lbnRcbiAgICogYW5kIGNvbnZlcnRzIHRoZSBjb250ZW50cyBvZiBlYWNoIGluc3RhbmNlIGludG8gYSA8bWF0aD4gZWxlbWVudC5cbiAgICovXG4gIHJlbmRlck1hdGhJbkVsZW1lbnQsXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgYW4gZW50aXJlIEhUTUwgYmxvY2suXG4gICAqIFdyaXRlcyBBTVMgYXV0by1udW1iZXJzIGFuZCBpbXBsZW1lbnRzIFxccmVme30uXG4gICAqIFR5cGNhbGx5IGNhbGxlZCBvbmNlLCBhZnRlciBhIGxvb3AgaGFzIHJlbmRlcmVkIG1hbnkgaW5kaXZpZHVhbCBzcGFucy5cbiAgICovXG4gIHBvc3RQcm9jZXNzLFxuICAvKipcbiAgICogVGVtbWwgZXJyb3IsIHVzdWFsbHkgZHVyaW5nIHBhcnNpbmcuXG4gICAqL1xuICBQYXJzZUVycm9yLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNldCBvZiBtYWNyb3Mgd2l0aCBkb2N1bWVudC13aWRlIHNjb3BlLlxuICAgKi9cbiAgZGVmaW5lUHJlYW1ibGUsXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIExhVGVYIGludG8gVGVtbWwncyBpbnRlcm5hbCBwYXJzZSB0cmVlIHN0cnVjdHVyZSxcbiAgICogd2l0aG91dCByZW5kZXJpbmcgdG8gSFRNTCBvciBNYXRoTUwuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19wYXJzZTogZ2VuZXJhdGVQYXJzZVRyZWUsXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGEgTWF0aE1MIGludGVybmFsIERPTSB0cmVlXG4gICAqIHJlcHJlc2VudGF0aW9uLCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvTWF0aE1MVHJlZTogcmVuZGVyVG9NYXRoTUxUcmVlLFxuICAvKipcbiAgICogYWRkcyBhIG5ldyBzeW1ib2wgdG8gYnVpbHRpbiBzeW1ib2xzIHRhYmxlXG4gICAqL1xuICBfX2RlZmluZVN5bWJvbDogZGVmaW5lU3ltYm9sLFxuICAvKipcbiAgICogYWRkcyBhIG5ldyBtYWNybyB0byBidWlsdGluIG1hY3JvIGxpc3RcbiAgICovXG4gIF9fZGVmaW5lTWFjcm86IGRlZmluZU1hY3JvXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbW1sJDE7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiZXhwb3J0IHsgRGVmdWRkbGUgfSBmcm9tICcuL2RlZnVkZGxlJztcbmV4cG9ydCB0eXBlIHsgRGVmdWRkbGVPcHRpb25zLCBEZWZ1ZGRsZVJlc3BvbnNlLCBEZWZ1ZGRsZU1ldGFkYXRhIH0gZnJvbSAnLi90eXBlcyc7ICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==