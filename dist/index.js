(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Defuddle"] = factory();
	else
		root["Defuddle"] = factory();
})(typeof self !== "undefined" ? self : this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 315:
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mathStandardizationRules = exports.createStandardMathElement = exports.isBlockMath = exports.getLatexFromElement = exports.getMathMLFromElement = void 0;
const mathml_to_latex_1 = __webpack_require__(/*! mathml-to-latex */ 354);
const temml = __importStar(__webpack_require__(/*! temml */ 914));
const getMathMLFromElement = (el) => {
    console.log('getMathMLFromElement input:', el.outerHTML);
    // 1. Direct MathML content
    if (el.tagName.toLowerCase() === 'math') {
        const isBlock = el.getAttribute('display') === 'block';
        console.log('Direct MathML - isBlock:', isBlock);
        return {
            mathml: el.outerHTML,
            latex: el.getAttribute('alttext') || null,
            isBlock
        };
    }
    // 2. MathML in data-mathml attribute
    const mathmlStr = el.getAttribute('data-mathml');
    if (mathmlStr) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathmlStr;
        const mathElement = tempDiv.querySelector('math');
        if (mathElement) {
            const isBlock = mathElement.getAttribute('display') === 'block';
            console.log('data-mathml - isBlock:', isBlock);
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 3. MathJax assistive MathML
    const assistiveMmlContainer = el.querySelector('.MJX_Assistive_MathML, mjx-assistive-mml');
    console.log('Found assistiveMmlContainer:', assistiveMmlContainer === null || assistiveMmlContainer === void 0 ? void 0 : assistiveMmlContainer.outerHTML);
    if (assistiveMmlContainer) {
        const mathElement = assistiveMmlContainer.querySelector('math');
        console.log('Found mathElement:', mathElement === null || mathElement === void 0 ? void 0 : mathElement.outerHTML);
        if (mathElement) {
            // Check both the math element and container for display mode
            const mathDisplayAttr = mathElement.getAttribute('display');
            const containerDisplayAttr = assistiveMmlContainer.getAttribute('display');
            console.log('Math display attribute:', mathDisplayAttr);
            console.log('Container display attribute:', containerDisplayAttr);
            const isBlock = mathDisplayAttr === 'block' || containerDisplayAttr === 'block';
            console.log('Final isBlock determination:', isBlock);
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 4. KaTeX MathML
    const katexMathml = el.querySelector('.katex-mathml math');
    if (katexMathml) {
        console.log('KaTeX MathML found');
        return {
            mathml: katexMathml.outerHTML,
            latex: null, // We'll get LaTeX separately for KaTeX
            isBlock: false // We'll determine this from container
        };
    }
    console.log('No MathML found');
    return null;
};
exports.getMathMLFromElement = getMathMLFromElement;
const getLatexFromElement = (el) => {
    var _a, _b, _c;
    // Direct data-latex attribute
    const dataLatex = el.getAttribute('data-latex');
    if (dataLatex) {
        return dataLatex;
    }
    // WordPress LaTeX images
    if (el instanceof HTMLImageElement && el.classList.contains('latex')) {
        // Try alt text first as it's cleaner
        const altLatex = el.getAttribute('alt');
        if (altLatex) {
            return altLatex;
        }
        // Fallback to extracting from URL
        const src = el.getAttribute('src');
        if (src) {
            const match = src.match(/latex\.php\?latex=([^&]+)/);
            if (match) {
                return decodeURIComponent(match[1])
                    .replace(/\+/g, ' ') // Replace + with spaces
                    .replace(/%5C/g, '\\'); // Fix escaped backslashes
            }
        }
    }
    // LaTeX in annotation
    const annotation = el.querySelector('annotation[encoding="application/x-tex"]');
    if (annotation === null || annotation === void 0 ? void 0 : annotation.textContent) {
        return annotation.textContent.trim();
    }
    // KaTeX formats
    if (el.matches('.katex')) {
        // Try katex-mathml annotation first
        const katexAnnotation = el.querySelector('.katex-mathml annotation[encoding="application/x-tex"]');
        if (katexAnnotation === null || katexAnnotation === void 0 ? void 0 : katexAnnotation.textContent) {
            return katexAnnotation.textContent.trim();
        }
    }
    // MathJax scripts
    // Important: this will only work if the script has not been removed at an earlier stage
    if (el.matches('script[type="math/tex"]') || el.matches('script[type="math/tex; mode=display"]')) {
        return ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || null;
    }
    // Check for sibling script element
    if (el.parentElement) {
        const siblingScript = el.parentElement.querySelector('script[type="math/tex"], script[type="math/tex; mode=display"]');
        if (siblingScript) {
            return ((_b = siblingScript.textContent) === null || _b === void 0 ? void 0 : _b.trim()) || null;
        }
    }
    // Try to convert MathML to LaTeX as last resort
    const mathml = (0, exports.getMathMLFromElement)(el);
    if (mathml === null || mathml === void 0 ? void 0 : mathml.mathml) {
        try {
            return mathml_to_latex_1.MathMLToLaTeX.convert(mathml.mathml);
        }
        catch (error) {
            console.error('Error converting MathML to LaTeX:', error);
            return null;
        }
    }
    // Fallback to alt text or text content
    return el.getAttribute('alt') || ((_c = el.textContent) === null || _c === void 0 ? void 0 : _c.trim()) || null;
};
exports.getLatexFromElement = getLatexFromElement;
const isBlockMath = (el) => {
    console.log('isBlockMath checking element:', el.outerHTML);
    // 1. Check explicit display attribute
    const displayAttr = el.getAttribute('display');
    console.log('display attribute:', displayAttr);
    if (displayAttr === 'block') {
        return true;
    }
    // 2. Check common class names
    const classNames = el.className.toLowerCase();
    console.log('class names:', classNames);
    if (classNames.includes('display') || classNames.includes('block')) {
        return true;
    }
    // 3. Check container classes
    const container = el.closest('.katex-display, .MathJax_Display, [data-display="block"]');
    console.log('container found:', container === null || container === void 0 ? void 0 : container.outerHTML);
    if (container) {
        return true;
    }
    // 4. Check if preceded by block element
    const prevElement = el.previousElementSibling;
    console.log('previous element:', prevElement === null || prevElement === void 0 ? void 0 : prevElement.outerHTML);
    if ((prevElement === null || prevElement === void 0 ? void 0 : prevElement.tagName.toLowerCase()) === 'p') {
        return true;
    }
    // 5. Check specific formats
    if (el.matches('.mwe-math-fallback-image-display')) {
        return true;
    }
    // 6. Check KaTeX display mode
    if (el.matches('.katex')) {
        // KaTeX elements are inline by default
        // Only block if explicitly marked as display
        return el.closest('.katex-display') !== null;
    }
    // 7. Check MathJax v3 display attribute
    if (el.hasAttribute('display')) {
        console.log('Found display attribute:', el.getAttribute('display'));
        return el.getAttribute('display') === 'true';
    }
    // 8. Check parent container display attribute
    const parentContainer = el.closest('[display]');
    if (parentContainer) {
        console.log('Parent container display:', parentContainer.getAttribute('display'));
        return parentContainer.getAttribute('display') === 'true';
    }
    return false;
};
exports.isBlockMath = isBlockMath;
const createStandardMathElement = (mathData, latex, isBlock) => {
    console.log('createStandardMathElement inputs:', {
        mathData,
        latex,
        isBlock
    });
    const newMath = document.createElement('math');
    // Set MathML namespace
    newMath.setAttribute('xmlns', 'http://www.w3.org/1998/Math/MathML');
    // Set display mode
    newMath.setAttribute('display', isBlock ? 'block' : 'inline');
    // Set LaTeX if available
    if (latex) {
        newMath.setAttribute('data-latex', latex);
    }
    // First try to use existing MathML content
    if (mathData === null || mathData === void 0 ? void 0 : mathData.mathml) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathData.mathml;
        const mathContent = tempDiv.querySelector('math');
        if (mathContent) {
            newMath.innerHTML = mathContent.innerHTML;
        }
    }
    // If no MathML content but we have LaTeX, convert using Temml
    else if (latex) {
        try {
            console.log('Converting LaTeX to MathML:', latex);
            // Convert LaTeX to MathML using Temml
            const mathml = temml.renderToString(latex, {
                displayMode: isBlock,
                throwOnError: false
            });
            console.log('Temml conversion result:', mathml);
            if (typeof mathml === 'string') {
                // Extract the inner content of the math element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = mathml;
                const mathContent = tempDiv.querySelector('math');
                if (mathContent) {
                    // Copy attributes except display mode
                    Array.from(mathContent.attributes).forEach(attr => {
                        if (attr.name !== 'display') {
                            newMath.setAttribute(attr.name, attr.value);
                        }
                    });
                    newMath.innerHTML = mathContent.innerHTML;
                }
                else {
                    // Use the entire output as fallback
                    newMath.innerHTML = mathml;
                }
            }
            else {
                newMath.textContent = latex;
            }
        }
        catch (error) {
            console.error('Error converting LaTeX to MathML:', error);
            newMath.textContent = latex;
        }
    }
    console.log('Created math element:', newMath.outerHTML);
    return newMath;
};
exports.createStandardMathElement = createStandardMathElement;
// Math element standardization rules
exports.mathStandardizationRules = [
    {
        // WordPress LaTeX images
        selector: 'img.latex[src*="latex.php"]',
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLImageElement))
                return el;
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // WordPress LaTeX images are inline by default
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element without MathML
            return (0, exports.createStandardMathElement)(null, latex, isBlock);
        }
    },
    {
        // MathJax elements (v2 and v3)
        selector: [
            'span.MathJax',
            'mjx-container',
            'script[type="math/tex"]',
            'script[type="math/tex; mode=display"]',
            '.MathJax_Preview + script[type="math/tex"]',
            '.MathJax_Display',
            '.MathJax_SVG',
            '.MathJax_MathML'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el) || el.matches('script[type="math/tex; mode=display"]');
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    },
    {
        // MediaWiki math elements
        selector: [
            '.mwe-math-element',
            '.mwe-math-fallback-image-inline',
            '.mwe-math-fallback-image-display',
            '.mwe-math-mathml-inline',
            '.mwe-math-mathml-display',
            'math[xmlns="http://www.w3.org/1998/Math/MathML"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    },
    {
        // KaTeX elements
        selector: [
            '.katex',
            '.katex-display',
            '.katex-mathml',
            '.katex-html',
            '[data-katex]',
            'script[type="math/katex"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    },
    {
        // Generic math elements and other formats
        selector: [
            'math',
            '[data-math]',
            '[data-latex]',
            '[data-tex]',
            'script[type^="math/"]',
            'annotation[encoding="application/x-tex"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    }
];


/***/ }),

/***/ 354:
/*!*********************************************************!*\
  !*** ./node_modules/mathml-to-latex/dist/bundle.min.js ***!
  \*********************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(()=>(()=>{var e={4582:(e,t)=>{"use strict";function r(e,t){return void 0===t&&(t=Object),t&&"function"==typeof t.freeze?t.freeze(e):e}var a=r({HTML:"text/html",isHTML:function(e){return e===a.HTML},XML_APPLICATION:"application/xml",XML_TEXT:"text/xml",XML_XHTML_APPLICATION:"application/xhtml+xml",XML_SVG_IMAGE:"image/svg+xml"}),n=r({HTML:"http://www.w3.org/1999/xhtml",isHTML:function(e){return e===n.HTML},SVG:"http://www.w3.org/2000/svg",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"});t.assign=function(e,t){if(null===e||"object"!=typeof e)throw new TypeError("target is not an object");for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e},t.find=function(e,t,r){if(void 0===r&&(r=Array.prototype),e&&"function"==typeof r.find)return r.find.call(e,t);for(var a=0;a<e.length;a++)if(Object.prototype.hasOwnProperty.call(e,a)){var n=e[a];if(t.call(void 0,n,a,e))return n}},t.freeze=r,t.MIME_TYPE=a,t.NAMESPACE=n},5752:(e,t,r)=>{var a=r(4582),n=r(4722),o=r(6559),i=r(4466),s=n.DOMImplementation,l=a.NAMESPACE,c=i.ParseError,u=i.XMLReader;function h(e){return e.replace(/\r[\n\u0085]/g,"\n").replace(/[\r\u0085\u2028]/g,"\n")}function d(e){this.options=e||{locator:{}}}function m(){this.cdata=!1}function p(e,t){t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber}function f(e){if(e)return"\n@"+(e.systemId||"")+"#[line:"+e.lineNumber+",col:"+e.columnNumber+"]"}function x(e,t,r){return"string"==typeof e?e.substr(t,r):e.length>=t+r||t?new java.lang.String(e,t,r)+"":e}function g(e,t){e.currentElement?e.currentElement.appendChild(t):e.doc.appendChild(t)}d.prototype.parseFromString=function(e,t){var r=this.options,a=new u,n=r.domBuilder||new m,i=r.errorHandler,s=r.locator,c=r.xmlns||{},d=/\/x?html?$/.test(t),p=d?o.HTML_ENTITIES:o.XML_ENTITIES;s&&n.setDocumentLocator(s),a.errorHandler=function(e,t,r){if(!e){if(t instanceof m)return t;e=t}var a={},n=e instanceof Function;function o(t){var o=e[t];!o&&n&&(o=2==e.length?function(r){e(t,r)}:e),a[t]=o&&function(e){o("[xmldom "+t+"]\t"+e+f(r))}||function(){}}return r=r||{},o("warning"),o("error"),o("fatalError"),a}(i,n,s),a.domBuilder=r.domBuilder||n,d&&(c[""]=l.HTML),c.xml=c.xml||l.XML;var x=r.normalizeLineEndings||h;return e&&"string"==typeof e?a.parse(x(e),c,p):a.errorHandler.error("invalid doc source"),n.doc},m.prototype={startDocument:function(){this.doc=(new s).createDocument(null,null,null),this.locator&&(this.doc.documentURI=this.locator.systemId)},startElement:function(e,t,r,a){var n=this.doc,o=n.createElementNS(e,r||t),i=a.length;g(this,o),this.currentElement=o,this.locator&&p(this.locator,o);for(var s=0;s<i;s++){e=a.getURI(s);var l=a.getValue(s),c=(r=a.getQName(s),n.createAttributeNS(e,r));this.locator&&p(a.getLocator(s),c),c.value=c.nodeValue=l,o.setAttributeNode(c)}},endElement:function(e,t,r){var a=this.currentElement;a.tagName,this.currentElement=a.parentNode},startPrefixMapping:function(e,t){},endPrefixMapping:function(e){},processingInstruction:function(e,t){var r=this.doc.createProcessingInstruction(e,t);this.locator&&p(this.locator,r),g(this,r)},ignorableWhitespace:function(e,t,r){},characters:function(e,t,r){if(e=x.apply(this,arguments)){if(this.cdata)var a=this.doc.createCDATASection(e);else a=this.doc.createTextNode(e);this.currentElement?this.currentElement.appendChild(a):/^\s*$/.test(e)&&this.doc.appendChild(a),this.locator&&p(this.locator,a)}},skippedEntity:function(e){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(e){(this.locator=e)&&(e.lineNumber=0)},comment:function(e,t,r){e=x.apply(this,arguments);var a=this.doc.createComment(e);this.locator&&p(this.locator,a),g(this,a)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(e,t,r){var a=this.doc.implementation;if(a&&a.createDocumentType){var n=a.createDocumentType(e,t,r);this.locator&&p(this.locator,n),g(this,n),this.doc.doctype=n}},warning:function(e){console.warn("[xmldom warning]\t"+e,f(this.locator))},error:function(e){console.error("[xmldom error]\t"+e,f(this.locator))},fatalError:function(e){throw new c(e,this.locator)}},"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,(function(e){m.prototype[e]=function(){return null}})),t.DOMParser=d},4722:(e,t,r)=>{var a=r(4582),n=a.find,o=a.NAMESPACE;function i(e){return""!==e}function s(e,t){return e.hasOwnProperty(t)||(e[t]=!0),e}function l(e){if(!e)return[];var t=function(e){return e?e.split(/[\t\n\f\r ]+/).filter(i):[]}(e);return Object.keys(t.reduce(s,{}))}function c(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function u(e,t){var r=e.prototype;if(!(r instanceof t)){function a(){}a.prototype=t.prototype,c(r,a=new a),e.prototype=r=a}r.constructor!=e&&("function"!=typeof e&&console.error("unknown Class:"+e),r.constructor=e)}var h={},d=h.ELEMENT_NODE=1,m=h.ATTRIBUTE_NODE=2,p=h.TEXT_NODE=3,f=h.CDATA_SECTION_NODE=4,x=h.ENTITY_REFERENCE_NODE=5,g=h.ENTITY_NODE=6,w=h.PROCESSING_INSTRUCTION_NODE=7,b=h.COMMENT_NODE=8,v=h.DOCUMENT_NODE=9,C=h.DOCUMENT_TYPE_NODE=10,A=h.DOCUMENT_FRAGMENT_NODE=11,E=h.NOTATION_NODE=12,_={},y={},q=(_.INDEX_SIZE_ERR=(y[1]="Index size error",1),_.DOMSTRING_SIZE_ERR=(y[2]="DOMString size error",2),_.HIERARCHY_REQUEST_ERR=(y[3]="Hierarchy request error",3)),D=(_.WRONG_DOCUMENT_ERR=(y[4]="Wrong document",4),_.INVALID_CHARACTER_ERR=(y[5]="Invalid character",5),_.NO_DATA_ALLOWED_ERR=(y[6]="No data allowed",6),_.NO_MODIFICATION_ALLOWED_ERR=(y[7]="No modification allowed",7),_.NOT_FOUND_ERR=(y[8]="Not found",8)),M=(_.NOT_SUPPORTED_ERR=(y[9]="Not supported",9),_.INUSE_ATTRIBUTE_ERR=(y[10]="Attribute in use",10));function T(e,t){if(t instanceof Error)var r=t;else r=this,Error.call(this,y[e]),this.message=y[e],Error.captureStackTrace&&Error.captureStackTrace(this,T);return r.code=e,t&&(this.message=this.message+": "+t),r}function N(){}function O(e,t){this._node=e,this._refresh=t,L(this)}function L(e){var t=e._node._inc||e._node.ownerDocument._inc;if(e._inc!==t){var r=e._refresh(e._node);if(we(e,"length",r.length),!e.$$length||r.length<e.$$length)for(var a=r.length;a in e;a++)Object.prototype.hasOwnProperty.call(e,a)&&delete e[a];c(r,e),e._inc=t}}function B(){}function S(e,t){for(var r=e.length;r--;)if(e[r]===t)return r}function F(e,t,r,a){if(a?t[S(t,a)]=r:t[t.length++]=r,e){r.ownerElement=e;var n=e.ownerDocument;n&&(a&&V(n,e,a),function(e,t,r){e&&e._inc++,r.namespaceURI===o.XMLNS&&(t._nsMap[r.prefix?r.localName:""]=r.value)}(n,e,r))}}function P(e,t,r){var a=S(t,r);if(!(a>=0))throw new T(D,new Error(e.tagName+"@"+r));for(var n=t.length-1;a<n;)t[a]=t[++a];if(t.length=n,e){var o=e.ownerDocument;o&&(V(o,e,r),r.ownerElement=null)}}function k(){}function R(){}function I(e){return("<"==e?"&lt;":">"==e&&"&gt;")||"&"==e&&"&amp;"||'"'==e&&"&quot;"||"&#"+e.charCodeAt()+";"}function U(e,t){if(t(e))return!0;if(e=e.firstChild)do{if(U(e,t))return!0}while(e=e.nextSibling)}function j(){this.ownerDocument=this}function V(e,t,r,a){e&&e._inc++,r.namespaceURI===o.XMLNS&&delete t._nsMap[r.prefix?r.localName:""]}function G(e,t,r){if(e&&e._inc){e._inc++;var a=t.childNodes;if(r)a[a.length++]=r;else{for(var n=t.firstChild,o=0;n;)a[o++]=n,n=n.nextSibling;a.length=o,delete a[a.length]}}}function $(e,t){var r=t.previousSibling,a=t.nextSibling;return r?r.nextSibling=a:e.firstChild=a,a?a.previousSibling=r:e.lastChild=r,t.parentNode=null,t.previousSibling=null,t.nextSibling=null,G(e.ownerDocument,e),t}function X(e){return e&&e.nodeType===R.DOCUMENT_TYPE_NODE}function H(e){return e&&e.nodeType===R.ELEMENT_NODE}function W(e){return e&&e.nodeType===R.TEXT_NODE}function z(e,t){var r=e.childNodes||[];if(n(r,H)||X(t))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function Y(e,t){var r=e.childNodes||[];if(n(r,(function(e){return H(e)&&e!==t})))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function J(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!z(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!z(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,X))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element");if(!r&&s)throw new T(q,"Doctype can not be appended since element is present")}}function Z(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!Y(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!Y(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,(function(e){return X(e)&&e!==r})))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element")}}function Q(e,t,r,a){(function(e,t,r){if(!function(e){return e&&(e.nodeType===R.DOCUMENT_NODE||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.ELEMENT_NODE)}(e))throw new T(q,"Unexpected parent node type "+e.nodeType);if(r&&r.parentNode!==e)throw new T(D,"child not in parent");if(!function(e){return e&&(H(e)||W(e)||X(e)||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.COMMENT_NODE||e.nodeType===R.PROCESSING_INSTRUCTION_NODE)}(t)||X(t)&&e.nodeType!==R.DOCUMENT_NODE)throw new T(q,"Unexpected node type "+t.nodeType+" for parent node type "+e.nodeType)})(e,t,r),e.nodeType===R.DOCUMENT_NODE&&(a||J)(e,t,r);var n=t.parentNode;if(n&&n.removeChild(t),t.nodeType===A){var o=t.firstChild;if(null==o)return t;var i=t.lastChild}else o=i=t;var s=r?r.previousSibling:e.lastChild;o.previousSibling=s,i.nextSibling=r,s?s.nextSibling=o:e.firstChild=o,null==r?e.lastChild=i:r.previousSibling=i;do{o.parentNode=e}while(o!==i&&(o=o.nextSibling));return G(e.ownerDocument||e,e),t.nodeType==A&&(t.firstChild=t.lastChild=null),t}function K(){this._nsMap={}}function ee(){}function te(){}function re(){}function ae(){}function ne(){}function oe(){}function ie(){}function se(){}function le(){}function ce(){}function ue(){}function he(){}function de(e,t){var r=[],a=9==this.nodeType&&this.documentElement||this,n=a.prefix,o=a.namespaceURI;if(o&&null==n&&null==(n=a.lookupPrefix(o)))var i=[{namespace:o,prefix:null}];return fe(this,r,e,t,i),r.join("")}function me(e,t,r){var a=e.prefix||"",n=e.namespaceURI;if(!n)return!1;if("xml"===a&&n===o.XML||n===o.XMLNS)return!1;for(var i=r.length;i--;){var s=r[i];if(s.prefix===a)return s.namespace!==n}return!0}function pe(e,t,r){e.push(" ",t,'="',r.replace(/[<>&"\t\n\r]/g,I),'"')}function fe(e,t,r,a,n){if(n||(n=[]),a){if(!(e=a(e)))return;if("string"==typeof e)return void t.push(e)}switch(e.nodeType){case d:var i=e.attributes,s=i.length,l=e.firstChild,c=e.tagName,u=c;if(!(r=o.isHTML(e.namespaceURI)||r)&&!e.prefix&&e.namespaceURI){for(var h,g=0;g<i.length;g++)if("xmlns"===i.item(g).name){h=i.item(g).value;break}if(!h)for(var E=n.length-1;E>=0;E--)if(""===(_=n[E]).prefix&&_.namespace===e.namespaceURI){h=_.namespace;break}if(h!==e.namespaceURI)for(E=n.length-1;E>=0;E--){var _;if((_=n[E]).namespace===e.namespaceURI){_.prefix&&(u=_.prefix+":"+c);break}}}t.push("<",u);for(var y=0;y<s;y++)"xmlns"==(q=i.item(y)).prefix?n.push({prefix:q.localName,namespace:q.value}):"xmlns"==q.nodeName&&n.push({prefix:"",namespace:q.value});for(y=0;y<s;y++){var q,D,M;me(q=i.item(y),0,n)&&(pe(t,(D=q.prefix||"")?"xmlns:"+D:"xmlns",M=q.namespaceURI),n.push({prefix:D,namespace:M})),fe(q,t,r,a,n)}if(c===u&&me(e,0,n)&&(pe(t,(D=e.prefix||"")?"xmlns:"+D:"xmlns",M=e.namespaceURI),n.push({prefix:D,namespace:M})),l||r&&!/^(?:meta|link|img|br|hr|input)$/i.test(c)){if(t.push(">"),r&&/^script$/i.test(c))for(;l;)l.data?t.push(l.data):fe(l,t,r,a,n.slice()),l=l.nextSibling;else for(;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;t.push("</",u,">")}else t.push("/>");return;case v:case A:for(l=e.firstChild;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;return;case m:return pe(t,e.name,e.value);case p:return t.push(e.data.replace(/[<&>]/g,I));case f:return t.push("<![CDATA[",e.data,"]]>");case b:return t.push("\x3c!--",e.data,"--\x3e");case C:var T=e.publicId,N=e.systemId;if(t.push("<!DOCTYPE ",e.name),T)t.push(" PUBLIC ",T),N&&"."!=N&&t.push(" ",N),t.push(">");else if(N&&"."!=N)t.push(" SYSTEM ",N,">");else{var O=e.internalSubset;O&&t.push(" [",O,"]"),t.push(">")}return;case w:return t.push("<?",e.target," ",e.data,"?>");case x:return t.push("&",e.nodeName,";");default:t.push("??",e.nodeName)}}function xe(e,t,r){var a;switch(t.nodeType){case d:(a=t.cloneNode(!1)).ownerDocument=e;case A:break;case m:r=!0}if(a||(a=t.cloneNode(!1)),a.ownerDocument=e,a.parentNode=null,r)for(var n=t.firstChild;n;)a.appendChild(xe(e,n,r)),n=n.nextSibling;return a}function ge(e,t,r){var a=new t.constructor;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var o=t[n];"object"!=typeof o&&o!=a[n]&&(a[n]=o)}switch(t.childNodes&&(a.childNodes=new N),a.ownerDocument=e,a.nodeType){case d:var i=t.attributes,s=a.attributes=new B,l=i.length;s._ownerElement=a;for(var c=0;c<l;c++)a.setAttributeNode(ge(e,i.item(c),!0));break;case m:r=!0}if(r)for(var u=t.firstChild;u;)a.appendChild(ge(e,u,r)),u=u.nextSibling;return a}function we(e,t,r){e[t]=r}_.INVALID_STATE_ERR=(y[11]="Invalid state",11),_.SYNTAX_ERR=(y[12]="Syntax error",12),_.INVALID_MODIFICATION_ERR=(y[13]="Invalid modification",13),_.NAMESPACE_ERR=(y[14]="Invalid namespace",14),_.INVALID_ACCESS_ERR=(y[15]="Invalid access",15),T.prototype=Error.prototype,c(_,T),N.prototype={length:0,item:function(e){return e>=0&&e<this.length?this[e]:null},toString:function(e,t){for(var r=[],a=0;a<this.length;a++)fe(this[a],r,e,t);return r.join("")},filter:function(e){return Array.prototype.filter.call(this,e)},indexOf:function(e){return Array.prototype.indexOf.call(this,e)}},O.prototype.item=function(e){return L(this),this[e]||null},u(O,N),B.prototype={length:0,item:N.prototype.item,getNamedItem:function(e){for(var t=this.length;t--;){var r=this[t];if(r.nodeName==e)return r}},setNamedItem:function(e){var t=e.ownerElement;if(t&&t!=this._ownerElement)throw new T(M);var r=this.getNamedItem(e.nodeName);return F(this._ownerElement,this,e,r),r},setNamedItemNS:function(e){var t,r=e.ownerElement;if(r&&r!=this._ownerElement)throw new T(M);return t=this.getNamedItemNS(e.namespaceURI,e.localName),F(this._ownerElement,this,e,t),t},removeNamedItem:function(e){var t=this.getNamedItem(e);return P(this._ownerElement,this,t),t},removeNamedItemNS:function(e,t){var r=this.getNamedItemNS(e,t);return P(this._ownerElement,this,r),r},getNamedItemNS:function(e,t){for(var r=this.length;r--;){var a=this[r];if(a.localName==t&&a.namespaceURI==e)return a}return null}},k.prototype={hasFeature:function(e,t){return!0},createDocument:function(e,t,r){var a=new j;if(a.implementation=this,a.childNodes=new N,a.doctype=r||null,r&&a.appendChild(r),t){var n=a.createElementNS(e,t);a.appendChild(n)}return a},createDocumentType:function(e,t,r){var a=new oe;return a.name=e,a.nodeName=e,a.publicId=t||"",a.systemId=r||"",a}},R.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(e,t){return Q(this,e,t)},replaceChild:function(e,t){Q(this,e,t,Z),t&&this.removeChild(t)},removeChild:function(e){return $(this,e)},appendChild:function(e){return this.insertBefore(e,null)},hasChildNodes:function(){return null!=this.firstChild},cloneNode:function(e){return ge(this.ownerDocument||this,this,e)},normalize:function(){for(var e=this.firstChild;e;){var t=e.nextSibling;t&&t.nodeType==p&&e.nodeType==p?(this.removeChild(t),e.appendData(t.data)):(e.normalize(),e=t)}},isSupported:function(e,t){return this.ownerDocument.implementation.hasFeature(e,t)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(e){for(var t=this;t;){var r=t._nsMap;if(r)for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a)&&r[a]===e)return a;t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},lookupNamespaceURI:function(e){for(var t=this;t;){var r=t._nsMap;if(r&&Object.prototype.hasOwnProperty.call(r,e))return r[e];t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},isDefaultNamespace:function(e){return null==this.lookupPrefix(e)}},c(h,R),c(h,R.prototype),j.prototype={nodeName:"#document",nodeType:v,doctype:null,documentElement:null,_inc:1,insertBefore:function(e,t){if(e.nodeType==A){for(var r=e.firstChild;r;){var a=r.nextSibling;this.insertBefore(r,t),r=a}return e}return Q(this,e,t),e.ownerDocument=this,null===this.documentElement&&e.nodeType===d&&(this.documentElement=e),e},removeChild:function(e){return this.documentElement==e&&(this.documentElement=null),$(this,e)},replaceChild:function(e,t){Q(this,e,t,Z),e.ownerDocument=this,t&&this.removeChild(t),H(e)&&(this.documentElement=e)},importNode:function(e,t){return xe(this,e,t)},getElementById:function(e){var t=null;return U(this.documentElement,(function(r){if(r.nodeType==d&&r.getAttribute("id")==e)return t=r,!0})),t},getElementsByClassName:function(e){var t=l(e);return new O(this,(function(r){var a=[];return t.length>0&&U(r.documentElement,(function(n){if(n!==r&&n.nodeType===d){var o=n.getAttribute("class");if(o){var i=e===o;if(!i){var s=l(o);i=t.every((c=s,function(e){return c&&-1!==c.indexOf(e)}))}i&&a.push(n)}}var c})),a}))},createElement:function(e){var t=new K;return t.ownerDocument=this,t.nodeName=e,t.tagName=e,t.localName=e,t.childNodes=new N,(t.attributes=new B)._ownerElement=t,t},createDocumentFragment:function(){var e=new ce;return e.ownerDocument=this,e.childNodes=new N,e},createTextNode:function(e){var t=new re;return t.ownerDocument=this,t.appendData(e),t},createComment:function(e){var t=new ae;return t.ownerDocument=this,t.appendData(e),t},createCDATASection:function(e){var t=new ne;return t.ownerDocument=this,t.appendData(e),t},createProcessingInstruction:function(e,t){var r=new ue;return r.ownerDocument=this,r.tagName=r.nodeName=r.target=e,r.nodeValue=r.data=t,r},createAttribute:function(e){var t=new ee;return t.ownerDocument=this,t.name=e,t.nodeName=e,t.localName=e,t.specified=!0,t},createEntityReference:function(e){var t=new le;return t.ownerDocument=this,t.nodeName=e,t},createElementNS:function(e,t){var r=new K,a=t.split(":"),n=r.attributes=new B;return r.childNodes=new N,r.ownerDocument=this,r.nodeName=t,r.tagName=t,r.namespaceURI=e,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,n._ownerElement=r,r},createAttributeNS:function(e,t){var r=new ee,a=t.split(":");return r.ownerDocument=this,r.nodeName=t,r.name=t,r.namespaceURI=e,r.specified=!0,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,r}},u(j,R),K.prototype={nodeType:d,hasAttribute:function(e){return null!=this.getAttributeNode(e)},getAttribute:function(e){var t=this.getAttributeNode(e);return t&&t.value||""},getAttributeNode:function(e){return this.attributes.getNamedItem(e)},setAttribute:function(e,t){var r=this.ownerDocument.createAttribute(e);r.value=r.nodeValue=""+t,this.setAttributeNode(r)},removeAttribute:function(e){var t=this.getAttributeNode(e);t&&this.removeAttributeNode(t)},appendChild:function(e){return e.nodeType===A?this.insertBefore(e,null):function(e,t){return t.parentNode&&t.parentNode.removeChild(t),t.parentNode=e,t.previousSibling=e.lastChild,t.nextSibling=null,t.previousSibling?t.previousSibling.nextSibling=t:e.firstChild=t,e.lastChild=t,G(e.ownerDocument,e,t),t}(this,e)},setAttributeNode:function(e){return this.attributes.setNamedItem(e)},setAttributeNodeNS:function(e){return this.attributes.setNamedItemNS(e)},removeAttributeNode:function(e){return this.attributes.removeNamedItem(e.nodeName)},removeAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);r&&this.removeAttributeNode(r)},hasAttributeNS:function(e,t){return null!=this.getAttributeNodeNS(e,t)},getAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);return r&&r.value||""},setAttributeNS:function(e,t,r){var a=this.ownerDocument.createAttributeNS(e,t);a.value=a.nodeValue=""+r,this.setAttributeNode(a)},getAttributeNodeNS:function(e,t){return this.attributes.getNamedItemNS(e,t)},getElementsByTagName:function(e){return new O(this,(function(t){var r=[];return U(t,(function(a){a===t||a.nodeType!=d||"*"!==e&&a.tagName!=e||r.push(a)})),r}))},getElementsByTagNameNS:function(e,t){return new O(this,(function(r){var a=[];return U(r,(function(n){n===r||n.nodeType!==d||"*"!==e&&n.namespaceURI!==e||"*"!==t&&n.localName!=t||a.push(n)})),a}))}},j.prototype.getElementsByTagName=K.prototype.getElementsByTagName,j.prototype.getElementsByTagNameNS=K.prototype.getElementsByTagNameNS,u(K,R),ee.prototype.nodeType=m,u(ee,R),te.prototype={data:"",substringData:function(e,t){return this.data.substring(e,e+t)},appendData:function(e){e=this.data+e,this.nodeValue=this.data=e,this.length=e.length},insertData:function(e,t){this.replaceData(e,0,t)},appendChild:function(e){throw new Error(y[q])},deleteData:function(e,t){this.replaceData(e,t,"")},replaceData:function(e,t,r){r=this.data.substring(0,e)+r+this.data.substring(e+t),this.nodeValue=this.data=r,this.length=r.length}},u(te,R),re.prototype={nodeName:"#text",nodeType:p,splitText:function(e){var t=this.data,r=t.substring(e);t=t.substring(0,e),this.data=this.nodeValue=t,this.length=t.length;var a=this.ownerDocument.createTextNode(r);return this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling),a}},u(re,te),ae.prototype={nodeName:"#comment",nodeType:b},u(ae,te),ne.prototype={nodeName:"#cdata-section",nodeType:f},u(ne,te),oe.prototype.nodeType=C,u(oe,R),ie.prototype.nodeType=E,u(ie,R),se.prototype.nodeType=g,u(se,R),le.prototype.nodeType=x,u(le,R),ce.prototype.nodeName="#document-fragment",ce.prototype.nodeType=A,u(ce,R),ue.prototype.nodeType=w,u(ue,R),he.prototype.serializeToString=function(e,t,r){return de.call(e,t,r)},R.prototype.toString=de;try{if(Object.defineProperty){function be(e){switch(e.nodeType){case d:case A:var t=[];for(e=e.firstChild;e;)7!==e.nodeType&&8!==e.nodeType&&t.push(be(e)),e=e.nextSibling;return t.join("");default:return e.nodeValue}}Object.defineProperty(O.prototype,"length",{get:function(){return L(this),this.$$length}}),Object.defineProperty(R.prototype,"textContent",{get:function(){return be(this)},set:function(e){switch(this.nodeType){case d:case A:for(;this.firstChild;)this.removeChild(this.firstChild);(e||String(e))&&this.appendChild(this.ownerDocument.createTextNode(e));break;default:this.data=e,this.value=e,this.nodeValue=e}}}),we=function(e,t,r){e["$$"+t]=r}}}catch(ve){}t.DocumentType=oe,t.DOMException=T,t.DOMImplementation=k,t.Element=K,t.Node=R,t.NodeList=N,t.XMLSerializer=he},6559:(e,t,r)=>{"use strict";var a=r(4582).freeze;t.XML_ENTITIES=a({amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}),t.HTML_ENTITIES=a({Aacute:"Á",aacute:"á",Abreve:"Ă",abreve:"ă",ac:"∾",acd:"∿",acE:"∾̳",Acirc:"Â",acirc:"â",acute:"´",Acy:"А",acy:"а",AElig:"Æ",aelig:"æ",af:"⁡",Afr:"𝔄",afr:"𝔞",Agrave:"À",agrave:"à",alefsym:"ℵ",aleph:"ℵ",Alpha:"Α",alpha:"α",Amacr:"Ā",amacr:"ā",amalg:"⨿",AMP:"&",amp:"&",And:"⩓",and:"∧",andand:"⩕",andd:"⩜",andslope:"⩘",andv:"⩚",ang:"∠",ange:"⦤",angle:"∠",angmsd:"∡",angmsdaa:"⦨",angmsdab:"⦩",angmsdac:"⦪",angmsdad:"⦫",angmsdae:"⦬",angmsdaf:"⦭",angmsdag:"⦮",angmsdah:"⦯",angrt:"∟",angrtvb:"⊾",angrtvbd:"⦝",angsph:"∢",angst:"Å",angzarr:"⍼",Aogon:"Ą",aogon:"ą",Aopf:"𝔸",aopf:"𝕒",ap:"≈",apacir:"⩯",apE:"⩰",ape:"≊",apid:"≋",apos:"'",ApplyFunction:"⁡",approx:"≈",approxeq:"≊",Aring:"Å",aring:"å",Ascr:"𝒜",ascr:"𝒶",Assign:"≔",ast:"*",asymp:"≈",asympeq:"≍",Atilde:"Ã",atilde:"ã",Auml:"Ä",auml:"ä",awconint:"∳",awint:"⨑",backcong:"≌",backepsilon:"϶",backprime:"‵",backsim:"∽",backsimeq:"⋍",Backslash:"∖",Barv:"⫧",barvee:"⊽",Barwed:"⌆",barwed:"⌅",barwedge:"⌅",bbrk:"⎵",bbrktbrk:"⎶",bcong:"≌",Bcy:"Б",bcy:"б",bdquo:"„",becaus:"∵",Because:"∵",because:"∵",bemptyv:"⦰",bepsi:"϶",bernou:"ℬ",Bernoullis:"ℬ",Beta:"Β",beta:"β",beth:"ℶ",between:"≬",Bfr:"𝔅",bfr:"𝔟",bigcap:"⋂",bigcirc:"◯",bigcup:"⋃",bigodot:"⨀",bigoplus:"⨁",bigotimes:"⨂",bigsqcup:"⨆",bigstar:"★",bigtriangledown:"▽",bigtriangleup:"△",biguplus:"⨄",bigvee:"⋁",bigwedge:"⋀",bkarow:"⤍",blacklozenge:"⧫",blacksquare:"▪",blacktriangle:"▴",blacktriangledown:"▾",blacktriangleleft:"◂",blacktriangleright:"▸",blank:"␣",blk12:"▒",blk14:"░",blk34:"▓",block:"█",bne:"=⃥",bnequiv:"≡⃥",bNot:"⫭",bnot:"⌐",Bopf:"𝔹",bopf:"𝕓",bot:"⊥",bottom:"⊥",bowtie:"⋈",boxbox:"⧉",boxDL:"╗",boxDl:"╖",boxdL:"╕",boxdl:"┐",boxDR:"╔",boxDr:"╓",boxdR:"╒",boxdr:"┌",boxH:"═",boxh:"─",boxHD:"╦",boxHd:"╤",boxhD:"╥",boxhd:"┬",boxHU:"╩",boxHu:"╧",boxhU:"╨",boxhu:"┴",boxminus:"⊟",boxplus:"⊞",boxtimes:"⊠",boxUL:"╝",boxUl:"╜",boxuL:"╛",boxul:"┘",boxUR:"╚",boxUr:"╙",boxuR:"╘",boxur:"└",boxV:"║",boxv:"│",boxVH:"╬",boxVh:"╫",boxvH:"╪",boxvh:"┼",boxVL:"╣",boxVl:"╢",boxvL:"╡",boxvl:"┤",boxVR:"╠",boxVr:"╟",boxvR:"╞",boxvr:"├",bprime:"‵",Breve:"˘",breve:"˘",brvbar:"¦",Bscr:"ℬ",bscr:"𝒷",bsemi:"⁏",bsim:"∽",bsime:"⋍",bsol:"\\",bsolb:"⧅",bsolhsub:"⟈",bull:"•",bullet:"•",bump:"≎",bumpE:"⪮",bumpe:"≏",Bumpeq:"≎",bumpeq:"≏",Cacute:"Ć",cacute:"ć",Cap:"⋒",cap:"∩",capand:"⩄",capbrcup:"⩉",capcap:"⩋",capcup:"⩇",capdot:"⩀",CapitalDifferentialD:"ⅅ",caps:"∩︀",caret:"⁁",caron:"ˇ",Cayleys:"ℭ",ccaps:"⩍",Ccaron:"Č",ccaron:"č",Ccedil:"Ç",ccedil:"ç",Ccirc:"Ĉ",ccirc:"ĉ",Cconint:"∰",ccups:"⩌",ccupssm:"⩐",Cdot:"Ċ",cdot:"ċ",cedil:"¸",Cedilla:"¸",cemptyv:"⦲",cent:"¢",CenterDot:"·",centerdot:"·",Cfr:"ℭ",cfr:"𝔠",CHcy:"Ч",chcy:"ч",check:"✓",checkmark:"✓",Chi:"Χ",chi:"χ",cir:"○",circ:"ˆ",circeq:"≗",circlearrowleft:"↺",circlearrowright:"↻",circledast:"⊛",circledcirc:"⊚",circleddash:"⊝",CircleDot:"⊙",circledR:"®",circledS:"Ⓢ",CircleMinus:"⊖",CirclePlus:"⊕",CircleTimes:"⊗",cirE:"⧃",cire:"≗",cirfnint:"⨐",cirmid:"⫯",cirscir:"⧂",ClockwiseContourIntegral:"∲",CloseCurlyDoubleQuote:"”",CloseCurlyQuote:"’",clubs:"♣",clubsuit:"♣",Colon:"∷",colon:":",Colone:"⩴",colone:"≔",coloneq:"≔",comma:",",commat:"@",comp:"∁",compfn:"∘",complement:"∁",complexes:"ℂ",cong:"≅",congdot:"⩭",Congruent:"≡",Conint:"∯",conint:"∮",ContourIntegral:"∮",Copf:"ℂ",copf:"𝕔",coprod:"∐",Coproduct:"∐",COPY:"©",copy:"©",copysr:"℗",CounterClockwiseContourIntegral:"∳",crarr:"↵",Cross:"⨯",cross:"✗",Cscr:"𝒞",cscr:"𝒸",csub:"⫏",csube:"⫑",csup:"⫐",csupe:"⫒",ctdot:"⋯",cudarrl:"⤸",cudarrr:"⤵",cuepr:"⋞",cuesc:"⋟",cularr:"↶",cularrp:"⤽",Cup:"⋓",cup:"∪",cupbrcap:"⩈",CupCap:"≍",cupcap:"⩆",cupcup:"⩊",cupdot:"⊍",cupor:"⩅",cups:"∪︀",curarr:"↷",curarrm:"⤼",curlyeqprec:"⋞",curlyeqsucc:"⋟",curlyvee:"⋎",curlywedge:"⋏",curren:"¤",curvearrowleft:"↶",curvearrowright:"↷",cuvee:"⋎",cuwed:"⋏",cwconint:"∲",cwint:"∱",cylcty:"⌭",Dagger:"‡",dagger:"†",daleth:"ℸ",Darr:"↡",dArr:"⇓",darr:"↓",dash:"‐",Dashv:"⫤",dashv:"⊣",dbkarow:"⤏",dblac:"˝",Dcaron:"Ď",dcaron:"ď",Dcy:"Д",dcy:"д",DD:"ⅅ",dd:"ⅆ",ddagger:"‡",ddarr:"⇊",DDotrahd:"⤑",ddotseq:"⩷",deg:"°",Del:"∇",Delta:"Δ",delta:"δ",demptyv:"⦱",dfisht:"⥿",Dfr:"𝔇",dfr:"𝔡",dHar:"⥥",dharl:"⇃",dharr:"⇂",DiacriticalAcute:"´",DiacriticalDot:"˙",DiacriticalDoubleAcute:"˝",DiacriticalGrave:"`",DiacriticalTilde:"˜",diam:"⋄",Diamond:"⋄",diamond:"⋄",diamondsuit:"♦",diams:"♦",die:"¨",DifferentialD:"ⅆ",digamma:"ϝ",disin:"⋲",div:"÷",divide:"÷",divideontimes:"⋇",divonx:"⋇",DJcy:"Ђ",djcy:"ђ",dlcorn:"⌞",dlcrop:"⌍",dollar:"$",Dopf:"𝔻",dopf:"𝕕",Dot:"¨",dot:"˙",DotDot:"⃜",doteq:"≐",doteqdot:"≑",DotEqual:"≐",dotminus:"∸",dotplus:"∔",dotsquare:"⊡",doublebarwedge:"⌆",DoubleContourIntegral:"∯",DoubleDot:"¨",DoubleDownArrow:"⇓",DoubleLeftArrow:"⇐",DoubleLeftRightArrow:"⇔",DoubleLeftTee:"⫤",DoubleLongLeftArrow:"⟸",DoubleLongLeftRightArrow:"⟺",DoubleLongRightArrow:"⟹",DoubleRightArrow:"⇒",DoubleRightTee:"⊨",DoubleUpArrow:"⇑",DoubleUpDownArrow:"⇕",DoubleVerticalBar:"∥",DownArrow:"↓",Downarrow:"⇓",downarrow:"↓",DownArrowBar:"⤓",DownArrowUpArrow:"⇵",DownBreve:"̑",downdownarrows:"⇊",downharpoonleft:"⇃",downharpoonright:"⇂",DownLeftRightVector:"⥐",DownLeftTeeVector:"⥞",DownLeftVector:"↽",DownLeftVectorBar:"⥖",DownRightTeeVector:"⥟",DownRightVector:"⇁",DownRightVectorBar:"⥗",DownTee:"⊤",DownTeeArrow:"↧",drbkarow:"⤐",drcorn:"⌟",drcrop:"⌌",Dscr:"𝒟",dscr:"𝒹",DScy:"Ѕ",dscy:"ѕ",dsol:"⧶",Dstrok:"Đ",dstrok:"đ",dtdot:"⋱",dtri:"▿",dtrif:"▾",duarr:"⇵",duhar:"⥯",dwangle:"⦦",DZcy:"Џ",dzcy:"џ",dzigrarr:"⟿",Eacute:"É",eacute:"é",easter:"⩮",Ecaron:"Ě",ecaron:"ě",ecir:"≖",Ecirc:"Ê",ecirc:"ê",ecolon:"≕",Ecy:"Э",ecy:"э",eDDot:"⩷",Edot:"Ė",eDot:"≑",edot:"ė",ee:"ⅇ",efDot:"≒",Efr:"𝔈",efr:"𝔢",eg:"⪚",Egrave:"È",egrave:"è",egs:"⪖",egsdot:"⪘",el:"⪙",Element:"∈",elinters:"⏧",ell:"ℓ",els:"⪕",elsdot:"⪗",Emacr:"Ē",emacr:"ē",empty:"∅",emptyset:"∅",EmptySmallSquare:"◻",emptyv:"∅",EmptyVerySmallSquare:"▫",emsp:" ",emsp13:" ",emsp14:" ",ENG:"Ŋ",eng:"ŋ",ensp:" ",Eogon:"Ę",eogon:"ę",Eopf:"𝔼",eopf:"𝕖",epar:"⋕",eparsl:"⧣",eplus:"⩱",epsi:"ε",Epsilon:"Ε",epsilon:"ε",epsiv:"ϵ",eqcirc:"≖",eqcolon:"≕",eqsim:"≂",eqslantgtr:"⪖",eqslantless:"⪕",Equal:"⩵",equals:"=",EqualTilde:"≂",equest:"≟",Equilibrium:"⇌",equiv:"≡",equivDD:"⩸",eqvparsl:"⧥",erarr:"⥱",erDot:"≓",Escr:"ℰ",escr:"ℯ",esdot:"≐",Esim:"⩳",esim:"≂",Eta:"Η",eta:"η",ETH:"Ð",eth:"ð",Euml:"Ë",euml:"ë",euro:"€",excl:"!",exist:"∃",Exists:"∃",expectation:"ℰ",ExponentialE:"ⅇ",exponentiale:"ⅇ",fallingdotseq:"≒",Fcy:"Ф",fcy:"ф",female:"♀",ffilig:"ﬃ",fflig:"ﬀ",ffllig:"ﬄ",Ffr:"𝔉",ffr:"𝔣",filig:"ﬁ",FilledSmallSquare:"◼",FilledVerySmallSquare:"▪",fjlig:"fj",flat:"♭",fllig:"ﬂ",fltns:"▱",fnof:"ƒ",Fopf:"𝔽",fopf:"𝕗",ForAll:"∀",forall:"∀",fork:"⋔",forkv:"⫙",Fouriertrf:"ℱ",fpartint:"⨍",frac12:"½",frac13:"⅓",frac14:"¼",frac15:"⅕",frac16:"⅙",frac18:"⅛",frac23:"⅔",frac25:"⅖",frac34:"¾",frac35:"⅗",frac38:"⅜",frac45:"⅘",frac56:"⅚",frac58:"⅝",frac78:"⅞",frasl:"⁄",frown:"⌢",Fscr:"ℱ",fscr:"𝒻",gacute:"ǵ",Gamma:"Γ",gamma:"γ",Gammad:"Ϝ",gammad:"ϝ",gap:"⪆",Gbreve:"Ğ",gbreve:"ğ",Gcedil:"Ģ",Gcirc:"Ĝ",gcirc:"ĝ",Gcy:"Г",gcy:"г",Gdot:"Ġ",gdot:"ġ",gE:"≧",ge:"≥",gEl:"⪌",gel:"⋛",geq:"≥",geqq:"≧",geqslant:"⩾",ges:"⩾",gescc:"⪩",gesdot:"⪀",gesdoto:"⪂",gesdotol:"⪄",gesl:"⋛︀",gesles:"⪔",Gfr:"𝔊",gfr:"𝔤",Gg:"⋙",gg:"≫",ggg:"⋙",gimel:"ℷ",GJcy:"Ѓ",gjcy:"ѓ",gl:"≷",gla:"⪥",glE:"⪒",glj:"⪤",gnap:"⪊",gnapprox:"⪊",gnE:"≩",gne:"⪈",gneq:"⪈",gneqq:"≩",gnsim:"⋧",Gopf:"𝔾",gopf:"𝕘",grave:"`",GreaterEqual:"≥",GreaterEqualLess:"⋛",GreaterFullEqual:"≧",GreaterGreater:"⪢",GreaterLess:"≷",GreaterSlantEqual:"⩾",GreaterTilde:"≳",Gscr:"𝒢",gscr:"ℊ",gsim:"≳",gsime:"⪎",gsiml:"⪐",Gt:"≫",GT:">",gt:">",gtcc:"⪧",gtcir:"⩺",gtdot:"⋗",gtlPar:"⦕",gtquest:"⩼",gtrapprox:"⪆",gtrarr:"⥸",gtrdot:"⋗",gtreqless:"⋛",gtreqqless:"⪌",gtrless:"≷",gtrsim:"≳",gvertneqq:"≩︀",gvnE:"≩︀",Hacek:"ˇ",hairsp:" ",half:"½",hamilt:"ℋ",HARDcy:"Ъ",hardcy:"ъ",hArr:"⇔",harr:"↔",harrcir:"⥈",harrw:"↭",Hat:"^",hbar:"ℏ",Hcirc:"Ĥ",hcirc:"ĥ",hearts:"♥",heartsuit:"♥",hellip:"…",hercon:"⊹",Hfr:"ℌ",hfr:"𝔥",HilbertSpace:"ℋ",hksearow:"⤥",hkswarow:"⤦",hoarr:"⇿",homtht:"∻",hookleftarrow:"↩",hookrightarrow:"↪",Hopf:"ℍ",hopf:"𝕙",horbar:"―",HorizontalLine:"─",Hscr:"ℋ",hscr:"𝒽",hslash:"ℏ",Hstrok:"Ħ",hstrok:"ħ",HumpDownHump:"≎",HumpEqual:"≏",hybull:"⁃",hyphen:"‐",Iacute:"Í",iacute:"í",ic:"⁣",Icirc:"Î",icirc:"î",Icy:"И",icy:"и",Idot:"İ",IEcy:"Е",iecy:"е",iexcl:"¡",iff:"⇔",Ifr:"ℑ",ifr:"𝔦",Igrave:"Ì",igrave:"ì",ii:"ⅈ",iiiint:"⨌",iiint:"∭",iinfin:"⧜",iiota:"℩",IJlig:"Ĳ",ijlig:"ĳ",Im:"ℑ",Imacr:"Ī",imacr:"ī",image:"ℑ",ImaginaryI:"ⅈ",imagline:"ℐ",imagpart:"ℑ",imath:"ı",imof:"⊷",imped:"Ƶ",Implies:"⇒",in:"∈",incare:"℅",infin:"∞",infintie:"⧝",inodot:"ı",Int:"∬",int:"∫",intcal:"⊺",integers:"ℤ",Integral:"∫",intercal:"⊺",Intersection:"⋂",intlarhk:"⨗",intprod:"⨼",InvisibleComma:"⁣",InvisibleTimes:"⁢",IOcy:"Ё",iocy:"ё",Iogon:"Į",iogon:"į",Iopf:"𝕀",iopf:"𝕚",Iota:"Ι",iota:"ι",iprod:"⨼",iquest:"¿",Iscr:"ℐ",iscr:"𝒾",isin:"∈",isindot:"⋵",isinE:"⋹",isins:"⋴",isinsv:"⋳",isinv:"∈",it:"⁢",Itilde:"Ĩ",itilde:"ĩ",Iukcy:"І",iukcy:"і",Iuml:"Ï",iuml:"ï",Jcirc:"Ĵ",jcirc:"ĵ",Jcy:"Й",jcy:"й",Jfr:"𝔍",jfr:"𝔧",jmath:"ȷ",Jopf:"𝕁",jopf:"𝕛",Jscr:"𝒥",jscr:"𝒿",Jsercy:"Ј",jsercy:"ј",Jukcy:"Є",jukcy:"є",Kappa:"Κ",kappa:"κ",kappav:"ϰ",Kcedil:"Ķ",kcedil:"ķ",Kcy:"К",kcy:"к",Kfr:"𝔎",kfr:"𝔨",kgreen:"ĸ",KHcy:"Х",khcy:"х",KJcy:"Ќ",kjcy:"ќ",Kopf:"𝕂",kopf:"𝕜",Kscr:"𝒦",kscr:"𝓀",lAarr:"⇚",Lacute:"Ĺ",lacute:"ĺ",laemptyv:"⦴",lagran:"ℒ",Lambda:"Λ",lambda:"λ",Lang:"⟪",lang:"⟨",langd:"⦑",langle:"⟨",lap:"⪅",Laplacetrf:"ℒ",laquo:"«",Larr:"↞",lArr:"⇐",larr:"←",larrb:"⇤",larrbfs:"⤟",larrfs:"⤝",larrhk:"↩",larrlp:"↫",larrpl:"⤹",larrsim:"⥳",larrtl:"↢",lat:"⪫",lAtail:"⤛",latail:"⤙",late:"⪭",lates:"⪭︀",lBarr:"⤎",lbarr:"⤌",lbbrk:"❲",lbrace:"{",lbrack:"[",lbrke:"⦋",lbrksld:"⦏",lbrkslu:"⦍",Lcaron:"Ľ",lcaron:"ľ",Lcedil:"Ļ",lcedil:"ļ",lceil:"⌈",lcub:"{",Lcy:"Л",lcy:"л",ldca:"⤶",ldquo:"“",ldquor:"„",ldrdhar:"⥧",ldrushar:"⥋",ldsh:"↲",lE:"≦",le:"≤",LeftAngleBracket:"⟨",LeftArrow:"←",Leftarrow:"⇐",leftarrow:"←",LeftArrowBar:"⇤",LeftArrowRightArrow:"⇆",leftarrowtail:"↢",LeftCeiling:"⌈",LeftDoubleBracket:"⟦",LeftDownTeeVector:"⥡",LeftDownVector:"⇃",LeftDownVectorBar:"⥙",LeftFloor:"⌊",leftharpoondown:"↽",leftharpoonup:"↼",leftleftarrows:"⇇",LeftRightArrow:"↔",Leftrightarrow:"⇔",leftrightarrow:"↔",leftrightarrows:"⇆",leftrightharpoons:"⇋",leftrightsquigarrow:"↭",LeftRightVector:"⥎",LeftTee:"⊣",LeftTeeArrow:"↤",LeftTeeVector:"⥚",leftthreetimes:"⋋",LeftTriangle:"⊲",LeftTriangleBar:"⧏",LeftTriangleEqual:"⊴",LeftUpDownVector:"⥑",LeftUpTeeVector:"⥠",LeftUpVector:"↿",LeftUpVectorBar:"⥘",LeftVector:"↼",LeftVectorBar:"⥒",lEg:"⪋",leg:"⋚",leq:"≤",leqq:"≦",leqslant:"⩽",les:"⩽",lescc:"⪨",lesdot:"⩿",lesdoto:"⪁",lesdotor:"⪃",lesg:"⋚︀",lesges:"⪓",lessapprox:"⪅",lessdot:"⋖",lesseqgtr:"⋚",lesseqqgtr:"⪋",LessEqualGreater:"⋚",LessFullEqual:"≦",LessGreater:"≶",lessgtr:"≶",LessLess:"⪡",lesssim:"≲",LessSlantEqual:"⩽",LessTilde:"≲",lfisht:"⥼",lfloor:"⌊",Lfr:"𝔏",lfr:"𝔩",lg:"≶",lgE:"⪑",lHar:"⥢",lhard:"↽",lharu:"↼",lharul:"⥪",lhblk:"▄",LJcy:"Љ",ljcy:"љ",Ll:"⋘",ll:"≪",llarr:"⇇",llcorner:"⌞",Lleftarrow:"⇚",llhard:"⥫",lltri:"◺",Lmidot:"Ŀ",lmidot:"ŀ",lmoust:"⎰",lmoustache:"⎰",lnap:"⪉",lnapprox:"⪉",lnE:"≨",lne:"⪇",lneq:"⪇",lneqq:"≨",lnsim:"⋦",loang:"⟬",loarr:"⇽",lobrk:"⟦",LongLeftArrow:"⟵",Longleftarrow:"⟸",longleftarrow:"⟵",LongLeftRightArrow:"⟷",Longleftrightarrow:"⟺",longleftrightarrow:"⟷",longmapsto:"⟼",LongRightArrow:"⟶",Longrightarrow:"⟹",longrightarrow:"⟶",looparrowleft:"↫",looparrowright:"↬",lopar:"⦅",Lopf:"𝕃",lopf:"𝕝",loplus:"⨭",lotimes:"⨴",lowast:"∗",lowbar:"_",LowerLeftArrow:"↙",LowerRightArrow:"↘",loz:"◊",lozenge:"◊",lozf:"⧫",lpar:"(",lparlt:"⦓",lrarr:"⇆",lrcorner:"⌟",lrhar:"⇋",lrhard:"⥭",lrm:"‎",lrtri:"⊿",lsaquo:"‹",Lscr:"ℒ",lscr:"𝓁",Lsh:"↰",lsh:"↰",lsim:"≲",lsime:"⪍",lsimg:"⪏",lsqb:"[",lsquo:"‘",lsquor:"‚",Lstrok:"Ł",lstrok:"ł",Lt:"≪",LT:"<",lt:"<",ltcc:"⪦",ltcir:"⩹",ltdot:"⋖",lthree:"⋋",ltimes:"⋉",ltlarr:"⥶",ltquest:"⩻",ltri:"◃",ltrie:"⊴",ltrif:"◂",ltrPar:"⦖",lurdshar:"⥊",luruhar:"⥦",lvertneqq:"≨︀",lvnE:"≨︀",macr:"¯",male:"♂",malt:"✠",maltese:"✠",Map:"⤅",map:"↦",mapsto:"↦",mapstodown:"↧",mapstoleft:"↤",mapstoup:"↥",marker:"▮",mcomma:"⨩",Mcy:"М",mcy:"м",mdash:"—",mDDot:"∺",measuredangle:"∡",MediumSpace:" ",Mellintrf:"ℳ",Mfr:"𝔐",mfr:"𝔪",mho:"℧",micro:"µ",mid:"∣",midast:"*",midcir:"⫰",middot:"·",minus:"−",minusb:"⊟",minusd:"∸",minusdu:"⨪",MinusPlus:"∓",mlcp:"⫛",mldr:"…",mnplus:"∓",models:"⊧",Mopf:"𝕄",mopf:"𝕞",mp:"∓",Mscr:"ℳ",mscr:"𝓂",mstpos:"∾",Mu:"Μ",mu:"μ",multimap:"⊸",mumap:"⊸",nabla:"∇",Nacute:"Ń",nacute:"ń",nang:"∠⃒",nap:"≉",napE:"⩰̸",napid:"≋̸",napos:"ŉ",napprox:"≉",natur:"♮",natural:"♮",naturals:"ℕ",nbsp:" ",nbump:"≎̸",nbumpe:"≏̸",ncap:"⩃",Ncaron:"Ň",ncaron:"ň",Ncedil:"Ņ",ncedil:"ņ",ncong:"≇",ncongdot:"⩭̸",ncup:"⩂",Ncy:"Н",ncy:"н",ndash:"–",ne:"≠",nearhk:"⤤",neArr:"⇗",nearr:"↗",nearrow:"↗",nedot:"≐̸",NegativeMediumSpace:"​",NegativeThickSpace:"​",NegativeThinSpace:"​",NegativeVeryThinSpace:"​",nequiv:"≢",nesear:"⤨",nesim:"≂̸",NestedGreaterGreater:"≫",NestedLessLess:"≪",NewLine:"\n",nexist:"∄",nexists:"∄",Nfr:"𝔑",nfr:"𝔫",ngE:"≧̸",nge:"≱",ngeq:"≱",ngeqq:"≧̸",ngeqslant:"⩾̸",nges:"⩾̸",nGg:"⋙̸",ngsim:"≵",nGt:"≫⃒",ngt:"≯",ngtr:"≯",nGtv:"≫̸",nhArr:"⇎",nharr:"↮",nhpar:"⫲",ni:"∋",nis:"⋼",nisd:"⋺",niv:"∋",NJcy:"Њ",njcy:"њ",nlArr:"⇍",nlarr:"↚",nldr:"‥",nlE:"≦̸",nle:"≰",nLeftarrow:"⇍",nleftarrow:"↚",nLeftrightarrow:"⇎",nleftrightarrow:"↮",nleq:"≰",nleqq:"≦̸",nleqslant:"⩽̸",nles:"⩽̸",nless:"≮",nLl:"⋘̸",nlsim:"≴",nLt:"≪⃒",nlt:"≮",nltri:"⋪",nltrie:"⋬",nLtv:"≪̸",nmid:"∤",NoBreak:"⁠",NonBreakingSpace:" ",Nopf:"ℕ",nopf:"𝕟",Not:"⫬",not:"¬",NotCongruent:"≢",NotCupCap:"≭",NotDoubleVerticalBar:"∦",NotElement:"∉",NotEqual:"≠",NotEqualTilde:"≂̸",NotExists:"∄",NotGreater:"≯",NotGreaterEqual:"≱",NotGreaterFullEqual:"≧̸",NotGreaterGreater:"≫̸",NotGreaterLess:"≹",NotGreaterSlantEqual:"⩾̸",NotGreaterTilde:"≵",NotHumpDownHump:"≎̸",NotHumpEqual:"≏̸",notin:"∉",notindot:"⋵̸",notinE:"⋹̸",notinva:"∉",notinvb:"⋷",notinvc:"⋶",NotLeftTriangle:"⋪",NotLeftTriangleBar:"⧏̸",NotLeftTriangleEqual:"⋬",NotLess:"≮",NotLessEqual:"≰",NotLessGreater:"≸",NotLessLess:"≪̸",NotLessSlantEqual:"⩽̸",NotLessTilde:"≴",NotNestedGreaterGreater:"⪢̸",NotNestedLessLess:"⪡̸",notni:"∌",notniva:"∌",notnivb:"⋾",notnivc:"⋽",NotPrecedes:"⊀",NotPrecedesEqual:"⪯̸",NotPrecedesSlantEqual:"⋠",NotReverseElement:"∌",NotRightTriangle:"⋫",NotRightTriangleBar:"⧐̸",NotRightTriangleEqual:"⋭",NotSquareSubset:"⊏̸",NotSquareSubsetEqual:"⋢",NotSquareSuperset:"⊐̸",NotSquareSupersetEqual:"⋣",NotSubset:"⊂⃒",NotSubsetEqual:"⊈",NotSucceeds:"⊁",NotSucceedsEqual:"⪰̸",NotSucceedsSlantEqual:"⋡",NotSucceedsTilde:"≿̸",NotSuperset:"⊃⃒",NotSupersetEqual:"⊉",NotTilde:"≁",NotTildeEqual:"≄",NotTildeFullEqual:"≇",NotTildeTilde:"≉",NotVerticalBar:"∤",npar:"∦",nparallel:"∦",nparsl:"⫽⃥",npart:"∂̸",npolint:"⨔",npr:"⊀",nprcue:"⋠",npre:"⪯̸",nprec:"⊀",npreceq:"⪯̸",nrArr:"⇏",nrarr:"↛",nrarrc:"⤳̸",nrarrw:"↝̸",nRightarrow:"⇏",nrightarrow:"↛",nrtri:"⋫",nrtrie:"⋭",nsc:"⊁",nsccue:"⋡",nsce:"⪰̸",Nscr:"𝒩",nscr:"𝓃",nshortmid:"∤",nshortparallel:"∦",nsim:"≁",nsime:"≄",nsimeq:"≄",nsmid:"∤",nspar:"∦",nsqsube:"⋢",nsqsupe:"⋣",nsub:"⊄",nsubE:"⫅̸",nsube:"⊈",nsubset:"⊂⃒",nsubseteq:"⊈",nsubseteqq:"⫅̸",nsucc:"⊁",nsucceq:"⪰̸",nsup:"⊅",nsupE:"⫆̸",nsupe:"⊉",nsupset:"⊃⃒",nsupseteq:"⊉",nsupseteqq:"⫆̸",ntgl:"≹",Ntilde:"Ñ",ntilde:"ñ",ntlg:"≸",ntriangleleft:"⋪",ntrianglelefteq:"⋬",ntriangleright:"⋫",ntrianglerighteq:"⋭",Nu:"Ν",nu:"ν",num:"#",numero:"№",numsp:" ",nvap:"≍⃒",nVDash:"⊯",nVdash:"⊮",nvDash:"⊭",nvdash:"⊬",nvge:"≥⃒",nvgt:">⃒",nvHarr:"⤄",nvinfin:"⧞",nvlArr:"⤂",nvle:"≤⃒",nvlt:"<⃒",nvltrie:"⊴⃒",nvrArr:"⤃",nvrtrie:"⊵⃒",nvsim:"∼⃒",nwarhk:"⤣",nwArr:"⇖",nwarr:"↖",nwarrow:"↖",nwnear:"⤧",Oacute:"Ó",oacute:"ó",oast:"⊛",ocir:"⊚",Ocirc:"Ô",ocirc:"ô",Ocy:"О",ocy:"о",odash:"⊝",Odblac:"Ő",odblac:"ő",odiv:"⨸",odot:"⊙",odsold:"⦼",OElig:"Œ",oelig:"œ",ofcir:"⦿",Ofr:"𝔒",ofr:"𝔬",ogon:"˛",Ograve:"Ò",ograve:"ò",ogt:"⧁",ohbar:"⦵",ohm:"Ω",oint:"∮",olarr:"↺",olcir:"⦾",olcross:"⦻",oline:"‾",olt:"⧀",Omacr:"Ō",omacr:"ō",Omega:"Ω",omega:"ω",Omicron:"Ο",omicron:"ο",omid:"⦶",ominus:"⊖",Oopf:"𝕆",oopf:"𝕠",opar:"⦷",OpenCurlyDoubleQuote:"“",OpenCurlyQuote:"‘",operp:"⦹",oplus:"⊕",Or:"⩔",or:"∨",orarr:"↻",ord:"⩝",order:"ℴ",orderof:"ℴ",ordf:"ª",ordm:"º",origof:"⊶",oror:"⩖",orslope:"⩗",orv:"⩛",oS:"Ⓢ",Oscr:"𝒪",oscr:"ℴ",Oslash:"Ø",oslash:"ø",osol:"⊘",Otilde:"Õ",otilde:"õ",Otimes:"⨷",otimes:"⊗",otimesas:"⨶",Ouml:"Ö",ouml:"ö",ovbar:"⌽",OverBar:"‾",OverBrace:"⏞",OverBracket:"⎴",OverParenthesis:"⏜",par:"∥",para:"¶",parallel:"∥",parsim:"⫳",parsl:"⫽",part:"∂",PartialD:"∂",Pcy:"П",pcy:"п",percnt:"%",period:".",permil:"‰",perp:"⊥",pertenk:"‱",Pfr:"𝔓",pfr:"𝔭",Phi:"Φ",phi:"φ",phiv:"ϕ",phmmat:"ℳ",phone:"☎",Pi:"Π",pi:"π",pitchfork:"⋔",piv:"ϖ",planck:"ℏ",planckh:"ℎ",plankv:"ℏ",plus:"+",plusacir:"⨣",plusb:"⊞",pluscir:"⨢",plusdo:"∔",plusdu:"⨥",pluse:"⩲",PlusMinus:"±",plusmn:"±",plussim:"⨦",plustwo:"⨧",pm:"±",Poincareplane:"ℌ",pointint:"⨕",Popf:"ℙ",popf:"𝕡",pound:"£",Pr:"⪻",pr:"≺",prap:"⪷",prcue:"≼",prE:"⪳",pre:"⪯",prec:"≺",precapprox:"⪷",preccurlyeq:"≼",Precedes:"≺",PrecedesEqual:"⪯",PrecedesSlantEqual:"≼",PrecedesTilde:"≾",preceq:"⪯",precnapprox:"⪹",precneqq:"⪵",precnsim:"⋨",precsim:"≾",Prime:"″",prime:"′",primes:"ℙ",prnap:"⪹",prnE:"⪵",prnsim:"⋨",prod:"∏",Product:"∏",profalar:"⌮",profline:"⌒",profsurf:"⌓",prop:"∝",Proportion:"∷",Proportional:"∝",propto:"∝",prsim:"≾",prurel:"⊰",Pscr:"𝒫",pscr:"𝓅",Psi:"Ψ",psi:"ψ",puncsp:" ",Qfr:"𝔔",qfr:"𝔮",qint:"⨌",Qopf:"ℚ",qopf:"𝕢",qprime:"⁗",Qscr:"𝒬",qscr:"𝓆",quaternions:"ℍ",quatint:"⨖",quest:"?",questeq:"≟",QUOT:'"',quot:'"',rAarr:"⇛",race:"∽̱",Racute:"Ŕ",racute:"ŕ",radic:"√",raemptyv:"⦳",Rang:"⟫",rang:"⟩",rangd:"⦒",range:"⦥",rangle:"⟩",raquo:"»",Rarr:"↠",rArr:"⇒",rarr:"→",rarrap:"⥵",rarrb:"⇥",rarrbfs:"⤠",rarrc:"⤳",rarrfs:"⤞",rarrhk:"↪",rarrlp:"↬",rarrpl:"⥅",rarrsim:"⥴",Rarrtl:"⤖",rarrtl:"↣",rarrw:"↝",rAtail:"⤜",ratail:"⤚",ratio:"∶",rationals:"ℚ",RBarr:"⤐",rBarr:"⤏",rbarr:"⤍",rbbrk:"❳",rbrace:"}",rbrack:"]",rbrke:"⦌",rbrksld:"⦎",rbrkslu:"⦐",Rcaron:"Ř",rcaron:"ř",Rcedil:"Ŗ",rcedil:"ŗ",rceil:"⌉",rcub:"}",Rcy:"Р",rcy:"р",rdca:"⤷",rdldhar:"⥩",rdquo:"”",rdquor:"”",rdsh:"↳",Re:"ℜ",real:"ℜ",realine:"ℛ",realpart:"ℜ",reals:"ℝ",rect:"▭",REG:"®",reg:"®",ReverseElement:"∋",ReverseEquilibrium:"⇋",ReverseUpEquilibrium:"⥯",rfisht:"⥽",rfloor:"⌋",Rfr:"ℜ",rfr:"𝔯",rHar:"⥤",rhard:"⇁",rharu:"⇀",rharul:"⥬",Rho:"Ρ",rho:"ρ",rhov:"ϱ",RightAngleBracket:"⟩",RightArrow:"→",Rightarrow:"⇒",rightarrow:"→",RightArrowBar:"⇥",RightArrowLeftArrow:"⇄",rightarrowtail:"↣",RightCeiling:"⌉",RightDoubleBracket:"⟧",RightDownTeeVector:"⥝",RightDownVector:"⇂",RightDownVectorBar:"⥕",RightFloor:"⌋",rightharpoondown:"⇁",rightharpoonup:"⇀",rightleftarrows:"⇄",rightleftharpoons:"⇌",rightrightarrows:"⇉",rightsquigarrow:"↝",RightTee:"⊢",RightTeeArrow:"↦",RightTeeVector:"⥛",rightthreetimes:"⋌",RightTriangle:"⊳",RightTriangleBar:"⧐",RightTriangleEqual:"⊵",RightUpDownVector:"⥏",RightUpTeeVector:"⥜",RightUpVector:"↾",RightUpVectorBar:"⥔",RightVector:"⇀",RightVectorBar:"⥓",ring:"˚",risingdotseq:"≓",rlarr:"⇄",rlhar:"⇌",rlm:"‏",rmoust:"⎱",rmoustache:"⎱",rnmid:"⫮",roang:"⟭",roarr:"⇾",robrk:"⟧",ropar:"⦆",Ropf:"ℝ",ropf:"𝕣",roplus:"⨮",rotimes:"⨵",RoundImplies:"⥰",rpar:")",rpargt:"⦔",rppolint:"⨒",rrarr:"⇉",Rrightarrow:"⇛",rsaquo:"›",Rscr:"ℛ",rscr:"𝓇",Rsh:"↱",rsh:"↱",rsqb:"]",rsquo:"’",rsquor:"’",rthree:"⋌",rtimes:"⋊",rtri:"▹",rtrie:"⊵",rtrif:"▸",rtriltri:"⧎",RuleDelayed:"⧴",ruluhar:"⥨",rx:"℞",Sacute:"Ś",sacute:"ś",sbquo:"‚",Sc:"⪼",sc:"≻",scap:"⪸",Scaron:"Š",scaron:"š",sccue:"≽",scE:"⪴",sce:"⪰",Scedil:"Ş",scedil:"ş",Scirc:"Ŝ",scirc:"ŝ",scnap:"⪺",scnE:"⪶",scnsim:"⋩",scpolint:"⨓",scsim:"≿",Scy:"С",scy:"с",sdot:"⋅",sdotb:"⊡",sdote:"⩦",searhk:"⤥",seArr:"⇘",searr:"↘",searrow:"↘",sect:"§",semi:";",seswar:"⤩",setminus:"∖",setmn:"∖",sext:"✶",Sfr:"𝔖",sfr:"𝔰",sfrown:"⌢",sharp:"♯",SHCHcy:"Щ",shchcy:"щ",SHcy:"Ш",shcy:"ш",ShortDownArrow:"↓",ShortLeftArrow:"←",shortmid:"∣",shortparallel:"∥",ShortRightArrow:"→",ShortUpArrow:"↑",shy:"­",Sigma:"Σ",sigma:"σ",sigmaf:"ς",sigmav:"ς",sim:"∼",simdot:"⩪",sime:"≃",simeq:"≃",simg:"⪞",simgE:"⪠",siml:"⪝",simlE:"⪟",simne:"≆",simplus:"⨤",simrarr:"⥲",slarr:"←",SmallCircle:"∘",smallsetminus:"∖",smashp:"⨳",smeparsl:"⧤",smid:"∣",smile:"⌣",smt:"⪪",smte:"⪬",smtes:"⪬︀",SOFTcy:"Ь",softcy:"ь",sol:"/",solb:"⧄",solbar:"⌿",Sopf:"𝕊",sopf:"𝕤",spades:"♠",spadesuit:"♠",spar:"∥",sqcap:"⊓",sqcaps:"⊓︀",sqcup:"⊔",sqcups:"⊔︀",Sqrt:"√",sqsub:"⊏",sqsube:"⊑",sqsubset:"⊏",sqsubseteq:"⊑",sqsup:"⊐",sqsupe:"⊒",sqsupset:"⊐",sqsupseteq:"⊒",squ:"□",Square:"□",square:"□",SquareIntersection:"⊓",SquareSubset:"⊏",SquareSubsetEqual:"⊑",SquareSuperset:"⊐",SquareSupersetEqual:"⊒",SquareUnion:"⊔",squarf:"▪",squf:"▪",srarr:"→",Sscr:"𝒮",sscr:"𝓈",ssetmn:"∖",ssmile:"⌣",sstarf:"⋆",Star:"⋆",star:"☆",starf:"★",straightepsilon:"ϵ",straightphi:"ϕ",strns:"¯",Sub:"⋐",sub:"⊂",subdot:"⪽",subE:"⫅",sube:"⊆",subedot:"⫃",submult:"⫁",subnE:"⫋",subne:"⊊",subplus:"⪿",subrarr:"⥹",Subset:"⋐",subset:"⊂",subseteq:"⊆",subseteqq:"⫅",SubsetEqual:"⊆",subsetneq:"⊊",subsetneqq:"⫋",subsim:"⫇",subsub:"⫕",subsup:"⫓",succ:"≻",succapprox:"⪸",succcurlyeq:"≽",Succeeds:"≻",SucceedsEqual:"⪰",SucceedsSlantEqual:"≽",SucceedsTilde:"≿",succeq:"⪰",succnapprox:"⪺",succneqq:"⪶",succnsim:"⋩",succsim:"≿",SuchThat:"∋",Sum:"∑",sum:"∑",sung:"♪",Sup:"⋑",sup:"⊃",sup1:"¹",sup2:"²",sup3:"³",supdot:"⪾",supdsub:"⫘",supE:"⫆",supe:"⊇",supedot:"⫄",Superset:"⊃",SupersetEqual:"⊇",suphsol:"⟉",suphsub:"⫗",suplarr:"⥻",supmult:"⫂",supnE:"⫌",supne:"⊋",supplus:"⫀",Supset:"⋑",supset:"⊃",supseteq:"⊇",supseteqq:"⫆",supsetneq:"⊋",supsetneqq:"⫌",supsim:"⫈",supsub:"⫔",supsup:"⫖",swarhk:"⤦",swArr:"⇙",swarr:"↙",swarrow:"↙",swnwar:"⤪",szlig:"ß",Tab:"\t",target:"⌖",Tau:"Τ",tau:"τ",tbrk:"⎴",Tcaron:"Ť",tcaron:"ť",Tcedil:"Ţ",tcedil:"ţ",Tcy:"Т",tcy:"т",tdot:"⃛",telrec:"⌕",Tfr:"𝔗",tfr:"𝔱",there4:"∴",Therefore:"∴",therefore:"∴",Theta:"Θ",theta:"θ",thetasym:"ϑ",thetav:"ϑ",thickapprox:"≈",thicksim:"∼",ThickSpace:"  ",thinsp:" ",ThinSpace:" ",thkap:"≈",thksim:"∼",THORN:"Þ",thorn:"þ",Tilde:"∼",tilde:"˜",TildeEqual:"≃",TildeFullEqual:"≅",TildeTilde:"≈",times:"×",timesb:"⊠",timesbar:"⨱",timesd:"⨰",tint:"∭",toea:"⤨",top:"⊤",topbot:"⌶",topcir:"⫱",Topf:"𝕋",topf:"𝕥",topfork:"⫚",tosa:"⤩",tprime:"‴",TRADE:"™",trade:"™",triangle:"▵",triangledown:"▿",triangleleft:"◃",trianglelefteq:"⊴",triangleq:"≜",triangleright:"▹",trianglerighteq:"⊵",tridot:"◬",trie:"≜",triminus:"⨺",TripleDot:"⃛",triplus:"⨹",trisb:"⧍",tritime:"⨻",trpezium:"⏢",Tscr:"𝒯",tscr:"𝓉",TScy:"Ц",tscy:"ц",TSHcy:"Ћ",tshcy:"ћ",Tstrok:"Ŧ",tstrok:"ŧ",twixt:"≬",twoheadleftarrow:"↞",twoheadrightarrow:"↠",Uacute:"Ú",uacute:"ú",Uarr:"↟",uArr:"⇑",uarr:"↑",Uarrocir:"⥉",Ubrcy:"Ў",ubrcy:"ў",Ubreve:"Ŭ",ubreve:"ŭ",Ucirc:"Û",ucirc:"û",Ucy:"У",ucy:"у",udarr:"⇅",Udblac:"Ű",udblac:"ű",udhar:"⥮",ufisht:"⥾",Ufr:"𝔘",ufr:"𝔲",Ugrave:"Ù",ugrave:"ù",uHar:"⥣",uharl:"↿",uharr:"↾",uhblk:"▀",ulcorn:"⌜",ulcorner:"⌜",ulcrop:"⌏",ultri:"◸",Umacr:"Ū",umacr:"ū",uml:"¨",UnderBar:"_",UnderBrace:"⏟",UnderBracket:"⎵",UnderParenthesis:"⏝",Union:"⋃",UnionPlus:"⊎",Uogon:"Ų",uogon:"ų",Uopf:"𝕌",uopf:"𝕦",UpArrow:"↑",Uparrow:"⇑",uparrow:"↑",UpArrowBar:"⤒",UpArrowDownArrow:"⇅",UpDownArrow:"↕",Updownarrow:"⇕",updownarrow:"↕",UpEquilibrium:"⥮",upharpoonleft:"↿",upharpoonright:"↾",uplus:"⊎",UpperLeftArrow:"↖",UpperRightArrow:"↗",Upsi:"ϒ",upsi:"υ",upsih:"ϒ",Upsilon:"Υ",upsilon:"υ",UpTee:"⊥",UpTeeArrow:"↥",upuparrows:"⇈",urcorn:"⌝",urcorner:"⌝",urcrop:"⌎",Uring:"Ů",uring:"ů",urtri:"◹",Uscr:"𝒰",uscr:"𝓊",utdot:"⋰",Utilde:"Ũ",utilde:"ũ",utri:"▵",utrif:"▴",uuarr:"⇈",Uuml:"Ü",uuml:"ü",uwangle:"⦧",vangrt:"⦜",varepsilon:"ϵ",varkappa:"ϰ",varnothing:"∅",varphi:"ϕ",varpi:"ϖ",varpropto:"∝",vArr:"⇕",varr:"↕",varrho:"ϱ",varsigma:"ς",varsubsetneq:"⊊︀",varsubsetneqq:"⫋︀",varsupsetneq:"⊋︀",varsupsetneqq:"⫌︀",vartheta:"ϑ",vartriangleleft:"⊲",vartriangleright:"⊳",Vbar:"⫫",vBar:"⫨",vBarv:"⫩",Vcy:"В",vcy:"в",VDash:"⊫",Vdash:"⊩",vDash:"⊨",vdash:"⊢",Vdashl:"⫦",Vee:"⋁",vee:"∨",veebar:"⊻",veeeq:"≚",vellip:"⋮",Verbar:"‖",verbar:"|",Vert:"‖",vert:"|",VerticalBar:"∣",VerticalLine:"|",VerticalSeparator:"❘",VerticalTilde:"≀",VeryThinSpace:" ",Vfr:"𝔙",vfr:"𝔳",vltri:"⊲",vnsub:"⊂⃒",vnsup:"⊃⃒",Vopf:"𝕍",vopf:"𝕧",vprop:"∝",vrtri:"⊳",Vscr:"𝒱",vscr:"𝓋",vsubnE:"⫋︀",vsubne:"⊊︀",vsupnE:"⫌︀",vsupne:"⊋︀",Vvdash:"⊪",vzigzag:"⦚",Wcirc:"Ŵ",wcirc:"ŵ",wedbar:"⩟",Wedge:"⋀",wedge:"∧",wedgeq:"≙",weierp:"℘",Wfr:"𝔚",wfr:"𝔴",Wopf:"𝕎",wopf:"𝕨",wp:"℘",wr:"≀",wreath:"≀",Wscr:"𝒲",wscr:"𝓌",xcap:"⋂",xcirc:"◯",xcup:"⋃",xdtri:"▽",Xfr:"𝔛",xfr:"𝔵",xhArr:"⟺",xharr:"⟷",Xi:"Ξ",xi:"ξ",xlArr:"⟸",xlarr:"⟵",xmap:"⟼",xnis:"⋻",xodot:"⨀",Xopf:"𝕏",xopf:"𝕩",xoplus:"⨁",xotime:"⨂",xrArr:"⟹",xrarr:"⟶",Xscr:"𝒳",xscr:"𝓍",xsqcup:"⨆",xuplus:"⨄",xutri:"△",xvee:"⋁",xwedge:"⋀",Yacute:"Ý",yacute:"ý",YAcy:"Я",yacy:"я",Ycirc:"Ŷ",ycirc:"ŷ",Ycy:"Ы",ycy:"ы",yen:"¥",Yfr:"𝔜",yfr:"𝔶",YIcy:"Ї",yicy:"ї",Yopf:"𝕐",yopf:"𝕪",Yscr:"𝒴",yscr:"𝓎",YUcy:"Ю",yucy:"ю",Yuml:"Ÿ",yuml:"ÿ",Zacute:"Ź",zacute:"ź",Zcaron:"Ž",zcaron:"ž",Zcy:"З",zcy:"з",Zdot:"Ż",zdot:"ż",zeetrf:"ℨ",ZeroWidthSpace:"​",Zeta:"Ζ",zeta:"ζ",Zfr:"ℨ",zfr:"𝔷",ZHcy:"Ж",zhcy:"ж",zigrarr:"⇝",Zopf:"ℤ",zopf:"𝕫",Zscr:"𝒵",zscr:"𝓏",zwj:"‍",zwnj:"‌"}),t.entityMap=t.HTML_ENTITIES},8978:(e,t,r)=>{var a=r(4722);t.DOMImplementation=a.DOMImplementation,t.XMLSerializer=a.XMLSerializer,t.DOMParser=r(5752).DOMParser},4466:(e,t,r)=>{var a=r(4582).NAMESPACE,n=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,o=new RegExp("[\\-\\.0-9"+n.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),i=new RegExp("^"+n.source+o.source+"*(?::"+n.source+o.source+"*)?$");function s(e,t){this.message=e,this.locator=t,Error.captureStackTrace&&Error.captureStackTrace(this,s)}function l(){}function c(e,t){return t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber,t}function u(e,t,r,n,o,i){function s(e,t,a){r.attributeNames.hasOwnProperty(e)&&i.fatalError("Attribute "+e+" redefined"),r.addValue(e,t.replace(/[\t\n\r]/g," ").replace(/&#?\w+;/g,o),a)}for(var l,c=++t,u=0;;){var h=e.charAt(c);switch(h){case"=":if(1===u)l=e.slice(t,c),u=3;else{if(2!==u)throw new Error("attribute equal must after attrName");u=3}break;case"'":case'"':if(3===u||1===u){if(1===u&&(i.warning('attribute value must after "="'),l=e.slice(t,c)),t=c+1,!((c=e.indexOf(h,t))>0))throw new Error("attribute value no end '"+h+"' match");s(l,d=e.slice(t,c),t-1),u=5}else{if(4!=u)throw new Error('attribute value must after "="');s(l,d=e.slice(t,c),t),i.warning('attribute "'+l+'" missed start quot('+h+")!!"),t=c+1,u=5}break;case"/":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:u=7,r.closed=!0;case 4:case 1:break;case 2:r.closed=!0;break;default:throw new Error("attribute invalid close char('/')")}break;case"":return i.error("unexpected end of input"),0==u&&r.setTagName(e.slice(t,c)),c;case">":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:break;case 4:case 1:"/"===(d=e.slice(t,c)).slice(-1)&&(r.closed=!0,d=d.slice(0,-1));case 2:2===u&&(d=l),4==u?(i.warning('attribute "'+d+'" missed quot(")!'),s(l,d,t)):(a.isHTML(n[""])&&d.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+d+'" missed value!! "'+d+'" instead!!'),s(d,d,t));break;case 3:throw new Error("attribute value missed!!")}return c;case"":h=" ";default:if(h<=" ")switch(u){case 0:r.setTagName(e.slice(t,c)),u=6;break;case 1:l=e.slice(t,c),u=2;break;case 4:var d=e.slice(t,c);i.warning('attribute "'+d+'" missed quot(")!!'),s(l,d,t);case 5:u=6}else switch(u){case 2:r.tagName,a.isHTML(n[""])&&l.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+l+'" missed value!! "'+l+'" instead2!!'),s(l,l,t),t=c,u=1;break;case 5:i.warning('attribute space is required"'+l+'"!!');case 6:u=1,t=c;break;case 3:u=4,t=c;break;case 7:throw new Error("elements closed character '/' and '>' must be connected to")}}c++}}function h(e,t,r){for(var n=e.tagName,o=null,i=e.length;i--;){var s=e[i],l=s.qName,c=s.value;if((m=l.indexOf(":"))>0)var u=s.prefix=l.slice(0,m),h=l.slice(m+1),d="xmlns"===u&&h;else h=l,u=null,d="xmlns"===l&&"";s.localName=h,!1!==d&&(null==o&&(o={},p(r,r={})),r[d]=o[d]=c,s.uri=a.XMLNS,t.startPrefixMapping(d,c))}for(i=e.length;i--;)(u=(s=e[i]).prefix)&&("xml"===u&&(s.uri=a.XML),"xmlns"!==u&&(s.uri=r[u||""]));var m;(m=n.indexOf(":"))>0?(u=e.prefix=n.slice(0,m),h=e.localName=n.slice(m+1)):(u=null,h=e.localName=n);var f=e.uri=r[u||""];if(t.startElement(f,h,n,e),!e.closed)return e.currentNSMap=r,e.localNSMap=o,!0;if(t.endElement(f,h,n),o)for(u in o)Object.prototype.hasOwnProperty.call(o,u)&&t.endPrefixMapping(u)}function d(e,t,r,a,n){if(/^(?:script|textarea)$/i.test(r)){var o=e.indexOf("</"+r+">",t),i=e.substring(t+1,o);if(/[&<]/.test(i))return/^script$/i.test(r)?(n.characters(i,0,i.length),o):(i=i.replace(/&#?\w+;/g,a),n.characters(i,0,i.length),o)}return t+1}function m(e,t,r,a){var n=a[r];return null==n&&((n=e.lastIndexOf("</"+r+">"))<t&&(n=e.lastIndexOf("</"+r)),a[r]=n),n<t}function p(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function f(e,t,r,a){if("-"===e.charAt(t+2))return"-"===e.charAt(t+3)?(n=e.indexOf("--\x3e",t+4))>t?(r.comment(e,t+4,n-t-4),n+3):(a.error("Unclosed comment"),-1):-1;if("CDATA["==e.substr(t+3,6)){var n=e.indexOf("]]>",t+9);return r.startCDATA(),r.characters(e,t+9,n-t-9),r.endCDATA(),n+3}var o=function(e,t){var r,a=[],n=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;for(n.lastIndex=t,n.exec(e);r=n.exec(e);)if(a.push(r),r[1])return a}(e,t),i=o.length;if(i>1&&/!doctype/i.test(o[0][0])){var s=o[1][0],l=!1,c=!1;i>3&&(/^public$/i.test(o[2][0])?(l=o[3][0],c=i>4&&o[4][0]):/^system$/i.test(o[2][0])&&(c=o[3][0]));var u=o[i-1];return r.startDTD(s,l,c),r.endDTD(),u.index+u[0].length}return-1}function x(e,t,r){var a=e.indexOf("?>",t);if(a){var n=e.substring(t,a).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);return n?(n[0].length,r.processingInstruction(n[1],n[2]),a+2):-1}return-1}function g(){this.attributeNames={}}s.prototype=new Error,s.prototype.name=s.name,l.prototype={parse:function(e,t,r){var n=this.domBuilder;n.startDocument(),p(t,t={}),function(e,t,r,n,o){function i(e){var t=e.slice(1,-1);return Object.hasOwnProperty.call(r,t)?r[t]:"#"===t.charAt(0)?function(e){if(e>65535){var t=55296+((e-=65536)>>10),r=56320+(1023&e);return String.fromCharCode(t,r)}return String.fromCharCode(e)}(parseInt(t.substr(1).replace("x","0x"))):(o.error("entity not found:"+e),e)}function l(t){if(t>_){var r=e.substring(_,t).replace(/&#?\w+;/g,i);C&&p(_),n.characters(r,0,t-_),_=t}}function p(t,r){for(;t>=b&&(r=v.exec(e));)w=r.index,b=w+r[0].length,C.lineNumber++;C.columnNumber=t-w+1}for(var w=0,b=0,v=/.*(?:\r\n?|\n)|.*$/g,C=n.locator,A=[{currentNSMap:t}],E={},_=0;;){try{var y=e.indexOf("<",_);if(y<0){if(!e.substr(_).match(/^\s*$/)){var q=n.doc,D=q.createTextNode(e.substr(_));q.appendChild(D),n.currentElement=D}return}switch(y>_&&l(y),e.charAt(y+1)){case"/":var M=e.indexOf(">",y+3),T=e.substring(y+2,M).replace(/[ \t\n\r]+$/g,""),N=A.pop();M<0?(T=e.substring(y+2).replace(/[\s<].*/,""),o.error("end tag name: "+T+" is not complete:"+N.tagName),M=y+1+T.length):T.match(/\s</)&&(T=T.replace(/[\s<].*/,""),o.error("end tag name: "+T+" maybe not complete"),M=y+1+T.length);var O=N.localNSMap,L=N.tagName==T;if(L||N.tagName&&N.tagName.toLowerCase()==T.toLowerCase()){if(n.endElement(N.uri,N.localName,T),O)for(var B in O)Object.prototype.hasOwnProperty.call(O,B)&&n.endPrefixMapping(B);L||o.fatalError("end tag name: "+T+" is not match the current start tagName:"+N.tagName)}else A.push(N);M++;break;case"?":C&&p(y),M=x(e,y,n);break;case"!":C&&p(y),M=f(e,y,n,o);break;default:C&&p(y);var S=new g,F=A[A.length-1].currentNSMap,P=(M=u(e,y,S,F,i,o),S.length);if(!S.closed&&m(e,M,S.tagName,E)&&(S.closed=!0,r.nbsp||o.warning("unclosed xml attribute")),C&&P){for(var k=c(C,{}),R=0;R<P;R++){var I=S[R];p(I.offset),I.locator=c(C,{})}n.locator=k,h(S,n,F)&&A.push(S),n.locator=C}else h(S,n,F)&&A.push(S);a.isHTML(S.uri)&&!S.closed?M=d(e,M,S.tagName,i,n):M++}}catch(e){if(e instanceof s)throw e;o.error("element parse error: "+e),M=-1}M>_?_=M:l(Math.max(y,_)+1)}}(e,t,r,n,this.errorHandler),n.endDocument()}},g.prototype={setTagName:function(e){if(!i.test(e))throw new Error("invalid tagName:"+e);this.tagName=e},addValue:function(e,t,r){if(!i.test(e))throw new Error("invalid attribute:"+e);this.attributeNames[e]=this.length,this[this.length++]={qName:e,value:t,offset:r}},length:0,getLocalName:function(e){return this[e].localName},getLocator:function(e){return this[e].locator},getQName:function(e){return this[e].qName},getURI:function(e){return this[e].uri},getValue:function(e){return this[e].value}},t.XMLReader=l,t.ParseError=s},8917:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;var a=r(6200);Object.defineProperty(t,"InvalidNumberOfChildrenError",{enumerable:!0,get:function(){return a.InvalidNumberOfChildrenError}})},6200:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;class r extends Error{constructor(e,t,r,a="exactly"){super(`${e} tag must have ${a} ${t} children. It's actually ${r}`),this.name="InvalidNumberOfChildrenError"}}t.InvalidNumberOfChildrenError=r},4279:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(828),t),n(r(5975),t),n(r(799),t),n(r(2424),t)},5975:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JoinWithManySeparators=void 0;class r{constructor(e){this._separators=e}static join(e,t){return new r(t)._join(e)}_join(e){return e.reduce(((e,t,r,a)=>e+t+(r===a.length-1?"":this._get(r))),"")}_get(e){return this._separators[e]?this._separators[e]:this._separators.length>0?this._separators[this._separators.length-1]:","}}t.JoinWithManySeparators=r},799:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathMLElementToLaTeXConverter=void 0;const a=r(5443);t.mathMLElementToLaTeXConverter=e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter()},2424:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.normalizeWhiteSpaces=void 0,t.normalizeWhiteSpaces=e=>e.replace(/\s+/g," ")},7192:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BracketWrapper=void 0;const a=r(1855);t.BracketWrapper=class{constructor(){this._open="{",this._close="}"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},5025:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=void 0;const a=r(1855);t.GenericWrapper=class{constructor(e,t){this._open="\\left"+e,this._close="\\right"+t}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},828:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=t.ParenthesisWrapper=t.BracketWrapper=void 0;var a=r(7192);Object.defineProperty(t,"BracketWrapper",{enumerable:!0,get:function(){return a.BracketWrapper}});var n=r(1168);Object.defineProperty(t,"ParenthesisWrapper",{enumerable:!0,get:function(){return n.ParenthesisWrapper}});var o=r(5025);Object.defineProperty(t,"GenericWrapper",{enumerable:!0,get:function(){return o.GenericWrapper}})},1168:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ParenthesisWrapper=void 0;const a=r(1855);t.ParenthesisWrapper=class{constructor(){this._open="\\left(",this._close="\\right)"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}wrapIfMoreThanOneChar(e){return e.length<=1?e:this.wrap(e)}}},1855:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Wrapper=void 0,t.Wrapper=class{constructor(e,t){this._open=e,this._close=t}wrap(e){return this._open+e+this._close}}},2697:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VoidMathMLElement=void 0,t.VoidMathMLElement=class{constructor(){this.name="void",this.value="",this.children=[],this.attributes={}}}},4760:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericSpacingWrapper=void 0;const a=r(4279);t.GenericSpacingWrapper=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}},9376:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericUnderOver=void 0;const a=r(799),n=r(8917),o=r(472);t.GenericUnderOver=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert(),i=(0,a.mathMLElementToLaTeXConverter)(t[1]).convert();return this._applyCommand(o,i)}_applyCommand(e,t){const r=this._mathmlElement.name.match(/under/)?s.Under:s.Over;return new i(r).apply(e,t)}};class i{constructor(e){this._type=e}apply(e,t){return o.latexAccents.includes(t)?`${t}{${e}}`:`${this._defaultCommand}{${t}}{${e}}`}get _defaultCommand(){return this._type===s.Under?"\\underset":"\\overset"}}var s;!function(e){e[e.Under=0]="Under",e[e.Over=1]="Over"}(s||(s={}))},6959:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=t.GenericUnderOver=t.GenericSpacingWrapper=t.MTr=t.MTable=t.MUnderover=t.MText=t.MMultiscripts=t.MSubsup=t.MSub=t.MSup=t.MPhantom=t.MError=t.MEnclose=t.MAction=t.MRoot=t.MFrac=t.MFenced=t.MSqrt=t.MN=t.MO=t.MI=t.Math=void 0;var a=r(393);Object.defineProperty(t,"Math",{enumerable:!0,get:function(){return a.Math}});var n=r(7037);Object.defineProperty(t,"MI",{enumerable:!0,get:function(){return n.MI}});var o=r(3487);Object.defineProperty(t,"MO",{enumerable:!0,get:function(){return o.MO}});var i=r(4464);Object.defineProperty(t,"MN",{enumerable:!0,get:function(){return i.MN}});var s=r(8686);Object.defineProperty(t,"MSqrt",{enumerable:!0,get:function(){return s.MSqrt}});var l=r(9511);Object.defineProperty(t,"MFenced",{enumerable:!0,get:function(){return l.MFenced}});var c=r(6440);Object.defineProperty(t,"MFrac",{enumerable:!0,get:function(){return c.MFrac}});var u=r(6052);Object.defineProperty(t,"MRoot",{enumerable:!0,get:function(){return u.MRoot}});var h=r(1678);Object.defineProperty(t,"MAction",{enumerable:!0,get:function(){return h.MAction}});var d=r(2631);Object.defineProperty(t,"MEnclose",{enumerable:!0,get:function(){return d.MEnclose}});var m=r(1840);Object.defineProperty(t,"MError",{enumerable:!0,get:function(){return m.MError}});var p=r(7443);Object.defineProperty(t,"MPhantom",{enumerable:!0,get:function(){return p.MPhantom}});var f=r(6926);Object.defineProperty(t,"MSup",{enumerable:!0,get:function(){return f.MSup}});var x=r(2564);Object.defineProperty(t,"MSub",{enumerable:!0,get:function(){return x.MSub}});var g=r(1358);Object.defineProperty(t,"MSubsup",{enumerable:!0,get:function(){return g.MSubsup}});var w=r(8303);Object.defineProperty(t,"MMultiscripts",{enumerable:!0,get:function(){return w.MMultiscripts}});var b=r(3951);Object.defineProperty(t,"MText",{enumerable:!0,get:function(){return b.MText}});var v=r(1222);Object.defineProperty(t,"MUnderover",{enumerable:!0,get:function(){return v.MUnderover}});var C=r(2350);Object.defineProperty(t,"MTable",{enumerable:!0,get:function(){return C.MTable}});var A=r(1586);Object.defineProperty(t,"MTr",{enumerable:!0,get:function(){return A.MTr}});var E=r(4760);Object.defineProperty(t,"GenericSpacingWrapper",{enumerable:!0,get:function(){return E.GenericSpacingWrapper}});var _=r(9376);Object.defineProperty(t,"GenericUnderOver",{enumerable:!0,get:function(){return _.GenericUnderOver}});var y=r(9165);Object.defineProperty(t,"Void",{enumerable:!0,get:function(){return y.Void}})},1678:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAction=void 0;const a=r(799);t.MAction=class{constructor(e){this._mathmlElement=e}convert(){const{children:e}=this._mathmlElement;return this._isToggle()?e.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\Longrightarrow "):(0,a.mathMLElementToLaTeXConverter)(e[0]).convert()}_isToggle(){const{actiontype:e}=this._mathmlElement.attributes;return"toggle"===e||!e}}},393:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Math=void 0;const a=r(799),n=r(2424);t.Math=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return(0,n.normalizeWhiteSpaces)(e)}}},2631:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MEnclose=void 0;const a=r(799);t.MEnclose=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return"actuarial"===this._notation?`\\overline{\\left.${e}\\right|}`:"radical"===this._notation?`\\sqrt{${e}}`:["box","roundedbox","circle"].includes(this._notation)?`\\boxed{${e}}`:"left"===this._notation?`\\left|${e}`:"right"===this._notation?`${e}\\right|`:"top"===this._notation?`\\overline{${e}}`:"bottom"===this._notation?`\\underline{${e}}`:"updiagonalstrike"===this._notation?`\\cancel{${e}}`:"downdiagonalstrike"===this._notation?`\\bcancel{${e}}`:"updiagonalarrow"===this._notation?`\\cancelto{}{${e}}`:["verticalstrike","horizontalstrike"].includes(this._notation)?`\\hcancel{${e}}`:"madruwb"===this._notation?`\\underline{${e}\\right|}`:"phasorangle"===this._notation?`{\\angle \\underline{${e}}}`:`\\overline{\\left.\\right)${e}}`}get _notation(){return this._mathmlElement.attributes.notation||"longdiv"}}},1840:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MError=void 0;const a=r(799);t.MError=class{constructor(e){this._mathmlElement=e}convert(){return`\\color{red}{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},9511:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFenced=void 0;const a=r(799),n=r(4279);t.MFenced=class{constructor(e){this._mathmlElement=e,this._open=this._mathmlElement.attributes.open||"",this._close=this._mathmlElement.attributes.close||"",this._separators=Array.from(this._mathmlElement.attributes.separators||"")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert()));return this._isThereRelativeOfName(this._mathmlElement.children,"mtable")?new i(this._open,this._close).apply(e):new o(this._open,this._close,this._separators).apply(e)}_isThereRelativeOfName(e,t){return e.some((e=>e.name===t||this._isThereRelativeOfName(e.children,t)))}};class o{constructor(e,t,r){this._open=e||"(",this._close=t||")",this._separators=r}apply(e){const t=n.JoinWithManySeparators.join(e,this._separators);return new n.GenericWrapper(this._open,this._close).wrap(t)}}class i{constructor(e,t){this._genericCommand="matrix",this._separators=new s(e,t)}apply(e){const t=this._command,r=`\\begin{${t}}\n${e.join("")}\n\\end{${t}}`;return t===this._genericCommand?this._separators.wrap(r):r}get _command(){return this._separators.areParentheses()?"pmatrix":this._separators.areSquareBrackets()?"bmatrix":this._separators.areBrackets()?"Bmatrix":this._separators.areDivides()?"vmatrix":this._separators.areParallels()?"Vmatrix":this._separators.areNotEqual()?this._genericCommand:"bmatrix"}}class s{constructor(e,t){this._open=e,this._close=t}wrap(e){return new n.GenericWrapper(this._open,this._close).wrap(e)}areParentheses(){return this._compare("(",")")}areSquareBrackets(){return this._compare("[","]")}areBrackets(){return this._compare("{","}")}areDivides(){return this._compare("|","|")}areParallels(){return this._compare("||","||")}areNotEqual(){return this._open!==this._close}_compare(e,t){return this._open===e&&this._close===t}}},6440:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFrac=void 0;const a=r(8917),n=r(4279);t.MFrac=class{constructor(e){this._mathmlElement=e}convert(){const{children:e,name:t}=this._mathmlElement,r=e.length;if(2!==r)throw new a.InvalidNumberOfChildrenError(t,2,r);const o=(0,n.mathMLElementToLaTeXConverter)(e[0]).convert(),i=(0,n.mathMLElementToLaTeXConverter)(e[1]).convert();return this._isBevelled()?`${this._wrapIfMoreThanOneChar(o)}/${this._wrapIfMoreThanOneChar(i)}`:`\\frac{${o}}{${i}}`}_wrapIfMoreThanOneChar(e){return(new n.ParenthesisWrapper).wrapIfMoreThanOneChar(e)}_isBevelled(){return!!this._mathmlElement.attributes.bevelled}}},7037:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MI=void 0;const a=r(4279),n=r(5406),o=r(6122);t.MI=class{constructor(e){this.utf8Converter=new o.HashUTF8ToLtXConverter,this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value);if(" "===e)return i.apply(e);const t=e.trim(),r=i.apply(t),n=this.utf8Converter.convert(r);return n!==r?n:this.wrapInMathVariant(r,this.getMathVariant(this._mathmlElement.attributes))}getMathVariant(e){if(e&&e.mathvariant)return e.mathvariant}wrapInMathVariant(e,t){switch(t){case"bold":return`\\mathbf{${e}}`;case"italic":return`\\mathit{${e}}`;case"bold-italic":return`\\mathbf{\\mathit{${e}}}`;case"double-struck":return`\\mathbb{${e}}`;case"bold-fraktur":return`\\mathbf{\\mathfrak{${e}}}`;case"script":return`\\mathcal{${e}}`;case"bold-script":return`\\mathbf{\\mathcal{${e}}}`;case"fraktur":return`\\mathfrak{${e}}`;case"sans-serif":return`\\mathsf{${e}}`;case"bold-sans-serif":return`\\mathbf{\\mathsf{${e}}}`;case"sans-serif-italic":return`\\mathsf{\\mathit{${e}}}`;case"sans-serif-bold-italic":return`\\mathbf{\\mathsf{\\mathit{${e}}}}`;case"monospace":return`\\mathtt{${e}}`;default:return e}}};class i{constructor(e){this._value=e}static apply(e){return new i(e)._apply()}_apply(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new o.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathSymbolsByChar[this._value]}_findByGlyph(){return n.allMathSymbolsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},8303:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MMultiscripts=void 0;const a=r(4279),n=r(8917);t.MMultiscripts=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(r<3)throw new n.InvalidNumberOfChildrenError(e,3,r,"at least");const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return this._prescriptLatex()+this._wrapInParenthesisIfThereIsSpace(o)+this._postscriptLatex()}_prescriptLatex(){const{children:e}=this._mathmlElement;let t,r;if(this._isPrescripts(e[1]))t=e[2],r=e[3];else{if(!this._isPrescripts(e[3]))return"";t=e[4],r=e[5]}return`\\_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_postscriptLatex(){const{children:e}=this._mathmlElement;if(this._isPrescripts(e[1]))return"";const t=e[1],r=e[2];return`_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_wrapInParenthesisIfThereIsSpace(e){return e.match(/\s+/g)?(new a.ParenthesisWrapper).wrap(e):e}_isPrescripts(e){return"mprescripts"===(null==e?void 0:e.name)}}},4464:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MN=void 0;const a=r(4279),n=r(5406);t.MN=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return n.mathNumberByGlyph[e]||e}}},3487:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MO=void 0;const a=r(4279),n=r(5406);t.MO=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return o.operate(e)}};class o{constructor(e){this._value=e}static operate(e){return new o(e)._operate()}_operate(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new n.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathOperatorsByChar[this._value]}_findByGlyph(){return n.allMathOperatorsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},7443:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MPhantom=void 0,t.MPhantom=class{constructor(e){this._mathmlElement=e}convert(){return""}}},6052:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MRoot=void 0;const a=r(4279),n=r(8917);t.MRoot=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return`\\sqrt[${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}]{${o}}`}}},8686:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSqrt=void 0;const a=r(4279);t.MSqrt=class{constructor(e){this._mathmlElement=e}convert(){return`\\sqrt{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},2564:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSub=void 0;const a=r(4279),n=r(8917);t.MSub=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},1358:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSubsup=void 0;const a=r(4279),n=r(8917);t.MSubsup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);const a=t[0],o=t[1],i=t[2];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}^${this._handleSuperscriptChild(i)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}_handleSuperscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},6926:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSup=void 0;const a=r(4279),n=r(8917);t.MSup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}^${this._handleExponentChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleExponentChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},2350:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTable=void 0;const a=r(4279);t.MTable=class{constructor(e){this._mathmlElement=e,this._addFlagRecursiveIfName(this._mathmlElement.children,"mtable","innerTable")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\\\\n");return this._hasFlag("innerTable")?this._wrap(e):e}_wrap(e){return`\\begin{matrix}${e}\\end{matrix}`}_addFlagRecursiveIfName(e,t,r){e.forEach((e=>{e.name===t&&(e.attributes[r]=r),this._addFlagRecursiveIfName(e.children,t,r)}))}_hasFlag(e){return!!this._mathmlElement.attributes[e]}}},3951:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MText=void 0;const a=r(7037);t.MText=class{constructor(e){this._mathmlElement=e}convert(){const{attributes:e,value:t}=this._mathmlElement;return[...t].map((e=>/^[a-zA-Z0-9]$/.test(e)||" "===e?{value:e,isAlphanumeric:!0}:{value:e,isAlphanumeric:!1})).reduce(((e,t)=>{if(t.isAlphanumeric){const r=e[e.length-1];if(r&&r.isAlphanumeric)return r.value+=t.value,e}return[...e,t]}),[]).map((t=>t.isAlphanumeric?new n(e.mathvariant).apply(t.value):new a.MI({name:"mi",attributes:{},children:[],value:t.value}).convert())).join("")}};class n{constructor(e){this._mathvariant=e||"normal"}apply(e){return this._commands.reduce(((t,r,a)=>0===a?`${r}{${e}}`:`${r}{${t}}`),"")}get _commands(){switch(this._mathvariant){case"bold":return["\\textbf"];case"italic":return["\\textit"];case"bold-italic":return["\\textit","\\textbf"];case"double-struck":return["\\mathbb"];case"monospace":return["\\mathtt"];case"bold-fraktur":case"fraktur":return["\\mathfrak"];default:return["\\text"]}}}},1586:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTr=void 0;const a=r(4279);t.MTr=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" & ")}}},1222:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MUnderover=void 0;const a=r(4279),n=r(8917);t.MUnderover=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);return`${(0,a.mathMLElementToLaTeXConverter)(t[0]).convert()}_{${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(t[2]).convert()}}`}}},9165:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=void 0,t.Void=class{constructor(e){this._mathmlElement=e}convert(){return""}}},5443:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return n(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLElementToLatexConverterAdapter=void 0;const i=o(r(6959)),s=r(2697);t.MathMLElementToLatexConverterAdapter=class{constructor(e){this._mathMLElement=null!=e?e:new s.VoidMathMLElement}toLatexConverter(){const{name:e}=this._mathMLElement;return new(l[e]||i.GenericSpacingWrapper)(this._mathMLElement)}};const l={math:i.Math,mi:i.MI,mo:i.MO,mn:i.MN,msqrt:i.MSqrt,mfenced:i.MFenced,mfrac:i.MFrac,mroot:i.MRoot,maction:i.MAction,menclose:i.MEnclose,merror:i.MError,mphantom:i.MPhantom,msup:i.MSup,msub:i.MSub,msubsup:i.MSubsup,mmultiscripts:i.MMultiscripts,mtext:i.MText,munderover:i.MUnderover,mtable:i.MTable,mtr:i.MTr,mover:i.GenericUnderOver,munder:i.GenericUnderOver,mrow:i.GenericSpacingWrapper,mpadded:i.GenericSpacingWrapper,void:i.Void}},5243:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorHandler=void 0,t.ErrorHandler=class{constructor(){this._errors=[],this.errorLocator={}}fixError(e,t){return this._isMissingAttributeValueError(t)?(this._errors.push(t),this._fixMissingAttribute(t,e)):e}isThereAnyErrors(){return this._errors.length>0}cleanErrors(){this._errors=[]}_fixMissingAttribute(e,t){const r=e.split('"')[1];if(r)return t.replace(this._matchMissingValueForAttribute(r),"");for(;this._mathGenericMissingValue().exec(t);)t=t.replace(this._mathGenericMissingValue(),"$1$3");return t}_matchMissingValueForAttribute(e){return new RegExp(`(${e}=(?!("|')))|(${e}(?!("|')))`,"gm")}_mathGenericMissingValue(){return/(\<.* )(\w+=(?!\"|\'))(.*\>)/gm}_isMissingAttributeValueError(e){return!!e.includes("attribute")&&!!e.includes("missed")||e.includes("attribute value missed")}}},9208:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(9548),t),n(r(5243),t),n(r(1101),t)},1101:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ElementsToMathMLAdapter=void 0,t.ElementsToMathMLAdapter=class{convert(e){return e.filter((e=>void 0!==e.tagName)).map((e=>this._convertElement(e)))}_convertElement(e){return{name:e.tagName,attributes:this._convertElementAttributes(e.attributes),value:this._hasElementChild(e)?"":e.textContent||"",children:this._hasElementChild(e)?this.convert(Array.from(e.childNodes)):[]}}_convertElementAttributes(e){return Array.from(e).reduce(((e,t)=>Object.assign({[t.nodeName]:t.nodeValue===t.nodeName?"":t.nodeValue},e)),{})}_hasElementChild(e){const t=e.childNodes;return!!t&&0!==t.length&&this._isThereAnyNoTextNode(t)}_isThereAnyNoTextNode(e){return Array.from(e).some((e=>"#text"!==e.nodeName))}}},9548:function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.XmlToMathMLAdapter=void 0;const n=a(r(8978));t.XmlToMathMLAdapter=class{constructor(e,t){this._xml="",this._elementsConvertor=e,this._errorHandler=t,this._xmlDOM=new n.default.DOMParser({locator:this._errorHandler.errorLocator,errorHandler:this._fixError.bind(this)})}convert(e){return this._xml=this._removeLineBreaks(e),this._xml=this._removeMsWordPrefixes(this._xml),this._elementsConvertor.convert(this._mathMLElements)}_fixError(e){this._xml=this._errorHandler.fixError(this._xml,e)}_removeLineBreaks(e){return e.replace(/\n|\r\n|\r/g,"")}_removeMsWordPrefixes(e){return e.replace(/mml:/g,"")}get _mathMLElements(){let e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math");return this._errorHandler.isThereAnyErrors()&&(this._errorHandler.cleanErrors(),e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math")),Array.from(e)}}},7941:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(8585),t)},8585:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeToMathElementsConverter=void 0;const a=r(9208);t.makeToMathElementsConverter=()=>{const e=new a.ElementsToMathMLAdapter,t=new a.ErrorHandler;return new a.XmlToMathMLAdapter(e,t)}},8672:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(3798),t)},3798:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLToLaTeX=void 0;const a=r(5443),n=r(7941);t.MathMLToLaTeX=class{static convert(e){return(0,n.makeToMathElementsConverter)().convert(e).map((e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter())).map((e=>e.convert())).join("").trim()}}},2965:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByChar=void 0,t.allMathOperatorsByChar={_:"\\underline","&#x23E1;":"\\underbrace","&#x23E0;":"\\overbrace","&#x23DF;":"\\underbrace","&#x23DE;":"\\overbrace","&#x23DD;":"\\underbrace","&#x23DC;":"\\overbrace","&#x23B5;":"\\underbrace","&#x23B4;":"\\overbrace","&#x20DC;":"\\square","&#x20DB;":"\\square","&#x2064;":"","&#x2057;":"''''","&#x203E;":"\\bar","&#x2037;":"```","&#x2036;":"``","&#x2035;":"`","&#x2034;":"'''","&#x2033;":"''","&#x201F;":"``","&#x201E;":",,","&#x201B;":"`","&#x201A;":",","&#x302;":"\\hat","&#x2F7;":"\\sim","&#x2DD;":"\\sim","&#x2DC;":"\\sim","&#x2DA;":"\\circ","&#x2D9;":"\\cdot","&#x2D8;":"","&#x2CD;":"\\_","&#x2CB;":"ˋ","&#x2CA;":"ˊ","&#x2C9;":"ˉ","&#x2C7;":"","&#x2C6;":"\\hat","&#xBA;":"o","&#xB9;":"1","&#xB8;":"¸","&#xB4;":"´","&#xB3;":"3","&#xB2;":"2","&#xB0;":"\\circ","&#xAF;":"\\bar","&#xAA;":"a","&#xA8;":"\\cdot\\cdot","~":"\\sim","`":"`","^":"\\hat","--":"--","++":"++","&amp;":"\\&","&#x2061;":"","&#x221C;":"\\sqrt[4]{}","&#x221B;":"\\sqrt[3]{}","&#x221A;":"\\sqrt{}","&#x2146;":"d","&#x2145;":"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","&#x266F;":"\\#","&#x266E;":"","&#x266D;":"","&#x2032;":"'","&lt;>":"<>","**":"\\star\\star","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x2299;":"\\bigodot","&#xAC;":"\\neg","&#x2222;":"\\measuredangle","&#x2221;":"\\measuredangle","&#x2220;":"\\angle","&#xF7;":"\\div","/":"/","&#x2216;":"\\backslash","\\":"\\backslash","%":"\\%","&#x2297;":"\\bigotimes","&#xB7;":"\\cdot","&#x2A3F;":"\\coprod","&#x2A2F;":"\\times","&#x22C5;":"\\cdot","&#x22A1;":"\\boxdot","&#x22A0;":"\\boxtimes","&#x2062;":"","&#x2043;":"-","&#x2022;":"\\cdot","&#xD7;":"\\times",".":".","*":"\\star","&#x222A;":"\\cup","&#x2229;":"\\cap","&#x2210;":"\\coprod","&#x220F;":"\\prod","&#x2240;":"","&#x2AFF;":"","&#x2AFC;":"\\mid\\mid\\mid","&#x2A09;":"\\times","&#x2A08;":"","&#x2A07;":"","&#x2A06;":"\\sqcup","&#x2A05;":"\\sqcap","&#x2A02;":"\\otimes","&#x2A00;":"\\odot","&#x22C2;":"\\cap","&#x22C1;":"\\vee","&#x22C0;":"\\wedge","&#x2A04;":"\\uplus","&#x2A03;":"\\cup","&#x22C3;":"\\cup","&#x2A1C;":"\\underline{\\int}","&#x2A1B;":"\\overline{\\int}","&#x2A1A;":"\\int","&#x2A19;":"\\int","&#x2A18;":"\\int","&#x2A17;":"\\int","&#x2A16;":"\\oint","&#x2A15;":"\\oint","&#x2A14;":"\\int","&#x2A13;":"\\int","&#x2A12;":"\\int","&#x2A11;":"\\int","&#x2A10;":"\\int","&#x2A0F;":"\\bcancel{\\int}","&#x2A0E;":"","&#x2A0D;":"\\hcancel{\\int}","&#x2A0C;":"\\iiiint","&#x2233;":"\\oint","&#x2232;":"\\oint","&#x2231;":"\\int","&#x2230;":"\\oiint","&#x222F;":"\\oiint","&#x222E;":"\\oint","&#x222B;":"\\int","&#x2A01;":"\\oplus","&#x2298;":"\\oslash","&#x2296;":"\\ominus","&#x2295;":"\\oplus","&#x222D;":"\\iiint","&#x222C;":"\\iint","&#x2A0B;":"","&#x2A0A;":"","&#x2211;":"\\sum","&#x229F;":"\\boxminus","&#x229E;":"\\boxplus","&#x2214;":"\\dot{+}","&#x2213;":"+-","&#x2212;":"-","&#xB1;":"\\pm","-":"-","+":"+","&#x2B46;":"\\Rrightarrow","&#x2B45;":"\\Lleftarrow","&#x29F4;":":\\rightarrow","&#x29EF;":"","&#x29DF;":"\\bullet-\\bullet","&#x299F;":"\\angle","&#x299E;":"\\measuredangle","&#x299D;":"\\measuredangle","&#x299C;":"\\perp","&#x299B;":"\\measuredangle","&#x299A;":"","&#x2999;":"\\vdots","&#x297F;":"","&#x297E;":"","&#x297D;":"\\prec","&#x297C;":"\\succ","&#x297B;":"\\underset{\\rightarrow}{\\supset}","&#x297A;":"","&#x2979;":"\\underset{\\rightarrow}{\\subset}","&#x2978;":"\\underset{\\rightarrow}{>}","&#x2977;":"","&#x2976;":"\\underset{\\leftarrow}{<}","&#x2975;":"\\underset{\\approx}{\\rightarrow}","&#x2974;":"\\underset{\\sim}{\\rightarrow}","&#x2973;":"\\underset{\\sim}{\\leftarrow}","&#x2972;":"\\overset{\\sim}{\\rightarrow}","&#x2971;":"\\overset{=}{\\rightarrow}","&#x2970;":"","&#x296F;":"","&#x296E;":"","&#x296D;":"\\overline{\\rightharpoondown}","&#x296C;":"\\underline{\\rightharpoonup}","&#x296B;":"\\overline{\\leftharpoondown}","&#x296A;":"\\underline{\\leftharpoonup}","&#x2969;":"\\rightleftharpoons","&#x2968;":"\\rightleftharpoons","&#x2967;":"\\rightleftharpoons","&#x2966;":"\\rightleftharpoons","&#x2965;":"\\Downarrow","&#x2964;":"\\Rightarrow","&#x2963;":"\\Uparrow","&#x2962;":"\\Leftarrow","&#x2961;":"\\downarrow","&#x2960;":"\\uparrow","&#x295F;":"\\rightarrow","&#x295E;":"\\leftarrow","&#x295D;":"\\downarrow","&#x295C;":"\\uparrow","&#x295B;":"\\rightarrow","&#x295A;":"\\leftarrow","&#x2959;":"\\downarrow","&#x2958;":"\\uparrow","&#x2957;":"\\rightarrow","&#x2956;":"\\leftarrow","&#x2955;":"\\downarrow","&#x2954;":"\\uparrow","&#x2953;":"\\rightarrow","&#x2952;":"\\leftarrow","&#x2951;":"\\updownarrow","&#x2950;":"\\leftrightarrow","&#x294F;":"\\updownarrow","&#x294E;":"\\leftrightarrow","&#x294D;":"\\updownarrow","&#x294C;":"\\updownarrow","&#x294B;":"\\leftrightarrow","&#x294A;":"\\leftrightarrow","&#x2949;":"","&#x2948;":"\\leftrightarrow","&#x2947;":"\\nrightarrow","&#x2946;":"","&#x2945;":"","&#x2944;":"\\rightleftarrows","&#x2943;":"\\leftrightarrows","&#x2942;":"\\rightleftarrows","&#x2941;":"\\circlearrowright","&#x2940;":"\\circlearrowleft","&#x293F;":"\\rightarrow","&#x293E;":"\\leftarrow","&#x293D;":"","&#x293C;":"","&#x293B;":"","&#x293A;":"","&#x2939;":"","&#x2938;":"","&#x2937;":"\\Rsh","&#x2936;":"\\Lsh","&#x2935;":"\\downarrow","&#x2934;":"\\uparrow","&#x2933;":"\\leadsto","&#x2932;":"","&#x2931;":"","&#x2930;":"","&#x292F;":"","&#x292E;":"","&#x292D;":"","&#x292C;":"\\times","&#x292B;":"\\times","&#x292A;":"","&#x2929;":"","&#x2928;":"","&#x2927;":"","&#x2926;":"","&#x2925;":"","&#x2924;":"","&#x2923;":"","&#x2922;":"","&#x2921;":"","&#x2920;":"\\mapsto\\cdot","&#x291F;":"\\cdot\\leftarrow","&#x291E;":"\\rightarrow\\cdot","&#x291D;":"\\leftarrow","&#x291C;":"\\rightarrow","&#x291B;":"\\leftarrow","&#x291A;":"\\rightarrow","&#x2919;":"\\leftarrow","&#x2918;":"\\rightarrow","&#x2917;":"\\rightarrow","&#x2916;":"\\rightarrow","&#x2915;":"\\rightarrow","&#x2914;":"\\rightarrow","&#x2913;":"\\downarrow","&#x2912;":"\\uparrow","&#x2911;":"\\rightarrow","&#x2910;":"\\rightarrow","&#x290F;":"\\rightarrow","&#x290E;":"\\leftarrow","&#x290D;":"\\rightarrow","&#x290C;":"\\leftarrow","&#x290B;":"\\Downarrow","&#x290A;":"\\Uparrow","&#x2909;":"\\uparrow","&#x2908;":"\\downarrow","&#x2907;":"\\Rightarrow","&#x2906;":"\\Leftarrow","&#x2905;":"\\mapsto","&#x2904;":"\\nLeftrightarrow","&#x2903;":"\\nRightarrow","&#x2902;":"\\nLeftarrow","&#x2901;":"\\rightsquigarrow","&#x2900;":"\\rightsquigarrow","&#x27FF;":"\\rightsquigarrow","&#x27FE;":"\\Rightarrow","&#x27FD;":"\\Leftarrow","&#x27FC;":"\\mapsto","&#x27FB;":"\\leftarrow","&#x27FA;":"\\Longleftrightarrow","&#x27F9;":"\\Longrightarrow","&#x27F8;":"\\Longleftarrow","&#x27F7;":"\\leftrightarrow","&#x27F6;":"\\rightarrow","&#x27F5;":"\\leftarrow","&#x27F1;":"\\Downarrow","&#x27F0;":"\\Uparrow","&#x22B8;":"\\rightarrow","&#x21FF;":"\\leftrightarrow","&#x21FE;":"\\rightarrow","&#x21FD;":"\\leftarrow","&#x21FC;":"\\nleftrightarrow","&#x21FB;":"\\nrightarrow","&#x21FA;":"\\nleftarrow","&#x21F9;":"\\nleftrightarrow","&#x21F8;":"\\nrightarrow","&#x21F7;":"\\nleftarrow","&#x21F6;":"\\Rrightarrow","&#x21F5;":"","&#x21F4;":"\\rightarrow","&#x21F3;":"\\Updownarrow","&#x21F2;":"\\searrow","&#x21F1;":"\\nwarrow","&#x21F0;":"\\Leftarrow","&#x21EF;":"\\Uparrow","&#x21EE;":"\\Uparrow","&#x21ED;":"\\Uparrow","&#x21EC;":"\\Uparrow","&#x21EB;":"\\Uparrow","&#x21EA;":"\\Uparrow","&#x21E9;":"\\Downarrow","&#x21E8;":"\\Rightarrow","&#x21E7;":"\\Uparrow","&#x21E6;":"\\Leftarrow","&#x21E5;":"\\rightarrow","&#x21E4;":"\\leftarrow","&#x21E3;":"\\downarrow","&#x21E2;":"\\rightarrow","&#x21E1;":"\\uparrow","&#x21E0;":"\\leftarrow","&#x21DF;":"\\downarrow","&#x21DE;":"\\uparrow","&#x21DD;":"\\rightsquigarrow","&#x21DC;":"\\leftarrow","&#x21DB;":"\\Rrightarrow","&#x21DA;":"\\Lleftarrow","&#x21D9;":"\\swarrow","&#x21D8;":"\\searrow","&#x21D7;":"\\nearrow","&#x21D6;":"\\nwarrow","&#x21D5;":"\\Updownarrow","&#x21D4;":"\\Leftrightarrow","&#x21D3;":"\\Downarrow","&#x21D2;":"\\Rightarrow","&#x21D1;":"\\Uparrow","&#x21D0;":"\\Leftarrow","&#x21CF;":"\\nRightarrow","&#x21CE;":"\\nLeftrightarrow","&#x21CD;":"\\nLeftarrow","&#x21CC;":"\\rightleftharpoons","&#x21CB;":"\\leftrightharpoons","&#x21CA;":"\\downdownarrows","&#x21C9;":"\\rightrightarrows","&#x21C8;":"\\upuparrows","&#x21C7;":"\\leftleftarrows","&#x21C6;":"\\leftrightarrows","&#x21C5;":"","&#x21C4;":"\\rightleftarrows","&#x21C3;":"\\downharpoonleft","&#x21C2;":"\\downharpoonright","&#x21C1;":"\\rightharpoondown","&#x21C0;":"\\rightharpoonup","&#x21BF;":"\\upharpoonleft","&#x21BE;":"\\upharpoonright","&#x21BD;":"\\leftharpoondown","&#x21BC;":"\\leftharpoonup","&#x21BB;":"\\circlearrowright","&#x21BA;":"\\circlearrowleft","&#x21B9;":"\\leftrightarrows","&#x21B8;":"\\overline{\\nwarrow}","&#x21B7;":"\\curvearrowright","&#x21B6;":"\\curvearrowleft","&#x21B5;":"\\swarrow","&#x21B4;":"\\searrow","&#x21B3;":"\\Rsh","&#x21B2;":"\\Lsh","&#x21B1;":"\\Rsh","&#x21B0;":"\\Lsh","&#x21AF;":"\\swarrow","&#x21AE;":"","&#x21AD;":"\\leftrightsquigarrow","&#x21AC;":"\\looparrowright","&#x21AB;":"\\looparrowleft","&#x21AA;":"\\hookrightarrow","&#x21A9;":"\\hookleftarrow","&#x21A8;":"\\underline{\\updownarrow}","&#x21A7;":"\\downarrow","&#x21A6;":"\\rightarrowtail","&#x21A5;":"\\uparrow","&#x21A4;":"\\leftarrowtail","&#x21A3;":"\\rightarrowtail","&#x21A2;":"\\leftarrowtail","&#x21A1;":"\\downarrow","&#x21A0;":"\\twoheadrightarrow","&#x219F;":"\\uparrow","&#x219E;":"\\twoheadleftarrow","&#x219D;":"\\nearrow","&#x219C;":"\\nwarrow","&#x219B;":"","&#x219A;":"","&#x2199;":"\\swarrow","&#x2198;":"\\searrow","&#x2197;":"\\nearrow","&#x2196;":"\\nwarrow","&#x2195;":"\\updownarrow","&#x2194;":"\\leftrightarrow","&#x2193;":"\\downarrow","&#x2192;":"\\rightarrow","&#x2191;":"\\uparrow","&#x2190;":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\left|\\right.","&#x2AFE;":"","&#x2AFD;":"//","&#x2AFB;":"///","&#x2AFA;":"","&#x2AF9;":"","&#x2AF8;":"","&#x2AF7;":"","&#x2AF6;":"\\vdots","&#x2AF5;":"","&#x2AF4;":"","&#x2AF3;":"","&#x2AF2;":"\\nparallel","&#x2AF1;":"","&#x2AF0;":"","&#x2AEF;":"","&#x2AEE;":"\\bcancel{\\mid}","&#x2AED;":"","&#x2AEC;":"","&#x2AEB;":"","&#x2AEA;":"","&#x2AE9;":"","&#x2AE8;":"\\underline{\\perp}","&#x2AE7;":"\\overline{\\top}","&#x2AE6;":"","&#x2AE5;":"","&#x2AE4;":"","&#x2AE3;":"","&#x2AE2;":"","&#x2AE1;":"","&#x2AE0;":"\\perp","&#x2ADF;":"\\top","&#x2ADE;":"\\dashv","&#x2ADD;&#x338;":"","&#x2ADD;":"","&#x2ADB;":"\\pitchfork","&#x2ADA;":"","&#x2AD9;":"","&#x2AD8;":"","&#x2AD7;":"","&#x2AD6;":"","&#x2AD5;":"","&#x2AD4;":"","&#x2AD3;":"","&#x2AD2;":"","&#x2AD1;":"","&#x2AD0;":"","&#x2ACF;":"","&#x2ACE;":"","&#x2ACD;":"","&#x2ACC;":"\\underset{\\neq}{\\supset}","&#x2ACB;":"\\underset{\\neq}{\\subset}","&#x2ACA;":"\\underset{\\approx}{\\supset}","&#x2AC9;":"\\underset{\\approx}{\\subset}","&#x2AC8;":"\\underset{\\sim}{\\supset}","&#x2AC7;":"\\underset{\\sim}{\\subset}","&#x2AC6;":"\\supseteqq","&#x2AC5;":"\\subseteqq","&#x2AC4;":"\\dot{\\supseteq}","&#x2AC3;":"\\dot{\\subseteq}","&#x2AC2;":"\\underset{\\times}{\\supset}","&#x2AC1;":"\\underset{\\times}{\\subset}","&#x2AC0;":"\\underset{+}{\\supset}","&#x2ABF;":"\\underset{+}{\\subset}","&#x2ABE;":"","&#x2ABD;":"","&#x2ABC;":"\\gg ","&#x2ABB;":"\\ll","&#x2ABA;":"\\underset{\\cancel{\\approx}}{\\succ}","&#x2AB9;":"\\underset{\\cancel{\\approx}}{\\prec}","&#x2AB8;":"\\underset{\\approx}{\\succ}","&#x2AB7;":"\\underset{\\approx}{\\prec}","&#x2AB6;":"\\underset{\\cancel{=}}{\\succ}","&#x2AB5;":"\\underset{\\cancel{=}}{\\prec}","&#x2AB4;":"\\underset{=}{\\succ}","&#x2AB3;":"\\underset{=}{\\prec}","&#x2AB2;":"","&#x2AB1;":"","&#x2AAE;":"","&#x2AAD;":"\\underline{\\hcancel{>}}","&#x2AAC;":"\\underline{\\hcancel{>}}","&#x2AAB;":"\\hcancel{>}","&#x2AAA;":"\\hcancel{<}","&#x2AA9;":"","&#x2AA8;":"","&#x2AA7;":"\\vartriangleright","&#x2AA6;":"\\vartriangleleft","&#x2AA5;":"><","&#x2AA4;":"><","&#x2AA3;":"\\underline{\\ll}","&#x2AA2;&#x338;":"\\cancel{\\gg}","&#x2AA2;":"\\gg","&#x2AA1;&#x338;":"\\cancel{\\ll}","&#x2AA1;":"\\ll","&#x2AA0;":"\\overset{\\sim}{\\geqq}","&#x2A9F;":"\\overset{\\sim}{\\leqq}","&#x2A9E;":"\\overset{\\sim}{>}","&#x2A9D;":"\\overset{\\sim}{<}","&#x2A9C;":"","&#x2A9B;":"","&#x2A9A;":"\\overset{=}{>}","&#x2A99;":"\\overset{=}{<}","&#x2A98;":"","&#x2A97;":"","&#x2A96;":"","&#x2A95;":"","&#x2A94;":"","&#x2A93;":"","&#x2A92;":"\\underset{=}{\\gtrless}","&#x2A91;":"\\underset{=}{\\lessgtr}","&#x2A90;":"\\underset{<}{\\gtrsim}","&#x2A8F;":"\\underset{>}{\\lesssim}","&#x2A8E;":"\\underset{\\simeq}{>}","&#x2A8D;":"\\underset{\\simeq}{<}","&#x2A8C;":"\\gtreqqless","&#x2A8B;":"\\lesseqqgtr","&#x2A8A;":"\\underset{\\cancel{\\approx}}{>}","&#x2A89;":"\\underset{\\approx}{<}","&#x2A86;":"\\underset{\\approx}{>}","&#x2A85;":"\\underset{\\approx}{<}","&#x2A84;":"","&#x2A83;":"","&#x2A82;":"","&#x2A81;":"","&#x2A80;":"","&#x2A7F;":"","&#x2A7E;&#x338;":"\\bcancel{\\geq}","&#x2A7E;":"\\geq","&#x2A7D;&#x338;":"\\bcancel{\\leq}","&#x2A7D;":"\\leq","&#x2A7C;":"","&#x2A7B;":"","&#x2A7A;":"","&#x2A79;":"","&#x2A78;":"\\overset{\\dots}{\\equiv}","&#x2A77;":"","&#x2A76;":"===","&#x2A75;":"==","&#x2A74;":"::=","&#x2A73;":"","&#x2A72;":"\\underset{=}{+}","&#x2A71;":"\\overset{=}{+}","&#x2A70;":"\\overset{\\approx}{=}","&#x2A6F;":"\\overset{\\wedge}{=}","&#x2A6E;":"\\overset{*}{=}","&#x2A6D;":"\\dot{\\approx}","&#x2A6C;":"","&#x2A6B;":"","&#x2A6A;":"\\dot{\\sim}","&#x2A69;":"","&#x2A68;":"","&#x2A67;":"\\dot{\\equiv}","&#x2A66;":"\\underset{\\cdot}{=}","&#x2A65;":"","&#x2A64;":"","&#x2A63;":"\\underset{=}{\\vee}","&#x2A62;":"\\overset{=}{\\vee}","&#x2A61;":"ul(vv)","&#x2A60;":"\\underset{=}{\\wedge}","&#x2A5F;":"\\underline{\\wedge}","&#x2A5E;":"\\overset{=}{\\wedge}","&#x2A5D;":"\\hcancel{\\vee}","&#x2A5C;":"\\hcancel{\\wedge}","&#x2A5B;":"","&#x2A5A;":"","&#x2A59;":"","&#x2A58;":"\\vee","&#x2A57;":"\\wedge","&#x2A56;":"","&#x2A55;":"","&#x2A54;":"","&#x2A53;":"","&#x2A52;":"\\dot{\\vee}","&#x2A51;":"\\dot{\\wedge}","&#x2A50;":"","&#x2A4F;":"","&#x2A4E;":"","&#x2A4D;":"\\overline{\\cap}","&#x2A4C;":"\\overline{\\cup}","&#x2A4B;":"","&#x2A4A;":"","&#x2A49;":"","&#x2A48;":"","&#x2A47;":"","&#x2A46;":"","&#x2A45;":"","&#x2A44;":"","&#x2A43;":"\\overline{\\cap}","&#x2A42;":"\\overline{\\cup}","&#x2A41;":"","&#x2A40;":"","&#x2A3E;":"","&#x2A3D;":"\\llcorner","&#x2A3C;":"\\lrcorner","&#x2A3B;":"","&#x2A3A;":"","&#x2A39;":"","&#x2A38;":"","&#x2A37;":"","&#x2A36;":"\\hat{\\otimes}","&#x2A35;":"","&#x2A34;":"","&#x2A33;":"","&#x2A32;":"\\underline{\\times}","&#x2A31;":"\\underline{\\times}","&#x2A30;":"\\dot{\\times}","&#x2A2E;":"","&#x2A2D;":"","&#x2A2C;":"","&#x2A2B;":"","&#x2A2A;":"","&#x2A29;":"","&#x2A28;":"","&#x2A27;":"","&#x2A26;":"\\underset{\\sim}{+}","&#x2A25;":"\\underset{\\circ}{+}","&#x2A24;":"\\overset{\\sim}{+}","&#x2A23;":"\\hat{+}","&#x2A22;":"\\dot{+}","&#x2A21;":"\\upharpoonright","&#x2A20;":">>","&#x2A1F;":"","&#x2A1E;":"\\triangleleft","&#x2A1D;":"\\bowtie","&#x29FF;":"","&#x29FE;":"+","&#x29FB;":"\\hcancel{|||}","&#x29FA;":"\\hcancel{||}","&#x29F9;":"\\backslash","&#x29F8;":"/","&#x29F7;":"hcancel{\backslash}","&#x29F6;":"","&#x29F5;":"\\backslash","&#x29F2;":"\\Phi","&#x29F1;":"","&#x29F0;":"","&#x29EE;":"","&#x29ED;":"","&#x29EC;":"","&#x29EB;":"\\lozenge","&#x29EA;":"","&#x29E9;":"","&#x29E8;":"","&#x29E7;":"\\ddagger","&#x29E2;":"\\sqcup\\sqcup","&#x29E1;":"","&#x29E0;":"\\square","&#x29DE;":"","&#x29DD;":"","&#x29DC;":"","&#x29DB;":"\\{\\{","&#x29D9;":"\\{","&#x29D8;":"\\}","&#x29D7;":"","&#x29D6;":"","&#x29D5;":"\\bowtie","&#x29D4;":"\\bowtie","&#x29D3;":"\\bowtie","&#x29D2;":"\\bowtie","&#x29D1;":"\\bowtie","&#x29D0;&#x338;":"| \\not\\triangleright","&#x29D0;":"| \\triangleright","&#x29CF;&#x338;":"\\not\\triangleleft |","&#x29CF;":"\\triangleleft |","&#x29CE;":"","&#x29CD;":"\\triangle","&#x29CC;":"","&#x29CB;":"\\underline{\\triangle}","&#x29CA;":"\\dot{\\triangle}","&#x29C9;":"","&#x29C8;":"\\boxed{\\circ}","&#x29C7;":"\\boxed{\\circ}","&#x29C6;":"\\boxed{\\rightarrow}","&#x29C5;":"\\bcancel{\\square}","&#x29C4;":"\\cancel{\\square}","&#x29C3;":"\\odot","&#x29C2;":"\\odot","&#x29BF;":"\\odot","&#x29BE;":"\\odot","&#x29BD;":"\\varnothing","&#x29BC;":"\\oplus","&#x29BB;":"\\otimes","&#x29BA;":"","&#x29B9;":"\\varnothing","&#x29B8;":"\\varnothing","&#x29B7;":"\\ominus","&#x29B6;":"\\ominus","&#x29B5;":"\\ominus","&#x29B4;":"\\vec{\\varnothing}","&#x29B3;":"\\vec{\\varnothing}","&#x29B2;":"\\dot{\\varnothing}","&#x29B1;":"\\overline{\\varnothing}","&#x29B0;":"\\varnothing","&#x29AF;":"","&#x29AE;":"","&#x29AD;":"","&#x29AC;":"","&#x29AB;":"","&#x29AA;":"","&#x29A9;":"","&#x29A8;":"","&#x29A7;":"","&#x29A6;":"","&#x29A5;":"","&#x29A4;":"","&#x29A3;":"","&#x29A2;":"","&#x29A1;":"\\not\\lor","&#x29A0;":"\\bcancel{>}","&#x2982;":":","&#x2981;":"\\circ","&#x2758;":"|","&#x25B2;":"\\bigtriangleup","&#x22FF;":"\\Epsilon","&#x22FE;":"\\overline{\\ni}","&#x22FD;":"\\overline{\\ni}","&#x22FC;":"\\in","&#x22FB;":"\\in","&#x22FA;":"\\in","&#x22F9;":"\\underline{\\in}","&#x22F8;":"\\underline{\\in}","&#x22F7;":"\\overline{\\in}","&#x22F6;":"\\overline{\\in}","&#x22F5;":"\\dot{\\in}","&#x22F4;":"\\in","&#x22F3;":"\\in","&#x22F2;":"\\in","&#x22F0;":"\\ddots","&#x22E9;":"\\underset{\\sim}{\\succ}","&#x22E8;":"\\underset{\\sim}{\\prec}","&#x22E7;":"\\underset{\\not\\sim}{>}","&#x22E6;":"\\underset{\\not\\sim}{<}","&#x22E5;":"\\not\\sqsupseteq","&#x22E4;":"\\not\\sqsubseteq","&#x22E3;":"\\not\\sqsupseteq","&#x22E2;":"\\not\\sqsubseteq","&#x22E1;":"\\nsucc","&#x22E0;":"\\nprec","&#x22DF;":"\\succ","&#x22DE;":"\\prec","&#x22DD;":"\\overline{>}","&#x22DC;":"\\overline{<}","&#x22DB;":"\\underset{>}{\\leq}","&#x22DA;":"\\underset{<}{\\geq}","&#x22D5;":"\\#","&#x22D3;":"\\cup","&#x22D2;":"\\cap","&#x22D1;":"\\supset","&#x22D0;":"\\subset","&#x22CF;":"\\wedge","&#x22CE;":"\\vee","&#x22CD;":"\\simeq","&#x22C8;":"\\bowtie","&#x22C7;":"\\ast","&#x22C6;":"\\star","&#x22C4;":"\\diamond","&#x22BF;":"\\triangle","&#x22BE;":"\\measuredangle","&#x22BD;":"\\overline{\\lor}","&#x22BC;":"\\overline{\\land}","&#x22BB;":"\\underline{\\lor}","&#x22BA;":"\\top","&#x22B9;":"","&#x22B7;":"\\circ\\multimap","&#x22B6;":"\\circ\\multimap","&#x22B3;":"\\triangleright","&#x22B2;":"\\triangleleft","&#x22B1;":"\\succ","&#x22B0;":"\\prec","&#x22AB;":"|\\models","&#x22AA;":"|\\models","&#x22A7;":"\\models","&#x22A6;":"\\vdash","&#x229D;":"\\ominus","&#x229C;":"\\ominus","&#x229B;":"\\odot","&#x229A;":"\\odot","&#x2294;":"\\sqcup","&#x2293;":"\\sqcap","&#x2292;":"\\sqsupseteq","&#x2291;":"\\sqsubseteq","&#x2290;&#x338;":"\\not\\sqsupset","&#x2290;":"\\sqsupset","&#x228F;&#x338;":"\\not\\sqsubset","&#x228F;":"\\sqsubset","&#x228E;":"\\cup","&#x228D;":"\\cup","&#x228C;":"\\cup","&#x227F;&#x338;":"\\not\\succsim","&#x227F;":"\\succsim","&#x227E;":"\\precsim","&#x2279;":"\\not\\overset{>}{<}","&#x2278;":"\\not\\overset{>}{<}","&#x2277;":"\\overset{>}{<}","&#x2276;":"\\overset{<}{>}","&#x2275;":"\\not\\geg","&#x2274;":"\\not\\leq","&#x2273;":"\\geg","&#x2272;":"\\leq","&#x226C;":"","&#x2267;":"\\geg","&#x2266;&#x338;":"\\not\\leq","&#x2266;":"\\leq","&#x2263;":"\\overset{=}{=} ","&#x225E;":"\\overset{m}{=} ","&#x225D;":"\\overset{def}{=}","&#x2258;":"=","&#x2256;":"=","&#x2255;":"=:","&#x2253;":"\\doteq","&#x2252;":"\\doteq","&#x2251;":"\\doteq","&#x2250;":"\\doteq","&#x224F;&#x338;":"","&#x224F;":"","&#x224E;&#x338;":"","&#x224E;":"","&#x224C;":"\\approx","&#x224B;":"\\approx","&#x224A;":"\\approx","&#x2242;&#x338;":"\\neq","&#x2242;":"=","&#x223F;":"\\sim","&#x223E;":"\\infty","&#x223D;&#x331;":"\\sim","&#x223D;":"\\sim","&#x223B;":"\\sim","&#x223A;":":-:","&#x2239;":"-:","&#x2238;":"\\bot","&#x2237;":"::","&#x2236;":":","&#x2223;":"|","&#x221F;":"\\llcorner","&#x2219;":"\\cdot","&#x2218;":"\\circ","&#x2217;":"*","&#x2215;":"/","&#x220E;":"\\square","&#x220D;":"\\ni","&#x220A;":"\\in","&#x2206;":"\\Delta","&#x2044;":"/","&#x2AB0;&#x338;":"\\nsucceq","&#x2AB0;":"\\succeq","&#x2AAF;&#x338;":"\\npreceq","&#x2AAF;":"\\preceq","&#x2A88;":"\\ngeqslant","&#x2A87;":"\\nleqslant","&#x29F3;":"\\Phi","&#x29E6;":"\\models","&#x29E5;":"\\not\\equiv","&#x29E4;":"\\approx\\neq","&#x29E3;":"\\neq","&#x29C1;":"\\circle","&#x29C0;":"\\circle","&#x25E6;":"\\circle","&#x25D7;":"\\circle","&#x25D6;":"\\circle","&#x25CF;":"\\circle","&#x25CE;":"\\circledcirc","&#x25CD;":"\\circledcirc","&#x25CC;":"\\circledcirc","&#x25C9;":"\\circledcirc","&#x25C8;":"\\diamond","&#x25C7;":"\\diamond","&#x25C6;":"\\diamond","&#x25C5;":"\\triangleleft","&#x25C4;":"\\triangleleft","&#x25C3;":"\\triangleleft","&#x25C2;":"\\triangleleft","&#x25C1;":"\\triangleleft","&#x25C0;":"\\triangleleft","&#x25BF;":"\\triangledown","&#x25BE;":"\\triangledown","&#x25BD;":"\\triangledown","&#x25BC;":"\\triangledown","&#x25B9;":"\\triangleright","&#x25B8;":"\\triangleright","&#x25B7;":"\\triangleright","&#x25B6;":"\\triangleright","&#x25B5;":"\\triangle","&#x25B4;":"\\triangle","&#x25B3;":"\\triangle","&#x25B1;":"\\square","&#x25B0;":"\\square","&#x25AF;":"\\square","&#x25AE;":"\\square","&#x25AD;":"\\square","&#x25AB;":"\\square","&#x25AA;":"\\square","&#x25A1;":"\\square","&#x25A0;":"\\square","&#x22ED;":"\\not\\triangleright","&#x22EC;":"\\not\\triangleleft","&#x22EB;":"\\not\\triangleright","&#x22EA;":"\\not\\triangleleft","&#x22D9;":"\\ggg","&#x22D8;":"\\lll","&#x22D7;":"*>","&#x22D6;":"<*","&#x22D4;":"\\pitchfork","&#x22CC;":"","&#x22CB;":"","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#x22B5;":"\\triangleright","&#x22B4;":"","&#x22A5;":"\\bot","&#x2281;":"\\nsucc","&#x2280;":"\\preceq","&#x227D;":"\\succeq","&#x227C;":"\\preceq","&#x227B;":"\\succ","&#x227A;":"\\prec","&#x2271;":"\\geq/","&#x2270;":"\\leq/","&#x226D;":"\\neq","&#x226B;&#x338;":"\\not\\gg","&#x226B;":"\\gg","&#x226A;&#x338;":"\\not\\ll","&#x226A;":"\\ll","&#x2269;":"\\ngeqslant","&#x2268;":"\\nleqslant","&#x2261;":"\\equiv","&#x225F;":"\\doteq","&#x225C;":"\\triangleq","&#x225B;":"\\doteq","&#x225A;":"\\triangleq","&#x2259;":"\\triangleq","&#x2257;":"\\doteq","&#x2254;":":=","&#x224D;":"\\asymp","&#x2247;":"\\ncong","&#x2246;":"\\ncong","&#x2245;":"\\cong","&#x2244;":"\\not\\simeq","&#x2243;":"\\simeq","&#x2241;":"\\not\\sim","&#x2226;":"\\not\\parallel","&#x2225;":"\\parallel","&#x2224;":"\\not|","&#x221D;":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","&#x2260;":"\\neq","&#x2262;":"\\equiv /","&#x2249;":"\\approx /","&#x223C;":"sim","&#x2248;":"\\approx","&#x226E;":"</","&lt;":"<","&#x226F;":">/",">=":">=",">":">","&#x2265;":"\\geq","&#x2264;":"\\leq","&lt;=":"<=","&#x228B;":"\\supsetneq","&#x228A;":"\\subsetneq","&#x2289;":"\\nsupseteq","&#x2288;":"\\nsubseteq","&#x2287;":"\\supseteq","&#x2286;":"\\subseteq","&#x2285;":"\\not\\supset","&#x2284;":"\\not\\subset","&#x2283;&#x20D2;":"\\supset |","&#x2283;":"\\supset","&#x2282;&#x20D2;":"\\subset |","&#x2282;":"\\subset","&#x220C;":"\\not\\in","&#x2209;":"\\notin","&#x2208;":"\\in","&#x2201;":"C","&#x2204;":"\\nexists","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x2227;":"\\land","&amp;&amp;":"\\&\\&","&#x2228;":"\\lor","&#x22AF;":"\\cancel{\\vDash}","&#x22AE;":"\\cancel{\\Vdash}","&#x22AD;":"\\nvDash","&#x22AC;":"\\nvDash","&#x22A9;":"\\Vdash","&#x22A8;":"\\vDash","&#x22A4;":"\\top","&#x22A3;":"\\dashv","&#x22A2;":"\\vdash","&#x220B;":"\\ni","&#x22F1;":"\\ddots","&#x22EF;":"\\hdots","&#x22EE;":"\\vdots","&#x2026;":"\\hdots","&#x3F6;":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","&#x2235;":"\\because","&#x2234;":"\\therefore ","&#x2063;":"",",":",",";":";","&#x29FD;":"\\}","&#x29FC;":"\\{","&#x2998;":"\\]","&#x2997;":"\\[","&#x2996;":"\\ll","&#x2995;":"\\gg","&#x2994;":"\\gg","&#x2993;":"\\ll","&#x2992;":"\\gg","&#x2991;":"\\ll","&#x2990;":"\\]","&#x298F;":"\\]","&#x298E;":"\\]","&#x298D;":"\\[","&#x298C;":"\\[","&#x298B;":"\\]","&#x298A;":"\\triangleright","&#x2989;":"\\triangleleft","&#x2988;":"|\\)","&#x2987;":"\\(|","&#x2986;":"|\\)","&#x2985;":"\\(\\(","&#x2984;":"|\\}","&#x2983;":"\\{|","&#x2980;":"\\||","&#x27EF;":"\\left. \\right]","&#x27EE;":"\\left[ \\right.","&#x27ED;":"\\left. \\right]]","&#x27EC;":"\\left[[ \\right.","&#x27EB;":"\\gg","&#x27EA;":"\\ll","&#x27E9;":"\\rangle","&#x27E8;":"\\langle","&#x27E7;":"\\left. \\right]]","&#x27E6;":"\\left[[ \\right.","&#x2773;":"\\left.\\right)","&#x2772;":"\\left(\\right.","&#x232A;":"\\rangle","&#x2329;":"\\langle","&#x230B;":"\\rfloor","&#x230A;":"\\lfloor","&#x2309;":"\\rceil","&#x2308;":"\\lceil","&#x2016;":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","&#x201D;":'"',"&#x201C;":"``","&#x2019;":"'","&#x2018;":"`","%CE%B1":"\\alpha","%CE%B2":"\\beta","%CE%B3":"\\gamma","%CE%93":"\\Gamma","%CE%B4":"\\delta","%CE%94":"\\Delta","%CF%B5":"\\epsilon","%CE%B6":"\\zeta","%CE%B7":"\\eta","%CE%B8":"\\theta","%CE%98":"\\Theta","%CE%B9":"\\iota","%CE%BA":"\\kappa","%CE%BB":"\\lambda","%CE%BC":"\\mu","%CE%BD":"\\nu","%CE%BF":"\\omicron","%CF%80":"\\pi","%CE%A0":"\\Pi","%CF%81":"\\pho","%CF%83":"\\sigma","%CE%A3":"\\Sigma","%CF%84":"\\tau","%CF%85":"\\upsilon","%CE%A5":"\\Upsilon","%CF%95":"\\phi","%CE%A6":"\\Phi","%CF%87":"\\chi","%CF%88":"\\psi","%CE%A8":"\\Psi","%CF%89":"\\omega","%CE%A9":"\\Omega"}},9039:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByGlyph=void 0,t.allMathOperatorsByGlyph={_:"\\underline","⏡":"\\underbrace","⏠":"\\overbrace","⏟":"\\underbrace","⏞":"\\overbrace","⏝":"\\underbrace","⏜":"\\overbrace","⎵":"\\underbrace","⎴":"\\overbrace","⃜":"\\square","⃛":"\\square","⁤":"","⁗":"''''","‾":"\\overline","‷":"```","‶":"``","‵":"`","‴":"'''","″":"''","‟":"``","„":",,","‛":"`","‚":",","^":"\\hat","˷":"\\sim","˝":"\\sim","˜":"\\sim","˚":"\\circ","˙":"\\cdot","˘":" ",ˍ:"\\_",ˋ:"ˋ",ˊ:"ˊ",ˉ:"ˉ",ˇ:"",ˆ:"\\hat",º:"o","¹":"1","¸":",","´":"´","³":"3","²":"2","°":"\\circ","¯":"\\bar",ª:"a","↛":"\\nrightarrow","¨":"\\cdot\\cdot","~":"\\sim","`":"`","--":"--","++":"++","&":"\\&","∜":"\\sqrt[4]{}","∛":"\\sqrt[3]{}","√":"\\sqrt{}",ⅆ:"d",ⅅ:"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","♯":"\\#","♮":"","♭":"","′":"'","<>":"<>","**":"\\star\\star","∇":"\\nabla","∂":"\\partial","⊙":"\\bigodot","¬":"\\neg","∢":"\\measuredangle","∡":"\\measuredangle","∠":"\\angle","÷":"\\div","/":"/","∖":"\\backslash","\\":"\\backslash","%":"\\%","⊗":"\\bigotimes","·":"\\cdot","⨿":"\\coprod","⨯":"\\times","⋅":"\\cdot","⊡":"\\boxdot","⊠":"\\boxtimes","⁢":"","⁃":"-","•":"\\cdot",".":".","*":"\\star","∪":"\\cup","∩":"\\cap","∐":"\\coprod","∏":"\\prod","≀":"","⫿":"","⫼":"\\mid\\mid\\mid","⨉":"\\times","⨈":"","⨇":"","⨆":"\\sqcup","⨅":"\\sqcap","⨂":"\\otimes","⨀":"\\odot","⋂":"\\cap","⋁":"\\vee","⋀":"\\wedge","⨄":"\\uplus","⨃":"\\cup","⋃":"\\cup","⨜":"\\underline{\\int}","⨛":"\\overline{\\int}","⨚":"\\int","⨙":"\\int","⨘":"\\int","⨗":"\\int","⨖":"\\oint","⨕":"\\oint","⨔":"\\int","⨓":"\\int","⨒":"\\int","⨑":"\\int","⨐":"\\int","⨏":"\\bcancel{\\int}","⨎":"","⨍":"\\hcancel{\\int}","⨌":"\\iiiint","∳":"\\oint","∲":"\\oint","∱":"\\int","∰":"\\oiint","∯":"\\oiint","∮":"\\oint","∫":"\\int","⨁":"\\oplus","⊘":"\\oslash","⊖":"\\ominus","⊕":"\\oplus","∭":"\\iiint","∬":"\\iint","⨋":"","⨊":"","∑":"\\sum","⊟":"\\boxminus","⊞":"\\boxplus","∔":"\\dot{+}","∓":"+-","−":"-","±":"\\pm","-":"-","+":"+","⭆":"\\Rrightarrow","⭅":"\\Lleftarrow","⧴":":\\rightarrow","⧯":"","⧟":"\\bullet-\\bullet","⦟":"\\angle","⦞":"\\measuredangle","⦝":"\\measuredangle","⦜":"\\perp","⦛":"\\measuredangle","⦚":"","⦙":"\\vdots","⥿":"","⥾":"","⥽":"\\prec","⥼":"\\succ","⥻":"\\underset{\\rightarrow}{\\supset}","⥺":"","⥹":"\\underset{\\rightarrow}{\\subset}","⥸":"\\underset{\\rightarrow}{>}","⥷":"","⥶":"\\underset{\\leftarrow}{<}","⥵":"\\underset{\\approx}{\\rightarrow}","⥴":"\\underset{\\sim}{\\rightarrow}","⥳":"\\underset{\\sim}{\\leftarrow}","⥲":"\\overset{\\sim}{\\rightarrow}","⥱":"\\overset{=}{\\rightarrow}","⥰":"","⥯":"","⥮":"","⥭":"\\overline{\\rightharpoondown}","⥬":"\\underline{\\rightharpoonup}","⥫":"\\overline{\\leftharpoondown}","⥪":"\\underline{\\leftharpoonup}","⥩":"\\rightleftharpoons","⥨":"\\rightleftharpoons","⥧":"\\rightleftharpoons","⥦":"\\rightleftharpoons","⥥":"\\Downarrow","⥤":"\\Rightarrow","⥣":"\\Uparrow","⥢":"\\Leftarrow","⥡":"\\downarrow","⥠":"\\uparrow","⥟":"\\rightarrow","⥞":"\\leftarrow","⥝":"\\downarrow","⥜":"\\uparrow","⥛":"\\rightarrow","⥚":"\\leftarrow","⥙":"\\downarrow","⥘":"\\uparrow","⥗":"\\rightarrow","⥖":"\\leftarrow","⥕":"\\downarrow","⥔":"\\uparrow","⥓":"\\rightarrow","⥒":"\\leftarrow","⥑":"\\updownarrow","⥐":"\\leftrightarrow","⥏":"\\updownarrow","⥎":"\\leftrightarrow","⥍":"\\updownarrow","⥌":"\\updownarrow","⥋":"\\leftrightarrow","⥊":"\\leftrightarrow","⥉":"","⥈":"\\leftrightarrow","⥇":"\\nrightarrow","⥆":"","⥅":"","⥄":"\\rightleftarrows","⥃":"\\leftrightarrows","⥂":"\\rightleftarrows","⥁":"\\circlearrowright","⥀":"\\circlearrowleft","⤿":"\\rightarrow","⤾":"\\leftarrow","⤽":"\\leftarrow","⤼":"\\rightarrow","⤻":"\\rightarrow","⤺":"\\leftarrow","⤹":"\\downarrow","⤸":"\\downarrow","⤷":"\\Rsh","⤶":"\\Lsh","⤵":"\\downarrow","⤴":"\\uparrow","⤳":"\\rightarrow","⤲":"\\leftarrow","⤱":" ","⤰":" ","⤯":" ","⤮":" ","⤭":" ","⤬":"\\times","⤫":"\\times","⤪":" ","⤩":" ","⤨":" ","⤧":" ","⤦":" ","⤥":" ","⤤":" ","⤣":" ","⤢":" ","⤡":" ","⤠":"\\mapsto\\cdot","⤟":"\\cdot\\leftarrow","⤞":"\\rightarrow\\cdot","⤝":"\\leftarrow","⤜":"\\rightarrow","⤛":"\\leftarrow","⤚":"\\rightarrow","⤙":"\\leftarrow","⤘":"\\rightarrow","⤗":"\\rightarrow","⤖":"\\rightarrow","⤕":"\\rightarrow","⤔":"\\rightarrow","⤓":"\\downarrow","⤒":"\\uparrow","⤑":"\\rightarrow","⤐":"\\rightarrow","⤏":"\\rightarrow","⤎":"\\leftarrow","⤍":"\\rightarrow","⤌":"\\leftarrow","⤋":"\\Downarrow","⤊":"\\Uparrow","⤉":"\\uparrow","⤈":"\\downarrow","⤇":"\\Rightarrow","⤆":"\\Leftarrow","⤅":"\\mapsto","⤄":"\\nLeftrightarrow","⤃":"\\nRightarrow","⤂":"\\nLeftarrow","⤁":"\\rightsquigarrow","⤀":"\\rightsquigarrow","⟿":"\\rightsquigarrow","⟾":"\\Rightarrow","⟽":"\\Leftarrow","⟼":"\\mapsto","⟻":"\\leftarrow","⟺":"\\Longleftrightarrow","⟹":"\\Longrightarrow","⟸":"\\Longleftarrow","⟷":"\\leftrightarrow","⟶":"\\rightarrow","⟵":"\\leftarrow","⟱":"\\Downarrow","⟰":"\\Uparrow","⊸":"\\rightarrow","⇿":"\\leftrightarrow","⇾":"\\rightarrow","⇽":"\\leftarrow","⇼":"\\nleftrightarrow","⇻":"\\nrightarrow","⇺":"\\nleftarrow","⇹":"\\nleftrightarrow","⇸":"\\nrightarrow","⇷":"\\nleftarrow","⇶":"\\Rrightarrow","⇵":"","⇴":"\\rightarrow","⇳":"\\Updownarrow","⇲":"\\searrow","⇱":"\\nwarrow","⇰":"\\Leftarrow","⇯":"\\Uparrow","⇮":"\\Uparrow","⇭":"\\Uparrow","⇬":"\\Uparrow","⇫":"\\Uparrow","⇪":"\\Uparrow","⇩":"\\Downarrow","⇨":"\\Rightarrow","⇧":"\\Uparrow","⇦":"\\Leftarrow","⇥":"\\rightarrow","⇤":"\\leftarrow","⇣":"\\downarrow","⇢":"\\rightarrow","⇡":"\\uparrow","⇠":"\\leftarrow","⇟":"\\downarrow","⇞":"\\uparrow","⇝":"\\rightsquigarrow","⇜":"\\leftarrow","⇛":"\\Rrightarrow","⇚":"\\Lleftarrow","⇙":"\\swarrow","⇘":"\\searrow","⇗":"\\nearrow","⇖":"\\nwarrow","⇕":"\\Updownarrow","⇔":"\\Leftrightarrow","⇓":"\\Downarrow","⇒":"\\Rightarrow","⇑":"\\Uparrow","⇐":"\\Leftarrow","⇏":"\\nRightarrow","⇎":"\\nLeftrightarrow","⇍":"\\nLeftarrow","⇌":"\\rightleftharpoons","⇋":"\\leftrightharpoons","⇊":"\\downdownarrows","⇉":"\\rightrightarrows","⇈":"\\upuparrows","⇇":"\\leftleftarrows","⇆":"\\leftrightarrows","⇅":"","⇄":"\\rightleftarrows","⇃":"\\downharpoonleft","⇂":"\\downharpoonright","⇁":"\\rightharpoondown","⇀":"\\rightharpoonup","↿":"\\upharpoonleft","↾":"\\upharpoonright","↽":"\\leftharpoondown","↼":"\\leftharpoonup","↻":"\\circlearrowright","↺":"\\circlearrowleft","↹":"\\leftrightarrows","↸":"\\overline{\\nwarrow}","↷":"\\curvearrowright","↶":"\\curvearrowleft","↵":"\\swarrow","↴":"\\searrow","↳":"\\Rsh","↲":"\\Lsh","↱":"\\Rsh","↰":"\\Lsh","↯":"\\swarrow","↮":"","↭":"\\leftrightsquigarrow","↬":"\\looparrowright","↫":"\\looparrowleft","↪":"\\hookrightarrow","↩":"\\hookleftarrow","↨":"\\underline{\\updownarrow}","↧":"\\downarrow","↦":"\\rightarrowtail","↥":"\\uparrow","↤":"\\leftarrowtail","↣":"\\rightarrowtail","↢":"\\leftarrowtail","↡":"\\downarrow","↠":"\\twoheadrightarrow","↟":"\\uparrow","↞":"\\twoheadleftarrow","↝":"\\nearrow","↜":"\\nwarrow","↚":"","↙":"\\swarrow","↘":"\\searrow","↗":"\\nearrow","↖":"\\nwarrow","↕":"\\updownarrow","↔":"\\leftrightarrow","↓":"\\downarrow","→":"\\rightarrow","↑":"\\uparrow","←":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\mid","⫾":"","⫽":"//","⫻":"///","⫺":"","⫹":"","⫸":"","⫷":"","⫶":"\\vdots","⫵":"","⫴":"","⫳":"","⫲":"\\nparallel","⫱":"","⫰":"","⫯":"","⫮":"\\bcancel{\\mid}","⫭":"","⫬":"","⫫":"","⫪":"","⫩":"","⫨":"\\underline{\\perp}","⫧":"\\overline{\\top}","⫦":"","⫥":"","⫤":"","⫣":"","⫢":"","⫡":"","⫠":"\\perp","⫟":"\\top","⫞":"\\dashv","⫝̸":"","⫝":"","⫛":"\\pitchfork","⫚":"","⫙":"","⫘":"","⫗":"","⫖":"","⫕":"","⫔":"","⫓":"","⫒":"","⫑":"","⫐":"","⫏":"","⫎":"","⫍":"","⫌":"\\underset{\\neq}{\\supset}","⫋":"\\underset{\\neq}{\\subset}","⫊":"\\underset{\\approx}{\\supset}","⫉":"\\underset{\\approx}{\\subset}","⫈":"\\underset{\\sim}{\\supset}","⫇":"\\underset{\\sim}{\\subset}","⫆":"\\supseteqq","⫅":"\\subseteqq","⫄":"\\dot{\\supseteq}","⫃":"\\dot{\\subseteq}","⫂":"\\underset{\\times}{\\supset}","⫁":"\\underset{\\times}{\\subset}","⫀":"\\underset{+}{\\supset}","⪿":"\\underset{+}{\\subset}","⪾":"","⪽":"","⪼":"\\gg ","⪻":"\\ll","⪺":"\\underset{\\cancel{\\approx}}{\\succ}","⪹":"\\underset{\\cancel{\\approx}}{\\prec}","⪸":"\\underset{\\approx}{\\succ}","⪷":"\\underset{\\approx}{\\prec}","⪶":"\\underset{\\cancel{=}}{\\succ}","⪵":"\\underset{\\cancel{=}}{\\prec}","⪴":"\\underset{=}{\\succ}","⪳":"\\underset{=}{\\prec}","⪲":"","⪱":"","⪮":"","⪭":"\\underline{\\hcancel{>}}","⪬":"\\underline{\\hcancel{>}}","⪫":"\\hcancel{>}","⪪":"\\hcancel{<}","⪩":"","⪨":"","⪧":"\\vartriangleright","⪦":"\\vartriangleleft","⪥":"><","⪤":"><","⪣":"\\underline{\\ll}","⪢̸":"\\cancel{\\gg}","⪢":"\\gg","⪡̸":"\\cancel{\\ll}","⪡":"\\ll","⪠":"\\overset{\\sim}{\\geqq}","⪟":"\\overset{\\sim}{\\leqq}","⪞":"\\overset{\\sim}{>}","⪝":"\\overset{\\sim}{<}","⪜":"","⪛":"","⪚":"\\overset{=}{>}","⪙":"\\overset{=}{<}","⪘":"","⪗":"","⪖":"","⪕":"","⪔":"","⪓":"","⪒":"\\underset{=}{\\gtrless}","⪑":"\\underset{=}{\\lessgtr}","⪐":"\\underset{<}{\\gtrsim}","⪏":"\\underset{>}{\\lesssim}","⪎":"\\underset{\\simeq}{>}","⪍":"\\underset{\\simeq}{<}","⪌":"\\gtreqqless","⪋":"\\lesseqqgtr","⪊":"\\underset{\\cancel{\\approx}}{>}","⪉":"\\underset{\\approx}{<}","⪆":"\\underset{\\approx}{>}","⪅":"\\underset{\\approx}{<}","⪄":"","⪃":"","⪂":"","⪁":"","⪀":"","⩿":"","⩾̸":"\\bcancel{\\geq}","⩾":"\\geq","⩽̸":"\\bcancel{\\leq}","⩽":"\\leq","⩼":"","⩻":"","⩺":"","⩹":"","⩸":"\\overset{\\dots}{\\equiv}","⩷":"","⩶":"===","⩵":"==","⩴":"::=","⩳":"","⩲":"\\underset{=}{+}","⩱":"\\overset{=}{+}","⩰":"\\overset{\\approx}{=}","⩯":"\\overset{\\wedge}{=}","⩮":"\\overset{*}{=}","⩭":"\\dot{\\approx}","⩬":"","⩫":"","⩪":"\\dot{\\sim}","⩩":"","⩨":"","⩧":"\\dot{\\equiv}","⩦":"\\underset{\\cdot}{=}","⩥":"","⩤":"","⩣":"\\underset{=}{\\vee}","⩢":"\\overset{=}{\\vee}","⩡":"ul(vv)","⩠":"\\underset{=}{\\wedge}","⩟":"\\underline{\\wedge}","⩞":"\\overset{=}{\\wedge}","⩝":"\\hcancel{\\vee}","⩜":"\\hcancel{\\wedge}","⩛":"","⩚":"","⩙":"","⩘":"\\vee","⩗":"\\wedge","⩖":"","⩕":"","⩔":"","⩓":"","⩒":"\\dot{\\vee}","⩑":"\\dot{\\wedge}","⩐":"","⩏":"","⩎":"","⩍":"\\overline{\\cap}","⩌":"\\overline{\\cup}","⩋":"","⩊":"","⩉":"","⩈":"","⩇":"","⩆":"","⩅":"","⩄":"","⩃":"\\overline{\\cap}","⩂":"\\overline{\\cup}","⩁":"","⩀":"","⨾":"","⨽":"\\llcorner","⨼":"\\lrcorner","⨻":"","⨺":"","⨹":"","⨸":"","⨷":"","⨶":"\\hat{\\otimes}","⨵":"","⨴":"","⨳":"","⨲":"\\underline{\\times}","⨱":"\\underline{\\times}","⨰":"\\dot{\\times}","⨮":"\\bigodot","⨭":"\\bigodot","⨬":"","⨫":"","⨪":"","⨩":"","⨨":"","⨧":"","◻":"\\Box","⨦":"\\underset{\\sim}{+}","⨥":"\\underset{\\circ}{+}","⨤":"\\overset{\\sim}{+}","⨣":"\\hat{+}","⨢":"\\dot{+}","⨡":"\\upharpoonright","⨠":">>","⨟":"","⨞":"\\triangleleft","⨝":"\\bowtie","⧿":"","⧾":"+","⧻":"\\hcancel{|||}","⧺":"\\hcancel{||}","⧹":"\\backslash","⧸":"/","⧷":"hcancel{\backslash}","⧶":"","⧵":"\\backslash","⧲":"\\Phi","⧱":"","⧰":"","⧮":"","⧭":"","⧬":"","⧫":"\\lozenge","⧪":"","⧩":"","⧨":"","⧧":"\\ddagger","⧢":"\\sqcup\\sqcup","⧡":"","⧠":"\\square","⧞":"","⧝":"","⧜":"","⧛":"\\{\\{","⧙":"\\{","⧘":"\\}","⧗":"","⧖":"","⧕":"\\bowtie","⧔":"\\bowtie","⧓":"\\bowtie","⧒":"\\bowtie","⧑":"\\bowtie","⧐̸":"| \\not\\triangleright","⧐":"| \\triangleright","⧏̸":"\\not\\triangleleft |","⧏":"\\triangleleft |","⧎":"","⧍":"\\triangle","⧌":"","⧋":"\\underline{\\triangle}","⧊":"\\dot{\\triangle}","⧉":"","⧈":"\\boxed{\\circ}","⧇":"\\boxed{\\circ}","⧆":"\\boxed{\\rightarrow}","⧅":"\\bcancel{\\square}","⧄":"\\cancel{\\square}","⧃":"\\odot","⧂":"\\odot","⦿":"\\odot","⦾":"\\odot","⦽":"\\varnothing","⦼":"\\oplus","⦻":"\\otimes","⦺":"","⦹":"\\varnothing","⦸":"\\varnothing","⦷":"\\ominus","⦶":"\\ominus","⦵":"\\ominus","⦴":"\\vec{\\varnothing}","⦳":"\\vec{\\varnothing}","⦲":"\\dot{\\varnothing}","⦱":"\\overline{\\varnothing}","⦰":"\\varnothing","⦯":"\\measuredangle","⦮":"\\measuredangle","⦭":"\\measuredangle","⦬":"\\measuredangle","⦫":"\\measuredangle","⦪":"\\measuredangle","⦩":"\\measuredangle","⦨":"\\measuredangle","⦧":"","⦦":"","⦥":"","⦤":"","⦣":"\\ulcorner","⦢":"\\measuredangle","⦡":"\\not\\lor","⦠":"\\bcancel{>}","⦂":":","⦁":"\\cdot","❘":"\\mid","▲":"\\bigtriangleup","⋿":"\\Epsilon","⋾":"\\overline{\\ni}","⋽":"\\overline{\\ni}","⋼":"\\in","⋻":"\\in","⋺":"\\in","⋹":"\\underline{\\in}","⋸":"\\underline{\\in}","⋷":"\\overline{\\in}","⋶":"\\overline{\\in}","⋵":"\\dot{\\in}","⋴":"\\in","⋳":"\\in","⋲":"\\in","⋰":"\\ddots","։":":","⋩":"\\underset{\\sim}{\\succ}","⋨":"\\underset{\\sim}{\\prec}","⋧":"\\underset{\\not\\sim}{>}","⋦":"\\underset{\\not\\sim}{<}","⋥":"\\not\\sqsupseteq","⋤":"\\not\\sqsubseteq","⋣":"\\not\\sqsupseteq","⋢":"\\not\\sqsubseteq","⋡":"\\nsucc","⋠":"\\nprec","⋟":"\\succ","⋞":"\\prec","⋝":"\\overline{>}","⋜":"\\overline{<}","⋛":"\\underset{>}{\\leq}","⋚":"\\underset{<}{\\geq}","⋕":"\\#","⋓":"\\cup","⋒":"\\cap","⋑":"\\supset","⋐":"\\subset","⋏":"\\wedge","⋎":"\\vee","⋍":"\\simeq","⋈":"\\Join","⋇":"\\ast","⋆":"\\star","⋄":"\\diamond","⊿":"\\triangle","⊾":"\\measuredangle","⊽":"\\overline{\\lor}","⊼":"\\overline{\\land}","⊻":"\\underline{\\lor}","⊺":"\\top",土:"\\pm",十:"+","⊹":"","⊷":"\\circ\\multimap","⊶":"\\circ\\multimap","⊳":"\\triangleright","⊲":"\\triangleleft","⊱":"\\succ","⊰":"\\prec","⊫":"|\\models","⊪":"|\\models","⊧":"\\models","⊦":"\\vdash","⊝":"\\ominus","⊜":"\\ominus","⊛":"\\odot","⊚":"\\odot","⊔":"\\sqcup","⊓":"\\sqcap","⊒":"\\sqsupseteq","⊑":"\\sqsubseteq","⊐̸":"\\not\\sqsupset","⊐":"\\sqsupset","⊏̸":"\\not\\sqsubset","⊏":"\\sqsubset","⊎":"\\cup","⊍":"\\cup","⊌":"\\cup","≿̸":"\\not\\succsim","≿":"\\succsim","≾":"\\precsim","≹":"\\not\\overset{>}{<}","≸":"\\not\\overset{>}{<}","≷":"\\overset{>}{<}","≶":"\\overset{<}{>}","≵":"\\not\\geg","≴":"\\not\\leq","≳":"\\geg","≲":"\\leq","≬":"","≧":"\\geg","≦̸":"\\not\\leq","≦":"\\leq","≣":"\\overset{=}{=} ","≞":"\\overset{m}{=} ","≝":"\\overset{def}{=}","≘":"=","≖":"=","≕":"=:","≓":"\\doteq","≒":"\\doteq","≑":"\\doteq","≐":"\\doteq","≏̸":"","≏":"","≎̸":"","≎":"","≌":"\\approx","≋":"\\approx","≊":"\\approx","≂̸":"\\neq","≂":"=","∿":"\\sim","∾":"\\infty","∽̱":"\\sim","∽":"\\sim","∻":"\\sim","∺":":-:","∹":"-:","∸":"\\bot","∷":"::","∶":":","∣":"\\mid","∟":"\\llcorner","∘":"\\circ","∗":"*","∕":"/","∎":"\\square","∍":"\\ni","∊":"\\in","∆":"\\Delta","⁄":"/","⪰̸":"\\nsucceq","⪰":"\\succeq","⪯̸":"\\npreceq","⪯":"\\preceq","⪈":"\\ngeqslant","⪇":"\\nleqslant","⧳":"\\Phi","⧦":"\\models","⧥":"\\not\\equiv","⧤":"\\approx\\neq","⧣":"\\neq","⧁":"\\circle","⧀":"\\circle","◦":"\\circle","◗":"\\circle","◖":"\\circle","●":"\\circle","◎":"\\circledcirc","◍":"\\circledcirc","◌":"\\circledcirc","◉":"\\circledcirc","◈":"\\diamond","◇":"\\diamond","◆":"\\diamond","◅":"\\triangleleft","◄":"\\triangleleft","◃":"\\triangleleft","◂":"\\triangleleft","◁":"\\triangleleft","◀":"\\triangleleft","▿":"\\triangledown","▾":"\\triangledown","▽":"\\triangledown","▼":"\\triangledown","▹":"\\triangleright","▸":"\\triangleright","▷":"\\triangleright","▶":"\\triangleright","▵":"\\triangle","▴":"\\triangle","△":"\\triangle","▱":"\\square","▰":"\\blacksquare","▯":"\\square","▮":"\\blacksquare","▭":"\\square","▫":"\\square","▪":"\\square","□":"\\square","■":"\\blacksquare","⋭":"\\not\\triangleright","⋬":"\\not\\triangleleft","⋫":"\\not\\triangleright","⋪":"\\not\\triangleleft","⋙":"\\ggg","⋘":"\\lll","⋗":"*>","⋖":"<*","⋔":"\\pitchfork","⋌":"","⋋":"\\bowtie","⋊":"\\ltimes","⋉":"\\rtimes","⊵":"\\triangleright","\\triangleleft":"","⊥":"\\bot","⊁":"\\nsucc","⊀":"\\preceq","≽":"\\succeq","≼":"\\preceq","≻":"\\succ","≺":"\\prec","≱":"\\geq/","≰":"\\leq/","≭":"\\neq","≫̸":"\\not\\gg","≫":"\\gg","≪̸":"\\not\\ll","≪":"\\ll","≩":"\\ngeqslant","≨":"\\nleqslant","≡":"\\equiv","≟":"\\doteq","≜":"\\triangleq","≛":"\\doteq","≚":"\\triangleq","≙":"\\triangleq","≗":"\\doteq","≔":":=","≍":"\\asymp","≇":"\\ncong","≆":"\\ncong","≅":"\\cong","≄":"\\not\\simeq","≃":"\\simeq","≁":"\\not\\sim","∦":"\\not\\parallel","∥":"\\parallel","∤":"\\not|","∝":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","≠":"\\neq","≢":"\\equiv /","≉":"\\approx /","∼":"sim","≈":"\\approx","≮":"</","<":"<","≯":">/",">=":">=",">":">","≥":"\\geq","≤":"\\leq","<=":"<=","⊋":"\\supsetneq","⊊":"\\subsetneq","⊉":"\\nsupseteq","⊈":"\\nsubseteq","⊇":"\\supseteq","⊆":"\\subseteq","⊅":"\\not\\supset","⊄":"\\not\\subset","⊃⃒":"\\supset |","⊃":"\\supset","⊂⃒":"\\subset |","⊂":"\\subset","∌":"\\not\\in","∉":"\\notin","∈":"\\in","∁":"C","∄":"\\nexists","∃":"\\exists","∀":"\\forall","∧":"\\land","&&":"\\&\\&","∨":"\\lor","⊯":"\\cancel{\\vDash}","⊮":"\\cancel{\\Vdash}","⊭":"\\nvDash","⊬":"\\nvDash","⊩":"\\Vdash","⊨":"\\vDash","⊤":"\\top","⊣":"\\dashv","⊢":"\\vdash","∋":"\\ni","⋱":"\\ddots","⋯":"\\hdots","⋮":"\\vdots","϶":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","∵":"\\because","∴":"\\therefore ","⁣":"\\llbracket",",":",",";":";","⧽":"\\}","⧼":"\\{","⦘":"\\]","⦗":"\\[","⦖":"\\ll","⦕":"\\gg","⦔":"\\gg","⦓":"\\ll","⦒":"\\gg","⦑":"\\ll","⦐":"\\]","⦏":"\\]","⦎":"\\]","⦍":"\\[","⦌":"\\[","⦋":"\\]","⦊":"\\triangleright","⦉":"\\triangleleft","⦈":"|\\)","⦇":"\\(|","⦆":"|\\)","⦅":"\\(\\(","⦄":"|\\}","⦃":"\\{|","⦀":"\\||","⟯":"\\left. \\right]","⟮":"\\left[ \\right.","⟭":"\\left. \\right]]","⟬":"\\left[[ \\right.","⟫":"\\gg","⟪":"\\ll","⟧":"\\)|","⟦":"\\(|","❳":"\\left.\\right)","❲":"\\left(\\right.","〉":"\\rangle","〈":"\\langle","⌋":"\\rfloor","⌊":"\\lfloor","⌉":"\\rceil","⌈":"\\lceil","‖":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","”":'\\"',"“":"\\text{``}","’":"'","‘":"`",α:"\\alpha",β:"\\beta",γ:"\\gamma",Γ:"\\Gamma",δ:"\\delta",Δ:"\\Delta",ϵ:"\\epsilon",ζ:"\\zeta",η:"\\eta",θ:"\\theta",Θ:"\\Theta",ι:"\\iota",κ:"\\kappa",λ:"\\lambda",ν:"\\nu",ο:"\\omicron",π:"\\pi",Π:"\\Pi",ρ:"\\rho",σ:"\\sigma",Σ:"\\Sigma",τ:"\\tau",υ:"\\upsilon",Υ:"\\Upsilon",ϕ:"\\phi",Φ:"\\Phi",χ:"\\chi",ψ:"\\psi",Ψ:"\\Psi",ω:"\\omega",Ω:"\\Omega",Ω:"\\Omega","∅":"\\emptyset","⟲":"\\circlearrowleft","⟳":"\\circlearrowright","×":"\\times","½":"\\dfrac{1}{2}",μ:"\\mu",Ө:"\\theta","✓":"\\checkmark","⟩":"\\rangle","⟨":"\\langle","¼":"\\dfrac{1}{4}","…":"\\ldots",ℏ:"\\hbar",ℜ:"\\mathfrak{R}",Ѳ:"\\theta",Ø:"\\emptyset",ϱ:"\\varrho",ф:"\\phi",ℇ:"\\varepsilon",T:"T","∙":"\\cdot",Ρ:"P","∞":"\\infty",ᐁ:"\\nabla",ƞ:"\\eta","⁺":"^{+}","⁻":"^{-}","⁼":"^{=}","⁽":"^{(}","⁾":"^{)}","〗":"\\)|","〖":"\\langle",";":";","൦":"\\circ","┴":"\\perp","✕":"\\times","⎻":"-","»":"\\gg","⬆":"\\uparrow","⬇":"\\downarrow","⬅":"\\leftarrow","➡":"\\rightarrow","⎼":"-","⎜":"\\mid","⎥":"\\mid",ħ:"\\hbar","⮕":"\\rightarrow","・":"\\cdot","¦":"\\mid","£":"\\pounds","¥":"\\yen","✗":"\\times","✔":"\\checkmark",ⁿ:"^{n}","«":"\\ll",เ:"\\prime","†":"\\dagger","│":"\\mid",$:"\\$","#":"\\#","℃":"\\text{\\textdegree C}","℉":"\\text{\\textdegree F}","█":"\\blacksquare","℧":"\\mho",ⅇ:"\\text{e}",ɼ:"r","‡":"\\ddagger",ἱ:"i",ϒ:"\\Upsilon",𝛿:"\\delta","˳":"\\cdot",ѳ:"\\theta",𝜙:"\\phi",П:"\\prod",о:"o",ђ:"\\hbar",Ʌ:"\\Lambda","।":"\\mid","€":"\\euro",ῡ:"\\bar{u}",φ:"\\varphi",ȼ:"c",𝞮:"\\epsilon",Χ:"\\mathsf{X}",ₙ:"_{n}"}},8249:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByChar=void 0,t.allMathSymbolsByChar={"&#xA0;":"\\textrm{ }","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x21D4;":"\\iff","&#x21D2;":"=>","&#xAC;":"\\neg","&#x2124;":"\\mathbb{Z}","&#x211D;":"\\mathbb{R}","&#x211A;":"\\mathbb{Q}","&#x2115;":"\\mathbb{N}","&#x2102;":"CC","&#x25A1;":"\\square","&#x22C4;":"\\diamond","&#x25B3;":"\\triangle","&#x2322;":"\\frown","&#x2220;":"\\angle","&#x22F1;":"\\ddots","&#x22EE;":"\\vdots","&#x2235;":"\\because","&#x2234;":"\\therefore","&#x2135;":"\\aleph","&#x2205;":"\\oslash","&#xB1;":"\\pm","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x222E;":"\\oint","&#x222B;":"\\int","&#x22C3;":"\\cup","&#x222A;":"\\cup","&#x22C2;":"\\cap","&#x2229;":"\\cap","&#x22C1;":"\\vee","&#x2228;":"\\vee","&#x22C0;":"\\wedge","&#x2227;":"\\wedge","&#x220F;":"\\prod","&#x2211;":"\\sum","&#x2299;":"\\bigodot","&#x2297;":"\\bigoplus","&#x2295;":"o+","&#x2218;":"@","&#x22C8;":"\\bowtie","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#xF7;":"\\div","&#xD7;":"\\times","\\":"\\backslash","&#x22C6;":"\\star","&#x2217;":"\\star","&#x22C5;":"\\cdot","&#x3A9;":"\\Omega","&#x3C9;":"\\omega","&#x3A8;":"\\Psi","&#x3C8;":"\\psi","&#x3C7;":"\\chi","&#x3C6;":"\\varphi","&#x3A6;":"\\Phi","&#x3D5;":"\\phi","&#x3C5;":"\\upsilon","&#x3C4;":"\\tau","&#x3A3;":"\\Sigma","&#x3C3;":"\\sigma","&#x3C1;":"\\rho","&#x3A0;":"\\Pi","&#x3C0;":"\\pi","&#x39E;":"\\Xi","&#x3BE;":"\\xi","&#x3BD;":"\\nu","&#x3BC;":"\\mu","&#x39B;":"\\Lambda","&#x3BB;":"\\lambda","&#x3BA;":"\\kappa","&#x3B9;":"\\iota","&#x3D1;":"\\vartheta","&#x398;":"\\Theta","&#x3B8;":"\\theta","&#x3B7;":"\\eta","&#x3B6;":"\\zeta","&#x25B;":"\\varepsilon","&#x3B5;":"\\epsilon","&#x394;":"\\Delta","&#x3B4;":"\\delta","&#x393;":"\\Gamma","&#x3B3;":"\\gamma","&#x3B2;":"\\beta","&#x3B1;":"\\alpha","&#x221E;":"\\infty","‬":"\\text{\\textdir TRT}","‎":"\\text{\\textdir LTR}"}},8171:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByGlyph=void 0,t.allMathSymbolsByGlyph={" ":"\\textrm{ }","∃":"\\exists","∀":"\\forall","⇔":"\\iff","⇒":"\\Rightarrow","¬":"\\neg","□":"\\square","⋄":"\\diamond","△":"\\triangle","⌢":"\\frown","∠":"\\angle","⋱":"\\ddots","⋮":"\\vdots","∵":"\\because","∴":"\\therefore",ℵ:"\\aleph","∅":"\\emptyset","±":"\\pm","∇":"\\nabla","∂":"\\partial","∮":"\\oint","∫":"\\int","⋃":"\\cup","∪":"\\cup","⋂":"\\cap","∩":"\\cap","⋁":"\\vee","∨":"\\vee","⋀":"\\wedge","∧":"\\wedge","∏":"\\prod","∑":"\\sum","⊙":"\\bigodot","⊗":"\\bigoplus","⊕":"o+","∘":"@","⋈":"\\bowtie","⋊":"\\rtimes","⋉":"\\ltimes","÷":"\\div","×":"\\times","\\":"\\backslash","⋆":"\\star","∗":"\\star","⋅":"\\cdot",Ω:"\\Omega",ω:"\\omega",Ψ:"\\Psi",ψ:"\\psi",χ:"\\chi",φ:"\\varphi",Φ:"\\Phi",ϕ:"\\phi",υ:"\\upsilon",τ:"\\tau",Σ:"\\Sigma",σ:"\\sigma",ρ:"\\rho",Π:"\\Pi",π:"\\pi",Ξ:"\\Xi",ξ:"\\xi",ν:"\\nu",μ:"\\mu",Λ:"\\Lambda",λ:"\\lambda",κ:"\\kappa",ι:"\\iota",ϑ:"\\vartheta",Θ:"\\Theta",θ:"\\theta",η:"\\eta",ζ:"\\zeta",ɛ:"\\varepsilon",ε:"\\epsilon",Δ:"\\Delta",δ:"\\delta",Γ:"\\Gamma",γ:"\\gamma",β:"\\beta",α:"\\alpha","∞":"\\infty",ϵ:"\\epsilon",µ:"\\mu","²":"^{2}",ı:"\\imath","∎":"\\blacksquare",ม:"\\mathbf{m}",Ω:"\\Omega","⟲":"\\circlearrowleft","⟳":"\\circlearrowright",त:" ","¥":"\\yen","⁽":"^{(}","⁾":"^{)}",ß:"\\ss",Ћ:"\\hbar","⦵":"\\ominus","⊿":"\\bigtriangleup","↛'":"\\nrightarrow","†":"\\dagger",เ:"\\prime",白:" ","⿱":" ",ℸ:"\\wp",퓰:" ",ⁿ:"^{n}","✔":"\\checkmark","✗":"\\times","½":"\\dfrac{1}{2}",Ө:"\\theta","✓":"\\checkmark","⟩":"\\rangle","⟨":"\\langle","〈":"\\langle","¼":"\\dfrac{1}{4}","…":"\\ldots",ℏ:"\\hbar",ℜ:"\\mathfrak{R}",Ѳ:"\\theta",Ø:"\\emptyset",ϱ:"\\varrho",ф:"\\phi",T:"T","∙":"\\cdot",Ρ:"P",ᐁ:"\\nabla",ƞ:"\\eta",ɣ:"\\gamma",ћ:"\\hbar",Ɛ:"\\varepsilon",ⅅ:"\\_{D}",𝜆:"\\lambda","〗":"\\rangle","〖":"\\langle",";":";",𝑥:"x",𝑦:"y",𝑧:"z",𝑖:"i",𝑗:"j",𝑘:"k",𝑚:"m",𝑒:"e",𝑟:"r",ɳ:"\\eta",𝛽:"\\beta","⍵":"\\omega",℘:"\\wp",𝜋:"\\pi",Є:"\\epsilon",є:"\\epsilon",𝜀:"\\epsilon",п:"\\pi",Ν:"\\nu",ɵ:"\\theta",𝜓:"\\psi",ϴ:"\\theta",ɸ:"\\phi",Ӷ:"\\Gamma",ɭ:"\\ell",ʋ:"\\upsilon",𝛟:"\\varphi","⍬":"\\theta",Ф:"\\Phi",𝜑:"\\varphi",ⅈ:"i",ο:"o",ơ:"o",ƒ:"f","⍴":"\\rho","🇽":"x",𝑝:"p",𝑞:"q",𝑠:"s",𝑡:"t",𝑢:"u",𝑣:"v",𝑤:"w",𝑎:"a",𝑏:"b",𝑐:"c",𝑑:"d",𝑓:"f",𝑔:"g",𝑙:"l",𝑛:"n",𝑜:"o",𝔀:"w",𝚟:"v",ṁ:"m","൦":"\\circ","┴":"\\perp","✕":"\\times","∣":"\\mid",Փ:"\\Phi","⎜":"\\mid",ħ:"\\hbar",ፈ:" ","⦨":"\\llbracket",ế:"\\hat{e}","¢":"\\cent","⤹":"\\downarrow","⤸":"\\downarrow","⤷":"\\Rsh","⤶":"\\Lsh","⤵":"\\downarrow","⤴":"\\uparrow","⤳":"\\rightarrow","|":"\\mid","⎥":"\\mid","♥":"\\heartsuit",О:"0",Υ:"Y",х:"x",𝓏:"z",𝓎:"y",𝓍:"x",р:"p",а:"a","£":"\\pounds",m:"m",𝚵:"\\Xi","⓪":"\\textcircled{0}","①":"\\textcircled{1}","②":"\\textcircled{2}","③":"\\textcircled{3}","④":"\\textcircled{4}","⑤":"\\textcircled{5}","⑥":"\\textcircled{6}","⑦":"\\textcircled{7}","⑧":"\\textcircled{8}","⑨":"\\textcircled{9}","⑩":"\\textcircled{10}","⑪":"\\textcircled{11}","⑫":"\\textcircled{12}","⑬":"\\textcircled{13}","⑭":"\\textcircled{14}","⑮":"\\textcircled{15}","⑯":"\\textcircled{16}","⑰":"\\textcircled{17}","⑱":"\\textcircled{18}","⑲":"\\textcircled{19}","⑳":"\\textcircled{20}","㉑":"\\textcircled{21}","㉒":"\\textcircled{22}","㉓":"\\textcircled{23}","㉔":"\\textcircled{24}","㉕":"\\textcircled{25}","㉖":"\\textcircled{26}","㉗":"\\textcircled{27}","㉘":"\\textcircled{28}","㉙":"\\textcircled{29}","㉚":"\\textcircled{30}","㉛":"\\textcircled{31}","㉜":"\\textcircled{32}","㉝":"\\textcircled{33}","㉞":"\\textcircled{34}","㉟":"\\textcircled{35}","㊱":"\\textcircled{36}","㊲":"\\textcircled{37}","㊳":"\\textcircled{38}","㊴":"\\textcircled{39}","㊵":"\\textcircled{40}","㊶":"\\textcircled{41}","㊷":"\\textcircled{42}","㊸":"\\textcircled{43}","㊹":"\\textcircled{44}","㊺":"\\textcircled{45}","㊻":"\\textcircled{46}","㊼":"\\textcircled{47}","㊽":"\\textcircled{48}","㊾":"\\textcircled{49}","㊿":"\\textcircled{50}","&":"\\&","‖":"\\parallel","%":"\\%","“":"\\text{``}",$:"\\$","#":"\\#","℃":"\\text{\\textdegree C}","℉":"\\text{\\textdegree F}","█":"\\blacksquare","℧":"\\mho","⌋":"\\rfloor","⌊":"\\lfloor","⌉":"\\rceil","⌈":"\\lceil",ℇ:"\\varepsilon",ⅇ:"\\text{e}",ɼ:"r","↛":"\\nrightarrow",ˆ:"\\hat{}","‾":"\\overline","→":"\\rightarrow","‡":"\\ddagger","・":"\\cdot","▱":"\\square","∆":"\\Delta",ἱ:"i","∡":"\\angle",ϒ:"\\Upsilon","↓":"\\downarrow","↑":"\\uparrow","»":"\\gg","⊤":"\\top","⧸":"/",𝛿:"\\delta","˳":"\\cdot","։":":","⦪":"\\measuredangle","⦩":"\\measuredangle","⦫":"\\measuredangle","⦁":"\\cdot",ѳ:"\\theta","⦢":"\\measuredangle","¸":",","⎻":"\\overline","⟦":"\\llbracket",𝜙:"\\phi",П:"\\prod",о:"o","≈":"\\approx","≤":"\\leq",ђ:"\\hbar",Ʌ:"\\Lambda",土:"\\pm","⎼":"-",十:"+","≠":"\\neq","←":"\\leftarrow","।":"\\mid","€":"\\euro","˘":" ",ῡ:"\\bar{u}","∥":"\\parallel","↔":"\\leftrightarrow","√":"\\sqrt{}",ȼ:"c",𝞮:"\\epsilon","·":"\\cdot","⦬":"\\measuredangle","⦮":"\\measuredangle","⦭":"\\measuredangle","«":"\\ll",Χ:"\\mathsf{X}","│":"\\mid","〉":"\\rangle",ₙ:"_{n}","▫":"\\square","●":"\\circle","”":'\\"'}},5406:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(2965),t),n(r(9039),t),n(r(8249),t),n(r(8171),t),n(r(472),t),n(r(4320),t),n(r(6122),t)},472:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.latexAccents=void 0,t.latexAccents=["\\hat","\\bar","\\underbrace","\\overbrace"]},4320:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathNumberByGlyph=void 0,t.mathNumberByGlyph={"₀":"_{0}","₁":"_{1}","₂":"_{2}","₃":"_{3}","₄":"_{4}","₅":"_{5}","₆":"_{6}","₇":"_{7}","₈":"_{8}","₉":"_{9}","⁰":"^{0}","¹":"^{1}","²":"^{2}","³":"^{3}","⁴":"^{4}","⁵":"^{5}","⁶":"^{6}","⁷":"^{7}","⁸":"^{8}","⁹":"^{9}",ⁿ:"^{n}",ₙ:"_{n}","⓪":"\\textcircled{0}","①":"\\textcircled{1}","②":"\\textcircled{2}","③":"\\textcircled{3}","④":"\\textcircled{4}","⑤":"\\textcircled{5}","⑥":"\\textcircled{6}","⑦":"\\textcircled{7}","⑧":"\\textcircled{8}","⑨":"\\textcircled{9}","⑩":"\\textcircled{10}","⑪":"\\textcircled{11}","⑫":"\\textcircled{12}","⑬":"\\textcircled{13}","⑭":"\\textcircled{14}","⑮":"\\textcircled{15}","⑯":"\\textcircled{16}","⑰":"\\textcircled{17}","⑱":"\\textcircled{18}","⑲":"\\textcircled{19}","⑳":"\\textcircled{20}","㉑":"\\textcircled{21}","㉒":"\\textcircled{22}","㉓":"\\textcircled{23}","㉔":"\\textcircled{24}","㉕":"\\textcircled{25}","㉖":"\\textcircled{26}","㉗":"\\textcircled{27}","㉘":"\\textcircled{28}","㉙":"\\textcircled{29}","㉚":"\\textcircled{30}","㉛":"\\textcircled{31}","㉜":"\\textcircled{32}","㉝":"\\textcircled{33}","㉞":"\\textcircled{34}","㉟":"\\textcircled{35}","㊱":"\\textcircled{36}","㊲":"\\textcircled{37}","㊳":"\\textcircled{38}","㊴":"\\textcircled{39}","㊵":"\\textcircled{40}","㊶":"\\textcircled{41}","㊷":"\\textcircled{42}","㊸":"\\textcircled{43}","㊹":"\\textcircled{44}","㊺":"\\textcircled{45}","㊻":"\\textcircled{46}","㊼":"\\textcircled{47}","㊽":"\\textcircled{48}","㊾":"\\textcircled{49}","㊿":"\\textcircled{50}","½":"\\dfrac{1}{2}","⅓":"\\dfrac{1}{3}","⅔":"\\dfrac{2}{3}","¼":"\\dfrac{1}{4}","¾":"\\dfrac{3}{4}","⅕":"\\dfrac{1}{5}","⅖":"\\dfrac{2}{5}","⅗":"\\dfrac{3}{5}","⅘":"\\dfrac{4}{5}","⅙":"\\dfrac{1}{6}","⅚":"\\dfrac{5}{6}","⅐":"\\dfrac{1}{7}","⅛":"\\dfrac{1}{8}","⅜":"\\dfrac{3}{8}","⅝":"\\dfrac{5}{8}","⅞":"\\dfrac{7}{8}","⅑":"\\dfrac{1}{9}","⅒":"\\dfrac{1}{10}"}},6122:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HashUTF8ToLtXConverter=void 0,t.HashUTF8ToLtXConverter=class{convert(e){if(e.match(/[a-z0-9]/i))return e;const t=r[e];if(t){return this.convertAccentCharToLtX(t)||e}return this.convertSpecialCharToLtX(e)||e}convertAccentCharToLtX(e){const{char:t,accent:r}=e,n=a[r];return n?`\\${n}{${t}}`:null}convertSpecialCharToLtX(e){const t=n[e];if(!t)return null;const{letter:r,fontCmd:a}=t;return`\\${a}{${r}}`}};const r={á:{char:"a",accent:"´"},à:{char:"a",accent:"`"},â:{char:"a",accent:"^"},ã:{char:"a",accent:"~"},ä:{char:"a",accent:"¨"},å:{char:"a",accent:"˚"},ą:{char:"a",accent:"˙"},ă:{char:"a",accent:"˘"},ǎ:{char:"a",accent:"ˇ"},ǟ:{char:"a",accent:"ˆ"},ǻ:{char:"a",accent:"˙"},ǡ:{char:"a",accent:"-"},ā:{char:"a",accent:"-"},é:{char:"e",accent:"´"},è:{char:"e",accent:"`"},ê:{char:"e",accent:"^"},ë:{char:"e",accent:"¨"},ę:{char:"e",accent:"˙"},ě:{char:"e",accent:"ˇ"},ȇ:{char:"i",accent:"^"},ё:{char:"e",accent:"¨"},ē:{char:"e",accent:"-"},í:{char:"i",accent:"´"},ì:{char:"i",accent:"`"},î:{char:"i",accent:"^"},ï:{char:"i",accent:"¨"},į:{char:"i",accent:"˙"},ǐ:{char:"i",accent:"ˇ"},ȉ:{char:"i",accent:"`"},ȋ:{char:"i",accent:"¨"},ī:{char:"i",accent:"-"},ó:{char:"o",accent:"´"},ò:{char:"o",accent:"`"},ô:{char:"o",accent:"^"},õ:{char:"o",accent:"~"},ö:{char:"o",accent:"¨"},ő:{char:"o",accent:"˝"},ǒ:{char:"o",accent:"ˇ"},ȍ:{char:"o",accent:"`"},ȏ:{char:"o",accent:"¨"},ȫ:{char:"o",accent:"˘"},ȭ:{char:"o",accent:"˝"},ȯ:{char:"o",accent:"˙"},ō:{char:"o",accent:"-"},ú:{char:"u",accent:"´"},ù:{char:"u",accent:"`"},û:{char:"u",accent:"^"},ü:{char:"u",accent:"¨"},ű:{char:"u",accent:"˝"},ǔ:{char:"u",accent:"ˇ"},ǖ:{char:"u",accent:"¨"},ǘ:{char:"u",accent:"¨"},ǚ:{char:"u",accent:"¨"},ǜ:{char:"u",accent:"¨"},ȕ:{char:"u",accent:"`"},ȗ:{char:"u",accent:"¨"},ū:{char:"u",accent:"-"},ý:{char:"y",accent:"´"},ỳ:{char:"y",accent:"`"},ŷ:{char:"y",accent:"^"},ÿ:{char:"y",accent:"¨"},ȳ:{char:"y",accent:"-"},Á:{char:"A",accent:"´"},À:{char:"A",accent:"`"},Â:{char:"A",accent:"^"},Ã:{char:"A",accent:"~"},Ä:{char:"A",accent:"¨"},Å:{char:"A",accent:"˚"},Å:{char:"A",accent:"˚"},Ȧ:{char:"A",accent:"˙"},Ă:{char:"A",accent:"˘"},Ǎ:{char:"A",accent:"ˇ"},Ǟ:{char:"A",accent:"˝"},Ǻ:{char:"A",accent:"˚"},Ǡ:{char:"A",accent:"-"},Ā:{char:"A",accent:"-"},É:{char:"E",accent:"´"},È:{char:"E",accent:"`"},Ė:{char:"E",accent:"˙"},Ê:{char:"E",accent:"^"},Ë:{char:"E",accent:"¨"},Ě:{char:"E",accent:"ˇ"},Ȅ:{char:"E",accent:"`"},Ȇ:{char:"E",accent:"¨"},Ē:{char:"E",accent:"-"},Í:{char:"I",accent:"´"},Ì:{char:"I",accent:"`"},Î:{char:"I",accent:"^"},Ï:{char:"I",accent:"¨"},Ĭ:{char:"I",accent:"˘"},Ǐ:{char:"I",accent:"ˇ"},Ȉ:{char:"I",accent:"`"},Ȋ:{char:"I",accent:"¨"},Ī:{char:"I",accent:"-"},Ó:{char:"O",accent:"´"},Ò:{char:"O",accent:"`"},Ô:{char:"O",accent:"^"},Õ:{char:"O",accent:"~"},Ö:{char:"O",accent:"¨"},Ő:{char:"O",accent:"˝"},Ǒ:{char:"O",accent:"ˇ"},Ȍ:{char:"O",accent:"`"},Ȏ:{char:"O",accent:"¨"},Ȫ:{char:"O",accent:"˘"},Ȭ:{char:"O",accent:"˝"},Ȯ:{char:"O",accent:"˙"},Ō:{char:"O",accent:"-"},Ú:{char:"U",accent:"´"},Ù:{char:"U",accent:"`"},Û:{char:"U",accent:"^"},Ü:{char:"U",accent:"¨"},Ű:{char:"U",accent:"˝"},Ǔ:{char:"U",accent:"ˇ"},Ǖ:{char:"U",accent:"¨"},Ȕ:{char:"U",accent:"`"},Ȗ:{char:"U",accent:"¨"},Ū:{char:"U",accent:"-"},Ý:{char:"Y",accent:"´"},Ỳ:{char:"Y",accent:"`"},Ŷ:{char:"Y",accent:"^"},Ÿ:{char:"Y",accent:"¨"},Ȳ:{char:"Y",accent:"-"},ñ:{char:"n",accent:"~"},Ñ:{char:"N",accent:"~"},ç:{char:"c",accent:"˙"},Ç:{char:"C",accent:"˙"},ṽ:{char:"v",accent:"~"},Ṽ:{char:"V",accent:"~"},ĵ:{char:"j",accent:"^"},Ĵ:{char:"J",accent:"^"},ź:{char:"z",accent:"´"},Ź:{char:"Z",accent:"´"},Ż:{char:"Z",accent:"^"},ż:{char:"z",accent:"^"},Ž:{char:"Z",accent:"ˇ"},ž:{char:"z",accent:"ˇ"},ẑ:{char:"z",accent:"ˆ"}},a={"´":"grave","`":"acute","^":"hat","~":"tilde","¨":"ddot","˚":"mathring","˘":"breve",ˇ:"check","˝":"ddot","˙":"dot","-":"bar",ˆ:"hat","˜":"tilde"},n={𝐀:{letter:"A",fontCmd:"mathbf"},𝐁:{letter:"B",fontCmd:"mathbf"},𝐂:{letter:"C",fontCmd:"mathbf"},𝐃:{letter:"D",fontCmd:"mathbf"},𝐄:{letter:"E",fontCmd:"mathbf"},Ε:{letter:"E",fontCmd:"mathbf"},𝐅:{letter:"F",fontCmd:"mathbf"},𝐆:{letter:"G",fontCmd:"mathbf"},𝐇:{letter:"H",fontCmd:"mathbf"},𝐈:{letter:"I",fontCmd:"mathbf"},𝐉:{letter:"J",fontCmd:"mathbf"},𝐊:{letter:"K",fontCmd:"mathbf"},𝐋:{letter:"L",fontCmd:"mathbf"},𝐌:{letter:"M",fontCmd:"mathbf"},𝐍:{letter:"N",fontCmd:"mathbf"},𝐎:{letter:"O",fontCmd:"mathbf"},𝐏:{letter:"P",fontCmd:"mathbf"},𝐐:{letter:"Q",fontCmd:"mathbf"},𝐑:{letter:"R",fontCmd:"mathbf"},𝐒:{letter:"S",fontCmd:"mathbf"},𝐓:{letter:"T",fontCmd:"mathbf"},𝐔:{letter:"U",fontCmd:"mathbf"},𝐕:{letter:"V",fontCmd:"mathbf"},𝐖:{letter:"W",fontCmd:"mathbf"},𝐗:{letter:"X",fontCmd:"mathbf"},𝞆:{letter:"X",fontCmd:"mathbf"},𝐘:{letter:"Y",fontCmd:"mathbf"},𝐙:{letter:"Z",fontCmd:"mathbf"},"𝟎":{letter:"0",fontCmd:"mathbf"},"𝟏":{letter:"1",fontCmd:"mathbf"},"𝟐":{letter:"2",fontCmd:"mathbf"},"𝟑":{letter:"3",fontCmd:"mathbf"},"𝟒":{letter:"4",fontCmd:"mathbf"},"𝟓":{letter:"5",fontCmd:"mathbf"},"𝟔":{letter:"6",fontCmd:"mathbf"},"𝟕":{letter:"7",fontCmd:"mathbf"},"𝟖":{letter:"8",fontCmd:"mathbf"},"𝟗":{letter:"9",fontCmd:"mathbf"},𝐴:{letter:"A",fontCmd:"mathit"},𝐵:{letter:"B",fontCmd:"mathit"},𝐶:{letter:"C",fontCmd:"mathit"},𝐷:{letter:"D",fontCmd:"mathit"},𝐸:{letter:"E",fontCmd:"mathit"},𝐹:{letter:"F",fontCmd:"mathit"},𝐺:{letter:"G",fontCmd:"mathit"},𝐻:{letter:"H",fontCmd:"mathit"},𝐼:{letter:"I",fontCmd:"mathit"},Ι:{letter:"I",fontCmd:"mathit"},𝐽:{letter:"J",fontCmd:"mathit"},𝐾:{letter:"K",fontCmd:"mathit"},𝐿:{letter:"L",fontCmd:"mathit"},𝑀:{letter:"M",fontCmd:"mathit"},𝑁:{letter:"N",fontCmd:"mathit"},𝑂:{letter:"O",fontCmd:"mathit"},𝑃:{letter:"P",fontCmd:"mathit"},𝑄:{letter:"Q",fontCmd:"mathit"},𝑅:{letter:"R",fontCmd:"mathit"},𝑆:{letter:"S",fontCmd:"mathit"},𝑇:{letter:"T",fontCmd:"mathit"},𝑈:{letter:"U",fontCmd:"mathit"},𝑉:{letter:"V",fontCmd:"mathit"},𝑊:{letter:"W",fontCmd:"mathit"},𝑋:{letter:"X",fontCmd:"mathit"},𝑌:{letter:"Y",fontCmd:"mathit"},𝑍:{letter:"Z",fontCmd:"mathit"},𝔸:{letter:"A",fontCmd:"mathbb"},𝔹:{letter:"B",fontCmd:"mathbb"},ℂ:{letter:"C",fontCmd:"mathbb"},𝔻:{letter:"D",fontCmd:"mathbb"},𝔼:{letter:"E",fontCmd:"mathbb"},𝔽:{letter:"F",fontCmd:"mathbb"},𝔾:{letter:"G",fontCmd:"mathbb"},ℍ:{letter:"H",fontCmd:"mathbb"},𝕀:{letter:"I",fontCmd:"mathbb"},𝕁:{letter:"J",fontCmd:"mathbb"},𝕂:{letter:"K",fontCmd:"mathbb"},𝕃:{letter:"L",fontCmd:"mathbb"},𝕄:{letter:"M",fontCmd:"mathbb"},ℕ:{letter:"N",fontCmd:"mathbb"},𝕆:{letter:"O",fontCmd:"mathbb"},ℙ:{letter:"P",fontCmd:"mathbb"},ℚ:{letter:"Q",fontCmd:"mathbb"},ℝ:{letter:"R",fontCmd:"mathbb"},𝕊:{letter:"S",fontCmd:"mathbb"},𝕋:{letter:"T",fontCmd:"mathbb"},𝕌:{letter:"U",fontCmd:"mathbb"},𝕍:{letter:"V",fontCmd:"mathbb"},𝕎:{letter:"W",fontCmd:"mathbb"},𝕏:{letter:"X",fontCmd:"mathbb"},𝕐:{letter:"Y",fontCmd:"mathbb"},ℤ:{letter:"Z",fontCmd:"mathbb"},"𝟘":{letter:"0",fontCmd:"mathbb"},"𝟙":{letter:"1",fontCmd:"mathbb"},"𝟚":{letter:"2",fontCmd:"mathbb"},"𝟛":{letter:"3",fontCmd:"mathbb"},"𝟜":{letter:"4",fontCmd:"mathbb"},"𝟝":{letter:"5",fontCmd:"mathbb"},"𝟞":{letter:"6",fontCmd:"mathbb"},"𝟟":{letter:"7",fontCmd:"mathbb"},"𝟠":{letter:"8",fontCmd:"mathbb"},"𝟡":{letter:"9",fontCmd:"mathbb"},𝒜:{letter:"A",fontCmd:"mathcal"},𝓐:{letter:"A",fontCmd:"mathcal"},ℬ:{letter:"B",fontCmd:"mathcal"},𝒞:{letter:"C",fontCmd:"mathcal"},𝒟:{letter:"D",fontCmd:"mathcal"},𝓓:{letter:"D",fontCmd:"mathcal"},ℰ:{letter:"E",fontCmd:"mathcal"},ℱ:{letter:"F",fontCmd:"mathcal"},𝓕:{letter:"F",fontCmd:"mathcal"},𝒢:{letter:"G",fontCmd:"mathcal"},ℋ:{letter:"H",fontCmd:"mathcal"},ℐ:{letter:"I",fontCmd:"mathcal"},𝒥:{letter:"J",fontCmd:"mathcal"},𝒦:{letter:"K",fontCmd:"mathcal"},ℒ:{letter:"L",fontCmd:"mathcal"},𝓛:{letter:"L",fontCmd:"mathcal"},ℳ:{letter:"M",fontCmd:"mathcal"},𝒩:{letter:"N",fontCmd:"mathcal"},𝒪:{letter:"O",fontCmd:"mathcal"},𝓞:{letter:"O",fontCmd:"mathcal"},𝒫:{letter:"P",fontCmd:"mathcal"},𝒬:{letter:"Q",fontCmd:"mathcal"},ℛ:{letter:"R",fontCmd:"mathcal"},𝕽:{letter:"R",fontCmd:"mathcal"},"℟":{letter:"R",fontCmd:"mathcal"},𝒮:{letter:"S",fontCmd:"mathcal"},𝒯:{letter:"T",fontCmd:"mathcal"},𝒰:{letter:"U",fontCmd:"mathcal"},𝒱:{letter:"V",fontCmd:"mathcal"},𝒲:{letter:"W",fontCmd:"mathcal"},𝒳:{letter:"X",fontCmd:"mathcal"},𝒴:{letter:"Y",fontCmd:"mathcal"},𝒵:{letter:"Z",fontCmd:"mathcal"},𝔄:{letter:"A",fontCmd:"mathfrak"},𝔅:{letter:"B",fontCmd:"mathfrak"},ℭ:{letter:"C",fontCmd:"mathfrak"},𝔇:{letter:"D",fontCmd:"mathfrak"},𝔈:{letter:"E",fontCmd:"mathfrak"},𝔉:{letter:"F",fontCmd:"mathfrak"},𝔊:{letter:"G",fontCmd:"mathfrak"},ℌ:{letter:"H",fontCmd:"mathfrak"},ℑ:{letter:"I",fontCmd:"mathfrak"},𝔍:{letter:"J",fontCmd:"mathfrak"},𝔎:{letter:"K",fontCmd:"mathfrak"},𝔏:{letter:"L",fontCmd:"mathfrak"},𝔐:{letter:"M",fontCmd:"mathfrak"},𝔑:{letter:"N",fontCmd:"mathfrak"},𝔒:{letter:"O",fontCmd:"mathfrak"},𝔓:{letter:"P",fontCmd:"mathfrak"},𝔔:{letter:"Q",fontCmd:"mathfrak"},ℜ:{letter:"R",fontCmd:"mathfrak"},𝔖:{letter:"S",fontCmd:"mathfrak"},𝔗:{letter:"T",fontCmd:"mathfrak"},𝔘:{letter:"U",fontCmd:"mathfrak"},𝔙:{letter:"V",fontCmd:"mathfrak"},𝔚:{letter:"W",fontCmd:"mathfrak"},𝔛:{letter:"X",fontCmd:"mathfrak"},𝔜:{letter:"Y",fontCmd:"mathfrak"},ℨ:{letter:"Z",fontCmd:"mathfrak"},𝖠:{letter:"A",fontCmd:"mathsf"},Α:{letter:"A",fontCmd:"mathsf"},𝖡:{letter:"B",fontCmd:"mathsf"},Β:{letter:"B",fontCmd:"mathsf"},𝖢:{letter:"C",fontCmd:"mathsf"},𝖣:{letter:"D",fontCmd:"mathsf"},𝖤:{letter:"E",fontCmd:"mathsf"},𝖥:{letter:"F",fontCmd:"mathsf"},𝖦:{letter:"G",fontCmd:"mathsf"},𝖧:{letter:"H",fontCmd:"mathsf"},𝖨:{letter:"I",fontCmd:"mathsf"},𝖩:{letter:"J",fontCmd:"mathsf"},ȷ:{letter:"J",fontCmd:"mathsf"},𝖪:{letter:"K",fontCmd:"mathsf"},Κ:{letter:"K",fontCmd:"mathsf"},𝖫:{letter:"L",fontCmd:"mathsf"},𝖬:{letter:"M",fontCmd:"mathsf"},𝖭:{letter:"N",fontCmd:"mathsf"},𝖮:{letter:"O",fontCmd:"mathsf"},𝖯:{letter:"P",fontCmd:"mathsf"},𝖰:{letter:"Q",fontCmd:"mathsf"},𝖱:{letter:"R",fontCmd:"mathsf"},𝖲:{letter:"S",fontCmd:"mathsf"},𝖳:{letter:"T",fontCmd:"mathsf"},𝖴:{letter:"U",fontCmd:"mathsf"},𝖵:{letter:"V",fontCmd:"mathsf"},𝖶:{letter:"W",fontCmd:"mathsf"},𝖷:{letter:"X",fontCmd:"mathsf"},Χ:{letter:"X",fontCmd:"mathsf"},𝖸:{letter:"Y",fontCmd:"mathsf"},𝖹:{letter:"Z",fontCmd:"mathsf"},𝚨:{letter:"A",fontCmd:"mathtt"},𝚩:{letter:"B",fontCmd:"mathtt"},𝚪:{letter:"\\Gamma",fontCmd:"mathtt"},𝚫:{letter:"\\Delta",fontCmd:"mathtt"},𝚬:{letter:"E",fontCmd:"mathtt"},𝚭:{letter:"F",fontCmd:"mathtt"},𝚮:{letter:"G",fontCmd:"mathtt"},𝚯:{letter:"\\Theta",fontCmd:"mathtt"},𝚰:{letter:"I",fontCmd:"mathtt"},𝚱:{letter:"J",fontCmd:"mathtt"},𝚲:{letter:"\\Lambda",fontCmd:"mathtt"},𝚳:{letter:"L",fontCmd:"mathtt"},𝚴:{letter:"M",fontCmd:"mathtt"},𝚵:{letter:"\\Pi",fontCmd:"mathtt"},𝚶:{letter:"O",fontCmd:"mathtt"},𝚷:{letter:"\\Pi",fontCmd:"mathtt"},𝚸:{letter:"Q",fontCmd:"mathtt"},𝚹:{letter:"R",fontCmd:"mathtt"},𝚺:{letter:"S",fontCmd:"mathtt"},𝚻:{letter:"T",fontCmd:"mathtt"},𝚼:{letter:"U",fontCmd:"mathtt"},𝚽:{letter:"\\Phi",fontCmd:"mathtt"},𝚾:{letter:"W",fontCmd:"mathtt"},𝚿:{letter:"\\Psi",fontCmd:"mathtt"},𝛀:{letter:"\\Omega",fontCmd:"mathtt"}}}},t={};function r(a){var n=t[a];if(void 0!==n)return n.exports;var o=t[a]={exports:{}};return e[a].call(o.exports,o,o.exports,r),o.exports}var a={};return(()=>{"use strict";var e=a;Object.defineProperty(e,"__esModule",{value:!0}),e.MathMLToLaTeX=void 0;var t=r(8672);Object.defineProperty(e,"MathMLToLaTeX",{enumerable:!0,get:function(){return t.MathMLToLaTeX}})})(),a})()));
//# sourceMappingURL=bundle.min.js.map

/***/ }),

/***/ 608:
/*!*************************!*\
  !*** ./src/metadata.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetadataExtractor = void 0;
class MetadataExtractor {
    static extract(doc, schemaOrgData) {
        var _a, _b;
        let domain = '';
        let url = '';
        try {
            // Try to get URL from document location
            url = ((_a = doc.location) === null || _a === void 0 ? void 0 : _a.href) || '';
            // If no URL from location, try other sources
            if (!url) {
                url = this.getMetaContent(doc, "property", "og:url") ||
                    this.getMetaContent(doc, "property", "twitter:url") ||
                    this.getSchemaProperty(doc, schemaOrgData, 'url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntityOfPage.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntity.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'WebSite.url') ||
                    ((_b = doc.querySelector('link[rel="canonical"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('href')) || '';
            }
            if (url) {
                domain = new URL(url).hostname.replace(/^www\./, '');
            }
        }
        catch (e) {
            // If URL parsing fails, try to get from base tag
            const baseTag = doc.querySelector('base[href]');
            if (baseTag) {
                try {
                    url = baseTag.getAttribute('href') || '';
                    domain = new URL(url).hostname.replace(/^www\./, '');
                }
                catch (e) {
                    console.warn('Failed to parse base URL:', e);
                }
            }
        }
        return {
            title: this.getTitle(doc, schemaOrgData),
            description: this.getDescription(doc, schemaOrgData),
            domain,
            favicon: this.getFavicon(doc, url),
            image: this.getImage(doc, schemaOrgData),
            published: this.getPublished(doc, schemaOrgData),
            author: this.getAuthor(doc, schemaOrgData),
            site: this.getSite(doc, schemaOrgData),
            schemaOrgData,
            wordCount: 0,
            parseTime: 0
        };
    }
    static getAuthor(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "sailthru.author") ||
            this.getSchemaProperty(doc, schemaOrgData, 'author.name') ||
            this.getMetaContent(doc, "property", "author") ||
            this.getMetaContent(doc, "name", "byl") ||
            this.getMetaContent(doc, "name", "author") ||
            this.getMetaContent(doc, "name", "authorList") ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "twitter:creator") ||
            this.getMetaContent(doc, "name", "application-name") ||
            '');
    }
    static getSite(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'WebSite.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "application-name") ||
            this.getAuthor(doc, schemaOrgData) ||
            '');
    }
    static getTitle(doc, schemaOrgData) {
        var _a, _b;
        const rawTitle = (this.getMetaContent(doc, "property", "og:title") ||
            this.getMetaContent(doc, "name", "twitter:title") ||
            this.getSchemaProperty(doc, schemaOrgData, 'headline') ||
            this.getMetaContent(doc, "name", "title") ||
            this.getMetaContent(doc, "name", "sailthru.title") ||
            ((_b = (_a = doc.querySelector('title')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) ||
            '');
        return this.cleanTitle(rawTitle, this.getSite(doc, schemaOrgData));
    }
    static cleanTitle(title, siteName) {
        if (!title || !siteName)
            return title;
        // Remove site name if it exists
        const siteNameEscaped = siteName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const patterns = [
            `\\s*[\\|\\-–—]\\s*${siteNameEscaped}\\s*$`, // Title | Site Name
            `^\\s*${siteNameEscaped}\\s*[\\|\\-–—]\\s*`, // Site Name | Title
        ];
        for (const pattern of patterns) {
            const regex = new RegExp(pattern, 'i');
            if (regex.test(title)) {
                title = title.replace(regex, '');
                break;
            }
        }
        return title.trim();
    }
    static getDescription(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "description") ||
            this.getMetaContent(doc, "property", "description") ||
            this.getMetaContent(doc, "property", "og:description") ||
            this.getSchemaProperty(doc, schemaOrgData, 'description') ||
            this.getMetaContent(doc, "name", "twitter:description") ||
            this.getMetaContent(doc, "name", "sailthru.description") ||
            '');
    }
    static getImage(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "property", "og:image") ||
            this.getMetaContent(doc, "name", "twitter:image") ||
            this.getSchemaProperty(doc, schemaOrgData, 'image.url') ||
            this.getMetaContent(doc, "name", "sailthru.image.full") ||
            '');
    }
    static getFavicon(doc, baseUrl) {
        var _a, _b;
        const iconFromMeta = this.getMetaContent(doc, "property", "og:image:favicon");
        if (iconFromMeta)
            return iconFromMeta;
        const iconLink = (_a = doc.querySelector("link[rel='icon']")) === null || _a === void 0 ? void 0 : _a.getAttribute("href");
        if (iconLink)
            return iconLink;
        const shortcutLink = (_b = doc.querySelector("link[rel='shortcut icon']")) === null || _b === void 0 ? void 0 : _b.getAttribute("href");
        if (shortcutLink)
            return shortcutLink;
        // Only try to construct favicon URL if we have a valid base URL
        if (baseUrl) {
            try {
                return new URL("/favicon.ico", baseUrl).href;
            }
            catch (e) {
                console.warn('Failed to construct favicon URL:', e);
            }
        }
        return '';
    }
    static getPublished(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'datePublished') ||
            this.getMetaContent(doc, "name", "publishDate") ||
            this.getMetaContent(doc, "property", "article:published_time") ||
            this.getTimeElement(doc) ||
            this.getMetaContent(doc, "name", "sailthru.date") ||
            '');
    }
    static getMetaContent(doc, attr, value) {
        var _a, _b;
        const selector = `meta[${attr}]`;
        const element = Array.from(doc.querySelectorAll(selector))
            .find(el => { var _a; return ((_a = el.getAttribute(attr)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === value.toLowerCase(); });
        const content = element ? (_b = (_a = element.getAttribute("content")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : "" : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static getTimeElement(doc) {
        var _a, _b, _c, _d;
        const selector = `time`;
        const element = Array.from(doc.querySelectorAll(selector))[0];
        const content = element ? ((_d = (_b = (_a = element.getAttribute("datetime")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.trim()) !== null && _d !== void 0 ? _d : "") : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static decodeHTMLEntities(text, doc) {
        const textarea = doc.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }
    static getSchemaProperty(doc, schemaOrgData, property, defaultValue = '') {
        if (!schemaOrgData)
            return defaultValue;
        const searchSchema = (data, props, fullPath, isExactMatch = true) => {
            if (typeof data === 'string') {
                return props.length === 0 ? [data] : [];
            }
            if (!data || typeof data !== 'object') {
                return [];
            }
            if (Array.isArray(data)) {
                const currentProp = props[0];
                if (/^\[\d+\]$/.test(currentProp)) {
                    const index = parseInt(currentProp.slice(1, -1));
                    if (data[index]) {
                        return searchSchema(data[index], props.slice(1), fullPath, isExactMatch);
                    }
                    return [];
                }
                if (props.length === 0 && data.every(item => typeof item === 'string' || typeof item === 'number')) {
                    return data.map(String);
                }
                return data.flatMap(item => searchSchema(item, props, fullPath, isExactMatch));
            }
            const [currentProp, ...remainingProps] = props;
            if (!currentProp) {
                if (typeof data === 'string')
                    return [data];
                if (typeof data === 'object' && data.name) {
                    return [data.name];
                }
                return [];
            }
            if (data.hasOwnProperty(currentProp)) {
                return searchSchema(data[currentProp], remainingProps, fullPath ? `${fullPath}.${currentProp}` : currentProp, true);
            }
            if (!isExactMatch) {
                const nestedResults = [];
                for (const key in data) {
                    if (typeof data[key] === 'object') {
                        const results = searchSchema(data[key], props, fullPath ? `${fullPath}.${key}` : key, false);
                        nestedResults.push(...results);
                    }
                }
                if (nestedResults.length > 0) {
                    return nestedResults;
                }
            }
            return [];
        };
        try {
            let results = searchSchema(schemaOrgData, property.split('.'), '', true);
            if (results.length === 0) {
                results = searchSchema(schemaOrgData, property.split('.'), '', false);
            }
            const result = results.length > 0 ? results.filter(Boolean).join(', ') : defaultValue;
            return this.decodeHTMLEntities(result, doc);
        }
        catch (error) {
            console.error(`Error in getSchemaProperty for ${property}:`, error);
            return defaultValue;
        }
    }
    static extractSchemaOrgData(doc) {
        const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
        const schemaData = [];
        schemaScripts.forEach(script => {
            let jsonContent = script.textContent || '';
            try {
                jsonContent = jsonContent
                    .replace(/\/\*[\s\S]*?\*\/|^\s*\/\/.*$/gm, '')
                    .replace(/^\s*<!\[CDATA\[([\s\S]*?)\]\]>\s*$/, '$1')
                    .replace(/^\s*(\*\/|\/\*)\s*|\s*(\*\/|\/\*)\s*$/g, '')
                    .trim();
                const jsonData = JSON.parse(jsonContent);
                if (jsonData['@graph'] && Array.isArray(jsonData['@graph'])) {
                    schemaData.push(...jsonData['@graph']);
                }
                else {
                    schemaData.push(jsonData);
                }
            }
            catch (error) {
                console.error('Error parsing schema.org data:', error);
                console.error('Problematic JSON content:', jsonContent);
            }
        });
        return schemaData;
    }
}
exports.MetadataExtractor = MetadataExtractor;


/***/ }),

/***/ 628:
/*!*************************!*\
  !*** ./src/defuddle.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
const metadata_1 = __webpack_require__(/*! ./metadata */ 608);
const constants_1 = __webpack_require__(/*! ./constants */ 640);
const math_1 = __webpack_require__(/*! ./math */ 315);
const ELEMENT_STANDARDIZATION_RULES = [
    // Math elements
    ...math_1.mathStandardizationRules,
    // Code blocks
    {
        selector: 'pre',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Function to get language from class
            const getLanguageFromClass = (element) => {
                // Check data-lang attribute first
                const dataLang = element.getAttribute('data-lang');
                if (dataLang) {
                    return dataLang.toLowerCase();
                }
                // Define language patterns
                const languagePatterns = [
                    /^language-(\w+)$/, // language-javascript
                    /^lang-(\w+)$/, // lang-javascript
                    /^(\w+)-code$/, // javascript-code
                    /^code-(\w+)$/, // code-javascript
                    /^syntax-(\w+)$/, // syntax-javascript
                    /^code-snippet__(\w+)$/, // code-snippet__javascript
                    /^highlight-(\w+)$/, // highlight-javascript
                    /^(\w+)-snippet$/ // javascript-snippet
                ];
                // Then check the class attribute for patterns
                if (element.className && typeof element.className === 'string') {
                    for (const pattern of languagePatterns) {
                        const match = element.className.toLowerCase().match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                    // Then check for supported language
                    if (constants_1.SUPPORTED_LANGUAGES.has(element.className.toLowerCase())) {
                        return element.className.toLowerCase();
                    }
                }
                const classNames = Array.from(element.classList);
                for (const className of classNames) {
                    // Check patterns first
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                }
                // Only check bare language names if no patterns were found
                for (const className of classNames) {
                    if (constants_1.SUPPORTED_LANGUAGES.has(className.toLowerCase())) {
                        return className.toLowerCase();
                    }
                }
                return '';
            };
            // Try to get the language from the element and its ancestors
            let language = '';
            let currentElement = el;
            while (currentElement && !language) {
                language = getLanguageFromClass(currentElement);
                // Also check for code elements within the current element
                if (!language && currentElement.querySelector('code')) {
                    language = getLanguageFromClass(currentElement.querySelector('code'));
                }
                currentElement = currentElement.parentElement;
            }
            // Function to recursively extract text content while preserving structure
            const extractStructuredText = (element) => {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent || '';
                }
                let text = '';
                if (element instanceof HTMLElement) {
                    // Handle line breaks
                    if (element.tagName === 'BR') {
                        return '\n';
                    }
                    // Handle code elements and their children
                    element.childNodes.forEach(child => {
                        text += extractStructuredText(child);
                    });
                    // Add newline after each code element
                    if (element.tagName === 'CODE') {
                        text += '\n';
                    }
                }
                return text;
            };
            // Extract all text content
            let codeContent = extractStructuredText(el);
            // Clean up the content
            codeContent = codeContent
                // Remove any extra newlines at the start
                .replace(/^\n+/, '')
                // Remove any extra newlines at the end
                .replace(/\n+$/, '')
                // Replace multiple consecutive newlines with a single newline
                .replace(/\n{3,}/g, '\n\n');
            // Create new pre element
            const newPre = document.createElement('pre');
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    newPre.setAttribute(attr.name, attr.value);
                }
            });
            // Create code element
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    },
    // Simplify headings by removing internal navigation elements
    {
        selector: 'h1, h2, h3, h4, h5, h6',
        element: 'keep',
        transform: (el) => {
            var _a, _b, _c, _d, _e;
            // If heading only contains a single anchor with internal link
            if (el.children.length === 1 &&
                ((_a = el.firstElementChild) === null || _a === void 0 ? void 0 : _a.tagName) === 'A' &&
                (((_b = el.firstElementChild.getAttribute('href')) === null || _b === void 0 ? void 0 : _b.includes('#')) ||
                    ((_c = el.firstElementChild.getAttribute('href')) === null || _c === void 0 ? void 0 : _c.startsWith('#')))) {
                // Create new heading of same level
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes from original heading
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                return newHeading;
            }
            // If heading contains navigation buttons or other utility elements
            const buttons = el.querySelectorAll('button');
            if (buttons.length > 0) {
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_e = el.textContent) === null || _e === void 0 ? void 0 : _e.trim()) || '';
                return newHeading;
            }
            return el;
        }
    },
    // Convert divs with paragraph role to actual paragraphs
    {
        selector: 'div[data-testid^="paragraph"], div[role="paragraph"]',
        element: 'p',
        transform: (el) => {
            const p = document.createElement('p');
            // Copy innerHTML
            p.innerHTML = el.innerHTML;
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    p.setAttribute(attr.name, attr.value);
                }
            });
            return p;
        }
    },
    // Convert divs with list roles to actual lists
    {
        selector: 'div[role="list"]',
        element: 'ul',
        // Custom handler for list type detection and transformation
        transform: (el) => {
            var _a;
            // First determine if this is an ordered list
            const firstItem = el.querySelector('div[role="listitem"] .label');
            const label = ((_a = firstItem === null || firstItem === void 0 ? void 0 : firstItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
            const isOrdered = label.match(/^\d+\)/);
            // Create the appropriate list type
            const list = document.createElement(isOrdered ? 'ol' : 'ul');
            // Process each list item
            const items = el.querySelectorAll('div[role="listitem"]');
            items.forEach(item => {
                const li = document.createElement('li');
                const content = item.querySelector('.content');
                if (content) {
                    // Convert any paragraph divs inside content
                    const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
                    paragraphDivs.forEach(div => {
                        const p = document.createElement('p');
                        p.innerHTML = div.innerHTML;
                        div.replaceWith(p);
                    });
                    // Convert any nested lists recursively
                    const nestedLists = content.querySelectorAll('div[role="list"]');
                    nestedLists.forEach(nestedList => {
                        var _a;
                        const firstNestedItem = nestedList.querySelector('div[role="listitem"] .label');
                        const nestedLabel = ((_a = firstNestedItem === null || firstNestedItem === void 0 ? void 0 : firstNestedItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        const isNestedOrdered = nestedLabel.match(/^\d+\)/);
                        const newNestedList = document.createElement(isNestedOrdered ? 'ol' : 'ul');
                        // Process nested items
                        const nestedItems = nestedList.querySelectorAll('div[role="listitem"]');
                        nestedItems.forEach(nestedItem => {
                            const nestedLi = document.createElement('li');
                            const nestedContent = nestedItem.querySelector('.content');
                            if (nestedContent) {
                                // Convert paragraph divs in nested items
                                const nestedParagraphs = nestedContent.querySelectorAll('div[role="paragraph"]');
                                nestedParagraphs.forEach(div => {
                                    const p = document.createElement('p');
                                    p.innerHTML = div.innerHTML;
                                    div.replaceWith(p);
                                });
                                nestedLi.innerHTML = nestedContent.innerHTML;
                            }
                            newNestedList.appendChild(nestedLi);
                        });
                        nestedList.replaceWith(newNestedList);
                    });
                    li.innerHTML = content.innerHTML;
                }
                list.appendChild(li);
            });
            return list;
        }
    },
    {
        selector: 'div[role="listitem"]',
        element: 'li',
        // Custom handler for list item content
        transform: (el) => {
            const content = el.querySelector('.content');
            if (!content)
                return el;
            // Convert any paragraph divs inside content
            const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
            paragraphDivs.forEach(div => {
                const p = document.createElement('p');
                p.innerHTML = div.innerHTML;
                div.replaceWith(p);
            });
            return content;
        }
    },
    // Code blocks with syntax highlighting
    {
        selector: '.wp-block-syntaxhighlighter-code, .syntaxhighlighter, .highlight, .highlight-source, .wp-block-code, pre[class*="language-"], pre[class*="brush:"]',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Create new pre element
            const newPre = document.createElement('pre');
            // Try to detect language
            let language = '';
            // Check for WordPress syntax highlighter specific format
            const syntaxEl = el.querySelector('.syntaxhighlighter');
            if (syntaxEl) {
                // Get language from syntaxhighlighter class
                const classes = Array.from(syntaxEl.classList);
                const langClass = classes.find(c => !['syntaxhighlighter', 'nogutter'].includes(c));
                if (langClass && constants_1.SUPPORTED_LANGUAGES.has(langClass.toLowerCase())) {
                    language = langClass.toLowerCase();
                }
            }
            // If no language found yet, check other common patterns
            if (!language) {
                const classNames = Array.from(el.classList);
                const languagePatterns = [
                    /(?:^|\s)(?:language|lang|brush|syntax)-(\w+)(?:\s|$)/i,
                    /(?:^|\s)(\w+)(?:\s|$)/i
                ];
                for (const className of classNames) {
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match && match[1] && constants_1.SUPPORTED_LANGUAGES.has(match[1].toLowerCase())) {
                            language = match[1].toLowerCase();
                            break;
                        }
                    }
                    if (language)
                        break;
                }
            }
            // Extract code content, handling various formats
            let codeContent = '';
            // Handle WordPress syntax highlighter table format
            const codeContainer = el.querySelector('.syntaxhighlighter table .code .container');
            if (codeContainer) {
                // Process each line
                const lines = Array.from(codeContainer.children);
                codeContent = lines
                    .map(line => {
                    // Get all code elements in this line
                    const codeParts = Array.from(line.querySelectorAll('code'))
                        .map(code => {
                        // Get the text content, preserving spaces
                        let text = code.textContent || '';
                        // If this is a 'spaces' class element, convert to actual spaces
                        if (code.classList.contains('spaces')) {
                            text = ' '.repeat(text.length);
                        }
                        return text;
                    })
                        .join('');
                    return codeParts || line.textContent || '';
                })
                    .join('\n');
            }
            else {
                // Handle WordPress syntax highlighter non-table format
                const codeLines = el.querySelectorAll('.code .line');
                if (codeLines.length > 0) {
                    codeContent = Array.from(codeLines)
                        .map(line => {
                        const codeParts = Array.from(line.querySelectorAll('code'))
                            .map(code => code.textContent || '')
                            .join('');
                        return codeParts || line.textContent || '';
                    })
                        .join('\n');
                }
                else {
                    // Fallback to regular text content
                    codeContent = el.textContent || '';
                }
            }
            // Clean up the content
            codeContent = codeContent
                .replace(/^\s+|\s+$/g, '') // Trim start/end whitespace
                .replace(/\t/g, '    ') // Convert tabs to spaces
                .replace(/\n{3,}/g, '\n\n') // Normalize multiple newlines
                .replace(/\u00a0/g, ' '); // Replace non-breaking spaces with regular spaces
            // Create code element with language class if detected
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    }
];
class Defuddle {
    /**
     * Create a new Defuddle instance
     * @param doc - The document to parse
     * @param options - Options for parsing
     */
    constructor(doc, options = {}) {
        this.doc = doc;
        this.options = options;
        this.debug = options.debug || false;
    }
    /**
     * Parse the document and extract its main content
     */
    parse() {
        const startTime = performance.now();
        // Extract metadata first since we'll need it in multiple places
        const schemaOrgData = metadata_1.MetadataExtractor.extractSchemaOrgData(this.doc);
        const metadata = metadata_1.MetadataExtractor.extract(this.doc, schemaOrgData);
        try {
            // Evaluate styles and sizes on original document
            const mobileStyles = this._evaluateMediaQueries(this.doc);
            // Check for small images in original document, excluding lazy-loaded ones
            const smallImages = this.findSmallImages(this.doc);
            // Clone document
            const clone = this.doc.cloneNode(true);
            // Apply mobile style to clone
            this.applyMobileStyles(clone, mobileStyles);
            // Find main content
            const mainContent = this.findMainContent(clone);
            if (!mainContent) {
                const endTime = performance.now();
                return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
            }
            // Remove small images identified from original document
            this.removeSmallImages(clone, smallImages);
            // Perform other destructive operations on the clone
            this.removeHiddenElements(clone);
            this.removeClutter(clone);
            // Clean up the main content
            this.cleanContent(mainContent, metadata);
            const content = mainContent ? mainContent.outerHTML : this.doc.body.innerHTML;
            const endTime = performance.now();
            return Object.assign(Object.assign({ content }, metadata), { wordCount: this.countWords(content), parseTime: Math.round(endTime - startTime) });
        }
        catch (error) {
            console.error('Defuddle', 'Error processing document:', error);
            const endTime = performance.now();
            return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
        }
    }
    countWords(content) {
        // Create a temporary div to parse HTML content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        // Get text content, removing extra whitespace
        const text = tempDiv.textContent || '';
        const words = text
            .trim()
            .replace(/\s+/g, ' ') // Replace multiple spaces with single space
            .split(' ')
            .filter(word => word.length > 0); // Filter out empty strings
        return words.length;
    }
    // Make all other methods private by removing the static keyword and using private
    _log(...args) {
        if (this.debug) {
            console.log('Defuddle:', ...args);
        }
    }
    _evaluateMediaQueries(doc) {
        const mobileStyles = [];
        const maxWidthRegex = /max-width[^:]*:\s*(\d+)/;
        try {
            // Get all styles, including inline styles
            const sheets = Array.from(doc.styleSheets).filter(sheet => {
                try {
                    // Access rules once to check validity
                    sheet.cssRules;
                    return true;
                }
                catch (e) {
                    // Expected error for cross-origin stylesheets
                    if (e instanceof DOMException && e.name === 'SecurityError') {
                        return false;
                    }
                    throw e;
                }
            });
            // Process all sheets in a single pass
            const mediaRules = sheets.flatMap(sheet => {
                try {
                    return Array.from(sheet.cssRules)
                        .filter((rule) => rule instanceof CSSMediaRule &&
                        rule.conditionText.includes('max-width'));
                }
                catch (e) {
                    if (this.debug) {
                        console.warn('Defuddle: Failed to process stylesheet:', e);
                    }
                    return [];
                }
            });
            // Process all media rules in a single pass
            mediaRules.forEach(rule => {
                const match = rule.conditionText.match(maxWidthRegex);
                if (match) {
                    const maxWidth = parseInt(match[1]);
                    if (constants_1.MOBILE_WIDTH <= maxWidth) {
                        // Batch process all style rules
                        const styleRules = Array.from(rule.cssRules)
                            .filter((r) => r instanceof CSSStyleRule);
                        styleRules.forEach(cssRule => {
                            try {
                                mobileStyles.push({
                                    selector: cssRule.selectorText,
                                    styles: cssRule.style.cssText
                                });
                            }
                            catch (e) {
                                if (this.debug) {
                                    console.warn('Defuddle: Failed to process CSS rule:', e);
                                }
                            }
                        });
                    }
                }
            });
        }
        catch (e) {
            console.error('Defuddle: Error evaluating media queries:', e);
        }
        return mobileStyles;
    }
    applyMobileStyles(doc, mobileStyles) {
        let appliedCount = 0;
        mobileStyles.forEach(({ selector, styles }) => {
            try {
                const elements = doc.querySelectorAll(selector);
                elements.forEach(element => {
                    element.setAttribute('style', (element.getAttribute('style') || '') + styles);
                    appliedCount++;
                });
            }
            catch (e) {
                console.error('Defuddle', 'Error applying styles for selector:', selector, e);
            }
        });
    }
    removeHiddenElements(doc) {
        let count = 0;
        const elementsToRemove = new Set();
        // First pass: Get all elements matching hidden selectors
        const hiddenElements = doc.querySelectorAll(constants_1.HIDDEN_ELEMENT_SELECTORS);
        hiddenElements.forEach(el => elementsToRemove.add(el));
        count += hiddenElements.length;
        // Second pass: Use TreeWalker for efficient traversal
        const treeWalker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, {
            acceptNode: (node) => {
                // Skip elements already marked for removal
                if (elementsToRemove.has(node)) {
                    return NodeFilter.FILTER_REJECT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        // Batch style computations
        const elements = [];
        let currentNode;
        while (currentNode = treeWalker.nextNode()) {
            elements.push(currentNode);
        }
        // Process styles in batches to minimize layout thrashing
        const BATCH_SIZE = 100;
        for (let i = 0; i < elements.length; i += BATCH_SIZE) {
            const batch = elements.slice(i, i + BATCH_SIZE);
            // Read phase - gather all computedStyles
            const styles = batch.map(el => window.getComputedStyle(el));
            // Write phase - mark elements for removal
            batch.forEach((element, index) => {
                const computedStyle = styles[index];
                if (computedStyle.display === 'none' ||
                    computedStyle.visibility === 'hidden' ||
                    computedStyle.opacity === '0') {
                    elementsToRemove.add(element);
                    count++;
                }
            });
        }
        // Final pass: Batch remove all hidden elements
        elementsToRemove.forEach(el => el.remove());
        this._log('Removed hidden elements:', count);
    }
    removeClutter(doc) {
        const startTime = performance.now();
        let exactSelectorCount = 0;
        let partialSelectorCount = 0;
        // Track all elements to be removed
        const elementsToRemove = new Set();
        // First collect elements matching exact selectors
        const exactElements = doc.querySelectorAll(constants_1.EXACT_SELECTORS.join(','));
        exactElements.forEach(el => {
            if (el === null || el === void 0 ? void 0 : el.parentNode) {
                elementsToRemove.add(el);
                exactSelectorCount++;
            }
        });
        // Pre-compile regexes and combine into a single regex for better performance
        const combinedPattern = constants_1.PARTIAL_SELECTORS.join('|');
        const partialRegex = new RegExp(combinedPattern, 'i');
        // Create an efficient attribute selector for elements we care about
        const attributeSelector = '[class],[id],[data-testid],[data-qa],[data-cy]';
        const allElements = doc.querySelectorAll(attributeSelector);
        // Process elements for partial matches
        allElements.forEach(el => {
            // Skip if already marked for removal
            if (elementsToRemove.has(el)) {
                return;
            }
            // Get all relevant attributes and combine into a single string
            const attrs = [
                el.className && typeof el.className === 'string' ? el.className : '',
                el.id || '',
                el.getAttribute('data-testid') || '',
                el.getAttribute('data-qa') || '',
                el.getAttribute('data-cy') || ''
            ].join(' ').toLowerCase();
            // Skip if no attributes to check
            if (!attrs.trim()) {
                return;
            }
            // Check for partial match using single regex test
            if (partialRegex.test(attrs)) {
                elementsToRemove.add(el);
                partialSelectorCount++;
            }
        });
        // Remove all collected elements in a single pass
        elementsToRemove.forEach(el => el.remove());
        const endTime = performance.now();
        this._log('Removed clutter elements:', {
            exactSelectors: exactSelectorCount,
            partialSelectors: partialSelectorCount,
            total: elementsToRemove.size,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    flattenDivs(element) {
        let processedCount = 0;
        const startTime = performance.now();
        // Process in batches to maintain performance
        let keepProcessing = true;
        const shouldPreserveElement = (el) => {
            const tagName = el.tagName.toLowerCase();
            // Check if element should be preserved
            if (constants_1.PRESERVE_ELEMENTS.has(tagName))
                return true;
            // Check for semantic roles
            const role = el.getAttribute('role');
            if (role && ['article', 'main', 'navigation', 'banner', 'contentinfo'].includes(role)) {
                return true;
            }
            // Check for semantic classes
            const className = el.className.toLowerCase();
            if (className.match(/(?:article|main|content|footnote|reference|bibliography)/)) {
                return true;
            }
            // Check if div contains mixed content types that should be preserved
            if (tagName === 'div') {
                const children = Array.from(el.children);
                const hasPreservedElements = children.some(child => constants_1.PRESERVE_ELEMENTS.has(child.tagName.toLowerCase()) ||
                    child.getAttribute('role') === 'article' ||
                    child.className.toLowerCase().includes('article'));
                if (hasPreservedElements)
                    return true;
            }
            return false;
        };
        const isWrapperDiv = (div) => {
            var _a;
            // Check if it's just empty space
            if (!((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim()))
                return true;
            // Check if it only contains other divs or block elements
            const children = Array.from(div.children);
            if (children.length === 0)
                return true;
            // Check if all children are block elements
            const allBlockElements = children.every(child => {
                const tag = child.tagName.toLowerCase();
                return tag === 'div' || tag === 'p' || tag === 'h1' || tag === 'h2' ||
                    tag === 'h3' || tag === 'h4' || tag === 'h5' || tag === 'h6' ||
                    tag === 'ul' || tag === 'ol' || tag === 'pre' || tag === 'blockquote' ||
                    tag === 'figure';
            });
            if (allBlockElements)
                return true;
            // Check for common wrapper patterns
            const className = div.className.toLowerCase();
            const isWrapper = /(?:wrapper|container|layout|row|col|grid|flex|outer|inner|content-area)/i.test(className);
            if (isWrapper)
                return true;
            // Check if it has excessive whitespace or empty text nodes
            const textNodes = Array.from(div.childNodes).filter(node => { var _a; return node.nodeType === Node.TEXT_NODE && ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.trim()); });
            if (textNodes.length === 0)
                return true;
            // Check if it's a div that only contains block elements
            const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                const tag = child.tagName.toLowerCase();
                return constants_1.INLINE_ELEMENTS.has(tag);
            });
            if (hasOnlyBlockElements)
                return true;
            return false;
        };
        // Function to process a single div
        const processDiv = (div) => {
            var _a, _b;
            // Skip processing if div has been removed or should be preserved
            if (!div.isConnected || shouldPreserveElement(div))
                return false;
            // Case 1: Empty div or div with only whitespace
            if (!div.hasChildNodes() || !((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim())) {
                div.remove();
                processedCount++;
                return true;
            }
            // Case 2: Top-level div - be more aggressive
            if (div.parentElement === element) {
                const children = Array.from(div.children);
                const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (hasOnlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
            }
            // Case 3: Wrapper div - merge up aggressively
            if (isWrapperDiv(div)) {
                // Special case: if div only contains block elements, merge them up
                const children = Array.from(div.children);
                const onlyBlockElements = !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (onlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
                // Otherwise handle as normal wrapper
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            // Case 4: Div only contains text content - convert to paragraph
            if (!div.children.length && ((_b = div.textContent) === null || _b === void 0 ? void 0 : _b.trim())) {
                const p = document.createElement('p');
                p.textContent = div.textContent;
                div.replaceWith(p);
                processedCount++;
                return true;
            }
            // Case 5: Div has single child
            if (div.children.length === 1) {
                const child = div.firstElementChild;
                const childTag = child.tagName.toLowerCase();
                // Don't unwrap if child is inline or should be preserved
                if (!constants_1.INLINE_ELEMENTS.has(childTag) && !shouldPreserveElement(child)) {
                    div.replaceWith(child);
                    processedCount++;
                    return true;
                }
            }
            // Case 6: Deeply nested div - merge up
            let nestingDepth = 0;
            let parent = div.parentElement;
            while (parent) {
                if (parent.tagName.toLowerCase() === 'div') {
                    nestingDepth++;
                }
                parent = parent.parentElement;
            }
            if (nestingDepth > 0) { // Changed from > 1 to > 0 to be more aggressive
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            return false;
        };
        // First pass: Process top-level divs
        const processTopLevelDivs = () => {
            const topDivs = Array.from(element.children).filter(el => el.tagName.toLowerCase() === 'div');
            let modified = false;
            topDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Second pass: Process remaining divs from deepest to shallowest
        const processRemainingDivs = () => {
            const allDivs = Array.from(element.getElementsByTagName('div'))
                .sort((a, b) => {
                // Count nesting depth
                const getDepth = (el) => {
                    let depth = 0;
                    let parent = el.parentElement;
                    while (parent) {
                        if (parent.tagName.toLowerCase() === 'div')
                            depth++;
                        parent = parent.parentElement;
                    }
                    return depth;
                };
                return getDepth(b) - getDepth(a); // Process deepest first
            });
            let modified = false;
            allDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Final cleanup pass - aggressively flatten remaining divs
        const finalCleanup = () => {
            const remainingDivs = Array.from(element.getElementsByTagName('div'));
            let modified = false;
            remainingDivs.forEach(div => {
                // Check if div only contains paragraphs
                const children = Array.from(div.children);
                const onlyParagraphs = children.every(child => child.tagName.toLowerCase() === 'p');
                if (onlyParagraphs || (!shouldPreserveElement(div) && isWrapperDiv(div))) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    modified = true;
                }
            });
            return modified;
        };
        // Execute all passes until no more changes
        do {
            keepProcessing = false;
            if (processTopLevelDivs())
                keepProcessing = true;
            if (processRemainingDivs())
                keepProcessing = true;
            if (finalCleanup())
                keepProcessing = true;
        } while (keepProcessing);
        const endTime = performance.now();
        this._log('Flattened divs:', {
            count: processedCount,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    cleanContent(element, metadata) {
        // Remove HTML comments
        this.removeHtmlComments(element);
        // Handle H1 elements - remove first one and convert others to H2
        this.handleHeadings(element, metadata.title);
        // Standardize footnotes and citations
        this.standardizeFootnotes(element);
        // Handle lazy-loaded images
        this.handleLazyImages(element);
        // Convert embedded content to standard formats
        this.standardizeElements(element);
        // Skip div flattening in debug mode
        if (!this.debug) {
            // First pass of div flattening
            this.flattenDivs(element);
            // Strip unwanted attributes
            this.stripUnwantedAttributes(element);
            // Remove empty elements
            this.removeEmptyElements(element);
            // Remove trailing headings
            this.removeTrailingHeadings(element);
            // Final pass of div flattening after cleanup operations
            this.flattenDivs(element);
        }
        else {
            // In debug mode, still do basic cleanup but preserve structure
            this.stripUnwantedAttributes(element);
            this.removeEmptyElements(element);
            this.removeTrailingHeadings(element);
            this._log('Debug mode: Skipping div flattening to preserve structure');
        }
    }
    removeTrailingHeadings(element) {
        let removedCount = 0;
        const hasContentAfter = (el) => {
            // Check if there's any meaningful content after this element
            let nextContent = '';
            let sibling = el.nextSibling;
            // First check direct siblings
            while (sibling) {
                if (sibling.nodeType === Node.TEXT_NODE) {
                    nextContent += sibling.textContent || '';
                }
                else if (sibling.nodeType === Node.ELEMENT_NODE) {
                    // If we find an element sibling, check its content
                    nextContent += sibling.textContent || '';
                }
                sibling = sibling.nextSibling;
            }
            // If we found meaningful content at this level, return true
            if (nextContent.trim()) {
                return true;
            }
            // If no content found at this level and we have a parent,
            // check for content after the parent
            const parent = el.parentElement;
            if (parent && parent !== element) {
                return hasContentAfter(parent);
            }
            return false;
        };
        // Process all headings from bottom to top
        const headings = Array.from(element.querySelectorAll('h1, h2, h3, h4, h5, h6'))
            .reverse();
        headings.forEach(heading => {
            if (!hasContentAfter(heading)) {
                heading.remove();
                removedCount++;
            }
            else {
                // Stop processing once we find a heading with content after it
                return;
            }
        });
        if (removedCount > 0) {
            this._log('Removed trailing headings:', removedCount);
        }
    }
    handleHeadings(element, title) {
        var _a;
        const h1s = element.getElementsByTagName('h1');
        Array.from(h1s).forEach(h1 => {
            var _a;
            const h2 = document.createElement('h2');
            h2.innerHTML = h1.innerHTML;
            // Copy allowed attributes
            Array.from(h1.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    h2.setAttribute(attr.name, attr.value);
                }
            });
            (_a = h1.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(h2, h1);
        });
        // Remove first H2 if it matches title
        const h2s = element.getElementsByTagName('h2');
        if (h2s.length > 0) {
            const firstH2 = h2s[0];
            const firstH2Text = ((_a = firstH2.textContent) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) || '';
            const normalizedTitle = title.toLowerCase().trim();
            if (normalizedTitle && normalizedTitle === firstH2Text) {
                firstH2.remove();
            }
        }
    }
    removeHtmlComments(element) {
        const comments = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_COMMENT, null);
        let node;
        while (node = walker.nextNode()) {
            comments.push(node);
        }
        comments.forEach(comment => {
            comment.remove();
        });
        this._log('Removed HTML comments:', comments.length);
    }
    stripUnwantedAttributes(element) {
        let attributeCount = 0;
        const processElement = (el) => {
            // Skip SVG elements - preserve all their attributes
            if (el instanceof SVGElement) {
                return;
            }
            const attributes = Array.from(el.attributes);
            attributes.forEach(attr => {
                const attrName = attr.name.toLowerCase();
                // In debug mode, allow debug attributes and data- attributes
                if (this.debug) {
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName) &&
                        !constants_1.ALLOWED_ATTRIBUTES_DEBUG.has(attrName) &&
                        !attrName.startsWith('data-')) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
                else {
                    // In normal mode, only allow standard attributes
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName)) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
            });
        };
        processElement(element);
        element.querySelectorAll('*').forEach(processElement);
        this._log('Stripped attributes:', attributeCount);
    }
    removeEmptyElements(element) {
        let removedCount = 0;
        let iterations = 0;
        let keepRemoving = true;
        while (keepRemoving) {
            iterations++;
            keepRemoving = false;
            // Get all elements without children, working from deepest first
            const emptyElements = Array.from(element.getElementsByTagName('*')).filter(el => {
                if (constants_1.ALLOWED_EMPTY_ELEMENTS.has(el.tagName.toLowerCase())) {
                    return false;
                }
                // Check if element has only whitespace or &nbsp;
                const textContent = el.textContent || '';
                const hasOnlyWhitespace = textContent.trim().length === 0;
                const hasNbsp = textContent.includes('\u00A0'); // Unicode non-breaking space
                // Check if element has no meaningful children
                const hasNoChildren = !el.hasChildNodes() ||
                    (Array.from(el.childNodes).every(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            const nodeText = node.textContent || '';
                            return nodeText.trim().length === 0 && !nodeText.includes('\u00A0');
                        }
                        return false;
                    }));
                // Special case: Check for divs that only contain spans with commas
                if (el.tagName.toLowerCase() === 'div') {
                    const children = Array.from(el.children);
                    const hasOnlyCommaSpans = children.length > 0 && children.every(child => {
                        var _a;
                        if (child.tagName.toLowerCase() !== 'span')
                            return false;
                        const content = ((_a = child.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        return content === ',' || content === '' || content === ' ';
                    });
                    if (hasOnlyCommaSpans)
                        return true;
                }
                return hasOnlyWhitespace && !hasNbsp && hasNoChildren;
            });
            if (emptyElements.length > 0) {
                emptyElements.forEach(el => {
                    el.remove();
                    removedCount++;
                });
                keepRemoving = true;
            }
        }
        this._log('Removed empty elements:', {
            count: removedCount,
            iterations
        });
    }
    createFootnoteItem(footnoteNumber, content, refs) {
        const newItem = document.createElement('li');
        newItem.className = 'footnote';
        newItem.id = `fn:${footnoteNumber}`;
        // Handle content
        if (typeof content === 'string') {
            const paragraph = document.createElement('p');
            paragraph.innerHTML = content;
            newItem.appendChild(paragraph);
        }
        else {
            // Get all paragraphs from the content
            const paragraphs = Array.from(content.querySelectorAll('p'));
            if (paragraphs.length === 0) {
                // If no paragraphs, wrap content in a paragraph
                const paragraph = document.createElement('p');
                paragraph.innerHTML = content.innerHTML;
                newItem.appendChild(paragraph);
            }
            else {
                // Copy existing paragraphs
                paragraphs.forEach(p => {
                    const newP = document.createElement('p');
                    newP.innerHTML = p.innerHTML;
                    newItem.appendChild(newP);
                });
            }
        }
        // Add backlink(s) to the last paragraph
        const lastParagraph = newItem.querySelector('p:last-of-type') || newItem;
        refs.forEach((refId, index) => {
            const backlink = document.createElement('a');
            backlink.href = `#${refId}`;
            backlink.title = 'return to article';
            backlink.className = 'footnote-backref';
            backlink.innerHTML = '↩';
            if (index < refs.length - 1) {
                backlink.innerHTML += ' ';
            }
            lastParagraph.appendChild(backlink);
        });
        return newItem;
    }
    collectFootnotes(element) {
        const footnotes = {};
        let footnoteCount = 1;
        const processedIds = new Set(); // Track processed IDs
        // Collect all footnotes and their IDs from footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => {
            // Substack has individual footnote divs with no parent
            if (list.matches('div.footnote[data-component-name="FootnoteToDOM"]')) {
                const anchor = list.querySelector('a.footnote-number');
                const content = list.querySelector('.footnote-content');
                if (anchor && content) {
                    const id = anchor.id.replace('footnote-', '').toLowerCase();
                    if (id && !processedIds.has(id)) {
                        footnotes[footnoteCount] = {
                            content: content,
                            originalId: id,
                            refs: []
                        };
                        processedIds.add(id);
                        footnoteCount++;
                    }
                }
                return;
            }
            // Common format using OL/UL and LI elements
            const items = list.querySelectorAll('li, div[role="listitem"]');
            items.forEach(li => {
                var _a, _b, _c, _d;
                let id = '';
                let content = null;
                // Handle citations with .citations class
                const citationsDiv = li.querySelector('.citations');
                if ((_a = citationsDiv === null || citationsDiv === void 0 ? void 0 : citationsDiv.id) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith('r')) {
                    id = citationsDiv.id.toLowerCase();
                    // Look for citation content within the citations div
                    const citationContent = citationsDiv.querySelector('.citation-content');
                    if (citationContent) {
                        content = citationContent;
                    }
                }
                else {
                    // Extract ID from various formats
                    if (li.id.toLowerCase().startsWith('bib.bib')) {
                        id = li.id.replace('bib.bib', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn:')) {
                        id = li.id.replace('fn:', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn')) {
                        id = li.id.replace('fn', '').toLowerCase();
                        // Nature.com
                    }
                    else if (li.hasAttribute('data-counter')) {
                        id = ((_c = (_b = li.getAttribute('data-counter')) === null || _b === void 0 ? void 0 : _b.replace(/\.$/, '')) === null || _c === void 0 ? void 0 : _c.toLowerCase()) || '';
                    }
                    else {
                        const match = (_d = li.id.split('/').pop()) === null || _d === void 0 ? void 0 : _d.match(/cite_note-(.+)/);
                        id = match ? match[1].toLowerCase() : li.id.toLowerCase();
                    }
                    content = li;
                }
                if (id && !processedIds.has(id)) {
                    footnotes[footnoteCount] = {
                        content: content || li,
                        originalId: id,
                        refs: []
                    };
                    processedIds.add(id);
                    footnoteCount++;
                }
            });
        });
        return footnotes;
    }
    findOuterFootnoteContainer(el) {
        let current = el;
        let parent = el.parentElement;
        // Keep going up until we find an element that's not a span or sup
        while (parent && (parent.tagName.toLowerCase() === 'span' ||
            parent.tagName.toLowerCase() === 'sup')) {
            current = parent;
            parent = parent.parentElement;
        }
        return current;
    }
    // Every footnote reference should be a sup element with an anchor inside
    // e.g. <sup id="fnref:1"><a href="#fn:1">1</a></sup>
    createFootnoteReference(footnoteNumber, refId) {
        const sup = document.createElement('sup');
        sup.id = refId;
        const link = document.createElement('a');
        link.href = `#fn:${footnoteNumber}`;
        link.textContent = footnoteNumber;
        sup.appendChild(link);
        return sup;
    }
    standardizeFootnotes(element) {
        const footnotes = this.collectFootnotes(element);
        // Standardize inline footnotes using the collected IDs
        const footnoteInlineReferences = element.querySelectorAll(constants_1.FOOTNOTE_INLINE_REFERENCES);
        // Group references by their parent sup element
        const supGroups = new Map();
        footnoteInlineReferences.forEach(el => {
            var _a, _b, _c, _d;
            if (!(el instanceof HTMLElement))
                return;
            let footnoteId = '';
            let footnoteContent = '';
            // Extract footnote ID based on element type
            // Nature.com
            if (el.matches('a[id^="ref-link"]')) {
                footnoteId = ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                // Science.org
            }
            else if (el.matches('a[role="doc-biblioref"]')) {
                const xmlRid = el.getAttribute('data-xml-rid');
                if (xmlRid) {
                    footnoteId = xmlRid;
                }
                else {
                    const href = el.getAttribute('href');
                    if (href === null || href === void 0 ? void 0 : href.startsWith('#core-R')) {
                        footnoteId = href.replace('#core-', '');
                    }
                }
                // Substack
            }
            else if (el.matches('a.footnote-anchor, span.footnote-hovercard-target a')) {
                const id = ((_b = el.id) === null || _b === void 0 ? void 0 : _b.replace('footnote-anchor-', '')) || '';
                if (id) {
                    footnoteId = id.toLowerCase();
                }
                // Arxiv
            }
            else if (el.matches('cite.ltx_cite')) {
                const link = el.querySelector('a');
                if (link) {
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_c = href.split('/').pop()) === null || _c === void 0 ? void 0 : _c.match(/bib\.bib(\d+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                }
            }
            else if (el.matches('sup.reference')) {
                const links = el.querySelectorAll('a');
                Array.from(links).forEach(link => {
                    var _a;
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_a = href.split('/').pop()) === null || _a === void 0 ? void 0 : _a.match(/(?:cite_note|cite_ref)-(.+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                });
            }
            else if (el.matches('sup[id^="fnref:"]')) {
                footnoteId = el.id.replace('fnref:', '').toLowerCase();
            }
            else if (el.matches('sup[id^="fnr"]')) {
                footnoteId = el.id.replace('fnr', '').toLowerCase();
            }
            else if (el.matches('span.footnote-reference')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
            }
            else if (el.matches('span.footnote-link')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
                footnoteContent = el.getAttribute('data-footnote-content') || '';
            }
            else if (el.matches('a.citation')) {
                footnoteId = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                footnoteContent = el.getAttribute('href') || '';
            }
            else if (el.matches('a[id^="fnref"]')) {
                footnoteId = el.id.replace('fnref', '').toLowerCase();
            }
            else {
                // Other citation types
                const href = el.getAttribute('href');
                if (href) {
                    const id = href.replace(/^[#]/, '');
                    footnoteId = id.toLowerCase();
                }
            }
            if (footnoteId) {
                // Find the footnote number by matching the original ID
                const footnoteEntry = Object.entries(footnotes).find(([_, data]) => data.originalId === footnoteId.toLowerCase());
                if (footnoteEntry) {
                    const [footnoteNumber, footnoteData] = footnoteEntry;
                    // Create footnote reference ID
                    const refId = footnoteData.refs.length > 0 ?
                        `fnref:${footnoteNumber}-${footnoteData.refs.length + 1}` :
                        `fnref:${footnoteNumber}`;
                    footnoteData.refs.push(refId);
                    // Find the outermost container (span or sup)
                    const container = this.findOuterFootnoteContainer(el);
                    // If container is a sup, group references
                    if (container.tagName.toLowerCase() === 'sup') {
                        if (!supGroups.has(container)) {
                            supGroups.set(container, []);
                        }
                        const group = supGroups.get(container);
                        group.push(this.createFootnoteReference(footnoteNumber, refId));
                    }
                    else {
                        // Replace the container directly
                        container.replaceWith(this.createFootnoteReference(footnoteNumber, refId));
                    }
                }
            }
        });
        // Handle grouped references
        supGroups.forEach((references, container) => {
            if (references.length > 0) {
                // Create a document fragment to hold all the references
                const fragment = document.createDocumentFragment();
                // Add each reference as its own sup element
                references.forEach((ref, index) => {
                    const link = ref.querySelector('a');
                    if (link) {
                        const sup = document.createElement('sup');
                        sup.id = ref.id;
                        sup.appendChild(link.cloneNode(true));
                        fragment.appendChild(sup);
                    }
                });
                container.replaceWith(fragment);
            }
        });
        // Create the standardized footnote list
        const newList = document.createElement('footnotes');
        newList.className = 'footnotes';
        const orderedList = document.createElement('ol');
        // Create footnote items in order
        Object.entries(footnotes).forEach(([number, data]) => {
            const newItem = this.createFootnoteItem(parseInt(number), data.content, data.refs);
            orderedList.appendChild(newItem);
        });
        // Remove original footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => list.remove());
        // If we have any footnotes, add the new list to the document
        if (orderedList.children.length > 0) {
            newList.appendChild(orderedList);
            element.appendChild(newList);
        }
    }
    handleLazyImages(element) {
        let processedCount = 0;
        const lazyImages = element.querySelectorAll('img[data-src], img[data-srcset]');
        lazyImages.forEach(img => {
            if (!(img instanceof HTMLImageElement))
                return;
            // Handle data-src
            const dataSrc = img.getAttribute('data-src');
            if (dataSrc && !img.src) {
                img.src = dataSrc;
                processedCount++;
            }
            // Handle data-srcset
            const dataSrcset = img.getAttribute('data-srcset');
            if (dataSrcset && !img.srcset) {
                img.srcset = dataSrcset;
                processedCount++;
            }
            // Remove lazy loading related classes and attributes
            img.classList.remove('lazy', 'lazyload');
            img.removeAttribute('data-ll-status');
            img.removeAttribute('data-src');
            img.removeAttribute('data-srcset');
        });
        this._log('Processed lazy images:', processedCount);
    }
    standardizeElements(element) {
        let processedCount = 0;
        // Convert elements based on standardization rules
        ELEMENT_STANDARDIZATION_RULES.forEach(rule => {
            const elements = element.querySelectorAll(rule.selector);
            elements.forEach(el => {
                if (rule.transform) {
                    // If there's a transform function, use it to create the new element
                    const transformed = rule.transform(el);
                    el.replaceWith(transformed);
                    processedCount++;
                }
            });
        });
        // Convert lite-youtube elements
        const liteYoutubeElements = element.querySelectorAll('lite-youtube');
        liteYoutubeElements.forEach(el => {
            const videoId = el.getAttribute('videoid');
            if (!videoId)
                return;
            const iframe = document.createElement('iframe');
            iframe.width = '560';
            iframe.height = '315';
            iframe.src = `https://www.youtube.com/embed/${videoId}`;
            iframe.title = el.getAttribute('videotitle') || 'YouTube video player';
            iframe.frameBorder = '0';
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.setAttribute('allowfullscreen', '');
            el.replaceWith(iframe);
            processedCount++;
        });
        this._log('Converted embedded elements:', processedCount);
    }
    // Find small IMG and SVG elements
    findSmallImages(doc) {
        const MIN_DIMENSION = 33;
        const smallImages = new Set();
        const transformRegex = /scale\(([\d.]+)\)/;
        const startTime = performance.now();
        let processedCount = 0;
        // 1. Read phase - Gather all elements in a single pass
        const elements = [
            ...Array.from(doc.getElementsByTagName('img')),
            ...Array.from(doc.getElementsByTagName('svg'))
        ].filter(element => {
            // Skip lazy-loaded images that haven't been processed yet
            // and math images which may be small
            if (element instanceof HTMLImageElement) {
                const ignoredImage = element.classList.contains('lazy') ||
                    element.classList.contains('lazyload') ||
                    element.classList.contains('latex') ||
                    element.hasAttribute('decoding') ||
                    element.hasAttribute('data-src') ||
                    element.hasAttribute('data-srcset');
                return !ignoredImage;
            }
            return true;
        });
        if (elements.length === 0) {
            return smallImages;
        }
        // 2. Batch process - Collect all measurements in one go
        const measurements = elements.map(element => ({
            element,
            // Static attributes (no reflow)
            naturalWidth: element instanceof HTMLImageElement ? element.naturalWidth : 0,
            naturalHeight: element instanceof HTMLImageElement ? element.naturalHeight : 0,
            attrWidth: parseInt(element.getAttribute('width') || '0'),
            attrHeight: parseInt(element.getAttribute('height') || '0')
        }));
        // 3. Batch compute styles - Process in chunks to avoid long tasks
        const BATCH_SIZE = 50;
        for (let i = 0; i < measurements.length; i += BATCH_SIZE) {
            const batch = measurements.slice(i, i + BATCH_SIZE);
            try {
                // Read phase - compute all styles at once
                const styles = batch.map(({ element }) => window.getComputedStyle(element));
                const rects = batch.map(({ element }) => element.getBoundingClientRect());
                // Process phase - no DOM operations
                batch.forEach((measurement, index) => {
                    var _a;
                    try {
                        const style = styles[index];
                        const rect = rects[index];
                        // Get transform scale in the same batch
                        const transform = style.transform;
                        const scale = transform ?
                            parseFloat(((_a = transform.match(transformRegex)) === null || _a === void 0 ? void 0 : _a[1]) || '1') : 1;
                        // Calculate effective dimensions
                        const widths = [
                            measurement.naturalWidth,
                            measurement.attrWidth,
                            parseInt(style.width) || 0,
                            rect.width * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        const heights = [
                            measurement.naturalHeight,
                            measurement.attrHeight,
                            parseInt(style.height) || 0,
                            rect.height * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        // Decision phase - no DOM operations
                        if (widths.length > 0 && heights.length > 0) {
                            const effectiveWidth = Math.min(...widths);
                            const effectiveHeight = Math.min(...heights);
                            if (effectiveWidth < MIN_DIMENSION || effectiveHeight < MIN_DIMENSION) {
                                const identifier = this.getElementIdentifier(measurement.element);
                                if (identifier) {
                                    smallImages.add(identifier);
                                    processedCount++;
                                }
                            }
                        }
                    }
                    catch (e) {
                        if (this.debug) {
                            console.warn('Defuddle: Failed to process element dimensions:', e);
                        }
                    }
                });
            }
            catch (e) {
                if (this.debug) {
                    console.warn('Defuddle: Failed to process batch:', e);
                }
            }
        }
        const endTime = performance.now();
        this._log('Found small elements:', {
            count: processedCount,
            totalElements: elements.length,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        return smallImages;
    }
    removeSmallImages(doc, smallImages) {
        let removedCount = 0;
        ['img', 'svg'].forEach(tag => {
            const elements = doc.getElementsByTagName(tag);
            Array.from(elements).forEach(element => {
                const identifier = this.getElementIdentifier(element);
                if (identifier && smallImages.has(identifier)) {
                    element.remove();
                    removedCount++;
                }
            });
        });
        this._log('Removed small elements:', removedCount);
    }
    getElementIdentifier(element) {
        // Try to create a unique identifier using various attributes
        if (element instanceof HTMLImageElement) {
            // For lazy-loaded images, use data-src as identifier if available
            const dataSrc = element.getAttribute('data-src');
            if (dataSrc)
                return `src:${dataSrc}`;
            const src = element.src || '';
            const srcset = element.srcset || '';
            const dataSrcset = element.getAttribute('data-srcset');
            if (src)
                return `src:${src}`;
            if (srcset)
                return `srcset:${srcset}`;
            if (dataSrcset)
                return `srcset:${dataSrcset}`;
        }
        const id = element.id || '';
        const className = element.className || '';
        const viewBox = element instanceof SVGElement ? element.getAttribute('viewBox') || '' : '';
        if (id)
            return `id:${id}`;
        if (viewBox)
            return `viewBox:${viewBox}`;
        if (className)
            return `class:${className}`;
        return null;
    }
    findMainContent(doc) {
        // Find all potential content containers
        const candidates = [];
        constants_1.ENTRY_POINT_ELEMENTS.forEach((selector, index) => {
            const elements = doc.querySelectorAll(selector);
            elements.forEach(element => {
                // Base score from selector priority (earlier = higher)
                let score = (constants_1.ENTRY_POINT_ELEMENTS.length - index) * 10;
                // Add score based on content analysis
                score += this.scoreElement(element);
                candidates.push({ element, score });
            });
        });
        if (candidates.length === 0) {
            // Fall back to scoring block elements
            // Currently <body> element is used as the fallback, so this is not used
            return this.findContentByScoring(doc);
        }
        // Sort by score descending
        candidates.sort((a, b) => b.score - a.score);
        if (this.debug) {
            this._log('Content candidates:', candidates.map(c => ({
                element: c.element.tagName,
                selector: this.getElementSelector(c.element),
                score: c.score
            })));
        }
        return candidates[0].element;
    }
    findContentByScoring(doc) {
        const candidates = this.scoreElements(doc);
        return candidates.length > 0 ? candidates[0].element : null;
    }
    getElementSelector(element) {
        const parts = [];
        let current = element;
        while (current && current !== this.doc.documentElement) {
            let selector = current.tagName.toLowerCase();
            if (current.id) {
                selector += '#' + current.id;
            }
            else if (current.className && typeof current.className === 'string') {
                selector += '.' + current.className.trim().split(/\s+/).join('.');
            }
            parts.unshift(selector);
            current = current.parentElement;
        }
        return parts.join(' > ');
    }
    scoreElements(doc) {
        const candidates = [];
        constants_1.BLOCK_ELEMENTS.forEach((tag) => {
            Array.from(doc.getElementsByTagName(tag)).forEach((element) => {
                const score = this.scoreElement(element);
                if (score > 0) {
                    candidates.push({ score, element });
                }
            });
        });
        return candidates.sort((a, b) => b.score - a.score);
    }
    scoreElement(element) {
        let score = 0;
        // Score based on element properties
        const className = element.className && typeof element.className === 'string' ?
            element.className.toLowerCase() : '';
        const id = element.id ? element.id.toLowerCase() : '';
        // Score based on content
        const text = element.textContent || '';
        const words = text.split(/\s+/).length;
        score += Math.min(Math.floor(words / 100), 3);
        // Score based on link density
        const links = element.getElementsByTagName('a');
        const linkText = Array.from(links).reduce((acc, link) => { var _a; return acc + (((_a = link.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0); }, 0);
        const linkDensity = text.length ? linkText / text.length : 0;
        if (linkDensity > 0.5) {
            score -= 10;
        }
        // Score based on presence of meaningful elements
        const paragraphs = element.getElementsByTagName('p').length;
        score += paragraphs;
        const images = element.getElementsByTagName('img').length;
        score += Math.min(images * 3, 9);
        return score;
    }
}
exports.Defuddle = Defuddle;


/***/ }),

/***/ 640:
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SUPPORTED_LANGUAGES = exports.ALLOWED_ATTRIBUTES_DEBUG = exports.ALLOWED_ATTRIBUTES = exports.ALLOWED_EMPTY_ELEMENTS = exports.FOOTNOTE_LIST_SELECTORS = exports.FOOTNOTE_INLINE_REFERENCES = exports.PARTIAL_SELECTORS = exports.EXACT_SELECTORS = exports.HIDDEN_ELEMENT_SELECTORS = exports.INLINE_ELEMENTS = exports.PRESERVE_ELEMENTS = exports.BLOCK_ELEMENTS = exports.MOBILE_WIDTH = exports.ENTRY_POINT_ELEMENTS = void 0;
// Entry point elements
// These are the elements that will be used to find the main content
exports.ENTRY_POINT_ELEMENTS = [
    'article',
    '[role="article"]',
    '.post-content',
    '.article-content',
    '#article-content',
    '.content-article',
    'main',
    '[role="main"]',
    'body' // ensures there is always a match
];
exports.MOBILE_WIDTH = 600;
exports.BLOCK_ELEMENTS = ['div', 'section', 'article', 'main'];
// Elements that should not be unwrapped
exports.PRESERVE_ELEMENTS = new Set([
    'pre', 'code', 'table', 'thead', 'tbody', 'tr', 'td', 'th',
    'ul', 'ol', 'li', 'dl', 'dt', 'dd',
    'figure', 'figcaption', 'picture',
    'details', 'summary',
    'blockquote',
    'form', 'fieldset'
]);
// Inline elements that should not be unwrapped
exports.INLINE_ELEMENTS = new Set([
    'a', 'span', 'strong', 'em', 'i', 'b', 'u', 'code', 'br', 'small',
    'sub', 'sup', 'mark', 'del', 'ins', 'q', 'abbr', 'cite', 'time'
]);
// Hidden elements that should be removed
exports.HIDDEN_ELEMENT_SELECTORS = [
    '[hidden]',
    //	'[aria-hidden="true"]', needed for math formulas
    //	'[style*="display: none"]', needed for for math formulas
    //	'[style*="display:none"]',
    '[style*="visibility: hidden"]',
    '[style*="visibility:hidden"]',
    '.hidden',
    '.invisible'
].join(',');
// Selectors to be removed
exports.EXACT_SELECTORS = [
    // scripts, styles
    'noscript',
    'script',
    'style',
    // ads
    '.ad:not([class*="gradient"])',
    '[class^="ad-" i]',
    '[class$="-ad" i]',
    '[id^="ad-" i]',
    '[id$="-ad" i]',
    '[role="banner" i]',
    '.promo',
    '.Promo',
    '#barrier-page', // ft.com
    // comments
    '[id="comments" i]',
    // header, nav
    'header',
    '.header',
    '#header',
    'nav',
    '.navigation',
    '#navigation',
    '[role="navigation" i]',
    '[role="dialog" i]',
    '[role*="complementary" i]',
    '[class*="pagination" i]',
    '.menu',
    '#menu',
    '#siteSub',
    // metadata
    '.author',
    '.Author',
    '.contributor',
    '.date',
    '.meta',
    '.tags',
    '.toc',
    '.Toc',
    '#toc',
    '#title',
    '#Title',
    '[href*="/category"]',
    '[href*="/categories"]',
    '[href*="/tag/"]',
    '[href*="/tags/"]',
    '[href*="/topics"]',
    '[href*="author"]',
    '[href="#site-content"]',
    '[src*="author"]',
    // footer
    'footer',
    // inputs, forms, elements
    'aside',
    'button',
    // '[role="button"]', Medium images
    'canvas',
    'dialog',
    'fieldset',
    'form',
    'input:not([type="checkbox"])',
    'label',
    'link',
    'option',
    'select',
    'textarea',
    'time',
    // iframes
    'instaread-player',
    'iframe:not([src*="youtube"]):not([src*="youtu.be"]):not([src*="vimeo"]):not([src*="twitter"])',
    // logos
    '[class="logo" i]',
    '#logo',
    '#Logo',
    // newsletter
    '#newsletter',
    '#Newsletter',
    // hidden for print
    '.noprint',
    '[data-link-name*="skip" i]',
    '[data-print-layout="hide" i]',
    '[data-block="donotprint" i]',
    // footnotes, citations
    '[class*="clickable-icon" i]',
    'li span[class*="ltx_tag" i][class*="ltx_tag_item" i]',
    'a[href^="#"][class*="anchor" i]',
    'a[href^="#"][class*="ref" i]',
    // link lists
    '[data-container*="most-viewed" i]',
    // sidebar
    '.sidebar',
    '.Sidebar',
    '#sidebar',
    '#Sidebar',
    '#sitesub',
    // other
    '#primaryaudio', // NPR
    '#NYT_ABOVE_MAIN_CONTENT_REGION',
    '[data-testid="photoviewer-children-figure"] > span', // New York Times
    'table.infobox',
    '.pencraft:not(.pc-display-contents)', // Substack
    '[data-optimizely="related-articles-section" i]' // The Economist
];
// Removal patterns tested against attributes: class, id, data-testid, and data-qa
// Case insensitive, partial matches allowed
exports.PARTIAL_SELECTORS = [
    'access-wall',
    'activitypub',
    'actioncall',
    'appendix',
    'avatar',
    'advert',
    '-ad-',
    '_ad_',
    'allterms',
    'around-the-web',
    'article-bottom-section',
    'article__copy',
    'article_date',
    'article-end ',
    'article_header',
    'article__header',
    'article__info',
    'article-info',
    'article__meta',
    'article-subject',
    'article_subject',
    'article-snippet',
    'article-separator',
    'article--share',
    'article--topics',
    'articletags',
    'article-tags',
    'article_tags',
    'article-title',
    'article_title',
    'articletopics',
    'article-topics',
    'article-type',
    'article--lede', // The Verge
    'articlewell',
    'associated-people',
    'audio-card',
    //	'author', Gwern
    'authored-by',
    'author-box',
    'author-name',
    'author-bio',
    'author-mini-bio',
    'back-to-top',
    'backlinks-section',
    'banner',
    'bio-block',
    'blog-pager',
    'bookmark-',
    '-bookmark',
    'bottom-of-article',
    'brand-bar',
    'breadcrumb',
    'button-wrapper',
    'btn-',
    '-btn',
    'byline',
    'captcha',
    'card-text',
    'card-media',
    'cat_header',
    'catlinks',
    'chapter-list', // The Economist
    'collections',
    'comments',
    //	'-comment', Syntax highlighting
    'commentbox',
    'comment-count',
    'comment-content',
    'comment-form',
    'comment-number',
    'comment-respond',
    'comment-thread',
    'complementary',
    'consent',
    'content-card', // The Verge
    'content-topics',
    'contentpromo',
    'context-widget', // Reuters
    'core-collateral',
    '_cta',
    '-cta',
    'cta-',
    'cta_',
    'current-issue', // The Nation
    'custom-list-number',
    'dateline',
    'dateheader',
    'date-header',
    'date_header-',
    //	'dialog',
    'disclaimer',
    'disclosure',
    'discussion',
    'discuss_',
    'disqus',
    'donate',
    'dropdown', // Ars Technica
    'eletters',
    'emailsignup',
    'engagement-widget',
    'entry-author-info',
    'entry-categories',
    'entry-date',
    'entry-meta',
    'entry-title',
    'entry-utility',
    'eyebrow',
    'expand-reduce',
    'externallinkembedwrapper', // The New Yorker
    'extra-services',
    'extra-title',
    'facebook',
    'favorite',
    'feedback',
    'feed-links',
    'field-site-sections',
    'fixed',
    'floating-vid',
    'follow',
    'footer',
    'footnote-back',
    'footnoteback',
    'for-you',
    'frontmatter',
    'further-reading',
    'gist-meta',
    //	'global',
    'google',
    'goog-',
    'graph-view',
    'header-logo',
    'header-pattern', // The Verge
    'hero-list',
    'hide-for-print',
    'hide-print',
    'hide-when-no-script',
    'hidden-sidenote',
    'interlude',
    'interaction',
    'jumplink',
    'jump-to-',
    //	'keyword', // used in syntax highlighting
    'kicker',
    'labstab', // Arxiv
    '-labels',
    'language-name',
    'latest-content',
    '-ledes-', // The Verge
    '-license',
    'link-box',
    'links-grid', // BBC
    'links-title', // BBC
    'listing-dynamic-terms', // Boston Review
    'list-tags',
    'loading',
    'loa-info',
    'logo_container',
    'ltx_role_refnum', // Arxiv
    'ltx_tag_bibitem',
    'ltx_error',
    'marketing',
    'media-inquiry',
    'menu-',
    'meta-',
    'metadata',
    'might-like',
    '_modal',
    '-modal',
    'more-',
    'morenews',
    'morestories',
    'move-helper',
    'mw-editsection',
    'mw-cite-backlink',
    'mw-indicators',
    'mw-jump-link',
    'nav-',
    'nav_',
    'navbar',
    //	'navigation',
    'next-',
    'news-story-title',
    //	'newsletter', used on Substack
    'newsletter_',
    'newsletter-signup',
    'newslettersignup',
    'newsletterwidget',
    'newsletterwrapper',
    'not-found',
    'nomobile',
    'noprint',
    'originally-published', // Mercury News
    'outline-view',
    'overlay',
    'page-title',
    '-partners',
    'plea',
    'popular',
    //	'popup', Gwern
    'pop-up',
    'popover',
    'post-bottom',
    'post__category',
    'postcomment',
    'postdate',
    'post-author',
    'post-date',
    'post_date',
    'post-feeds',
    'postinfo',
    'post-info',
    'post_info',
    'post-inline-date',
    'post-links',
    'post-meta',
    'postmeta',
    'postsnippet',
    'post_snippet',
    'post-snippet',
    'posttitle',
    'post-title',
    'post_title',
    'posttax',
    'post-tax',
    'post_tax',
    'posttag',
    'post_tag',
    'post-tag',
    //	'preview', used on Obsidian Publish
    'prevnext',
    'previousnext',
    'press-inquiries',
    'print-none',
    'print-header',
    'profile',
    //	'promo',
    'promo-box',
    'pubdate',
    'pub_date',
    'pub-date',
    'publication-date',
    'publicationName', // Medium
    'qr-code',
    'qr_code',
    '_rail',
    'readmore',
    'read-next',
    'read_next',
    'read_time',
    'read-time',
    'reading_time',
    'reading-time',
    'reading-list',
    'recentpost',
    'recent_post',
    'recent-post',
    'recommend',
    'redirectedfrom',
    'recirc',
    'register',
    'related',
    'relevant',
    'reversefootnote',
    'screen-reader-text',
    //	'share',
    //	'-share', scitechdaily.com
    'share-box',
    'sharedaddy',
    'share-icons',
    'sharelinks',
    'share-section',
    'sidebartitle',
    'sidebar_',
    'sidebar-content',
    'similar-',
    'similar_',
    'similars-',
    'sideitems',
    'side-box',
    'site-index',
    'site-header',
    'site-logo',
    'site-name',
    //	'skip-',
    //	'skip-link', TechCrunch
    '_skip-link',
    'slug-wrap',
    'social',
    'speechify-ignore',
    'sponsor',
    'springercitation',
    //	'-stats',
    '_stats',
    'sticky',
    'storyreadtime', // Medium
    'storypublishdate', // Medium
    'subject-label',
    'subscribe',
    '_tags',
    'tags__item',
    'tag_list',
    'taxonomy',
    'table-of-contents',
    'tabs-',
    //	'teaser', Nature
    'terminaltout',
    'time-rubric',
    'timestamp',
    'tip_off',
    'tiptout',
    '-tout-',
    '-toc',
    'toggle-caption',
    'topic-list',
    'toolbar',
    'tooltip',
    'top-wrapper',
    'tree-item',
    'trending',
    'trust-feat',
    'trust-badge',
    'twitter',
    'visually-hidden',
    'welcomebox'
    //	'widget-'
];
// Selectors for footnotes and citations
exports.FOOTNOTE_INLINE_REFERENCES = [
    'sup.reference',
    'cite.ltx_cite',
    'sup[id^="fnr"]',
    'sup[id^="fnref:"]',
    'span.footnote-link',
    'a.citation',
    'a[id^="ref-link"]',
    'a[href^="#fn"]',
    'a[href^="#cite"]',
    'a[href^="#reference"]',
    'a[href^="#footnote"]',
    'a[href^="#r"]', // Common in academic papers
    'a[href^="#b"]', // Common for bibliography references
    'a[href*="cite_note"]',
    'a[href*="cite_ref"]',
    'a.footnote-anchor', // Substack
    'span.footnote-hovercard-target a', // Substack
    'a[role="doc-biblioref"]', // Science.org
    'a[id^="fnref"]',
    'a[id^="ref-link"]', // Nature.com
].join(',');
exports.FOOTNOTE_LIST_SELECTORS = [
    'div.footnote ol',
    'div.footnotes ol',
    'div[role="doc-endnotes"]',
    'div[role="doc-footnotes"]',
    'ol.footnotes-list',
    'ol.footnotes',
    'ol.references',
    'ol[class*="article-references"]',
    'section.footnotes ol',
    'section[role="doc-endnotes"]',
    'section[role="doc-footnotes"]',
    'section[role="doc-bibliography"]',
    'ul.footnotes-list',
    'ul.ltx_biblist',
    'div.footnote[data-component-name="FootnoteToDOM"]' // Substack
].join(',');
// Elements that are allowed to be empty
// These are not removed even if they have no content
exports.ALLOWED_EMPTY_ELEMENTS = new Set([
    'area',
    'audio',
    'base',
    'br',
    'circle',
    'col',
    'defs',
    'ellipse',
    'embed',
    'figure',
    'g',
    'hr',
    'iframe',
    'img',
    'input',
    'line',
    'link',
    'mask',
    'meta',
    'object',
    'param',
    'path',
    'pattern',
    'picture',
    'polygon',
    'polyline',
    'rect',
    'source',
    'stop',
    'svg',
    'td',
    'th',
    'track',
    'use',
    'video',
    'wbr'
]);
// Attributes to keep
exports.ALLOWED_ATTRIBUTES = new Set([
    'alt',
    'allow',
    'allowfullscreen',
    'aria-label',
    'checked',
    'colspan',
    'controls',
    'data-latex',
    'data-src',
    'data-srcset',
    'data-lang',
    'dir',
    'display',
    'frameborder',
    'headers',
    'height',
    'href',
    'lang',
    'role',
    'rowspan',
    'src',
    'srcset',
    'title',
    'type',
    'width',
    // MathML attributes
    'accent',
    'accentunder',
    'align',
    'columnalign',
    'columnlines',
    'columnspacing',
    'columnspan',
    'data-mjx-texclass',
    'depth',
    'displaystyle',
    'fence',
    'frame',
    'framespacing',
    'linethickness',
    'lspace',
    'mathbackground',
    'mathcolor',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'scriptlevel',
    'separator',
    'stretchy',
    'symmetric',
    'voffset',
    'xmlns'
]);
exports.ALLOWED_ATTRIBUTES_DEBUG = new Set([
    'class',
    'id',
]);
// Supported languages for code blocks
exports.SUPPORTED_LANGUAGES = new Set([
    // Markup & Web
    'markup', 'html', 'xml', 'svg', 'mathml', 'ssml', 'atom', 'rss',
    'javascript', 'js', 'jsx', 'typescript', 'ts', 'tsx',
    'webassembly', 'wasm',
    // Common Programming Languages
    'python',
    'java',
    'csharp', 'cs', 'dotnet', 'aspnet',
    'cpp', 'c++', 'c', 'objc',
    'ruby', 'rb',
    'php',
    'golang',
    'rust',
    'swift',
    'kotlin',
    'scala',
    'dart',
    // Shell & Scripting
    'bash', 'shell', 'sh',
    'powershell',
    'batch',
    // Data & Config
    'json', 'jsonp',
    'yaml', 'yml',
    'toml',
    'dockerfile',
    'gitignore',
    // Query Languages
    'sql', 'mysql', 'postgresql',
    'graphql',
    'mongodb',
    'sparql',
    // Markup & Documentation
    'markdown', 'md',
    'latex', 'tex',
    'asciidoc', 'adoc',
    'jsdoc',
    // Functional Languages
    'haskell', 'hs',
    'elm',
    'elixir',
    'erlang',
    'ocaml',
    'fsharp',
    'scheme',
    'lisp', 'elisp',
    'clojure',
    // Other Languages
    'matlab',
    'fortran',
    'cobol',
    'pascal',
    'perl',
    'lua',
    'julia',
    'groovy',
    'crystal',
    'nim',
    'zig',
    // Domain Specific
    'regex',
    'gradle',
    'cmake',
    'makefile',
    'nix',
    'terraform',
    'solidity',
    'glsl',
    'hlsl',
    // Assembly
    'nasm',
    'masm',
    'armasm',
    // Game Development
    'gdscript',
    'unrealscript',
    // Others
    'abap',
    'actionscript',
    'ada',
    'agda',
    'antlr4',
    'applescript',
    'arduino',
    'coffeescript',
    'django',
    'erlang',
    'fortran',
    'haxe',
    'idris',
    'kotlin',
    'livescript',
    'matlab',
    'nginx',
    'pascal',
    'prolog',
    'puppet',
    'scala',
    'scheme',
    'tcl',
    'verilog',
    'vhdl'
]);


/***/ }),

/***/ 914:
/*!*******************************************!*\
  !*** ./node_modules/temml/dist/temml.cjs ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/**
 * This is the ParseError class, which is the main error thrown by Temml
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */
class ParseError {
  constructor(
    message, // The error message
    token // An object providing position information
  ) {
    let error = " " + message;
    let start;

    const loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      // If we have the input and a position, make the error a bit fancier

      // Get the input
      const input = loc.lexer.input;

      // Prepend some information
      start = loc.start;
      const end = loc.end;
      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": \n";
      }

      // Underline token in question using combining underscores
      const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

      // Extract some context from the input and add it to the error
      let left;
      if (start > 15) {
        left = "…" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      let right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "…";
      } else {
        right = input.slice(end);
      }
      error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    const self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;
    self.position = start;
    return self;
  }
}

ParseError.prototype.__proto__ = Error.prototype;

//
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide a default value if a setting is undefined
 */
const deflt = function(setting, defaultIfUndefined) {
  return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

const uppercase = /([A-Z])/g;
const hyphenate = function(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};

const ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};

const ESCAPE_REGEX = /[&><"']/g;

/**
 * Escapes text to prevent scripting attacks.
 */
function escape(text) {
  return String(text).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
const getBaseElem = function(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem(group.body);
  } else {
    return group;
  }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
const isCharacterBox = function(group) {
  const baseElem = getBaseElem(group);

  // These are all the types of groups which hold single characters
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom"
};

const assert = function(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};

/**
 * Return the protocol of a URL, or "_relative" if the URL does not specify a
 * protocol (and thus is relative), or `null` if URL has invalid protocol
 * (so should be outright rejected).
 */
const protocolFromUrl = function(url) {
  // Check for possible leading protocol.
  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace
  // (\x00) or C0 control (\x00-\x1F) characters.
  // eslint-disable-next-line no-control-regex
  const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
  if (!protocol) {
    return "_relative";
  }
  // Reject weird colons
  if (protocol[2] !== ":") {
    return null;
  }
  // Reject invalid characters in scheme according to
  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  // Lowercase the protocol
  return protocol[1].toLowerCase();
};

/**
 * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. The TeXbook
 * gives an acceptable rounding error of 100sp (which would be the nearest
 * 1/6551.6em with our ptPerEm = 10):
 * http://www.ctex.org/documents/shredder/src/texbook.pdf#page=69
 */
const round = function(n) {
  return +n.toFixed(4);
};

var utils = {
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl,
  round
};

/**
 * This is a module for storing settings passed into Temml. It correctly handles
 * default settings.
 */


/**
 * The main Settings object
 */
class Settings {
  constructor(options) {
    // allow null options
    options = options || {};
    this.displayMode = utils.deflt(options.displayMode, false);    // boolean
    this.annotate = utils.deflt(options.annotate, false);           // boolean
    this.leqno = utils.deflt(options.leqno, false);                // boolean
    this.throwOnError = utils.deflt(options.throwOnError, false);  // boolean
    this.errorColor = utils.deflt(options.errorColor, "#b22222");  // string
    this.macros = options.macros || {};
    this.wrap = utils.deflt(options.wrap, "tex");                    // "tex" | "="
    this.xml = utils.deflt(options.xml, false);                     // boolean
    this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);  // booelean
    this.strict = utils.deflt(options.strict, false);    // boolean
    this.trust = utils.deflt(options.trust, false);  // trust context. See html.js.
    this.maxSize = (options.maxSize === undefined
      ? [Infinity, Infinity]
      : Array.isArray(options.maxSize)
      ? options.maxSize
      : [Infinity, Infinity]
    );
    this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000)); // number
  }

  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      const protocol = utils.protocolFromUrl(context.url);
      if (protocol == null) {
        return false
      }
      context.protocol = protocol;
    }
    const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
}

/**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */
const _functions = {};

/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */
const _mathmlGroupBuilders = {};

function defineFunction({
  type,
  names,
  props,
  handler,
  mathmlBuilder
}) {
  // Set default values of functions
  const data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler: handler
  };
  for (let i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }
  if (type) {
    if (mathmlBuilder) {
      _mathmlGroupBuilders[type] = mathmlBuilder;
    }
  }
}

/**
 * Use this to register only the MathML builder for a function(e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */
function defineFunctionBuilders({ type, mathmlBuilder }) {
  defineFunction({
    type,
    names: [],
    props: { numArgs: 0 },
    handler() {
      throw new Error("Should never be called.")
    },
    mathmlBuilder
  });
}

const normalizeArgument = function(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg
};

// Since the corresponding buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
const ordargument = function(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg]
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */
class DocumentFragment {
  constructor(children) {
    this.children = children;
    this.classes = [];
    this.style = {};
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  /** Convert the fragment into a node. */
  toNode() {
    const frag = document.createDocumentFragment();

    for (let i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }

    return frag;
  }

  /** Convert the fragment into HTML markup. */
  toMarkup() {
    let markup = "";

    // Simply concatenate the markup for the children together.
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    // To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    const toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
}

/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 */

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */
const createClass = function(classes) {
  return classes.filter((cls) => cls).join(" ");
};

const initNode = function(classes, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.style = style || {};
};

/**
 * Convert into an HTML node
 */
const toNode = function(tagName) {
  const node = document.createElement(tagName);

  // Apply the class
  node.className = createClass(this.classes);

  // Apply inline styles
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      node.style[style] = this.style[style];
    }
  }

  // Apply attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  }

  // Append the children, also as HTML nodes
  for (let i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }

  return node;
};

/**
 * Convert into an HTML markup string
 */
const toMarkup = function(tagName) {
  let markup = `<${tagName}`;

  // Add the class
  if (this.classes.length) {
    markup += ` class="${utils.escape(createClass(this.classes))}"`;
  }

  let styles = "";

  // Add the styles, after hyphenation
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      styles += `${utils.hyphenate(style)}:${this.style[style]};`;
    }
  }

  if (styles) {
    markup += ` style="${styles}"`;
  }

  // Add the attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      markup += ` ${attr}="${utils.escape(this.attributes[attr])}"`;
    }
  }

  markup += ">";

  // Add the markup of the children, also as markup
  for (let i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }

  markup += `</${tagName}>`;

  return markup;
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style.
 *
 */
class Span {
  constructor(classes, children, style) {
    initNode.call(this, classes, style);
    this.children = children || [];
  }

  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  toNode() {
    return toNode.call(this, "span");
  }

  toMarkup() {
    return toMarkup.call(this, "span");
  }
}

let TextNode$1 = class TextNode {
  constructor(text) {
    this.text = text;
  }
  toNode() {
    return document.createTextNode(this.text);
  }
  toMarkup() {
    return utils.escape(this.text);
  }
};

// Create an <a href="…"> node.
class AnchorNode {
  constructor(href, classes, children) {
    this.href = href;
    this.classes = classes;
    this.children = children || [];
  }

  toNode() {
    const node = document.createElement("a");
    node.setAttribute("href", this.href);
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node
  }

  toMarkup() {
    let markup = `<a href='${utils.escape(this.href)}'`;
    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }
    markup += ">";
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</a>";
    return markup
  }
}

/*
 * This node represents an image embed (<img>) element.
 */
class Img {
  constructor(src, alt, style) {
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  toNode() {
    const node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    return node;
  }

  toMarkup() {
    let markup = `<img src='${this.src}' alt='${this.alt}'`;

    // Add the styles, after hyphenation
    let styles = "";
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }
    if (styles) {
      markup += ` style="${utils.escape(styles)}"`;
    }

    markup += ">";
    return markup;
  }
}

//
/**
 * These objects store data about MathML nodes.
 * The `toNode` and `toMarkup` functions  create namespaced DOM nodes and
 * HTML text markup respectively.
 */


function newDocumentFragment(children) {
  return new DocumentFragment(children);
}

/**
 * This node represents a general purpose MathML node of any type,
 * for example, `"mo"` or `"mspace"`, corresponding to `<mo>` and
 * `<mspace>` tags).
 */
class MathNode {
  constructor(type, children, classes, style) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
    this.style = style || {};   // Used for <mstyle> elements
    this.label = "";
  }

  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value) {
    this.attributes[name] = value;
  }

  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }

  setLabel(value) {
    this.label = value;
  }

  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }

  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    let markup = "<" + this.type;

    // Add the attributes
    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils.escape(this.attributes[attr]);
        markup += '"';
      }
    }

    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }

    let styles = "";

    // Add the styles, after hyphenation
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }

    if (styles) {
      markup += ` style="${styles}"`;
    }

    markup += ">";

    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}

/**
 * This node represents a piece of text.
 */
class TextNode {
  constructor(text) {
    this.text = text;
  }

  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }

  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }

  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}

// Do not make an <mrow> the only child of a <mstyle>.
// An <mstyle> acts as its own implicit <mrow>.
const wrapWithMstyle = expression => {
  let node;
  if (expression.length === 1 && expression[0].type === "mrow") {
    node = expression.pop();
    node.type = "mstyle";
  } else {
    node = new MathNode("mstyle", expression);
  }
  return node
};

var mathMLTree = {
  MathNode,
  TextNode,
  newDocumentFragment
};

/**
 * This file provides support for building horizontal stretchy elements.
 */


// TODO: Remove when Chromium stretches \widetilde & \widehat
const estimatedWidth = node => {
  let width = 0;
  if (node.body) {
    for (const item of node.body) {
      width += estimatedWidth(item);
    }
  } else if (node.type === "supsub") {
    width += estimatedWidth(node.base);
    if (node.sub) { width += 0.7 * estimatedWidth(node.sub); }
    if (node.sup) { width += 0.7 * estimatedWidth(node.sup); }
  } else if (node.type === "mathord" || node.type === "textord") {
    for (const ch of node.text.split('')) {
      const codePoint = ch.codePointAt(0);
      if ((0x60 < codePoint && codePoint < 0x7B) || (0x03B0 < codePoint && codePoint < 0x3CA)) {
        width += 0.56; // lower case latin or greek. Use advance width of letter n
      } else if (0x2F < codePoint && codePoint < 0x3A) {
        width += 0.50; // numerals.
      } else {
        width += 0.92; // advance width of letter M
      }
    }
  } else {
    width += 1.0;
  }
  return width
};

const stretchyCodePoint = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  wideparen: "⏜", // \u23dc
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23df",
  overbrace: "\u23de",
  overgroup: "\u23e0",
  overparen: "⏜",
  undergroup: "\u23e1",
  underparen: "\u23dd",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21d2",
  xRightarrow: "\u21d2",
  overleftharpoon: "\u21bc",
  xleftharpoonup: "\u21bc",
  overrightharpoon: "\u21c0",
  xrightharpoonup: "\u21c0",
  xLeftarrow: "\u21d0",
  xLeftrightarrow: "\u21d4",
  xhookleftarrow: "\u21a9",
  xhookrightarrow: "\u21aa",
  xmapsto: "\u21a6",
  xrightharpoondown: "\u21c1",
  xleftharpoondown: "\u21bd",
  xtwoheadleftarrow: "\u219e",
  xtwoheadrightarrow: "\u21a0",
  xlongequal: "=",
  xrightleftarrows: "\u21c4",
  yields: "\u2192",
  yieldsLeft: "\u2190",
  mesomerism: "\u2194",
  longrightharpoonup: "\u21c0",
  longleftharpoondown: "\u21bd",
  eqrightharpoonup: "\u21c0",
  eqleftharpoondown: "\u21bd",
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};

const mathMLnode = function(label) {
  const child = new mathMLTree.TextNode(stretchyCodePoint[label.slice(1)]);
  const node = new mathMLTree.MathNode("mo", [child]);
  node.setAttribute("stretchy", "true");
  return node
};

const crookedWides = ["\\widetilde", "\\widehat", "\\widecheck", "\\utilde"];

// TODO: Remove when Chromium stretches \widetilde & \widehat
const accentNode = (group) => {
  const mo = mathMLnode(group.label);
  if (crookedWides.includes(group.label)) {
    const width = estimatedWidth(group.base);
    if (1 < width && width < 1.6) {
      mo.classes.push("tml-crooked-2");
    } else if (1.6 <= width && width < 2.5) {
      mo.classes.push("tml-crooked-3");
    } else if (2.5 <= width) {
      mo.classes.push("tml-crooked-4");
    }
  }
  return mo
};

var stretchy = {
  mathMLnode,
  accentNode
};

/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are two properties they can have:
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

// Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
const ATOMS = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
};
const NON_ATOMS = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
};

const symbols = {
  math: {},
  text: {}
};

/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */
function defineSymbol(mode, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = { group, replace };

  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
const math = "math";
const text = "text";

// groups:
const accent = "accent-token";
const bin = "bin";
const close = "close";
const inner = "inner";
const mathord = "mathord";
const op = "op-token";
const open = "open";
const punct = "punct";
const rel = "rel";
const spacing = "spacing";
const textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, rel, "\u2261", "\\equiv", true);
defineSymbol(math, rel, "\u227a", "\\prec", true);
defineSymbol(math, rel, "\u227b", "\\succ", true);
defineSymbol(math, rel, "\u223c", "\\sim", true);
defineSymbol(math, rel, "\u27c2", "\\perp", true);
defineSymbol(math, rel, "\u2aaf", "\\preceq", true);
defineSymbol(math, rel, "\u2ab0", "\\succeq", true);
defineSymbol(math, rel, "\u2243", "\\simeq", true);
defineSymbol(math, rel, "\u224c", "\\backcong", true);
defineSymbol(math, rel, "|", "\\mid", true);
defineSymbol(math, rel, "\u226a", "\\ll", true);
defineSymbol(math, rel, "\u226b", "\\gg", true);
defineSymbol(math, rel, "\u224d", "\\asymp", true);
defineSymbol(math, rel, "\u2225", "\\parallel");
defineSymbol(math, rel, "\u2323", "\\smile", true);
defineSymbol(math, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, rel, "\u2250", "\\doteq", true);
defineSymbol(math, rel, "\u2322", "\\frown", true);
defineSymbol(math, rel, "\u220b", "\\ni", true);
defineSymbol(math, rel, "\u220c", "\\notni", true);
defineSymbol(math, rel, "\u221d", "\\propto", true);
defineSymbol(math, rel, "\u22a2", "\\vdash", true);
defineSymbol(math, rel, "\u22a3", "\\dashv", true);
defineSymbol(math, rel, "\u220b", "\\owns");
defineSymbol(math, rel, "\u2258", "\\arceq", true);
defineSymbol(math, rel, "\u2259", "\\wedgeq", true);
defineSymbol(math, rel, "\u225a", "\\veeeq", true);
defineSymbol(math, rel, "\u225b", "\\stareq", true);
defineSymbol(math, rel, "\u225d", "\\eqdef", true);
defineSymbol(math, rel, "\u225e", "\\measeq", true);
defineSymbol(math, rel, "\u225f", "\\questeq", true);
defineSymbol(math, rel, "\u2260", "\\ne", true);
defineSymbol(math, rel, "\u2260", "\\neq");
// unicodemath
defineSymbol(math, rel, "\u2a75", "\\eqeq", true);
defineSymbol(math, rel, "\u2a76", "\\eqeqeq", true);
// mathtools.sty
defineSymbol(math, rel, "\u2237", "\\dblcolon", true);
defineSymbol(math, rel, "\u2254", "\\coloneqq", true);
defineSymbol(math, rel, "\u2255", "\\eqqcolon", true);
defineSymbol(math, rel, "\u2239", "\\eqcolon", true);
defineSymbol(math, rel, "\u2A74", "\\Coloneqq", true);

// Punctuation
defineSymbol(math, punct, "\u002e", "\\ldotp");
defineSymbol(math, punct, "\u00b7", "\\cdotp");

// Misc Symbols
defineSymbol(math, textord, "\u0023", "\\#");
defineSymbol(text, textord, "\u0023", "\\#");
defineSymbol(math, textord, "\u0026", "\\&");
defineSymbol(text, textord, "\u0026", "\\&");
defineSymbol(math, textord, "\u2135", "\\aleph", true);
defineSymbol(math, textord, "\u2200", "\\forall", true);
defineSymbol(math, textord, "\u210f", "\\hbar", true);
defineSymbol(math, textord, "\u2203", "\\exists", true);
// ∇ is actually a unary operator, not binary. But this works.
defineSymbol(math, bin, "\u2207", "\\nabla", true);
defineSymbol(math, textord, "\u266d", "\\flat", true);
defineSymbol(math, textord, "\u2113", "\\ell", true);
defineSymbol(math, textord, "\u266e", "\\natural", true);
defineSymbol(math, textord, "Å", "\\Angstrom", true);
defineSymbol(text, textord, "Å", "\\Angstrom", true);
defineSymbol(math, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, textord, "\u2667", "\\varclubsuit", true);
defineSymbol(math, textord, "\u2118", "\\wp", true);
defineSymbol(math, textord, "\u266f", "\\sharp", true);
defineSymbol(math, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, textord, "\u2666", "\\vardiamondsuit", true);
defineSymbol(math, textord, "\u211c", "\\Re", true);
defineSymbol(math, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, textord, "\u2665", "\\varheartsuit", true);
defineSymbol(math, textord, "\u2111", "\\Im", true);
defineSymbol(math, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, textord, "\u2664", "\\varspadesuit", true);
defineSymbol(math, textord, "\u2640", "\\female", true);
defineSymbol(math, textord, "\u2642", "\\male", true);
defineSymbol(math, textord, "\u00a7", "\\S", true);
defineSymbol(text, textord, "\u00a7", "\\S");
defineSymbol(math, textord, "\u00b6", "\\P", true);
defineSymbol(text, textord, "\u00b6", "\\P");
defineSymbol(text, textord, "\u263a", "\\smiley", true);
defineSymbol(math, textord, "\u263a", "\\smiley", true);

// Math and Text
defineSymbol(math, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\textdagger");
defineSymbol(math, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\textdaggerdbl");

// Large Delimiters
defineSymbol(math, close, "\u23b1", "\\rmoustache", true);
defineSymbol(math, open, "\u23b0", "\\lmoustache", true);
defineSymbol(math, close, "\u27ef", "\\rgroup", true);
defineSymbol(math, open, "\u27ee", "\\lgroup", true);

// Binary Operators
defineSymbol(math, bin, "\u2213", "\\mp", true);
defineSymbol(math, bin, "\u2296", "\\ominus", true);
defineSymbol(math, bin, "\u228e", "\\uplus", true);
defineSymbol(math, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, bin, "\u2217", "\\ast");
defineSymbol(math, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, bin, "\u25ef", "\\bigcirc", true);
defineSymbol(math, bin, "\u2219", "\\bullet", true);
defineSymbol(math, bin, "\u2021", "\\ddagger");
defineSymbol(math, bin, "\u2240", "\\wr", true);
defineSymbol(math, bin, "\u2a3f", "\\amalg");
defineSymbol(math, bin, "\u0026", "\\And"); // from amsmath
defineSymbol(math, bin, "\u2AFD", "\\sslash", true); // from stmaryrd

// Arrow Symbols
defineSymbol(math, rel, "\u27f5", "\\longleftarrow", true);
defineSymbol(math, rel, "\u21d0", "\\Leftarrow", true);
defineSymbol(math, rel, "\u27f8", "\\Longleftarrow", true);
defineSymbol(math, rel, "\u27f6", "\\longrightarrow", true);
defineSymbol(math, rel, "\u21d2", "\\Rightarrow", true);
defineSymbol(math, rel, "\u27f9", "\\Longrightarrow", true);
defineSymbol(math, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, rel, "\u27f7", "\\longleftrightarrow", true);
defineSymbol(math, rel, "\u21d4", "\\Leftrightarrow", true);
defineSymbol(math, rel, "\u27fa", "\\Longleftrightarrow", true);
defineSymbol(math, rel, "\u21a4", "\\mapsfrom", true);
defineSymbol(math, rel, "\u21a6", "\\mapsto", true);
defineSymbol(math, rel, "\u27fc", "\\longmapsto", true);
defineSymbol(math, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, rel, "\u21a9", "\\hookleftarrow", true);
defineSymbol(math, rel, "\u21aa", "\\hookrightarrow", true);
defineSymbol(math, rel, "\u2198", "\\searrow", true);
defineSymbol(math, rel, "\u21bc", "\\leftharpoonup", true);
defineSymbol(math, rel, "\u21c0", "\\rightharpoonup", true);
defineSymbol(math, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, rel, "\u21bd", "\\leftharpoondown", true);
defineSymbol(math, rel, "\u21c1", "\\rightharpoondown", true);
defineSymbol(math, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, rel, "\u21cc", "\\rightleftharpoons", true);
defineSymbol(math, mathord, "\u21af", "\\lightning", true);
defineSymbol(math, mathord, "\u220E", "\\QED", true);
defineSymbol(math, mathord, "\u2030", "\\permil", true);
defineSymbol(text, textord, "\u2030", "\\permil");
defineSymbol(math, mathord, "\u2609", "\\astrosun", true);
defineSymbol(math, mathord, "\u263c", "\\sun", true);
defineSymbol(math, mathord, "\u263e", "\\leftmoon", true);
defineSymbol(math, mathord, "\u263d", "\\rightmoon", true);
defineSymbol(math, mathord, "\u2295", "\\Earth");

// AMS Negated Binary Relations
defineSymbol(math, rel, "\u226e", "\\nless", true);
// Symbol names preceeded by "@" each have a corresponding macro.
defineSymbol(math, rel, "\u2a87", "\\lneq", true);
defineSymbol(math, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, rel, "\u2268\ufe00", "\\lvertneqq");
defineSymbol(math, rel, "\u22e6", "\\lnsim", true);
defineSymbol(math, rel, "\u2a89", "\\lnapprox", true);
defineSymbol(math, rel, "\u2280", "\\nprec", true);
// unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e0", "\\npreceq", true);
defineSymbol(math, rel, "\u22e8", "\\precnsim", true);
defineSymbol(math, rel, "\u2ab9", "\\precnapprox", true);
defineSymbol(math, rel, "\u2241", "\\nsim", true);
defineSymbol(math, rel, "\u2224", "\\nmid", true);
defineSymbol(math, rel, "\u2224", "\\nshortmid");
defineSymbol(math, rel, "\u22ac", "\\nvdash", true);
defineSymbol(math, rel, "\u22ad", "\\nvDash", true);
defineSymbol(math, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, rel, "\u22ec", "\\ntrianglelefteq", true);
defineSymbol(math, rel, "\u2284", "\\nsubset", true);
defineSymbol(math, rel, "\u2285", "\\nsupset", true);
defineSymbol(math, rel, "\u228a", "\\subsetneq", true);
defineSymbol(math, rel, "\u228a\ufe00", "\\varsubsetneq");
defineSymbol(math, rel, "\u2acb", "\\subsetneqq", true);
defineSymbol(math, rel, "\u2acb\ufe00", "\\varsubsetneqq");
defineSymbol(math, rel, "\u226f", "\\ngtr", true);
defineSymbol(math, rel, "\u2a88", "\\gneq", true);
defineSymbol(math, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, rel, "\u2269\ufe00", "\\gvertneqq");
defineSymbol(math, rel, "\u22e7", "\\gnsim", true);
defineSymbol(math, rel, "\u2a8a", "\\gnapprox", true);
defineSymbol(math, rel, "\u2281", "\\nsucc", true);
// unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e1", "\\nsucceq", true);
defineSymbol(math, rel, "\u22e9", "\\succnsim", true);
defineSymbol(math, rel, "\u2aba", "\\succnapprox", true);
// unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u2246", "\\ncong", true);
defineSymbol(math, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, rel, "\u2226", "\\nshortparallel");
defineSymbol(math, rel, "\u22af", "\\nVDash", true);
defineSymbol(math, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, rel, "\u22ed", "\\ntrianglerighteq", true);
defineSymbol(math, rel, "\u228b", "\\supsetneq", true);
defineSymbol(math, rel, "\u228b", "\\varsupsetneq");
defineSymbol(math, rel, "\u2acc", "\\supsetneqq", true);
defineSymbol(math, rel, "\u2acc\ufe00", "\\varsupsetneqq");
defineSymbol(math, rel, "\u22ae", "\\nVdash", true);
defineSymbol(math, rel, "\u2ab5", "\\precneqq", true);
defineSymbol(math, rel, "\u2ab6", "\\succneqq", true);
defineSymbol(math, bin, "\u22b4", "\\unlhd");
defineSymbol(math, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, rel, "\u219a", "\\nleftarrow", true);
defineSymbol(math, rel, "\u219b", "\\nrightarrow", true);
defineSymbol(math, rel, "\u21cd", "\\nLeftarrow", true);
defineSymbol(math, rel, "\u21cf", "\\nRightarrow", true);
defineSymbol(math, rel, "\u21ae", "\\nleftrightarrow", true);
defineSymbol(math, rel, "\u21ce", "\\nLeftrightarrow", true);

// AMS Misc
defineSymbol(math, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, textord, "\u210f", "\\hslash");
defineSymbol(math, textord, "\u25bd", "\\triangledown");
defineSymbol(math, textord, "\u25ca", "\\lozenge");
defineSymbol(math, textord, "\u24c8", "\\circledS");
defineSymbol(math, textord, "\u00ae", "\\circledR", true);
defineSymbol(text, textord, "\u00ae", "\\circledR");
defineSymbol(text, textord, "\u00ae", "\\textregistered");
defineSymbol(math, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, textord, "\u2204", "\\nexists");
defineSymbol(math, textord, "\u2127", "\\mho");
defineSymbol(math, textord, "\u2132", "\\Finv", true);
defineSymbol(math, textord, "\u2141", "\\Game", true);
defineSymbol(math, textord, "\u2035", "\\backprime");
defineSymbol(math, textord, "\u2036", "\\backdprime");
defineSymbol(math, textord, "\u2037", "\\backtrprime");
defineSymbol(math, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, textord, "\u2605", "\\bigstar");
defineSymbol(math, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, textord, "\u2201", "\\complement", true);
// unicode-math maps U+F0 to \matheth. We map to AMS function \eth
defineSymbol(math, textord, "\u00f0", "\\eth", true);
defineSymbol(text, textord, "\u00f0", "\u00f0");
defineSymbol(math, textord, "\u2571", "\\diagup");
defineSymbol(math, textord, "\u2572", "\\diagdown");
defineSymbol(math, textord, "\u25a1", "\\square");
defineSymbol(math, textord, "\u25a1", "\\Box");
defineSymbol(math, textord, "\u25ca", "\\Diamond");
// unicode-math maps U+A5 to \mathyen. We map to AMS function \yen
defineSymbol(math, textord, "\u00a5", "\\yen", true);
defineSymbol(text, textord, "\u00a5", "\\yen", true);
defineSymbol(math, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, textord, "\u2713", "\\checkmark");
defineSymbol(math, textord, "\u2717", "\\ballotx", true);
defineSymbol(text, textord, "\u2717", "\\ballotx");
defineSymbol(text, textord, "\u2022", "\\textbullet");

// AMS Hebrew
defineSymbol(math, textord, "\u2136", "\\beth", true);
defineSymbol(math, textord, "\u2138", "\\daleth", true);
defineSymbol(math, textord, "\u2137", "\\gimel", true);

// AMS Greek
defineSymbol(math, textord, "\u03dd", "\\digamma", true);
defineSymbol(math, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, open, "\u231C", "\\ulcorner", true);
defineSymbol(math, close, "\u231D", "\\urcorner", true);
defineSymbol(math, open, "\u231E", "\\llcorner", true);
defineSymbol(math, close, "\u231F", "\\lrcorner", true);

// AMS Binary Relations
defineSymbol(math, rel, "\u2266", "\\leqq", true);
defineSymbol(math, rel, "\u2a7d", "\\leqslant", true);
defineSymbol(math, rel, "\u2a95", "\\eqslantless", true);
defineSymbol(math, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, rel, "\u2a85", "\\lessapprox", true);
defineSymbol(math, rel, "\u224a", "\\approxeq", true);
defineSymbol(math, bin, "\u22d6", "\\lessdot");
defineSymbol(math, rel, "\u22d8", "\\lll", true);
defineSymbol(math, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, rel, "\u22da", "\\lesseqgtr", true);
defineSymbol(math, rel, "\u2a8b", "\\lesseqqgtr", true);
defineSymbol(math, rel, "\u2251", "\\doteqdot");
defineSymbol(math, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, rel, "\u223d", "\\backsim", true);
defineSymbol(math, rel, "\u22cd", "\\backsimeq", true);
defineSymbol(math, rel, "\u2ac5", "\\subseteqq", true);
defineSymbol(math, rel, "\u22d0", "\\Subset", true);
defineSymbol(math, rel, "\u228f", "\\sqsubset", true);
defineSymbol(math, rel, "\u227c", "\\preccurlyeq", true);
defineSymbol(math, rel, "\u22de", "\\curlyeqprec", true);
defineSymbol(math, rel, "\u227e", "\\precsim", true);
defineSymbol(math, rel, "\u2ab7", "\\precapprox", true);
defineSymbol(math, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, rel, "\u22a8", "\\vDash", true);
defineSymbol(math, rel, "\u22ab", "\\VDash", true);
defineSymbol(math, rel, "\u22aa", "\\Vvdash", true);
defineSymbol(math, rel, "\u2323", "\\smallsmile");
defineSymbol(math, rel, "\u2322", "\\smallfrown");
defineSymbol(math, rel, "\u224f", "\\bumpeq", true);
defineSymbol(math, rel, "\u224e", "\\Bumpeq", true);
defineSymbol(math, rel, "\u2267", "\\geqq", true);
defineSymbol(math, rel, "\u2a7e", "\\geqslant", true);
defineSymbol(math, rel, "\u2a96", "\\eqslantgtr", true);
defineSymbol(math, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, rel, "\u2a86", "\\gtrapprox", true);
defineSymbol(math, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, rel, "\u22d9", "\\ggg", true);
defineSymbol(math, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, rel, "\u22db", "\\gtreqless", true);
defineSymbol(math, rel, "\u2a8c", "\\gtreqqless", true);
defineSymbol(math, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, rel, "\u2257", "\\circeq", true);
defineSymbol(math, rel, "\u225c", "\\triangleq", true);
defineSymbol(math, rel, "\u223c", "\\thicksim");
defineSymbol(math, rel, "\u2248", "\\thickapprox");
defineSymbol(math, rel, "\u2ac6", "\\supseteqq", true);
defineSymbol(math, rel, "\u22d1", "\\Supset", true);
defineSymbol(math, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, rel, "\u227d", "\\succcurlyeq", true);
defineSymbol(math, rel, "\u22df", "\\curlyeqsucc", true);
defineSymbol(math, rel, "\u227f", "\\succsim", true);
defineSymbol(math, rel, "\u2ab8", "\\succapprox", true);
defineSymbol(math, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, rel, "\u22a9", "\\Vdash", true);
defineSymbol(math, rel, "\u2223", "\\shortmid");
defineSymbol(math, rel, "\u2225", "\\shortparallel");
defineSymbol(math, rel, "\u226c", "\\between", true);
defineSymbol(math, rel, "\u22d4", "\\pitchfork", true);
defineSymbol(math, rel, "\u221d", "\\varpropto");
defineSymbol(math, rel, "\u25c0", "\\blacktriangleleft");
// unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2234", "\\therefore", true);
defineSymbol(math, rel, "\u220d", "\\backepsilon");
defineSymbol(math, rel, "\u25b6", "\\blacktriangleright");
// unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2235", "\\because", true);
defineSymbol(math, rel, "\u22d8", "\\llless");
defineSymbol(math, rel, "\u22d9", "\\gggtr");
defineSymbol(math, bin, "\u22b2", "\\lhd");
defineSymbol(math, bin, "\u22b3", "\\rhd");
defineSymbol(math, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, rel, "\u2251", "\\Doteq", true);
defineSymbol(math, rel, "\u297d", "\\strictif", true);
defineSymbol(math, rel, "\u297c", "\\strictfi", true);

// AMS Binary Operators
defineSymbol(math, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, bin, "\u22d2", "\\Cap", true);
defineSymbol(math, bin, "\u22d3", "\\Cup", true);
defineSymbol(math, bin, "\u2a5e", "\\doublebarwedge", true);
defineSymbol(math, bin, "\u229f", "\\boxminus", true);
defineSymbol(math, bin, "\u229e", "\\boxplus", true);
defineSymbol(math, bin, "\u29C4", "\\boxslash", true);
defineSymbol(math, bin, "\u22c7", "\\divideontimes", true);
defineSymbol(math, bin, "\u22c9", "\\ltimes", true);
defineSymbol(math, bin, "\u22ca", "\\rtimes", true);
defineSymbol(math, bin, "\u22cb", "\\leftthreetimes", true);
defineSymbol(math, bin, "\u22cc", "\\rightthreetimes", true);
defineSymbol(math, bin, "\u22cf", "\\curlywedge", true);
defineSymbol(math, bin, "\u22ce", "\\curlyvee", true);
defineSymbol(math, bin, "\u229d", "\\circleddash", true);
defineSymbol(math, bin, "\u229b", "\\circledast", true);
defineSymbol(math, bin, "\u22ba", "\\intercal", true);
defineSymbol(math, bin, "\u22d2", "\\doublecap");
defineSymbol(math, bin, "\u22d3", "\\doublecup");
defineSymbol(math, bin, "\u22a0", "\\boxtimes", true);
defineSymbol(math, bin, "\u22c8", "\\bowtie", true);
defineSymbol(math, bin, "\u22c8", "\\Join");
defineSymbol(math, bin, "\u27d5", "\\leftouterjoin", true);
defineSymbol(math, bin, "\u27d6", "\\rightouterjoin", true);
defineSymbol(math, bin, "\u27d7", "\\fullouterjoin", true);

// stix Binary Operators
defineSymbol(math, bin, "\u2238", "\\dotminus", true);
defineSymbol(math, bin, "\u27D1", "\\wedgedot", true);
defineSymbol(math, bin, "\u27C7", "\\veedot", true);
defineSymbol(math, bin, "\u2A62", "\\doublebarvee", true);
defineSymbol(math, bin, "\u2A63", "\\veedoublebar", true);
defineSymbol(math, bin, "\u2A5F", "\\wedgebar", true);
defineSymbol(math, bin, "\u2A60", "\\wedgedoublebar", true);
defineSymbol(math, bin, "\u2A54", "\\Vee", true);
defineSymbol(math, bin, "\u2A53", "\\Wedge", true);
defineSymbol(math, bin, "\u2A43", "\\barcap", true);
defineSymbol(math, bin, "\u2A42", "\\barcup", true);
defineSymbol(math, bin, "\u2A48", "\\capbarcup", true);
defineSymbol(math, bin, "\u2A40", "\\capdot", true);
defineSymbol(math, bin, "\u2A47", "\\capovercup", true);
defineSymbol(math, bin, "\u2A46", "\\cupovercap", true);
defineSymbol(math, bin, "\u2A4D", "\\closedvarcap", true);
defineSymbol(math, bin, "\u2A4C", "\\closedvarcup", true);
defineSymbol(math, bin, "\u2A2A", "\\minusdot", true);
defineSymbol(math, bin, "\u2A2B", "\\minusfdots", true);
defineSymbol(math, bin, "\u2A2C", "\\minusrdots", true);
defineSymbol(math, bin, "\u22BB", "\\Xor", true);
defineSymbol(math, bin, "\u22BC", "\\Nand", true);
defineSymbol(math, bin, "\u22BD", "\\Nor", true);
defineSymbol(math, bin, "\u22BD", "\\barvee");
defineSymbol(math, bin, "\u2AF4", "\\interleave", true);
defineSymbol(math, bin, "\u29E2", "\\shuffle", true);
defineSymbol(math, bin, "\u2AF6", "\\threedotcolon", true);
defineSymbol(math, bin, "\u2982", "\\typecolon", true);
defineSymbol(math, bin, "\u223E", "\\invlazys", true);
defineSymbol(math, bin, "\u2A4B", "\\twocaps", true);
defineSymbol(math, bin, "\u2A4A", "\\twocups", true);
defineSymbol(math, bin, "\u2A4E", "\\Sqcap", true);
defineSymbol(math, bin, "\u2A4F", "\\Sqcup", true);
defineSymbol(math, bin, "\u2A56", "\\veeonvee", true);
defineSymbol(math, bin, "\u2A55", "\\wedgeonwedge", true);
defineSymbol(math, bin, "\u29D7", "\\blackhourglass", true);
defineSymbol(math, bin, "\u29C6", "\\boxast", true);
defineSymbol(math, bin, "\u29C8", "\\boxbox", true);
defineSymbol(math, bin, "\u29C7", "\\boxcircle", true);
defineSymbol(math, bin, "\u229C", "\\circledequal", true);
defineSymbol(math, bin, "\u29B7", "\\circledparallel", true);
defineSymbol(math, bin, "\u29B6", "\\circledvert", true);
defineSymbol(math, bin, "\u29B5", "\\circlehbar", true);
defineSymbol(math, bin, "\u27E1", "\\concavediamond", true);
defineSymbol(math, bin, "\u27E2", "\\concavediamondtickleft", true);
defineSymbol(math, bin, "\u27E3", "\\concavediamondtickright", true);
defineSymbol(math, bin, "\u22C4", "\\diamond", true);
defineSymbol(math, bin, "\u29D6", "\\hourglass", true);
defineSymbol(math, bin, "\u27E0", "\\lozengeminus", true);
defineSymbol(math, bin, "\u233D", "\\obar", true);
defineSymbol(math, bin, "\u29B8", "\\obslash", true);
defineSymbol(math, bin, "\u2A38", "\\odiv", true);
defineSymbol(math, bin, "\u29C1", "\\ogreaterthan", true);
defineSymbol(math, bin, "\u29C0", "\\olessthan", true);
defineSymbol(math, bin, "\u29B9", "\\operp", true);
defineSymbol(math, bin, "\u2A37", "\\Otimes", true);
defineSymbol(math, bin, "\u2A36", "\\otimeshat", true);
defineSymbol(math, bin, "\u22C6", "\\star", true);
defineSymbol(math, bin, "\u25B3", "\\triangle", true);
defineSymbol(math, bin, "\u2A3A", "\\triangleminus", true);
defineSymbol(math, bin, "\u2A39", "\\triangleplus", true);
defineSymbol(math, bin, "\u2A3B", "\\triangletimes", true);
defineSymbol(math, bin, "\u27E4", "\\whitesquaretickleft", true);
defineSymbol(math, bin, "\u27E5", "\\whitesquaretickright", true);
defineSymbol(math, bin, "\u2A33", "\\smashtimes", true);

// AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.
defineSymbol(math, rel, "\u21e2", "\\dashrightarrow", true);
// unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21e0", "\\dashleftarrow", true);
defineSymbol(math, rel, "\u21c7", "\\leftleftarrows", true);
defineSymbol(math, rel, "\u21c6", "\\leftrightarrows", true);
defineSymbol(math, rel, "\u21da", "\\Lleftarrow", true);
defineSymbol(math, rel, "\u219e", "\\twoheadleftarrow", true);
defineSymbol(math, rel, "\u21a2", "\\leftarrowtail", true);
defineSymbol(math, rel, "\u21ab", "\\looparrowleft", true);
defineSymbol(math, rel, "\u21cb", "\\leftrightharpoons", true);
defineSymbol(math, rel, "\u21b6", "\\curvearrowleft", true);
// unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21ba", "\\circlearrowleft", true);
defineSymbol(math, rel, "\u21b0", "\\Lsh", true);
defineSymbol(math, rel, "\u21c8", "\\upuparrows", true);
defineSymbol(math, rel, "\u21bf", "\\upharpoonleft", true);
defineSymbol(math, rel, "\u21c3", "\\downharpoonleft", true);
defineSymbol(math, rel, "\u22b6", "\\origof", true);
defineSymbol(math, rel, "\u22b7", "\\imageof", true);
defineSymbol(math, rel, "\u22b8", "\\multimap", true);
defineSymbol(math, rel, "\u21ad", "\\leftrightsquigarrow", true);
defineSymbol(math, rel, "\u21c9", "\\rightrightarrows", true);
defineSymbol(math, rel, "\u21c4", "\\rightleftarrows", true);
defineSymbol(math, rel, "\u21a0", "\\twoheadrightarrow", true);
defineSymbol(math, rel, "\u21a3", "\\rightarrowtail", true);
defineSymbol(math, rel, "\u21ac", "\\looparrowright", true);
defineSymbol(math, rel, "\u21b7", "\\curvearrowright", true);
// unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21bb", "\\circlearrowright", true);
defineSymbol(math, rel, "\u21b1", "\\Rsh", true);
defineSymbol(math, rel, "\u21ca", "\\downdownarrows", true);
defineSymbol(math, rel, "\u21be", "\\upharpoonright", true);
defineSymbol(math, rel, "\u21c2", "\\downharpoonright", true);
defineSymbol(math, rel, "\u21dd", "\\rightsquigarrow", true);
defineSymbol(math, rel, "\u21dd", "\\leadsto");
defineSymbol(math, rel, "\u21db", "\\Rrightarrow", true);
defineSymbol(math, rel, "\u21be", "\\restriction");

defineSymbol(math, textord, "\u2018", "`");
defineSymbol(math, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\textdollar");
defineSymbol(math, textord, "¢", "\\cent");
defineSymbol(text, textord, "¢", "\\cent");
defineSymbol(math, textord, "%", "\\%");
defineSymbol(text, textord, "%", "\\%");
defineSymbol(math, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\textunderscore");
defineSymbol(text, textord, "\u2423", "\\textvisiblespace", true);
defineSymbol(math, textord, "\u2220", "\\angle", true);
defineSymbol(math, textord, "\u221e", "\\infty", true);
defineSymbol(math, textord, "\u2032", "\\prime");
defineSymbol(math, textord, "\u2033", "\\dprime");
defineSymbol(math, textord, "\u2034", "\\trprime");
defineSymbol(math, textord, "\u2057", "\\qprime");
defineSymbol(math, textord, "\u25b3", "\\triangle");
defineSymbol(text, textord, "\u0391", "\\Alpha", true);
defineSymbol(text, textord, "\u0392", "\\Beta", true);
defineSymbol(text, textord, "\u0393", "\\Gamma", true);
defineSymbol(text, textord, "\u0394", "\\Delta", true);
defineSymbol(text, textord, "\u0395", "\\Epsilon", true);
defineSymbol(text, textord, "\u0396", "\\Zeta", true);
defineSymbol(text, textord, "\u0397", "\\Eta", true);
defineSymbol(text, textord, "\u0398", "\\Theta", true);
defineSymbol(text, textord, "\u0399", "\\Iota", true);
defineSymbol(text, textord, "\u039a", "\\Kappa", true);
defineSymbol(text, textord, "\u039b", "\\Lambda", true);
defineSymbol(text, textord, "\u039c", "\\Mu", true);
defineSymbol(text, textord, "\u039d", "\\Nu", true);
defineSymbol(text, textord, "\u039e", "\\Xi", true);
defineSymbol(text, textord, "\u039f", "\\Omicron", true);
defineSymbol(text, textord, "\u03a0", "\\Pi", true);
defineSymbol(text, textord, "\u03a1", "\\Rho", true);
defineSymbol(text, textord, "\u03a3", "\\Sigma", true);
defineSymbol(text, textord, "\u03a4", "\\Tau", true);
defineSymbol(text, textord, "\u03a5", "\\Upsilon", true);
defineSymbol(text, textord, "\u03a6", "\\Phi", true);
defineSymbol(text, textord, "\u03a7", "\\Chi", true);
defineSymbol(text, textord, "\u03a8", "\\Psi", true);
defineSymbol(text, textord, "\u03a9", "\\Omega", true);
defineSymbol(math, mathord, "\u0391", "\\Alpha", true);
defineSymbol(math, mathord, "\u0392", "\\Beta", true);
defineSymbol(math, mathord, "\u0393", "\\Gamma", true);
defineSymbol(math, mathord, "\u0394", "\\Delta", true);
defineSymbol(math, mathord, "\u0395", "\\Epsilon", true);
defineSymbol(math, mathord, "\u0396", "\\Zeta", true);
defineSymbol(math, mathord, "\u0397", "\\Eta", true);
defineSymbol(math, mathord, "\u0398", "\\Theta", true);
defineSymbol(math, mathord, "\u0399", "\\Iota", true);
defineSymbol(math, mathord, "\u039a", "\\Kappa", true);
defineSymbol(math, mathord, "\u039b", "\\Lambda", true);
defineSymbol(math, mathord, "\u039c", "\\Mu", true);
defineSymbol(math, mathord, "\u039d", "\\Nu", true);
defineSymbol(math, mathord, "\u039e", "\\Xi", true);
defineSymbol(math, mathord, "\u039f", "\\Omicron", true);
defineSymbol(math, mathord, "\u03a0", "\\Pi", true);
defineSymbol(math, mathord, "\u03a1", "\\Rho", true);
defineSymbol(math, mathord, "\u03a3", "\\Sigma", true);
defineSymbol(math, mathord, "\u03a4", "\\Tau", true);
defineSymbol(math, mathord, "\u03a5", "\\Upsilon", true);
defineSymbol(math, mathord, "\u03a6", "\\Phi", true);
defineSymbol(math, mathord, "\u03a7", "\\Chi", true);
defineSymbol(math, mathord, "\u03a8", "\\Psi", true);
defineSymbol(math, mathord, "\u03a9", "\\Omega", true);
defineSymbol(math, open, "\u00ac", "\\neg", true);
defineSymbol(math, open, "\u00ac", "\\lnot");
defineSymbol(math, textord, "\u22a4", "\\top");
defineSymbol(math, textord, "\u22a5", "\\bot");
defineSymbol(math, textord, "\u2205", "\\emptyset");
defineSymbol(math, textord, "\u2300", "\\varnothing");
defineSymbol(math, mathord, "\u03b1", "\\alpha", true);
defineSymbol(math, mathord, "\u03b2", "\\beta", true);
defineSymbol(math, mathord, "\u03b3", "\\gamma", true);
defineSymbol(math, mathord, "\u03b4", "\\delta", true);
defineSymbol(math, mathord, "\u03f5", "\\epsilon", true);
defineSymbol(math, mathord, "\u03b6", "\\zeta", true);
defineSymbol(math, mathord, "\u03b7", "\\eta", true);
defineSymbol(math, mathord, "\u03b8", "\\theta", true);
defineSymbol(math, mathord, "\u03b9", "\\iota", true);
defineSymbol(math, mathord, "\u03ba", "\\kappa", true);
defineSymbol(math, mathord, "\u03bb", "\\lambda", true);
defineSymbol(math, mathord, "\u03bc", "\\mu", true);
defineSymbol(math, mathord, "\u03bd", "\\nu", true);
defineSymbol(math, mathord, "\u03be", "\\xi", true);
defineSymbol(math, mathord, "\u03bf", "\\omicron", true);
defineSymbol(math, mathord, "\u03c0", "\\pi", true);
defineSymbol(math, mathord, "\u03c1", "\\rho", true);
defineSymbol(math, mathord, "\u03c3", "\\sigma", true);
defineSymbol(math, mathord, "\u03c4", "\\tau", true);
defineSymbol(math, mathord, "\u03c5", "\\upsilon", true);
defineSymbol(math, mathord, "\u03d5", "\\phi", true);
defineSymbol(math, mathord, "\u03c7", "\\chi", true);
defineSymbol(math, mathord, "\u03c8", "\\psi", true);
defineSymbol(math, mathord, "\u03c9", "\\omega", true);
defineSymbol(math, mathord, "\u03b5", "\\varepsilon", true);
defineSymbol(math, mathord, "\u03d1", "\\vartheta", true);
defineSymbol(math, mathord, "\u03d6", "\\varpi", true);
defineSymbol(math, mathord, "\u03f1", "\\varrho", true);
defineSymbol(math, mathord, "\u03c2", "\\varsigma", true);
defineSymbol(math, mathord, "\u03c6", "\\varphi", true);
defineSymbol(math, mathord, "\u03d8", "\\Coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\varcoppa", true);
defineSymbol(math, mathord, "\u03de", "\\Koppa", true);
defineSymbol(math, mathord, "\u03df", "\\koppa", true);
defineSymbol(math, mathord, "\u03e0", "\\Sampi", true);
defineSymbol(math, mathord, "\u03e1", "\\sampi", true);
defineSymbol(math, mathord, "\u03da", "\\Stigma", true);
defineSymbol(math, mathord, "\u03db", "\\stigma", true);
defineSymbol(math, mathord, "\u2aeb", "\\Bot");
defineSymbol(math, bin, "\u2217", "\u2217", true);
defineSymbol(math, bin, "+", "+");
defineSymbol(math, bin, "\u2217", "*");
defineSymbol(math, bin, "\u2044", "/", true);
defineSymbol(math, bin, "\u2044", "\u2044");
defineSymbol(math, bin, "\u2212", "-", true);
defineSymbol(math, bin, "\u22c5", "\\cdot", true);
defineSymbol(math, bin, "\u2218", "\\circ", true);
defineSymbol(math, bin, "\u00f7", "\\div", true);
defineSymbol(math, bin, "\u00b1", "\\pm", true);
defineSymbol(math, bin, "\u00d7", "\\times", true);
defineSymbol(math, bin, "\u2229", "\\cap", true);
defineSymbol(math, bin, "\u222a", "\\cup", true);
defineSymbol(math, bin, "\u2216", "\\setminus", true);
defineSymbol(math, bin, "\u2227", "\\land");
defineSymbol(math, bin, "\u2228", "\\lor");
defineSymbol(math, bin, "\u2227", "\\wedge", true);
defineSymbol(math, bin, "\u2228", "\\vee", true);
defineSymbol(math, open, "\u27e6", "\\llbracket", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u27e7", "\\rrbracket", true);
defineSymbol(math, open, "\u27e8", "\\langle", true);
defineSymbol(math, open, "\u27ea", "\\lAngle", true);
defineSymbol(math, open, "\u2989", "\\llangle", true);
defineSymbol(math, open, "|", "\\lvert");
defineSymbol(math, open, "\u2016", "\\lVert", true);
defineSymbol(math, textord, "!", "\\oc"); // cmll package
defineSymbol(math, textord, "?", "\\wn");
defineSymbol(math, textord, "\u2193", "\\shpos");
defineSymbol(math, textord, "\u2195", "\\shift");
defineSymbol(math, textord, "\u2191", "\\shneg");
defineSymbol(math, close, "?", "?");
defineSymbol(math, close, "!", "!");
defineSymbol(math, close, "‼", "‼");
defineSymbol(math, close, "\u27e9", "\\rangle", true);
defineSymbol(math, close, "\u27eb", "\\rAngle", true);
defineSymbol(math, close, "\u298a", "\\rrangle", true);
defineSymbol(math, close, "|", "\\rvert");
defineSymbol(math, close, "\u2016", "\\rVert");
defineSymbol(math, open, "\u2983", "\\lBrace", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u2984", "\\rBrace", true);
defineSymbol(math, rel, "=", "\\equal", true);
defineSymbol(math, rel, ":", ":");
defineSymbol(math, rel, "\u2248", "\\approx", true);
defineSymbol(math, rel, "\u2245", "\\cong", true);
defineSymbol(math, rel, "\u2265", "\\ge");
defineSymbol(math, rel, "\u2265", "\\geq", true);
defineSymbol(math, rel, "\u2190", "\\gets");
defineSymbol(math, rel, ">", "\\gt", true);
defineSymbol(math, rel, "\u2208", "\\in", true);
defineSymbol(math, rel, "\u2209", "\\notin", true);
defineSymbol(math, rel, "\ue020", "\\@not");
defineSymbol(math, rel, "\u2282", "\\subset", true);
defineSymbol(math, rel, "\u2283", "\\supset", true);
defineSymbol(math, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteqq");
defineSymbol(math, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, rel, "\u2289", "\\nsupseteqq");
defineSymbol(math, rel, "\u22a8", "\\models");
defineSymbol(math, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, rel, "\u2264", "\\le");
defineSymbol(math, rel, "\u2264", "\\leq", true);
defineSymbol(math, rel, "<", "\\lt", true);
defineSymbol(math, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, rel, "\u2192", "\\to");
defineSymbol(math, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, rel, "\u2271", "\\ngeqq");
defineSymbol(math, rel, "\u2271", "\\ngeqslant");
defineSymbol(math, rel, "\u2270", "\\nleq", true);
defineSymbol(math, rel, "\u2270", "\\nleqq");
defineSymbol(math, rel, "\u2270", "\\nleqslant");
defineSymbol(math, rel, "\u2aeb", "\\Perp", true); //cmll package
defineSymbol(math, spacing, "\u00a0", "\\ ");
defineSymbol(math, spacing, "\u00a0", "\\space");
// Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%
defineSymbol(math, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(text, spacing, "\u00a0", "\\ ");
defineSymbol(text, spacing, "\u00a0", " ");
defineSymbol(text, spacing, "\u00a0", "\\space");
defineSymbol(text, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(math, spacing, null, "\\nobreak");
defineSymbol(math, spacing, null, "\\allowbreak");
defineSymbol(math, punct, ",", ",");
defineSymbol(text, punct, ":", ":");
defineSymbol(math, punct, ";", ";");
defineSymbol(math, bin, "\u22bc", "\\barwedge");
defineSymbol(math, bin, "\u22bb", "\\veebar");
defineSymbol(math, bin, "\u2299", "\\odot", true);
// Firefox turns ⊕ into an emoji. So append \uFE0E. Define Unicode character in macros, not here.
defineSymbol(math, bin, "\u2295\uFE0E", "\\oplus");
defineSymbol(math, bin, "\u2297", "\\otimes", true);
defineSymbol(math, textord, "\u2202", "\\partial", true);
defineSymbol(math, bin, "\u2298", "\\oslash", true);
defineSymbol(math, bin, "\u229a", "\\circledcirc", true);
defineSymbol(math, bin, "\u22a1", "\\boxdot", true);
defineSymbol(math, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, bin, "\u2020", "\\dagger");
defineSymbol(math, bin, "\u22c4", "\\diamond");
defineSymbol(math, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, bin, "\u25b9", "\\triangleright");
defineSymbol(math, open, "{", "\\{");
defineSymbol(text, textord, "{", "\\{");
defineSymbol(text, textord, "{", "\\textbraceleft");
defineSymbol(math, close, "}", "\\}");
defineSymbol(text, textord, "}", "\\}");
defineSymbol(text, textord, "}", "\\textbraceright");
defineSymbol(math, open, "{", "\\lbrace");
defineSymbol(math, close, "}", "\\rbrace");
defineSymbol(math, open, "[", "\\lbrack", true);
defineSymbol(text, textord, "[", "\\lbrack", true);
defineSymbol(math, close, "]", "\\rbrack", true);
defineSymbol(text, textord, "]", "\\rbrack", true);
defineSymbol(math, open, "(", "\\lparen", true);
defineSymbol(math, close, ")", "\\rparen", true);
defineSymbol(math, open, "⦇", "\\llparenthesis", true);
defineSymbol(math, close, "⦈", "\\rrparenthesis", true);
defineSymbol(text, textord, "<", "\\textless", true); // in T1 fontenc
defineSymbol(text, textord, ">", "\\textgreater", true); // in T1 fontenc
defineSymbol(math, open, "\u230a", "\\lfloor", true);
defineSymbol(math, close, "\u230b", "\\rfloor", true);
defineSymbol(math, open, "\u2308", "\\lceil", true);
defineSymbol(math, close, "\u2309", "\\rceil", true);
defineSymbol(math, textord, "\\", "\\backslash");
defineSymbol(math, textord, "|", "|");
defineSymbol(math, textord, "|", "\\vert");
defineSymbol(text, textord, "|", "\\textbar", true); // in T1 fontenc
defineSymbol(math, textord, "\u2016", "\\|");
defineSymbol(math, textord, "\u2016", "\\Vert");
defineSymbol(text, textord, "\u2016", "\\textbardbl");
defineSymbol(text, textord, "~", "\\textasciitilde");
defineSymbol(text, textord, "\\", "\\textbackslash");
defineSymbol(text, textord, "^", "\\textasciicircum");
defineSymbol(math, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, rel, "\u21d1", "\\Uparrow", true);
defineSymbol(math, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, rel, "\u21d3", "\\Downarrow", true);
defineSymbol(math, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, rel, "\u21d5", "\\Updownarrow", true);
defineSymbol(math, op, "\u2210", "\\coprod");
defineSymbol(math, op, "\u22c1", "\\bigvee");
defineSymbol(math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, op, "\u2a04", "\\biguplus");
defineSymbol(math, op, "\u2a04", "\\bigcupplus");
defineSymbol(math, op, "\u2a03", "\\bigcupdot");
defineSymbol(math, op, "\u2a07", "\\bigdoublevee");
defineSymbol(math, op, "\u2a08", "\\bigdoublewedge");
defineSymbol(math, op, "\u22c2", "\\bigcap");
defineSymbol(math, op, "\u22c3", "\\bigcup");
defineSymbol(math, op, "\u222b", "\\int");
defineSymbol(math, op, "\u222b", "\\intop");
defineSymbol(math, op, "\u222c", "\\iint");
defineSymbol(math, op, "\u222d", "\\iiint");
defineSymbol(math, op, "\u220f", "\\prod");
defineSymbol(math, op, "\u2211", "\\sum");
defineSymbol(math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, op, "\u2a00", "\\bigodot");
defineSymbol(math, op, "\u2a09", "\\bigtimes");
defineSymbol(math, op, "\u222e", "\\oint");
defineSymbol(math, op, "\u222f", "\\oiint");
defineSymbol(math, op, "\u2230", "\\oiiint");
defineSymbol(math, op, "\u2231", "\\intclockwise");
defineSymbol(math, op, "\u2232", "\\varointclockwise");
defineSymbol(math, op, "\u2a0c", "\\iiiint");
defineSymbol(math, op, "\u2a0d", "\\intbar");
defineSymbol(math, op, "\u2a0e", "\\intBar");
defineSymbol(math, op, "\u2a0f", "\\fint");
defineSymbol(math, op, "\u2a12", "\\rppolint");
defineSymbol(math, op, "\u2a13", "\\scpolint");
defineSymbol(math, op, "\u2a15", "\\pointint");
defineSymbol(math, op, "\u2a16", "\\sqint");
defineSymbol(math, op, "\u2a17", "\\intlarhk");
defineSymbol(math, op, "\u2a18", "\\intx");
defineSymbol(math, op, "\u2a19", "\\intcap");
defineSymbol(math, op, "\u2a1a", "\\intcup");
defineSymbol(math, op, "\u2a05", "\\bigsqcap");
defineSymbol(math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, op, "\u222b", "\\smallint");
defineSymbol(text, inner, "\u2026", "\\textellipsis");
defineSymbol(math, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u22f0", "\\iddots", true);
defineSymbol(math, inner, "\u22ef", "\\@cdots", true);
defineSymbol(math, inner, "\u22f1", "\\ddots", true);
defineSymbol(math, textord, "\u22ee", "\\varvdots"); // \vdots is a macro
defineSymbol(text, textord, "\u22ee", "\\varvdots");
defineSymbol(math, accent, "\u02ca", "\\acute");
defineSymbol(math, accent, "\u0060", "\\grave");
defineSymbol(math, accent, "\u00a8", "\\ddot");
defineSymbol(math, accent, "\u2026", "\\dddot");
defineSymbol(math, accent, "\u2026\u002e", "\\ddddot");
defineSymbol(math, accent, "\u007e", "\\tilde");
defineSymbol(math, accent, "\u203e", "\\bar");
defineSymbol(math, accent, "\u02d8", "\\breve");
defineSymbol(math, accent, "\u02c7", "\\check");
defineSymbol(math, accent, "\u005e", "\\hat");
defineSymbol(math, accent, "\u2192", "\\vec");
defineSymbol(math, accent, "\u02d9", "\\dot");
defineSymbol(math, accent, "\u02da", "\\mathring");
defineSymbol(math, mathord, "\u0131", "\\imath", true);
defineSymbol(math, mathord, "\u0237", "\\jmath", true);
defineSymbol(math, textord, "\u0131", "\u0131");
defineSymbol(math, textord, "\u0237", "\u0237");
defineSymbol(text, textord, "\u0131", "\\i", true);
defineSymbol(text, textord, "\u0237", "\\j", true);
defineSymbol(text, textord, "\u00df", "\\ss", true);
defineSymbol(text, textord, "\u00e6", "\\ae", true);
defineSymbol(text, textord, "\u0153", "\\oe", true);
defineSymbol(text, textord, "\u00f8", "\\o", true);
defineSymbol(math, mathord, "\u00f8", "\\o", true);
defineSymbol(text, textord, "\u00c6", "\\AE", true);
defineSymbol(text, textord, "\u0152", "\\OE", true);
defineSymbol(text, textord, "\u00d8", "\\O", true);
defineSymbol(math, mathord, "\u00d8", "\\O", true);
defineSymbol(text, accent, "\u02ca", "\\'"); // acute
defineSymbol(text, accent, "\u02cb", "\\`"); // grave
defineSymbol(text, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(text, accent, "\u02dc", "\\~"); // tilde
defineSymbol(text, accent, "\u02c9", "\\="); // macron
defineSymbol(text, accent, "\u02d8", "\\u"); // breve
defineSymbol(text, accent, "\u02d9", "\\."); // dot above
defineSymbol(text, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(text, accent, "\u02da", "\\r"); // ring above
defineSymbol(text, accent, "\u02c7", "\\v"); // caron
defineSymbol(text, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(text, accent, "\u02dd", "\\H"); // double acute
defineSymbol(math, accent, "\u02ca", "\\'"); // acute
defineSymbol(math, accent, "\u02cb", "\\`"); // grave
defineSymbol(math, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(math, accent, "\u02dc", "\\~"); // tilde
defineSymbol(math, accent, "\u02c9", "\\="); // macron
defineSymbol(math, accent, "\u02d8", "\\u"); // breve
defineSymbol(math, accent, "\u02d9", "\\."); // dot above
defineSymbol(math, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(math, accent, "\u02da", "\\r"); // ring above
defineSymbol(math, accent, "\u02c7", "\\v"); // caron
defineSymbol(math, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(math, accent, "\u02dd", "\\H"); // double acute

// These ligatures are detected and created in Parser.js's `formLigatures`.
const ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};

defineSymbol(text, textord, "\u2013", "--", true);
defineSymbol(text, textord, "\u2013", "\\textendash");
defineSymbol(text, textord, "\u2014", "---", true);
defineSymbol(text, textord, "\u2014", "\\textemdash");
defineSymbol(text, textord, "\u2018", "`", true);
defineSymbol(text, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, textord, "\u2019", "'", true);
defineSymbol(text, textord, "\u2019", "\\textquoteright");
defineSymbol(text, textord, "\u201c", "``", true);
defineSymbol(text, textord, "\u201c", "\\textquotedblleft");
defineSymbol(text, textord, "\u201d", "''", true);
defineSymbol(text, textord, "\u201d", "\\textquotedblright");
//  \degree from gensymb package
defineSymbol(math, textord, "\u00b0", "\\degree", true);
defineSymbol(text, textord, "\u00b0", "\\degree");
// \textdegree from inputenc package
defineSymbol(text, textord, "\u00b0", "\\textdegree", true);
// TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Regular defines this character "163".
defineSymbol(math, textord, "\u00a3", "\\pounds");
defineSymbol(math, textord, "\u00a3", "\\mathsterling", true);
defineSymbol(text, textord, "\u00a3", "\\pounds");
defineSymbol(text, textord, "\u00a3", "\\textsterling", true);
defineSymbol(math, textord, "\u2720", "\\maltese");
defineSymbol(text, textord, "\u2720", "\\maltese");
defineSymbol(math, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\texteuro");
defineSymbol(math, textord, "\u00a9", "\\copyright", true);
defineSymbol(text, textord, "\u00a9", "\\textcopyright");
defineSymbol(math, textord, "\u2300", "\\diameter", true);
defineSymbol(text, textord, "\u2300", "\\diameter");

// Italic Greek
defineSymbol(math, textord, "𝛤", "\\varGamma");
defineSymbol(math, textord, "𝛥", "\\varDelta");
defineSymbol(math, textord, "𝛩", "\\varTheta");
defineSymbol(math, textord, "𝛬", "\\varLambda");
defineSymbol(math, textord, "𝛯", "\\varXi");
defineSymbol(math, textord, "𝛱", "\\varPi");
defineSymbol(math, textord, "𝛴", "\\varSigma");
defineSymbol(math, textord, "𝛶", "\\varUpsilon");
defineSymbol(math, textord, "𝛷", "\\varPhi");
defineSymbol(math, textord, "𝛹", "\\varPsi");
defineSymbol(math, textord, "𝛺", "\\varOmega");
defineSymbol(text, textord, "𝛤", "\\varGamma");
defineSymbol(text, textord, "𝛥", "\\varDelta");
defineSymbol(text, textord, "𝛩", "\\varTheta");
defineSymbol(text, textord, "𝛬", "\\varLambda");
defineSymbol(text, textord, "𝛯", "\\varXi");
defineSymbol(text, textord, "𝛱", "\\varPi");
defineSymbol(text, textord, "𝛴", "\\varSigma");
defineSymbol(text, textord, "𝛶", "\\varUpsilon");
defineSymbol(text, textord, "𝛷", "\\varPhi");
defineSymbol(text, textord, "𝛹", "\\varPsi");
defineSymbol(text, textord, "𝛺", "\\varOmega");


// There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode
const mathTextSymbols = '0123456789/@."';
for (let i = 0; i < mathTextSymbols.length; i++) {
  const ch = mathTextSymbols.charAt(i);
  defineSymbol(math, textord, ch, ch);
}

// All of these are textords in text mode
const textSymbols = '0123456789!@*()-=+";:?/.,';
for (let i = 0; i < textSymbols.length; i++) {
  const ch = textSymbols.charAt(i);
  defineSymbol(text, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (let i = 0; i < letters.length; i++) {
  const ch = letters.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// Some more letters in Unicode Basic Multilingual Plane.
const narrow = "ÇÐÞçþℂℍℕℙℚℝℤℎℏℊℋℌℐℑℒℓ℘ℛℜℬℰℱℳℭℨ";
for (let i = 0; i < narrow.length; i++) {
  const ch = narrow.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
let wideChar = "";
for (let i = 0; i < letters.length; i++) {
  // The hex numbers in the next line are a surrogate pair.
  // 0xD835 is the high surrogate for all letters in the range we support.
  // 0xDC00 is the low surrogate for bold A.
  wideChar = String.fromCharCode(0xd835, 0xdc00 + i); // A-Z a-z bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc34 + i); // A-Z a-z italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc68 + i); // A-Z a-z bold italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd04 + i); // A-Z a-z Fractur
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdda0 + i); // A-Z a-z sans-serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xddd4 + i); // A-Z a-z sans bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde08 + i); // A-Z a-z sans italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde70 + i); // A-Z a-z monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd38 + i); // A-Z a-z double struck
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  const ch = letters.charAt(i);
  wideChar = String.fromCharCode(0xd835, 0xdc9c + i); // A-Z a-z calligraphic
  defineSymbol(math, mathord, ch, wideChar);
  defineSymbol(text, textord, ch, wideChar);
}

// Next, some wide character numerals
for (let i = 0; i < 10; i++) {
  wideChar = String.fromCharCode(0xd835, 0xdfce + i); // 0-9 bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfe2 + i); // 0-9 sans serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfec + i); // 0-9 bold sans
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdff6 + i); // 0-9 monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);
}

/*
 * Neither Firefox nor Chrome support hard line breaks or soft line breaks.
 * (Despite https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs)
 * So Temml has work-arounds for both hard and soft breaks.
 * The work-arounds sadly do not work simultaneously. Any top-level hard
 * break makes soft line breaks impossible.
 *
 * Hard breaks are simulated by creating a <mtable> and putting each line in its own <mtr>.
 *
 * To create soft line breaks, Temml avoids using the <semantics> and <annotation> tags.
 * Then the top level of a <math> element can be occupied by <mrow> elements, and the browser
 * will break after a <mrow> if the expression extends beyond the container limit.
 *
 * The default is for soft line breaks after each top-level binary or
 * relational operator, per TeXbook p. 173. So we gather the expression into <mrow>s so that
 * each <mrow> ends in a binary or relational operator.
 *
 * An option is for soft line breaks before an "=" sign. That changes the <mrow>s.
 *
 * Soft line breaks will not work in Chromium and Safari, only Firefox.
 *
 * Hopefully browsers will someday do their own linebreaking and we will be able to delete
 * much of this module.
 */

const openDelims = "([{⌊⌈⟨⟮⎰⟦⦃";
const closeDelims = ")]}⌋⌉⟩⟯⎱⟦⦄";

function setLineBreaks(expression, wrapMode, isDisplayMode) {
  const mtrs = [];
  let mrows = [];
  let block = [];
  let numTopLevelEquals = 0;
  let i = 0;
  let level = 0;
  while (i < expression.length) {
    while (expression[i] instanceof DocumentFragment) {
      expression.splice(i, 1, ...expression[i].children); // Expand the fragment.
    }
    const node = expression[i];
    if (node.attributes && node.attributes.linebreak &&
      node.attributes.linebreak === "newline") {
      // A hard line break. Create a <mtr> for the current block.
      if (block.length > 0) {
        mrows.push(new mathMLTree.MathNode("mrow", block));
      }
      mrows.push(node);
      block = [];
      const mtd = new mathMLTree.MathNode("mtd", mrows);
      mtd.style.textAlign = "left";
      mtrs.push(new mathMLTree.MathNode("mtr", [mtd]));
      mrows = [];
      i += 1;
      continue
    }
    block.push(node);
    if (node.type && node.type === "mo" && node.children.length === 1 &&
        !Object.prototype.hasOwnProperty.call(node.attributes, "movablelimits")) {
      const ch = node.children[0].text;
      if (openDelims.indexOf(ch) > -1) {
        level += 1;
      } else if (closeDelims.indexOf(ch) > -1) {
        level -= 1;
      } else if (level === 0 && wrapMode === "=" && ch === "=") {
        numTopLevelEquals += 1;
        if (numTopLevelEquals > 1) {
          block.pop();
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [node];
        }
      } else if (level === 0 && wrapMode === "tex" && ch !== "∇") {
        // Check if the following node is a \nobreak text node, e.g. "~""
        const next = i < expression.length - 1 ? expression[i + 1] : null;
        let glueIsFreeOfNobreak = true;
        if (
          !(
            next &&
            next.type === "mtext" &&
            next.attributes.linebreak &&
            next.attributes.linebreak === "nobreak"
          )
        ) {
          // We may need to start a new block.
          // First, put any post-operator glue on same line as operator.
          for (let j = i + 1; j < expression.length; j++) {
            const nd = expression[j];
            if (
              nd.type &&
              nd.type === "mspace" &&
              !(nd.attributes.linebreak && nd.attributes.linebreak === "newline")
            ) {
              block.push(nd);
              i += 1;
              if (
                nd.attributes &&
                nd.attributes.linebreak &&
                nd.attributes.linebreak === "nobreak"
              ) {
                glueIsFreeOfNobreak = false;
              }
            } else {
              break;
            }
          }
        }
        if (glueIsFreeOfNobreak) {
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [];
        }
      }
    }
    i += 1;
  }
  if (block.length > 0) {
    const element = new mathMLTree.MathNode("mrow", block);
    mrows.push(element);
  }
  if (mtrs.length > 0) {
    const mtd = new mathMLTree.MathNode("mtd", mrows);
    mtd.style.textAlign = "left";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    mtrs.push(mtr);
    const mtable = new mathMLTree.MathNode("mtable", mtrs);
    if (!isDisplayMode) {
      mtable.setAttribute("columnalign", "left");
      mtable.setAttribute("rowspacing", "0em");
    }
    return mtable
  }
  return mathMLTree.newDocumentFragment(mrows);
}

/**
 * This file converts a parse tree into a corresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */


/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
const makeText = function(text, mode, style) {
  if (
    symbols[mode][text] &&
    symbols[mode][text].replace &&
    text.charCodeAt(0) !== 0xd835 &&
    !(
      Object.prototype.hasOwnProperty.call(ligatures, text) &&
      style &&
      ((style.fontFamily && style.fontFamily.slice(4, 6) === "tt") ||
        (style.font && style.font.slice(4, 6) === "tt"))
    )
  ) {
    text = symbols[mode][text].replace;
  }

  return new mathMLTree.TextNode(text);
};

const copyChar = (newRow, child) => {
  if (newRow.children.length === 0 ||
      newRow.children[newRow.children.length - 1].type !== "mtext") {
    const mtext = new mathMLTree.MathNode(
      "mtext",
      [new mathMLTree.TextNode(child.children[0].text)]
    );
    newRow.children.push(mtext);
  } else {
    newRow.children[newRow.children.length - 1].children[0].text += child.children[0].text;
  }
};

const consolidateText = mrow => {
  // If possible, consolidate adjacent <mtext> elements into a single element.
  if (mrow.type !== "mrow" && mrow.type !== "mstyle") { return mrow }
  if (mrow.children.length === 0) { return mrow } // empty group, e.g., \text{}
  const newRow = new mathMLTree.MathNode("mrow");
  for (let i = 0; i < mrow.children.length; i++) {
    const child = mrow.children[i];
    if (child.type === "mtext" && Object.keys(child.attributes).length === 0) {
      copyChar(newRow, child);
    } else if (child.type === "mrow") {
      // We'll also check the children of an mrow. One level only. No recursion.
      let canConsolidate = true;
      for (let j = 0; j < child.children.length; j++) {
        const grandChild = child.children[j];
        if (grandChild.type !== "mtext" || Object.keys(child.attributes).length !== 0) {
          canConsolidate = false;
          break
        }
      }
      if (canConsolidate) {
        for (let j = 0; j < child.children.length; j++) {
          const grandChild = child.children[j];
          copyChar(newRow, grandChild);
        }
      } else {
        newRow.children.push(child);
      }
    } else {
      newRow.children.push(child);
    }
  }
  for (let i = 0; i < newRow.children.length; i++) {
    if (newRow.children[i].type === "mtext") {
      const mtext = newRow.children[i];
      // Firefox does not render a space at either end of an <mtext> string.
      // To get proper rendering, we replace leading or trailing spaces with no-break spaces.
      if (mtext.children[0].text.charAt(0) === " ") {
        mtext.children[0].text = "\u00a0" + mtext.children[0].text.slice(1);
      }
      const L = mtext.children[0].text.length;
      if (L > 0 && mtext.children[0].text.charAt(L - 1) === " ") {
        mtext.children[0].text = mtext.children[0].text.slice(0, -1) + "\u00a0";
      }
      for (const [key, value] of Object.entries(mrow.attributes)) {
        mtext.attributes[key] = value;
      }
    }
  }
  if (newRow.children.length === 1 && newRow.children[0].type === "mtext") {
    return newRow.children[0]; // A consolidated <mtext>
  } else {
    return newRow
  }
};

/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */
const makeRow = function(body, semisimple = false) {
  if (body.length === 1 && !(body[0] instanceof DocumentFragment)) {
    return body[0];
  } else if (!semisimple) {
    // Suppress spacing on <mo> nodes at both ends of the row.
    if (body[0] instanceof MathNode && body[0].type === "mo" && !body[0].attributes.fence) {
      body[0].attributes.lspace = "0em";
      body[0].attributes.rspace = "0em";
    }
    const end = body.length - 1;
    if (body[end] instanceof MathNode && body[end].type === "mo" && !body[end].attributes.fence) {
      body[end].attributes.lspace = "0em";
      body[end].attributes.rspace = "0em";
    }
  }
  return new mathMLTree.MathNode("mrow", body);
};

/**
 * Check for <mi>.</mi> which is how a dot renders in MathML,
 * or <mo separator="true" lspace="0em" rspace="0em">,</mo>
 * which is how a braced comma {,} renders in MathML
 */
function isNumberPunctuation(group) {
  if (!group) {
    return false
  }
  if (group.type === 'mi' && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '.'
  } else if (group.type === "mtext" && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '\u2008' // punctuation space
  } else if (group.type === 'mo' && group.children.length === 1 &&
    group.getAttribute('separator') === 'true' &&
    group.getAttribute('lspace') === '0em' &&
    group.getAttribute('rspace') === '0em') {
    const child = group.children[0];
    return child instanceof TextNode && child.text === ','
  } else {
    return false
  }
}
const isComma = (expression, i) => {
  const node = expression[i];
  const followingNode = expression[i + 1];
  return (node.type === "atom" && node.text === ",") &&
    // Don't consolidate if there is a space after the comma.
    node.loc && followingNode.loc && node.loc.end === followingNode.loc.start
};

const isRel = item => {
  return (item.type === "atom" && item.family === "rel") ||
      (item.type === "mclass" && item.mclass === "mrel")
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also do a couple chores along the way:
 * (1) Suppress spacing when an author wraps an operator w/braces, as in {=}.
 * (2) Suppress spacing between two adjacent relations.
 */
const buildExpression = function(expression, style, semisimple = false) {
  if (!semisimple && expression.length === 1) {
    const group = buildGroup$1(expression[0], style);
    if (group instanceof MathNode && group.type === "mo") {
      // When TeX writers want to suppress spacing on an operator,
      // they often put the operator by itself inside braces.
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }

  const groups = [];
  const groupArray = [];
  let lastGroup;
  for (let i = 0; i < expression.length; i++) {
    groupArray.push(buildGroup$1(expression[i], style));
  }

  for (let i = 0; i < groupArray.length; i++) {
    const group = groupArray[i];

    // Suppress spacing between adjacent relations
    if (i < expression.length - 1 && isRel(expression[i]) && isRel(expression[i + 1])) {
      group.setAttribute("rspace", "0em");
    }
    if (i > 0 && isRel(expression[i]) && isRel(expression[i - 1])) {
      group.setAttribute("lspace", "0em");
    }

    // Concatenate numbers
    if (group.type === 'mn' && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (isNumberPunctuation(group) && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (lastGroup && lastGroup.type === "mn" && i < groupArray.length - 1 &&
      groupArray[i + 1].type === "mn" && isComma(expression, i)) {
      lastGroup.children.push(...group.children);
      continue
    } else if (group.type === 'mn' && isNumberPunctuation(lastGroup)) {
      // Concatenate <mi>.</mi> followed by <mn>...</mn>
      group.children = [...lastGroup.children, ...group.children];
      groups.pop();
    } else if ((group.type === 'msup' || group.type === 'msub') &&
        group.children.length >= 1 && lastGroup &&
        (lastGroup.type === 'mn' || isNumberPunctuation(lastGroup))) {
      // Put preceding <mn>...</mn> or <mi>.</mi> inside base of
      // <msup><mn>...base...</mn>...exponent...</msup> (or <msub>)
      const base = group.children[0];
      if (base instanceof MathNode && base.type === 'mn' && lastGroup) {
        base.children = [...lastGroup.children, ...base.children];
        groups.pop();
      }
    }
    groups.push(group);
    lastGroup = group;
  }
  return groups
};

/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */
const buildExpressionRow = function(expression, style, semisimple = false) {
  return makeRow(buildExpression(expression, style, semisimple), semisimple);
};

/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */
const buildGroup$1 = function(group, style) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }

  if (_mathmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    const result = _mathmlGroupBuilders[group.type](group, style);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};

const glue$1 = _ => {
  return new mathMLTree.MathNode("mtd", [], [], { padding: "0", width: "50%" })
};

const labelContainers = ["mrow", "mtd", "mtable", "mtr"];
const getLabel = parent => {
  for (const node of parent.children) {
    if (node.type && labelContainers.includes(node.type)) {
      if (node.classes && node.classes[0] === "tml-label") {
        const label = node.label;
        return label
      } else {
        const label = getLabel(node);
        if (label) { return label }
      }
    } else if (!node.type) {
      const label = getLabel(node);
      if (label) { return label }
    }
  }
};

const taggedExpression = (expression, tag, style, leqno) => {
  tag = buildExpressionRow(tag[0].body, style);
  tag = consolidateText(tag);
  tag.classes.push("tml-tag");

  const label = getLabel(expression); // from a \label{} function.
  expression = new mathMLTree.MathNode("mtd", [expression]);
  const rowArray = [glue$1(), expression, glue$1()];
  rowArray[leqno ? 0 : 2].classes.push(leqno ? "tml-left" : "tml-right");
  rowArray[leqno ? 0 : 2].children.push(tag);
  const mtr = new mathMLTree.MathNode("mtr", rowArray, ["tml-tageqn"]);
  if (label) { mtr.setAttribute("id", label); }
  const table = new mathMLTree.MathNode("mtable", [mtr]);
  table.style.width = "100%";
  table.setAttribute("displaystyle", "true");
  return table
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it.
 */
function buildMathML(tree, texExpression, style, settings) {
  // Strip off outer tag wrapper for processing below.
  let tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }

  const expression = buildExpression(tree, style);

  if (expression.length === 1 && expression[0] instanceof AnchorNode) {
    return expression[0]
  }

  const wrap = (settings.displayMode || settings.annotate) ? "none" : settings.wrap;

  const n1 = expression.length === 0 ? null : expression[0];
  let wrapper = expression.length === 1 && tag === null && (n1 instanceof MathNode)
      ? expression[0]
      : setLineBreaks(expression, wrap, settings.displayMode);

  if (tag) {
    wrapper = taggedExpression(wrapper, tag, style, settings.leqno);
  }

  if (settings.annotate) {
    // Build a TeX annotation of the source
    const annotation = new mathMLTree.MathNode(
      "annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    wrapper = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  }

  const math = new mathMLTree.MathNode("math", [wrapper]);

  if (settings.xml) {
    math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  }
  if (wrapper.style.width) {
    math.style.width = "100%";
  }
  if (settings.displayMode) {
    math.setAttribute("display", "block");
    math.style.display = "block math"; // necessary in Chromium.
    // Firefox and Safari do not recognize display: "block math".
    // Set a class so that the CSS file can set display: block.
    math.classes = ["tml-display"];
  }
  return math;
}

const smalls = "acegıȷmnopqrsuvwxyzαγεηικμνοπρςστυχωϕ𝐚𝐜𝐞𝐠𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐮𝐯𝐰𝐱𝐲𝐳";
const talls = "ABCDEFGHIJKLMNOPQRSTUVWXYZbdfhkltΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩβδλζφθψ"
             + "𝐀𝐁𝐂𝐃𝐄𝐅𝐆𝐇𝐈𝐉𝐊𝐋𝐌𝐍𝐎𝐏𝐐𝐑𝐒𝐓𝐔𝐕𝐖𝐗𝐘𝐙𝐛𝐝𝐟𝐡𝐤𝐥𝐭";
const longSmalls = new Set(["\\alpha", "\\gamma", "\\delta", "\\epsilon", "\\eta", "\\iota",
  "\\kappa", "\\mu", "\\nu", "\\pi", "\\rho", "\\sigma", "\\tau", "\\upsilon", "\\chi", "\\psi",
  "\\omega", "\\imath", "\\jmath"]);
const longTalls = new Set(["\\Gamma", "\\Delta", "\\Sigma", "\\Omega", "\\beta", "\\delta",
  "\\lambda", "\\theta", "\\psi"]);

const mathmlBuilder$a = (group, style) => {
  const accentNode = group.isStretchy
    ? stretchy.accentNode(group)
    : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);

  if (group.label === "\\vec") {
    accentNode.style.transform = "scale(0.75) translate(10%, 30%)";
  } else {
    accentNode.style.mathStyle = "normal";
    accentNode.style.mathDepth = "0";
    if (needWebkitShift.has(group.label) &&  utils.isCharacterBox(group.base)) {
      let shift = "";
      const ch = group.base.text;
      if (smalls.indexOf(ch) > -1 || longSmalls.has(ch)) { shift = "tml-xshift"; }
      if (talls.indexOf(ch) > -1  || longTalls.has(ch))  { shift = "tml-capshift"; }
      if (shift) { accentNode.classes.push(shift); }
    }
  }
  if (!group.isStretchy) {
    accentNode.setAttribute("stretchy", "false");
  }

  const node = new mathMLTree.MathNode((group.label === "\\c" ? "munder" : "mover"),
    [buildGroup$1(group.base, style), accentNode]
  );

  return node;
};

const nonStretchyAccents = new Set([
  "\\acute",
  "\\grave",
  "\\ddot",
  "\\dddot",
  "\\ddddot",
  "\\tilde",
  "\\bar",
  "\\breve",
  "\\check",
  "\\hat",
  "\\vec",
  "\\dot",
  "\\mathring"
]);

const needWebkitShift = new Set([
  "\\acute",
  "\\bar",
  "\\breve",
  "\\check",
  "\\dot",
  "\\ddot",
  "\\grave",
  "\\hat",
  "\\mathring",
  "\\'", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"
]);

const combiningChar = {
  "\\`": "\u0300",
  "\\'": "\u0301",
  "\\^": "\u0302",
  "\\~": "\u0303",
  "\\=": "\u0304",
  "\\u": "\u0306",
  "\\.": "\u0307",
  '\\"': "\u0308",
  "\\r": "\u030A",
  "\\H": "\u030B",
  "\\v": "\u030C"
};

// Accents
defineFunction({
  type: "accent",
  names: [
    "\\acute",
    "\\grave",
    "\\ddot",
    "\\dddot",
    "\\ddddot",
    "\\tilde",
    "\\bar",
    "\\breve",
    "\\check",
    "\\hat",
    "\\vec",
    "\\dot",
    "\\mathring",
    "\\overparen",
    "\\widecheck",
    "\\widehat",
    "\\wideparen",
    "\\widetilde",
    "\\overrightarrow",
    "\\overleftarrow",
    "\\Overrightarrow",
    "\\overleftrightarrow",
    "\\overgroup",
    "\\overleftharpoon",
    "\\overrightharpoon"
  ],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);

    const isStretchy = !nonStretchyAccents.has(context.funcName);

    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: isStretchy,
      base: base
    };
  },
  mathmlBuilder: mathmlBuilder$a
});

// Text-mode accents
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\c", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);
    const mode = context.parser.mode;

    if (mode === "math" && context.parser.settings.strict) {
      // LaTeX only writes a warning. It doesn't stop. We'll issue the same warning.
      // eslint-disable-next-line no-console
      console.log(`Temml parse error: Command ${context.funcName} is invalid in math mode.`);
    }

    if (mode === "text" && base.text && base.text.length === 1
        && context.funcName in combiningChar  && smalls.indexOf(base.text) > -1) {
      // Return a combining accent character
      return {
        type: "textord",
        mode: "text",
        text: base.text + combiningChar[context.funcName]
      }
    } else {
      // Build up the accent
      return {
        type: "accent",
        mode: mode,
        label: context.funcName,
        isStretchy: false,
        base: base
      }
    }
  },
  mathmlBuilder: mathmlBuilder$a
});

defineFunction({
  type: "accentUnder",
  names: [
    "\\underleftarrow",
    "\\underrightarrow",
    "\\underleftrightarrow",
    "\\undergroup",
    "\\underparen",
    "\\utilde"
  ],
  props: {
    numArgs: 1
  },
  handler: ({ parser, funcName }, args) => {
    const base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base
    };
  },
  mathmlBuilder: (group, style) => {
    const accentNode = stretchy.accentNode(group);
    accentNode.style["math-depth"] = 0;
    const node = new mathMLTree.MathNode("munder", [
      buildGroup$1(group.base, style),
      accentNode
    ]);
    return node;
  }
});

/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into CSS units.
 */


const ptPerUnit = {
  // Convert to CSS (Postscipt) points, not TeX points
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 800 / 803, // convert TeX point to CSS (Postscript) point
  pc: (12 * 800) / 803, // pica
  dd: ((1238 / 1157) * 800) / 803, // didot
  cc: ((14856 / 1157) * 800) / 803, // cicero (12 didot)
  nd: ((685 / 642) * 800) / 803, // new didot
  nc: ((1370 / 107) * 800) / 803, // new cicero (12 new didot)
  sp: ((1 / 65536) * 800) / 803, // scaled point (TeX's internal smallest unit)
  mm: (25.4 / 72),
  cm: (2.54 / 72),
  in: (1 / 72),
  px: (96 / 72)
};

/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */
const validUnits = [
  "em",
  "ex",
  "mu",
  "pt",
  "mm",
  "cm",
  "in",
  "px",
  "bp",
  "pc",
  "dd",
  "cc",
  "nd",
  "nc",
  "sp"
];

const validUnit = function(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return validUnits.indexOf(unit) > -1
};

const emScale = styleLevel => {
  const scriptLevel = Math.max(styleLevel - 1, 0);
  return [1, 0.7, 0.5][scriptLevel]
};

/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS value.
 */
const calculateSize = function(sizeValue, style) {
  let number = sizeValue.number;
  if (style.maxSize[0] < 0 && number > 0) {
    return { number: 0, unit: "em" }
  }
  const unit = sizeValue.unit;
  switch (unit) {
    case "mm":
    case "cm":
    case "in":
    case "px": {
      const numInCssPts = number * ptPerUnit[unit];
      if (numInCssPts > style.maxSize[1]) {
        return { number: style.maxSize[1], unit: "pt" }
      }
      return { number, unit }; // absolute CSS units.
    }
    case "em":
    case "ex": {
      // In TeX, em and ex do not change size in \scriptstyle.
      if (unit === "ex") { number *= 0.431; }
      number = Math.min(number / emScale(style.level), style.maxSize[0]);
      return { number: utils.round(number), unit: "em" };
    }
    case "bp": {
      if (number > style.maxSize[1]) { number = style.maxSize[1]; }
      return { number, unit: "pt" }; // TeX bp is a CSS pt. (1/72 inch).
    }
    case "pt":
    case "pc":
    case "dd":
    case "cc":
    case "nd":
    case "nc":
    case "sp": {
      number = Math.min(number * ptPerUnit[unit], style.maxSize[1]);
      return { number: utils.round(number), unit: "pt" }
    }
    case "mu": {
      number = Math.min(number / 18, style.maxSize[0]);
      return { number: utils.round(number), unit: "em" }
    }
    default:
      throw new ParseError("Invalid unit: '" + unit + "'")
  }
};

// Helper functions

const padding$1 = width => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", width + "em");
  return node
};

const paddedNode = (group, lspace = 0.3, rspace = 0, mustSmash = false) => {
  if (group == null && rspace === 0) { return padding$1(lspace) }
  const row = group ? [group] : [];
  if (lspace !== 0)   { row.unshift(padding$1(lspace)); }
  if (rspace > 0) { row.push(padding$1(rspace)); }
  if (mustSmash) {
    // Used for the bottom arrow in a {CD} environment
    const mpadded = new mathMLTree.MathNode("mpadded", row);
    mpadded.setAttribute("height", "0");
    return mpadded
  } else {
    return new mathMLTree.MathNode("mrow", row)
  }
};

const labelSize = (size, scriptLevel) =>  Number(size) / emScale(scriptLevel);

const munderoverNode = (fName, body, below, style) => {
  const arrowNode = stretchy.mathMLnode(fName);
  // Is this the short part of a mhchem equilibrium arrow?
  const isEq = fName.slice(1, 3) === "eq";
  const minWidth = fName.charAt(1) === "x"
    ? "1.75"  // mathtools extensible arrows are ≥ 1.75em long
    : fName.slice(2, 4) === "cd"
    ? "3.0"  // cd package arrows
    : isEq
    ? "1.0"  // The shorter harpoon of a mhchem equilibrium arrow
    : "2.0"; // other mhchem arrows
  // TODO: When Firefox supports minsize, use the next line.
  //arrowNode.setAttribute("minsize", String(minWidth) + "em")
  arrowNode.setAttribute("lspace", "0");
  arrowNode.setAttribute("rspace", (isEq ? "0.5em" : "0"));

  // <munderover> upper and lower labels are set to scriptlevel by MathML
  // So we have to adjust our label dimensions accordingly.
  const labelStyle = style.withLevel(style.level < 2 ? 2 : 3);
  const minArrowWidth = labelSize(minWidth, labelStyle.level);
  // The dummyNode will be inside a <mover> inside a <mover>
  // So it will be at scriptlevel 3
  const dummyWidth = labelSize(minWidth, 3);
  const emptyLabel = paddedNode(null, minArrowWidth.toFixed(4), 0);
  const dummyNode = paddedNode(null, dummyWidth.toFixed(4), 0);
  // The arrow is a little longer than the label. Set a spacer length.
  const space = labelSize((isEq ? 0 : 0.3), labelStyle.level).toFixed(4);
  let upperNode;
  let lowerNode;

  const gotUpper = (body && body.body &&
    // \hphantom        visible content
    (body.body.body || body.body.length > 0));
  if (gotUpper) {
    let label =  buildGroup$1(body, labelStyle);
    const mustSmash = (fName === "\\\\cdrightarrow" || fName === "\\\\cdleftarrow");
    label = paddedNode(label, space, space, mustSmash);
    // Since Firefox does not support minsize, stack a invisible node
    // on top of the label. Its width will serve as a min-width.
    // TODO: Refactor this after Firefox supports minsize.
    upperNode = new mathMLTree.MathNode("mover", [label, dummyNode]);
  }
  const gotLower = (below && below.body &&
    (below.body.body || below.body.length > 0));
  if (gotLower) {
    let label =  buildGroup$1(below, labelStyle);
    label = paddedNode(label, space, space);
    lowerNode = new mathMLTree.MathNode("munder", [label, dummyNode]);
  }

  let node;
  if (!gotUpper && !gotLower) {
    node = new mathMLTree.MathNode("mover", [arrowNode, emptyLabel]);
  } else if (gotUpper && gotLower) {
    node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
  } else if (gotUpper) {
    node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
  } else {
    node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
  }
  if (minWidth === "3.0") { node.style.height = "1em"; } // CD environment
  node.setAttribute("accent", "false"); // Necessary for MS Word
  return node
};

// Stretchy arrows with an optional argument
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    // The next 5 functions are here only to support mhchem
    "\\yields",
    "\\yieldsLeft",
    "\\mesomerism",
    "\\longrightharpoonup",
    "\\longleftharpoondown",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    return {
      type: "xArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    // Build the arrow and its labels.
    const node = munderoverNode(group.name, group.body, group.below, style);
    // Create operator spacing for a relation.
    const row = [node];
    row.unshift(padding$1(0.2778));
    row.push(padding$1(0.2778));
    return new mathMLTree.MathNode("mrow", row)
  }
});

const arrowComponent = {
  "\\xtofrom": ["\\xrightarrow", "\\xleftarrow"],
  "\\xleftrightharpoons": ["\\xleftharpoonup", "\\xrightharpoondown"],
  "\\xrightleftharpoons": ["\\xrightharpoonup", "\\xleftharpoondown"],
  "\\yieldsLeftRight": ["\\yields", "\\yieldsLeft"],
  // The next three all get the same harpoon glyphs. Only the lengths and paddings differ.
  "\\equilibrium": ["\\longrightharpoonup", "\\longleftharpoondown"],
  "\\equilibriumRight": ["\\longrightharpoonup", "\\eqleftharpoondown"],
  "\\equilibriumLeft": ["\\eqrightharpoonup", "\\longleftharpoondown"]
};

// Browsers are not good at stretching a glyph that contains a pair of stacked arrows such as ⇄.
// So we stack a pair of single arrows.
defineFunction({
  type: "stackedArrow",
  names: [
    "\\xtofrom",              // expfeil
    "\\xleftrightharpoons",   // mathtools
    "\\xrightleftharpoons",   // mathtools
    "\\yieldsLeftRight",      // mhchem
    "\\equilibrium",          // mhchem
    "\\equilibriumRight",
    "\\equilibriumLeft"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    const lowerArrowBody = args[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: args[0]
      }
      : null;
    const upperArrowBelow = optArgs[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: optArgs[0]
      }
      : null;
    return {
      type: "stackedArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      upperArrowBelow,
      lowerArrowBody,
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    const topLabel = arrowComponent[group.name][0];
    const botLabel = arrowComponent[group.name][1];
    const topArrow = munderoverNode(topLabel, group.body, group.upperArrowBelow, style);
    const botArrow = munderoverNode(botLabel, group.lowerArrowBody, group.below, style);
    let wrapper;

    const raiseNode = new mathMLTree.MathNode("mpadded", [topArrow]);
    raiseNode.setAttribute("voffset", "0.3em");
    raiseNode.setAttribute("height", "+0.3em");
    raiseNode.setAttribute("depth", "-0.3em");
    // One of the arrows is given ~zero width. so the other has the same horzontal alignment.
    if (group.name === "\\equilibriumLeft") {
      const botNode =  new mathMLTree.MathNode("mpadded", [botArrow]);
      botNode.setAttribute("width", "0.5em");
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), botNode, raiseNode, padding$1(0.2778)]
      );
    } else {
      raiseNode.setAttribute("width", (group.name === "\\equilibriumRight" ? "0.5em" : "0"));
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), raiseNode, botArrow, padding$1(0.2778)]
      );
    }

    wrapper.setAttribute("voffset", "-0.18em");
    wrapper.setAttribute("height", "-0.18em");
    wrapper.setAttribute("depth", "+0.18em");
    return wrapper
  }
});

/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */
const _environments = {};

function defineEnvironment({ type, names, props, handler, mathmlBuilder }) {
  // Set default values of environments.
  const data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (let i = 0; i < names.length; ++i) {
    _environments[names[i]] = data;
  }
  if (mathmlBuilder) {
    _mathmlGroupBuilders[type] = mathmlBuilder;
  }
}

/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error(
      `Expected node of type ${type}, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return node;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function assertSymbolNodeType(node) {
  const typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error(
      `Expected node of symbol group type, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return typedNode;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" ||
      Object.prototype.hasOwnProperty.call(NON_ATOMS, node.type))) {
    return node;
  }
  return null;
}

const cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};

const newCell = () => {
  // Create an empty cell, to be filled below with parse nodes.
  return { type: "styling", body: [], mode: "math", scriptLevel: "display" };
};

const isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};

const isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};

function cdArrow(arrowChar, labels, parser) {
  // Return a parse tree of an arrow and its labels.
  // This acts in a way similar to a macro expansion.
  const funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      const bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      const arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel],
        semisimple: true
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      const arrow = { type: "textord", text: "\\Vert", mode: "math" };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return { type: "textord", text: " ", mode: "math" };
  }
}

function parseCD(parser) {
  // Get the array's parse nodes with \\ temporarily mapped to \cr.
  const parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    // Get the parse nodes for the next row.
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    const next = parser.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop(); // final row ended in \\
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }

  let row = [];
  const body = [row];

  // Loop thru the parse nodes. Collect them into cells and arrows.
  for (let i = 0; i < parsedRows.length; i++) {
    // Start a new row.
    const rowNodes = parsedRows[i];
    // Create the first cell.
    let cell = newCell();

    for (let j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        // If a parseNode is not an arrow, it goes into a cell.
        cell.body.push(rowNodes[j]);
      } else {
        // Parse node j is an "@", the start of an arrow.
        // Before starting on the arrow, push the cell into `row`.
        row.push(cell);

        // Now collect parseNodes into an arrow.
        // The character after "@" defines the arrow type.
        j += 1;
        const arrowChar = assertSymbolNodeType(rowNodes[j]).text;

        // Create two empty label nodes. We may or may not use them.
        const labels = new Array(2);
        labels[0] = { type: "ordgroup", mode: "math", body: [] };
        labels[1] = { type: "ordgroup", mode: "math", body: [] };

        // Process the arrow.
        if ("=|.".indexOf(arrowChar) > -1) ; else if ("<>AV".indexOf(arrowChar) > -1) {
          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take
          // two optional labels. E.g. the right-point arrow syntax is
          // really:  @>{optional label}>{optional label}>
          // Collect parseNodes into labels.
          for (let labelNum = 0; labelNum < 2; labelNum++) {
            let inLabel = true;
            for (let k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError(
                  "Missing a " + arrowChar + " character to complete a CD arrow.",
                  rowNodes[k]
                );
              }

              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              // isLabelEnd never returned a true.
              throw new ParseError(
                "Missing a " + arrowChar + " character to complete a CD arrow.",
                rowNodes[j]
              );
            }
          }
        } else {
          throw new ParseError(`Expected one of "<>AV=|." after @.`);
        }

        // Now join the arrow to its labels.
        const arrow = cdArrow(arrowChar, labels, parser);

        // Wrap the arrow in a styling node
        row.push(arrow);
        // In CD's syntax, cells are implicit. That is, everything that
        // is not an arrow gets collected into a cell. So create an empty
        // cell now. It will collect upcoming parseNodes.
        cell = newCell();
      }
    }
    if (i % 2 === 0) {
      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell
      // The last cell is not yet pushed into `row`, so:
      row.push(cell);
    } else {
      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow
      // Remove the empty cell that was placed at the beginning of `row`.
      row.shift();
    }
    row = [];
    body.push(row);
  }
  body.pop();

  // End row group
  parser.gullet.endGroup();
  // End array group defining \\
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: "math",
    body,
    tags: null,
    labels: new Array(body.length + 1).fill(""),
    envClasses: ["jot", "cd"],
    cols: [],
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}

// The functions below are not available for general use.
// They are here only for internal use by the {CD} environment in placing labels
// next to vertical arrows.

// We don't need any such functions for horizontal arrows because we can reuse
// the functionality that already exists for extensible arrows.

defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  mathmlBuilder(group, style) {
    if (group.label.body.length === 0) {
      return new mathMLTree.MathNode("mrow", style)  // empty label
    }
    // Abuse an <mtable> to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.label, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    const mtable = new mathMLTree.MathNode("mtable", [mtr]);
    const label = new mathMLTree.MathNode("mpadded", [mtable]);
    // Set the label width to zero so that the arrow will be centered under the corner cell.
    label.setAttribute("width", "0");
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    if (group.side === "left") {
      label.style.display = "flex";
      label.style.justifyContent = "flex-end";
    }
    return label;
  }
});

defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler({ parser }, args) {
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow", [buildGroup$1(group.fragment, style)]);
  }
});

const ordGroup = (body) => {
  return {
    "type": "ordgroup",
    "mode": "math",
    "body": body,
    "semisimple": true
  }
};

const phantom = (body, type) => {
  return {
    "type": type,
    "mode": "math",
    "body": ordGroup(body)
  }
};

/*
 * A helper for \bordermatrix.
 * parseArray() has parsed the tokens as if the environment
 * was \begin{matrix}. That parse tree is this function’s input.
 * Here, we rearrange the parse tree to get one that will
 * result in TeX \bordermatrix.
 * The final result includes a {pmatrix}, which is the bottom
 * half of a <mover> element. The top of the <mover> contains
 * the \bordermatrix headings. The top section also contains the
 * contents of the bottom {pmatrix}. Those elements are hidden via
 * \hphantom, but they ensure that column widths are the same top and
 * bottom.
 *
 * We also create a left {matrix} with a single column that contains
 * elements shifted out of the matrix. The left {matrix} also
 * contains \vphantom copies of the other {pmatrix} elements.
 * As before, this ensures consistent row heights of left and main.
 */

const bordermatrixParseTree = (matrix, delimiters) => {
  const body = matrix.body;
  body[0].shift(); // dispose of top left cell

  // Create an array for the left column
  const leftColumnBody = new Array(body.length - 1).fill().map(() => []);
  for (let i = 1; i < body.length; i++) {
    // The visible part of the cell
    leftColumnBody[i - 1].push(body[i].shift());
    // A vphantom with contents from the pmatrix, to set minimum cell height
    const phantomBody = [];
    for (let j = 0; j < body[i].length; j++) {
      phantomBody.push(structuredClone(body[i][j]));
    }
    leftColumnBody[i - 1].push(phantom(phantomBody, "vphantom"));
  }

  // Create an array for the top row
  const topRowBody = new Array(body.length).fill().map(() => []);
  for (let j = 0; j < body[0].length; j++) {
    topRowBody[0].push(structuredClone(body[0][j]));
  }
  // Copy the rest of the pmatrix, but squashed via \hphantom
  for (let i = 1; i < body.length; i++) {
    for (let j = 0; j < body[0].length; j++) {
      topRowBody[i].push(phantom(structuredClone(body[i][j]).body, "hphantom"));
    }
  }

  // Squash the top row of the main {pmatrix}
  for (let j = 0; j < body[0].length; j++) {
    body[0][j] = phantom(structuredClone(body[0][j]).body, "hphantom");
  }

  // Now wrap the arrays in the proper parse nodes.

  const leftColumn = {
    type: "array",
    mode: "math",
    body: leftColumnBody,
    cols: [{ type: "align", align: "c" }],
    rowGaps: new Array(leftColumnBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(leftColumnBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(leftColumnBody.length).fill(""),
    arraycolsep: { "number": 0.04, unit: "em" }
  };

  const topRow = {
    type: "array",
    mode: "math",
    body: topRowBody,
    cols: new Array(topRowBody.length).fill({ type: "align", align: "c" }),
    rowGaps: new Array(topRowBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(topRowBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(topRowBody.length).fill(""),
    arraycolsep: null
  };

  const topWrapper = {
    type: "styling",
    mode: "math",
    scriptLevel: "text", // Must set this explicitly.
    body: [topRow]       // Default level is "script".
  };

  const container = {
    type: "leftright",
    mode: "math",
    body: [matrix],
    left: delimiters ? delimiters[0] : "(",
    right: delimiters ? delimiters[1] : ")",
    rightColor: undefined
  };

  const base = {
    type: "op",   // The base of a TeX \overset
    mode: "math",
    limits: true,
    alwaysHandleSupSub: true,
    parentIsSupSub: true,
    symbol: false,
    stack: true,
    suppressBaseShift: true,
    body: [container]
  };

  const mover = {
    type: "supsub",  // We're using the MathML equivalent
    mode: "math",    // of TeX \overset.
    base: base,      // That keeps the {pmatrix} aligned with
    sup: topWrapper, // the math centerline.
    sub: null
  };

  return ordGroup([leftColumn, mover])
};

/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */
class SourceLocation {
  constructor(lexer, start, end) {
    this.lexer = lexer; // Lexer holding the input string.
    this.start = start; // Start offset, zero-based inclusive.
    this.end = end;     // End offset, zero-based exclusive.
  }

  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
}

/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */
class Token {
  constructor(
    text, // the text of this token
    loc
  ) {
    this.text = text;
    this.loc = loc;
  }

  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(
    endToken, // last token of the range, inclusive
    text // the text of the newly constructed token
  ) {
    return new Token(text, SourceLocation.range(this, endToken));
  }
}

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are
// provided in the the arrays below, in that order.
//

// Math style is not quite the same thing as script level.
const StyleLevel = {
  DISPLAY: 0,
  TEXT: 1,
  SCRIPT: 2,
  SCRIPTSCRIPT: 3
};

/**
 * All registered global/built-in macros.
 * `macros.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `macros.js`.
 */
const _macros = {};

// This function might one day accept an additional argument and do more things.
function defineMacro(name, body) {
  _macros[name] = body;
}

/**
 * Predefined macros for Temml.
 * This can be used to define some commands in terms of others.
 */

const macros = _macros;

//////////////////////////////////////////////////////////////////////
// macro tools

defineMacro("\\noexpand", function(context) {
  // The expansion is the token itself; but that token is interpreted
  // as if its meaning were ‘\relax’ if it is a control sequence that
  // would ordinarily be expanded by TeX’s expansion rules.
  const t = context.popToken();
  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }
  return { tokens: [t], numArgs: 0 };
});

defineMacro("\\expandafter", function(context) {
  // TeX first reads the token that comes immediately after \expandafter,
  // without expanding it; let’s call this token t. Then TeX reads the
  // token that comes after t (and possibly more tokens, if that token
  // has an argument), replacing it by its expansion. Finally TeX puts
  // t back in front of that expansion.
  const t = context.popToken();
  context.expandOnce(true); // expand only an expandable token
  return { tokens: [t], numArgs: 0 };
});

// LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}
defineMacro("\\@firstoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[0], numArgs: 0 };
});

// LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}
defineMacro("\\@secondoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[1], numArgs: 0 };
});

// LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol that isn't a space, consuming any spaces but not consuming the
// first nonspace character.  If that nonspace character matches #1, then
// the macro expands to #2; otherwise, it expands to #3.
defineMacro("\\@ifnextchar", function(context) {
  const args = context.consumeArgs(3); // symbol, if, else
  context.consumeSpaces();
  const nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return { tokens: args[1], numArgs: 0 };
  } else {
    return { tokens: args[2], numArgs: 0 };
  }
});

// LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");

// LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode
defineMacro("\\TextOrMath", function(context) {
  const args = context.consumeArgs(2);
  if (context.mode === "text") {
    return { tokens: args[0], numArgs: 0 };
  } else {
    return { tokens: args[1], numArgs: 0 };
  }
});

const stringFromArg = arg => {
  // Reverse the order of the arg and return a string.
  let str = "";
  for (let i = arg.length - 1; i > -1; i--) {
    str += arg[i].text;
  }
  return str
};

// Lookup table for parsing numbers in base 8 through 16
const digitToNumber = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

const nextCharNumber = context => {
  const numStr = context.future().text;
  if (numStr === "EOF") { return [null, ""] }
  return [digitToNumber[numStr.charAt(0)], numStr]
};

const appendCharNumbers = (number, numStr, base) => {
  for (let i = 1; i < numStr.length; i++) {
    const digit = digitToNumber[numStr.charAt(i)];
    number *= base;
    number += digit;
  }
  return number
};

// TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.
defineMacro("\\char", function(context) {
  let token = context.popToken();
  let base;
  let number = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    // Parse a number in the given base, starting with first `token`.
    let numStr = token.text;
    number = digitToNumber[numStr.charAt(0)];
    if (number == null || number >= base) {
      throw new ParseError(`Invalid base-${base} digit ${token.text}`);
    }
    number = appendCharNumbers(number, numStr, base);
    let digit;
    [digit, numStr] = nextCharNumber(context);
    while (digit != null && digit < base) {
      number *= base;
      number += digit;
      number = appendCharNumbers(number, numStr, base);
      context.popToken();
      [digit, numStr] = nextCharNumber(context);
    }
  }
  return `\\@char{${number}}`;
});

function recreateArgStr(context) {
  // Recreate the macro's original argument string from the array of parse tokens.
  const tokens = context.consumeArgs(1)[0];
  let str = "";
  let expectedLoc = tokens[tokens.length - 1].loc.start;
  for (let i = tokens.length - 1; i >= 0; i--) {
    const actualLoc = tokens[i].loc.start;
    if (actualLoc > expectedLoc) {
      // context.consumeArgs has eaten a space.
      str += " ";
      expectedLoc = actualLoc;
    }
    str += tokens[i].text;
    expectedLoc += tokens[i].text.length;
  }
  return str
}

// The Latin Modern font renders <mi>√</mi> at the wrong vertical alignment.
// This macro provides a better rendering.
defineMacro("\\surd", '\\sqrt{\\vphantom{|}}');

// See comment for \oplus in symbols.js.
defineMacro("\u2295", "\\oplus");

// Since Temml has no \par, ignore \long.
defineMacro("\\long", "");

//////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");

// Symbols from latex.ltx:
// \def~{\nobreakspace{}}
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");

defineMacro("\\Bbbk", "\\Bbb{k}");

// \mathstrut from the TeXbook, p 360
defineMacro("\\mathstrut", "\\vphantom{(}");

// \underbar from TeXbook p 353
defineMacro("\\underbar", "\\underline{\\text{#1}}");

//////////////////////////////////////////////////////////////////////
// LaTeX_2ε

// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.
defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22ee", "\\vdots");

// {array} environment gaps
defineMacro("\\arraystretch", "1");     // line spacing factor times 12pt
defineMacro("\\arraycolsep", "6pt");    // half the width separating columns

//////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf

//\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");

// \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");

// AMSMath's automatic \dots, based on \mdots@@ macro.
const dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcap": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\bigtimes": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};

defineMacro("\\dots", function(context) {
  // TODO: If used in text mode, should expand to \textellipsis.
  // However, in Temml, \textellipsis and \ldots behave the same
  // (in text mode), and it's unlikely we'd see any of the math commands
  // that affect the behavior of \dots when in text mode.  So fine for now
  // (until we support \ifmmode ... \else ... \fi).
  let thedots = "\\dotso";
  const next = context.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (["bin", "rel"].includes(symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});

const spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  $: true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};

defineMacro("\\dotso", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\dotsc", function(context) {
  const next = context.future().text;
  // \dotsc uses \extra@ but not \extrap@, instead specially checking for
  // ';' and '.', but doesn't check for ','.
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\cdots", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});

defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\idotsint", "\\dotsi");
// amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.
defineMacro("\\dotsx", "\\ldots\\,");

// \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");

// Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
// \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\,", "{\\tmspace+{3mu}{.1667em}}");
// \let\thinspace\,
defineMacro("\\thinspace", "\\,");
// \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "{\\tmspace+{4mu}{.2222em}}");
// \let\medspace\:
defineMacro("\\medspace", "\\:");
// \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu
defineMacro("\\;", "{\\tmspace+{5mu}{.2777em}}");
// \let\thickspace\;
defineMacro("\\thickspace", "\\;");
// \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\!", "{\\tmspace-{3mu}{.1667em}}");
// \let\negthinspace\!
defineMacro("\\negthinspace", "\\!");
// \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip
defineMacro("\\negmedspace", "{\\tmspace-{4mu}{.2222em}}");
// \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip
defineMacro("\\negthickspace", "{\\tmspace-{5mu}{.277em}}");
// \def\enspace{\kern.5em }
defineMacro("\\enspace", "\\kern.5em ");
// \def\enskip{\hskip.5em\relax}
defineMacro("\\enskip", "\\hskip.5em\\relax");
// \def\quad{\hskip1em\relax}
defineMacro("\\quad", "\\hskip1em\\relax");
// \def\qquad{\hskip2em\relax}
defineMacro("\\qquad", "\\hskip2em\\relax");

defineMacro("\\AA", "\\TextOrMath{\\Angstrom}{\\mathring{A}}\\relax");

// \tag@in@display form of \tag
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\notag", "\\nonumber");
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");

// \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\bmod", "\\mathbin{\\text{mod}}");
defineMacro(
  "\\pod",
  "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"
);
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro(
  "\\mod",
  "\\allowbreak" +
    "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" +
    "{\\rm mod}\\,\\,#1"
);

//////////////////////////////////////////////////////////////////////
// LaTeX source2e

// \expandafter\let\expandafter\@normalcr
//     \csname\expandafter\@gobble\string\\ \endcsname
// \DeclareRobustCommand\newline{\@normalcr\relax}
defineMacro("\\newline", "\\\\\\relax");

// \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.
defineMacro("\\TeX", "\\textrm{T}\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125em\\textrm{X}");

defineMacro(
  "\\LaTeX",
    "\\textrm{L}\\kern-.35em\\raisebox{0.2em}{\\scriptstyle A}\\kern-.15em\\TeX"
);

defineMacro(
  "\\Temml",
  // eslint-disable-next-line max-len
  "\\textrm{T}\\kern-0.2em\\lower{0.2em}{\\textrm{E}}\\kern-0.08em{\\textrm{M}\\kern-0.08em\\raise{0.2em}\\textrm{M}\\kern-0.08em\\textrm{L}}"
);

// \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");

defineMacro("\\colon", `\\mathpunct{\\char"3a}`);

//////////////////////////////////////////////////////////////////////
// mathtools.sty

defineMacro("\\prescript", "\\pres@cript{_{#1}^{#2}}{}{#3}");

//\providecommand\ordinarycolon{:}
defineMacro("\\ordinarycolon", `\\char"3a`);
// Raise to center on the math axis, as closely as possible.
defineMacro("\\vcentcolon", "\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}}");
// \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\coloneq", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2212}');
// \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\Coloneq", '\\mathrel{\\char"2237\\char"2212}');
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqqcolon", '\\mathrel{\\char"3d\\char"2237}');
// \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqcolon", '\\mathrel{\\char"2212\\char"2237}');
// \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\colonapprox", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2248}');
// \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\Colonapprox", '\\mathrel{\\char"2237\\char"2248}');
// \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');
// \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\Colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');

//////////////////////////////////////////////////////////////////////
// colonequals.sty

// Alternate names for mathtools's macros:
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
// \colonapprox name is same in mathtools and colonequals.
defineMacro("\\coloncolonapprox", "\\Colonapprox");
// \colonsim name is same in mathtools and colonequals.
defineMacro("\\coloncolonsim", "\\Colonsim");

// Present in newtxmath, pxfonts and txfonts
defineMacro("\\notni", "\\mathrel{\\char`\u220C}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");

//////////////////////////////////////////////////////////////////////
// From amsopn.sty
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{\\text{lim}}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{\\text{lim}}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{\\text{lim}}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{\\text{lim}}}");

defineMacro("\\centerdot", "{\\medspace\\rule{0.167em}{0.189em}\\medspace}");

//////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\operatorname*{plim}");

//////////////////////////////////////////////////////////////////////
// MnSymbol.sty

defineMacro("\\leftmodels", "\\mathop{\\reflectbox{$\\models$}}");

//////////////////////////////////////////////////////////////////////
// braket.sty
// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf

defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
// A helper for \Braket and \Set
const replaceVert = (argStr, match) => {
  const ch = match[0] === "|" ? "\\vert" : "\\Vert";
  const replaceStr = `}\\,\\middle${ch}\\,{`;
  return argStr.slice(0, match.index) + replaceStr + argStr.slice(match.index + match[0].length)
};
defineMacro("\\Braket",  function(context) {
  let argStr = recreateArgStr(context);
  const regEx = /\|\||\||\\\|/g;
  let match;
  while ((match = regEx.exec(argStr)) !== null) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\langle{" + argStr + "}\\right\\rangle"
});
defineMacro("\\Set",  function(context) {
  let argStr = recreateArgStr(context);
  const match = /\|\||\||\\\|/.exec(argStr);
  if (match) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\{\\:{" + argStr + "}\\:\\right\\}"
});
defineMacro("\\set",  function(context) {
  const argStr = recreateArgStr(context);
  return "\\{{" + argStr.replace(/\|/, "}\\mid{") + "}\\}"
});

//////////////////////////////////////////////////////////////////////
// actuarialangle.dtx
defineMacro("\\angln", "{\\angl n}");

//////////////////////////////////////////////////////////////////////
// derivative.sty
defineMacro("\\odv", "\\@ifstar\\odv@next\\odv@numerator");
defineMacro("\\odv@numerator", "\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}");
defineMacro("\\odv@next", "\\frac{\\mathrm{d}}{\\mathrm{d}#2}#1");
defineMacro("\\pdv", "\\@ifstar\\pdv@next\\pdv@numerator");

const pdvHelper = args => {
  const numerator = args[0][0].text;
  const denoms = stringFromArg(args[1]).split(",");
  const power = String(denoms.length);
  const numOp = power === "1" ? "\\partial" : `\\partial^${power}`;
  let denominator = "";
  denoms.map(e => { denominator += "\\partial " + e.trim() +  "\\,";});
  return [numerator, numOp,  denominator.replace(/\\,$/, "")]
};
defineMacro("\\pdv@numerator", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp} ${numerator}}{${denominator}}`
});
defineMacro("\\pdv@next", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp}}{${denominator}} ${numerator}`
});

//////////////////////////////////////////////////////////////////////
// upgreek.dtx
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\upbeta", "\\up@greek{\\beta}");
defineMacro("\\upgamma", "\\up@greek{\\gamma}");
defineMacro("\\updelta", "\\up@greek{\\delta}");
defineMacro("\\upepsilon", "\\up@greek{\\epsilon}");
defineMacro("\\upzeta", "\\up@greek{\\zeta}");
defineMacro("\\upeta", "\\up@greek{\\eta}");
defineMacro("\\uptheta", "\\up@greek{\\theta}");
defineMacro("\\upiota", "\\up@greek{\\iota}");
defineMacro("\\upkappa", "\\up@greek{\\kappa}");
defineMacro("\\uplambda", "\\up@greek{\\lambda}");
defineMacro("\\upmu", "\\up@greek{\\mu}");
defineMacro("\\upnu", "\\up@greek{\\nu}");
defineMacro("\\upxi", "\\up@greek{\\xi}");
defineMacro("\\upomicron", "\\up@greek{\\omicron}");
defineMacro("\\uppi", "\\up@greek{\\pi}");
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\uprho", "\\up@greek{\\rho}");
defineMacro("\\upsigma", "\\up@greek{\\sigma}");
defineMacro("\\uptau", "\\up@greek{\\tau}");
defineMacro("\\upupsilon", "\\up@greek{\\upsilon}");
defineMacro("\\upphi", "\\up@greek{\\phi}");
defineMacro("\\upchi", "\\up@greek{\\chi}");
defineMacro("\\uppsi", "\\up@greek{\\psi}");
defineMacro("\\upomega", "\\up@greek{\\omega}");

//////////////////////////////////////////////////////////////////////
// cmll package
defineMacro("\\invamp", '\\mathbin{\\char"214b}');
defineMacro("\\parr", '\\mathbin{\\char"214b}');
defineMacro("\\with", '\\mathbin{\\char"26}');
defineMacro("\\multimapinv", '\\mathrel{\\char"27dc}');
defineMacro("\\multimapboth", '\\mathrel{\\char"29df}');
defineMacro("\\scoh", '{\\mkern5mu\\char"2322\\mkern5mu}');
defineMacro("\\sincoh", '{\\mkern5mu\\char"2323\\mkern5mu}');
defineMacro("\\coh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2322}}}
{\\smash{\\lower4mu{\\char"2323}}}\\mkern5mu}`);
defineMacro("\\incoh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2323}}}
{\\smash{\\lower4mu{\\char"2322}}}\\mkern5mu}`);


//////////////////////////////////////////////////////////////////////
// chemstyle package
defineMacro("\\standardstate", "\\text{\\tiny\\char`⦵}");

﻿/* eslint-disable */
/* -*- Mode: JavaScript; indent-tabs-mode:nil; js-indent-level: 2 -*- */
/* vim: set ts=2 et sw=2 tw=80: */

/*************************************************************
 *
 *  Temml mhchem.js
 *
 *  This file implements a Temml version of mhchem version 3.3.0.
 *  It is adapted from MathJax/extensions/TeX/mhchem.js
 *  It differs from the MathJax version as follows:
 *    1. The interface is changed so that it can be called from Temml, not MathJax.
 *    2. \rlap and \llap are replaced with \mathrlap and \mathllap.
 *    3. The reaction arrow code is simplified. All reaction arrows are rendered
 *       using Temml extensible arrows instead of building non-extensible arrows.
 *    4. The ~bond forms are composed entirely of \rule elements.
 *    5. Two dashes in _getBond are wrapped in braces to suppress spacing. i.e., {-}
 *    6. The electron dot uses \textbullet instead of \bullet.
 *    7. \smash[T] has been removed. (WebKit hides anything inside \smash{…})
 *
 *    This code, as other Temml code, is released under the MIT license.
 * 
 * /*************************************************************
 *
 *  MathJax/extensions/TeX/mhchem.js
 *
 *  Implements the \ce command for handling chemical formulas
 *  from the mhchem LaTeX package.
 *
 *  ---------------------------------------------------------------------
 *
 *  Copyright (c) 2011-2015 The MathJax Consortium
 *  Copyright (c) 2015-2018 Martin Hensel
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

//
// Coding Style
//   - use '' for identifiers that can by minified/uglified
//   - use "" for strings that need to stay untouched

// version: "3.3.0" for MathJax and Temml


// Add \ce, \pu, and \tripleDash to the Temml macros.

defineMacro("\\ce", function(context) {
  return chemParse(context.consumeArgs(1)[0], "ce")
});

defineMacro("\\pu", function(context) {
  return chemParse(context.consumeArgs(1)[0], "pu");
});

// Math fonts do not include glyphs for the ~ form of bonds. So we'll send path geometry
// So we'll compose characters built from \rule elements.
defineMacro("\\uniDash", `{\\rule{0.672em}{0.06em}}`)
defineMacro("\\triDash", `{\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}}`)
defineMacro("\\tripleDash", `\\kern0.075em\\raise0.25em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverLine", `\\kern0.075em\\mathrlap{\\raise0.125em{\\uniDash}}\\raise0.34em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\triDash}}\\raise0.27em{\\uniDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)
defineMacro("\\tripleDashBetweenDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\uniDash}}\\raise0.27em{\\triDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)

  //
  //  This is the main function for handing the \ce and \pu commands.
  //  It takes the argument to \ce or \pu and returns the corresponding TeX string.
  //

  var chemParse = function (tokens, stateMachine) {
    // Recreate the argument string from Temml's array of tokens.
    var str = "";
    var expectedLoc = tokens.length && tokens[tokens.length - 1].loc.start
    for (var i = tokens.length - 1; i >= 0; i--) {
      if(tokens[i].loc.start > expectedLoc) {
        // context.consumeArgs has eaten a space.
        str += " ";
        expectedLoc = tokens[i].loc.start;
      }
      str += tokens[i].text;
      expectedLoc += tokens[i].text.length;
    }
    // Call the mhchem core parser.
    var tex = texify.go(mhchemParser.go(str, stateMachine));
    return tex;
  };

  //
  // Core parser for mhchem syntax  (recursive)
  //
  /** @type {MhchemParser} */
  var mhchemParser = {
    //
    // Parses mchem \ce syntax
    //
    // Call like
    //   go("H2O");
    //
    go: function (input, stateMachine) {
      if (!input) { return []; }
      if (stateMachine === undefined) { stateMachine = 'ce'; }
      var state = '0';

      //
      // String buffers for parsing:
      //
      // buffer.a == amount
      // buffer.o == element
      // buffer.b == left-side superscript
      // buffer.p == left-side subscript
      // buffer.q == right-side subscript
      // buffer.d == right-side superscript
      //
      // buffer.r == arrow
      // buffer.rdt == arrow, script above, type
      // buffer.rd == arrow, script above, content
      // buffer.rqt == arrow, script below, type
      // buffer.rq == arrow, script below, content
      //
      // buffer.text_
      // buffer.rm
      // etc.
      //
      // buffer.parenthesisLevel == int, starting at 0
      // buffer.sb == bool, space before
      // buffer.beginsWithBond == bool
      //
      // These letters are also used as state names.
      //
      // Other states:
      // 0 == begin of main part (arrow/operator unlikely)
      // 1 == next entity
      // 2 == next entity (arrow/operator unlikely)
      // 3 == next atom
      // c == macro
      //
      /** @type {Buffer} */
      var buffer = {};
      buffer['parenthesisLevel'] = 0;

      input = input.replace(/\n/g, " ");
      input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
      input = input.replace(/[\u2026]/g, "...");

      //
      // Looks through mhchemParser.transitions, to execute a matching action
      // (recursive)
      //
      var lastInput;
      var watchdog = 10;
      /** @type {ParserOutput[]} */
      var output = [];
      while (true) {
        if (lastInput !== input) {
          watchdog = 10;
          lastInput = input;
        } else {
          watchdog--;
        }
        //
        // Find actions in transition table
        //
        var machine = mhchemParser.stateMachines[stateMachine];
        var t = machine.transitions[state] || machine.transitions['*'];
        iterateTransitions:
        for (var i=0; i<t.length; i++) {
          var matches = mhchemParser.patterns.match_(t[i].pattern, input);
          if (matches) {
            //
            // Execute actions
            //
            var task = t[i].task;
            for (var iA=0; iA<task.action_.length; iA++) {
              var o;
              //
              // Find and execute action
              //
              if (machine.actions[task.action_[iA].type_]) {
                o = machine.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else if (mhchemParser.actions[task.action_[iA].type_]) {
                o = mhchemParser.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else {
                throw ["MhchemBugA", "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"];  // Trying to use non-existing action
              }
              //
              // Add output
              //
              mhchemParser.concatArray(output, o);
            }
            //
            // Set next state,
            // Shorten input,
            // Continue with next character
            //   (= apply only one transition per position)
            //
            state = task.nextState || state;
            if (input.length > 0) {
              if (!task.revisit) {
                input = matches.remainder;
              }
              if (!task.toContinue) {
                break iterateTransitions;
              }
            } else {
              return output;
            }
          }
        }
        //
        // Prevent infinite loop
        //
        if (watchdog <= 0) {
          throw ["MhchemBugU", "mhchem bug U. Please report."];  // Unexpected character
        }
      }
    },
    concatArray: function (a, b) {
      if (b) {
        if (Array.isArray(b)) {
          for (var iB=0; iB<b.length; iB++) {
            a.push(b[iB]);
          }
        } else {
          a.push(b);
        }
      }
    },

    patterns: {
      //
      // Matching patterns
      // either regexps or function that return null or {match_:"a", remainder:"bc"}
      //
      patterns: {
        // property names must not look like integers ("2") for correct property traversal order, later on
        'empty': /^$/,
        'else': /^./,
        'else2': /^./,
        'space': /^\s/,
        'space A': /^\s(?=[A-Z\\$])/,
        'space$': /^\s$/,
        'a-z': /^[a-z]/,
        'x': /^x/,
        'x$': /^x$/,
        'i$': /^i$/,
        'letters': /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
        '\\greek': /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
        'one lowercase latin letter $': /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
        '$one lowercase latin letter$ $': /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
        'one lowercase greek letter $': /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
        'digits': /^[0-9]+/,
        '-9.,9': /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
        '-9.,9 no missing 0': /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
        '(-)(9.,9)(e)(99)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '(-)(9)^(-9)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        'state of aggregation $': function (input) {  // ... or crystal system
          var a = mhchemParser.patterns.findObserveGroups(input, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");  // (aq), (aq,$\infty$), (aq, sat)
          if (a  &&  a.remainder.match(/^($|[\s,;\)\]\}])/)) { return a; }  //  AND end of 'phrase'
          var m = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);  // OR crystal system ($o$) (\ca$c$)
          if (m) {
            return { match_: m[0], remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '_{(state of aggregation)}$': /^_\{(\([a-z]{1,3}\))\}/,
        '{[(': /^(?:\\\{|\[|\()/,
        ')]}': /^(?:\)|\]|\\\})/,
        ', ': /^[,;]\s*/,
        ',': /^[,;]/,
        '.': /^[.]/,
        '. ': /^([.\u22C5\u00B7\u2022])\s*/,
        '...': /^\.\.\.(?=$|[^.])/,
        '* ': /^([*])\s*/,
        '^{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^{", "", "", "}"); },
        '^($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", "$", "$", ""); },
        '^a': /^\^([0-9]+|[^\\_])/,
        '^\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '^\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", ""); },
        '^\\x': /^\^(\\[a-zA-Z]+)\s*/,
        '^(-1)': /^\^(-?\d+)/,
        '\'': /^'/,
        '_{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_{", "", "", "}"); },
        '_($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", "$", "$", ""); },
        '_9': /^_([+\-]?[0-9]+|[^\\])/,
        '_\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '_\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", ""); },
        '_\\x': /^_(\\[a-zA-Z]+)\s*/,
        '^_': /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
        '{}': /^\{\}/,
        '{...}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "{", "}", ""); },
        '{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}"); },
        '$...$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "$", "$", ""); },
        '${(...)}$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "${", "", "", "}$"); },
        '$(...)$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$"); },
        '=<>': /^[=<>]/,
        '#': /^[#\u2261]/,
        '+': /^\+/,
        '-$': /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,  // -space -, -; -] -/ -$ -state-of-aggregation
        '-9': /^-(?=[0-9])/,
        '- orbital overlap': /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
        '-': /^-/,
        'pm-operator': /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
        'operator': /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
        'arrowUpDown': /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
        '\\bond{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\bond{", "", "", "}"); },
        '->': /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
        'CMT': /^[CMT](?=\[)/,
        '[(...)]': function (input) { return mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]"); },
        '1st-level escape': /^(&|\\\\|\\hline)\s*/,
        '\\,': /^(?:\\[,\ ;:])/,  // \\x - but output no space before
        '\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", ""); },
        '\\ca': /^\\ca(?:\s+|(?![a-zA-Z]))/,
        '\\x': /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
        'orbital': /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,  // only those with numbers in front, because the others will be formatted correctly anyway
        'others': /^[\/~|]/,
        '\\frac{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\frac{", "", "", "}", "{", "", "", "}"); },
        '\\overset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\overset{", "", "", "}", "{", "", "", "}"); },
        '\\underset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underset{", "", "", "}", "{", "", "", "}"); },
        '\\underbrace{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underbrace{", "", "", "}_", "{", "", "", "}"); },
        '\\color{(...)}0': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}"); },
        '\\color{(...)}{(...)}1': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}", "{", "", "", "}"); },
        '\\color(...){(...)}2': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}"); },
        '\\ce{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\ce{", "", "", "}"); },
        'oxidation$': /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
        'd-oxidation$': /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,  // 0 could be oxidation or charge
        'roman numeral': /^[IVX]+/,
        '1/2$': /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
        'amount': function (input) {
          var match;
          // e.g. 2, 0.5, 1/2, -2, n/2, +;  $a$ could be added later in parsing
          match = input.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          var a = mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
          if (a) {  // e.g. $2n-1$, $-$
            match = a.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/);
            if (match) {
              return { match_: match[0], remainder: input.substr(match[0].length) };
            }
          }
          return null;
        },
        'amount2': function (input) { return this['amount'](input); },
        '(KV letters),': /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
        'formula$': function (input) {
          if (input.match(/^\([a-z]+\)$/)) { return null; }  // state of aggregation = no formula
          var match = input.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          return null;
        },
        'uprightEntities': /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
        '/': /^\s*(\/)\s*/,
        '//': /^\s*(\/\/)\s*/,
        '*': /^\s*[*.]\s*/
      },
      findObserveGroups: function (input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
        /** @type {{(input: string, pattern: string | RegExp): string | string[] | null;}} */
        var _match = function (input, pattern) {
          if (typeof pattern === "string") {
            if (input.indexOf(pattern) !== 0) { return null; }
            return pattern;
          } else {
            var match = input.match(pattern);
            if (!match) { return null; }
            return match[0];
          }
        };
        /** @type {{(input: string, i: number, endChars: string | RegExp): {endMatchBegin: number, endMatchEnd: number} | null;}} */
        var _findObserveGroups = function (input, i, endChars) {
          var braces = 0;
          while (i < input.length) {
            var a = input.charAt(i);
            var match = _match(input.substr(i), endChars);
            if (match !== null  &&  braces === 0) {
              return { endMatchBegin: i, endMatchEnd: i + match.length };
            } else if (a === "{") {
              braces++;
            } else if (a === "}") {
              if (braces === 0) {
                throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
              } else {
                braces--;
              }
            }
            i++;
          }
          if (braces > 0) {
            return null;
          }
          return null;
        };
        var match = _match(input, begExcl);
        if (match === null) { return null; }
        input = input.substr(match.length);
        match = _match(input, begIncl);
        if (match === null) { return null; }
        var e = _findObserveGroups(input, match.length, endIncl || endExcl);
        if (e === null) { return null; }
        var match1 = input.substring(0, (endIncl ? e.endMatchEnd : e.endMatchBegin));
        if (!(beg2Excl || beg2Incl)) {
          return {
            match_: match1,
            remainder: input.substr(e.endMatchEnd)
          };
        } else {
          var group2 = this.findObserveGroups(input.substr(e.endMatchEnd), beg2Excl, beg2Incl, end2Incl, end2Excl);
          if (group2 === null) { return null; }
          /** @type {string[]} */
          var matchRet = [match1, group2.match_];
          return {
            match_: (combine ? matchRet.join("") : matchRet),
            remainder: group2.remainder
          };
        }
      },

      //
      // Matching function
      // e.g. match("a", input) will look for the regexp called "a" and see if it matches
      // returns null or {match_:"a", remainder:"bc"}
      //
      match_: function (m, input) {
        var pattern = mhchemParser.patterns.patterns[m];
        if (pattern === undefined) {
          throw ["MhchemBugP", "mhchem bug P. Please report. (" + m + ")"];  // Trying to use non-existing pattern
        } else if (typeof pattern === "function") {
          return mhchemParser.patterns.patterns[m](input);  // cannot use cached var pattern here, because some pattern functions need this===mhchemParser
        } else {  // RegExp
          var match = input.match(pattern);
          if (match) {
            var mm;
            if (match[2]) {
              mm = [ match[1], match[2] ];
            } else if (match[1]) {
              mm = match[1];
            } else {
              mm = match[0];
            }
            return { match_: mm, remainder: input.substr(match[0].length) };
          }
          return null;
        }
      }
    },

    //
    // Generic state machine actions
    //
    actions: {
      'a=': function (buffer, m) { buffer.a = (buffer.a || "") + m; },
      'b=': function (buffer, m) { buffer.b = (buffer.b || "") + m; },
      'p=': function (buffer, m) { buffer.p = (buffer.p || "") + m; },
      'o=': function (buffer, m) { buffer.o = (buffer.o || "") + m; },
      'q=': function (buffer, m) { buffer.q = (buffer.q || "") + m; },
      'd=': function (buffer, m) { buffer.d = (buffer.d || "") + m; },
      'rm=': function (buffer, m) { buffer.rm = (buffer.rm || "") + m; },
      'text=': function (buffer, m) { buffer.text_ = (buffer.text_ || "") + m; },
      'insert': function (buffer, m, a) { return { type_: a }; },
      'insert+p1': function (buffer, m, a) { return { type_: a, p1: m }; },
      'insert+p1+p2': function (buffer, m, a) { return { type_: a, p1: m[0], p2: m[1] }; },
      'copy': function (buffer, m) { return m; },
      'rm': function (buffer, m) { return { type_: 'rm', p1: m || ""}; },
      'text': function (buffer, m) { return mhchemParser.go(m, 'text'); },
      '{text}': function (buffer, m) {
        var ret = [ "{" ];
        mhchemParser.concatArray(ret, mhchemParser.go(m, 'text'));
        ret.push("}");
        return ret;
      },
      'tex-math': function (buffer, m) { return mhchemParser.go(m, 'tex-math'); },
      'tex-math tight': function (buffer, m) { return mhchemParser.go(m, 'tex-math tight'); },
      'bond': function (buffer, m, k) { return { type_: 'bond', kind_: k || m }; },
      'color0-output': function (buffer, m) { return { type_: 'color0', color: m[0] }; },
      'ce': function (buffer, m) { return mhchemParser.go(m); },
      '1/2': function (buffer, m) {
        /** @type {ParserOutput[]} */
        var ret = [];
        if (m.match(/^[+\-]/)) {
          ret.push(m.substr(0, 1));
          m = m.substr(1);
        }
        var n = m.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
        n[1] = n[1].replace(/\$/g, "");
        ret.push({ type_: 'frac', p1: n[1], p2: n[2] });
        if (n[3]) {
          n[3] = n[3].replace(/\$/g, "");
          ret.push({ type_: 'tex-math', p1: n[3] });
        }
        return ret;
      },
      '9,9': function (buffer, m) { return mhchemParser.go(m, '9,9'); }
    },
    //
    // createTransitions
    // convert  { 'letter': { 'state': { action_: 'output' } } }  to  { 'state' => [ { pattern: 'letter', task: { action_: [{type_: 'output'}] } } ] }
    // with expansion of 'a|b' to 'a' and 'b' (at 2 places)
    //
    createTransitions: function (o) {
      var pattern, state;
      /** @type {string[]} */
      var stateArray;
      var i;
      //
      // 1. Collect all states
      //
      /** @type {Transitions} */
      var transitions = {};
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = state.split("|");
          o[pattern][state].stateArray = stateArray;
          for (i=0; i<stateArray.length; i++) {
            transitions[stateArray[i]] = [];
          }
        }
      }
      //
      // 2. Fill states
      //
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = o[pattern][state].stateArray || [];
          for (i=0; i<stateArray.length; i++) {
            //
            // 2a. Normalize actions into array:  'text=' ==> [{type_:'text='}]
            // (Note to myself: Resolving the function here would be problematic. It would need .bind (for *this*) and currying (for *option*).)
            //
            /** @type {any} */
            var p = o[pattern][state];
            if (p.action_) {
              p.action_ = [].concat(p.action_);
              for (var k=0; k<p.action_.length; k++) {
                if (typeof p.action_[k] === "string") {
                  p.action_[k] = { type_: p.action_[k] };
                }
              }
            } else {
              p.action_ = [];
            }
            //
            // 2.b Multi-insert
            //
            var patternArray = pattern.split("|");
            for (var j=0; j<patternArray.length; j++) {
              if (stateArray[i] === '*') {  // insert into all
                for (var t in transitions) {
                  transitions[t].push({ pattern: patternArray[j], task: p });
                }
              } else {
                transitions[stateArray[i]].push({ pattern: patternArray[j], task: p });
              }
            }
          }
        }
      }
      return transitions;
    },
    stateMachines: {}
  };

  //
  // Definition of state machines
  //
  mhchemParser.stateMachines = {
    //
    // \ce state machines
    //
    //#region ce
    'ce': {  // main parser
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'else':  {
          '0|1|2': { action_: 'beginsWithBond=false', revisit: true, toContinue: true } },
        'oxidation$': {
          '0': { action_: 'oxidation-output' } },
        'CMT': {
          'r': { action_: 'rdt=', nextState: 'rt' },
          'rd': { action_: 'rqt=', nextState: 'rdt' } },
        'arrowUpDown': {
          '0|1|2|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '1' } },
        'uprightEntities': {
          '0|1|2': { action_: [ 'o=', 'output' ], nextState: '1' } },
        'orbital': {
          '0|1|2|3': { action_: 'o=', nextState: 'o' } },
        '->': {
          '0|1|2|3': { action_: 'r=', nextState: 'r' },
          'a|as': { action_: [ 'output', 'r=' ], nextState: 'r' },
          '*': { action_: [ 'output', 'r=' ], nextState: 'r' } },
        '+': {
          'o': { action_: 'd= kv',  nextState: 'd' },
          'd|D': { action_: 'd=', nextState: 'd' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd|qD': { action_: 'd=', nextState: 'qd' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' },
          '3': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        'amount': {
          '0|2': { action_: 'a=', nextState: 'a' } },
        'pm-operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', { type_: 'operator', option: '\\pm' } ], nextState: '0' } },
        'operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        '-$': {
          'o|q': { action_: [ 'charge or bond', 'output' ],  nextState: 'qd' },
          'd': { action_: 'd=', nextState: 'd' },
          'D': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd': { action_: 'd=', nextState: 'qd' },
          'qD|dq': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        '-9': {
          '3|o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '3' } },
        '- orbital overlap': {
          'o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'd': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' } },
        '-': {
          '0|1|2': { action_: [ { type_: 'output', option: 1 }, 'beginsWithBond=true', { type_: 'bond', option: "-" } ], nextState: '3' },
          '3': { action_: { type_: 'bond', option: "-" } },
          'a': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'as': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "-" } ], nextState: '3' },
          'b': { action_: 'b=' },
          'o': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'q': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'd|qd|dq': { action_: { type_: '- after o/d', option: true }, nextState: '2' },
          'D|qD|p': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        'amount2': {
          '1|3': { action_: 'a=', nextState: 'a' } },
        'letters': {
          '0|1|2|3|a|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },
          'q|dq': { action_: ['output', 'o='], nextState: 'o' },
          'd|D|qd|qD': { action_: 'o after d', nextState: 'o' } },
        'digits': {
          'o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q': { action_: [ 'output', 'o=' ], nextState: 'o' },
          'a': { action_: 'o=', nextState: 'o' } },
        'space A': {
          'b|p|bp': {} },
        'space': {
          'a': { nextState: 'as' },
          '0': { action_: 'sb=false' },
          '1|2': { action_: 'sb=true' },
          'r|rt|rd|rdt|rdq': { action_: 'output', nextState: '0' },
          '*': { action_: [ 'output', 'sb=true' ], nextState: '1'} },
        '1st-level escape': {
          '1|2': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ] },
          '*': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ], nextState: '0' } },
        '[(...)]': {
          'r|rt': { action_: 'rd=', nextState: 'rd' },
          'rd|rdt': { action_: 'rq=', nextState: 'rdq' } },
        '...': {
          'o|d|D|dq|qd|qD': { action_: [ 'output', { type_: 'bond', option: "..." } ], nextState: '3' },
          '*': { action_: [ { type_: 'output', option: 1 }, { type_: 'insert', option: 'ellipsis' } ], nextState: '1' } },
        '. |* ': {
          '*': { action_: [ 'output', { type_: 'insert', option: 'addition compound' } ], nextState: '1' } },
        'state of aggregation $': {
          '*': { action_: [ 'output', 'state of aggregation' ], nextState: '1' } },
        '{[(': {
          'a|as|o': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '0|1|2|3': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '*': { action_: [ 'output', 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' } },
        ')]}': {
          '0|1|2|3|b|p|bp|o': { action_: [ 'o=', 'parenthesisLevel--' ], nextState: 'o' },
          'a|as|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=', 'parenthesisLevel--' ], nextState: 'o' } },
        ', ': {
          '*': { action_: [ 'output', 'comma' ], nextState: '0' } },
        '^_': {  // ^ and _ without a sensible argument
          '*': { } },
        '^{(...)}|^($...$)': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'D' },
          'q': { action_: 'd=', nextState: 'qD' },
          'd|D|qd|qD|dq': { action_: [ 'output', 'd=' ], nextState: 'D' } },
        '^a|^\\x{}{}|^\\x{}|^\\x|\'': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'd' },
          'q': { action_: 'd=', nextState: 'qd' },
          'd|qd|D|qD': { action_: 'd=' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' } },
        '_{(state of aggregation)}$': {
          'd|D|q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x': {
          '0|1|2|as': { action_: 'p=', nextState: 'p' },
          'b': { action_: 'p=', nextState: 'bp' },
          '3|o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '=<>': {
          '0|1|2|3|a|as|o|q|d|D|qd|qD|dq': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: '3' } },
        '#': {
          '0|1|2|3|a|as|o': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "#" } ], nextState: '3' } },
        '{}': {
          '*': { action_: { type_: 'output', option: 1 },  nextState: '1' } },
        '{...}': {
          '0|1|2|3|a|as|b|p|bp': { action_: 'o=', nextState: 'o' },
          'o|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '$...$': {
          'a': { action_: 'a=' },  // 2$n$
          '0|1|2|3|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },  // not 'amount'
          'as|o': { action_: 'o=' },
          'q|d|D|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '\\bond{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: "3" } },
        '\\frac{(...)}': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'frac-output' ], nextState: '3' } },
        '\\overset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'overset-output' ], nextState: '3' } },
        '\\underset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underset-output' ], nextState: '3' } },
        '\\underbrace{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underbrace-output' ], nextState: '3' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color-output' ], nextState: '3' } },
        '\\color{(...)}0': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color0-output' ] } },
        '\\ce{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'ce' ], nextState: '3' } },
        '\\,': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '1' } },
        '\\x{}{}|\\x{}|\\x': {
          '0|1|2|3|a|as|b|p|bp|o|c0': { action_: [ 'o=', 'output' ], nextState: '3' },
          '*': { action_: ['output', 'o=', 'output' ], nextState: '3' } },
        'others': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '3' } },
        'else2': {
          'a': { action_: 'a to o', nextState: 'o', revisit: true },
          'as': { action_: [ 'output', 'sb=true' ], nextState: '1', revisit: true },
          'r|rt|rd|rdt|rdq': { action_: [ 'output' ], nextState: '0', revisit: true },
          '*': { action_: [ 'output', 'copy' ], nextState: '3' } }
      }),
      actions: {
        'o after d': function (buffer, m) {
          var ret;
          if ((buffer.d || "").match(/^[0-9]+$/)) {
            var tmp = buffer.d;
            buffer.d = undefined;
            ret = this['output'](buffer);
            buffer.b = tmp;
          } else {
            ret = this['output'](buffer);
          }
          mhchemParser.actions['o='](buffer, m);
          return ret;
        },
        'd= kv': function (buffer, m) {
          buffer.d = m;
          buffer.dType = 'kv';
        },
        'charge or bond': function (buffer, m) {
          if (buffer['beginsWithBond']) {
            /** @type {ParserOutput[]} */
            var ret = [];
            mhchemParser.concatArray(ret, this['output'](buffer));
            mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            return ret;
          } else {
            buffer.d = m;
          }
        },
        '- after o/d': function (buffer, m, isAfterD) {
          var c1 = mhchemParser.patterns.match_('orbital', buffer.o || "");
          var c2 = mhchemParser.patterns.match_('one lowercase greek letter $', buffer.o || "");
          var c3 = mhchemParser.patterns.match_('one lowercase latin letter $', buffer.o || "");
          var c4 = mhchemParser.patterns.match_('$one lowercase latin letter$ $', buffer.o || "");
          var hyphenFollows =  m==="-" && ( c1 && c1.remainder===""  ||  c2  ||  c3  ||  c4 );
          if (hyphenFollows && !buffer.a && !buffer.b && !buffer.p && !buffer.d && !buffer.q && !c1 && c3) {
            buffer.o = '$' + buffer.o + '$';
          }
          /** @type {ParserOutput[]} */
          var ret = [];
          if (hyphenFollows) {
            mhchemParser.concatArray(ret, this['output'](buffer));
            ret.push({ type_: 'hyphen' });
          } else {
            c1 = mhchemParser.patterns.match_('digits', buffer.d || "");
            if (isAfterD && c1 && c1.remainder==='') {
              mhchemParser.concatArray(ret, mhchemParser.actions['d='](buffer, m));
              mhchemParser.concatArray(ret, this['output'](buffer));
            } else {
              mhchemParser.concatArray(ret, this['output'](buffer));
              mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            }
          }
          return ret;
        },
        'a to o': function (buffer) {
          buffer.o = buffer.a;
          buffer.a = undefined;
        },
        'sb=true': function (buffer) { buffer.sb = true; },
        'sb=false': function (buffer) { buffer.sb = false; },
        'beginsWithBond=true': function (buffer) { buffer['beginsWithBond'] = true; },
        'beginsWithBond=false': function (buffer) { buffer['beginsWithBond'] = false; },
        'parenthesisLevel++': function (buffer) { buffer['parenthesisLevel']++; },
        'parenthesisLevel--': function (buffer) { buffer['parenthesisLevel']--; },
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation', p1: mhchemParser.go(m, 'o') };
        },
        'comma': function (buffer, m) {
          var a = m.replace(/\s*$/, '');
          var withSpace = (a !== m);
          if (withSpace  &&  buffer['parenthesisLevel'] === 0) {
            return { type_: 'comma enumeration L', p1: a };
          } else {
            return { type_: 'comma enumeration M', p1: a };
          }
        },
        'output': function (buffer, m, entityFollows) {
          // entityFollows:
          //   undefined = if we have nothing else to output, also ignore the just read space (buffer.sb)
          //   1 = an entity follows, never omit the space if there was one just read before (can only apply to state 1)
          //   2 = 1 + the entity can have an amount, so output a\, instead of converting it to o (can only apply to states a|as)
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          if (!buffer.r) {
            ret = [];
            if (!buffer.a && !buffer.b && !buffer.p && !buffer.o && !buffer.q && !buffer.d && !entityFollows) {
              //ret = [];
            } else {
              if (buffer.sb) {
                ret.push({ type_: 'entitySkip' });
              }
              if (!buffer.o && !buffer.q && !buffer.d && !buffer.b && !buffer.p && entityFollows!==2) {
                buffer.o = buffer.a;
                buffer.a = undefined;
              } else if (!buffer.o && !buffer.q && !buffer.d && (buffer.b || buffer.p)) {
                buffer.o = buffer.a;
                buffer.d = buffer.b;
                buffer.q = buffer.p;
                buffer.a = buffer.b = buffer.p = undefined;
              } else {
                if (buffer.o && buffer.dType==='kv' && mhchemParser.patterns.match_('d-oxidation$', buffer.d || "")) {
                  buffer.dType = 'oxidation';
                } else if (buffer.o && buffer.dType==='kv' && !buffer.q) {
                  buffer.dType = undefined;
                }
              }
              ret.push({
                type_: 'chemfive',
                a: mhchemParser.go(buffer.a, 'a'),
                b: mhchemParser.go(buffer.b, 'bd'),
                p: mhchemParser.go(buffer.p, 'pq'),
                o: mhchemParser.go(buffer.o, 'o'),
                q: mhchemParser.go(buffer.q, 'pq'),
                d: mhchemParser.go(buffer.d, (buffer.dType === 'oxidation' ? 'oxidation' : 'bd')),
                dType: buffer.dType
              });
            }
          } else {  // r
            /** @type {ParserOutput[]} */
            var rd;
            if (buffer.rdt === 'M') {
              rd = mhchemParser.go(buffer.rd, 'tex-math');
            } else if (buffer.rdt === 'T') {
              rd = [ { type_: 'text', p1: buffer.rd || "" } ];
            } else {
              rd = mhchemParser.go(buffer.rd);
            }
            /** @type {ParserOutput[]} */
            var rq;
            if (buffer.rqt === 'M') {
              rq = mhchemParser.go(buffer.rq, 'tex-math');
            } else if (buffer.rqt === 'T') {
              rq = [ { type_: 'text', p1: buffer.rq || ""} ];
            } else {
              rq = mhchemParser.go(buffer.rq);
            }
            ret = {
              type_: 'arrow',
              r: buffer.r,
              rd: rd,
              rq: rq
            };
          }
          for (var p in buffer) {
            if (p !== 'parenthesisLevel'  &&  p !== 'beginsWithBond') {
              delete buffer[p];
            }
          }
          return ret;
        },
        'oxidation-output': function (buffer, m) {
          var ret = [ "{" ];
          mhchemParser.concatArray(ret, mhchemParser.go(m, 'oxidation'));
          ret.push("}");
          return ret;
        },
        'frac-output': function (buffer, m) {
          return { type_: 'frac-ce', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'overset-output': function (buffer, m) {
          return { type_: 'overset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underset-output': function (buffer, m) {
          return { type_: 'underset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underbrace-output': function (buffer, m) {
          return { type_: 'underbrace', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1]) };
        },
        'r=': function (buffer, m) { buffer.r = m; },
        'rdt=': function (buffer, m) { buffer.rdt = m; },
        'rd=': function (buffer, m) { buffer.rd = m; },
        'rqt=': function (buffer, m) { buffer.rqt = m; },
        'rq=': function (buffer, m) { buffer.rq = m; },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; }
      }
    },
    'a': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        '$(...)$': {
          '*': { action_: 'tex-math tight', nextState: '1' } },
        ',': {
          '*': { action_: { type_: 'insert', option: 'commaDecimal' } } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'o': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        'letters': {
          '*': { action_: 'rm' } },
        '\\ca': {
          '*': { action_: { type_: 'insert', option: 'circa' } } },
        '\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: '{text}' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'text': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '{...}': {
          '*': { action_: 'text=' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '\\greek': {
          '*': { action_: [ 'output', 'rm' ] } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: [ 'output', 'copy' ] } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.text_) {
            /** @type {ParserOutput} */
            var ret = { type_: 'text', p1: buffer.text_ };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'pq': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'state of aggregation $': {
          '*': { action_: 'state of aggregation' } },
        'i$': {
          '0': { nextState: '!f', revisit: true } },
        '(KV letters),': {
          '0': { action_: 'rm', nextState: '0' } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'letters': {
          '*': { action_: 'rm' } },
        '-9.,9': {
          '*': { action_: '9,9'  } },
        ',': {
          '*': { action_: { type_: 'insert+p1', option: 'comma enumeration S' } } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation subscript', p1: mhchemParser.go(m, 'o') };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'pq') };
        }
      }
    },
    'bd': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'x$': {
          '0': { nextState: '!f', revisit: true } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '-9.,9 no missing 0': {
          '*': { action_: '9,9' } },
        '.': {
          '*': { action_: { type_: 'insert', option: 'electron dot' } } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'x': {
          '*': { action_: { type_: 'insert', option: 'KV x' } } },
        'letters': {
          '*': { action_: 'rm' } },
        '\'': {
          '*': { action_: { type_: 'insert', option: 'prime' } } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'bd') };
        }
      }
    },
    'oxidation': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'roman numeral': {
          '*': { action_: 'roman-numeral' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'roman-numeral': function (buffer, m) { return { type_: 'roman numeral', p1: m || "" }; }
      }
    },
    'tex-math': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'tex-math tight': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        '-|+': {
          '*': { action_: 'tight operator' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'tight operator': function (buffer, m) { buffer.o = (buffer.o || "") + "{"+m+"}"; },
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    '9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        ',': {
          '*': { action_: 'comma' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; }
      }
    },
    //#endregion
    //
    // \pu state machines
    //
    //#region pu
    'pu': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'space$': {
          '*': { action_: [ 'output', 'space' ] } },
        '{[(|)]}': {
          '0|a': { action_: 'copy' } },
        '(-)(9)^(-9)': {
          '0': { action_: 'number^', nextState: 'a' } },
        '(-)(9.,9)(e)(99)': {
          '0': { action_: 'enumber', nextState: 'a' } },
        'space': {
          '0|a': {} },
        'pm-operator': {
          '0|a': { action_: { type_: 'operator', option: '\\pm' }, nextState: '0' } },
        'operator': {
          '0|a': { action_: 'copy', nextState: '0' } },
        '//': {
          'd': { action_: 'o=', nextState: '/' } },
        '/': {
          'd': { action_: 'o=', nextState: '/' } },
        '{...}|else': {
          '0|d': { action_: 'd=', nextState: 'd' },
          'a': { action_: [ 'space', 'd=' ], nextState: 'd' },
          '/|q': { action_: 'q=', nextState: 'q' } }
      }),
      actions: {
        'enumber': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          if (m[1]) {
            mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
            if (m[2]) {
              if (m[2].match(/[,.]/)) {
                mhchemParser.concatArray(ret, mhchemParser.go(m[2], 'pu-9,9'));
              } else {
                ret.push(m[2]);
              }
            }
            m[3] = m[4] || m[3];
            if (m[3]) {
              m[3] = m[3].trim();
              if (m[3] === "e"  ||  m[3].substr(0, 1) === "*") {
                ret.push({ type_: 'cdot' });
              } else {
                ret.push({ type_: 'times' });
              }
            }
          }
          if (m[3]) {
            ret.push("10^{"+m[5]+"}");
          }
          return ret;
        },
        'number^': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
          ret.push("^{"+m[2]+"}");
          return ret;
        },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; },
        'space': function () { return { type_: 'pu-space-1' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          var md = mhchemParser.patterns.match_('{(...)}', buffer.d || "");
          if (md  &&  md.remainder === '') { buffer.d = md.match_; }
          var mq = mhchemParser.patterns.match_('{(...)}', buffer.q || "");
          if (mq  &&  mq.remainder === '') { buffer.q = mq.match_; }
          if (buffer.d) {
            buffer.d = buffer.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.d = buffer.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
          }
          if (buffer.q) {  // fraction
            buffer.q = buffer.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.q = buffer.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
            var b5 = {
              d: mhchemParser.go(buffer.d, 'pu'),
              q: mhchemParser.go(buffer.q, 'pu')
            };
            if (buffer.o === '//') {
              ret = { type_: 'pu-frac', p1: b5.d, p2: b5.q };
            } else {
              ret = b5.d;
              if (b5.d.length > 1  ||  b5.q.length > 1) {
                ret.push({ type_: ' / ' });
              } else {
                ret.push({ type_: '/' });
              }
              mhchemParser.concatArray(ret, b5.q);
            }
          } else {  // no fraction
            ret = mhchemParser.go(buffer.d, 'pu-2');
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-2': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '*': {
          '*': { action_: [ 'output', 'cdot' ], nextState: '0' } },
        '\\x': {
          '*': { action_: 'rm=' } },
        'space': {
          '*': { action_: [ 'output', 'space' ], nextState: '0' } },
        '^{(...)}|^(-1)': {
          '1': { action_: '^(-1)' } },
        '-9.,9': {
          '0': { action_: 'rm=', nextState: '0' },
          '1': { action_: '^(-1)', nextState: '0' } },
        '{...}|else': {
          '*': { action_: 'rm=', nextState: '1' } }
      }),
      actions: {
        'cdot': function () { return { type_: 'tight cdot' }; },
        '^(-1)': function (buffer, m) { buffer.rm += "^{"+m+"}"; },
        'space': function () { return { type_: 'pu-space-2' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret = [];
          if (buffer.rm) {
            var mrm = mhchemParser.patterns.match_('{(...)}', buffer.rm || "");
            if (mrm  &&  mrm.remainder === '') {
              ret = mhchemParser.go(mrm.match_, 'pu');
            } else {
              ret = { type_: 'rm', p1: buffer.rm };
            }
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '0': { action_: 'output-0' },
          'o': { action_: 'output-o' } },
        ',': {
          '0': { action_: [ 'output-0', 'comma' ], nextState: 'o' } },
        '.': {
          '0': { action_: [ 'output-0', 'copy' ], nextState: 'o' } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; },
        'output-0': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length % 3;
            if (a === 0) { a = 3; }
            for (var i=buffer.text_.length-3; i>0; i-=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(0, a));
            ret.reverse();
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        },
        'output-o': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length - 3;
            for (var i=0; i<a; i+=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(i));
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    }
    //#endregion
  };

  //
  // texify: Take MhchemParser output and convert it to TeX
  //
  /** @type {Texify} */
  var texify = {
    go: function (input, isInner) {  // (recursive, max 4 levels)
      if (!input) { return ""; }
      var res = "";
      var cee = false;
      for (var i=0; i < input.length; i++) {
        var inputi = input[i];
        if (typeof inputi === "string") {
          res += inputi;
        } else {
          res += texify._go2(inputi);
          if (inputi.type_ === '1st-level escape') { cee = true; }
        }
      }
      if (!isInner && !cee && res) {
        res = "{" + res + "}";
      }
      return res;
    },
    _goInner: function (input) {
      if (!input) { return input; }
      return texify.go(input, true);
    },
    _go2: function (buf) {
      /** @type {undefined | string} */
      var res;
      switch (buf.type_) {
        case 'chemfive':
          res = "";
          var b5 = {
            a: texify._goInner(buf.a),
            b: texify._goInner(buf.b),
            p: texify._goInner(buf.p),
            o: texify._goInner(buf.o),
            q: texify._goInner(buf.q),
            d: texify._goInner(buf.d)
          };
          //
          // a
          //
          if (b5.a) {
            if (b5.a.match(/^[+\-]/)) { b5.a = "{"+b5.a+"}"; }
            res += b5.a + "\\,";
          }
          //
          // b and p
          //
          if (b5.b || b5.p) {
            res += "{\\vphantom{X}}";
            res += "^{\\hphantom{"+(b5.b||"")+"}}_{\\hphantom{"+(b5.p||"")+"}}";
            res += "{\\vphantom{X}}";
            // In the next two lines, I've removed \smash[t] (ron)
            // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
            //res += "^{\\smash[t]{\\vphantom{2}}\\mathllap{"+(b5.b||"")+"}}";
            res += "^{\\vphantom{2}\\mathllap{"+(b5.b||"")+"}}";
            //res += "_{\\vphantom{2}\\mathllap{\\smash[t]{"+(b5.p||"")+"}}}";
            res += "_{\\vphantom{2}\\mathllap{"+(b5.p||"")+"}}";
          }
          //
          // o
          //
          if (b5.o) {
            if (b5.o.match(/^[+\-]/)) { b5.o = "{"+b5.o+"}"; }
            res += b5.o;
          }
          //
          // q and d
          //
          if (buf.dType === 'kv') {
            if (b5.d || b5.q) {
              res += "{\\vphantom{X}}";
            }
            if (b5.d) {
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else if (buf.dType === 'oxidation') {
            if (b5.d) {
              res += "{\\vphantom{X}}";
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // A Firefox bug adds a bogus depth to <mphantom>, so we change \vphantom{X} to {}
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else {
            if (b5.q) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
            if (b5.d) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              res += "^{"+b5.d+"}";
            }
          }
          break;
        case 'rm':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'text':
          if (buf.p1.match(/[\^_]/)) {
            buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
            res = "\\mathrm{"+buf.p1+"}";
          } else {
            res = "\\text{"+buf.p1+"}";
          }
          break;
        case 'roman numeral':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'state of aggregation':
          res = "\\mskip2mu "+texify._goInner(buf.p1);
          break;
        case 'state of aggregation subscript':
          res = "\\mskip1mu "+texify._goInner(buf.p1);
          break;
        case 'bond':
          res = texify._getBond(buf.kind_);
          if (!res) {
            throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + buf.kind_ + ")"];
          }
          break;
        case 'frac':
          var c = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
          res = "\\mathchoice{\\textstyle"+c+"}{"+c+"}{"+c+"}{"+c+"}";
          break;
        case 'pu-frac':
          var d = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          res = "\\mathchoice{\\textstyle"+d+"}{"+d+"}{"+d+"}{"+d+"}";
          break;
        case 'tex-math':
          res = buf.p1 + " ";
          break;
        case 'frac-ce':
          res = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'overset':
          res = "\\overset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underset':
          res = "\\underset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underbrace':
          res =  "\\underbrace{" + texify._goInner(buf.p1) + "}_{" + texify._goInner(buf.p2) + "}";
          break;
        case 'color':
          res = "{\\color{" + buf.color1 + "}{" + texify._goInner(buf.color2) + "}}";
          break;
        case 'color0':
          res = "\\color{" + buf.color + "}";
          break;
        case 'arrow':
          var b6 = {
            rd: texify._goInner(buf.rd),
            rq: texify._goInner(buf.rq)
          };
          var arrow = texify._getArrow(buf.r);
          if (b6.rq) { arrow += "[{\\rm " + b6.rq + "}]"; }
          if (b6.rd) {
            arrow += "{\\rm " + b6.rd + "}";
          } else {
            arrow += "{}";
          }
          res = arrow;
          break;
        case 'operator':
          res = texify._getOperator(buf.kind_);
          break;
        case '1st-level escape':
          res = buf.p1+" ";  // &, \\\\, \\hlin
          break;
        case 'space':
          res = " ";
          break;
        case 'entitySkip':
          res = "~";
          break;
        case 'pu-space-1':
          res = "~";
          break;
        case 'pu-space-2':
          res = "\\mkern3mu ";
          break;
        case '1000 separator':
          res = "\\mkern2mu ";
          break;
        case 'commaDecimal':
          res = "{,}";
          break;
          case 'comma enumeration L':
          res = "{"+buf.p1+"}\\mkern6mu ";
          break;
        case 'comma enumeration M':
          res = "{"+buf.p1+"}\\mkern3mu ";
          break;
        case 'comma enumeration S':
          res = "{"+buf.p1+"}\\mkern1mu ";
          break;
        case 'hyphen':
          res = "\\text{-}";
          break;
        case 'addition compound':
          res = "\\,{\\cdot}\\,";
          break;
        case 'electron dot':
          res = "\\mkern1mu \\text{\\textbullet}\\mkern1mu ";
          break;
        case 'KV x':
          res = "{\\times}";
          break;
        case 'prime':
          res = "\\prime ";
          break;
        case 'cdot':
          res = "\\cdot ";
          break;
        case 'tight cdot':
          res = "\\mkern1mu{\\cdot}\\mkern1mu ";
          break;
        case 'times':
          res = "\\times ";
          break;
        case 'circa':
          res = "{\\sim}";
          break;
        case '^':
          res = "uparrow";
          break;
        case 'v':
          res = "downarrow";
          break;
        case 'ellipsis':
          res = "\\ldots ";
          break;
        case '/':
          res = "/";
          break;
        case ' / ':
          res = "\\,/\\,";
          break;
        default:
          assertNever(buf);
          throw ["MhchemBugT", "mhchem bug T. Please report."];  // Missing texify rule or unknown MhchemParser output
      }
      assertString(res);
      return res;
    },
    _getArrow: function (a) {
      switch (a) {
        case "->": return "\\yields";
        case "\u2192": return "\\yields";
        case "\u27F6": return "\\yields";
        case "<-": return "\\yieldsLeft";
        case "<->": return "\\mesomerism";
        case "<-->": return "\\yieldsLeftRight";
        case "<=>": return "\\equilibrium";
        case "\u21CC": return "\\equilibrium";
        case "<=>>": return "\\equilibriumRight";
        case "<<=>": return "\\equilibriumLeft";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getBond: function (a) {
      switch (a) {
        case "-": return "{-}";
        case "1": return "{-}";
        case "=": return "{=}";
        case "2": return "{=}";
        case "#": return "{\\equiv}";
        case "3": return "{\\equiv}";
        case "~": return "{\\tripleDash}";
        case "~-": return "{\\tripleDashOverLine}";
        case "~=": return "{\\tripleDashOverDoubleLine}";
        case "~--": return "{\\tripleDashOverDoubleLine}";
        case "-~-": return "{\\tripleDashBetweenDoubleLine}";
        case "...": return "{{\\cdot}{\\cdot}{\\cdot}}";
        case "....": return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
        case "->": return "{\\rightarrow}";
        case "<-": return "{\\leftarrow}";
        case "<": return "{<}";
        case ">": return "{>}";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getOperator: function (a) {
      switch (a) {
        case "+": return " {}+{} ";
        case "-": return " {}-{} ";
        case "=": return " {}={} ";
        case "<": return " {}<{} ";
        case ">": return " {}>{} ";
        case "<<": return " {}\\ll{} ";
        case ">>": return " {}\\gg{} ";
        case "\\pm": return " {}\\pm{} ";
        case "\\approx": return " {}\\approx{} ";
        case "$\\approx$": return " {}\\approx{} ";
        case "v": return " \\downarrow{} ";
        case "(v)": return " \\downarrow{} ";
        case "^": return " \\uparrow{} ";
        case "(^)": return " \\uparrow{} ";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    }
  };

  //
  // Helpers for code analysis
  // Will show type error at calling position
  //
  /** @param {number} a */
  function assertNever(a) {}
  /** @param {string} a */
  function assertString(a) {}

/* eslint-disable no-undef */

//////////////////////////////////////////////////////////////////////
// texvc.sty

// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax

// We also omit texvc's \O, which conflicts with \text{\O}

defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\bull", "\\bullet");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\isin", "\\in");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");

/* eslint-disable no-undef */

/****************************************************
 *
 *  physics.js
 *
 *  Implements the Physics Package for LaTeX input.
 *
 *  ---------------------------------------------------------------------
 *
 *  The original version of this file is licensed as follows:
 *  Copyright (c) 2015-2016 Kolen Cheung <https://github.com/ickc/MathJax-third-party-extensions>.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  ---------------------------------------------------------------------
 *
 *  This file has been revised from the original in the following ways:
 *  1. The interface is changed so that it can be called from Temml, not MathJax.
 *  2. \Re and \Im are not used, to avoid conflict with existing LaTeX letters.
 *
 *  This revision of the file is released under the MIT license.
 *  https://mit-license.org/
 */
defineMacro("\\quantity", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\qty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\pqty", "{\\left( #1 \\right)}");
defineMacro("\\bqty", "{\\left[ #1 \\right]}");
defineMacro("\\vqty", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\Bqty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\absolutevalue", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\abs", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\norm", "{\\left\\Vert #1 \\right\\Vert}");
defineMacro("\\evaluated", "{\\left.#1 \\right\\vert}");
defineMacro("\\eval", "{\\left.#1 \\right\\vert}");
defineMacro("\\order", "{\\mathcal{O} \\left( #1 \\right)}");
defineMacro("\\commutator", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\comm", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\anticommutator", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\acomm", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\poissonbracket", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\pb", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\vectorbold", "{\\boldsymbol{ #1 }}");
defineMacro("\\vb", "{\\boldsymbol{ #1 }}");
defineMacro("\\vectorarrow", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\va", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\vectorunit", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\vu", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\dotproduct", "\\mathbin{\\boldsymbol\\cdot}");
defineMacro("\\vdot", "{\\boldsymbol\\cdot}");
defineMacro("\\crossproduct", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cross", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cp", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\gradient", "{\\boldsymbol\\nabla}");
defineMacro("\\grad", "{\\boldsymbol\\nabla}");
defineMacro("\\divergence", "{\\grad\\vdot}");
//defineMacro("\\div", "{\\grad\\vdot}"); Not included in Temml. Conflicts w/LaTeX \div
defineMacro("\\curl", "{\\grad\\cross}");
defineMacro("\\laplacian", "\\nabla^2");
defineMacro("\\tr", "{\\operatorname{tr}}");
defineMacro("\\Tr", "{\\operatorname{Tr}}");
defineMacro("\\rank", "{\\operatorname{rank}}");
defineMacro("\\erf", "{\\operatorname{erf}}");
defineMacro("\\Res", "{\\operatorname{Res}}");
defineMacro("\\principalvalue", "{\\mathcal{P}}");
defineMacro("\\pv", "{\\mathcal{P}}");
defineMacro("\\PV", "{\\operatorname{P.V.}}");
// Temml does not use the next two lines. They conflict with LaTeX letters.
//defineMacro("\\Re", "{\\operatorname{Re} \\left\\{ #1 \\right\\}}");
//defineMacro("\\Im", "{\\operatorname{Im} \\left\\{ #1 \\right\\}}");
defineMacro("\\qqtext", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qq", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qcomma", "{\\text{,}\\quad}");
defineMacro("\\qc", "{\\text{,}\\quad}");
defineMacro("\\qcc", "{\\quad\\text{c.c.}\\quad}");
defineMacro("\\qif", "{\\quad\\text{if}\\quad}");
defineMacro("\\qthen", "{\\quad\\text{then}\\quad}");
defineMacro("\\qelse", "{\\quad\\text{else}\\quad}");
defineMacro("\\qotherwise", "{\\quad\\text{otherwise}\\quad}");
defineMacro("\\qunless", "{\\quad\\text{unless}\\quad}");
defineMacro("\\qgiven", "{\\quad\\text{given}\\quad}");
defineMacro("\\qusing", "{\\quad\\text{using}\\quad}");
defineMacro("\\qassume", "{\\quad\\text{assume}\\quad}");
defineMacro("\\qsince", "{\\quad\\text{since}\\quad}");
defineMacro("\\qlet", "{\\quad\\text{let}\\quad}");
defineMacro("\\qfor", "{\\quad\\text{for}\\quad}");
defineMacro("\\qall", "{\\quad\\text{all}\\quad}");
defineMacro("\\qeven", "{\\quad\\text{even}\\quad}");
defineMacro("\\qodd", "{\\quad\\text{odd}\\quad}");
defineMacro("\\qinteger", "{\\quad\\text{integer}\\quad}");
defineMacro("\\qand", "{\\quad\\text{and}\\quad}");
defineMacro("\\qor", "{\\quad\\text{or}\\quad}");
defineMacro("\\qas", "{\\quad\\text{as}\\quad}");
defineMacro("\\qin", "{\\quad\\text{in}\\quad}");
defineMacro("\\differential", "{\\text{d}}");
defineMacro("\\dd", "{\\text{d}}");
defineMacro("\\derivative", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\dv", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\partialderivative", "{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}");
defineMacro("\\variation", "{\\delta}");
defineMacro("\\var", "{\\delta}");
defineMacro("\\functionalderivative", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\fdv", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\innerproduct", "{\\left\\langle {#1} \\mid { #2} \\right\\rangle}");
defineMacro("\\outerproduct",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\dyad",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\ketbra",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\op",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\expectationvalue", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\expval", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\ev", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\matrixelement",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\matrixel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\mel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");

// Helper functions
function getHLines(parser) {
  // Return an array. The array length = number of hlines.
  // Each element in the array tells if the line is dashed.
  const hlineInfo = [];
  parser.consumeSpaces();
  let nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}

const validateAmsEnvironmentContext = context => {
  const settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError(`{${context.envName}} can be used only in display mode.`);
  }
};

const sizeRegEx$1 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const arrayGaps = macros => {
  let arraystretch = macros.get("\\arraystretch");
  if (typeof arraystretch !== "string") {
    arraystretch = stringFromArg(arraystretch.tokens);
  }
  arraystretch = isNaN(arraystretch) ? null : Number(arraystretch);
  let arraycolsepStr = macros.get("\\arraycolsep");
  if (typeof arraycolsepStr !== "string") {
    arraycolsepStr = stringFromArg(arraycolsepStr.tokens);
  }
  const match = sizeRegEx$1.exec(arraycolsepStr);
  const arraycolsep = match
    ? { number: +(match[1] + match[2]), unit: match[3] }
    : null;
  return [arraystretch, arraycolsep]
};

const checkCellForLabels = cell => {
  // Check if the author wrote a \tag{} inside this cell.
  let rowLabel = "";
  for (let i = 0; i < cell.length; i++) {
    if (cell[i].type === "label") {
      if (rowLabel) { throw new ParseError(("Multiple \\labels in one row")) }
      rowLabel = cell[i].string;
    }
  }
  return rowLabel
};

// autoTag (an argument to parseArray) can be one of three values:
// * undefined: Regular (not-top-level) array; no tags on each row
// * true: Automatic equation numbering, overridable by \tag
// * false: Tags allowed on each row, but no automatic numbering
// This function *doesn't* work with the "split" environment name.
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
  // return undefined;
}

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument scriptLevel
 * ("text", "display", etc.), then each cell is cast into that scriptLevel.
 */
function parseArray(
  parser,
  {
    cols, // [{ type: string , align: l|c|r|null }]
    envClasses, // align(ed|at|edat) | array | cases | cd | small | multline
    autoTag,        // boolean
    singleRow,      // boolean
    emptySingleRow, // boolean
    maxNumCols,     // number
    leqno,          // boolean
    arraystretch,   // number  | null
    arraycolsep     // size value | null
},
  scriptLevel
) {
  const endToken = envClasses && envClasses.includes("bordermatrix") ? "}" : "\\end";
  parser.gullet.beginGroup();
  if (!singleRow) {
    // \cr is equivalent to \\ without the optional size argument (see below)
    // TODO: provide helpful error when \cr is used outside array environment
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }

  // Start group for first cell
  parser.gullet.beginGroup();

  let row = [];
  const body = [row];
  const rowGaps = [];
  const labels = [];

  const hLinesBeforeRow = [];

  const tags = (autoTag != null ? [] : undefined);

  // amsmath uses \global\@eqnswtrue and \global\@eqnswfalse to represent
  // whether this row should have an equation number.  Simulate this with
  // a \@eqnsw macro set to 1 or 0.
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", undefined, true);
      } else {
        tags.push(Boolean(autoTag) &&
            parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();

  // Test for \hline at the top of the array.
  hLinesBeforeRow.push(getHLines(parser));

  while (true) {
    // Parse each cell in its own group (namespace)
    let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();

    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell,
      semisimple: true
    };
    row.push(cell);
    const next = parser.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (envClasses.includes("array")) {
          if (parser.settings.strict) {
            throw new ParseError("Too few columns " + "specified in the {array} column argument.",
              parser.nextToken)
          }
        } else if (maxNumCols === 2) {
          throw new ParseError("The split environment accepts no more than two columns",
            parser.nextToken);
        } else {
          throw new ParseError("The equation environment accepts only one column",
            parser.nextToken)
        }
      }
      parser.consume();
    } else if (next === endToken) {
      endRow();
      // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
      // the last line is empty.  However, AMS environments keep the
      // empty row if it's the only one.
      // NOTE: Currently, `cell` is the last item added into `row`.
      if (row.length === 1 && cell.body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      labels.push(checkCellForLabels(cell.body));
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser.consume();
      let size;
      // \def\Let@{\let\\\math@cr}
      // \def\math@cr{...\math@cr@}
      // \def\math@cr@{\new@ifnextchar[\math@cr@@{\math@cr@@[\z@]}}
      // \def\math@cr@@[#1]{...\math@cr@@@...}
      // \def\math@cr@@@{\cr}
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();

      labels.push(checkCellForLabels(cell.body));

      // check for \hline(s) following the row separator
      hLinesBeforeRow.push(getHLines(parser));

      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or " + endToken, parser.nextToken);
    }
  }

  // End cell group
  parser.gullet.endGroup();
  // End array group defining \cr
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: parser.mode,
    body,
    cols,
    rowGaps,
    hLinesBeforeRow,
    envClasses,
    autoTag,
    scriptLevel,
    tags,
    labels,
    leqno,
    arraystretch,
    arraycolsep
  };
}

// Decides on a scriptLevel for cells in an array according to whether the given
// environment name starts with the letter 'd'.
function dCellStyle(envName) {
  return envName.slice(0, 1) === "d" ? "display" : "text"
}

const alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};

const glue = group => {
  const glueNode = new mathMLTree.MathNode("mtd", []);
  glueNode.style = { padding: "0", width: "50%" };
  if (group.envClasses.includes("multline")) {
    glueNode.style.width = "7.5%";
  }
  return glueNode
};

const mathmlBuilder$9 = function(group, style) {
  const tbl = [];
  const numRows = group.body.length;
  const hlines = group.hLinesBeforeRow;

  for (let i = 0; i < numRows; i++) {
    const rw = group.body[i];
    const row = [];
    const cellLevel = group.scriptLevel === "text"
      ? StyleLevel.TEXT
      : group.scriptLevel === "script"
      ? StyleLevel.SCRIPT
      : StyleLevel.DISPLAY;

    for (let j = 0; j < rw.length; j++) {
      const mtd = new mathMLTree.MathNode(
        "mtd",
        [buildGroup$1(rw[j], style.withLevel(cellLevel))]
      );

      if (group.envClasses.includes("multline")) {
        const align = i === 0 ? "left" : i === numRows - 1 ? "right" : "center";
        mtd.setAttribute("columnalign", align);
        if (align !== "center") {
          mtd.classes.push("tml-" + align);
        }
      }
      row.push(mtd);
    }
    const numColumns = group.body[0].length;
    // Fill out a short row with empty <mtd> elements.
    for (let k = 0; k < numColumns - rw.length; k++) {
      row.push(new mathMLTree.MathNode("mtd", [], style));
    }
    if (group.autoTag) {
      const tag = group.tags[i];
      let tagElement;
      if (tag === true) {  // automatic numbering
        tagElement = new mathMLTree.MathNode("mtext", [new Span(["tml-eqn"])]);
      } else if (tag === false) {
        // \nonumber/\notag or starred environment
        tagElement = new mathMLTree.MathNode("mtext", [], []);
      } else {  // manual \tag
        tagElement = buildExpressionRow(tag[0].body, style.withLevel(cellLevel), true);
        tagElement = consolidateText(tagElement);
        tagElement.classes = ["tml-tag"];
      }
      if (tagElement) {
        row.unshift(glue(group));
        row.push(glue(group));
        if (group.leqno) {
          row[0].children.push(tagElement);
          row[0].classes.push("tml-left");
        } else {
          row[row.length - 1].children.push(tagElement);
          row[row.length - 1].classes.push("tml-right");
        }
      }
    }
    const mtr = new mathMLTree.MathNode("mtr", row, []);
    const label = group.labels.shift();
    if (label && group.tags && group.tags[i]) {
      mtr.setAttribute("id", label);
      if (Array.isArray(group.tags[i])) { mtr.classes.push("tml-tageqn"); }
    }

    // Write horizontal rules
    if (i === 0 && hlines[0].length > 0) {
      if (hlines[0].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderTop = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderTop = hlines[0][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }
    if (hlines[i + 1].length > 0) {
      if (hlines[i + 1].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderBottom = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderBottom = hlines[i + 1][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }

    // Check for \hphantom \from \bordermatrix
    let mustSquashRow = true;
    for (let j = 0; j < mtr.children.length; j++) {
      const child = mtr.children[j].children[0];
      if (!(child && child.type === "mpadded" && child.attributes.height === "0px")) {
        mustSquashRow = false;
        break
      }
    }
    if (mustSquashRow) {
      // All the cell contents are \hphantom. Squash the padding.
      for (let j = 0; j < mtr.children.length; j++) {
        mtr.children[j].style.paddingTop = "0";
        mtr.children[j].style.paddingBottom = "0";
      }
    }

    tbl.push(mtr);
  }

  if (group.arraystretch && group.arraystretch !== 1) {
    // In LaTeX, \arraystretch is a factor applied to a 12pt strut height.
    // It defines a baseline to baseline distance.
    // Here, we do an approximation of that approach.
    const pad = String(1.4 * group.arraystretch - 0.8) + "ex";
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingTop = pad;
        tbl[i].children[j].style.paddingBottom = pad;
      }
    }
  }

  let sidePadding;
  let sidePadUnit;
  if (group.envClasses.length > 0) {
    sidePadding = group.envClasses.includes("abut")
      ? "0"
      : group.envClasses.includes("cases")
      ? "0"
      : group.envClasses.includes("small")
      ? "0.1389"
      : group.envClasses.includes("cd")
      ? "0.25"
      : "0.4"; // default side padding
    sidePadUnit = "em";
  }
  if (group.arraycolsep) {
    const arraySidePad = calculateSize(group.arraycolsep, style);
    sidePadding = arraySidePad.number.toFixed(4);
    sidePadUnit = arraySidePad.unit;
  }
  if (sidePadding) {
    const numCols = tbl.length === 0 ? 0 : tbl[0].children.length;

    const sidePad = (j, hand) => {
      if (j === 0 && hand === 0) { return "0" }
      if (j === numCols - 1 && hand === 1) { return "0" }
      if (group.envClasses[0] !== "align") { return sidePadding }
      if (hand === 1) { return "0" }
      if (group.autoTag) {
        return (j % 2) ? "1" : "0"
      } else {
        return (j % 2) ? "0" : "1"
      }
    };

    // Side padding
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingLeft = `${sidePad(j, 0)}${sidePadUnit}`;
        tbl[i].children[j].style.paddingRight = `${sidePad(j, 1)}${sidePadUnit}`;
      }
    }
  }
  if (group.envClasses.length === 0) {
    // Set zero padding on side of the matrix
    for (let i = 0; i < tbl.length; i++) {
      tbl[i].children[0].style.paddingLeft = "0em";
      if (tbl[i].children.length === tbl[0].children.length) {
        tbl[i].children[tbl[i].children.length - 1].style.paddingRight = "0em";
      }
    }
  }

  if (group.envClasses.length > 0) {
    // Justification
    const align = group.envClasses.includes("align") || group.envClasses.includes("alignat");
    for (let i = 0; i < tbl.length; i++) {
      const row = tbl[i];
      if (align) {
        for (let j = 0; j < row.children.length; j++) {
          // Chromium does not recognize text-align: left. Use -webkit-
          // TODO: Remove -webkit- when Chromium no longer needs it.
          row.children[j].classes = ["tml-" + (j % 2 ? "left" : "right")];
        }
        if (group.autoTag) {
          const k = group.leqno ? 0 : row.children.length - 1;
          row.children[k].classes = ["tml-" + (group.leqno ? "left" : "right")];
        }
      }
      if (row.children.length > 1 && group.envClasses.includes("cases")) {
        row.children[1].style.paddingLeft = "1em";
      }

      if (group.envClasses.includes("cases") || group.envClasses.includes("subarray")) {
        for (const cell of row.children) {
          cell.classes.push("tml-left");
        }
      }
    }
  }

  let table = new mathMLTree.MathNode("mtable", tbl);
  if (group.envClasses.length > 0) {
    // Top & bottom padding
    if (group.envClasses.includes("jot")) {
      table.classes.push("tml-jot");
    } else if (group.envClasses.includes("small")) {
      table.classes.push("tml-small");
    }
  }
  if (group.scriptLevel === "display") { table.setAttribute("displaystyle", "true"); }

  if (group.autoTag || group.envClasses.includes("multline")) {
    table.style.width = "100%";
  }

  // Column separator lines and column alignment
  let align = "";

  if (group.cols && group.cols.length > 0) {
    const cols = group.cols;
    let prevTypeWasAlign = false;
    let iStart = 0;
    let iEnd = cols.length;

    while (cols[iStart].type === "separator") {
      iStart += 1;
    }
    while (cols[iEnd - 1].type === "separator") {
      iEnd -= 1;
    }

    if (cols[0].type === "separator") {
      const sep = cols[1].type === "separator"
        ? "0.15em double"
        : cols[0].separator === "|"
        ? "0.06em solid "
        : "0.06em dashed ";
      for (const row of table.children) {
        row.children[0].style.borderLeft = sep;
      }
    }
    let iCol = group.autoTag ? 0 : -1;
    for (let i = iStart; i < iEnd; i++) {
      if (cols[i].type === "align") {
        const colAlign = alignMap[cols[i].align];
        align += colAlign;
        iCol += 1;
        for (const row of table.children) {
          if (colAlign.trim() !== "center" && iCol < row.children.length) {
            row.children[iCol].classes = ["tml-" + colAlign.trim()];
          }
        }
        prevTypeWasAlign = true;
      } else if (cols[i].type === "separator") {
        // MathML accepts only single lines between cells.
        // So we read only the first of consecutive separators.
        if (prevTypeWasAlign) {
          const sep = cols[i + 1].type === "separator"
            ? "0.15em double"
            : cols[i].separator === "|"
            ? "0.06em solid"
            : "0.06em dashed";
          for (const row of table.children) {
            if (iCol < row.children.length) {
              row.children[iCol].style.borderRight = sep;
            }
          }
        }
        prevTypeWasAlign = false;
      }
    }
    if (cols[cols.length - 1].type === "separator") {
      const sep = cols[cols.length - 2].type === "separator"
        ? "0.15em double"
        : cols[cols.length - 1].separator === "|"
        ? "0.06em solid"
        : "0.06em dashed";
      for (const row of table.children) {
        row.children[row.children.length - 1].style.borderRight = sep;
        row.children[row.children.length - 1].style.paddingRight = "0.4em";
      }
    }
  }
  if (group.autoTag) {
     // allow for glue cells on each side
    align = "left " + (align.length > 0 ? align : "center ") + "right ";
  }
  if (align) {
    // Firefox reads this attribute, not the -webkit-left|right written above.
    // TODO: When Chrome no longer needs "-webkit-", use CSS and delete the next line.
    table.setAttribute("columnalign", align.trim());
  }

  if (group.envClasses.includes("small")) {
    // A small array. Wrap in scriptstyle.
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }

  return table
};

// Convenience function for align, align*, aligned, alignat, alignat*, alignedat, split.
const alignedHandler = function(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  const isSplit = context.envName === "split";
  const cols = [];
  const res = parseArray(
    context.parser,
    {
      cols,
      emptySingleRow: true,
      autoTag: isSplit ? undefined : getAutoTag(context.envName),
      envClasses: ["abut", "jot"], // set row spacing & provisional column spacing
      maxNumCols: context.envName === "split" ? 2 : undefined,
      leqno: context.parser.settings.leqno
    },
    "display"
  );

  // Determining number of columns.
  // 1. If the first argument is given, we use it as a number of columns,
  //    and makes sure that each row doesn't exceed that number.
  // 2. Otherwise, just count number of columns = maximum number
  //    of cells in each row ("aligned" mode -- isAligned will be true).
  //
  // At the same time, prepend empty group {} at beginning of every second
  // cell in each row (starting with second cell) so that operators become
  // binary.  This behavior is implemented in amsmath's \start@aligned.
  let numMaths;
  let numCols = 0;
  const isAlignedAt = context.envName.indexOf("at") > -1;
  if (args[0] && isAlignedAt) {
    // alignat environment takes an argument w/ number of columns
    let arg0 = "";
    for (let i = 0; i < args[0].body.length; i++) {
      const textord = assertNodeType(args[0].body[i], "textord");
      arg0 += textord.text;
    }
    if (isNaN(arg0)) {
      throw new ParseError("The alignat enviroment requires a numeric first argument.")
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  res.body.forEach(function(row) {
    if (isAlignedAt) {
      // Case 1
      const curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError(
          "Too many math in a row: " + `expected ${numMaths}, but got ${curMaths}`,
          row[0]
        );
      }
    } else if (numCols < row.length) {
      // Case 2
      numCols = row.length;
    }
  });

  // Adjusting alignment.
  // In aligned mode, we add one \qquad between columns;
  // otherwise we add nothing.
  for (let i = 0; i < numCols; ++i) {
    let align = "r";
    if (i % 2 === 1) {
      align = "l";
    }
    cols[i] = {
      type: "align",
      align: align
    };
  }
  if (context.envName === "split") ; else if (isAlignedAt) {
    res.envClasses.push("alignat"); // Sets justification
  } else {
    res.envClasses[0] = "align"; // Sets column spacing & justification
  }
  return res;
};

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    const res = {
      cols,
      envClasses: ["array"],
      maxNumCols: cols.length,
      arraystretch,
      arraycolsep
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  mathmlBuilder: mathmlBuilder$9
});

// The matrix environments of amsmath build on the array environment
// of LaTeX, which is discussed above.
// The mathtools package adds starred versions of the same environments.
// These have an optional argument to choose left|center|right justification.
defineEnvironment({
  type: "array",
  names: [
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix",
    "matrix*",
    "pmatrix*",
    "bmatrix*",
    "Bmatrix*",
    "vmatrix*",
    "Vmatrix*"
  ],
  props: {
    numArgs: 0
  },
  handler(context) {
    const delimiters = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    // \hskip -\arraycolsep in amsmath
    let colAlign = "c";
    const payload = {
      envClasses: [],
      cols: []
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      // It's one of the mathtools starred functions.
      // Parse the optional alignment argument.
      const parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [];
      }
    }
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: colAlign });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    res.arraystretch = arraystretch;
    if (arraycolsep && !(arraycolsep === 6 && arraycolsep === "pt")) {
      res.arraycolsep = arraycolsep;
    }
    return delimiters
      ? {
        type: "leftright",
        mode: context.mode,
        body: [res],
        left: delimiters[0],
        right: delimiters[1],
        rightColor: undefined // \right uninfluenced by \color in array
      }
      : res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["bordermatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { cols: [], envClasses: ["bordermatrix"] };
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: "c" });
    res.envClasses = [];
    res.arraystretch = 1;
    if (context.envName === "matrix") { return res}
    return bordermatrixParseTree(res, context.delimiters)
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { type: "small" };
    const res = parseArray(context.parser, payload, "script");
    res.envClasses = ["small"];
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Parsing of {subarray} is similar to {array}
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      // {subarray} only recognizes "l" & "c"
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    let res = {
      cols,
      envClasses: ["small"]
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def
// \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.
// {rcases} is another mathtools environment. It's brace is on the right side.
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = {
      cols: [],
      envClasses: ["cases"]
    };
    const res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: undefined
    };
  },
  mathmlBuilder: mathmlBuilder$9
});

// In the align environment, one uses ampersands, &, to specify number of
// columns in each row, and to locate spacing between each column.
// align gets automatic numbering. align* and aligned do not.
// The alignedat environment can be used in math mode.
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust where spacing occurs.
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (context.envName !== "gathered") {
      validateAmsEnvironmentContext(context);
    }
    const res = {
      cols: [],
      envClasses: ["abut", "jot"],
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      envClasses: ["align"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["multline", "multline*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: context.envName === "multline",
      maxNumCols: 1,
      envClasses: ["jot", "multline"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  mathmlBuilder: mathmlBuilder$9
});

// Catch \hline outside array environment
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(`${context.funcName} valid only within array environment`);
  }
});

const environments = _environments;

// \bordermatrix  from TeXbook pp 177 & 361
// Optional argument from Herbert Voß, Math mode, p 20
// Ref: https://tug.ctan.org/obsolete/info/math/voss/mathmode/Mathmode.pdf

defineFunction({
  type: "bordermatrix",
  names: ["\\bordermatrix", "\\matrix"],
  props: {
    numArgs: 0,
    numOptionalArgs: 1
  },
  handler: ({ parser, funcName }, args, optArgs) => {
    // Find out if the author has defined custom delimiters
    let delimiters = ["(", ")"];
    if (funcName === "\\bordermatrix" && optArgs[0] && optArgs[0].body) {
      const body = optArgs[0].body;
      if (body.length === 2 && body[0].type === "atom" && body[1].type === "atom") {
        if (body[0].family === "open" && body[1].family === "close") {
          delimiters = [body[0].text, body[1].text];
        }
      }
    }
    // consume the opening brace
    parser.consumeSpaces();
    parser.consume();

    // Pass control to the environment handler in array.js.
    const env = environments["bordermatrix"];
    const context = {
      mode: parser.mode,
      envName: funcName.slice(1),
      delimiters,
      parser
    };
    const result = env.handler(context);
    parser.expect("}", true);
    return result
  }
});

// \@char is an internal function that takes a grouped decimal argument like
// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, token }, args) {
    const arg = assertNodeType(args[0], "ordgroup");
    const group = arg.body;
    let number = "";
    for (let i = 0; i < group.length; i++) {
      const node = assertNodeType(group[i], "textord");
      number += node.text;
    }
    const code = parseInt(number);
    if (isNaN(code)) {
      throw new ParseError(`\\@char has non-numeric argument ${number}`, token)
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: String.fromCodePoint(code)
    }
  }
});

// Helpers
const htmlRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6})$/i;
const htmlOrNameRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i;
const RGBregEx = /^ *\d{1,3} *(?:, *\d{1,3} *){2}$/;
const rgbRegEx = /^ *[10](?:\.\d*)? *(?:, *[10](?:\.\d*)? *){2}$/;
const xcolorHtmlRegEx = /^[a-f0-9]{6}$/i;
const toHex = num => {
  let str = num.toString(16);
  if (str.length === 1) { str = "0" + str; }
  return str
};

// Colors from Tables 4.1 and 4.2 of the xcolor package.
// Table 4.1 (lower case) RGB values are taken from chroma and xcolor.dtx.
// Table 4.2 (Capitalizzed) values were sampled, because Chroma contains a unreliable
// conversion from cmyk to RGB. See https://tex.stackexchange.com/a/537274.
const xcolors = JSON.parse(`{
  "Apricot": "#ffb484",
  "Aquamarine": "#08b4bc",
  "Bittersweet": "#c84c14",
  "blue": "#0000FF",
  "Blue": "#303494",
  "BlueGreen": "#08b4bc",
  "BlueViolet": "#503c94",
  "BrickRed": "#b8341c",
  "brown": "#BF8040",
  "Brown": "#802404",
  "BurntOrange": "#f8941c",
  "CadetBlue": "#78749c",
  "CarnationPink": "#f884b4",
  "Cerulean": "#08a4e4",
  "CornflowerBlue": "#40ace4",
  "cyan": "#00FFFF",
  "Cyan": "#08acec",
  "Dandelion": "#ffbc44",
  "darkgray": "#404040",
  "DarkOrchid": "#a8548c",
  "Emerald": "#08ac9c",
  "ForestGreen": "#089c54",
  "Fuchsia": "#90348c",
  "Goldenrod": "#ffdc44",
  "gray": "#808080",
  "Gray": "#98949c",
  "green": "#00FF00",
  "Green": "#08a44c",
  "GreenYellow": "#e0e474",
  "JungleGreen": "#08ac9c",
  "Lavender": "#f89cc4",
  "lightgray": "#c0c0c0",
  "lime": "#BFFF00",
  "LimeGreen": "#90c43c",
  "magenta": "#FF00FF",
  "Magenta": "#f0048c",
  "Mahogany": "#b0341c",
  "Maroon": "#b03434",
  "Melon": "#f89c7c",
  "MidnightBlue": "#086494",
  "Mulberry": "#b03c94",
  "NavyBlue": "#086cbc",
  "olive": "#7F7F00",
  "OliveGreen": "#407c34",
  "orange": "#FF8000",
  "Orange": "#f8843c",
  "OrangeRed": "#f0145c",
  "Orchid": "#b074ac",
  "Peach": "#f8945c",
  "Periwinkle": "#8074bc",
  "PineGreen": "#088c74",
  "pink": "#ff7f7f",
  "Plum": "#98248c",
  "ProcessBlue": "#08b4ec",
  "purple": "#BF0040",
  "Purple": "#a0449c",
  "RawSienna": "#983c04",
  "red": "#ff0000",
  "Red": "#f01c24",
  "RedOrange": "#f86434",
  "RedViolet": "#a0246c",
  "Rhodamine": "#f0549c",
  "Royallue": "#0874bc",
  "RoyalPurple": "#683c9c",
  "RubineRed": "#f0047c",
  "Salmon": "#f8948c",
  "SeaGreen": "#30bc9c",
  "Sepia": "#701404",
  "SkyBlue": "#48c4dc",
  "SpringGreen": "#c8dc64",
  "Tan": "#e09c74",
  "teal": "#007F7F",
  "TealBlue": "#08acb4",
  "Thistle": "#d884b4",
  "Turquoise": "#08b4cc",
  "violet": "#800080",
  "Violet": "#60449c",
  "VioletRed": "#f054a4",
  "WildStrawberry": "#f0246c",
  "yellow": "#FFFF00",
  "Yellow": "#fff404",
  "YellowGreen": "#98cc6c",
  "YellowOrange": "#ffa41c"
}`);

const colorFromSpec = (model, spec) => {
  let color = "";
  if (model === "HTML") {
    if (!htmlRegEx.test(spec)) {
      throw new ParseError("Invalid HTML input.")
    }
    color = spec;
  } else if (model === "RGB") {
    if (!RGBregEx.test(spec)) {
      throw new ParseError("Invalid RGB input.")
    }
    spec.split(",").map(e => { color += toHex(Number(e.trim())); });
  } else {
    if (!rgbRegEx.test(spec)) {
      throw new ParseError("Invalid rbg input.")
    }
    spec.split(",").map(e => {
      const num = Number(e.trim());
      if (num > 1) { throw new ParseError("Color rgb input must be < 1.") }
      color += toHex(Number((num * 255).toFixed(0)));
    });
  }
  if (color.charAt(0) !== "#") { color = "#" + color; }
  return color
};

const validateColor = (color, macros, token) => {
  const macroName = `\\\\color@${color}`; // from \defineColor.
  const match = htmlOrNameRegEx.exec(color);
  if (!match) { throw new ParseError("Invalid color: '" + color + "'", token) }
  // We allow a 6-digit HTML color spec without a leading "#".
  // This follows the xcolor package's HTML color model.
  // Predefined color names are all missed by this RegEx pattern.
  if (xcolorHtmlRegEx.test(color)) {
    return "#" + color
  } else if (color.charAt(0) === "#") {
    return color
  } else if (macros.has(macroName)) {
    color = macros.get(macroName).tokens[0].text;
  } else if (xcolors[color]) {
    color = xcolors[color];
  }
  return color
};

const mathmlBuilder$8 = (group, style) => {
  // In LaTeX, color is not supposed to change the spacing of any node.
  // So instead of wrapping the group in an <mstyle>, we apply
  // the color individually to each node and return a document fragment.
  let expr = buildExpression(group.body, style.withColor(group.color));
  expr = expr.map(e => {
    e.style.color = group.color;
    return e
  });
  return mathMLTree.newDocumentFragment(expr)
};

defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "original"]
  },
  handler({ parser, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }
    const body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: true,
      body: ordargument(body)
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw"]
  },
  handler({ parser, breakOnTokenText, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }

    // Parse out the implicit body that should be colored.
    const body = parser.parseExpression(true, breakOnTokenText, true);

    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: false,
      body
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\definecolor"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw"]
  },
  handler({ parser, funcName, token }, args) {
    const name = assertNodeType(args[0], "raw").string;
    if (!/^[A-Za-z]+$/.test(name)) {
      throw new ParseError("Color name must be latin letters.", token)
    }
    const model = assertNodeType(args[1], "raw").string;
    if (!["HTML", "RGB", "rgb"].includes(model)) {
      throw new ParseError("Color model must be HTML, RGB, or rgb.", token)
    }
    const spec = assertNodeType(args[2], "raw").string;
    const color = colorFromSpec(model, spec);
    parser.gullet.macros.set(`\\\\color@${name}`, { tokens: [{ text: color }], numArgs: 0 });
    return { type: "internal", mode: parser.mode }
  }
  // No mathmlBuilder. The point of \definecolor is to set a macro.
});

// Row breaks within tabular environments, and line breaks at top level


// \DeclareRobustCommand\\{...\@xnewline}
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },

  handler({ parser }, args, optArgs) {
    const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    const newLine = !parser.settings.displayMode;
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    }
  },

  // The following builder is called only at the top level,
  // not within tabular/array environments.

  mathmlBuilder(group, style) {
    // MathML 3.0 calls for newline to occur in an <mo> or an <mspace>.
    // Ref: https://www.w3.org/TR/MathML3/chapter3.html#presm.linebreaking
    const node = new mathMLTree.MathNode("mo");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        const size = calculateSize(group.size, style);
        node.setAttribute("height", size.number + size.unit);
      }
    }
    return node
  }
});

const globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};

const checkControlSequence = (tok) => {
  const name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};

const getRHS = (parser) => {
  let tok = parser.gullet.popToken();
  if (tok.text === "=") {
    // consume optional equals
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      // consume one optional space
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};

const letCommand = (parser, name, tok, global) => {
  let macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    // don't expand it later even if a macro with the same name is defined
    // e.g., \let\foo=\frac \def\frac{\relax} \frac12
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global);
};

// <assignment> -> <non-macro assignment>|<macro assignment>
// <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
// <macro assignment> -> <definition>|<prefix><macro assignment>
// <prefix> -> \global|\long|\outer
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser, funcName }) {
    parser.consumeSpaces();
    const token = parser.fetch();
    if (globalMap[token.text]) {
      // Temml doesn't have \par, so ignore \long
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError(`Invalid token after macro prefix`, token);
  }
});

// Basic support for macro definitions: \def, \gdef, \edef, \xdef
// <definition> -> <def><control sequence><definition text>
// <def> -> \def|\gdef|\edef|\xdef
// <definition text> -> <parameter text><left brace><balanced text><right brace>
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let tok = parser.gullet.popToken();
    const name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }

    let numArgs = 0;
    let insert;
    const delimiters = [[]];
    // <parameter text> contains no braces
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        // If the very last character of the <parameter text> is #, so that
        // this # is immediately followed by {, TeX will behave as if the {
        // had been inserted at the right end of both the parameter text
        // and the replacement text.
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters[numArgs].push("{");
          break;
        }

        // A parameter, the first appearance of # must be followed by 1,
        // the next by 2, and so on; up to nine #’s are allowed
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError(`Invalid argument number "${tok.text}"`);
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError(`Argument number "${tok.text}" out of order`);
        }
        numArgs++;
        delimiters.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters[numArgs].push(tok.text);
      }
    }
    // replacement text, enclosed in '{' and '}' and properly nested
    let { tokens } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }

    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      if (tokens.length > parser.gullet.settings.maxExpand) {
        throw new ParseError("Too many expansions in an " + funcName);
      }
      tokens.reverse(); // to fit in with stack order
    }
    // Final arg is the expansion of the macro
    parser.gullet.macros.set(
      name,
      { tokens, numArgs, delimiters },
      funcName === globalMap[funcName]
    );
    return { type: "internal", mode: parser.mode };
  }
});

// <simple assignment> -> <let assignment>
// <let assignment> -> \futurelet<control sequence><token><token>
//     | \let<control sequence><equals><one optional space><token>
// <equals> -> <optional spaces>|<optional spaces>=
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    const tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return { type: "internal", mode: parser.mode };
  }
});

// ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    const middle = parser.gullet.popToken();
    const tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return { type: "internal", mode: parser.mode };
  }
});

defineFunction({
  type: "internal",
  names: ["\\newcommand", "\\renewcommand", "\\providecommand"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let name = "";
    const tok = parser.gullet.popToken();
    if (tok.text === "{") {
      name = checkControlSequence(parser.gullet.popToken());
      parser.gullet.popToken();
    } else {
      name = checkControlSequence(tok);
    }

    const exists = parser.gullet.isDefined(name);
    if (exists && funcName === "\\newcommand") {
      throw new ParseError(
        `\\newcommand{${name}} attempting to redefine ${name}; use \\renewcommand`
      );
    }
    if (!exists && funcName === "\\renewcommand") {
      throw new ParseError(
        `\\renewcommand{${name}} when command ${name} does not yet exist; use \\newcommand`
      );
    }

    let numArgs = 0;
    if (parser.gullet.future().text === "[") {
      let tok = parser.gullet.popToken();
      tok = parser.gullet.popToken();
      if (!/^[0-9]$/.test(tok.text)) {
        throw new ParseError(`Invalid number of arguments: "${tok.text}"`);
      }
      numArgs = parseInt(tok.text);
      tok = parser.gullet.popToken();
      if (tok.text !== "]") {
        throw new ParseError(`Invalid argument "${tok.text}"`);
      }
    }

    // replacement text, enclosed in '{' and '}' and properly nested
    const { tokens } = parser.gullet.consumeArg();

    if (!(funcName === "\\providecommand" && parser.gullet.macros.has(name))) {
      // Ignore \providecommand
      parser.gullet.macros.set(
        name,
        { tokens, numArgs }
      );
    }

    return { type: "internal", mode: parser.mode };

  }
});

// Extra data needed for the delimiter handler down below
const delimiterSizes = {
  "\\bigl": { mclass: "mopen", size: 1 },
  "\\Bigl": { mclass: "mopen", size: 2 },
  "\\biggl": { mclass: "mopen", size: 3 },
  "\\Biggl": { mclass: "mopen", size: 4 },
  "\\bigr": { mclass: "mclose", size: 1 },
  "\\Bigr": { mclass: "mclose", size: 2 },
  "\\biggr": { mclass: "mclose", size: 3 },
  "\\Biggr": { mclass: "mclose", size: 4 },
  "\\bigm": { mclass: "mrel", size: 1 },
  "\\Bigm": { mclass: "mrel", size: 2 },
  "\\biggm": { mclass: "mrel", size: 3 },
  "\\Biggm": { mclass: "mrel", size: 4 },
  "\\big": { mclass: "mord", size: 1 },
  "\\Big": { mclass: "mord", size: 2 },
  "\\bigg": { mclass: "mord", size: 3 },
  "\\Bigg": { mclass: "mord", size: 4 }
};

const delimiters = [
  "(",
  "\\lparen",
  ")",
  "\\rparen",
  "[",
  "\\lbrack",
  "]",
  "\\rbrack",
  "\\{",
  "\\lbrace",
  "\\}",
  "\\rbrace",
  "⦇",
  "\\llparenthesis",
  "⦈",
  "\\rrparenthesis",
  "\\lfloor",
  "\\rfloor",
  "\u230a",
  "\u230b",
  "\\lceil",
  "\\rceil",
  "\u2308",
  "\u2309",
  "<",
  ">",
  "\\langle",
  "\u27e8",
  "\\rangle",
  "\u27e9",
  "\\lAngle",
  "\u27ea",
  "\\rAngle",
  "\u27eb",
  "\\llangle",
  "⦉",
  "\\rrangle",
  "⦊",
  "\\lt",
  "\\gt",
  "\\lvert",
  "\\rvert",
  "\\lVert",
  "\\rVert",
  "\\lgroup",
  "\\rgroup",
  "\u27ee",
  "\u27ef",
  "\\lmoustache",
  "\\rmoustache",
  "\u23b0",
  "\u23b1",
  "\\llbracket",
  "\\rrbracket",
  "\u27e6",
  "\u27e6",
  "\\lBrace",
  "\\rBrace",
  "\u2983",
  "\u2984",
  "/",
  "\\backslash",
  "|",
  "\\vert",
  "\\|",
  "\\Vert",
  "\u2016",
  "\\uparrow",
  "\\Uparrow",
  "\\downarrow",
  "\\Downarrow",
  "\\updownarrow",
  "\\Updownarrow",
  "."
];

// Export isDelimiter for benefit of parser.
const dels = ["}", "\\left", "\\middle", "\\right"];
const isDelimiter = str => str.length > 0 &&
  (delimiters.includes(str) || delimiterSizes[str] || dels.includes(str));

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

// Delimiter functions
function checkDelimiter(delim, context) {
  const symDelim = checkSymbolNodeType(delim);
  if (symDelim && delimiters.includes(symDelim.text)) {
    // If a character is not in the MathML operator dictionary, it will not stretch.
    // Replace such characters w/characters that will stretch.
    if (["<", "\\lt"].includes(symDelim.text)) { symDelim.text = "⟨"; }
    if ([">", "\\gt"].includes(symDelim.text)) { symDelim.text = "⟩"; }
    return symDelim;
  } else if (symDelim) {
    throw new ParseError(`Invalid delimiter '${symDelim.text}' after '${context.funcName}'`, delim);
  } else {
    throw new ParseError(`Invalid delimiter type '${delim.type}'`, delim);
  }
}

//                               /         \
const needExplicitStretch = ["\u002F", "\u005C", "\\backslash", "\\vert", "|"];

defineFunction({
  type: "delimsizing",
  names: [
    "\\bigl",
    "\\Bigl",
    "\\biggl",
    "\\Biggl",
    "\\bigr",
    "\\Bigr",
    "\\biggr",
    "\\Biggr",
    "\\bigm",
    "\\Bigm",
    "\\biggm",
    "\\Biggm",
    "\\big",
    "\\Big",
    "\\bigg",
    "\\Bigg"
  ],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  mathmlBuilder: (group) => {
    const children = [];

    if (group.delim === ".") { group.delim = ""; }
    children.push(makeText(group.delim, group.mode));

    const node = new mathMLTree.MathNode("mo", children);

    if (group.mclass === "mopen" || group.mclass === "mclose") {
      // Only some of the delimsizing functions act as fences, and they
      // return "mopen" or "mclose" mclass.
      node.setAttribute("fence", "true");
    } else {
      // Explicitly disable fencing if it's not a fence, to override the
      // defaults.
      node.setAttribute("fence", "false");
    }
    if (needExplicitStretch.includes(group.delim) || group.delim.indexOf("arrow") > -1) {
      // We have to explicitly set stretchy to true.
      node.setAttribute("stretchy", "true");
    }
    node.setAttribute("symmetric", "true"); // Needed for tall arrows in Firefox.
    node.setAttribute("minsize", sizeToMaxHeight[group.size] + "em");
    node.setAttribute("maxsize", sizeToMaxHeight[group.size] + "em");
    return node;
  }
});

function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}

defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text
    };
  }
});

defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    const parser = context.parser;
    // Parse out the implicit body
    ++parser.leftrightDepth;
    // parseExpression stops before '\\right' or `\\middle`
    let body = parser.parseExpression(false, null, true);
    let nextToken = parser.fetch();
    while (nextToken.text === "\\middle") {
      // `\middle`, from the ε-TeX package, ends one group and starts another group.
      // We had to parse this expression with `breakOnMiddle` enabled in order
      // to get TeX-compliant parsing of \over.
      // But we do not want, at this point, to end on \middle, so continue
      // to parse until we fetch a `\right`.
      parser.consume();
      const middle = parser.fetch().text;
      if (!symbols.math[middle]) {
        throw new ParseError(`Invalid delimiter '${middle}' after '\\middle'`);
      }
      checkDelimiter({ type: "atom", mode: "math", text: middle }, { funcName: "\\middle" });
      body.push({ type: "middle", mode: "math", delim: middle });
      parser.consume();
      body = body.concat(parser.parseExpression(false, null, true));
      nextToken = parser.fetch();
    }
    --parser.leftrightDepth;
    // Check the next token
    parser.expect("\\right", false);
    const right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim
    };
  },
  mathmlBuilder: (group, style) => {
    assertParsed(group);
    const inner = buildExpression(group.body, style);

    if (group.left === ".") { group.left = ""; }
    const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
    leftNode.setAttribute("fence", "true");
    leftNode.setAttribute("form", "prefix");
    if (group.left === "/" || group.left === "\u005C" || group.left.indexOf("arrow") > -1) {
      leftNode.setAttribute("stretchy", "true");
    }
    inner.unshift(leftNode);

    if (group.right === ".") { group.right = ""; }
    const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
    rightNode.setAttribute("fence", "true");
    rightNode.setAttribute("form", "postfix");
    if (group.right === "\u2216" || group.right.indexOf("arrow") > -1) {
      rightNode.setAttribute("stretchy", "true");
    }
    if (group.body.length > 0) {
      const lastElement = group.body[group.body.length - 1];
      if (lastElement.type === "color" && !lastElement.isTextColor) {
        // \color is a switch. If the last element is of type "color" then
        // the user set the \color switch and left it on.
        // A \right delimiter turns the switch off, but the delimiter itself gets the color.
        rightNode.setAttribute("mathcolor", lastElement.color);
      }
    }
    inner.push(rightNode);

    return makeRow(inner);
  }
});

defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  mathmlBuilder: (group, style) => {
    const textNode = makeText(group.delim, group.mode);
    const middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    if (group.delim.indexOf("arrow") > -1) {
      middleNode.setAttribute("stretchy", "true");
    }
    // The next line is not semantically correct, but
    // Chromium fails to stretch if it is not there.
    middleNode.setAttribute("form", "prefix");
    // MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});

const padding = _ => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", "3pt");
  return node
};

const mathmlBuilder$7 = (group, style) => {
  let node;
  if (group.label.indexOf("colorbox") > -1 || group.label === "\\boxed") {
    // MathML core does not support +width attribute in <mpadded>.
    // Firefox does not reliably add side padding.
    // Insert <mspace>
    node = new mathMLTree.MathNode("mrow", [
      padding(),
      buildGroup$1(group.body, style),
      padding()
    ]);
  } else {
    node = new mathMLTree.MathNode("menclose", [buildGroup$1(group.body, style)]);
  }
  switch (group.label) {
    case "\\overline":
      node.setAttribute("notation", "top"); // for Firefox & WebKit
      node.classes.push("tml-overline");    // for Chromium
      break
    case "\\underline":
      node.setAttribute("notation", "bottom");
      node.classes.push("tml-underline");
      break
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "upstrike"]));
      break
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "downstrike"]));
      break
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "sout"]));
      break
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      node.classes.push("tml-xcancel");
      break
    case "\\longdiv":
      node.setAttribute("notation", "longdiv");
      node.classes.push("longdiv-top");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["longdiv-arc"]));
      break
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      node.classes.push("phasor-bottom");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["phasor-angle"]));
      break
    case "\\textcircled":
      node.setAttribute("notation", "circle");
      node.classes.push("circle-pad");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["textcircle"]));
      break
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      node.classes.push("actuarial");
      break
    case "\\boxed":
      // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}} from amsmath.sty
      node.setAttribute("notation", "box");
      node.classes.push("tml-box");
      node.setAttribute("scriptlevel", "0");
      node.setAttribute("displaystyle", "true");
      break
    case "\\fbox":
      node.setAttribute("notation", "box");
      node.classes.push("tml-fbox");
      break
    case "\\fcolorbox":
    case "\\colorbox": {
      // <menclose> doesn't have a good notation option for \colorbox.
      // So use <mpadded> instead. Set some attributes that come
      // included with <menclose>.
      //const fboxsep = 3; // 3 pt from LaTeX source2e
      //node.setAttribute("height", `+${2 * fboxsep}pt`)
      //node.setAttribute("voffset", `${fboxsep}pt`)
      const style = { padding: "3pt 0 3pt 0" };

      if (group.label === "\\fcolorbox") {
        style.border = "0.0667em solid " + String(group.borderColor);
      }
      node.style = style;
      break
    }
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};

defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
    }
    const body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let borderColor = "";
    let backgroundColor;
    if (model) {
      const borderSpec = assertNodeType(args[0], "raw").string;
      const backgroundSpec = assertNodeType(args[0], "raw").string;
      borderColor = colorFromSpec(model, borderSpec);
      backgroundColor = colorFromSpec(model, backgroundSpec);
    } else {
      borderColor = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
      backgroundColor = validateColor(assertNodeType(args[1], "raw").string, parser.gullet.macros);
    }
    const body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});

defineFunction({
  type: "enclose",
  names: ["\\angl", "\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\overline",
    "\\boxed", "\\longdiv", "\\phase"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});


defineFunction({
  type: "enclose",
  names: ["\\textcircled"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

// Environment delimiters. HTML/MathML rendering is defined in the corresponding
// defineEnvironment definitions.
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler({ parser, funcName }, args) {
    const nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    let envName = "";
    for (let i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }

    if (funcName === "\\begin") {
      // begin...end is similar to left...right
      if (!Object.prototype.hasOwnProperty.call(environments, envName )) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      // Build the environment object. Arguments and other information will
      // be made available to the begin and end methods using properties.
      const env = environments[envName];
      const { args, optArgs } = parser.parseArguments("\\begin{" + envName + "}", env);
      const context = {
        mode: parser.mode,
        envName,
        parser
      };
      const result = env.handler(context, args, optArgs);
      parser.expect("\\end", false);
      const endNameToken = parser.nextToken;
      const end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError(
          `Mismatch: \\begin{${envName}} matched by \\end{${end.name}}`,
          endNameToken
        );
      }
      return result;
    }

    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});

defineFunction({
  type: "envTag",
  names: ["\\env@tag"],
  props: {
    numArgs: 1,
    argTypes: ["math"]
  },
  handler({ parser }, args) {
    return {
      type: "envTag",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

defineFunction({
  type: "noTag",
  names: ["\\env@notag"],
  props: {
    numArgs: 0
  },
  handler({ parser }) {
    return {
      type: "noTag",
      mode: parser.mode
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

const isLongVariableName = (group, font) => {
  if (font !== "mathrm" || group.body.type !== "ordgroup" || group.body.body.length === 1) {
    return false
  }
  if (group.body.body[0].type !== "mathord") { return false }
  for (let i = 1; i < group.body.body.length; i++) {
    const parseNodeType = group.body.body[i].type;
    if (!(parseNodeType ===  "mathord" ||
    (parseNodeType ===  "textord" && !isNaN(group.body.body[i].text)))) {
      return false
    }
  }
  return true
};

const mathmlBuilder$6 = (group, style) => {
  const font = group.font;
  const newStyle = style.withFont(font);
  const mathGroup = buildGroup$1(group.body, newStyle);

  if (mathGroup.children.length === 0) { return mathGroup } // empty group, e.g., \mathrm{}
  if (font === "boldsymbol" && ["mo", "mpadded", "mrow"].includes(mathGroup.type)) {
    mathGroup.style.fontWeight = "bold";
    return mathGroup
  }
  // Check if it is possible to consolidate elements into a single <mi> element.
  if (isLongVariableName(group, font)) {
    // This is a \mathrm{…} group. It gets special treatment because symbolsOrd.js
    // wraps <mi> elements with <mrow>s to work around a Firefox bug.
    const mi = mathGroup.children[0].children[0];
    delete mi.attributes.mathvariant;
    for (let i = 1; i < mathGroup.children.length; i++) {
      mi.children[0].text += mathGroup.children[i].type === "mn"
        ? mathGroup.children[i].children[0].text
        : mathGroup.children[i].children[0].children[0].text;
    }
    // Wrap in a <mrow> to prevent the same Firefox bug.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  let canConsolidate = mathGroup.children[0].type === "mo";
  for (let i = 1; i < mathGroup.children.length; i++) {
    if (mathGroup.children[i].type === "mo" && font === "boldsymbol") {
      mathGroup.children[i].style.fontWeight = "bold";
    }
    if (mathGroup.children[i].type !== "mi") { canConsolidate = false; }
    const localVariant = mathGroup.children[i].attributes &&
      mathGroup.children[i].attributes.mathvariant || "";
    if (localVariant !== "normal") { canConsolidate = false; }
  }
  if (!canConsolidate) { return mathGroup }
  // Consolidate the <mi> elements.
  const mi = mathGroup.children[0];
  for (let i = 1; i < mathGroup.children.length; i++) {
    mi.children.push(mathGroup.children[i].children[0]);
  }
  if (mi.attributes.mathvariant && mi.attributes.mathvariant === "normal") {
    // Workaround for a Firefox bug that renders spurious space around
    // a <mi mathvariant="normal">
    // Ref: https://bugs.webkit.org/show_bug.cgi?id=129097
    // We insert a text node that contains a zero-width space and wrap in an mrow.
    // TODO: Get rid of this <mi> workaround when the Firefox bug is fixed.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  return mi
};

const fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};

defineFunction({
  type: "font",
  names: [
    // styles
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\up@greek",
    "\\boldsymbol",

    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathsfit",
    "\\mathtt",

    // aliases
    "\\Bbb",
    "\\bm",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = normalizeArgument(args[0]);
    let func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

// Old font changing functions
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ parser, funcName, breakOnTokenText }, args) => {
    const { mode } = parser;
    const body = parser.parseExpression(true, breakOnTokenText, true);
    const fontStyle = `math${funcName.slice(1)}`;

    return {
      type: "font",
      mode: mode,
      font: fontStyle,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

const stylArray = ["display", "text", "script", "scriptscript"];
const scriptLevel = { auto: -1, display: 0, text: 0, script: 1, scriptscript: 2 };

const mathmlBuilder$5 = (group, style) => {
  // Track the scriptLevel of the numerator and denominator.
  // We may need that info for \mathchoice or for adjusting em dimensions.
  const childOptions = group.scriptLevel === "auto"
    ? style.incrementLevel()
    : group.scriptLevel === "display"
    ? style.withLevel(StyleLevel.TEXT)
    : group.scriptLevel === "text"
    ? style.withLevel(StyleLevel.SCRIPT)
    : style.withLevel(StyleLevel.SCRIPTSCRIPT);

  // Chromium (wrongly) continues to shrink fractions beyond scriptscriptlevel.
  // So we check for levels that Chromium shrinks too small.
  // If necessary, set an explicit fraction depth.
  const numer = buildGroup$1(group.numer, childOptions);
  const denom = buildGroup$1(group.denom, childOptions);
  if (style.level === 3) {
    numer.style.mathDepth = "2";
    numer.setAttribute("scriptlevel", "2");
    denom.style.mathDepth = "2";
    denom.setAttribute("scriptlevel", "2");
  }

  let node = new mathMLTree.MathNode("mfrac", [numer, denom]);

  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    const ruleWidth = calculateSize(group.barSize, style);
    node.setAttribute("linethickness", ruleWidth.number + ruleWidth.unit);
  }

  if (group.leftDelim != null || group.rightDelim != null) {
    const withDelims = [];

    if (group.leftDelim != null) {
      const leftOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))
      ]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }

    withDelims.push(node);

    if (group.rightDelim != null) {
      const rightOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))
      ]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }

    node = makeRow(withDelims);
  }

  if (group.scriptLevel !== "auto") {
    node = new mathMLTree.MathNode("mstyle", [node]);
    node.setAttribute("displaystyle", String(group.scriptLevel === "display"));
    node.setAttribute("scriptlevel", scriptLevel[group.scriptLevel]);
  }

  return node;
};

defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac", // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac" // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];
    let hasBarLine = false;
    let leftDelim = null;
    let rightDelim = null;
    let scriptLevel = "auto";

    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }

    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        scriptLevel = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        scriptLevel = "text";
        break;
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      scriptLevel,
      barSize: null
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "display",
      barSize: null
    };
  }
});

// Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler({ parser, funcName, token }) {
    let replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});

const delimFromValue = function(delimString) {
  let delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};

defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler({ parser }, args) {
    const numer = args[4];
    const denom = args[5];

    // Look into the parse nodes to get the desired delimiters.
    const leftNode = normalizeArgument(args[0]);
    const leftDelim = leftNode.type === "atom" && leftNode.family === "open"
      ? delimFromValue(leftNode.text)
      : null;
    const rightNode = normalizeArgument(args[1]);
    const rightDelim =
      rightNode.type === "atom" && rightNode.family === "close"
        ? delimFromValue(rightNode.text)
        : null;

    const barNode = assertNodeType(args[2], "size");
    let hasBarLine;
    let barSize = null;
    if (barNode.isBlank) {
      // \genfrac acts differently than \above.
      // \genfrac treats an empty size group as a signal to use a
      // standard bar size. \above would see size = 0 and omit the bar.
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }

    // Find out if we want displaystyle, textstyle, etc.
    let scriptLevel = "auto";
    let styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        const textOrd = assertNodeType(styl.body[0], "textord");
        scriptLevel = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      scriptLevel = stylArray[Number(styl.text)];
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      scriptLevel
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

// \above is an infix fraction that also defines a fraction bar size.
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler({ parser, funcName, token }, args) {
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      barSize: assertNodeType(args[0], "size").value,
      token
    };
  }
});

defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const barSize = assert(assertNodeType(args[1], "infix").barSize);
    const denom = args[2];

    const hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "auto"
    };
  },

  mathmlBuilder: mathmlBuilder$5
});

// \hbox is provided for compatibility with LaTeX functions that act on a box.
// This function by itself doesn't do anything but set scriptlevel to \textstyle
// and prevent a soft line break.

defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInArgument: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = style.withLevel(StyleLevel.TEXT);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

const mathmlBuilder$4 = (group, style) => {
  const accentNode = stretchy.mathMLnode(group.label);
  accentNode.style["math-depth"] = 0;
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [
    buildGroup$1(group.base, style),
    accentNode
  ]);
};

// Horizontal stretchy braces
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  mathmlBuilder: mathmlBuilder$4
});

defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const body = args[1];
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\href",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\href" is not trusted`, token)
    }

    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const math = new MathNode("math", [buildExpressionRow(group.body, style)]);
    const anchorNode = new AnchorNode(group.href, [], [math]);
    return anchorNode
  }
});

defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\url",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\url" is not trusted`, token)
    }

    const chars = [];
    for (let i = 0; i < href.length; i++) {
      let c = href[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    const body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});

defineFunction({
  type: "html",
  names: ["\\class", "\\id", "\\style", "\\data"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    const value = assertNodeType(args[0], "raw").string;
    const body = args[1];

    if (parser.settings.strict) {
      throw new ParseError(`Function "${funcName}" is disabled in strict mode`, token)
    }

    let trustContext;
    const attributes = {};

    switch (funcName) {
      case "\\class":
        attributes.class = value;
        trustContext = {
          command: "\\class",
          class: value
        };
        break;
      case "\\id":
        attributes.id = value;
        trustContext = {
          command: "\\id",
          id: value
        };
        break;
      case "\\style":
        attributes.style = value;
        trustContext = {
          command: "\\style",
          style: value
        };
        break;
      case "\\data": {
        const data = value.split(",");
        for (let i = 0; i < data.length; i++) {
          const keyVal = data[i].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\data");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }

        trustContext = {
          command: "\\data",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }

    if (!parser.settings.isTrusted(trustContext)) {
      throw new ParseError(`Function "${funcName}" is not trusted`, token)
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const element =  buildExpressionRow(group.body, style);

    const classes = [];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    element.classes = classes;

    for (const attr in group.attributes) {
      if (attr !== "class" && Object.prototype.hasOwnProperty.call(group.attributes, attr)) {
        element.setAttribute(attr, group.attributes[attr]);
      }
    }

    return element;
  }
});

const sizeData = function(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    // str is a number with no unit specified.
    // default unit is bp, per graphix package.
    return { number: +str, unit: "bp" }
  } else {
    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data
  }
};

defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: ({ parser, token }, args, optArgs) => {
    let width = { number: 0, unit: "em" };
    let height = { number: 0.9, unit: "em" };  // sorta character sized.
    let totalheight = { number: 0, unit: "em" };
    let alt = "";

    if (optArgs[0]) {
      const attributeStr = assertNodeType(optArgs[0], "raw").string;

      // Parser.js does not parse key/value pairs. We get a string.
      const attributes = attributeStr.split(",");
      for (let i = 0; i < attributes.length; i++) {
        const keyVal = attributes[i].split("=");
        if (keyVal.length === 2) {
          const str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break
            case "width":
              width = sizeData(str);
              break
            case "height":
              height = sizeData(str);
              break
            case "totalheight":
              totalheight = sizeData(str);
              break
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.")
          }
        }
      }
    }

    const src = assertNodeType(args[0], "url").url;

    if (alt === "") {
      // No alt given. Use the file name. Strip away the path.
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }

    if (
      !parser.settings.isTrusted({
        command: "\\includegraphics",
        url: src
      })
    ) {
      throw new ParseError(`Function "\\includegraphics" is not trusted`, token)
    }

    return {
      type: "includegraphics",
      mode: parser.mode,
      alt: alt,
      width: width,
      height: height,
      totalheight: totalheight,
      src: src
    }
  },
  mathmlBuilder: (group, style) => {
    const height = calculateSize(group.height, style);
    const depth = { number: 0, unit: "em" };

    if (group.totalheight.number > 0) {
      if (group.totalheight.unit === height.unit &&
        group.totalheight.number > height.number) {
        depth.number = group.totalheight.number - height.number;
        depth.unit = height.unit;
      }
    }

    let width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, style);
    }

    const graphicStyle = { height: height.number + depth.number + "em" };
    if (width.number > 0) {
      graphicStyle.width = width.number + width.unit;
    }
    if (depth.number > 0) {
      graphicStyle.verticalAlign = -depth.number + depth.unit;
    }

    const node = new Img(group.src, group.alt, graphicStyle);
    node.height = height;
    node.depth = depth;
    return new mathMLTree.MathNode("mtext", [node])
  }
});

// Horizontal spacing commands


// TODO: \hskip and \mskip should support plus and minus in lengths

defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler({ parser, funcName, token }, args) {
    const size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      const mathFunction = funcName[1] === "m"; // \mkern, \mskip
      const muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          throw new ParseError(`LaTeX's ${funcName} supports only mu units, ` +
            `not ${size.value.unit} units`, token)
        }
        if (parser.mode !== "math") {
          throw new ParseError(`LaTeX's ${funcName} works only in math mode`, token)
        }
      } else {
        // !mathFunction
        if (muUnit) {
          throw new ParseError(`LaTeX's ${funcName} doesn't support mu units`, token)
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  mathmlBuilder(group, style) {
    const dimension = calculateSize(group.dimension, style);
    const ch = dimension.unit === "em" ? spaceCharacter(dimension.number) : "";
    if (group.mode === "text" && ch.length > 0) {
      const character = new mathMLTree.TextNode(ch);
      return new mathMLTree.MathNode("mtext", [character]);
    } else {
      const node = new mathMLTree.MathNode("mspace");
      node.setAttribute("width", dimension.number + dimension.unit);
      if (dimension.number < 0) {
        node.style.marginLeft = dimension.number + dimension.unit;
      }
      return node;
    }
  }
});

const spaceCharacter = function(width) {
  if (width >= 0.05555 && width <= 0.05556) {
    return "\u200a"; // &VeryThinSpace;
  } else if (width >= 0.1666 && width <= 0.1667) {
    return "\u2009"; // &ThinSpace;
  } else if (width >= 0.2222 && width <= 0.2223) {
    return "\u2005"; // &MediumSpace;
  } else if (width >= 0.2777 && width <= 0.2778) {
    return "\u2005\u200a"; // &ThickSpace;
  } else {
    return "";
  }
};

// Limit valid characters to a small set, for safety.
const invalidIdRegEx = /[^A-Za-z_0-9-]/g;

defineFunction({
  type: "label",
  names: ["\\label"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser }, args) {
    return {
      type: "label",
      mode: parser.mode,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Return a no-width, no-ink element with an HTML id.
    const node = new mathMLTree.MathNode("mrow", [], ["tml-label"]);
    if (group.string.length > 0) {
      node.setLabel(group.string);
    }
    return node
  }
});

// Horizontal overlap functions

const textModeLap = ["\\clap", "\\llap", "\\rlap"];

defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap", "\\clap", "\\llap", "\\rlap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    if (textModeLap.includes(funcName)) {
      if (parser.settings.strict && parser.mode !== "text") {
        throw new ParseError(`{${funcName}} can be used only in text mode.
 Try \\math${funcName.slice(1)}`, token)
      }
      funcName = funcName.slice(1);
    } else {
      funcName = funcName.slice(5);
    }
    const body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName,
      body
    }
  },
  mathmlBuilder: (group, style) => {
    // mathllap, mathrlap, mathclap
    let strut;
    if (group.alignment === "llap") {
      // We need an invisible strut with the same depth as the group.
      // We can't just read the depth, so we use \vphantom methods.
      const phantomInner = buildExpression(ordargument(group.body), style);
      const phantom = new mathMLTree.MathNode("mphantom", phantomInner);
      strut = new mathMLTree.MathNode("mpadded", [phantom]);
      strut.setAttribute("width", "0px");
    }

    const inner = buildGroup$1(group.body, style);
    let node;
    if (group.alignment === "llap") {
      inner.style.position = "absolute";
      inner.style.right = "0";
      inner.style.bottom = `0`; // If we could have read the ink depth, it would go here.
      node = new mathMLTree.MathNode("mpadded", [strut, inner]);
    } else {
      node = new mathMLTree.MathNode("mpadded", [inner]);
    }

    if (group.alignment === "rlap") {
      if (group.body.body.length > 0 && group.body.body[0].type === "genfrac") {
        // In Firefox, a <mpadded> squashes the 3/18em padding of a child \frac. Put it back.
        node.setAttribute("lspace", "0.16667em");
      }
    } else {
      const offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
      if (group.alignment === "llap") {
        node.style.position = "relative";
      } else {
        node.style.display = "flex";
        node.style.justifyContent = "center";
      }
    }
    node.setAttribute("width", "0px");
    return node
  }
});

// Switching from text mode back to math mode
defineFunction({
  type: "ordgroup",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler({ funcName, parser }, args) {
    const outerMode = parser.mode;
    parser.switchMode("math");
    const close = funcName === "\\(" ? "\\)" : "$";
    const body = parser.parseExpression(false, close);
    parser.expect(close);
    parser.switchMode(outerMode);
    return {
      type: "ordgroup",
      mode: parser.mode,
      body
    };
  }
});

// Check for extra closing math delimiters
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, token) {
    throw new ParseError(`Mismatched ${context.funcName}`, token);
  }
});

const chooseStyle = (group, style) => {
  switch (style.level) {
    case StyleLevel.DISPLAY:       // 0
      return group.display;
    case StyleLevel.TEXT:          // 1
      return group.text;
    case StyleLevel.SCRIPT:        // 2
      return group.script;
    case StyleLevel.SCRIPTSCRIPT:  // 3
      return group.scriptscript;
    default:
      return group.text;
  }
};

defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: ({ parser }, args) => {
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  mathmlBuilder: (group, style) => {
    const body = chooseStyle(group, style);
    return buildExpressionRow(body, style);
  }
});

const textAtomTypes = ["text", "textord", "mathord", "atom"];

function mathmlBuilder$3(group, style) {
  let node;
  const inner = buildExpression(group.body, style);

  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox || inner[0].type === "mathord") {
      node = inner[0];
      node.type = "mi";
      if (node.children.length === 1 && node.children[0].text && node.children[0].text === "∇") {
        node.setAttribute("mathvariant", "normal");
      }
    } else {
      node = new mathMLTree.MathNode("mi", inner);
    }
  } else {
    node = new mathMLTree.MathNode("mrow", inner);
    if (group.mustPromote) {
      node = inner[0];
      node.type = "mo";
      if (group.isCharacterBox && group.body[0].text && /[A-Za-z]/.test(group.body[0].text)) {
        node.setAttribute("mathvariant", "italic");
      }
    } else {
      node = new mathMLTree.MathNode("mrow", inner);
    }

    // Set spacing based on what is the most likely adjacent atom type.
    // See TeXbook p170.
    const doSpacing = style.level < 2; // Operator spacing is zero inside a (sub|super)script.
    if (node.type === "mrow") {
      if (doSpacing ) {
        if (group.mclass === "mbin") {
          // medium space
          node.children.unshift(padding$1(0.2222));
          node.children.push(padding$1(0.2222));
        } else if (group.mclass === "mrel") {
          // thickspace
          node.children.unshift(padding$1(0.2778));
          node.children.push(padding$1(0.2778));
        } else if (group.mclass === "mpunct") {
          node.children.push(padding$1(0.1667));
        } else if (group.mclass === "minner") {
          node.children.unshift(padding$1(0.0556));  // 1 mu is the most likely option
          node.children.push(padding$1(0.0556));
        }
      }
    } else {
      if (group.mclass === "mbin") {
        // medium space
        node.attributes.lspace = (doSpacing ? "0.2222em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2222em" : "0");
      } else if (group.mclass === "mrel") {
        // thickspace
        node.attributes.lspace = (doSpacing ? "0.2778em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2778em" : "0");
      } else if (group.mclass === "mpunct") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = (doSpacing ? "0.1667em" : "0");
      } else if (group.mclass === "mopen" || group.mclass === "mclose") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0em";
      } else if (group.mclass === "minner" && doSpacing) {
        node.attributes.lspace = "0.0556em"; // 1 mu is the most likely option
        node.attributes.width = "+0.1111em";
      }
    }

    if (!(group.mclass === "mopen" || group.mclass === "mclose")) {
      delete node.attributes.stretchy;
      delete node.attributes.form;
    }
  }
  return node;
}

// Math class commands except \mathop
defineFunction({
  type: "mclass",
  names: [
    "\\mathord",
    "\\mathbin",
    "\\mathrel",
    "\\mathopen",
    "\\mathclose",
    "\\mathpunct",
    "\\mathinner"
  ],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    const isCharacterBox = utils.isCharacterBox(body);
    // We should not wrap a <mo> around a <mi> or <mord>. That would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    let mustPromote = true;
    const mord = { type: "mathord", text: "", mode: parser.mode };
    const arr = (body.body) ? body.body : [body];
    for (const arg of arr) {
      if (textAtomTypes.includes(arg.type)) {
        if (symbols[parser.mode][arg.text]) {
          mord.text += symbols[parser.mode][arg.text].replace;
        } else if (arg.text) {
          mord.text += arg.text;
        } else if (arg.body) {
          arg.body.map(e => { mord.text += e.text; });
        }
      } else {
        mustPromote = false;
        break
      }
    }
    if (mustPromote && funcName === "\\mathord" && mord.type === "mathord"
                    && mord.text.length > 1) {
      return mord
    } else {
      return {
        type: "mclass",
        mode: parser.mode,
        mclass: "m" + funcName.slice(5),
        body: ordargument(mustPromote ? mord : body),
        isCharacterBox,
        mustPromote
      };
    }
  },
  mathmlBuilder: mathmlBuilder$3
});

const binrelClass = (arg) => {
  // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
  // (by rendering separately and with {}s before and after, and measuring
  // the change in spacing).  We'll do roughly the same by detecting the
  // atom type directly.
  const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};

// \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler({ parser }, args) {
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});

// Build a relation or stacked op by placing one symbol on top of another
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler({ parser, funcName }, args) {
    const baseArg = args[1];
    const shiftedArg = args[0];

    const baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      stack: true,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };

    return {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
  },
  mathmlBuilder: mathmlBuilder$3
});

// Helper function
const buildGroup = (el, style, noneNode) => {
  if (!el) { return noneNode }
  const node = buildGroup$1(el, style);
  if (node.type === "mrow" && node.children.length === 0) { return noneNode }
  return node
};

defineFunction({
  type: "multiscript",
  names: ["\\sideset", "\\pres@cript"], // See macros.js for \prescript
  props: {
    numArgs: 3
  },
  handler({ parser, funcName, token }, args) {
    if (args[2].body.length === 0) {
      throw new ParseError(funcName + `cannot parse an empty base.`)
    }
    const base = args[2].body[0];
    if (parser.settings.strict && funcName === "\\sideset" && !base.symbol) {
      throw new ParseError(`The base of \\sideset must be a big operator. Try \\prescript.`)
    }

    if ((args[0].body.length > 0 && args[0].body[0].type !== "supsub") ||
        (args[1].body.length > 0 && args[1].body[0].type !== "supsub")) {
      throw new ParseError("\\sideset can parse only subscripts and " +
                            "superscripts in its first two arguments", token)
    }

    // The prescripts and postscripts come wrapped in a supsub.
    const prescripts = args[0].body.length > 0 ? args[0].body[0] : null;
    const postscripts = args[1].body.length > 0 ? args[1].body[0] : null;

    if (!prescripts && !postscripts) {
      return base
    } else if (!prescripts) {
      // It's not a multi-script. Get a \textstyle supsub.
      return {
        type: "styling",
        mode: parser.mode,
        scriptLevel: "text",
        body: [{
          type: "supsub",
          mode: parser.mode,
          base,
          sup: postscripts.sup,
          sub: postscripts.sub
        }]
      }
    } else {
      return {
        type: "multiscript",
        mode: parser.mode,
        isSideset: funcName === "\\sideset",
        prescripts,
        postscripts,
        base
      }
    }
  },
  mathmlBuilder(group, style) {
    const base =  buildGroup$1(group.base, style);

    const prescriptsNode = new mathMLTree.MathNode("mprescripts");
    const noneNode = new mathMLTree.MathNode("none");
    let children = [];

    const preSub = buildGroup(group.prescripts.sub, style, noneNode);
    const preSup = buildGroup(group.prescripts.sup, style, noneNode);
    if (group.isSideset) {
      // This seems silly, but LaTeX does this. Firefox ignores it, which does not make me sad.
      preSub.setAttribute("style", "text-align: left;");
      preSup.setAttribute("style", "text-align: left;");
    }

    if (group.postscripts) {
      const postSub = buildGroup(group.postscripts.sub, style, noneNode);
      const postSup = buildGroup(group.postscripts.sup, style, noneNode);
      children = [base, postSub, postSup, prescriptsNode, preSub, preSup];
    } else {
      children = [base, prescriptsNode, preSub, preSup];
    }

    return new mathMLTree.MathNode("mmultiscripts", children);
  }
});

defineFunction({
  type: "not",
  names: ["\\not"],
  props: {
    numArgs: 1,
    primitive: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    const isCharacterBox = utils.isCharacterBox(args[0]);
    let body;
    if (isCharacterBox) {
      body = ordargument(args[0]);
      if (body[0].text.charAt(0) === "\\") {
        body[0].text = symbols.math[body[0].text].replace;
      }
      // \u0338 is the Unicode Combining Long Solidus Overlay
      body[0].text = body[0].text.slice(0, 1) + "\u0338" + body[0].text.slice(1);
    } else {
      // When the argument is not a character box, TeX does an awkward, poorly placed overlay.
      // We'll do the same.
      const notNode = { type: "textord", mode: "math", text: "\u0338" };
      const kernNode = { type: "kern", mode: "math", dimension: { number: -0.6, unit: "em" } };
      body = [notNode, kernNode, args[0]];
    }
    return {
      type: "not",
      mode: parser.mode,
      body,
      isCharacterBox
    };
  },
  mathmlBuilder(group, style) {
    if (group.isCharacterBox) {
      const inner = buildExpression(group.body, style, true);
      return inner[0]
    } else {
      return buildExpressionRow(group.body, style)
    }
  }
});

// Limits, symbols

// Some helpers

const ordAtomTypes = ["textord", "mathord", "atom"];

// Most operators have a large successor symbol, but these don't.
const noSuccessor = ["\\smallint"];

// Math operators (e.g. \sin) need a space between these types and themselves:
const ordTypes = ["textord", "mathord", "ordgroup", "close", "leftright", "font"];

// NOTE: Unlike most `builders`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.

const setSpacing = node => {
  // The user wrote a \mathop{…} function. Change spacing from default to OP spacing.
  // The most likely spacing for an OP is a thin space per TeXbook p170.
  node.attributes.lspace = "0.1667em";
  node.attributes.rspace = "0.1667em";
};

const mathmlBuilder$2 = (group, style) => {
  let node;

  if (group.symbol) {
    // This is a symbol. Just add the symbol.
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (noSuccessor.includes(group.name)) {
      node.setAttribute("largeop", "false");
    } else {
      node.setAttribute("movablelimits", "false");
    }
    if (group.fromMathOp) { setSpacing(node); }
  } else if (group.body) {
    // This is an operator with children. Add them.
    node = new MathNode("mo", buildExpression(group.body, style));
    if (group.fromMathOp) { setSpacing(node); }
  } else {
    // This is a text operator. Add all of the characters from the operator's name.
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);

    if (!group.parentIsSupSub) {
      // Append an invisible <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new MathNode("mo", [makeText("\u2061", "text")]);
      const row = [node, operator];
      // Set spacing
      if (group.needsLeadingSpace) {
        const lead = new MathNode("mspace");
        lead.setAttribute("width", "0.1667em"); // thin space.
        row.unshift(lead);
      }
      if (!group.isFollowedByDelimiter) {
        const trail = new MathNode("mspace");
        trail.setAttribute("width", "0.1667em"); // thin space.
        row.push(trail);
      }
      node = new MathNode("mrow", row);
    }
  }

  return node;
};

const singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22c0": "\\bigwedge",
  "\u22c1": "\\bigvee",
  "\u22c2": "\\bigcap",
  "\u22c3": "\\bigcup",
  "\u2a00": "\\bigodot",
  "\u2a01": "\\bigoplus",
  "\u2a02": "\\bigotimes",
  "\u2a04": "\\biguplus",
  "\u2a05": "\\bigsqcap",
  "\u2a06": "\\bigsqcup",
  "\u2a03": "\\bigcupdot",
  "\u2a07": "\\bigdoublevee",
  "\u2a08": "\\bigdoublewedge",
  "\u2a09": "\\bigtimes"
};

defineFunction({
  type: "op",
  names: [
    "\\coprod",
    "\\bigvee",
    "\\bigwedge",
    "\\biguplus",
    "\\bigcupplus",
    "\\bigcupdot",
    "\\bigcap",
    "\\bigcup",
    "\\bigdoublevee",
    "\\bigdoublewedge",
    "\\intop",
    "\\prod",
    "\\sum",
    "\\bigotimes",
    "\\bigoplus",
    "\\bigodot",
    "\\bigsqcap",
    "\\bigsqcup",
    "\\bigtimes",
    "\\smallint",
    "\u220F",
    "\u2210",
    "\u2211",
    "\u22c0",
    "\u22c1",
    "\u22c2",
    "\u22c3",
    "\u2a00",
    "\u2a01",
    "\u2a02",
    "\u2a04",
    "\u2a06"
  ],
  props: {
    numArgs: 0
  },
  handler: ({ parser, funcName }, args) => {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      stack: false, // This is true for \stackrel{}, not here.
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Note: calling defineFunction with a type that's already been defined only
// works because the same mathmlBuilder is being used.
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    // It would be convienient to just wrap a <mo> around the argument.
    // But if the argument is a <mi> or <mord>, that would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    const arr = (body.body) ? body.body : [body];
    const isSymbol = arr.length === 1 && ordAtomTypes.includes(arr[0].type);
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: isSymbol,
      fromMathOp: true,
      stack: false,
      name: isSymbol ? arr[0].text : null,
      body: isSymbol ? null : ordargument(body)
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

const singleCharIntegrals = {
  "\u222b": "\\int",
  "\u222c": "\\iint",
  "\u222d": "\\iiint",
  "\u222e": "\\oint",
  "\u222f": "\\oiint",
  "\u2230": "\\oiiint",
  "\u2231": "\\intclockwise",
  "\u2232": "\\varointclockwise",
  "\u2a0c": "\\iiiint",
  "\u2a0d": "\\intbar",
  "\u2a0e": "\\intBar",
  "\u2a0f": "\\fint",
  "\u2a12": "\\rppolint",
  "\u2a13": "\\scpolint",
  "\u2a15": "\\pointint",
  "\u2a16": "\\sqint",
  "\u2a17": "\\intlarhk",
  "\u2a18": "\\intx",
  "\u2a19": "\\intcap",
  "\u2a1a": "\\intcup"
};

// No limits, not symbols
defineFunction({
  type: "op",
  names: [
    "\\arcsin",
    "\\arccos",
    "\\arctan",
    "\\arctg",
    "\\arcctg",
    "\\arg",
    "\\ch",
    "\\cos",
    "\\cosec",
    "\\cosh",
    "\\cot",
    "\\cotg",
    "\\coth",
    "\\csc",
    "\\ctg",
    "\\cth",
    "\\deg",
    "\\dim",
    "\\exp",
    "\\hom",
    "\\ker",
    "\\lg",
    "\\ln",
    "\\log",
    "\\sec",
    "\\sin",
    "\\sinh",
    "\\sh",
    "\\sgn",
    "\\tan",
    "\\tanh",
    "\\tg",
    "\\th"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Limits, not symbols
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// No limits, symbols
defineFunction({
  type: "op",
  names: [
    "\\int",
    "\\iint",
    "\\iiint",
    "\\iiiint",
    "\\oint",
    "\\oiint",
    "\\oiiint",
    "\\intclockwise",
    "\\varointclockwise",
    "\\intbar",
    "\\intBar",
    "\\fint",
    "\\rppolint",
    "\\scpolint",
    "\\pointint",
    "\\sqint",
    "\\intlarhk",
    "\\intx",
    "\\intcap",
    "\\intcup",
    "\u222b",
    "\u222c",
    "\u222d",
    "\u222e",
    "\u222f",
    "\u2230",
    "\u2231",
    "\u2232",
    "\u2a0c",
    "\u2a0d",
    "\u2a0e",
    "\u2a0f",
    "\u2a12",
    "\u2a13",
    "\u2a15",
    "\u2a16",
    "\u2a17",
    "\u2a18",
    "\u2a19",
    "\u2a1a"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      stack: false,
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// NOTE: Unlike most builders, this one handles not only
// "operatorname", but also  "supsub" since \operatorname* can
// affect super/subscripting.

const mathmlBuilder$1 = (group, style) => {
  let expression = buildExpression(group.body, style.withFont("mathrm"));

  // Is expression a string or has it something like a fraction?
  let isAllString = true; // default
  for (let i = 0; i < expression.length; i++) {
    let node = expression[i];
    if (node instanceof mathMLTree.MathNode) {
      if ((node.type === "mrow" || node.type === "mpadded") && node.children.length === 1 &&
          node.children[0] instanceof mathMLTree.MathNode) {
        node = node.children[0];
      }
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mtext":
          break; // Do nothing yet.
        case "mspace":
          {
            if (node.attributes.width) {
              const width = node.attributes.width.replace("em", "");
              const ch = spaceCharacter(Number(width));
              if (ch === "") {
                isAllString = false;
              } else {
                expression[i] = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(ch)]);
              }
            }
          }
          break
        case "mo": {
          const child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }

  if (isAllString) {
    // Write a single TextNode instead of multiple nested tags.
    const word = expression.map((node) => node.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  } else if (
    expression.length === 1
    && ["mover", "munder"].includes(expression[0].type) &&
    (expression[0].children[0].type === "mi" || expression[0].children[0].type === "mtext")
  ) {
    expression[0].children[0].type = "mi";
    if (group.parentIsSupSub) {
      return new mathMLTree.MathNode("mrow", expression)
    } else {
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      return mathMLTree.newDocumentFragment([expression[0], operator])
    }
  }

  let wrapper;
  if (isAllString) {
    wrapper = new mathMLTree.MathNode("mi", expression);
    if (expression[0].text.length === 1) {
      wrapper.setAttribute("mathvariant", "normal");
    }
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }

  if (!group.parentIsSupSub) {
    // Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
    const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
    const fragment = [wrapper, operator];
    if (group.needsLeadingSpace) {
      // LaTeX gives operator spacing, but a <mi> gets ord spacing.
      // So add a leading space.
      const space = new mathMLTree.MathNode("mspace");
      space.setAttribute("width", "0.1667em"); // thin space.
      fragment.unshift(space);
    }
    if (!group.isFollowedByDelimiter) {
      const trail = new mathMLTree.MathNode("mspace");
      trail.setAttribute("width", "0.1667em"); // thin space.
      fragment.push(trail);
    }
    return mathMLTree.newDocumentFragment(fragment)
  }

  return wrapper
};

// \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = args[0];
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: (funcName === "\\operatornamewithlimits"),
      limits: false,
      parentIsSupSub: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType)
    };
  },
  mathmlBuilder: mathmlBuilder$1
});

defineMacro("\\operatorname",
  "\\@ifstar\\operatornamewithlimits\\operatorname@");

defineFunctionBuilders({
  type: "ordgroup",
  mathmlBuilder(group, style) {
    return buildExpressionRow(group.body, style, group.semisimple);
  }
});

defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(group.body, style);
    return new mathMLTree.MathNode("mphantom", inner);
  }
});

defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});

defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});

// In LaTeX, \pmb is a simulation of bold font.
// The version of \pmb in ambsy.sty works by typesetting three copies of the argument
// with small offsets. We use CSS font-weight:bold.

defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "pmb",
      mode: parser.mode,
      body: ordargument(args[0])
    }
  },
  mathmlBuilder(group, style) {
    const inner = buildExpression(group.body, style);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    node.setAttribute("style", "font-weight:bold");
    return node
  }
});

// \raise, \lower, and \raisebox

const mathmlBuilder = (group, style) => {
  const newStyle = style.withLevel(StyleLevel.TEXT);
  const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, newStyle)]);
  const dy = calculateSize(group.dy, style);
  node.setAttribute("voffset", dy.number + dy.unit);
  // Add padding, which acts to increase height in Chromium.
  // TODO: Figure out some way to change height in Firefox w/o breaking Chromium.
  if (dy.number > 0) {
    node.style.padding = dy.number + dy.unit + " 0 0 0";
  } else {
    node.style.padding = "0 0 " + Math.abs(dy.number) + dy.unit + " 0";
  }
  return node
};

defineFunction({
  type: "raise",
  names: ["\\raise", "\\lower"],
  props: {
    numArgs: 2,
    argTypes: ["size", "primitive"],
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    if (funcName === "\\lower") { amount.number *= -1; }
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});


defineFunction({
  type: "raise",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});

defineFunction({
  type: "ref",
  names: ["\\ref", "\\eqref"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser, funcName }, args) {
    return {
      type: "ref",
      mode: parser.mode,
      funcName,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Create an empty <a> node. Set a class and an href attribute.
    // The post-processor will populate with the target's tag or equation number.
    const classes = group.funcName === "\\ref" ? ["tml-ref"] : ["tml-ref", "tml-eqref"];
    return new AnchorNode("#" + group.string, classes, null)
  }
});

defineFunction({
  type: "reflect",
  names: ["\\reflectbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "reflect",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    const node = buildGroup$1(group.body, style);
    node.style.transform = "scaleX(-1)";
    return node
  }
});

defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser }) {
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});

defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["size", "size", "size"]
  },
  handler({ parser }, args, optArgs) {
    const shift = optArgs[0];
    const width = assertNodeType(args[0], "size");
    const height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  mathmlBuilder(group, style) {
    const width = calculateSize(group.width, style);
    const height = calculateSize(group.height, style);
    const shift = group.shift
      ? calculateSize(group.shift, style)
      : { number: 0, unit: "em" };
    const color = (style.color && style.getColor()) || "black";

    const rule = new mathMLTree.MathNode("mspace");
    if (width.number > 0 && height.number > 0) {
      rule.setAttribute("mathbackground", color);
    }
    rule.setAttribute("width", width.number + width.unit);
    rule.setAttribute("height", height.number + height.unit);
    if (shift.number === 0) { return rule }

    const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift.number >= 0) {
      wrapper.setAttribute("height", "+" + shift.number + shift.unit);
    } else {
      wrapper.setAttribute("height", shift.number + shift.unit);
      wrapper.setAttribute("depth", "+" + -shift.number + shift.unit);
    }
    wrapper.setAttribute("voffset", shift.number + shift.unit);
    return wrapper;
  }
});

// The size mappings are taken from TeX with \normalsize=10pt.
// We don't have to track script level. MathML does that.
const sizeMap = {
  "\\tiny": 0.5,
  "\\sixptsize": 0.6,
  "\\Tiny": 0.6,
  "\\scriptsize": 0.7,
  "\\footnotesize": 0.8,
  "\\small": 0.9,
  "\\normalsize": 1.0,
  "\\large": 1.2,
  "\\Large": 1.44,
  "\\LARGE": 1.728,
  "\\huge": 2.074,
  "\\Huge": 2.488
};

defineFunction({
  type: "sizing",
  names: [
    "\\tiny",
    "\\sixptsize",
    "\\Tiny",
    "\\scriptsize",
    "\\footnotesize",
    "\\small",
    "\\normalsize",
    "\\large",
    "\\Large",
    "\\LARGE",
    "\\huge",
    "\\Huge"
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ breakOnTokenText, funcName, parser }, args) => {
    if (parser.settings.strict && parser.mode === "math") {
      // eslint-disable-next-line no-console
      console.log(`Temml strict-mode warning: Command ${funcName} is invalid in math mode.`);
    }
    const body = parser.parseExpression(false, breakOnTokenText, true);
    return {
      type: "sizing",
      mode: parser.mode,
      funcName,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const newStyle = style.withFontSize(sizeMap[group.funcName]);
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    const factor = (sizeMap[group.funcName] / style.fontSize).toFixed(4);
    node.setAttribute("mathsize", factor + "em");
    return node;
  }
});

// smash, with optional [tb], as in AMS

defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args, optArgs) => {
    let smashHeight = false;
    let smashDepth = false;
    const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      // Optional [tb] argument is engaged.
      // ref: amsmath: \renewcommand{\smash}[1][tb]{%
      //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
      let letter = "";
      for (let i = 0; i < tbArg.body.length; ++i) {
        const node = tbArg.body[i];
        // TODO: Write an AssertSymbolNode
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }

    const body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  mathmlBuilder: (group, style) => {
    const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, style)]);

    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }

    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }

    return node;
  }
});

defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser }, args, optArgs) {
    const index = optArgs[0];
    const body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  mathmlBuilder(group, style) {
    const { body, index } = group;
    return index
      ? new mathMLTree.MathNode("mroot", [
        buildGroup$1(body, style),
        buildGroup$1(index, style.incrementLevel())
      ])
    : new mathMLTree.MathNode("msqrt", [buildGroup$1(body, style)]);
  }
});

const styleMap = {
  display: 0,
  text: 1,
  script: 2,
  scriptscript: 3
};

const styleAttributes = {
  display: ["0", "true"],
  text: ["0", "false"],
  script: ["1", "false"],
  scriptscript: ["2", "false"]
};

defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ breakOnTokenText, funcName, parser }, args) {
    // parse out the implicit body
    const body = parser.parseExpression(true, breakOnTokenText, true);

    const scriptLevel = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what scriptLevel to use by pulling out the scriptLevel from
      // the function name
      scriptLevel,
      body
    };
  },
  mathmlBuilder(group, style) {
    // Figure out what scriptLevel we're changing to.
    const newStyle = style.withLevel(styleMap[group.scriptLevel]);
    // The style argument in the next line does NOT directly set a MathML script level.
    // It just tracks the style level, in case we need to know it for supsub or mathchoice.
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);

    const attr = styleAttributes[group.scriptLevel];

    // Here is where we set the MathML script level.
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
  }
});

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */

// Helpers
const symbolRegEx = /^m(over|under|underover)$/;

// Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.
defineFunctionBuilders({
  type: "supsub",
  mathmlBuilder(group, style) {
    // Is the inner group a relevant horizontal brace?
    let isBrace = false;
    let isOver;
    let isSup;
    let appendApplyFunction = false;
    let appendSpace = false;
    let needsLeadingSpace = false;

    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }

    if (group.base && !group.base.stack &&
      (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
      appendApplyFunction = !group.base.symbol;
      appendSpace = appendApplyFunction && !group.isFollowedByDelimiter;
      needsLeadingSpace = group.base.needsLeadingSpace;
    }

    const children = group.base && group.base.stack
      ? [buildGroup$1(group.base.body[0], style)]
      : [buildGroup$1(group.base, style)];

    // Note regarding scriptstyle level.
    // (Sub|super)scripts should not shrink beyond MathML scriptlevel 2 aka \scriptscriptstyle
    // Ref: https://w3c.github.io/mathml-core/#the-displaystyle-and-scriptlevel-attributes
    // (BTW, MathML scriptlevel 2 is equal to Temml level 3.)
    // But Chromium continues to shrink the (sub|super)scripts. So we explicitly set scriptlevel 2.

    const childStyle = style.inSubOrSup();
    if (group.sub) {
      const sub = buildGroup$1(group.sub, childStyle);
      if (style.level === 3) { sub.setAttribute("scriptlevel", "2"); }
      children.push(sub);
    }

    if (group.sup) {
      const sup = buildGroup$1(group.sup, childStyle);
      if (style.level === 3) { sup.setAttribute("scriptlevel", "2"); }
      const testNode = sup.type === "mrow" ? sup.children[0] : sup;
      if ((testNode && testNode.type === "mo" && testNode.classes.includes("tml-prime"))
        && group.base && group.base.text && "fF".indexOf(group.base.text) > -1) {
        // Chromium does not address italic correction on prime.  Prevent f′ from overlapping.
        testNode.classes.push("prime-pad");
      }
      children.push(sup);
    }

    let nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "mover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munder";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      const base = group.base;
      if (base && ((base.type === "op" && base.limits) || base.type === "multiscript") &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munderover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (style.level === StyleLevel.DISPLAY || base.limits)
      ) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }

    let node = new mathMLTree.MathNode(nodeType, children);
    if (appendApplyFunction) {
      // Append an <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      if (needsLeadingSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node = mathMLTree.newDocumentFragment([space, node, operator]);
      } else {
        node = mathMLTree.newDocumentFragment([node, operator]);
      }
      if (appendSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node.children.push(space);
      }
    } else if (symbolRegEx.test(nodeType)) {
      // Wrap in a <mrow>. Otherwise Firefox stretchy parens will not stretch to include limits.
      node = new mathMLTree.MathNode("mrow", [node]);
    }

    return node
  }
});

// Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.

const short = ["\\shortmid", "\\nshortmid", "\\shortparallel",
  "\\nshortparallel", "\\smallsetminus"];

const arrows = ["\\Rsh", "\\Lsh", "\\restriction"];

const isArrow = str => {
  if (str.length === 1) {
    const codePoint = str.codePointAt(0);
    return (0x218f < codePoint && codePoint < 0x2200)
  }
  return str.indexOf("arrow") > -1 || str.indexOf("harpoon") > -1 || arrows.includes(str)
};

defineFunctionBuilders({
  type: "atom",
  mathmlBuilder(group, style) {
    const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      // Delims built here should not stretch vertically.
      // See delimsizing.js for stretchy delims.
      if (group.family === "open") {
        node.setAttribute("form", "prefix");
        // Set an explicit attribute for stretch. Otherwise Firefox may do it wrong.
        node.setAttribute("stretchy", "false");
      } else if (group.family === "close") {
        node.setAttribute("form", "postfix");
        node.setAttribute("stretchy", "false");
      }
    } else if (group.text === "\\mid") {
      // Firefox messes up this spacing if at the end of an <mrow>. See it explicitly.
      node.setAttribute("lspace", "0.22em"); // medium space
      node.setAttribute("rspace", "0.22em");
      node.setAttribute("stretchy", "false");
    } else if (group.family === "rel" && isArrow(group.text)) {
      node.setAttribute("stretchy", "false");
    } else if (short.includes(group.text)) {
      node.setAttribute("mathsize", "70%");
    } else if (group.text === ":") {
      // ":" is not in the MathML operator dictionary. Give it BIN spacing.
      node.attributes.lspace = "0.2222em";
      node.attributes.rspace = "0.2222em";
    } else if (group.needsSpacing) {
      // Fix a MathML bug that occurs when a <mo> is between two <mtext> elements.
      if (group.family === "bin") {
        return new mathMLTree.MathNode("mrow", [padding$1(0.222), node, padding$1(0.222)])
      } else {
        // REL spacing
        return new mathMLTree.MathNode("mrow", [padding$1(0.2778), node, padding$1(0.2778)])
      }
    }
    return node;
  }
});

/**
 * Maps TeX font commands to "mathvariant" attribute in buildMathML.js
 */
const fontMap = {
  // styles
  mathbf: "bold",
  mathrm: "normal",
  textit: "italic",
  mathit: "italic",
  mathnormal: "italic",

  // families
  mathbb: "double-struck",
  mathcal: "script",
  mathfrak: "fraktur",
  mathscr: "script",
  mathsf: "sans-serif",
  mathtt: "monospace"
};

/**
 * Returns the math variant as a string or null if none is required.
 */
const getVariant = function(group, style) {
  // Handle font specifiers as best we can.
  // Chromium does not support the MathML mathvariant attribute.
  // So we'll use Unicode replacement characters instead.
  // But first, determine the math variant.

  // Deal with the \textit, \textbf, etc., functions.
  if (style.fontFamily === "texttt") {
    return "monospace"
  } else if (style.fontFamily === "textsc") {
    return "normal"; // handled via character substitution in symbolsOrd.js.
  } else if (style.fontFamily === "textsf") {
    if (style.fontShape === "textit" && style.fontWeight === "textbf") {
      return "sans-serif-bold-italic"
    } else if (style.fontShape === "textit") {
      return "sans-serif-italic"
    } else if (style.fontWeight === "textbf") {
      return "sans-serif-bold"
    } else {
      return "sans-serif"
    }
  } else if (style.fontShape === "textit" && style.fontWeight === "textbf") {
    return "bold-italic"
  } else if (style.fontShape === "textit") {
    return "italic"
  } else if (style.fontWeight === "textbf") {
    return "bold"
  }

  // Deal with the \mathit, mathbf, etc, functions.
  const font = style.font;
  if (!font || font === "mathnormal") {
    return null
  }

  const mode = group.mode;
  switch (font) {
    case "mathit":
      return "italic"
    case "mathrm": {
      const codePoint = group.text.codePointAt(0);
      // LaTeX \mathrm returns italic for Greek characters.
      return  (0x03ab < codePoint && codePoint < 0x03cf) ? "italic" : "normal"
    }
    case "greekItalic":
      return "italic"
    case "up@greek":
      return "normal"
    case "boldsymbol":
    case "mathboldsymbol":
      return "bold-italic"
    case "mathbf":
      return "bold"
    case "mathbb":
      return "double-struck"
    case "mathfrak":
      return "fraktur"
    case "mathscr":
    case "mathcal":
      return "script"
    case "mathsf":
      return "sans-serif"
    case "mathsfit":
      return "sans-serif-italic"
    case "mathtt":
      return "monospace"
  }

  let text = group.text;
  if (symbols[mode][text] && symbols[mode][text].replace) {
    text = symbols[mode][text].replace;
  }

  return Object.prototype.hasOwnProperty.call(fontMap, font) ? fontMap[font] : null
};

// Chromium does not support the MathML `mathvariant` attribute.
// Instead, we replace ASCII characters with Unicode characters that
// are defined in the font as bold, italic, double-struck, etc.
// This module identifies those Unicode code points.

// First, a few helpers.
const script = Object.freeze({
  B: 0x20EA, // Offset from ASCII B to Unicode script B
  E: 0x20EB,
  F: 0x20EB,
  H: 0x20C3,
  I: 0x20C7,
  L: 0x20C6,
  M: 0x20E6,
  R: 0x20C9,
  e: 0x20CA,
  g: 0x20A3,
  o: 0x20C5
});

const frak = Object.freeze({
  C: 0x20EA,
  H: 0x20C4,
  I: 0x20C8,
  R: 0x20CA,
  Z: 0x20CE
});

const bbb = Object.freeze({
  C: 0x20BF, // blackboard bold
  H: 0x20C5,
  N: 0x20C7,
  P: 0x20C9,
  Q: 0x20C9,
  R: 0x20CB,
  Z: 0x20CA
});

const bold = Object.freeze({
  "\u03f5": 0x1D2E7, // lunate epsilon
  "\u03d1": 0x1D30C, // vartheta
  "\u03f0": 0x1D2EE, // varkappa
  "\u03c6": 0x1D319, // varphi
  "\u03f1": 0x1D2EF, // varrho
  "\u03d6": 0x1D30B  // varpi
});

const boldItalic = Object.freeze({
  "\u03f5": 0x1D35B, // lunate epsilon
  "\u03d1": 0x1D380, // vartheta
  "\u03f0": 0x1D362, // varkappa
  "\u03c6": 0x1D38D, // varphi
  "\u03f1": 0x1D363, // varrho
  "\u03d6": 0x1D37F  // varpi
});

const boldsf = Object.freeze({
  "\u03f5": 0x1D395, // lunate epsilon
  "\u03d1": 0x1D3BA, // vartheta
  "\u03f0": 0x1D39C, // varkappa
  "\u03c6": 0x1D3C7, // varphi
  "\u03f1": 0x1D39D, // varrho
  "\u03d6": 0x1D3B9  // varpi
});

const bisf = Object.freeze({
  "\u03f5": 0x1D3CF, // lunate epsilon
  "\u03d1": 0x1D3F4, // vartheta
  "\u03f0": 0x1D3D6, // varkappa
  "\u03c6": 0x1D401, // varphi
  "\u03f1": 0x1D3D7, // varrho
  "\u03d6": 0x1D3F3  // varpi
});

// Code point offsets below are derived from https://www.unicode.org/charts/PDF/U1D400.pdf
const offset = Object.freeze({
  upperCaseLatin: { // A-Z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3BF },
    "italic": ch =>                 { return 0x1D3F3 },
    "bold-italic": ch =>            { return 0x1D427 },
    "script": ch =>                 { return script[ch] || 0x1D45B },
    "script-bold": ch =>            { return 0x1D48F },
    "fraktur": ch =>                { return frak[ch] || 0x1D4C3 },
    "fraktur-bold": ch =>           { return 0x1D52B },
    "double-struck": ch =>          { return bbb[ch] || 0x1D4F7 },
    "sans-serif": ch =>             { return 0x1D55F },
    "sans-serif-bold": ch =>        { return 0x1D593 },
    "sans-serif-italic": ch =>      { return 0x1D5C7 },
    "sans-serif-bold-italic": ch => { return 0x1D63C },
    "monospace": ch =>              { return 0x1D62F }
  },
  lowerCaseLatin: { // a-z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3B9 },
    "italic": ch =>                 { return ch === "h" ? 0x20A6 : 0x1D3ED },
    "bold-italic": ch =>            { return 0x1D421 },
    "script": ch =>                 { return script[ch] || 0x1D455 },
    "script-bold": ch =>            { return 0x1D489 },
    "fraktur": ch =>                { return 0x1D4BD },
    "fraktur-bold": ch =>           { return 0x1D525 },
    "double-struck": ch =>          { return 0x1D4F1 },
    "sans-serif": ch =>             { return 0x1D559 },
    "sans-serif-bold": ch =>        { return 0x1D58D },
    "sans-serif-italic": ch =>      { return 0x1D5C1 },
    "sans-serif-bold-italic": ch => { return 0x1D5F5 },
    "monospace": ch =>              { return 0x1D629 }
  },
  upperCaseGreek: { // A-Ω
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D317 },
    "italic": ch =>                 { return 0x1D351 },
    // \boldsymbol actually returns upright bold for upperCaseGreek
    "bold-italic": ch =>            { return 0x1D317 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3C5 },
    "sans-serif-bold": ch =>        { return 0x1D3C5 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3FF },
    "monospace": ch =>              { return 0 }
  },
  lowerCaseGreek: { // α-ω
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D311 },
    "italic": ch =>                 { return 0x1D34B },
    "bold-italic": ch =>            { return ch === "\u03d5" ? 0x1D37E : 0x1D385 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3BF },
    "sans-serif-bold": ch =>        { return 0x1D3BF },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3F9 },
    "monospace": ch =>              { return 0 }
  },
  varGreek: { // \varGamma, etc
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return  bold[ch] || -51 },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return boldItalic[ch] || 0x3A },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    "sans-serif": ch =>             { return boldsf[ch] || 0x74 },
    "sans-serif-bold": ch =>        { return boldsf[ch] || 0x74 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return bisf[ch] || 0xAE },
    "monospace": ch =>              { return 0 }
  },
  numeral: { // 0-9
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D79E },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return 0 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0x1D7A8 },
    "sans-serif": ch =>             { return 0x1D7B2 },
    "sans-serif-bold": ch =>        { return 0x1D7BC },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0 },
    "monospace": ch =>              { return 0x1D7C6 }
  }
});

const variantChar = (ch, variant) => {
  const codePoint = ch.codePointAt(0);
  const block = 0x40 < codePoint && codePoint < 0x5b
    ? "upperCaseLatin"
    : 0x60 < codePoint && codePoint < 0x7b
    ? "lowerCaseLatin"
    : (0x390  < codePoint && codePoint < 0x3AA)
    ? "upperCaseGreek"
    : 0x3B0 < codePoint && codePoint < 0x3CA || ch === "\u03d5"
    ? "lowerCaseGreek"
    : 0x1D6E1 < codePoint && codePoint < 0x1D6FC  || bold[ch]
    ? "varGreek"
    : (0x2F < codePoint && codePoint <  0x3A)
    ? "numeral"
    : "other";
  return block === "other"
    ? ch
    : String.fromCodePoint(codePoint + offset[block][variant](ch))
};

const smallCaps = Object.freeze({
  a: "ᴀ",
  b: "ʙ",
  c: "ᴄ",
  d: "ᴅ",
  e: "ᴇ",
  f: "ꜰ",
  g: "ɢ",
  h: "ʜ",
  i: "ɪ",
  j: "ᴊ",
  k: "ᴋ",
  l: "ʟ",
  m: "ᴍ",
  n: "ɴ",
  o: "ᴏ",
  p: "ᴘ",
  q: "ǫ",
  r: "ʀ",
  s: "s",
  t: "ᴛ",
  u: "ᴜ",
  v: "ᴠ",
  w: "ᴡ",
  x: "x",
  y: "ʏ",
  z: "ᴢ"
});

// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
// src/symbols.js.

const numberRegEx = /^\d(?:[\d,.]*\d)?$/;
const latinRegEx = /[A-Ba-z]/;
const primes = new Set(["\\prime", "\\dprime", "\\trprime", "\\qprime",
  "\\backprime", "\\backdprime", "\\backtrprime"]);

const italicNumber = (text, variant, tag) => {
  const mn = new mathMLTree.MathNode(tag, [text]);
  const wrapper = new mathMLTree.MathNode("mstyle", [mn]);
  wrapper.style["font-style"] = "italic";
  wrapper.style["font-family"] = "Cambria, 'Times New Roman', serif";
  if (variant === "bold-italic") { wrapper.style["font-weight"] = "bold"; }
  return wrapper
};

defineFunctionBuilders({
  type: "mathord",
  mathmlBuilder(group, style) {
    const text = makeText(group.text, group.mode, style);
    const codePoint = text.text.codePointAt(0);
    // Test for upper-case Greek
    const defaultVariant = (0x0390 < codePoint && codePoint < 0x03aa) ? "normal" : "italic";
    const variant = getVariant(group, style) || defaultVariant;
    if (variant === "script") {
      text.text = variantChar(text.text, variant);
      return new mathMLTree.MathNode("mi", [text], [style.font])
    } else if (variant !== "italic") {
      text.text = variantChar(text.text, variant);
    }
    let node = new mathMLTree.MathNode("mi", [text]);
    // TODO: Handle U+1D49C - U+1D4CF per https://www.unicode.org/charts/PDF/U1D400.pdf
    if (variant === "normal") {
      node.setAttribute("mathvariant", "normal");
      if (text.text.length === 1) {
        // A Firefox bug will apply spacing here, but there should be none. Fix it.
        node = new mathMLTree.MathNode("mpadded", [node]);
        node.setAttribute("lspace", "0");
        node.setAttribute("rspace", "0");
      }
    }
    return node
  }
});

defineFunctionBuilders({
  type: "textord",
  mathmlBuilder(group, style) {
    let ch = group.text;
    const codePoint = ch.codePointAt(0);
    if (style.fontFamily === "textsc") {
      // Convert small latin letters to small caps.
      if (96 < codePoint && codePoint < 123) {
        ch = smallCaps[ch];
      }
    }
    const text = makeText(ch, group.mode, style);
    const variant = getVariant(group, style) || "normal";

    let node;
    if (numberRegEx.test(group.text)) {
      const tag = group.mode === "text" ? "mtext" : "mn";
      if (variant === "italic" || variant === "bold-italic") {
        return italicNumber(text, variant, tag)
      } else {
        if (variant !== "normal") {
          text.text = text.text.split("").map(c => variantChar(c, variant)).join("");
        }
        node = new mathMLTree.MathNode(tag, [text]);
      }
    } else if (group.mode === "text") {
      if (variant !== "normal") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mtext", [text]);
    } else if (primes.has(group.text)) {
      node = new mathMLTree.MathNode("mo", [text]);
      // TODO: If/when Chromium uses ssty variant for prime, remove the next line.
      node.classes.push("tml-prime");
    } else {
      const origText = text.text;
      if (variant !== "italic") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mi", [text]);
      if (text.text === origText && latinRegEx.test(origText)) {
        node.setAttribute("mathvariant", "italic");
      }
    }
    return node
  }
});

// A map of CSS-based spacing functions to their CSS class.
const cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};

// A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.
const regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};

// ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.
defineFunctionBuilders({
  type: "spacing",
  mathmlBuilder(group, style) {
    let node;

    if (Object.prototype.hasOwnProperty.call(regularSpace, group.text)) {
      // Firefox does not render a space in a <mtext> </mtext>. So write a no-break space.
      // TODO: If Firefox fixes that bug, uncomment the next line and write ch into the node.
      //const ch = (regularSpace[group.text].className === "nobreak") ? "\u00a0" : " "
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else if (Object.prototype.hasOwnProperty.call(cssSpace, group.text)) {
      // MathML 3.0 calls for nobreak to occur in an <mo>, not an <mtext>
      // Ref: https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs
      node = new mathMLTree.MathNode("mo");
      if (group.text === "\\nobreak") {
        node.setAttribute("linebreak", "nobreak");
      }
    } else {
      throw new ParseError(`Unknown type of space "${group.text}"`)
    }

    return node
  }
});

defineFunctionBuilders({
  type: "tag"
});

// For a \tag, the work usually done in a mathmlBuilder is instead done in buildMathML.js.
// That way, a \tag can be pulled out of the parse tree and wrapped around the outer node.

// Non-mathy text, possibly in a font
const textFontFamilies = {
  "\\text": undefined,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm",
  "\\textsc": "textsc"      // small caps
};

const textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};

const textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};

const styleWithFont = (group, style) => {
  const font = group.font;
  // Checks if the argument is a font family or a font style.
  if (!font) {
    return style;
  } else if (textFontFamilies[font]) {
    return style.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return style.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return style.fontShape === "textit"
      ? style.withTextFontShape("textup")
      : style.withTextFontShape("textit")
  }
  return style.withTextFontShape(textFontShapes[font])
};

defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    "\\textsc",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = styleWithFont(group, style);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

// \vcenter:  Vertically center the argument group on the math axis.

defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    // Use a math table to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.body, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    return new mathMLTree.MathNode("mtable", [mtr])
  }
});

defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    // \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  mathmlBuilder(group, style) {
    const text = new mathMLTree.TextNode(makeVerb(group));
    const node = new mathMLTree.MathNode("mtext", [text]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});

/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */
const makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");

/** Include this to ensure that all functions are defined. */

const functions = _functions;

/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */


/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first two groups
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - mathches numerals
 * - matches a backslash followed by one or more whitespace characters
 * - matches a backslash followed by one or more letters then whitespace
 * - matches a backslash followed by any BMP character
 * Capturing groups:
 *   [1] regular whitespace
 *   [2] backslash followed by whitespace
 *   [3] anything else, which may include:
 *     [4] left character of \verb*
 *     [5] left character of \verb
 *     [6] backslash followed by word, excluding any trailing whitespace
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
const spaceRegexString = "[ \r\n\t]";
const controlWordRegexString = "\\\\[a-zA-Z@]+";
const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
const controlWordWhitespaceRegexString = `(${controlWordRegexString})${spaceRegexString}*`;
const controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
const combiningDiacriticalMarkString = "[\u0300-\u036f]";
const combiningDiacriticalMarksEndRegex = new RegExp(`${combiningDiacriticalMarkString}+$`);
const tokenRegexString =
  `(${spaceRegexString}+)|` + // whitespace
  `${controlSpaceRegexString}|` +  // whitespace
  "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|\\\\verb\\*([^]).*?\\4" + // \verb*
  "|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
  `|${controlWordWhitespaceRegexString}` + // \macroName + spaces
  `|${controlSymbolRegexString})`; // \\, \', etc.

/** Main Lexer class */
class Lexer {
  constructor(input, settings) {
    // Separate accents from characters
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, 'g');
    // Category codes. The lexer only supports comment characters (14) for now.
    // MacroExpander additionally distinguishes active (13).
    this.catcodes = {
      "%": 14, // comment character
      "~": 13  // active character
    };
  }

  setCatcode(char, code) {
    this.catcodes[char] = code;
  }

  /**
   * This function lexes a single token.
   */
  lex() {
    const input = this.input;
    const pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    const match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError(
        `Unexpected character: '${input[pos]}'`,
        new Token(input[pos], new SourceLocation(this, pos, pos + 1))
      );
    }
    const text = match[6] || match[3] || (match[2] ? "\\ " : " ");

    if (this.catcodes[text] === 14) {
      // comment character
      const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length; // EOF
        if (this.settings.strict) {
          throw new ParseError("% comment has no terminating newline; LaTeX would " +
              "fail because of commenting the end of math mode")
        }
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }

    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}

/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */


class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins = {}, globalMacros = {}) {
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }

  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }

  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError(
        "Unbalanced namespace destruction: attempt " +
          "to pop global namespace; please report this as a bug"
      );
    }
    const undefs = this.undefStack.pop();
    for (const undef in undefs) {
      if (Object.prototype.hasOwnProperty.call(undefs, undef )) {
        if (undefs[undef] === undefined) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }

  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.current, name ) ||
    Object.prototype.hasOwnProperty.call(this.builtins, name );
  }

  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (Object.prototype.hasOwnProperty.call(this.current, name )) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }

  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   */
  set(name, value, global = false) {
    if (global) {
      // Global set is equivalent to setting in all groups.  Simulate this
      // by destroying any undos currently scheduled for this name,
      // and adding an undo with the *new* value (in case it later gets
      // locally reset within this environment).
      for (let i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      // Undo this set at end of this group (possibly to `undefined`),
      // unless an undo is already in place, in which case that older
      // value is the correct one.
      const top = this.undefStack[this.undefStack.length - 1];
      if (top && !Object.prototype.hasOwnProperty.call(top, name )) {
        top[name] = this.current[name];
      }
    }
    this.current[name] = value;
  }
}

/**
 * This file contains the “gullet” where macros are expanded
 * until only non-macro tokens remain.
 */


// List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
const implicitCommands = {
  "^": true, // Parser.js
  _: true, // Parser.js
  "\\limits": true, // Parser.js
  "\\nolimits": true // Parser.js
};

class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    // Make new global namespace
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = []; // contains tokens in REVERSE order
  }

  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }

  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }

  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }

  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1]
  }

  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future(); // ensure non-empty stack
    return this.stack.pop();
  }

  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }

  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }

  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    let start;
    let end;
    let tokens;
    if (isOptional) {
      this.consumeSpaces(); // \@ifnextchar gobbles any space following it
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken(); // don't include [ in tokens
      ({ tokens, end } = this.consumeArg(["]"]));
    } else {
      ({ tokens, start, end } = this.consumeArg());
    }

    // indicate the end of an argument
    this.pushToken(new Token("EOF", end.loc));

    this.pushTokens(tokens);
    return start.range(end, "");
  }

  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (;;) {
      const token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }

  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    // The argument for a delimited parameter is the shortest (possibly
    // empty) sequence of tokens with properly nested {...} groups that is
    // followed ... by this particular list of non-parameter tokens.
    // The argument for an undelimited parameter is the next nonblank
    // token, unless that token is ‘{’, when the argument will be the
    // entire {...} group that follows.
    const tokens = [];
    const isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      // Ignore spaces between arguments.  As the TeXbook says:
      // "After you have said ‘\def\row#1#2{...}’, you are allowed to
      //  put spaces between the arguments (e.g., ‘\row x n’), because
      //  TeX doesn’t use single spaces as undelimited arguments."
      this.consumeSpaces();
    }
    const start = this.future();
    let tok;
    let depth = 0;
    let match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError(
          "Unexpected end of input in a macro argument" +
            ", expected '" +
            (delims && isDelimited ? delims[match] : "}") +
            "'",
          tok
        );
      }
      if (delims && isDelimited) {
        if ((depth === 0 || (depth === 1 && delims[match] === "{")) && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            // don't include delims in tokens
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    // If the argument found ... has the form ‘{<nested tokens>}’,
    // ... the outermost braces enclosing the argument are removed
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse(); // to fit in with stack order
    return { tokens, start, end: tok };
  }

  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters) {
    if (delimiters) {
      if (delimiters.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      const delims = delimiters[0];
      for (let i = 0; i < delims.length; i++) {
        const tok = this.popToken();
        if (delims[i] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }

    const args = [];
    for (let i = 0; i < numArgs; i++) {
      args.push(this.consumeArg(delimiters && delimiters[i + 1]).tokens);
    }
    return args;
  }

  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    const topToken = this.popToken();
    const name = topToken.text;
    const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || (expandableOnly && expansion.unexpandable)) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.expansionCount++;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError(
        "Too many expansions: infinite loop or " + "need to increase maxExpand setting"
      );
    }
    let tokens = expansion.tokens;
    const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      // paste arguments in place of the placeholders
      tokens = tokens.slice(); // make a shallow copy
      for (let i = tokens.length - 1; i >= 0; --i) {
        let tok = tokens[i];
        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i]; // next token on stack
          if (tok.text === "#") {
            // ## → #
            tokens.splice(i + 1, 1); // drop first #
          } else if (/^[1-9]$/.test(tok.text)) {
            // replace the placeholder with the indicated argument
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    // Concatenate expansion onto top of stack.
    this.pushTokens(tokens);
    return tokens.length;
  }

  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }

  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (;;) {
      if (this.expandOnce() === false) { // fully expanded
        const token = this.stack.pop();
        // The token after \noexpand is interpreted as if its meaning were ‘\relax’
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token
      }
    }

    // This pathway is impossible.
    throw new Error(); // eslint-disable-line no-unreachable
  }

  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
  }

  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    const output = [];
    const oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      // Expand only expandable tokens
      if (this.expandOnce(true) === false) {  // fully expanded
        const token = this.stack.pop();
        if (token.treatAsRelax) {
          // the expansion of \noexpand is the token itself
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    return output;
  }

  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    const tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }

  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    const definition = this.macros.get(name);
    if (definition == null) {
      // mainly checking for undefined here
      return definition;
    }
    // If a single character has an associated catcode other than 13
    // (active character), then don't expand it.
    if (name.length === 1) {
      const catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return
      }
    }
    const expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      let numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        const stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      const bodyLexer = new Lexer(expansion, this.settings);
      const tokens = [];
      let tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse(); // to fit in with stack using push and pop
      const expanded = { tokens, numArgs };
      return expanded;
    }

    return expansion;
  }

  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return (
      this.macros.has(name) ||
      Object.prototype.hasOwnProperty.call(functions, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.math, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.text, name ) ||
      Object.prototype.hasOwnProperty.call(implicitCommands, name )
    );
  }

  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    const macro = this.macros.get(name);
    return macro != null
      ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable
      : Object.prototype.hasOwnProperty.call(functions, name ) && !functions[name].primitive;
  }
}

// Helpers for Parser.js handling of Unicode (sub|super)script characters.

const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;

const uSubsAndSups = Object.freeze({
  '₊': '+',
  '₋': '-',
  '₌': '=',
  '₍': '(',
  '₎': ')',
  '₀': '0',
  '₁': '1',
  '₂': '2',
  '₃': '3',
  '₄': '4',
  '₅': '5',
  '₆': '6',
  '₇': '7',
  '₈': '8',
  '₉': '9',
  '\u2090': 'a',
  '\u2091': 'e',
  '\u2095': 'h',
  '\u1D62': 'i',
  '\u2C7C': 'j',
  '\u2096': 'k',
  '\u2097': 'l',
  '\u2098': 'm',
  '\u2099': 'n',
  '\u2092': 'o',
  '\u209A': 'p',
  '\u1D63': 'r',
  '\u209B': 's',
  '\u209C': 't',
  '\u1D64': 'u',
  '\u1D65': 'v',
  '\u2093': 'x',
  '\u1D66': 'β',
  '\u1D67': 'γ',
  '\u1D68': 'ρ',
  '\u1D69': '\u03d5',
  '\u1D6A': 'χ',
  '⁺': '+',
  '⁻': '-',
  '⁼': '=',
  '⁽': '(',
  '⁾': ')',
  '⁰': '0',
  '¹': '1',
  '²': '2',
  '³': '3',
  '⁴': '4',
  '⁵': '5',
  '⁶': '6',
  '⁷': '7',
  '⁸': '8',
  '⁹': '9',
  '\u1D2C': 'A',
  '\u1D2E': 'B',
  '\u1D30': 'D',
  '\u1D31': 'E',
  '\u1D33': 'G',
  '\u1D34': 'H',
  '\u1D35': 'I',
  '\u1D36': 'J',
  '\u1D37': 'K',
  '\u1D38': 'L',
  '\u1D39': 'M',
  '\u1D3A': 'N',
  '\u1D3C': 'O',
  '\u1D3E': 'P',
  '\u1D3F': 'R',
  '\u1D40': 'T',
  '\u1D41': 'U',
  '\u2C7D': 'V',
  '\u1D42': 'W',
  '\u1D43': 'a',
  '\u1D47': 'b',
  '\u1D9C': 'c',
  '\u1D48': 'd',
  '\u1D49': 'e',
  '\u1DA0': 'f',
  '\u1D4D': 'g',
  '\u02B0': 'h',
  '\u2071': 'i',
  '\u02B2': 'j',
  '\u1D4F': 'k',
  '\u02E1': 'l',
  '\u1D50': 'm',
  '\u207F': 'n',
  '\u1D52': 'o',
  '\u1D56': 'p',
  '\u02B3': 'r',
  '\u02E2': 's',
  '\u1D57': 't',
  '\u1D58': 'u',
  '\u1D5B': 'v',
  '\u02B7': 'w',
  '\u02E3': 'x',
  '\u02B8': 'y',
  '\u1DBB': 'z',
  '\u1D5D': 'β',
  '\u1D5E': 'γ',
  '\u1D5F': 'δ',
  '\u1D60': '\u03d5',
  '\u1D61': 'χ',
  '\u1DBF': 'θ'
});

// Used for Unicode input of calligraphic and script letters
const asciiFromScript = Object.freeze({
  "\ud835\udc9c": "A",
  "\u212c": "B",
  "\ud835\udc9e": "C",
  "\ud835\udc9f": "D",
  "\u2130": "E",
  "\u2131": "F",
  "\ud835\udca2": "G",
  "\u210B": "H",
  "\u2110": "I",
  "\ud835\udca5": "J",
  "\ud835\udca6": "K",
  "\u2112": "L",
  "\u2133": "M",
  "\ud835\udca9": "N",
  "\ud835\udcaa": "O",
  "\ud835\udcab": "P",
  "\ud835\udcac": "Q",
  "\u211B": "R",
  "\ud835\udcae": "S",
  "\ud835\udcaf": "T",
  "\ud835\udcb0": "U",
  "\ud835\udcb1": "V",
  "\ud835\udcb2": "W",
  "\ud835\udcb3": "X",
  "\ud835\udcb4": "Y",
  "\ud835\udcb5": "Z"
});

// Mapping of Unicode accent characters to their LaTeX equivalent in text and
// math mode (when they exist).
var unicodeAccents = {
  "\u0301": { text: "\\'", math: "\\acute" },
  "\u0300": { text: "\\`", math: "\\grave" },
  "\u0308": { text: '\\"', math: "\\ddot" },
  "\u0303": { text: "\\~", math: "\\tilde" },
  "\u0304": { text: "\\=", math: "\\bar" },
  "\u0306": { text: "\\u", math: "\\breve" },
  "\u030c": { text: "\\v", math: "\\check" },
  "\u0302": { text: "\\^", math: "\\hat" },
  "\u0307": { text: "\\.", math: "\\dot" },
  "\u030a": { text: "\\r", math: "\\mathring" },
  "\u030b": { text: "\\H" },
  '\u0327': { text: '\\c' }
};

var unicodeSymbols = {
  "á": "á",
  "à": "à",
  "ä": "ä",
  "ǟ": "ǟ",
  "ã": "ã",
  "ā": "ā",
  "ă": "ă",
  "ắ": "ắ",
  "ằ": "ằ",
  "ẵ": "ẵ",
  "ǎ": "ǎ",
  "â": "â",
  "ấ": "ấ",
  "ầ": "ầ",
  "ẫ": "ẫ",
  "ȧ": "ȧ",
  "ǡ": "ǡ",
  "å": "å",
  "ǻ": "ǻ",
  "ḃ": "ḃ",
  "ć": "ć",
  "č": "č",
  "ĉ": "ĉ",
  "ċ": "ċ",
  "ď": "ď",
  "ḋ": "ḋ",
  "é": "é",
  "è": "è",
  "ë": "ë",
  "ẽ": "ẽ",
  "ē": "ē",
  "ḗ": "ḗ",
  "ḕ": "ḕ",
  "ĕ": "ĕ",
  "ě": "ě",
  "ê": "ê",
  "ế": "ế",
  "ề": "ề",
  "ễ": "ễ",
  "ė": "ė",
  "ḟ": "ḟ",
  "ǵ": "ǵ",
  "ḡ": "ḡ",
  "ğ": "ğ",
  "ǧ": "ǧ",
  "ĝ": "ĝ",
  "ġ": "ġ",
  "ḧ": "ḧ",
  "ȟ": "ȟ",
  "ĥ": "ĥ",
  "ḣ": "ḣ",
  "í": "í",
  "ì": "ì",
  "ï": "ï",
  "ḯ": "ḯ",
  "ĩ": "ĩ",
  "ī": "ī",
  "ĭ": "ĭ",
  "ǐ": "ǐ",
  "î": "î",
  "ǰ": "ǰ",
  "ĵ": "ĵ",
  "ḱ": "ḱ",
  "ǩ": "ǩ",
  "ĺ": "ĺ",
  "ľ": "ľ",
  "ḿ": "ḿ",
  "ṁ": "ṁ",
  "ń": "ń",
  "ǹ": "ǹ",
  "ñ": "ñ",
  "ň": "ň",
  "ṅ": "ṅ",
  "ó": "ó",
  "ò": "ò",
  "ö": "ö",
  "ȫ": "ȫ",
  "õ": "õ",
  "ṍ": "ṍ",
  "ṏ": "ṏ",
  "ȭ": "ȭ",
  "ō": "ō",
  "ṓ": "ṓ",
  "ṑ": "ṑ",
  "ŏ": "ŏ",
  "ǒ": "ǒ",
  "ô": "ô",
  "ố": "ố",
  "ồ": "ồ",
  "ỗ": "ỗ",
  "ȯ": "ȯ",
  "ȱ": "ȱ",
  "ő": "ő",
  "ṕ": "ṕ",
  "ṗ": "ṗ",
  "ŕ": "ŕ",
  "ř": "ř",
  "ṙ": "ṙ",
  "ś": "ś",
  "ṥ": "ṥ",
  "š": "š",
  "ṧ": "ṧ",
  "ŝ": "ŝ",
  "ṡ": "ṡ",
  "ẗ": "ẗ",
  "ť": "ť",
  "ṫ": "ṫ",
  "ú": "ú",
  "ù": "ù",
  "ü": "ü",
  "ǘ": "ǘ",
  "ǜ": "ǜ",
  "ǖ": "ǖ",
  "ǚ": "ǚ",
  "ũ": "ũ",
  "ṹ": "ṹ",
  "ū": "ū",
  "ṻ": "ṻ",
  "ŭ": "ŭ",
  "ǔ": "ǔ",
  "û": "û",
  "ů": "ů",
  "ű": "ű",
  "ṽ": "ṽ",
  "ẃ": "ẃ",
  "ẁ": "ẁ",
  "ẅ": "ẅ",
  "ŵ": "ŵ",
  "ẇ": "ẇ",
  "ẘ": "ẘ",
  "ẍ": "ẍ",
  "ẋ": "ẋ",
  "ý": "ý",
  "ỳ": "ỳ",
  "ÿ": "ÿ",
  "ỹ": "ỹ",
  "ȳ": "ȳ",
  "ŷ": "ŷ",
  "ẏ": "ẏ",
  "ẙ": "ẙ",
  "ź": "ź",
  "ž": "ž",
  "ẑ": "ẑ",
  "ż": "ż",
  "Á": "Á",
  "À": "À",
  "Ä": "Ä",
  "Ǟ": "Ǟ",
  "Ã": "Ã",
  "Ā": "Ā",
  "Ă": "Ă",
  "Ắ": "Ắ",
  "Ằ": "Ằ",
  "Ẵ": "Ẵ",
  "Ǎ": "Ǎ",
  "Â": "Â",
  "Ấ": "Ấ",
  "Ầ": "Ầ",
  "Ẫ": "Ẫ",
  "Ȧ": "Ȧ",
  "Ǡ": "Ǡ",
  "Å": "Å",
  "Ǻ": "Ǻ",
  "Ḃ": "Ḃ",
  "Ć": "Ć",
  "Č": "Č",
  "Ĉ": "Ĉ",
  "Ċ": "Ċ",
  "Ď": "Ď",
  "Ḋ": "Ḋ",
  "É": "É",
  "È": "È",
  "Ë": "Ë",
  "Ẽ": "Ẽ",
  "Ē": "Ē",
  "Ḗ": "Ḗ",
  "Ḕ": "Ḕ",
  "Ĕ": "Ĕ",
  "Ě": "Ě",
  "Ê": "Ê",
  "Ế": "Ế",
  "Ề": "Ề",
  "Ễ": "Ễ",
  "Ė": "Ė",
  "Ḟ": "Ḟ",
  "Ǵ": "Ǵ",
  "Ḡ": "Ḡ",
  "Ğ": "Ğ",
  "Ǧ": "Ǧ",
  "Ĝ": "Ĝ",
  "Ġ": "Ġ",
  "Ḧ": "Ḧ",
  "Ȟ": "Ȟ",
  "Ĥ": "Ĥ",
  "Ḣ": "Ḣ",
  "Í": "Í",
  "Ì": "Ì",
  "Ï": "Ï",
  "Ḯ": "Ḯ",
  "Ĩ": "Ĩ",
  "Ī": "Ī",
  "Ĭ": "Ĭ",
  "Ǐ": "Ǐ",
  "Î": "Î",
  "İ": "İ",
  "Ĵ": "Ĵ",
  "Ḱ": "Ḱ",
  "Ǩ": "Ǩ",
  "Ĺ": "Ĺ",
  "Ľ": "Ľ",
  "Ḿ": "Ḿ",
  "Ṁ": "Ṁ",
  "Ń": "Ń",
  "Ǹ": "Ǹ",
  "Ñ": "Ñ",
  "Ň": "Ň",
  "Ṅ": "Ṅ",
  "Ó": "Ó",
  "Ò": "Ò",
  "Ö": "Ö",
  "Ȫ": "Ȫ",
  "Õ": "Õ",
  "Ṍ": "Ṍ",
  "Ṏ": "Ṏ",
  "Ȭ": "Ȭ",
  "Ō": "Ō",
  "Ṓ": "Ṓ",
  "Ṑ": "Ṑ",
  "Ŏ": "Ŏ",
  "Ǒ": "Ǒ",
  "Ô": "Ô",
  "Ố": "Ố",
  "Ồ": "Ồ",
  "Ỗ": "Ỗ",
  "Ȯ": "Ȯ",
  "Ȱ": "Ȱ",
  "Ő": "Ő",
  "Ṕ": "Ṕ",
  "Ṗ": "Ṗ",
  "Ŕ": "Ŕ",
  "Ř": "Ř",
  "Ṙ": "Ṙ",
  "Ś": "Ś",
  "Ṥ": "Ṥ",
  "Š": "Š",
  "Ṧ": "Ṧ",
  "Ŝ": "Ŝ",
  "Ṡ": "Ṡ",
  "Ť": "Ť",
  "Ṫ": "Ṫ",
  "Ú": "Ú",
  "Ù": "Ù",
  "Ü": "Ü",
  "Ǘ": "Ǘ",
  "Ǜ": "Ǜ",
  "Ǖ": "Ǖ",
  "Ǚ": "Ǚ",
  "Ũ": "Ũ",
  "Ṹ": "Ṹ",
  "Ū": "Ū",
  "Ṻ": "Ṻ",
  "Ŭ": "Ŭ",
  "Ǔ": "Ǔ",
  "Û": "Û",
  "Ů": "Ů",
  "Ű": "Ű",
  "Ṽ": "Ṽ",
  "Ẃ": "Ẃ",
  "Ẁ": "Ẁ",
  "Ẅ": "Ẅ",
  "Ŵ": "Ŵ",
  "Ẇ": "Ẇ",
  "Ẍ": "Ẍ",
  "Ẋ": "Ẋ",
  "Ý": "Ý",
  "Ỳ": "Ỳ",
  "Ÿ": "Ÿ",
  "Ỹ": "Ỹ",
  "Ȳ": "Ȳ",
  "Ŷ": "Ŷ",
  "Ẏ": "Ẏ",
  "Ź": "Ź",
  "Ž": "Ž",
  "Ẑ": "Ẑ",
  "Ż": "Ż",
  "ά": "ά",
  "ὰ": "ὰ",
  "ᾱ": "ᾱ",
  "ᾰ": "ᾰ",
  "έ": "έ",
  "ὲ": "ὲ",
  "ή": "ή",
  "ὴ": "ὴ",
  "ί": "ί",
  "ὶ": "ὶ",
  "ϊ": "ϊ",
  "ΐ": "ΐ",
  "ῒ": "ῒ",
  "ῑ": "ῑ",
  "ῐ": "ῐ",
  "ό": "ό",
  "ὸ": "ὸ",
  "ύ": "ύ",
  "ὺ": "ὺ",
  "ϋ": "ϋ",
  "ΰ": "ΰ",
  "ῢ": "ῢ",
  "ῡ": "ῡ",
  "ῠ": "ῠ",
  "ώ": "ώ",
  "ὼ": "ὼ",
  "Ύ": "Ύ",
  "Ὺ": "Ὺ",
  "Ϋ": "Ϋ",
  "Ῡ": "Ῡ",
  "Ῠ": "Ῠ",
  "Ώ": "Ώ",
  "Ὼ": "Ὼ"
};

/* eslint no-constant-condition:0 */

const binLeftCancellers = ["bin", "op", "open", "punct", "rel"];
const sizeRegEx = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const textRegEx = /^ *\\text/;

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */

class Parser {
  constructor(input, settings, isPreamble = false) {
    // Start in math mode
    this.mode = "math";
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings, this.mode);
    // Store the settings for use in parsing
    this.settings = settings;
    // Are we defining a preamble?
    this.isPreamble = isPreamble;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
    this.prevAtomType = "";
  }

  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text, consume = true) {
    if (this.fetch().text !== text) {
      throw new ParseError(`Expected '${text}', got '${this.fetch().text}'`, this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }

  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }

  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }

  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    // Create a group namespace for every $...$, $$...$$, \[...\].)
    // A \def is then valid only within that pair of delimiters.
    this.gullet.beginGroup();

    if (this.settings.colorIsTextColor) {
      // Use old \color behavior (same as LaTeX's \textcolor) if requested.
      // We do this within the group for the math expression, so it doesn't
      // pollute settings.macros.
      this.gullet.macros.set("\\color", "\\textcolor");
    }

    // Try to parse the input
    const parse = this.parseExpression(false);

    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF");

    if (this.isPreamble) {
      const macros = Object.create(null);
      Object.entries(this.gullet.macros.current).forEach(([key, value]) => {
        macros[key] = value;
      });
      this.gullet.endGroup();
      return macros
    }

    // The only local macro that we want to save is from \tag.
    const tag = this.gullet.macros.get("\\df@tag");

    // End the group namespace for the expression
    this.gullet.endGroup();

    if (tag) { this.gullet.macros.current["\\df@tag"] = tag; }

    return parse;
  }

  static get endOfExpression() {
    return ["}", "\\endgroup", "\\end", "\\right", "\\endtoggle", "&"];
  }

  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    // Save the next token from the current job.
    const oldToken = this.nextToken;
    this.consume();

    // Run the new job, terminating it with an excess '}'
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    const parse = this.parseExpression(false);
    this.expect("}");

    // Restore the next token from the current job.
    this.nextToken = oldToken;

    return parse;
  }

/**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   *
   * `breakOnMiddle`: \color, \over, and old styling functions work on an implicit group.
   *                  These groups end just before the usual tokens, but they also
   *                  end just before `\middle`.
   */
  parseExpression(breakOnInfix, breakOnTokenText, breakOnMiddle) {
    const body = [];
    this.prevAtomType = "";
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
      // Ignore spaces in math mode
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      const lex = this.fetch();
      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnMiddle && lex.text === "\\middle") {
        break
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      const atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
      // Keep a record of the atom type, so that op.js can set correct spacing.
      this.prevAtomType = atom.type === "atom" ? atom.family : atom.type;
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }

  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    let overIndex = -1;
    let funcName;

    for (let i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i].token);
        }
        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }

    if (overIndex !== -1 && funcName) {
      let numerNode;
      let denomNode;

      const numerBody = body.slice(0, overIndex);
      const denomBody = body.slice(overIndex + 1);

      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = { type: "ordgroup", mode: this.mode, body: numerBody };
      }

      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = { type: "ordgroup", mode: this.mode, body: denomBody };
      }

      let node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }

  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(
    name // For error reporting.
  ) {
    const symbolToken = this.fetch();
    const symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces(); // ignore spaces before sup/subscript argument
    const group = this.parseGroup(name);

    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }

    return group;
  }

  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text) {
    const textordArray = [];

    for (let i = 0; i < text.length; i++) {
      textordArray.push({ type: "textord", mode: "text", text: text[i] });
    }

    const textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };

    const colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };

    return colorNode;
  }

  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    const base = this.parseGroup("atom", breakOnTokenText);

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
      return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    let superscript;
    let subscript;
    while (true) {
      // Guaranteed in math mode, so eat any spaces first.
      this.consumeSpaces();

      // Lex the first token
      const lex = this.fetch();

      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        // We got a limit control
        if (base && base.type === "op") {
          const limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        // We got a superscript start
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        // We got a subscript start
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        // We got a prime
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        const prime = { type: "textord", mode: this.mode, text: "\\prime" };

        // Many primes can be grouped together, so we handle this here
        const primes = [prime];
        this.consume();
        // Keep lexing tokens until we get something that's not a prime
        while (this.fetch().text === "'") {
          // For each one, add another prime to the list
          primes.push(prime);
          this.consume();
        }
        // If there's a superscript following the primes, combine that
        // superscript in with the primes.
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        // Put everything into an ordgroup as the superscript
        superscript = { type: "ordgroup", mode: this.mode, body: primes };
      } else if (uSubsAndSups[lex.text]) {
        // A Unicode subscript or superscript character.
        // We treat these similarly to the unicode-math package.
        // So we render a string of Unicode (sub|super)scripts the
        // same as a (sub|super)script of regular characters.
        const isSub = unicodeSubRegEx.test(lex.text);
        const subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        // Continue fetching tokens to fill out the group.
        while (true) {
          const token = this.fetch().text;
          if (!(uSubsAndSups[token])) { break }
          if (unicodeSubRegEx.test(token) !== isSub) { break }
          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        }
        // Now create a (sub|super)script.
        const body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = { type: "ordgroup", mode: "math", body };
        } else {
          superscript = { type: "ordgroup", mode: "math", body };
        }
      } else {
        // If it wasn't ^, _, a Unicode (sub|super)script, or ', stop parsing super/subscripts
        break;
      }
    }

    if (superscript || subscript) {
      if (base && base.type === "multiscript" && !base.postscripts) {
        // base is the result of a \prescript function.
        // Write the sub- & superscripts into the multiscript element.
        base.postscripts = { sup: superscript, sub: subscript };
        return base
      } else {
        // We got either a superscript or subscript, create a supsub
        const isFollowedByDelimiter = (!base || base.type !== "op" && base.type !== "operatorname")
          ? undefined
          : isDelimiter(this.nextToken.text);
        return {
          type: "supsub",
          mode: this.mode,
          base: base,
          sup: superscript,
          sub: subscript,
          isFollowedByDelimiter
        }
      }
    } else {
      // Otherwise return the original body
      return base;
    }
  }

  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(
    breakOnTokenText,
    name // For determining its context
  ) {
    const token = this.fetch();
    const func = token.text;
    const funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume(); // consume command token

    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError(
        "Got function '" + func + "' with no arguments" + (name ? " as " + name : ""),
        token
      );
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }

    const prevAtomType = this.prevAtomType;
    const { args, optArgs } = this.parseArguments(func, funcData);
    this.prevAtomType = prevAtomType;
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }

  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    const context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    const func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError(`No function handler for ${name}`);
    }
  }

  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(
    func, // Should look like "\name" or "\begin{name}".
    funcData
  ) {
    const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return { args: [], optArgs: [] };
    }

    const args = [];
    const optArgs = [];

    for (let i = 0; i < totalArgs; i++) {
      let argType = funcData.argTypes && funcData.argTypes[i];
      const isOptional = i < funcData.numOptionalArgs;

      if (
        (funcData.primitive && argType == null) ||
        // \sqrt expands into primitive if optional argument doesn't exist
        (funcData.type === "sqrt" && i === 1 && optArgs[0] == null)
      ) {
        argType = "primitive";
      }

      const arg = this.parseGroupOfType(`argument to '${func}'`, argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        // should be unreachable
        throw new ParseError("Null argument, please report this as a bug");
      }
    }

    return { args, optArgs };
  }

  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        // hbox argument type wraps the argument in the equivalent of
        // \hbox, which is like \text but switching to \textstyle size.
        const group = this.parseArgumentGroup(optional, "text");
        return group != null
          ? {
            type: "styling",
            mode: group.mode,
            body: [group],
            scriptLevel: "text" // simulate \textstyle
          }
          : null;
      }
      case "raw": {
        const token = this.parseStringGroup("raw", optional);
        return token != null
          ? {
            type: "raw",
            mode: "text",
            string: token.text
          }
          : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        const group = this.parseGroup(name);
        if (group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return group;
      }
      case "original":
      case null:
      case undefined:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }

  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (true) {
      const ch = this.fetch().text;
      // \ufe0e is the Unicode variation selector to supress emoji. Ignore it.
      if (ch === " " || ch === "\u00a0" || ch === "\ufe0e") {
        this.consume();
      } else {
        break
      }
    }
  }

  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(
    modeName, // Used to describe the mode in error messages.
    optional
  ) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume(); // consume the end of the argument
    argToken.text = str;
    return argToken;
  }

  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(
    regex,
    modeName // Used to describe the mode in error messages.
  ) {
    const firstToken = this.fetch();
    let lastToken = firstToken;
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }

  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    let res;
    let isBlank = false;
    // don't expand before parseStringGroup
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      // Because we've tested for what is !optional, this block won't
      // affect \kern, \hspace, etc. It will capture the mandatory arguments
      // to \genfrac and \above.
      res.text = "0pt"; // Enable \above{}
      isBlank = true; // This is here specifically for \genfrac
    }
    const match = sizeRegEx.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }

  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13); // active character
    this.gullet.lexer.setCatcode("~", 12); // other character
    const res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14); // comment character
    this.gullet.lexer.setCatcode("~", 13); // active character
    if (res == null) {
      return null;
    }
    // hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.
    let url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    url = res.text.replace(/{\u2044}/g, "/");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }

  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    const outerMode = this.mode;
    if (mode) {
      // Switch to specified mode
      this.switchMode(mode);
    }

    this.gullet.beginGroup();
    const expression = this.parseExpression(false, "EOF");
    // TODO: find an alternative way to denote the end
    this.expect("EOF"); // expect the end of the argument
    this.gullet.endGroup();
    const result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };

    if (mode) {
      // Switch mode back
      this.switchMode(outerMode);
    }
    return result;
  }

  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(
    name, // For error reporting.
    breakOnTokenText
  ) {
    const firstToken = this.fetch();
    const text = firstToken.text;

    let result;
    // Try to parse an open brace or \begingroup
    if (text === "{" || text === "\\begingroup" || text === "\\toggle") {
      this.consume();
      const groupEnd = text === "{"
        ? "}"
        : text === "\\begingroup"
        ? "\\endgroup"
        : "\\endtoggle";

      this.gullet.beginGroup();
      // If we get a brace, parse an expression
      const expression = this.parseExpression(false, groupEnd);
      const lastToken = this.fetch();
      this.expect(groupEnd); // Check that we got a matching closing brace
      this.gullet.endGroup();
      result = {
        type: (lastToken.text === "\\endtoggle" ? "toggle" : "ordgroup"),
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/
        semisimple: text === "\\begingroup" || undefined
      };
    } else {
      // If there exists a function with this name, parse the function.
      // Otherwise, just return a nucleus
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text[0] === "\\" &&
          !Object.prototype.hasOwnProperty.call(implicitCommands, text )) {
        result = this.formatUnsupportedCmd(text);
        this.consume();
      }
    }
    return result;
  }

  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    let n = group.length - 1;
    for (let i = 0; i < n; ++i) {
      const a = group[i];
      const v = a.text;
      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }
      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }

  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    const nucleus = this.fetch();
    let text = nucleus.text;

    if (/^\\verb[^a-zA-Z]/.test(text)) {
      this.consume();
      let arg = text.slice(5);
      const star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      // Lexer's tokenRegex is constructed to always have matching
      // first/last characters.
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
      }
      arg = arg.slice(1, -1); // remove first and last char
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    // At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.
    if (Object.prototype.hasOwnProperty.call(unicodeSymbols, text[0]) &&
      this.mode === "math" && !symbols[this.mode][text[0]]) {
      // This behavior is not strict (XeTeX-compatible) in math mode.
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Accented Unicode text character "${text[0]}" used in ` + `math mode`,
          nucleus
        );
      }
      text = unicodeSymbols[text[0]] + text.slice(1);
    }
    // Strip off any combining characters
    const match = this.mode === "math"
      ? combiningDiacriticalMarksEndRegex.exec(text)
      : null;
    if (match) {
      text = text.substring(0, match.index);
      if (text === "i") {
        text = "\u0131"; // dotless i, in math and text mode
      } else if (text === "j") {
        text = "\u0237"; // dotless j, in math and text mode
      }
    }
    // Recognize base symbol
    let symbol;
    if (symbols[this.mode][text]) {
      let group = symbols[this.mode][text].group;
      if (group === "bin" && binLeftCancellers.includes(this.prevAtomType)) {
        // Change from a binary operator to a unary (prefix) operator
        group = "open";
      }
      const loc = SourceLocation.range(nucleus);
      let s;
      if (Object.prototype.hasOwnProperty.call(ATOMS, group )) {
        const family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text
        };
        if ((family === "rel" || family === "bin") && this.prevAtomType === "text") {
          if (textRegEx.test(loc.lexer.input.slice(loc.end))) {
            s.needsSpacing = true;  // Fix a MathML bug.
          }
        }
      } else {
        if (asciiFromScript[text]) {
          // Unicode 14 disambiguates chancery from roundhand.
          // See https://www.unicode.org/charts/PDF/U1D400.pdf
          this.consume();
          const nextCode = this.fetch().text.charCodeAt(0);
          // mathcal is Temml default. Use mathscript if called for.
          const font = nextCode === 0xfe01 ? "mathscr" : "mathcal";
          if (nextCode === 0xfe00 || nextCode === 0xfe01) { this.consume(); }
          return {
            type: "font",
            mode: "math",
            font,
            body: { type: "mathord", mode: "math", loc, text: asciiFromScript[text] }
          }
        }
        // Default ord character. No disambiguation necessary.
        s = {
          type: group,
          mode: this.mode,
          loc,
          text
        };
      }
      symbol = s;
    } else if (text.charCodeAt(0) >= 0x80 || combiningDiacriticalMarksEndRegex.exec(text)) {
      // no symbol for e.g. ^
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Unicode text character "${text[0]}" used in math mode`, nucleus)
      }
      // All nonmathematical Unicode characters are rendered as if they
      // are in text mode (wrapped in \text) because that's what it
      // takes to render them in LaTeX.
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text
      };
    } else {
      return null; // EOF, ^, _, {, }, etc.
    }
    this.consume();
    // Transform combining characters into accents
    if (match) {
      for (let i = 0; i < match[0].length; i++) {
        const accent = match[0][i];
        if (!unicodeAccents[accent]) {
          throw new ParseError(`Unknown accent ' ${accent}'`, nucleus);
        }
        const command = unicodeAccents[accent][this.mode] ||
                        unicodeAccents[accent].text;
        if (!command) {
          throw new ParseError(`Accent ${accent} unsupported in ${this.mode} mode`, nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          base: symbol
        };
      }
    }
    return symbol;
  }
}

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
const parseTree = function(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(toParse, settings);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];

  let tree = parser.parse();

  // LaTeX ignores a \tag placed outside an AMS environment.
  if (!(tree.length > 0 &&  tree[0].type && tree[0].type === "array" && tree[0].addEqnNum)) {
    // If the input used \tag, it will set the \df@tag macro to the tag.
    // In this case, we separately parse the tag and wrap the tree.
    if (parser.gullet.macros.get("\\df@tag")) {
      if (!settings.displayMode) {
        throw new ParseError("\\tag works only in display mode")
      }
      parser.gullet.feed("\\df@tag");
      tree = [
        {
          type: "tag",
          mode: "text",
          body: tree,
          tag: parser.parse()
        }
      ];
    }
  }

  return tree
};

/**
 * This file contains information about the style that the mathmlBuilder carries
 * around with it. Data is held in an `Style` object, and when
 * recursing, a new `Style` object can be created with the `.with*` functions.
 */

const subOrSupLevel = [2, 2, 3, 3];

/**
 * This is the main Style class. It contains the current style.level, color, and font.
 *
 * Style objects should not be modified. To create a new Style with
 * different properties, call a `.with*` method.
 */
class Style {
  constructor(data) {
    // Style.level can be 0 | 1 | 2 | 3, which correspond to
    //       displaystyle, textstyle, scriptstyle, and scriptscriptstyle.
    // style.level usually does not directly set MathML's script level. MathML does that itself.
    // However, Chromium does not stop shrinking after scriptscriptstyle, so we do explicitly
    // set a scriptlevel attribute in those conditions.
    // We also use style.level to track math style so that we can get the correct
    // scriptlevel when needed in supsub.js, mathchoice.js, or for dimensions in em.
    this.level = data.level;
    this.color = data.color;  // string | void
    // A font family applies to a group of fonts (i.e. SansSerif), while a font
    // represents a specific font (i.e. SansSerif Bold).
    // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
    this.font = data.font || "";                // string
    this.fontFamily = data.fontFamily || "";    // string
    this.fontSize = data.fontSize || 1.0;       // number
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.maxSize = data.maxSize;                // [number, number]
  }

  /**
   * Returns a new style object with the same properties as "this".  Properties
   * from "extension" will be copied to the new style object.
   */
  extend(extension) {
    const data = {
      level: this.level,
      color: this.color,
      font: this.font,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize
    };

    for (const key in extension) {
      if (Object.prototype.hasOwnProperty.call(extension, key)) {
        data[key] = extension[key];
      }
    }

    return new Style(data);
  }

  withLevel(n) {
    return this.extend({
      level: n
    });
  }

  incrementLevel() {
    return this.extend({
      level: Math.min(this.level + 1, 3)
    });
  }

  inSubOrSup() {
    return this.extend({
      level: subOrSupLevel[this.level]
    })
  }

  /**
   * Create a new style object with the given color.
   */
  withColor(color) {
    return this.extend({
      color: color
    });
  }

  /**
   * Creates a new style object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }

  /**
   * Create a new style objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font size
   */
  withFontSize(num) {
    return this.extend({
      fontSize: num
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }

  /**
   * Gets the CSS color of the current style object
   */
  getColor() {
    return this.color;
  }
}

/* Temml Post Process
 * Populate the text contents of each \ref & \eqref
 *
 * As with other Temml code, this file is released under terms of the MIT license.
 * https://mit-license.org/
 */

const version = "0.11.02";

function postProcess(block) {
  const labelMap = {};
  let i = 0;

  // Get a collection of the parents of each \tag & auto-numbered equation
  const amsEqns = document.getElementsByClassName('tml-eqn');
  for (let parent of amsEqns) {
    // AMS automatically numbered equation.
    // Assign an id.
    i += 1;
    parent.setAttribute("id", "tml-eqn-" + String(i));
    // No need to write a number into the text content of the element.
    // A CSS counter has done that even if this postProcess() function is not used.

    // Find any \label that refers to an AMS automatic eqn number.
    while (true) {
      if (parent.tagName === "mtable") { break }
      const labels = parent.getElementsByClassName("tml-label");
      if (labels.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = String(i);
        break
      } else {
        parent = parent.parentElement;
      }
    }
  }

  // Find \labels associated with \tag
  const taggedEqns = document.getElementsByClassName('tml-tageqn');
  for (const parent of taggedEqns) {
    const labels = parent.getElementsByClassName("tml-label");
    if (labels.length > 0) {
      const tags = parent.getElementsByClassName("tml-tag");
      if (tags.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = tags[0].textContent;
      }
    }
  }

  // Populate \ref & \eqref text content
  const refs = block.getElementsByClassName("tml-ref");
  [...refs].forEach(ref => {
    const attr = ref.getAttribute("href");
    let str = labelMap[attr.slice(1)];
    if (ref.className.indexOf("tml-eqref") === -1) {
      // \ref. Omit parens.
      str = str.replace(/^\(/, "");
      str = str.replace(/\)$/, "");
    } else {
      // \eqref. Include parens
      if (str.charAt(0) !== "(") { str = "(" + str; }
      if (str.slice(-1) !== ")") { str =  str + ")"; }
    }
    const mtext = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mtext");
    mtext.appendChild(document.createTextNode(str));
    const math =  document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
    math.appendChild(mtext);
    ref.textContent = '';
    ref.appendChild(math);
  });
}

const findEndOfMath = function(delimiter, text, startIndex) {
  // Adapted from
  // https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx
  let index = startIndex;
  let braceLevel = 0;

  const delimLength = delimiter.length;

  while (index < text.length) {
    const character = text[index];

    if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter) {
      return index;
    } else if (character === "\\") {
      index++;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    }

    index++;
  }

  return -1;
};

const escapeRegex = function(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};

const amsRegex = /^\\(?:begin|(?:eq)?ref){/;

const splitAtDelimiters = function(text, delimiters) {
  let index;
  const data = [];

  const regexLeft = new RegExp(
    "(" + delimiters.map((x) => escapeRegex(x.left)).join("|") + ")"
  );

  while (true) {
    index = text.search(regexLeft);
    if (index === -1) {
      break;
    }
    if (index > 0) {
      data.push({
        type: "text",
        data: text.slice(0, index)
      });
      text = text.slice(index); // now text starts with delimiter
    }
    // ... so this always succeeds:
    const i = delimiters.findIndex((delim) => text.startsWith(delim.left));
    index = findEndOfMath(delimiters[i].right, text, delimiters[i].left.length);
    if (index === -1) {
      break;
    }
    const rawData = text.slice(0, index + delimiters[i].right.length);
    const math = amsRegex.test(rawData)
      ? rawData
      : text.slice(delimiters[i].left.length, index);
    data.push({
      type: "math",
      data: math,
      rawData,
      display: delimiters[i].display
    });
    text = text.slice(index + delimiters[i].right.length);
  }

  if (text !== "") {
    data.push({
      type: "text",
      data: text
    });
  }

  return data;
};

const defaultDelimiters = [
  { left: "$$", right: "$$", display: true },
  { left: "\\(", right: "\\)", display: false },
  // LaTeX uses $…$, but it ruins the display of normal `$` in text:
  // {left: "$", right: "$", display: false},
  // $ must come after $$

  // Render AMS environments even if outside $$…$$ delimiters.
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  // Ditto \ref & \eqref
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false },

  { left: "\\[", right: "\\]", display: true }
];

const firstDraftDelimiters = {
  "$": [
         { left: "$$", right: "$$", display: true },
         { left: "$`", right: "`$", display: false },
         { left: "$", right: "$", display: false }
  ],
  "(": [
    { left: "\\[", right: "\\]", display: true },
    { left: "\\(", right: "\\)", display: false }
  ]
};

const amsDelimiters = [
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false }
];

const delimitersFromKey = key => {
  if (key === "$" || key === "(") {
    return firstDraftDelimiters[key];
  } else if (key === "$+" || key === "(+") {
    const firstDraft = firstDraftDelimiters[key.slice(0, 1)];
    return firstDraft.concat(amsDelimiters)
  } else if (key === "ams") {
    return amsDelimiters
  } else if (key === "all") {
    return (firstDraftDelimiters["("]).concat(firstDraftDelimiters["$"]).concat(amsDelimiters)
  } else {
    return defaultDelimiters
  }
};

/* Note: optionsCopy is mutated by this method. If it is ever exposed in the
 * API, we should copy it before mutating.
 */
const renderMathInText = function(text, optionsCopy) {
  const data = splitAtDelimiters(text, optionsCopy.delimiters);
  if (data.length === 1 && data[0].type === "text") {
    // There is no formula in the text.
    // Let's return null which means there is no need to replace
    // the current text node with a new one.
    return null;
  }

  const fragment = document.createDocumentFragment();

  for (let i = 0; i < data.length; i++) {
    if (data[i].type === "text") {
      fragment.appendChild(document.createTextNode(data[i].data));
    } else {
      const span = document.createElement("span");
      let math = data[i].data;
      // Override any display mode defined in the settings with that
      // defined by the text itself
      optionsCopy.displayMode = data[i].display;
      try {
        if (optionsCopy.preProcess) {
          math = optionsCopy.preProcess(math);
        }
        // Importing render() from temml.js would be a circular dependency.
        // So call the global version.
        // eslint-disable-next-line no-undef
        temml.render(math, span, optionsCopy);
      } catch (e) {
        if (!(e instanceof ParseError)) {
          throw e;
        }
        optionsCopy.errorCallback(
          "Temml auto-render: Failed to parse `" + data[i].data + "` with ",
          e
        );
        fragment.appendChild(document.createTextNode(data[i].rawData));
        continue;
      }
      fragment.appendChild(span);
    }
  }

  return fragment;
};

const renderElem = function(elem, optionsCopy) {
  for (let i = 0; i < elem.childNodes.length; i++) {
    const childNode = elem.childNodes[i];
    if (childNode.nodeType === 3) {
      // Text node
      const frag = renderMathInText(childNode.textContent, optionsCopy);
      if (frag) {
        i += frag.childNodes.length - 1;
        elem.replaceChild(frag, childNode);
      }
    } else if (childNode.nodeType === 1) {
      // Element node
      const className = " " + childNode.className + " ";
      const shouldRender =
        optionsCopy.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 &&
        optionsCopy.ignoredClasses.every((x) => className.indexOf(" " + x + " ") === -1);

      if (shouldRender) {
        renderElem(childNode, optionsCopy);
      }
    }
    // Otherwise, it's something else, and ignore it.
  }
};

const renderMathInElement = function(elem, options) {
  if (!elem) {
    throw new Error("No element provided to render");
  }

  const optionsCopy = {};

  // Object.assign(optionsCopy, option)
  for (const option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      optionsCopy[option] = options[option];
    }
  }

  if (optionsCopy.fences) {
    optionsCopy.delimiters = delimitersFromKey(optionsCopy.fences);
  } else {
    optionsCopy.delimiters = optionsCopy.delimiters || defaultDelimiters;
  }
  optionsCopy.ignoredTags = optionsCopy.ignoredTags || [
    "script",
    "noscript",
    "style",
    "textarea",
    "pre",
    "code",
    "option"
  ];
  optionsCopy.ignoredClasses = optionsCopy.ignoredClasses || [];
  // eslint-disable-next-line no-console
  optionsCopy.errorCallback = optionsCopy.errorCallback || console.error;

  // Enable sharing of global macros defined via `\gdef` between different
  // math elements within a single call to `renderMathInElement`.
  optionsCopy.macros = optionsCopy.macros || {};

  renderElem(elem, optionsCopy);
  postProcess(elem);
};

/* eslint no-console:0 */
/**
 * This is the main entry point for Temml. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from Temml are
 * errors in the expression, or errors in javascript handling.
 */


/**
 * @type {import('./temml').render}
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
let render = function(expression, baseNode, options = {}) {
  baseNode.textContent = "";
  const alreadyInMathElement = baseNode.tagName.toLowerCase() === "math";
  if (alreadyInMathElement) { options.wrap = "none"; }
  const math = renderToMathMLTree(expression, options);
  if (alreadyInMathElement) {
    // The <math> element already exists. Populate it.
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else if (math.children.length > 1) {
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else {
    baseNode.appendChild(math.toNode());
  }
};

// Temml's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" &&
      console.warn(
        "Warning: Temml doesn't work in quirks mode. Make sure your " +
          "website has a suitable doctype."
      );

    render = function() {
      throw new ParseError("Temml doesn't work in quirks mode.");
    };
  }
}

/**
 * @type {import('./temml').renderToString}
 * Parse and build an expression, and return the markup for that.
 */
const renderToString = function(expression, options) {
  const markup = renderToMathMLTree(expression, options).toMarkup();
  return markup;
};

/**
 * @type {import('./temml').generateParseTree}
 * Parse an expression and return the parse tree.
 */
const generateParseTree = function(expression, options) {
  const settings = new Settings(options);
  return parseTree(expression, settings);
};

/**
 * @type {import('./temml').definePreamble}
 * Take an expression which contains a preamble.
 * Parse it and return the macros.
 */
const definePreamble = function(expression, options) {
  const settings = new Settings(options);
  settings.macros = {};
  if (!(typeof expression === "string" || expression instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(expression, settings, true);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];
  const macros = parser.parse();
  return macros
};

/**
 * If the given error is a Temml ParseError,
 * renders the invalid LaTeX as a span with hover title giving the Temml
 * error message.  Otherwise, simply throws the error.
 */
const renderError = function(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }
  const node = new Span(["temml-error"], [new TextNode$1(expression + "\n\n" + error.toString())]);
  node.style.color = options.errorColor;
  node.style.whiteSpace = "pre-line";
  return node;
};

/**
 * @type {import('./temml').renderToMathMLTree}
 * Generates and returns the Temml build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */
const renderToMathMLTree = function(expression, options) {
  const settings = new Settings(options);
  try {
    const tree = parseTree(expression, settings);
    const style = new Style({
      level: settings.displayMode ? StyleLevel.DISPLAY : StyleLevel.TEXT,
      maxSize: settings.maxSize
    });
    return buildMathML(tree, expression, style, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};

/** @type {import('./temml').default} */
var temml$1 = {
  /**
   * Current Temml version
   */
  version: version,
  /**
   * Renders the given LaTeX into MathML, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into MathML string,
   * for sending to the client.
   */
  renderToString,
  /**
   * Finds all the math delimiters in a given element of a running HTML document
   * and converts the contents of each instance into a <math> element.
   */
  renderMathInElement,
  /**
   * Post-process an entire HTML block.
   * Writes AMS auto-numbers and implements \ref{}.
   * Typcally called once, after a loop has rendered many individual spans.
   */
  postProcess,
  /**
   * Temml error, usually during parsing.
   */
  ParseError,
  /**
   * Creates a set of macros with document-wide scope.
   */
  definePreamble,
  /**
   * Parses the given LaTeX into Temml's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into a MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToMathMLTree: renderToMathMLTree,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro
};

module.exports = temml$1;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
var defuddle_1 = __webpack_require__(/*! ./defuddle */ 628);
Object.defineProperty(exports, "Defuddle", ({ enumerable: true, get: function () { return defuddle_1.Defuddle; } }));

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsRUFBRSxlQUFlLEdBQUcsR0FBRyxHQUFHLGNBQWMsYUFBYSxzQ0FBc0MsU0FBUyxpRUFBaUUsV0FBVyxpQ0FBaUMsYUFBYSxNQUFNLHlDQUF5QywwQ0FBMEMsMEJBQTBCLE1BQU0sZ0JBQWdCLFVBQVUsY0FBYyxHQUFHLEVBQUUsR0FBRyxPQUFPLDJCQUEyQixhQUFhLGtCQUFrQixNQUFNLG1CQUFtQixHQUFHLFdBQVcsR0FBRyxFQUFFLEdBQUcsSUFBSSxTQUFTLEdBQUcsb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUksb0JBQW9CLElBQUkscUJBQXFCLElBQUksaUpBQWlKLElBQUksSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsSUFBSSw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsT0FBTyw0QkFBNEIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsSUFBSSw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsSUFBSSw2QkFBNkIsSUFBSSw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsSUFBSSw2QkFBNkIsSUFBSSw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsSUFBSSw2QkFBNkIsS0FBSyw2QkFBNkIsSUFBSSw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsSUFBSSw2QkFBNkIsS0FBSyw2QkFBNkIsTUFBTSw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw2QkFBNkIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsSUFBSSw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsSUFBSSw4QkFBOEIsSUFBSSw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsSUFBSSw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsS0FBSyw4QkFBOEIsSUFBSSw4QkFBOEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsSUFBSSw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyxrQ0FBa0MsS0FBSyxrQ0FBa0MsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyxrQ0FBa0MsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSyxtQ0FBbUMsS0FBSyw0QkFBNEIsS0FBSyw0QkFBNEIsS0FBSywrQkFBK0IsS0FBSyw0QkFBNEIs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QzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVB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QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLDRDQUE0QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQyxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztB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c0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLGdCQUFnQjtBQUN0RCxzQ0FBc0MsZ0JBQWdCO0FBQ3RELHNDQUFzQyxnQkFBZ0I7QUFDdEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDLFVBQVU7QUFDaEQsc0NBQXNDO0FBQ3RDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scURBQXFELFdBQVc7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QixHQUFHLGlCQUFpQjtBQUN4RjtBQUNBO0FBQ0Esd0RBQXdELCtCQUErQjtBQUN2RjtBQUNBLE1BQU0saUJBQWlCO0FBQ3ZCLEtBQUssd0JBQXdCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQSxLQUFLLCtCQUErQjtBQUNwQztBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSx5QkFBeUIsSUFBSTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFNBQVMsY0FBYztBQUN2QixNQUFNO0FBQ04sU0FBUyxxQkFBcUI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0EseUJBQXlCLDBDQUEwQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsYUFBYTtBQUMzQixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QSxpQ0FBaUMsbUNBQW1DO0FBQ3BFLElBQUk7QUFDSjtBQUNBLGlDQUFpQyxtQ0FBbUM7QUFDcEUsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O1VDM2xjQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQSw0REFBc0M7QUFBN0IsNkdBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vRGVmdWRkbGUvLi9zcmMvbWF0aC50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy9tYXRobWwtdG8tbGF0ZXgvZGlzdC9idW5kbGUubWluLmpzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL21ldGFkYXRhLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2RlZnVkZGxlLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy90ZW1tbC9kaXN0L3RlbW1sLmNqcyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHRoaXMsICgpID0+IHtcbnJldHVybiAiLCJpbXBvcnQgeyBNYXRoTUxUb0xhVGVYIH0gZnJvbSAnbWF0aG1sLXRvLWxhdGV4JztcbmltcG9ydCAqIGFzIHRlbW1sIGZyb20gJ3RlbW1sJztcblxuZXhwb3J0IGludGVyZmFjZSBNYXRoRGF0YSB7XG5cdG1hdGhtbDogc3RyaW5nO1xuXHRsYXRleDogc3RyaW5nIHwgbnVsbDtcblx0aXNCbG9jazogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGdldE1hdGhNTEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogTWF0aERhdGEgfCBudWxsID0+IHtcblx0Y29uc29sZS5sb2coJ2dldE1hdGhNTEZyb21FbGVtZW50IGlucHV0OicsIGVsLm91dGVySFRNTCk7XG5cblx0Ly8gMS4gRGlyZWN0IE1hdGhNTCBjb250ZW50XG5cdGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdtYXRoJykge1xuXHRcdGNvbnN0IGlzQmxvY2sgPSBlbC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcblx0XHRjb25zb2xlLmxvZygnRGlyZWN0IE1hdGhNTCAtIGlzQmxvY2s6JywgaXNCbG9jayk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG1hdGhtbDogZWwub3V0ZXJIVE1MLFxuXHRcdFx0bGF0ZXg6IGVsLmdldEF0dHJpYnV0ZSgnYWx0dGV4dCcpIHx8IG51bGwsXG5cdFx0XHRpc0Jsb2NrXG5cdFx0fTtcblx0fVxuXG5cdC8vIDIuIE1hdGhNTCBpbiBkYXRhLW1hdGhtbCBhdHRyaWJ1dGVcblx0Y29uc3QgbWF0aG1sU3RyID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1hdGhtbCcpO1xuXHRpZiAobWF0aG1sU3RyKSB7XG5cdFx0Y29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdHRlbXBEaXYuaW5uZXJIVE1MID0gbWF0aG1sU3RyO1xuXHRcdGNvbnN0IG1hdGhFbGVtZW50ID0gdGVtcERpdi5xdWVyeVNlbGVjdG9yKCdtYXRoJyk7XG5cdFx0aWYgKG1hdGhFbGVtZW50KSB7XG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gbWF0aEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNwbGF5JykgPT09ICdibG9jayc7XG5cdFx0XHRjb25zb2xlLmxvZygnZGF0YS1tYXRobWwgLSBpc0Jsb2NrOicsIGlzQmxvY2spO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF0aG1sOiBtYXRoRWxlbWVudC5vdXRlckhUTUwsXG5cdFx0XHRcdGxhdGV4OiBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FsdHRleHQnKSB8fCBudWxsLFxuXHRcdFx0XHRpc0Jsb2NrXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8vIDMuIE1hdGhKYXggYXNzaXN0aXZlIE1hdGhNTFxuXHRjb25zdCBhc3Npc3RpdmVNbWxDb250YWluZXIgPSBlbC5xdWVyeVNlbGVjdG9yKCcuTUpYX0Fzc2lzdGl2ZV9NYXRoTUwsIG1qeC1hc3Npc3RpdmUtbW1sJyk7XG5cdGNvbnNvbGUubG9nKCdGb3VuZCBhc3Npc3RpdmVNbWxDb250YWluZXI6JywgYXNzaXN0aXZlTW1sQ29udGFpbmVyPy5vdXRlckhUTUwpO1xuXHRcblx0aWYgKGFzc2lzdGl2ZU1tbENvbnRhaW5lcikge1xuXHRcdGNvbnN0IG1hdGhFbGVtZW50ID0gYXNzaXN0aXZlTW1sQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRjb25zb2xlLmxvZygnRm91bmQgbWF0aEVsZW1lbnQ6JywgbWF0aEVsZW1lbnQ/Lm91dGVySFRNTCk7XG5cdFx0XG5cdFx0aWYgKG1hdGhFbGVtZW50KSB7XG5cdFx0XHQvLyBDaGVjayBib3RoIHRoZSBtYXRoIGVsZW1lbnQgYW5kIGNvbnRhaW5lciBmb3IgZGlzcGxheSBtb2RlXG5cdFx0XHRjb25zdCBtYXRoRGlzcGxheUF0dHIgPSBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKTtcblx0XHRcdGNvbnN0IGNvbnRhaW5lckRpc3BsYXlBdHRyID0gYXNzaXN0aXZlTW1sQ29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpO1xuXHRcdFx0Y29uc29sZS5sb2coJ01hdGggZGlzcGxheSBhdHRyaWJ1dGU6JywgbWF0aERpc3BsYXlBdHRyKTtcblx0XHRcdGNvbnNvbGUubG9nKCdDb250YWluZXIgZGlzcGxheSBhdHRyaWJ1dGU6JywgY29udGFpbmVyRGlzcGxheUF0dHIpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gbWF0aERpc3BsYXlBdHRyID09PSAnYmxvY2snIHx8IGNvbnRhaW5lckRpc3BsYXlBdHRyID09PSAnYmxvY2snO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbmFsIGlzQmxvY2sgZGV0ZXJtaW5hdGlvbjonLCBpc0Jsb2NrKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF0aG1sOiBtYXRoRWxlbWVudC5vdXRlckhUTUwsXG5cdFx0XHRcdGxhdGV4OiBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FsdHRleHQnKSB8fCBudWxsLFxuXHRcdFx0XHRpc0Jsb2NrXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8vIDQuIEthVGVYIE1hdGhNTFxuXHRjb25zdCBrYXRleE1hdGhtbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5rYXRleC1tYXRobWwgbWF0aCcpO1xuXHRpZiAoa2F0ZXhNYXRobWwpIHtcblx0XHRjb25zb2xlLmxvZygnS2FUZVggTWF0aE1MIGZvdW5kJyk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG1hdGhtbDoga2F0ZXhNYXRobWwub3V0ZXJIVE1MLFxuXHRcdFx0bGF0ZXg6IG51bGwsIC8vIFdlJ2xsIGdldCBMYVRlWCBzZXBhcmF0ZWx5IGZvciBLYVRlWFxuXHRcdFx0aXNCbG9jazogZmFsc2UgLy8gV2UnbGwgZGV0ZXJtaW5lIHRoaXMgZnJvbSBjb250YWluZXJcblx0XHR9O1xuXHR9XG5cblx0Y29uc29sZS5sb2coJ05vIE1hdGhNTCBmb3VuZCcpO1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRMYXRleEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogc3RyaW5nIHwgbnVsbCA9PiB7XG5cdC8vIERpcmVjdCBkYXRhLWxhdGV4IGF0dHJpYnV0ZVxuXHRjb25zdCBkYXRhTGF0ZXggPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGF0ZXgnKTtcblx0aWYgKGRhdGFMYXRleCkge1xuXHRcdHJldHVybiBkYXRhTGF0ZXg7XG5cdH1cblxuXHQvLyBXb3JkUHJlc3MgTGFUZVggaW1hZ2VzXG5cdGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXRleCcpKSB7XG5cdFx0Ly8gVHJ5IGFsdCB0ZXh0IGZpcnN0IGFzIGl0J3MgY2xlYW5lclxuXHRcdGNvbnN0IGFsdExhdGV4ID0gZWwuZ2V0QXR0cmlidXRlKCdhbHQnKTtcblx0XHRpZiAoYWx0TGF0ZXgpIHtcblx0XHRcdHJldHVybiBhbHRMYXRleDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRmFsbGJhY2sgdG8gZXh0cmFjdGluZyBmcm9tIFVSTFxuXHRcdGNvbnN0IHNyYyA9IGVsLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goL2xhdGV4XFwucGhwXFw/bGF0ZXg9KFteJl0rKS8pO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcKy9nLCAnICcpIC8vIFJlcGxhY2UgKyB3aXRoIHNwYWNlc1xuXHRcdFx0XHRcdC5yZXBsYWNlKC8lNUMvZywgJ1xcXFwnKTsgLy8gRml4IGVzY2FwZWQgYmFja3NsYXNoZXNcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBMYVRlWCBpbiBhbm5vdGF0aW9uXG5cdGNvbnN0IGFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCdhbm5vdGF0aW9uW2VuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIl0nKTtcblx0aWYgKGFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0cmV0dXJuIGFubm90YXRpb24udGV4dENvbnRlbnQudHJpbSgpO1xuXHR9XG5cblx0Ly8gS2FUZVggZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLmthdGV4JykpIHtcblx0XHQvLyBUcnkga2F0ZXgtbWF0aG1sIGFubm90YXRpb24gZmlyc3Rcblx0XHRjb25zdCBrYXRleEFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCcua2F0ZXgtbWF0aG1sIGFubm90YXRpb25bZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiXScpO1xuXHRcdGlmIChrYXRleEFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0XHRyZXR1cm4ga2F0ZXhBbm5vdGF0aW9uLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHR9XG5cdH1cblxuXHQvLyBNYXRoSmF4IHNjcmlwdHNcblx0Ly8gSW1wb3J0YW50OiB0aGlzIHdpbGwgb25seSB3b3JrIGlmIHRoZSBzY3JpcHQgaGFzIG5vdCBiZWVuIHJlbW92ZWQgYXQgYW4gZWFybGllciBzdGFnZVxuXHRpZiAoZWwubWF0Y2hlcygnc2NyaXB0W3R5cGU9XCJtYXRoL3RleFwiXScpIHx8IGVsLm1hdGNoZXMoJ3NjcmlwdFt0eXBlPVwibWF0aC90ZXg7IG1vZGU9ZGlzcGxheVwiXScpKSB7XG5cdFx0cmV0dXJuIGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzaWJsaW5nIHNjcmlwdCBlbGVtZW50XG5cdGlmIChlbC5wYXJlbnRFbGVtZW50KSB7XG5cdFx0Y29uc3Qgc2libGluZ1NjcmlwdCA9IGVsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3R5cGU9XCJtYXRoL3RleFwiXSwgc2NyaXB0W3R5cGU9XCJtYXRoL3RleDsgbW9kZT1kaXNwbGF5XCJdJyk7XG5cdFx0aWYgKHNpYmxpbmdTY3JpcHQpIHtcblx0XHRcdHJldHVybiBzaWJsaW5nU2NyaXB0LnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvLyBUcnkgdG8gY29udmVydCBNYXRoTUwgdG8gTGFUZVggYXMgbGFzdCByZXNvcnRcblx0Y29uc3QgbWF0aG1sID0gZ2V0TWF0aE1MRnJvbUVsZW1lbnQoZWwpO1xuXHRpZiAobWF0aG1sPy5tYXRobWwpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIE1hdGhNTFRvTGFUZVguY29udmVydChtYXRobWwubWF0aG1sKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY29udmVydGluZyBNYXRoTUwgdG8gTGFUZVg6JywgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0Ly8gRmFsbGJhY2sgdG8gYWx0IHRleHQgb3IgdGV4dCBjb250ZW50XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0Jsb2NrTWF0aCA9IChlbDogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xuXHRjb25zb2xlLmxvZygnaXNCbG9ja01hdGggY2hlY2tpbmcgZWxlbWVudDonLCBlbC5vdXRlckhUTUwpO1xuXG5cdC8vIDEuIENoZWNrIGV4cGxpY2l0IGRpc3BsYXkgYXR0cmlidXRlXG5cdGNvbnN0IGRpc3BsYXlBdHRyID0gZWwuZ2V0QXR0cmlidXRlKCdkaXNwbGF5Jyk7XG5cdGNvbnNvbGUubG9nKCdkaXNwbGF5IGF0dHJpYnV0ZTonLCBkaXNwbGF5QXR0cik7XG5cdGlmIChkaXNwbGF5QXR0ciA9PT0gJ2Jsb2NrJykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMi4gQ2hlY2sgY29tbW9uIGNsYXNzIG5hbWVzXG5cdGNvbnN0IGNsYXNzTmFtZXMgPSBlbC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0Y29uc29sZS5sb2coJ2NsYXNzIG5hbWVzOicsIGNsYXNzTmFtZXMpO1xuXHRpZiAoY2xhc3NOYW1lcy5pbmNsdWRlcygnZGlzcGxheScpIHx8IGNsYXNzTmFtZXMuaW5jbHVkZXMoJ2Jsb2NrJykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDMuIENoZWNrIGNvbnRhaW5lciBjbGFzc2VzXG5cdGNvbnN0IGNvbnRhaW5lciA9IGVsLmNsb3Nlc3QoJy5rYXRleC1kaXNwbGF5LCAuTWF0aEpheF9EaXNwbGF5LCBbZGF0YS1kaXNwbGF5PVwiYmxvY2tcIl0nKTtcblx0Y29uc29sZS5sb2coJ2NvbnRhaW5lciBmb3VuZDonLCBjb250YWluZXI/Lm91dGVySFRNTCk7XG5cdGlmIChjb250YWluZXIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDQuIENoZWNrIGlmIHByZWNlZGVkIGJ5IGJsb2NrIGVsZW1lbnRcblx0Y29uc3QgcHJldkVsZW1lbnQgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXHRjb25zb2xlLmxvZygncHJldmlvdXMgZWxlbWVudDonLCBwcmV2RWxlbWVudD8ub3V0ZXJIVE1MKTtcblx0aWYgKHByZXZFbGVtZW50Py50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNS4gQ2hlY2sgc3BlY2lmaWMgZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLm13ZS1tYXRoLWZhbGxiYWNrLWltYWdlLWRpc3BsYXknKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNi4gQ2hlY2sgS2FUZVggZGlzcGxheSBtb2RlXG5cdGlmIChlbC5tYXRjaGVzKCcua2F0ZXgnKSkge1xuXHRcdC8vIEthVGVYIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuXHRcdC8vIE9ubHkgYmxvY2sgaWYgZXhwbGljaXRseSBtYXJrZWQgYXMgZGlzcGxheVxuXHRcdHJldHVybiBlbC5jbG9zZXN0KCcua2F0ZXgtZGlzcGxheScpICE9PSBudWxsO1xuXHR9XG5cblx0Ly8gNy4gQ2hlY2sgTWF0aEpheCB2MyBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNwbGF5JykpIHtcblx0XHRjb25zb2xlLmxvZygnRm91bmQgZGlzcGxheSBhdHRyaWJ1dGU6JywgZWwuZ2V0QXR0cmlidXRlKCdkaXNwbGF5JykpO1xuXHRcdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ3RydWUnO1xuXHR9XG5cblx0Ly8gOC4gQ2hlY2sgcGFyZW50IGNvbnRhaW5lciBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRjb25zdCBwYXJlbnRDb250YWluZXIgPSBlbC5jbG9zZXN0KCdbZGlzcGxheV0nKTtcblx0aWYgKHBhcmVudENvbnRhaW5lcikge1xuXHRcdGNvbnNvbGUubG9nKCdQYXJlbnQgY29udGFpbmVyIGRpc3BsYXk6JywgcGFyZW50Q29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpKTtcblx0XHRyZXR1cm4gcGFyZW50Q29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpID09PSAndHJ1ZSc7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudCA9IChtYXRoRGF0YTogTWF0aERhdGEgfCBudWxsLCBsYXRleDogc3RyaW5nIHwgbnVsbCwgaXNCbG9jazogYm9vbGVhbik6IEVsZW1lbnQgPT4ge1xuXHRjb25zb2xlLmxvZygnY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudCBpbnB1dHM6Jywge1xuXHRcdG1hdGhEYXRhLFxuXHRcdGxhdGV4LFxuXHRcdGlzQmxvY2tcblx0fSk7XG5cblx0Y29uc3QgbmV3TWF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21hdGgnKTtcblxuXHQvLyBTZXQgTWF0aE1MIG5hbWVzcGFjZVxuXHRuZXdNYXRoLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcpO1xuXG5cdC8vIFNldCBkaXNwbGF5IG1vZGVcblx0bmV3TWF0aC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCBpc0Jsb2NrID8gJ2Jsb2NrJyA6ICdpbmxpbmUnKTtcblxuXHQvLyBTZXQgTGFUZVggaWYgYXZhaWxhYmxlXG5cdGlmIChsYXRleCkge1xuXHRcdG5ld01hdGguc2V0QXR0cmlidXRlKCdkYXRhLWxhdGV4JywgbGF0ZXgpO1xuXHR9XG5cblx0Ly8gRmlyc3QgdHJ5IHRvIHVzZSBleGlzdGluZyBNYXRoTUwgY29udGVudFxuXHRpZiAobWF0aERhdGE/Lm1hdGhtbCkge1xuXHRcdGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0ZW1wRGl2LmlubmVySFRNTCA9IG1hdGhEYXRhLm1hdGhtbDtcblx0XHRjb25zdCBtYXRoQ29udGVudCA9IHRlbXBEaXYucXVlcnlTZWxlY3RvcignbWF0aCcpO1xuXHRcdGlmIChtYXRoQ29udGVudCkge1xuXHRcdFx0bmV3TWF0aC5pbm5lckhUTUwgPSBtYXRoQ29udGVudC5pbm5lckhUTUw7XG5cdFx0fVxuXHR9XG5cdC8vIElmIG5vIE1hdGhNTCBjb250ZW50IGJ1dCB3ZSBoYXZlIExhVGVYLCBjb252ZXJ0IHVzaW5nIFRlbW1sXG5cdGVsc2UgaWYgKGxhdGV4KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnNvbGUubG9nKCdDb252ZXJ0aW5nIExhVGVYIHRvIE1hdGhNTDonLCBsYXRleCk7XG5cdFx0XHRcblx0XHRcdC8vIENvbnZlcnQgTGFUZVggdG8gTWF0aE1MIHVzaW5nIFRlbW1sXG5cdFx0XHRjb25zdCBtYXRobWwgPSB0ZW1tbC5yZW5kZXJUb1N0cmluZyhsYXRleCwge1xuXHRcdFx0XHRkaXNwbGF5TW9kZTogaXNCbG9jayxcblx0XHRcdFx0dGhyb3dPbkVycm9yOiBmYWxzZVxuXHRcdFx0fSk7XG5cdFx0XHRjb25zb2xlLmxvZygnVGVtbWwgY29udmVyc2lvbiByZXN1bHQ6JywgbWF0aG1sKTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBtYXRobWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEV4dHJhY3QgdGhlIGlubmVyIGNvbnRlbnQgb2YgdGhlIG1hdGggZWxlbWVudFxuXHRcdFx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdHRlbXBEaXYuaW5uZXJIVE1MID0gbWF0aG1sO1xuXHRcdFx0XHRjb25zdCBtYXRoQ29udGVudCA9IHRlbXBEaXYucXVlcnlTZWxlY3RvcignbWF0aCcpO1xuXHRcdFx0XHRpZiAobWF0aENvbnRlbnQpIHtcblx0XHRcdFx0XHQvLyBDb3B5IGF0dHJpYnV0ZXMgZXhjZXB0IGRpc3BsYXkgbW9kZVxuXHRcdFx0XHRcdEFycmF5LmZyb20obWF0aENvbnRlbnQuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0XHRcdGlmIChhdHRyLm5hbWUgIT09ICdkaXNwbGF5Jykge1xuXHRcdFx0XHRcdFx0XHRuZXdNYXRoLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdG5ld01hdGguaW5uZXJIVE1MID0gbWF0aENvbnRlbnQuaW5uZXJIVE1MO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIFVzZSB0aGUgZW50aXJlIG91dHB1dCBhcyBmYWxsYmFja1xuXHRcdFx0XHRcdG5ld01hdGguaW5uZXJIVE1MID0gbWF0aG1sO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXdNYXRoLnRleHRDb250ZW50ID0gbGF0ZXg7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbnZlcnRpbmcgTGFUZVggdG8gTWF0aE1MOicsIGVycm9yKTtcblx0XHRcdG5ld01hdGgudGV4dENvbnRlbnQgPSBsYXRleDtcblx0XHR9XG5cdH1cblxuXHRjb25zb2xlLmxvZygnQ3JlYXRlZCBtYXRoIGVsZW1lbnQ6JywgbmV3TWF0aC5vdXRlckhUTUwpO1xuXHRyZXR1cm4gbmV3TWF0aDtcbn07XG5cbi8vIE1hdGggZWxlbWVudCBzdGFuZGFyZGl6YXRpb24gcnVsZXNcbmV4cG9ydCBjb25zdCBtYXRoU3RhbmRhcmRpemF0aW9uUnVsZXMgPSBbXG5cdHtcblx0XHQvLyBXb3JkUHJlc3MgTGFUZVggaW1hZ2VzXG5cdFx0c2VsZWN0b3I6ICdpbWcubGF0ZXhbc3JjKj1cImxhdGV4LnBocFwiXScsXG5cdFx0ZWxlbWVudDogJ21hdGgnLFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHRpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIEdldCBMYVRlWCBmb3JtdWxhXG5cdFx0XHRjb25zdCBsYXRleCA9IGdldExhdGV4RnJvbUVsZW1lbnQoZWwpO1xuXHRcdFx0XG5cdFx0XHQvLyBXb3JkUHJlc3MgTGFUZVggaW1hZ2VzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuXHRcdFx0Y29uc3QgaXNCbG9jayA9IGlzQmxvY2tNYXRoKGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ3JlYXRlIHN0YW5kYXJkaXplZCBtYXRoIGVsZW1lbnQgd2l0aG91dCBNYXRoTUxcblx0XHRcdHJldHVybiBjcmVhdGVTdGFuZGFyZE1hdGhFbGVtZW50KG51bGwsIGxhdGV4LCBpc0Jsb2NrKTtcblx0XHR9XG5cdH0sXG5cdHtcblx0XHQvLyBNYXRoSmF4IGVsZW1lbnRzICh2MiBhbmQgdjMpXG5cdFx0c2VsZWN0b3I6IFtcblx0XHRcdCdzcGFuLk1hdGhKYXgnLFxuXHRcdFx0J21qeC1jb250YWluZXInLFxuXHRcdFx0J3NjcmlwdFt0eXBlPVwibWF0aC90ZXhcIl0nLFxuXHRcdFx0J3NjcmlwdFt0eXBlPVwibWF0aC90ZXg7IG1vZGU9ZGlzcGxheVwiXScsXG5cdFx0XHQnLk1hdGhKYXhfUHJldmlldyArIHNjcmlwdFt0eXBlPVwibWF0aC90ZXhcIl0nLFxuXHRcdFx0Jy5NYXRoSmF4X0Rpc3BsYXknLFxuXHRcdFx0Jy5NYXRoSmF4X1NWRycsXG5cdFx0XHQnLk1hdGhKYXhfTWF0aE1MJ1xuXHRcdF0uam9pbignLCcpLFxuXHRcdGVsZW1lbnQ6ICdtYXRoJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBlbDtcblxuXHRcdFx0Ly8gR2V0IE1hdGhNTCBjb250ZW50XG5cdFx0XHRjb25zdCBtYXRoRGF0YSA9IGdldE1hdGhNTEZyb21FbGVtZW50KGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IExhVGVYIGZvcm11bGFcblx0XHRcdGNvbnN0IGxhdGV4ID0gZ2V0TGF0ZXhGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIERldGVybWluZSBkaXNwbGF5IG1vZGVcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBpc0Jsb2NrTWF0aChlbCkgfHwgZWwubWF0Y2hlcygnc2NyaXB0W3R5cGU9XCJtYXRoL3RleDsgbW9kZT1kaXNwbGF5XCJdJyk7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBzdGFuZGFyZGl6ZWQgbWF0aCBlbGVtZW50XG5cdFx0XHRyZXR1cm4gY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudChtYXRoRGF0YSwgbGF0ZXgsIGlzQmxvY2spO1xuXHRcdH1cblx0fSxcblx0e1xuXHRcdC8vIE1lZGlhV2lraSBtYXRoIGVsZW1lbnRzXG5cdFx0c2VsZWN0b3I6IFtcblx0XHRcdCcubXdlLW1hdGgtZWxlbWVudCcsXG5cdFx0XHQnLm13ZS1tYXRoLWZhbGxiYWNrLWltYWdlLWlubGluZScsXG5cdFx0XHQnLm13ZS1tYXRoLWZhbGxiYWNrLWltYWdlLWRpc3BsYXknLFxuXHRcdFx0Jy5td2UtbWF0aC1tYXRobWwtaW5saW5lJyxcblx0XHRcdCcubXdlLW1hdGgtbWF0aG1sLWRpc3BsYXknLFxuXHRcdFx0J21hdGhbeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCJdJ1xuXHRcdF0uam9pbignLCcpLFxuXHRcdGVsZW1lbnQ6ICdtYXRoJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBlbDtcblxuXHRcdFx0Ly8gR2V0IE1hdGhNTCBjb250ZW50XG5cdFx0XHRjb25zdCBtYXRoRGF0YSA9IGdldE1hdGhNTEZyb21FbGVtZW50KGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IExhVGVYIGZvcm11bGFcblx0XHRcdGNvbnN0IGxhdGV4ID0gZ2V0TGF0ZXhGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIERldGVybWluZSBkaXNwbGF5IG1vZGVcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBpc0Jsb2NrTWF0aChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBzdGFuZGFyZGl6ZWQgbWF0aCBlbGVtZW50XG5cdFx0XHRyZXR1cm4gY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudChtYXRoRGF0YSwgbGF0ZXgsIGlzQmxvY2spO1xuXHRcdH1cblx0fSxcblx0e1xuXHRcdC8vIEthVGVYIGVsZW1lbnRzXG5cdFx0c2VsZWN0b3I6IFtcblx0XHRcdCcua2F0ZXgnLFxuXHRcdFx0Jy5rYXRleC1kaXNwbGF5Jyxcblx0XHRcdCcua2F0ZXgtbWF0aG1sJyxcblx0XHRcdCcua2F0ZXgtaHRtbCcsXG5cdFx0XHQnW2RhdGEta2F0ZXhdJyxcblx0XHRcdCdzY3JpcHRbdHlwZT1cIm1hdGgva2F0ZXhcIl0nXG5cdFx0XS5qb2luKCcsJyksXG5cdFx0ZWxlbWVudDogJ21hdGgnLFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHRpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuIGVsO1xuXG5cdFx0XHQvLyBHZXQgTWF0aE1MIGNvbnRlbnRcblx0XHRcdGNvbnN0IG1hdGhEYXRhID0gZ2V0TWF0aE1MRnJvbUVsZW1lbnQoZWwpO1xuXHRcdFx0XG5cdFx0XHQvLyBHZXQgTGFUZVggZm9ybXVsYVxuXHRcdFx0Y29uc3QgbGF0ZXggPSBnZXRMYXRleEZyb21FbGVtZW50KGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGRpc3BsYXkgbW9kZVxuXHRcdFx0Y29uc3QgaXNCbG9jayA9IGlzQmxvY2tNYXRoKGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ3JlYXRlIHN0YW5kYXJkaXplZCBtYXRoIGVsZW1lbnRcblx0XHRcdHJldHVybiBjcmVhdGVTdGFuZGFyZE1hdGhFbGVtZW50KG1hdGhEYXRhLCBsYXRleCwgaXNCbG9jayk7XG5cdFx0fVxuXHR9LFxuXHR7XG5cdFx0Ly8gR2VuZXJpYyBtYXRoIGVsZW1lbnRzIGFuZCBvdGhlciBmb3JtYXRzXG5cdFx0c2VsZWN0b3I6IFtcblx0XHRcdCdtYXRoJyxcblx0XHRcdCdbZGF0YS1tYXRoXScsXG5cdFx0XHQnW2RhdGEtbGF0ZXhdJyxcblx0XHRcdCdbZGF0YS10ZXhdJyxcblx0XHRcdCdzY3JpcHRbdHlwZV49XCJtYXRoL1wiXScsXG5cdFx0XHQnYW5ub3RhdGlvbltlbmNvZGluZz1cImFwcGxpY2F0aW9uL3gtdGV4XCJdJ1xuXHRcdF0uam9pbignLCcpLFxuXHRcdGVsZW1lbnQ6ICdtYXRoJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBlbDtcblxuXHRcdFx0Ly8gR2V0IE1hdGhNTCBjb250ZW50XG5cdFx0XHRjb25zdCBtYXRoRGF0YSA9IGdldE1hdGhNTEZyb21FbGVtZW50KGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IExhVGVYIGZvcm11bGFcblx0XHRcdGNvbnN0IGxhdGV4ID0gZ2V0TGF0ZXhGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIERldGVybWluZSBkaXNwbGF5IG1vZGVcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBpc0Jsb2NrTWF0aChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBzdGFuZGFyZGl6ZWQgbWF0aCBlbGVtZW50XG5cdFx0XHRyZXR1cm4gY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudChtYXRoRGF0YSwgbGF0ZXgsIGlzQmxvY2spO1xuXHRcdH1cblx0fVxuXTsgIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5NYXRoTUxUb0xhVGVYPXQoKTplLk1hdGhNTFRvTGFUZVg9dCgpfSh0aGlzLCgoKT0+KCgpPT57dmFyIGU9ezQ1ODI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PU9iamVjdCksdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5mcmVlemU/dC5mcmVlemUoZSk6ZX12YXIgYT1yKHtIVE1MOlwidGV4dC9odG1sXCIsaXNIVE1MOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09YS5IVE1MfSxYTUxfQVBQTElDQVRJT046XCJhcHBsaWNhdGlvbi94bWxcIixYTUxfVEVYVDpcInRleHQveG1sXCIsWE1MX1hIVE1MX0FQUExJQ0FUSU9OOlwiYXBwbGljYXRpb24veGh0bWwreG1sXCIsWE1MX1NWR19JTUFHRTpcImltYWdlL3N2Zyt4bWxcIn0pLG49cih7SFRNTDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixpc0hUTUw6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1uLkhUTUx9LFNWRzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsWE1MOlwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsWE1MTlM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wifSk7dC5hc3NpZ249ZnVuY3Rpb24oZSx0KXtpZihudWxsPT09ZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcInRhcmdldCBpcyBub3QgYW4gb2JqZWN0XCIpO2Zvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYoZVtyXT10W3JdKTtyZXR1cm4gZX0sdC5maW5kPWZ1bmN0aW9uKGUsdCxyKXtpZih2b2lkIDA9PT1yJiYocj1BcnJheS5wcm90b3R5cGUpLGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZmluZClyZXR1cm4gci5maW5kLmNhbGwoZSx0KTtmb3IodmFyIGE9MDthPGUubGVuZ3RoO2ErKylpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxhKSl7dmFyIG49ZVthXTtpZih0LmNhbGwodm9pZCAwLG4sYSxlKSlyZXR1cm4gbn19LHQuZnJlZXplPXIsdC5NSU1FX1RZUEU9YSx0Lk5BTUVTUEFDRT1ufSw1NzUyOihlLHQscik9Pnt2YXIgYT1yKDQ1ODIpLG49cig0NzIyKSxvPXIoNjU1OSksaT1yKDQ0NjYpLHM9bi5ET01JbXBsZW1lbnRhdGlvbixsPWEuTkFNRVNQQUNFLGM9aS5QYXJzZUVycm9yLHU9aS5YTUxSZWFkZXI7ZnVuY3Rpb24gaChlKXtyZXR1cm4gZS5yZXBsYWNlKC9cXHJbXFxuXFx1MDA4NV0vZyxcIlxcblwiKS5yZXBsYWNlKC9bXFxyXFx1MDA4NVxcdTIwMjhdL2csXCJcXG5cIil9ZnVuY3Rpb24gZChlKXt0aGlzLm9wdGlvbnM9ZXx8e2xvY2F0b3I6e319fWZ1bmN0aW9uIG0oKXt0aGlzLmNkYXRhPSExfWZ1bmN0aW9uIHAoZSx0KXt0LmxpbmVOdW1iZXI9ZS5saW5lTnVtYmVyLHQuY29sdW1uTnVtYmVyPWUuY29sdW1uTnVtYmVyfWZ1bmN0aW9uIGYoZSl7aWYoZSlyZXR1cm5cIlxcbkBcIisoZS5zeXN0ZW1JZHx8XCJcIikrXCIjW2xpbmU6XCIrZS5saW5lTnVtYmVyK1wiLGNvbDpcIitlLmNvbHVtbk51bWJlcitcIl1cIn1mdW5jdGlvbiB4KGUsdCxyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT9lLnN1YnN0cih0LHIpOmUubGVuZ3RoPj10K3J8fHQ/bmV3IGphdmEubGFuZy5TdHJpbmcoZSx0LHIpK1wiXCI6ZX1mdW5jdGlvbiBnKGUsdCl7ZS5jdXJyZW50RWxlbWVudD9lLmN1cnJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHQpOmUuZG9jLmFwcGVuZENoaWxkKHQpfWQucHJvdG90eXBlLnBhcnNlRnJvbVN0cmluZz1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMub3B0aW9ucyxhPW5ldyB1LG49ci5kb21CdWlsZGVyfHxuZXcgbSxpPXIuZXJyb3JIYW5kbGVyLHM9ci5sb2NhdG9yLGM9ci54bWxuc3x8e30sZD0vXFwveD9odG1sPyQvLnRlc3QodCkscD1kP28uSFRNTF9FTlRJVElFUzpvLlhNTF9FTlRJVElFUztzJiZuLnNldERvY3VtZW50TG9jYXRvcihzKSxhLmVycm9ySGFuZGxlcj1mdW5jdGlvbihlLHQscil7aWYoIWUpe2lmKHQgaW5zdGFuY2VvZiBtKXJldHVybiB0O2U9dH12YXIgYT17fSxuPWUgaW5zdGFuY2VvZiBGdW5jdGlvbjtmdW5jdGlvbiBvKHQpe3ZhciBvPWVbdF07IW8mJm4mJihvPTI9PWUubGVuZ3RoP2Z1bmN0aW9uKHIpe2UodCxyKX06ZSksYVt0XT1vJiZmdW5jdGlvbihlKXtvKFwiW3htbGRvbSBcIit0K1wiXVxcdFwiK2UrZihyKSl9fHxmdW5jdGlvbigpe319cmV0dXJuIHI9cnx8e30sbyhcIndhcm5pbmdcIiksbyhcImVycm9yXCIpLG8oXCJmYXRhbEVycm9yXCIpLGF9KGksbixzKSxhLmRvbUJ1aWxkZXI9ci5kb21CdWlsZGVyfHxuLGQmJihjW1wiXCJdPWwuSFRNTCksYy54bWw9Yy54bWx8fGwuWE1MO3ZhciB4PXIubm9ybWFsaXplTGluZUVuZGluZ3N8fGg7cmV0dXJuIGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlP2EucGFyc2UoeChlKSxjLHApOmEuZXJyb3JIYW5kbGVyLmVycm9yKFwiaW52YWxpZCBkb2Mgc291cmNlXCIpLG4uZG9jfSxtLnByb3RvdHlwZT17c3RhcnREb2N1bWVudDpmdW5jdGlvbigpe3RoaXMuZG9jPShuZXcgcykuY3JlYXRlRG9jdW1lbnQobnVsbCxudWxsLG51bGwpLHRoaXMubG9jYXRvciYmKHRoaXMuZG9jLmRvY3VtZW50VVJJPXRoaXMubG9jYXRvci5zeXN0ZW1JZCl9LHN0YXJ0RWxlbWVudDpmdW5jdGlvbihlLHQscixhKXt2YXIgbj10aGlzLmRvYyxvPW4uY3JlYXRlRWxlbWVudE5TKGUscnx8dCksaT1hLmxlbmd0aDtnKHRoaXMsbyksdGhpcy5jdXJyZW50RWxlbWVudD1vLHRoaXMubG9jYXRvciYmcCh0aGlzLmxvY2F0b3Isbyk7Zm9yKHZhciBzPTA7czxpO3MrKyl7ZT1hLmdldFVSSShzKTt2YXIgbD1hLmdldFZhbHVlKHMpLGM9KHI9YS5nZXRRTmFtZShzKSxuLmNyZWF0ZUF0dHJpYnV0ZU5TKGUscikpO3RoaXMubG9jYXRvciYmcChhLmdldExvY2F0b3IocyksYyksYy52YWx1ZT1jLm5vZGVWYWx1ZT1sLG8uc2V0QXR0cmlidXRlTm9kZShjKX19LGVuZEVsZW1lbnQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhPXRoaXMuY3VycmVudEVsZW1lbnQ7YS50YWdOYW1lLHRoaXMuY3VycmVudEVsZW1lbnQ9YS5wYXJlbnROb2RlfSxzdGFydFByZWZpeE1hcHBpbmc6ZnVuY3Rpb24oZSx0KXt9LGVuZFByZWZpeE1hcHBpbmc6ZnVuY3Rpb24oZSl7fSxwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmRvYy5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oZSx0KTt0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLHIpLGcodGhpcyxyKX0saWdub3JhYmxlV2hpdGVzcGFjZTpmdW5jdGlvbihlLHQscil7fSxjaGFyYWN0ZXJzOmZ1bmN0aW9uKGUsdCxyKXtpZihlPXguYXBwbHkodGhpcyxhcmd1bWVudHMpKXtpZih0aGlzLmNkYXRhKXZhciBhPXRoaXMuZG9jLmNyZWF0ZUNEQVRBU2VjdGlvbihlKTtlbHNlIGE9dGhpcy5kb2MuY3JlYXRlVGV4dE5vZGUoZSk7dGhpcy5jdXJyZW50RWxlbWVudD90aGlzLmN1cnJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGEpOi9eXFxzKiQvLnRlc3QoZSkmJnRoaXMuZG9jLmFwcGVuZENoaWxkKGEpLHRoaXMubG9jYXRvciYmcCh0aGlzLmxvY2F0b3IsYSl9fSxza2lwcGVkRW50aXR5OmZ1bmN0aW9uKGUpe30sZW5kRG9jdW1lbnQ6ZnVuY3Rpb24oKXt0aGlzLmRvYy5ub3JtYWxpemUoKX0sc2V0RG9jdW1lbnRMb2NhdG9yOmZ1bmN0aW9uKGUpeyh0aGlzLmxvY2F0b3I9ZSkmJihlLmxpbmVOdW1iZXI9MCl9LGNvbW1lbnQ6ZnVuY3Rpb24oZSx0LHIpe2U9eC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9dGhpcy5kb2MuY3JlYXRlQ29tbWVudChlKTt0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLGEpLGcodGhpcyxhKX0sc3RhcnRDREFUQTpmdW5jdGlvbigpe3RoaXMuY2RhdGE9ITB9LGVuZENEQVRBOmZ1bmN0aW9uKCl7dGhpcy5jZGF0YT0hMX0sc3RhcnREVEQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhPXRoaXMuZG9jLmltcGxlbWVudGF0aW9uO2lmKGEmJmEuY3JlYXRlRG9jdW1lbnRUeXBlKXt2YXIgbj1hLmNyZWF0ZURvY3VtZW50VHlwZShlLHQscik7dGhpcy5sb2NhdG9yJiZwKHRoaXMubG9jYXRvcixuKSxnKHRoaXMsbiksdGhpcy5kb2MuZG9jdHlwZT1ufX0sd2FybmluZzpmdW5jdGlvbihlKXtjb25zb2xlLndhcm4oXCJbeG1sZG9tIHdhcm5pbmddXFx0XCIrZSxmKHRoaXMubG9jYXRvcikpfSxlcnJvcjpmdW5jdGlvbihlKXtjb25zb2xlLmVycm9yKFwiW3htbGRvbSBlcnJvcl1cXHRcIitlLGYodGhpcy5sb2NhdG9yKSl9LGZhdGFsRXJyb3I6ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IGMoZSx0aGlzLmxvY2F0b3IpfX0sXCJlbmREVEQsc3RhcnRFbnRpdHksZW5kRW50aXR5LGF0dHJpYnV0ZURlY2wsZWxlbWVudERlY2wsZXh0ZXJuYWxFbnRpdHlEZWNsLGludGVybmFsRW50aXR5RGVjbCxyZXNvbHZlRW50aXR5LGdldEV4dGVybmFsU3Vic2V0LG5vdGF0aW9uRGVjbCx1bnBhcnNlZEVudGl0eURlY2xcIi5yZXBsYWNlKC9cXHcrL2csKGZ1bmN0aW9uKGUpe20ucHJvdG90eXBlW2VdPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fSkpLHQuRE9NUGFyc2VyPWR9LDQ3MjI6KGUsdCxyKT0+e3ZhciBhPXIoNDU4Miksbj1hLmZpbmQsbz1hLk5BTUVTUEFDRTtmdW5jdGlvbiBpKGUpe3JldHVyblwiXCIhPT1lfWZ1bmN0aW9uIHMoZSx0KXtyZXR1cm4gZS5oYXNPd25Qcm9wZXJ0eSh0KXx8KGVbdF09ITApLGV9ZnVuY3Rpb24gbChlKXtpZighZSlyZXR1cm5bXTt2YXIgdD1mdW5jdGlvbihlKXtyZXR1cm4gZT9lLnNwbGl0KC9bXFx0XFxuXFxmXFxyIF0rLykuZmlsdGVyKGkpOltdfShlKTtyZXR1cm4gT2JqZWN0LmtleXModC5yZWR1Y2Uocyx7fSkpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9ZnVuY3Rpb24gdShlLHQpe3ZhciByPWUucHJvdG90eXBlO2lmKCEociBpbnN0YW5jZW9mIHQpKXtmdW5jdGlvbiBhKCl7fWEucHJvdG90eXBlPXQucHJvdG90eXBlLGMocixhPW5ldyBhKSxlLnByb3RvdHlwZT1yPWF9ci5jb25zdHJ1Y3RvciE9ZSYmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJmNvbnNvbGUuZXJyb3IoXCJ1bmtub3duIENsYXNzOlwiK2UpLHIuY29uc3RydWN0b3I9ZSl9dmFyIGg9e30sZD1oLkVMRU1FTlRfTk9ERT0xLG09aC5BVFRSSUJVVEVfTk9ERT0yLHA9aC5URVhUX05PREU9MyxmPWguQ0RBVEFfU0VDVElPTl9OT0RFPTQseD1oLkVOVElUWV9SRUZFUkVOQ0VfTk9ERT01LGc9aC5FTlRJVFlfTk9ERT02LHc9aC5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU9NyxiPWguQ09NTUVOVF9OT0RFPTgsdj1oLkRPQ1VNRU5UX05PREU9OSxDPWguRE9DVU1FTlRfVFlQRV9OT0RFPTEwLEE9aC5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFPTExLEU9aC5OT1RBVElPTl9OT0RFPTEyLF89e30seT17fSxxPShfLklOREVYX1NJWkVfRVJSPSh5WzFdPVwiSW5kZXggc2l6ZSBlcnJvclwiLDEpLF8uRE9NU1RSSU5HX1NJWkVfRVJSPSh5WzJdPVwiRE9NU3RyaW5nIHNpemUgZXJyb3JcIiwyKSxfLkhJRVJBUkNIWV9SRVFVRVNUX0VSUj0oeVszXT1cIkhpZXJhcmNoeSByZXF1ZXN0IGVycm9yXCIsMykpLEQ9KF8uV1JPTkdfRE9DVU1FTlRfRVJSPSh5WzRdPVwiV3JvbmcgZG9jdW1lbnRcIiw0KSxfLklOVkFMSURfQ0hBUkFDVEVSX0VSUj0oeVs1XT1cIkludmFsaWQgY2hhcmFjdGVyXCIsNSksXy5OT19EQVRBX0FMTE9XRURfRVJSPSh5WzZdPVwiTm8gZGF0YSBhbGxvd2VkXCIsNiksXy5OT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI9KHlbN109XCJObyBtb2RpZmljYXRpb24gYWxsb3dlZFwiLDcpLF8uTk9UX0ZPVU5EX0VSUj0oeVs4XT1cIk5vdCBmb3VuZFwiLDgpKSxNPShfLk5PVF9TVVBQT1JURURfRVJSPSh5WzldPVwiTm90IHN1cHBvcnRlZFwiLDkpLF8uSU5VU0VfQVRUUklCVVRFX0VSUj0oeVsxMF09XCJBdHRyaWJ1dGUgaW4gdXNlXCIsMTApKTtmdW5jdGlvbiBUKGUsdCl7aWYodCBpbnN0YW5jZW9mIEVycm9yKXZhciByPXQ7ZWxzZSByPXRoaXMsRXJyb3IuY2FsbCh0aGlzLHlbZV0pLHRoaXMubWVzc2FnZT15W2VdLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLFQpO3JldHVybiByLmNvZGU9ZSx0JiYodGhpcy5tZXNzYWdlPXRoaXMubWVzc2FnZStcIjogXCIrdCkscn1mdW5jdGlvbiBOKCl7fWZ1bmN0aW9uIE8oZSx0KXt0aGlzLl9ub2RlPWUsdGhpcy5fcmVmcmVzaD10LEwodGhpcyl9ZnVuY3Rpb24gTChlKXt2YXIgdD1lLl9ub2RlLl9pbmN8fGUuX25vZGUub3duZXJEb2N1bWVudC5faW5jO2lmKGUuX2luYyE9PXQpe3ZhciByPWUuX3JlZnJlc2goZS5fbm9kZSk7aWYod2UoZSxcImxlbmd0aFwiLHIubGVuZ3RoKSwhZS4kJGxlbmd0aHx8ci5sZW5ndGg8ZS4kJGxlbmd0aClmb3IodmFyIGE9ci5sZW5ndGg7YSBpbiBlO2ErKylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxhKSYmZGVsZXRlIGVbYV07YyhyLGUpLGUuX2luYz10fX1mdW5jdGlvbiBCKCl7fWZ1bmN0aW9uIFMoZSx0KXtmb3IodmFyIHI9ZS5sZW5ndGg7ci0tOylpZihlW3JdPT09dClyZXR1cm4gcn1mdW5jdGlvbiBGKGUsdCxyLGEpe2lmKGE/dFtTKHQsYSldPXI6dFt0Lmxlbmd0aCsrXT1yLGUpe3Iub3duZXJFbGVtZW50PWU7dmFyIG49ZS5vd25lckRvY3VtZW50O24mJihhJiZWKG4sZSxhKSxmdW5jdGlvbihlLHQscil7ZSYmZS5faW5jKyssci5uYW1lc3BhY2VVUkk9PT1vLlhNTE5TJiYodC5fbnNNYXBbci5wcmVmaXg/ci5sb2NhbE5hbWU6XCJcIl09ci52YWx1ZSl9KG4sZSxyKSl9fWZ1bmN0aW9uIFAoZSx0LHIpe3ZhciBhPVModCxyKTtpZighKGE+PTApKXRocm93IG5ldyBUKEQsbmV3IEVycm9yKGUudGFnTmFtZStcIkBcIityKSk7Zm9yKHZhciBuPXQubGVuZ3RoLTE7YTxuOyl0W2FdPXRbKythXTtpZih0Lmxlbmd0aD1uLGUpe3ZhciBvPWUub3duZXJEb2N1bWVudDtvJiYoVihvLGUsciksci5vd25lckVsZW1lbnQ9bnVsbCl9fWZ1bmN0aW9uIGsoKXt9ZnVuY3Rpb24gUigpe31mdW5jdGlvbiBJKGUpe3JldHVybihcIjxcIj09ZT9cIiZsdDtcIjpcIj5cIj09ZSYmXCImZ3Q7XCIpfHxcIiZcIj09ZSYmXCImYW1wO1wifHwnXCInPT1lJiZcIiZxdW90O1wifHxcIiYjXCIrZS5jaGFyQ29kZUF0KCkrXCI7XCJ9ZnVuY3Rpb24gVShlLHQpe2lmKHQoZSkpcmV0dXJuITA7aWYoZT1lLmZpcnN0Q2hpbGQpZG97aWYoVShlLHQpKXJldHVybiEwfXdoaWxlKGU9ZS5uZXh0U2libGluZyl9ZnVuY3Rpb24gaigpe3RoaXMub3duZXJEb2N1bWVudD10aGlzfWZ1bmN0aW9uIFYoZSx0LHIsYSl7ZSYmZS5faW5jKyssci5uYW1lc3BhY2VVUkk9PT1vLlhNTE5TJiZkZWxldGUgdC5fbnNNYXBbci5wcmVmaXg/ci5sb2NhbE5hbWU6XCJcIl19ZnVuY3Rpb24gRyhlLHQscil7aWYoZSYmZS5faW5jKXtlLl9pbmMrKzt2YXIgYT10LmNoaWxkTm9kZXM7aWYocilhW2EubGVuZ3RoKytdPXI7ZWxzZXtmb3IodmFyIG49dC5maXJzdENoaWxkLG89MDtuOylhW28rK109bixuPW4ubmV4dFNpYmxpbmc7YS5sZW5ndGg9byxkZWxldGUgYVthLmxlbmd0aF19fX1mdW5jdGlvbiAkKGUsdCl7dmFyIHI9dC5wcmV2aW91c1NpYmxpbmcsYT10Lm5leHRTaWJsaW5nO3JldHVybiByP3IubmV4dFNpYmxpbmc9YTplLmZpcnN0Q2hpbGQ9YSxhP2EucHJldmlvdXNTaWJsaW5nPXI6ZS5sYXN0Q2hpbGQ9cix0LnBhcmVudE5vZGU9bnVsbCx0LnByZXZpb3VzU2libGluZz1udWxsLHQubmV4dFNpYmxpbmc9bnVsbCxHKGUub3duZXJEb2N1bWVudCxlKSx0fWZ1bmN0aW9uIFgoZSl7cmV0dXJuIGUmJmUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX1RZUEVfTk9ERX1mdW5jdGlvbiBIKGUpe3JldHVybiBlJiZlLm5vZGVUeXBlPT09Ui5FTEVNRU5UX05PREV9ZnVuY3Rpb24gVyhlKXtyZXR1cm4gZSYmZS5ub2RlVHlwZT09PVIuVEVYVF9OT0RFfWZ1bmN0aW9uIHooZSx0KXt2YXIgcj1lLmNoaWxkTm9kZXN8fFtdO2lmKG4ocixIKXx8WCh0KSlyZXR1cm4hMTt2YXIgYT1uKHIsWCk7cmV0dXJuISh0JiZhJiZyLmluZGV4T2YoYSk+ci5pbmRleE9mKHQpKX1mdW5jdGlvbiBZKGUsdCl7dmFyIHI9ZS5jaGlsZE5vZGVzfHxbXTtpZihuKHIsKGZ1bmN0aW9uKGUpe3JldHVybiBIKGUpJiZlIT09dH0pKSlyZXR1cm4hMTt2YXIgYT1uKHIsWCk7cmV0dXJuISh0JiZhJiZyLmluZGV4T2YoYSk+ci5pbmRleE9mKHQpKX1mdW5jdGlvbiBKKGUsdCxyKXt2YXIgYT1lLmNoaWxkTm9kZXN8fFtdLG89dC5jaGlsZE5vZGVzfHxbXTtpZih0Lm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXt2YXIgaT1vLmZpbHRlcihIKTtpZihpLmxlbmd0aD4xfHxuKG8sVykpdGhyb3cgbmV3IFQocSxcIk1vcmUgdGhhbiBvbmUgZWxlbWVudCBvciB0ZXh0IGluIGZyYWdtZW50XCIpO2lmKDE9PT1pLmxlbmd0aCYmIXooZSxyKSl0aHJvdyBuZXcgVChxLFwiRWxlbWVudCBpbiBmcmFnbWVudCBjYW4gbm90IGJlIGluc2VydGVkIGJlZm9yZSBkb2N0eXBlXCIpfWlmKEgodCkmJiF6KGUscikpdGhyb3cgbmV3IFQocSxcIk9ubHkgb25lIGVsZW1lbnQgY2FuIGJlIGFkZGVkIGFuZCBvbmx5IGFmdGVyIGRvY3R5cGVcIik7aWYoWCh0KSl7aWYobihhLFgpKXRocm93IG5ldyBUKHEsXCJPbmx5IG9uZSBkb2N0eXBlIGlzIGFsbG93ZWRcIik7dmFyIHM9bihhLEgpO2lmKHImJmEuaW5kZXhPZihzKTxhLmluZGV4T2YocikpdGhyb3cgbmV3IFQocSxcIkRvY3R5cGUgY2FuIG9ubHkgYmUgaW5zZXJ0ZWQgYmVmb3JlIGFuIGVsZW1lbnRcIik7aWYoIXImJnMpdGhyb3cgbmV3IFQocSxcIkRvY3R5cGUgY2FuIG5vdCBiZSBhcHBlbmRlZCBzaW5jZSBlbGVtZW50IGlzIHByZXNlbnRcIil9fWZ1bmN0aW9uIFooZSx0LHIpe3ZhciBhPWUuY2hpbGROb2Rlc3x8W10sbz10LmNoaWxkTm9kZXN8fFtdO2lmKHQubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe3ZhciBpPW8uZmlsdGVyKEgpO2lmKGkubGVuZ3RoPjF8fG4obyxXKSl0aHJvdyBuZXcgVChxLFwiTW9yZSB0aGFuIG9uZSBlbGVtZW50IG9yIHRleHQgaW4gZnJhZ21lbnRcIik7aWYoMT09PWkubGVuZ3RoJiYhWShlLHIpKXRocm93IG5ldyBUKHEsXCJFbGVtZW50IGluIGZyYWdtZW50IGNhbiBub3QgYmUgaW5zZXJ0ZWQgYmVmb3JlIGRvY3R5cGVcIil9aWYoSCh0KSYmIVkoZSxyKSl0aHJvdyBuZXcgVChxLFwiT25seSBvbmUgZWxlbWVudCBjYW4gYmUgYWRkZWQgYW5kIG9ubHkgYWZ0ZXIgZG9jdHlwZVwiKTtpZihYKHQpKXtpZihuKGEsKGZ1bmN0aW9uKGUpe3JldHVybiBYKGUpJiZlIT09cn0pKSl0aHJvdyBuZXcgVChxLFwiT25seSBvbmUgZG9jdHlwZSBpcyBhbGxvd2VkXCIpO3ZhciBzPW4oYSxIKTtpZihyJiZhLmluZGV4T2Yocyk8YS5pbmRleE9mKHIpKXRocm93IG5ldyBUKHEsXCJEb2N0eXBlIGNhbiBvbmx5IGJlIGluc2VydGVkIGJlZm9yZSBhbiBlbGVtZW50XCIpfX1mdW5jdGlvbiBRKGUsdCxyLGEpeyhmdW5jdGlvbihlLHQscil7aWYoIWZ1bmN0aW9uKGUpe3JldHVybiBlJiYoZS5ub2RlVHlwZT09PVIuRE9DVU1FTlRfTk9ERXx8ZS5ub2RlVHlwZT09PVIuRE9DVU1FTlRfRlJBR01FTlRfTk9ERXx8ZS5ub2RlVHlwZT09PVIuRUxFTUVOVF9OT0RFKX0oZSkpdGhyb3cgbmV3IFQocSxcIlVuZXhwZWN0ZWQgcGFyZW50IG5vZGUgdHlwZSBcIitlLm5vZGVUeXBlKTtpZihyJiZyLnBhcmVudE5vZGUhPT1lKXRocm93IG5ldyBUKEQsXCJjaGlsZCBub3QgaW4gcGFyZW50XCIpO2lmKCFmdW5jdGlvbihlKXtyZXR1cm4gZSYmKEgoZSl8fFcoZSl8fFgoZSl8fGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLkNPTU1FTlRfTk9ERXx8ZS5ub2RlVHlwZT09PVIuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFKX0odCl8fFgodCkmJmUubm9kZVR5cGUhPT1SLkRPQ1VNRU5UX05PREUpdGhyb3cgbmV3IFQocSxcIlVuZXhwZWN0ZWQgbm9kZSB0eXBlIFwiK3Qubm9kZVR5cGUrXCIgZm9yIHBhcmVudCBub2RlIHR5cGUgXCIrZS5ub2RlVHlwZSl9KShlLHQsciksZS5ub2RlVHlwZT09PVIuRE9DVU1FTlRfTk9ERSYmKGF8fEopKGUsdCxyKTt2YXIgbj10LnBhcmVudE5vZGU7aWYobiYmbi5yZW1vdmVDaGlsZCh0KSx0Lm5vZGVUeXBlPT09QSl7dmFyIG89dC5maXJzdENoaWxkO2lmKG51bGw9PW8pcmV0dXJuIHQ7dmFyIGk9dC5sYXN0Q2hpbGR9ZWxzZSBvPWk9dDt2YXIgcz1yP3IucHJldmlvdXNTaWJsaW5nOmUubGFzdENoaWxkO28ucHJldmlvdXNTaWJsaW5nPXMsaS5uZXh0U2libGluZz1yLHM/cy5uZXh0U2libGluZz1vOmUuZmlyc3RDaGlsZD1vLG51bGw9PXI/ZS5sYXN0Q2hpbGQ9aTpyLnByZXZpb3VzU2libGluZz1pO2Rve28ucGFyZW50Tm9kZT1lfXdoaWxlKG8hPT1pJiYobz1vLm5leHRTaWJsaW5nKSk7cmV0dXJuIEcoZS5vd25lckRvY3VtZW50fHxlLGUpLHQubm9kZVR5cGU9PUEmJih0LmZpcnN0Q2hpbGQ9dC5sYXN0Q2hpbGQ9bnVsbCksdH1mdW5jdGlvbiBLKCl7dGhpcy5fbnNNYXA9e319ZnVuY3Rpb24gZWUoKXt9ZnVuY3Rpb24gdGUoKXt9ZnVuY3Rpb24gcmUoKXt9ZnVuY3Rpb24gYWUoKXt9ZnVuY3Rpb24gbmUoKXt9ZnVuY3Rpb24gb2UoKXt9ZnVuY3Rpb24gaWUoKXt9ZnVuY3Rpb24gc2UoKXt9ZnVuY3Rpb24gbGUoKXt9ZnVuY3Rpb24gY2UoKXt9ZnVuY3Rpb24gdWUoKXt9ZnVuY3Rpb24gaGUoKXt9ZnVuY3Rpb24gZGUoZSx0KXt2YXIgcj1bXSxhPTk9PXRoaXMubm9kZVR5cGUmJnRoaXMuZG9jdW1lbnRFbGVtZW50fHx0aGlzLG49YS5wcmVmaXgsbz1hLm5hbWVzcGFjZVVSSTtpZihvJiZudWxsPT1uJiZudWxsPT0obj1hLmxvb2t1cFByZWZpeChvKSkpdmFyIGk9W3tuYW1lc3BhY2U6byxwcmVmaXg6bnVsbH1dO3JldHVybiBmZSh0aGlzLHIsZSx0LGkpLHIuam9pbihcIlwiKX1mdW5jdGlvbiBtZShlLHQscil7dmFyIGE9ZS5wcmVmaXh8fFwiXCIsbj1lLm5hbWVzcGFjZVVSSTtpZighbilyZXR1cm4hMTtpZihcInhtbFwiPT09YSYmbj09PW8uWE1MfHxuPT09by5YTUxOUylyZXR1cm4hMTtmb3IodmFyIGk9ci5sZW5ndGg7aS0tOyl7dmFyIHM9cltpXTtpZihzLnByZWZpeD09PWEpcmV0dXJuIHMubmFtZXNwYWNlIT09bn1yZXR1cm4hMH1mdW5jdGlvbiBwZShlLHQscil7ZS5wdXNoKFwiIFwiLHQsJz1cIicsci5yZXBsYWNlKC9bPD4mXCJcXHRcXG5cXHJdL2csSSksJ1wiJyl9ZnVuY3Rpb24gZmUoZSx0LHIsYSxuKXtpZihufHwobj1bXSksYSl7aWYoIShlPWEoZSkpKXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gdm9pZCB0LnB1c2goZSl9c3dpdGNoKGUubm9kZVR5cGUpe2Nhc2UgZDp2YXIgaT1lLmF0dHJpYnV0ZXMscz1pLmxlbmd0aCxsPWUuZmlyc3RDaGlsZCxjPWUudGFnTmFtZSx1PWM7aWYoIShyPW8uaXNIVE1MKGUubmFtZXNwYWNlVVJJKXx8cikmJiFlLnByZWZpeCYmZS5uYW1lc3BhY2VVUkkpe2Zvcih2YXIgaCxnPTA7ZzxpLmxlbmd0aDtnKyspaWYoXCJ4bWxuc1wiPT09aS5pdGVtKGcpLm5hbWUpe2g9aS5pdGVtKGcpLnZhbHVlO2JyZWFrfWlmKCFoKWZvcih2YXIgRT1uLmxlbmd0aC0xO0U+PTA7RS0tKWlmKFwiXCI9PT0oXz1uW0VdKS5wcmVmaXgmJl8ubmFtZXNwYWNlPT09ZS5uYW1lc3BhY2VVUkkpe2g9Xy5uYW1lc3BhY2U7YnJlYWt9aWYoaCE9PWUubmFtZXNwYWNlVVJJKWZvcihFPW4ubGVuZ3RoLTE7RT49MDtFLS0pe3ZhciBfO2lmKChfPW5bRV0pLm5hbWVzcGFjZT09PWUubmFtZXNwYWNlVVJJKXtfLnByZWZpeCYmKHU9Xy5wcmVmaXgrXCI6XCIrYyk7YnJlYWt9fX10LnB1c2goXCI8XCIsdSk7Zm9yKHZhciB5PTA7eTxzO3krKylcInhtbG5zXCI9PShxPWkuaXRlbSh5KSkucHJlZml4P24ucHVzaCh7cHJlZml4OnEubG9jYWxOYW1lLG5hbWVzcGFjZTpxLnZhbHVlfSk6XCJ4bWxuc1wiPT1xLm5vZGVOYW1lJiZuLnB1c2goe3ByZWZpeDpcIlwiLG5hbWVzcGFjZTpxLnZhbHVlfSk7Zm9yKHk9MDt5PHM7eSsrKXt2YXIgcSxELE07bWUocT1pLml0ZW0oeSksMCxuKSYmKHBlKHQsKEQ9cS5wcmVmaXh8fFwiXCIpP1wieG1sbnM6XCIrRDpcInhtbG5zXCIsTT1xLm5hbWVzcGFjZVVSSSksbi5wdXNoKHtwcmVmaXg6RCxuYW1lc3BhY2U6TX0pKSxmZShxLHQscixhLG4pfWlmKGM9PT11JiZtZShlLDAsbikmJihwZSh0LChEPWUucHJlZml4fHxcIlwiKT9cInhtbG5zOlwiK0Q6XCJ4bWxuc1wiLE09ZS5uYW1lc3BhY2VVUkkpLG4ucHVzaCh7cHJlZml4OkQsbmFtZXNwYWNlOk19KSksbHx8ciYmIS9eKD86bWV0YXxsaW5rfGltZ3xicnxocnxpbnB1dCkkL2kudGVzdChjKSl7aWYodC5wdXNoKFwiPlwiKSxyJiYvXnNjcmlwdCQvaS50ZXN0KGMpKWZvcig7bDspbC5kYXRhP3QucHVzaChsLmRhdGEpOmZlKGwsdCxyLGEsbi5zbGljZSgpKSxsPWwubmV4dFNpYmxpbmc7ZWxzZSBmb3IoO2w7KWZlKGwsdCxyLGEsbi5zbGljZSgpKSxsPWwubmV4dFNpYmxpbmc7dC5wdXNoKFwiPC9cIix1LFwiPlwiKX1lbHNlIHQucHVzaChcIi8+XCIpO3JldHVybjtjYXNlIHY6Y2FzZSBBOmZvcihsPWUuZmlyc3RDaGlsZDtsOylmZShsLHQscixhLG4uc2xpY2UoKSksbD1sLm5leHRTaWJsaW5nO3JldHVybjtjYXNlIG06cmV0dXJuIHBlKHQsZS5uYW1lLGUudmFsdWUpO2Nhc2UgcDpyZXR1cm4gdC5wdXNoKGUuZGF0YS5yZXBsYWNlKC9bPCY+XS9nLEkpKTtjYXNlIGY6cmV0dXJuIHQucHVzaChcIjwhW0NEQVRBW1wiLGUuZGF0YSxcIl1dPlwiKTtjYXNlIGI6cmV0dXJuIHQucHVzaChcIlxceDNjIS0tXCIsZS5kYXRhLFwiLS1cXHgzZVwiKTtjYXNlIEM6dmFyIFQ9ZS5wdWJsaWNJZCxOPWUuc3lzdGVtSWQ7aWYodC5wdXNoKFwiPCFET0NUWVBFIFwiLGUubmFtZSksVCl0LnB1c2goXCIgUFVCTElDIFwiLFQpLE4mJlwiLlwiIT1OJiZ0LnB1c2goXCIgXCIsTiksdC5wdXNoKFwiPlwiKTtlbHNlIGlmKE4mJlwiLlwiIT1OKXQucHVzaChcIiBTWVNURU0gXCIsTixcIj5cIik7ZWxzZXt2YXIgTz1lLmludGVybmFsU3Vic2V0O08mJnQucHVzaChcIiBbXCIsTyxcIl1cIiksdC5wdXNoKFwiPlwiKX1yZXR1cm47Y2FzZSB3OnJldHVybiB0LnB1c2goXCI8P1wiLGUudGFyZ2V0LFwiIFwiLGUuZGF0YSxcIj8+XCIpO2Nhc2UgeDpyZXR1cm4gdC5wdXNoKFwiJlwiLGUubm9kZU5hbWUsXCI7XCIpO2RlZmF1bHQ6dC5wdXNoKFwiPz9cIixlLm5vZGVOYW1lKX19ZnVuY3Rpb24geGUoZSx0LHIpe3ZhciBhO3N3aXRjaCh0Lm5vZGVUeXBlKXtjYXNlIGQ6KGE9dC5jbG9uZU5vZGUoITEpKS5vd25lckRvY3VtZW50PWU7Y2FzZSBBOmJyZWFrO2Nhc2UgbTpyPSEwfWlmKGF8fChhPXQuY2xvbmVOb2RlKCExKSksYS5vd25lckRvY3VtZW50PWUsYS5wYXJlbnROb2RlPW51bGwscilmb3IodmFyIG49dC5maXJzdENoaWxkO247KWEuYXBwZW5kQ2hpbGQoeGUoZSxuLHIpKSxuPW4ubmV4dFNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZ2UoZSx0LHIpe3ZhciBhPW5ldyB0LmNvbnN0cnVjdG9yO2Zvcih2YXIgbiBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pKXt2YXIgbz10W25dO1wib2JqZWN0XCIhPXR5cGVvZiBvJiZvIT1hW25dJiYoYVtuXT1vKX1zd2l0Y2godC5jaGlsZE5vZGVzJiYoYS5jaGlsZE5vZGVzPW5ldyBOKSxhLm93bmVyRG9jdW1lbnQ9ZSxhLm5vZGVUeXBlKXtjYXNlIGQ6dmFyIGk9dC5hdHRyaWJ1dGVzLHM9YS5hdHRyaWJ1dGVzPW5ldyBCLGw9aS5sZW5ndGg7cy5fb3duZXJFbGVtZW50PWE7Zm9yKHZhciBjPTA7YzxsO2MrKylhLnNldEF0dHJpYnV0ZU5vZGUoZ2UoZSxpLml0ZW0oYyksITApKTticmVhaztjYXNlIG06cj0hMH1pZihyKWZvcih2YXIgdT10LmZpcnN0Q2hpbGQ7dTspYS5hcHBlbmRDaGlsZChnZShlLHUscikpLHU9dS5uZXh0U2libGluZztyZXR1cm4gYX1mdW5jdGlvbiB3ZShlLHQscil7ZVt0XT1yfV8uSU5WQUxJRF9TVEFURV9FUlI9KHlbMTFdPVwiSW52YWxpZCBzdGF0ZVwiLDExKSxfLlNZTlRBWF9FUlI9KHlbMTJdPVwiU3ludGF4IGVycm9yXCIsMTIpLF8uSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSPSh5WzEzXT1cIkludmFsaWQgbW9kaWZpY2F0aW9uXCIsMTMpLF8uTkFNRVNQQUNFX0VSUj0oeVsxNF09XCJJbnZhbGlkIG5hbWVzcGFjZVwiLDE0KSxfLklOVkFMSURfQUNDRVNTX0VSUj0oeVsxNV09XCJJbnZhbGlkIGFjY2Vzc1wiLDE1KSxULnByb3RvdHlwZT1FcnJvci5wcm90b3R5cGUsYyhfLFQpLE4ucHJvdG90eXBlPXtsZW5ndGg6MCxpdGVtOmZ1bmN0aW9uKGUpe3JldHVybiBlPj0wJiZlPHRoaXMubGVuZ3RoP3RoaXNbZV06bnVsbH0sdG9TdHJpbmc6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9W10sYT0wO2E8dGhpcy5sZW5ndGg7YSsrKWZlKHRoaXNbYV0scixlLHQpO3JldHVybiByLmpvaW4oXCJcIil9LGZpbHRlcjpmdW5jdGlvbihlKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMsZSl9LGluZGV4T2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcyxlKX19LE8ucHJvdG90eXBlLml0ZW09ZnVuY3Rpb24oZSl7cmV0dXJuIEwodGhpcyksdGhpc1tlXXx8bnVsbH0sdShPLE4pLEIucHJvdG90eXBlPXtsZW5ndGg6MCxpdGVtOk4ucHJvdG90eXBlLml0ZW0sZ2V0TmFtZWRJdGVtOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLmxlbmd0aDt0LS07KXt2YXIgcj10aGlzW3RdO2lmKHIubm9kZU5hbWU9PWUpcmV0dXJuIHJ9fSxzZXROYW1lZEl0ZW06ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5vd25lckVsZW1lbnQ7aWYodCYmdCE9dGhpcy5fb3duZXJFbGVtZW50KXRocm93IG5ldyBUKE0pO3ZhciByPXRoaXMuZ2V0TmFtZWRJdGVtKGUubm9kZU5hbWUpO3JldHVybiBGKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGUscikscn0sc2V0TmFtZWRJdGVtTlM6ZnVuY3Rpb24oZSl7dmFyIHQscj1lLm93bmVyRWxlbWVudDtpZihyJiZyIT10aGlzLl9vd25lckVsZW1lbnQpdGhyb3cgbmV3IFQoTSk7cmV0dXJuIHQ9dGhpcy5nZXROYW1lZEl0ZW1OUyhlLm5hbWVzcGFjZVVSSSxlLmxvY2FsTmFtZSksRih0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxlLHQpLHR9LHJlbW92ZU5hbWVkSXRlbTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldE5hbWVkSXRlbShlKTtyZXR1cm4gUCh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyx0KSx0fSxyZW1vdmVOYW1lZEl0ZW1OUzpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0TmFtZWRJdGVtTlMoZSx0KTtyZXR1cm4gUCh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxyKSxyfSxnZXROYW1lZEl0ZW1OUzpmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj10aGlzLmxlbmd0aDtyLS07KXt2YXIgYT10aGlzW3JdO2lmKGEubG9jYWxOYW1lPT10JiZhLm5hbWVzcGFjZVVSST09ZSlyZXR1cm4gYX1yZXR1cm4gbnVsbH19LGsucHJvdG90eXBlPXtoYXNGZWF0dXJlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuITB9LGNyZWF0ZURvY3VtZW50OmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1uZXcgajtpZihhLmltcGxlbWVudGF0aW9uPXRoaXMsYS5jaGlsZE5vZGVzPW5ldyBOLGEuZG9jdHlwZT1yfHxudWxsLHImJmEuYXBwZW5kQ2hpbGQociksdCl7dmFyIG49YS5jcmVhdGVFbGVtZW50TlMoZSx0KTthLmFwcGVuZENoaWxkKG4pfXJldHVybiBhfSxjcmVhdGVEb2N1bWVudFR5cGU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhPW5ldyBvZTtyZXR1cm4gYS5uYW1lPWUsYS5ub2RlTmFtZT1lLGEucHVibGljSWQ9dHx8XCJcIixhLnN5c3RlbUlkPXJ8fFwiXCIsYX19LFIucHJvdG90eXBlPXtmaXJzdENoaWxkOm51bGwsbGFzdENoaWxkOm51bGwscHJldmlvdXNTaWJsaW5nOm51bGwsbmV4dFNpYmxpbmc6bnVsbCxhdHRyaWJ1dGVzOm51bGwscGFyZW50Tm9kZTpudWxsLGNoaWxkTm9kZXM6bnVsbCxvd25lckRvY3VtZW50Om51bGwsbm9kZVZhbHVlOm51bGwsbmFtZXNwYWNlVVJJOm51bGwscHJlZml4Om51bGwsbG9jYWxOYW1lOm51bGwsaW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFEodGhpcyxlLHQpfSxyZXBsYWNlQ2hpbGQ6ZnVuY3Rpb24oZSx0KXtRKHRoaXMsZSx0LFopLHQmJnRoaXMucmVtb3ZlQ2hpbGQodCl9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiAkKHRoaXMsZSl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmluc2VydEJlZm9yZShlLG51bGwpfSxoYXNDaGlsZE5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZmlyc3RDaGlsZH0sY2xvbmVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiBnZSh0aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsdGhpcyxlKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuZmlyc3RDaGlsZDtlOyl7dmFyIHQ9ZS5uZXh0U2libGluZzt0JiZ0Lm5vZGVUeXBlPT1wJiZlLm5vZGVUeXBlPT1wPyh0aGlzLnJlbW92ZUNoaWxkKHQpLGUuYXBwZW5kRGF0YSh0LmRhdGEpKTooZS5ub3JtYWxpemUoKSxlPXQpfX0saXNTdXBwb3J0ZWQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoZSx0KX0saGFzQXR0cmlidXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoPjB9LGxvb2t1cFByZWZpeDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpczt0Oyl7dmFyIHI9dC5fbnNNYXA7aWYocilmb3IodmFyIGEgaW4gcilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixhKSYmclthXT09PWUpcmV0dXJuIGE7dD10Lm5vZGVUeXBlPT1tP3Qub3duZXJEb2N1bWVudDp0LnBhcmVudE5vZGV9cmV0dXJuIG51bGx9LGxvb2t1cE5hbWVzcGFjZVVSSTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpczt0Oyl7dmFyIHI9dC5fbnNNYXA7aWYociYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsZSkpcmV0dXJuIHJbZV07dD10Lm5vZGVUeXBlPT1tP3Qub3duZXJEb2N1bWVudDp0LnBhcmVudE5vZGV9cmV0dXJuIG51bGx9LGlzRGVmYXVsdE5hbWVzcGFjZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09dGhpcy5sb29rdXBQcmVmaXgoZSl9fSxjKGgsUiksYyhoLFIucHJvdG90eXBlKSxqLnByb3RvdHlwZT17bm9kZU5hbWU6XCIjZG9jdW1lbnRcIixub2RlVHlwZTp2LGRvY3R5cGU6bnVsbCxkb2N1bWVudEVsZW1lbnQ6bnVsbCxfaW5jOjEsaW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGUsdCl7aWYoZS5ub2RlVHlwZT09QSl7Zm9yKHZhciByPWUuZmlyc3RDaGlsZDtyOyl7dmFyIGE9ci5uZXh0U2libGluZzt0aGlzLmluc2VydEJlZm9yZShyLHQpLHI9YX1yZXR1cm4gZX1yZXR1cm4gUSh0aGlzLGUsdCksZS5vd25lckRvY3VtZW50PXRoaXMsbnVsbD09PXRoaXMuZG9jdW1lbnRFbGVtZW50JiZlLm5vZGVUeXBlPT09ZCYmKHRoaXMuZG9jdW1lbnRFbGVtZW50PWUpLGV9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRvY3VtZW50RWxlbWVudD09ZSYmKHRoaXMuZG9jdW1lbnRFbGVtZW50PW51bGwpLCQodGhpcyxlKX0scmVwbGFjZUNoaWxkOmZ1bmN0aW9uKGUsdCl7USh0aGlzLGUsdCxaKSxlLm93bmVyRG9jdW1lbnQ9dGhpcyx0JiZ0aGlzLnJlbW92ZUNoaWxkKHQpLEgoZSkmJih0aGlzLmRvY3VtZW50RWxlbWVudD1lKX0saW1wb3J0Tm9kZTpmdW5jdGlvbihlLHQpe3JldHVybiB4ZSh0aGlzLGUsdCl9LGdldEVsZW1lbnRCeUlkOmZ1bmN0aW9uKGUpe3ZhciB0PW51bGw7cmV0dXJuIFUodGhpcy5kb2N1bWVudEVsZW1lbnQsKGZ1bmN0aW9uKHIpe2lmKHIubm9kZVR5cGU9PWQmJnIuZ2V0QXR0cmlidXRlKFwiaWRcIik9PWUpcmV0dXJuIHQ9ciwhMH0pKSx0fSxnZXRFbGVtZW50c0J5Q2xhc3NOYW1lOmZ1bmN0aW9uKGUpe3ZhciB0PWwoZSk7cmV0dXJuIG5ldyBPKHRoaXMsKGZ1bmN0aW9uKHIpe3ZhciBhPVtdO3JldHVybiB0Lmxlbmd0aD4wJiZVKHIuZG9jdW1lbnRFbGVtZW50LChmdW5jdGlvbihuKXtpZihuIT09ciYmbi5ub2RlVHlwZT09PWQpe3ZhciBvPW4uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7aWYobyl7dmFyIGk9ZT09PW87aWYoIWkpe3ZhciBzPWwobyk7aT10LmV2ZXJ5KChjPXMsZnVuY3Rpb24oZSl7cmV0dXJuIGMmJi0xIT09Yy5pbmRleE9mKGUpfSkpfWkmJmEucHVzaChuKX19dmFyIGN9KSksYX0pKX0sY3JlYXRlRWxlbWVudDpmdW5jdGlvbihlKXt2YXIgdD1uZXcgSztyZXR1cm4gdC5vd25lckRvY3VtZW50PXRoaXMsdC5ub2RlTmFtZT1lLHQudGFnTmFtZT1lLHQubG9jYWxOYW1lPWUsdC5jaGlsZE5vZGVzPW5ldyBOLCh0LmF0dHJpYnV0ZXM9bmV3IEIpLl9vd25lckVsZW1lbnQ9dCx0fSxjcmVhdGVEb2N1bWVudEZyYWdtZW50OmZ1bmN0aW9uKCl7dmFyIGU9bmV3IGNlO3JldHVybiBlLm93bmVyRG9jdW1lbnQ9dGhpcyxlLmNoaWxkTm9kZXM9bmV3IE4sZX0sY3JlYXRlVGV4dE5vZGU6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IHJlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0LmFwcGVuZERhdGEoZSksdH0sY3JlYXRlQ29tbWVudDpmdW5jdGlvbihlKXt2YXIgdD1uZXcgYWU7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQuYXBwZW5kRGF0YShlKSx0fSxjcmVhdGVDREFUQVNlY3Rpb246ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG5lO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0LmFwcGVuZERhdGEoZSksdH0sY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IHVlO3JldHVybiByLm93bmVyRG9jdW1lbnQ9dGhpcyxyLnRhZ05hbWU9ci5ub2RlTmFtZT1yLnRhcmdldD1lLHIubm9kZVZhbHVlPXIuZGF0YT10LHJ9LGNyZWF0ZUF0dHJpYnV0ZTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgZWU7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQubmFtZT1lLHQubm9kZU5hbWU9ZSx0LmxvY2FsTmFtZT1lLHQuc3BlY2lmaWVkPSEwLHR9LGNyZWF0ZUVudGl0eVJlZmVyZW5jZTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgbGU7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQubm9kZU5hbWU9ZSx0fSxjcmVhdGVFbGVtZW50TlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgSyxhPXQuc3BsaXQoXCI6XCIpLG49ci5hdHRyaWJ1dGVzPW5ldyBCO3JldHVybiByLmNoaWxkTm9kZXM9bmV3IE4sci5vd25lckRvY3VtZW50PXRoaXMsci5ub2RlTmFtZT10LHIudGFnTmFtZT10LHIubmFtZXNwYWNlVVJJPWUsMj09YS5sZW5ndGg/KHIucHJlZml4PWFbMF0sci5sb2NhbE5hbWU9YVsxXSk6ci5sb2NhbE5hbWU9dCxuLl9vd25lckVsZW1lbnQ9cixyfSxjcmVhdGVBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3ZhciByPW5ldyBlZSxhPXQuc3BsaXQoXCI6XCIpO3JldHVybiByLm93bmVyRG9jdW1lbnQ9dGhpcyxyLm5vZGVOYW1lPXQsci5uYW1lPXQsci5uYW1lc3BhY2VVUkk9ZSxyLnNwZWNpZmllZD0hMCwyPT1hLmxlbmd0aD8oci5wcmVmaXg9YVswXSxyLmxvY2FsTmFtZT1hWzFdKTpyLmxvY2FsTmFtZT10LHJ9fSx1KGosUiksSy5wcm90b3R5cGU9e25vZGVUeXBlOmQsaGFzQXR0cmlidXRlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT10aGlzLmdldEF0dHJpYnV0ZU5vZGUoZSl9LGdldEF0dHJpYnV0ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldEF0dHJpYnV0ZU5vZGUoZSk7cmV0dXJuIHQmJnQudmFsdWV8fFwiXCJ9LGdldEF0dHJpYnV0ZU5vZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oZSl9LHNldEF0dHJpYnV0ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUoZSk7ci52YWx1ZT1yLm5vZGVWYWx1ZT1cIlwiK3QsdGhpcy5zZXRBdHRyaWJ1dGVOb2RlKHIpfSxyZW1vdmVBdHRyaWJ1dGU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlKGUpO3QmJnRoaXMucmVtb3ZlQXR0cmlidXRlTm9kZSh0KX0sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZVR5cGU9PT1BP3RoaXMuaW5zZXJ0QmVmb3JlKGUsbnVsbCk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5wYXJlbnROb2RlJiZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksdC5wYXJlbnROb2RlPWUsdC5wcmV2aW91c1NpYmxpbmc9ZS5sYXN0Q2hpbGQsdC5uZXh0U2libGluZz1udWxsLHQucHJldmlvdXNTaWJsaW5nP3QucHJldmlvdXNTaWJsaW5nLm5leHRTaWJsaW5nPXQ6ZS5maXJzdENoaWxkPXQsZS5sYXN0Q2hpbGQ9dCxHKGUub3duZXJEb2N1bWVudCxlLHQpLHR9KHRoaXMsZSl9LHNldEF0dHJpYnV0ZU5vZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW0oZSl9LHNldEF0dHJpYnV0ZU5vZGVOUzpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnNldE5hbWVkSXRlbU5TKGUpfSxyZW1vdmVBdHRyaWJ1dGVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMucmVtb3ZlTmFtZWRJdGVtKGUubm9kZU5hbWUpfSxyZW1vdmVBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKGUsdCk7ciYmdGhpcy5yZW1vdmVBdHRyaWJ1dGVOb2RlKHIpfSxoYXNBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT10aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhlLHQpfSxnZXRBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKGUsdCk7cmV0dXJuIHImJnIudmFsdWV8fFwiXCJ9LHNldEF0dHJpYnV0ZU5TOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT10aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlTlMoZSx0KTthLnZhbHVlPWEubm9kZVZhbHVlPVwiXCIrcix0aGlzLnNldEF0dHJpYnV0ZU5vZGUoYSl9LGdldEF0dHJpYnV0ZU5vZGVOUzpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtTlMoZSx0KX0sZ2V0RWxlbWVudHNCeVRhZ05hbWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBPKHRoaXMsKGZ1bmN0aW9uKHQpe3ZhciByPVtdO3JldHVybiBVKHQsKGZ1bmN0aW9uKGEpe2E9PT10fHxhLm5vZGVUeXBlIT1kfHxcIipcIiE9PWUmJmEudGFnTmFtZSE9ZXx8ci5wdXNoKGEpfSkpLHJ9KSl9LGdldEVsZW1lbnRzQnlUYWdOYW1lTlM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IE8odGhpcywoZnVuY3Rpb24ocil7dmFyIGE9W107cmV0dXJuIFUociwoZnVuY3Rpb24obil7bj09PXJ8fG4ubm9kZVR5cGUhPT1kfHxcIipcIiE9PWUmJm4ubmFtZXNwYWNlVVJJIT09ZXx8XCIqXCIhPT10JiZuLmxvY2FsTmFtZSE9dHx8YS5wdXNoKG4pfSkpLGF9KSl9fSxqLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1LLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSxqLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TPUsucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMsdShLLFIpLGVlLnByb3RvdHlwZS5ub2RlVHlwZT1tLHUoZWUsUiksdGUucHJvdG90eXBlPXtkYXRhOlwiXCIsc3Vic3RyaW5nRGF0YTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmRhdGEuc3Vic3RyaW5nKGUsZSt0KX0sYXBwZW5kRGF0YTpmdW5jdGlvbihlKXtlPXRoaXMuZGF0YStlLHRoaXMubm9kZVZhbHVlPXRoaXMuZGF0YT1lLHRoaXMubGVuZ3RoPWUubGVuZ3RofSxpbnNlcnREYXRhOmZ1bmN0aW9uKGUsdCl7dGhpcy5yZXBsYWNlRGF0YShlLDAsdCl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcih5W3FdKX0sZGVsZXRlRGF0YTpmdW5jdGlvbihlLHQpe3RoaXMucmVwbGFjZURhdGEoZSx0LFwiXCIpfSxyZXBsYWNlRGF0YTpmdW5jdGlvbihlLHQscil7cj10aGlzLmRhdGEuc3Vic3RyaW5nKDAsZSkrcit0aGlzLmRhdGEuc3Vic3RyaW5nKGUrdCksdGhpcy5ub2RlVmFsdWU9dGhpcy5kYXRhPXIsdGhpcy5sZW5ndGg9ci5sZW5ndGh9fSx1KHRlLFIpLHJlLnByb3RvdHlwZT17bm9kZU5hbWU6XCIjdGV4dFwiLG5vZGVUeXBlOnAsc3BsaXRUZXh0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZGF0YSxyPXQuc3Vic3RyaW5nKGUpO3Q9dC5zdWJzdHJpbmcoMCxlKSx0aGlzLmRhdGE9dGhpcy5ub2RlVmFsdWU9dCx0aGlzLmxlbmd0aD10Lmxlbmd0aDt2YXIgYT10aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocik7cmV0dXJuIHRoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRoaXMubmV4dFNpYmxpbmcpLGF9fSx1KHJlLHRlKSxhZS5wcm90b3R5cGU9e25vZGVOYW1lOlwiI2NvbW1lbnRcIixub2RlVHlwZTpifSx1KGFlLHRlKSxuZS5wcm90b3R5cGU9e25vZGVOYW1lOlwiI2NkYXRhLXNlY3Rpb25cIixub2RlVHlwZTpmfSx1KG5lLHRlKSxvZS5wcm90b3R5cGUubm9kZVR5cGU9Qyx1KG9lLFIpLGllLnByb3RvdHlwZS5ub2RlVHlwZT1FLHUoaWUsUiksc2UucHJvdG90eXBlLm5vZGVUeXBlPWcsdShzZSxSKSxsZS5wcm90b3R5cGUubm9kZVR5cGU9eCx1KGxlLFIpLGNlLnByb3RvdHlwZS5ub2RlTmFtZT1cIiNkb2N1bWVudC1mcmFnbWVudFwiLGNlLnByb3RvdHlwZS5ub2RlVHlwZT1BLHUoY2UsUiksdWUucHJvdG90eXBlLm5vZGVUeXBlPXcsdSh1ZSxSKSxoZS5wcm90b3R5cGUuc2VyaWFsaXplVG9TdHJpbmc9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBkZS5jYWxsKGUsdCxyKX0sUi5wcm90b3R5cGUudG9TdHJpbmc9ZGU7dHJ5e2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSl7ZnVuY3Rpb24gYmUoZSl7c3dpdGNoKGUubm9kZVR5cGUpe2Nhc2UgZDpjYXNlIEE6dmFyIHQ9W107Zm9yKGU9ZS5maXJzdENoaWxkO2U7KTchPT1lLm5vZGVUeXBlJiY4IT09ZS5ub2RlVHlwZSYmdC5wdXNoKGJlKGUpKSxlPWUubmV4dFNpYmxpbmc7cmV0dXJuIHQuam9pbihcIlwiKTtkZWZhdWx0OnJldHVybiBlLm5vZGVWYWx1ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KE8ucHJvdG90eXBlLFwibGVuZ3RoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBMKHRoaXMpLHRoaXMuJCRsZW5ndGh9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFIucHJvdG90eXBlLFwidGV4dENvbnRlbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGJlKHRoaXMpfSxzZXQ6ZnVuY3Rpb24oZSl7c3dpdGNoKHRoaXMubm9kZVR5cGUpe2Nhc2UgZDpjYXNlIEE6Zm9yKDt0aGlzLmZpcnN0Q2hpbGQ7KXRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTsoZXx8U3RyaW5nKGUpKSYmdGhpcy5hcHBlbmRDaGlsZCh0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZSkpO2JyZWFrO2RlZmF1bHQ6dGhpcy5kYXRhPWUsdGhpcy52YWx1ZT1lLHRoaXMubm9kZVZhbHVlPWV9fX0pLHdlPWZ1bmN0aW9uKGUsdCxyKXtlW1wiJCRcIit0XT1yfX19Y2F0Y2godmUpe310LkRvY3VtZW50VHlwZT1vZSx0LkRPTUV4Y2VwdGlvbj1ULHQuRE9NSW1wbGVtZW50YXRpb249ayx0LkVsZW1lbnQ9Syx0Lk5vZGU9Uix0Lk5vZGVMaXN0PU4sdC5YTUxTZXJpYWxpemVyPWhlfSw2NTU5OihlLHQscik9PntcInVzZSBzdHJpY3RcIjt2YXIgYT1yKDQ1ODIpLmZyZWV6ZTt0LlhNTF9FTlRJVElFUz1hKHthbXA6XCImXCIsYXBvczpcIidcIixndDpcIj5cIixsdDpcIjxcIixxdW90OidcIid9KSx0LkhUTUxfRU5USVRJRVM9YSh7QWFjdXRlOlwiw4FcIixhYWN1dGU6XCLDoVwiLEFicmV2ZTpcIsSCXCIsYWJyZXZlOlwixINcIixhYzpcIuKIvlwiLGFjZDpcIuKIv1wiLGFjRTpcIuKIvsyzXCIsQWNpcmM6XCLDglwiLGFjaXJjOlwiw6JcIixhY3V0ZTpcIsK0XCIsQWN5Olwi0JBcIixhY3k6XCLQsFwiLEFFbGlnOlwiw4ZcIixhZWxpZzpcIsOmXCIsYWY6XCLigaFcIixBZnI6XCLwnZSEXCIsYWZyOlwi8J2UnlwiLEFncmF2ZTpcIsOAXCIsYWdyYXZlOlwiw6BcIixhbGVmc3ltOlwi4oS1XCIsYWxlcGg6XCLihLVcIixBbHBoYTpcIs6RXCIsYWxwaGE6XCLOsVwiLEFtYWNyOlwixIBcIixhbWFjcjpcIsSBXCIsYW1hbGc6XCLiqL9cIixBTVA6XCImXCIsYW1wOlwiJlwiLEFuZDpcIuKpk1wiLGFuZDpcIuKIp1wiLGFuZGFuZDpcIuKplVwiLGFuZGQ6XCLiqZxcIixhbmRzbG9wZTpcIuKpmFwiLGFuZHY6XCLiqZpcIixhbmc6XCLiiKBcIixhbmdlOlwi4qakXCIsYW5nbGU6XCLiiKBcIixhbmdtc2Q6XCLiiKFcIixhbmdtc2RhYTpcIuKmqFwiLGFuZ21zZGFiOlwi4qapXCIsYW5nbXNkYWM6XCLipqpcIixhbmdtc2RhZDpcIuKmq1wiLGFuZ21zZGFlOlwi4qasXCIsYW5nbXNkYWY6XCLipq1cIixhbmdtc2RhZzpcIuKmrlwiLGFuZ21zZGFoOlwi4qavXCIsYW5ncnQ6XCLiiJ9cIixhbmdydHZiOlwi4oq+XCIsYW5ncnR2YmQ6XCLipp1cIixhbmdzcGg6XCLiiKJcIixhbmdzdDpcIsOFXCIsYW5nemFycjpcIuKNvFwiLEFvZ29uOlwixIRcIixhb2dvbjpcIsSFXCIsQW9wZjpcIvCdlLhcIixhb3BmOlwi8J2VklwiLGFwOlwi4omIXCIsYXBhY2lyOlwi4qmvXCIsYXBFOlwi4qmwXCIsYXBlOlwi4omKXCIsYXBpZDpcIuKJi1wiLGFwb3M6XCInXCIsQXBwbHlGdW5jdGlvbjpcIuKBoVwiLGFwcHJveDpcIuKJiFwiLGFwcHJveGVxOlwi4omKXCIsQXJpbmc6XCLDhVwiLGFyaW5nOlwiw6VcIixBc2NyOlwi8J2SnFwiLGFzY3I6XCLwnZK2XCIsQXNzaWduOlwi4omUXCIsYXN0OlwiKlwiLGFzeW1wOlwi4omIXCIsYXN5bXBlcTpcIuKJjVwiLEF0aWxkZTpcIsODXCIsYXRpbGRlOlwiw6NcIixBdW1sOlwiw4RcIixhdW1sOlwiw6RcIixhd2NvbmludDpcIuKIs1wiLGF3aW50Olwi4qiRXCIsYmFja2Nvbmc6XCLiiYxcIixiYWNrZXBzaWxvbjpcIs+2XCIsYmFja3ByaW1lOlwi4oC1XCIsYmFja3NpbTpcIuKIvVwiLGJhY2tzaW1lcTpcIuKLjVwiLEJhY2tzbGFzaDpcIuKIllwiLEJhcnY6XCLiq6dcIixiYXJ2ZWU6XCLiir1cIixCYXJ3ZWQ6XCLijIZcIixiYXJ3ZWQ6XCLijIVcIixiYXJ3ZWRnZTpcIuKMhVwiLGJicms6XCLijrVcIixiYnJrdGJyazpcIuKOtlwiLGJjb25nOlwi4omMXCIsQmN5Olwi0JFcIixiY3k6XCLQsVwiLGJkcXVvOlwi4oCeXCIsYmVjYXVzOlwi4oi1XCIsQmVjYXVzZTpcIuKItVwiLGJlY2F1c2U6XCLiiLVcIixiZW1wdHl2Olwi4qawXCIsYmVwc2k6XCLPtlwiLGJlcm5vdTpcIuKErFwiLEJlcm5vdWxsaXM6XCLihKxcIixCZXRhOlwizpJcIixiZXRhOlwizrJcIixiZXRoOlwi4oS2XCIsYmV0d2VlbjpcIuKJrFwiLEJmcjpcIvCdlIVcIixiZnI6XCLwnZSfXCIsYmlnY2FwOlwi4ouCXCIsYmlnY2lyYzpcIuKXr1wiLGJpZ2N1cDpcIuKLg1wiLGJpZ29kb3Q6XCLiqIBcIixiaWdvcGx1czpcIuKogVwiLGJpZ290aW1lczpcIuKoglwiLGJpZ3NxY3VwOlwi4qiGXCIsYmlnc3RhcjpcIuKYhVwiLGJpZ3RyaWFuZ2xlZG93bjpcIuKWvVwiLGJpZ3RyaWFuZ2xldXA6XCLilrNcIixiaWd1cGx1czpcIuKohFwiLGJpZ3ZlZTpcIuKLgVwiLGJpZ3dlZGdlOlwi4ouAXCIsYmthcm93Olwi4qSNXCIsYmxhY2tsb3plbmdlOlwi4qerXCIsYmxhY2tzcXVhcmU6XCLilqpcIixibGFja3RyaWFuZ2xlOlwi4pa0XCIsYmxhY2t0cmlhbmdsZWRvd246XCLilr5cIixibGFja3RyaWFuZ2xlbGVmdDpcIuKXglwiLGJsYWNrdHJpYW5nbGVyaWdodDpcIuKWuFwiLGJsYW5rOlwi4pCjXCIsYmxrMTI6XCLilpJcIixibGsxNDpcIuKWkVwiLGJsazM0Olwi4paTXCIsYmxvY2s6XCLilohcIixibmU6XCI94oOlXCIsYm5lcXVpdjpcIuKJoeKDpVwiLGJOb3Q6XCLiq61cIixibm90Olwi4oyQXCIsQm9wZjpcIvCdlLlcIixib3BmOlwi8J2Vk1wiLGJvdDpcIuKKpVwiLGJvdHRvbTpcIuKKpVwiLGJvd3RpZTpcIuKLiFwiLGJveGJveDpcIuKniVwiLGJveERMOlwi4pWXXCIsYm94RGw6XCLilZZcIixib3hkTDpcIuKVlVwiLGJveGRsOlwi4pSQXCIsYm94RFI6XCLilZRcIixib3hEcjpcIuKVk1wiLGJveGRSOlwi4pWSXCIsYm94ZHI6XCLilIxcIixib3hIOlwi4pWQXCIsYm94aDpcIuKUgFwiLGJveEhEOlwi4pWmXCIsYm94SGQ6XCLilaRcIixib3hoRDpcIuKVpVwiLGJveGhkOlwi4pSsXCIsYm94SFU6XCLilalcIixib3hIdTpcIuKVp1wiLGJveGhVOlwi4pWoXCIsYm94aHU6XCLilLRcIixib3htaW51czpcIuKKn1wiLGJveHBsdXM6XCLiip5cIixib3h0aW1lczpcIuKKoFwiLGJveFVMOlwi4pWdXCIsYm94VWw6XCLilZxcIixib3h1TDpcIuKVm1wiLGJveHVsOlwi4pSYXCIsYm94VVI6XCLilZpcIixib3hVcjpcIuKVmVwiLGJveHVSOlwi4pWYXCIsYm94dXI6XCLilJRcIixib3hWOlwi4pWRXCIsYm94djpcIuKUglwiLGJveFZIOlwi4pWsXCIsYm94Vmg6XCLilatcIixib3h2SDpcIuKVqlwiLGJveHZoOlwi4pS8XCIsYm94Vkw6XCLilaNcIixib3hWbDpcIuKVolwiLGJveHZMOlwi4pWhXCIsYm94dmw6XCLilKRcIixib3hWUjpcIuKVoFwiLGJveFZyOlwi4pWfXCIsYm94dlI6XCLilZ5cIixib3h2cjpcIuKUnFwiLGJwcmltZTpcIuKAtVwiLEJyZXZlOlwiy5hcIixicmV2ZTpcIsuYXCIsYnJ2YmFyOlwiwqZcIixCc2NyOlwi4oSsXCIsYnNjcjpcIvCdkrdcIixic2VtaTpcIuKBj1wiLGJzaW06XCLiiL1cIixic2ltZTpcIuKLjVwiLGJzb2w6XCJcXFxcXCIsYnNvbGI6XCLip4VcIixic29saHN1YjpcIuKfiFwiLGJ1bGw6XCLigKJcIixidWxsZXQ6XCLigKJcIixidW1wOlwi4omOXCIsYnVtcEU6XCLiqq5cIixidW1wZTpcIuKJj1wiLEJ1bXBlcTpcIuKJjlwiLGJ1bXBlcTpcIuKJj1wiLENhY3V0ZTpcIsSGXCIsY2FjdXRlOlwixIdcIixDYXA6XCLii5JcIixjYXA6XCLiiKlcIixjYXBhbmQ6XCLiqYRcIixjYXBicmN1cDpcIuKpiVwiLGNhcGNhcDpcIuKpi1wiLGNhcGN1cDpcIuKph1wiLGNhcGRvdDpcIuKpgFwiLENhcGl0YWxEaWZmZXJlbnRpYWxEOlwi4oWFXCIsY2FwczpcIuKIqe+4gFwiLGNhcmV0Olwi4oGBXCIsY2Fyb246XCLLh1wiLENheWxleXM6XCLihK1cIixjY2FwczpcIuKpjVwiLENjYXJvbjpcIsSMXCIsY2Nhcm9uOlwixI1cIixDY2VkaWw6XCLDh1wiLGNjZWRpbDpcIsOnXCIsQ2NpcmM6XCLEiFwiLGNjaXJjOlwixIlcIixDY29uaW50Olwi4oiwXCIsY2N1cHM6XCLiqYxcIixjY3Vwc3NtOlwi4qmQXCIsQ2RvdDpcIsSKXCIsY2RvdDpcIsSLXCIsY2VkaWw6XCLCuFwiLENlZGlsbGE6XCLCuFwiLGNlbXB0eXY6XCLiprJcIixjZW50OlwiwqJcIixDZW50ZXJEb3Q6XCLCt1wiLGNlbnRlcmRvdDpcIsK3XCIsQ2ZyOlwi4oStXCIsY2ZyOlwi8J2UoFwiLENIY3k6XCLQp1wiLGNoY3k6XCLRh1wiLGNoZWNrOlwi4pyTXCIsY2hlY2ttYXJrOlwi4pyTXCIsQ2hpOlwizqdcIixjaGk6XCLPh1wiLGNpcjpcIuKXi1wiLGNpcmM6XCLLhlwiLGNpcmNlcTpcIuKJl1wiLGNpcmNsZWFycm93bGVmdDpcIuKGulwiLGNpcmNsZWFycm93cmlnaHQ6XCLihrtcIixjaXJjbGVkYXN0Olwi4oqbXCIsY2lyY2xlZGNpcmM6XCLiippcIixjaXJjbGVkZGFzaDpcIuKKnVwiLENpcmNsZURvdDpcIuKKmVwiLGNpcmNsZWRSOlwiwq5cIixjaXJjbGVkUzpcIuKTiFwiLENpcmNsZU1pbnVzOlwi4oqWXCIsQ2lyY2xlUGx1czpcIuKKlVwiLENpcmNsZVRpbWVzOlwi4oqXXCIsY2lyRTpcIuKng1wiLGNpcmU6XCLiiZdcIixjaXJmbmludDpcIuKokFwiLGNpcm1pZDpcIuKrr1wiLGNpcnNjaXI6XCLip4JcIixDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6XCLiiLJcIixDbG9zZUN1cmx5RG91YmxlUXVvdGU6XCLigJ1cIixDbG9zZUN1cmx5UXVvdGU6XCLigJlcIixjbHViczpcIuKZo1wiLGNsdWJzdWl0Olwi4pmjXCIsQ29sb246XCLiiLdcIixjb2xvbjpcIjpcIixDb2xvbmU6XCLiqbRcIixjb2xvbmU6XCLiiZRcIixjb2xvbmVxOlwi4omUXCIsY29tbWE6XCIsXCIsY29tbWF0OlwiQFwiLGNvbXA6XCLiiIFcIixjb21wZm46XCLiiJhcIixjb21wbGVtZW50Olwi4oiBXCIsY29tcGxleGVzOlwi4oSCXCIsY29uZzpcIuKJhVwiLGNvbmdkb3Q6XCLiqa1cIixDb25ncnVlbnQ6XCLiiaFcIixDb25pbnQ6XCLiiK9cIixjb25pbnQ6XCLiiK5cIixDb250b3VySW50ZWdyYWw6XCLiiK5cIixDb3BmOlwi4oSCXCIsY29wZjpcIvCdlZRcIixjb3Byb2Q6XCLiiJBcIixDb3Byb2R1Y3Q6XCLiiJBcIixDT1BZOlwiwqlcIixjb3B5OlwiwqlcIixjb3B5c3I6XCLihJdcIixDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsOlwi4oizXCIsY3JhcnI6XCLihrVcIixDcm9zczpcIuKor1wiLGNyb3NzOlwi4pyXXCIsQ3NjcjpcIvCdkp5cIixjc2NyOlwi8J2SuFwiLGNzdWI6XCLiq49cIixjc3ViZTpcIuKrkVwiLGNzdXA6XCLiq5BcIixjc3VwZTpcIuKrklwiLGN0ZG90Olwi4ouvXCIsY3VkYXJybDpcIuKkuFwiLGN1ZGFycnI6XCLipLVcIixjdWVwcjpcIuKLnlwiLGN1ZXNjOlwi4oufXCIsY3VsYXJyOlwi4oa2XCIsY3VsYXJycDpcIuKkvVwiLEN1cDpcIuKLk1wiLGN1cDpcIuKIqlwiLGN1cGJyY2FwOlwi4qmIXCIsQ3VwQ2FwOlwi4omNXCIsY3VwY2FwOlwi4qmGXCIsY3VwY3VwOlwi4qmKXCIsY3VwZG90Olwi4oqNXCIsY3Vwb3I6XCLiqYVcIixjdXBzOlwi4oiq77iAXCIsY3VyYXJyOlwi4oa3XCIsY3VyYXJybTpcIuKkvFwiLGN1cmx5ZXFwcmVjOlwi4oueXCIsY3VybHllcXN1Y2M6XCLii59cIixjdXJseXZlZTpcIuKLjlwiLGN1cmx5d2VkZ2U6XCLii49cIixjdXJyZW46XCLCpFwiLGN1cnZlYXJyb3dsZWZ0Olwi4oa2XCIsY3VydmVhcnJvd3JpZ2h0Olwi4oa3XCIsY3V2ZWU6XCLii45cIixjdXdlZDpcIuKLj1wiLGN3Y29uaW50Olwi4oiyXCIsY3dpbnQ6XCLiiLFcIixjeWxjdHk6XCLijK1cIixEYWdnZXI6XCLigKFcIixkYWdnZXI6XCLigKBcIixkYWxldGg6XCLihLhcIixEYXJyOlwi4oahXCIsZEFycjpcIuKHk1wiLGRhcnI6XCLihpNcIixkYXNoOlwi4oCQXCIsRGFzaHY6XCLiq6RcIixkYXNodjpcIuKKo1wiLGRia2Fyb3c6XCLipI9cIixkYmxhYzpcIsudXCIsRGNhcm9uOlwixI5cIixkY2Fyb246XCLEj1wiLERjeTpcItCUXCIsZGN5Olwi0LRcIixERDpcIuKFhVwiLGRkOlwi4oWGXCIsZGRhZ2dlcjpcIuKAoVwiLGRkYXJyOlwi4oeKXCIsRERvdHJhaGQ6XCLipJFcIixkZG90c2VxOlwi4qm3XCIsZGVnOlwiwrBcIixEZWw6XCLiiIdcIixEZWx0YTpcIs6UXCIsZGVsdGE6XCLOtFwiLGRlbXB0eXY6XCLiprFcIixkZmlzaHQ6XCLipb9cIixEZnI6XCLwnZSHXCIsZGZyOlwi8J2UoVwiLGRIYXI6XCLipaVcIixkaGFybDpcIuKHg1wiLGRoYXJyOlwi4oeCXCIsRGlhY3JpdGljYWxBY3V0ZTpcIsK0XCIsRGlhY3JpdGljYWxEb3Q6XCLLmVwiLERpYWNyaXRpY2FsRG91YmxlQWN1dGU6XCLLnVwiLERpYWNyaXRpY2FsR3JhdmU6XCJgXCIsRGlhY3JpdGljYWxUaWxkZTpcIsucXCIsZGlhbTpcIuKLhFwiLERpYW1vbmQ6XCLii4RcIixkaWFtb25kOlwi4ouEXCIsZGlhbW9uZHN1aXQ6XCLimaZcIixkaWFtczpcIuKZplwiLGRpZTpcIsKoXCIsRGlmZmVyZW50aWFsRDpcIuKFhlwiLGRpZ2FtbWE6XCLPnVwiLGRpc2luOlwi4ouyXCIsZGl2Olwiw7dcIixkaXZpZGU6XCLDt1wiLGRpdmlkZW9udGltZXM6XCLii4dcIixkaXZvbng6XCLii4dcIixESmN5Olwi0IJcIixkamN5Olwi0ZJcIixkbGNvcm46XCLijJ5cIixkbGNyb3A6XCLijI1cIixkb2xsYXI6XCIkXCIsRG9wZjpcIvCdlLtcIixkb3BmOlwi8J2VlVwiLERvdDpcIsKoXCIsZG90Olwiy5lcIixEb3REb3Q6XCLig5xcIixkb3RlcTpcIuKJkFwiLGRvdGVxZG90Olwi4omRXCIsRG90RXF1YWw6XCLiiZBcIixkb3RtaW51czpcIuKIuFwiLGRvdHBsdXM6XCLiiJRcIixkb3RzcXVhcmU6XCLiiqFcIixkb3VibGViYXJ3ZWRnZTpcIuKMhlwiLERvdWJsZUNvbnRvdXJJbnRlZ3JhbDpcIuKIr1wiLERvdWJsZURvdDpcIsKoXCIsRG91YmxlRG93bkFycm93Olwi4oeTXCIsRG91YmxlTGVmdEFycm93Olwi4oeQXCIsRG91YmxlTGVmdFJpZ2h0QXJyb3c6XCLih5RcIixEb3VibGVMZWZ0VGVlOlwi4qukXCIsRG91YmxlTG9uZ0xlZnRBcnJvdzpcIuKfuFwiLERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdzpcIuKfulwiLERvdWJsZUxvbmdSaWdodEFycm93Olwi4p+5XCIsRG91YmxlUmlnaHRBcnJvdzpcIuKHklwiLERvdWJsZVJpZ2h0VGVlOlwi4oqoXCIsRG91YmxlVXBBcnJvdzpcIuKHkVwiLERvdWJsZVVwRG93bkFycm93Olwi4oeVXCIsRG91YmxlVmVydGljYWxCYXI6XCLiiKVcIixEb3duQXJyb3c6XCLihpNcIixEb3duYXJyb3c6XCLih5NcIixkb3duYXJyb3c6XCLihpNcIixEb3duQXJyb3dCYXI6XCLipJNcIixEb3duQXJyb3dVcEFycm93Olwi4oe1XCIsRG93bkJyZXZlOlwizJFcIixkb3duZG93bmFycm93czpcIuKHilwiLGRvd25oYXJwb29ubGVmdDpcIuKHg1wiLGRvd25oYXJwb29ucmlnaHQ6XCLih4JcIixEb3duTGVmdFJpZ2h0VmVjdG9yOlwi4qWQXCIsRG93bkxlZnRUZWVWZWN0b3I6XCLipZ5cIixEb3duTGVmdFZlY3RvcjpcIuKGvVwiLERvd25MZWZ0VmVjdG9yQmFyOlwi4qWWXCIsRG93blJpZ2h0VGVlVmVjdG9yOlwi4qWfXCIsRG93blJpZ2h0VmVjdG9yOlwi4oeBXCIsRG93blJpZ2h0VmVjdG9yQmFyOlwi4qWXXCIsRG93blRlZTpcIuKKpFwiLERvd25UZWVBcnJvdzpcIuKGp1wiLGRyYmthcm93Olwi4qSQXCIsZHJjb3JuOlwi4oyfXCIsZHJjcm9wOlwi4oyMXCIsRHNjcjpcIvCdkp9cIixkc2NyOlwi8J2SuVwiLERTY3k6XCLQhVwiLGRzY3k6XCLRlVwiLGRzb2w6XCLip7ZcIixEc3Ryb2s6XCLEkFwiLGRzdHJvazpcIsSRXCIsZHRkb3Q6XCLii7FcIixkdHJpOlwi4pa/XCIsZHRyaWY6XCLilr5cIixkdWFycjpcIuKHtVwiLGR1aGFyOlwi4qWvXCIsZHdhbmdsZTpcIuKmplwiLERaY3k6XCLQj1wiLGR6Y3k6XCLRn1wiLGR6aWdyYXJyOlwi4p+/XCIsRWFjdXRlOlwiw4lcIixlYWN1dGU6XCLDqVwiLGVhc3RlcjpcIuKprlwiLEVjYXJvbjpcIsSaXCIsZWNhcm9uOlwixJtcIixlY2lyOlwi4omWXCIsRWNpcmM6XCLDilwiLGVjaXJjOlwiw6pcIixlY29sb246XCLiiZVcIixFY3k6XCLQrVwiLGVjeTpcItGNXCIsZUREb3Q6XCLiqbdcIixFZG90OlwixJZcIixlRG90Olwi4omRXCIsZWRvdDpcIsSXXCIsZWU6XCLihYdcIixlZkRvdDpcIuKJklwiLEVmcjpcIvCdlIhcIixlZnI6XCLwnZSiXCIsZWc6XCLiqppcIixFZ3JhdmU6XCLDiFwiLGVncmF2ZTpcIsOoXCIsZWdzOlwi4qqWXCIsZWdzZG90Olwi4qqYXCIsZWw6XCLiqplcIixFbGVtZW50Olwi4oiIXCIsZWxpbnRlcnM6XCLij6dcIixlbGw6XCLihJNcIixlbHM6XCLiqpVcIixlbHNkb3Q6XCLiqpdcIixFbWFjcjpcIsSSXCIsZW1hY3I6XCLEk1wiLGVtcHR5Olwi4oiFXCIsZW1wdHlzZXQ6XCLiiIVcIixFbXB0eVNtYWxsU3F1YXJlOlwi4pe7XCIsZW1wdHl2Olwi4oiFXCIsRW1wdHlWZXJ5U21hbGxTcXVhcmU6XCLilqtcIixlbXNwOlwi4oCDXCIsZW1zcDEzOlwi4oCEXCIsZW1zcDE0Olwi4oCFXCIsRU5HOlwixYpcIixlbmc6XCLFi1wiLGVuc3A6XCLigIJcIixFb2dvbjpcIsSYXCIsZW9nb246XCLEmVwiLEVvcGY6XCLwnZS8XCIsZW9wZjpcIvCdlZZcIixlcGFyOlwi4ouVXCIsZXBhcnNsOlwi4qejXCIsZXBsdXM6XCLiqbFcIixlcHNpOlwizrVcIixFcHNpbG9uOlwizpVcIixlcHNpbG9uOlwizrVcIixlcHNpdjpcIs+1XCIsZXFjaXJjOlwi4omWXCIsZXFjb2xvbjpcIuKJlVwiLGVxc2ltOlwi4omCXCIsZXFzbGFudGd0cjpcIuKqllwiLGVxc2xhbnRsZXNzOlwi4qqVXCIsRXF1YWw6XCLiqbVcIixlcXVhbHM6XCI9XCIsRXF1YWxUaWxkZTpcIuKJglwiLGVxdWVzdDpcIuKJn1wiLEVxdWlsaWJyaXVtOlwi4oeMXCIsZXF1aXY6XCLiiaFcIixlcXVpdkREOlwi4qm4XCIsZXF2cGFyc2w6XCLip6VcIixlcmFycjpcIuKlsVwiLGVyRG90Olwi4omTXCIsRXNjcjpcIuKEsFwiLGVzY3I6XCLihK9cIixlc2RvdDpcIuKJkFwiLEVzaW06XCLiqbNcIixlc2ltOlwi4omCXCIsRXRhOlwizpdcIixldGE6XCLOt1wiLEVUSDpcIsOQXCIsZXRoOlwiw7BcIixFdW1sOlwiw4tcIixldW1sOlwiw6tcIixldXJvOlwi4oKsXCIsZXhjbDpcIiFcIixleGlzdDpcIuKIg1wiLEV4aXN0czpcIuKIg1wiLGV4cGVjdGF0aW9uOlwi4oSwXCIsRXhwb25lbnRpYWxFOlwi4oWHXCIsZXhwb25lbnRpYWxlOlwi4oWHXCIsZmFsbGluZ2RvdHNlcTpcIuKJklwiLEZjeTpcItCkXCIsZmN5Olwi0YRcIixmZW1hbGU6XCLimYBcIixmZmlsaWc6XCLvrINcIixmZmxpZzpcIu+sgFwiLGZmbGxpZzpcIu+shFwiLEZmcjpcIvCdlIlcIixmZnI6XCLwnZSjXCIsZmlsaWc6XCLvrIFcIixGaWxsZWRTbWFsbFNxdWFyZTpcIuKXvFwiLEZpbGxlZFZlcnlTbWFsbFNxdWFyZTpcIuKWqlwiLGZqbGlnOlwiZmpcIixmbGF0Olwi4pmtXCIsZmxsaWc6XCLvrIJcIixmbHRuczpcIuKWsVwiLGZub2Y6XCLGklwiLEZvcGY6XCLwnZS9XCIsZm9wZjpcIvCdlZdcIixGb3JBbGw6XCLiiIBcIixmb3JhbGw6XCLiiIBcIixmb3JrOlwi4ouUXCIsZm9ya3Y6XCLiq5lcIixGb3VyaWVydHJmOlwi4oSxXCIsZnBhcnRpbnQ6XCLiqI1cIixmcmFjMTI6XCLCvVwiLGZyYWMxMzpcIuKFk1wiLGZyYWMxNDpcIsK8XCIsZnJhYzE1Olwi4oWVXCIsZnJhYzE2Olwi4oWZXCIsZnJhYzE4Olwi4oWbXCIsZnJhYzIzOlwi4oWUXCIsZnJhYzI1Olwi4oWWXCIsZnJhYzM0Olwiwr5cIixmcmFjMzU6XCLihZdcIixmcmFjMzg6XCLihZxcIixmcmFjNDU6XCLihZhcIixmcmFjNTY6XCLihZpcIixmcmFjNTg6XCLihZ1cIixmcmFjNzg6XCLihZ5cIixmcmFzbDpcIuKBhFwiLGZyb3duOlwi4oyiXCIsRnNjcjpcIuKEsVwiLGZzY3I6XCLwnZK7XCIsZ2FjdXRlOlwix7VcIixHYW1tYTpcIs6TXCIsZ2FtbWE6XCLOs1wiLEdhbW1hZDpcIs+cXCIsZ2FtbWFkOlwiz51cIixnYXA6XCLiqoZcIixHYnJldmU6XCLEnlwiLGdicmV2ZTpcIsSfXCIsR2NlZGlsOlwixKJcIixHY2lyYzpcIsScXCIsZ2NpcmM6XCLEnVwiLEdjeTpcItCTXCIsZ2N5Olwi0LNcIixHZG90OlwixKBcIixnZG90OlwixKFcIixnRTpcIuKJp1wiLGdlOlwi4omlXCIsZ0VsOlwi4qqMXCIsZ2VsOlwi4oubXCIsZ2VxOlwi4omlXCIsZ2VxcTpcIuKJp1wiLGdlcXNsYW50Olwi4qm+XCIsZ2VzOlwi4qm+XCIsZ2VzY2M6XCLiqqlcIixnZXNkb3Q6XCLiqoBcIixnZXNkb3RvOlwi4qqCXCIsZ2VzZG90b2w6XCLiqoRcIixnZXNsOlwi4oub77iAXCIsZ2VzbGVzOlwi4qqUXCIsR2ZyOlwi8J2UilwiLGdmcjpcIvCdlKRcIixHZzpcIuKLmVwiLGdnOlwi4omrXCIsZ2dnOlwi4ouZXCIsZ2ltZWw6XCLihLdcIixHSmN5Olwi0INcIixnamN5Olwi0ZNcIixnbDpcIuKJt1wiLGdsYTpcIuKqpVwiLGdsRTpcIuKqklwiLGdsajpcIuKqpFwiLGduYXA6XCLiqopcIixnbmFwcHJveDpcIuKqilwiLGduRTpcIuKJqVwiLGduZTpcIuKqiFwiLGduZXE6XCLiqohcIixnbmVxcTpcIuKJqVwiLGduc2ltOlwi4ounXCIsR29wZjpcIvCdlL5cIixnb3BmOlwi8J2VmFwiLGdyYXZlOlwiYFwiLEdyZWF0ZXJFcXVhbDpcIuKJpVwiLEdyZWF0ZXJFcXVhbExlc3M6XCLii5tcIixHcmVhdGVyRnVsbEVxdWFsOlwi4omnXCIsR3JlYXRlckdyZWF0ZXI6XCLiqqJcIixHcmVhdGVyTGVzczpcIuKJt1wiLEdyZWF0ZXJTbGFudEVxdWFsOlwi4qm+XCIsR3JlYXRlclRpbGRlOlwi4omzXCIsR3NjcjpcIvCdkqJcIixnc2NyOlwi4oSKXCIsZ3NpbTpcIuKJs1wiLGdzaW1lOlwi4qqOXCIsZ3NpbWw6XCLiqpBcIixHdDpcIuKJq1wiLEdUOlwiPlwiLGd0OlwiPlwiLGd0Y2M6XCLiqqdcIixndGNpcjpcIuKpulwiLGd0ZG90Olwi4ouXXCIsZ3RsUGFyOlwi4qaVXCIsZ3RxdWVzdDpcIuKpvFwiLGd0cmFwcHJveDpcIuKqhlwiLGd0cmFycjpcIuKluFwiLGd0cmRvdDpcIuKLl1wiLGd0cmVxbGVzczpcIuKLm1wiLGd0cmVxcWxlc3M6XCLiqoxcIixndHJsZXNzOlwi4om3XCIsZ3Ryc2ltOlwi4omzXCIsZ3ZlcnRuZXFxOlwi4omp77iAXCIsZ3ZuRTpcIuKJqe+4gFwiLEhhY2VrOlwiy4dcIixoYWlyc3A6XCLigIpcIixoYWxmOlwiwr1cIixoYW1pbHQ6XCLihItcIixIQVJEY3k6XCLQqlwiLGhhcmRjeTpcItGKXCIsaEFycjpcIuKHlFwiLGhhcnI6XCLihpRcIixoYXJyY2lyOlwi4qWIXCIsaGFycnc6XCLihq1cIixIYXQ6XCJeXCIsaGJhcjpcIuKEj1wiLEhjaXJjOlwixKRcIixoY2lyYzpcIsSlXCIsaGVhcnRzOlwi4pmlXCIsaGVhcnRzdWl0Olwi4pmlXCIsaGVsbGlwOlwi4oCmXCIsaGVyY29uOlwi4oq5XCIsSGZyOlwi4oSMXCIsaGZyOlwi8J2UpVwiLEhpbGJlcnRTcGFjZTpcIuKEi1wiLGhrc2Vhcm93Olwi4qSlXCIsaGtzd2Fyb3c6XCLipKZcIixob2FycjpcIuKHv1wiLGhvbXRodDpcIuKIu1wiLGhvb2tsZWZ0YXJyb3c6XCLihqlcIixob29rcmlnaHRhcnJvdzpcIuKGqlwiLEhvcGY6XCLihI1cIixob3BmOlwi8J2VmVwiLGhvcmJhcjpcIuKAlVwiLEhvcml6b250YWxMaW5lOlwi4pSAXCIsSHNjcjpcIuKEi1wiLGhzY3I6XCLwnZK9XCIsaHNsYXNoOlwi4oSPXCIsSHN0cm9rOlwixKZcIixoc3Ryb2s6XCLEp1wiLEh1bXBEb3duSHVtcDpcIuKJjlwiLEh1bXBFcXVhbDpcIuKJj1wiLGh5YnVsbDpcIuKBg1wiLGh5cGhlbjpcIuKAkFwiLElhY3V0ZTpcIsONXCIsaWFjdXRlOlwiw61cIixpYzpcIuKBo1wiLEljaXJjOlwiw45cIixpY2lyYzpcIsOuXCIsSWN5Olwi0JhcIixpY3k6XCLQuFwiLElkb3Q6XCLEsFwiLElFY3k6XCLQlVwiLGllY3k6XCLQtVwiLGlleGNsOlwiwqFcIixpZmY6XCLih5RcIixJZnI6XCLihJFcIixpZnI6XCLwnZSmXCIsSWdyYXZlOlwiw4xcIixpZ3JhdmU6XCLDrFwiLGlpOlwi4oWIXCIsaWlpaW50Olwi4qiMXCIsaWlpbnQ6XCLiiK1cIixpaW5maW46XCLip5xcIixpaW90YTpcIuKEqVwiLElKbGlnOlwixLJcIixpamxpZzpcIsSzXCIsSW06XCLihJFcIixJbWFjcjpcIsSqXCIsaW1hY3I6XCLEq1wiLGltYWdlOlwi4oSRXCIsSW1hZ2luYXJ5STpcIuKFiFwiLGltYWdsaW5lOlwi4oSQXCIsaW1hZ3BhcnQ6XCLihJFcIixpbWF0aDpcIsSxXCIsaW1vZjpcIuKKt1wiLGltcGVkOlwixrVcIixJbXBsaWVzOlwi4oeSXCIsaW46XCLiiIhcIixpbmNhcmU6XCLihIVcIixpbmZpbjpcIuKInlwiLGluZmludGllOlwi4qedXCIsaW5vZG90OlwixLFcIixJbnQ6XCLiiKxcIixpbnQ6XCLiiKtcIixpbnRjYWw6XCLiirpcIixpbnRlZ2VyczpcIuKEpFwiLEludGVncmFsOlwi4oirXCIsaW50ZXJjYWw6XCLiirpcIixJbnRlcnNlY3Rpb246XCLii4JcIixpbnRsYXJoazpcIuKol1wiLGludHByb2Q6XCLiqLxcIixJbnZpc2libGVDb21tYTpcIuKBo1wiLEludmlzaWJsZVRpbWVzOlwi4oGiXCIsSU9jeTpcItCBXCIsaW9jeTpcItGRXCIsSW9nb246XCLErlwiLGlvZ29uOlwixK9cIixJb3BmOlwi8J2VgFwiLGlvcGY6XCLwnZWaXCIsSW90YTpcIs6ZXCIsaW90YTpcIs65XCIsaXByb2Q6XCLiqLxcIixpcXVlc3Q6XCLCv1wiLElzY3I6XCLihJBcIixpc2NyOlwi8J2SvlwiLGlzaW46XCLiiIhcIixpc2luZG90Olwi4ou1XCIsaXNpbkU6XCLii7lcIixpc2luczpcIuKLtFwiLGlzaW5zdjpcIuKLs1wiLGlzaW52Olwi4oiIXCIsaXQ6XCLigaJcIixJdGlsZGU6XCLEqFwiLGl0aWxkZTpcIsSpXCIsSXVrY3k6XCLQhlwiLGl1a2N5Olwi0ZZcIixJdW1sOlwiw49cIixpdW1sOlwiw69cIixKY2lyYzpcIsS0XCIsamNpcmM6XCLEtVwiLEpjeTpcItCZXCIsamN5Olwi0LlcIixKZnI6XCLwnZSNXCIsamZyOlwi8J2Up1wiLGptYXRoOlwiyLdcIixKb3BmOlwi8J2VgVwiLGpvcGY6XCLwnZWbXCIsSnNjcjpcIvCdkqVcIixqc2NyOlwi8J2Sv1wiLEpzZXJjeTpcItCIXCIsanNlcmN5Olwi0ZhcIixKdWtjeTpcItCEXCIsanVrY3k6XCLRlFwiLEthcHBhOlwizppcIixrYXBwYTpcIs66XCIsa2FwcGF2Olwiz7BcIixLY2VkaWw6XCLEtlwiLGtjZWRpbDpcIsS3XCIsS2N5Olwi0JpcIixrY3k6XCLQulwiLEtmcjpcIvCdlI5cIixrZnI6XCLwnZSoXCIsa2dyZWVuOlwixLhcIixLSGN5Olwi0KVcIixraGN5Olwi0YVcIixLSmN5Olwi0IxcIixramN5Olwi0ZxcIixLb3BmOlwi8J2VglwiLGtvcGY6XCLwnZWcXCIsS3NjcjpcIvCdkqZcIixrc2NyOlwi8J2TgFwiLGxBYXJyOlwi4oeaXCIsTGFjdXRlOlwixLlcIixsYWN1dGU6XCLEulwiLGxhZW1wdHl2Olwi4qa0XCIsbGFncmFuOlwi4oSSXCIsTGFtYmRhOlwizptcIixsYW1iZGE6XCLOu1wiLExhbmc6XCLin6pcIixsYW5nOlwi4p+oXCIsbGFuZ2Q6XCLippFcIixsYW5nbGU6XCLin6hcIixsYXA6XCLiqoVcIixMYXBsYWNldHJmOlwi4oSSXCIsbGFxdW86XCLCq1wiLExhcnI6XCLihp5cIixsQXJyOlwi4oeQXCIsbGFycjpcIuKGkFwiLGxhcnJiOlwi4oekXCIsbGFycmJmczpcIuKkn1wiLGxhcnJmczpcIuKknVwiLGxhcnJoazpcIuKGqVwiLGxhcnJscDpcIuKGq1wiLGxhcnJwbDpcIuKkuVwiLGxhcnJzaW06XCLipbNcIixsYXJydGw6XCLihqJcIixsYXQ6XCLiqqtcIixsQXRhaWw6XCLipJtcIixsYXRhaWw6XCLipJlcIixsYXRlOlwi4qqtXCIsbGF0ZXM6XCLiqq3vuIBcIixsQmFycjpcIuKkjlwiLGxiYXJyOlwi4qSMXCIsbGJicms6XCLinbJcIixsYnJhY2U6XCJ7XCIsbGJyYWNrOlwiW1wiLGxicmtlOlwi4qaLXCIsbGJya3NsZDpcIuKmj1wiLGxicmtzbHU6XCLipo1cIixMY2Fyb246XCLEvVwiLGxjYXJvbjpcIsS+XCIsTGNlZGlsOlwixLtcIixsY2VkaWw6XCLEvFwiLGxjZWlsOlwi4oyIXCIsbGN1YjpcIntcIixMY3k6XCLQm1wiLGxjeTpcItC7XCIsbGRjYTpcIuKktlwiLGxkcXVvOlwi4oCcXCIsbGRxdW9yOlwi4oCeXCIsbGRyZGhhcjpcIuKlp1wiLGxkcnVzaGFyOlwi4qWLXCIsbGRzaDpcIuKGslwiLGxFOlwi4ommXCIsbGU6XCLiiaRcIixMZWZ0QW5nbGVCcmFja2V0Olwi4p+oXCIsTGVmdEFycm93Olwi4oaQXCIsTGVmdGFycm93Olwi4oeQXCIsbGVmdGFycm93Olwi4oaQXCIsTGVmdEFycm93QmFyOlwi4oekXCIsTGVmdEFycm93UmlnaHRBcnJvdzpcIuKHhlwiLGxlZnRhcnJvd3RhaWw6XCLihqJcIixMZWZ0Q2VpbGluZzpcIuKMiFwiLExlZnREb3VibGVCcmFja2V0Olwi4p+mXCIsTGVmdERvd25UZWVWZWN0b3I6XCLipaFcIixMZWZ0RG93blZlY3RvcjpcIuKHg1wiLExlZnREb3duVmVjdG9yQmFyOlwi4qWZXCIsTGVmdEZsb29yOlwi4oyKXCIsbGVmdGhhcnBvb25kb3duOlwi4oa9XCIsbGVmdGhhcnBvb251cDpcIuKGvFwiLGxlZnRsZWZ0YXJyb3dzOlwi4oeHXCIsTGVmdFJpZ2h0QXJyb3c6XCLihpRcIixMZWZ0cmlnaHRhcnJvdzpcIuKHlFwiLGxlZnRyaWdodGFycm93Olwi4oaUXCIsbGVmdHJpZ2h0YXJyb3dzOlwi4oeGXCIsbGVmdHJpZ2h0aGFycG9vbnM6XCLih4tcIixsZWZ0cmlnaHRzcXVpZ2Fycm93Olwi4oatXCIsTGVmdFJpZ2h0VmVjdG9yOlwi4qWOXCIsTGVmdFRlZTpcIuKKo1wiLExlZnRUZWVBcnJvdzpcIuKGpFwiLExlZnRUZWVWZWN0b3I6XCLipZpcIixsZWZ0dGhyZWV0aW1lczpcIuKLi1wiLExlZnRUcmlhbmdsZTpcIuKKslwiLExlZnRUcmlhbmdsZUJhcjpcIuKnj1wiLExlZnRUcmlhbmdsZUVxdWFsOlwi4oq0XCIsTGVmdFVwRG93blZlY3RvcjpcIuKlkVwiLExlZnRVcFRlZVZlY3RvcjpcIuKloFwiLExlZnRVcFZlY3RvcjpcIuKGv1wiLExlZnRVcFZlY3RvckJhcjpcIuKlmFwiLExlZnRWZWN0b3I6XCLihrxcIixMZWZ0VmVjdG9yQmFyOlwi4qWSXCIsbEVnOlwi4qqLXCIsbGVnOlwi4ouaXCIsbGVxOlwi4omkXCIsbGVxcTpcIuKJplwiLGxlcXNsYW50Olwi4qm9XCIsbGVzOlwi4qm9XCIsbGVzY2M6XCLiqqhcIixsZXNkb3Q6XCLiqb9cIixsZXNkb3RvOlwi4qqBXCIsbGVzZG90b3I6XCLiqoNcIixsZXNnOlwi4oua77iAXCIsbGVzZ2VzOlwi4qqTXCIsbGVzc2FwcHJveDpcIuKqhVwiLGxlc3Nkb3Q6XCLii5ZcIixsZXNzZXFndHI6XCLii5pcIixsZXNzZXFxZ3RyOlwi4qqLXCIsTGVzc0VxdWFsR3JlYXRlcjpcIuKLmlwiLExlc3NGdWxsRXF1YWw6XCLiiaZcIixMZXNzR3JlYXRlcjpcIuKJtlwiLGxlc3NndHI6XCLiibZcIixMZXNzTGVzczpcIuKqoVwiLGxlc3NzaW06XCLiibJcIixMZXNzU2xhbnRFcXVhbDpcIuKpvVwiLExlc3NUaWxkZTpcIuKJslwiLGxmaXNodDpcIuKlvFwiLGxmbG9vcjpcIuKMilwiLExmcjpcIvCdlI9cIixsZnI6XCLwnZSpXCIsbGc6XCLiibZcIixsZ0U6XCLiqpFcIixsSGFyOlwi4qWiXCIsbGhhcmQ6XCLihr1cIixsaGFydTpcIuKGvFwiLGxoYXJ1bDpcIuKlqlwiLGxoYmxrOlwi4paEXCIsTEpjeTpcItCJXCIsbGpjeTpcItGZXCIsTGw6XCLii5hcIixsbDpcIuKJqlwiLGxsYXJyOlwi4oeHXCIsbGxjb3JuZXI6XCLijJ5cIixMbGVmdGFycm93Olwi4oeaXCIsbGxoYXJkOlwi4qWrXCIsbGx0cmk6XCLil7pcIixMbWlkb3Q6XCLEv1wiLGxtaWRvdDpcIsWAXCIsbG1vdXN0Olwi4o6wXCIsbG1vdXN0YWNoZTpcIuKOsFwiLGxuYXA6XCLiqolcIixsbmFwcHJveDpcIuKqiVwiLGxuRTpcIuKJqFwiLGxuZTpcIuKqh1wiLGxuZXE6XCLiqodcIixsbmVxcTpcIuKJqFwiLGxuc2ltOlwi4oumXCIsbG9hbmc6XCLin6xcIixsb2FycjpcIuKHvVwiLGxvYnJrOlwi4p+mXCIsTG9uZ0xlZnRBcnJvdzpcIuKftVwiLExvbmdsZWZ0YXJyb3c6XCLin7hcIixsb25nbGVmdGFycm93Olwi4p+1XCIsTG9uZ0xlZnRSaWdodEFycm93Olwi4p+3XCIsTG9uZ2xlZnRyaWdodGFycm93Olwi4p+6XCIsbG9uZ2xlZnRyaWdodGFycm93Olwi4p+3XCIsbG9uZ21hcHN0bzpcIuKfvFwiLExvbmdSaWdodEFycm93Olwi4p+2XCIsTG9uZ3JpZ2h0YXJyb3c6XCLin7lcIixsb25ncmlnaHRhcnJvdzpcIuKftlwiLGxvb3BhcnJvd2xlZnQ6XCLihqtcIixsb29wYXJyb3dyaWdodDpcIuKGrFwiLGxvcGFyOlwi4qaFXCIsTG9wZjpcIvCdlYNcIixsb3BmOlwi8J2VnVwiLGxvcGx1czpcIuKorVwiLGxvdGltZXM6XCLiqLRcIixsb3dhc3Q6XCLiiJdcIixsb3diYXI6XCJfXCIsTG93ZXJMZWZ0QXJyb3c6XCLihplcIixMb3dlclJpZ2h0QXJyb3c6XCLihphcIixsb3o6XCLil4pcIixsb3plbmdlOlwi4peKXCIsbG96ZjpcIuKnq1wiLGxwYXI6XCIoXCIsbHBhcmx0Olwi4qaTXCIsbHJhcnI6XCLih4ZcIixscmNvcm5lcjpcIuKMn1wiLGxyaGFyOlwi4oeLXCIsbHJoYXJkOlwi4qWtXCIsbHJtOlwi4oCOXCIsbHJ0cmk6XCLiir9cIixsc2FxdW86XCLigLlcIixMc2NyOlwi4oSSXCIsbHNjcjpcIvCdk4FcIixMc2g6XCLihrBcIixsc2g6XCLihrBcIixsc2ltOlwi4omyXCIsbHNpbWU6XCLiqo1cIixsc2ltZzpcIuKqj1wiLGxzcWI6XCJbXCIsbHNxdW86XCLigJhcIixsc3F1b3I6XCLigJpcIixMc3Ryb2s6XCLFgVwiLGxzdHJvazpcIsWCXCIsTHQ6XCLiiapcIixMVDpcIjxcIixsdDpcIjxcIixsdGNjOlwi4qqmXCIsbHRjaXI6XCLiqblcIixsdGRvdDpcIuKLllwiLGx0aHJlZTpcIuKLi1wiLGx0aW1lczpcIuKLiVwiLGx0bGFycjpcIuKltlwiLGx0cXVlc3Q6XCLiqbtcIixsdHJpOlwi4peDXCIsbHRyaWU6XCLiirRcIixsdHJpZjpcIuKXglwiLGx0clBhcjpcIuKmllwiLGx1cmRzaGFyOlwi4qWKXCIsbHVydWhhcjpcIuKlplwiLGx2ZXJ0bmVxcTpcIuKJqO+4gFwiLGx2bkU6XCLiiajvuIBcIixtYWNyOlwiwq9cIixtYWxlOlwi4pmCXCIsbWFsdDpcIuKcoFwiLG1hbHRlc2U6XCLinKBcIixNYXA6XCLipIVcIixtYXA6XCLihqZcIixtYXBzdG86XCLihqZcIixtYXBzdG9kb3duOlwi4oanXCIsbWFwc3RvbGVmdDpcIuKGpFwiLG1hcHN0b3VwOlwi4oalXCIsbWFya2VyOlwi4pauXCIsbWNvbW1hOlwi4qipXCIsTWN5Olwi0JxcIixtY3k6XCLQvFwiLG1kYXNoOlwi4oCUXCIsbUREb3Q6XCLiiLpcIixtZWFzdXJlZGFuZ2xlOlwi4oihXCIsTWVkaXVtU3BhY2U6XCLigZ9cIixNZWxsaW50cmY6XCLihLNcIixNZnI6XCLwnZSQXCIsbWZyOlwi8J2UqlwiLG1obzpcIuKEp1wiLG1pY3JvOlwiwrVcIixtaWQ6XCLiiKNcIixtaWRhc3Q6XCIqXCIsbWlkY2lyOlwi4quwXCIsbWlkZG90OlwiwrdcIixtaW51czpcIuKIklwiLG1pbnVzYjpcIuKKn1wiLG1pbnVzZDpcIuKIuFwiLG1pbnVzZHU6XCLiqKpcIixNaW51c1BsdXM6XCLiiJNcIixtbGNwOlwi4qubXCIsbWxkcjpcIuKAplwiLG1ucGx1czpcIuKIk1wiLG1vZGVsczpcIuKKp1wiLE1vcGY6XCLwnZWEXCIsbW9wZjpcIvCdlZ5cIixtcDpcIuKIk1wiLE1zY3I6XCLihLNcIixtc2NyOlwi8J2TglwiLG1zdHBvczpcIuKIvlwiLE11OlwizpxcIixtdTpcIs68XCIsbXVsdGltYXA6XCLiirhcIixtdW1hcDpcIuKKuFwiLG5hYmxhOlwi4oiHXCIsTmFjdXRlOlwixYNcIixuYWN1dGU6XCLFhFwiLG5hbmc6XCLiiKDig5JcIixuYXA6XCLiiYlcIixuYXBFOlwi4qmwzLhcIixuYXBpZDpcIuKJi8y4XCIsbmFwb3M6XCLFiVwiLG5hcHByb3g6XCLiiYlcIixuYXR1cjpcIuKZrlwiLG5hdHVyYWw6XCLima5cIixuYXR1cmFsczpcIuKElVwiLG5ic3A6XCLCoFwiLG5idW1wOlwi4omOzLhcIixuYnVtcGU6XCLiiY/MuFwiLG5jYXA6XCLiqYNcIixOY2Fyb246XCLFh1wiLG5jYXJvbjpcIsWIXCIsTmNlZGlsOlwixYVcIixuY2VkaWw6XCLFhlwiLG5jb25nOlwi4omHXCIsbmNvbmdkb3Q6XCLiqa3MuFwiLG5jdXA6XCLiqYJcIixOY3k6XCLQnVwiLG5jeTpcItC9XCIsbmRhc2g6XCLigJNcIixuZTpcIuKJoFwiLG5lYXJoazpcIuKkpFwiLG5lQXJyOlwi4oeXXCIsbmVhcnI6XCLihpdcIixuZWFycm93Olwi4oaXXCIsbmVkb3Q6XCLiiZDMuFwiLE5lZ2F0aXZlTWVkaXVtU3BhY2U6XCLigItcIixOZWdhdGl2ZVRoaWNrU3BhY2U6XCLigItcIixOZWdhdGl2ZVRoaW5TcGFjZTpcIuKAi1wiLE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTpcIuKAi1wiLG5lcXVpdjpcIuKJolwiLG5lc2VhcjpcIuKkqFwiLG5lc2ltOlwi4omCzLhcIixOZXN0ZWRHcmVhdGVyR3JlYXRlcjpcIuKJq1wiLE5lc3RlZExlc3NMZXNzOlwi4omqXCIsTmV3TGluZTpcIlxcblwiLG5leGlzdDpcIuKIhFwiLG5leGlzdHM6XCLiiIRcIixOZnI6XCLwnZSRXCIsbmZyOlwi8J2Uq1wiLG5nRTpcIuKJp8y4XCIsbmdlOlwi4omxXCIsbmdlcTpcIuKJsVwiLG5nZXFxOlwi4omnzLhcIixuZ2Vxc2xhbnQ6XCLiqb7MuFwiLG5nZXM6XCLiqb7MuFwiLG5HZzpcIuKLmcy4XCIsbmdzaW06XCLiibVcIixuR3Q6XCLiiavig5JcIixuZ3Q6XCLiia9cIixuZ3RyOlwi4omvXCIsbkd0djpcIuKJq8y4XCIsbmhBcnI6XCLih45cIixuaGFycjpcIuKGrlwiLG5ocGFyOlwi4quyXCIsbmk6XCLiiItcIixuaXM6XCLii7xcIixuaXNkOlwi4ou6XCIsbml2Olwi4oiLXCIsTkpjeTpcItCKXCIsbmpjeTpcItGaXCIsbmxBcnI6XCLih41cIixubGFycjpcIuKGmlwiLG5sZHI6XCLigKVcIixubEU6XCLiiabMuFwiLG5sZTpcIuKJsFwiLG5MZWZ0YXJyb3c6XCLih41cIixubGVmdGFycm93Olwi4oaaXCIsbkxlZnRyaWdodGFycm93Olwi4oeOXCIsbmxlZnRyaWdodGFycm93Olwi4oauXCIsbmxlcTpcIuKJsFwiLG5sZXFxOlwi4ommzLhcIixubGVxc2xhbnQ6XCLiqb3MuFwiLG5sZXM6XCLiqb3MuFwiLG5sZXNzOlwi4omuXCIsbkxsOlwi4ouYzLhcIixubHNpbTpcIuKJtFwiLG5MdDpcIuKJquKDklwiLG5sdDpcIuKJrlwiLG5sdHJpOlwi4ouqXCIsbmx0cmllOlwi4ousXCIsbkx0djpcIuKJqsy4XCIsbm1pZDpcIuKIpFwiLE5vQnJlYWs6XCLigaBcIixOb25CcmVha2luZ1NwYWNlOlwiwqBcIixOb3BmOlwi4oSVXCIsbm9wZjpcIvCdlZ9cIixOb3Q6XCLiq6xcIixub3Q6XCLCrFwiLE5vdENvbmdydWVudDpcIuKJolwiLE5vdEN1cENhcDpcIuKJrVwiLE5vdERvdWJsZVZlcnRpY2FsQmFyOlwi4oimXCIsTm90RWxlbWVudDpcIuKIiVwiLE5vdEVxdWFsOlwi4omgXCIsTm90RXF1YWxUaWxkZTpcIuKJgsy4XCIsTm90RXhpc3RzOlwi4oiEXCIsTm90R3JlYXRlcjpcIuKJr1wiLE5vdEdyZWF0ZXJFcXVhbDpcIuKJsVwiLE5vdEdyZWF0ZXJGdWxsRXF1YWw6XCLiiafMuFwiLE5vdEdyZWF0ZXJHcmVhdGVyOlwi4omrzLhcIixOb3RHcmVhdGVyTGVzczpcIuKJuVwiLE5vdEdyZWF0ZXJTbGFudEVxdWFsOlwi4qm+zLhcIixOb3RHcmVhdGVyVGlsZGU6XCLiibVcIixOb3RIdW1wRG93bkh1bXA6XCLiiY7MuFwiLE5vdEh1bXBFcXVhbDpcIuKJj8y4XCIsbm90aW46XCLiiIlcIixub3RpbmRvdDpcIuKLtcy4XCIsbm90aW5FOlwi4ou5zLhcIixub3RpbnZhOlwi4oiJXCIsbm90aW52YjpcIuKLt1wiLG5vdGludmM6XCLii7ZcIixOb3RMZWZ0VHJpYW5nbGU6XCLii6pcIixOb3RMZWZ0VHJpYW5nbGVCYXI6XCLip4/MuFwiLE5vdExlZnRUcmlhbmdsZUVxdWFsOlwi4ousXCIsTm90TGVzczpcIuKJrlwiLE5vdExlc3NFcXVhbDpcIuKJsFwiLE5vdExlc3NHcmVhdGVyOlwi4om4XCIsTm90TGVzc0xlc3M6XCLiiarMuFwiLE5vdExlc3NTbGFudEVxdWFsOlwi4qm9zLhcIixOb3RMZXNzVGlsZGU6XCLiibRcIixOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjpcIuKqosy4XCIsTm90TmVzdGVkTGVzc0xlc3M6XCLiqqHMuFwiLG5vdG5pOlwi4oiMXCIsbm90bml2YTpcIuKIjFwiLG5vdG5pdmI6XCLii75cIixub3RuaXZjOlwi4ou9XCIsTm90UHJlY2VkZXM6XCLiioBcIixOb3RQcmVjZWRlc0VxdWFsOlwi4qqvzLhcIixOb3RQcmVjZWRlc1NsYW50RXF1YWw6XCLii6BcIixOb3RSZXZlcnNlRWxlbWVudDpcIuKIjFwiLE5vdFJpZ2h0VHJpYW5nbGU6XCLii6tcIixOb3RSaWdodFRyaWFuZ2xlQmFyOlwi4qeQzLhcIixOb3RSaWdodFRyaWFuZ2xlRXF1YWw6XCLii61cIixOb3RTcXVhcmVTdWJzZXQ6XCLiio/MuFwiLE5vdFNxdWFyZVN1YnNldEVxdWFsOlwi4ouiXCIsTm90U3F1YXJlU3VwZXJzZXQ6XCLiipDMuFwiLE5vdFNxdWFyZVN1cGVyc2V0RXF1YWw6XCLii6NcIixOb3RTdWJzZXQ6XCLiioLig5JcIixOb3RTdWJzZXRFcXVhbDpcIuKKiFwiLE5vdFN1Y2NlZWRzOlwi4oqBXCIsTm90U3VjY2VlZHNFcXVhbDpcIuKqsMy4XCIsTm90U3VjY2VlZHNTbGFudEVxdWFsOlwi4ouhXCIsTm90U3VjY2VlZHNUaWxkZTpcIuKJv8y4XCIsTm90U3VwZXJzZXQ6XCLiioPig5JcIixOb3RTdXBlcnNldEVxdWFsOlwi4oqJXCIsTm90VGlsZGU6XCLiiYFcIixOb3RUaWxkZUVxdWFsOlwi4omEXCIsTm90VGlsZGVGdWxsRXF1YWw6XCLiiYdcIixOb3RUaWxkZVRpbGRlOlwi4omJXCIsTm90VmVydGljYWxCYXI6XCLiiKRcIixucGFyOlwi4oimXCIsbnBhcmFsbGVsOlwi4oimXCIsbnBhcnNsOlwi4qu94oOlXCIsbnBhcnQ6XCLiiILMuFwiLG5wb2xpbnQ6XCLiqJRcIixucHI6XCLiioBcIixucHJjdWU6XCLii6BcIixucHJlOlwi4qqvzLhcIixucHJlYzpcIuKKgFwiLG5wcmVjZXE6XCLiqq/MuFwiLG5yQXJyOlwi4oePXCIsbnJhcnI6XCLihptcIixucmFycmM6XCLipLPMuFwiLG5yYXJydzpcIuKGncy4XCIsblJpZ2h0YXJyb3c6XCLih49cIixucmlnaHRhcnJvdzpcIuKGm1wiLG5ydHJpOlwi4ourXCIsbnJ0cmllOlwi4outXCIsbnNjOlwi4oqBXCIsbnNjY3VlOlwi4ouhXCIsbnNjZTpcIuKqsMy4XCIsTnNjcjpcIvCdkqlcIixuc2NyOlwi8J2Tg1wiLG5zaG9ydG1pZDpcIuKIpFwiLG5zaG9ydHBhcmFsbGVsOlwi4oimXCIsbnNpbTpcIuKJgVwiLG5zaW1lOlwi4omEXCIsbnNpbWVxOlwi4omEXCIsbnNtaWQ6XCLiiKRcIixuc3BhcjpcIuKIplwiLG5zcXN1YmU6XCLii6JcIixuc3FzdXBlOlwi4oujXCIsbnN1YjpcIuKKhFwiLG5zdWJFOlwi4quFzLhcIixuc3ViZTpcIuKKiFwiLG5zdWJzZXQ6XCLiioLig5JcIixuc3Vic2V0ZXE6XCLiiohcIixuc3Vic2V0ZXFxOlwi4quFzLhcIixuc3VjYzpcIuKKgVwiLG5zdWNjZXE6XCLiqrDMuFwiLG5zdXA6XCLiioVcIixuc3VwRTpcIuKrhsy4XCIsbnN1cGU6XCLiiolcIixuc3Vwc2V0Olwi4oqD4oOSXCIsbnN1cHNldGVxOlwi4oqJXCIsbnN1cHNldGVxcTpcIuKrhsy4XCIsbnRnbDpcIuKJuVwiLE50aWxkZTpcIsORXCIsbnRpbGRlOlwiw7FcIixudGxnOlwi4om4XCIsbnRyaWFuZ2xlbGVmdDpcIuKLqlwiLG50cmlhbmdsZWxlZnRlcTpcIuKLrFwiLG50cmlhbmdsZXJpZ2h0Olwi4ourXCIsbnRyaWFuZ2xlcmlnaHRlcTpcIuKLrVwiLE51Olwizp1cIixudTpcIs69XCIsbnVtOlwiI1wiLG51bWVybzpcIuKEllwiLG51bXNwOlwi4oCHXCIsbnZhcDpcIuKJjeKDklwiLG5WRGFzaDpcIuKKr1wiLG5WZGFzaDpcIuKKrlwiLG52RGFzaDpcIuKKrVwiLG52ZGFzaDpcIuKKrFwiLG52Z2U6XCLiiaXig5JcIixudmd0OlwiPuKDklwiLG52SGFycjpcIuKkhFwiLG52aW5maW46XCLip55cIixudmxBcnI6XCLipIJcIixudmxlOlwi4omk4oOSXCIsbnZsdDpcIjzig5JcIixudmx0cmllOlwi4oq04oOSXCIsbnZyQXJyOlwi4qSDXCIsbnZydHJpZTpcIuKKteKDklwiLG52c2ltOlwi4oi84oOSXCIsbndhcmhrOlwi4qSjXCIsbndBcnI6XCLih5ZcIixud2FycjpcIuKGllwiLG53YXJyb3c6XCLihpZcIixud25lYXI6XCLipKdcIixPYWN1dGU6XCLDk1wiLG9hY3V0ZTpcIsOzXCIsb2FzdDpcIuKKm1wiLG9jaXI6XCLiippcIixPY2lyYzpcIsOUXCIsb2NpcmM6XCLDtFwiLE9jeTpcItCeXCIsb2N5Olwi0L5cIixvZGFzaDpcIuKKnVwiLE9kYmxhYzpcIsWQXCIsb2RibGFjOlwixZFcIixvZGl2Olwi4qi4XCIsb2RvdDpcIuKKmVwiLG9kc29sZDpcIuKmvFwiLE9FbGlnOlwixZJcIixvZWxpZzpcIsWTXCIsb2ZjaXI6XCLipr9cIixPZnI6XCLwnZSSXCIsb2ZyOlwi8J2UrFwiLG9nb246XCLLm1wiLE9ncmF2ZTpcIsOSXCIsb2dyYXZlOlwiw7JcIixvZ3Q6XCLip4FcIixvaGJhcjpcIuKmtVwiLG9obTpcIs6pXCIsb2ludDpcIuKIrlwiLG9sYXJyOlwi4oa6XCIsb2xjaXI6XCLipr5cIixvbGNyb3NzOlwi4qa7XCIsb2xpbmU6XCLigL5cIixvbHQ6XCLip4BcIixPbWFjcjpcIsWMXCIsb21hY3I6XCLFjVwiLE9tZWdhOlwizqlcIixvbWVnYTpcIs+JXCIsT21pY3JvbjpcIs6fXCIsb21pY3JvbjpcIs6/XCIsb21pZDpcIuKmtlwiLG9taW51czpcIuKKllwiLE9vcGY6XCLwnZWGXCIsb29wZjpcIvCdlaBcIixvcGFyOlwi4qa3XCIsT3BlbkN1cmx5RG91YmxlUXVvdGU6XCLigJxcIixPcGVuQ3VybHlRdW90ZTpcIuKAmFwiLG9wZXJwOlwi4qa5XCIsb3BsdXM6XCLiipVcIixPcjpcIuKplFwiLG9yOlwi4oioXCIsb3JhcnI6XCLihrtcIixvcmQ6XCLiqZ1cIixvcmRlcjpcIuKEtFwiLG9yZGVyb2Y6XCLihLRcIixvcmRmOlwiwqpcIixvcmRtOlwiwrpcIixvcmlnb2Y6XCLiirZcIixvcm9yOlwi4qmWXCIsb3JzbG9wZTpcIuKpl1wiLG9ydjpcIuKpm1wiLG9TOlwi4pOIXCIsT3NjcjpcIvCdkqpcIixvc2NyOlwi4oS0XCIsT3NsYXNoOlwiw5hcIixvc2xhc2g6XCLDuFwiLG9zb2w6XCLiiphcIixPdGlsZGU6XCLDlVwiLG90aWxkZTpcIsO1XCIsT3RpbWVzOlwi4qi3XCIsb3RpbWVzOlwi4oqXXCIsb3RpbWVzYXM6XCLiqLZcIixPdW1sOlwiw5ZcIixvdW1sOlwiw7ZcIixvdmJhcjpcIuKMvVwiLE92ZXJCYXI6XCLigL5cIixPdmVyQnJhY2U6XCLij55cIixPdmVyQnJhY2tldDpcIuKOtFwiLE92ZXJQYXJlbnRoZXNpczpcIuKPnFwiLHBhcjpcIuKIpVwiLHBhcmE6XCLCtlwiLHBhcmFsbGVsOlwi4oilXCIscGFyc2ltOlwi4quzXCIscGFyc2w6XCLiq71cIixwYXJ0Olwi4oiCXCIsUGFydGlhbEQ6XCLiiIJcIixQY3k6XCLQn1wiLHBjeTpcItC/XCIscGVyY250OlwiJVwiLHBlcmlvZDpcIi5cIixwZXJtaWw6XCLigLBcIixwZXJwOlwi4oqlXCIscGVydGVuazpcIuKAsVwiLFBmcjpcIvCdlJNcIixwZnI6XCLwnZStXCIsUGhpOlwizqZcIixwaGk6XCLPhlwiLHBoaXY6XCLPlVwiLHBobW1hdDpcIuKEs1wiLHBob25lOlwi4piOXCIsUGk6XCLOoFwiLHBpOlwiz4BcIixwaXRjaGZvcms6XCLii5RcIixwaXY6XCLPllwiLHBsYW5jazpcIuKEj1wiLHBsYW5ja2g6XCLihI5cIixwbGFua3Y6XCLihI9cIixwbHVzOlwiK1wiLHBsdXNhY2lyOlwi4qijXCIscGx1c2I6XCLiip5cIixwbHVzY2lyOlwi4qiiXCIscGx1c2RvOlwi4oiUXCIscGx1c2R1Olwi4qilXCIscGx1c2U6XCLiqbJcIixQbHVzTWludXM6XCLCsVwiLHBsdXNtbjpcIsKxXCIscGx1c3NpbTpcIuKoplwiLHBsdXN0d286XCLiqKdcIixwbTpcIsKxXCIsUG9pbmNhcmVwbGFuZTpcIuKEjFwiLHBvaW50aW50Olwi4qiVXCIsUG9wZjpcIuKEmVwiLHBvcGY6XCLwnZWhXCIscG91bmQ6XCLCo1wiLFByOlwi4qq7XCIscHI6XCLiibpcIixwcmFwOlwi4qq3XCIscHJjdWU6XCLiibxcIixwckU6XCLiqrNcIixwcmU6XCLiqq9cIixwcmVjOlwi4om6XCIscHJlY2FwcHJveDpcIuKqt1wiLHByZWNjdXJseWVxOlwi4om8XCIsUHJlY2VkZXM6XCLiibpcIixQcmVjZWRlc0VxdWFsOlwi4qqvXCIsUHJlY2VkZXNTbGFudEVxdWFsOlwi4om8XCIsUHJlY2VkZXNUaWxkZTpcIuKJvlwiLHByZWNlcTpcIuKqr1wiLHByZWNuYXBwcm94Olwi4qq5XCIscHJlY25lcXE6XCLiqrVcIixwcmVjbnNpbTpcIuKLqFwiLHByZWNzaW06XCLiib5cIixQcmltZTpcIuKAs1wiLHByaW1lOlwi4oCyXCIscHJpbWVzOlwi4oSZXCIscHJuYXA6XCLiqrlcIixwcm5FOlwi4qq1XCIscHJuc2ltOlwi4ouoXCIscHJvZDpcIuKIj1wiLFByb2R1Y3Q6XCLiiI9cIixwcm9mYWxhcjpcIuKMrlwiLHByb2ZsaW5lOlwi4oySXCIscHJvZnN1cmY6XCLijJNcIixwcm9wOlwi4oidXCIsUHJvcG9ydGlvbjpcIuKIt1wiLFByb3BvcnRpb25hbDpcIuKInVwiLHByb3B0bzpcIuKInVwiLHByc2ltOlwi4om+XCIscHJ1cmVsOlwi4oqwXCIsUHNjcjpcIvCdkqtcIixwc2NyOlwi8J2ThVwiLFBzaTpcIs6oXCIscHNpOlwiz4hcIixwdW5jc3A6XCLigIhcIixRZnI6XCLwnZSUXCIscWZyOlwi8J2UrlwiLHFpbnQ6XCLiqIxcIixRb3BmOlwi4oSaXCIscW9wZjpcIvCdlaJcIixxcHJpbWU6XCLigZdcIixRc2NyOlwi8J2SrFwiLHFzY3I6XCLwnZOGXCIscXVhdGVybmlvbnM6XCLihI1cIixxdWF0aW50Olwi4qiWXCIscXVlc3Q6XCI/XCIscXVlc3RlcTpcIuKJn1wiLFFVT1Q6J1wiJyxxdW90OidcIicsckFhcnI6XCLih5tcIixyYWNlOlwi4oi9zLFcIixSYWN1dGU6XCLFlFwiLHJhY3V0ZTpcIsWVXCIscmFkaWM6XCLiiJpcIixyYWVtcHR5djpcIuKms1wiLFJhbmc6XCLin6tcIixyYW5nOlwi4p+pXCIscmFuZ2Q6XCLippJcIixyYW5nZTpcIuKmpVwiLHJhbmdsZTpcIuKfqVwiLHJhcXVvOlwiwrtcIixSYXJyOlwi4oagXCIsckFycjpcIuKHklwiLHJhcnI6XCLihpJcIixyYXJyYXA6XCLipbVcIixyYXJyYjpcIuKHpVwiLHJhcnJiZnM6XCLipKBcIixyYXJyYzpcIuKks1wiLHJhcnJmczpcIuKknlwiLHJhcnJoazpcIuKGqlwiLHJhcnJscDpcIuKGrFwiLHJhcnJwbDpcIuKlhVwiLHJhcnJzaW06XCLipbRcIixSYXJydGw6XCLipJZcIixyYXJydGw6XCLihqNcIixyYXJydzpcIuKGnVwiLHJBdGFpbDpcIuKknFwiLHJhdGFpbDpcIuKkmlwiLHJhdGlvOlwi4oi2XCIscmF0aW9uYWxzOlwi4oSaXCIsUkJhcnI6XCLipJBcIixyQmFycjpcIuKkj1wiLHJiYXJyOlwi4qSNXCIscmJicms6XCLinbNcIixyYnJhY2U6XCJ9XCIscmJyYWNrOlwiXVwiLHJicmtlOlwi4qaMXCIscmJya3NsZDpcIuKmjlwiLHJicmtzbHU6XCLippBcIixSY2Fyb246XCLFmFwiLHJjYXJvbjpcIsWZXCIsUmNlZGlsOlwixZZcIixyY2VkaWw6XCLFl1wiLHJjZWlsOlwi4oyJXCIscmN1YjpcIn1cIixSY3k6XCLQoFwiLHJjeTpcItGAXCIscmRjYTpcIuKkt1wiLHJkbGRoYXI6XCLipalcIixyZHF1bzpcIuKAnVwiLHJkcXVvcjpcIuKAnVwiLHJkc2g6XCLihrNcIixSZTpcIuKEnFwiLHJlYWw6XCLihJxcIixyZWFsaW5lOlwi4oSbXCIscmVhbHBhcnQ6XCLihJxcIixyZWFsczpcIuKEnVwiLHJlY3Q6XCLilq1cIixSRUc6XCLCrlwiLHJlZzpcIsKuXCIsUmV2ZXJzZUVsZW1lbnQ6XCLiiItcIixSZXZlcnNlRXF1aWxpYnJpdW06XCLih4tcIixSZXZlcnNlVXBFcXVpbGlicml1bTpcIuKlr1wiLHJmaXNodDpcIuKlvVwiLHJmbG9vcjpcIuKMi1wiLFJmcjpcIuKEnFwiLHJmcjpcIvCdlK9cIixySGFyOlwi4qWkXCIscmhhcmQ6XCLih4FcIixyaGFydTpcIuKHgFwiLHJoYXJ1bDpcIuKlrFwiLFJobzpcIs6hXCIscmhvOlwiz4FcIixyaG92Olwiz7FcIixSaWdodEFuZ2xlQnJhY2tldDpcIuKfqVwiLFJpZ2h0QXJyb3c6XCLihpJcIixSaWdodGFycm93Olwi4oeSXCIscmlnaHRhcnJvdzpcIuKGklwiLFJpZ2h0QXJyb3dCYXI6XCLih6VcIixSaWdodEFycm93TGVmdEFycm93Olwi4oeEXCIscmlnaHRhcnJvd3RhaWw6XCLihqNcIixSaWdodENlaWxpbmc6XCLijIlcIixSaWdodERvdWJsZUJyYWNrZXQ6XCLin6dcIixSaWdodERvd25UZWVWZWN0b3I6XCLipZ1cIixSaWdodERvd25WZWN0b3I6XCLih4JcIixSaWdodERvd25WZWN0b3JCYXI6XCLipZVcIixSaWdodEZsb29yOlwi4oyLXCIscmlnaHRoYXJwb29uZG93bjpcIuKHgVwiLHJpZ2h0aGFycG9vbnVwOlwi4oeAXCIscmlnaHRsZWZ0YXJyb3dzOlwi4oeEXCIscmlnaHRsZWZ0aGFycG9vbnM6XCLih4xcIixyaWdodHJpZ2h0YXJyb3dzOlwi4oeJXCIscmlnaHRzcXVpZ2Fycm93Olwi4oadXCIsUmlnaHRUZWU6XCLiiqJcIixSaWdodFRlZUFycm93Olwi4oamXCIsUmlnaHRUZWVWZWN0b3I6XCLipZtcIixyaWdodHRocmVldGltZXM6XCLii4xcIixSaWdodFRyaWFuZ2xlOlwi4oqzXCIsUmlnaHRUcmlhbmdsZUJhcjpcIuKnkFwiLFJpZ2h0VHJpYW5nbGVFcXVhbDpcIuKKtVwiLFJpZ2h0VXBEb3duVmVjdG9yOlwi4qWPXCIsUmlnaHRVcFRlZVZlY3RvcjpcIuKlnFwiLFJpZ2h0VXBWZWN0b3I6XCLihr5cIixSaWdodFVwVmVjdG9yQmFyOlwi4qWUXCIsUmlnaHRWZWN0b3I6XCLih4BcIixSaWdodFZlY3RvckJhcjpcIuKlk1wiLHJpbmc6XCLLmlwiLHJpc2luZ2RvdHNlcTpcIuKJk1wiLHJsYXJyOlwi4oeEXCIscmxoYXI6XCLih4xcIixybG06XCLigI9cIixybW91c3Q6XCLijrFcIixybW91c3RhY2hlOlwi4o6xXCIscm5taWQ6XCLiq65cIixyb2FuZzpcIuKfrVwiLHJvYXJyOlwi4oe+XCIscm9icms6XCLin6dcIixyb3BhcjpcIuKmhlwiLFJvcGY6XCLihJ1cIixyb3BmOlwi8J2Vo1wiLHJvcGx1czpcIuKorlwiLHJvdGltZXM6XCLiqLVcIixSb3VuZEltcGxpZXM6XCLipbBcIixycGFyOlwiKVwiLHJwYXJndDpcIuKmlFwiLHJwcG9saW50Olwi4qiSXCIscnJhcnI6XCLih4lcIixScmlnaHRhcnJvdzpcIuKHm1wiLHJzYXF1bzpcIuKAulwiLFJzY3I6XCLihJtcIixyc2NyOlwi8J2Th1wiLFJzaDpcIuKGsVwiLHJzaDpcIuKGsVwiLHJzcWI6XCJdXCIscnNxdW86XCLigJlcIixyc3F1b3I6XCLigJlcIixydGhyZWU6XCLii4xcIixydGltZXM6XCLii4pcIixydHJpOlwi4pa5XCIscnRyaWU6XCLiirVcIixydHJpZjpcIuKWuFwiLHJ0cmlsdHJpOlwi4qeOXCIsUnVsZURlbGF5ZWQ6XCLip7RcIixydWx1aGFyOlwi4qWoXCIscng6XCLihJ5cIixTYWN1dGU6XCLFmlwiLHNhY3V0ZTpcIsWbXCIsc2JxdW86XCLigJpcIixTYzpcIuKqvFwiLHNjOlwi4om7XCIsc2NhcDpcIuKquFwiLFNjYXJvbjpcIsWgXCIsc2Nhcm9uOlwixaFcIixzY2N1ZTpcIuKJvVwiLHNjRTpcIuKqtFwiLHNjZTpcIuKqsFwiLFNjZWRpbDpcIsWeXCIsc2NlZGlsOlwixZ9cIixTY2lyYzpcIsWcXCIsc2NpcmM6XCLFnVwiLHNjbmFwOlwi4qq6XCIsc2NuRTpcIuKqtlwiLHNjbnNpbTpcIuKLqVwiLHNjcG9saW50Olwi4qiTXCIsc2NzaW06XCLiib9cIixTY3k6XCLQoVwiLHNjeTpcItGBXCIsc2RvdDpcIuKLhVwiLHNkb3RiOlwi4oqhXCIsc2RvdGU6XCLiqaZcIixzZWFyaGs6XCLipKVcIixzZUFycjpcIuKHmFwiLHNlYXJyOlwi4oaYXCIsc2VhcnJvdzpcIuKGmFwiLHNlY3Q6XCLCp1wiLHNlbWk6XCI7XCIsc2Vzd2FyOlwi4qSpXCIsc2V0bWludXM6XCLiiJZcIixzZXRtbjpcIuKIllwiLHNleHQ6XCLinLZcIixTZnI6XCLwnZSWXCIsc2ZyOlwi8J2UsFwiLHNmcm93bjpcIuKMolwiLHNoYXJwOlwi4pmvXCIsU0hDSGN5Olwi0KlcIixzaGNoY3k6XCLRiVwiLFNIY3k6XCLQqFwiLHNoY3k6XCLRiFwiLFNob3J0RG93bkFycm93Olwi4oaTXCIsU2hvcnRMZWZ0QXJyb3c6XCLihpBcIixzaG9ydG1pZDpcIuKIo1wiLHNob3J0cGFyYWxsZWw6XCLiiKVcIixTaG9ydFJpZ2h0QXJyb3c6XCLihpJcIixTaG9ydFVwQXJyb3c6XCLihpFcIixzaHk6XCLCrVwiLFNpZ21hOlwizqNcIixzaWdtYTpcIs+DXCIsc2lnbWFmOlwiz4JcIixzaWdtYXY6XCLPglwiLHNpbTpcIuKIvFwiLHNpbWRvdDpcIuKpqlwiLHNpbWU6XCLiiYNcIixzaW1lcTpcIuKJg1wiLHNpbWc6XCLiqp5cIixzaW1nRTpcIuKqoFwiLHNpbWw6XCLiqp1cIixzaW1sRTpcIuKqn1wiLHNpbW5lOlwi4omGXCIsc2ltcGx1czpcIuKopFwiLHNpbXJhcnI6XCLipbJcIixzbGFycjpcIuKGkFwiLFNtYWxsQ2lyY2xlOlwi4oiYXCIsc21hbGxzZXRtaW51czpcIuKIllwiLHNtYXNocDpcIuKos1wiLHNtZXBhcnNsOlwi4qekXCIsc21pZDpcIuKIo1wiLHNtaWxlOlwi4oyjXCIsc210Olwi4qqqXCIsc210ZTpcIuKqrFwiLHNtdGVzOlwi4qqs77iAXCIsU09GVGN5Olwi0KxcIixzb2Z0Y3k6XCLRjFwiLHNvbDpcIi9cIixzb2xiOlwi4qeEXCIsc29sYmFyOlwi4oy/XCIsU29wZjpcIvCdlYpcIixzb3BmOlwi8J2VpFwiLHNwYWRlczpcIuKZoFwiLHNwYWRlc3VpdDpcIuKZoFwiLHNwYXI6XCLiiKVcIixzcWNhcDpcIuKKk1wiLHNxY2FwczpcIuKKk++4gFwiLHNxY3VwOlwi4oqUXCIsc3FjdXBzOlwi4oqU77iAXCIsU3FydDpcIuKImlwiLHNxc3ViOlwi4oqPXCIsc3FzdWJlOlwi4oqRXCIsc3FzdWJzZXQ6XCLiio9cIixzcXN1YnNldGVxOlwi4oqRXCIsc3FzdXA6XCLiipBcIixzcXN1cGU6XCLiipJcIixzcXN1cHNldDpcIuKKkFwiLHNxc3Vwc2V0ZXE6XCLiipJcIixzcXU6XCLilqFcIixTcXVhcmU6XCLilqFcIixzcXVhcmU6XCLilqFcIixTcXVhcmVJbnRlcnNlY3Rpb246XCLiipNcIixTcXVhcmVTdWJzZXQ6XCLiio9cIixTcXVhcmVTdWJzZXRFcXVhbDpcIuKKkVwiLFNxdWFyZVN1cGVyc2V0Olwi4oqQXCIsU3F1YXJlU3VwZXJzZXRFcXVhbDpcIuKKklwiLFNxdWFyZVVuaW9uOlwi4oqUXCIsc3F1YXJmOlwi4paqXCIsc3F1ZjpcIuKWqlwiLHNyYXJyOlwi4oaSXCIsU3NjcjpcIvCdkq5cIixzc2NyOlwi8J2TiFwiLHNzZXRtbjpcIuKIllwiLHNzbWlsZTpcIuKMo1wiLHNzdGFyZjpcIuKLhlwiLFN0YXI6XCLii4ZcIixzdGFyOlwi4piGXCIsc3RhcmY6XCLimIVcIixzdHJhaWdodGVwc2lsb246XCLPtVwiLHN0cmFpZ2h0cGhpOlwiz5VcIixzdHJuczpcIsKvXCIsU3ViOlwi4ouQXCIsc3ViOlwi4oqCXCIsc3ViZG90Olwi4qq9XCIsc3ViRTpcIuKrhVwiLHN1YmU6XCLiioZcIixzdWJlZG90Olwi4quDXCIsc3VibXVsdDpcIuKrgVwiLHN1Ym5FOlwi4quLXCIsc3VibmU6XCLiiopcIixzdWJwbHVzOlwi4qq/XCIsc3VicmFycjpcIuKluVwiLFN1YnNldDpcIuKLkFwiLHN1YnNldDpcIuKKglwiLHN1YnNldGVxOlwi4oqGXCIsc3Vic2V0ZXFxOlwi4quFXCIsU3Vic2V0RXF1YWw6XCLiioZcIixzdWJzZXRuZXE6XCLiiopcIixzdWJzZXRuZXFxOlwi4quLXCIsc3Vic2ltOlwi4quHXCIsc3Vic3ViOlwi4quVXCIsc3Vic3VwOlwi4quTXCIsc3VjYzpcIuKJu1wiLHN1Y2NhcHByb3g6XCLiqrhcIixzdWNjY3VybHllcTpcIuKJvVwiLFN1Y2NlZWRzOlwi4om7XCIsU3VjY2VlZHNFcXVhbDpcIuKqsFwiLFN1Y2NlZWRzU2xhbnRFcXVhbDpcIuKJvVwiLFN1Y2NlZWRzVGlsZGU6XCLiib9cIixzdWNjZXE6XCLiqrBcIixzdWNjbmFwcHJveDpcIuKqulwiLHN1Y2NuZXFxOlwi4qq2XCIsc3VjY25zaW06XCLii6lcIixzdWNjc2ltOlwi4om/XCIsU3VjaFRoYXQ6XCLiiItcIixTdW06XCLiiJFcIixzdW06XCLiiJFcIixzdW5nOlwi4pmqXCIsU3VwOlwi4ouRXCIsc3VwOlwi4oqDXCIsc3VwMTpcIsK5XCIsc3VwMjpcIsKyXCIsc3VwMzpcIsKzXCIsc3VwZG90Olwi4qq+XCIsc3VwZHN1YjpcIuKrmFwiLHN1cEU6XCLiq4ZcIixzdXBlOlwi4oqHXCIsc3VwZWRvdDpcIuKrhFwiLFN1cGVyc2V0Olwi4oqDXCIsU3VwZXJzZXRFcXVhbDpcIuKKh1wiLHN1cGhzb2w6XCLin4lcIixzdXBoc3ViOlwi4quXXCIsc3VwbGFycjpcIuKlu1wiLHN1cG11bHQ6XCLiq4JcIixzdXBuRTpcIuKrjFwiLHN1cG5lOlwi4oqLXCIsc3VwcGx1czpcIuKrgFwiLFN1cHNldDpcIuKLkVwiLHN1cHNldDpcIuKKg1wiLHN1cHNldGVxOlwi4oqHXCIsc3Vwc2V0ZXFxOlwi4quGXCIsc3Vwc2V0bmVxOlwi4oqLXCIsc3Vwc2V0bmVxcTpcIuKrjFwiLHN1cHNpbTpcIuKriFwiLHN1cHN1YjpcIuKrlFwiLHN1cHN1cDpcIuKrllwiLHN3YXJoazpcIuKkplwiLHN3QXJyOlwi4oeZXCIsc3dhcnI6XCLihplcIixzd2Fycm93Olwi4oaZXCIsc3dud2FyOlwi4qSqXCIsc3psaWc6XCLDn1wiLFRhYjpcIlxcdFwiLHRhcmdldDpcIuKMllwiLFRhdTpcIs6kXCIsdGF1Olwiz4RcIix0YnJrOlwi4o60XCIsVGNhcm9uOlwixaRcIix0Y2Fyb246XCLFpVwiLFRjZWRpbDpcIsWiXCIsdGNlZGlsOlwixaNcIixUY3k6XCLQolwiLHRjeTpcItGCXCIsdGRvdDpcIuKDm1wiLHRlbHJlYzpcIuKMlVwiLFRmcjpcIvCdlJdcIix0ZnI6XCLwnZSxXCIsdGhlcmU0Olwi4oi0XCIsVGhlcmVmb3JlOlwi4oi0XCIsdGhlcmVmb3JlOlwi4oi0XCIsVGhldGE6XCLOmFwiLHRoZXRhOlwizrhcIix0aGV0YXN5bTpcIs+RXCIsdGhldGF2Olwiz5FcIix0aGlja2FwcHJveDpcIuKJiFwiLHRoaWNrc2ltOlwi4oi8XCIsVGhpY2tTcGFjZTpcIuKBn+KAilwiLHRoaW5zcDpcIuKAiVwiLFRoaW5TcGFjZTpcIuKAiVwiLHRoa2FwOlwi4omIXCIsdGhrc2ltOlwi4oi8XCIsVEhPUk46XCLDnlwiLHRob3JuOlwiw75cIixUaWxkZTpcIuKIvFwiLHRpbGRlOlwiy5xcIixUaWxkZUVxdWFsOlwi4omDXCIsVGlsZGVGdWxsRXF1YWw6XCLiiYVcIixUaWxkZVRpbGRlOlwi4omIXCIsdGltZXM6XCLDl1wiLHRpbWVzYjpcIuKKoFwiLHRpbWVzYmFyOlwi4qixXCIsdGltZXNkOlwi4qiwXCIsdGludDpcIuKIrVwiLHRvZWE6XCLipKhcIix0b3A6XCLiiqRcIix0b3Bib3Q6XCLijLZcIix0b3BjaXI6XCLiq7FcIixUb3BmOlwi8J2Vi1wiLHRvcGY6XCLwnZWlXCIsdG9wZm9yazpcIuKrmlwiLHRvc2E6XCLipKlcIix0cHJpbWU6XCLigLRcIixUUkFERTpcIuKEolwiLHRyYWRlOlwi4oSiXCIsdHJpYW5nbGU6XCLilrVcIix0cmlhbmdsZWRvd246XCLilr9cIix0cmlhbmdsZWxlZnQ6XCLil4NcIix0cmlhbmdsZWxlZnRlcTpcIuKKtFwiLHRyaWFuZ2xlcTpcIuKJnFwiLHRyaWFuZ2xlcmlnaHQ6XCLilrlcIix0cmlhbmdsZXJpZ2h0ZXE6XCLiirVcIix0cmlkb3Q6XCLil6xcIix0cmllOlwi4omcXCIsdHJpbWludXM6XCLiqLpcIixUcmlwbGVEb3Q6XCLig5tcIix0cmlwbHVzOlwi4qi5XCIsdHJpc2I6XCLip41cIix0cml0aW1lOlwi4qi7XCIsdHJwZXppdW06XCLij6JcIixUc2NyOlwi8J2Sr1wiLHRzY3I6XCLwnZOJXCIsVFNjeTpcItCmXCIsdHNjeTpcItGGXCIsVFNIY3k6XCLQi1wiLHRzaGN5Olwi0ZtcIixUc3Ryb2s6XCLFplwiLHRzdHJvazpcIsWnXCIsdHdpeHQ6XCLiiaxcIix0d29oZWFkbGVmdGFycm93Olwi4oaeXCIsdHdvaGVhZHJpZ2h0YXJyb3c6XCLihqBcIixVYWN1dGU6XCLDmlwiLHVhY3V0ZTpcIsO6XCIsVWFycjpcIuKGn1wiLHVBcnI6XCLih5FcIix1YXJyOlwi4oaRXCIsVWFycm9jaXI6XCLipYlcIixVYnJjeTpcItCOXCIsdWJyY3k6XCLRnlwiLFVicmV2ZTpcIsWsXCIsdWJyZXZlOlwixa1cIixVY2lyYzpcIsObXCIsdWNpcmM6XCLDu1wiLFVjeTpcItCjXCIsdWN5Olwi0YNcIix1ZGFycjpcIuKHhVwiLFVkYmxhYzpcIsWwXCIsdWRibGFjOlwixbFcIix1ZGhhcjpcIuKlrlwiLHVmaXNodDpcIuKlvlwiLFVmcjpcIvCdlJhcIix1ZnI6XCLwnZSyXCIsVWdyYXZlOlwiw5lcIix1Z3JhdmU6XCLDuVwiLHVIYXI6XCLipaNcIix1aGFybDpcIuKGv1wiLHVoYXJyOlwi4oa+XCIsdWhibGs6XCLiloBcIix1bGNvcm46XCLijJxcIix1bGNvcm5lcjpcIuKMnFwiLHVsY3JvcDpcIuKMj1wiLHVsdHJpOlwi4pe4XCIsVW1hY3I6XCLFqlwiLHVtYWNyOlwixatcIix1bWw6XCLCqFwiLFVuZGVyQmFyOlwiX1wiLFVuZGVyQnJhY2U6XCLij59cIixVbmRlckJyYWNrZXQ6XCLijrVcIixVbmRlclBhcmVudGhlc2lzOlwi4o+dXCIsVW5pb246XCLii4NcIixVbmlvblBsdXM6XCLiio5cIixVb2dvbjpcIsWyXCIsdW9nb246XCLFs1wiLFVvcGY6XCLwnZWMXCIsdW9wZjpcIvCdlaZcIixVcEFycm93Olwi4oaRXCIsVXBhcnJvdzpcIuKHkVwiLHVwYXJyb3c6XCLihpFcIixVcEFycm93QmFyOlwi4qSSXCIsVXBBcnJvd0Rvd25BcnJvdzpcIuKHhVwiLFVwRG93bkFycm93Olwi4oaVXCIsVXBkb3duYXJyb3c6XCLih5VcIix1cGRvd25hcnJvdzpcIuKGlVwiLFVwRXF1aWxpYnJpdW06XCLipa5cIix1cGhhcnBvb25sZWZ0Olwi4oa/XCIsdXBoYXJwb29ucmlnaHQ6XCLihr5cIix1cGx1czpcIuKKjlwiLFVwcGVyTGVmdEFycm93Olwi4oaWXCIsVXBwZXJSaWdodEFycm93Olwi4oaXXCIsVXBzaTpcIs+SXCIsdXBzaTpcIs+FXCIsdXBzaWg6XCLPklwiLFVwc2lsb246XCLOpVwiLHVwc2lsb246XCLPhVwiLFVwVGVlOlwi4oqlXCIsVXBUZWVBcnJvdzpcIuKGpVwiLHVwdXBhcnJvd3M6XCLih4hcIix1cmNvcm46XCLijJ1cIix1cmNvcm5lcjpcIuKMnVwiLHVyY3JvcDpcIuKMjlwiLFVyaW5nOlwixa5cIix1cmluZzpcIsWvXCIsdXJ0cmk6XCLil7lcIixVc2NyOlwi8J2SsFwiLHVzY3I6XCLwnZOKXCIsdXRkb3Q6XCLii7BcIixVdGlsZGU6XCLFqFwiLHV0aWxkZTpcIsWpXCIsdXRyaTpcIuKWtVwiLHV0cmlmOlwi4pa0XCIsdXVhcnI6XCLih4hcIixVdW1sOlwiw5xcIix1dW1sOlwiw7xcIix1d2FuZ2xlOlwi4qanXCIsdmFuZ3J0Olwi4qacXCIsdmFyZXBzaWxvbjpcIs+1XCIsdmFya2FwcGE6XCLPsFwiLHZhcm5vdGhpbmc6XCLiiIVcIix2YXJwaGk6XCLPlVwiLHZhcnBpOlwiz5ZcIix2YXJwcm9wdG86XCLiiJ1cIix2QXJyOlwi4oeVXCIsdmFycjpcIuKGlVwiLHZhcnJobzpcIs+xXCIsdmFyc2lnbWE6XCLPglwiLHZhcnN1YnNldG5lcTpcIuKKiu+4gFwiLHZhcnN1YnNldG5lcXE6XCLiq4vvuIBcIix2YXJzdXBzZXRuZXE6XCLiiovvuIBcIix2YXJzdXBzZXRuZXFxOlwi4quM77iAXCIsdmFydGhldGE6XCLPkVwiLHZhcnRyaWFuZ2xlbGVmdDpcIuKKslwiLHZhcnRyaWFuZ2xlcmlnaHQ6XCLiirNcIixWYmFyOlwi4qurXCIsdkJhcjpcIuKrqFwiLHZCYXJ2Olwi4qupXCIsVmN5Olwi0JJcIix2Y3k6XCLQslwiLFZEYXNoOlwi4oqrXCIsVmRhc2g6XCLiiqlcIix2RGFzaDpcIuKKqFwiLHZkYXNoOlwi4oqiXCIsVmRhc2hsOlwi4qumXCIsVmVlOlwi4ouBXCIsdmVlOlwi4oioXCIsdmVlYmFyOlwi4oq7XCIsdmVlZXE6XCLiiZpcIix2ZWxsaXA6XCLii65cIixWZXJiYXI6XCLigJZcIix2ZXJiYXI6XCJ8XCIsVmVydDpcIuKAllwiLHZlcnQ6XCJ8XCIsVmVydGljYWxCYXI6XCLiiKNcIixWZXJ0aWNhbExpbmU6XCJ8XCIsVmVydGljYWxTZXBhcmF0b3I6XCLinZhcIixWZXJ0aWNhbFRpbGRlOlwi4omAXCIsVmVyeVRoaW5TcGFjZTpcIuKAilwiLFZmcjpcIvCdlJlcIix2ZnI6XCLwnZSzXCIsdmx0cmk6XCLiirJcIix2bnN1YjpcIuKKguKDklwiLHZuc3VwOlwi4oqD4oOSXCIsVm9wZjpcIvCdlY1cIix2b3BmOlwi8J2Vp1wiLHZwcm9wOlwi4oidXCIsdnJ0cmk6XCLiirNcIixWc2NyOlwi8J2SsVwiLHZzY3I6XCLwnZOLXCIsdnN1Ym5FOlwi4quL77iAXCIsdnN1Ym5lOlwi4oqK77iAXCIsdnN1cG5FOlwi4quM77iAXCIsdnN1cG5lOlwi4oqL77iAXCIsVnZkYXNoOlwi4oqqXCIsdnppZ3phZzpcIuKmmlwiLFdjaXJjOlwixbRcIix3Y2lyYzpcIsW1XCIsd2VkYmFyOlwi4qmfXCIsV2VkZ2U6XCLii4BcIix3ZWRnZTpcIuKIp1wiLHdlZGdlcTpcIuKJmVwiLHdlaWVycDpcIuKEmFwiLFdmcjpcIvCdlJpcIix3ZnI6XCLwnZS0XCIsV29wZjpcIvCdlY5cIix3b3BmOlwi8J2VqFwiLHdwOlwi4oSYXCIsd3I6XCLiiYBcIix3cmVhdGg6XCLiiYBcIixXc2NyOlwi8J2SslwiLHdzY3I6XCLwnZOMXCIseGNhcDpcIuKLglwiLHhjaXJjOlwi4pevXCIseGN1cDpcIuKLg1wiLHhkdHJpOlwi4pa9XCIsWGZyOlwi8J2Um1wiLHhmcjpcIvCdlLVcIix4aEFycjpcIuKfulwiLHhoYXJyOlwi4p+3XCIsWGk6XCLOnlwiLHhpOlwizr5cIix4bEFycjpcIuKfuFwiLHhsYXJyOlwi4p+1XCIseG1hcDpcIuKfvFwiLHhuaXM6XCLii7tcIix4b2RvdDpcIuKogFwiLFhvcGY6XCLwnZWPXCIseG9wZjpcIvCdlalcIix4b3BsdXM6XCLiqIFcIix4b3RpbWU6XCLiqIJcIix4ckFycjpcIuKfuVwiLHhyYXJyOlwi4p+2XCIsWHNjcjpcIvCdkrNcIix4c2NyOlwi8J2TjVwiLHhzcWN1cDpcIuKohlwiLHh1cGx1czpcIuKohFwiLHh1dHJpOlwi4pazXCIseHZlZTpcIuKLgVwiLHh3ZWRnZTpcIuKLgFwiLFlhY3V0ZTpcIsOdXCIseWFjdXRlOlwiw71cIixZQWN5Olwi0K9cIix5YWN5Olwi0Y9cIixZY2lyYzpcIsW2XCIseWNpcmM6XCLFt1wiLFljeTpcItCrXCIseWN5Olwi0YtcIix5ZW46XCLCpVwiLFlmcjpcIvCdlJxcIix5ZnI6XCLwnZS2XCIsWUljeTpcItCHXCIseWljeTpcItGXXCIsWW9wZjpcIvCdlZBcIix5b3BmOlwi8J2VqlwiLFlzY3I6XCLwnZK0XCIseXNjcjpcIvCdk45cIixZVWN5Olwi0K5cIix5dWN5Olwi0Y5cIixZdW1sOlwixbhcIix5dW1sOlwiw79cIixaYWN1dGU6XCLFuVwiLHphY3V0ZTpcIsW6XCIsWmNhcm9uOlwixb1cIix6Y2Fyb246XCLFvlwiLFpjeTpcItCXXCIsemN5Olwi0LdcIixaZG90OlwixbtcIix6ZG90OlwixbxcIix6ZWV0cmY6XCLihKhcIixaZXJvV2lkdGhTcGFjZTpcIuKAi1wiLFpldGE6XCLOllwiLHpldGE6XCLOtlwiLFpmcjpcIuKEqFwiLHpmcjpcIvCdlLdcIixaSGN5Olwi0JZcIix6aGN5Olwi0LZcIix6aWdyYXJyOlwi4oedXCIsWm9wZjpcIuKEpFwiLHpvcGY6XCLwnZWrXCIsWnNjcjpcIvCdkrVcIix6c2NyOlwi8J2Tj1wiLHp3ajpcIuKAjVwiLHp3bmo6XCLigIxcIn0pLHQuZW50aXR5TWFwPXQuSFRNTF9FTlRJVElFU30sODk3ODooZSx0LHIpPT57dmFyIGE9cig0NzIyKTt0LkRPTUltcGxlbWVudGF0aW9uPWEuRE9NSW1wbGVtZW50YXRpb24sdC5YTUxTZXJpYWxpemVyPWEuWE1MU2VyaWFsaXplcix0LkRPTVBhcnNlcj1yKDU3NTIpLkRPTVBhcnNlcn0sNDQ2NjooZSx0LHIpPT57dmFyIGE9cig0NTgyKS5OQU1FU1BBQ0Usbj0vW0EtWl9hLXpcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS8sbz1uZXcgUmVnRXhwKFwiW1xcXFwtXFxcXC4wLTlcIituLnNvdXJjZS5zbGljZSgxLC0xKStcIlxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXVwiKSxpPW5ldyBSZWdFeHAoXCJeXCIrbi5zb3VyY2Urby5zb3VyY2UrXCIqKD86OlwiK24uc291cmNlK28uc291cmNlK1wiKik/JFwiKTtmdW5jdGlvbiBzKGUsdCl7dGhpcy5tZXNzYWdlPWUsdGhpcy5sb2NhdG9yPXQsRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMscyl9ZnVuY3Rpb24gbCgpe31mdW5jdGlvbiBjKGUsdCl7cmV0dXJuIHQubGluZU51bWJlcj1lLmxpbmVOdW1iZXIsdC5jb2x1bW5OdW1iZXI9ZS5jb2x1bW5OdW1iZXIsdH1mdW5jdGlvbiB1KGUsdCxyLG4sbyxpKXtmdW5jdGlvbiBzKGUsdCxhKXtyLmF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KGUpJiZpLmZhdGFsRXJyb3IoXCJBdHRyaWJ1dGUgXCIrZStcIiByZWRlZmluZWRcIiksci5hZGRWYWx1ZShlLHQucmVwbGFjZSgvW1xcdFxcblxccl0vZyxcIiBcIikucmVwbGFjZSgvJiM/XFx3KzsvZyxvKSxhKX1mb3IodmFyIGwsYz0rK3QsdT0wOzspe3ZhciBoPWUuY2hhckF0KGMpO3N3aXRjaChoKXtjYXNlXCI9XCI6aWYoMT09PXUpbD1lLnNsaWNlKHQsYyksdT0zO2Vsc2V7aWYoMiE9PXUpdGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIGVxdWFsIG11c3QgYWZ0ZXIgYXR0ck5hbWVcIik7dT0zfWJyZWFrO2Nhc2VcIidcIjpjYXNlJ1wiJzppZigzPT09dXx8MT09PXUpe2lmKDE9PT11JiYoaS53YXJuaW5nKCdhdHRyaWJ1dGUgdmFsdWUgbXVzdCBhZnRlciBcIj1cIicpLGw9ZS5zbGljZSh0LGMpKSx0PWMrMSwhKChjPWUuaW5kZXhPZihoLHQpKT4wKSl0aHJvdyBuZXcgRXJyb3IoXCJhdHRyaWJ1dGUgdmFsdWUgbm8gZW5kICdcIitoK1wiJyBtYXRjaFwiKTtzKGwsZD1lLnNsaWNlKHQsYyksdC0xKSx1PTV9ZWxzZXtpZig0IT11KXRocm93IG5ldyBFcnJvcignYXR0cmlidXRlIHZhbHVlIG11c3QgYWZ0ZXIgXCI9XCInKTtzKGwsZD1lLnNsaWNlKHQsYyksdCksaS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2wrJ1wiIG1pc3NlZCBzdGFydCBxdW90KCcraCtcIikhIVwiKSx0PWMrMSx1PTV9YnJlYWs7Y2FzZVwiL1wiOnN3aXRjaCh1KXtjYXNlIDA6ci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSk7Y2FzZSA1OmNhc2UgNjpjYXNlIDc6dT03LHIuY2xvc2VkPSEwO2Nhc2UgNDpjYXNlIDE6YnJlYWs7Y2FzZSAyOnIuY2xvc2VkPSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIGludmFsaWQgY2xvc2UgY2hhcignLycpXCIpfWJyZWFrO2Nhc2VcIlwiOnJldHVybiBpLmVycm9yKFwidW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIiksMD09dSYmci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSksYztjYXNlXCI+XCI6c3dpdGNoKHUpe2Nhc2UgMDpyLnNldFRhZ05hbWUoZS5zbGljZSh0LGMpKTtjYXNlIDU6Y2FzZSA2OmNhc2UgNzpicmVhaztjYXNlIDQ6Y2FzZSAxOlwiL1wiPT09KGQ9ZS5zbGljZSh0LGMpKS5zbGljZSgtMSkmJihyLmNsb3NlZD0hMCxkPWQuc2xpY2UoMCwtMSkpO2Nhc2UgMjoyPT09dSYmKGQ9bCksND09dT8oaS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2QrJ1wiIG1pc3NlZCBxdW90KFwiKSEnKSxzKGwsZCx0KSk6KGEuaXNIVE1MKG5bXCJcIl0pJiZkLm1hdGNoKC9eKD86ZGlzYWJsZWR8Y2hlY2tlZHxzZWxlY3RlZCkkL2kpfHxpLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrZCsnXCIgbWlzc2VkIHZhbHVlISEgXCInK2QrJ1wiIGluc3RlYWQhIScpLHMoZCxkLHQpKTticmVhaztjYXNlIDM6dGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIHZhbHVlIG1pc3NlZCEhXCIpfXJldHVybiBjO2Nhc2VcIsKAXCI6aD1cIiBcIjtkZWZhdWx0OmlmKGg8PVwiIFwiKXN3aXRjaCh1KXtjYXNlIDA6ci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSksdT02O2JyZWFrO2Nhc2UgMTpsPWUuc2xpY2UodCxjKSx1PTI7YnJlYWs7Y2FzZSA0OnZhciBkPWUuc2xpY2UodCxjKTtpLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrZCsnXCIgbWlzc2VkIHF1b3QoXCIpISEnKSxzKGwsZCx0KTtjYXNlIDU6dT02fWVsc2Ugc3dpdGNoKHUpe2Nhc2UgMjpyLnRhZ05hbWUsYS5pc0hUTUwobltcIlwiXSkmJmwubWF0Y2goL14oPzpkaXNhYmxlZHxjaGVja2VkfHNlbGVjdGVkKSQvaSl8fGkud2FybmluZygnYXR0cmlidXRlIFwiJytsKydcIiBtaXNzZWQgdmFsdWUhISBcIicrbCsnXCIgaW5zdGVhZDIhIScpLHMobCxsLHQpLHQ9Yyx1PTE7YnJlYWs7Y2FzZSA1Omkud2FybmluZygnYXR0cmlidXRlIHNwYWNlIGlzIHJlcXVpcmVkXCInK2wrJ1wiISEnKTtjYXNlIDY6dT0xLHQ9YzticmVhaztjYXNlIDM6dT00LHQ9YzticmVhaztjYXNlIDc6dGhyb3cgbmV3IEVycm9yKFwiZWxlbWVudHMgY2xvc2VkIGNoYXJhY3RlciAnLycgYW5kICc+JyBtdXN0IGJlIGNvbm5lY3RlZCB0b1wiKX19YysrfX1mdW5jdGlvbiBoKGUsdCxyKXtmb3IodmFyIG49ZS50YWdOYW1lLG89bnVsbCxpPWUubGVuZ3RoO2ktLTspe3ZhciBzPWVbaV0sbD1zLnFOYW1lLGM9cy52YWx1ZTtpZigobT1sLmluZGV4T2YoXCI6XCIpKT4wKXZhciB1PXMucHJlZml4PWwuc2xpY2UoMCxtKSxoPWwuc2xpY2UobSsxKSxkPVwieG1sbnNcIj09PXUmJmg7ZWxzZSBoPWwsdT1udWxsLGQ9XCJ4bWxuc1wiPT09bCYmXCJcIjtzLmxvY2FsTmFtZT1oLCExIT09ZCYmKG51bGw9PW8mJihvPXt9LHAocixyPXt9KSkscltkXT1vW2RdPWMscy51cmk9YS5YTUxOUyx0LnN0YXJ0UHJlZml4TWFwcGluZyhkLGMpKX1mb3IoaT1lLmxlbmd0aDtpLS07KSh1PShzPWVbaV0pLnByZWZpeCkmJihcInhtbFwiPT09dSYmKHMudXJpPWEuWE1MKSxcInhtbG5zXCIhPT11JiYocy51cmk9clt1fHxcIlwiXSkpO3ZhciBtOyhtPW4uaW5kZXhPZihcIjpcIikpPjA/KHU9ZS5wcmVmaXg9bi5zbGljZSgwLG0pLGg9ZS5sb2NhbE5hbWU9bi5zbGljZShtKzEpKToodT1udWxsLGg9ZS5sb2NhbE5hbWU9bik7dmFyIGY9ZS51cmk9clt1fHxcIlwiXTtpZih0LnN0YXJ0RWxlbWVudChmLGgsbixlKSwhZS5jbG9zZWQpcmV0dXJuIGUuY3VycmVudE5TTWFwPXIsZS5sb2NhbE5TTWFwPW8sITA7aWYodC5lbmRFbGVtZW50KGYsaCxuKSxvKWZvcih1IGluIG8pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sdSkmJnQuZW5kUHJlZml4TWFwcGluZyh1KX1mdW5jdGlvbiBkKGUsdCxyLGEsbil7aWYoL14oPzpzY3JpcHR8dGV4dGFyZWEpJC9pLnRlc3Qocikpe3ZhciBvPWUuaW5kZXhPZihcIjwvXCIrcitcIj5cIix0KSxpPWUuc3Vic3RyaW5nKHQrMSxvKTtpZigvWyY8XS8udGVzdChpKSlyZXR1cm4vXnNjcmlwdCQvaS50ZXN0KHIpPyhuLmNoYXJhY3RlcnMoaSwwLGkubGVuZ3RoKSxvKTooaT1pLnJlcGxhY2UoLyYjP1xcdys7L2csYSksbi5jaGFyYWN0ZXJzKGksMCxpLmxlbmd0aCksbyl9cmV0dXJuIHQrMX1mdW5jdGlvbiBtKGUsdCxyLGEpe3ZhciBuPWFbcl07cmV0dXJuIG51bGw9PW4mJigobj1lLmxhc3RJbmRleE9mKFwiPC9cIityK1wiPlwiKSk8dCYmKG49ZS5sYXN0SW5kZXhPZihcIjwvXCIrcikpLGFbcl09biksbjx0fWZ1bmN0aW9uIHAoZSx0KXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9ZnVuY3Rpb24gZihlLHQscixhKXtpZihcIi1cIj09PWUuY2hhckF0KHQrMikpcmV0dXJuXCItXCI9PT1lLmNoYXJBdCh0KzMpPyhuPWUuaW5kZXhPZihcIi0tXFx4M2VcIix0KzQpKT50PyhyLmNvbW1lbnQoZSx0KzQsbi10LTQpLG4rMyk6KGEuZXJyb3IoXCJVbmNsb3NlZCBjb21tZW50XCIpLC0xKTotMTtpZihcIkNEQVRBW1wiPT1lLnN1YnN0cih0KzMsNikpe3ZhciBuPWUuaW5kZXhPZihcIl1dPlwiLHQrOSk7cmV0dXJuIHIuc3RhcnRDREFUQSgpLHIuY2hhcmFjdGVycyhlLHQrOSxuLXQtOSksci5lbmRDREFUQSgpLG4rM312YXIgbz1mdW5jdGlvbihlLHQpe3ZhciByLGE9W10sbj0vJ1teJ10rJ3xcIlteXCJdK1wifFteXFxzPD5cXC89XSs9P3woXFwvP1xccyo+fDwpL2c7Zm9yKG4ubGFzdEluZGV4PXQsbi5leGVjKGUpO3I9bi5leGVjKGUpOylpZihhLnB1c2gociksclsxXSlyZXR1cm4gYX0oZSx0KSxpPW8ubGVuZ3RoO2lmKGk+MSYmLyFkb2N0eXBlL2kudGVzdChvWzBdWzBdKSl7dmFyIHM9b1sxXVswXSxsPSExLGM9ITE7aT4zJiYoL15wdWJsaWMkL2kudGVzdChvWzJdWzBdKT8obD1vWzNdWzBdLGM9aT40JiZvWzRdWzBdKTovXnN5c3RlbSQvaS50ZXN0KG9bMl1bMF0pJiYoYz1vWzNdWzBdKSk7dmFyIHU9b1tpLTFdO3JldHVybiByLnN0YXJ0RFREKHMsbCxjKSxyLmVuZERURCgpLHUuaW5kZXgrdVswXS5sZW5ndGh9cmV0dXJuLTF9ZnVuY3Rpb24geChlLHQscil7dmFyIGE9ZS5pbmRleE9mKFwiPz5cIix0KTtpZihhKXt2YXIgbj1lLnN1YnN0cmluZyh0LGEpLm1hdGNoKC9ePFxcPyhcXFMqKVxccyooW1xcc1xcU10qPylcXHMqJC8pO3JldHVybiBuPyhuWzBdLmxlbmd0aCxyLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihuWzFdLG5bMl0pLGErMik6LTF9cmV0dXJuLTF9ZnVuY3Rpb24gZygpe3RoaXMuYXR0cmlidXRlTmFtZXM9e319cy5wcm90b3R5cGU9bmV3IEVycm9yLHMucHJvdG90eXBlLm5hbWU9cy5uYW1lLGwucHJvdG90eXBlPXtwYXJzZTpmdW5jdGlvbihlLHQscil7dmFyIG49dGhpcy5kb21CdWlsZGVyO24uc3RhcnREb2N1bWVudCgpLHAodCx0PXt9KSxmdW5jdGlvbihlLHQscixuLG8pe2Z1bmN0aW9uIGkoZSl7dmFyIHQ9ZS5zbGljZSgxLC0xKTtyZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocix0KT9yW3RdOlwiI1wiPT09dC5jaGFyQXQoMCk/ZnVuY3Rpb24oZSl7aWYoZT42NTUzNSl7dmFyIHQ9NTUyOTYrKChlLT02NTUzNik+PjEwKSxyPTU2MzIwKygxMDIzJmUpO3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHQscil9cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZSl9KHBhcnNlSW50KHQuc3Vic3RyKDEpLnJlcGxhY2UoXCJ4XCIsXCIweFwiKSkpOihvLmVycm9yKFwiZW50aXR5IG5vdCBmb3VuZDpcIitlKSxlKX1mdW5jdGlvbiBsKHQpe2lmKHQ+Xyl7dmFyIHI9ZS5zdWJzdHJpbmcoXyx0KS5yZXBsYWNlKC8mIz9cXHcrOy9nLGkpO0MmJnAoXyksbi5jaGFyYWN0ZXJzKHIsMCx0LV8pLF89dH19ZnVuY3Rpb24gcCh0LHIpe2Zvcig7dD49YiYmKHI9di5leGVjKGUpKTspdz1yLmluZGV4LGI9dytyWzBdLmxlbmd0aCxDLmxpbmVOdW1iZXIrKztDLmNvbHVtbk51bWJlcj10LXcrMX1mb3IodmFyIHc9MCxiPTAsdj0vLiooPzpcXHJcXG4/fFxcbil8LiokL2csQz1uLmxvY2F0b3IsQT1be2N1cnJlbnROU01hcDp0fV0sRT17fSxfPTA7Oyl7dHJ5e3ZhciB5PWUuaW5kZXhPZihcIjxcIixfKTtpZih5PDApe2lmKCFlLnN1YnN0cihfKS5tYXRjaCgvXlxccyokLykpe3ZhciBxPW4uZG9jLEQ9cS5jcmVhdGVUZXh0Tm9kZShlLnN1YnN0cihfKSk7cS5hcHBlbmRDaGlsZChEKSxuLmN1cnJlbnRFbGVtZW50PUR9cmV0dXJufXN3aXRjaCh5Pl8mJmwoeSksZS5jaGFyQXQoeSsxKSl7Y2FzZVwiL1wiOnZhciBNPWUuaW5kZXhPZihcIj5cIix5KzMpLFQ9ZS5zdWJzdHJpbmcoeSsyLE0pLnJlcGxhY2UoL1sgXFx0XFxuXFxyXSskL2csXCJcIiksTj1BLnBvcCgpO008MD8oVD1lLnN1YnN0cmluZyh5KzIpLnJlcGxhY2UoL1tcXHM8XS4qLyxcIlwiKSxvLmVycm9yKFwiZW5kIHRhZyBuYW1lOiBcIitUK1wiIGlzIG5vdCBjb21wbGV0ZTpcIitOLnRhZ05hbWUpLE09eSsxK1QubGVuZ3RoKTpULm1hdGNoKC9cXHM8LykmJihUPVQucmVwbGFjZSgvW1xcczxdLiovLFwiXCIpLG8uZXJyb3IoXCJlbmQgdGFnIG5hbWU6IFwiK1QrXCIgbWF5YmUgbm90IGNvbXBsZXRlXCIpLE09eSsxK1QubGVuZ3RoKTt2YXIgTz1OLmxvY2FsTlNNYXAsTD1OLnRhZ05hbWU9PVQ7aWYoTHx8Ti50YWdOYW1lJiZOLnRhZ05hbWUudG9Mb3dlckNhc2UoKT09VC50b0xvd2VyQ2FzZSgpKXtpZihuLmVuZEVsZW1lbnQoTi51cmksTi5sb2NhbE5hbWUsVCksTylmb3IodmFyIEIgaW4gTylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTyxCKSYmbi5lbmRQcmVmaXhNYXBwaW5nKEIpO0x8fG8uZmF0YWxFcnJvcihcImVuZCB0YWcgbmFtZTogXCIrVCtcIiBpcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgc3RhcnQgdGFnTmFtZTpcIitOLnRhZ05hbWUpfWVsc2UgQS5wdXNoKE4pO00rKzticmVhaztjYXNlXCI/XCI6QyYmcCh5KSxNPXgoZSx5LG4pO2JyZWFrO2Nhc2VcIiFcIjpDJiZwKHkpLE09ZihlLHksbixvKTticmVhaztkZWZhdWx0OkMmJnAoeSk7dmFyIFM9bmV3IGcsRj1BW0EubGVuZ3RoLTFdLmN1cnJlbnROU01hcCxQPShNPXUoZSx5LFMsRixpLG8pLFMubGVuZ3RoKTtpZighUy5jbG9zZWQmJm0oZSxNLFMudGFnTmFtZSxFKSYmKFMuY2xvc2VkPSEwLHIubmJzcHx8by53YXJuaW5nKFwidW5jbG9zZWQgeG1sIGF0dHJpYnV0ZVwiKSksQyYmUCl7Zm9yKHZhciBrPWMoQyx7fSksUj0wO1I8UDtSKyspe3ZhciBJPVNbUl07cChJLm9mZnNldCksSS5sb2NhdG9yPWMoQyx7fSl9bi5sb2NhdG9yPWssaChTLG4sRikmJkEucHVzaChTKSxuLmxvY2F0b3I9Q31lbHNlIGgoUyxuLEYpJiZBLnB1c2goUyk7YS5pc0hUTUwoUy51cmkpJiYhUy5jbG9zZWQ/TT1kKGUsTSxTLnRhZ05hbWUsaSxuKTpNKyt9fWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBzKXRocm93IGU7by5lcnJvcihcImVsZW1lbnQgcGFyc2UgZXJyb3I6IFwiK2UpLE09LTF9TT5fP189TTpsKE1hdGgubWF4KHksXykrMSl9fShlLHQscixuLHRoaXMuZXJyb3JIYW5kbGVyKSxuLmVuZERvY3VtZW50KCl9fSxnLnByb3RvdHlwZT17c2V0VGFnTmFtZTpmdW5jdGlvbihlKXtpZighaS50ZXN0KGUpKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgdGFnTmFtZTpcIitlKTt0aGlzLnRhZ05hbWU9ZX0sYWRkVmFsdWU6ZnVuY3Rpb24oZSx0LHIpe2lmKCFpLnRlc3QoZSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhdHRyaWJ1dGU6XCIrZSk7dGhpcy5hdHRyaWJ1dGVOYW1lc1tlXT10aGlzLmxlbmd0aCx0aGlzW3RoaXMubGVuZ3RoKytdPXtxTmFtZTplLHZhbHVlOnQsb2Zmc2V0OnJ9fSxsZW5ndGg6MCxnZXRMb2NhbE5hbWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXNbZV0ubG9jYWxOYW1lfSxnZXRMb2NhdG9yOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLmxvY2F0b3J9LGdldFFOYW1lOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLnFOYW1lfSxnZXRVUkk6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXNbZV0udXJpfSxnZXRWYWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpc1tlXS52YWx1ZX19LHQuWE1MUmVhZGVyPWwsdC5QYXJzZUVycm9yPXN9LDg5MTc6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcj12b2lkIDA7dmFyIGE9cig2MjAwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yfX0pfSw2MjAwOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yPXZvaWQgMDtjbGFzcyByIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoZSx0LHIsYT1cImV4YWN0bHlcIil7c3VwZXIoYCR7ZX0gdGFnIG11c3QgaGF2ZSAke2F9ICR7dH0gY2hpbGRyZW4uIEl0J3MgYWN0dWFsbHkgJHtyfWApLHRoaXMubmFtZT1cIkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3JcIn19dC5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yPXJ9LDQyNzk6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDgyOCksdCksbihyKDU5NzUpLHQpLG4ocig3OTkpLHQpLG4ocigyNDI0KSx0KX0sNTk3NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSm9pbldpdGhNYW55U2VwYXJhdG9ycz12b2lkIDA7Y2xhc3Mgcntjb25zdHJ1Y3RvcihlKXt0aGlzLl9zZXBhcmF0b3JzPWV9c3RhdGljIGpvaW4oZSx0KXtyZXR1cm4gbmV3IHIodCkuX2pvaW4oZSl9X2pvaW4oZSl7cmV0dXJuIGUucmVkdWNlKCgoZSx0LHIsYSk9PmUrdCsocj09PWEubGVuZ3RoLTE/XCJcIjp0aGlzLl9nZXQocikpKSxcIlwiKX1fZ2V0KGUpe3JldHVybiB0aGlzLl9zZXBhcmF0b3JzW2VdP3RoaXMuX3NlcGFyYXRvcnNbZV06dGhpcy5fc2VwYXJhdG9ycy5sZW5ndGg+MD90aGlzLl9zZXBhcmF0b3JzW3RoaXMuX3NlcGFyYXRvcnMubGVuZ3RoLTFdOlwiLFwifX10LkpvaW5XaXRoTWFueVNlcGFyYXRvcnM9cn0sNzk5OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyPXZvaWQgMDtjb25zdCBhPXIoNTQ0Myk7dC5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcj1lPT5uZXcgYS5NYXRoTUxFbGVtZW50VG9MYXRleENvbnZlcnRlckFkYXB0ZXIoZSkudG9MYXRleENvbnZlcnRlcigpfSwyNDI0OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5ub3JtYWxpemVXaGl0ZVNwYWNlcz12b2lkIDAsdC5ub3JtYWxpemVXaGl0ZVNwYWNlcz1lPT5lLnJlcGxhY2UoL1xccysvZyxcIiBcIil9LDcxOTI6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQnJhY2tldFdyYXBwZXI9dm9pZCAwO2NvbnN0IGE9cigxODU1KTt0LkJyYWNrZXRXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fb3Blbj1cIntcIix0aGlzLl9jbG9zZT1cIn1cIn13cmFwKGUpe3JldHVybiBuZXcgYS5XcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAoZSl9fX0sNTAyNTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljV3JhcHBlcj12b2lkIDA7Y29uc3QgYT1yKDE4NTUpO3QuR2VuZXJpY1dyYXBwZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9vcGVuPVwiXFxcXGxlZnRcIitlLHRoaXMuX2Nsb3NlPVwiXFxcXHJpZ2h0XCIrdH13cmFwKGUpe3JldHVybiBuZXcgYS5XcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAoZSl9fX0sODI4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkdlbmVyaWNXcmFwcGVyPXQuUGFyZW50aGVzaXNXcmFwcGVyPXQuQnJhY2tldFdyYXBwZXI9dm9pZCAwO3ZhciBhPXIoNzE5Mik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJCcmFja2V0V3JhcHBlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLkJyYWNrZXRXcmFwcGVyfX0pO3ZhciBuPXIoMTE2OCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJQYXJlbnRoZXNpc1dyYXBwZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5QYXJlbnRoZXNpc1dyYXBwZXJ9fSk7dmFyIG89cig1MDI1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkdlbmVyaWNXcmFwcGVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uR2VuZXJpY1dyYXBwZXJ9fSl9LDExNjg6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUGFyZW50aGVzaXNXcmFwcGVyPXZvaWQgMDtjb25zdCBhPXIoMTg1NSk7dC5QYXJlbnRoZXNpc1dyYXBwZXI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLl9vcGVuPVwiXFxcXGxlZnQoXCIsdGhpcy5fY2xvc2U9XCJcXFxccmlnaHQpXCJ9d3JhcChlKXtyZXR1cm4gbmV3IGEuV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfXdyYXBJZk1vcmVUaGFuT25lQ2hhcihlKXtyZXR1cm4gZS5sZW5ndGg8PTE/ZTp0aGlzLndyYXAoZSl9fX0sMTg1NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV3JhcHBlcj12b2lkIDAsdC5XcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5fb3Blbj1lLHRoaXMuX2Nsb3NlPXR9d3JhcChlKXtyZXR1cm4gdGhpcy5fb3BlbitlK3RoaXMuX2Nsb3NlfX19LDI2OTc6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlZvaWRNYXRoTUxFbGVtZW50PXZvaWQgMCx0LlZvaWRNYXRoTUxFbGVtZW50PWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5uYW1lPVwidm9pZFwiLHRoaXMudmFsdWU9XCJcIix0aGlzLmNoaWxkcmVuPVtdLHRoaXMuYXR0cmlidXRlcz17fX19fSw0NzYwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkdlbmVyaWNTcGFjaW5nV3JhcHBlcj12b2lkIDA7Y29uc3QgYT1yKDQyNzkpO3QuR2VuZXJpY1NwYWNpbmdXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuIHRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFwiKX19fSw5Mzc2OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkdlbmVyaWNVbmRlck92ZXI9dm9pZCAwO2NvbnN0IGE9cig3OTkpLG49cig4OTE3KSxvPXIoNDcyKTt0LkdlbmVyaWNVbmRlck92ZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtuYW1lOmUsY2hpbGRyZW46dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPXQubGVuZ3RoO2lmKDIhPT1yKXRocm93IG5ldyBuLkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3IoZSwyLHIpO2NvbnN0IG89KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFswXSkuY29udmVydCgpLGk9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFsxXSkuY29udmVydCgpO3JldHVybiB0aGlzLl9hcHBseUNvbW1hbmQobyxpKX1fYXBwbHlDb21tYW5kKGUsdCl7Y29uc3Qgcj10aGlzLl9tYXRobWxFbGVtZW50Lm5hbWUubWF0Y2goL3VuZGVyLyk/cy5VbmRlcjpzLk92ZXI7cmV0dXJuIG5ldyBpKHIpLmFwcGx5KGUsdCl9fTtjbGFzcyBpe2NvbnN0cnVjdG9yKGUpe3RoaXMuX3R5cGU9ZX1hcHBseShlLHQpe3JldHVybiBvLmxhdGV4QWNjZW50cy5pbmNsdWRlcyh0KT9gJHt0fXske2V9fWA6YCR7dGhpcy5fZGVmYXVsdENvbW1hbmR9eyR7dH19eyR7ZX19YH1nZXQgX2RlZmF1bHRDb21tYW5kKCl7cmV0dXJuIHRoaXMuX3R5cGU9PT1zLlVuZGVyP1wiXFxcXHVuZGVyc2V0XCI6XCJcXFxcb3ZlcnNldFwifX12YXIgczshZnVuY3Rpb24oZSl7ZVtlLlVuZGVyPTBdPVwiVW5kZXJcIixlW2UuT3Zlcj0xXT1cIk92ZXJcIn0oc3x8KHM9e30pKX0sNjk1OTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Wb2lkPXQuR2VuZXJpY1VuZGVyT3Zlcj10LkdlbmVyaWNTcGFjaW5nV3JhcHBlcj10Lk1Ucj10Lk1UYWJsZT10Lk1VbmRlcm92ZXI9dC5NVGV4dD10Lk1NdWx0aXNjcmlwdHM9dC5NU3Vic3VwPXQuTVN1Yj10Lk1TdXA9dC5NUGhhbnRvbT10Lk1FcnJvcj10Lk1FbmNsb3NlPXQuTUFjdGlvbj10Lk1Sb290PXQuTUZyYWM9dC5NRmVuY2VkPXQuTVNxcnQ9dC5NTj10Lk1PPXQuTUk9dC5NYXRoPXZvaWQgMDt2YXIgYT1yKDM5Myk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNYXRoXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuTWF0aH19KTt2YXIgbj1yKDcwMzcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUlcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5NSX19KTt2YXIgbz1yKDM0ODcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTU9cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5NT319KTt2YXIgaT1yKDQ0NjQpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTU5cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5NTn19KTt2YXIgcz1yKDg2ODYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVNxcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5NU3FydH19KTt2YXIgbD1yKDk1MTEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUZlbmNlZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsLk1GZW5jZWR9fSk7dmFyIGM9cig2NDQwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1GcmFjXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuTUZyYWN9fSk7dmFyIHU9cig2MDUyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1Sb290XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuTVJvb3R9fSk7dmFyIGg9cigxNjc4KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1BY3Rpb25cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5NQWN0aW9ufX0pO3ZhciBkPXIoMjYzMSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNRW5jbG9zZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLk1FbmNsb3NlfX0pO3ZhciBtPXIoMTg0MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNRXJyb3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbS5NRXJyb3J9fSk7dmFyIHA9cig3NDQzKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1QaGFudG9tXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHAuTVBoYW50b219fSk7dmFyIGY9cig2OTI2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1TdXBcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5NU3VwfX0pO3ZhciB4PXIoMjU2NCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNU3ViXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHguTVN1Yn19KTt2YXIgZz1yKDEzNTgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVN1YnN1cFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBnLk1TdWJzdXB9fSk7dmFyIHc9cig4MzAzKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1NdWx0aXNjcmlwdHNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdy5NTXVsdGlzY3JpcHRzfX0pO3ZhciBiPXIoMzk1MSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNVGV4dFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBiLk1UZXh0fX0pO3ZhciB2PXIoMTIyMik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNVW5kZXJvdmVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYuTVVuZGVyb3Zlcn19KTt2YXIgQz1yKDIzNTApO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVRhYmxlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEMuTVRhYmxlfX0pO3ZhciBBPXIoMTU4Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNVHJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQS5NVHJ9fSk7dmFyIEU9cig0NzYwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkdlbmVyaWNTcGFjaW5nV3JhcHBlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBFLkdlbmVyaWNTcGFjaW5nV3JhcHBlcn19KTt2YXIgXz1yKDkzNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiR2VuZXJpY1VuZGVyT3ZlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBfLkdlbmVyaWNVbmRlck92ZXJ9fSk7dmFyIHk9cig5MTY1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIlZvaWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4geS5Wb2lkfX0pfSwxNjc4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1BY3Rpb249dm9pZCAwO2NvbnN0IGE9cig3OTkpO3QuTUFjdGlvbj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e2NoaWxkcmVuOmV9PXRoaXMuX21hdGhtbEVsZW1lbnQ7cmV0dXJuIHRoaXMuX2lzVG9nZ2xlKCk/ZS5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXFxcXExvbmdyaWdodGFycm93IFwiKTooMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlWzBdKS5jb252ZXJ0KCl9X2lzVG9nZ2xlKCl7Y29uc3R7YWN0aW9udHlwZTplfT10aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXM7cmV0dXJuXCJ0b2dnbGVcIj09PWV8fCFlfX19LDM5MzooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NYXRoPXZvaWQgMDtjb25zdCBhPXIoNzk5KSxuPXIoMjQyNCk7dC5NYXRoPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT10aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIik7cmV0dXJuKDAsbi5ub3JtYWxpemVXaGl0ZVNwYWNlcykoZSl9fX0sMjYzMTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRW5jbG9zZT12b2lkIDA7Y29uc3QgYT1yKDc5OSk7dC5NRW5jbG9zZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0IGU9dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpO3JldHVyblwiYWN0dWFyaWFsXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXG92ZXJsaW5le1xcXFxsZWZ0LiR7ZX1cXFxccmlnaHR8fWA6XCJyYWRpY2FsXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXHNxcnR7JHtlfX1gOltcImJveFwiLFwicm91bmRlZGJveFwiLFwiY2lyY2xlXCJdLmluY2x1ZGVzKHRoaXMuX25vdGF0aW9uKT9gXFxcXGJveGVkeyR7ZX19YDpcImxlZnRcIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcbGVmdHwke2V9YDpcInJpZ2h0XCI9PT10aGlzLl9ub3RhdGlvbj9gJHtlfVxcXFxyaWdodHxgOlwidG9wXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXG92ZXJsaW5leyR7ZX19YDpcImJvdHRvbVwiPT09dGhpcy5fbm90YXRpb24/YFxcXFx1bmRlcmxpbmV7JHtlfX1gOlwidXBkaWFnb25hbHN0cmlrZVwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxjYW5jZWx7JHtlfX1gOlwiZG93bmRpYWdvbmFsc3RyaWtlXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXGJjYW5jZWx7JHtlfX1gOlwidXBkaWFnb25hbGFycm93XCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXGNhbmNlbHRve317JHtlfX1gOltcInZlcnRpY2Fsc3RyaWtlXCIsXCJob3Jpem9udGFsc3RyaWtlXCJdLmluY2x1ZGVzKHRoaXMuX25vdGF0aW9uKT9gXFxcXGhjYW5jZWx7JHtlfX1gOlwibWFkcnV3YlwiPT09dGhpcy5fbm90YXRpb24/YFxcXFx1bmRlcmxpbmV7JHtlfVxcXFxyaWdodHx9YDpcInBoYXNvcmFuZ2xlXCI9PT10aGlzLl9ub3RhdGlvbj9ge1xcXFxhbmdsZSBcXFxcdW5kZXJsaW5leyR7ZX19fWA6YFxcXFxvdmVybGluZXtcXFxcbGVmdC5cXFxccmlnaHQpJHtlfX1gfWdldCBfbm90YXRpb24oKXtyZXR1cm4gdGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzLm5vdGF0aW9ufHxcImxvbmdkaXZcIn19fSwxODQwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1FcnJvcj12b2lkIDA7Y29uc3QgYT1yKDc5OSk7dC5NRXJyb3I9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5gXFxcXGNvbG9ye3JlZH17JHt0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIil9fWB9fX0sOTUxMTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRmVuY2VkPXZvaWQgMDtjb25zdCBhPXIoNzk5KSxuPXIoNDI3OSk7dC5NRmVuY2VkPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZSx0aGlzLl9vcGVuPXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5vcGVufHxcIlwiLHRoaXMuX2Nsb3NlPXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5jbG9zZXx8XCJcIix0aGlzLl9zZXBhcmF0b3JzPUFycmF5LmZyb20odGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzLnNlcGFyYXRvcnN8fFwiXCIpfWNvbnZlcnQoKXtjb25zdCBlPXRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKTtyZXR1cm4gdGhpcy5faXNUaGVyZVJlbGF0aXZlT2ZOYW1lKHRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4sXCJtdGFibGVcIik/bmV3IGkodGhpcy5fb3Blbix0aGlzLl9jbG9zZSkuYXBwbHkoZSk6bmV3IG8odGhpcy5fb3Blbix0aGlzLl9jbG9zZSx0aGlzLl9zZXBhcmF0b3JzKS5hcHBseShlKX1faXNUaGVyZVJlbGF0aXZlT2ZOYW1lKGUsdCl7cmV0dXJuIGUuc29tZSgoZT0+ZS5uYW1lPT09dHx8dGhpcy5faXNUaGVyZVJlbGF0aXZlT2ZOYW1lKGUuY2hpbGRyZW4sdCkpKX19O2NsYXNzIG97Y29uc3RydWN0b3IoZSx0LHIpe3RoaXMuX29wZW49ZXx8XCIoXCIsdGhpcy5fY2xvc2U9dHx8XCIpXCIsdGhpcy5fc2VwYXJhdG9ycz1yfWFwcGx5KGUpe2NvbnN0IHQ9bi5Kb2luV2l0aE1hbnlTZXBhcmF0b3JzLmpvaW4oZSx0aGlzLl9zZXBhcmF0b3JzKTtyZXR1cm4gbmV3IG4uR2VuZXJpY1dyYXBwZXIodGhpcy5fb3Blbix0aGlzLl9jbG9zZSkud3JhcCh0KX19Y2xhc3MgaXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX2dlbmVyaWNDb21tYW5kPVwibWF0cml4XCIsdGhpcy5fc2VwYXJhdG9ycz1uZXcgcyhlLHQpfWFwcGx5KGUpe2NvbnN0IHQ9dGhpcy5fY29tbWFuZCxyPWBcXFxcYmVnaW57JHt0fX1cXG4ke2Uuam9pbihcIlwiKX1cXG5cXFxcZW5keyR7dH19YDtyZXR1cm4gdD09PXRoaXMuX2dlbmVyaWNDb21tYW5kP3RoaXMuX3NlcGFyYXRvcnMud3JhcChyKTpyfWdldCBfY29tbWFuZCgpe3JldHVybiB0aGlzLl9zZXBhcmF0b3JzLmFyZVBhcmVudGhlc2VzKCk/XCJwbWF0cml4XCI6dGhpcy5fc2VwYXJhdG9ycy5hcmVTcXVhcmVCcmFja2V0cygpP1wiYm1hdHJpeFwiOnRoaXMuX3NlcGFyYXRvcnMuYXJlQnJhY2tldHMoKT9cIkJtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZURpdmlkZXMoKT9cInZtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZVBhcmFsbGVscygpP1wiVm1hdHJpeFwiOnRoaXMuX3NlcGFyYXRvcnMuYXJlTm90RXF1YWwoKT90aGlzLl9nZW5lcmljQ29tbWFuZDpcImJtYXRyaXhcIn19Y2xhc3Mgc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX29wZW49ZSx0aGlzLl9jbG9zZT10fXdyYXAoZSl7cmV0dXJuIG5ldyBuLkdlbmVyaWNXcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAoZSl9YXJlUGFyZW50aGVzZXMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcIihcIixcIilcIil9YXJlU3F1YXJlQnJhY2tldHMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcIltcIixcIl1cIil9YXJlQnJhY2tldHMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcIntcIixcIn1cIil9YXJlRGl2aWRlcygpe3JldHVybiB0aGlzLl9jb21wYXJlKFwifFwiLFwifFwiKX1hcmVQYXJhbGxlbHMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcInx8XCIsXCJ8fFwiKX1hcmVOb3RFcXVhbCgpe3JldHVybiB0aGlzLl9vcGVuIT09dGhpcy5fY2xvc2V9X2NvbXBhcmUoZSx0KXtyZXR1cm4gdGhpcy5fb3Blbj09PWUmJnRoaXMuX2Nsb3NlPT09dH19fSw2NDQwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1GcmFjPXZvaWQgMDtjb25zdCBhPXIoODkxNyksbj1yKDQyNzkpO3QuTUZyYWM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtjaGlsZHJlbjplLG5hbWU6dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPWUubGVuZ3RoO2lmKDIhPT1yKXRocm93IG5ldyBhLkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3IodCwyLHIpO2NvbnN0IG89KDAsbi5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZVswXSkuY29udmVydCgpLGk9KDAsbi5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZVsxXSkuY29udmVydCgpO3JldHVybiB0aGlzLl9pc0JldmVsbGVkKCk/YCR7dGhpcy5fd3JhcElmTW9yZVRoYW5PbmVDaGFyKG8pfS8ke3RoaXMuX3dyYXBJZk1vcmVUaGFuT25lQ2hhcihpKX1gOmBcXFxcZnJhY3ske299fXske2l9fWB9X3dyYXBJZk1vcmVUaGFuT25lQ2hhcihlKXtyZXR1cm4obmV3IG4uUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwSWZNb3JlVGhhbk9uZUNoYXIoZSl9X2lzQmV2ZWxsZWQoKXtyZXR1cm4hIXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5iZXZlbGxlZH19fSw3MDM3OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1JPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDU0MDYpLG89cig2MTIyKTt0Lk1JPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudXRmOENvbnZlcnRlcj1uZXcgby5IYXNoVVRGOFRvTHRYQ29udmVydGVyLHRoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT0oMCxhLm5vcm1hbGl6ZVdoaXRlU3BhY2VzKSh0aGlzLl9tYXRobWxFbGVtZW50LnZhbHVlKTtpZihcIiBcIj09PWUpcmV0dXJuIGkuYXBwbHkoZSk7Y29uc3QgdD1lLnRyaW0oKSxyPWkuYXBwbHkodCksbj10aGlzLnV0ZjhDb252ZXJ0ZXIuY29udmVydChyKTtyZXR1cm4gbiE9PXI/bjp0aGlzLndyYXBJbk1hdGhWYXJpYW50KHIsdGhpcy5nZXRNYXRoVmFyaWFudCh0aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMpKX1nZXRNYXRoVmFyaWFudChlKXtpZihlJiZlLm1hdGh2YXJpYW50KXJldHVybiBlLm1hdGh2YXJpYW50fXdyYXBJbk1hdGhWYXJpYW50KGUsdCl7c3dpdGNoKHQpe2Nhc2VcImJvbGRcIjpyZXR1cm5gXFxcXG1hdGhiZnske2V9fWA7Y2FzZVwiaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoaXR7JHtlfX1gO2Nhc2VcImJvbGQtaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhpdHske2V9fX1gO2Nhc2VcImRvdWJsZS1zdHJ1Y2tcIjpyZXR1cm5gXFxcXG1hdGhiYnske2V9fWA7Y2FzZVwiYm9sZC1mcmFrdHVyXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhmcmFreyR7ZX19fWA7Y2FzZVwic2NyaXB0XCI6cmV0dXJuYFxcXFxtYXRoY2FseyR7ZX19YDtjYXNlXCJib2xkLXNjcmlwdFwiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoY2FseyR7ZX19fWA7Y2FzZVwiZnJha3R1clwiOnJldHVybmBcXFxcbWF0aGZyYWt7JHtlfX1gO2Nhc2VcInNhbnMtc2VyaWZcIjpyZXR1cm5gXFxcXG1hdGhzZnske2V9fWA7Y2FzZVwiYm9sZC1zYW5zLXNlcmlmXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhzZnske2V9fX1gO2Nhc2VcInNhbnMtc2VyaWYtaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoc2Z7XFxcXG1hdGhpdHske2V9fX1gO2Nhc2VcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjpyZXR1cm5gXFxcXG1hdGhiZntcXFxcbWF0aHNme1xcXFxtYXRoaXR7JHtlfX19fWA7Y2FzZVwibW9ub3NwYWNlXCI6cmV0dXJuYFxcXFxtYXRodHR7JHtlfX1gO2RlZmF1bHQ6cmV0dXJuIGV9fX07Y2xhc3MgaXtjb25zdHJ1Y3RvcihlKXt0aGlzLl92YWx1ZT1lfXN0YXRpYyBhcHBseShlKXtyZXR1cm4gbmV3IGkoZSkuX2FwcGx5KCl9X2FwcGx5KCl7cmV0dXJuIHRoaXMuX2ZpbmRCeUNoYXJhY3RlcigpfHx0aGlzLl9maW5kQnlHbHlwaCgpfHx0aGlzLl9maW5kQnlOdW1iZXIoKXx8KG5ldyBvLkhhc2hVVEY4VG9MdFhDb252ZXJ0ZXIpLmNvbnZlcnQodGhpcy5fdmFsdWUpfV9maW5kQnlDaGFyYWN0ZXIoKXtyZXR1cm4gbi5hbGxNYXRoU3ltYm9sc0J5Q2hhclt0aGlzLl92YWx1ZV19X2ZpbmRCeUdseXBoKCl7cmV0dXJuIG4uYWxsTWF0aFN5bWJvbHNCeUdseXBoW3RoaXMuX3ZhbHVlXX1fZmluZEJ5TnVtYmVyKCl7cmV0dXJuIG4ubWF0aE51bWJlckJ5R2x5cGhbdGhpcy5fdmFsdWVdfX19LDgzMDM6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTU11bHRpc2NyaXB0cz12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig4OTE3KTt0Lk1NdWx0aXNjcmlwdHM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtuYW1lOmUsY2hpbGRyZW46dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPXQubGVuZ3RoO2lmKHI8Myl0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMyxyLFwiYXQgbGVhc3RcIik7Y29uc3Qgbz0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzBdKS5jb252ZXJ0KCk7cmV0dXJuIHRoaXMuX3ByZXNjcmlwdExhdGV4KCkrdGhpcy5fd3JhcEluUGFyZW50aGVzaXNJZlRoZXJlSXNTcGFjZShvKSt0aGlzLl9wb3N0c2NyaXB0TGF0ZXgoKX1fcHJlc2NyaXB0TGF0ZXgoKXtjb25zdHtjaGlsZHJlbjplfT10aGlzLl9tYXRobWxFbGVtZW50O2xldCB0LHI7aWYodGhpcy5faXNQcmVzY3JpcHRzKGVbMV0pKXQ9ZVsyXSxyPWVbM107ZWxzZXtpZighdGhpcy5faXNQcmVzY3JpcHRzKGVbM10pKXJldHVyblwiXCI7dD1lWzRdLHI9ZVs1XX1yZXR1cm5gXFxcXF97JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0KS5jb252ZXJ0KCl9fV57JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShyKS5jb252ZXJ0KCl9fWB9X3Bvc3RzY3JpcHRMYXRleCgpe2NvbnN0e2NoaWxkcmVuOmV9PXRoaXMuX21hdGhtbEVsZW1lbnQ7aWYodGhpcy5faXNQcmVzY3JpcHRzKGVbMV0pKXJldHVyblwiXCI7Y29uc3QgdD1lWzFdLHI9ZVsyXTtyZXR1cm5gX3skeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHQpLmNvbnZlcnQoKX19XnskeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHIpLmNvbnZlcnQoKX19YH1fd3JhcEluUGFyZW50aGVzaXNJZlRoZXJlSXNTcGFjZShlKXtyZXR1cm4gZS5tYXRjaCgvXFxzKy9nKT8obmV3IGEuUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwKGUpOmV9X2lzUHJlc2NyaXB0cyhlKXtyZXR1cm5cIm1wcmVzY3JpcHRzXCI9PT0obnVsbD09ZT92b2lkIDA6ZS5uYW1lKX19fSw0NDY0OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1OPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDU0MDYpO3QuTU49Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdCBlPSgwLGEubm9ybWFsaXplV2hpdGVTcGFjZXMpKHRoaXMuX21hdGhtbEVsZW1lbnQudmFsdWUpLnRyaW0oKTtyZXR1cm4gbi5tYXRoTnVtYmVyQnlHbHlwaFtlXXx8ZX19fSwzNDg3OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1PPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDU0MDYpO3QuTU89Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdCBlPSgwLGEubm9ybWFsaXplV2hpdGVTcGFjZXMpKHRoaXMuX21hdGhtbEVsZW1lbnQudmFsdWUpLnRyaW0oKTtyZXR1cm4gby5vcGVyYXRlKGUpfX07Y2xhc3Mgb3tjb25zdHJ1Y3RvcihlKXt0aGlzLl92YWx1ZT1lfXN0YXRpYyBvcGVyYXRlKGUpe3JldHVybiBuZXcgbyhlKS5fb3BlcmF0ZSgpfV9vcGVyYXRlKCl7cmV0dXJuIHRoaXMuX2ZpbmRCeUNoYXJhY3RlcigpfHx0aGlzLl9maW5kQnlHbHlwaCgpfHx0aGlzLl9maW5kQnlOdW1iZXIoKXx8KG5ldyBuLkhhc2hVVEY4VG9MdFhDb252ZXJ0ZXIpLmNvbnZlcnQodGhpcy5fdmFsdWUpfV9maW5kQnlDaGFyYWN0ZXIoKXtyZXR1cm4gbi5hbGxNYXRoT3BlcmF0b3JzQnlDaGFyW3RoaXMuX3ZhbHVlXX1fZmluZEJ5R2x5cGgoKXtyZXR1cm4gbi5hbGxNYXRoT3BlcmF0b3JzQnlHbHlwaFt0aGlzLl92YWx1ZV19X2ZpbmRCeU51bWJlcigpe3JldHVybiBuLm1hdGhOdW1iZXJCeUdseXBoW3RoaXMuX3ZhbHVlXX19fSw3NDQzOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NUGhhbnRvbT12b2lkIDAsdC5NUGhhbnRvbT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe3JldHVyblwiXCJ9fX0sNjA1MjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NUm9vdD12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig4OTE3KTt0Lk1Sb290PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMixyKTtjb25zdCBvPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMF0pLmNvbnZlcnQoKTtyZXR1cm5gXFxcXHNxcnRbJHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzFdKS5jb252ZXJ0KCl9XXske299fWB9fX0sODY4NjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3FydD12b2lkIDA7Y29uc3QgYT1yKDQyNzkpO3QuTVNxcnQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5gXFxcXHNxcnR7JHt0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIil9fWB9fX0sMjU2NDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3ViPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVN1Yj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMiE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDIscik7Y29uc3QgYT10WzBdLG89dFsxXTtyZXR1cm5gJHt0aGlzLl9oYW5kbGVCYXNlQ2hpbGQoYSl9XyR7dGhpcy5faGFuZGxlU3Vic2NyaXB0Q2hpbGQobyl9YH1faGFuZGxlQmFzZUNoaWxkKGUpe2NvbnN0IHQ9ZS5jaGlsZHJlbixyPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4gdC5sZW5ndGg8PTE/cjoobmV3IGEuUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwSWZNb3JlVGhhbk9uZUNoYXIocil9X2hhbmRsZVN1YnNjcmlwdENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX19fSwxMzU4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1TdWJzdXA9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NU3Vic3VwPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigzIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMyxyKTtjb25zdCBhPXRbMF0sbz10WzFdLGk9dFsyXTtyZXR1cm5gJHt0aGlzLl9oYW5kbGVCYXNlQ2hpbGQoYSl9XyR7dGhpcy5faGFuZGxlU3Vic2NyaXB0Q2hpbGQobyl9XiR7dGhpcy5faGFuZGxlU3VwZXJzY3JpcHRDaGlsZChpKX1gfV9oYW5kbGVCYXNlQ2hpbGQoZSl7Y29uc3QgdD1lLmNoaWxkcmVuLHI9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybiB0Lmxlbmd0aDw9MT9yOihuZXcgYS5QYXJlbnRoZXNpc1dyYXBwZXIpLndyYXBJZk1vcmVUaGFuT25lQ2hhcihyKX1faGFuZGxlU3Vic2NyaXB0Q2hpbGQoZSl7Y29uc3QgdD0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKS5jb252ZXJ0KCk7cmV0dXJuKG5ldyBhLkJyYWNrZXRXcmFwcGVyKS53cmFwKHQpfV9oYW5kbGVTdXBlcnNjcmlwdENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX19fSw2OTI2OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1TdXA9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NU3VwPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMixyKTtjb25zdCBhPXRbMF0sbz10WzFdO3JldHVybmAke3RoaXMuX2hhbmRsZUJhc2VDaGlsZChhKX1eJHt0aGlzLl9oYW5kbGVFeHBvbmVudENoaWxkKG8pfWB9X2hhbmRsZUJhc2VDaGlsZChlKXtjb25zdCB0PWUuY2hpbGRyZW4scj0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKS5jb252ZXJ0KCk7cmV0dXJuIHQubGVuZ3RoPD0xP3I6KG5ldyBhLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcElmTW9yZVRoYW5PbmVDaGFyKHIpfV9oYW5kbGVFeHBvbmVudENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX19fSwyMzUwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1UYWJsZT12b2lkIDA7Y29uc3QgYT1yKDQyNzkpO3QuTVRhYmxlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZSx0aGlzLl9hZGRGbGFnUmVjdXJzaXZlSWZOYW1lKHRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4sXCJtdGFibGVcIixcImlubmVyVGFibGVcIil9Y29udmVydCgpe2NvbnN0IGU9dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXFxcXFxcXFxcXG5cIik7cmV0dXJuIHRoaXMuX2hhc0ZsYWcoXCJpbm5lclRhYmxlXCIpP3RoaXMuX3dyYXAoZSk6ZX1fd3JhcChlKXtyZXR1cm5gXFxcXGJlZ2lue21hdHJpeH0ke2V9XFxcXGVuZHttYXRyaXh9YH1fYWRkRmxhZ1JlY3Vyc2l2ZUlmTmFtZShlLHQscil7ZS5mb3JFYWNoKChlPT57ZS5uYW1lPT09dCYmKGUuYXR0cmlidXRlc1tyXT1yKSx0aGlzLl9hZGRGbGFnUmVjdXJzaXZlSWZOYW1lKGUuY2hpbGRyZW4sdCxyKX0pKX1faGFzRmxhZyhlKXtyZXR1cm4hIXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlc1tlXX19fSwzOTUxOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1UZXh0PXZvaWQgMDtjb25zdCBhPXIoNzAzNyk7dC5NVGV4dD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e2F0dHJpYnV0ZXM6ZSx2YWx1ZTp0fT10aGlzLl9tYXRobWxFbGVtZW50O3JldHVyblsuLi50XS5tYXAoKGU9Pi9eW2EtekEtWjAtOV0kLy50ZXN0KGUpfHxcIiBcIj09PWU/e3ZhbHVlOmUsaXNBbHBoYW51bWVyaWM6ITB9Ont2YWx1ZTplLGlzQWxwaGFudW1lcmljOiExfSkpLnJlZHVjZSgoKGUsdCk9PntpZih0LmlzQWxwaGFudW1lcmljKXtjb25zdCByPWVbZS5sZW5ndGgtMV07aWYociYmci5pc0FscGhhbnVtZXJpYylyZXR1cm4gci52YWx1ZSs9dC52YWx1ZSxlfXJldHVyblsuLi5lLHRdfSksW10pLm1hcCgodD0+dC5pc0FscGhhbnVtZXJpYz9uZXcgbihlLm1hdGh2YXJpYW50KS5hcHBseSh0LnZhbHVlKTpuZXcgYS5NSSh7bmFtZTpcIm1pXCIsYXR0cmlidXRlczp7fSxjaGlsZHJlbjpbXSx2YWx1ZTp0LnZhbHVlfSkuY29udmVydCgpKSkuam9pbihcIlwiKX19O2NsYXNzIG57Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aHZhcmlhbnQ9ZXx8XCJub3JtYWxcIn1hcHBseShlKXtyZXR1cm4gdGhpcy5fY29tbWFuZHMucmVkdWNlKCgodCxyLGEpPT4wPT09YT9gJHtyfXske2V9fWA6YCR7cn17JHt0fX1gKSxcIlwiKX1nZXQgX2NvbW1hbmRzKCl7c3dpdGNoKHRoaXMuX21hdGh2YXJpYW50KXtjYXNlXCJib2xkXCI6cmV0dXJuW1wiXFxcXHRleHRiZlwiXTtjYXNlXCJpdGFsaWNcIjpyZXR1cm5bXCJcXFxcdGV4dGl0XCJdO2Nhc2VcImJvbGQtaXRhbGljXCI6cmV0dXJuW1wiXFxcXHRleHRpdFwiLFwiXFxcXHRleHRiZlwiXTtjYXNlXCJkb3VibGUtc3RydWNrXCI6cmV0dXJuW1wiXFxcXG1hdGhiYlwiXTtjYXNlXCJtb25vc3BhY2VcIjpyZXR1cm5bXCJcXFxcbWF0aHR0XCJdO2Nhc2VcImJvbGQtZnJha3R1clwiOmNhc2VcImZyYWt0dXJcIjpyZXR1cm5bXCJcXFxcbWF0aGZyYWtcIl07ZGVmYXVsdDpyZXR1cm5bXCJcXFxcdGV4dFwiXX19fX0sMTU4NjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVHI9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0Lk1Ucj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe3JldHVybiB0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiAmIFwiKX19fSwxMjIyOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1VbmRlcm92ZXI9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NVW5kZXJvdmVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigzIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMyxyKTtyZXR1cm5gJHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzBdKS5jb252ZXJ0KCl9X3skeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMV0pLmNvbnZlcnQoKX19XnskeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMl0pLmNvbnZlcnQoKX19YH19fSw5MTY1OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Wb2lkPXZvaWQgMCx0LlZvaWQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5cIlwifX19LDU0NDM6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIiE9PXImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiZhKHQsZSxyKTtyZXR1cm4gbih0LGUpLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyPXZvaWQgMDtjb25zdCBpPW8ocig2OTU5KSkscz1yKDI2OTcpO3QuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhNTEVsZW1lbnQ9bnVsbCE9ZT9lOm5ldyBzLlZvaWRNYXRoTUxFbGVtZW50fXRvTGF0ZXhDb252ZXJ0ZXIoKXtjb25zdHtuYW1lOmV9PXRoaXMuX21hdGhNTEVsZW1lbnQ7cmV0dXJuIG5ldyhsW2VdfHxpLkdlbmVyaWNTcGFjaW5nV3JhcHBlcikodGhpcy5fbWF0aE1MRWxlbWVudCl9fTtjb25zdCBsPXttYXRoOmkuTWF0aCxtaTppLk1JLG1vOmkuTU8sbW46aS5NTixtc3FydDppLk1TcXJ0LG1mZW5jZWQ6aS5NRmVuY2VkLG1mcmFjOmkuTUZyYWMsbXJvb3Q6aS5NUm9vdCxtYWN0aW9uOmkuTUFjdGlvbixtZW5jbG9zZTppLk1FbmNsb3NlLG1lcnJvcjppLk1FcnJvcixtcGhhbnRvbTppLk1QaGFudG9tLG1zdXA6aS5NU3VwLG1zdWI6aS5NU3ViLG1zdWJzdXA6aS5NU3Vic3VwLG1tdWx0aXNjcmlwdHM6aS5NTXVsdGlzY3JpcHRzLG10ZXh0OmkuTVRleHQsbXVuZGVyb3ZlcjppLk1VbmRlcm92ZXIsbXRhYmxlOmkuTVRhYmxlLG10cjppLk1Ucixtb3ZlcjppLkdlbmVyaWNVbmRlck92ZXIsbXVuZGVyOmkuR2VuZXJpY1VuZGVyT3Zlcixtcm93OmkuR2VuZXJpY1NwYWNpbmdXcmFwcGVyLG1wYWRkZWQ6aS5HZW5lcmljU3BhY2luZ1dyYXBwZXIsdm9pZDppLlZvaWR9fSw1MjQzOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5FcnJvckhhbmRsZXI9dm9pZCAwLHQuRXJyb3JIYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fZXJyb3JzPVtdLHRoaXMuZXJyb3JMb2NhdG9yPXt9fWZpeEVycm9yKGUsdCl7cmV0dXJuIHRoaXMuX2lzTWlzc2luZ0F0dHJpYnV0ZVZhbHVlRXJyb3IodCk/KHRoaXMuX2Vycm9ycy5wdXNoKHQpLHRoaXMuX2ZpeE1pc3NpbmdBdHRyaWJ1dGUodCxlKSk6ZX1pc1RoZXJlQW55RXJyb3JzKCl7cmV0dXJuIHRoaXMuX2Vycm9ycy5sZW5ndGg+MH1jbGVhbkVycm9ycygpe3RoaXMuX2Vycm9ycz1bXX1fZml4TWlzc2luZ0F0dHJpYnV0ZShlLHQpe2NvbnN0IHI9ZS5zcGxpdCgnXCInKVsxXTtpZihyKXJldHVybiB0LnJlcGxhY2UodGhpcy5fbWF0Y2hNaXNzaW5nVmFsdWVGb3JBdHRyaWJ1dGUociksXCJcIik7Zm9yKDt0aGlzLl9tYXRoR2VuZXJpY01pc3NpbmdWYWx1ZSgpLmV4ZWModCk7KXQ9dC5yZXBsYWNlKHRoaXMuX21hdGhHZW5lcmljTWlzc2luZ1ZhbHVlKCksXCIkMSQzXCIpO3JldHVybiB0fV9tYXRjaE1pc3NpbmdWYWx1ZUZvckF0dHJpYnV0ZShlKXtyZXR1cm4gbmV3IFJlZ0V4cChgKCR7ZX09KD8hKFwifCcpKSl8KCR7ZX0oPyEoXCJ8JykpKWAsXCJnbVwiKX1fbWF0aEdlbmVyaWNNaXNzaW5nVmFsdWUoKXtyZXR1cm4vKFxcPC4qICkoXFx3Kz0oPyFcXFwifFxcJykpKC4qXFw+KS9nbX1faXNNaXNzaW5nQXR0cmlidXRlVmFsdWVFcnJvcihlKXtyZXR1cm4hIWUuaW5jbHVkZXMoXCJhdHRyaWJ1dGVcIikmJiEhZS5pbmNsdWRlcyhcIm1pc3NlZFwiKXx8ZS5pbmNsdWRlcyhcImF0dHJpYnV0ZSB2YWx1ZSBtaXNzZWRcIil9fX0sOTIwODpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpO3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtuJiYhKFwiZ2V0XCJpbiBuPyF0Ll9fZXNNb2R1bGU6bi53cml0YWJsZXx8bi5jb25maWd1cmFibGUpfHwobj17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLG4pfTpmdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKSxlW2FdPXRbcl19KSxuPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiBlKVwiZGVmYXVsdFwiPT09cnx8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscil8fGEodCxlLHIpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuKHIoOTU0OCksdCksbihyKDUyNDMpLHQpLG4ocigxMTAxKSx0KX0sMTEwMTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRWxlbWVudHNUb01hdGhNTEFkYXB0ZXI9dm9pZCAwLHQuRWxlbWVudHNUb01hdGhNTEFkYXB0ZXI9Y2xhc3N7Y29udmVydChlKXtyZXR1cm4gZS5maWx0ZXIoKGU9PnZvaWQgMCE9PWUudGFnTmFtZSkpLm1hcCgoZT0+dGhpcy5fY29udmVydEVsZW1lbnQoZSkpKX1fY29udmVydEVsZW1lbnQoZSl7cmV0dXJue25hbWU6ZS50YWdOYW1lLGF0dHJpYnV0ZXM6dGhpcy5fY29udmVydEVsZW1lbnRBdHRyaWJ1dGVzKGUuYXR0cmlidXRlcyksdmFsdWU6dGhpcy5faGFzRWxlbWVudENoaWxkKGUpP1wiXCI6ZS50ZXh0Q29udGVudHx8XCJcIixjaGlsZHJlbjp0aGlzLl9oYXNFbGVtZW50Q2hpbGQoZSk/dGhpcy5jb252ZXJ0KEFycmF5LmZyb20oZS5jaGlsZE5vZGVzKSk6W119fV9jb252ZXJ0RWxlbWVudEF0dHJpYnV0ZXMoZSl7cmV0dXJuIEFycmF5LmZyb20oZSkucmVkdWNlKCgoZSx0KT0+T2JqZWN0LmFzc2lnbih7W3Qubm9kZU5hbWVdOnQubm9kZVZhbHVlPT09dC5ub2RlTmFtZT9cIlwiOnQubm9kZVZhbHVlfSxlKSkse30pfV9oYXNFbGVtZW50Q2hpbGQoZSl7Y29uc3QgdD1lLmNoaWxkTm9kZXM7cmV0dXJuISF0JiYwIT09dC5sZW5ndGgmJnRoaXMuX2lzVGhlcmVBbnlOb1RleHROb2RlKHQpfV9pc1RoZXJlQW55Tm9UZXh0Tm9kZShlKXtyZXR1cm4gQXJyYXkuZnJvbShlKS5zb21lKChlPT5cIiN0ZXh0XCIhPT1lLm5vZGVOYW1lKSl9fX0sOTU0ODpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5YbWxUb01hdGhNTEFkYXB0ZXI9dm9pZCAwO2NvbnN0IG49YShyKDg5NzgpKTt0LlhtbFRvTWF0aE1MQWRhcHRlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX3htbD1cIlwiLHRoaXMuX2VsZW1lbnRzQ29udmVydG9yPWUsdGhpcy5fZXJyb3JIYW5kbGVyPXQsdGhpcy5feG1sRE9NPW5ldyBuLmRlZmF1bHQuRE9NUGFyc2VyKHtsb2NhdG9yOnRoaXMuX2Vycm9ySGFuZGxlci5lcnJvckxvY2F0b3IsZXJyb3JIYW5kbGVyOnRoaXMuX2ZpeEVycm9yLmJpbmQodGhpcyl9KX1jb252ZXJ0KGUpe3JldHVybiB0aGlzLl94bWw9dGhpcy5fcmVtb3ZlTGluZUJyZWFrcyhlKSx0aGlzLl94bWw9dGhpcy5fcmVtb3ZlTXNXb3JkUHJlZml4ZXModGhpcy5feG1sKSx0aGlzLl9lbGVtZW50c0NvbnZlcnRvci5jb252ZXJ0KHRoaXMuX21hdGhNTEVsZW1lbnRzKX1fZml4RXJyb3IoZSl7dGhpcy5feG1sPXRoaXMuX2Vycm9ySGFuZGxlci5maXhFcnJvcih0aGlzLl94bWwsZSl9X3JlbW92ZUxpbmVCcmVha3MoZSl7cmV0dXJuIGUucmVwbGFjZSgvXFxufFxcclxcbnxcXHIvZyxcIlwiKX1fcmVtb3ZlTXNXb3JkUHJlZml4ZXMoZSl7cmV0dXJuIGUucmVwbGFjZSgvbW1sOi9nLFwiXCIpfWdldCBfbWF0aE1MRWxlbWVudHMoKXtsZXQgZT10aGlzLl94bWxET00ucGFyc2VGcm9tU3RyaW5nKHRoaXMuX3htbCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtYXRoXCIpO3JldHVybiB0aGlzLl9lcnJvckhhbmRsZXIuaXNUaGVyZUFueUVycm9ycygpJiYodGhpcy5fZXJyb3JIYW5kbGVyLmNsZWFuRXJyb3JzKCksZT10aGlzLl94bWxET00ucGFyc2VGcm9tU3RyaW5nKHRoaXMuX3htbCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtYXRoXCIpKSxBcnJheS5mcm9tKGUpfX19LDc5NDE6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDg1ODUpLHQpfSw4NTg1OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm1ha2VUb01hdGhFbGVtZW50c0NvbnZlcnRlcj12b2lkIDA7Y29uc3QgYT1yKDkyMDgpO3QubWFrZVRvTWF0aEVsZW1lbnRzQ29udmVydGVyPSgpPT57Y29uc3QgZT1uZXcgYS5FbGVtZW50c1RvTWF0aE1MQWRhcHRlcix0PW5ldyBhLkVycm9ySGFuZGxlcjtyZXR1cm4gbmV3IGEuWG1sVG9NYXRoTUxBZGFwdGVyKGUsdCl9fSw4NjcyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocigzNzk4KSx0KX0sMzc5ODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NYXRoTUxUb0xhVGVYPXZvaWQgMDtjb25zdCBhPXIoNTQ0Myksbj1yKDc5NDEpO3QuTWF0aE1MVG9MYVRlWD1jbGFzc3tzdGF0aWMgY29udmVydChlKXtyZXR1cm4oMCxuLm1ha2VUb01hdGhFbGVtZW50c0NvbnZlcnRlcikoKS5jb252ZXJ0KGUpLm1hcCgoZT0+bmV3IGEuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyKGUpLnRvTGF0ZXhDb252ZXJ0ZXIoKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiXCIpLnRyaW0oKX19fSwyOTY1OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoT3BlcmF0b3JzQnlDaGFyPXZvaWQgMCx0LmFsbE1hdGhPcGVyYXRvcnNCeUNoYXI9e186XCJcXFxcdW5kZXJsaW5lXCIsXCImI3gyM0UxO1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzRTA7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyM0RGO1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzREU7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyM0REO1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzREM7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyM0I1O1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzQjQ7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyMERDO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjBEQjtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIwNjQ7XCI6XCJcIixcIiYjeDIwNTc7XCI6XCInJycnXCIsXCImI3gyMDNFO1wiOlwiXFxcXGJhclwiLFwiJiN4MjAzNztcIjpcImBgYFwiLFwiJiN4MjAzNjtcIjpcImBgXCIsXCImI3gyMDM1O1wiOlwiYFwiLFwiJiN4MjAzNDtcIjpcIicnJ1wiLFwiJiN4MjAzMztcIjpcIicnXCIsXCImI3gyMDFGO1wiOlwiYGBcIixcIiYjeDIwMUU7XCI6XCIsLFwiLFwiJiN4MjAxQjtcIjpcImBcIixcIiYjeDIwMUE7XCI6XCIsXCIsXCImI3gzMDI7XCI6XCJcXFxcaGF0XCIsXCImI3gyRjc7XCI6XCJcXFxcc2ltXCIsXCImI3gyREQ7XCI6XCJcXFxcc2ltXCIsXCImI3gyREM7XCI6XCJcXFxcc2ltXCIsXCImI3gyREE7XCI6XCJcXFxcY2lyY1wiLFwiJiN4MkQ5O1wiOlwiXFxcXGNkb3RcIixcIiYjeDJEODtcIjpcIlwiLFwiJiN4MkNEO1wiOlwiXFxcXF9cIixcIiYjeDJDQjtcIjpcIsuLXCIsXCImI3gyQ0E7XCI6XCLLilwiLFwiJiN4MkM5O1wiOlwiy4lcIixcIiYjeDJDNztcIjpcIlwiLFwiJiN4MkM2O1wiOlwiXFxcXGhhdFwiLFwiJiN4QkE7XCI6XCJvXCIsXCImI3hCOTtcIjpcIjFcIixcIiYjeEI4O1wiOlwiwrhcIixcIiYjeEI0O1wiOlwiwrRcIixcIiYjeEIzO1wiOlwiM1wiLFwiJiN4QjI7XCI6XCIyXCIsXCImI3hCMDtcIjpcIlxcXFxjaXJjXCIsXCImI3hBRjtcIjpcIlxcXFxiYXJcIixcIiYjeEFBO1wiOlwiYVwiLFwiJiN4QTg7XCI6XCJcXFxcY2RvdFxcXFxjZG90XCIsXCJ+XCI6XCJcXFxcc2ltXCIsXCJgXCI6XCJgXCIsXCJeXCI6XCJcXFxcaGF0XCIsXCItLVwiOlwiLS1cIixcIisrXCI6XCIrK1wiLFwiJmFtcDtcIjpcIlxcXFwmXCIsXCImI3gyMDYxO1wiOlwiXCIsXCImI3gyMjFDO1wiOlwiXFxcXHNxcnRbNF17fVwiLFwiJiN4MjIxQjtcIjpcIlxcXFxzcXJ0WzNde31cIixcIiYjeDIyMUE7XCI6XCJcXFxcc3FydHt9XCIsXCImI3gyMTQ2O1wiOlwiZFwiLFwiJiN4MjE0NTtcIjpcIlxcXFxtYXRoYmJ7RH1cIixcIj9cIjpcIj9cIixcIkBcIjpcIkBcIixcIi8vXCI6XCIvL1wiLFwiISFcIjpcIiEhXCIsXCIhXCI6XCIhXCIsXCImI3gyNjZGO1wiOlwiXFxcXCNcIixcIiYjeDI2NkU7XCI6XCJcIixcIiYjeDI2NkQ7XCI6XCJcIixcIiYjeDIwMzI7XCI6XCInXCIsXCImbHQ7PlwiOlwiPD5cIixcIioqXCI6XCJcXFxcc3RhclxcXFxzdGFyXCIsXCImI3gyMjA3O1wiOlwiXFxcXG5hYmxhXCIsXCImI3gyMjAyO1wiOlwiXFxcXHBhcnRpYWxcIixcIiYjeDIyOTk7XCI6XCJcXFxcYmlnb2RvdFwiLFwiJiN4QUM7XCI6XCJcXFxcbmVnXCIsXCImI3gyMjIyO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDIyMjE7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4MjIyMDtcIjpcIlxcXFxhbmdsZVwiLFwiJiN4Rjc7XCI6XCJcXFxcZGl2XCIsXCIvXCI6XCIvXCIsXCImI3gyMjE2O1wiOlwiXFxcXGJhY2tzbGFzaFwiLFwiXFxcXFwiOlwiXFxcXGJhY2tzbGFzaFwiLFwiJVwiOlwiXFxcXCVcIixcIiYjeDIyOTc7XCI6XCJcXFxcYmlnb3RpbWVzXCIsXCImI3hCNztcIjpcIlxcXFxjZG90XCIsXCImI3gyQTNGO1wiOlwiXFxcXGNvcHJvZFwiLFwiJiN4MkEyRjtcIjpcIlxcXFx0aW1lc1wiLFwiJiN4MjJDNTtcIjpcIlxcXFxjZG90XCIsXCImI3gyMkExO1wiOlwiXFxcXGJveGRvdFwiLFwiJiN4MjJBMDtcIjpcIlxcXFxib3h0aW1lc1wiLFwiJiN4MjA2MjtcIjpcIlwiLFwiJiN4MjA0MztcIjpcIi1cIixcIiYjeDIwMjI7XCI6XCJcXFxcY2RvdFwiLFwiJiN4RDc7XCI6XCJcXFxcdGltZXNcIixcIi5cIjpcIi5cIixcIipcIjpcIlxcXFxzdGFyXCIsXCImI3gyMjJBO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjIyOTtcIjpcIlxcXFxjYXBcIixcIiYjeDIyMTA7XCI6XCJcXFxcY29wcm9kXCIsXCImI3gyMjBGO1wiOlwiXFxcXHByb2RcIixcIiYjeDIyNDA7XCI6XCJcIixcIiYjeDJBRkY7XCI6XCJcIixcIiYjeDJBRkM7XCI6XCJcXFxcbWlkXFxcXG1pZFxcXFxtaWRcIixcIiYjeDJBMDk7XCI6XCJcXFxcdGltZXNcIixcIiYjeDJBMDg7XCI6XCJcIixcIiYjeDJBMDc7XCI6XCJcIixcIiYjeDJBMDY7XCI6XCJcXFxcc3FjdXBcIixcIiYjeDJBMDU7XCI6XCJcXFxcc3FjYXBcIixcIiYjeDJBMDI7XCI6XCJcXFxcb3RpbWVzXCIsXCImI3gyQTAwO1wiOlwiXFxcXG9kb3RcIixcIiYjeDIyQzI7XCI6XCJcXFxcY2FwXCIsXCImI3gyMkMxO1wiOlwiXFxcXHZlZVwiLFwiJiN4MjJDMDtcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MkEwNDtcIjpcIlxcXFx1cGx1c1wiLFwiJiN4MkEwMztcIjpcIlxcXFxjdXBcIixcIiYjeDIyQzM7XCI6XCJcXFxcY3VwXCIsXCImI3gyQTFDO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaW50fVwiLFwiJiN4MkExQjtcIjpcIlxcXFxvdmVybGluZXtcXFxcaW50fVwiLFwiJiN4MkExQTtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTk7XCI6XCJcXFxcaW50XCIsXCImI3gyQTE4O1wiOlwiXFxcXGludFwiLFwiJiN4MkExNztcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTY7XCI6XCJcXFxcb2ludFwiLFwiJiN4MkExNTtcIjpcIlxcXFxvaW50XCIsXCImI3gyQTE0O1wiOlwiXFxcXGludFwiLFwiJiN4MkExMztcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTI7XCI6XCJcXFxcaW50XCIsXCImI3gyQTExO1wiOlwiXFxcXGludFwiLFwiJiN4MkExMDtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMEY7XCI6XCJcXFxcYmNhbmNlbHtcXFxcaW50fVwiLFwiJiN4MkEwRTtcIjpcIlwiLFwiJiN4MkEwRDtcIjpcIlxcXFxoY2FuY2Vse1xcXFxpbnR9XCIsXCImI3gyQTBDO1wiOlwiXFxcXGlpaWludFwiLFwiJiN4MjIzMztcIjpcIlxcXFxvaW50XCIsXCImI3gyMjMyO1wiOlwiXFxcXG9pbnRcIixcIiYjeDIyMzE7XCI6XCJcXFxcaW50XCIsXCImI3gyMjMwO1wiOlwiXFxcXG9paW50XCIsXCImI3gyMjJGO1wiOlwiXFxcXG9paW50XCIsXCImI3gyMjJFO1wiOlwiXFxcXG9pbnRcIixcIiYjeDIyMkI7XCI6XCJcXFxcaW50XCIsXCImI3gyQTAxO1wiOlwiXFxcXG9wbHVzXCIsXCImI3gyMjk4O1wiOlwiXFxcXG9zbGFzaFwiLFwiJiN4MjI5NjtcIjpcIlxcXFxvbWludXNcIixcIiYjeDIyOTU7XCI6XCJcXFxcb3BsdXNcIixcIiYjeDIyMkQ7XCI6XCJcXFxcaWlpbnRcIixcIiYjeDIyMkM7XCI6XCJcXFxcaWludFwiLFwiJiN4MkEwQjtcIjpcIlwiLFwiJiN4MkEwQTtcIjpcIlwiLFwiJiN4MjIxMTtcIjpcIlxcXFxzdW1cIixcIiYjeDIyOUY7XCI6XCJcXFxcYm94bWludXNcIixcIiYjeDIyOUU7XCI6XCJcXFxcYm94cGx1c1wiLFwiJiN4MjIxNDtcIjpcIlxcXFxkb3R7K31cIixcIiYjeDIyMTM7XCI6XCIrLVwiLFwiJiN4MjIxMjtcIjpcIi1cIixcIiYjeEIxO1wiOlwiXFxcXHBtXCIsXCItXCI6XCItXCIsXCIrXCI6XCIrXCIsXCImI3gyQjQ2O1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCImI3gyQjQ1O1wiOlwiXFxcXExsZWZ0YXJyb3dcIixcIiYjeDI5RjQ7XCI6XCI6XFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5RUY7XCI6XCJcIixcIiYjeDI5REY7XCI6XCJcXFxcYnVsbGV0LVxcXFxidWxsZXRcIixcIiYjeDI5OUY7XCI6XCJcXFxcYW5nbGVcIixcIiYjeDI5OUU7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4Mjk5RDtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCImI3gyOTlDO1wiOlwiXFxcXHBlcnBcIixcIiYjeDI5OUI7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4Mjk5QTtcIjpcIlwiLFwiJiN4Mjk5OTtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4Mjk3RjtcIjpcIlwiLFwiJiN4Mjk3RTtcIjpcIlwiLFwiJiN4Mjk3RDtcIjpcIlxcXFxwcmVjXCIsXCImI3gyOTdDO1wiOlwiXFxcXHN1Y2NcIixcIiYjeDI5N0I7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHJpZ2h0YXJyb3d9e1xcXFxzdXBzZXR9XCIsXCImI3gyOTdBO1wiOlwiXCIsXCImI3gyOTc5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vic2V0fVwiLFwiJiN4Mjk3ODtcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317Pn1cIixcIiYjeDI5Nzc7XCI6XCJcIixcIiYjeDI5NzY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGxlZnRhcnJvd317PH1cIixcIiYjeDI5NzU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHJpZ2h0YXJyb3d9XCIsXCImI3gyOTc0O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3MztcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcbGVmdGFycm93fVwiLFwiJiN4Mjk3MjtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3MTtcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3MDtcIjpcIlwiLFwiJiN4Mjk2RjtcIjpcIlwiLFwiJiN4Mjk2RTtcIjpcIlwiLFwiJiN4Mjk2RDtcIjpcIlxcXFxvdmVybGluZXtcXFxccmlnaHRoYXJwb29uZG93bn1cIixcIiYjeDI5NkM7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxyaWdodGhhcnBvb251cH1cIixcIiYjeDI5NkI7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxlZnRoYXJwb29uZG93bn1cIixcIiYjeDI5NkE7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsZWZ0aGFycG9vbnVwfVwiLFwiJiN4Mjk2OTtcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2ODtcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2NztcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2NjtcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2NTtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDI5NjQ7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4Mjk2MztcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyOTYyO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4Mjk2MTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NjA7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1RjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTVFO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1RDtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NUM7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1QjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTVBO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1OTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NTg7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1NztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTU2O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1NTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NTQ7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1MztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTUyO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1MTtcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk1MDtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0RjtcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk0RTtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0RDtcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk0QztcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk0QjtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0QTtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0OTtcIjpcIlwiLFwiJiN4Mjk0ODtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0NztcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiJiN4Mjk0NjtcIjpcIlwiLFwiJiN4Mjk0NTtcIjpcIlwiLFwiJiN4Mjk0NDtcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIiYjeDI5NDM7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCImI3gyOTQyO1wiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwiJiN4Mjk0MTtcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCImI3gyOTQwO1wiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwiJiN4MjkzRjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTNFO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkzRDtcIjpcIlwiLFwiJiN4MjkzQztcIjpcIlwiLFwiJiN4MjkzQjtcIjpcIlwiLFwiJiN4MjkzQTtcIjpcIlwiLFwiJiN4MjkzOTtcIjpcIlwiLFwiJiN4MjkzODtcIjpcIlwiLFwiJiN4MjkzNztcIjpcIlxcXFxSc2hcIixcIiYjeDI5MzY7XCI6XCJcXFxcTHNoXCIsXCImI3gyOTM1O1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjkzNDtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyOTMzO1wiOlwiXFxcXGxlYWRzdG9cIixcIiYjeDI5MzI7XCI6XCJcIixcIiYjeDI5MzE7XCI6XCJcIixcIiYjeDI5MzA7XCI6XCJcIixcIiYjeDI5MkY7XCI6XCJcIixcIiYjeDI5MkU7XCI6XCJcIixcIiYjeDI5MkQ7XCI6XCJcIixcIiYjeDI5MkM7XCI6XCJcXFxcdGltZXNcIixcIiYjeDI5MkI7XCI6XCJcXFxcdGltZXNcIixcIiYjeDI5MkE7XCI6XCJcIixcIiYjeDI5Mjk7XCI6XCJcIixcIiYjeDI5Mjg7XCI6XCJcIixcIiYjeDI5Mjc7XCI6XCJcIixcIiYjeDI5MjY7XCI6XCJcIixcIiYjeDI5MjU7XCI6XCJcIixcIiYjeDI5MjQ7XCI6XCJcIixcIiYjeDI5MjM7XCI6XCJcIixcIiYjeDI5MjI7XCI6XCJcIixcIiYjeDI5MjE7XCI6XCJcIixcIiYjeDI5MjA7XCI6XCJcXFxcbWFwc3RvXFxcXGNkb3RcIixcIiYjeDI5MUY7XCI6XCJcXFxcY2RvdFxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MUU7XCI6XCJcXFxccmlnaHRhcnJvd1xcXFxjZG90XCIsXCImI3gyOTFEO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkxQztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTFCO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkxQTtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE5O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkxODtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE3O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTY7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxNTtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE0O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTM7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTEyO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5MTE7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxMDtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTBGO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MEU7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyOTBEO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MEM7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyOTBCO1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjkwQTtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyOTA5O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5MDg7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTA3O1wiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIiYjeDI5MDY7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyOTA1O1wiOlwiXFxcXG1hcHN0b1wiLFwiJiN4MjkwNDtcIjpcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5MDM7XCI6XCJcXFxcblJpZ2h0YXJyb3dcIixcIiYjeDI5MDI7XCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwiJiN4MjkwMTtcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIiYjeDI5MDA7XCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCImI3gyN0ZGO1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjdGRTtcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyN0ZEO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjdGQztcIjpcIlxcXFxtYXBzdG9cIixcIiYjeDI3RkI7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyN0ZBO1wiOlwiXFxcXExvbmdsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjdGOTtcIjpcIlxcXFxMb25ncmlnaHRhcnJvd1wiLFwiJiN4MjdGODtcIjpcIlxcXFxMb25nbGVmdGFycm93XCIsXCImI3gyN0Y3O1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCImI3gyN0Y2O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI3RjU7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyN0YxO1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjdGMDtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMkI4O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRkY7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDIxRkU7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjFGRDtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDIxRkM7XCI6XCJcXFxcbmxlZnRyaWdodGFycm93XCIsXCImI3gyMUZCO1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCImI3gyMUZBO1wiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIiYjeDIxRjk7XCI6XCJcXFxcbmxlZnRyaWdodGFycm93XCIsXCImI3gyMUY4O1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCImI3gyMUY3O1wiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIiYjeDIxRjY7XCI6XCJcXFxcUnJpZ2h0YXJyb3dcIixcIiYjeDIxRjU7XCI6XCJcIixcIiYjeDIxRjQ7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjFGMztcIjpcIlxcXFxVcGRvd25hcnJvd1wiLFwiJiN4MjFGMjtcIjpcIlxcXFxzZWFycm93XCIsXCImI3gyMUYxO1wiOlwiXFxcXG53YXJyb3dcIixcIiYjeDIxRjA7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyMUVGO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUU7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFRDtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUVDO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUI7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFQTtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUU5O1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjFFODtcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyMUU3O1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRTY7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyMUU1O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRTQ7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMUUzO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFFMjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMUUxO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDIxRTA7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMURGO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFERTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMUREO1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjFEQztcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDIxREI7XCI6XCJcXFxcUnJpZ2h0YXJyb3dcIixcIiYjeDIxREE7XCI6XCJcXFxcTGxlZnRhcnJvd1wiLFwiJiN4MjFEOTtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMUQ4O1wiOlwiXFxcXHNlYXJyb3dcIixcIiYjeDIxRDc7XCI6XCJcXFxcbmVhcnJvd1wiLFwiJiN4MjFENjtcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMUQ1O1wiOlwiXFxcXFVwZG93bmFycm93XCIsXCImI3gyMUQ0O1wiOlwiXFxcXExlZnRyaWdodGFycm93XCIsXCImI3gyMUQzO1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjFEMjtcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyMUQxO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRDA7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyMUNGO1wiOlwiXFxcXG5SaWdodGFycm93XCIsXCImI3gyMUNFO1wiOlwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFDRDtcIjpcIlxcXFxuTGVmdGFycm93XCIsXCImI3gyMUNDO1wiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCImI3gyMUNCO1wiOlwiXFxcXGxlZnRyaWdodGhhcnBvb25zXCIsXCImI3gyMUNBO1wiOlwiXFxcXGRvd25kb3duYXJyb3dzXCIsXCImI3gyMUM5O1wiOlwiXFxcXHJpZ2h0cmlnaHRhcnJvd3NcIixcIiYjeDIxQzg7XCI6XCJcXFxcdXB1cGFycm93c1wiLFwiJiN4MjFDNztcIjpcIlxcXFxsZWZ0bGVmdGFycm93c1wiLFwiJiN4MjFDNjtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIixcIiYjeDIxQzU7XCI6XCJcIixcIiYjeDIxQzQ7XCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCImI3gyMUMzO1wiOlwiXFxcXGRvd25oYXJwb29ubGVmdFwiLFwiJiN4MjFDMjtcIjpcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIsXCImI3gyMUMxO1wiOlwiXFxcXHJpZ2h0aGFycG9vbmRvd25cIixcIiYjeDIxQzA7XCI6XCJcXFxccmlnaHRoYXJwb29udXBcIixcIiYjeDIxQkY7XCI6XCJcXFxcdXBoYXJwb29ubGVmdFwiLFwiJiN4MjFCRTtcIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwiJiN4MjFCRDtcIjpcIlxcXFxsZWZ0aGFycG9vbmRvd25cIixcIiYjeDIxQkM7XCI6XCJcXFxcbGVmdGhhcnBvb251cFwiLFwiJiN4MjFCQjtcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCImI3gyMUJBO1wiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwiJiN4MjFCOTtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIixcIiYjeDIxQjg7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG53YXJyb3d9XCIsXCImI3gyMUI3O1wiOlwiXFxcXGN1cnZlYXJyb3dyaWdodFwiLFwiJiN4MjFCNjtcIjpcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLFwiJiN4MjFCNTtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMUI0O1wiOlwiXFxcXHNlYXJyb3dcIixcIiYjeDIxQjM7XCI6XCJcXFxcUnNoXCIsXCImI3gyMUIyO1wiOlwiXFxcXExzaFwiLFwiJiN4MjFCMTtcIjpcIlxcXFxSc2hcIixcIiYjeDIxQjA7XCI6XCJcXFxcTHNoXCIsXCImI3gyMUFGO1wiOlwiXFxcXHN3YXJyb3dcIixcIiYjeDIxQUU7XCI6XCJcIixcIiYjeDIxQUQ7XCI6XCJcXFxcbGVmdHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjFBQztcIjpcIlxcXFxsb29wYXJyb3dyaWdodFwiLFwiJiN4MjFBQjtcIjpcIlxcXFxsb29wYXJyb3dsZWZ0XCIsXCImI3gyMUFBO1wiOlwiXFxcXGhvb2tyaWdodGFycm93XCIsXCImI3gyMUE5O1wiOlwiXFxcXGhvb2tsZWZ0YXJyb3dcIixcIiYjeDIxQTg7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx1cGRvd25hcnJvd31cIixcIiYjeDIxQTc7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyMUE2O1wiOlwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsXCImI3gyMUE1O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDIxQTQ7XCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwiJiN4MjFBMztcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwiJiN4MjFBMjtcIjpcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsXCImI3gyMUExO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFBMDtcIjpcIlxcXFx0d29oZWFkcmlnaHRhcnJvd1wiLFwiJiN4MjE5RjtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMTlFO1wiOlwiXFxcXHR3b2hlYWRsZWZ0YXJyb3dcIixcIiYjeDIxOUQ7XCI6XCJcXFxcbmVhcnJvd1wiLFwiJiN4MjE5QztcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMTlCO1wiOlwiXCIsXCImI3gyMTlBO1wiOlwiXCIsXCImI3gyMTk5O1wiOlwiXFxcXHN3YXJyb3dcIixcIiYjeDIxOTg7XCI6XCJcXFxcc2VhcnJvd1wiLFwiJiN4MjE5NztcIjpcIlxcXFxuZWFycm93XCIsXCImI3gyMTk2O1wiOlwiXFxcXG53YXJyb3dcIixcIiYjeDIxOTU7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDIxOTQ7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDIxOTM7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyMTkyO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxOTE7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjE5MDtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcInx8fFwiOlwiXFxcXGxlZnR8fHxcXFxccmlnaHQuXCIsXCJ8fFwiOlwiXFxcXGxlZnR8fFxcXFxyaWdodC5cIixcInxcIjpcIlxcXFxsZWZ0fFxcXFxyaWdodC5cIixcIiYjeDJBRkU7XCI6XCJcIixcIiYjeDJBRkQ7XCI6XCIvL1wiLFwiJiN4MkFGQjtcIjpcIi8vL1wiLFwiJiN4MkFGQTtcIjpcIlwiLFwiJiN4MkFGOTtcIjpcIlwiLFwiJiN4MkFGODtcIjpcIlwiLFwiJiN4MkFGNztcIjpcIlwiLFwiJiN4MkFGNjtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4MkFGNTtcIjpcIlwiLFwiJiN4MkFGNDtcIjpcIlwiLFwiJiN4MkFGMztcIjpcIlwiLFwiJiN4MkFGMjtcIjpcIlxcXFxucGFyYWxsZWxcIixcIiYjeDJBRjE7XCI6XCJcIixcIiYjeDJBRjA7XCI6XCJcIixcIiYjeDJBRUY7XCI6XCJcIixcIiYjeDJBRUU7XCI6XCJcXFxcYmNhbmNlbHtcXFxcbWlkfVwiLFwiJiN4MkFFRDtcIjpcIlwiLFwiJiN4MkFFQztcIjpcIlwiLFwiJiN4MkFFQjtcIjpcIlwiLFwiJiN4MkFFQTtcIjpcIlwiLFwiJiN4MkFFOTtcIjpcIlwiLFwiJiN4MkFFODtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHBlcnB9XCIsXCImI3gyQUU3O1wiOlwiXFxcXG92ZXJsaW5le1xcXFx0b3B9XCIsXCImI3gyQUU2O1wiOlwiXCIsXCImI3gyQUU1O1wiOlwiXCIsXCImI3gyQUU0O1wiOlwiXCIsXCImI3gyQUUzO1wiOlwiXCIsXCImI3gyQUUyO1wiOlwiXCIsXCImI3gyQUUxO1wiOlwiXCIsXCImI3gyQUUwO1wiOlwiXFxcXHBlcnBcIixcIiYjeDJBREY7XCI6XCJcXFxcdG9wXCIsXCImI3gyQURFO1wiOlwiXFxcXGRhc2h2XCIsXCImI3gyQUREOyYjeDMzODtcIjpcIlwiLFwiJiN4MkFERDtcIjpcIlwiLFwiJiN4MkFEQjtcIjpcIlxcXFxwaXRjaGZvcmtcIixcIiYjeDJBREE7XCI6XCJcIixcIiYjeDJBRDk7XCI6XCJcIixcIiYjeDJBRDg7XCI6XCJcIixcIiYjeDJBRDc7XCI6XCJcIixcIiYjeDJBRDY7XCI6XCJcIixcIiYjeDJBRDU7XCI6XCJcIixcIiYjeDJBRDQ7XCI6XCJcIixcIiYjeDJBRDM7XCI6XCJcIixcIiYjeDJBRDI7XCI6XCJcIixcIiYjeDJBRDE7XCI6XCJcIixcIiYjeDJBRDA7XCI6XCJcIixcIiYjeDJBQ0Y7XCI6XCJcIixcIiYjeDJBQ0U7XCI6XCJcIixcIiYjeDJBQ0Q7XCI6XCJcIixcIiYjeDJBQ0M7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5lcX17XFxcXHN1cHNldH1cIixcIiYjeDJBQ0I7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5lcX17XFxcXHN1YnNldH1cIixcIiYjeDJBQ0E7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1cHNldH1cIixcIiYjeDJBQzk7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1YnNldH1cIixcIiYjeDJBQzg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHN1cHNldH1cIixcIiYjeDJBQzc7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHN1YnNldH1cIixcIiYjeDJBQzY7XCI6XCJcXFxcc3Vwc2V0ZXFxXCIsXCImI3gyQUM1O1wiOlwiXFxcXHN1YnNldGVxcVwiLFwiJiN4MkFDNDtcIjpcIlxcXFxkb3R7XFxcXHN1cHNldGVxfVwiLFwiJiN4MkFDMztcIjpcIlxcXFxkb3R7XFxcXHN1YnNldGVxfVwiLFwiJiN4MkFDMjtcIjpcIlxcXFx1bmRlcnNldHtcXFxcdGltZXN9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUMxO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFx0aW1lc317XFxcXHN1YnNldH1cIixcIiYjeDJBQzA7XCI6XCJcXFxcdW5kZXJzZXR7K317XFxcXHN1cHNldH1cIixcIiYjeDJBQkY7XCI6XCJcXFxcdW5kZXJzZXR7K317XFxcXHN1YnNldH1cIixcIiYjeDJBQkU7XCI6XCJcIixcIiYjeDJBQkQ7XCI6XCJcIixcIiYjeDJBQkM7XCI6XCJcXFxcZ2cgXCIsXCImI3gyQUJCO1wiOlwiXFxcXGxsXCIsXCImI3gyQUJBO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19e1xcXFxzdWNjfVwiLFwiJiN4MkFCOTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXtcXFxccHJlY31cIixcIiYjeDJBQjg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1Y2N9XCIsXCImI3gyQUI3O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxwcmVjfVwiLFwiJiN4MkFCNjtcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vsez19fXtcXFxcc3VjY31cIixcIiYjeDJBQjU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHByZWN9XCIsXCImI3gyQUI0O1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxzdWNjfVwiLFwiJiN4MkFCMztcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxccHJlY31cIixcIiYjeDJBQjI7XCI6XCJcIixcIiYjeDJBQjE7XCI6XCJcIixcIiYjeDJBQUU7XCI6XCJcIixcIiYjeDJBQUQ7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwiJiN4MkFBQztcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGhjYW5jZWx7Pn19XCIsXCImI3gyQUFCO1wiOlwiXFxcXGhjYW5jZWx7Pn1cIixcIiYjeDJBQUE7XCI6XCJcXFxcaGNhbmNlbHs8fVwiLFwiJiN4MkFBOTtcIjpcIlwiLFwiJiN4MkFBODtcIjpcIlwiLFwiJiN4MkFBNztcIjpcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIsXCImI3gyQUE2O1wiOlwiXFxcXHZhcnRyaWFuZ2xlbGVmdFwiLFwiJiN4MkFBNTtcIjpcIj48XCIsXCImI3gyQUE0O1wiOlwiPjxcIixcIiYjeDJBQTM7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsbH1cIixcIiYjeDJBQTI7JiN4MzM4O1wiOlwiXFxcXGNhbmNlbHtcXFxcZ2d9XCIsXCImI3gyQUEyO1wiOlwiXFxcXGdnXCIsXCImI3gyQUExOyYjeDMzODtcIjpcIlxcXFxjYW5jZWx7XFxcXGxsfVwiLFwiJiN4MkFBMTtcIjpcIlxcXFxsbFwiLFwiJiN4MkFBMDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxnZXFxfVwiLFwiJiN4MkE5RjtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxsZXFxfVwiLFwiJiN4MkE5RTtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ez59XCIsXCImI3gyQTlEO1wiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17PH1cIixcIiYjeDJBOUM7XCI6XCJcIixcIiYjeDJBOUI7XCI6XCJcIixcIiYjeDJBOUE7XCI6XCJcXFxcb3ZlcnNldHs9fXs+fVwiLFwiJiN4MkE5OTtcIjpcIlxcXFxvdmVyc2V0ez19ezx9XCIsXCImI3gyQTk4O1wiOlwiXCIsXCImI3gyQTk3O1wiOlwiXCIsXCImI3gyQTk2O1wiOlwiXCIsXCImI3gyQTk1O1wiOlwiXCIsXCImI3gyQTk0O1wiOlwiXCIsXCImI3gyQTkzO1wiOlwiXCIsXCImI3gyQTkyO1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxndHJsZXNzfVwiLFwiJiN4MkE5MTtcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcbGVzc2d0cn1cIixcIiYjeDJBOTA7XCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGd0cnNpbX1cIixcIiYjeDJBOEY7XCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlc3NzaW19XCIsXCImI3gyQThFO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW1lcX17Pn1cIixcIiYjeDJBOEQ7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbWVxfXs8fVwiLFwiJiN4MkE4QztcIjpcIlxcXFxndHJlcXFsZXNzXCIsXCImI3gyQThCO1wiOlwiXFxcXGxlc3NlcXFndHJcIixcIiYjeDJBOEE7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17Pn1cIixcIiYjeDJBODk7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIiYjeDJBODY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17Pn1cIixcIiYjeDJBODU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIiYjeDJBODQ7XCI6XCJcIixcIiYjeDJBODM7XCI6XCJcIixcIiYjeDJBODI7XCI6XCJcIixcIiYjeDJBODE7XCI6XCJcIixcIiYjeDJBODA7XCI6XCJcIixcIiYjeDJBN0Y7XCI6XCJcIixcIiYjeDJBN0U7JiN4MzM4O1wiOlwiXFxcXGJjYW5jZWx7XFxcXGdlcX1cIixcIiYjeDJBN0U7XCI6XCJcXFxcZ2VxXCIsXCImI3gyQTdEOyYjeDMzODtcIjpcIlxcXFxiY2FuY2Vse1xcXFxsZXF9XCIsXCImI3gyQTdEO1wiOlwiXFxcXGxlcVwiLFwiJiN4MkE3QztcIjpcIlwiLFwiJiN4MkE3QjtcIjpcIlwiLFwiJiN4MkE3QTtcIjpcIlwiLFwiJiN4MkE3OTtcIjpcIlwiLFwiJiN4MkE3ODtcIjpcIlxcXFxvdmVyc2V0e1xcXFxkb3RzfXtcXFxcZXF1aXZ9XCIsXCImI3gyQTc3O1wiOlwiXCIsXCImI3gyQTc2O1wiOlwiPT09XCIsXCImI3gyQTc1O1wiOlwiPT1cIixcIiYjeDJBNzQ7XCI6XCI6Oj1cIixcIiYjeDJBNzM7XCI6XCJcIixcIiYjeDJBNzI7XCI6XCJcXFxcdW5kZXJzZXR7PX17K31cIixcIiYjeDJBNzE7XCI6XCJcXFxcb3ZlcnNldHs9fXsrfVwiLFwiJiN4MkE3MDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxhcHByb3h9ez19XCIsXCImI3gyQTZGO1wiOlwiXFxcXG92ZXJzZXR7XFxcXHdlZGdlfXs9fVwiLFwiJiN4MkE2RTtcIjpcIlxcXFxvdmVyc2V0eyp9ez19XCIsXCImI3gyQTZEO1wiOlwiXFxcXGRvdHtcXFxcYXBwcm94fVwiLFwiJiN4MkE2QztcIjpcIlwiLFwiJiN4MkE2QjtcIjpcIlwiLFwiJiN4MkE2QTtcIjpcIlxcXFxkb3R7XFxcXHNpbX1cIixcIiYjeDJBNjk7XCI6XCJcIixcIiYjeDJBNjg7XCI6XCJcIixcIiYjeDJBNjc7XCI6XCJcXFxcZG90e1xcXFxlcXVpdn1cIixcIiYjeDJBNjY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNkb3R9ez19XCIsXCImI3gyQTY1O1wiOlwiXCIsXCImI3gyQTY0O1wiOlwiXCIsXCImI3gyQTYzO1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFx2ZWV9XCIsXCImI3gyQTYyO1wiOlwiXFxcXG92ZXJzZXR7PX17XFxcXHZlZX1cIixcIiYjeDJBNjE7XCI6XCJ1bCh2dilcIixcIiYjeDJBNjA7XCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHdlZGdlfVwiLFwiJiN4MkE1RjtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHdlZGdlfVwiLFwiJiN4MkE1RTtcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIiYjeDJBNUQ7XCI6XCJcXFxcaGNhbmNlbHtcXFxcdmVlfVwiLFwiJiN4MkE1QztcIjpcIlxcXFxoY2FuY2Vse1xcXFx3ZWRnZX1cIixcIiYjeDJBNUI7XCI6XCJcIixcIiYjeDJBNUE7XCI6XCJcIixcIiYjeDJBNTk7XCI6XCJcIixcIiYjeDJBNTg7XCI6XCJcXFxcdmVlXCIsXCImI3gyQTU3O1wiOlwiXFxcXHdlZGdlXCIsXCImI3gyQTU2O1wiOlwiXCIsXCImI3gyQTU1O1wiOlwiXCIsXCImI3gyQTU0O1wiOlwiXCIsXCImI3gyQTUzO1wiOlwiXCIsXCImI3gyQTUyO1wiOlwiXFxcXGRvdHtcXFxcdmVlfVwiLFwiJiN4MkE1MTtcIjpcIlxcXFxkb3R7XFxcXHdlZGdlfVwiLFwiJiN4MkE1MDtcIjpcIlwiLFwiJiN4MkE0RjtcIjpcIlwiLFwiJiN4MkE0RTtcIjpcIlwiLFwiJiN4MkE0RDtcIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwiJiN4MkE0QztcIjpcIlxcXFxvdmVybGluZXtcXFxcY3VwfVwiLFwiJiN4MkE0QjtcIjpcIlwiLFwiJiN4MkE0QTtcIjpcIlwiLFwiJiN4MkE0OTtcIjpcIlwiLFwiJiN4MkE0ODtcIjpcIlwiLFwiJiN4MkE0NztcIjpcIlwiLFwiJiN4MkE0NjtcIjpcIlwiLFwiJiN4MkE0NTtcIjpcIlwiLFwiJiN4MkE0NDtcIjpcIlwiLFwiJiN4MkE0MztcIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwiJiN4MkE0MjtcIjpcIlxcXFxvdmVybGluZXtcXFxcY3VwfVwiLFwiJiN4MkE0MTtcIjpcIlwiLFwiJiN4MkE0MDtcIjpcIlwiLFwiJiN4MkEzRTtcIjpcIlwiLFwiJiN4MkEzRDtcIjpcIlxcXFxsbGNvcm5lclwiLFwiJiN4MkEzQztcIjpcIlxcXFxscmNvcm5lclwiLFwiJiN4MkEzQjtcIjpcIlwiLFwiJiN4MkEzQTtcIjpcIlwiLFwiJiN4MkEzOTtcIjpcIlwiLFwiJiN4MkEzODtcIjpcIlwiLFwiJiN4MkEzNztcIjpcIlwiLFwiJiN4MkEzNjtcIjpcIlxcXFxoYXR7XFxcXG90aW1lc31cIixcIiYjeDJBMzU7XCI6XCJcIixcIiYjeDJBMzQ7XCI6XCJcIixcIiYjeDJBMzM7XCI6XCJcIixcIiYjeDJBMzI7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0aW1lc31cIixcIiYjeDJBMzE7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0aW1lc31cIixcIiYjeDJBMzA7XCI6XCJcXFxcZG90e1xcXFx0aW1lc31cIixcIiYjeDJBMkU7XCI6XCJcIixcIiYjeDJBMkQ7XCI6XCJcIixcIiYjeDJBMkM7XCI6XCJcIixcIiYjeDJBMkI7XCI6XCJcIixcIiYjeDJBMkE7XCI6XCJcIixcIiYjeDJBMjk7XCI6XCJcIixcIiYjeDJBMjg7XCI6XCJcIixcIiYjeDJBMjc7XCI6XCJcIixcIiYjeDJBMjY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17K31cIixcIiYjeDJBMjU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNpcmN9eyt9XCIsXCImI3gyQTI0O1wiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17K31cIixcIiYjeDJBMjM7XCI6XCJcXFxcaGF0eyt9XCIsXCImI3gyQTIyO1wiOlwiXFxcXGRvdHsrfVwiLFwiJiN4MkEyMTtcIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwiJiN4MkEyMDtcIjpcIj4+XCIsXCImI3gyQTFGO1wiOlwiXCIsXCImI3gyQTFFO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MkExRDtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RkY7XCI6XCJcIixcIiYjeDI5RkU7XCI6XCIrXCIsXCImI3gyOUZCO1wiOlwiXFxcXGhjYW5jZWx7fHx8fVwiLFwiJiN4MjlGQTtcIjpcIlxcXFxoY2FuY2Vse3x8fVwiLFwiJiN4MjlGOTtcIjpcIlxcXFxiYWNrc2xhc2hcIixcIiYjeDI5Rjg7XCI6XCIvXCIsXCImI3gyOUY3O1wiOlwiaGNhbmNlbHtcXGJhY2tzbGFzaH1cIixcIiYjeDI5RjY7XCI6XCJcIixcIiYjeDI5RjU7XCI6XCJcXFxcYmFja3NsYXNoXCIsXCImI3gyOUYyO1wiOlwiXFxcXFBoaVwiLFwiJiN4MjlGMTtcIjpcIlwiLFwiJiN4MjlGMDtcIjpcIlwiLFwiJiN4MjlFRTtcIjpcIlwiLFwiJiN4MjlFRDtcIjpcIlwiLFwiJiN4MjlFQztcIjpcIlwiLFwiJiN4MjlFQjtcIjpcIlxcXFxsb3plbmdlXCIsXCImI3gyOUVBO1wiOlwiXCIsXCImI3gyOUU5O1wiOlwiXCIsXCImI3gyOUU4O1wiOlwiXCIsXCImI3gyOUU3O1wiOlwiXFxcXGRkYWdnZXJcIixcIiYjeDI5RTI7XCI6XCJcXFxcc3FjdXBcXFxcc3FjdXBcIixcIiYjeDI5RTE7XCI6XCJcIixcIiYjeDI5RTA7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyOURFO1wiOlwiXCIsXCImI3gyOUREO1wiOlwiXCIsXCImI3gyOURDO1wiOlwiXCIsXCImI3gyOURCO1wiOlwiXFxcXHtcXFxce1wiLFwiJiN4MjlEOTtcIjpcIlxcXFx7XCIsXCImI3gyOUQ4O1wiOlwiXFxcXH1cIixcIiYjeDI5RDc7XCI6XCJcIixcIiYjeDI5RDY7XCI6XCJcIixcIiYjeDI5RDU7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUQ0O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlEMztcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RDI7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUQxO1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlEMDsmI3gzMzg7XCI6XCJ8IFxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjlEMDtcIjpcInwgXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI5Q0Y7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnQgfFwiLFwiJiN4MjlDRjtcIjpcIlxcXFx0cmlhbmdsZWxlZnQgfFwiLFwiJiN4MjlDRTtcIjpcIlwiLFwiJiN4MjlDRDtcIjpcIlxcXFx0cmlhbmdsZVwiLFwiJiN4MjlDQztcIjpcIlwiLFwiJiN4MjlDQjtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHRyaWFuZ2xlfVwiLFwiJiN4MjlDQTtcIjpcIlxcXFxkb3R7XFxcXHRyaWFuZ2xlfVwiLFwiJiN4MjlDOTtcIjpcIlwiLFwiJiN4MjlDODtcIjpcIlxcXFxib3hlZHtcXFxcY2lyY31cIixcIiYjeDI5Qzc7XCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCImI3gyOUM2O1wiOlwiXFxcXGJveGVke1xcXFxyaWdodGFycm93fVwiLFwiJiN4MjlDNTtcIjpcIlxcXFxiY2FuY2Vse1xcXFxzcXVhcmV9XCIsXCImI3gyOUM0O1wiOlwiXFxcXGNhbmNlbHtcXFxcc3F1YXJlfVwiLFwiJiN4MjlDMztcIjpcIlxcXFxvZG90XCIsXCImI3gyOUMyO1wiOlwiXFxcXG9kb3RcIixcIiYjeDI5QkY7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjlCRTtcIjpcIlxcXFxvZG90XCIsXCImI3gyOUJEO1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5QkM7XCI6XCJcXFxcb3BsdXNcIixcIiYjeDI5QkI7XCI6XCJcXFxcb3RpbWVzXCIsXCImI3gyOUJBO1wiOlwiXCIsXCImI3gyOUI5O1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5Qjg7XCI6XCJcXFxcdmFybm90aGluZ1wiLFwiJiN4MjlCNztcIjpcIlxcXFxvbWludXNcIixcIiYjeDI5QjY7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyOUI1O1wiOlwiXFxcXG9taW51c1wiLFwiJiN4MjlCNDtcIjpcIlxcXFx2ZWN7XFxcXHZhcm5vdGhpbmd9XCIsXCImI3gyOUIzO1wiOlwiXFxcXHZlY3tcXFxcdmFybm90aGluZ31cIixcIiYjeDI5QjI7XCI6XCJcXFxcZG90e1xcXFx2YXJub3RoaW5nfVwiLFwiJiN4MjlCMTtcIjpcIlxcXFxvdmVybGluZXtcXFxcdmFybm90aGluZ31cIixcIiYjeDI5QjA7XCI6XCJcXFxcdmFybm90aGluZ1wiLFwiJiN4MjlBRjtcIjpcIlwiLFwiJiN4MjlBRTtcIjpcIlwiLFwiJiN4MjlBRDtcIjpcIlwiLFwiJiN4MjlBQztcIjpcIlwiLFwiJiN4MjlBQjtcIjpcIlwiLFwiJiN4MjlBQTtcIjpcIlwiLFwiJiN4MjlBOTtcIjpcIlwiLFwiJiN4MjlBODtcIjpcIlwiLFwiJiN4MjlBNztcIjpcIlwiLFwiJiN4MjlBNjtcIjpcIlwiLFwiJiN4MjlBNTtcIjpcIlwiLFwiJiN4MjlBNDtcIjpcIlwiLFwiJiN4MjlBMztcIjpcIlwiLFwiJiN4MjlBMjtcIjpcIlwiLFwiJiN4MjlBMTtcIjpcIlxcXFxub3RcXFxcbG9yXCIsXCImI3gyOUEwO1wiOlwiXFxcXGJjYW5jZWx7Pn1cIixcIiYjeDI5ODI7XCI6XCI6XCIsXCImI3gyOTgxO1wiOlwiXFxcXGNpcmNcIixcIiYjeDI3NTg7XCI6XCJ8XCIsXCImI3gyNUIyO1wiOlwiXFxcXGJpZ3RyaWFuZ2xldXBcIixcIiYjeDIyRkY7XCI6XCJcXFxcRXBzaWxvblwiLFwiJiN4MjJGRTtcIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCImI3gyMkZEO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxuaX1cIixcIiYjeDIyRkM7XCI6XCJcXFxcaW5cIixcIiYjeDIyRkI7XCI6XCJcXFxcaW5cIixcIiYjeDIyRkE7XCI6XCJcXFxcaW5cIixcIiYjeDIyRjk7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIiYjeDIyRjg7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIiYjeDIyRjc7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGlufVwiLFwiJiN4MjJGNjtcIjpcIlxcXFxvdmVybGluZXtcXFxcaW59XCIsXCImI3gyMkY1O1wiOlwiXFxcXGRvdHtcXFxcaW59XCIsXCImI3gyMkY0O1wiOlwiXFxcXGluXCIsXCImI3gyMkYzO1wiOlwiXFxcXGluXCIsXCImI3gyMkYyO1wiOlwiXFxcXGluXCIsXCImI3gyMkYwO1wiOlwiXFxcXGRkb3RzXCIsXCImI3gyMkU5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdWNjfVwiLFwiJiN4MjJFODtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxccHJlY31cIixcIiYjeDIyRTc7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5vdFxcXFxzaW19ez59XCIsXCImI3gyMkU2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxub3RcXFxcc2ltfXs8fVwiLFwiJiN4MjJFNTtcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRlcVwiLFwiJiN4MjJFNDtcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRlcVwiLFwiJiN4MjJFMztcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRlcVwiLFwiJiN4MjJFMjtcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRlcVwiLFwiJiN4MjJFMTtcIjpcIlxcXFxuc3VjY1wiLFwiJiN4MjJFMDtcIjpcIlxcXFxucHJlY1wiLFwiJiN4MjJERjtcIjpcIlxcXFxzdWNjXCIsXCImI3gyMkRFO1wiOlwiXFxcXHByZWNcIixcIiYjeDIyREQ7XCI6XCJcXFxcb3ZlcmxpbmV7Pn1cIixcIiYjeDIyREM7XCI6XCJcXFxcb3ZlcmxpbmV7PH1cIixcIiYjeDIyREI7XCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlcX1cIixcIiYjeDIyREE7XCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGdlcX1cIixcIiYjeDIyRDU7XCI6XCJcXFxcI1wiLFwiJiN4MjJEMztcIjpcIlxcXFxjdXBcIixcIiYjeDIyRDI7XCI6XCJcXFxcY2FwXCIsXCImI3gyMkQxO1wiOlwiXFxcXHN1cHNldFwiLFwiJiN4MjJEMDtcIjpcIlxcXFxzdWJzZXRcIixcIiYjeDIyQ0Y7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDIyQ0U7XCI6XCJcXFxcdmVlXCIsXCImI3gyMkNEO1wiOlwiXFxcXHNpbWVxXCIsXCImI3gyMkM4O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjJDNztcIjpcIlxcXFxhc3RcIixcIiYjeDIyQzY7XCI6XCJcXFxcc3RhclwiLFwiJiN4MjJDNDtcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyMkJGO1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyMkJFO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDIyQkQ7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxvcn1cIixcIiYjeDIyQkM7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxhbmR9XCIsXCImI3gyMkJCO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbG9yfVwiLFwiJiN4MjJCQTtcIjpcIlxcXFx0b3BcIixcIiYjeDIyQjk7XCI6XCJcIixcIiYjeDIyQjc7XCI6XCJcXFxcY2lyY1xcXFxtdWx0aW1hcFwiLFwiJiN4MjJCNjtcIjpcIlxcXFxjaXJjXFxcXG11bHRpbWFwXCIsXCImI3gyMkIzO1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyQjI7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyMkIxO1wiOlwiXFxcXHN1Y2NcIixcIiYjeDIyQjA7XCI6XCJcXFxccHJlY1wiLFwiJiN4MjJBQjtcIjpcInxcXFxcbW9kZWxzXCIsXCImI3gyMkFBO1wiOlwifFxcXFxtb2RlbHNcIixcIiYjeDIyQTc7XCI6XCJcXFxcbW9kZWxzXCIsXCImI3gyMkE2O1wiOlwiXFxcXHZkYXNoXCIsXCImI3gyMjlEO1wiOlwiXFxcXG9taW51c1wiLFwiJiN4MjI5QztcIjpcIlxcXFxvbWludXNcIixcIiYjeDIyOUI7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjI5QTtcIjpcIlxcXFxvZG90XCIsXCImI3gyMjk0O1wiOlwiXFxcXHNxY3VwXCIsXCImI3gyMjkzO1wiOlwiXFxcXHNxY2FwXCIsXCImI3gyMjkyO1wiOlwiXFxcXHNxc3Vwc2V0ZXFcIixcIiYjeDIyOTE7XCI6XCJcXFxcc3FzdWJzZXRlcVwiLFwiJiN4MjI5MDsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0XCIsXCImI3gyMjkwO1wiOlwiXFxcXHNxc3Vwc2V0XCIsXCImI3gyMjhGOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRcIixcIiYjeDIyOEY7XCI6XCJcXFxcc3FzdWJzZXRcIixcIiYjeDIyOEU7XCI6XCJcXFxcY3VwXCIsXCImI3gyMjhEO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjI4QztcIjpcIlxcXFxjdXBcIixcIiYjeDIyN0Y7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFxzdWNjc2ltXCIsXCImI3gyMjdGO1wiOlwiXFxcXHN1Y2NzaW1cIixcIiYjeDIyN0U7XCI6XCJcXFxccHJlY3NpbVwiLFwiJiN4MjI3OTtcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwiJiN4MjI3ODtcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwiJiN4MjI3NztcIjpcIlxcXFxvdmVyc2V0ez59ezx9XCIsXCImI3gyMjc2O1wiOlwiXFxcXG92ZXJzZXR7PH17Pn1cIixcIiYjeDIyNzU7XCI6XCJcXFxcbm90XFxcXGdlZ1wiLFwiJiN4MjI3NDtcIjpcIlxcXFxub3RcXFxcbGVxXCIsXCImI3gyMjczO1wiOlwiXFxcXGdlZ1wiLFwiJiN4MjI3MjtcIjpcIlxcXFxsZXFcIixcIiYjeDIyNkM7XCI6XCJcIixcIiYjeDIyNjc7XCI6XCJcXFxcZ2VnXCIsXCImI3gyMjY2OyYjeDMzODtcIjpcIlxcXFxub3RcXFxcbGVxXCIsXCImI3gyMjY2O1wiOlwiXFxcXGxlcVwiLFwiJiN4MjI2MztcIjpcIlxcXFxvdmVyc2V0ez19ez19IFwiLFwiJiN4MjI1RTtcIjpcIlxcXFxvdmVyc2V0e219ez19IFwiLFwiJiN4MjI1RDtcIjpcIlxcXFxvdmVyc2V0e2RlZn17PX1cIixcIiYjeDIyNTg7XCI6XCI9XCIsXCImI3gyMjU2O1wiOlwiPVwiLFwiJiN4MjI1NTtcIjpcIj06XCIsXCImI3gyMjUzO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjUyO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjUxO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjUwO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjRGOyYjeDMzODtcIjpcIlwiLFwiJiN4MjI0RjtcIjpcIlwiLFwiJiN4MjI0RTsmI3gzMzg7XCI6XCJcIixcIiYjeDIyNEU7XCI6XCJcIixcIiYjeDIyNEM7XCI6XCJcXFxcYXBwcm94XCIsXCImI3gyMjRCO1wiOlwiXFxcXGFwcHJveFwiLFwiJiN4MjI0QTtcIjpcIlxcXFxhcHByb3hcIixcIiYjeDIyNDI7JiN4MzM4O1wiOlwiXFxcXG5lcVwiLFwiJiN4MjI0MjtcIjpcIj1cIixcIiYjeDIyM0Y7XCI6XCJcXFxcc2ltXCIsXCImI3gyMjNFO1wiOlwiXFxcXGluZnR5XCIsXCImI3gyMjNEOyYjeDMzMTtcIjpcIlxcXFxzaW1cIixcIiYjeDIyM0Q7XCI6XCJcXFxcc2ltXCIsXCImI3gyMjNCO1wiOlwiXFxcXHNpbVwiLFwiJiN4MjIzQTtcIjpcIjotOlwiLFwiJiN4MjIzOTtcIjpcIi06XCIsXCImI3gyMjM4O1wiOlwiXFxcXGJvdFwiLFwiJiN4MjIzNztcIjpcIjo6XCIsXCImI3gyMjM2O1wiOlwiOlwiLFwiJiN4MjIyMztcIjpcInxcIixcIiYjeDIyMUY7XCI6XCJcXFxcbGxjb3JuZXJcIixcIiYjeDIyMTk7XCI6XCJcXFxcY2RvdFwiLFwiJiN4MjIxODtcIjpcIlxcXFxjaXJjXCIsXCImI3gyMjE3O1wiOlwiKlwiLFwiJiN4MjIxNTtcIjpcIi9cIixcIiYjeDIyMEU7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyMjBEO1wiOlwiXFxcXG5pXCIsXCImI3gyMjBBO1wiOlwiXFxcXGluXCIsXCImI3gyMjA2O1wiOlwiXFxcXERlbHRhXCIsXCImI3gyMDQ0O1wiOlwiL1wiLFwiJiN4MkFCMDsmI3gzMzg7XCI6XCJcXFxcbnN1Y2NlcVwiLFwiJiN4MkFCMDtcIjpcIlxcXFxzdWNjZXFcIixcIiYjeDJBQUY7JiN4MzM4O1wiOlwiXFxcXG5wcmVjZXFcIixcIiYjeDJBQUY7XCI6XCJcXFxccHJlY2VxXCIsXCImI3gyQTg4O1wiOlwiXFxcXG5nZXFzbGFudFwiLFwiJiN4MkE4NztcIjpcIlxcXFxubGVxc2xhbnRcIixcIiYjeDI5RjM7XCI6XCJcXFxcUGhpXCIsXCImI3gyOUU2O1wiOlwiXFxcXG1vZGVsc1wiLFwiJiN4MjlFNTtcIjpcIlxcXFxub3RcXFxcZXF1aXZcIixcIiYjeDI5RTQ7XCI6XCJcXFxcYXBwcm94XFxcXG5lcVwiLFwiJiN4MjlFMztcIjpcIlxcXFxuZXFcIixcIiYjeDI5QzE7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyOUMwO1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjVFNjtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1RDc7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyNUQ2O1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjVDRjtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1Q0U7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Q0Q7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Q0M7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Qzk7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Qzg7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjVDNztcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyNUM2O1wiOlwiXFxcXGRpYW1vbmRcIixcIiYjeDI1QzU7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUM0O1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDMztcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QzI7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUMxO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDMDtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QkY7XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCImI3gyNUJFO1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwiJiN4MjVCRDtcIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIiYjeDI1QkM7XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCImI3gyNUI5O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI1Qjg7XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjVCNztcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyNUI2O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI1QjU7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI1QjQ7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI1QjM7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI1QjE7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUIwO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBRjtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUU7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUFEO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBQjtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUE7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUExO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBMDtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIyRUQ7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyRUM7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjJFQjtcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjJFQTtcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyMkQ5O1wiOlwiXFxcXGdnZ1wiLFwiJiN4MjJEODtcIjpcIlxcXFxsbGxcIixcIiYjeDIyRDc7XCI6XCIqPlwiLFwiJiN4MjJENjtcIjpcIjwqXCIsXCImI3gyMkQ0O1wiOlwiXFxcXHBpdGNoZm9ya1wiLFwiJiN4MjJDQztcIjpcIlwiLFwiJiN4MjJDQjtcIjpcIlwiLFwiJiN4MjJDQTtcIjpcIlxcXFxydGltZXNcIixcIiYjeDIyQzk7XCI6XCJcXFxcbHRpbWVzXCIsXCImI3gyMkI1O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyQjQ7XCI6XCJcIixcIiYjeDIyQTU7XCI6XCJcXFxcYm90XCIsXCImI3gyMjgxO1wiOlwiXFxcXG5zdWNjXCIsXCImI3gyMjgwO1wiOlwiXFxcXHByZWNlcVwiLFwiJiN4MjI3RDtcIjpcIlxcXFxzdWNjZXFcIixcIiYjeDIyN0M7XCI6XCJcXFxccHJlY2VxXCIsXCImI3gyMjdCO1wiOlwiXFxcXHN1Y2NcIixcIiYjeDIyN0E7XCI6XCJcXFxccHJlY1wiLFwiJiN4MjI3MTtcIjpcIlxcXFxnZXEvXCIsXCImI3gyMjcwO1wiOlwiXFxcXGxlcS9cIixcIiYjeDIyNkQ7XCI6XCJcXFxcbmVxXCIsXCImI3gyMjZCOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcZ2dcIixcIiYjeDIyNkI7XCI6XCJcXFxcZ2dcIixcIiYjeDIyNkE7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFxsbFwiLFwiJiN4MjI2QTtcIjpcIlxcXFxsbFwiLFwiJiN4MjI2OTtcIjpcIlxcXFxuZ2Vxc2xhbnRcIixcIiYjeDIyNjg7XCI6XCJcXFxcbmxlcXNsYW50XCIsXCImI3gyMjYxO1wiOlwiXFxcXGVxdWl2XCIsXCImI3gyMjVGO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjVDO1wiOlwiXFxcXHRyaWFuZ2xlcVwiLFwiJiN4MjI1QjtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1QTtcIjpcIlxcXFx0cmlhbmdsZXFcIixcIiYjeDIyNTk7XCI6XCJcXFxcdHJpYW5nbGVxXCIsXCImI3gyMjU3O1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjU0O1wiOlwiOj1cIixcIiYjeDIyNEQ7XCI6XCJcXFxcYXN5bXBcIixcIiYjeDIyNDc7XCI6XCJcXFxcbmNvbmdcIixcIiYjeDIyNDY7XCI6XCJcXFxcbmNvbmdcIixcIiYjeDIyNDU7XCI6XCJcXFxcY29uZ1wiLFwiJiN4MjI0NDtcIjpcIlxcXFxub3RcXFxcc2ltZXFcIixcIiYjeDIyNDM7XCI6XCJcXFxcc2ltZXFcIixcIiYjeDIyNDE7XCI6XCJcXFxcbm90XFxcXHNpbVwiLFwiJiN4MjIyNjtcIjpcIlxcXFxub3RcXFxccGFyYWxsZWxcIixcIiYjeDIyMjU7XCI6XCJcXFxccGFyYWxsZWxcIixcIiYjeDIyMjQ7XCI6XCJcXFxcbm90fFwiLFwiJiN4MjIxRDtcIjpcIlxcXFxwcm9wdG9cIixcIj09XCI6XCI9PVwiLFwiPVwiOlwiPVwiLFwiOj1cIjpcIjo9XCIsXCIvPVwiOlwiPVwiLFwiLT1cIjpcIi09XCIsXCIrPVwiOlwiKz1cIixcIio9XCI6XCIqPVwiLFwiIT1cIjpcIiE9XCIsXCImI3gyMjYwO1wiOlwiXFxcXG5lcVwiLFwiJiN4MjI2MjtcIjpcIlxcXFxlcXVpdiAvXCIsXCImI3gyMjQ5O1wiOlwiXFxcXGFwcHJveCAvXCIsXCImI3gyMjNDO1wiOlwic2ltXCIsXCImI3gyMjQ4O1wiOlwiXFxcXGFwcHJveFwiLFwiJiN4MjI2RTtcIjpcIjwvXCIsXCImbHQ7XCI6XCI8XCIsXCImI3gyMjZGO1wiOlwiPi9cIixcIj49XCI6XCI+PVwiLFwiPlwiOlwiPlwiLFwiJiN4MjI2NTtcIjpcIlxcXFxnZXFcIixcIiYjeDIyNjQ7XCI6XCJcXFxcbGVxXCIsXCImbHQ7PVwiOlwiPD1cIixcIiYjeDIyOEI7XCI6XCJcXFxcc3Vwc2V0bmVxXCIsXCImI3gyMjhBO1wiOlwiXFxcXHN1YnNldG5lcVwiLFwiJiN4MjI4OTtcIjpcIlxcXFxuc3Vwc2V0ZXFcIixcIiYjeDIyODg7XCI6XCJcXFxcbnN1YnNldGVxXCIsXCImI3gyMjg3O1wiOlwiXFxcXHN1cHNldGVxXCIsXCImI3gyMjg2O1wiOlwiXFxcXHN1YnNldGVxXCIsXCImI3gyMjg1O1wiOlwiXFxcXG5vdFxcXFxzdXBzZXRcIixcIiYjeDIyODQ7XCI6XCJcXFxcbm90XFxcXHN1YnNldFwiLFwiJiN4MjI4MzsmI3gyMEQyO1wiOlwiXFxcXHN1cHNldCB8XCIsXCImI3gyMjgzO1wiOlwiXFxcXHN1cHNldFwiLFwiJiN4MjI4MjsmI3gyMEQyO1wiOlwiXFxcXHN1YnNldCB8XCIsXCImI3gyMjgyO1wiOlwiXFxcXHN1YnNldFwiLFwiJiN4MjIwQztcIjpcIlxcXFxub3RcXFxcaW5cIixcIiYjeDIyMDk7XCI6XCJcXFxcbm90aW5cIixcIiYjeDIyMDg7XCI6XCJcXFxcaW5cIixcIiYjeDIyMDE7XCI6XCJDXCIsXCImI3gyMjA0O1wiOlwiXFxcXG5leGlzdHNcIixcIiYjeDIyMDM7XCI6XCJcXFxcZXhpc3RzXCIsXCImI3gyMjAwO1wiOlwiXFxcXGZvcmFsbFwiLFwiJiN4MjIyNztcIjpcIlxcXFxsYW5kXCIsXCImYW1wOyZhbXA7XCI6XCJcXFxcJlxcXFwmXCIsXCImI3gyMjI4O1wiOlwiXFxcXGxvclwiLFwiJiN4MjJBRjtcIjpcIlxcXFxjYW5jZWx7XFxcXHZEYXNofVwiLFwiJiN4MjJBRTtcIjpcIlxcXFxjYW5jZWx7XFxcXFZkYXNofVwiLFwiJiN4MjJBRDtcIjpcIlxcXFxudkRhc2hcIixcIiYjeDIyQUM7XCI6XCJcXFxcbnZEYXNoXCIsXCImI3gyMkE5O1wiOlwiXFxcXFZkYXNoXCIsXCImI3gyMkE4O1wiOlwiXFxcXHZEYXNoXCIsXCImI3gyMkE0O1wiOlwiXFxcXHRvcFwiLFwiJiN4MjJBMztcIjpcIlxcXFxkYXNodlwiLFwiJiN4MjJBMjtcIjpcIlxcXFx2ZGFzaFwiLFwiJiN4MjIwQjtcIjpcIlxcXFxuaVwiLFwiJiN4MjJGMTtcIjpcIlxcXFxkZG90c1wiLFwiJiN4MjJFRjtcIjpcIlxcXFxoZG90c1wiLFwiJiN4MjJFRTtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4MjAyNjtcIjpcIlxcXFxoZG90c1wiLFwiJiN4M0Y2O1wiOlwiXFxcXG5pXCIsXCI6XCI6XCI6XCIsXCIuLi5cIjpcIlxcXFxjZG90c1wiLFwiLi5cIjpcIi4uXCIsXCItPlwiOlwiLT5cIixcIiYjeDIyMzU7XCI6XCJcXFxcYmVjYXVzZVwiLFwiJiN4MjIzNDtcIjpcIlxcXFx0aGVyZWZvcmUgXCIsXCImI3gyMDYzO1wiOlwiXCIsXCIsXCI6XCIsXCIsXCI7XCI6XCI7XCIsXCImI3gyOUZEO1wiOlwiXFxcXH1cIixcIiYjeDI5RkM7XCI6XCJcXFxce1wiLFwiJiN4Mjk5ODtcIjpcIlxcXFxdXCIsXCImI3gyOTk3O1wiOlwiXFxcXFtcIixcIiYjeDI5OTY7XCI6XCJcXFxcbGxcIixcIiYjeDI5OTU7XCI6XCJcXFxcZ2dcIixcIiYjeDI5OTQ7XCI6XCJcXFxcZ2dcIixcIiYjeDI5OTM7XCI6XCJcXFxcbGxcIixcIiYjeDI5OTI7XCI6XCJcXFxcZ2dcIixcIiYjeDI5OTE7XCI6XCJcXFxcbGxcIixcIiYjeDI5OTA7XCI6XCJcXFxcXVwiLFwiJiN4Mjk4RjtcIjpcIlxcXFxdXCIsXCImI3gyOThFO1wiOlwiXFxcXF1cIixcIiYjeDI5OEQ7XCI6XCJcXFxcW1wiLFwiJiN4Mjk4QztcIjpcIlxcXFxbXCIsXCImI3gyOThCO1wiOlwiXFxcXF1cIixcIiYjeDI5OEE7XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4Mjk4OTtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI5ODg7XCI6XCJ8XFxcXClcIixcIiYjeDI5ODc7XCI6XCJcXFxcKHxcIixcIiYjeDI5ODY7XCI6XCJ8XFxcXClcIixcIiYjeDI5ODU7XCI6XCJcXFxcKFxcXFwoXCIsXCImI3gyOTg0O1wiOlwifFxcXFx9XCIsXCImI3gyOTgzO1wiOlwiXFxcXHt8XCIsXCImI3gyOTgwO1wiOlwiXFxcXHx8XCIsXCImI3gyN0VGO1wiOlwiXFxcXGxlZnQuIFxcXFxyaWdodF1cIixcIiYjeDI3RUU7XCI6XCJcXFxcbGVmdFsgXFxcXHJpZ2h0LlwiLFwiJiN4MjdFRDtcIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXVwiLFwiJiN4MjdFQztcIjpcIlxcXFxsZWZ0W1sgXFxcXHJpZ2h0LlwiLFwiJiN4MjdFQjtcIjpcIlxcXFxnZ1wiLFwiJiN4MjdFQTtcIjpcIlxcXFxsbFwiLFwiJiN4MjdFOTtcIjpcIlxcXFxyYW5nbGVcIixcIiYjeDI3RTg7XCI6XCJcXFxcbGFuZ2xlXCIsXCImI3gyN0U3O1wiOlwiXFxcXGxlZnQuIFxcXFxyaWdodF1dXCIsXCImI3gyN0U2O1wiOlwiXFxcXGxlZnRbWyBcXFxccmlnaHQuXCIsXCImI3gyNzczO1wiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0KVwiLFwiJiN4Mjc3MjtcIjpcIlxcXFxsZWZ0KFxcXFxyaWdodC5cIixcIiYjeDIzMkE7XCI6XCJcXFxccmFuZ2xlXCIsXCImI3gyMzI5O1wiOlwiXFxcXGxhbmdsZVwiLFwiJiN4MjMwQjtcIjpcIlxcXFxyZmxvb3JcIixcIiYjeDIzMEE7XCI6XCJcXFxcbGZsb29yXCIsXCImI3gyMzA5O1wiOlwiXFxcXHJjZWlsXCIsXCImI3gyMzA4O1wiOlwiXFxcXGxjZWlsXCIsXCImI3gyMDE2O1wiOlwiXFxcXHBhcmFsbGVsXCIsXCJ9XCI6XCJcXFxcbGVmdC5cXFxccmlnaHR9XCIsXCJ7XCI6XCJcXFxcbGVmdHtcXFxccmlnaHQuXCIsXCJdXCI6XCJcXFxcbGVmdF1cXFxccmlnaHQuXCIsXCJbXCI6XCJcXFxcbGVmdFtcXFxccmlnaHQuXCIsXCIpXCI6XCJcXFxcbGVmdC5cXFxccmlnaHQpXCIsXCIoXCI6XCJcXFxcbGVmdChcXFxccmlnaHQuXCIsXCImI3gyMDFEO1wiOidcIicsXCImI3gyMDFDO1wiOlwiYGBcIixcIiYjeDIwMTk7XCI6XCInXCIsXCImI3gyMDE4O1wiOlwiYFwiLFwiJUNFJUIxXCI6XCJcXFxcYWxwaGFcIixcIiVDRSVCMlwiOlwiXFxcXGJldGFcIixcIiVDRSVCM1wiOlwiXFxcXGdhbW1hXCIsXCIlQ0UlOTNcIjpcIlxcXFxHYW1tYVwiLFwiJUNFJUI0XCI6XCJcXFxcZGVsdGFcIixcIiVDRSU5NFwiOlwiXFxcXERlbHRhXCIsXCIlQ0YlQjVcIjpcIlxcXFxlcHNpbG9uXCIsXCIlQ0UlQjZcIjpcIlxcXFx6ZXRhXCIsXCIlQ0UlQjdcIjpcIlxcXFxldGFcIixcIiVDRSVCOFwiOlwiXFxcXHRoZXRhXCIsXCIlQ0UlOThcIjpcIlxcXFxUaGV0YVwiLFwiJUNFJUI5XCI6XCJcXFxcaW90YVwiLFwiJUNFJUJBXCI6XCJcXFxca2FwcGFcIixcIiVDRSVCQlwiOlwiXFxcXGxhbWJkYVwiLFwiJUNFJUJDXCI6XCJcXFxcbXVcIixcIiVDRSVCRFwiOlwiXFxcXG51XCIsXCIlQ0UlQkZcIjpcIlxcXFxvbWljcm9uXCIsXCIlQ0YlODBcIjpcIlxcXFxwaVwiLFwiJUNFJUEwXCI6XCJcXFxcUGlcIixcIiVDRiU4MVwiOlwiXFxcXHBob1wiLFwiJUNGJTgzXCI6XCJcXFxcc2lnbWFcIixcIiVDRSVBM1wiOlwiXFxcXFNpZ21hXCIsXCIlQ0YlODRcIjpcIlxcXFx0YXVcIixcIiVDRiU4NVwiOlwiXFxcXHVwc2lsb25cIixcIiVDRSVBNVwiOlwiXFxcXFVwc2lsb25cIixcIiVDRiU5NVwiOlwiXFxcXHBoaVwiLFwiJUNFJUE2XCI6XCJcXFxcUGhpXCIsXCIlQ0YlODdcIjpcIlxcXFxjaGlcIixcIiVDRiU4OFwiOlwiXFxcXHBzaVwiLFwiJUNFJUE4XCI6XCJcXFxcUHNpXCIsXCIlQ0YlODlcIjpcIlxcXFxvbWVnYVwiLFwiJUNFJUE5XCI6XCJcXFxcT21lZ2FcIn19LDkwMzk6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmFsbE1hdGhPcGVyYXRvcnNCeUdseXBoPXZvaWQgMCx0LmFsbE1hdGhPcGVyYXRvcnNCeUdseXBoPXtfOlwiXFxcXHVuZGVybGluZVwiLFwi4o+hXCI6XCJcXFxcdW5kZXJicmFjZVwiLFwi4o+gXCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCLij59cIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCLij55cIjpcIlxcXFxvdmVyYnJhY2VcIixcIuKPnVwiOlwiXFxcXHVuZGVyYnJhY2VcIixcIuKPnFwiOlwiXFxcXG92ZXJicmFjZVwiLFwi4o61XCI6XCJcXFxcdW5kZXJicmFjZVwiLFwi4o60XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCLig5xcIjpcIlxcXFxzcXVhcmVcIixcIuKDm1wiOlwiXFxcXHNxdWFyZVwiLFwi4oGkXCI6XCJcIixcIuKBl1wiOlwiJycnJ1wiLFwi4oC+XCI6XCJcXFxcb3ZlcmxpbmVcIixcIuKAt1wiOlwiYGBgXCIsXCLigLZcIjpcImBgXCIsXCLigLVcIjpcImBcIixcIuKAtFwiOlwiJycnXCIsXCLigLNcIjpcIicnXCIsXCLigJ9cIjpcImBgXCIsXCLigJ5cIjpcIiwsXCIsXCLigJtcIjpcImBcIixcIuKAmlwiOlwiLFwiLFwiXlwiOlwiXFxcXGhhdFwiLFwiy7dcIjpcIlxcXFxzaW1cIixcIsudXCI6XCJcXFxcc2ltXCIsXCLLnFwiOlwiXFxcXHNpbVwiLFwiy5pcIjpcIlxcXFxjaXJjXCIsXCLLmVwiOlwiXFxcXGNkb3RcIixcIsuYXCI6XCIgXCIsy406XCJcXFxcX1wiLMuLOlwiy4tcIizLijpcIsuKXCIsy4k6XCLLiVwiLMuHOlwiXCIsy4Y6XCJcXFxcaGF0XCIswro6XCJvXCIsXCLCuVwiOlwiMVwiLFwiwrhcIjpcIixcIixcIsK0XCI6XCLCtFwiLFwiwrNcIjpcIjNcIixcIsKyXCI6XCIyXCIsXCLCsFwiOlwiXFxcXGNpcmNcIixcIsKvXCI6XCJcXFxcYmFyXCIswqo6XCJhXCIsXCLihptcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiwqhcIjpcIlxcXFxjZG90XFxcXGNkb3RcIixcIn5cIjpcIlxcXFxzaW1cIixcImBcIjpcImBcIixcIi0tXCI6XCItLVwiLFwiKytcIjpcIisrXCIsXCImXCI6XCJcXFxcJlwiLFwi4oicXCI6XCJcXFxcc3FydFs0XXt9XCIsXCLiiJtcIjpcIlxcXFxzcXJ0WzNde31cIixcIuKImlwiOlwiXFxcXHNxcnR7fVwiLOKFhjpcImRcIizihYU6XCJcXFxcbWF0aGJie0R9XCIsXCI/XCI6XCI/XCIsXCJAXCI6XCJAXCIsXCIvL1wiOlwiLy9cIixcIiEhXCI6XCIhIVwiLFwiIVwiOlwiIVwiLFwi4pmvXCI6XCJcXFxcI1wiLFwi4pmuXCI6XCJcIixcIuKZrVwiOlwiXCIsXCLigLJcIjpcIidcIixcIjw+XCI6XCI8PlwiLFwiKipcIjpcIlxcXFxzdGFyXFxcXHN0YXJcIixcIuKIh1wiOlwiXFxcXG5hYmxhXCIsXCLiiIJcIjpcIlxcXFxwYXJ0aWFsXCIsXCLiiplcIjpcIlxcXFxiaWdvZG90XCIsXCLCrFwiOlwiXFxcXG5lZ1wiLFwi4oiiXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4oihXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4oigXCI6XCJcXFxcYW5nbGVcIixcIsO3XCI6XCJcXFxcZGl2XCIsXCIvXCI6XCIvXCIsXCLiiJZcIjpcIlxcXFxiYWNrc2xhc2hcIixcIlxcXFxcIjpcIlxcXFxiYWNrc2xhc2hcIixcIiVcIjpcIlxcXFwlXCIsXCLiipdcIjpcIlxcXFxiaWdvdGltZXNcIixcIsK3XCI6XCJcXFxcY2RvdFwiLFwi4qi/XCI6XCJcXFxcY29wcm9kXCIsXCLiqK9cIjpcIlxcXFx0aW1lc1wiLFwi4ouFXCI6XCJcXFxcY2RvdFwiLFwi4oqhXCI6XCJcXFxcYm94ZG90XCIsXCLiiqBcIjpcIlxcXFxib3h0aW1lc1wiLFwi4oGiXCI6XCJcIixcIuKBg1wiOlwiLVwiLFwi4oCiXCI6XCJcXFxcY2RvdFwiLFwiLlwiOlwiLlwiLFwiKlwiOlwiXFxcXHN0YXJcIixcIuKIqlwiOlwiXFxcXGN1cFwiLFwi4oipXCI6XCJcXFxcY2FwXCIsXCLiiJBcIjpcIlxcXFxjb3Byb2RcIixcIuKIj1wiOlwiXFxcXHByb2RcIixcIuKJgFwiOlwiXCIsXCLiq79cIjpcIlwiLFwi4qu8XCI6XCJcXFxcbWlkXFxcXG1pZFxcXFxtaWRcIixcIuKoiVwiOlwiXFxcXHRpbWVzXCIsXCLiqIhcIjpcIlwiLFwi4qiHXCI6XCJcIixcIuKohlwiOlwiXFxcXHNxY3VwXCIsXCLiqIVcIjpcIlxcXFxzcWNhcFwiLFwi4qiCXCI6XCJcXFxcb3RpbWVzXCIsXCLiqIBcIjpcIlxcXFxvZG90XCIsXCLii4JcIjpcIlxcXFxjYXBcIixcIuKLgVwiOlwiXFxcXHZlZVwiLFwi4ouAXCI6XCJcXFxcd2VkZ2VcIixcIuKohFwiOlwiXFxcXHVwbHVzXCIsXCLiqINcIjpcIlxcXFxjdXBcIixcIuKLg1wiOlwiXFxcXGN1cFwiLFwi4qicXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbnR9XCIsXCLiqJtcIjpcIlxcXFxvdmVybGluZXtcXFxcaW50fVwiLFwi4qiaXCI6XCJcXFxcaW50XCIsXCLiqJlcIjpcIlxcXFxpbnRcIixcIuKomFwiOlwiXFxcXGludFwiLFwi4qiXXCI6XCJcXFxcaW50XCIsXCLiqJZcIjpcIlxcXFxvaW50XCIsXCLiqJVcIjpcIlxcXFxvaW50XCIsXCLiqJRcIjpcIlxcXFxpbnRcIixcIuKok1wiOlwiXFxcXGludFwiLFwi4qiSXCI6XCJcXFxcaW50XCIsXCLiqJFcIjpcIlxcXFxpbnRcIixcIuKokFwiOlwiXFxcXGludFwiLFwi4qiPXCI6XCJcXFxcYmNhbmNlbHtcXFxcaW50fVwiLFwi4qiOXCI6XCJcIixcIuKojVwiOlwiXFxcXGhjYW5jZWx7XFxcXGludH1cIixcIuKojFwiOlwiXFxcXGlpaWludFwiLFwi4oizXCI6XCJcXFxcb2ludFwiLFwi4oiyXCI6XCJcXFxcb2ludFwiLFwi4oixXCI6XCJcXFxcaW50XCIsXCLiiLBcIjpcIlxcXFxvaWludFwiLFwi4oivXCI6XCJcXFxcb2lpbnRcIixcIuKIrlwiOlwiXFxcXG9pbnRcIixcIuKIq1wiOlwiXFxcXGludFwiLFwi4qiBXCI6XCJcXFxcb3BsdXNcIixcIuKKmFwiOlwiXFxcXG9zbGFzaFwiLFwi4oqWXCI6XCJcXFxcb21pbnVzXCIsXCLiipVcIjpcIlxcXFxvcGx1c1wiLFwi4oitXCI6XCJcXFxcaWlpbnRcIixcIuKIrFwiOlwiXFxcXGlpbnRcIixcIuKoi1wiOlwiXCIsXCLiqIpcIjpcIlwiLFwi4oiRXCI6XCJcXFxcc3VtXCIsXCLiip9cIjpcIlxcXFxib3htaW51c1wiLFwi4oqeXCI6XCJcXFxcYm94cGx1c1wiLFwi4oiUXCI6XCJcXFxcZG90eyt9XCIsXCLiiJNcIjpcIistXCIsXCLiiJJcIjpcIi1cIixcIsKxXCI6XCJcXFxccG1cIixcIi1cIjpcIi1cIixcIitcIjpcIitcIixcIuKthlwiOlwiXFxcXFJyaWdodGFycm93XCIsXCLirYVcIjpcIlxcXFxMbGVmdGFycm93XCIsXCLip7RcIjpcIjpcXFxccmlnaHRhcnJvd1wiLFwi4qevXCI6XCJcIixcIuKnn1wiOlwiXFxcXGJ1bGxldC1cXFxcYnVsbGV0XCIsXCLipp9cIjpcIlxcXFxhbmdsZVwiLFwi4qaeXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qadXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qacXCI6XCJcXFxccGVycFwiLFwi4qabXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qaaXCI6XCJcIixcIuKmmVwiOlwiXFxcXHZkb3RzXCIsXCLipb9cIjpcIlwiLFwi4qW+XCI6XCJcIixcIuKlvVwiOlwiXFxcXHByZWNcIixcIuKlvFwiOlwiXFxcXHN1Y2NcIixcIuKlu1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vwc2V0fVwiLFwi4qW6XCI6XCJcIixcIuKluVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vic2V0fVwiLFwi4qW4XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHJpZ2h0YXJyb3d9ez59XCIsXCLipbdcIjpcIlwiLFwi4qW2XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGxlZnRhcnJvd317PH1cIixcIuKltVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxyaWdodGFycm93fVwiLFwi4qW0XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHJpZ2h0YXJyb3d9XCIsXCLipbNcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcbGVmdGFycm93fVwiLFwi4qWyXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxccmlnaHRhcnJvd31cIixcIuKlsVwiOlwiXFxcXG92ZXJzZXR7PX17XFxcXHJpZ2h0YXJyb3d9XCIsXCLipbBcIjpcIlwiLFwi4qWvXCI6XCJcIixcIuKlrlwiOlwiXCIsXCLipa1cIjpcIlxcXFxvdmVybGluZXtcXFxccmlnaHRoYXJwb29uZG93bn1cIixcIuKlrFwiOlwiXFxcXHVuZGVybGluZXtcXFxccmlnaHRoYXJwb29udXB9XCIsXCLipatcIjpcIlxcXFxvdmVybGluZXtcXFxcbGVmdGhhcnBvb25kb3dufVwiLFwi4qWqXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsZWZ0aGFycG9vbnVwfVwiLFwi4qWpXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKlqFwiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCLipadcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwi4qWmXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKlpVwiOlwiXFxcXERvd25hcnJvd1wiLFwi4qWkXCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4qWjXCI6XCJcXFxcVXBhcnJvd1wiLFwi4qWiXCI6XCJcXFxcTGVmdGFycm93XCIsXCLipaFcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKloFwiOlwiXFxcXHVwYXJyb3dcIixcIuKln1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKlnlwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qWdXCI6XCJcXFxcZG93bmFycm93XCIsXCLipZxcIjpcIlxcXFx1cGFycm93XCIsXCLipZtcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipZpcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKlmVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qWYXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qWXXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qWWXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipZVcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKllFwiOlwiXFxcXHVwYXJyb3dcIixcIuKlk1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKlklwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qWRXCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIuKlkFwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipY9cIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4qWOXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKljVwiOlwiXFxcXHVwZG93bmFycm93XCIsXCLipYxcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4qWLXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKlilwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipYlcIjpcIlwiLFwi4qWIXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKlh1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCLipYZcIjpcIlwiLFwi4qWFXCI6XCJcIixcIuKlhFwiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwi4qWDXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCLipYJcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIuKlgVwiOlwiXFxcXGNpcmNsZWFycm93cmlnaHRcIixcIuKlgFwiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwi4qS/XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qS+XCI6XCJcXFxcbGVmdGFycm93XCIsXCLipL1cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkvFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKku1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkulwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qS5XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLhcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKkt1wiOlwiXFxcXFJzaFwiLFwi4qS2XCI6XCJcXFxcTHNoXCIsXCLipLVcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKktFwiOlwiXFxcXHVwYXJyb3dcIixcIuKks1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkslwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qSxXCI6XCIgXCIsXCLipLBcIjpcIiBcIixcIuKkr1wiOlwiIFwiLFwi4qSuXCI6XCIgXCIsXCLipK1cIjpcIiBcIixcIuKkrFwiOlwiXFxcXHRpbWVzXCIsXCLipKtcIjpcIlxcXFx0aW1lc1wiLFwi4qSqXCI6XCIgXCIsXCLipKlcIjpcIiBcIixcIuKkqFwiOlwiIFwiLFwi4qSnXCI6XCIgXCIsXCLipKZcIjpcIiBcIixcIuKkpVwiOlwiIFwiLFwi4qSkXCI6XCIgXCIsXCLipKNcIjpcIiBcIixcIuKkolwiOlwiIFwiLFwi4qShXCI6XCIgXCIsXCLipKBcIjpcIlxcXFxtYXBzdG9cXFxcY2RvdFwiLFwi4qSfXCI6XCJcXFxcY2RvdFxcXFxsZWZ0YXJyb3dcIixcIuKknlwiOlwiXFxcXHJpZ2h0YXJyb3dcXFxcY2RvdFwiLFwi4qSdXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipJxcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipJtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkmlwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkmVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qSYXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSXXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSWXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSVXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSUXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSTXCI6XCJcXFxcZG93bmFycm93XCIsXCLipJJcIjpcIlxcXFx1cGFycm93XCIsXCLipJFcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipJBcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipI9cIjpcIlxcXFxyaWdodGFycm93XCIsXCLipI5cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkjVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkjFwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qSLXCI6XCJcXFxcRG93bmFycm93XCIsXCLipIpcIjpcIlxcXFxVcGFycm93XCIsXCLipIlcIjpcIlxcXFx1cGFycm93XCIsXCLipIhcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKkh1wiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIuKkhlwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4qSFXCI6XCJcXFxcbWFwc3RvXCIsXCLipIRcIjpcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIixcIuKkg1wiOlwiXFxcXG5SaWdodGFycm93XCIsXCLipIJcIjpcIlxcXFxuTGVmdGFycm93XCIsXCLipIFcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIuKkgFwiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwi4p+/XCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCLin75cIjpcIlxcXFxSaWdodGFycm93XCIsXCLin71cIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKfvFwiOlwiXFxcXG1hcHN0b1wiLFwi4p+7XCI6XCJcXFxcbGVmdGFycm93XCIsXCLin7pcIjpcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIixcIuKfuVwiOlwiXFxcXExvbmdyaWdodGFycm93XCIsXCLin7hcIjpcIlxcXFxMb25nbGVmdGFycm93XCIsXCLin7dcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4p+2XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4p+1XCI6XCJcXFxcbGVmdGFycm93XCIsXCLin7FcIjpcIlxcXFxEb3duYXJyb3dcIixcIuKfsFwiOlwiXFxcXFVwYXJyb3dcIixcIuKKuFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKHv1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLih75cIjpcIlxcXFxyaWdodGFycm93XCIsXCLih71cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHvFwiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwi4oe7XCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIuKHulwiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIuKHuVwiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwi4oe4XCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIuKHt1wiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIuKHtlwiOlwiXFxcXFJyaWdodGFycm93XCIsXCLih7VcIjpcIlwiLFwi4oe0XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oezXCI6XCJcXFxcVXBkb3duYXJyb3dcIixcIuKHslwiOlwiXFxcXHNlYXJyb3dcIixcIuKHsVwiOlwiXFxcXG53YXJyb3dcIixcIuKHsFwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4oevXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oeuXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oetXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oesXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oerXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oeqXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oepXCI6XCJcXFxcRG93bmFycm93XCIsXCLih6hcIjpcIlxcXFxSaWdodGFycm93XCIsXCLih6dcIjpcIlxcXFxVcGFycm93XCIsXCLih6ZcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKHpVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKHpFwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4oejXCI6XCJcXFxcZG93bmFycm93XCIsXCLih6JcIjpcIlxcXFxyaWdodGFycm93XCIsXCLih6FcIjpcIlxcXFx1cGFycm93XCIsXCLih6BcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHn1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oeeXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oedXCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCLih5xcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHm1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCLih5pcIjpcIlxcXFxMbGVmdGFycm93XCIsXCLih5lcIjpcIlxcXFxzd2Fycm93XCIsXCLih5hcIjpcIlxcXFxzZWFycm93XCIsXCLih5dcIjpcIlxcXFxuZWFycm93XCIsXCLih5ZcIjpcIlxcXFxud2Fycm93XCIsXCLih5VcIjpcIlxcXFxVcGRvd25hcnJvd1wiLFwi4oeUXCI6XCJcXFxcTGVmdHJpZ2h0YXJyb3dcIixcIuKHk1wiOlwiXFxcXERvd25hcnJvd1wiLFwi4oeSXCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4oeRXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oeQXCI6XCJcXFxcTGVmdGFycm93XCIsXCLih49cIjpcIlxcXFxuUmlnaHRhcnJvd1wiLFwi4oeOXCI6XCJcXFxcbkxlZnRyaWdodGFycm93XCIsXCLih41cIjpcIlxcXFxuTGVmdGFycm93XCIsXCLih4xcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwi4oeLXCI6XCJcXFxcbGVmdHJpZ2h0aGFycG9vbnNcIixcIuKHilwiOlwiXFxcXGRvd25kb3duYXJyb3dzXCIsXCLih4lcIjpcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIsXCLih4hcIjpcIlxcXFx1cHVwYXJyb3dzXCIsXCLih4dcIjpcIlxcXFxsZWZ0bGVmdGFycm93c1wiLFwi4oeGXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCLih4VcIjpcIlwiLFwi4oeEXCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCLih4NcIjpcIlxcXFxkb3duaGFycG9vbmxlZnRcIixcIuKHglwiOlwiXFxcXGRvd25oYXJwb29ucmlnaHRcIixcIuKHgVwiOlwiXFxcXHJpZ2h0aGFycG9vbmRvd25cIixcIuKHgFwiOlwiXFxcXHJpZ2h0aGFycG9vbnVwXCIsXCLihr9cIjpcIlxcXFx1cGhhcnBvb25sZWZ0XCIsXCLihr5cIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwi4oa9XCI6XCJcXFxcbGVmdGhhcnBvb25kb3duXCIsXCLihrxcIjpcIlxcXFxsZWZ0aGFycG9vbnVwXCIsXCLihrtcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCLihrpcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKGuVwiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwi4oa4XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG53YXJyb3d9XCIsXCLihrdcIjpcIlxcXFxjdXJ2ZWFycm93cmlnaHRcIixcIuKGtlwiOlwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIsXCLihrVcIjpcIlxcXFxzd2Fycm93XCIsXCLihrRcIjpcIlxcXFxzZWFycm93XCIsXCLihrNcIjpcIlxcXFxSc2hcIixcIuKGslwiOlwiXFxcXExzaFwiLFwi4oaxXCI6XCJcXFxcUnNoXCIsXCLihrBcIjpcIlxcXFxMc2hcIixcIuKGr1wiOlwiXFxcXHN3YXJyb3dcIixcIuKGrlwiOlwiXCIsXCLihq1cIjpcIlxcXFxsZWZ0cmlnaHRzcXVpZ2Fycm93XCIsXCLihqxcIjpcIlxcXFxsb29wYXJyb3dyaWdodFwiLFwi4oarXCI6XCJcXFxcbG9vcGFycm93bGVmdFwiLFwi4oaqXCI6XCJcXFxcaG9va3JpZ2h0YXJyb3dcIixcIuKGqVwiOlwiXFxcXGhvb2tsZWZ0YXJyb3dcIixcIuKGqFwiOlwiXFxcXHVuZGVybGluZXtcXFxcdXBkb3duYXJyb3d9XCIsXCLihqdcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKGplwiOlwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsXCLihqVcIjpcIlxcXFx1cGFycm93XCIsXCLihqRcIjpcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsXCLihqNcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwi4oaiXCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwi4oahXCI6XCJcXFxcZG93bmFycm93XCIsXCLihqBcIjpcIlxcXFx0d29oZWFkcmlnaHRhcnJvd1wiLFwi4oafXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oaeXCI6XCJcXFxcdHdvaGVhZGxlZnRhcnJvd1wiLFwi4oadXCI6XCJcXFxcbmVhcnJvd1wiLFwi4oacXCI6XCJcXFxcbndhcnJvd1wiLFwi4oaaXCI6XCJcIixcIuKGmVwiOlwiXFxcXHN3YXJyb3dcIixcIuKGmFwiOlwiXFxcXHNlYXJyb3dcIixcIuKGl1wiOlwiXFxcXG5lYXJyb3dcIixcIuKGllwiOlwiXFxcXG53YXJyb3dcIixcIuKGlVwiOlwiXFxcXHVwZG93bmFycm93XCIsXCLihpRcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4oaTXCI6XCJcXFxcZG93bmFycm93XCIsXCLihpJcIjpcIlxcXFxyaWdodGFycm93XCIsXCLihpFcIjpcIlxcXFx1cGFycm93XCIsXCLihpBcIjpcIlxcXFxsZWZ0YXJyb3dcIixcInx8fFwiOlwiXFxcXGxlZnR8fHxcXFxccmlnaHQuXCIsXCJ8fFwiOlwiXFxcXGxlZnR8fFxcXFxyaWdodC5cIixcInxcIjpcIlxcXFxtaWRcIixcIuKrvlwiOlwiXCIsXCLiq71cIjpcIi8vXCIsXCLiq7tcIjpcIi8vL1wiLFwi4qu6XCI6XCJcIixcIuKruVwiOlwiXCIsXCLiq7hcIjpcIlwiLFwi4qu3XCI6XCJcIixcIuKrtlwiOlwiXFxcXHZkb3RzXCIsXCLiq7VcIjpcIlwiLFwi4qu0XCI6XCJcIixcIuKrs1wiOlwiXCIsXCLiq7JcIjpcIlxcXFxucGFyYWxsZWxcIixcIuKrsVwiOlwiXCIsXCLiq7BcIjpcIlwiLFwi4quvXCI6XCJcIixcIuKrrlwiOlwiXFxcXGJjYW5jZWx7XFxcXG1pZH1cIixcIuKrrVwiOlwiXCIsXCLiq6xcIjpcIlwiLFwi4qurXCI6XCJcIixcIuKrqlwiOlwiXCIsXCLiq6lcIjpcIlwiLFwi4quoXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxwZXJwfVwiLFwi4qunXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHRvcH1cIixcIuKrplwiOlwiXCIsXCLiq6VcIjpcIlwiLFwi4qukXCI6XCJcIixcIuKro1wiOlwiXCIsXCLiq6JcIjpcIlwiLFwi4quhXCI6XCJcIixcIuKroFwiOlwiXFxcXHBlcnBcIixcIuKrn1wiOlwiXFxcXHRvcFwiLFwi4queXCI6XCJcXFxcZGFzaHZcIixcIuKrncy4XCI6XCJcIixcIuKrnVwiOlwiXCIsXCLiq5tcIjpcIlxcXFxwaXRjaGZvcmtcIixcIuKrmlwiOlwiXCIsXCLiq5lcIjpcIlwiLFwi4quYXCI6XCJcIixcIuKrl1wiOlwiXCIsXCLiq5ZcIjpcIlwiLFwi4quVXCI6XCJcIixcIuKrlFwiOlwiXCIsXCLiq5NcIjpcIlwiLFwi4quSXCI6XCJcIixcIuKrkVwiOlwiXCIsXCLiq5BcIjpcIlwiLFwi4quPXCI6XCJcIixcIuKrjlwiOlwiXCIsXCLiq41cIjpcIlwiLFwi4quMXCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5lcX17XFxcXHN1cHNldH1cIixcIuKri1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdWJzZXR9XCIsXCLiq4pcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxcc3Vwc2V0fVwiLFwi4quJXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1YnNldH1cIixcIuKriFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdXBzZXR9XCIsXCLiq4dcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3Vic2V0fVwiLFwi4quGXCI6XCJcXFxcc3Vwc2V0ZXFxXCIsXCLiq4VcIjpcIlxcXFxzdWJzZXRlcXFcIixcIuKrhFwiOlwiXFxcXGRvdHtcXFxcc3Vwc2V0ZXF9XCIsXCLiq4NcIjpcIlxcXFxkb3R7XFxcXHN1YnNldGVxfVwiLFwi4quCXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHRpbWVzfXtcXFxcc3Vwc2V0fVwiLFwi4quBXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHRpbWVzfXtcXFxcc3Vic2V0fVwiLFwi4quAXCI6XCJcXFxcdW5kZXJzZXR7K317XFxcXHN1cHNldH1cIixcIuKqv1wiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdWJzZXR9XCIsXCLiqr5cIjpcIlwiLFwi4qq9XCI6XCJcIixcIuKqvFwiOlwiXFxcXGdnIFwiLFwi4qq7XCI6XCJcXFxcbGxcIixcIuKqulwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19e1xcXFxzdWNjfVwiLFwi4qq5XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17XFxcXHByZWN9XCIsXCLiqrhcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxcc3VjY31cIixcIuKqt1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxwcmVjfVwiLFwi4qq2XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHN1Y2N9XCIsXCLiqrVcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vsez19fXtcXFxccHJlY31cIixcIuKqtFwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxzdWNjfVwiLFwi4qqzXCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHByZWN9XCIsXCLiqrJcIjpcIlwiLFwi4qqxXCI6XCJcIixcIuKqrlwiOlwiXCIsXCLiqq1cIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGhjYW5jZWx7Pn19XCIsXCLiqqxcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGhjYW5jZWx7Pn19XCIsXCLiqqtcIjpcIlxcXFxoY2FuY2Vsez59XCIsXCLiqqpcIjpcIlxcXFxoY2FuY2Vsezx9XCIsXCLiqqlcIjpcIlwiLFwi4qqoXCI6XCJcIixcIuKqp1wiOlwiXFxcXHZhcnRyaWFuZ2xlcmlnaHRcIixcIuKqplwiOlwiXFxcXHZhcnRyaWFuZ2xlbGVmdFwiLFwi4qqlXCI6XCI+PFwiLFwi4qqkXCI6XCI+PFwiLFwi4qqjXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsbH1cIixcIuKqosy4XCI6XCJcXFxcY2FuY2Vse1xcXFxnZ31cIixcIuKqolwiOlwiXFxcXGdnXCIsXCLiqqHMuFwiOlwiXFxcXGNhbmNlbHtcXFxcbGx9XCIsXCLiqqFcIjpcIlxcXFxsbFwiLFwi4qqgXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxcZ2VxcX1cIixcIuKqn1wiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17XFxcXGxlcXF9XCIsXCLiqp5cIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ez59XCIsXCLiqp1cIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ezx9XCIsXCLiqpxcIjpcIlwiLFwi4qqbXCI6XCJcIixcIuKqmlwiOlwiXFxcXG92ZXJzZXR7PX17Pn1cIixcIuKqmVwiOlwiXFxcXG92ZXJzZXR7PX17PH1cIixcIuKqmFwiOlwiXCIsXCLiqpdcIjpcIlwiLFwi4qqWXCI6XCJcIixcIuKqlVwiOlwiXCIsXCLiqpRcIjpcIlwiLFwi4qqTXCI6XCJcIixcIuKqklwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxndHJsZXNzfVwiLFwi4qqRXCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXGxlc3NndHJ9XCIsXCLiqpBcIjpcIlxcXFx1bmRlcnNldHs8fXtcXFxcZ3Ryc2ltfVwiLFwi4qqPXCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlc3NzaW19XCIsXCLiqo5cIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltZXF9ez59XCIsXCLiqo1cIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltZXF9ezx9XCIsXCLiqoxcIjpcIlxcXFxndHJlcXFsZXNzXCIsXCLiqotcIjpcIlxcXFxsZXNzZXFxZ3RyXCIsXCLiqopcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXs+fVwiLFwi4qqJXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIuKqhlwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ez59XCIsXCLiqoVcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXs8fVwiLFwi4qqEXCI6XCJcIixcIuKqg1wiOlwiXCIsXCLiqoJcIjpcIlwiLFwi4qqBXCI6XCJcIixcIuKqgFwiOlwiXCIsXCLiqb9cIjpcIlwiLFwi4qm+zLhcIjpcIlxcXFxiY2FuY2Vse1xcXFxnZXF9XCIsXCLiqb5cIjpcIlxcXFxnZXFcIixcIuKpvcy4XCI6XCJcXFxcYmNhbmNlbHtcXFxcbGVxfVwiLFwi4qm9XCI6XCJcXFxcbGVxXCIsXCLiqbxcIjpcIlwiLFwi4qm7XCI6XCJcIixcIuKpulwiOlwiXCIsXCLiqblcIjpcIlwiLFwi4qm4XCI6XCJcXFxcb3ZlcnNldHtcXFxcZG90c317XFxcXGVxdWl2fVwiLFwi4qm3XCI6XCJcIixcIuKptlwiOlwiPT09XCIsXCLiqbVcIjpcIj09XCIsXCLiqbRcIjpcIjo6PVwiLFwi4qmzXCI6XCJcIixcIuKpslwiOlwiXFxcXHVuZGVyc2V0ez19eyt9XCIsXCLiqbFcIjpcIlxcXFxvdmVyc2V0ez19eyt9XCIsXCLiqbBcIjpcIlxcXFxvdmVyc2V0e1xcXFxhcHByb3h9ez19XCIsXCLiqa9cIjpcIlxcXFxvdmVyc2V0e1xcXFx3ZWRnZX17PX1cIixcIuKprlwiOlwiXFxcXG92ZXJzZXR7Kn17PX1cIixcIuKprVwiOlwiXFxcXGRvdHtcXFxcYXBwcm94fVwiLFwi4qmsXCI6XCJcIixcIuKpq1wiOlwiXCIsXCLiqapcIjpcIlxcXFxkb3R7XFxcXHNpbX1cIixcIuKpqVwiOlwiXCIsXCLiqahcIjpcIlwiLFwi4qmnXCI6XCJcXFxcZG90e1xcXFxlcXVpdn1cIixcIuKpplwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjZG90fXs9fVwiLFwi4qmlXCI6XCJcIixcIuKppFwiOlwiXCIsXCLiqaNcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcdmVlfVwiLFwi4qmiXCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxcdmVlfVwiLFwi4qmhXCI6XCJ1bCh2dilcIixcIuKpoFwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIuKpn1wiOlwiXFxcXHVuZGVybGluZXtcXFxcd2VkZ2V9XCIsXCLiqZ5cIjpcIlxcXFxvdmVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIuKpnVwiOlwiXFxcXGhjYW5jZWx7XFxcXHZlZX1cIixcIuKpnFwiOlwiXFxcXGhjYW5jZWx7XFxcXHdlZGdlfVwiLFwi4qmbXCI6XCJcIixcIuKpmlwiOlwiXCIsXCLiqZlcIjpcIlwiLFwi4qmYXCI6XCJcXFxcdmVlXCIsXCLiqZdcIjpcIlxcXFx3ZWRnZVwiLFwi4qmWXCI6XCJcIixcIuKplVwiOlwiXCIsXCLiqZRcIjpcIlwiLFwi4qmTXCI6XCJcIixcIuKpklwiOlwiXFxcXGRvdHtcXFxcdmVlfVwiLFwi4qmRXCI6XCJcXFxcZG90e1xcXFx3ZWRnZX1cIixcIuKpkFwiOlwiXCIsXCLiqY9cIjpcIlwiLFwi4qmOXCI6XCJcIixcIuKpjVwiOlwiXFxcXG92ZXJsaW5le1xcXFxjYXB9XCIsXCLiqYxcIjpcIlxcXFxvdmVybGluZXtcXFxcY3VwfVwiLFwi4qmLXCI6XCJcIixcIuKpilwiOlwiXCIsXCLiqYlcIjpcIlwiLFwi4qmIXCI6XCJcIixcIuKph1wiOlwiXCIsXCLiqYZcIjpcIlwiLFwi4qmFXCI6XCJcIixcIuKphFwiOlwiXCIsXCLiqYNcIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwi4qmCXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIuKpgVwiOlwiXCIsXCLiqYBcIjpcIlwiLFwi4qi+XCI6XCJcIixcIuKovVwiOlwiXFxcXGxsY29ybmVyXCIsXCLiqLxcIjpcIlxcXFxscmNvcm5lclwiLFwi4qi7XCI6XCJcIixcIuKoulwiOlwiXCIsXCLiqLlcIjpcIlwiLFwi4qi4XCI6XCJcIixcIuKot1wiOlwiXCIsXCLiqLZcIjpcIlxcXFxoYXR7XFxcXG90aW1lc31cIixcIuKotVwiOlwiXCIsXCLiqLRcIjpcIlwiLFwi4qizXCI6XCJcIixcIuKoslwiOlwiXFxcXHVuZGVybGluZXtcXFxcdGltZXN9XCIsXCLiqLFcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHRpbWVzfVwiLFwi4qiwXCI6XCJcXFxcZG90e1xcXFx0aW1lc31cIixcIuKorlwiOlwiXFxcXGJpZ29kb3RcIixcIuKorVwiOlwiXFxcXGJpZ29kb3RcIixcIuKorFwiOlwiXCIsXCLiqKtcIjpcIlwiLFwi4qiqXCI6XCJcIixcIuKoqVwiOlwiXCIsXCLiqKhcIjpcIlwiLFwi4qinXCI6XCJcIixcIuKXu1wiOlwiXFxcXEJveFwiLFwi4qimXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17K31cIixcIuKopVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjaXJjfXsrfVwiLFwi4qikXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXsrfVwiLFwi4qijXCI6XCJcXFxcaGF0eyt9XCIsXCLiqKJcIjpcIlxcXFxkb3R7K31cIixcIuKooVwiOlwiXFxcXHVwaGFycG9vbnJpZ2h0XCIsXCLiqKBcIjpcIj4+XCIsXCLiqJ9cIjpcIlwiLFwi4qieXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLiqJ1cIjpcIlxcXFxib3d0aWVcIixcIuKnv1wiOlwiXCIsXCLip75cIjpcIitcIixcIuKnu1wiOlwiXFxcXGhjYW5jZWx7fHx8fVwiLFwi4qe6XCI6XCJcXFxcaGNhbmNlbHt8fH1cIixcIuKnuVwiOlwiXFxcXGJhY2tzbGFzaFwiLFwi4qe4XCI6XCIvXCIsXCLip7dcIjpcImhjYW5jZWx7XFxiYWNrc2xhc2h9XCIsXCLip7ZcIjpcIlwiLFwi4qe1XCI6XCJcXFxcYmFja3NsYXNoXCIsXCLip7JcIjpcIlxcXFxQaGlcIixcIuKnsVwiOlwiXCIsXCLip7BcIjpcIlwiLFwi4qeuXCI6XCJcIixcIuKnrVwiOlwiXCIsXCLip6xcIjpcIlwiLFwi4qerXCI6XCJcXFxcbG96ZW5nZVwiLFwi4qeqXCI6XCJcIixcIuKnqVwiOlwiXCIsXCLip6hcIjpcIlwiLFwi4qenXCI6XCJcXFxcZGRhZ2dlclwiLFwi4qeiXCI6XCJcXFxcc3FjdXBcXFxcc3FjdXBcIixcIuKnoVwiOlwiXCIsXCLip6BcIjpcIlxcXFxzcXVhcmVcIixcIuKnnlwiOlwiXCIsXCLip51cIjpcIlwiLFwi4qecXCI6XCJcIixcIuKnm1wiOlwiXFxcXHtcXFxce1wiLFwi4qeZXCI6XCJcXFxce1wiLFwi4qeYXCI6XCJcXFxcfVwiLFwi4qeXXCI6XCJcIixcIuKnllwiOlwiXCIsXCLip5VcIjpcIlxcXFxib3d0aWVcIixcIuKnlFwiOlwiXFxcXGJvd3RpZVwiLFwi4qeTXCI6XCJcXFxcYm93dGllXCIsXCLip5JcIjpcIlxcXFxib3d0aWVcIixcIuKnkVwiOlwiXFxcXGJvd3RpZVwiLFwi4qeQzLhcIjpcInwgXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLip5BcIjpcInwgXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKnj8y4XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdCB8XCIsXCLip49cIjpcIlxcXFx0cmlhbmdsZWxlZnQgfFwiLFwi4qeOXCI6XCJcIixcIuKnjVwiOlwiXFxcXHRyaWFuZ2xlXCIsXCLip4xcIjpcIlwiLFwi4qeLXCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0cmlhbmdsZX1cIixcIuKnilwiOlwiXFxcXGRvdHtcXFxcdHJpYW5nbGV9XCIsXCLip4lcIjpcIlwiLFwi4qeIXCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCLip4dcIjpcIlxcXFxib3hlZHtcXFxcY2lyY31cIixcIuKnhlwiOlwiXFxcXGJveGVke1xcXFxyaWdodGFycm93fVwiLFwi4qeFXCI6XCJcXFxcYmNhbmNlbHtcXFxcc3F1YXJlfVwiLFwi4qeEXCI6XCJcXFxcY2FuY2Vse1xcXFxzcXVhcmV9XCIsXCLip4NcIjpcIlxcXFxvZG90XCIsXCLip4JcIjpcIlxcXFxvZG90XCIsXCLipr9cIjpcIlxcXFxvZG90XCIsXCLipr5cIjpcIlxcXFxvZG90XCIsXCLipr1cIjpcIlxcXFx2YXJub3RoaW5nXCIsXCLiprxcIjpcIlxcXFxvcGx1c1wiLFwi4qa7XCI6XCJcXFxcb3RpbWVzXCIsXCLiprpcIjpcIlwiLFwi4qa5XCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qa4XCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qa3XCI6XCJcXFxcb21pbnVzXCIsXCLiprZcIjpcIlxcXFxvbWludXNcIixcIuKmtVwiOlwiXFxcXG9taW51c1wiLFwi4qa0XCI6XCJcXFxcdmVje1xcXFx2YXJub3RoaW5nfVwiLFwi4qazXCI6XCJcXFxcdmVje1xcXFx2YXJub3RoaW5nfVwiLFwi4qayXCI6XCJcXFxcZG90e1xcXFx2YXJub3RoaW5nfVwiLFwi4qaxXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHZhcm5vdGhpbmd9XCIsXCLiprBcIjpcIlxcXFx2YXJub3RoaW5nXCIsXCLipq9cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq5cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq1cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqxcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqpcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqlcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqhcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqdcIjpcIlwiLFwi4qamXCI6XCJcIixcIuKmpVwiOlwiXCIsXCLipqRcIjpcIlwiLFwi4qajXCI6XCJcXFxcdWxjb3JuZXJcIixcIuKmolwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmoVwiOlwiXFxcXG5vdFxcXFxsb3JcIixcIuKmoFwiOlwiXFxcXGJjYW5jZWx7Pn1cIixcIuKmglwiOlwiOlwiLFwi4qaBXCI6XCJcXFxcY2RvdFwiLFwi4p2YXCI6XCJcXFxcbWlkXCIsXCLilrJcIjpcIlxcXFxiaWd0cmlhbmdsZXVwXCIsXCLii79cIjpcIlxcXFxFcHNpbG9uXCIsXCLii75cIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCLii71cIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCLii7xcIjpcIlxcXFxpblwiLFwi4ou7XCI6XCJcXFxcaW5cIixcIuKLulwiOlwiXFxcXGluXCIsXCLii7lcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGlufVwiLFwi4ou4XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIuKLt1wiOlwiXFxcXG92ZXJsaW5le1xcXFxpbn1cIixcIuKLtlwiOlwiXFxcXG92ZXJsaW5le1xcXFxpbn1cIixcIuKLtVwiOlwiXFxcXGRvdHtcXFxcaW59XCIsXCLii7RcIjpcIlxcXFxpblwiLFwi4ouzXCI6XCJcXFxcaW5cIixcIuKLslwiOlwiXFxcXGluXCIsXCLii7BcIjpcIlxcXFxkZG90c1wiLFwi1olcIjpcIjpcIixcIuKLqVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdWNjfVwiLFwi4ouoXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHByZWN9XCIsXCLii6dcIjpcIlxcXFx1bmRlcnNldHtcXFxcbm90XFxcXHNpbX17Pn1cIixcIuKLplwiOlwiXFxcXHVuZGVyc2V0e1xcXFxub3RcXFxcc2ltfXs8fVwiLFwi4oulXCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIuKLpFwiOlwiXFxcXG5vdFxcXFxzcXN1YnNldGVxXCIsXCLii6NcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRlcVwiLFwi4ouiXCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0ZXFcIixcIuKLoVwiOlwiXFxcXG5zdWNjXCIsXCLii6BcIjpcIlxcXFxucHJlY1wiLFwi4oufXCI6XCJcXFxcc3VjY1wiLFwi4oueXCI6XCJcXFxccHJlY1wiLFwi4oudXCI6XCJcXFxcb3ZlcmxpbmV7Pn1cIixcIuKLnFwiOlwiXFxcXG92ZXJsaW5lezx9XCIsXCLii5tcIjpcIlxcXFx1bmRlcnNldHs+fXtcXFxcbGVxfVwiLFwi4ouaXCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGdlcX1cIixcIuKLlVwiOlwiXFxcXCNcIixcIuKLk1wiOlwiXFxcXGN1cFwiLFwi4ouSXCI6XCJcXFxcY2FwXCIsXCLii5FcIjpcIlxcXFxzdXBzZXRcIixcIuKLkFwiOlwiXFxcXHN1YnNldFwiLFwi4ouPXCI6XCJcXFxcd2VkZ2VcIixcIuKLjlwiOlwiXFxcXHZlZVwiLFwi4ouNXCI6XCJcXFxcc2ltZXFcIixcIuKLiFwiOlwiXFxcXEpvaW5cIixcIuKLh1wiOlwiXFxcXGFzdFwiLFwi4ouGXCI6XCJcXFxcc3RhclwiLFwi4ouEXCI6XCJcXFxcZGlhbW9uZFwiLFwi4oq/XCI6XCJcXFxcdHJpYW5nbGVcIixcIuKKvlwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKKvVwiOlwiXFxcXG92ZXJsaW5le1xcXFxsb3J9XCIsXCLiirxcIjpcIlxcXFxvdmVybGluZXtcXFxcbGFuZH1cIixcIuKKu1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbG9yfVwiLFwi4oq6XCI6XCJcXFxcdG9wXCIs5ZyfOlwiXFxcXHBtXCIs5Y2BOlwiK1wiLFwi4oq5XCI6XCJcIixcIuKKt1wiOlwiXFxcXGNpcmNcXFxcbXVsdGltYXBcIixcIuKKtlwiOlwiXFxcXGNpcmNcXFxcbXVsdGltYXBcIixcIuKKs1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKKslwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4oqxXCI6XCJcXFxcc3VjY1wiLFwi4oqwXCI6XCJcXFxccHJlY1wiLFwi4oqrXCI6XCJ8XFxcXG1vZGVsc1wiLFwi4oqqXCI6XCJ8XFxcXG1vZGVsc1wiLFwi4oqnXCI6XCJcXFxcbW9kZWxzXCIsXCLiiqZcIjpcIlxcXFx2ZGFzaFwiLFwi4oqdXCI6XCJcXFxcb21pbnVzXCIsXCLiipxcIjpcIlxcXFxvbWludXNcIixcIuKKm1wiOlwiXFxcXG9kb3RcIixcIuKKmlwiOlwiXFxcXG9kb3RcIixcIuKKlFwiOlwiXFxcXHNxY3VwXCIsXCLiipNcIjpcIlxcXFxzcWNhcFwiLFwi4oqSXCI6XCJcXFxcc3FzdXBzZXRlcVwiLFwi4oqRXCI6XCJcXFxcc3FzdWJzZXRlcVwiLFwi4oqQzLhcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRcIixcIuKKkFwiOlwiXFxcXHNxc3Vwc2V0XCIsXCLiio/MuFwiOlwiXFxcXG5vdFxcXFxzcXN1YnNldFwiLFwi4oqPXCI6XCJcXFxcc3FzdWJzZXRcIixcIuKKjlwiOlwiXFxcXGN1cFwiLFwi4oqNXCI6XCJcXFxcY3VwXCIsXCLiioxcIjpcIlxcXFxjdXBcIixcIuKJv8y4XCI6XCJcXFxcbm90XFxcXHN1Y2NzaW1cIixcIuKJv1wiOlwiXFxcXHN1Y2NzaW1cIixcIuKJvlwiOlwiXFxcXHByZWNzaW1cIixcIuKJuVwiOlwiXFxcXG5vdFxcXFxvdmVyc2V0ez59ezx9XCIsXCLiibhcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwi4om3XCI6XCJcXFxcb3ZlcnNldHs+fXs8fVwiLFwi4om2XCI6XCJcXFxcb3ZlcnNldHs8fXs+fVwiLFwi4om1XCI6XCJcXFxcbm90XFxcXGdlZ1wiLFwi4om0XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwi4omzXCI6XCJcXFxcZ2VnXCIsXCLiibJcIjpcIlxcXFxsZXFcIixcIuKJrFwiOlwiXCIsXCLiiadcIjpcIlxcXFxnZWdcIixcIuKJpsy4XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwi4ommXCI6XCJcXFxcbGVxXCIsXCLiiaNcIjpcIlxcXFxvdmVyc2V0ez19ez19IFwiLFwi4omeXCI6XCJcXFxcb3ZlcnNldHttfXs9fSBcIixcIuKJnVwiOlwiXFxcXG92ZXJzZXR7ZGVmfXs9fVwiLFwi4omYXCI6XCI9XCIsXCLiiZZcIjpcIj1cIixcIuKJlVwiOlwiPTpcIixcIuKJk1wiOlwiXFxcXGRvdGVxXCIsXCLiiZJcIjpcIlxcXFxkb3RlcVwiLFwi4omRXCI6XCJcXFxcZG90ZXFcIixcIuKJkFwiOlwiXFxcXGRvdGVxXCIsXCLiiY/MuFwiOlwiXCIsXCLiiY9cIjpcIlwiLFwi4omOzLhcIjpcIlwiLFwi4omOXCI6XCJcIixcIuKJjFwiOlwiXFxcXGFwcHJveFwiLFwi4omLXCI6XCJcXFxcYXBwcm94XCIsXCLiiYpcIjpcIlxcXFxhcHByb3hcIixcIuKJgsy4XCI6XCJcXFxcbmVxXCIsXCLiiYJcIjpcIj1cIixcIuKIv1wiOlwiXFxcXHNpbVwiLFwi4oi+XCI6XCJcXFxcaW5mdHlcIixcIuKIvcyxXCI6XCJcXFxcc2ltXCIsXCLiiL1cIjpcIlxcXFxzaW1cIixcIuKIu1wiOlwiXFxcXHNpbVwiLFwi4oi6XCI6XCI6LTpcIixcIuKIuVwiOlwiLTpcIixcIuKIuFwiOlwiXFxcXGJvdFwiLFwi4oi3XCI6XCI6OlwiLFwi4oi2XCI6XCI6XCIsXCLiiKNcIjpcIlxcXFxtaWRcIixcIuKIn1wiOlwiXFxcXGxsY29ybmVyXCIsXCLiiJhcIjpcIlxcXFxjaXJjXCIsXCLiiJdcIjpcIipcIixcIuKIlVwiOlwiL1wiLFwi4oiOXCI6XCJcXFxcc3F1YXJlXCIsXCLiiI1cIjpcIlxcXFxuaVwiLFwi4oiKXCI6XCJcXFxcaW5cIixcIuKIhlwiOlwiXFxcXERlbHRhXCIsXCLigYRcIjpcIi9cIixcIuKqsMy4XCI6XCJcXFxcbnN1Y2NlcVwiLFwi4qqwXCI6XCJcXFxcc3VjY2VxXCIsXCLiqq/MuFwiOlwiXFxcXG5wcmVjZXFcIixcIuKqr1wiOlwiXFxcXHByZWNlcVwiLFwi4qqIXCI6XCJcXFxcbmdlcXNsYW50XCIsXCLiqodcIjpcIlxcXFxubGVxc2xhbnRcIixcIuKns1wiOlwiXFxcXFBoaVwiLFwi4qemXCI6XCJcXFxcbW9kZWxzXCIsXCLip6VcIjpcIlxcXFxub3RcXFxcZXF1aXZcIixcIuKnpFwiOlwiXFxcXGFwcHJveFxcXFxuZXFcIixcIuKno1wiOlwiXFxcXG5lcVwiLFwi4qeBXCI6XCJcXFxcY2lyY2xlXCIsXCLip4BcIjpcIlxcXFxjaXJjbGVcIixcIuKXplwiOlwiXFxcXGNpcmNsZVwiLFwi4peXXCI6XCJcXFxcY2lyY2xlXCIsXCLil5ZcIjpcIlxcXFxjaXJjbGVcIixcIuKXj1wiOlwiXFxcXGNpcmNsZVwiLFwi4peOXCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIuKXjVwiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCLil4xcIjpcIlxcXFxjaXJjbGVkY2lyY1wiLFwi4peJXCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIuKXiFwiOlwiXFxcXGRpYW1vbmRcIixcIuKXh1wiOlwiXFxcXGRpYW1vbmRcIixcIuKXhlwiOlwiXFxcXGRpYW1vbmRcIixcIuKXhVwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peEXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLil4NcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKXglwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peBXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLil4BcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKWv1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwi4pa+XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCLilr1cIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIuKWvFwiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwi4pa5XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa4XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa3XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa2XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa1XCI6XCJcXFxcdHJpYW5nbGVcIixcIuKWtFwiOlwiXFxcXHRyaWFuZ2xlXCIsXCLilrNcIjpcIlxcXFx0cmlhbmdsZVwiLFwi4paxXCI6XCJcXFxcc3F1YXJlXCIsXCLilrBcIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4pavXCI6XCJcXFxcc3F1YXJlXCIsXCLilq5cIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4patXCI6XCJcXFxcc3F1YXJlXCIsXCLilqtcIjpcIlxcXFxzcXVhcmVcIixcIuKWqlwiOlwiXFxcXHNxdWFyZVwiLFwi4pahXCI6XCJcXFxcc3F1YXJlXCIsXCLilqBcIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4outXCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKLrFwiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnRcIixcIuKLq1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLii6pcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0XCIsXCLii5lcIjpcIlxcXFxnZ2dcIixcIuKLmFwiOlwiXFxcXGxsbFwiLFwi4ouXXCI6XCIqPlwiLFwi4ouWXCI6XCI8KlwiLFwi4ouUXCI6XCJcXFxccGl0Y2hmb3JrXCIsXCLii4xcIjpcIlwiLFwi4ouLXCI6XCJcXFxcYm93dGllXCIsXCLii4pcIjpcIlxcXFxsdGltZXNcIixcIuKLiVwiOlwiXFxcXHJ0aW1lc1wiLFwi4oq1XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiXFxcXHRyaWFuZ2xlbGVmdFwiOlwiXCIsXCLiiqVcIjpcIlxcXFxib3RcIixcIuKKgVwiOlwiXFxcXG5zdWNjXCIsXCLiioBcIjpcIlxcXFxwcmVjZXFcIixcIuKJvVwiOlwiXFxcXHN1Y2NlcVwiLFwi4om8XCI6XCJcXFxccHJlY2VxXCIsXCLiibtcIjpcIlxcXFxzdWNjXCIsXCLiibpcIjpcIlxcXFxwcmVjXCIsXCLiibFcIjpcIlxcXFxnZXEvXCIsXCLiibBcIjpcIlxcXFxsZXEvXCIsXCLiia1cIjpcIlxcXFxuZXFcIixcIuKJq8y4XCI6XCJcXFxcbm90XFxcXGdnXCIsXCLiiatcIjpcIlxcXFxnZ1wiLFwi4omqzLhcIjpcIlxcXFxub3RcXFxcbGxcIixcIuKJqlwiOlwiXFxcXGxsXCIsXCLiialcIjpcIlxcXFxuZ2Vxc2xhbnRcIixcIuKJqFwiOlwiXFxcXG5sZXFzbGFudFwiLFwi4omhXCI6XCJcXFxcZXF1aXZcIixcIuKJn1wiOlwiXFxcXGRvdGVxXCIsXCLiiZxcIjpcIlxcXFx0cmlhbmdsZXFcIixcIuKJm1wiOlwiXFxcXGRvdGVxXCIsXCLiiZpcIjpcIlxcXFx0cmlhbmdsZXFcIixcIuKJmVwiOlwiXFxcXHRyaWFuZ2xlcVwiLFwi4omXXCI6XCJcXFxcZG90ZXFcIixcIuKJlFwiOlwiOj1cIixcIuKJjVwiOlwiXFxcXGFzeW1wXCIsXCLiiYdcIjpcIlxcXFxuY29uZ1wiLFwi4omGXCI6XCJcXFxcbmNvbmdcIixcIuKJhVwiOlwiXFxcXGNvbmdcIixcIuKJhFwiOlwiXFxcXG5vdFxcXFxzaW1lcVwiLFwi4omDXCI6XCJcXFxcc2ltZXFcIixcIuKJgVwiOlwiXFxcXG5vdFxcXFxzaW1cIixcIuKIplwiOlwiXFxcXG5vdFxcXFxwYXJhbGxlbFwiLFwi4oilXCI6XCJcXFxccGFyYWxsZWxcIixcIuKIpFwiOlwiXFxcXG5vdHxcIixcIuKInVwiOlwiXFxcXHByb3B0b1wiLFwiPT1cIjpcIj09XCIsXCI9XCI6XCI9XCIsXCI6PVwiOlwiOj1cIixcIi89XCI6XCI9XCIsXCItPVwiOlwiLT1cIixcIis9XCI6XCIrPVwiLFwiKj1cIjpcIio9XCIsXCIhPVwiOlwiIT1cIixcIuKJoFwiOlwiXFxcXG5lcVwiLFwi4omiXCI6XCJcXFxcZXF1aXYgL1wiLFwi4omJXCI6XCJcXFxcYXBwcm94IC9cIixcIuKIvFwiOlwic2ltXCIsXCLiiYhcIjpcIlxcXFxhcHByb3hcIixcIuKJrlwiOlwiPC9cIixcIjxcIjpcIjxcIixcIuKJr1wiOlwiPi9cIixcIj49XCI6XCI+PVwiLFwiPlwiOlwiPlwiLFwi4omlXCI6XCJcXFxcZ2VxXCIsXCLiiaRcIjpcIlxcXFxsZXFcIixcIjw9XCI6XCI8PVwiLFwi4oqLXCI6XCJcXFxcc3Vwc2V0bmVxXCIsXCLiiopcIjpcIlxcXFxzdWJzZXRuZXFcIixcIuKKiVwiOlwiXFxcXG5zdXBzZXRlcVwiLFwi4oqIXCI6XCJcXFxcbnN1YnNldGVxXCIsXCLiiodcIjpcIlxcXFxzdXBzZXRlcVwiLFwi4oqGXCI6XCJcXFxcc3Vic2V0ZXFcIixcIuKKhVwiOlwiXFxcXG5vdFxcXFxzdXBzZXRcIixcIuKKhFwiOlwiXFxcXG5vdFxcXFxzdWJzZXRcIixcIuKKg+KDklwiOlwiXFxcXHN1cHNldCB8XCIsXCLiioNcIjpcIlxcXFxzdXBzZXRcIixcIuKKguKDklwiOlwiXFxcXHN1YnNldCB8XCIsXCLiioJcIjpcIlxcXFxzdWJzZXRcIixcIuKIjFwiOlwiXFxcXG5vdFxcXFxpblwiLFwi4oiJXCI6XCJcXFxcbm90aW5cIixcIuKIiFwiOlwiXFxcXGluXCIsXCLiiIFcIjpcIkNcIixcIuKIhFwiOlwiXFxcXG5leGlzdHNcIixcIuKIg1wiOlwiXFxcXGV4aXN0c1wiLFwi4oiAXCI6XCJcXFxcZm9yYWxsXCIsXCLiiKdcIjpcIlxcXFxsYW5kXCIsXCImJlwiOlwiXFxcXCZcXFxcJlwiLFwi4oioXCI6XCJcXFxcbG9yXCIsXCLiiq9cIjpcIlxcXFxjYW5jZWx7XFxcXHZEYXNofVwiLFwi4oquXCI6XCJcXFxcY2FuY2Vse1xcXFxWZGFzaH1cIixcIuKKrVwiOlwiXFxcXG52RGFzaFwiLFwi4oqsXCI6XCJcXFxcbnZEYXNoXCIsXCLiiqlcIjpcIlxcXFxWZGFzaFwiLFwi4oqoXCI6XCJcXFxcdkRhc2hcIixcIuKKpFwiOlwiXFxcXHRvcFwiLFwi4oqjXCI6XCJcXFxcZGFzaHZcIixcIuKKolwiOlwiXFxcXHZkYXNoXCIsXCLiiItcIjpcIlxcXFxuaVwiLFwi4ouxXCI6XCJcXFxcZGRvdHNcIixcIuKLr1wiOlwiXFxcXGhkb3RzXCIsXCLii65cIjpcIlxcXFx2ZG90c1wiLFwiz7ZcIjpcIlxcXFxuaVwiLFwiOlwiOlwiOlwiLFwiLi4uXCI6XCJcXFxcY2RvdHNcIixcIi4uXCI6XCIuLlwiLFwiLT5cIjpcIi0+XCIsXCLiiLVcIjpcIlxcXFxiZWNhdXNlXCIsXCLiiLRcIjpcIlxcXFx0aGVyZWZvcmUgXCIsXCLigaNcIjpcIlxcXFxsbGJyYWNrZXRcIixcIixcIjpcIixcIixcIjtcIjpcIjtcIixcIuKnvVwiOlwiXFxcXH1cIixcIuKnvFwiOlwiXFxcXHtcIixcIuKmmFwiOlwiXFxcXF1cIixcIuKml1wiOlwiXFxcXFtcIixcIuKmllwiOlwiXFxcXGxsXCIsXCLippVcIjpcIlxcXFxnZ1wiLFwi4qaUXCI6XCJcXFxcZ2dcIixcIuKmk1wiOlwiXFxcXGxsXCIsXCLippJcIjpcIlxcXFxnZ1wiLFwi4qaRXCI6XCJcXFxcbGxcIixcIuKmkFwiOlwiXFxcXF1cIixcIuKmj1wiOlwiXFxcXF1cIixcIuKmjlwiOlwiXFxcXF1cIixcIuKmjVwiOlwiXFxcXFtcIixcIuKmjFwiOlwiXFxcXFtcIixcIuKmi1wiOlwiXFxcXF1cIixcIuKmilwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKmiVwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4qaIXCI6XCJ8XFxcXClcIixcIuKmh1wiOlwiXFxcXCh8XCIsXCLipoZcIjpcInxcXFxcKVwiLFwi4qaFXCI6XCJcXFxcKFxcXFwoXCIsXCLipoRcIjpcInxcXFxcfVwiLFwi4qaDXCI6XCJcXFxce3xcIixcIuKmgFwiOlwiXFxcXHx8XCIsXCLin69cIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXCIsXCLin65cIjpcIlxcXFxsZWZ0WyBcXFxccmlnaHQuXCIsXCLin61cIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXVwiLFwi4p+sXCI6XCJcXFxcbGVmdFtbIFxcXFxyaWdodC5cIixcIuKfq1wiOlwiXFxcXGdnXCIsXCLin6pcIjpcIlxcXFxsbFwiLFwi4p+nXCI6XCJcXFxcKXxcIixcIuKfplwiOlwiXFxcXCh8XCIsXCLinbNcIjpcIlxcXFxsZWZ0LlxcXFxyaWdodClcIixcIuKdslwiOlwiXFxcXGxlZnQoXFxcXHJpZ2h0LlwiLFwi4oyqXCI6XCJcXFxccmFuZ2xlXCIsXCLijKlcIjpcIlxcXFxsYW5nbGVcIixcIuKMi1wiOlwiXFxcXHJmbG9vclwiLFwi4oyKXCI6XCJcXFxcbGZsb29yXCIsXCLijIlcIjpcIlxcXFxyY2VpbFwiLFwi4oyIXCI6XCJcXFxcbGNlaWxcIixcIuKAllwiOlwiXFxcXHBhcmFsbGVsXCIsXCJ9XCI6XCJcXFxcbGVmdC5cXFxccmlnaHR9XCIsXCJ7XCI6XCJcXFxcbGVmdHtcXFxccmlnaHQuXCIsXCJdXCI6XCJcXFxcbGVmdF1cXFxccmlnaHQuXCIsXCJbXCI6XCJcXFxcbGVmdFtcXFxccmlnaHQuXCIsXCIpXCI6XCJcXFxcbGVmdC5cXFxccmlnaHQpXCIsXCIoXCI6XCJcXFxcbGVmdChcXFxccmlnaHQuXCIsXCLigJ1cIjonXFxcXFwiJyxcIuKAnFwiOlwiXFxcXHRleHR7YGB9XCIsXCLigJlcIjpcIidcIixcIuKAmFwiOlwiYFwiLM6xOlwiXFxcXGFscGhhXCIszrI6XCJcXFxcYmV0YVwiLM6zOlwiXFxcXGdhbW1hXCIszpM6XCJcXFxcR2FtbWFcIizOtDpcIlxcXFxkZWx0YVwiLM6UOlwiXFxcXERlbHRhXCIsz7U6XCJcXFxcZXBzaWxvblwiLM62OlwiXFxcXHpldGFcIizOtzpcIlxcXFxldGFcIizOuDpcIlxcXFx0aGV0YVwiLM6YOlwiXFxcXFRoZXRhXCIszrk6XCJcXFxcaW90YVwiLM66OlwiXFxcXGthcHBhXCIszrs6XCJcXFxcbGFtYmRhXCIszr06XCJcXFxcbnVcIizOvzpcIlxcXFxvbWljcm9uXCIsz4A6XCJcXFxccGlcIizOoDpcIlxcXFxQaVwiLM+BOlwiXFxcXHJob1wiLM+DOlwiXFxcXHNpZ21hXCIszqM6XCJcXFxcU2lnbWFcIizPhDpcIlxcXFx0YXVcIizPhTpcIlxcXFx1cHNpbG9uXCIszqU6XCJcXFxcVXBzaWxvblwiLM+VOlwiXFxcXHBoaVwiLM6mOlwiXFxcXFBoaVwiLM+HOlwiXFxcXGNoaVwiLM+IOlwiXFxcXHBzaVwiLM6oOlwiXFxcXFBzaVwiLM+JOlwiXFxcXG9tZWdhXCIszqk6XCJcXFxcT21lZ2FcIizihKY6XCJcXFxcT21lZ2FcIixcIuKIhVwiOlwiXFxcXGVtcHR5c2V0XCIsXCLin7JcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKfs1wiOlwiXFxcXGNpcmNsZWFycm93cmlnaHRcIixcIsOXXCI6XCJcXFxcdGltZXNcIixcIsK9XCI6XCJcXFxcZGZyYWN7MX17Mn1cIizOvDpcIlxcXFxtdVwiLNOoOlwiXFxcXHRoZXRhXCIsXCLinJNcIjpcIlxcXFxjaGVja21hcmtcIixcIuKfqVwiOlwiXFxcXHJhbmdsZVwiLFwi4p+oXCI6XCJcXFxcbGFuZ2xlXCIsXCLCvFwiOlwiXFxcXGRmcmFjezF9ezR9XCIsXCLigKZcIjpcIlxcXFxsZG90c1wiLOKEjzpcIlxcXFxoYmFyXCIs4oScOlwiXFxcXG1hdGhmcmFre1J9XCIs0bI6XCJcXFxcdGhldGFcIizDmDpcIlxcXFxlbXB0eXNldFwiLM+xOlwiXFxcXHZhcnJob1wiLNGEOlwiXFxcXHBoaVwiLOKEhzpcIlxcXFx2YXJlcHNpbG9uXCIsVDpcIlRcIixcIuKImVwiOlwiXFxcXGNkb3RcIizOoTpcIlBcIixcIuKInlwiOlwiXFxcXGluZnR5XCIs4ZCBOlwiXFxcXG5hYmxhXCIsxp46XCJcXFxcZXRhXCIsXCLigbpcIjpcIl57K31cIixcIuKBu1wiOlwiXnstfVwiLFwi4oG8XCI6XCJeez19XCIsXCLigb1cIjpcIl57KH1cIixcIuKBvlwiOlwiXnspfVwiLFwi44CXXCI6XCJcXFxcKXxcIixcIuOAllwiOlwiXFxcXGxhbmdsZVwiLFwizb5cIjpcIjtcIixcIuC1plwiOlwiXFxcXGNpcmNcIixcIuKUtFwiOlwiXFxcXHBlcnBcIixcIuKclVwiOlwiXFxcXHRpbWVzXCIsXCLijrtcIjpcIi1cIixcIsK7XCI6XCJcXFxcZ2dcIixcIuKshlwiOlwiXFxcXHVwYXJyb3dcIixcIuKsh1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qyFXCI6XCJcXFxcbGVmdGFycm93XCIsXCLinqFcIjpcIlxcXFxyaWdodGFycm93XCIsXCLijrxcIjpcIi1cIixcIuKOnFwiOlwiXFxcXG1pZFwiLFwi4o6lXCI6XCJcXFxcbWlkXCIsxKc6XCJcXFxcaGJhclwiLFwi4q6VXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi44O7XCI6XCJcXFxcY2RvdFwiLFwiwqZcIjpcIlxcXFxtaWRcIixcIsKjXCI6XCJcXFxccG91bmRzXCIsXCLCpVwiOlwiXFxcXHllblwiLFwi4pyXXCI6XCJcXFxcdGltZXNcIixcIuKclFwiOlwiXFxcXGNoZWNrbWFya1wiLOKBvzpcIl57bn1cIixcIsKrXCI6XCJcXFxcbGxcIizguYA6XCJcXFxccHJpbWVcIixcIuKAoFwiOlwiXFxcXGRhZ2dlclwiLFwi4pSCXCI6XCJcXFxcbWlkXCIsJDpcIlxcXFwkXCIsXCIjXCI6XCJcXFxcI1wiLFwi4oSDXCI6XCJcXFxcdGV4dHtcXFxcdGV4dGRlZ3JlZSBDfVwiLFwi4oSJXCI6XCJcXFxcdGV4dHtcXFxcdGV4dGRlZ3JlZSBGfVwiLFwi4paIXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKEp1wiOlwiXFxcXG1ob1wiLOKFhzpcIlxcXFx0ZXh0e2V9XCIsybw6XCJyXCIsXCLigKFcIjpcIlxcXFxkZGFnZ2VyXCIs4byxOlwiaVwiLM+SOlwiXFxcXFVwc2lsb25cIizwnZu/OlwiXFxcXGRlbHRhXCIsXCLLs1wiOlwiXFxcXGNkb3RcIizRszpcIlxcXFx0aGV0YVwiLPCdnJk6XCJcXFxccGhpXCIs0J86XCJcXFxccHJvZFwiLNC+Olwib1wiLNGSOlwiXFxcXGhiYXJcIizJhTpcIlxcXFxMYW1iZGFcIixcIuClpFwiOlwiXFxcXG1pZFwiLFwi4oKsXCI6XCJcXFxcZXVyb1wiLOG/oTpcIlxcXFxiYXJ7dX1cIizPhjpcIlxcXFx2YXJwaGlcIizIvDpcImNcIizwnZ6uOlwiXFxcXGVwc2lsb25cIizOpzpcIlxcXFxtYXRoc2Z7WH1cIizigpk6XCJfe259XCJ9fSw4MjQ5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoU3ltYm9sc0J5Q2hhcj12b2lkIDAsdC5hbGxNYXRoU3ltYm9sc0J5Q2hhcj17XCImI3hBMDtcIjpcIlxcXFx0ZXh0cm17IH1cIixcIiYjeDIyMDM7XCI6XCJcXFxcZXhpc3RzXCIsXCImI3gyMjAwO1wiOlwiXFxcXGZvcmFsbFwiLFwiJiN4MjFENDtcIjpcIlxcXFxpZmZcIixcIiYjeDIxRDI7XCI6XCI9PlwiLFwiJiN4QUM7XCI6XCJcXFxcbmVnXCIsXCImI3gyMTI0O1wiOlwiXFxcXG1hdGhiYntafVwiLFwiJiN4MjExRDtcIjpcIlxcXFxtYXRoYmJ7Un1cIixcIiYjeDIxMUE7XCI6XCJcXFxcbWF0aGJie1F9XCIsXCImI3gyMTE1O1wiOlwiXFxcXG1hdGhiYntOfVwiLFwiJiN4MjEwMjtcIjpcIkNDXCIsXCImI3gyNUExO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjJDNDtcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyNUIzO1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyMzIyO1wiOlwiXFxcXGZyb3duXCIsXCImI3gyMjIwO1wiOlwiXFxcXGFuZ2xlXCIsXCImI3gyMkYxO1wiOlwiXFxcXGRkb3RzXCIsXCImI3gyMkVFO1wiOlwiXFxcXHZkb3RzXCIsXCImI3gyMjM1O1wiOlwiXFxcXGJlY2F1c2VcIixcIiYjeDIyMzQ7XCI6XCJcXFxcdGhlcmVmb3JlXCIsXCImI3gyMTM1O1wiOlwiXFxcXGFsZXBoXCIsXCImI3gyMjA1O1wiOlwiXFxcXG9zbGFzaFwiLFwiJiN4QjE7XCI6XCJcXFxccG1cIixcIiYjeDIyMDc7XCI6XCJcXFxcbmFibGFcIixcIiYjeDIyMDI7XCI6XCJcXFxccGFydGlhbFwiLFwiJiN4MjIyRTtcIjpcIlxcXFxvaW50XCIsXCImI3gyMjJCO1wiOlwiXFxcXGludFwiLFwiJiN4MjJDMztcIjpcIlxcXFxjdXBcIixcIiYjeDIyMkE7XCI6XCJcXFxcY3VwXCIsXCImI3gyMkMyO1wiOlwiXFxcXGNhcFwiLFwiJiN4MjIyOTtcIjpcIlxcXFxjYXBcIixcIiYjeDIyQzE7XCI6XCJcXFxcdmVlXCIsXCImI3gyMjI4O1wiOlwiXFxcXHZlZVwiLFwiJiN4MjJDMDtcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MjIyNztcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MjIwRjtcIjpcIlxcXFxwcm9kXCIsXCImI3gyMjExO1wiOlwiXFxcXHN1bVwiLFwiJiN4MjI5OTtcIjpcIlxcXFxiaWdvZG90XCIsXCImI3gyMjk3O1wiOlwiXFxcXGJpZ29wbHVzXCIsXCImI3gyMjk1O1wiOlwibytcIixcIiYjeDIyMTg7XCI6XCJAXCIsXCImI3gyMkM4O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjJDQTtcIjpcIlxcXFxydGltZXNcIixcIiYjeDIyQzk7XCI6XCJcXFxcbHRpbWVzXCIsXCImI3hGNztcIjpcIlxcXFxkaXZcIixcIiYjeEQ3O1wiOlwiXFxcXHRpbWVzXCIsXCJcXFxcXCI6XCJcXFxcYmFja3NsYXNoXCIsXCImI3gyMkM2O1wiOlwiXFxcXHN0YXJcIixcIiYjeDIyMTc7XCI6XCJcXFxcc3RhclwiLFwiJiN4MjJDNTtcIjpcIlxcXFxjZG90XCIsXCImI3gzQTk7XCI6XCJcXFxcT21lZ2FcIixcIiYjeDNDOTtcIjpcIlxcXFxvbWVnYVwiLFwiJiN4M0E4O1wiOlwiXFxcXFBzaVwiLFwiJiN4M0M4O1wiOlwiXFxcXHBzaVwiLFwiJiN4M0M3O1wiOlwiXFxcXGNoaVwiLFwiJiN4M0M2O1wiOlwiXFxcXHZhcnBoaVwiLFwiJiN4M0E2O1wiOlwiXFxcXFBoaVwiLFwiJiN4M0Q1O1wiOlwiXFxcXHBoaVwiLFwiJiN4M0M1O1wiOlwiXFxcXHVwc2lsb25cIixcIiYjeDNDNDtcIjpcIlxcXFx0YXVcIixcIiYjeDNBMztcIjpcIlxcXFxTaWdtYVwiLFwiJiN4M0MzO1wiOlwiXFxcXHNpZ21hXCIsXCImI3gzQzE7XCI6XCJcXFxccmhvXCIsXCImI3gzQTA7XCI6XCJcXFxcUGlcIixcIiYjeDNDMDtcIjpcIlxcXFxwaVwiLFwiJiN4MzlFO1wiOlwiXFxcXFhpXCIsXCImI3gzQkU7XCI6XCJcXFxceGlcIixcIiYjeDNCRDtcIjpcIlxcXFxudVwiLFwiJiN4M0JDO1wiOlwiXFxcXG11XCIsXCImI3gzOUI7XCI6XCJcXFxcTGFtYmRhXCIsXCImI3gzQkI7XCI6XCJcXFxcbGFtYmRhXCIsXCImI3gzQkE7XCI6XCJcXFxca2FwcGFcIixcIiYjeDNCOTtcIjpcIlxcXFxpb3RhXCIsXCImI3gzRDE7XCI6XCJcXFxcdmFydGhldGFcIixcIiYjeDM5ODtcIjpcIlxcXFxUaGV0YVwiLFwiJiN4M0I4O1wiOlwiXFxcXHRoZXRhXCIsXCImI3gzQjc7XCI6XCJcXFxcZXRhXCIsXCImI3gzQjY7XCI6XCJcXFxcemV0YVwiLFwiJiN4MjVCO1wiOlwiXFxcXHZhcmVwc2lsb25cIixcIiYjeDNCNTtcIjpcIlxcXFxlcHNpbG9uXCIsXCImI3gzOTQ7XCI6XCJcXFxcRGVsdGFcIixcIiYjeDNCNDtcIjpcIlxcXFxkZWx0YVwiLFwiJiN4MzkzO1wiOlwiXFxcXEdhbW1hXCIsXCImI3gzQjM7XCI6XCJcXFxcZ2FtbWFcIixcIiYjeDNCMjtcIjpcIlxcXFxiZXRhXCIsXCImI3gzQjE7XCI6XCJcXFxcYWxwaGFcIixcIiYjeDIyMUU7XCI6XCJcXFxcaW5mdHlcIixcIuKArFwiOlwiXFxcXHRleHR7XFxcXHRleHRkaXIgVFJUfVwiLFwi4oCOXCI6XCJcXFxcdGV4dHtcXFxcdGV4dGRpciBMVFJ9XCJ9fSw4MTcxOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoU3ltYm9sc0J5R2x5cGg9dm9pZCAwLHQuYWxsTWF0aFN5bWJvbHNCeUdseXBoPXtcIiBcIjpcIlxcXFx0ZXh0cm17IH1cIixcIuKIg1wiOlwiXFxcXGV4aXN0c1wiLFwi4oiAXCI6XCJcXFxcZm9yYWxsXCIsXCLih5RcIjpcIlxcXFxpZmZcIixcIuKHklwiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIsKsXCI6XCJcXFxcbmVnXCIsXCLilqFcIjpcIlxcXFxzcXVhcmVcIixcIuKLhFwiOlwiXFxcXGRpYW1vbmRcIixcIuKWs1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCLijKJcIjpcIlxcXFxmcm93blwiLFwi4oigXCI6XCJcXFxcYW5nbGVcIixcIuKLsVwiOlwiXFxcXGRkb3RzXCIsXCLii65cIjpcIlxcXFx2ZG90c1wiLFwi4oi1XCI6XCJcXFxcYmVjYXVzZVwiLFwi4oi0XCI6XCJcXFxcdGhlcmVmb3JlXCIs4oS1OlwiXFxcXGFsZXBoXCIsXCLiiIVcIjpcIlxcXFxlbXB0eXNldFwiLFwiwrFcIjpcIlxcXFxwbVwiLFwi4oiHXCI6XCJcXFxcbmFibGFcIixcIuKIglwiOlwiXFxcXHBhcnRpYWxcIixcIuKIrlwiOlwiXFxcXG9pbnRcIixcIuKIq1wiOlwiXFxcXGludFwiLFwi4ouDXCI6XCJcXFxcY3VwXCIsXCLiiKpcIjpcIlxcXFxjdXBcIixcIuKLglwiOlwiXFxcXGNhcFwiLFwi4oipXCI6XCJcXFxcY2FwXCIsXCLii4FcIjpcIlxcXFx2ZWVcIixcIuKIqFwiOlwiXFxcXHZlZVwiLFwi4ouAXCI6XCJcXFxcd2VkZ2VcIixcIuKIp1wiOlwiXFxcXHdlZGdlXCIsXCLiiI9cIjpcIlxcXFxwcm9kXCIsXCLiiJFcIjpcIlxcXFxzdW1cIixcIuKKmVwiOlwiXFxcXGJpZ29kb3RcIixcIuKKl1wiOlwiXFxcXGJpZ29wbHVzXCIsXCLiipVcIjpcIm8rXCIsXCLiiJhcIjpcIkBcIixcIuKLiFwiOlwiXFxcXGJvd3RpZVwiLFwi4ouKXCI6XCJcXFxccnRpbWVzXCIsXCLii4lcIjpcIlxcXFxsdGltZXNcIixcIsO3XCI6XCJcXFxcZGl2XCIsXCLDl1wiOlwiXFxcXHRpbWVzXCIsXCJcXFxcXCI6XCJcXFxcYmFja3NsYXNoXCIsXCLii4ZcIjpcIlxcXFxzdGFyXCIsXCLiiJdcIjpcIlxcXFxzdGFyXCIsXCLii4VcIjpcIlxcXFxjZG90XCIszqk6XCJcXFxcT21lZ2FcIizPiTpcIlxcXFxvbWVnYVwiLM6oOlwiXFxcXFBzaVwiLM+IOlwiXFxcXHBzaVwiLM+HOlwiXFxcXGNoaVwiLM+GOlwiXFxcXHZhcnBoaVwiLM6mOlwiXFxcXFBoaVwiLM+VOlwiXFxcXHBoaVwiLM+FOlwiXFxcXHVwc2lsb25cIizPhDpcIlxcXFx0YXVcIizOozpcIlxcXFxTaWdtYVwiLM+DOlwiXFxcXHNpZ21hXCIsz4E6XCJcXFxccmhvXCIszqA6XCJcXFxcUGlcIizPgDpcIlxcXFxwaVwiLM6eOlwiXFxcXFhpXCIszr46XCJcXFxceGlcIizOvTpcIlxcXFxudVwiLM68OlwiXFxcXG11XCIszps6XCJcXFxcTGFtYmRhXCIszrs6XCJcXFxcbGFtYmRhXCIszro6XCJcXFxca2FwcGFcIizOuTpcIlxcXFxpb3RhXCIsz5E6XCJcXFxcdmFydGhldGFcIizOmDpcIlxcXFxUaGV0YVwiLM64OlwiXFxcXHRoZXRhXCIszrc6XCJcXFxcZXRhXCIszrY6XCJcXFxcemV0YVwiLMmbOlwiXFxcXHZhcmVwc2lsb25cIizOtTpcIlxcXFxlcHNpbG9uXCIszpQ6XCJcXFxcRGVsdGFcIizOtDpcIlxcXFxkZWx0YVwiLM6TOlwiXFxcXEdhbW1hXCIszrM6XCJcXFxcZ2FtbWFcIizOsjpcIlxcXFxiZXRhXCIszrE6XCJcXFxcYWxwaGFcIixcIuKInlwiOlwiXFxcXGluZnR5XCIsz7U6XCJcXFxcZXBzaWxvblwiLMK1OlwiXFxcXG11XCIsXCLCslwiOlwiXnsyfVwiLMSxOlwiXFxcXGltYXRoXCIsXCLiiI5cIjpcIlxcXFxibGFja3NxdWFyZVwiLOC4oTpcIlxcXFxtYXRoYmZ7bX1cIizihKY6XCJcXFxcT21lZ2FcIixcIuKfslwiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwi4p+zXCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLOCkpDpcIiBcIixcIsKlXCI6XCJcXFxceWVuXCIsXCLigb1cIjpcIl57KH1cIixcIuKBvlwiOlwiXnspfVwiLMOfOlwiXFxcXHNzXCIs0Is6XCJcXFxcaGJhclwiLFwi4qa1XCI6XCJcXFxcb21pbnVzXCIsXCLiir9cIjpcIlxcXFxiaWd0cmlhbmdsZXVwXCIsXCLihpsnXCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIuKAoFwiOlwiXFxcXGRhZ2dlclwiLOC5gDpcIlxcXFxwcmltZVwiLOeZvTpcIiBcIixcIuK/sVwiOlwiIFwiLOKEuDpcIlxcXFx3cFwiLO2TsDpcIiBcIizigb86XCJee259XCIsXCLinJRcIjpcIlxcXFxjaGVja21hcmtcIixcIuKcl1wiOlwiXFxcXHRpbWVzXCIsXCLCvVwiOlwiXFxcXGRmcmFjezF9ezJ9XCIs06g6XCJcXFxcdGhldGFcIixcIuKck1wiOlwiXFxcXGNoZWNrbWFya1wiLFwi4p+pXCI6XCJcXFxccmFuZ2xlXCIsXCLin6hcIjpcIlxcXFxsYW5nbGVcIixcIuKMqVwiOlwiXFxcXGxhbmdsZVwiLFwiwrxcIjpcIlxcXFxkZnJhY3sxfXs0fVwiLFwi4oCmXCI6XCJcXFxcbGRvdHNcIizihI86XCJcXFxcaGJhclwiLOKEnDpcIlxcXFxtYXRoZnJha3tSfVwiLNGyOlwiXFxcXHRoZXRhXCIsw5g6XCJcXFxcZW1wdHlzZXRcIizPsTpcIlxcXFx2YXJyaG9cIizRhDpcIlxcXFxwaGlcIixUOlwiVFwiLFwi4oiZXCI6XCJcXFxcY2RvdFwiLM6hOlwiUFwiLOGQgTpcIlxcXFxuYWJsYVwiLMaeOlwiXFxcXGV0YVwiLMmjOlwiXFxcXGdhbW1hXCIs0Zs6XCJcXFxcaGJhclwiLMaQOlwiXFxcXHZhcmVwc2lsb25cIizihYU6XCJcXFxcX3tEfVwiLPCdnIY6XCJcXFxcbGFtYmRhXCIsXCLjgJdcIjpcIlxcXFxyYW5nbGVcIixcIuOAllwiOlwiXFxcXGxhbmdsZVwiLFwizb5cIjpcIjtcIizwnZGlOlwieFwiLPCdkaY6XCJ5XCIs8J2RpzpcInpcIizwnZGWOlwiaVwiLPCdkZc6XCJqXCIs8J2RmDpcImtcIizwnZGaOlwibVwiLPCdkZI6XCJlXCIs8J2RnzpcInJcIizJszpcIlxcXFxldGFcIizwnZu9OlwiXFxcXGJldGFcIixcIuKNtVwiOlwiXFxcXG9tZWdhXCIs4oSYOlwiXFxcXHdwXCIs8J2cizpcIlxcXFxwaVwiLNCEOlwiXFxcXGVwc2lsb25cIizRlDpcIlxcXFxlcHNpbG9uXCIs8J2cgDpcIlxcXFxlcHNpbG9uXCIs0L86XCJcXFxccGlcIizOnTpcIlxcXFxudVwiLMm1OlwiXFxcXHRoZXRhXCIs8J2ckzpcIlxcXFxwc2lcIizPtDpcIlxcXFx0aGV0YVwiLMm4OlwiXFxcXHBoaVwiLNO2OlwiXFxcXEdhbW1hXCIsya06XCJcXFxcZWxsXCIsyos6XCJcXFxcdXBzaWxvblwiLPCdm586XCJcXFxcdmFycGhpXCIsXCLijaxcIjpcIlxcXFx0aGV0YVwiLNCkOlwiXFxcXFBoaVwiLPCdnJE6XCJcXFxcdmFycGhpXCIs4oWIOlwiaVwiLM6/Olwib1wiLMahOlwib1wiLMaSOlwiZlwiLFwi4o20XCI6XCJcXFxccmhvXCIsXCLwn4e9XCI6XCJ4XCIs8J2RnTpcInBcIizwnZGeOlwicVwiLPCdkaA6XCJzXCIs8J2RoTpcInRcIizwnZGiOlwidVwiLPCdkaM6XCJ2XCIs8J2RpDpcIndcIizwnZGOOlwiYVwiLPCdkY86XCJiXCIs8J2RkDpcImNcIizwnZGROlwiZFwiLPCdkZM6XCJmXCIs8J2RlDpcImdcIizwnZGZOlwibFwiLPCdkZs6XCJuXCIs8J2RnDpcIm9cIizwnZSAOlwid1wiLPCdmp86XCJ2XCIs4bmBOlwibVwiLFwi4LWmXCI6XCJcXFxcY2lyY1wiLFwi4pS0XCI6XCJcXFxccGVycFwiLFwi4pyVXCI6XCJcXFxcdGltZXNcIixcIuKIo1wiOlwiXFxcXG1pZFwiLNWTOlwiXFxcXFBoaVwiLFwi4o6cXCI6XCJcXFxcbWlkXCIsxKc6XCJcXFxcaGJhclwiLOGNiDpcIiBcIixcIuKmqFwiOlwiXFxcXGxsYnJhY2tldFwiLOG6vzpcIlxcXFxoYXR7ZX1cIixcIsKiXCI6XCJcXFxcY2VudFwiLFwi4qS5XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLhcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKkt1wiOlwiXFxcXFJzaFwiLFwi4qS2XCI6XCJcXFxcTHNoXCIsXCLipLVcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKktFwiOlwiXFxcXHVwYXJyb3dcIixcIuKks1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcInxcIjpcIlxcXFxtaWRcIixcIuKOpVwiOlwiXFxcXG1pZFwiLFwi4pmlXCI6XCJcXFxcaGVhcnRzdWl0XCIs0J46XCIwXCIszqU6XCJZXCIs0YU6XCJ4XCIs8J2TjzpcInpcIizwnZOOOlwieVwiLPCdk406XCJ4XCIs0YA6XCJwXCIs0LA6XCJhXCIsXCLCo1wiOlwiXFxcXHBvdW5kc1wiLG06XCJtXCIs8J2atTpcIlxcXFxYaVwiLFwi4pOqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MH1cIixcIuKRoFwiOlwiXFxcXHRleHRjaXJjbGVkezF9XCIsXCLikaFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyfVwiLFwi4pGiXCI6XCJcXFxcdGV4dGNpcmNsZWR7M31cIixcIuKRo1wiOlwiXFxcXHRleHRjaXJjbGVkezR9XCIsXCLikaRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs1fVwiLFwi4pGlXCI6XCJcXFxcdGV4dGNpcmNsZWR7Nn1cIixcIuKRplwiOlwiXFxcXHRleHRjaXJjbGVkezd9XCIsXCLikadcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs4fVwiLFwi4pGoXCI6XCJcXFxcdGV4dGNpcmNsZWR7OX1cIixcIuKRqVwiOlwiXFxcXHRleHRjaXJjbGVkezEwfVwiLFwi4pGqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTF9XCIsXCLikatcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMn1cIixcIuKRrFwiOlwiXFxcXHRleHRjaXJjbGVkezEzfVwiLFwi4pGtXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTR9XCIsXCLika5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNX1cIixcIuKRr1wiOlwiXFxcXHRleHRjaXJjbGVkezE2fVwiLFwi4pGwXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTd9XCIsXCLikbFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOH1cIixcIuKRslwiOlwiXFxcXHRleHRjaXJjbGVkezE5fVwiLFwi4pGzXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjB9XCIsXCLjiZFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMX1cIixcIuOJklwiOlwiXFxcXHRleHRjaXJjbGVkezIyfVwiLFwi44mTXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjN9XCIsXCLjiZRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNH1cIixcIuOJlVwiOlwiXFxcXHRleHRjaXJjbGVkezI1fVwiLFwi44mWXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjZ9XCIsXCLjiZdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyN31cIixcIuOJmFwiOlwiXFxcXHRleHRjaXJjbGVkezI4fVwiLFwi44mZXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjl9XCIsXCLjiZpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMH1cIixcIuOJm1wiOlwiXFxcXHRleHRjaXJjbGVkezMxfVwiLFwi44mcXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzJ9XCIsXCLjiZ1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszM31cIixcIuOJnlwiOlwiXFxcXHRleHRjaXJjbGVkezM0fVwiLFwi44mfXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzV9XCIsXCLjirFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNn1cIixcIuOKslwiOlwiXFxcXHRleHRjaXJjbGVkezM3fVwiLFwi44qzXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzh9XCIsXCLjirRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszOX1cIixcIuOKtVwiOlwiXFxcXHRleHRjaXJjbGVkezQwfVwiLFwi44q2XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDF9XCIsXCLjirdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Mn1cIixcIuOKuFwiOlwiXFxcXHRleHRjaXJjbGVkezQzfVwiLFwi44q5XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDR9XCIsXCLjirpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0NX1cIixcIuOKu1wiOlwiXFxcXHRleHRjaXJjbGVkezQ2fVwiLFwi44q8XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDd9XCIsXCLjir1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OH1cIixcIuOKvlwiOlwiXFxcXHRleHRjaXJjbGVkezQ5fVwiLFwi44q/XCI6XCJcXFxcdGV4dGNpcmNsZWR7NTB9XCIsXCImXCI6XCJcXFxcJlwiLFwi4oCWXCI6XCJcXFxccGFyYWxsZWxcIixcIiVcIjpcIlxcXFwlXCIsXCLigJxcIjpcIlxcXFx0ZXh0e2BgfVwiLCQ6XCJcXFxcJFwiLFwiI1wiOlwiXFxcXCNcIixcIuKEg1wiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgQ31cIixcIuKEiVwiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgRn1cIixcIuKWiFwiOlwiXFxcXGJsYWNrc3F1YXJlXCIsXCLihKdcIjpcIlxcXFxtaG9cIixcIuKMi1wiOlwiXFxcXHJmbG9vclwiLFwi4oyKXCI6XCJcXFxcbGZsb29yXCIsXCLijIlcIjpcIlxcXFxyY2VpbFwiLFwi4oyIXCI6XCJcXFxcbGNlaWxcIizihIc6XCJcXFxcdmFyZXBzaWxvblwiLOKFhzpcIlxcXFx0ZXh0e2V9XCIsybw6XCJyXCIsXCLihptcIjpcIlxcXFxucmlnaHRhcnJvd1wiLMuGOlwiXFxcXGhhdHt9XCIsXCLigL5cIjpcIlxcXFxvdmVybGluZVwiLFwi4oaSXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oChXCI6XCJcXFxcZGRhZ2dlclwiLFwi44O7XCI6XCJcXFxcY2RvdFwiLFwi4paxXCI6XCJcXFxcc3F1YXJlXCIsXCLiiIZcIjpcIlxcXFxEZWx0YVwiLOG8sTpcImlcIixcIuKIoVwiOlwiXFxcXGFuZ2xlXCIsz5I6XCJcXFxcVXBzaWxvblwiLFwi4oaTXCI6XCJcXFxcZG93bmFycm93XCIsXCLihpFcIjpcIlxcXFx1cGFycm93XCIsXCLCu1wiOlwiXFxcXGdnXCIsXCLiiqRcIjpcIlxcXFx0b3BcIixcIuKnuFwiOlwiL1wiLPCdm786XCJcXFxcZGVsdGFcIixcIsuzXCI6XCJcXFxcY2RvdFwiLFwi1olcIjpcIjpcIixcIuKmqlwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmqVwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmq1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmgVwiOlwiXFxcXGNkb3RcIizRszpcIlxcXFx0aGV0YVwiLFwi4qaiXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiwrhcIjpcIixcIixcIuKOu1wiOlwiXFxcXG92ZXJsaW5lXCIsXCLin6ZcIjpcIlxcXFxsbGJyYWNrZXRcIizwnZyZOlwiXFxcXHBoaVwiLNCfOlwiXFxcXHByb2RcIizQvjpcIm9cIixcIuKJiFwiOlwiXFxcXGFwcHJveFwiLFwi4omkXCI6XCJcXFxcbGVxXCIs0ZI6XCJcXFxcaGJhclwiLMmFOlwiXFxcXExhbWJkYVwiLOWcnzpcIlxcXFxwbVwiLFwi4o68XCI6XCItXCIs5Y2BOlwiK1wiLFwi4omgXCI6XCJcXFxcbmVxXCIsXCLihpBcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuClpFwiOlwiXFxcXG1pZFwiLFwi4oKsXCI6XCJcXFxcZXVyb1wiLFwiy5hcIjpcIiBcIizhv6E6XCJcXFxcYmFye3V9XCIsXCLiiKVcIjpcIlxcXFxwYXJhbGxlbFwiLFwi4oaUXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKImlwiOlwiXFxcXHNxcnR7fVwiLMi8OlwiY1wiLPCdnq46XCJcXFxcZXBzaWxvblwiLFwiwrdcIjpcIlxcXFxjZG90XCIsXCLipqxcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq5cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq1cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLCq1wiOlwiXFxcXGxsXCIszqc6XCJcXFxcbWF0aHNme1h9XCIsXCLilIJcIjpcIlxcXFxtaWRcIixcIuKMqlwiOlwiXFxcXHJhbmdsZVwiLOKCmTpcIl97bn1cIixcIuKWq1wiOlwiXFxcXHNxdWFyZVwiLFwi4pePXCI6XCJcXFxcY2lyY2xlXCIsXCLigJ1cIjonXFxcXFwiJ319LDU0MDY6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDI5NjUpLHQpLG4ocig5MDM5KSx0KSxuKHIoODI0OSksdCksbihyKDgxNzEpLHQpLG4ocig0NzIpLHQpLG4ocig0MzIwKSx0KSxuKHIoNjEyMiksdCl9LDQ3MjooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubGF0ZXhBY2NlbnRzPXZvaWQgMCx0LmxhdGV4QWNjZW50cz1bXCJcXFxcaGF0XCIsXCJcXFxcYmFyXCIsXCJcXFxcdW5kZXJicmFjZVwiLFwiXFxcXG92ZXJicmFjZVwiXX0sNDMyMDooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubWF0aE51bWJlckJ5R2x5cGg9dm9pZCAwLHQubWF0aE51bWJlckJ5R2x5cGg9e1wi4oKAXCI6XCJfezB9XCIsXCLigoFcIjpcIl97MX1cIixcIuKCglwiOlwiX3syfVwiLFwi4oKDXCI6XCJfezN9XCIsXCLigoRcIjpcIl97NH1cIixcIuKChVwiOlwiX3s1fVwiLFwi4oKGXCI6XCJfezZ9XCIsXCLigodcIjpcIl97N31cIixcIuKCiFwiOlwiX3s4fVwiLFwi4oKJXCI6XCJfezl9XCIsXCLigbBcIjpcIl57MH1cIixcIsK5XCI6XCJeezF9XCIsXCLCslwiOlwiXnsyfVwiLFwiwrNcIjpcIl57M31cIixcIuKBtFwiOlwiXns0fVwiLFwi4oG1XCI6XCJeezV9XCIsXCLigbZcIjpcIl57Nn1cIixcIuKBt1wiOlwiXns3fVwiLFwi4oG4XCI6XCJeezh9XCIsXCLigblcIjpcIl57OX1cIizigb86XCJee259XCIs4oKZOlwiX3tufVwiLFwi4pOqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MH1cIixcIuKRoFwiOlwiXFxcXHRleHRjaXJjbGVkezF9XCIsXCLikaFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyfVwiLFwi4pGiXCI6XCJcXFxcdGV4dGNpcmNsZWR7M31cIixcIuKRo1wiOlwiXFxcXHRleHRjaXJjbGVkezR9XCIsXCLikaRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs1fVwiLFwi4pGlXCI6XCJcXFxcdGV4dGNpcmNsZWR7Nn1cIixcIuKRplwiOlwiXFxcXHRleHRjaXJjbGVkezd9XCIsXCLikadcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs4fVwiLFwi4pGoXCI6XCJcXFxcdGV4dGNpcmNsZWR7OX1cIixcIuKRqVwiOlwiXFxcXHRleHRjaXJjbGVkezEwfVwiLFwi4pGqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTF9XCIsXCLikatcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMn1cIixcIuKRrFwiOlwiXFxcXHRleHRjaXJjbGVkezEzfVwiLFwi4pGtXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTR9XCIsXCLika5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNX1cIixcIuKRr1wiOlwiXFxcXHRleHRjaXJjbGVkezE2fVwiLFwi4pGwXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTd9XCIsXCLikbFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOH1cIixcIuKRslwiOlwiXFxcXHRleHRjaXJjbGVkezE5fVwiLFwi4pGzXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjB9XCIsXCLjiZFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMX1cIixcIuOJklwiOlwiXFxcXHRleHRjaXJjbGVkezIyfVwiLFwi44mTXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjN9XCIsXCLjiZRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNH1cIixcIuOJlVwiOlwiXFxcXHRleHRjaXJjbGVkezI1fVwiLFwi44mWXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjZ9XCIsXCLjiZdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyN31cIixcIuOJmFwiOlwiXFxcXHRleHRjaXJjbGVkezI4fVwiLFwi44mZXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjl9XCIsXCLjiZpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMH1cIixcIuOJm1wiOlwiXFxcXHRleHRjaXJjbGVkezMxfVwiLFwi44mcXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzJ9XCIsXCLjiZ1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszM31cIixcIuOJnlwiOlwiXFxcXHRleHRjaXJjbGVkezM0fVwiLFwi44mfXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzV9XCIsXCLjirFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNn1cIixcIuOKslwiOlwiXFxcXHRleHRjaXJjbGVkezM3fVwiLFwi44qzXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzh9XCIsXCLjirRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszOX1cIixcIuOKtVwiOlwiXFxcXHRleHRjaXJjbGVkezQwfVwiLFwi44q2XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDF9XCIsXCLjirdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Mn1cIixcIuOKuFwiOlwiXFxcXHRleHRjaXJjbGVkezQzfVwiLFwi44q5XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDR9XCIsXCLjirpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0NX1cIixcIuOKu1wiOlwiXFxcXHRleHRjaXJjbGVkezQ2fVwiLFwi44q8XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDd9XCIsXCLjir1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OH1cIixcIuOKvlwiOlwiXFxcXHRleHRjaXJjbGVkezQ5fVwiLFwi44q/XCI6XCJcXFxcdGV4dGNpcmNsZWR7NTB9XCIsXCLCvVwiOlwiXFxcXGRmcmFjezF9ezJ9XCIsXCLihZNcIjpcIlxcXFxkZnJhY3sxfXszfVwiLFwi4oWUXCI6XCJcXFxcZGZyYWN7Mn17M31cIixcIsK8XCI6XCJcXFxcZGZyYWN7MX17NH1cIixcIsK+XCI6XCJcXFxcZGZyYWN7M317NH1cIixcIuKFlVwiOlwiXFxcXGRmcmFjezF9ezV9XCIsXCLihZZcIjpcIlxcXFxkZnJhY3syfXs1fVwiLFwi4oWXXCI6XCJcXFxcZGZyYWN7M317NX1cIixcIuKFmFwiOlwiXFxcXGRmcmFjezR9ezV9XCIsXCLihZlcIjpcIlxcXFxkZnJhY3sxfXs2fVwiLFwi4oWaXCI6XCJcXFxcZGZyYWN7NX17Nn1cIixcIuKFkFwiOlwiXFxcXGRmcmFjezF9ezd9XCIsXCLihZtcIjpcIlxcXFxkZnJhY3sxfXs4fVwiLFwi4oWcXCI6XCJcXFxcZGZyYWN7M317OH1cIixcIuKFnVwiOlwiXFxcXGRmcmFjezV9ezh9XCIsXCLihZ5cIjpcIlxcXFxkZnJhY3s3fXs4fVwiLFwi4oWRXCI6XCJcXFxcZGZyYWN7MX17OX1cIixcIuKFklwiOlwiXFxcXGRmcmFjezF9ezEwfVwifX0sNjEyMjooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSGFzaFVURjhUb0x0WENvbnZlcnRlcj12b2lkIDAsdC5IYXNoVVRGOFRvTHRYQ29udmVydGVyPWNsYXNze2NvbnZlcnQoZSl7aWYoZS5tYXRjaCgvW2EtejAtOV0vaSkpcmV0dXJuIGU7Y29uc3QgdD1yW2VdO2lmKHQpe3JldHVybiB0aGlzLmNvbnZlcnRBY2NlbnRDaGFyVG9MdFgodCl8fGV9cmV0dXJuIHRoaXMuY29udmVydFNwZWNpYWxDaGFyVG9MdFgoZSl8fGV9Y29udmVydEFjY2VudENoYXJUb0x0WChlKXtjb25zdHtjaGFyOnQsYWNjZW50OnJ9PWUsbj1hW3JdO3JldHVybiBuP2BcXFxcJHtufXske3R9fWA6bnVsbH1jb252ZXJ0U3BlY2lhbENoYXJUb0x0WChlKXtjb25zdCB0PW5bZV07aWYoIXQpcmV0dXJuIG51bGw7Y29uc3R7bGV0dGVyOnIsZm9udENtZDphfT10O3JldHVybmBcXFxcJHthfXske3J9fWB9fTtjb25zdCByPXvDoTp7Y2hhcjpcImFcIixhY2NlbnQ6XCLCtFwifSzDoDp7Y2hhcjpcImFcIixhY2NlbnQ6XCJgXCJ9LMOiOntjaGFyOlwiYVwiLGFjY2VudDpcIl5cIn0sw6M6e2NoYXI6XCJhXCIsYWNjZW50OlwiflwifSzDpDp7Y2hhcjpcImFcIixhY2NlbnQ6XCLCqFwifSzDpTp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmlwifSzEhTp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmVwifSzEgzp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmFwifSzHjjp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLh1wifSzHnzp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLhlwifSzHuzp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmVwifSzHoTp7Y2hhcjpcImFcIixhY2NlbnQ6XCItXCJ9LMSBOntjaGFyOlwiYVwiLGFjY2VudDpcIi1cIn0sw6k6e2NoYXI6XCJlXCIsYWNjZW50OlwiwrRcIn0sw6g6e2NoYXI6XCJlXCIsYWNjZW50OlwiYFwifSzDqjp7Y2hhcjpcImVcIixhY2NlbnQ6XCJeXCJ9LMOrOntjaGFyOlwiZVwiLGFjY2VudDpcIsKoXCJ9LMSZOntjaGFyOlwiZVwiLGFjY2VudDpcIsuZXCJ9LMSbOntjaGFyOlwiZVwiLGFjY2VudDpcIsuHXCJ9LMiHOntjaGFyOlwiaVwiLGFjY2VudDpcIl5cIn0s0ZE6e2NoYXI6XCJlXCIsYWNjZW50OlwiwqhcIn0sxJM6e2NoYXI6XCJlXCIsYWNjZW50OlwiLVwifSzDrTp7Y2hhcjpcImlcIixhY2NlbnQ6XCLCtFwifSzDrDp7Y2hhcjpcImlcIixhY2NlbnQ6XCJgXCJ9LMOuOntjaGFyOlwiaVwiLGFjY2VudDpcIl5cIn0sw686e2NoYXI6XCJpXCIsYWNjZW50OlwiwqhcIn0sxK86e2NoYXI6XCJpXCIsYWNjZW50Olwiy5lcIn0sx5A6e2NoYXI6XCJpXCIsYWNjZW50Olwiy4dcIn0syIk6e2NoYXI6XCJpXCIsYWNjZW50OlwiYFwifSzIizp7Y2hhcjpcImlcIixhY2NlbnQ6XCLCqFwifSzEqzp7Y2hhcjpcImlcIixhY2NlbnQ6XCItXCJ9LMOzOntjaGFyOlwib1wiLGFjY2VudDpcIsK0XCJ9LMOyOntjaGFyOlwib1wiLGFjY2VudDpcImBcIn0sw7Q6e2NoYXI6XCJvXCIsYWNjZW50OlwiXlwifSzDtTp7Y2hhcjpcIm9cIixhY2NlbnQ6XCJ+XCJ9LMO2OntjaGFyOlwib1wiLGFjY2VudDpcIsKoXCJ9LMWROntjaGFyOlwib1wiLGFjY2VudDpcIsudXCJ9LMeSOntjaGFyOlwib1wiLGFjY2VudDpcIsuHXCJ9LMiNOntjaGFyOlwib1wiLGFjY2VudDpcImBcIn0syI86e2NoYXI6XCJvXCIsYWNjZW50OlwiwqhcIn0syKs6e2NoYXI6XCJvXCIsYWNjZW50Olwiy5hcIn0syK06e2NoYXI6XCJvXCIsYWNjZW50Olwiy51cIn0syK86e2NoYXI6XCJvXCIsYWNjZW50Olwiy5lcIn0sxY06e2NoYXI6XCJvXCIsYWNjZW50OlwiLVwifSzDujp7Y2hhcjpcInVcIixhY2NlbnQ6XCLCtFwifSzDuTp7Y2hhcjpcInVcIixhY2NlbnQ6XCJgXCJ9LMO7OntjaGFyOlwidVwiLGFjY2VudDpcIl5cIn0sw7w6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sxbE6e2NoYXI6XCJ1XCIsYWNjZW50Olwiy51cIn0sx5Q6e2NoYXI6XCJ1XCIsYWNjZW50Olwiy4dcIn0sx5Y6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sx5g6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sx5o6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sx5w6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0syJU6e2NoYXI6XCJ1XCIsYWNjZW50OlwiYFwifSzIlzp7Y2hhcjpcInVcIixhY2NlbnQ6XCLCqFwifSzFqzp7Y2hhcjpcInVcIixhY2NlbnQ6XCItXCJ9LMO9OntjaGFyOlwieVwiLGFjY2VudDpcIsK0XCJ9LOG7szp7Y2hhcjpcInlcIixhY2NlbnQ6XCJgXCJ9LMW3OntjaGFyOlwieVwiLGFjY2VudDpcIl5cIn0sw786e2NoYXI6XCJ5XCIsYWNjZW50OlwiwqhcIn0syLM6e2NoYXI6XCJ5XCIsYWNjZW50OlwiLVwifSzDgTp7Y2hhcjpcIkFcIixhY2NlbnQ6XCLCtFwifSzDgDp7Y2hhcjpcIkFcIixhY2NlbnQ6XCJgXCJ9LMOCOntjaGFyOlwiQVwiLGFjY2VudDpcIl5cIn0sw4M6e2NoYXI6XCJBXCIsYWNjZW50OlwiflwifSzDhDp7Y2hhcjpcIkFcIixhY2NlbnQ6XCLCqFwifSzDhTp7Y2hhcjpcIkFcIixhY2NlbnQ6XCLLmlwifSzihKs6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5pcIn0syKY6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5lcIn0sxII6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5hcIn0sx406e2NoYXI6XCJBXCIsYWNjZW50Olwiy4dcIn0sx546e2NoYXI6XCJBXCIsYWNjZW50Olwiy51cIn0sx7o6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5pcIn0sx6A6e2NoYXI6XCJBXCIsYWNjZW50OlwiLVwifSzEgDp7Y2hhcjpcIkFcIixhY2NlbnQ6XCItXCJ9LMOJOntjaGFyOlwiRVwiLGFjY2VudDpcIsK0XCJ9LMOIOntjaGFyOlwiRVwiLGFjY2VudDpcImBcIn0sxJY6e2NoYXI6XCJFXCIsYWNjZW50Olwiy5lcIn0sw4o6e2NoYXI6XCJFXCIsYWNjZW50OlwiXlwifSzDizp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLCqFwifSzEmjp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLLh1wifSzIhDp7Y2hhcjpcIkVcIixhY2NlbnQ6XCJgXCJ9LMiGOntjaGFyOlwiRVwiLGFjY2VudDpcIsKoXCJ9LMSSOntjaGFyOlwiRVwiLGFjY2VudDpcIi1cIn0sw406e2NoYXI6XCJJXCIsYWNjZW50OlwiwrRcIn0sw4w6e2NoYXI6XCJJXCIsYWNjZW50OlwiYFwifSzDjjp7Y2hhcjpcIklcIixhY2NlbnQ6XCJeXCJ9LMOPOntjaGFyOlwiSVwiLGFjY2VudDpcIsKoXCJ9LMSsOntjaGFyOlwiSVwiLGFjY2VudDpcIsuYXCJ9LMePOntjaGFyOlwiSVwiLGFjY2VudDpcIsuHXCJ9LMiIOntjaGFyOlwiSVwiLGFjY2VudDpcImBcIn0syIo6e2NoYXI6XCJJXCIsYWNjZW50OlwiwqhcIn0sxKo6e2NoYXI6XCJJXCIsYWNjZW50OlwiLVwifSzDkzp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLCtFwifSzDkjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCJgXCJ9LMOUOntjaGFyOlwiT1wiLGFjY2VudDpcIl5cIn0sw5U6e2NoYXI6XCJPXCIsYWNjZW50OlwiflwifSzDljp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLCqFwifSzFkDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLnVwifSzHkTp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLh1wifSzIjDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCJgXCJ9LMiOOntjaGFyOlwiT1wiLGFjY2VudDpcIsKoXCJ9LMiqOntjaGFyOlwiT1wiLGFjY2VudDpcIsuYXCJ9LMisOntjaGFyOlwiT1wiLGFjY2VudDpcIsudXCJ9LMiuOntjaGFyOlwiT1wiLGFjY2VudDpcIsuZXCJ9LMWMOntjaGFyOlwiT1wiLGFjY2VudDpcIi1cIn0sw5o6e2NoYXI6XCJVXCIsYWNjZW50OlwiwrRcIn0sw5k6e2NoYXI6XCJVXCIsYWNjZW50OlwiYFwifSzDmzp7Y2hhcjpcIlVcIixhY2NlbnQ6XCJeXCJ9LMOcOntjaGFyOlwiVVwiLGFjY2VudDpcIsKoXCJ9LMWwOntjaGFyOlwiVVwiLGFjY2VudDpcIsudXCJ9LMeTOntjaGFyOlwiVVwiLGFjY2VudDpcIsuHXCJ9LMeVOntjaGFyOlwiVVwiLGFjY2VudDpcIsKoXCJ9LMiUOntjaGFyOlwiVVwiLGFjY2VudDpcImBcIn0syJY6e2NoYXI6XCJVXCIsYWNjZW50OlwiwqhcIn0sxao6e2NoYXI6XCJVXCIsYWNjZW50OlwiLVwifSzDnTp7Y2hhcjpcIllcIixhY2NlbnQ6XCLCtFwifSzhu7I6e2NoYXI6XCJZXCIsYWNjZW50OlwiYFwifSzFtjp7Y2hhcjpcIllcIixhY2NlbnQ6XCJeXCJ9LMW4OntjaGFyOlwiWVwiLGFjY2VudDpcIsKoXCJ9LMiyOntjaGFyOlwiWVwiLGFjY2VudDpcIi1cIn0sw7E6e2NoYXI6XCJuXCIsYWNjZW50OlwiflwifSzDkTp7Y2hhcjpcIk5cIixhY2NlbnQ6XCJ+XCJ9LMOnOntjaGFyOlwiY1wiLGFjY2VudDpcIsuZXCJ9LMOHOntjaGFyOlwiQ1wiLGFjY2VudDpcIsuZXCJ9LOG5vTp7Y2hhcjpcInZcIixhY2NlbnQ6XCJ+XCJ9LOG5vDp7Y2hhcjpcIlZcIixhY2NlbnQ6XCJ+XCJ9LMS1OntjaGFyOlwialwiLGFjY2VudDpcIl5cIn0sxLQ6e2NoYXI6XCJKXCIsYWNjZW50OlwiXlwifSzFujp7Y2hhcjpcInpcIixhY2NlbnQ6XCLCtFwifSzFuTp7Y2hhcjpcIlpcIixhY2NlbnQ6XCLCtFwifSzFuzp7Y2hhcjpcIlpcIixhY2NlbnQ6XCJeXCJ9LMW8OntjaGFyOlwielwiLGFjY2VudDpcIl5cIn0sxb06e2NoYXI6XCJaXCIsYWNjZW50Olwiy4dcIn0sxb46e2NoYXI6XCJ6XCIsYWNjZW50Olwiy4dcIn0s4bqROntjaGFyOlwielwiLGFjY2VudDpcIsuGXCJ9fSxhPXtcIsK0XCI6XCJncmF2ZVwiLFwiYFwiOlwiYWN1dGVcIixcIl5cIjpcImhhdFwiLFwiflwiOlwidGlsZGVcIixcIsKoXCI6XCJkZG90XCIsXCLLmlwiOlwibWF0aHJpbmdcIixcIsuYXCI6XCJicmV2ZVwiLMuHOlwiY2hlY2tcIixcIsudXCI6XCJkZG90XCIsXCLLmVwiOlwiZG90XCIsXCItXCI6XCJiYXJcIizLhjpcImhhdFwiLFwiy5xcIjpcInRpbGRlXCJ9LG49e/CdkIA6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkIE6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkII6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkIM6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkIQ6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGJmXCJ9LM6VOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCFOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCGOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCHOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCIOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCJOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCKOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCLOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCMOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCNOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCOOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCPOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCQOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCROntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCSOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCTOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCUOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCVOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCWOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCXOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZ6GOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCYOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCZOntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn45cIjp7bGV0dGVyOlwiMFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+PXCI6e2xldHRlcjpcIjFcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fkFwiOntsZXR0ZXI6XCIyXCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5FcIjp7bGV0dGVyOlwiM1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+SXCI6e2xldHRlcjpcIjRcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fk1wiOntsZXR0ZXI6XCI1XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5RcIjp7bGV0dGVyOlwiNlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+VXCI6e2xldHRlcjpcIjdcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fllwiOntsZXR0ZXI6XCI4XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5dcIjp7bGV0dGVyOlwiOVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QtDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QtTp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Qtjp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Qtzp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QuDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QuTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Qujp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Quzp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QvDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0szpk6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkL06e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkL46e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkL86e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYA6e2xldHRlcjpcIk1cIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYE6e2xldHRlcjpcIk5cIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYI6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYM6e2xldHRlcjpcIlBcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYQ6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYU6e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYY6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYc6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYg6e2xldHRlcjpcIlVcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYk6e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYo6e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYs6e2xldHRlcjpcIlhcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYw6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkY06e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdlLg6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlLk6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEgjp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Uuzp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2UvDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2UvTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Uvjp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSNOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWAOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWBOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWCOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWDOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWEOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhiYlwifSzihJU6e2xldHRlcjpcIk5cIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYY6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGJiXCJ9LOKEmTp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSaOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhiYlwifSzihJ06e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYo6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYs6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYw6e2xldHRlcjpcIlVcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlY06e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlY46e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlY86e2xldHRlcjpcIlhcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlZA6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEpDp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+YXCI6e2xldHRlcjpcIjBcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fmVwiOntsZXR0ZXI6XCIxXCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn5pcIjp7bGV0dGVyOlwiMlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+bXCI6e2xldHRlcjpcIjNcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fnFwiOntsZXR0ZXI6XCI0XCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn51cIjp7bGV0dGVyOlwiNVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+eXCI6e2xldHRlcjpcIjZcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fn1wiOntsZXR0ZXI6XCI3XCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn6BcIjp7bGV0dGVyOlwiOFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+hXCI6e2xldHRlcjpcIjlcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdkpw6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZOQOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSsOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Snjp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkp86e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZOTOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSwOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSxOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2TlTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqI6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGNhbFwifSzihIs6e2xldHRlcjpcIkhcIixmb250Q21kOlwibWF0aGNhbFwifSzihJA6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKlOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Spjp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEkjp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdk5s6e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGNhbFwifSzihLM6e2xldHRlcjpcIk1cIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKpOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Sqjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdk546e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKrOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SrDp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEmzp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdlb06e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGNhbFwifSxcIuKEn1wiOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Srjp7bGV0dGVyOlwiU1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkq86e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKwOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SsTp7bGV0dGVyOlwiVlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrI6e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKzOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2StDp7bGV0dGVyOlwiWVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrU6e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZSEOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIU6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oStOntsZXR0ZXI6XCJDXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIc6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UiDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSJOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIo6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oSMOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEkTp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSNOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlI46e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ujzp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSQOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJE6e2xldHRlcjpcIk5cIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ukjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSTOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJQ6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oScOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJY6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ulzp7bGV0dGVyOlwiVFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSYOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJk6e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Umjp7bGV0dGVyOlwiV1wiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSbOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJw6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oSoOntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlqA6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aHNmXCJ9LM6ROntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZahOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhzZlwifSzOkjp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wojp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wozp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WpDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WpTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wpjp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wpzp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WqDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WqTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0syLc6e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqo6e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aHNmXCJ9LM6aOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZarOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZasOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZatOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZauOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZavOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZawOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZaxOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZayOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZazOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa0OntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa1OntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa2OntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa3OntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhzZlwifSzOpzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WuDp7bGV0dGVyOlwiWVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WuTp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2aqDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aqTp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aqjp7bGV0dGVyOlwiXFxcXEdhbW1hXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqrOntsZXR0ZXI6XCJcXFxcRGVsdGFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmqw6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmq06e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmq46e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmq86e2xldHRlcjpcIlxcXFxUaGV0YVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2asDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2asTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2asjp7bGV0dGVyOlwiXFxcXExhbWJkYVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aszp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atTp7bGV0dGVyOlwiXFxcXFBpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq2OntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq3OntsZXR0ZXI6XCJcXFxcUGlcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrg6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrk6e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmro6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrs6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrw6e2xldHRlcjpcIlVcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmr06e2xldHRlcjpcIlxcXFxQaGlcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmr46e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmr86e2xldHRlcjpcIlxcXFxQc2lcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdm4A6e2xldHRlcjpcIlxcXFxPbWVnYVwiLGZvbnRDbWQ6XCJtYXRodHRcIn19fX0sdD17fTtmdW5jdGlvbiByKGEpe3ZhciBuPXRbYV07aWYodm9pZCAwIT09bilyZXR1cm4gbi5leHBvcnRzO3ZhciBvPXRbYV09e2V4cG9ydHM6e319O3JldHVybiBlW2FdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHIpLG8uZXhwb3J0c312YXIgYT17fTtyZXR1cm4oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT1hO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTWF0aE1MVG9MYVRlWD12b2lkIDA7dmFyIHQ9cig4NjcyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIk1hdGhNTFRvTGFUZVhcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5NYXRoTUxUb0xhVGVYfX0pfSkoKSxhfSkoKSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLm1pbi5qcy5tYXAiLCJpbXBvcnQgeyBEZWZ1ZGRsZU1ldGFkYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBNZXRhZGF0YUV4dHJhY3RvciB7XG5cdHN0YXRpYyBleHRyYWN0KGRvYzogRG9jdW1lbnQsIHNjaGVtYU9yZ0RhdGE6IGFueSk6IERlZnVkZGxlTWV0YWRhdGEge1xuXHRcdGxldCBkb21haW4gPSAnJztcblx0XHRsZXQgdXJsID0gJyc7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gVHJ5IHRvIGdldCBVUkwgZnJvbSBkb2N1bWVudCBsb2NhdGlvblxuXHRcdFx0dXJsID0gZG9jLmxvY2F0aW9uPy5ocmVmIHx8ICcnO1xuXHRcdFx0XG5cdFx0XHQvLyBJZiBubyBVUkwgZnJvbSBsb2NhdGlvbiwgdHJ5IG90aGVyIHNvdXJjZXNcblx0XHRcdGlmICghdXJsKSB7XG5cdFx0XHRcdHVybCA9IHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6dXJsXCIpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJ0d2l0dGVyOnVybFwiKSB8fFxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAndXJsJykgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ21haW5FbnRpdHlPZlBhZ2UudXJsJykgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ21haW5FbnRpdHkudXJsJykgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ1dlYlNpdGUudXJsJykgfHxcblx0XHRcdFx0XHRkb2MucXVlcnlTZWxlY3RvcignbGlua1tyZWw9XCJjYW5vbmljYWxcIl0nKT8uZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1cmwpIHtcblx0XHRcdFx0ZG9tYWluID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCAnJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSWYgVVJMIHBhcnNpbmcgZmFpbHMsIHRyeSB0byBnZXQgZnJvbSBiYXNlIHRhZ1xuXHRcdFx0Y29uc3QgYmFzZVRhZyA9IGRvYy5xdWVyeVNlbGVjdG9yKCdiYXNlW2hyZWZdJyk7XG5cdFx0XHRpZiAoYmFzZVRhZykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHVybCA9IGJhc2VUYWcuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG5cdFx0XHRcdFx0ZG9tYWluID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCAnJyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBiYXNlIFVSTDonLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0aXRsZTogdGhpcy5nZXRUaXRsZShkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0ZGVzY3JpcHRpb246IHRoaXMuZ2V0RGVzY3JpcHRpb24oZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdGRvbWFpbixcblx0XHRcdGZhdmljb246IHRoaXMuZ2V0RmF2aWNvbihkb2MsIHVybCksXG5cdFx0XHRpbWFnZTogdGhpcy5nZXRJbWFnZShkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0cHVibGlzaGVkOiB0aGlzLmdldFB1Ymxpc2hlZChkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0YXV0aG9yOiB0aGlzLmdldEF1dGhvcihkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0c2l0ZTogdGhpcy5nZXRTaXRlKGRvYywgc2NoZW1hT3JnRGF0YSksXG5cdFx0XHRzY2hlbWFPcmdEYXRhLFxuXHRcdFx0d29yZENvdW50OiAwLFxuXHRcdFx0cGFyc2VUaW1lOiAwXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldEF1dGhvcihkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUuYXV0aG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2F1dGhvci5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwiYXV0aG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYnlsXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXV0aG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXV0aG9yTGlzdFwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImNvcHlyaWdodFwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdjb3B5cmlnaHRIb2xkZXIubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOnNpdGVfbmFtZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdwdWJsaXNoZXIubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3NvdXJjZU9yZ2FuaXphdGlvbi5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnaXNQYXJ0T2YubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwidHdpdHRlcjpjcmVhdG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXBwbGljYXRpb24tbmFtZVwiKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0U2l0ZShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3B1Ymxpc2hlci5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6c2l0ZV9uYW1lXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ1dlYlNpdGUubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3NvdXJjZU9yZ2FuaXphdGlvbi5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJjb3B5cmlnaHRcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnY29weXJpZ2h0SG9sZGVyLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdpc1BhcnRPZi5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJhcHBsaWNhdGlvbi1uYW1lXCIpIHx8XG5cdFx0XHR0aGlzLmdldEF1dGhvcihkb2MsIHNjaGVtYU9yZ0RhdGEpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRUaXRsZShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHJhd1RpdGxlID0gKFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJvZzp0aXRsZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInR3aXR0ZXI6dGl0bGVcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnaGVhZGxpbmUnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInRpdGxlXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUudGl0bGVcIikgfHxcblx0XHRcdGRvYy5xdWVyeVNlbGVjdG9yKCd0aXRsZScpPy50ZXh0Q29udGVudD8udHJpbSgpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGVhblRpdGxlKHJhd1RpdGxlLCB0aGlzLmdldFNpdGUoZG9jLCBzY2hlbWFPcmdEYXRhKSk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBjbGVhblRpdGxlKHRpdGxlOiBzdHJpbmcsIHNpdGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGlmICghdGl0bGUgfHwgIXNpdGVOYW1lKSByZXR1cm4gdGl0bGU7XG5cblx0XHQvLyBSZW1vdmUgc2l0ZSBuYW1lIGlmIGl0IGV4aXN0c1xuXHRcdGNvbnN0IHNpdGVOYW1lRXNjYXBlZCA9IHNpdGVOYW1lLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG5cdFx0Y29uc3QgcGF0dGVybnMgPSBbXG5cdFx0XHRgXFxcXHMqW1xcXFx8XFxcXC3igJPigJRdXFxcXHMqJHtzaXRlTmFtZUVzY2FwZWR9XFxcXHMqJGAsIC8vIFRpdGxlIHwgU2l0ZSBOYW1lXG5cdFx0XHRgXlxcXFxzKiR7c2l0ZU5hbWVFc2NhcGVkfVxcXFxzKltcXFxcfFxcXFwt4oCT4oCUXVxcXFxzKmAsIC8vIFNpdGUgTmFtZSB8IFRpdGxlXG5cdFx0XTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcblx0XHRcdGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnaScpO1xuXHRcdFx0aWYgKHJlZ2V4LnRlc3QodGl0bGUpKSB7XG5cdFx0XHRcdHRpdGxlID0gdGl0bGUucmVwbGFjZShyZWdleCwgJycpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGl0bGUudHJpbSgpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0RGVzY3JpcHRpb24oZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcImRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOmRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2Rlc2NyaXB0aW9uJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0d2l0dGVyOmRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUuZGVzY3JpcHRpb25cIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldEltYWdlKGRvYzogRG9jdW1lbnQsIHNjaGVtYU9yZ0RhdGE6IGFueSk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6aW1hZ2VcIikgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0d2l0dGVyOmltYWdlXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2ltYWdlLnVybCcpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUuaW1hZ2UuZnVsbFwiKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0RmF2aWNvbihkb2M6IERvY3VtZW50LCBiYXNlVXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGljb25Gcm9tTWV0YSA9IHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6aW1hZ2U6ZmF2aWNvblwiKTtcblx0XHRpZiAoaWNvbkZyb21NZXRhKSByZXR1cm4gaWNvbkZyb21NZXRhO1xuXG5cdFx0Y29uc3QgaWNvbkxpbmsgPSBkb2MucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPSdpY29uJ11cIik/LmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0aWYgKGljb25MaW5rKSByZXR1cm4gaWNvbkxpbms7XG5cblx0XHRjb25zdCBzaG9ydGN1dExpbmsgPSBkb2MucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPSdzaG9ydGN1dCBpY29uJ11cIik/LmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0aWYgKHNob3J0Y3V0TGluaykgcmV0dXJuIHNob3J0Y3V0TGluaztcblxuXHRcdC8vIE9ubHkgdHJ5IHRvIGNvbnN0cnVjdCBmYXZpY29uIFVSTCBpZiB3ZSBoYXZlIGEgdmFsaWQgYmFzZSBVUkxcblx0XHRpZiAoYmFzZVVybCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIG5ldyBVUkwoXCIvZmF2aWNvbi5pY29cIiwgYmFzZVVybCkuaHJlZjtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gY29uc3RydWN0IGZhdmljb24gVVJMOicsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldFB1Ymxpc2hlZChkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2RhdGVQdWJsaXNoZWQnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInB1Ymxpc2hEYXRlXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcImFydGljbGU6cHVibGlzaGVkX3RpbWVcIikgfHxcblx0XHRcdHRoaXMuZ2V0VGltZUVsZW1lbnQoZG9jKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmRhdGVcIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldE1ldGFDb250ZW50KGRvYzogRG9jdW1lbnQsIGF0dHI6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0Y29uc3Qgc2VsZWN0b3IgPSBgbWV0YVske2F0dHJ9XWA7XG5cdFx0Y29uc3QgZWxlbWVudCA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxuXHRcdFx0LmZpbmQoZWwgPT4gZWwuZ2V0QXR0cmlidXRlKGF0dHIpPy50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcblx0XHRjb25zdCBjb250ZW50ID0gZWxlbWVudCA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKT8udHJpbSgpID8/IFwiXCIgOiBcIlwiO1xuXHRcdHJldHVybiB0aGlzLmRlY29kZUhUTUxFbnRpdGllcyhjb250ZW50LCBkb2MpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0VGltZUVsZW1lbnQoZG9jOiBEb2N1bWVudCk6IHN0cmluZyB7XG5cdFx0Y29uc3Qgc2VsZWN0b3IgPSBgdGltZWA7XG5cdFx0Y29uc3QgZWxlbWVudCA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVswXTtcblx0XHRjb25zdCBjb250ZW50ID0gZWxlbWVudCA/IChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGV0aW1lXCIpPy50cmltKCkgPz8gZWxlbWVudC50ZXh0Q29udGVudD8udHJpbSgpID8/IFwiXCIpIDogXCJcIjtcblx0XHRyZXR1cm4gdGhpcy5kZWNvZGVIVE1MRW50aXRpZXMoY29udGVudCwgZG9jKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGRlY29kZUhUTUxFbnRpdGllcyh0ZXh0OiBzdHJpbmcsIGRvYzogRG9jdW1lbnQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHRleHRhcmVhID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdFx0dGV4dGFyZWEuaW5uZXJIVE1MID0gdGV4dDtcblx0XHRyZXR1cm4gdGV4dGFyZWEudmFsdWU7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRTY2hlbWFQcm9wZXJ0eShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnksIHByb3BlcnR5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuXHRcdGlmICghc2NoZW1hT3JnRGF0YSkgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuXHRcdGNvbnN0IHNlYXJjaFNjaGVtYSA9IChkYXRhOiBhbnksIHByb3BzOiBzdHJpbmdbXSwgZnVsbFBhdGg6IHN0cmluZywgaXNFeGFjdE1hdGNoOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZ1tdID0+IHtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHByb3BzLmxlbmd0aCA9PT0gMCA/IFtkYXRhXSA6IFtdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFByb3AgPSBwcm9wc1swXTtcblx0XHRcdFx0aWYgKC9eXFxbXFxkK1xcXSQvLnRlc3QoY3VycmVudFByb3ApKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludChjdXJyZW50UHJvcC5zbGljZSgxLCAtMSkpO1xuXHRcdFx0XHRcdGlmIChkYXRhW2luZGV4XSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNlYXJjaFNjaGVtYShkYXRhW2luZGV4XSwgcHJvcHMuc2xpY2UoMSksIGZ1bGxQYXRoLCBpc0V4YWN0TWF0Y2gpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwcm9wcy5sZW5ndGggPT09IDAgJiYgZGF0YS5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubWFwKFN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBkYXRhLmZsYXRNYXAoaXRlbSA9PiBzZWFyY2hTY2hlbWEoaXRlbSwgcHJvcHMsIGZ1bGxQYXRoLCBpc0V4YWN0TWF0Y2gpKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgW2N1cnJlbnRQcm9wLCAuLi5yZW1haW5pbmdQcm9wc10gPSBwcm9wcztcblx0XHRcdFxuXHRcdFx0aWYgKCFjdXJyZW50UHJvcCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSByZXR1cm4gW2RhdGFdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEubmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiBbZGF0YS5uYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLmhhc093blByb3BlcnR5KGN1cnJlbnRQcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gc2VhcmNoU2NoZW1hKGRhdGFbY3VycmVudFByb3BdLCByZW1haW5pbmdQcm9wcywgXG5cdFx0XHRcdFx0ZnVsbFBhdGggPyBgJHtmdWxsUGF0aH0uJHtjdXJyZW50UHJvcH1gIDogY3VycmVudFByb3AsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzRXhhY3RNYXRjaCkge1xuXHRcdFx0XHRjb25zdCBuZXN0ZWRSZXN1bHRzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBkYXRhW2tleV0gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gc2VhcmNoU2NoZW1hKGRhdGFba2V5XSwgcHJvcHMsIFxuXHRcdFx0XHRcdFx0XHRmdWxsUGF0aCA/IGAke2Z1bGxQYXRofS4ke2tleX1gIDoga2V5LCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRuZXN0ZWRSZXN1bHRzLnB1c2goLi4ucmVzdWx0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuZXN0ZWRSZXN1bHRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmVzdGVkUmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRsZXQgcmVzdWx0cyA9IHNlYXJjaFNjaGVtYShzY2hlbWFPcmdEYXRhLCBwcm9wZXJ0eS5zcGxpdCgnLicpLCAnJywgdHJ1ZSk7XG5cdFx0XHRpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmVzdWx0cyA9IHNlYXJjaFNjaGVtYShzY2hlbWFPcmdEYXRhLCBwcm9wZXJ0eS5zcGxpdCgnLicpLCAnJywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPiAwID8gcmVzdWx0cy5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKSA6IGRlZmF1bHRWYWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLmRlY29kZUhUTUxFbnRpdGllcyhyZXN1bHQsIGRvYyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGdldFNjaGVtYVByb3BlcnR5IGZvciAke3Byb3BlcnR5fTpgLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBleHRyYWN0U2NoZW1hT3JnRGF0YShkb2M6IERvY3VtZW50KTogYW55IHtcblx0XHRjb25zdCBzY2hlbWFTY3JpcHRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFt0eXBlPVwiYXBwbGljYXRpb24vbGQranNvblwiXScpO1xuXHRcdGNvbnN0IHNjaGVtYURhdGE6IGFueVtdID0gW107XG5cblx0XHRzY2hlbWFTY3JpcHRzLmZvckVhY2goc2NyaXB0ID0+IHtcblx0XHRcdGxldCBqc29uQ29udGVudCA9IHNjcmlwdC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvbkNvbnRlbnQgPSBqc29uQ29udGVudFxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfF5cXHMqXFwvXFwvLiokL2dtLCAnJylcblx0XHRcdFx0XHQucmVwbGFjZSgvXlxccyo8IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXFxdXFxdPlxccyokLywgJyQxJylcblx0XHRcdFx0XHQucmVwbGFjZSgvXlxccyooXFwqXFwvfFxcL1xcKilcXHMqfFxccyooXFwqXFwvfFxcL1xcKilcXHMqJC9nLCAnJylcblx0XHRcdFx0XHQudHJpbSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoanNvbkNvbnRlbnQpO1xuXG5cdFx0XHRcdGlmIChqc29uRGF0YVsnQGdyYXBoJ10gJiYgQXJyYXkuaXNBcnJheShqc29uRGF0YVsnQGdyYXBoJ10pKSB7XG5cdFx0XHRcdFx0c2NoZW1hRGF0YS5wdXNoKC4uLmpzb25EYXRhWydAZ3JhcGgnXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2NoZW1hRGF0YS5wdXNoKGpzb25EYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzY2hlbWEub3JnIGRhdGE6JywgZXJyb3IpO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdQcm9ibGVtYXRpYyBKU09OIGNvbnRlbnQ6JywganNvbkNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNjaGVtYURhdGE7XG5cdH1cbn0iLCJpbXBvcnQgeyBNZXRhZGF0YUV4dHJhY3RvciB9IGZyb20gJy4vbWV0YWRhdGEnO1xuaW1wb3J0IHsgRGVmdWRkbGVPcHRpb25zLCBEZWZ1ZGRsZVJlc3BvbnNlLCBEZWZ1ZGRsZU1ldGFkYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBcblx0SElEREVOX0VMRU1FTlRfU0VMRUNUT1JTLFxuXHRNT0JJTEVfV0lEVEgsXG5cdEJMT0NLX0VMRU1FTlRTLFxuXHRQUkVTRVJWRV9FTEVNRU5UUyxcblx0SU5MSU5FX0VMRU1FTlRTLFxuXHRTVVBQT1JURURfTEFOR1VBR0VTLFxuXHRBTExPV0VEX0FUVFJJQlVURVMsXG5cdEFMTE9XRURfQVRUUklCVVRFU19ERUJVRyxcblx0RVhBQ1RfU0VMRUNUT1JTLFxuXHRQQVJUSUFMX1NFTEVDVE9SUyxcblx0Rk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMsXG5cdEZPT1ROT1RFX0lOTElORV9SRUZFUkVOQ0VTLFxuXHRFTlRSWV9QT0lOVF9FTEVNRU5UUyxcblx0QUxMT1dFRF9FTVBUWV9FTEVNRU5UU1xufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBtYXRoU3RhbmRhcmRpemF0aW9uUnVsZXMgfSBmcm9tICcuL21hdGgnO1xuXG4vLyBFbGVtZW50IHN0YW5kYXJkaXphdGlvbiBydWxlc1xuLy8gTWFwcyBzZWxlY3RvcnMgdG8gdGhlaXIgdGFyZ2V0IEhUTUwgZWxlbWVudCBuYW1lXG5pbnRlcmZhY2UgU3RhbmRhcmRpemF0aW9uUnVsZSB7XG5cdHNlbGVjdG9yOiBzdHJpbmc7XG5cdGVsZW1lbnQ6IHN0cmluZztcblx0dHJhbnNmb3JtPzogKGVsOiBFbGVtZW50KSA9PiBFbGVtZW50O1xufVxuXG5jb25zdCBFTEVNRU5UX1NUQU5EQVJESVpBVElPTl9SVUxFUzogU3RhbmRhcmRpemF0aW9uUnVsZVtdID0gW1xuXHQvLyBNYXRoIGVsZW1lbnRzXG5cdC4uLm1hdGhTdGFuZGFyZGl6YXRpb25SdWxlcyxcblx0Ly8gQ29kZSBibG9ja3Ncblx0e1xuXHRcdHNlbGVjdG9yOiAncHJlJyxcblx0XHRlbGVtZW50OiAncHJlJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBlbDtcblxuXHRcdFx0Ly8gRnVuY3Rpb24gdG8gZ2V0IGxhbmd1YWdlIGZyb20gY2xhc3Ncblx0XHRcdGNvbnN0IGdldExhbmd1YWdlRnJvbUNsYXNzID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogc3RyaW5nID0+IHtcblx0XHRcdFx0Ly8gQ2hlY2sgZGF0YS1sYW5nIGF0dHJpYnV0ZSBmaXJzdFxuXHRcdFx0XHRjb25zdCBkYXRhTGFuZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWxhbmcnKTtcblx0XHRcdFx0aWYgKGRhdGFMYW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGFMYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEZWZpbmUgbGFuZ3VhZ2UgcGF0dGVybnNcblx0XHRcdFx0Y29uc3QgbGFuZ3VhZ2VQYXR0ZXJucyA9IFtcblx0XHRcdFx0XHQvXmxhbmd1YWdlLShcXHcrKSQvLCAgICAgICAgICAvLyBsYW5ndWFnZS1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15sYW5nLShcXHcrKSQvLCAgICAgICAgICAgICAgLy8gbGFuZy1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L14oXFx3KyktY29kZSQvLCAgICAgICAgICAgICAgLy8gamF2YXNjcmlwdC1jb2RlXG5cdFx0XHRcdFx0L15jb2RlLShcXHcrKSQvLCAgICAgICAgICAgICAgLy8gY29kZS1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15zeW50YXgtKFxcdyspJC8sICAgICAgICAgICAgLy8gc3ludGF4LWphdmFzY3JpcHRcblx0XHRcdFx0XHQvXmNvZGUtc25pcHBldF9fKFxcdyspJC8sICAgICAvLyBjb2RlLXNuaXBwZXRfX2phdmFzY3JpcHRcblx0XHRcdFx0XHQvXmhpZ2hsaWdodC0oXFx3KykkLywgICAgICAgICAvLyBoaWdobGlnaHQtamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9eKFxcdyspLXNuaXBwZXQkLyAgICAgICAgICAgIC8vIGphdmFzY3JpcHQtc25pcHBldFxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdC8vIFRoZW4gY2hlY2sgdGhlIGNsYXNzIGF0dHJpYnV0ZSBmb3IgcGF0dGVybnNcblx0XHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NOYW1lICYmIHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ3VhZ2VQYXR0ZXJucykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBlbGVtZW50LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKHBhdHRlcm4pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBUaGVuIGNoZWNrIGZvciBzdXBwb3J0ZWQgbGFuZ3VhZ2Vcblx0XHRcdFx0XHRpZiAoU1VQUE9SVEVEX0xBTkdVQUdFUy5oYXMoZWxlbWVudC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZXMgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2xhc3NMaXN0KTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXR0ZXJucyBmaXJzdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgcGF0dGVybiBvZiBsYW5ndWFnZVBhdHRlcm5zKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGNsYXNzTmFtZS5tYXRjaChwYXR0ZXJuKTtcblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPbmx5IGNoZWNrIGJhcmUgbGFuZ3VhZ2UgbmFtZXMgaWYgbm8gcGF0dGVybnMgd2VyZSBmb3VuZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG5cdFx0XHRcdFx0aWYgKFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKGNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH07XG5cblx0XHRcdC8vIFRyeSB0byBnZXQgdGhlIGxhbmd1YWdlIGZyb20gdGhlIGVsZW1lbnQgYW5kIGl0cyBhbmNlc3RvcnNcblx0XHRcdGxldCBsYW5ndWFnZSA9ICcnO1xuXHRcdFx0bGV0IGN1cnJlbnRFbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwgPSBlbDtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGN1cnJlbnRFbGVtZW50ICYmICFsYW5ndWFnZSkge1xuXHRcdFx0XHRsYW5ndWFnZSA9IGdldExhbmd1YWdlRnJvbUNsYXNzKGN1cnJlbnRFbGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFsc28gY2hlY2sgZm9yIGNvZGUgZWxlbWVudHMgd2l0aGluIHRoZSBjdXJyZW50IGVsZW1lbnRcblx0XHRcdFx0aWYgKCFsYW5ndWFnZSAmJiBjdXJyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJykpIHtcblx0XHRcdFx0XHRsYW5ndWFnZSA9IGdldExhbmd1YWdlRnJvbUNsYXNzKGN1cnJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKSEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZ1bmN0aW9uIHRvIHJlY3Vyc2l2ZWx5IGV4dHJhY3QgdGV4dCBjb250ZW50IHdoaWxlIHByZXNlcnZpbmcgc3RydWN0dXJlXG5cdFx0XHRjb25zdCBleHRyYWN0U3RydWN0dXJlZFRleHQgPSAoZWxlbWVudDogTm9kZSk6IHN0cmluZyA9PiB7XG5cdFx0XHRcdGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50LnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgdGV4dCA9ICcnO1xuXHRcdFx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGxpbmUgYnJlYWtzXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0JSJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuICdcXG4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBIYW5kbGUgY29kZSBlbGVtZW50cyBhbmQgdGhlaXIgY2hpbGRyZW5cblx0XHRcdFx0XHRlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdFx0XHR0ZXh0ICs9IGV4dHJhY3RTdHJ1Y3R1cmVkVGV4dChjaGlsZCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQWRkIG5ld2xpbmUgYWZ0ZXIgZWFjaCBjb2RlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQ09ERScpIHtcblx0XHRcdFx0XHRcdHRleHQgKz0gJ1xcbic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRXh0cmFjdCBhbGwgdGV4dCBjb250ZW50XG5cdFx0XHRsZXQgY29kZUNvbnRlbnQgPSBleHRyYWN0U3RydWN0dXJlZFRleHQoZWwpO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgY29udGVudFxuXHRcdFx0Y29kZUNvbnRlbnQgPSBjb2RlQ29udGVudFxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IGV4dHJhIG5ld2xpbmVzIGF0IHRoZSBzdGFydFxuXHRcdFx0XHQucmVwbGFjZSgvXlxcbisvLCAnJylcblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSBleHRyYSBuZXdsaW5lcyBhdCB0aGUgZW5kXG5cdFx0XHRcdC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuXHRcdFx0XHQvLyBSZXBsYWNlIG11bHRpcGxlIGNvbnNlY3V0aXZlIG5ld2xpbmVzIHdpdGggYSBzaW5nbGUgbmV3bGluZVxuXHRcdFx0XHQucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJyk7XG5cblx0XHRcdC8vIENyZWF0ZSBuZXcgcHJlIGVsZW1lbnRcblx0XHRcdGNvbnN0IG5ld1ByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXHRcdFx0XG5cdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlc1xuXHRcdFx0QXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0bmV3UHJlLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGNvZGUgZWxlbWVudFxuXHRcdFx0Y29uc3QgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcblx0XHRcdGlmIChsYW5ndWFnZSkge1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5nJywgbGFuZ3VhZ2UpO1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcblx0XHRcdH1cblx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBjb2RlQ29udGVudDtcblx0XHRcdFxuXHRcdFx0bmV3UHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuXHRcdFx0cmV0dXJuIG5ld1ByZTtcblx0XHR9XG5cdH0sXG5cdC8vIFNpbXBsaWZ5IGhlYWRpbmdzIGJ5IHJlbW92aW5nIGludGVybmFsIG5hdmlnYXRpb24gZWxlbWVudHNcblx0e1xuXHRcdHNlbGVjdG9yOiAnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicsXG5cdFx0ZWxlbWVudDogJ2tlZXAnLFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHQvLyBJZiBoZWFkaW5nIG9ubHkgY29udGFpbnMgYSBzaW5nbGUgYW5jaG9yIHdpdGggaW50ZXJuYWwgbGlua1xuXHRcdFx0aWYgKGVsLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBcblx0XHRcdFx0ZWwuZmlyc3RFbGVtZW50Q2hpbGQ/LnRhZ05hbWUgPT09ICdBJyAmJlxuXHRcdFx0XHQoZWwuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0QXR0cmlidXRlKCdocmVmJyk/LmluY2x1ZGVzKCcjJykgfHwgXG5cdFx0XHRcdCBlbC5maXJzdEVsZW1lbnRDaGlsZC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKT8uc3RhcnRzV2l0aCgnIycpKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ3JlYXRlIG5ldyBoZWFkaW5nIG9mIHNhbWUgbGV2ZWxcblx0XHRcdFx0Y29uc3QgbmV3SGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwudGFnTmFtZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlcyBmcm9tIG9yaWdpbmFsIGhlYWRpbmdcblx0XHRcdFx0QXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRcdGlmIChBTExPV0VEX0FUVFJJQlVURVMuaGFzKGF0dHIubmFtZSkpIHtcblx0XHRcdFx0XHRcdG5ld0hlYWRpbmcuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEp1c3QgdXNlIHRoZSB0ZXh0IGNvbnRlbnRcblx0XHRcdFx0bmV3SGVhZGluZy50ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3SGVhZGluZztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSWYgaGVhZGluZyBjb250YWlucyBuYXZpZ2F0aW9uIGJ1dHRvbnMgb3Igb3RoZXIgdXRpbGl0eSBlbGVtZW50c1xuXHRcdFx0Y29uc3QgYnV0dG9ucyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuXHRcdFx0aWYgKGJ1dHRvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCBuZXdIZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC50YWdOYW1lKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENvcHkgYWxsb3dlZCBhdHRyaWJ1dGVzXG5cdFx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRuZXdIZWFkaW5nLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBKdXN0IHVzZSB0aGUgdGV4dCBjb250ZW50XG5cdFx0XHRcdG5ld0hlYWRpbmcudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ld0hlYWRpbmc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBlbDtcblx0XHR9XG5cdH0sXG5cdC8vIENvbnZlcnQgZGl2cyB3aXRoIHBhcmFncmFwaCByb2xlIHRvIGFjdHVhbCBwYXJhZ3JhcGhzXG5cdHsgXG5cdFx0c2VsZWN0b3I6ICdkaXZbZGF0YS10ZXN0aWRePVwicGFyYWdyYXBoXCJdLCBkaXZbcm9sZT1cInBhcmFncmFwaFwiXScsIFxuXHRcdGVsZW1lbnQ6ICdwJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29weSBpbm5lckhUTUxcblx0XHRcdHAuaW5uZXJIVE1MID0gZWwuaW5uZXJIVE1MO1xuXHRcdFx0XG5cdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlc1xuXHRcdFx0QXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0cC5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBwO1xuXHRcdH1cblx0fSxcblx0Ly8gQ29udmVydCBkaXZzIHdpdGggbGlzdCByb2xlcyB0byBhY3R1YWwgbGlzdHNcblx0eyBcblx0XHRzZWxlY3RvcjogJ2Rpdltyb2xlPVwibGlzdFwiXScsIFxuXHRcdGVsZW1lbnQ6ICd1bCcsXG5cdFx0Ly8gQ3VzdG9tIGhhbmRsZXIgZm9yIGxpc3QgdHlwZSBkZXRlY3Rpb24gYW5kIHRyYW5zZm9ybWF0aW9uXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdC8vIEZpcnN0IGRldGVybWluZSBpZiB0aGlzIGlzIGFuIG9yZGVyZWQgbGlzdFxuXHRcdFx0Y29uc3QgZmlyc3RJdGVtID0gZWwucXVlcnlTZWxlY3RvcignZGl2W3JvbGU9XCJsaXN0aXRlbVwiXSAubGFiZWwnKTtcblx0XHRcdGNvbnN0IGxhYmVsID0gZmlyc3RJdGVtPy50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0Y29uc3QgaXNPcmRlcmVkID0gbGFiZWwubWF0Y2goL15cXGQrXFwpLyk7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgbGlzdCB0eXBlXG5cdFx0XHRjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpc09yZGVyZWQgPyAnb2wnIDogJ3VsJyk7XG5cdFx0XHRcblx0XHRcdC8vIFByb2Nlc3MgZWFjaCBsaXN0IGl0ZW1cblx0XHRcdGNvbnN0IGl0ZW1zID0gZWwucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJsaXN0aXRlbVwiXScpO1xuXHRcdFx0aXRlbXMuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdFx0Y29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gaXRlbS5xdWVyeVNlbGVjdG9yKCcuY29udGVudCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNvbnRlbnQpIHtcblx0XHRcdFx0XHQvLyBDb252ZXJ0IGFueSBwYXJhZ3JhcGggZGl2cyBpbnNpZGUgY29udGVudFxuXHRcdFx0XHRcdGNvbnN0IHBhcmFncmFwaERpdnMgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdltyb2xlPVwicGFyYWdyYXBoXCJdJyk7XG5cdFx0XHRcdFx0cGFyYWdyYXBoRGl2cy5mb3JFYWNoKGRpdiA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRcdFx0cC5pbm5lckhUTUwgPSBkaXYuaW5uZXJIVE1MO1xuXHRcdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKHApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIENvbnZlcnQgYW55IG5lc3RlZCBsaXN0cyByZWN1cnNpdmVseVxuXHRcdFx0XHRcdGNvbnN0IG5lc3RlZExpc3RzID0gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cImxpc3RcIl0nKTtcblx0XHRcdFx0XHRuZXN0ZWRMaXN0cy5mb3JFYWNoKG5lc3RlZExpc3QgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZmlyc3ROZXN0ZWRJdGVtID0gbmVzdGVkTGlzdC5xdWVyeVNlbGVjdG9yKCdkaXZbcm9sZT1cImxpc3RpdGVtXCJdIC5sYWJlbCcpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkTGFiZWwgPSBmaXJzdE5lc3RlZEl0ZW0/LnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHRcdFx0XHRjb25zdCBpc05lc3RlZE9yZGVyZWQgPSBuZXN0ZWRMYWJlbC5tYXRjaCgvXlxcZCtcXCkvKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3QgbmV3TmVzdGVkTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXNOZXN0ZWRPcmRlcmVkID8gJ29sJyA6ICd1bCcpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBQcm9jZXNzIG5lc3RlZCBpdGVtc1xuXHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkSXRlbXMgPSBuZXN0ZWRMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0nKTtcblx0XHRcdFx0XHRcdG5lc3RlZEl0ZW1zLmZvckVhY2gobmVzdGVkSXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZExpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkQ29udGVudCA9IG5lc3RlZEl0ZW0ucXVlcnlTZWxlY3RvcignLmNvbnRlbnQnKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChuZXN0ZWRDb250ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29udmVydCBwYXJhZ3JhcGggZGl2cyBpbiBuZXN0ZWQgaXRlbXNcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBuZXN0ZWRQYXJhZ3JhcGhzID0gbmVzdGVkQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cInBhcmFncmFwaFwiXScpO1xuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZFBhcmFncmFwaHMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0XHRcdFx0XHRcdHAuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChwKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWRMaS5pbm5lckhUTUwgPSBuZXN0ZWRDb250ZW50LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0bmV3TmVzdGVkTGlzdC5hcHBlbmRDaGlsZChuZXN0ZWRMaSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0bmVzdGVkTGlzdC5yZXBsYWNlV2l0aChuZXdOZXN0ZWRMaXN0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRsaS5pbm5lckhUTUwgPSBjb250ZW50LmlubmVySFRNTDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0bGlzdC5hcHBlbmRDaGlsZChsaSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXHR9LFxuXHR7IFxuXHRcdHNlbGVjdG9yOiAnZGl2W3JvbGU9XCJsaXN0aXRlbVwiXScsIFxuXHRcdGVsZW1lbnQ6ICdsaScsXG5cdFx0Ly8gQ3VzdG9tIGhhbmRsZXIgZm9yIGxpc3QgaXRlbSBjb250ZW50XG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBlbC5xdWVyeVNlbGVjdG9yKCcuY29udGVudCcpO1xuXHRcdFx0aWYgKCFjb250ZW50KSByZXR1cm4gZWw7XG5cdFx0XHRcblx0XHRcdC8vIENvbnZlcnQgYW55IHBhcmFncmFwaCBkaXZzIGluc2lkZSBjb250ZW50XG5cdFx0XHRjb25zdCBwYXJhZ3JhcGhEaXZzID0gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cInBhcmFncmFwaFwiXScpO1xuXHRcdFx0cGFyYWdyYXBoRGl2cy5mb3JFYWNoKGRpdiA9PiB7XG5cdFx0XHRcdGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdHAuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDtcblx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKHApO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdH1cblx0fSxcblx0Ly8gQ29kZSBibG9ja3Mgd2l0aCBzeW50YXggaGlnaGxpZ2h0aW5nXG5cdHtcblx0XHRzZWxlY3RvcjogJy53cC1ibG9jay1zeW50YXhoaWdobGlnaHRlci1jb2RlLCAuc3ludGF4aGlnaGxpZ2h0ZXIsIC5oaWdobGlnaHQsIC5oaWdobGlnaHQtc291cmNlLCAud3AtYmxvY2stY29kZSwgcHJlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgcHJlW2NsYXNzKj1cImJydXNoOlwiXScsXG5cdFx0ZWxlbWVudDogJ3ByZScsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIENyZWF0ZSBuZXcgcHJlIGVsZW1lbnRcblx0XHRcdGNvbnN0IG5ld1ByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXHRcdFx0XG5cdFx0XHQvLyBUcnkgdG8gZGV0ZWN0IGxhbmd1YWdlXG5cdFx0XHRsZXQgbGFuZ3VhZ2UgPSAnJztcblx0XHRcdFxuXHRcdFx0Ly8gQ2hlY2sgZm9yIFdvcmRQcmVzcyBzeW50YXggaGlnaGxpZ2h0ZXIgc3BlY2lmaWMgZm9ybWF0XG5cdFx0XHRjb25zdCBzeW50YXhFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zeW50YXhoaWdobGlnaHRlcicpO1xuXHRcdFx0aWYgKHN5bnRheEVsKSB7XG5cdFx0XHRcdC8vIEdldCBsYW5ndWFnZSBmcm9tIHN5bnRheGhpZ2hsaWdodGVyIGNsYXNzXG5cdFx0XHRcdGNvbnN0IGNsYXNzZXMgPSBBcnJheS5mcm9tKHN5bnRheEVsLmNsYXNzTGlzdCk7XG5cdFx0XHRcdGNvbnN0IGxhbmdDbGFzcyA9IGNsYXNzZXMuZmluZChjID0+ICFbJ3N5bnRheGhpZ2hsaWdodGVyJywgJ25vZ3V0dGVyJ10uaW5jbHVkZXMoYykpO1xuXHRcdFx0XHRpZiAobGFuZ0NsYXNzICYmIFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKGxhbmdDbGFzcy50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0XHRcdGxhbmd1YWdlID0gbGFuZ0NsYXNzLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm8gbGFuZ3VhZ2UgZm91bmQgeWV0LCBjaGVjayBvdGhlciBjb21tb24gcGF0dGVybnNcblx0XHRcdGlmICghbGFuZ3VhZ2UpIHtcblx0XHRcdFx0Y29uc3QgY2xhc3NOYW1lcyA9IEFycmF5LmZyb20oZWwuY2xhc3NMaXN0KTtcblx0XHRcdFx0Y29uc3QgbGFuZ3VhZ2VQYXR0ZXJucyA9IFtcblx0XHRcdFx0XHQvKD86XnxcXHMpKD86bGFuZ3VhZ2V8bGFuZ3xicnVzaHxzeW50YXgpLShcXHcrKSg/Olxcc3wkKS9pLFxuXHRcdFx0XHRcdC8oPzpefFxccykoXFx3KykoPzpcXHN8JCkvaVxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ3VhZ2VQYXR0ZXJucykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBjbGFzc05hbWUubWF0Y2gocGF0dGVybik7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2ggJiYgbWF0Y2hbMV0gJiYgU1VQUE9SVEVEX0xBTkdVQUdFUy5oYXMobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRcdFx0bGFuZ3VhZ2UgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxhbmd1YWdlKSBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBFeHRyYWN0IGNvZGUgY29udGVudCwgaGFuZGxpbmcgdmFyaW91cyBmb3JtYXRzXG5cdFx0XHRsZXQgY29kZUNvbnRlbnQgPSAnJztcblxuXHRcdFx0Ly8gSGFuZGxlIFdvcmRQcmVzcyBzeW50YXggaGlnaGxpZ2h0ZXIgdGFibGUgZm9ybWF0XG5cdFx0XHRjb25zdCBjb2RlQ29udGFpbmVyID0gZWwucXVlcnlTZWxlY3RvcignLnN5bnRheGhpZ2hsaWdodGVyIHRhYmxlIC5jb2RlIC5jb250YWluZXInKTtcblx0XHRcdGlmIChjb2RlQ29udGFpbmVyKSB7XG5cdFx0XHRcdC8vIFByb2Nlc3MgZWFjaCBsaW5lXG5cdFx0XHRcdGNvbnN0IGxpbmVzID0gQXJyYXkuZnJvbShjb2RlQ29udGFpbmVyLmNoaWxkcmVuKTtcblx0XHRcdFx0Y29kZUNvbnRlbnQgPSBsaW5lc1xuXHRcdFx0XHRcdC5tYXAobGluZSA9PiB7XG5cdFx0XHRcdFx0XHQvLyBHZXQgYWxsIGNvZGUgZWxlbWVudHMgaW4gdGhpcyBsaW5lXG5cdFx0XHRcdFx0XHRjb25zdCBjb2RlUGFydHMgPSBBcnJheS5mcm9tKGxpbmUucXVlcnlTZWxlY3RvckFsbCgnY29kZScpKVxuXHRcdFx0XHRcdFx0XHQubWFwKGNvZGUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgdGV4dCBjb250ZW50LCBwcmVzZXJ2aW5nIHNwYWNlc1xuXHRcdFx0XHRcdFx0XHRcdGxldCB0ZXh0ID0gY29kZS50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGlzIGlzIGEgJ3NwYWNlcycgY2xhc3MgZWxlbWVudCwgY29udmVydCB0byBhY3R1YWwgc3BhY2VzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNvZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdzcGFjZXMnKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9ICcgJy5yZXBlYXQodGV4dC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGV4dDtcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0LmpvaW4oJycpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvZGVQYXJ0cyB8fCBsaW5lLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmpvaW4oJ1xcbicpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGFuZGxlIFdvcmRQcmVzcyBzeW50YXggaGlnaGxpZ2h0ZXIgbm9uLXRhYmxlIGZvcm1hdFxuXHRcdFx0XHRjb25zdCBjb2RlTGluZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcuY29kZSAubGluZScpO1xuXHRcdFx0XHRpZiAoY29kZUxpbmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb2RlQ29udGVudCA9IEFycmF5LmZyb20oY29kZUxpbmVzKVxuXHRcdFx0XHRcdFx0Lm1hcChsaW5lID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY29kZVBhcnRzID0gQXJyYXkuZnJvbShsaW5lLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvZGUnKSlcblx0XHRcdFx0XHRcdFx0XHQubWFwKGNvZGUgPT4gY29kZS50ZXh0Q29udGVudCB8fCAnJylcblx0XHRcdFx0XHRcdFx0XHQuam9pbignJyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb2RlUGFydHMgfHwgbGluZS50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuam9pbignXFxuJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gcmVndWxhciB0ZXh0IGNvbnRlbnRcblx0XHRcdFx0XHRjb2RlQ29udGVudCA9IGVsLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFuIHVwIHRoZSBjb250ZW50XG5cdFx0XHRjb2RlQ29udGVudCA9IGNvZGVDb250ZW50XG5cdFx0XHRcdC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykgLy8gVHJpbSBzdGFydC9lbmQgd2hpdGVzcGFjZVxuXHRcdFx0XHQucmVwbGFjZSgvXFx0L2csICcgICAgJykgLy8gQ29udmVydCB0YWJzIHRvIHNwYWNlc1xuXHRcdFx0XHQucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJykgLy8gTm9ybWFsaXplIG11bHRpcGxlIG5ld2xpbmVzXG5cdFx0XHRcdC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7IC8vIFJlcGxhY2Ugbm9uLWJyZWFraW5nIHNwYWNlcyB3aXRoIHJlZ3VsYXIgc3BhY2VzXG5cblx0XHRcdC8vIENyZWF0ZSBjb2RlIGVsZW1lbnQgd2l0aCBsYW5ndWFnZSBjbGFzcyBpZiBkZXRlY3RlZFxuXHRcdFx0Y29uc3QgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcblx0XHRcdGlmIChsYW5ndWFnZSkge1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5nJywgbGFuZ3VhZ2UpO1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcblx0XHRcdH1cblx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBjb2RlQ29udGVudDtcblx0XHRcdFxuXHRcdFx0bmV3UHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuXHRcdFx0cmV0dXJuIG5ld1ByZTtcblx0XHR9XG5cdH1cbl07XG5cbmludGVyZmFjZSBGb290bm90ZURhdGEge1xuXHRjb250ZW50OiBFbGVtZW50IHwgc3RyaW5nO1xuXHRvcmlnaW5hbElkOiBzdHJpbmc7XG5cdHJlZnM6IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgRm9vdG5vdGVDb2xsZWN0aW9uIHtcblx0W2Zvb3Rub3RlTnVtYmVyOiBudW1iZXJdOiBGb290bm90ZURhdGE7XG59XG5cbmludGVyZmFjZSBDb250ZW50U2NvcmUge1xuXHRzY29yZTogbnVtYmVyO1xuXHRlbGVtZW50OiBFbGVtZW50O1xufVxuXG5pbnRlcmZhY2UgU3R5bGVDaGFuZ2Uge1xuXHRzZWxlY3Rvcjogc3RyaW5nO1xuXHRzdHlsZXM6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIERlZnVkZGxlIHtcblx0cHJpdmF0ZSBkb2M6IERvY3VtZW50O1xuXHRwcml2YXRlIG9wdGlvbnM6IERlZnVkZGxlT3B0aW9ucztcblx0cHJpdmF0ZSBkZWJ1ZzogYm9vbGVhbjtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IERlZnVkZGxlIGluc3RhbmNlXG5cdCAqIEBwYXJhbSBkb2MgLSBUaGUgZG9jdW1lbnQgdG8gcGFyc2Vcblx0ICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBwYXJzaW5nXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihkb2M6IERvY3VtZW50LCBvcHRpb25zOiBEZWZ1ZGRsZU9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuZG9jID0gZG9jO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWcgfHwgZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2UgdGhlIGRvY3VtZW50IGFuZCBleHRyYWN0IGl0cyBtYWluIGNvbnRlbnRcblx0ICovXG5cdHBhcnNlKCk6IERlZnVkZGxlUmVzcG9uc2Uge1xuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0Ly8gRXh0cmFjdCBtZXRhZGF0YSBmaXJzdCBzaW5jZSB3ZSdsbCBuZWVkIGl0IGluIG11bHRpcGxlIHBsYWNlc1xuXHRcdGNvbnN0IHNjaGVtYU9yZ0RhdGEgPSBNZXRhZGF0YUV4dHJhY3Rvci5leHRyYWN0U2NoZW1hT3JnRGF0YSh0aGlzLmRvYyk7XG5cdFx0Y29uc3QgbWV0YWRhdGEgPSBNZXRhZGF0YUV4dHJhY3Rvci5leHRyYWN0KHRoaXMuZG9jLCBzY2hlbWFPcmdEYXRhKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBFdmFsdWF0ZSBzdHlsZXMgYW5kIHNpemVzIG9uIG9yaWdpbmFsIGRvY3VtZW50XG5cdFx0XHRjb25zdCBtb2JpbGVTdHlsZXMgPSB0aGlzLl9ldmFsdWF0ZU1lZGlhUXVlcmllcyh0aGlzLmRvYyk7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBzbWFsbCBpbWFnZXMgaW4gb3JpZ2luYWwgZG9jdW1lbnQsIGV4Y2x1ZGluZyBsYXp5LWxvYWRlZCBvbmVzXG5cdFx0XHRjb25zdCBzbWFsbEltYWdlcyA9IHRoaXMuZmluZFNtYWxsSW1hZ2VzKHRoaXMuZG9jKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2xvbmUgZG9jdW1lbnRcblx0XHRcdGNvbnN0IGNsb25lID0gdGhpcy5kb2MuY2xvbmVOb2RlKHRydWUpIGFzIERvY3VtZW50O1xuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSBtb2JpbGUgc3R5bGUgdG8gY2xvbmVcblx0XHRcdHRoaXMuYXBwbHlNb2JpbGVTdHlsZXMoY2xvbmUsIG1vYmlsZVN0eWxlcyk7XG5cblx0XHRcdC8vIEZpbmQgbWFpbiBjb250ZW50XG5cdFx0XHRjb25zdCBtYWluQ29udGVudCA9IHRoaXMuZmluZE1haW5Db250ZW50KGNsb25lKTtcblx0XHRcdGlmICghbWFpbkNvbnRlbnQpIHtcblx0XHRcdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbnRlbnQ6IHRoaXMuZG9jLmJvZHkuaW5uZXJIVE1MLFxuXHRcdFx0XHRcdC4uLm1ldGFkYXRhLFxuXHRcdFx0XHRcdHdvcmRDb3VudDogdGhpcy5jb3VudFdvcmRzKHRoaXMuZG9jLmJvZHkuaW5uZXJIVE1MKSxcblx0XHRcdFx0XHRwYXJzZVRpbWU6IE1hdGgucm91bmQoZW5kVGltZSAtIHN0YXJ0VGltZSlcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHNtYWxsIGltYWdlcyBpZGVudGlmaWVkIGZyb20gb3JpZ2luYWwgZG9jdW1lbnRcblx0XHRcdHRoaXMucmVtb3ZlU21hbGxJbWFnZXMoY2xvbmUsIHNtYWxsSW1hZ2VzKTtcblx0XHRcdFxuXHRcdFx0Ly8gUGVyZm9ybSBvdGhlciBkZXN0cnVjdGl2ZSBvcGVyYXRpb25zIG9uIHRoZSBjbG9uZVxuXHRcdFx0dGhpcy5yZW1vdmVIaWRkZW5FbGVtZW50cyhjbG9uZSk7XG5cdFx0XHR0aGlzLnJlbW92ZUNsdXR0ZXIoY2xvbmUpO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgbWFpbiBjb250ZW50XG5cdFx0XHR0aGlzLmNsZWFuQ29udGVudChtYWluQ29udGVudCwgbWV0YWRhdGEpO1xuXG5cdFx0XHRjb25zdCBjb250ZW50ID0gbWFpbkNvbnRlbnQgPyBtYWluQ29udGVudC5vdXRlckhUTUwgOiB0aGlzLmRvYy5ib2R5LmlubmVySFRNTDtcblx0XHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29udGVudCxcblx0XHRcdFx0Li4ubWV0YWRhdGEsXG5cdFx0XHRcdHdvcmRDb3VudDogdGhpcy5jb3VudFdvcmRzKGNvbnRlbnQpLFxuXHRcdFx0XHRwYXJzZVRpbWU6IE1hdGgucm91bmQoZW5kVGltZSAtIHN0YXJ0VGltZSlcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0RlZnVkZGxlJywgJ0Vycm9yIHByb2Nlc3NpbmcgZG9jdW1lbnQ6JywgZXJyb3IpO1xuXHRcdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29udGVudDogdGhpcy5kb2MuYm9keS5pbm5lckhUTUwsXG5cdFx0XHRcdC4uLm1ldGFkYXRhLFxuXHRcdFx0XHR3b3JkQ291bnQ6IHRoaXMuY291bnRXb3Jkcyh0aGlzLmRvYy5ib2R5LmlubmVySFRNTCksXG5cdFx0XHRcdHBhcnNlVGltZTogTWF0aC5yb3VuZChlbmRUaW1lIC0gc3RhcnRUaW1lKVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGNvdW50V29yZHMoY29udGVudDogc3RyaW5nKTogbnVtYmVyIHtcblx0XHQvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZGl2IHRvIHBhcnNlIEhUTUwgY29udGVudFxuXHRcdGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0ZW1wRGl2LmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cblx0XHQvLyBHZXQgdGV4dCBjb250ZW50LCByZW1vdmluZyBleHRyYSB3aGl0ZXNwYWNlXG5cdFx0Y29uc3QgdGV4dCA9IHRlbXBEaXYudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0Y29uc3Qgd29yZHMgPSB0ZXh0XG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIFJlcGxhY2UgbXVsdGlwbGUgc3BhY2VzIHdpdGggc2luZ2xlIHNwYWNlXG5cdFx0XHQuc3BsaXQoJyAnKVxuXHRcdFx0LmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID4gMCk7IC8vIEZpbHRlciBvdXQgZW1wdHkgc3RyaW5nc1xuXG5cdFx0cmV0dXJuIHdvcmRzLmxlbmd0aDtcblx0fVxuXG5cdC8vIE1ha2UgYWxsIG90aGVyIG1ldGhvZHMgcHJpdmF0ZSBieSByZW1vdmluZyB0aGUgc3RhdGljIGtleXdvcmQgYW5kIHVzaW5nIHByaXZhdGVcblx0cHJpdmF0ZSBfbG9nKC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdEZWZ1ZGRsZTonLCAuLi5hcmdzKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIF9ldmFsdWF0ZU1lZGlhUXVlcmllcyhkb2M6IERvY3VtZW50KTogU3R5bGVDaGFuZ2VbXSB7XG5cdFx0Y29uc3QgbW9iaWxlU3R5bGVzOiBTdHlsZUNoYW5nZVtdID0gW107XG5cdFx0Y29uc3QgbWF4V2lkdGhSZWdleCA9IC9tYXgtd2lkdGhbXjpdKjpcXHMqKFxcZCspLztcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBHZXQgYWxsIHN0eWxlcywgaW5jbHVkaW5nIGlubGluZSBzdHlsZXNcblx0XHRcdGNvbnN0IHNoZWV0cyA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maWx0ZXIoc2hlZXQgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEFjY2VzcyBydWxlcyBvbmNlIHRvIGNoZWNrIHZhbGlkaXR5XG5cdFx0XHRcdFx0c2hlZXQuY3NzUnVsZXM7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBFeHBlY3RlZCBlcnJvciBmb3IgY3Jvc3Mtb3JpZ2luIHN0eWxlc2hlZXRzXG5cdFx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZS5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIFByb2Nlc3MgYWxsIHNoZWV0cyBpbiBhIHNpbmdsZSBwYXNzXG5cdFx0XHRjb25zdCBtZWRpYVJ1bGVzID0gc2hlZXRzLmZsYXRNYXAoc2hlZXQgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBBcnJheS5mcm9tKHNoZWV0LmNzc1J1bGVzKVxuXHRcdFx0XHRcdFx0LmZpbHRlcigocnVsZSk6IHJ1bGUgaXMgQ1NTTWVkaWFSdWxlID0+IFxuXHRcdFx0XHRcdFx0XHRydWxlIGluc3RhbmNlb2YgQ1NTTWVkaWFSdWxlICYmXG5cdFx0XHRcdFx0XHRcdHJ1bGUuY29uZGl0aW9uVGV4dC5pbmNsdWRlcygnbWF4LXdpZHRoJylcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdEZWZ1ZGRsZTogRmFpbGVkIHRvIHByb2Nlc3Mgc3R5bGVzaGVldDonLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUHJvY2VzcyBhbGwgbWVkaWEgcnVsZXMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdFx0bWVkaWFSdWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuXHRcdFx0XHRjb25zdCBtYXRjaCA9IHJ1bGUuY29uZGl0aW9uVGV4dC5tYXRjaChtYXhXaWR0aFJlZ2V4KTtcblx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0Y29uc3QgbWF4V2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKE1PQklMRV9XSURUSCA8PSBtYXhXaWR0aCkge1xuXHRcdFx0XHRcdFx0Ly8gQmF0Y2ggcHJvY2VzcyBhbGwgc3R5bGUgcnVsZXNcblx0XHRcdFx0XHRcdGNvbnN0IHN0eWxlUnVsZXMgPSBBcnJheS5mcm9tKHJ1bGUuY3NzUnVsZXMpXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoKHIpOiByIGlzIENTU1N0eWxlUnVsZSA9PiByIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlKTtcblxuXHRcdFx0XHRcdFx0c3R5bGVSdWxlcy5mb3JFYWNoKGNzc1J1bGUgPT4ge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdG1vYmlsZVN0eWxlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdG9yOiBjc3NSdWxlLnNlbGVjdG9yVGV4dCxcblx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlczogY3NzUnVsZS5zdHlsZS5jc3NUZXh0XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdEZWZ1ZGRsZTogRmFpbGVkIHRvIHByb2Nlc3MgQ1NTIHJ1bGU6JywgZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0RlZnVkZGxlOiBFcnJvciBldmFsdWF0aW5nIG1lZGlhIHF1ZXJpZXM6JywgZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1vYmlsZVN0eWxlcztcblx0fVxuXG5cdHByaXZhdGUgYXBwbHlNb2JpbGVTdHlsZXMoZG9jOiBEb2N1bWVudCwgbW9iaWxlU3R5bGVzOiBTdHlsZUNoYW5nZVtdKSB7XG5cdFx0bGV0IGFwcGxpZWRDb3VudCA9IDA7XG5cblx0XHRtb2JpbGVTdHlsZXMuZm9yRWFjaCgoe3NlbGVjdG9yLCBzdHlsZXN9KSA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBlbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRcdFx0ZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBcblx0XHRcdFx0XHRcdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJykgKyBzdHlsZXNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGFwcGxpZWRDb3VudCsrO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRGVmdWRkbGUnLCAnRXJyb3IgYXBwbHlpbmcgc3R5bGVzIGZvciBzZWxlY3RvcjonLCBzZWxlY3RvciwgZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlSGlkZGVuRWxlbWVudHMoZG9jOiBEb2N1bWVudCkge1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0Y29uc3QgZWxlbWVudHNUb1JlbW92ZSA9IG5ldyBTZXQ8RWxlbWVudD4oKTtcblxuXHRcdC8vIEZpcnN0IHBhc3M6IEdldCBhbGwgZWxlbWVudHMgbWF0Y2hpbmcgaGlkZGVuIHNlbGVjdG9yc1xuXHRcdGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoSElEREVOX0VMRU1FTlRfU0VMRUNUT1JTKTtcblx0XHRoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsZW1lbnRzVG9SZW1vdmUuYWRkKGVsKSk7XG5cdFx0Y291bnQgKz0gaGlkZGVuRWxlbWVudHMubGVuZ3RoO1xuXG5cdFx0Ly8gU2Vjb25kIHBhc3M6IFVzZSBUcmVlV2Fsa2VyIGZvciBlZmZpY2llbnQgdHJhdmVyc2FsXG5cdFx0Y29uc3QgdHJlZVdhbGtlciA9IGRvYy5jcmVhdGVUcmVlV2Fsa2VyKFxuXHRcdFx0ZG9jLmJvZHksXG5cdFx0XHROb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcblx0XHRcdHtcblx0XHRcdFx0YWNjZXB0Tm9kZTogKG5vZGU6IEVsZW1lbnQpID0+IHtcblx0XHRcdFx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgbWFya2VkIGZvciByZW1vdmFsXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnRzVG9SZW1vdmUuaGFzKG5vZGUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdC8vIEJhdGNoIHN0eWxlIGNvbXB1dGF0aW9uc1xuXHRcdGNvbnN0IGVsZW1lbnRzOiBFbGVtZW50W10gPSBbXTtcblx0XHRsZXQgY3VycmVudE5vZGU6IEVsZW1lbnQgfCBudWxsO1xuXHRcdHdoaWxlIChjdXJyZW50Tm9kZSA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSBhcyBFbGVtZW50KSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGN1cnJlbnROb2RlKTtcblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHN0eWxlcyBpbiBiYXRjaGVzIHRvIG1pbmltaXplIGxheW91dCB0aHJhc2hpbmdcblx0XHRjb25zdCBCQVRDSF9TSVpFID0gMTAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IEJBVENIX1NJWkUpIHtcblx0XHRcdGNvbnN0IGJhdGNoID0gZWxlbWVudHMuc2xpY2UoaSwgaSArIEJBVENIX1NJWkUpO1xuXHRcdFx0XG5cdFx0XHQvLyBSZWFkIHBoYXNlIC0gZ2F0aGVyIGFsbCBjb21wdXRlZFN0eWxlc1xuXHRcdFx0Y29uc3Qgc3R5bGVzID0gYmF0Y2gubWFwKGVsID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSk7XG5cdFx0XHRcblx0XHRcdC8vIFdyaXRlIHBoYXNlIC0gbWFyayBlbGVtZW50cyBmb3IgcmVtb3ZhbFxuXHRcdFx0YmF0Y2guZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcblx0XHRcdFx0Y29uc3QgY29tcHV0ZWRTdHlsZSA9IHN0eWxlc1tpbmRleF07XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fFxuXHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHxcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlLm9wYWNpdHkgPT09ICcwJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRlbGVtZW50c1RvUmVtb3ZlLmFkZChlbGVtZW50KTtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBGaW5hbCBwYXNzOiBCYXRjaCByZW1vdmUgYWxsIGhpZGRlbiBlbGVtZW50c1xuXHRcdGVsZW1lbnRzVG9SZW1vdmUuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG5cblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgaGlkZGVuIGVsZW1lbnRzOicsIGNvdW50KTtcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlQ2x1dHRlcihkb2M6IERvY3VtZW50KSB7XG5cdFx0Y29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0bGV0IGV4YWN0U2VsZWN0b3JDb3VudCA9IDA7XG5cdFx0bGV0IHBhcnRpYWxTZWxlY3RvckNvdW50ID0gMDtcblxuXHRcdC8vIFRyYWNrIGFsbCBlbGVtZW50cyB0byBiZSByZW1vdmVkXG5cdFx0Y29uc3QgZWxlbWVudHNUb1JlbW92ZSA9IG5ldyBTZXQ8RWxlbWVudD4oKTtcblxuXHRcdC8vIEZpcnN0IGNvbGxlY3QgZWxlbWVudHMgbWF0Y2hpbmcgZXhhY3Qgc2VsZWN0b3JzXG5cdFx0Y29uc3QgZXhhY3RFbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKEVYQUNUX1NFTEVDVE9SUy5qb2luKCcsJykpO1xuXHRcdGV4YWN0RWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRpZiAoZWw/LnBhcmVudE5vZGUpIHtcblx0XHRcdFx0ZWxlbWVudHNUb1JlbW92ZS5hZGQoZWwpO1xuXHRcdFx0XHRleGFjdFNlbGVjdG9yQ291bnQrKztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFByZS1jb21waWxlIHJlZ2V4ZXMgYW5kIGNvbWJpbmUgaW50byBhIHNpbmdsZSByZWdleCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdFx0Y29uc3QgY29tYmluZWRQYXR0ZXJuID0gUEFSVElBTF9TRUxFQ1RPUlMuam9pbignfCcpO1xuXHRcdGNvbnN0IHBhcnRpYWxSZWdleCA9IG5ldyBSZWdFeHAoY29tYmluZWRQYXR0ZXJuLCAnaScpO1xuXG5cdFx0Ly8gQ3JlYXRlIGFuIGVmZmljaWVudCBhdHRyaWJ1dGUgc2VsZWN0b3IgZm9yIGVsZW1lbnRzIHdlIGNhcmUgYWJvdXRcblx0XHRjb25zdCBhdHRyaWJ1dGVTZWxlY3RvciA9ICdbY2xhc3NdLFtpZF0sW2RhdGEtdGVzdGlkXSxbZGF0YS1xYV0sW2RhdGEtY3ldJztcblx0XHRjb25zdCBhbGxFbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKGF0dHJpYnV0ZVNlbGVjdG9yKTtcblxuXHRcdC8vIFByb2Nlc3MgZWxlbWVudHMgZm9yIHBhcnRpYWwgbWF0Y2hlc1xuXHRcdGFsbEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0Ly8gU2tpcCBpZiBhbHJlYWR5IG1hcmtlZCBmb3IgcmVtb3ZhbFxuXHRcdFx0aWYgKGVsZW1lbnRzVG9SZW1vdmUuaGFzKGVsKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldCBhbGwgcmVsZXZhbnQgYXR0cmlidXRlcyBhbmQgY29tYmluZSBpbnRvIGEgc2luZ2xlIHN0cmluZ1xuXHRcdFx0Y29uc3QgYXR0cnMgPSBbXG5cdFx0XHRcdGVsLmNsYXNzTmFtZSAmJiB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6ICcnLFxuXHRcdFx0XHRlbC5pZCB8fCAnJyxcblx0XHRcdFx0ZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRlc3RpZCcpIHx8ICcnLFxuXHRcdFx0XHRlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcWEnKSB8fCAnJyxcblx0XHRcdFx0ZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWN5JykgfHwgJydcblx0XHRcdF0uam9pbignICcpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdC8vIFNraXAgaWYgbm8gYXR0cmlidXRlcyB0byBjaGVja1xuXHRcdFx0aWYgKCFhdHRycy50cmltKCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3IgcGFydGlhbCBtYXRjaCB1c2luZyBzaW5nbGUgcmVnZXggdGVzdFxuXHRcdFx0aWYgKHBhcnRpYWxSZWdleC50ZXN0KGF0dHJzKSkge1xuXHRcdFx0XHRlbGVtZW50c1RvUmVtb3ZlLmFkZChlbCk7XG5cdFx0XHRcdHBhcnRpYWxTZWxlY3RvckNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBSZW1vdmUgYWxsIGNvbGxlY3RlZCBlbGVtZW50cyBpbiBhIHNpbmdsZSBwYXNzXG5cdFx0ZWxlbWVudHNUb1JlbW92ZS5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcblxuXHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgY2x1dHRlciBlbGVtZW50czonLCB7XG5cdFx0XHRleGFjdFNlbGVjdG9yczogZXhhY3RTZWxlY3RvckNvdW50LFxuXHRcdFx0cGFydGlhbFNlbGVjdG9yczogcGFydGlhbFNlbGVjdG9yQ291bnQsXG5cdFx0XHR0b3RhbDogZWxlbWVudHNUb1JlbW92ZS5zaXplLFxuXHRcdFx0cHJvY2Vzc2luZ1RpbWU6IGAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zYFxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBmbGF0dGVuRGl2cyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdC8vIFByb2Nlc3MgaW4gYmF0Y2hlcyB0byBtYWludGFpbiBwZXJmb3JtYW5jZVxuXHRcdGxldCBrZWVwUHJvY2Vzc2luZyA9IHRydWU7XG5cblx0XHRjb25zdCBzaG91bGRQcmVzZXJ2ZUVsZW1lbnQgPSAoZWw6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcblx0XHRcdGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnQgc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0aWYgKFBSRVNFUlZFX0VMRU1FTlRTLmhhcyh0YWdOYW1lKSkgcmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBzZW1hbnRpYyByb2xlc1xuXHRcdFx0Y29uc3Qgcm9sZSA9IGVsLmdldEF0dHJpYnV0ZSgncm9sZScpO1xuXHRcdFx0aWYgKHJvbGUgJiYgWydhcnRpY2xlJywgJ21haW4nLCAnbmF2aWdhdGlvbicsICdiYW5uZXInLCAnY29udGVudGluZm8nXS5pbmNsdWRlcyhyb2xlKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHNlbWFudGljIGNsYXNzZXNcblx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKGNsYXNzTmFtZS5tYXRjaCgvKD86YXJ0aWNsZXxtYWlufGNvbnRlbnR8Zm9vdG5vdGV8cmVmZXJlbmNlfGJpYmxpb2dyYXBoeSkvKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgZGl2IGNvbnRhaW5zIG1peGVkIGNvbnRlbnQgdHlwZXMgdGhhdCBzaG91bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRpZiAodGFnTmFtZSA9PT0gJ2RpdicpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKTtcblx0XHRcdFx0Y29uc3QgaGFzUHJlc2VydmVkRWxlbWVudHMgPSBjaGlsZHJlbi5zb21lKGNoaWxkID0+IFxuXHRcdFx0XHRcdFBSRVNFUlZFX0VMRU1FTlRTLmhhcyhjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHx8XG5cdFx0XHRcdFx0Y2hpbGQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdhcnRpY2xlJyB8fFxuXHRcdFx0XHRcdGNoaWxkLmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdhcnRpY2xlJylcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKGhhc1ByZXNlcnZlZEVsZW1lbnRzKSByZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRjb25zdCBpc1dyYXBwZXJEaXYgPSAoZGl2OiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHQvLyBDaGVjayBpZiBpdCdzIGp1c3QgZW1wdHkgc3BhY2Vcblx0XHRcdGlmICghZGl2LnRleHRDb250ZW50Py50cmltKCkpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdCBvbmx5IGNvbnRhaW5zIG90aGVyIGRpdnMgb3IgYmxvY2sgZWxlbWVudHNcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGlmIGFsbCBjaGlsZHJlbiBhcmUgYmxvY2sgZWxlbWVudHNcblx0XHRcdGNvbnN0IGFsbEJsb2NrRWxlbWVudHMgPSBjaGlsZHJlbi5ldmVyeShjaGlsZCA9PiB7XG5cdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0cmV0dXJuIHRhZyA9PT0gJ2RpdicgfHwgdGFnID09PSAncCcgfHwgdGFnID09PSAnaDEnIHx8IHRhZyA9PT0gJ2gyJyB8fCBcblx0XHRcdFx0XHQgICB0YWcgPT09ICdoMycgfHwgdGFnID09PSAnaDQnIHx8IHRhZyA9PT0gJ2g1JyB8fCB0YWcgPT09ICdoNicgfHxcblx0XHRcdFx0XHQgICB0YWcgPT09ICd1bCcgfHwgdGFnID09PSAnb2wnIHx8IHRhZyA9PT0gJ3ByZScgfHwgdGFnID09PSAnYmxvY2txdW90ZScgfHxcblx0XHRcdFx0XHQgICB0YWcgPT09ICdmaWd1cmUnO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoYWxsQmxvY2tFbGVtZW50cykgcmV0dXJuIHRydWU7XG5cblx0XHRcdC8vIENoZWNrIGZvciBjb21tb24gd3JhcHBlciBwYXR0ZXJuc1xuXHRcdFx0Y29uc3QgY2xhc3NOYW1lID0gZGl2LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y29uc3QgaXNXcmFwcGVyID0gLyg/OndyYXBwZXJ8Y29udGFpbmVyfGxheW91dHxyb3d8Y29sfGdyaWR8ZmxleHxvdXRlcnxpbm5lcnxjb250ZW50LWFyZWEpL2kudGVzdChjbGFzc05hbWUpO1xuXHRcdFx0aWYgKGlzV3JhcHBlcikgcmV0dXJuIHRydWU7XG5cblx0XHRcdC8vIENoZWNrIGlmIGl0IGhhcyBleGNlc3NpdmUgd2hpdGVzcGFjZSBvciBlbXB0eSB0ZXh0IG5vZGVzXG5cdFx0XHRjb25zdCB0ZXh0Tm9kZXMgPSBBcnJheS5mcm9tKGRpdi5jaGlsZE5vZGVzKS5maWx0ZXIobm9kZSA9PiBcblx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgbm9kZS50ZXh0Q29udGVudD8udHJpbSgpXG5cdFx0XHQpO1xuXHRcdFx0aWYgKHRleHROb2Rlcy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdCdzIGEgZGl2IHRoYXQgb25seSBjb250YWlucyBibG9jayBlbGVtZW50c1xuXHRcdFx0Y29uc3QgaGFzT25seUJsb2NrRWxlbWVudHMgPSBjaGlsZHJlbi5sZW5ndGggPiAwICYmICFjaGlsZHJlbi5zb21lKGNoaWxkID0+IHtcblx0XHRcdFx0Y29uc3QgdGFnID0gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRyZXR1cm4gSU5MSU5FX0VMRU1FTlRTLmhhcyh0YWcpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoaGFzT25seUJsb2NrRWxlbWVudHMpIHJldHVybiB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8vIEZ1bmN0aW9uIHRvIHByb2Nlc3MgYSBzaW5nbGUgZGl2XG5cdFx0Y29uc3QgcHJvY2Vzc0RpdiA9IChkaXY6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcblx0XHRcdC8vIFNraXAgcHJvY2Vzc2luZyBpZiBkaXYgaGFzIGJlZW4gcmVtb3ZlZCBvciBzaG91bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRpZiAoIWRpdi5pc0Nvbm5lY3RlZCB8fCBzaG91bGRQcmVzZXJ2ZUVsZW1lbnQoZGl2KSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBDYXNlIDE6IEVtcHR5IGRpdiBvciBkaXYgd2l0aCBvbmx5IHdoaXRlc3BhY2Vcblx0XHRcdGlmICghZGl2Lmhhc0NoaWxkTm9kZXMoKSB8fCAhZGl2LnRleHRDb250ZW50Py50cmltKCkpIHtcblx0XHRcdFx0ZGl2LnJlbW92ZSgpO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSAyOiBUb3AtbGV2ZWwgZGl2IC0gYmUgbW9yZSBhZ2dyZXNzaXZlXG5cdFx0XHRpZiAoZGl2LnBhcmVudEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGRpdi5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IGhhc09ubHlCbG9ja0VsZW1lbnRzID0gY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhY2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgdGFnID0gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHJldHVybiBJTkxJTkVfRUxFTUVOVFMuaGFzKHRhZyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChoYXNPbmx5QmxvY2tFbGVtZW50cykge1xuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSAzOiBXcmFwcGVyIGRpdiAtIG1lcmdlIHVwIGFnZ3Jlc3NpdmVseVxuXHRcdFx0aWYgKGlzV3JhcHBlckRpdihkaXYpKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZTogaWYgZGl2IG9ubHkgY29udGFpbnMgYmxvY2sgZWxlbWVudHMsIG1lcmdlIHRoZW0gdXBcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGRpdi5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IG9ubHlCbG9ja0VsZW1lbnRzID0gIWNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRyZXR1cm4gSU5MSU5FX0VMRU1FTlRTLmhhcyh0YWcpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChvbmx5QmxvY2tFbGVtZW50cykge1xuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgaGFuZGxlIGFzIG5vcm1hbCB3cmFwcGVyXG5cdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgNDogRGl2IG9ubHkgY29udGFpbnMgdGV4dCBjb250ZW50IC0gY29udmVydCB0byBwYXJhZ3JhcGhcblx0XHRcdGlmICghZGl2LmNoaWxkcmVuLmxlbmd0aCAmJiBkaXYudGV4dENvbnRlbnQ/LnRyaW0oKSkge1xuXHRcdFx0XHRjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRwLnRleHRDb250ZW50ID0gZGl2LnRleHRDb250ZW50O1xuXHRcdFx0XHRkaXYucmVwbGFjZVdpdGgocCk7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXNlIDU6IERpdiBoYXMgc2luZ2xlIGNoaWxkXG5cdFx0XHRpZiAoZGl2LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRjb25zdCBjaGlsZCA9IGRpdi5maXJzdEVsZW1lbnRDaGlsZCE7XG5cdFx0XHRcdGNvbnN0IGNoaWxkVGFnID0gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRG9uJ3QgdW53cmFwIGlmIGNoaWxkIGlzIGlubGluZSBvciBzaG91bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdGlmICghSU5MSU5FX0VMRU1FTlRTLmhhcyhjaGlsZFRhZykgJiYgIXNob3VsZFByZXNlcnZlRWxlbWVudChjaGlsZCkpIHtcblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoY2hpbGQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSA2OiBEZWVwbHkgbmVzdGVkIGRpdiAtIG1lcmdlIHVwXG5cdFx0XHRsZXQgbmVzdGluZ0RlcHRoID0gMDtcblx0XHRcdGxldCBwYXJlbnQgPSBkaXYucGFyZW50RWxlbWVudDtcblx0XHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnKSB7XG5cdFx0XHRcdFx0bmVzdGluZ0RlcHRoKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXN0aW5nRGVwdGggPiAwKSB7IC8vIENoYW5nZWQgZnJvbSA+IDEgdG8gPiAwIHRvIGJlIG1vcmUgYWdncmVzc2l2ZVxuXHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG5cdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChmcmFnbWVudCk7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8vIEZpcnN0IHBhc3M6IFByb2Nlc3MgdG9wLWxldmVsIGRpdnNcblx0XHRjb25zdCBwcm9jZXNzVG9wTGV2ZWxEaXZzID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgdG9wRGl2cyA9IEFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikuZmlsdGVyKFxuXHRcdFx0XHRlbCA9PiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHRsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblx0XHRcdHRvcERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRpZiAocHJvY2Vzc0RpdihkaXYpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBtb2RpZmllZDtcblx0XHR9O1xuXG5cdFx0Ly8gU2Vjb25kIHBhc3M6IFByb2Nlc3MgcmVtYWluaW5nIGRpdnMgZnJvbSBkZWVwZXN0IHRvIHNoYWxsb3dlc3Rcblx0XHRjb25zdCBwcm9jZXNzUmVtYWluaW5nRGl2cyA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGFsbERpdnMgPSBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpKVxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRcdC8vIENvdW50IG5lc3RpbmcgZGVwdGhcblx0XHRcdFx0XHRjb25zdCBnZXREZXB0aCA9IChlbDogRWxlbWVudCk6IG51bWJlciA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgZGVwdGggPSAwO1xuXHRcdFx0XHRcdFx0bGV0IHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2JykgZGVwdGgrKztcblx0XHRcdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGVwdGg7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0RGVwdGgoYikgLSBnZXREZXB0aChhKTsgLy8gUHJvY2VzcyBkZWVwZXN0IGZpcnN0XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblx0XHRcdGFsbERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRpZiAocHJvY2Vzc0RpdihkaXYpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBtb2RpZmllZDtcblx0XHR9O1xuXG5cdFx0Ly8gRmluYWwgY2xlYW51cCBwYXNzIC0gYWdncmVzc2l2ZWx5IGZsYXR0ZW4gcmVtYWluaW5nIGRpdnNcblx0XHRjb25zdCBmaW5hbENsZWFudXAgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCByZW1haW5pbmdEaXZzID0gQXJyYXkuZnJvbShlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKSk7XG5cdFx0XHRsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0cmVtYWluaW5nRGl2cy5mb3JFYWNoKGRpdiA9PiB7XG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiBvbmx5IGNvbnRhaW5zIHBhcmFncmFwaHNcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGRpdi5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IG9ubHlQYXJhZ3JhcGhzID0gY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG9ubHlQYXJhZ3JhcGhzIHx8ICghc2hvdWxkUHJlc2VydmVFbGVtZW50KGRpdikgJiYgaXNXcmFwcGVyRGl2KGRpdikpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFx0d2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG5cdFx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChmcmFnbWVudCk7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0XHRtb2RpZmllZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIG1vZGlmaWVkO1xuXHRcdH07XG5cblx0XHQvLyBFeGVjdXRlIGFsbCBwYXNzZXMgdW50aWwgbm8gbW9yZSBjaGFuZ2VzXG5cdFx0ZG8ge1xuXHRcdFx0XHRrZWVwUHJvY2Vzc2luZyA9IGZhbHNlO1xuXHRcdFx0XHRpZiAocHJvY2Vzc1RvcExldmVsRGl2cygpKSBrZWVwUHJvY2Vzc2luZyA9IHRydWU7XG5cdFx0XHRcdGlmIChwcm9jZXNzUmVtYWluaW5nRGl2cygpKSBrZWVwUHJvY2Vzc2luZyA9IHRydWU7XG5cdFx0XHRcdGlmIChmaW5hbENsZWFudXAoKSkga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0fSB3aGlsZSAoa2VlcFByb2Nlc3NpbmcpO1xuXG5cdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHRoaXMuX2xvZygnRmxhdHRlbmVkIGRpdnM6Jywge1xuXHRcdFx0Y291bnQ6IHByb2Nlc3NlZENvdW50LFxuXHRcdFx0cHJvY2Vzc2luZ1RpbWU6IGAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zYFxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBjbGVhbkNvbnRlbnQoZWxlbWVudDogRWxlbWVudCwgbWV0YWRhdGE6IERlZnVkZGxlTWV0YWRhdGEpIHtcblx0XHQvLyBSZW1vdmUgSFRNTCBjb21tZW50c1xuXHRcdHRoaXMucmVtb3ZlSHRtbENvbW1lbnRzKGVsZW1lbnQpO1xuXHRcdFxuXHRcdC8vIEhhbmRsZSBIMSBlbGVtZW50cyAtIHJlbW92ZSBmaXJzdCBvbmUgYW5kIGNvbnZlcnQgb3RoZXJzIHRvIEgyXG5cdFx0dGhpcy5oYW5kbGVIZWFkaW5ncyhlbGVtZW50LCBtZXRhZGF0YS50aXRsZSk7XG5cdFx0XG5cdFx0Ly8gU3RhbmRhcmRpemUgZm9vdG5vdGVzIGFuZCBjaXRhdGlvbnNcblx0XHR0aGlzLnN0YW5kYXJkaXplRm9vdG5vdGVzKGVsZW1lbnQpO1xuXG5cdFx0Ly8gSGFuZGxlIGxhenktbG9hZGVkIGltYWdlc1xuXHRcdHRoaXMuaGFuZGxlTGF6eUltYWdlcyhlbGVtZW50KTtcblxuXHRcdC8vIENvbnZlcnQgZW1iZWRkZWQgY29udGVudCB0byBzdGFuZGFyZCBmb3JtYXRzXG5cdFx0dGhpcy5zdGFuZGFyZGl6ZUVsZW1lbnRzKGVsZW1lbnQpO1xuXG5cdFx0Ly8gU2tpcCBkaXYgZmxhdHRlbmluZyBpbiBkZWJ1ZyBtb2RlXG5cdFx0aWYgKCF0aGlzLmRlYnVnKSB7XG5cdFx0XHQvLyBGaXJzdCBwYXNzIG9mIGRpdiBmbGF0dGVuaW5nXG5cdFx0XHR0aGlzLmZsYXR0ZW5EaXZzKGVsZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBTdHJpcCB1bndhbnRlZCBhdHRyaWJ1dGVzXG5cdFx0XHR0aGlzLnN0cmlwVW53YW50ZWRBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXG5cdFx0XHQvLyBSZW1vdmUgZW1wdHkgZWxlbWVudHNcblx0XHRcdHRoaXMucmVtb3ZlRW1wdHlFbGVtZW50cyhlbGVtZW50KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIHRyYWlsaW5nIGhlYWRpbmdzXG5cdFx0XHR0aGlzLnJlbW92ZVRyYWlsaW5nSGVhZGluZ3MoZWxlbWVudCk7XG5cblx0XHRcdC8vIEZpbmFsIHBhc3Mgb2YgZGl2IGZsYXR0ZW5pbmcgYWZ0ZXIgY2xlYW51cCBvcGVyYXRpb25zXG5cdFx0XHR0aGlzLmZsYXR0ZW5EaXZzKGVsZW1lbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJbiBkZWJ1ZyBtb2RlLCBzdGlsbCBkbyBiYXNpYyBjbGVhbnVwIGJ1dCBwcmVzZXJ2ZSBzdHJ1Y3R1cmVcblx0XHRcdHRoaXMuc3RyaXBVbndhbnRlZEF0dHJpYnV0ZXMoZWxlbWVudCk7XG5cdFx0XHR0aGlzLnJlbW92ZUVtcHR5RWxlbWVudHMoZWxlbWVudCk7XG5cdFx0XHR0aGlzLnJlbW92ZVRyYWlsaW5nSGVhZGluZ3MoZWxlbWVudCk7XG5cdFx0XHR0aGlzLl9sb2coJ0RlYnVnIG1vZGU6IFNraXBwaW5nIGRpdiBmbGF0dGVuaW5nIHRvIHByZXNlcnZlIHN0cnVjdHVyZScpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlVHJhaWxpbmdIZWFkaW5ncyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHJlbW92ZWRDb3VudCA9IDA7XG5cblx0XHRjb25zdCBoYXNDb250ZW50QWZ0ZXIgPSAoZWw6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcblx0XHRcdC8vIENoZWNrIGlmIHRoZXJlJ3MgYW55IG1lYW5pbmdmdWwgY29udGVudCBhZnRlciB0aGlzIGVsZW1lbnRcblx0XHRcdGxldCBuZXh0Q29udGVudCA9ICcnO1xuXHRcdFx0bGV0IHNpYmxpbmcgPSBlbC5uZXh0U2libGluZztcblxuXHRcdFx0Ly8gRmlyc3QgY2hlY2sgZGlyZWN0IHNpYmxpbmdzXG5cdFx0XHR3aGlsZSAoc2libGluZykge1xuXHRcdFx0XHRpZiAoc2libGluZy5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdFx0XHRuZXh0Q29udGVudCArPSBzaWJsaW5nLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNpYmxpbmcubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdFx0XHRcdFx0Ly8gSWYgd2UgZmluZCBhbiBlbGVtZW50IHNpYmxpbmcsIGNoZWNrIGl0cyBjb250ZW50XG5cdFx0XHRcdFx0bmV4dENvbnRlbnQgKz0gKHNpYmxpbmcgYXMgRWxlbWVudCkudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2libGluZyA9IHNpYmxpbmcubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGZvdW5kIG1lYW5pbmdmdWwgY29udGVudCBhdCB0aGlzIGxldmVsLCByZXR1cm4gdHJ1ZVxuXHRcdFx0aWYgKG5leHRDb250ZW50LnRyaW0oKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm8gY29udGVudCBmb3VuZCBhdCB0aGlzIGxldmVsIGFuZCB3ZSBoYXZlIGEgcGFyZW50LFxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbnRlbnQgYWZ0ZXIgdGhlIHBhcmVudFxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudDtcblx0XHRcdGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBlbGVtZW50KSB7XG5cdFx0XHRcdHJldHVybiBoYXNDb250ZW50QWZ0ZXIocGFyZW50KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBQcm9jZXNzIGFsbCBoZWFkaW5ncyBmcm9tIGJvdHRvbSB0byB0b3Bcblx0XHRjb25zdCBoZWFkaW5ncyA9IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2JykpXG5cdFx0XHQucmV2ZXJzZSgpO1xuXG5cdFx0aGVhZGluZ3MuZm9yRWFjaChoZWFkaW5nID0+IHtcblx0XHRcdGlmICghaGFzQ29udGVudEFmdGVyKGhlYWRpbmcpKSB7XG5cdFx0XHRcdGhlYWRpbmcucmVtb3ZlKCk7XG5cdFx0XHRcdHJlbW92ZWRDb3VudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU3RvcCBwcm9jZXNzaW5nIG9uY2Ugd2UgZmluZCBhIGhlYWRpbmcgd2l0aCBjb250ZW50IGFmdGVyIGl0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChyZW1vdmVkQ291bnQgPiAwKSB7XG5cdFx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgdHJhaWxpbmcgaGVhZGluZ3M6JywgcmVtb3ZlZENvdW50KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGhhbmRsZUhlYWRpbmdzKGVsZW1lbnQ6IEVsZW1lbnQsIHRpdGxlOiBzdHJpbmcpIHtcblx0XHRjb25zdCBoMXMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMScpO1xuXG5cdFx0QXJyYXkuZnJvbShoMXMpLmZvckVhY2goaDEgPT4ge1xuXHRcdFx0Y29uc3QgaDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuXHRcdFx0aDIuaW5uZXJIVE1MID0gaDEuaW5uZXJIVE1MO1xuXHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXNcblx0XHRcdEFycmF5LmZyb20oaDEuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdGgyLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGgxLnBhcmVudE5vZGU/LnJlcGxhY2VDaGlsZChoMiwgaDEpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIGZpcnN0IEgyIGlmIGl0IG1hdGNoZXMgdGl0bGVcblx0XHRjb25zdCBoMnMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMicpO1xuXHRcdGlmIChoMnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29uc3QgZmlyc3RIMiA9IGgyc1swXTtcblx0XHRcdGNvbnN0IGZpcnN0SDJUZXh0ID0gZmlyc3RIMi50ZXh0Q29udGVudD8udHJpbSgpLnRvTG93ZXJDYXNlKCkgfHwgJyc7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkVGl0bGUgPSB0aXRsZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblx0XHRcdGlmIChub3JtYWxpemVkVGl0bGUgJiYgbm9ybWFsaXplZFRpdGxlID09PSBmaXJzdEgyVGV4dCkge1xuXHRcdFx0XHRmaXJzdEgyLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlSHRtbENvbW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRjb25zdCBjb21tZW50czogQ29tbWVudFtdID0gW107XG5cdFx0Y29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHROb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCxcblx0XHRcdG51bGxcblx0XHQpO1xuXG5cdFx0bGV0IG5vZGU7XG5cdFx0d2hpbGUgKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuXHRcdFx0Y29tbWVudHMucHVzaChub2RlIGFzIENvbW1lbnQpO1xuXHRcdH1cblxuXHRcdGNvbW1lbnRzLmZvckVhY2goY29tbWVudCA9PiB7XG5cdFx0XHRjb21tZW50LnJlbW92ZSgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIEhUTUwgY29tbWVudHM6JywgY29tbWVudHMubGVuZ3RoKTtcblx0fVxuXG5cdHByaXZhdGUgc3RyaXBVbndhbnRlZEF0dHJpYnV0ZXMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCBhdHRyaWJ1dGVDb3VudCA9IDA7XG5cblx0XHRjb25zdCBwcm9jZXNzRWxlbWVudCA9IChlbDogRWxlbWVudCkgPT4ge1xuXHRcdFx0Ly8gU2tpcCBTVkcgZWxlbWVudHMgLSBwcmVzZXJ2ZSBhbGwgdGhlaXIgYXR0cmlidXRlc1xuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKGVsLmF0dHJpYnV0ZXMpO1xuXHRcdFx0XG5cdFx0XHRhdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdGNvbnN0IGF0dHJOYW1lID0gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdC8vIEluIGRlYnVnIG1vZGUsIGFsbG93IGRlYnVnIGF0dHJpYnV0ZXMgYW5kIGRhdGEtIGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRpZiAoIUFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ck5hbWUpICYmIFxuXHRcdFx0XHRcdFx0IUFMTE9XRURfQVRUUklCVVRFU19ERUJVRy5oYXMoYXR0ck5hbWUpICYmIFxuXHRcdFx0XHRcdFx0IWF0dHJOYW1lLnN0YXJ0c1dpdGgoJ2RhdGEtJykpIHtcblx0XHRcdFx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuXHRcdFx0XHRcdFx0YXR0cmlidXRlQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSW4gbm9ybWFsIG1vZGUsIG9ubHkgYWxsb3cgc3RhbmRhcmQgYXR0cmlidXRlc1xuXHRcdFx0XHRcdGlmICghQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyTmFtZSkpIHtcblx0XHRcdFx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuXHRcdFx0XHRcdFx0YXR0cmlidXRlQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRwcm9jZXNzRWxlbWVudChlbGVtZW50KTtcblx0XHRlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKS5mb3JFYWNoKHByb2Nlc3NFbGVtZW50KTtcblxuXHRcdHRoaXMuX2xvZygnU3RyaXBwZWQgYXR0cmlidXRlczonLCBhdHRyaWJ1dGVDb3VudCk7XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUVtcHR5RWxlbWVudHMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCByZW1vdmVkQ291bnQgPSAwO1xuXHRcdGxldCBpdGVyYXRpb25zID0gMDtcblx0XHRsZXQga2VlcFJlbW92aW5nID0gdHJ1ZTtcblxuXHRcdHdoaWxlIChrZWVwUmVtb3ZpbmcpIHtcblx0XHRcdGl0ZXJhdGlvbnMrKztcblx0XHRcdGtlZXBSZW1vdmluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gR2V0IGFsbCBlbGVtZW50cyB3aXRob3V0IGNoaWxkcmVuLCB3b3JraW5nIGZyb20gZGVlcGVzdCBmaXJzdFxuXHRcdFx0Y29uc3QgZW1wdHlFbGVtZW50cyA9IEFycmF5LmZyb20oZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKS5maWx0ZXIoZWwgPT4ge1xuXHRcdFx0XHRpZiAoQUxMT1dFRF9FTVBUWV9FTEVNRU5UUy5oYXMoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZWxlbWVudCBoYXMgb25seSB3aGl0ZXNwYWNlIG9yICZuYnNwO1xuXHRcdFx0XHRjb25zdCB0ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHRjb25zdCBoYXNPbmx5V2hpdGVzcGFjZSA9IHRleHRDb250ZW50LnRyaW0oKS5sZW5ndGggPT09IDA7XG5cdFx0XHRcdGNvbnN0IGhhc05ic3AgPSB0ZXh0Q29udGVudC5pbmNsdWRlcygnXFx1MDBBMCcpOyAvLyBVbmljb2RlIG5vbi1icmVha2luZyBzcGFjZVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZWxlbWVudCBoYXMgbm8gbWVhbmluZ2Z1bCBjaGlsZHJlblxuXHRcdFx0XHRjb25zdCBoYXNOb0NoaWxkcmVuID0gIWVsLmhhc0NoaWxkTm9kZXMoKSB8fCBcblx0XHRcdFx0XHQoQXJyYXkuZnJvbShlbC5jaGlsZE5vZGVzKS5ldmVyeShub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBub2RlVGV4dCA9IG5vZGUudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBub2RlVGV4dC50cmltKCkubGVuZ3RoID09PSAwICYmICFub2RlVGV4dC5pbmNsdWRlcygnXFx1MDBBMCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2U6IENoZWNrIGZvciBkaXZzIHRoYXQgb25seSBjb250YWluIHNwYW5zIHdpdGggY29tbWFzXG5cdFx0XHRcdGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRjb25zdCBoYXNPbmx5Q29tbWFTcGFucyA9IGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3NwYW4nKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRjb25zdCBjb250ZW50ID0gY2hpbGQudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ID09PSAnLCcgfHwgY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJyAnO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmIChoYXNPbmx5Q29tbWFTcGFucykgcmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gaGFzT25seVdoaXRlc3BhY2UgJiYgIWhhc05ic3AgJiYgaGFzTm9DaGlsZHJlbjtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoZW1wdHlFbGVtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGVtcHR5RWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRcdFx0ZWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0cmVtb3ZlZENvdW50Kys7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRrZWVwUmVtb3ZpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2xvZygnUmVtb3ZlZCBlbXB0eSBlbGVtZW50czonLCB7XG5cdFx0XHRjb3VudDogcmVtb3ZlZENvdW50LFxuXHRcdFx0aXRlcmF0aW9uc1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBjcmVhdGVGb290bm90ZUl0ZW0oXG5cdFx0Zm9vdG5vdGVOdW1iZXI6IG51bWJlcixcblx0XHRjb250ZW50OiBzdHJpbmcgfCBFbGVtZW50LFxuXHRcdHJlZnM6IHN0cmluZ1tdXG5cdCk6IEhUTUxMSUVsZW1lbnQge1xuXHRcdGNvbnN0IG5ld0l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXHRcdG5ld0l0ZW0uY2xhc3NOYW1lID0gJ2Zvb3Rub3RlJztcblx0XHRuZXdJdGVtLmlkID0gYGZuOiR7Zm9vdG5vdGVOdW1iZXJ9YDtcblxuXHRcdC8vIEhhbmRsZSBjb250ZW50XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuXHRcdFx0Y29uc3QgcGFyYWdyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0cGFyYWdyYXBoLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cdFx0XHRuZXdJdGVtLmFwcGVuZENoaWxkKHBhcmFncmFwaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBhbGwgcGFyYWdyYXBocyBmcm9tIHRoZSBjb250ZW50XG5cdFx0XHRjb25zdCBwYXJhZ3JhcGhzID0gQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3AnKSk7XG5cdFx0XHRpZiAocGFyYWdyYXBocy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Ly8gSWYgbm8gcGFyYWdyYXBocywgd3JhcCBjb250ZW50IGluIGEgcGFyYWdyYXBoXG5cdFx0XHRcdGNvbnN0IHBhcmFncmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0cGFyYWdyYXBoLmlubmVySFRNTCA9IGNvbnRlbnQuaW5uZXJIVE1MO1xuXHRcdFx0XHRuZXdJdGVtLmFwcGVuZENoaWxkKHBhcmFncmFwaCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBDb3B5IGV4aXN0aW5nIHBhcmFncmFwaHNcblx0XHRcdFx0cGFyYWdyYXBocy5mb3JFYWNoKHAgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG5ld1AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdFx0bmV3UC5pbm5lckhUTUwgPSBwLmlubmVySFRNTDtcblx0XHRcdFx0XHRuZXdJdGVtLmFwcGVuZENoaWxkKG5ld1ApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgYmFja2xpbmsocykgdG8gdGhlIGxhc3QgcGFyYWdyYXBoXG5cdFx0Y29uc3QgbGFzdFBhcmFncmFwaCA9IG5ld0l0ZW0ucXVlcnlTZWxlY3RvcigncDpsYXN0LW9mLXR5cGUnKSB8fCBuZXdJdGVtO1xuXHRcdHJlZnMuZm9yRWFjaCgocmVmSWQsIGluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBiYWNrbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0XHRcdGJhY2tsaW5rLmhyZWYgPSBgIyR7cmVmSWR9YDtcblx0XHRcdGJhY2tsaW5rLnRpdGxlID0gJ3JldHVybiB0byBhcnRpY2xlJztcblx0XHRcdGJhY2tsaW5rLmNsYXNzTmFtZSA9ICdmb290bm90ZS1iYWNrcmVmJztcblx0XHRcdGJhY2tsaW5rLmlubmVySFRNTCA9ICfihqknO1xuXHRcdFx0aWYgKGluZGV4IDwgcmVmcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdGJhY2tsaW5rLmlubmVySFRNTCArPSAnICc7XG5cdFx0XHR9XG5cdFx0XHRsYXN0UGFyYWdyYXBoLmFwcGVuZENoaWxkKGJhY2tsaW5rKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBuZXdJdGVtO1xuXHR9XG5cblx0cHJpdmF0ZSBjb2xsZWN0Rm9vdG5vdGVzKGVsZW1lbnQ6IEVsZW1lbnQpOiBGb290bm90ZUNvbGxlY3Rpb24ge1xuXHRcdGNvbnN0IGZvb3Rub3RlczogRm9vdG5vdGVDb2xsZWN0aW9uID0ge307XG5cdFx0bGV0IGZvb3Rub3RlQ291bnQgPSAxO1xuXHRcdGNvbnN0IHByb2Nlc3NlZElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpOyAvLyBUcmFjayBwcm9jZXNzZWQgSURzXG5cblx0XHQvLyBDb2xsZWN0IGFsbCBmb290bm90ZXMgYW5kIHRoZWlyIElEcyBmcm9tIGZvb3Rub3RlIGxpc3RzXG5cdFx0Y29uc3QgZm9vdG5vdGVMaXN0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChGT09UTk9URV9MSVNUX1NFTEVDVE9SUyk7XG5cdFx0Zm9vdG5vdGVMaXN0cy5mb3JFYWNoKGxpc3QgPT4ge1xuXHRcdFx0Ly8gU3Vic3RhY2sgaGFzIGluZGl2aWR1YWwgZm9vdG5vdGUgZGl2cyB3aXRoIG5vIHBhcmVudFxuXHRcdFx0aWYgKGxpc3QubWF0Y2hlcygnZGl2LmZvb3Rub3RlW2RhdGEtY29tcG9uZW50LW5hbWU9XCJGb290bm90ZVRvRE9NXCJdJykpIHtcblx0XHRcdFx0Y29uc3QgYW5jaG9yID0gbGlzdC5xdWVyeVNlbGVjdG9yKCdhLmZvb3Rub3RlLW51bWJlcicpO1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gbGlzdC5xdWVyeVNlbGVjdG9yKCcuZm9vdG5vdGUtY29udGVudCcpO1xuXHRcdFx0XHRpZiAoYW5jaG9yICYmIGNvbnRlbnQpIHtcblx0XHRcdFx0XHRjb25zdCBpZCA9IGFuY2hvci5pZC5yZXBsYWNlKCdmb290bm90ZS0nLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoaWQgJiYgIXByb2Nlc3NlZElkcy5oYXMoaWQpKSB7XG5cdFx0XHRcdFx0XHRmb290bm90ZXNbZm9vdG5vdGVDb3VudF0gPSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsSWQ6IGlkLFxuXHRcdFx0XHRcdFx0XHRyZWZzOiBbXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHByb2Nlc3NlZElkcy5hZGQoaWQpO1xuXHRcdFx0XHRcdFx0Zm9vdG5vdGVDb3VudCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbW1vbiBmb3JtYXQgdXNpbmcgT0wvVUwgYW5kIExJIGVsZW1lbnRzXG5cdFx0XHRjb25zdCBpdGVtcyA9IGxpc3QucXVlcnlTZWxlY3RvckFsbCgnbGksIGRpdltyb2xlPVwibGlzdGl0ZW1cIl0nKTtcblx0XHRcdGl0ZW1zLmZvckVhY2gobGkgPT4ge1xuXHRcdFx0XHRsZXQgaWQgPSAnJztcblx0XHRcdFx0bGV0IGNvbnRlbnQ6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuXHRcdFx0XHQvLyBIYW5kbGUgY2l0YXRpb25zIHdpdGggLmNpdGF0aW9ucyBjbGFzc1xuXHRcdFx0XHRjb25zdCBjaXRhdGlvbnNEaXYgPSBsaS5xdWVyeVNlbGVjdG9yKCcuY2l0YXRpb25zJyk7XG5cdFx0XHRcdGlmIChjaXRhdGlvbnNEaXY/LmlkPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3InKSkge1xuXHRcdFx0XHRcdGlkID0gY2l0YXRpb25zRGl2LmlkLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0Ly8gTG9vayBmb3IgY2l0YXRpb24gY29udGVudCB3aXRoaW4gdGhlIGNpdGF0aW9ucyBkaXZcblx0XHRcdFx0XHRjb25zdCBjaXRhdGlvbkNvbnRlbnQgPSBjaXRhdGlvbnNEaXYucXVlcnlTZWxlY3RvcignLmNpdGF0aW9uLWNvbnRlbnQnKTtcblx0XHRcdFx0XHRpZiAoY2l0YXRpb25Db250ZW50KSB7XG5cdFx0XHRcdFx0XHRjb250ZW50ID0gY2l0YXRpb25Db250ZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBFeHRyYWN0IElEIGZyb20gdmFyaW91cyBmb3JtYXRzXG5cdFx0XHRcdFx0aWYgKGxpLmlkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnYmliLmJpYicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmlkLnJlcGxhY2UoJ2JpYi5iaWInLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxpLmlkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZm46JykpIHtcblx0XHRcdFx0XHRcdGlkID0gbGkuaWQucmVwbGFjZSgnZm46JywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsaS5pZC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2ZuJykpIHtcblx0XHRcdFx0XHRcdGlkID0gbGkuaWQucmVwbGFjZSgnZm4nLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHQvLyBOYXR1cmUuY29tXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsaS5oYXNBdHRyaWJ1dGUoJ2RhdGEtY291bnRlcicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3VudGVyJyk/LnJlcGxhY2UoL1xcLiQvLCAnJyk/LnRvTG93ZXJDYXNlKCkgfHwgJyc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gbGkuaWQuc3BsaXQoJy8nKS5wb3AoKT8ubWF0Y2goL2NpdGVfbm90ZS0oLispLyk7XG5cdFx0XHRcdFx0XHRpZCA9IG1hdGNoID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6IGxpLmlkLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRlbnQgPSBsaTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpZCAmJiAhcHJvY2Vzc2VkSWRzLmhhcyhpZCkpIHtcblx0XHRcdFx0XHRmb290bm90ZXNbZm9vdG5vdGVDb3VudF0gPSB7XG5cdFx0XHRcdFx0XHRjb250ZW50OiBjb250ZW50IHx8IGxpLFxuXHRcdFx0XHRcdFx0b3JpZ2luYWxJZDogaWQsXG5cdFx0XHRcdFx0XHRyZWZzOiBbXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cHJvY2Vzc2VkSWRzLmFkZChpZCk7XG5cdFx0XHRcdFx0Zm9vdG5vdGVDb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBmb290bm90ZXM7XG5cdH1cblxuXHRwcml2YXRlIGZpbmRPdXRlckZvb3Rub3RlQ29udGFpbmVyKGVsOiBFbGVtZW50KTogRWxlbWVudCB7XG5cdFx0bGV0IGN1cnJlbnQ6IEVsZW1lbnQgfCBudWxsID0gZWw7XG5cdFx0bGV0IHBhcmVudDogRWxlbWVudCB8IG51bGwgPSBlbC5wYXJlbnRFbGVtZW50O1xuXHRcdFxuXHRcdC8vIEtlZXAgZ29pbmcgdXAgdW50aWwgd2UgZmluZCBhbiBlbGVtZW50IHRoYXQncyBub3QgYSBzcGFuIG9yIHN1cFxuXHRcdHdoaWxlIChwYXJlbnQgJiYgKFxuXHRcdFx0cGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NwYW4nIHx8IFxuXHRcdFx0cGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1cCdcblx0XHQpKSB7XG5cdFx0XHRjdXJyZW50ID0gcGFyZW50O1xuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBjdXJyZW50O1xuXHR9XG5cblx0Ly8gRXZlcnkgZm9vdG5vdGUgcmVmZXJlbmNlIHNob3VsZCBiZSBhIHN1cCBlbGVtZW50IHdpdGggYW4gYW5jaG9yIGluc2lkZVxuXHQvLyBlLmcuIDxzdXAgaWQ9XCJmbnJlZjoxXCI+PGEgaHJlZj1cIiNmbjoxXCI+MTwvYT48L3N1cD5cblx0cHJpdmF0ZSBjcmVhdGVGb290bm90ZVJlZmVyZW5jZShmb290bm90ZU51bWJlcjogc3RyaW5nLCByZWZJZDogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuXHRcdGNvbnN0IHN1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N1cCcpO1xuXHRcdHN1cC5pZCA9IHJlZklkO1xuXHRcdGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0bGluay5ocmVmID0gYCNmbjoke2Zvb3Rub3RlTnVtYmVyfWA7XG5cdFx0bGluay50ZXh0Q29udGVudCA9IGZvb3Rub3RlTnVtYmVyO1xuXHRcdHN1cC5hcHBlbmRDaGlsZChsaW5rKTtcblx0XHRyZXR1cm4gc3VwO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFuZGFyZGl6ZUZvb3Rub3RlcyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0Y29uc3QgZm9vdG5vdGVzID0gdGhpcy5jb2xsZWN0Rm9vdG5vdGVzKGVsZW1lbnQpO1xuXG5cdFx0Ly8gU3RhbmRhcmRpemUgaW5saW5lIGZvb3Rub3RlcyB1c2luZyB0aGUgY29sbGVjdGVkIElEc1xuXHRcdGNvbnN0IGZvb3Rub3RlSW5saW5lUmVmZXJlbmNlcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChGT09UTk9URV9JTkxJTkVfUkVGRVJFTkNFUyk7XG5cdFx0XG5cdFx0Ly8gR3JvdXAgcmVmZXJlbmNlcyBieSB0aGVpciBwYXJlbnQgc3VwIGVsZW1lbnRcblx0XHRjb25zdCBzdXBHcm91cHMgPSBuZXcgTWFwPEVsZW1lbnQsIEVsZW1lbnRbXT4oKTtcblx0XHRcblx0XHRmb290bm90ZUlubGluZVJlZmVyZW5jZXMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuO1xuXG5cdFx0XHRsZXQgZm9vdG5vdGVJZCA9ICcnO1xuXHRcdFx0bGV0IGZvb3Rub3RlQ29udGVudCA9ICcnO1xuXG5cdFx0XHQvLyBFeHRyYWN0IGZvb3Rub3RlIElEIGJhc2VkIG9uIGVsZW1lbnQgdHlwZVxuXHRcdFx0Ly8gTmF0dXJlLmNvbVxuXHRcdFx0aWYgKGVsLm1hdGNoZXMoJ2FbaWRePVwicmVmLWxpbmtcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdC8vIFNjaWVuY2Uub3JnXG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2Fbcm9sZT1cImRvYy1iaWJsaW9yZWZcIl0nKSkge1xuXHRcdFx0XHRjb25zdCB4bWxSaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEteG1sLXJpZCcpO1xuXHRcdFx0XHRpZiAoeG1sUmlkKSB7XG5cdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IHhtbFJpZDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBocmVmID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cdFx0XHRcdFx0aWYgKGhyZWY/LnN0YXJ0c1dpdGgoJyNjb3JlLVInKSkge1xuXHRcdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IGhyZWYucmVwbGFjZSgnI2NvcmUtJywgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gU3Vic3RhY2tcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnYS5mb290bm90ZS1hbmNob3IsIHNwYW4uZm9vdG5vdGUtaG92ZXJjYXJkLXRhcmdldCBhJykpIHtcblx0XHRcdFx0Y29uc3QgaWQgPSBlbC5pZD8ucmVwbGFjZSgnZm9vdG5vdGUtYW5jaG9yLScsICcnKSB8fCAnJztcblx0XHRcdFx0aWYgKGlkKSB7XG5cdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdC8vIEFyeGl2XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2NpdGUubHR4X2NpdGUnKSkge1xuXHRcdFx0XHRjb25zdCBsaW5rID0gZWwucXVlcnlTZWxlY3RvcignYScpO1xuXHRcdFx0XHRpZiAobGluaykge1xuXHRcdFx0XHRcdGNvbnN0IGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRcdGlmIChocmVmKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGhyZWYuc3BsaXQoJy8nKS5wb3AoKT8ubWF0Y2goL2JpYlxcLmJpYihcXGQrKS8pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdzdXAucmVmZXJlbmNlJykpIHtcblx0XHRcdFx0Y29uc3QgbGlua3MgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XG5cdFx0XHRcdEFycmF5LmZyb20obGlua3MpLmZvckVhY2gobGluayA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cdFx0XHRcdFx0aWYgKGhyZWYpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gaHJlZi5zcGxpdCgnLycpLnBvcCgpPy5tYXRjaCgvKD86Y2l0ZV9ub3RlfGNpdGVfcmVmKS0oLispLyk7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3VwW2lkXj1cImZucmVmOlwiXScpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5pZC5yZXBsYWNlKCdmbnJlZjonLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3VwW2lkXj1cImZuclwiXScpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5pZC5yZXBsYWNlKCdmbnInLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3Bhbi5mb290bm90ZS1yZWZlcmVuY2UnKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWZvb3Rub3RlLWlkJykgfHwgJyc7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3NwYW4uZm9vdG5vdGUtbGluaycpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZm9vdG5vdGUtaWQnKSB8fCAnJztcblx0XHRcdFx0Zm9vdG5vdGVDb250ZW50ID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWZvb3Rub3RlLWNvbnRlbnQnKSB8fCAnJztcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnYS5jaXRhdGlvbicpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRmb290bm90ZUNvbnRlbnQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAnJztcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnYVtpZF49XCJmbnJlZlwiXScpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5pZC5yZXBsYWNlKCdmbnJlZicsICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gT3RoZXIgY2l0YXRpb24gdHlwZXNcblx0XHRcdFx0Y29uc3QgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRpZiAoaHJlZikge1xuXHRcdFx0XHRcdGNvbnN0IGlkID0gaHJlZi5yZXBsYWNlKC9eWyNdLywgJycpO1xuXHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmb290bm90ZUlkKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIGZvb3Rub3RlIG51bWJlciBieSBtYXRjaGluZyB0aGUgb3JpZ2luYWwgSURcblx0XHRcdFx0Y29uc3QgZm9vdG5vdGVFbnRyeSA9IE9iamVjdC5lbnRyaWVzKGZvb3Rub3RlcykuZmluZChcblx0XHRcdFx0XHQoW18sIGRhdGFdKSA9PiBkYXRhLm9yaWdpbmFsSWQgPT09IGZvb3Rub3RlSWQudG9Mb3dlckNhc2UoKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChmb290bm90ZUVudHJ5KSB7XG5cdFx0XHRcdFx0Y29uc3QgW2Zvb3Rub3RlTnVtYmVyLCBmb290bm90ZURhdGFdID0gZm9vdG5vdGVFbnRyeTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBDcmVhdGUgZm9vdG5vdGUgcmVmZXJlbmNlIElEXG5cdFx0XHRcdFx0Y29uc3QgcmVmSWQgPSBmb290bm90ZURhdGEucmVmcy5sZW5ndGggPiAwID8gXG5cdFx0XHRcdFx0XHRgZm5yZWY6JHtmb290bm90ZU51bWJlcn0tJHtmb290bm90ZURhdGEucmVmcy5sZW5ndGggKyAxfWAgOiBcblx0XHRcdFx0XHRcdGBmbnJlZjoke2Zvb3Rub3RlTnVtYmVyfWA7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9vdG5vdGVEYXRhLnJlZnMucHVzaChyZWZJZCk7XG5cblx0XHRcdFx0XHQvLyBGaW5kIHRoZSBvdXRlcm1vc3QgY29udGFpbmVyIChzcGFuIG9yIHN1cClcblx0XHRcdFx0XHRjb25zdCBjb250YWluZXIgPSB0aGlzLmZpbmRPdXRlckZvb3Rub3RlQ29udGFpbmVyKGVsKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBJZiBjb250YWluZXIgaXMgYSBzdXAsIGdyb3VwIHJlZmVyZW5jZXNcblx0XHRcdFx0XHRpZiAoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1cCcpIHtcblx0XHRcdFx0XHRcdGlmICghc3VwR3JvdXBzLmhhcyhjb250YWluZXIpKSB7XG5cdFx0XHRcdFx0XHRcdHN1cEdyb3Vwcy5zZXQoY29udGFpbmVyLCBbXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IHN1cEdyb3Vwcy5nZXQoY29udGFpbmVyKSE7XG5cdFx0XHRcdFx0XHRncm91cC5wdXNoKHRoaXMuY3JlYXRlRm9vdG5vdGVSZWZlcmVuY2UoZm9vdG5vdGVOdW1iZXIsIHJlZklkKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFJlcGxhY2UgdGhlIGNvbnRhaW5lciBkaXJlY3RseVxuXHRcdFx0XHRcdFx0Y29udGFpbmVyLnJlcGxhY2VXaXRoKHRoaXMuY3JlYXRlRm9vdG5vdGVSZWZlcmVuY2UoZm9vdG5vdGVOdW1iZXIsIHJlZklkKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBIYW5kbGUgZ3JvdXBlZCByZWZlcmVuY2VzXG5cdFx0c3VwR3JvdXBzLmZvckVhY2goKHJlZmVyZW5jZXMsIGNvbnRhaW5lcikgPT4ge1xuXHRcdFx0aWYgKHJlZmVyZW5jZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBDcmVhdGUgYSBkb2N1bWVudCBmcmFnbWVudCB0byBob2xkIGFsbCB0aGUgcmVmZXJlbmNlc1xuXHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFkZCBlYWNoIHJlZmVyZW5jZSBhcyBpdHMgb3duIHN1cCBlbGVtZW50XG5cdFx0XHRcdHJlZmVyZW5jZXMuZm9yRWFjaCgocmVmLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmsgPSByZWYucXVlcnlTZWxlY3RvcignYScpO1xuXHRcdFx0XHRcdGlmIChsaW5rKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdXAnKTtcblx0XHRcdFx0XHRcdHN1cC5pZCA9IHJlZi5pZDtcblx0XHRcdFx0XHRcdHN1cC5hcHBlbmRDaGlsZChsaW5rLmNsb25lTm9kZSh0cnVlKSk7XG5cdFx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChzdXApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb250YWluZXIucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBzdGFuZGFyZGl6ZWQgZm9vdG5vdGUgbGlzdFxuXHRcdGNvbnN0IG5ld0xpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb290bm90ZXMnKTtcblx0XHRuZXdMaXN0LmNsYXNzTmFtZSA9ICdmb290bm90ZXMnO1xuXHRcdGNvbnN0IG9yZGVyZWRMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb2wnKTtcblxuXHRcdC8vIENyZWF0ZSBmb290bm90ZSBpdGVtcyBpbiBvcmRlclxuXHRcdE9iamVjdC5lbnRyaWVzKGZvb3Rub3RlcykuZm9yRWFjaCgoW251bWJlciwgZGF0YV0pID0+IHtcblx0XHRcdGNvbnN0IG5ld0l0ZW0gPSB0aGlzLmNyZWF0ZUZvb3Rub3RlSXRlbShcblx0XHRcdFx0cGFyc2VJbnQobnVtYmVyKSxcblx0XHRcdFx0ZGF0YS5jb250ZW50LFxuXHRcdFx0XHRkYXRhLnJlZnNcblx0XHRcdCk7XG5cdFx0XHRvcmRlcmVkTGlzdC5hcHBlbmRDaGlsZChuZXdJdGVtKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlbW92ZSBvcmlnaW5hbCBmb290bm90ZSBsaXN0c1xuXHRcdGNvbnN0IGZvb3Rub3RlTGlzdHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMpO1xuXHRcdGZvb3Rub3RlTGlzdHMuZm9yRWFjaChsaXN0ID0+IGxpc3QucmVtb3ZlKCkpO1xuXG5cdFx0Ly8gSWYgd2UgaGF2ZSBhbnkgZm9vdG5vdGVzLCBhZGQgdGhlIG5ldyBsaXN0IHRvIHRoZSBkb2N1bWVudFxuXHRcdGlmIChvcmRlcmVkTGlzdC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRuZXdMaXN0LmFwcGVuZENoaWxkKG9yZGVyZWRMaXN0KTtcblx0XHRcdGVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3TGlzdCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBoYW5kbGVMYXp5SW1hZ2VzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgcHJvY2Vzc2VkQ291bnQgPSAwO1xuXHRcdGNvbnN0IGxhenlJbWFnZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZ1tkYXRhLXNyY10sIGltZ1tkYXRhLXNyY3NldF0nKTtcblxuXHRcdGxhenlJbWFnZXMuZm9yRWFjaChpbWcgPT4ge1xuXHRcdFx0aWYgKCEoaW1nIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHJldHVybjtcblxuXHRcdFx0Ly8gSGFuZGxlIGRhdGEtc3JjXG5cdFx0XHRjb25zdCBkYXRhU3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblx0XHRcdGlmIChkYXRhU3JjICYmICFpbWcuc3JjKSB7XG5cdFx0XHRcdGltZy5zcmMgPSBkYXRhU3JjO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgZGF0YS1zcmNzZXRcblx0XHRcdGNvbnN0IGRhdGFTcmNzZXQgPSBpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdFx0aWYgKGRhdGFTcmNzZXQgJiYgIWltZy5zcmNzZXQpIHtcblx0XHRcdFx0aW1nLnNyY3NldCA9IGRhdGFTcmNzZXQ7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBsYXp5IGxvYWRpbmcgcmVsYXRlZCBjbGFzc2VzIGFuZCBhdHRyaWJ1dGVzXG5cdFx0XHRpbWcuY2xhc3NMaXN0LnJlbW92ZSgnbGF6eScsICdsYXp5bG9hZCcpO1xuXHRcdFx0aW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sbC1zdGF0dXMnKTtcblx0XHRcdGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG5cdFx0XHRpbWcucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdQcm9jZXNzZWQgbGF6eSBpbWFnZXM6JywgcHJvY2Vzc2VkQ291bnQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFuZGFyZGl6ZUVsZW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgcHJvY2Vzc2VkQ291bnQgPSAwO1xuXG5cdFx0Ly8gQ29udmVydCBlbGVtZW50cyBiYXNlZCBvbiBzdGFuZGFyZGl6YXRpb24gcnVsZXNcblx0XHRFTEVNRU5UX1NUQU5EQVJESVpBVElPTl9SVUxFUy5mb3JFYWNoKHJ1bGUgPT4ge1xuXHRcdFx0Y29uc3QgZWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocnVsZS5zZWxlY3Rvcik7XG5cdFx0XHRlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcblx0XHRcdFx0aWYgKHJ1bGUudHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhIHRyYW5zZm9ybSBmdW5jdGlvbiwgdXNlIGl0IHRvIGNyZWF0ZSB0aGUgbmV3IGVsZW1lbnRcblx0XHRcdFx0XHRjb25zdCB0cmFuc2Zvcm1lZCA9IHJ1bGUudHJhbnNmb3JtKGVsKTtcblx0XHRcdFx0XHRlbC5yZXBsYWNlV2l0aCh0cmFuc2Zvcm1lZCk7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBDb252ZXJ0IGxpdGUteW91dHViZSBlbGVtZW50c1xuXHRcdGNvbnN0IGxpdGVZb3V0dWJlRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpdGUteW91dHViZScpO1xuXHRcdGxpdGVZb3V0dWJlRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRjb25zdCB2aWRlb0lkID0gZWwuZ2V0QXR0cmlidXRlKCd2aWRlb2lkJyk7XG5cdFx0XHRpZiAoIXZpZGVvSWQpIHJldHVybjtcblxuXHRcdFx0Y29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUud2lkdGggPSAnNTYwJztcblx0XHRcdGlmcmFtZS5oZWlnaHQgPSAnMzE1Jztcblx0XHRcdGlmcmFtZS5zcmMgPSBgaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvJHt2aWRlb0lkfWA7XG5cdFx0XHRpZnJhbWUudGl0bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3ZpZGVvdGl0bGUnKSB8fCAnWW91VHViZSB2aWRlbyBwbGF5ZXInO1xuXHRcdFx0aWZyYW1lLmZyYW1lQm9yZGVyID0gJzAnO1xuXHRcdFx0aWZyYW1lLmFsbG93ID0gJ2FjY2VsZXJvbWV0ZXI7IGF1dG9wbGF5OyBjbGlwYm9hcmQtd3JpdGU7IGVuY3J5cHRlZC1tZWRpYTsgZ3lyb3Njb3BlOyBwaWN0dXJlLWluLXBpY3R1cmU7IHdlYi1zaGFyZSc7XG5cdFx0XHRpZnJhbWUuc2V0QXR0cmlidXRlKCdhbGxvd2Z1bGxzY3JlZW4nLCAnJyk7XG5cblx0XHRcdGVsLnJlcGxhY2VXaXRoKGlmcmFtZSk7XG5cdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdDb252ZXJ0ZWQgZW1iZWRkZWQgZWxlbWVudHM6JywgcHJvY2Vzc2VkQ291bnQpO1xuXHR9XG5cblx0Ly8gRmluZCBzbWFsbCBJTUcgYW5kIFNWRyBlbGVtZW50c1xuXHRwcml2YXRlIGZpbmRTbWFsbEltYWdlcyhkb2M6IERvY3VtZW50KTogU2V0PHN0cmluZz4ge1xuXHRcdGNvbnN0IE1JTl9ESU1FTlNJT04gPSAzMztcblx0XHRjb25zdCBzbWFsbEltYWdlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybVJlZ2V4ID0gL3NjYWxlXFwoKFtcXGQuXSspXFwpLztcblx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgcHJvY2Vzc2VkQ291bnQgPSAwO1xuXG5cdFx0Ly8gMS4gUmVhZCBwaGFzZSAtIEdhdGhlciBhbGwgZWxlbWVudHMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdGNvbnN0IGVsZW1lbnRzID0gW1xuXHRcdFx0Li4uQXJyYXkuZnJvbShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpKSxcblx0XHRcdC4uLkFycmF5LmZyb20oZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdmcnKSlcblx0XHRdLmZpbHRlcihlbGVtZW50ID0+IHtcblx0XHRcdC8vIFNraXAgbGF6eS1sb2FkZWQgaW1hZ2VzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXRcblx0XHRcdC8vIGFuZCBtYXRoIGltYWdlcyB3aGljaCBtYXkgYmUgc21hbGxcblx0XHRcdGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRjb25zdCBpZ25vcmVkSW1hZ2UgPSBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbGF6eScpIHx8IFxuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXp5bG9hZCcpIHx8XG5cdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2xhdGV4JykgfHxcblx0XHRcdFx0XHRlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGVjb2RpbmcnKSB8fFxuXHRcdFx0XHRcdGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXNyYycpIHx8XG5cdFx0XHRcdFx0ZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3Jjc2V0Jyk7XG5cdFx0XHRcdHJldHVybiAhaWdub3JlZEltYWdlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cblx0XHRpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gc21hbGxJbWFnZXM7XG5cdFx0fVxuXG5cdFx0Ly8gMi4gQmF0Y2ggcHJvY2VzcyAtIENvbGxlY3QgYWxsIG1lYXN1cmVtZW50cyBpbiBvbmUgZ29cblx0XHRjb25zdCBtZWFzdXJlbWVudHMgPSBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiAoe1xuXHRcdFx0ZWxlbWVudCxcblx0XHRcdC8vIFN0YXRpYyBhdHRyaWJ1dGVzIChubyByZWZsb3cpXG5cdFx0XHRuYXR1cmFsV2lkdGg6IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID8gZWxlbWVudC5uYXR1cmFsV2lkdGggOiAwLFxuXHRcdFx0bmF0dXJhbEhlaWdodDogZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgPyBlbGVtZW50Lm5hdHVyYWxIZWlnaHQgOiAwLFxuXHRcdFx0YXR0cldpZHRoOiBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCAnMCcpLFxuXHRcdFx0YXR0ckhlaWdodDogcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8ICcwJylcblx0XHR9KSk7XG5cblx0XHQvLyAzLiBCYXRjaCBjb21wdXRlIHN0eWxlcyAtIFByb2Nlc3MgaW4gY2h1bmtzIHRvIGF2b2lkIGxvbmcgdGFza3Ncblx0XHRjb25zdCBCQVRDSF9TSVpFID0gNTA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpICs9IEJBVENIX1NJWkUpIHtcblx0XHRcdGNvbnN0IGJhdGNoID0gbWVhc3VyZW1lbnRzLnNsaWNlKGksIGkgKyBCQVRDSF9TSVpFKTtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gUmVhZCBwaGFzZSAtIGNvbXB1dGUgYWxsIHN0eWxlcyBhdCBvbmNlXG5cdFx0XHRcdGNvbnN0IHN0eWxlcyA9IGJhdGNoLm1hcCgoeyBlbGVtZW50IH0pID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKTtcblx0XHRcdFx0Y29uc3QgcmVjdHMgPSBiYXRjaC5tYXAoKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFByb2Nlc3MgcGhhc2UgLSBubyBET00gb3BlcmF0aW9uc1xuXHRcdFx0XHRiYXRjaC5mb3JFYWNoKChtZWFzdXJlbWVudCwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3R5bGUgPSBzdHlsZXNbaW5kZXhdO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVjdCA9IHJlY3RzW2luZGV4XTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRyYW5zZm9ybSBzY2FsZSBpbiB0aGUgc2FtZSBiYXRjaFxuXHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2NhbGUgPSB0cmFuc2Zvcm0gPyBcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCh0cmFuc2Zvcm0ubWF0Y2godHJhbnNmb3JtUmVnZXgpPy5bMV0gfHwgJzEnKSA6IDE7XG5cblx0XHRcdFx0XHRcdC8vIENhbGN1bGF0ZSBlZmZlY3RpdmUgZGltZW5zaW9uc1xuXHRcdFx0XHRcdFx0Y29uc3Qgd2lkdGhzID0gW1xuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5uYXR1cmFsV2lkdGgsXG5cdFx0XHRcdFx0XHRcdG1lYXN1cmVtZW50LmF0dHJXaWR0aCxcblx0XHRcdFx0XHRcdFx0cGFyc2VJbnQoc3R5bGUud2lkdGgpIHx8IDAsXG5cdFx0XHRcdFx0XHRcdHJlY3Qud2lkdGggKiBzY2FsZVxuXHRcdFx0XHRcdFx0XS5maWx0ZXIoZGltID0+IHR5cGVvZiBkaW0gPT09ICdudW1iZXInICYmIGRpbSA+IDApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBoZWlnaHRzID0gW1xuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5uYXR1cmFsSGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5hdHRySGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRwYXJzZUludChzdHlsZS5oZWlnaHQpIHx8IDAsXG5cdFx0XHRcdFx0XHRcdHJlY3QuaGVpZ2h0ICogc2NhbGVcblx0XHRcdFx0XHRcdF0uZmlsdGVyKGRpbSA9PiB0eXBlb2YgZGltID09PSAnbnVtYmVyJyAmJiBkaW0gPiAwKTtcblxuXHRcdFx0XHRcdFx0Ly8gRGVjaXNpb24gcGhhc2UgLSBubyBET00gb3BlcmF0aW9uc1xuXHRcdFx0XHRcdFx0aWYgKHdpZHRocy5sZW5ndGggPiAwICYmIGhlaWdodHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlZmZlY3RpdmVXaWR0aCA9IE1hdGgubWluKC4uLndpZHRocyk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVmZmVjdGl2ZUhlaWdodCA9IE1hdGgubWluKC4uLmhlaWdodHMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChlZmZlY3RpdmVXaWR0aCA8IE1JTl9ESU1FTlNJT04gfHwgZWZmZWN0aXZlSGVpZ2h0IDwgTUlOX0RJTUVOU0lPTikge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmdldEVsZW1lbnRJZGVudGlmaWVyKG1lYXN1cmVtZW50LmVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzbWFsbEltYWdlcy5hZGQoaWRlbnRpZmllcik7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIGVsZW1lbnQgZGltZW5zaW9uczonLCBlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIGJhdGNoOicsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHRoaXMuX2xvZygnRm91bmQgc21hbGwgZWxlbWVudHM6Jywge1xuXHRcdFx0Y291bnQ6IHByb2Nlc3NlZENvdW50LFxuXHRcdFx0dG90YWxFbGVtZW50czogZWxlbWVudHMubGVuZ3RoLFxuXHRcdFx0cHJvY2Vzc2luZ1RpbWU6IGAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zYFxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNtYWxsSW1hZ2VzO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVTbWFsbEltYWdlcyhkb2M6IERvY3VtZW50LCBzbWFsbEltYWdlczogU2V0PHN0cmluZz4pIHtcblx0XHRsZXQgcmVtb3ZlZENvdW50ID0gMDtcblxuXHRcdFsnaW1nJywgJ3N2ZyddLmZvckVhY2godGFnID0+IHtcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XG5cdFx0XHRBcnJheS5mcm9tKGVsZW1lbnRzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRjb25zdCBpZGVudGlmaWVyID0gdGhpcy5nZXRFbGVtZW50SWRlbnRpZmllcihlbGVtZW50KTtcblx0XHRcdFx0aWYgKGlkZW50aWZpZXIgJiYgc21hbGxJbWFnZXMuaGFzKGlkZW50aWZpZXIpKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdFx0XHRyZW1vdmVkQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgc21hbGwgZWxlbWVudHM6JywgcmVtb3ZlZENvdW50KTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0RWxlbWVudElkZW50aWZpZXIoZWxlbWVudDogRWxlbWVudCk6IHN0cmluZyB8IG51bGwge1xuXHRcdC8vIFRyeSB0byBjcmVhdGUgYSB1bmlxdWUgaWRlbnRpZmllciB1c2luZyB2YXJpb3VzIGF0dHJpYnV0ZXNcblx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdC8vIEZvciBsYXp5LWxvYWRlZCBpbWFnZXMsIHVzZSBkYXRhLXNyYyBhcyBpZGVudGlmaWVyIGlmIGF2YWlsYWJsZVxuXHRcdFx0Y29uc3QgZGF0YVNyYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXHRcdFx0aWYgKGRhdGFTcmMpIHJldHVybiBgc3JjOiR7ZGF0YVNyY31gO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzcmMgPSBlbGVtZW50LnNyYyB8fCAnJztcblx0XHRcdGNvbnN0IHNyY3NldCA9IGVsZW1lbnQuc3Jjc2V0IHx8ICcnO1xuXHRcdFx0Y29uc3QgZGF0YVNyY3NldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3JjKSByZXR1cm4gYHNyYzoke3NyY31gO1xuXHRcdFx0aWYgKHNyY3NldCkgcmV0dXJuIGBzcmNzZXQ6JHtzcmNzZXR9YDtcblx0XHRcdGlmIChkYXRhU3Jjc2V0KSByZXR1cm4gYHNyY3NldDoke2RhdGFTcmNzZXR9YDtcblx0XHR9XG5cblx0XHRjb25zdCBpZCA9IGVsZW1lbnQuaWQgfHwgJyc7XG5cdFx0Y29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgfHwgJyc7XG5cdFx0Y29uc3Qgdmlld0JveCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSB8fCAnJyA6ICcnO1xuXHRcdFxuXHRcdGlmIChpZCkgcmV0dXJuIGBpZDoke2lkfWA7XG5cdFx0aWYgKHZpZXdCb3gpIHJldHVybiBgdmlld0JveDoke3ZpZXdCb3h9YDtcblx0XHRpZiAoY2xhc3NOYW1lKSByZXR1cm4gYGNsYXNzOiR7Y2xhc3NOYW1lfWA7XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRwcml2YXRlIGZpbmRNYWluQ29udGVudChkb2M6IERvY3VtZW50KTogRWxlbWVudCB8IG51bGwge1xuXG5cdFx0Ly8gRmluZCBhbGwgcG90ZW50aWFsIGNvbnRlbnQgY29udGFpbmVyc1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXM6IHsgZWxlbWVudDogRWxlbWVudDsgc2NvcmU6IG51bWJlciB9W10gPSBbXTtcblxuXHRcdEVOVFJZX1BPSU5UX0VMRU1FTlRTLmZvckVhY2goKHNlbGVjdG9yLCBpbmRleCkgPT4ge1xuXHRcdFx0Y29uc3QgZWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHRlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHQvLyBCYXNlIHNjb3JlIGZyb20gc2VsZWN0b3IgcHJpb3JpdHkgKGVhcmxpZXIgPSBoaWdoZXIpXG5cdFx0XHRcdGxldCBzY29yZSA9IChFTlRSWV9QT0lOVF9FTEVNRU5UUy5sZW5ndGggLSBpbmRleCkgKiAxMDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFkZCBzY29yZSBiYXNlZCBvbiBjb250ZW50IGFuYWx5c2lzXG5cdFx0XHRcdHNjb3JlICs9IHRoaXMuc2NvcmVFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FuZGlkYXRlcy5wdXNoKHsgZWxlbWVudCwgc2NvcmUgfSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIHNjb3JpbmcgYmxvY2sgZWxlbWVudHNcblx0XHRcdC8vIEN1cnJlbnRseSA8Ym9keT4gZWxlbWVudCBpcyB1c2VkIGFzIHRoZSBmYWxsYmFjaywgc28gdGhpcyBpcyBub3QgdXNlZFxuXHRcdFx0cmV0dXJuIHRoaXMuZmluZENvbnRlbnRCeVNjb3JpbmcoZG9jKTtcblx0XHR9XG5cblx0XHQvLyBTb3J0IGJ5IHNjb3JlIGRlc2NlbmRpbmdcblx0XHRjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcblx0XHRcblx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0dGhpcy5fbG9nKCdDb250ZW50IGNhbmRpZGF0ZXM6JywgY2FuZGlkYXRlcy5tYXAoYyA9PiAoe1xuXHRcdFx0XHRlbGVtZW50OiBjLmVsZW1lbnQudGFnTmFtZSxcblx0XHRcdFx0c2VsZWN0b3I6IHRoaXMuZ2V0RWxlbWVudFNlbGVjdG9yKGMuZWxlbWVudCksXG5cdFx0XHRcdHNjb3JlOiBjLnNjb3JlXG5cdFx0XHR9KSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYW5kaWRhdGVzWzBdLmVsZW1lbnQ7XG5cdH1cblxuXHRwcml2YXRlIGZpbmRDb250ZW50QnlTY29yaW5nKGRvYzogRG9jdW1lbnQpOiBFbGVtZW50IHwgbnVsbCB7XG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuc2NvcmVFbGVtZW50cyhkb2MpO1xuXHRcdHJldHVybiBjYW5kaWRhdGVzLmxlbmd0aCA+IDAgPyBjYW5kaWRhdGVzWzBdLmVsZW1lbnQgOiBudWxsO1xuXHR9XG5cblx0cHJpdmF0ZSBnZXRFbGVtZW50U2VsZWN0b3IoZWxlbWVudDogRWxlbWVudCk6IHN0cmluZyB7XG5cdFx0Y29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XG5cdFx0bGV0IGN1cnJlbnQ6IEVsZW1lbnQgfCBudWxsID0gZWxlbWVudDtcblx0XHRcblx0XHR3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSB0aGlzLmRvYy5kb2N1bWVudEVsZW1lbnQpIHtcblx0XHRcdGxldCBzZWxlY3RvciA9IGN1cnJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKGN1cnJlbnQuaWQpIHtcblx0XHRcdFx0c2VsZWN0b3IgKz0gJyMnICsgY3VycmVudC5pZDtcblx0XHRcdH0gZWxzZSBpZiAoY3VycmVudC5jbGFzc05hbWUgJiYgdHlwZW9mIGN1cnJlbnQuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRzZWxlY3RvciArPSAnLicgKyBjdXJyZW50LmNsYXNzTmFtZS50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKCcuJyk7XG5cdFx0XHR9XG5cdFx0XHRwYXJ0cy51bnNoaWZ0KHNlbGVjdG9yKTtcblx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCcgPiAnKTtcblx0fVxuXG5cdHByaXZhdGUgc2NvcmVFbGVtZW50cyhkb2M6IERvY3VtZW50KTogQ29udGVudFNjb3JlW10ge1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXM6IENvbnRlbnRTY29yZVtdID0gW107XG5cblx0XHRCTE9DS19FTEVNRU5UUy5mb3JFYWNoKCh0YWc6IHN0cmluZykgPT4ge1xuXHRcdFx0QXJyYXkuZnJvbShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKSkuZm9yRWFjaCgoZWxlbWVudDogRWxlbWVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCBzY29yZSA9IHRoaXMuc2NvcmVFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoc2NvcmUgPiAwKSB7XG5cdFx0XHRcdFx0Y2FuZGlkYXRlcy5wdXNoKHsgc2NvcmUsIGVsZW1lbnQgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNhbmRpZGF0ZXMuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuXHR9XG5cblx0cHJpdmF0ZSBzY29yZUVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IG51bWJlciB7XG5cdFx0bGV0IHNjb3JlID0gMDtcblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIGVsZW1lbnQgcHJvcGVydGllc1xuXHRcdGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICYmIHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBcblx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcblx0XHRjb25zdCBpZCA9IGVsZW1lbnQuaWQgPyBlbGVtZW50LmlkLnRvTG93ZXJDYXNlKCkgOiAnJztcblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIGNvbnRlbnRcblx0XHRjb25zdCB0ZXh0ID0gZWxlbWVudC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoL1xccysvKS5sZW5ndGg7XG5cdFx0c2NvcmUgKz0gTWF0aC5taW4oTWF0aC5mbG9vcih3b3JkcyAvIDEwMCksIDMpO1xuXG5cdFx0Ly8gU2NvcmUgYmFzZWQgb24gbGluayBkZW5zaXR5XG5cdFx0Y29uc3QgbGlua3MgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJyk7XG5cdFx0Y29uc3QgbGlua1RleHQgPSBBcnJheS5mcm9tKGxpbmtzKS5yZWR1Y2UoKGFjYywgbGluaykgPT4gYWNjICsgKGxpbmsudGV4dENvbnRlbnQ/Lmxlbmd0aCB8fCAwKSwgMCk7XG5cdFx0Y29uc3QgbGlua0RlbnNpdHkgPSB0ZXh0Lmxlbmd0aCA/IGxpbmtUZXh0IC8gdGV4dC5sZW5ndGggOiAwO1xuXHRcdGlmIChsaW5rRGVuc2l0eSA+IDAuNSkge1xuXHRcdFx0c2NvcmUgLT0gMTA7XG5cdFx0fVxuXG5cdFx0Ly8gU2NvcmUgYmFzZWQgb24gcHJlc2VuY2Ugb2YgbWVhbmluZ2Z1bCBlbGVtZW50c1xuXHRcdGNvbnN0IHBhcmFncmFwaHMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwJykubGVuZ3RoO1xuXHRcdHNjb3JlICs9IHBhcmFncmFwaHM7XG5cblx0XHRjb25zdCBpbWFnZXMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKS5sZW5ndGg7XG5cdFx0c2NvcmUgKz0gTWF0aC5taW4oaW1hZ2VzICogMywgOSk7XG5cblx0XHRyZXR1cm4gc2NvcmU7XG5cdH1cbn0gIiwiLy8gRW50cnkgcG9pbnQgZWxlbWVudHNcbi8vIFRoZXNlIGFyZSB0aGUgZWxlbWVudHMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZmluZCB0aGUgbWFpbiBjb250ZW50XG5leHBvcnQgY29uc3QgRU5UUllfUE9JTlRfRUxFTUVOVFMgPSBbXG5cdCdhcnRpY2xlJyxcblx0J1tyb2xlPVwiYXJ0aWNsZVwiXScsXG5cdCcucG9zdC1jb250ZW50Jyxcblx0Jy5hcnRpY2xlLWNvbnRlbnQnLFxuXHQnI2FydGljbGUtY29udGVudCcsXG5cdCcuY29udGVudC1hcnRpY2xlJyxcblx0J21haW4nLFxuXHQnW3JvbGU9XCJtYWluXCJdJyxcblx0J2JvZHknIC8vIGVuc3VyZXMgdGhlcmUgaXMgYWx3YXlzIGEgbWF0Y2hcbl07XG5cbmV4cG9ydCBjb25zdCBNT0JJTEVfV0lEVEggPSA2MDA7XG5leHBvcnQgY29uc3QgQkxPQ0tfRUxFTUVOVFMgPSBbJ2RpdicsICdzZWN0aW9uJywgJ2FydGljbGUnLCAnbWFpbiddO1xuXG4vLyBFbGVtZW50cyB0aGF0IHNob3VsZCBub3QgYmUgdW53cmFwcGVkXG5leHBvcnQgY29uc3QgUFJFU0VSVkVfRUxFTUVOVFMgPSBuZXcgU2V0KFtcblx0J3ByZScsICdjb2RlJywgJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3RyJywgJ3RkJywgJ3RoJyxcblx0J3VsJywgJ29sJywgJ2xpJywgJ2RsJywgJ2R0JywgJ2RkJyxcblx0J2ZpZ3VyZScsICdmaWdjYXB0aW9uJywgJ3BpY3R1cmUnLFxuXHQnZGV0YWlscycsICdzdW1tYXJ5Jyxcblx0J2Jsb2NrcXVvdGUnLFxuXHQnZm9ybScsICdmaWVsZHNldCdcbl0pO1xuXG4vLyBJbmxpbmUgZWxlbWVudHMgdGhhdCBzaG91bGQgbm90IGJlIHVud3JhcHBlZFxuZXhwb3J0IGNvbnN0IElOTElORV9FTEVNRU5UUyA9IG5ldyBTZXQoW1xuXHQnYScsICdzcGFuJywgJ3N0cm9uZycsICdlbScsICdpJywgJ2InLCAndScsICdjb2RlJywgJ2JyJywgJ3NtYWxsJyxcblx0J3N1YicsICdzdXAnLCAnbWFyaycsICdkZWwnLCAnaW5zJywgJ3EnLCAnYWJicicsICdjaXRlJywgJ3RpbWUnXG5dKTtcblxuLy8gSGlkZGVuIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWRcbmV4cG9ydCBjb25zdCBISURERU5fRUxFTUVOVF9TRUxFQ1RPUlMgPSBbXG5cdCdbaGlkZGVuXScsXG4vL1x0J1thcmlhLWhpZGRlbj1cInRydWVcIl0nLCBuZWVkZWQgZm9yIG1hdGggZm9ybXVsYXNcbi8vXHQnW3N0eWxlKj1cImRpc3BsYXk6IG5vbmVcIl0nLCBuZWVkZWQgZm9yIGZvciBtYXRoIGZvcm11bGFzXG4vL1x0J1tzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0nLFxuXHQnW3N0eWxlKj1cInZpc2liaWxpdHk6IGhpZGRlblwiXScsXG5cdCdbc3R5bGUqPVwidmlzaWJpbGl0eTpoaWRkZW5cIl0nLFxuXHQnLmhpZGRlbicsXG5cdCcuaW52aXNpYmxlJ1xuXS5qb2luKCcsJyk7XG5cbi8vIFNlbGVjdG9ycyB0byBiZSByZW1vdmVkXG5leHBvcnQgY29uc3QgRVhBQ1RfU0VMRUNUT1JTID0gW1xuXHQvLyBzY3JpcHRzLCBzdHlsZXNcblx0J25vc2NyaXB0Jyxcblx0J3NjcmlwdCcsXG5cdCdzdHlsZScsXG5cblx0Ly8gYWRzXG5cdCcuYWQ6bm90KFtjbGFzcyo9XCJncmFkaWVudFwiXSknLFxuXHQnW2NsYXNzXj1cImFkLVwiIGldJyxcblx0J1tjbGFzcyQ9XCItYWRcIiBpXScsXG5cdCdbaWRePVwiYWQtXCIgaV0nLFxuXHQnW2lkJD1cIi1hZFwiIGldJyxcblx0J1tyb2xlPVwiYmFubmVyXCIgaV0nLFxuXHQnLnByb21vJyxcblx0Jy5Qcm9tbycsXG5cdCcjYmFycmllci1wYWdlJywgLy8gZnQuY29tXG5cblx0Ly8gY29tbWVudHNcblx0J1tpZD1cImNvbW1lbnRzXCIgaV0nLFxuXG5cdC8vIGhlYWRlciwgbmF2XG5cdCdoZWFkZXInLFxuXHQnLmhlYWRlcicsXG5cdCcjaGVhZGVyJyxcblx0J25hdicsXG5cdCcubmF2aWdhdGlvbicsXG5cdCcjbmF2aWdhdGlvbicsXG5cdCdbcm9sZT1cIm5hdmlnYXRpb25cIiBpXScsXG5cdCdbcm9sZT1cImRpYWxvZ1wiIGldJyxcblx0J1tyb2xlKj1cImNvbXBsZW1lbnRhcnlcIiBpXScsXG5cdCdbY2xhc3MqPVwicGFnaW5hdGlvblwiIGldJyxcblx0Jy5tZW51Jyxcblx0JyNtZW51Jyxcblx0JyNzaXRlU3ViJyxcblxuXHQvLyBtZXRhZGF0YVxuXHQnLmF1dGhvcicsXG5cdCcuQXV0aG9yJyxcblx0Jy5jb250cmlidXRvcicsXG5cdCcuZGF0ZScsXG5cdCcubWV0YScsXG5cdCcudGFncycsXG5cdCcudG9jJyxcblx0Jy5Ub2MnLFxuXHQnI3RvYycsXG5cdCcjdGl0bGUnLFxuXHQnI1RpdGxlJyxcblx0J1tocmVmKj1cIi9jYXRlZ29yeVwiXScsXG5cdCdbaHJlZio9XCIvY2F0ZWdvcmllc1wiXScsXG5cdCdbaHJlZio9XCIvdGFnL1wiXScsXG5cdCdbaHJlZio9XCIvdGFncy9cIl0nLFxuXHQnW2hyZWYqPVwiL3RvcGljc1wiXScsXG5cdCdbaHJlZio9XCJhdXRob3JcIl0nLFxuXHQnW2hyZWY9XCIjc2l0ZS1jb250ZW50XCJdJyxcblx0J1tzcmMqPVwiYXV0aG9yXCJdJyxcblxuXHQvLyBmb290ZXJcblx0J2Zvb3RlcicsXG5cblx0Ly8gaW5wdXRzLCBmb3JtcywgZWxlbWVudHNcblx0J2FzaWRlJyxcblx0J2J1dHRvbicsXG5cdFx0Ly8gJ1tyb2xlPVwiYnV0dG9uXCJdJywgTWVkaXVtIGltYWdlc1xuXHQnY2FudmFzJyxcblx0J2RpYWxvZycsXG5cdCdmaWVsZHNldCcsXG5cdCdmb3JtJyxcblx0J2lucHV0Om5vdChbdHlwZT1cImNoZWNrYm94XCJdKScsXG5cdCdsYWJlbCcsXG5cdCdsaW5rJyxcblx0J29wdGlvbicsXG5cdCdzZWxlY3QnLFxuXHQndGV4dGFyZWEnLFxuXHQndGltZScsXG5cblx0Ly8gaWZyYW1lc1xuXHQnaW5zdGFyZWFkLXBsYXllcicsXG5cdCdpZnJhbWU6bm90KFtzcmMqPVwieW91dHViZVwiXSk6bm90KFtzcmMqPVwieW91dHUuYmVcIl0pOm5vdChbc3JjKj1cInZpbWVvXCJdKTpub3QoW3NyYyo9XCJ0d2l0dGVyXCJdKScsXG5cblx0Ly8gbG9nb3Ncblx0J1tjbGFzcz1cImxvZ29cIiBpXScsXG5cdCcjbG9nbycsXG5cdCcjTG9nbycsXG5cblx0Ly8gbmV3c2xldHRlclxuXHQnI25ld3NsZXR0ZXInLFxuXHQnI05ld3NsZXR0ZXInLFxuXG5cdC8vIGhpZGRlbiBmb3IgcHJpbnRcblx0Jy5ub3ByaW50Jyxcblx0J1tkYXRhLWxpbmstbmFtZSo9XCJza2lwXCIgaV0nLFxuXHQnW2RhdGEtcHJpbnQtbGF5b3V0PVwiaGlkZVwiIGldJyxcblx0J1tkYXRhLWJsb2NrPVwiZG9ub3RwcmludFwiIGldJyxcblxuXHQvLyBmb290bm90ZXMsIGNpdGF0aW9uc1xuXHQnW2NsYXNzKj1cImNsaWNrYWJsZS1pY29uXCIgaV0nLFxuXHQnbGkgc3BhbltjbGFzcyo9XCJsdHhfdGFnXCIgaV1bY2xhc3MqPVwibHR4X3RhZ19pdGVtXCIgaV0nLFxuXHQnYVtocmVmXj1cIiNcIl1bY2xhc3MqPVwiYW5jaG9yXCIgaV0nLFxuXHQnYVtocmVmXj1cIiNcIl1bY2xhc3MqPVwicmVmXCIgaV0nLFxuXG5cdC8vIGxpbmsgbGlzdHNcblx0J1tkYXRhLWNvbnRhaW5lcio9XCJtb3N0LXZpZXdlZFwiIGldJyxcblxuXHQvLyBzaWRlYmFyXG5cdCcuc2lkZWJhcicsXG5cdCcuU2lkZWJhcicsXG5cdCcjc2lkZWJhcicsXG5cdCcjU2lkZWJhcicsXG5cdCcjc2l0ZXN1YicsXG5cdFxuXHQvLyBvdGhlclxuXHQnI3ByaW1hcnlhdWRpbycsIC8vIE5QUlxuXHQnI05ZVF9BQk9WRV9NQUlOX0NPTlRFTlRfUkVHSU9OJyxcblx0J1tkYXRhLXRlc3RpZD1cInBob3Rvdmlld2VyLWNoaWxkcmVuLWZpZ3VyZVwiXSA+IHNwYW4nLCAvLyBOZXcgWW9yayBUaW1lc1xuXHQndGFibGUuaW5mb2JveCcsXG5cdCcucGVuY3JhZnQ6bm90KC5wYy1kaXNwbGF5LWNvbnRlbnRzKScsIC8vIFN1YnN0YWNrXG5cdCdbZGF0YS1vcHRpbWl6ZWx5PVwicmVsYXRlZC1hcnRpY2xlcy1zZWN0aW9uXCIgaV0nIC8vIFRoZSBFY29ub21pc3Rcbl07XG5cbi8vIFJlbW92YWwgcGF0dGVybnMgdGVzdGVkIGFnYWluc3QgYXR0cmlidXRlczogY2xhc3MsIGlkLCBkYXRhLXRlc3RpZCwgYW5kIGRhdGEtcWFcbi8vIENhc2UgaW5zZW5zaXRpdmUsIHBhcnRpYWwgbWF0Y2hlcyBhbGxvd2VkXG5leHBvcnQgY29uc3QgUEFSVElBTF9TRUxFQ1RPUlMgPSBbXG5cdCdhY2Nlc3Mtd2FsbCcsXG5cdCdhY3Rpdml0eXB1YicsXG5cdCdhY3Rpb25jYWxsJyxcblx0J2FwcGVuZGl4Jyxcblx0J2F2YXRhcicsXG5cdCdhZHZlcnQnLFxuXHQnLWFkLScsXG5cdCdfYWRfJyxcblx0J2FsbHRlcm1zJyxcblx0J2Fyb3VuZC10aGUtd2ViJyxcblx0J2FydGljbGUtYm90dG9tLXNlY3Rpb24nLFxuXHQnYXJ0aWNsZV9fY29weScsXG5cdCdhcnRpY2xlX2RhdGUnLFxuXHQnYXJ0aWNsZS1lbmQgJyxcblx0J2FydGljbGVfaGVhZGVyJyxcblx0J2FydGljbGVfX2hlYWRlcicsXG5cdCdhcnRpY2xlX19pbmZvJyxcblx0J2FydGljbGUtaW5mbycsXG5cdCdhcnRpY2xlX19tZXRhJyxcblx0J2FydGljbGUtc3ViamVjdCcsXG5cdCdhcnRpY2xlX3N1YmplY3QnLFxuXHQnYXJ0aWNsZS1zbmlwcGV0Jyxcblx0J2FydGljbGUtc2VwYXJhdG9yJyxcblx0J2FydGljbGUtLXNoYXJlJyxcblx0J2FydGljbGUtLXRvcGljcycsXG5cdCdhcnRpY2xldGFncycsXG5cdCdhcnRpY2xlLXRhZ3MnLFxuXHQnYXJ0aWNsZV90YWdzJyxcblx0J2FydGljbGUtdGl0bGUnLFxuXHQnYXJ0aWNsZV90aXRsZScsXG5cdCdhcnRpY2xldG9waWNzJyxcblx0J2FydGljbGUtdG9waWNzJyxcblx0J2FydGljbGUtdHlwZScsXG5cdCdhcnRpY2xlLS1sZWRlJywgLy8gVGhlIFZlcmdlXG5cdCdhcnRpY2xld2VsbCcsXG5cdCdhc3NvY2lhdGVkLXBlb3BsZScsXG5cdCdhdWRpby1jYXJkJyxcbi8vXHQnYXV0aG9yJywgR3dlcm5cblx0J2F1dGhvcmVkLWJ5Jyxcblx0J2F1dGhvci1ib3gnLFxuXHQnYXV0aG9yLW5hbWUnLFxuXHQnYXV0aG9yLWJpbycsXG5cdCdhdXRob3ItbWluaS1iaW8nLFxuXHQnYmFjay10by10b3AnLFxuXHQnYmFja2xpbmtzLXNlY3Rpb24nLFxuXHQnYmFubmVyJyxcblx0J2Jpby1ibG9jaycsXG5cdCdibG9nLXBhZ2VyJyxcblx0J2Jvb2ttYXJrLScsXG5cdCctYm9va21hcmsnLFxuXHQnYm90dG9tLW9mLWFydGljbGUnLFxuXHQnYnJhbmQtYmFyJyxcblx0J2JyZWFkY3J1bWInLFxuXHQnYnV0dG9uLXdyYXBwZXInLFxuXHQnYnRuLScsXG5cdCctYnRuJyxcblx0J2J5bGluZScsXG5cdCdjYXB0Y2hhJyxcblx0J2NhcmQtdGV4dCcsXG5cdCdjYXJkLW1lZGlhJyxcblx0J2NhdF9oZWFkZXInLFxuXHQnY2F0bGlua3MnLFxuXHQnY2hhcHRlci1saXN0JywgLy8gVGhlIEVjb25vbWlzdFxuXHQnY29sbGVjdGlvbnMnLFxuXHQnY29tbWVudHMnLFxuLy9cdCctY29tbWVudCcsIFN5bnRheCBoaWdobGlnaHRpbmdcblx0J2NvbW1lbnRib3gnLFxuXHQnY29tbWVudC1jb3VudCcsXG5cdCdjb21tZW50LWNvbnRlbnQnLFxuXHQnY29tbWVudC1mb3JtJyxcblx0J2NvbW1lbnQtbnVtYmVyJyxcblx0J2NvbW1lbnQtcmVzcG9uZCcsXG5cdCdjb21tZW50LXRocmVhZCcsXG5cdCdjb21wbGVtZW50YXJ5Jyxcblx0J2NvbnNlbnQnLFxuXHQnY29udGVudC1jYXJkJywgLy8gVGhlIFZlcmdlXG5cdCdjb250ZW50LXRvcGljcycsXG5cdCdjb250ZW50cHJvbW8nLFxuXHQnY29udGV4dC13aWRnZXQnLCAvLyBSZXV0ZXJzXG5cdCdjb3JlLWNvbGxhdGVyYWwnLFxuXHQnX2N0YScsXG5cdCctY3RhJyxcblx0J2N0YS0nLFxuXHQnY3RhXycsXG5cdCdjdXJyZW50LWlzc3VlJywgLy8gVGhlIE5hdGlvblxuXHQnY3VzdG9tLWxpc3QtbnVtYmVyJyxcblx0J2RhdGVsaW5lJyxcblx0J2RhdGVoZWFkZXInLFxuXHQnZGF0ZS1oZWFkZXInLFxuXHQnZGF0ZV9oZWFkZXItJyxcbi8vXHQnZGlhbG9nJyxcblx0J2Rpc2NsYWltZXInLFxuXHQnZGlzY2xvc3VyZScsXG5cdCdkaXNjdXNzaW9uJyxcblx0J2Rpc2N1c3NfJyxcblx0J2Rpc3F1cycsXG5cdCdkb25hdGUnLFxuXHQnZHJvcGRvd24nLCAvLyBBcnMgVGVjaG5pY2Fcblx0J2VsZXR0ZXJzJyxcblx0J2VtYWlsc2lnbnVwJyxcblx0J2VuZ2FnZW1lbnQtd2lkZ2V0Jyxcblx0J2VudHJ5LWF1dGhvci1pbmZvJyxcblx0J2VudHJ5LWNhdGVnb3JpZXMnLFxuXHQnZW50cnktZGF0ZScsXG5cdCdlbnRyeS1tZXRhJyxcblx0J2VudHJ5LXRpdGxlJyxcblx0J2VudHJ5LXV0aWxpdHknLFxuXHQnZXllYnJvdycsXG5cdCdleHBhbmQtcmVkdWNlJyxcblx0J2V4dGVybmFsbGlua2VtYmVkd3JhcHBlcicsIC8vIFRoZSBOZXcgWW9ya2VyXG5cdCdleHRyYS1zZXJ2aWNlcycsXG5cdCdleHRyYS10aXRsZScsXG5cdCdmYWNlYm9vaycsXG5cdCdmYXZvcml0ZScsXG5cdCdmZWVkYmFjaycsXG5cdCdmZWVkLWxpbmtzJyxcblx0J2ZpZWxkLXNpdGUtc2VjdGlvbnMnLFxuXHQnZml4ZWQnLFxuXHQnZmxvYXRpbmctdmlkJyxcblx0J2ZvbGxvdycsXG5cdCdmb290ZXInLFxuXHQnZm9vdG5vdGUtYmFjaycsXG5cdCdmb290bm90ZWJhY2snLFxuXHQnZm9yLXlvdScsXG5cdCdmcm9udG1hdHRlcicsXG5cdCdmdXJ0aGVyLXJlYWRpbmcnLFxuXHQnZ2lzdC1tZXRhJyxcbi8vXHQnZ2xvYmFsJyxcblx0J2dvb2dsZScsXG5cdCdnb29nLScsXG5cdCdncmFwaC12aWV3Jyxcblx0J2hlYWRlci1sb2dvJyxcblx0J2hlYWRlci1wYXR0ZXJuJywgLy8gVGhlIFZlcmdlXG5cdCdoZXJvLWxpc3QnLFxuXHQnaGlkZS1mb3ItcHJpbnQnLFxuXHQnaGlkZS1wcmludCcsXG5cdCdoaWRlLXdoZW4tbm8tc2NyaXB0Jyxcblx0J2hpZGRlbi1zaWRlbm90ZScsXG5cdCdpbnRlcmx1ZGUnLFxuXHQnaW50ZXJhY3Rpb24nLFxuXHQnanVtcGxpbmsnLFxuXHQnanVtcC10by0nLFxuLy9cdCdrZXl3b3JkJywgLy8gdXNlZCBpbiBzeW50YXggaGlnaGxpZ2h0aW5nXG5cdCdraWNrZXInLFxuXHQnbGFic3RhYicsIC8vIEFyeGl2XG5cdCctbGFiZWxzJyxcblx0J2xhbmd1YWdlLW5hbWUnLFxuXHQnbGF0ZXN0LWNvbnRlbnQnLFxuXHQnLWxlZGVzLScsIC8vIFRoZSBWZXJnZVxuXHQnLWxpY2Vuc2UnLFxuXHQnbGluay1ib3gnLFxuXHQnbGlua3MtZ3JpZCcsIC8vIEJCQ1xuXHQnbGlua3MtdGl0bGUnLCAvLyBCQkNcblx0J2xpc3RpbmctZHluYW1pYy10ZXJtcycsIC8vIEJvc3RvbiBSZXZpZXdcblx0J2xpc3QtdGFncycsXG5cdCdsb2FkaW5nJyxcblx0J2xvYS1pbmZvJyxcblx0J2xvZ29fY29udGFpbmVyJyxcblx0J2x0eF9yb2xlX3JlZm51bScsIC8vIEFyeGl2XG5cdCdsdHhfdGFnX2JpYml0ZW0nLFxuXHQnbHR4X2Vycm9yJyxcblx0J21hcmtldGluZycsXG5cdCdtZWRpYS1pbnF1aXJ5Jyxcblx0J21lbnUtJyxcblx0J21ldGEtJyxcblx0J21ldGFkYXRhJyxcblx0J21pZ2h0LWxpa2UnLFxuXHQnX21vZGFsJyxcblx0Jy1tb2RhbCcsXG5cdCdtb3JlLScsXG5cdCdtb3JlbmV3cycsXG5cdCdtb3Jlc3RvcmllcycsXG5cdCdtb3ZlLWhlbHBlcicsXG5cdCdtdy1lZGl0c2VjdGlvbicsXG5cdCdtdy1jaXRlLWJhY2tsaW5rJyxcblx0J213LWluZGljYXRvcnMnLFxuXHQnbXctanVtcC1saW5rJyxcblx0J25hdi0nLFxuXHQnbmF2XycsXG5cdCduYXZiYXInLFxuLy9cdCduYXZpZ2F0aW9uJyxcblx0J25leHQtJyxcblx0J25ld3Mtc3RvcnktdGl0bGUnLFxuLy9cdCduZXdzbGV0dGVyJywgdXNlZCBvbiBTdWJzdGFja1xuXHQnbmV3c2xldHRlcl8nLFxuXHQnbmV3c2xldHRlci1zaWdudXAnLFxuXHQnbmV3c2xldHRlcnNpZ251cCcsXG5cdCduZXdzbGV0dGVyd2lkZ2V0Jyxcblx0J25ld3NsZXR0ZXJ3cmFwcGVyJyxcblx0J25vdC1mb3VuZCcsXG5cdCdub21vYmlsZScsXG5cdCdub3ByaW50Jyxcblx0J29yaWdpbmFsbHktcHVibGlzaGVkJywgLy8gTWVyY3VyeSBOZXdzXG5cdCdvdXRsaW5lLXZpZXcnLFxuXHQnb3ZlcmxheScsXG5cdCdwYWdlLXRpdGxlJyxcblx0Jy1wYXJ0bmVycycsXG5cdCdwbGVhJyxcblx0J3BvcHVsYXInLFxuLy9cdCdwb3B1cCcsIEd3ZXJuXG5cdCdwb3AtdXAnLFxuXHQncG9wb3ZlcicsXG5cdCdwb3N0LWJvdHRvbScsXG5cdCdwb3N0X19jYXRlZ29yeScsXG5cdCdwb3N0Y29tbWVudCcsXG5cdCdwb3N0ZGF0ZScsXG5cdCdwb3N0LWF1dGhvcicsXG5cdCdwb3N0LWRhdGUnLFxuXHQncG9zdF9kYXRlJyxcblx0J3Bvc3QtZmVlZHMnLFxuXHQncG9zdGluZm8nLFxuXHQncG9zdC1pbmZvJyxcblx0J3Bvc3RfaW5mbycsXG5cdCdwb3N0LWlubGluZS1kYXRlJyxcblx0J3Bvc3QtbGlua3MnLFxuXHQncG9zdC1tZXRhJyxcblx0J3Bvc3RtZXRhJyxcblx0J3Bvc3RzbmlwcGV0Jyxcblx0J3Bvc3Rfc25pcHBldCcsXG5cdCdwb3N0LXNuaXBwZXQnLFxuXHQncG9zdHRpdGxlJyxcblx0J3Bvc3QtdGl0bGUnLFxuXHQncG9zdF90aXRsZScsXG5cdCdwb3N0dGF4Jyxcblx0J3Bvc3QtdGF4Jyxcblx0J3Bvc3RfdGF4Jyxcblx0J3Bvc3R0YWcnLFxuXHQncG9zdF90YWcnLFxuXHQncG9zdC10YWcnLFxuLy9cdCdwcmV2aWV3JywgdXNlZCBvbiBPYnNpZGlhbiBQdWJsaXNoXG5cdCdwcmV2bmV4dCcsXG5cdCdwcmV2aW91c25leHQnLFxuXHQncHJlc3MtaW5xdWlyaWVzJyxcblx0J3ByaW50LW5vbmUnLFxuXHQncHJpbnQtaGVhZGVyJyxcblx0J3Byb2ZpbGUnLFxuLy9cdCdwcm9tbycsXG5cdCdwcm9tby1ib3gnLFxuXHQncHViZGF0ZScsXG5cdCdwdWJfZGF0ZScsXG5cdCdwdWItZGF0ZScsXG5cdCdwdWJsaWNhdGlvbi1kYXRlJyxcblx0J3B1YmxpY2F0aW9uTmFtZScsIC8vIE1lZGl1bVxuXHQncXItY29kZScsXG5cdCdxcl9jb2RlJyxcblx0J19yYWlsJyxcblx0J3JlYWRtb3JlJyxcblx0J3JlYWQtbmV4dCcsXG5cdCdyZWFkX25leHQnLFxuXHQncmVhZF90aW1lJyxcblx0J3JlYWQtdGltZScsXG5cdCdyZWFkaW5nX3RpbWUnLFxuXHQncmVhZGluZy10aW1lJyxcblx0J3JlYWRpbmctbGlzdCcsXG5cdCdyZWNlbnRwb3N0Jyxcblx0J3JlY2VudF9wb3N0Jyxcblx0J3JlY2VudC1wb3N0Jyxcblx0J3JlY29tbWVuZCcsXG5cdCdyZWRpcmVjdGVkZnJvbScsXG5cdCdyZWNpcmMnLFxuXHQncmVnaXN0ZXInLFxuXHQncmVsYXRlZCcsXG5cdCdyZWxldmFudCcsXG5cdCdyZXZlcnNlZm9vdG5vdGUnLFxuXHQnc2NyZWVuLXJlYWRlci10ZXh0Jyxcbi8vXHQnc2hhcmUnLFxuLy9cdCctc2hhcmUnLCBzY2l0ZWNoZGFpbHkuY29tXG5cdCdzaGFyZS1ib3gnLFxuXHQnc2hhcmVkYWRkeScsXG5cdCdzaGFyZS1pY29ucycsXG5cdCdzaGFyZWxpbmtzJyxcblx0J3NoYXJlLXNlY3Rpb24nLFxuXHQnc2lkZWJhcnRpdGxlJyxcblx0J3NpZGViYXJfJyxcblx0J3NpZGViYXItY29udGVudCcsXG5cdCdzaW1pbGFyLScsXG5cdCdzaW1pbGFyXycsXG5cdCdzaW1pbGFycy0nLFxuXHQnc2lkZWl0ZW1zJyxcblx0J3NpZGUtYm94Jyxcblx0J3NpdGUtaW5kZXgnLFxuXHQnc2l0ZS1oZWFkZXInLFxuXHQnc2l0ZS1sb2dvJyxcblx0J3NpdGUtbmFtZScsXG4vL1x0J3NraXAtJyxcbi8vXHQnc2tpcC1saW5rJywgVGVjaENydW5jaFxuXHQnX3NraXAtbGluaycsXG5cdCdzbHVnLXdyYXAnLFxuXHQnc29jaWFsJyxcblx0J3NwZWVjaGlmeS1pZ25vcmUnLFxuXHQnc3BvbnNvcicsXG5cdCdzcHJpbmdlcmNpdGF0aW9uJyxcbi8vXHQnLXN0YXRzJyxcblx0J19zdGF0cycsXG5cdCdzdGlja3knLFxuXHQnc3RvcnlyZWFkdGltZScsIC8vIE1lZGl1bVxuXHQnc3RvcnlwdWJsaXNoZGF0ZScsIC8vIE1lZGl1bVxuXHQnc3ViamVjdC1sYWJlbCcsXG5cdCdzdWJzY3JpYmUnLFxuXHQnX3RhZ3MnLFxuXHQndGFnc19faXRlbScsXG5cdCd0YWdfbGlzdCcsXG5cdCd0YXhvbm9teScsXG5cdCd0YWJsZS1vZi1jb250ZW50cycsXG5cdCd0YWJzLScsXG4vL1x0J3RlYXNlcicsIE5hdHVyZVxuXHQndGVybWluYWx0b3V0Jyxcblx0J3RpbWUtcnVicmljJyxcblx0J3RpbWVzdGFtcCcsXG5cdCd0aXBfb2ZmJyxcblx0J3RpcHRvdXQnLFxuXHQnLXRvdXQtJyxcblx0Jy10b2MnLFxuXHQndG9nZ2xlLWNhcHRpb24nLFxuXHQndG9waWMtbGlzdCcsXG5cdCd0b29sYmFyJyxcblx0J3Rvb2x0aXAnLFxuXHQndG9wLXdyYXBwZXInLFxuXHQndHJlZS1pdGVtJyxcblx0J3RyZW5kaW5nJyxcblx0J3RydXN0LWZlYXQnLFxuXHQndHJ1c3QtYmFkZ2UnLFxuXHQndHdpdHRlcicsXG5cdCd2aXN1YWxseS1oaWRkZW4nLFxuXHQnd2VsY29tZWJveCdcbi8vXHQnd2lkZ2V0LSdcbl07XG5cbi8vIFNlbGVjdG9ycyBmb3IgZm9vdG5vdGVzIGFuZCBjaXRhdGlvbnNcbmV4cG9ydCBjb25zdCBGT09UTk9URV9JTkxJTkVfUkVGRVJFTkNFUyA9IFtcblx0J3N1cC5yZWZlcmVuY2UnLFxuXHQnY2l0ZS5sdHhfY2l0ZScsXG5cdCdzdXBbaWRePVwiZm5yXCJdJyxcblx0J3N1cFtpZF49XCJmbnJlZjpcIl0nLFxuXHQnc3Bhbi5mb290bm90ZS1saW5rJyxcblx0J2EuY2l0YXRpb24nLFxuXHQnYVtpZF49XCJyZWYtbGlua1wiXScsXG5cdCdhW2hyZWZePVwiI2ZuXCJdJyxcblx0J2FbaHJlZl49XCIjY2l0ZVwiXScsXG5cdCdhW2hyZWZePVwiI3JlZmVyZW5jZVwiXScsXG5cdCdhW2hyZWZePVwiI2Zvb3Rub3RlXCJdJyxcblx0J2FbaHJlZl49XCIjclwiXScsIC8vIENvbW1vbiBpbiBhY2FkZW1pYyBwYXBlcnNcblx0J2FbaHJlZl49XCIjYlwiXScsIC8vIENvbW1vbiBmb3IgYmlibGlvZ3JhcGh5IHJlZmVyZW5jZXNcblx0J2FbaHJlZio9XCJjaXRlX25vdGVcIl0nLFxuXHQnYVtocmVmKj1cImNpdGVfcmVmXCJdJyxcblx0J2EuZm9vdG5vdGUtYW5jaG9yJywgLy8gU3Vic3RhY2tcblx0J3NwYW4uZm9vdG5vdGUtaG92ZXJjYXJkLXRhcmdldCBhJywgLy8gU3Vic3RhY2tcblx0J2Fbcm9sZT1cImRvYy1iaWJsaW9yZWZcIl0nLCAvLyBTY2llbmNlLm9yZ1xuXHQnYVtpZF49XCJmbnJlZlwiXScsXG5cdCdhW2lkXj1cInJlZi1saW5rXCJdJywgLy8gTmF0dXJlLmNvbVxuXS5qb2luKCcsJyk7XG5cbmV4cG9ydCBjb25zdCBGT09UTk9URV9MSVNUX1NFTEVDVE9SUyA9IFtcblx0J2Rpdi5mb290bm90ZSBvbCcsXG5cdCdkaXYuZm9vdG5vdGVzIG9sJyxcblx0J2Rpdltyb2xlPVwiZG9jLWVuZG5vdGVzXCJdJyxcblx0J2Rpdltyb2xlPVwiZG9jLWZvb3Rub3Rlc1wiXScsXG5cdCdvbC5mb290bm90ZXMtbGlzdCcsXG5cdCdvbC5mb290bm90ZXMnLFxuXHQnb2wucmVmZXJlbmNlcycsXG5cdCdvbFtjbGFzcyo9XCJhcnRpY2xlLXJlZmVyZW5jZXNcIl0nLFxuXHQnc2VjdGlvbi5mb290bm90ZXMgb2wnLFxuXHQnc2VjdGlvbltyb2xlPVwiZG9jLWVuZG5vdGVzXCJdJyxcblx0J3NlY3Rpb25bcm9sZT1cImRvYy1mb290bm90ZXNcIl0nLFxuXHQnc2VjdGlvbltyb2xlPVwiZG9jLWJpYmxpb2dyYXBoeVwiXScsXG5cdCd1bC5mb290bm90ZXMtbGlzdCcsXG5cdCd1bC5sdHhfYmlibGlzdCcsXG5cdCdkaXYuZm9vdG5vdGVbZGF0YS1jb21wb25lbnQtbmFtZT1cIkZvb3Rub3RlVG9ET01cIl0nIC8vIFN1YnN0YWNrXG5dLmpvaW4oJywnKTtcblxuLy8gRWxlbWVudHMgdGhhdCBhcmUgYWxsb3dlZCB0byBiZSBlbXB0eVxuLy8gVGhlc2UgYXJlIG5vdCByZW1vdmVkIGV2ZW4gaWYgdGhleSBoYXZlIG5vIGNvbnRlbnRcbmV4cG9ydCBjb25zdCBBTExPV0VEX0VNUFRZX0VMRU1FTlRTID0gbmV3IFNldChbXG5cdCdhcmVhJyxcblx0J2F1ZGlvJyxcblx0J2Jhc2UnLFxuXHQnYnInLFxuXHQnY2lyY2xlJyxcblx0J2NvbCcsXG5cdCdkZWZzJyxcblx0J2VsbGlwc2UnLFxuXHQnZW1iZWQnLFxuXHQnZmlndXJlJyxcblx0J2cnLFxuXHQnaHInLFxuXHQnaWZyYW1lJyxcblx0J2ltZycsXG5cdCdpbnB1dCcsXG5cdCdsaW5lJyxcblx0J2xpbmsnLFxuXHQnbWFzaycsXG5cdCdtZXRhJyxcblx0J29iamVjdCcsXG5cdCdwYXJhbScsXG5cdCdwYXRoJyxcblx0J3BhdHRlcm4nLFxuXHQncGljdHVyZScsXG5cdCdwb2x5Z29uJyxcblx0J3BvbHlsaW5lJyxcblx0J3JlY3QnLFxuXHQnc291cmNlJyxcblx0J3N0b3AnLFxuXHQnc3ZnJyxcblx0J3RkJyxcblx0J3RoJyxcblx0J3RyYWNrJyxcblx0J3VzZScsXG5cdCd2aWRlbycsXG5cdCd3YnInXG5dKTtcblxuLy8gQXR0cmlidXRlcyB0byBrZWVwXG5leHBvcnQgY29uc3QgQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbXG5cdCdhbHQnLFxuXHQnYWxsb3cnLFxuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FyaWEtbGFiZWwnLFxuXHQnY2hlY2tlZCcsXG5cdCdjb2xzcGFuJyxcblx0J2NvbnRyb2xzJyxcblx0J2RhdGEtbGF0ZXgnLFxuXHQnZGF0YS1zcmMnLFxuXHQnZGF0YS1zcmNzZXQnLFxuXHQnZGF0YS1sYW5nJyxcblx0J2RpcicsXG5cdCdkaXNwbGF5Jyxcblx0J2ZyYW1lYm9yZGVyJyxcblx0J2hlYWRlcnMnLFxuXHQnaGVpZ2h0Jyxcblx0J2hyZWYnLFxuXHQnbGFuZycsXG5cdCdyb2xlJyxcblx0J3Jvd3NwYW4nLFxuXHQnc3JjJyxcblx0J3NyY3NldCcsXG5cdCd0aXRsZScsXG5cdCd0eXBlJyxcblx0J3dpZHRoJyxcblxuXHQvLyBNYXRoTUwgYXR0cmlidXRlc1xuXHQnYWNjZW50Jyxcblx0J2FjY2VudHVuZGVyJyxcblx0J2FsaWduJyxcblx0J2NvbHVtbmFsaWduJyxcblx0J2NvbHVtbmxpbmVzJyxcblx0J2NvbHVtbnNwYWNpbmcnLFxuXHQnY29sdW1uc3BhbicsXG5cdCdkYXRhLW1qeC10ZXhjbGFzcycsXG5cdCdkZXB0aCcsXG5cdCdkaXNwbGF5c3R5bGUnLFxuXHQnZmVuY2UnLFxuXHQnZnJhbWUnLFxuXHQnZnJhbWVzcGFjaW5nJyxcblx0J2xpbmV0aGlja25lc3MnLFxuXHQnbHNwYWNlJyxcblx0J21hdGhiYWNrZ3JvdW5kJyxcblx0J21hdGhjb2xvcicsXG5cdCdtYXRoc2l6ZScsXG5cdCdtYXRodmFyaWFudCcsXG5cdCdtYXhzaXplJyxcblx0J21pbnNpemUnLFxuXHQnbW92YWJsZWxpbWl0cycsXG5cdCdub3RhdGlvbicsXG5cdCdyb3dhbGlnbicsXG5cdCdyb3dsaW5lcycsXG5cdCdyb3dzcGFjaW5nJyxcblx0J3Jvd3NwYW4nLFxuXHQncnNwYWNlJyxcblx0J3NjcmlwdGxldmVsJyxcblx0J3NlcGFyYXRvcicsXG5cdCdzdHJldGNoeScsXG5cdCdzeW1tZXRyaWMnLFxuXHQndm9mZnNldCcsXG5cdCd4bWxucydcbl0pO1xuZXhwb3J0IGNvbnN0IEFMTE9XRURfQVRUUklCVVRFU19ERUJVRyA9IG5ldyBTZXQoW1xuXHQnY2xhc3MnLFxuXHQnaWQnLFxuXSk7XG5cbi8vIFN1cHBvcnRlZCBsYW5ndWFnZXMgZm9yIGNvZGUgYmxvY2tzXG5leHBvcnQgY29uc3QgU1VQUE9SVEVEX0xBTkdVQUdFUyA9IG5ldyBTZXQoW1xuXHQvLyBNYXJrdXAgJiBXZWJcblx0J21hcmt1cCcsICdodG1sJywgJ3htbCcsICdzdmcnLCAnbWF0aG1sJywgJ3NzbWwnLCAnYXRvbScsICdyc3MnLFxuXHQnamF2YXNjcmlwdCcsICdqcycsICdqc3gnLCAndHlwZXNjcmlwdCcsICd0cycsICd0c3gnLFxuXHQnd2ViYXNzZW1ibHknLCAnd2FzbScsXG5cdFxuXHQvLyBDb21tb24gUHJvZ3JhbW1pbmcgTGFuZ3VhZ2VzXG5cdCdweXRob24nLFxuXHQnamF2YScsXG5cdCdjc2hhcnAnLCAnY3MnLCAnZG90bmV0JywgJ2FzcG5ldCcsXG5cdCdjcHAnLCAnYysrJywgJ2MnLCAnb2JqYycsXG5cdCdydWJ5JywgJ3JiJyxcblx0J3BocCcsXG5cdCdnb2xhbmcnLFxuXHQncnVzdCcsXG5cdCdzd2lmdCcsXG5cdCdrb3RsaW4nLFxuXHQnc2NhbGEnLFxuXHQnZGFydCcsXG5cdFxuXHQvLyBTaGVsbCAmIFNjcmlwdGluZ1xuXHQnYmFzaCcsICdzaGVsbCcsICdzaCcsXG5cdCdwb3dlcnNoZWxsJyxcblx0J2JhdGNoJyxcblx0XG5cdC8vIERhdGEgJiBDb25maWdcblx0J2pzb24nLCAnanNvbnAnLFxuXHQneWFtbCcsICd5bWwnLFxuXHQndG9tbCcsXG5cdCdkb2NrZXJmaWxlJyxcblx0J2dpdGlnbm9yZScsXG5cdFxuXHQvLyBRdWVyeSBMYW5ndWFnZXNcblx0J3NxbCcsICdteXNxbCcsICdwb3N0Z3Jlc3FsJyxcblx0J2dyYXBocWwnLFxuXHQnbW9uZ29kYicsXG5cdCdzcGFycWwnLFxuXHRcblx0Ly8gTWFya3VwICYgRG9jdW1lbnRhdGlvblxuXHQnbWFya2Rvd24nLCAnbWQnLFxuXHQnbGF0ZXgnLCAndGV4Jyxcblx0J2FzY2lpZG9jJywgJ2Fkb2MnLFxuXHQnanNkb2MnLFxuXHRcblx0Ly8gRnVuY3Rpb25hbCBMYW5ndWFnZXNcblx0J2hhc2tlbGwnLCAnaHMnLFxuXHQnZWxtJyxcblx0J2VsaXhpcicsXG5cdCdlcmxhbmcnLFxuXHQnb2NhbWwnLFxuXHQnZnNoYXJwJyxcblx0J3NjaGVtZScsXG5cdCdsaXNwJywgJ2VsaXNwJyxcblx0J2Nsb2p1cmUnLFxuXHRcblx0Ly8gT3RoZXIgTGFuZ3VhZ2VzXG5cdCdtYXRsYWInLFxuXHQnZm9ydHJhbicsXG5cdCdjb2JvbCcsXG5cdCdwYXNjYWwnLFxuXHQncGVybCcsXG5cdCdsdWEnLFxuXHQnanVsaWEnLFxuXHQnZ3Jvb3Z5Jyxcblx0J2NyeXN0YWwnLFxuXHQnbmltJyxcblx0J3ppZycsXG5cdFxuXHQvLyBEb21haW4gU3BlY2lmaWNcblx0J3JlZ2V4Jyxcblx0J2dyYWRsZScsXG5cdCdjbWFrZScsXG5cdCdtYWtlZmlsZScsXG5cdCduaXgnLFxuXHQndGVycmFmb3JtJyxcblx0J3NvbGlkaXR5Jyxcblx0J2dsc2wnLFxuXHQnaGxzbCcsXG5cdFxuXHQvLyBBc3NlbWJseVxuXHQnbmFzbScsXG5cdCdtYXNtJyxcblx0J2FybWFzbScsXG5cdFxuXHQvLyBHYW1lIERldmVsb3BtZW50XG5cdCdnZHNjcmlwdCcsXG5cdCd1bnJlYWxzY3JpcHQnLFxuXHRcblx0Ly8gT3RoZXJzXG5cdCdhYmFwJyxcblx0J2FjdGlvbnNjcmlwdCcsXG5cdCdhZGEnLFxuXHQnYWdkYScsXG5cdCdhbnRscjQnLFxuXHQnYXBwbGVzY3JpcHQnLFxuXHQnYXJkdWlubycsXG5cdCdjb2ZmZWVzY3JpcHQnLFxuXHQnZGphbmdvJyxcblx0J2VybGFuZycsXG5cdCdmb3J0cmFuJyxcblx0J2hheGUnLFxuXHQnaWRyaXMnLFxuXHQna290bGluJyxcblx0J2xpdmVzY3JpcHQnLFxuXHQnbWF0bGFiJyxcblx0J25naW54Jyxcblx0J3Bhc2NhbCcsXG5cdCdwcm9sb2cnLFxuXHQncHVwcGV0Jyxcblx0J3NjYWxhJyxcblx0J3NjaGVtZScsXG5cdCd0Y2wnLFxuXHQndmVyaWxvZycsXG5cdCd2aGRsJ1xuXSk7XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgVGVtbWxcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKi9cbmNsYXNzIFBhcnNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlLCAvLyBUaGUgZXJyb3IgbWVzc2FnZVxuICAgIHRva2VuIC8vIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgKSB7XG4gICAgbGV0IGVycm9yID0gXCIgXCIgKyBtZXNzYWdlO1xuICAgIGxldCBzdGFydDtcblxuICAgIGNvbnN0IGxvYyA9IHRva2VuICYmIHRva2VuLmxvYztcbiAgICBpZiAobG9jICYmIGxvYy5zdGFydCA8PSBsb2MuZW5kKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRoZSBpbnB1dCBhbmQgYSBwb3NpdGlvbiwgbWFrZSB0aGUgZXJyb3IgYSBiaXQgZmFuY2llclxuXG4gICAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgICBjb25zdCBpbnB1dCA9IGxvYy5sZXhlci5pbnB1dDtcblxuICAgICAgLy8gUHJlcGVuZCBzb21lIGluZm9ybWF0aW9uXG4gICAgICBzdGFydCA9IGxvYy5zdGFydDtcbiAgICAgIGNvbnN0IGVuZCA9IGxvYy5lbmQ7XG4gICAgICBpZiAoc3RhcnQgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBlcnJvciArPSBcIiBhdCBlbmQgb2YgaW5wdXQ6IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IgKz0gXCIgYXQgcG9zaXRpb24gXCIgKyAoc3RhcnQgKyAxKSArIFwiOiBcXG5cIjtcbiAgICAgIH1cblxuICAgICAgLy8gVW5kZXJsaW5lIHRva2VuIGluIHF1ZXN0aW9uIHVzaW5nIGNvbWJpbmluZyB1bmRlcnNjb3Jlc1xuICAgICAgY29uc3QgdW5kZXJsaW5lZCA9IGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpLnJlcGxhY2UoL1teXS9nLCBcIiQmXFx1MDMzMlwiKTtcblxuICAgICAgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcbiAgICAgIGxldCBsZWZ0O1xuICAgICAgaWYgKHN0YXJ0ID4gMTUpIHtcbiAgICAgICAgbGVmdCA9IFwi4oCmXCIgKyBpbnB1dC5zbGljZShzdGFydCAtIDE1LCBzdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0ID0gaW5wdXQuc2xpY2UoMCwgc3RhcnQpO1xuICAgICAgfVxuICAgICAgbGV0IHJpZ2h0O1xuICAgICAgaWYgKGVuZCArIDE1IDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kLCBlbmQgKyAxNSkgKyBcIuKAplwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpO1xuICAgICAgfVxuICAgICAgZXJyb3IgKz0gbGVmdCArIHVuZGVybGluZWQgKyByaWdodDtcbiAgICB9XG5cbiAgICAvLyBTb21lIGhhY2tlcnkgdG8gbWFrZSBQYXJzZUVycm9yIGEgcHJvdG90eXBlIG9mIEVycm9yXG4gICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzg0NjA3NTNcbiAgICBjb25zdCBzZWxmID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICBzZWxmLm5hbWUgPSBcIlBhcnNlRXJyb3JcIjtcbiAgICBzZWxmLl9fcHJvdG9fXyA9IFBhcnNlRXJyb3IucHJvdG90eXBlO1xuICAgIHNlbGYucG9zaXRpb24gPSBzdGFydDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufVxuXG5QYXJzZUVycm9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7XG5cbi8vXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBhIGxpc3Qgb2YgdXRpbGl0eSBmdW5jdGlvbnMgd2hpY2ggYXJlIHVzZWZ1bCBpbiBvdGhlclxuICogZmlsZXMuXG4gKi9cblxuLyoqXG4gKiBQcm92aWRlIGEgZGVmYXVsdCB2YWx1ZSBpZiBhIHNldHRpbmcgaXMgdW5kZWZpbmVkXG4gKi9cbmNvbnN0IGRlZmx0ID0gZnVuY3Rpb24oc2V0dGluZywgZGVmYXVsdElmVW5kZWZpbmVkKSB7XG4gIHJldHVybiBzZXR0aW5nID09PSB1bmRlZmluZWQgPyBkZWZhdWx0SWZVbmRlZmluZWQgOiBzZXR0aW5nO1xufTtcblxuLy8gaHlwaGVuYXRlIGFuZCBlc2NhcGUgYWRhcHRlZCBmcm9tIEZhY2Vib29rJ3MgUmVhY3QgdW5kZXIgQXBhY2hlIDIgbGljZW5zZVxuXG5jb25zdCB1cHBlcmNhc2UgPSAvKFtBLVpdKS9nO1xuY29uc3QgaHlwaGVuYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSh1cHBlcmNhc2UsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5jb25zdCBFU0NBUEVfTE9PS1VQID0ge1xuICBcIiZcIjogXCImYW1wO1wiLFxuICBcIj5cIjogXCImZ3Q7XCIsXG4gIFwiPFwiOiBcIiZsdDtcIixcbiAgJ1wiJzogXCImcXVvdDtcIixcbiAgXCInXCI6IFwiJiN4Mjc7XCJcbn07XG5cbmNvbnN0IEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICovXG5mdW5jdGlvbiBlc2NhcGUodGV4dCkge1xuICByZXR1cm4gU3RyaW5nKHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCAobWF0Y2gpID0+IEVTQ0FQRV9MT09LVVBbbWF0Y2hdKTtcbn1cblxuLyoqXG4gKiBTb21ldGltZXMgd2Ugd2FudCB0byBwdWxsIG91dCB0aGUgaW5uZXJtb3N0IGVsZW1lbnQgb2YgYSBncm91cC4gSW4gbW9zdFxuICogY2FzZXMsIHRoaXMgd2lsbCBqdXN0IGJlIHRoZSBncm91cCBpdHNlbGYsIGJ1dCB3aGVuIG9yZGdyb3VwcyBhbmQgY29sb3JzIGhhdmVcbiAqIGEgc2luZ2xlIGVsZW1lbnQsIHdlIHdhbnQgdG8gcHVsbCB0aGF0IG91dC5cbiAqL1xuY29uc3QgZ2V0QmFzZUVsZW0gPSBmdW5jdGlvbihncm91cCkge1xuICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJmb250XCIpIHtcbiAgICByZXR1cm4gZ2V0QmFzZUVsZW0oZ3JvdXAuYm9keSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG59O1xuXG4vKipcbiAqIFRlWGJvb2sgYWxnb3JpdGhtcyBvZnRlbiByZWZlcmVuY2UgXCJjaGFyYWN0ZXIgYm94ZXNcIiwgd2hpY2ggYXJlIHNpbXBseSBncm91cHNcbiAqIHdpdGggYSBzaW5nbGUgY2hhcmFjdGVyIGluIHRoZW0uIFRvIGRlY2lkZSBpZiBzb21ldGhpbmcgaXMgYSBjaGFyYWN0ZXIgYm94LFxuICogd2UgZmluZCBpdHMgaW5uZXJtb3N0IGdyb3VwLCBhbmQgc2VlIGlmIGl0IGlzIGEgc2luZ2xlIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgaXNDaGFyYWN0ZXJCb3ggPSBmdW5jdGlvbihncm91cCkge1xuICBjb25zdCBiYXNlRWxlbSA9IGdldEJhc2VFbGVtKGdyb3VwKTtcblxuICAvLyBUaGVzZSBhcmUgYWxsIHRoZSB0eXBlcyBvZiBncm91cHMgd2hpY2ggaG9sZCBzaW5nbGUgY2hhcmFjdGVyc1xuICByZXR1cm4gYmFzZUVsZW0udHlwZSA9PT0gXCJtYXRob3JkXCIgfHwgYmFzZUVsZW0udHlwZSA9PT0gXCJ0ZXh0b3JkXCIgfHwgYmFzZUVsZW0udHlwZSA9PT0gXCJhdG9tXCJcbn07XG5cbmNvbnN0IGFzc2VydCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub24tbnVsbCwgYnV0IGdvdCBcIiArIFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBwcm90b2NvbCBvZiBhIFVSTCwgb3IgXCJfcmVsYXRpdmVcIiBpZiB0aGUgVVJMIGRvZXMgbm90IHNwZWNpZnkgYVxuICogcHJvdG9jb2wgKGFuZCB0aHVzIGlzIHJlbGF0aXZlKSwgb3IgYG51bGxgIGlmIFVSTCBoYXMgaW52YWxpZCBwcm90b2NvbFxuICogKHNvIHNob3VsZCBiZSBvdXRyaWdodCByZWplY3RlZCkuXG4gKi9cbmNvbnN0IHByb3RvY29sRnJvbVVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAvLyBDaGVjayBmb3IgcG9zc2libGUgbGVhZGluZyBwcm90b2NvbC5cbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtcGFyc2luZyBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlXG4gIC8vIChcXHgwMCkgb3IgQzAgY29udHJvbCAoXFx4MDAtXFx4MUYpIGNoYXJhY3RlcnMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gIGNvbnN0IHByb3RvY29sID0gL15bXFx4MDAtXFx4MjBdKihbXlxcXFwvIz9dKj8pKDp8JiMwKjU4fCYjeDAqM2F8JmNvbG9uKS9pLmV4ZWModXJsKTtcbiAgaWYgKCFwcm90b2NvbCkge1xuICAgIHJldHVybiBcIl9yZWxhdGl2ZVwiO1xuICB9XG4gIC8vIFJlamVjdCB3ZWlyZCBjb2xvbnNcbiAgaWYgKHByb3RvY29sWzJdICE9PSBcIjpcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFJlamVjdCBpbnZhbGlkIGNoYXJhY3RlcnMgaW4gc2NoZW1lIGFjY29yZGluZyB0b1xuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcbiAgaWYgKCEvXlthLXpBLVpdW2EtekEtWjAtOStcXC0uXSokLy50ZXN0KHByb3RvY29sWzFdKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIExvd2VyY2FzZSB0aGUgcHJvdG9jb2xcbiAgcmV0dXJuIHByb3RvY29sWzFdLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFJvdW5kIGBuYCB0byA0IGRlY2ltYWwgcGxhY2VzLCBvciB0byB0aGUgbmVhcmVzdCAxLzEwLDAwMHRoIGVtLiBUaGUgVGVYYm9va1xuICogZ2l2ZXMgYW4gYWNjZXB0YWJsZSByb3VuZGluZyBlcnJvciBvZiAxMDBzcCAod2hpY2ggd291bGQgYmUgdGhlIG5lYXJlc3RcbiAqIDEvNjU1MS42ZW0gd2l0aCBvdXIgcHRQZXJFbSA9IDEwKTpcbiAqIGh0dHA6Ly93d3cuY3RleC5vcmcvZG9jdW1lbnRzL3NocmVkZGVyL3NyYy90ZXhib29rLnBkZiNwYWdlPTY5XG4gKi9cbmNvbnN0IHJvdW5kID0gZnVuY3Rpb24obikge1xuICByZXR1cm4gK24udG9GaXhlZCg0KTtcbn07XG5cbnZhciB1dGlscyA9IHtcbiAgZGVmbHQsXG4gIGVzY2FwZSxcbiAgaHlwaGVuYXRlLFxuICBnZXRCYXNlRWxlbSxcbiAgaXNDaGFyYWN0ZXJCb3gsXG4gIHByb3RvY29sRnJvbVVybCxcbiAgcm91bmRcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIG1vZHVsZSBmb3Igc3RvcmluZyBzZXR0aW5ncyBwYXNzZWQgaW50byBUZW1tbC4gSXQgY29ycmVjdGx5IGhhbmRsZXNcbiAqIGRlZmF1bHQgc2V0dGluZ3MuXG4gKi9cblxuXG4vKipcbiAqIFRoZSBtYWluIFNldHRpbmdzIG9iamVjdFxuICovXG5jbGFzcyBTZXR0aW5ncyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvLyBhbGxvdyBudWxsIG9wdGlvbnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmRpc3BsYXlNb2RlID0gdXRpbHMuZGVmbHQob3B0aW9ucy5kaXNwbGF5TW9kZSwgZmFsc2UpOyAgICAvLyBib29sZWFuXG4gICAgdGhpcy5hbm5vdGF0ZSA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuYW5ub3RhdGUsIGZhbHNlKTsgICAgICAgICAgIC8vIGJvb2xlYW5cbiAgICB0aGlzLmxlcW5vID0gdXRpbHMuZGVmbHQob3B0aW9ucy5sZXFubywgZmFsc2UpOyAgICAgICAgICAgICAgICAvLyBib29sZWFuXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB1dGlscy5kZWZsdChvcHRpb25zLnRocm93T25FcnJvciwgZmFsc2UpOyAgLy8gYm9vbGVhblxuICAgIHRoaXMuZXJyb3JDb2xvciA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuZXJyb3JDb2xvciwgXCIjYjIyMjIyXCIpOyAgLy8gc3RyaW5nXG4gICAgdGhpcy5tYWNyb3MgPSBvcHRpb25zLm1hY3JvcyB8fCB7fTtcbiAgICB0aGlzLndyYXAgPSB1dGlscy5kZWZsdChvcHRpb25zLndyYXAsIFwidGV4XCIpOyAgICAgICAgICAgICAgICAgICAgLy8gXCJ0ZXhcIiB8IFwiPVwiXG4gICAgdGhpcy54bWwgPSB1dGlscy5kZWZsdChvcHRpb25zLnhtbCwgZmFsc2UpOyAgICAgICAgICAgICAgICAgICAgIC8vIGJvb2xlYW5cbiAgICB0aGlzLmNvbG9ySXNUZXh0Q29sb3IgPSB1dGlscy5kZWZsdChvcHRpb25zLmNvbG9ySXNUZXh0Q29sb3IsIGZhbHNlKTsgIC8vIGJvb2VsZWFuXG4gICAgdGhpcy5zdHJpY3QgPSB1dGlscy5kZWZsdChvcHRpb25zLnN0cmljdCwgZmFsc2UpOyAgICAvLyBib29sZWFuXG4gICAgdGhpcy50cnVzdCA9IHV0aWxzLmRlZmx0KG9wdGlvbnMudHJ1c3QsIGZhbHNlKTsgIC8vIHRydXN0IGNvbnRleHQuIFNlZSBodG1sLmpzLlxuICAgIHRoaXMubWF4U2l6ZSA9IChvcHRpb25zLm1heFNpemUgPT09IHVuZGVmaW5lZFxuICAgICAgPyBbSW5maW5pdHksIEluZmluaXR5XVxuICAgICAgOiBBcnJheS5pc0FycmF5KG9wdGlvbnMubWF4U2l6ZSlcbiAgICAgID8gb3B0aW9ucy5tYXhTaXplXG4gICAgICA6IFtJbmZpbml0eSwgSW5maW5pdHldXG4gICAgKTtcbiAgICB0aGlzLm1heEV4cGFuZCA9IE1hdGgubWF4KDAsIHV0aWxzLmRlZmx0KG9wdGlvbnMubWF4RXhwYW5kLCAxMDAwKSk7IC8vIG51bWJlclxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdG8gdGVzdCBwb3RlbnRpYWxseSBkYW5nZXJvdXMgaW5wdXQsIGFuZCByZXR1cm5cbiAgICogYHRydWVgICh0cnVzdGVkKSBvciBgZmFsc2VgICh1bnRydXN0ZWQpLiAgVGhlIHNvbGUgYXJndW1lbnQgYGNvbnRleHRgXG4gICAqIHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBgY29tbWFuZGAgZmllbGQgc3BlY2lmeWluZyB0aGUgcmVsZXZhbnQgTGFUZVhcbiAgICogY29tbWFuZCAoYXMgYSBzdHJpbmcgc3RhcnRpbmcgd2l0aCBgXFxgKSwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMsIGV0Yy5cbiAgICogSWYgYGNvbnRleHRgIGhhcyBhIGB1cmxgIGZpZWxkLCBhIGBwcm90b2NvbGAgZmllbGQgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAqIGdldCBhZGRlZCBieSB0aGlzIGZ1bmN0aW9uIChjaGFuZ2luZyB0aGUgc3BlY2lmaWVkIG9iamVjdCkuXG4gICAqL1xuICBpc1RydXN0ZWQoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LnVybCAmJiAhY29udGV4dC5wcm90b2NvbCkge1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB1dGlscy5wcm90b2NvbEZyb21VcmwoY29udGV4dC51cmwpO1xuICAgICAgaWYgKHByb3RvY29sID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBjb250ZXh0LnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgfVxuICAgIGNvbnN0IHRydXN0ID0gdHlwZW9mIHRoaXMudHJ1c3QgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMudHJ1c3QoY29udGV4dCkgOiB0aGlzLnRydXN0O1xuICAgIHJldHVybiBCb29sZWFuKHRydXN0KTtcbiAgfVxufVxuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGZ1bmN0aW9ucy5cbiAqIGBmdW5jdGlvbnMuanNgIGp1c3QgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5LlxuICovXG5jb25zdCBfZnVuY3Rpb25zID0ge307XG5cbi8qKlxuICogQWxsIE1hdGhNTCBidWlsZGVycy4gU2hvdWxkIGJlIG9ubHkgdXNlZCBpbiB0aGUgYGRlZmluZSpgIGFuZCB0aGUgYGJ1aWxkKk1MYFxuICogZnVuY3Rpb25zLlxuICovXG5jb25zdCBfbWF0aG1sR3JvdXBCdWlsZGVycyA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbih7XG4gIHR5cGUsXG4gIG5hbWVzLFxuICBwcm9wcyxcbiAgaGFuZGxlcixcbiAgbWF0aG1sQnVpbGRlclxufSkge1xuICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgZnVuY3Rpb25zXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdHlwZSxcbiAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzLFxuICAgIGFyZ1R5cGVzOiBwcm9wcy5hcmdUeXBlcyxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogISFwcm9wcy5hbGxvd2VkSW5Bcmd1bWVudCxcbiAgICBhbGxvd2VkSW5UZXh0OiAhIXByb3BzLmFsbG93ZWRJblRleHQsXG4gICAgYWxsb3dlZEluTWF0aDogcHJvcHMuYWxsb3dlZEluTWF0aCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHByb3BzLmFsbG93ZWRJbk1hdGgsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICBpbmZpeDogISFwcm9wcy5pbmZpeCxcbiAgICBwcmltaXRpdmU6ICEhcHJvcHMucHJpbWl0aXZlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIF9mdW5jdGlvbnNbbmFtZXNbaV1dID0gZGF0YTtcbiAgfVxuICBpZiAodHlwZSkge1xuICAgIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgICBfbWF0aG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IG1hdGhtbEJ1aWxkZXI7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXNlIHRoaXMgdG8gcmVnaXN0ZXIgb25seSB0aGUgTWF0aE1MIGJ1aWxkZXIgZm9yIGEgZnVuY3Rpb24oZS5nLlxuICogaWYgdGhlIGZ1bmN0aW9uJ3MgUGFyc2VOb2RlIGlzIGdlbmVyYXRlZCBpbiBQYXJzZXIuanMgcmF0aGVyIHRoYW4gdmlhIGFcbiAqIHN0YW5kLWFsb25lIGhhbmRsZXIgcHJvdmlkZWQgdG8gYGRlZmluZUZ1bmN0aW9uYCkuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoeyB0eXBlLCBtYXRobWxCdWlsZGVyIH0pIHtcbiAgZGVmaW5lRnVuY3Rpb24oe1xuICAgIHR5cGUsXG4gICAgbmFtZXM6IFtdLFxuICAgIHByb3BzOiB7IG51bUFyZ3M6IDAgfSxcbiAgICBoYW5kbGVyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cIilcbiAgICB9LFxuICAgIG1hdGhtbEJ1aWxkZXJcbiAgfSk7XG59XG5cbmNvbnN0IG5vcm1hbGl6ZUFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiICYmIGFyZy5ib2R5Lmxlbmd0aCA9PT0gMSA/IGFyZy5ib2R5WzBdIDogYXJnXG59O1xuXG4vLyBTaW5jZSB0aGUgY29ycmVzcG9uZGluZyBidWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xuY29uc3Qgb3JkYXJndW1lbnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgPyBhcmcuYm9keSA6IFthcmddXG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gSXQgb25seSBjb250YWluc1xuICogY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgRE9NIG5vZGUgcHJvcGVydGllcy5cbiAqL1xuY2xhc3MgRG9jdW1lbnRGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtdO1xuICAgIHRoaXMuc3R5bGUgPSB7fTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzZXMuaW5jbHVkZXMoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIGEgbm9kZS4gKi9cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICAvKiogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBIVE1MIG1hcmt1cC4gKi9cbiAgdG9NYXJrdXAoKSB7XG4gICAgbGV0IG1hcmt1cCA9IFwiXCI7XG5cbiAgICAvLyBTaW1wbHkgY29uY2F0ZW5hdGUgdGhlIG1hcmt1cCBmb3IgdGhlIGNoaWxkcmVuIHRvZ2V0aGVyLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQuIEFwcGxpZXMgdG9cbiAgICogTWF0aERvbU5vZGUncyBvbmx5LlxuICAgKi9cbiAgdG9UZXh0KCkge1xuICAgIC8vIFRvIGF2b2lkIHRoaXMsIHdlIHdvdWxkIHN1YmNsYXNzIGRvY3VtZW50RnJhZ21lbnQgc2VwYXJhdGVseSBmb3JcbiAgICAvLyBNYXRoTUwsIGJ1dCBwb2x5ZmlsbHMgZm9yIHN1YmNsYXNzaW5nIGlzIGV4cGVuc2l2ZSBwZXIgUFIgMTQ2OS5cbiAgICBjb25zdCB0b1RleHQgPSAoY2hpbGQpID0+IGNoaWxkLnRvVGV4dCgpO1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcCh0b1RleHQpLmpvaW4oXCJcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIHRoZSBkYXRhIGFib3V0IHRoZSBET00gbm9kZXMgd2UgY3JlYXRlLCBhcyB3ZWxsIGFzIHNvbWVcbiAqIGV4dHJhIGRhdGEuIFRoZXkgY2FuIHRoZW4gYmUgdHJhbnNmb3JtZWQgaW50byByZWFsIERPTSBub2RlcyB3aXRoIHRoZVxuICogYHRvTm9kZWAgZnVuY3Rpb24gb3IgSFRNTCBtYXJrdXAgdXNpbmcgYHRvTWFya3VwYC4gVGhleSBhcmUgdXNlZnVsIGZvciBib3RoXG4gKiBzdG9yaW5nIGV4dHJhIHByb3BlcnRpZXMgb24gdGhlIG5vZGVzLCBhcyB3ZWxsIGFzIHByb3ZpZGluZyBhIHdheSB0byBlYXNpbHlcbiAqIHdvcmsgd2l0aCB0aGUgRE9NLlxuICpcbiAqIFNpbWlsYXIgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggTWF0aE1MIG5vZGVzIGV4aXN0IGluIG1hdGhNTFRyZWUuanMuXG4gKlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGFuIEhUTUwgY2xhc3NOYW1lIGJhc2VkIG9uIGEgbGlzdCBvZiBjbGFzc2VzLiBJbiBhZGRpdGlvbiB0byBqb2luaW5nXG4gKiB3aXRoIHNwYWNlcywgd2UgYWxzbyByZW1vdmUgZW1wdHkgY2xhc3Nlcy5cbiAqL1xuY29uc3QgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbihjbGFzc2VzKSB7XG4gIHJldHVybiBjbGFzc2VzLmZpbHRlcigoY2xzKSA9PiBjbHMpLmpvaW4oXCIgXCIpO1xufTtcblxuY29uc3QgaW5pdE5vZGUgPSBmdW5jdGlvbihjbGFzc2VzLCBzdHlsZSkge1xuICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBub2RlXG4gKi9cbmNvbnN0IHRvTm9kZSA9IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG5cbiAgLy8gQXBwbHkgdGhlIGNsYXNzXG4gIG5vZGUuY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcblxuICAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgbm9kZS5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICB9XG4gIH1cblxuICAvLyBBcHBseSBhdHRyaWJ1dGVzXG4gIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0ciApKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGVuZCB0aGUgY2hpbGRyZW4sIGFsc28gYXMgSFRNTCBub2Rlc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuY29uc3QgdG9NYXJrdXAgPSBmdW5jdGlvbih0YWdOYW1lKSB7XG4gIGxldCBtYXJrdXAgPSBgPCR7dGFnTmFtZX1gO1xuXG4gIC8vIEFkZCB0aGUgY2xhc3NcbiAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBtYXJrdXAgKz0gYCBjbGFzcz1cIiR7dXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpfVwiYDtcbiAgfVxuXG4gIGxldCBzdHlsZXMgPSBcIlwiO1xuXG4gIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgIHN0eWxlcyArPSBgJHt1dGlscy5oeXBoZW5hdGUoc3R5bGUpfToke3RoaXMuc3R5bGVbc3R5bGVdfTtgO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHlsZXMpIHtcbiAgICBtYXJrdXAgKz0gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYDtcbiAgfVxuXG4gIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIgKSkge1xuICAgICAgbWFya3VwICs9IGAgJHthdHRyfT1cIiR7dXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSl9XCJgO1xuICAgIH1cbiAgfVxuXG4gIG1hcmt1cCArPSBcIj5cIjtcblxuICAvLyBBZGQgdGhlIG1hcmt1cCBvZiB0aGUgY2hpbGRyZW4sIGFsc28gYXMgbWFya3VwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gIH1cblxuICBtYXJrdXAgKz0gYDwvJHt0YWdOYW1lfT5gO1xuXG4gIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgc3BhbiBub2RlLCB3aXRoIGEgY2xhc3NOYW1lLCBhIGxpc3Qgb2YgY2hpbGRyZW4sIGFuZFxuICogYW4gaW5saW5lIHN0eWxlLlxuICpcbiAqL1xuY2xhc3MgU3BhbiB7XG4gIGNvbnN0cnVjdG9yKGNsYXNzZXMsIGNoaWxkcmVuLCBzdHlsZSkge1xuICAgIGluaXROb2RlLmNhbGwodGhpcywgY2xhc3Nlcywgc3R5bGUpO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgfVxuXG4gIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gdG9Ob2RlLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHRvTWFya3VwLmNhbGwodGhpcywgXCJzcGFuXCIpO1xuICB9XG59XG5cbmxldCBUZXh0Tm9kZSQxID0gY2xhc3MgVGV4dE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIH1cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRleHQpO1xuICB9XG59O1xuXG4vLyBDcmVhdGUgYW4gPGEgaHJlZj1cIuKAplwiPiBub2RlLlxuY2xhc3MgQW5jaG9yTm9kZSB7XG4gIGNvbnN0cnVjdG9yKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuKSB7XG4gICAgdGhpcy5ocmVmID0gaHJlZjtcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHRoaXMuaHJlZik7XG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIGxldCBtYXJrdXAgPSBgPGEgaHJlZj0nJHt1dGlscy5lc2NhcGUodGhpcy5ocmVmKX0nYDtcbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hcmt1cCArPSBgIGNsYXNzPVwiJHt1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSl9XCJgO1xuICAgIH1cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cbiAgICBtYXJrdXAgKz0gXCI8L2E+XCI7XG4gICAgcmV0dXJuIG1hcmt1cFxuICB9XG59XG5cbi8qXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhbiBpbWFnZSBlbWJlZCAoPGltZz4pIGVsZW1lbnQuXG4gKi9cbmNsYXNzIEltZyB7XG4gIGNvbnN0cnVjdG9yKHNyYywgYWx0LCBzdHlsZSkge1xuICAgIHRoaXMuYWx0ID0gYWx0O1xuICAgIHRoaXMuc3JjID0gc3JjO1xuICAgIHRoaXMuY2xhc3NlcyA9IFtcIm1vcmRcIl07XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3Nlcy5pbmNsdWRlcyhjbGFzc05hbWUpO1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIG5vZGUuc3JjID0gdGhpcy5zcmM7XG4gICAgbm9kZS5hbHQgPSB0aGlzLmFsdDtcbiAgICBub2RlLmNsYXNzTmFtZSA9IFwibW9yZFwiO1xuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gYDxpbWcgc3JjPScke3RoaXMuc3JjfScgYWx0PScke3RoaXMuYWx0fSdgO1xuXG4gICAgLy8gQWRkIHRoZSBzdHlsZXMsIGFmdGVyIGh5cGhlbmF0aW9uXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgICAgc3R5bGVzICs9IGAke3V0aWxzLmh5cGhlbmF0ZShzdHlsZSl9OiR7dGhpcy5zdHlsZVtzdHlsZV19O2A7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgIG1hcmt1cCArPSBgIHN0eWxlPVwiJHt1dGlscy5lc2NhcGUoc3R5bGVzKX1cImA7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cbn1cblxuLy9cbi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSBkYXRhIGFib3V0IE1hdGhNTCBub2Rlcy5cbiAqIFRoZSBgdG9Ob2RlYCBhbmQgYHRvTWFya3VwYCBmdW5jdGlvbnMgIGNyZWF0ZSBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmRcbiAqIEhUTUwgdGV4dCBtYXJrdXAgcmVzcGVjdGl2ZWx5LlxuICovXG5cblxuZnVuY3Rpb24gbmV3RG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICByZXR1cm4gbmV3IERvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xufVxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZ2VuZXJhbCBwdXJwb3NlIE1hdGhNTCBub2RlIG9mIGFueSB0eXBlLFxuICogZm9yIGV4YW1wbGUsIGBcIm1vXCJgIG9yIGBcIm1zcGFjZVwiYCwgY29ycmVzcG9uZGluZyB0byBgPG1vPmAgYW5kXG4gKiBgPG1zcGFjZT5gIHRhZ3MpLlxuICovXG5jbGFzcyBNYXRoTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIGNoaWxkcmVuLCBjbGFzc2VzLCBzdHlsZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9OyAgIC8vIFVzZWQgZm9yIDxtc3R5bGU+IGVsZW1lbnRzXG4gICAgdGhpcy5sYWJlbCA9IFwiXCI7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS4gTWF0aE1MIGRlcGVuZHMgb24gYXR0cmlidXRlcyB0byBjb252ZXkgYVxuICAgKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAgICovXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gYXR0cmlidXRlIG9uIGEgTWF0aE1MIG5vZGUuXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH1cblxuICBzZXRMYWJlbCh2YWx1ZSkge1xuICAgIHRoaXMubGFiZWwgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC5cbiAgICovXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCI8XCIgKyB0aGlzLnR5cGU7XG5cbiAgICAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArICc9XCInO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICAgIG1hcmt1cCArPSAnXCInO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWFya3VwICs9IGAgY2xhc3M9XCIke3V0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKX1cImA7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlcyA9IFwiXCI7XG5cbiAgICAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgICBzdHlsZXMgKz0gYCR7dXRpbHMuaHlwaGVuYXRlKHN0eWxlKX06JHt0aGlzLnN0eWxlW3N0eWxlXX07YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBtYXJrdXAgKz0gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYDtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPC9cIiArIHRoaXMudHlwZSArIFwiPlwiO1xuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LCBidXQgZXNjYXBlZC5cbiAgICovXG4gIHRvVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC50b1RleHQoKSkuam9pbihcIlwiKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGV4dC5cbiAqL1xuY2xhc3MgVGV4dE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gYSBET00gdGV4dCBub2RlLlxuICAgKi9cbiAgdG9Ob2RlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBlc2NhcGVkIEhUTUwgbWFya3VwXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB1dGlscy5lc2NhcGUodGhpcy50b1RleHQoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgc3RyaW5nXG4gICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS5cbiAgICovXG4gIHRvVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0O1xuICB9XG59XG5cbi8vIERvIG5vdCBtYWtlIGFuIDxtcm93PiB0aGUgb25seSBjaGlsZCBvZiBhIDxtc3R5bGU+LlxuLy8gQW4gPG1zdHlsZT4gYWN0cyBhcyBpdHMgb3duIGltcGxpY2l0IDxtcm93Pi5cbmNvbnN0IHdyYXBXaXRoTXN0eWxlID0gZXhwcmVzc2lvbiA9PiB7XG4gIGxldCBub2RlO1xuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvblswXS50eXBlID09PSBcIm1yb3dcIikge1xuICAgIG5vZGUgPSBleHByZXNzaW9uLnBvcCgpO1xuICAgIG5vZGUudHlwZSA9IFwibXN0eWxlXCI7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1zdHlsZVwiLCBleHByZXNzaW9uKTtcbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxudmFyIG1hdGhNTFRyZWUgPSB7XG4gIE1hdGhOb2RlLFxuICBUZXh0Tm9kZSxcbiAgbmV3RG9jdW1lbnRGcmFnbWVudFxufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgcHJvdmlkZXMgc3VwcG9ydCBmb3IgYnVpbGRpbmcgaG9yaXpvbnRhbCBzdHJldGNoeSBlbGVtZW50cy5cbiAqL1xuXG5cbi8vIFRPRE86IFJlbW92ZSB3aGVuIENocm9taXVtIHN0cmV0Y2hlcyBcXHdpZGV0aWxkZSAmIFxcd2lkZWhhdFxuY29uc3QgZXN0aW1hdGVkV2lkdGggPSBub2RlID0+IHtcbiAgbGV0IHdpZHRoID0gMDtcbiAgaWYgKG5vZGUuYm9keSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLmJvZHkpIHtcbiAgICAgIHdpZHRoICs9IGVzdGltYXRlZFdpZHRoKGl0ZW0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwic3Vwc3ViXCIpIHtcbiAgICB3aWR0aCArPSBlc3RpbWF0ZWRXaWR0aChub2RlLmJhc2UpO1xuICAgIGlmIChub2RlLnN1YikgeyB3aWR0aCArPSAwLjcgKiBlc3RpbWF0ZWRXaWR0aChub2RlLnN1Yik7IH1cbiAgICBpZiAobm9kZS5zdXApIHsgd2lkdGggKz0gMC43ICogZXN0aW1hdGVkV2lkdGgobm9kZS5zdXApOyB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBub2RlLnR5cGUgPT09IFwidGV4dG9yZFwiKSB7XG4gICAgZm9yIChjb25zdCBjaCBvZiBub2RlLnRleHQuc3BsaXQoJycpKSB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaC5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIGlmICgoMHg2MCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDdCKSB8fCAoMHgwM0IwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4M0NBKSkge1xuICAgICAgICB3aWR0aCArPSAwLjU2OyAvLyBsb3dlciBjYXNlIGxhdGluIG9yIGdyZWVrLiBVc2UgYWR2YW5jZSB3aWR0aCBvZiBsZXR0ZXIgblxuICAgICAgfSBlbHNlIGlmICgweDJGIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4M0EpIHtcbiAgICAgICAgd2lkdGggKz0gMC41MDsgLy8gbnVtZXJhbHMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWR0aCArPSAwLjkyOyAvLyBhZHZhbmNlIHdpZHRoIG9mIGxldHRlciBNXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdpZHRoICs9IDEuMDtcbiAgfVxuICByZXR1cm4gd2lkdGhcbn07XG5cbmNvbnN0IHN0cmV0Y2h5Q29kZVBvaW50ID0ge1xuICB3aWRlaGF0OiBcIl5cIixcbiAgd2lkZWNoZWNrOiBcIsuHXCIsXG4gIHdpZGV0aWxkZTogXCJ+XCIsXG4gIHdpZGVwYXJlbjogXCLij5xcIiwgLy8gXFx1MjNkY1xuICB1dGlsZGU6IFwiflwiLFxuICBvdmVybGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgdW5kZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB4bGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgb3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB1bmRlcnJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB4cmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVyYnJhY2U6IFwiXFx1MjNkZlwiLFxuICBvdmVyYnJhY2U6IFwiXFx1MjNkZVwiLFxuICBvdmVyZ3JvdXA6IFwiXFx1MjNlMFwiLFxuICBvdmVycGFyZW46IFwi4o+cXCIsXG4gIHVuZGVyZ3JvdXA6IFwiXFx1MjNlMVwiLFxuICB1bmRlcnBhcmVuOiBcIlxcdTIzZGRcIixcbiAgb3ZlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIHhsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIE92ZXJyaWdodGFycm93OiBcIlxcdTIxZDJcIixcbiAgeFJpZ2h0YXJyb3c6IFwiXFx1MjFkMlwiLFxuICBvdmVybGVmdGhhcnBvb246IFwiXFx1MjFiY1wiLFxuICB4bGVmdGhhcnBvb251cDogXCJcXHUyMWJjXCIsXG4gIG92ZXJyaWdodGhhcnBvb246IFwiXFx1MjFjMFwiLFxuICB4cmlnaHRoYXJwb29udXA6IFwiXFx1MjFjMFwiLFxuICB4TGVmdGFycm93OiBcIlxcdTIxZDBcIixcbiAgeExlZnRyaWdodGFycm93OiBcIlxcdTIxZDRcIixcbiAgeGhvb2tsZWZ0YXJyb3c6IFwiXFx1MjFhOVwiLFxuICB4aG9va3JpZ2h0YXJyb3c6IFwiXFx1MjFhYVwiLFxuICB4bWFwc3RvOiBcIlxcdTIxYTZcIixcbiAgeHJpZ2h0aGFycG9vbmRvd246IFwiXFx1MjFjMVwiLFxuICB4bGVmdGhhcnBvb25kb3duOiBcIlxcdTIxYmRcIixcbiAgeHR3b2hlYWRsZWZ0YXJyb3c6IFwiXFx1MjE5ZVwiLFxuICB4dHdvaGVhZHJpZ2h0YXJyb3c6IFwiXFx1MjFhMFwiLFxuICB4bG9uZ2VxdWFsOiBcIj1cIixcbiAgeHJpZ2h0bGVmdGFycm93czogXCJcXHUyMWM0XCIsXG4gIHlpZWxkczogXCJcXHUyMTkyXCIsXG4gIHlpZWxkc0xlZnQ6IFwiXFx1MjE5MFwiLFxuICBtZXNvbWVyaXNtOiBcIlxcdTIxOTRcIixcbiAgbG9uZ3JpZ2h0aGFycG9vbnVwOiBcIlxcdTIxYzBcIixcbiAgbG9uZ2xlZnRoYXJwb29uZG93bjogXCJcXHUyMWJkXCIsXG4gIGVxcmlnaHRoYXJwb29udXA6IFwiXFx1MjFjMFwiLFxuICBlcWxlZnRoYXJwb29uZG93bjogXCJcXHUyMWJkXCIsXG4gIFwiXFxcXGNkcmlnaHRhcnJvd1wiOiBcIlxcdTIxOTJcIixcbiAgXCJcXFxcY2RsZWZ0YXJyb3dcIjogXCJcXHUyMTkwXCIsXG4gIFwiXFxcXGNkbG9uZ2VxdWFsXCI6IFwiPVwiXG59O1xuXG5jb25zdCBtYXRoTUxub2RlID0gZnVuY3Rpb24obGFiZWwpIHtcbiAgY29uc3QgY2hpbGQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShzdHJldGNoeUNvZGVQb2ludFtsYWJlbC5zbGljZSgxKV0pO1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbY2hpbGRdKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gIHJldHVybiBub2RlXG59O1xuXG5jb25zdCBjcm9va2VkV2lkZXMgPSBbXCJcXFxcd2lkZXRpbGRlXCIsIFwiXFxcXHdpZGVoYXRcIiwgXCJcXFxcd2lkZWNoZWNrXCIsIFwiXFxcXHV0aWxkZVwiXTtcblxuLy8gVE9ETzogUmVtb3ZlIHdoZW4gQ2hyb21pdW0gc3RyZXRjaGVzIFxcd2lkZXRpbGRlICYgXFx3aWRlaGF0XG5jb25zdCBhY2NlbnROb2RlID0gKGdyb3VwKSA9PiB7XG4gIGNvbnN0IG1vID0gbWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gIGlmIChjcm9va2VkV2lkZXMuaW5jbHVkZXMoZ3JvdXAubGFiZWwpKSB7XG4gICAgY29uc3Qgd2lkdGggPSBlc3RpbWF0ZWRXaWR0aChncm91cC5iYXNlKTtcbiAgICBpZiAoMSA8IHdpZHRoICYmIHdpZHRoIDwgMS42KSB7XG4gICAgICBtby5jbGFzc2VzLnB1c2goXCJ0bWwtY3Jvb2tlZC0yXCIpO1xuICAgIH0gZWxzZSBpZiAoMS42IDw9IHdpZHRoICYmIHdpZHRoIDwgMi41KSB7XG4gICAgICBtby5jbGFzc2VzLnB1c2goXCJ0bWwtY3Jvb2tlZC0zXCIpO1xuICAgIH0gZWxzZSBpZiAoMi41IDw9IHdpZHRoKSB7XG4gICAgICBtby5jbGFzc2VzLnB1c2goXCJ0bWwtY3Jvb2tlZC00XCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9cbn07XG5cbnZhciBzdHJldGNoeSA9IHtcbiAgbWF0aE1Mbm9kZSxcbiAgYWNjZW50Tm9kZVxufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBuby1hcmd1bWVudCBmdW5jdGlvbnMgYW5kIHNpbmdsZS1jaGFyYWN0ZXJcbiAqIHN5bWJvbHMgKGxpa2UgJ2EnIG9yICc7JykuXG4gKlxuICogRm9yIGVhY2ggb2YgdGhlIHN5bWJvbHMsIHRoZXJlIGFyZSB0d28gcHJvcGVydGllcyB0aGV5IGNhbiBoYXZlOlxuICogLSBncm91cCAocmVxdWlyZWQpOiB0aGUgUGFyc2VOb2RlIGdyb3VwIHR5cGUgdGhlIHN5bWJvbCBzaG91bGQgaGF2ZSAoaS5lLlxuICAgICBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIGV0YykuXG4gKiAtIHJlcGxhY2U6IHRoZSBjaGFyYWN0ZXIgdGhhdCB0aGlzIHN5bWJvbCBvciBmdW5jdGlvbiBzaG91bGQgYmVcbiAqICAgcmVwbGFjZWQgd2l0aCAoaS5lLiBcIlxccGhpXCIgaGFzIGEgcmVwbGFjZSB2YWx1ZSBvZiBcIlxcdTAzZDVcIiwgdGhlIHBoaVxuICogICBjaGFyYWN0ZXIgaW4gdGhlIG1haW4gZm9udCkuXG4gKlxuICogVGhlIG91dGVybW9zdCBtYXAgaW4gdGhlIHRhYmxlIGluZGljYXRlcyB3aGF0IG1vZGUgdGhlIHN5bWJvbHMgc2hvdWxkIGJlXG4gKiBhY2NlcHRlZCBpbiAoZS5nLiBcIm1hdGhcIiBvciBcInRleHRcIikuXG4gKi9cblxuLy8gU29tZSBvZiB0aGVzZSBoYXZlIGEgXCItdG9rZW5cIiBzdWZmaXggc2luY2UgdGhlc2UgYXJlIGFsc28gdXNlZCBhcyBgUGFyc2VOb2RlYFxuLy8gdHlwZXMgZm9yIHJhdyB0ZXh0IHRva2VucywgYW5kIHdlIHdhbnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggaGlnaGVyLWxldmVsXG4vLyBgUGFyc2VOb2RlYCB0eXBlcy4gVGhlc2UgYFBhcnNlTm9kZWBzIGFyZSBjb25zdHJ1Y3RlZCB3aXRoaW4gYFBhcnNlcmAgYnlcbi8vIGxvb2tpbmcgdXAgdGhlIGBzeW1ib2xzYCBtYXAuXG5jb25zdCBBVE9NUyA9IHtcbiAgYmluOiAxLFxuICBjbG9zZTogMSxcbiAgaW5uZXI6IDEsXG4gIG9wZW46IDEsXG4gIHB1bmN0OiAxLFxuICByZWw6IDFcbn07XG5jb25zdCBOT05fQVRPTVMgPSB7XG4gIFwiYWNjZW50LXRva2VuXCI6IDEsXG4gIG1hdGhvcmQ6IDEsXG4gIFwib3AtdG9rZW5cIjogMSxcbiAgc3BhY2luZzogMSxcbiAgdGV4dG9yZDogMVxufTtcblxuY29uc3Qgc3ltYm9scyA9IHtcbiAgbWF0aDoge30sXG4gIHRleHQ6IHt9XG59O1xuXG4vKiogYGFjY2VwdFVuaWNvZGVDaGFyID0gdHJ1ZWAgaXMgb25seSBhcHBsaWNhYmxlIGlmIGByZXBsYWNlYCBpcyBzZXQuICovXG5mdW5jdGlvbiBkZWZpbmVTeW1ib2wobW9kZSwgZ3JvdXAsIHJlcGxhY2UsIG5hbWUsIGFjY2VwdFVuaWNvZGVDaGFyKSB7XG4gIHN5bWJvbHNbbW9kZV1bbmFtZV0gPSB7IGdyb3VwLCByZXBsYWNlIH07XG5cbiAgaWYgKGFjY2VwdFVuaWNvZGVDaGFyICYmIHJlcGxhY2UpIHtcbiAgICBzeW1ib2xzW21vZGVdW3JlcGxhY2VdID0gc3ltYm9sc1ttb2RlXVtuYW1lXTtcbiAgfVxufVxuXG4vLyBTb21lIGFiYnJldmlhdGlvbnMgZm9yIGNvbW1vbmx5IHVzZWQgc3RyaW5ncy5cbi8vIFRoaXMgaGVscHMgbWluaWZ5IHRoZSBjb2RlLCBhbmQgYWxzbyBzcG90dGluZyB0eXBvcyB1c2luZyBqc2hpbnQuXG5cbi8vIG1vZGVzOlxuY29uc3QgbWF0aCA9IFwibWF0aFwiO1xuY29uc3QgdGV4dCA9IFwidGV4dFwiO1xuXG4vLyBncm91cHM6XG5jb25zdCBhY2NlbnQgPSBcImFjY2VudC10b2tlblwiO1xuY29uc3QgYmluID0gXCJiaW5cIjtcbmNvbnN0IGNsb3NlID0gXCJjbG9zZVwiO1xuY29uc3QgaW5uZXIgPSBcImlubmVyXCI7XG5jb25zdCBtYXRob3JkID0gXCJtYXRob3JkXCI7XG5jb25zdCBvcCA9IFwib3AtdG9rZW5cIjtcbmNvbnN0IG9wZW4gPSBcIm9wZW5cIjtcbmNvbnN0IHB1bmN0ID0gXCJwdW5jdFwiO1xuY29uc3QgcmVsID0gXCJyZWxcIjtcbmNvbnN0IHNwYWNpbmcgPSBcInNwYWNpbmdcIjtcbmNvbnN0IHRleHRvcmQgPSBcInRleHRvcmRcIjtcblxuLy8gTm93IGNvbWVzIHRoZSBzeW1ib2wgdGFibGVcblxuLy8gUmVsYXRpb24gU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjYxXCIsIFwiXFxcXGVxdWl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdhXCIsIFwiXFxcXHByZWNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyN2JcIiwgXCJcXFxcc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFxzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3YzJcIiwgXCJcXFxccGVycFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFhZlwiLCBcIlxcXFxwcmVjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjBcIiwgXCJcXFxcc3VjY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQzXCIsIFwiXFxcXHNpbWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjRjXCIsIFwiXFxcXGJhY2tjb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJ8XCIsIFwiXFxcXG1pZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2YVwiLCBcIlxcXFxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2YlwiLCBcIlxcXFxnZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0ZFwiLCBcIlxcXFxhc3ltcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjMyM1wiLCBcIlxcXFxzbWlsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI5MVwiLCBcIlxcXFxzcXN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjkyXCIsIFwiXFxcXHNxc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTBcIiwgXCJcXFxcZG90ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcZnJvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcbmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMGNcIiwgXCJcXFxcbm90bmlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxccHJvcHRvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmEyXCIsIFwiXFxcXHZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmEzXCIsIFwiXFxcXGRhc2h2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjBiXCIsIFwiXFxcXG93bnNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNThcIiwgXCJcXFxcYXJjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTlcIiwgXCJcXFxcd2VkZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjVhXCIsIFwiXFxcXHZlZWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjViXCIsIFwiXFxcXHN0YXJlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1ZFwiLCBcIlxcXFxlcWRlZlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1ZVwiLCBcIlxcXFxtZWFzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNWZcIiwgXCJcXFxccXVlc3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2MFwiLCBcIlxcXFxuZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2MFwiLCBcIlxcXFxuZXFcIik7XG4vLyB1bmljb2RlbWF0aFxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTc1XCIsIFwiXFxcXGVxZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhNzZcIiwgXCJcXFxcZXFlcWVxXCIsIHRydWUpO1xuLy8gbWF0aHRvb2xzLnN0eVxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjM3XCIsIFwiXFxcXGRibGNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU0XCIsIFwiXFxcXGNvbG9uZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU1XCIsIFwiXFxcXGVxcWNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjM5XCIsIFwiXFxcXGVxY29sb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJBNzRcIiwgXCJcXFxcQ29sb25lcXFcIiwgdHJ1ZSk7XG5cbi8vIFB1bmN0dWF0aW9uXG5kZWZpbmVTeW1ib2wobWF0aCwgcHVuY3QsIFwiXFx1MDAyZVwiLCBcIlxcXFxsZG90cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBwdW5jdCwgXCJcXHUwMGI3XCIsIFwiXFxcXGNkb3RwXCIpO1xuXG4vLyBNaXNjIFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwMjNcIiwgXCJcXFxcI1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwMjZcIiwgXCJcXFxcJlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMzVcIiwgXCJcXFxcYWxlcGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjAwXCIsIFwiXFxcXGZvcmFsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMGZcIiwgXCJcXFxcaGJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDNcIiwgXCJcXFxcZXhpc3RzXCIsIHRydWUpO1xuLy8g4oiHIGlzIGFjdHVhbGx5IGEgdW5hcnkgb3BlcmF0b3IsIG5vdCBiaW5hcnkuIEJ1dCB0aGlzIHdvcmtzLlxuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLihKtcIiwgXCJcXFxcQW5nc3Ryb21cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLihKtcIiwgXCJcXFxcQW5nc3Ryb21cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2N1wiLCBcIlxcXFx2YXJjbHVic3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMThcIiwgXCJcXFxcd3BcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjZmXCIsIFwiXFxcXHNoYXJwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2MlwiLCBcIlxcXFxkaWFtb25kc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjZcIiwgXCJcXFxcdmFyZGlhbW9uZHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTFjXCIsIFwiXFxcXFJlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2MVwiLCBcIlxcXFxoZWFydHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjY1XCIsIFwiXFxcXHZhcmhlYXJ0c3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMTFcIiwgXCJcXFxcSW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjYwXCIsIFwiXFxcXHNwYWRlc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjRcIiwgXCJcXFxcdmFyc3BhZGVzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY0MFwiLCBcIlxcXFxmZW1hbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjQyXCIsIFwiXFxcXG1hbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGE3XCIsIFwiXFxcXFNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGE3XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGI2XCIsIFwiXFxcXFBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGI2XCIsIFwiXFxcXFBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNjNhXCIsIFwiXFxcXHNtaWxleVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2M2FcIiwgXCJcXFxcc21pbGV5XCIsIHRydWUpO1xuXG4vLyBNYXRoIGFuZCBUZXh0XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFx0ZXh0ZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMVwiLCBcIlxcXFx0ZXh0ZGFnZ2VyZGJsXCIpO1xuXG4vLyBMYXJnZSBEZWxpbWl0ZXJzXG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjNiMVwiLCBcIlxcXFxybW91c3RhY2hlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjNiMFwiLCBcIlxcXFxsbW91c3RhY2hlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI3ZWZcIiwgXCJcXFxccmdyb3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjdlZVwiLCBcIlxcXFxsZ3JvdXBcIiwgdHJ1ZSk7XG5cbi8vIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxM1wiLCBcIlxcXFxtcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5NlwiLCBcIlxcXFxvbWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOGVcIiwgXCJcXFxcdXBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTNcIiwgXCJcXFxcc3FjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTdcIiwgXCJcXFxcYXN0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk0XCIsIFwiXFxcXHNxY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNWVmXCIsIFwiXFxcXGJpZ2NpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTlcIiwgXCJcXFxcYnVsbGV0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyNDBcIiwgXCJcXFxcd3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJhM2ZcIiwgXCJcXFxcYW1hbGdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTAwMjZcIiwgXCJcXFxcQW5kXCIpOyAvLyBmcm9tIGFtc21hdGhcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkFGRFwiLCBcIlxcXFxzc2xhc2hcIiwgdHJ1ZSk7IC8vIGZyb20gc3RtYXJ5cmRcblxuLy8gQXJyb3cgU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2Y1XCIsIFwiXFxcXGxvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDBcIiwgXCJcXFxcTGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2Y4XCIsIFwiXFxcXExvbmdsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZjZcIiwgXCJcXFxcbG9uZ3JpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmOVwiLCBcIlxcXFxMb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5NFwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmN1wiLCBcIlxcXFxsb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDRcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZmFcIiwgXCJcXFxcTG9uZ2xlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWE0XCIsIFwiXFxcXG1hcHNmcm9tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWE2XCIsIFwiXFxcXG1hcHN0b1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmY1wiLCBcIlxcXFxsb25nbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk3XCIsIFwiXFxcXG5lYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYTlcIiwgXCJcXFxcaG9va2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhYVwiLCBcIlxcXFxob29rcmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5OFwiLCBcIlxcXFxzZWFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJjXCIsIFwiXFxcXGxlZnRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzBcIiwgXCJcXFxccmlnaHRoYXJwb29udXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTlcIiwgXCJcXFxcc3dhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiZFwiLCBcIlxcXFxsZWZ0aGFycG9vbmRvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzFcIiwgXCJcXFxccmlnaHRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5NlwiLCBcIlxcXFxud2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNjXCIsIFwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjFhZlwiLCBcIlxcXFxsaWdodG5pbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyMjBFXCIsIFwiXFxcXFFFRFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTIwMzBcIiwgXCJcXFxccGVybWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAzMFwiLCBcIlxcXFxwZXJtaWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyNjA5XCIsIFwiXFxcXGFzdHJvc3VuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjYzY1wiLCBcIlxcXFxzdW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyNjNlXCIsIFwiXFxcXGxlZnRtb29uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjYzZFwiLCBcIlxcXFxyaWdodG1vb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyMjk1XCIsIFwiXFxcXEVhcnRoXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNmVcIiwgXCJcXFxcbmxlc3NcIiwgdHJ1ZSk7XG4vLyBTeW1ib2wgbmFtZXMgcHJlY2VlZGVkIGJ5IFwiQFwiIGVhY2ggaGF2ZSBhIGNvcnJlc3BvbmRpbmcgbWFjcm8uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhODdcIiwgXCJcXFxcbG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2OFwiLCBcIlxcXFxsbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2OFxcdWZlMDBcIiwgXCJcXFxcbHZlcnRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmU2XCIsIFwiXFxcXGxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg5XCIsIFwiXFxcXGxuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjgwXCIsIFwiXFxcXG5wcmVjXCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMCB0byBcXG5wcmVjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlMFwiLCBcIlxcXFxucHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmU4XCIsIFwiXFxcXHByZWNuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI5XCIsIFwiXFxcXHByZWNuYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjRcIiwgXCJcXFxcbm1pZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWNcIiwgXCJcXFxcbnZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmFkXCIsIFwiXFxcXG52RGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlYVwiLCBcIlxcXFxudHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmVjXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4NFwiLCBcIlxcXFxuc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg1XCIsIFwiXFxcXG5zdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOGFcIiwgXCJcXFxcc3Vic2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjhhXFx1ZmUwMFwiLCBcIlxcXFx2YXJzdWJzZXRuZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhY2JcIiwgXCJcXFxcc3Vic2V0bmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjYlxcdWZlMDBcIiwgXCJcXFxcdmFyc3Vic2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2ZlwiLCBcIlxcXFxuZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg4XCIsIFwiXFxcXGduZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjlcIiwgXCJcXFxcZ25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjlcXHVmZTAwXCIsIFwiXFxcXGd2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlN1wiLCBcIlxcXFxnbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4YVwiLCBcIlxcXFxnbmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4MVwiLCBcIlxcXFxuc3VjY1wiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyZTEgdG8gXFxuc3VjY2N1cmx5ZXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlOVwiLCBcIlxcXFxzdWNjbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiYVwiLCBcIlxcXFxzdWNjbmFwcHJveFwiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyNDYgdG8gXFxzaW1uZXFxLiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQ2XCIsIFwiXFxcXG5jb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjI2XCIsIFwiXFxcXG5wYXJhbGxlbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNlwiLCBcIlxcXFxuc2hvcnRwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhZlwiLCBcIlxcXFxuVkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZWJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZWRcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4YlwiLCBcIlxcXFxzdXBzZXRuZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOGJcIiwgXCJcXFxcdmFyc3Vwc2V0bmVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhY2NcXHVmZTAwXCIsIFwiXFxcXHZhcnN1cHNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWVcIiwgXCJcXFxcblZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI1XCIsIFwiXFxcXHByZWNuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI2XCIsIFwiXFxcXHN1Y2NuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmI0XCIsIFwiXFxcXHVubGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmI1XCIsIFwiXFxcXHVucmhkXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBBcnJvd3NcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5YVwiLCBcIlxcXFxubGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTliXCIsIFwiXFxcXG5yaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNkXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2ZcIiwgXCJcXFxcblJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYWVcIiwgXCJcXFxcbmxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNlXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcblxuLy8gQU1TIE1pc2NcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjViM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMGZcIiwgXCJcXFxcaHNsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXGxvemVuZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNGM4XCIsIFwiXFxcXGNpcmNsZWRTXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYWVcIiwgXCJcXFxcY2lyY2xlZFJcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGFlXCIsIFwiXFxcXHRleHRyZWdpc3RlcmVkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIyMVwiLCBcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwNFwiLCBcIlxcXFxuZXhpc3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEyN1wiLCBcIlxcXFxtaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTMyXCIsIFwiXFxcXEZpbnZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTQxXCIsIFwiXFxcXEdhbWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzZcIiwgXCJcXFxcYmFja2RwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzdcIiwgXCJcXFxcYmFja3RycHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWIyXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjVhMFwiLCBcIlxcXFxibGFja3NxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI5ZWJcIiwgXCJcXFxcYmxhY2tsb3plbmdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIyMlwiLCBcIlxcXFxzcGhlcmljYWxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDFcIiwgXCJcXFxcY29tcGxlbWVudFwiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrRjAgdG8gXFxtYXRoZXRoLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxcZXRoXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGYwXCIsIFwiXFxcXGV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXHUwMGYwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjU3MVwiLCBcIlxcXFxkaWFndXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNTcyXCIsIFwiXFxcXGRpYWdkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWExXCIsIFwiXFxcXEJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcRGlhbW9uZFwiKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFUrQTUgdG8gXFxtYXRoeWVuLiBXZSBtYXAgdG8gQU1TIGZ1bmN0aW9uIFxceWVuXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGE1XCIsIFwiXFxcXHllblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjcxM1wiLCBcIlxcXFxjaGVja21hcmtcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI3MTdcIiwgXCJcXFxcYmFsbG90eFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTI3MTdcIiwgXCJcXFxcYmFsbG90eFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMjJcIiwgXCJcXFxcdGV4dGJ1bGxldFwiKTtcblxuLy8gQU1TIEhlYnJld1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEzNlwiLCBcIlxcXFxiZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEzOFwiLCBcIlxcXFxkYWxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTM3XCIsIFwiXFxcXGdpbWVsXCIsIHRydWUpO1xuXG4vLyBBTVMgR3JlZWtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAzZGRcIiwgXCJcXFxcZGlnYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAzZjBcIiwgXCJcXFxcdmFya2FwcGFcIik7XG5cbi8vIEFNUyBEZWxpbWl0ZXJzXG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyMzFDXCIsIFwiXFxcXHVsY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzMURcIiwgXCJcXFxcdXJjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyMzFFXCIsIFwiXFxcXGxsY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzMUZcIiwgXCJcXFxcbHJjb3JuZXJcIiwgdHJ1ZSk7XG5cbi8vIEFNUyBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjZcIiwgXCJcXFxcbGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE3ZFwiLCBcIlxcXFxsZXFzbGFudFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE5NVwiLCBcIlxcXFxlcXNsYW50bGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MlwiLCBcIlxcXFxsZXNzc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg1XCIsIFwiXFxcXGxlc3NhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNGFcIiwgXCJcXFxcYXBwcm94ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDZcIiwgXCJcXFxcbGVzc2RvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzZcIiwgXCJcXFxcbGVzc2d0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkYVwiLCBcIlxcXFxsZXNzZXFndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOGJcIiwgXCJcXFxcbGVzc2VxcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxkb3RlcWRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1M1wiLCBcIlxcXFxyaXNpbmdkb3RzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTJcIiwgXCJcXFxcZmFsbGluZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzZFwiLCBcIlxcXFxiYWNrc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmNkXCIsIFwiXFxcXGJhY2tzaW1lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjNVwiLCBcIlxcXFxzdWJzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDBcIiwgXCJcXFxcU3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjhmXCIsIFwiXFxcXHNxc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdjXCIsIFwiXFxcXHByZWNjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmRlXCIsIFwiXFxcXGN1cmx5ZXFwcmVjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdlXCIsIFwiXFxcXHByZWNzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjdcIiwgXCJcXFxccHJlY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiMlwiLCBcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjRcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYThcIiwgXCJcXFxcdkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWJcIiwgXCJcXFxcVkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWFcIiwgXCJcXFxcVnZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtYWxsc21pbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIzMjJcIiwgXCJcXFxcc21hbGxmcm93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0ZlwiLCBcIlxcXFxidW1wZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNGVcIiwgXCJcXFxcQnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY3XCIsIFwiXFxcXGdlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhN2VcIiwgXCJcXFxcZ2Vxc2xhbnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOTZcIiwgXCJcXFxcZXFzbGFudGd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3M1wiLCBcIlxcXFxndHJzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhODZcIiwgXCJcXFxcZ3RyYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQ3XCIsIFwiXFxcXGd0cmRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkOVwiLCBcIlxcXFxnZ2dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzdcIiwgXCJcXFxcZ3RybGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkYlwiLCBcIlxcXFxndHJlcWxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOGNcIiwgXCJcXFxcZ3RyZXFxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1NlwiLCBcIlxcXFxlcWNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTdcIiwgXCJcXFxcY2lyY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjVjXCIsIFwiXFxcXHRyaWFuZ2xlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFx0aGlja3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFx0aGlja2FwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjNlwiLCBcIlxcXFxzdXBzZXRlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDFcIiwgXCJcXFxcU3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjkwXCIsIFwiXFxcXHNxc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdkXCIsIFwiXFxcXHN1Y2NjdXJseWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmRmXCIsIFwiXFxcXGN1cmx5ZXFzdWNjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdmXCIsIFwiXFxcXHN1Y2NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjhcIiwgXCJcXFxcc3VjY2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmI1XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhOVwiLCBcIlxcXFxWZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxzaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNVwiLCBcIlxcXFxzaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjZjXCIsIFwiXFxcXGJldHdlZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDRcIiwgXCJcXFxccGl0Y2hmb3JrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjFkXCIsIFwiXFxcXHZhcnByb3B0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjVjMFwiLCBcIlxcXFxibGFja3RyaWFuZ2xlbGVmdFwiKTtcbi8vIHVuaWNvZGUtbWF0aCBzYXlzIHRoYXQgXFx0aGVyZWZvcmUgaXMgYSBtYXRob3JkIGF0b20uXG4vLyBXZSBrZXB0IHRoZSBhbXNzeW1iIGF0b20gdHlwZSwgd2hpY2ggaXMgcmVsLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjM0XCIsIFwiXFxcXHRoZXJlZm9yZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwZFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjViNlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlcmlnaHRcIik7XG4vLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcYmVjYXVzZSBpcyBhIG1hdGhvcmQgYXRvbS5cbi8vIFdlIGtlcHQgdGhlIGFtc3N5bWIgYXRvbSB0eXBlLCB3aGljaCBpcyByZWwuXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMzVcIiwgXCJcXFxcYmVjYXVzZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dndHJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYjJcIiwgXCJcXFxcbGhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmIzXCIsIFwiXFxcXHJoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0MlwiLCBcIlxcXFxlcXNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxEb3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1Mjk3ZFwiLCBcIlxcXFxzdHJpY3RpZlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1Mjk3Y1wiLCBcIlxcXFxzdHJpY3RmaVwiLCB0cnVlKTtcblxuLy8gQU1TIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxNFwiLCBcIlxcXFxkb3RwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE2XCIsIFwiXFxcXHNtYWxsc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcQ2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXEN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MmE1ZVwiLCBcIlxcXFxkb3VibGViYXJ3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5ZlwiLCBcIlxcXFxib3htaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5ZVwiLCBcIlxcXFxib3hwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUM0XCIsIFwiXFxcXGJveHNsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM3XCIsIFwiXFxcXGRpdmlkZW9udGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzlcIiwgXCJcXFxcbHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmNhXCIsIFwiXFxcXHJ0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjYlwiLCBcIlxcXFxsZWZ0dGhyZWV0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjY1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyY2ZcIiwgXCJcXFxcY3VybHl3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjZVwiLCBcIlxcXFxjdXJseXZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5ZFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5YlwiLCBcIlxcXFxjaXJjbGVkYXN0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmJhXCIsIFwiXFxcXGludGVyY2FsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXGRvdWJsZWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJkM1wiLCBcIlxcXFxkb3VibGVjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYTBcIiwgXCJcXFxcYm94dGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzhcIiwgXCJcXFxcYm93dGllXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM4XCIsIFwiXFxcXEpvaW5cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3ZDVcIiwgXCJcXFxcbGVmdG91dGVyam9pblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdkNlwiLCBcIlxcXFxyaWdodG91dGVyam9pblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdkN1wiLCBcIlxcXFxmdWxsb3V0ZXJqb2luXCIsIHRydWUpO1xuXG4vLyBzdGl4IEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIzOFwiLCBcIlxcXFxkb3RtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdEMVwiLCBcIlxcXFx3ZWRnZWRvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdDN1wiLCBcIlxcXFx2ZWVkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNjJcIiwgXCJcXFxcZG91YmxlYmFydmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTYzXCIsIFwiXFxcXHZlZWRvdWJsZWJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE1RlwiLCBcIlxcXFx3ZWRnZWJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE2MFwiLCBcIlxcXFx3ZWRnZWRvdWJsZWJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE1NFwiLCBcIlxcXFxWZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNTNcIiwgXCJcXFxcV2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDNcIiwgXCJcXFxcYmFyY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQyXCIsIFwiXFxcXGJhcmN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0OFwiLCBcIlxcXFxjYXBiYXJjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDBcIiwgXCJcXFxcY2FwZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQ3XCIsIFwiXFxcXGNhcG92ZXJjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDZcIiwgXCJcXFxcY3Vwb3ZlcmNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0RFwiLCBcIlxcXFxjbG9zZWR2YXJjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNENcIiwgXCJcXFxcY2xvc2VkdmFyY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTJBXCIsIFwiXFxcXG1pbnVzZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTJCXCIsIFwiXFxcXG1pbnVzZmRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMkNcIiwgXCJcXFxcbWludXNyZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJCQlwiLCBcIlxcXFxYb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQkNcIiwgXCJcXFxcTmFuZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJCRFwiLCBcIlxcXFxOb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQkRcIiwgXCJcXFxcYmFydmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQUY0XCIsIFwiXFxcXGludGVybGVhdmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5RTJcIiwgXCJcXFxcc2h1ZmZsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkFGNlwiLCBcIlxcXFx0aHJlZWRvdGNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOTgyXCIsIFwiXFxcXHR5cGVjb2xvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIzRVwiLCBcIlxcXFxpbnZsYXp5c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0QlwiLCBcIlxcXFx0d29jYXBzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTRBXCIsIFwiXFxcXHR3b2N1cHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNEVcIiwgXCJcXFxcU3FjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNEZcIiwgXCJcXFxcU3FjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNTZcIiwgXCJcXFxcdmVlb252ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNTVcIiwgXCJcXFxcd2VkZ2VvbndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUQ3XCIsIFwiXFxcXGJsYWNraG91cmdsYXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUM2XCIsIFwiXFxcXGJveGFzdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDOFwiLCBcIlxcXFxib3hib3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzdcIiwgXCJcXFxcYm94Y2lyY2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjlDXCIsIFwiXFxcXGNpcmNsZWRlcXVhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlCN1wiLCBcIlxcXFxjaXJjbGVkcGFyYWxsZWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QjZcIiwgXCJcXFxcY2lyY2xlZHZlcnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QjVcIiwgXCJcXFxcY2lyY2xlaGJhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFMVwiLCBcIlxcXFxjb25jYXZlZGlhbW9uZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFMlwiLCBcIlxcXFxjb25jYXZlZGlhbW9uZHRpY2tsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0UzXCIsIFwiXFxcXGNvbmNhdmVkaWFtb25kdGlja3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMkM0XCIsIFwiXFxcXGRpYW1vbmRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5RDZcIiwgXCJcXFxcaG91cmdsYXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0UwXCIsIFwiXFxcXGxvemVuZ2VtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjMzRFwiLCBcIlxcXFxvYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUI4XCIsIFwiXFxcXG9ic2xhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMzhcIiwgXCJcXFxcb2RpdlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDMVwiLCBcIlxcXFxvZ3JlYXRlcnRoYW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzBcIiwgXCJcXFxcb2xlc3N0aGFuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUI5XCIsIFwiXFxcXG9wZXJwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTM3XCIsIFwiXFxcXE90aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzNlwiLCBcIlxcXFxvdGltZXNoYXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQzZcIiwgXCJcXFxcc3RhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjVCM1wiLCBcIlxcXFx0cmlhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzQVwiLCBcIlxcXFx0cmlhbmdsZW1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTM5XCIsIFwiXFxcXHRyaWFuZ2xlcGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzQlwiLCBcIlxcXFx0cmlhbmdsZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0U0XCIsIFwiXFxcXHdoaXRlc3F1YXJldGlja2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RTVcIiwgXCJcXFxcd2hpdGVzcXVhcmV0aWNrcmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMzNcIiwgXCJcXFxcc21hc2h0aW1lc1wiLCB0cnVlKTtcblxuLy8gQU1TIEFycm93c1xuLy8gTm90ZTogdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFlMiB0byB0aGVpciBvd24gZnVuY3Rpb24gXFxyaWdodGRhc2hhcnJvdy5cbi8vIFdlJ2xsIG1hcCBpdCB0byBBTVMgZnVuY3Rpb24gXFxkYXNocmlnaHRhcnJvdy4gSXQgcHJvZHVjZXMgdGhlIHNhbWUgYXRvbS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFlMlwiLCBcIlxcXFxkYXNocmlnaHRhcnJvd1wiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxZTAgdG8gXFxsZWZ0ZGFzaGFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWUwXCIsIFwiXFxcXGRhc2hsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzdcIiwgXCJcXFxcbGVmdGxlZnRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzZcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWRhXCIsIFwiXFxcXExsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOWVcIiwgXCJcXFxcdHdvaGVhZGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhMlwiLCBcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWFiXCIsIFwiXFxcXGxvb3BhcnJvd2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2JcIiwgXCJcXFxcbGVmdHJpZ2h0aGFycG9vbnNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYjZcIiwgXCJcXFxcY3VydmVhcnJvd2xlZnRcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWJhIHRvIFxcYWN3b3BlbmNpcmNsZWFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJhXCIsIFwiXFxcXGNpcmNsZWFycm93bGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiMFwiLCBcIlxcXFxMc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiZlwiLCBcIlxcXFx1cGhhcnBvb25sZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWMzXCIsIFwiXFxcXGRvd25oYXJwb29ubGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiNlwiLCBcIlxcXFxvcmlnb2ZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjdcIiwgXCJcXFxcaW1hZ2VvZlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiOFwiLCBcIlxcXFxtdWx0aW1hcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhZFwiLCBcIlxcXFxsZWZ0cmlnaHRzcXVpZ2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWM5XCIsIFwiXFxcXHJpZ2h0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzRcIiwgXCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWEwXCIsIFwiXFxcXHR3b2hlYWRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWEzXCIsIFwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWFjXCIsIFwiXFxcXGxvb3BhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWI3XCIsIFwiXFxcXGN1cnZlYXJyb3dyaWdodFwiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxYmIgdG8gXFxjd29wZW5jaXJjbGVhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiYlwiLCBcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWIxXCIsIFwiXFxcXFJzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjYVwiLCBcIlxcXFxkb3duZG93bmFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFx1cGhhcnBvb25yaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjMlwiLCBcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWRkXCIsIFwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxsZWFkc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWRiXCIsIFwiXFxcXFJyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJlXCIsIFwiXFxcXHJlc3RyaWN0aW9uXCIpO1xuXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiYFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcJFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcJFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIiRcIiwgXCJcXFxcdGV4dGRvbGxhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIsKiXCIsIFwiXFxcXGNlbnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLColwiLCBcIlxcXFxjZW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiX1wiLCBcIlxcXFx0ZXh0dW5kZXJzY29yZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTI0MjNcIiwgXCJcXFxcdGV4dHZpc2libGVzcGFjZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMjBcIiwgXCJcXFxcYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjFlXCIsIFwiXFxcXGluZnR5XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzMlwiLCBcIlxcXFxwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzNcIiwgXCJcXFxcZHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzNFwiLCBcIlxcXFx0cnByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjA1N1wiLCBcIlxcXFxxcHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWIzXCIsIFwiXFxcXHRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5MVwiLCBcIlxcXFxBbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTJcIiwgXCJcXFxcQmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5NVwiLCBcIlxcXFxFcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5NlwiLCBcIlxcXFxaZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5N1wiLCBcIlxcXFxFdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk4XCIsIFwiXFxcXFRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5OVwiLCBcIlxcXFxJb3RhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5YVwiLCBcIlxcXFxLYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5Y1wiLCBcIlxcXFxNdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWRcIiwgXCJcXFxcTnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzllXCIsIFwiXFxcXFhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5ZlwiLCBcIlxcXFxPbWljcm9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhMFwiLCBcIlxcXFxQaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTFcIiwgXCJcXFxcUmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhM1wiLCBcIlxcXFxTaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTRcIiwgXCJcXFxcVGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2E3XCIsIFwiXFxcXENoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYThcIiwgXCJcXFxcUHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhOVwiLCBcIlxcXFxPbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTFcIiwgXCJcXFxcQWxwaGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzkyXCIsIFwiXFxcXEJldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzkzXCIsIFwiXFxcXEdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5NFwiLCBcIlxcXFxEZWx0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTVcIiwgXCJcXFxcRXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTZcIiwgXCJcXFxcWmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTdcIiwgXCJcXFxcRXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTlcIiwgXCJcXFxcSW90YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWFcIiwgXCJcXFxcS2FwcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzliXCIsIFwiXFxcXExhbWJkYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWNcIiwgXCJcXFxcTXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzlkXCIsIFwiXFxcXE51XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWZcIiwgXCJcXFxcT21pY3JvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2ExXCIsIFwiXFxcXFJob1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTNcIiwgXCJcXFxcU2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E0XCIsIFwiXFxcXFRhdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTVcIiwgXCJcXFxcVXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTZcIiwgXCJcXFxcUGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhN1wiLCBcIlxcXFxDaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUwMGFjXCIsIFwiXFxcXG5lZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTAwYWNcIiwgXCJcXFxcbG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyYTRcIiwgXCJcXFxcdG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjJhNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjMwMFwiLCBcIlxcXFx2YXJub3RoaW5nXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiMVwiLCBcIlxcXFxhbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjJcIiwgXCJcXFxcYmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjNcIiwgXCJcXFxcZ2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I0XCIsIFwiXFxcXGRlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNmNVwiLCBcIlxcXFxlcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiNlwiLCBcIlxcXFx6ZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiN1wiLCBcIlxcXFxldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I4XCIsIFwiXFxcXHRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiOVwiLCBcIlxcXFxpb3RhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiYVwiLCBcIlxcXFxrYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmJcIiwgXCJcXFxcbGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiY1wiLCBcIlxcXFxtdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmRcIiwgXCJcXFxcbnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2JlXCIsIFwiXFxcXHhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiZlwiLCBcIlxcXFxvbWljcm9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjMFwiLCBcIlxcXFxwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzFcIiwgXCJcXFxccmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjM1wiLCBcIlxcXFxzaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzRcIiwgXCJcXFxcdGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjNVwiLCBcIlxcXFx1cHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkNVwiLCBcIlxcXFxwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2M3XCIsIFwiXFxcXGNoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzhcIiwgXCJcXFxccHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjOVwiLCBcIlxcXFxvbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjVcIiwgXCJcXFxcdmFyZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDFcIiwgXCJcXFxcdmFydGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Q2XCIsIFwiXFxcXHZhcnBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNmMVwiLCBcIlxcXFx2YXJyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2MyXCIsIFwiXFxcXHZhcnNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjNlwiLCBcIlxcXFx2YXJwaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Q4XCIsIFwiXFxcXENvcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkOVwiLCBcIlxcXFxjb3BwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDlcIiwgXCJcXFxcdmFyY29wcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2RlXCIsIFwiXFxcXEtvcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkZlwiLCBcIlxcXFxrb3BwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZTBcIiwgXCJcXFxcU2FtcGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2UxXCIsIFwiXFxcXHNhbXBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkYVwiLCBcIlxcXFxTdGlnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2RiXCIsIFwiXFxcXHN0aWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTJhZWJcIiwgXCJcXFxcQm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFx1MjIxN1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiK1wiLCBcIitcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTdcIiwgXCIqXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMDQ0XCIsIFwiL1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjA0NFwiLCBcIlxcdTIwNDRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTJcIiwgXCItXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM1XCIsIFwiXFxcXGNkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMThcIiwgXCJcXFxcY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MDBmN1wiLCBcIlxcXFxkaXZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTAwYjFcIiwgXCJcXFxccG1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTAwZDdcIiwgXCJcXFxcdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMjlcIiwgXCJcXFxcY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjJhXCIsIFwiXFxcXGN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzZXRtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFxsYW5kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjI4XCIsIFwiXFxcXGxvclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyN1wiLCBcIlxcXFx3ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFx2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyN2U2XCIsIFwiXFxcXGxsYnJhY2tldFwiLCB0cnVlKTsgLy8gc3RtYXJ5cmQvc2VtYW50aWMgcGFja2FnZXNcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyN2U3XCIsIFwiXFxcXHJyYnJhY2tldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI3ZThcIiwgXCJcXFxcbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjdlYVwiLCBcIlxcXFxsQW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyOTg5XCIsIFwiXFxcXGxsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJ8XCIsIFwiXFxcXGx2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjAxNlwiLCBcIlxcXFxsVmVydFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIiFcIiwgXCJcXFxcb2NcIik7IC8vIGNtbGwgcGFja2FnZVxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiP1wiLCBcIlxcXFx3blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxOTNcIiwgXCJcXFxcc2hwb3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTk1XCIsIFwiXFxcXHNoaWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjE5MVwiLCBcIlxcXFxzaG5lZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCI/XCIsIFwiP1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCIhXCIsIFwiIVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCLigLxcIiwgXCLigLxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjdlYlwiLCBcIlxcXFxyQW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1Mjk4YVwiLCBcIlxcXFxycmFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcInxcIiwgXCJcXFxccnZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjAxNlwiLCBcIlxcXFxyVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI5ODNcIiwgXCJcXFxcbEJyYWNlXCIsIHRydWUpOyAvLyBzdG1hcnlyZC9zZW1hbnRpYyBwYWNrYWdlc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI5ODRcIiwgXCJcXFxcckJyYWNlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCI9XCIsIFwiXFxcXGVxdWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFxhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiPlwiLCBcIlxcXFxndFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwOFwiLCBcIlxcXFxpblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwOVwiLCBcIlxcXFxub3RpblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1ZTAyMFwiLCBcIlxcXFxAbm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjgyXCIsIFwiXFxcXHN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4M1wiLCBcIlxcXFxzdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODZcIiwgXCJcXFxcc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODdcIiwgXCJcXFxcc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg4XCIsIFwiXFxcXG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODlcIiwgXCJcXFxcbnN1cHNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg5XCIsIFwiXFxcXG5zdXBzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYThcIiwgXCJcXFxcbW9kZWxzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkwXCIsIFwiXFxcXGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NFwiLCBcIlxcXFxsZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIjxcIiwgXCJcXFxcbHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTJcIiwgXCJcXFxccmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFx0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MVwiLCBcIlxcXFxuZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcxXCIsIFwiXFxcXG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcxXCIsIFwiXFxcXG5nZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MFwiLCBcIlxcXFxubGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFlYlwiLCBcIlxcXFxQZXJwXCIsIHRydWUpOyAvL2NtbGwgcGFja2FnZVxuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFwgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTtcbi8vIFJlZjogTGFUZVggU291cmNlIDJlOiBcXERlY2xhcmVSb2J1c3RDb21tYW5ke1xcbm9icmVha3NwYWNlfXslXG5kZWZpbmVTeW1ib2wobWF0aCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCIgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxzcGFjZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIG51bGwsIFwiXFxcXG5vYnJlYWtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgc3BhY2luZywgbnVsbCwgXCJcXFxcYWxsb3dicmVha1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBwdW5jdCwgXCIsXCIsIFwiLFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBwdW5jdCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBwdW5jdCwgXCI7XCIsIFwiO1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiY1wiLCBcIlxcXFxiYXJ3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiYlwiLCBcIlxcXFx2ZWViYXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTlcIiwgXCJcXFxcb2RvdFwiLCB0cnVlKTtcbi8vIEZpcmVmb3ggdHVybnMg4oqVIGludG8gYW4gZW1vamkuIFNvIGFwcGVuZCBcXHVGRTBFLiBEZWZpbmUgVW5pY29kZSBjaGFyYWN0ZXIgaW4gbWFjcm9zLCBub3QgaGVyZS5cbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5NVxcdUZFMEVcIiwgXCJcXFxcb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTdcIiwgXCJcXFxcb3RpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk4XCIsIFwiXFxcXG9zbGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5YVwiLCBcIlxcXFxjaXJjbGVkY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJhMVwiLCBcIlxcXFxib3hkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1YjNcIiwgXCJcXFxcYmlndHJpYW5nbGV1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjViZFwiLCBcIlxcXFxiaWd0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM0XCIsIFwiXFxcXGRpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1YzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNWI5XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHRleHRicmFjZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwifVwiLCBcIlxcXFx0ZXh0YnJhY2VyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIntcIiwgXCJcXFxcbGJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIn1cIiwgXCJcXFxccmJyYWNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiKFwiLCBcIlxcXFxscGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiKVwiLCBcIlxcXFxycGFyZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCLipodcIiwgXCJcXFxcbGxwYXJlbnRoZXNpc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCLipohcIiwgXCJcXFxccnJwYXJlbnRoZXNpc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIjxcIiwgXCJcXFxcdGV4dGxlc3NcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIj5cIiwgXCJcXFxcdGV4dGdyZWF0ZXJcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTIzMGFcIiwgXCJcXFxcbGZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzMGJcIiwgXCJcXFxccmZsb29yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFxiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJ8XCIsIFwifFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcInxcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcInxcIiwgXCJcXFxcdGV4dGJhclwiLCB0cnVlKTsgLy8gaW4gVDEgZm9udGVuY1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAxNlwiLCBcIlxcXFx8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAxNlwiLCBcIlxcXFxWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxNlwiLCBcIlxcXFx0ZXh0YmFyZGJsXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiflwiLCBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcXFxcIiwgXCJcXFxcdGV4dGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIl5cIiwgXCJcXFxcdGV4dGFzY2lpY2lyY3VtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkxXCIsIFwiXFxcXHVwYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDFcIiwgXCJcXFxcVXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5M1wiLCBcIlxcXFxkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDNcIiwgXCJcXFxcRG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk1XCIsIFwiXFxcXHVwZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWQ1XCIsIFwiXFxcXFVwZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMTBcIiwgXCJcXFxcY29wcm9kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyYzFcIiwgXCJcXFxcYmlndmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyYzBcIiwgXCJcXFxcYmlnd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwNFwiLCBcIlxcXFxiaWd1cGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA0XCIsIFwiXFxcXGJpZ2N1cHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwM1wiLCBcIlxcXFxiaWdjdXBkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwN1wiLCBcIlxcXFxiaWdkb3VibGV2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwOFwiLCBcIlxcXFxiaWdkb3VibGV3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMmMyXCIsIFwiXFxcXGJpZ2NhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMmMzXCIsIFwiXFxcXGJpZ2N1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJiXCIsIFwiXFxcXGludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJiXCIsIFwiXFxcXGludG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmNcIiwgXCJcXFxcaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJkXCIsIFwiXFxcXGlpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMGZcIiwgXCJcXFxccHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjExXCIsIFwiXFxcXHN1bVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTAyXCIsIFwiXFxcXGJpZ290aW1lc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTAxXCIsIFwiXFxcXGJpZ29wbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDBcIiwgXCJcXFxcYmlnb2RvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA5XCIsIFwiXFxcXGJpZ3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmVcIiwgXCJcXFxcb2ludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJmXCIsIFwiXFxcXG9paW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMzBcIiwgXCJcXFxcb2lpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMzFcIiwgXCJcXFxcaW50Y2xvY2t3aXNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMzJcIiwgXCJcXFxcdmFyb2ludGNsb2Nrd2lzZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBjXCIsIFwiXFxcXGlpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBkXCIsIFwiXFxcXGludGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBlXCIsIFwiXFxcXGludEJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTBmXCIsIFwiXFxcXGZpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExMlwiLCBcIlxcXFxycHBvbGludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTEzXCIsIFwiXFxcXHNjcG9saW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMTVcIiwgXCJcXFxccG9pbnRpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExNlwiLCBcIlxcXFxzcWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTE3XCIsIFwiXFxcXGludGxhcmhrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMThcIiwgXCJcXFxcaW50eFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTE5XCIsIFwiXFxcXGludGNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTFhXCIsIFwiXFxcXGludGN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA1XCIsIFwiXFxcXGJpZ3NxY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXG1hdGhlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjJmMFwiLCBcIlxcXFxpZGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjJlZlwiLCBcIlxcXFxAY2RvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjJmMVwiLCBcIlxcXFxkZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyZWVcIiwgXCJcXFxcdmFydmRvdHNcIik7IC8vIFxcdmRvdHMgaXMgYSBtYWNyb1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2YXJ2ZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjYVwiLCBcIlxcXFxhY3V0ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDA2MFwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCBcIlxcXFxkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUyMDI2XCIsIFwiXFxcXGRkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUyMDI2XFx1MDAyZVwiLCBcIlxcXFxkZGRkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwN2VcIiwgXCJcXFxcdGlsZGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTIwM2VcIiwgXCJcXFxcYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXGJyZXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXGNoZWNrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMDVlXCIsIFwiXFxcXGhhdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MjE5MlwiLCBcIlxcXFx2ZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXG1hdGhyaW5nXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDEzMVwiLCBcIlxcXFxpbWF0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcam1hdGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFx1MDEzMVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXHUwMjM3XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDEzMVwiLCBcIlxcXFxpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDIzN1wiLCBcIlxcXFxqXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBkZlwiLCBcIlxcXFxzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwZTZcIiwgXCJcXFxcYWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMTUzXCIsIFwiXFxcXG9lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBmOFwiLCBcIlxcXFxvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDBmOFwiLCBcIlxcXFxvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBjNlwiLCBcIlxcXFxBRVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAxNTJcIiwgXCJcXFxcT0VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGQ4XCIsIFwiXFxcXE9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMGQ4XCIsIFwiXFxcXE9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyY2FcIiwgXCJcXFxcJ1wiKTsgLy8gYWN1dGVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxgXCIpOyAvLyBncmF2ZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmM2XCIsIFwiXFxcXF5cIik7IC8vIGNpcmN1bWZsZXhcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJkY1wiLCBcIlxcXFx+XCIpOyAvLyB0aWxkZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXD1cIik7IC8vIG1hY3JvblxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXHVcIik7IC8vIGJyZXZlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcLlwiKTsgLy8gZG90IGFib3ZlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAwYjhcIiwgXCJcXFxcY1wiKTsgLy8gY2VkaWxsYVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXHJcIik7IC8vIHJpbmcgYWJvdmVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFx2XCIpOyAvLyBjYXJvblxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMGE4XCIsICdcXFxcXCInKTsgLy8gZGlhZXJlc2lzXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyZGRcIiwgXCJcXFxcSFwiKTsgLy8gZG91YmxlIGFjdXRlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyY2FcIiwgXCJcXFxcJ1wiKTsgLy8gYWN1dGVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjYlwiLCBcIlxcXFxgXCIpOyAvLyBncmF2ZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmM2XCIsIFwiXFxcXF5cIik7IC8vIGNpcmN1bWZsZXhcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkY1wiLCBcIlxcXFx+XCIpOyAvLyB0aWxkZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmM5XCIsIFwiXFxcXD1cIik7IC8vIG1hY3JvblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmQ4XCIsIFwiXFxcXHVcIik7IC8vIGJyZXZlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZDlcIiwgXCJcXFxcLlwiKTsgLy8gZG90IGFib3ZlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwYjhcIiwgXCJcXFxcY1wiKTsgLy8gY2VkaWxsYVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmRhXCIsIFwiXFxcXHJcIik7IC8vIHJpbmcgYWJvdmVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFx2XCIpOyAvLyBjYXJvblxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMGE4XCIsICdcXFxcXCInKTsgLy8gZGlhZXJlc2lzXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZGRcIiwgXCJcXFxcSFwiKTsgLy8gZG91YmxlIGFjdXRlXG5cbi8vIFRoZXNlIGxpZ2F0dXJlcyBhcmUgZGV0ZWN0ZWQgYW5kIGNyZWF0ZWQgaW4gUGFyc2VyLmpzJ3MgYGZvcm1MaWdhdHVyZXNgLlxuY29uc3QgbGlnYXR1cmVzID0ge1xuICBcIi0tXCI6IHRydWUsXG4gIFwiLS0tXCI6IHRydWUsXG4gIFwiYGBcIjogdHJ1ZSxcbiAgXCInJ1wiOiB0cnVlXG59O1xuXG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiXFxcXHRleHRlbmRhc2hcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIlxcXFx0ZXh0ZW1kYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiXFxcXHRleHRxdW90ZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCJcXFxcdGV4dHF1b3RlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiYGBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFjXCIsIFwiXFxcXHRleHRxdW90ZWRibGxlZnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiJydcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDFkXCIsIFwiXFxcXHRleHRxdW90ZWRibHJpZ2h0XCIpO1xuLy8gIFxcZGVncmVlIGZyb20gZ2Vuc3ltYiBwYWNrYWdlXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXGRlZ3JlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpO1xuLy8gXFx0ZXh0ZGVncmVlIGZyb20gaW5wdXRlbmMgcGFja2FnZVxuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFx0ZXh0ZGVncmVlXCIsIHRydWUpO1xuLy8gVE9ETzogSW4gTGFUZVgsIFxccG91bmRzIGNhbiBnZW5lcmF0ZSBhIGRpZmZlcmVudCBjaGFyYWN0ZXIgaW4gdGV4dCBhbmQgbWF0aFxuLy8gbW9kZSwgYnV0IGFtb25nIG91ciBmb250cywgb25seSBNYWluLVJlZ3VsYXIgZGVmaW5lcyB0aGlzIGNoYXJhY3RlciBcIjE2M1wiLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxwb3VuZHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXG1hdGhzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFx0ZXh0c3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMGFjXCIsIFwiXFxcXGV1cm9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMGFjXCIsIFwiXFxcXGV1cm9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMGFjXCIsIFwiXFxcXHRleHRldXJvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhOVwiLCBcIlxcXFxjb3B5cmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGE5XCIsIFwiXFxcXHRleHRjb3B5cmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMzAwXCIsIFwiXFxcXGRpYW1ldGVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjMwMFwiLCBcIlxcXFxkaWFtZXRlclwiKTtcblxuLy8gSXRhbGljIEdyZWVrXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZukXCIsIFwiXFxcXHZhckdhbW1hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2bpVwiLCBcIlxcXFx2YXJEZWx0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm6lcIiwgXCJcXFxcdmFyVGhldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZusXCIsIFwiXFxcXHZhckxhbWJkYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm69cIiwgXCJcXFxcdmFyWGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZuxXCIsIFwiXFxcXHZhclBpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2btFwiLCBcIlxcXFx2YXJTaWdtYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7ZcIiwgXCJcXFxcdmFyVXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7dcIiwgXCJcXFxcdmFyUGhpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2buVwiLCBcIlxcXFx2YXJQc2lcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZu6XCIsIFwiXFxcXHZhck9tZWdhXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bpFwiLCBcIlxcXFx2YXJHYW1tYVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm6VcIiwgXCJcXFxcdmFyRGVsdGFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZupXCIsIFwiXFxcXHZhclRoZXRhXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2brFwiLCBcIlxcXFx2YXJMYW1iZGFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZuvXCIsIFwiXFxcXHZhclhpXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bsVwiLCBcIlxcXFx2YXJQaVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7RcIiwgXCJcXFxcdmFyU2lnbWFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZu2XCIsIFwiXFxcXHZhclVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZu3XCIsIFwiXFxcXHZhclBoaVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7lcIiwgXCJcXFxcdmFyUHNpXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bulwiLCBcIlxcXFx2YXJPbWVnYVwiKTtcblxuXG4vLyBUaGVyZSBhcmUgbG90cyBvZiBzeW1ib2xzIHdoaWNoIGFyZSB0aGUgc2FtZSwgc28gd2UgYWRkIHRoZW0gaW4gYWZ0ZXJ3YXJkcy5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG5jb25zdCBtYXRoVGV4dFN5bWJvbHMgPSAnMDEyMzQ1Njc4OS9ALlwiJztcbmZvciAobGV0IGkgPSAwOyBpIDwgbWF0aFRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gdGV4dCBtb2RlXG5jb25zdCB0ZXh0U3ltYm9scyA9ICcwMTIzNDU2Nzg5IUAqKCktPStcIjs6Py8uLCc7XG5mb3IgKGxldCBpID0gMDsgaSA8IHRleHRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gdGV4dFN5bWJvbHMuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcbmNvbnN0IGxldHRlcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbmZvciAobGV0IGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IGxldHRlcnMuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgY2gsIGNoKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIFNvbWUgbW9yZSBsZXR0ZXJzIGluIFVuaWNvZGUgQmFzaWMgTXVsdGlsaW5ndWFsIFBsYW5lLlxuY29uc3QgbmFycm93ID0gXCLDh8OQw57Dp8O+4oSC4oSN4oSV4oSZ4oSa4oSd4oSk4oSO4oSP4oSK4oSL4oSM4oSQ4oSR4oSS4oST4oSY4oSb4oSc4oSs4oSw4oSx4oSz4oSt4oSoXCI7XG5mb3IgKGxldCBpID0gMDsgaSA8IG5hcnJvdy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IG5hcnJvdy5jaGFyQXQoaSk7XG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBjaCwgY2gpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gVGhlIG5leHQgbG9vcCBsb2FkcyB3aWRlIChzdXJyb2dhdGUgcGFpcikgY2hhcmFjdGVycy5cbi8vIFdlIHN1cHBvcnQgc29tZSBsZXR0ZXJzIGluIHRoZSBVbmljb2RlIHJhbmdlIFUrMUQ0MDAgdG8gVSsxRDdGRixcbi8vIE1hdGhlbWF0aWNhbCBBbHBoYW51bWVyaWMgU3ltYm9scy5cbmxldCB3aWRlQ2hhciA9IFwiXCI7XG5mb3IgKGxldCBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgLy8gVGhlIGhleCBudW1iZXJzIGluIHRoZSBuZXh0IGxpbmUgYXJlIGEgc3Vycm9nYXRlIHBhaXIuXG4gIC8vIDB4RDgzNSBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgZm9yIGFsbCBsZXR0ZXJzIGluIHRoZSByYW5nZSB3ZSBzdXBwb3J0LlxuICAvLyAweERDMDAgaXMgdGhlIGxvdyBzdXJyb2dhdGUgZm9yIGJvbGQgQS5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkYzAwICsgaSk7IC8vIEEtWiBhLXogYm9sZFxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkYzM0ICsgaSk7IC8vIEEtWiBhLXogaXRhbGljXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRjNjggKyBpKTsgLy8gQS1aIGEteiBib2xkIGl0YWxpY1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZDA0ICsgaSk7IC8vIEEtWiBhLXogRnJhY3R1clxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZGEwICsgaSk7IC8vIEEtWiBhLXogc2Fucy1zZXJpZlxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZGQ0ICsgaSk7IC8vIEEtWiBhLXogc2FucyBib2xkXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRlMDggKyBpKTsgLy8gQS1aIGEteiBzYW5zIGl0YWxpY1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZTcwICsgaSk7IC8vIEEtWiBhLXogbW9ub3NwYWNlXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRkMzggKyBpKTsgLy8gQS1aIGEteiBkb3VibGUgc3RydWNrXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICBjb25zdCBjaCA9IGxldHRlcnMuY2hhckF0KGkpO1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRjOWMgKyBpKTsgLy8gQS1aIGEteiBjYWxsaWdyYXBoaWNcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIGNoLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBjaCwgd2lkZUNoYXIpO1xufVxuXG4vLyBOZXh0LCBzb21lIHdpZGUgY2hhcmFjdGVyIG51bWVyYWxzXG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZmNlICsgaSk7IC8vIDAtOSBib2xkXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRmZTIgKyBpKTsgLy8gMC05IHNhbnMgc2VyaWZcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGZlYyArIGkpOyAvLyAwLTkgYm9sZCBzYW5zXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRmZjYgKyBpKTsgLy8gMC05IG1vbm9zcGFjZVxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG59XG5cbi8qXG4gKiBOZWl0aGVyIEZpcmVmb3ggbm9yIENocm9tZSBzdXBwb3J0IGhhcmQgbGluZSBicmVha3Mgb3Igc29mdCBsaW5lIGJyZWFrcy5cbiAqIChEZXNwaXRlIGh0dHBzOi8vd3d3LnczLm9yZy9NYXRoL2RyYWZ0LXNwZWMvbWF0aG1sLmh0bWwjY2hhcHRlcjNfcHJlc20ubGJhdHRycylcbiAqIFNvIFRlbW1sIGhhcyB3b3JrLWFyb3VuZHMgZm9yIGJvdGggaGFyZCBhbmQgc29mdCBicmVha3MuXG4gKiBUaGUgd29yay1hcm91bmRzIHNhZGx5IGRvIG5vdCB3b3JrIHNpbXVsdGFuZW91c2x5LiBBbnkgdG9wLWxldmVsIGhhcmRcbiAqIGJyZWFrIG1ha2VzIHNvZnQgbGluZSBicmVha3MgaW1wb3NzaWJsZS5cbiAqXG4gKiBIYXJkIGJyZWFrcyBhcmUgc2ltdWxhdGVkIGJ5IGNyZWF0aW5nIGEgPG10YWJsZT4gYW5kIHB1dHRpbmcgZWFjaCBsaW5lIGluIGl0cyBvd24gPG10cj4uXG4gKlxuICogVG8gY3JlYXRlIHNvZnQgbGluZSBicmVha3MsIFRlbW1sIGF2b2lkcyB1c2luZyB0aGUgPHNlbWFudGljcz4gYW5kIDxhbm5vdGF0aW9uPiB0YWdzLlxuICogVGhlbiB0aGUgdG9wIGxldmVsIG9mIGEgPG1hdGg+IGVsZW1lbnQgY2FuIGJlIG9jY3VwaWVkIGJ5IDxtcm93PiBlbGVtZW50cywgYW5kIHRoZSBicm93c2VyXG4gKiB3aWxsIGJyZWFrIGFmdGVyIGEgPG1yb3c+IGlmIHRoZSBleHByZXNzaW9uIGV4dGVuZHMgYmV5b25kIHRoZSBjb250YWluZXIgbGltaXQuXG4gKlxuICogVGhlIGRlZmF1bHQgaXMgZm9yIHNvZnQgbGluZSBicmVha3MgYWZ0ZXIgZWFjaCB0b3AtbGV2ZWwgYmluYXJ5IG9yXG4gKiByZWxhdGlvbmFsIG9wZXJhdG9yLCBwZXIgVGVYYm9vayBwLiAxNzMuIFNvIHdlIGdhdGhlciB0aGUgZXhwcmVzc2lvbiBpbnRvIDxtcm93PnMgc28gdGhhdFxuICogZWFjaCA8bXJvdz4gZW5kcyBpbiBhIGJpbmFyeSBvciByZWxhdGlvbmFsIG9wZXJhdG9yLlxuICpcbiAqIEFuIG9wdGlvbiBpcyBmb3Igc29mdCBsaW5lIGJyZWFrcyBiZWZvcmUgYW4gXCI9XCIgc2lnbi4gVGhhdCBjaGFuZ2VzIHRoZSA8bXJvdz5zLlxuICpcbiAqIFNvZnQgbGluZSBicmVha3Mgd2lsbCBub3Qgd29yayBpbiBDaHJvbWl1bSBhbmQgU2FmYXJpLCBvbmx5IEZpcmVmb3guXG4gKlxuICogSG9wZWZ1bGx5IGJyb3dzZXJzIHdpbGwgc29tZWRheSBkbyB0aGVpciBvd24gbGluZWJyZWFraW5nIGFuZCB3ZSB3aWxsIGJlIGFibGUgdG8gZGVsZXRlXG4gKiBtdWNoIG9mIHRoaXMgbW9kdWxlLlxuICovXG5cbmNvbnN0IG9wZW5EZWxpbXMgPSBcIihbe+KMiuKMiOKfqOKfruKOsOKfpuKmg1wiO1xuY29uc3QgY2xvc2VEZWxpbXMgPSBcIildfeKMi+KMieKfqeKfr+KOseKfpuKmhFwiO1xuXG5mdW5jdGlvbiBzZXRMaW5lQnJlYWtzKGV4cHJlc3Npb24sIHdyYXBNb2RlLCBpc0Rpc3BsYXlNb2RlKSB7XG4gIGNvbnN0IG10cnMgPSBbXTtcbiAgbGV0IG1yb3dzID0gW107XG4gIGxldCBibG9jayA9IFtdO1xuICBsZXQgbnVtVG9wTGV2ZWxFcXVhbHMgPSAwO1xuICBsZXQgaSA9IDA7XG4gIGxldCBsZXZlbCA9IDA7XG4gIHdoaWxlIChpIDwgZXhwcmVzc2lvbi5sZW5ndGgpIHtcbiAgICB3aGlsZSAoZXhwcmVzc2lvbltpXSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgIGV4cHJlc3Npb24uc3BsaWNlKGksIDEsIC4uLmV4cHJlc3Npb25baV0uY2hpbGRyZW4pOyAvLyBFeHBhbmQgdGhlIGZyYWdtZW50LlxuICAgIH1cbiAgICBjb25zdCBub2RlID0gZXhwcmVzc2lvbltpXTtcbiAgICBpZiAobm9kZS5hdHRyaWJ1dGVzICYmIG5vZGUuYXR0cmlidXRlcy5saW5lYnJlYWsgJiZcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5saW5lYnJlYWsgPT09IFwibmV3bGluZVwiKSB7XG4gICAgICAvLyBBIGhhcmQgbGluZSBicmVhay4gQ3JlYXRlIGEgPG10cj4gZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAgaWYgKGJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbXJvd3MucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYmxvY2spKTtcbiAgICAgIH1cbiAgICAgIG1yb3dzLnB1c2gobm9kZSk7XG4gICAgICBibG9jayA9IFtdO1xuICAgICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgbXJvd3MpO1xuICAgICAgbXRkLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgbXRycy5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFttdGRdKSk7XG4gICAgICBtcm93cyA9IFtdO1xuICAgICAgaSArPSAxO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgYmxvY2sucHVzaChub2RlKTtcbiAgICBpZiAobm9kZS50eXBlICYmIG5vZGUudHlwZSA9PT0gXCJtb1wiICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZS5hdHRyaWJ1dGVzLCBcIm1vdmFibGVsaW1pdHNcIikpIHtcbiAgICAgIGNvbnN0IGNoID0gbm9kZS5jaGlsZHJlblswXS50ZXh0O1xuICAgICAgaWYgKG9wZW5EZWxpbXMuaW5kZXhPZihjaCkgPiAtMSkge1xuICAgICAgICBsZXZlbCArPSAxO1xuICAgICAgfSBlbHNlIGlmIChjbG9zZURlbGltcy5pbmRleE9mKGNoKSA+IC0xKSB7XG4gICAgICAgIGxldmVsIC09IDE7XG4gICAgICB9IGVsc2UgaWYgKGxldmVsID09PSAwICYmIHdyYXBNb2RlID09PSBcIj1cIiAmJiBjaCA9PT0gXCI9XCIpIHtcbiAgICAgICAgbnVtVG9wTGV2ZWxFcXVhbHMgKz0gMTtcbiAgICAgICAgaWYgKG51bVRvcExldmVsRXF1YWxzID4gMSkge1xuICAgICAgICAgIGJsb2NrLnBvcCgpO1xuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGJsb2NrLiAoSW5zZXJ0IGEgc29mdCBsaW5lYnJlYWsuKVxuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYmxvY2spO1xuICAgICAgICAgIG1yb3dzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgYmxvY2sgPSBbbm9kZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGV2ZWwgPT09IDAgJiYgd3JhcE1vZGUgPT09IFwidGV4XCIgJiYgY2ggIT09IFwi4oiHXCIpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZvbGxvd2luZyBub2RlIGlzIGEgXFxub2JyZWFrIHRleHQgbm9kZSwgZS5nLiBcIn5cIlwiXG4gICAgICAgIGNvbnN0IG5leHQgPSBpIDwgZXhwcmVzc2lvbi5sZW5ndGggLSAxID8gZXhwcmVzc2lvbltpICsgMV0gOiBudWxsO1xuICAgICAgICBsZXQgZ2x1ZUlzRnJlZU9mTm9icmVhayA9IHRydWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKFxuICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgbmV4dC50eXBlID09PSBcIm10ZXh0XCIgJiZcbiAgICAgICAgICAgIG5leHQuYXR0cmlidXRlcy5saW5lYnJlYWsgJiZcbiAgICAgICAgICAgIG5leHQuYXR0cmlidXRlcy5saW5lYnJlYWsgPT09IFwibm9icmVha1wiXG4gICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBXZSBtYXkgbmVlZCB0byBzdGFydCBhIG5ldyBibG9jay5cbiAgICAgICAgICAvLyBGaXJzdCwgcHV0IGFueSBwb3N0LW9wZXJhdG9yIGdsdWUgb24gc2FtZSBsaW5lIGFzIG9wZXJhdG9yLlxuICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGV4cHJlc3Npb24ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5kID0gZXhwcmVzc2lvbltqXTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbmQudHlwZSAmJlxuICAgICAgICAgICAgICBuZC50eXBlID09PSBcIm1zcGFjZVwiICYmXG4gICAgICAgICAgICAgICEobmQuYXR0cmlidXRlcy5saW5lYnJlYWsgJiYgbmQuYXR0cmlidXRlcy5saW5lYnJlYWsgPT09IFwibmV3bGluZVwiKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGJsb2NrLnB1c2gobmQpO1xuICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBuZC5hdHRyaWJ1dGVzICYmXG4gICAgICAgICAgICAgICAgbmQuYXR0cmlidXRlcy5saW5lYnJlYWsgJiZcbiAgICAgICAgICAgICAgICBuZC5hdHRyaWJ1dGVzLmxpbmVicmVhayA9PT0gXCJub2JyZWFrXCJcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2x1ZUlzRnJlZU9mTm9icmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsdWVJc0ZyZWVPZk5vYnJlYWspIHtcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBibG9jay4gKEluc2VydCBhIHNvZnQgbGluZWJyZWFrLilcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJsb2NrKTtcbiAgICAgICAgICBtcm93cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGJsb2NrID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSArPSAxO1xuICB9XG4gIGlmIChibG9jay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBibG9jayk7XG4gICAgbXJvd3MucHVzaChlbGVtZW50KTtcbiAgfVxuICBpZiAobXRycy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgbXJvd3MpO1xuICAgIG10ZC5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICBjb25zdCBtdHIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbbXRkXSk7XG4gICAgbXRycy5wdXNoKG10cik7XG4gICAgY29uc3QgbXRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgbXRycyk7XG4gICAgaWYgKCFpc0Rpc3BsYXlNb2RlKSB7XG4gICAgICBtdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uYWxpZ25cIiwgXCJsZWZ0XCIpO1xuICAgICAgbXRhYmxlLnNldEF0dHJpYnV0ZShcInJvd3NwYWNpbmdcIiwgXCIwZW1cIik7XG4gICAgfVxuICAgIHJldHVybiBtdGFibGVcbiAgfVxuICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KG1yb3dzKTtcbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udmVydHMgYSBwYXJzZSB0cmVlIGludG8gYSBjb3JyZXNwb25kaW5nIE1hdGhNTCB0cmVlLiBUaGUgbWFpblxuICogZW50cnkgcG9pbnQgaXMgdGhlIGBidWlsZE1hdGhNTGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcGFyc2UgdHJlZSBmcm9tIHRoZVxuICogcGFyc2VyLlxuICovXG5cblxuLyoqXG4gKiBUYWtlcyBhIHN5bWJvbCBhbmQgY29udmVydHMgaXQgaW50byBhIE1hdGhNTCB0ZXh0IG5vZGUgYWZ0ZXIgcGVyZm9ybWluZ1xuICogb3B0aW9uYWwgcmVwbGFjZW1lbnQgZnJvbSBzeW1ib2xzLmpzLlxuICovXG5jb25zdCBtYWtlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG1vZGUsIHN0eWxlKSB7XG4gIGlmIChcbiAgICBzeW1ib2xzW21vZGVdW3RleHRdICYmXG4gICAgc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlICYmXG4gICAgdGV4dC5jaGFyQ29kZUF0KDApICE9PSAweGQ4MzUgJiZcbiAgICAhKFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxpZ2F0dXJlcywgdGV4dCkgJiZcbiAgICAgIHN0eWxlICYmXG4gICAgICAoKHN0eWxlLmZvbnRGYW1pbHkgJiYgc3R5bGUuZm9udEZhbWlseS5zbGljZSg0LCA2KSA9PT0gXCJ0dFwiKSB8fFxuICAgICAgICAoc3R5bGUuZm9udCAmJiBzdHlsZS5mb250LnNsaWNlKDQsIDYpID09PSBcInR0XCIpKVxuICAgIClcbiAgKSB7XG4gICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh0ZXh0KTtcbn07XG5cbmNvbnN0IGNvcHlDaGFyID0gKG5ld1JvdywgY2hpbGQpID0+IHtcbiAgaWYgKG5ld1Jvdy5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHxcbiAgICAgIG5ld1Jvdy5jaGlsZHJlbltuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJtdGV4dFwiKSB7XG4gICAgY29uc3QgbXRleHQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgIFwibXRleHRcIixcbiAgICAgIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShjaGlsZC5jaGlsZHJlblswXS50ZXh0KV1cbiAgICApO1xuICAgIG5ld1Jvdy5jaGlsZHJlbi5wdXNoKG10ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBuZXdSb3cuY2hpbGRyZW5bbmV3Um93LmNoaWxkcmVuLmxlbmd0aCAtIDFdLmNoaWxkcmVuWzBdLnRleHQgKz0gY2hpbGQuY2hpbGRyZW5bMF0udGV4dDtcbiAgfVxufTtcblxuY29uc3QgY29uc29saWRhdGVUZXh0ID0gbXJvdyA9PiB7XG4gIC8vIElmIHBvc3NpYmxlLCBjb25zb2xpZGF0ZSBhZGphY2VudCA8bXRleHQ+IGVsZW1lbnRzIGludG8gYSBzaW5nbGUgZWxlbWVudC5cbiAgaWYgKG1yb3cudHlwZSAhPT0gXCJtcm93XCIgJiYgbXJvdy50eXBlICE9PSBcIm1zdHlsZVwiKSB7IHJldHVybiBtcm93IH1cbiAgaWYgKG1yb3cuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7IHJldHVybiBtcm93IH0gLy8gZW1wdHkgZ3JvdXAsIGUuZy4sIFxcdGV4dHt9XG4gIGNvbnN0IG5ld1JvdyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtcm93LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGQgPSBtcm93LmNoaWxkcmVuW2ldO1xuICAgIGlmIChjaGlsZC50eXBlID09PSBcIm10ZXh0XCIgJiYgT2JqZWN0LmtleXMoY2hpbGQuYXR0cmlidXRlcykubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb3B5Q2hhcihuZXdSb3csIGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKGNoaWxkLnR5cGUgPT09IFwibXJvd1wiKSB7XG4gICAgICAvLyBXZSdsbCBhbHNvIGNoZWNrIHRoZSBjaGlsZHJlbiBvZiBhbiBtcm93LiBPbmUgbGV2ZWwgb25seS4gTm8gcmVjdXJzaW9uLlxuICAgICAgbGV0IGNhbkNvbnNvbGlkYXRlID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3QgZ3JhbmRDaGlsZCA9IGNoaWxkLmNoaWxkcmVuW2pdO1xuICAgICAgICBpZiAoZ3JhbmRDaGlsZC50eXBlICE9PSBcIm10ZXh0XCIgfHwgT2JqZWN0LmtleXMoY2hpbGQuYXR0cmlidXRlcykubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY2FuQ29uc29saWRhdGUgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FuQ29uc29saWRhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IGdyYW5kQ2hpbGQgPSBjaGlsZC5jaGlsZHJlbltqXTtcbiAgICAgICAgICBjb3B5Q2hhcihuZXdSb3csIGdyYW5kQ2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdSb3cuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Jvdy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmV3Um93LmNoaWxkcmVuW2ldLnR5cGUgPT09IFwibXRleHRcIikge1xuICAgICAgY29uc3QgbXRleHQgPSBuZXdSb3cuY2hpbGRyZW5baV07XG4gICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlbmRlciBhIHNwYWNlIGF0IGVpdGhlciBlbmQgb2YgYW4gPG10ZXh0PiBzdHJpbmcuXG4gICAgICAvLyBUbyBnZXQgcHJvcGVyIHJlbmRlcmluZywgd2UgcmVwbGFjZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHNwYWNlcyB3aXRoIG5vLWJyZWFrIHNwYWNlcy5cbiAgICAgIGlmIChtdGV4dC5jaGlsZHJlblswXS50ZXh0LmNoYXJBdCgwKSA9PT0gXCIgXCIpIHtcbiAgICAgICAgbXRleHQuY2hpbGRyZW5bMF0udGV4dCA9IFwiXFx1MDBhMFwiICsgbXRleHQuY2hpbGRyZW5bMF0udGV4dC5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEwgPSBtdGV4dC5jaGlsZHJlblswXS50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChMID4gMCAmJiBtdGV4dC5jaGlsZHJlblswXS50ZXh0LmNoYXJBdChMIC0gMSkgPT09IFwiIFwiKSB7XG4gICAgICAgIG10ZXh0LmNoaWxkcmVuWzBdLnRleHQgPSBtdGV4dC5jaGlsZHJlblswXS50ZXh0LnNsaWNlKDAsIC0xKSArIFwiXFx1MDBhMFwiO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobXJvdy5hdHRyaWJ1dGVzKSkge1xuICAgICAgICBtdGV4dC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5ld1Jvdy5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbmV3Um93LmNoaWxkcmVuWzBdLnR5cGUgPT09IFwibXRleHRcIikge1xuICAgIHJldHVybiBuZXdSb3cuY2hpbGRyZW5bMF07IC8vIEEgY29uc29saWRhdGVkIDxtdGV4dD5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3Um93XG4gIH1cbn07XG5cbi8qKlxuICogV3JhcCB0aGUgZ2l2ZW4gYXJyYXkgb2Ygbm9kZXMgaW4gYW4gPG1yb3c+IG5vZGUgaWYgbmVlZGVkLCBpLmUuLFxuICogdW5sZXNzIHRoZSBhcnJheSBoYXMgbGVuZ3RoIDEuICBBbHdheXMgcmV0dXJucyBhIHNpbmdsZSBub2RlLlxuICovXG5jb25zdCBtYWtlUm93ID0gZnVuY3Rpb24oYm9keSwgc2VtaXNpbXBsZSA9IGZhbHNlKSB7XG4gIGlmIChib2R5Lmxlbmd0aCA9PT0gMSAmJiAhKGJvZHlbMF0gaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSkge1xuICAgIHJldHVybiBib2R5WzBdO1xuICB9IGVsc2UgaWYgKCFzZW1pc2ltcGxlKSB7XG4gICAgLy8gU3VwcHJlc3Mgc3BhY2luZyBvbiA8bW8+IG5vZGVzIGF0IGJvdGggZW5kcyBvZiB0aGUgcm93LlxuICAgIGlmIChib2R5WzBdIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgYm9keVswXS50eXBlID09PSBcIm1vXCIgJiYgIWJvZHlbMF0uYXR0cmlidXRlcy5mZW5jZSkge1xuICAgICAgYm9keVswXS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBib2R5WzBdLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICB9XG4gICAgY29uc3QgZW5kID0gYm9keS5sZW5ndGggLSAxO1xuICAgIGlmIChib2R5W2VuZF0gaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBib2R5W2VuZF0udHlwZSA9PT0gXCJtb1wiICYmICFib2R5W2VuZF0uYXR0cmlidXRlcy5mZW5jZSkge1xuICAgICAgYm9keVtlbmRdLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgIGJvZHlbZW5kXS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMGVtXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYm9keSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGZvciA8bWk+LjwvbWk+IHdoaWNoIGlzIGhvdyBhIGRvdCByZW5kZXJzIGluIE1hdGhNTCxcbiAqIG9yIDxtbyBzZXBhcmF0b3I9XCJ0cnVlXCIgbHNwYWNlPVwiMGVtXCIgcnNwYWNlPVwiMGVtXCI+LDwvbW8+XG4gKiB3aGljaCBpcyBob3cgYSBicmFjZWQgY29tbWEgeyx9IHJlbmRlcnMgaW4gTWF0aE1MXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyUHVuY3R1YXRpb24oZ3JvdXApIHtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChncm91cC50eXBlID09PSAnbWknICYmIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJy4nXG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJtdGV4dFwiICYmIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJ1xcdTIwMDgnIC8vIHB1bmN0dWF0aW9uIHNwYWNlXG4gIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gJ21vJyAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICBncm91cC5nZXRBdHRyaWJ1dGUoJ3NlcGFyYXRvcicpID09PSAndHJ1ZScgJiZcbiAgICBncm91cC5nZXRBdHRyaWJ1dGUoJ2xzcGFjZScpID09PSAnMGVtJyAmJlxuICAgIGdyb3VwLmdldEF0dHJpYnV0ZSgncnNwYWNlJykgPT09ICcwZW0nKSB7XG4gICAgY29uc3QgY2hpbGQgPSBncm91cC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBjaGlsZC50ZXh0ID09PSAnLCdcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuY29uc3QgaXNDb21tYSA9IChleHByZXNzaW9uLCBpKSA9PiB7XG4gIGNvbnN0IG5vZGUgPSBleHByZXNzaW9uW2ldO1xuICBjb25zdCBmb2xsb3dpbmdOb2RlID0gZXhwcmVzc2lvbltpICsgMV07XG4gIHJldHVybiAobm9kZS50eXBlID09PSBcImF0b21cIiAmJiBub2RlLnRleHQgPT09IFwiLFwiKSAmJlxuICAgIC8vIERvbid0IGNvbnNvbGlkYXRlIGlmIHRoZXJlIGlzIGEgc3BhY2UgYWZ0ZXIgdGhlIGNvbW1hLlxuICAgIG5vZGUubG9jICYmIGZvbGxvd2luZ05vZGUubG9jICYmIG5vZGUubG9jLmVuZCA9PT0gZm9sbG93aW5nTm9kZS5sb2Muc3RhcnRcbn07XG5cbmNvbnN0IGlzUmVsID0gaXRlbSA9PiB7XG4gIHJldHVybiAoaXRlbS50eXBlID09PSBcImF0b21cIiAmJiBpdGVtLmZhbWlseSA9PT0gXCJyZWxcIikgfHxcbiAgICAgIChpdGVtLnR5cGUgPT09IFwibWNsYXNzXCIgJiYgaXRlbS5tY2xhc3MgPT09IFwibXJlbFwiKVxufTtcblxuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2Ygbm9kZXMsIGJ1aWxkcyB0aGVtLCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgdGhlIGdlbmVyYXRlZFxuICogTWF0aE1MIG5vZGVzLiAgQWxzbyBkbyBhIGNvdXBsZSBjaG9yZXMgYWxvbmcgdGhlIHdheTpcbiAqICgxKSBTdXBwcmVzcyBzcGFjaW5nIHdoZW4gYW4gYXV0aG9yIHdyYXBzIGFuIG9wZXJhdG9yIHcvYnJhY2VzLCBhcyBpbiB7PX0uXG4gKiAoMikgU3VwcHJlc3Mgc3BhY2luZyBiZXR3ZWVuIHR3byBhZGphY2VudCByZWxhdGlvbnMuXG4gKi9cbmNvbnN0IGJ1aWxkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHN0eWxlLCBzZW1pc2ltcGxlID0gZmFsc2UpIHtcbiAgaWYgKCFzZW1pc2ltcGxlICYmIGV4cHJlc3Npb24ubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBidWlsZEdyb3VwJDEoZXhwcmVzc2lvblswXSwgc3R5bGUpO1xuICAgIGlmIChncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGdyb3VwLnR5cGUgPT09IFwibW9cIikge1xuICAgICAgLy8gV2hlbiBUZVggd3JpdGVycyB3YW50IHRvIHN1cHByZXNzIHNwYWNpbmcgb24gYW4gb3BlcmF0b3IsXG4gICAgICAvLyB0aGV5IG9mdGVuIHB1dCB0aGUgb3BlcmF0b3IgYnkgaXRzZWxmIGluc2lkZSBicmFjZXMuXG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuICAgIHJldHVybiBbZ3JvdXBdO1xuICB9XG5cbiAgY29uc3QgZ3JvdXBzID0gW107XG4gIGNvbnN0IGdyb3VwQXJyYXkgPSBbXTtcbiAgbGV0IGxhc3RHcm91cDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgZ3JvdXBBcnJheS5wdXNoKGJ1aWxkR3JvdXAkMShleHByZXNzaW9uW2ldLCBzdHlsZSkpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZ3JvdXAgPSBncm91cEFycmF5W2ldO1xuXG4gICAgLy8gU3VwcHJlc3Mgc3BhY2luZyBiZXR3ZWVuIGFkamFjZW50IHJlbGF0aW9uc1xuICAgIGlmIChpIDwgZXhwcmVzc2lvbi5sZW5ndGggLSAxICYmIGlzUmVsKGV4cHJlc3Npb25baV0pICYmIGlzUmVsKGV4cHJlc3Npb25baSArIDFdKSkge1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMGVtXCIpO1xuICAgIH1cbiAgICBpZiAoaSA+IDAgJiYgaXNSZWwoZXhwcmVzc2lvbltpXSkgJiYgaXNSZWwoZXhwcmVzc2lvbltpIC0gMV0pKSB7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuXG4gICAgLy8gQ29uY2F0ZW5hdGUgbnVtYmVyc1xuICAgIGlmIChncm91cC50eXBlID09PSAnbW4nICYmIGxhc3RHcm91cCAmJiBsYXN0R3JvdXAudHlwZSA9PT0gJ21uJykge1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgPG1uPi4uLjwvbW4+IGZvbGxvd2VkIGJ5IDxtaT4uPC9taT5cbiAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLmdyb3VwLmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChpc051bWJlclB1bmN0dWF0aW9uKGdyb3VwKSAmJiBsYXN0R3JvdXAgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgIC8vIENvbmNhdGVuYXRlIDxtbj4uLi48L21uPiBmb2xsb3dlZCBieSA8bWk+LjwvbWk+XG4gICAgICBsYXN0R3JvdXAuY2hpbGRyZW4ucHVzaCguLi5ncm91cC5jaGlsZHJlbik7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAobGFzdEdyb3VwICYmIGxhc3RHcm91cC50eXBlID09PSBcIm1uXCIgJiYgaSA8IGdyb3VwQXJyYXkubGVuZ3RoIC0gMSAmJlxuICAgICAgZ3JvdXBBcnJheVtpICsgMV0udHlwZSA9PT0gXCJtblwiICYmIGlzQ29tbWEoZXhwcmVzc2lvbiwgaSkpIHtcbiAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLmdyb3VwLmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSAnbW4nICYmIGlzTnVtYmVyUHVuY3R1YXRpb24obGFzdEdyb3VwKSkge1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgPG1pPi48L21pPiBmb2xsb3dlZCBieSA8bW4+Li4uPC9tbj5cbiAgICAgIGdyb3VwLmNoaWxkcmVuID0gWy4uLmxhc3RHcm91cC5jaGlsZHJlbiwgLi4uZ3JvdXAuY2hpbGRyZW5dO1xuICAgICAgZ3JvdXBzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoKGdyb3VwLnR5cGUgPT09ICdtc3VwJyB8fCBncm91cC50eXBlID09PSAnbXN1YicpICYmXG4gICAgICAgIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA+PSAxICYmIGxhc3RHcm91cCAmJlxuICAgICAgICAobGFzdEdyb3VwLnR5cGUgPT09ICdtbicgfHwgaXNOdW1iZXJQdW5jdHVhdGlvbihsYXN0R3JvdXApKSkge1xuICAgICAgLy8gUHV0IHByZWNlZGluZyA8bW4+Li4uPC9tbj4gb3IgPG1pPi48L21pPiBpbnNpZGUgYmFzZSBvZlxuICAgICAgLy8gPG1zdXA+PG1uPi4uLmJhc2UuLi48L21uPi4uLmV4cG9uZW50Li4uPC9tc3VwPiAob3IgPG1zdWI+KVxuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBiYXNlLnR5cGUgPT09ICdtbicgJiYgbGFzdEdyb3VwKSB7XG4gICAgICAgIGJhc2UuY2hpbGRyZW4gPSBbLi4ubGFzdEdyb3VwLmNoaWxkcmVuLCAuLi5iYXNlLmNoaWxkcmVuXTtcbiAgICAgICAgZ3JvdXBzLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgbGFzdEdyb3VwID0gZ3JvdXA7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwc1xufTtcblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIGJ1aWxkRXhwcmVzc2lvbiwgYnV0IHdyYXBzIHRoZSBlbGVtZW50cyBpbiBhbiA8bXJvdz5cbiAqIGlmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZS4gIFJldHVybnMgYSBzaW5nbGUgbm9kZSBpbnN0ZWFkIG9mIGFuIGFycmF5LlxuICovXG5jb25zdCBidWlsZEV4cHJlc3Npb25Sb3cgPSBmdW5jdGlvbihleHByZXNzaW9uLCBzdHlsZSwgc2VtaXNpbXBsZSA9IGZhbHNlKSB7XG4gIHJldHVybiBtYWtlUm93KGJ1aWxkRXhwcmVzc2lvbihleHByZXNzaW9uLCBzdHlsZSwgc2VtaXNpbXBsZSksIHNlbWlzaW1wbGUpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGdyb3VwIGZyb20gdGhlIHBhcnNlciBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAqIG9uIGl0IHRvIHByb2R1Y2UgYSBNYXRoTUwgbm9kZS5cbiAqL1xuY29uc3QgYnVpbGRHcm91cCQxID0gZnVuY3Rpb24oZ3JvdXAsIHN0eWxlKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG5cbiAgaWYgKF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7XG4gICAgLy8gQ2FsbCB0aGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICAgIGNvbnN0IHJlc3VsdCA9IF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKGdyb3VwLCBzdHlsZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkdvdCBncm91cCBvZiB1bmtub3duIHR5cGU6ICdcIiArIGdyb3VwLnR5cGUgKyBcIidcIik7XG4gIH1cbn07XG5cbmNvbnN0IGdsdWUkMSA9IF8gPT4ge1xuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10sIFtdLCB7IHBhZGRpbmc6IFwiMFwiLCB3aWR0aDogXCI1MCVcIiB9KVxufTtcblxuY29uc3QgbGFiZWxDb250YWluZXJzID0gW1wibXJvd1wiLCBcIm10ZFwiLCBcIm10YWJsZVwiLCBcIm10clwiXTtcbmNvbnN0IGdldExhYmVsID0gcGFyZW50ID0+IHtcbiAgZm9yIChjb25zdCBub2RlIG9mIHBhcmVudC5jaGlsZHJlbikge1xuICAgIGlmIChub2RlLnR5cGUgJiYgbGFiZWxDb250YWluZXJzLmluY2x1ZGVzKG5vZGUudHlwZSkpIHtcbiAgICAgIGlmIChub2RlLmNsYXNzZXMgJiYgbm9kZS5jbGFzc2VzWzBdID09PSBcInRtbC1sYWJlbFwiKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gbm9kZS5sYWJlbDtcbiAgICAgICAgcmV0dXJuIGxhYmVsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGdldExhYmVsKG5vZGUpO1xuICAgICAgICBpZiAobGFiZWwpIHsgcmV0dXJuIGxhYmVsIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFub2RlLnR5cGUpIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZ2V0TGFiZWwobm9kZSk7XG4gICAgICBpZiAobGFiZWwpIHsgcmV0dXJuIGxhYmVsIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHRhZ2dlZEV4cHJlc3Npb24gPSAoZXhwcmVzc2lvbiwgdGFnLCBzdHlsZSwgbGVxbm8pID0+IHtcbiAgdGFnID0gYnVpbGRFeHByZXNzaW9uUm93KHRhZ1swXS5ib2R5LCBzdHlsZSk7XG4gIHRhZyA9IGNvbnNvbGlkYXRlVGV4dCh0YWcpO1xuICB0YWcuY2xhc3Nlcy5wdXNoKFwidG1sLXRhZ1wiKTtcblxuICBjb25zdCBsYWJlbCA9IGdldExhYmVsKGV4cHJlc3Npb24pOyAvLyBmcm9tIGEgXFxsYWJlbHt9IGZ1bmN0aW9uLlxuICBleHByZXNzaW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2V4cHJlc3Npb25dKTtcbiAgY29uc3Qgcm93QXJyYXkgPSBbZ2x1ZSQxKCksIGV4cHJlc3Npb24sIGdsdWUkMSgpXTtcbiAgcm93QXJyYXlbbGVxbm8gPyAwIDogMl0uY2xhc3Nlcy5wdXNoKGxlcW5vID8gXCJ0bWwtbGVmdFwiIDogXCJ0bWwtcmlnaHRcIik7XG4gIHJvd0FycmF5W2xlcW5vID8gMCA6IDJdLmNoaWxkcmVuLnB1c2godGFnKTtcbiAgY29uc3QgbXRyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgcm93QXJyYXksIFtcInRtbC10YWdlcW5cIl0pO1xuICBpZiAobGFiZWwpIHsgbXRyLnNldEF0dHJpYnV0ZShcImlkXCIsIGxhYmVsKTsgfVxuICBjb25zdCB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFttdHJdKTtcbiAgdGFibGUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgdGFibGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHRhYmxlXG59O1xuXG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRNYXRoTUwodHJlZSwgdGV4RXhwcmVzc2lvbiwgc3R5bGUsIHNldHRpbmdzKSB7XG4gIC8vIFN0cmlwIG9mZiBvdXRlciB0YWcgd3JhcHBlciBmb3IgcHJvY2Vzc2luZyBiZWxvdy5cbiAgbGV0IHRhZyA9IG51bGw7XG4gIGlmICh0cmVlLmxlbmd0aCA9PT0gMSAmJiB0cmVlWzBdLnR5cGUgPT09IFwidGFnXCIpIHtcbiAgICB0YWcgPSB0cmVlWzBdLnRhZztcbiAgICB0cmVlID0gdHJlZVswXS5ib2R5O1xuICB9XG5cbiAgY29uc3QgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbih0cmVlLCBzdHlsZSk7XG5cbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxICYmIGV4cHJlc3Npb25bMF0gaW5zdGFuY2VvZiBBbmNob3JOb2RlKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25bMF1cbiAgfVxuXG4gIGNvbnN0IHdyYXAgPSAoc2V0dGluZ3MuZGlzcGxheU1vZGUgfHwgc2V0dGluZ3MuYW5ub3RhdGUpID8gXCJub25lXCIgOiBzZXR0aW5ncy53cmFwO1xuXG4gIGNvbnN0IG4xID0gZXhwcmVzc2lvbi5sZW5ndGggPT09IDAgPyBudWxsIDogZXhwcmVzc2lvblswXTtcbiAgbGV0IHdyYXBwZXIgPSBleHByZXNzaW9uLmxlbmd0aCA9PT0gMSAmJiB0YWcgPT09IG51bGwgJiYgKG4xIGluc3RhbmNlb2YgTWF0aE5vZGUpXG4gICAgICA/IGV4cHJlc3Npb25bMF1cbiAgICAgIDogc2V0TGluZUJyZWFrcyhleHByZXNzaW9uLCB3cmFwLCBzZXR0aW5ncy5kaXNwbGF5TW9kZSk7XG5cbiAgaWYgKHRhZykge1xuICAgIHdyYXBwZXIgPSB0YWdnZWRFeHByZXNzaW9uKHdyYXBwZXIsIHRhZywgc3R5bGUsIHNldHRpbmdzLmxlcW5vKTtcbiAgfVxuXG4gIGlmIChzZXR0aW5ncy5hbm5vdGF0ZSkge1xuICAgIC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuICAgIGNvbnN0IGFubm90YXRpb24gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgIFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcbiAgICBhbm5vdGF0aW9uLnNldEF0dHJpYnV0ZShcImVuY29kaW5nXCIsIFwiYXBwbGljYXRpb24veC10ZXhcIik7XG4gICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwic2VtYW50aWNzXCIsIFt3cmFwcGVyLCBhbm5vdGF0aW9uXSk7XG4gIH1cblxuICBjb25zdCBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFt3cmFwcGVyXSk7XG5cbiAgaWYgKHNldHRpbmdzLnhtbCkge1xuICAgIG1hdGguc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIpO1xuICB9XG4gIGlmICh3cmFwcGVyLnN0eWxlLndpZHRoKSB7XG4gICAgbWF0aC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICB9XG4gIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgIG1hdGguc2V0QXR0cmlidXRlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgIG1hdGguc3R5bGUuZGlzcGxheSA9IFwiYmxvY2sgbWF0aFwiOyAvLyBuZWNlc3NhcnkgaW4gQ2hyb21pdW0uXG4gICAgLy8gRmlyZWZveCBhbmQgU2FmYXJpIGRvIG5vdCByZWNvZ25pemUgZGlzcGxheTogXCJibG9jayBtYXRoXCIuXG4gICAgLy8gU2V0IGEgY2xhc3Mgc28gdGhhdCB0aGUgQ1NTIGZpbGUgY2FuIHNldCBkaXNwbGF5OiBibG9jay5cbiAgICBtYXRoLmNsYXNzZXMgPSBbXCJ0bWwtZGlzcGxheVwiXTtcbiAgfVxuICByZXR1cm4gbWF0aDtcbn1cblxuY29uc3Qgc21hbGxzID0gXCJhY2VnxLHIt21ub3BxcnN1dnd4eXrOsc6zzrXOt865zrrOvM69zr/PgM+Bz4LPg8+Ez4XPh8+Jz5XwnZCa8J2QnPCdkJ7wnZCg8J2QpvCdkKfwnZCo8J2QqfCdkKrwnZCr8J2QrPCdkK7wnZCv8J2QsPCdkLHwnZCy8J2Qs1wiO1xuY29uc3QgdGFsbHMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYmRmaGtsdM6RzpLOk86UzpXOls6XzpjOmc6azpvOnM6dzp7On86gzqHOo86kzqXOps6nzqjOqc6yzrTOu862z4bOuM+IXCJcbiAgICAgICAgICAgICArIFwi8J2QgPCdkIHwnZCC8J2Qg/CdkITwnZCF8J2QhvCdkIfwnZCI8J2QifCdkIrwnZCL8J2QjPCdkI3wnZCO8J2Qj/CdkJDwnZCR8J2QkvCdkJPwnZCU8J2QlfCdkJbwnZCX8J2QmPCdkJnwnZCb8J2QnfCdkJ/wnZCh8J2QpPCdkKXwnZCtXCI7XG5jb25zdCBsb25nU21hbGxzID0gbmV3IFNldChbXCJcXFxcYWxwaGFcIiwgXCJcXFxcZ2FtbWFcIiwgXCJcXFxcZGVsdGFcIiwgXCJcXFxcZXBzaWxvblwiLCBcIlxcXFxldGFcIiwgXCJcXFxcaW90YVwiLFxuICBcIlxcXFxrYXBwYVwiLCBcIlxcXFxtdVwiLCBcIlxcXFxudVwiLCBcIlxcXFxwaVwiLCBcIlxcXFxyaG9cIiwgXCJcXFxcc2lnbWFcIiwgXCJcXFxcdGF1XCIsIFwiXFxcXHVwc2lsb25cIiwgXCJcXFxcY2hpXCIsIFwiXFxcXHBzaVwiLFxuICBcIlxcXFxvbWVnYVwiLCBcIlxcXFxpbWF0aFwiLCBcIlxcXFxqbWF0aFwiXSk7XG5jb25zdCBsb25nVGFsbHMgPSBuZXcgU2V0KFtcIlxcXFxHYW1tYVwiLCBcIlxcXFxEZWx0YVwiLCBcIlxcXFxTaWdtYVwiLCBcIlxcXFxPbWVnYVwiLCBcIlxcXFxiZXRhXCIsIFwiXFxcXGRlbHRhXCIsXG4gIFwiXFxcXGxhbWJkYVwiLCBcIlxcXFx0aGV0YVwiLCBcIlxcXFxwc2lcIl0pO1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJGEgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGFjY2VudE5vZGUgPSBncm91cC5pc1N0cmV0Y2h5XG4gICAgPyBzdHJldGNoeS5hY2NlbnROb2RlKGdyb3VwKVxuICAgIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAubGFiZWwsIGdyb3VwLm1vZGUpXSk7XG5cbiAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFx2ZWNcIikge1xuICAgIGFjY2VudE5vZGUuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZSgwLjc1KSB0cmFuc2xhdGUoMTAlLCAzMCUpXCI7XG4gIH0gZWxzZSB7XG4gICAgYWNjZW50Tm9kZS5zdHlsZS5tYXRoU3R5bGUgPSBcIm5vcm1hbFwiO1xuICAgIGFjY2VudE5vZGUuc3R5bGUubWF0aERlcHRoID0gXCIwXCI7XG4gICAgaWYgKG5lZWRXZWJraXRTaGlmdC5oYXMoZ3JvdXAubGFiZWwpICYmICB1dGlscy5pc0NoYXJhY3RlckJveChncm91cC5iYXNlKSkge1xuICAgICAgbGV0IHNoaWZ0ID0gXCJcIjtcbiAgICAgIGNvbnN0IGNoID0gZ3JvdXAuYmFzZS50ZXh0O1xuICAgICAgaWYgKHNtYWxscy5pbmRleE9mKGNoKSA+IC0xIHx8IGxvbmdTbWFsbHMuaGFzKGNoKSkgeyBzaGlmdCA9IFwidG1sLXhzaGlmdFwiOyB9XG4gICAgICBpZiAodGFsbHMuaW5kZXhPZihjaCkgPiAtMSAgfHwgbG9uZ1RhbGxzLmhhcyhjaCkpICB7IHNoaWZ0ID0gXCJ0bWwtY2Fwc2hpZnRcIjsgfVxuICAgICAgaWYgKHNoaWZ0KSB7IGFjY2VudE5vZGUuY2xhc3Nlcy5wdXNoKHNoaWZ0KTsgfVxuICAgIH1cbiAgfVxuICBpZiAoIWdyb3VwLmlzU3RyZXRjaHkpIHtcbiAgICBhY2NlbnROb2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gIH1cblxuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoKGdyb3VwLmxhYmVsID09PSBcIlxcXFxjXCIgPyBcIm11bmRlclwiIDogXCJtb3ZlclwiKSxcbiAgICBbYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UsIHN0eWxlKSwgYWNjZW50Tm9kZV1cbiAgKTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IG5vblN0cmV0Y2h5QWNjZW50cyA9IG5ldyBTZXQoW1xuICBcIlxcXFxhY3V0ZVwiLFxuICBcIlxcXFxncmF2ZVwiLFxuICBcIlxcXFxkZG90XCIsXG4gIFwiXFxcXGRkZG90XCIsXG4gIFwiXFxcXGRkZGRvdFwiLFxuICBcIlxcXFx0aWxkZVwiLFxuICBcIlxcXFxiYXJcIixcbiAgXCJcXFxcYnJldmVcIixcbiAgXCJcXFxcY2hlY2tcIixcbiAgXCJcXFxcaGF0XCIsXG4gIFwiXFxcXHZlY1wiLFxuICBcIlxcXFxkb3RcIixcbiAgXCJcXFxcbWF0aHJpbmdcIlxuXSk7XG5cbmNvbnN0IG5lZWRXZWJraXRTaGlmdCA9IG5ldyBTZXQoW1xuICBcIlxcXFxhY3V0ZVwiLFxuICBcIlxcXFxiYXJcIixcbiAgXCJcXFxcYnJldmVcIixcbiAgXCJcXFxcY2hlY2tcIixcbiAgXCJcXFxcZG90XCIsXG4gIFwiXFxcXGRkb3RcIixcbiAgXCJcXFxcZ3JhdmVcIixcbiAgXCJcXFxcaGF0XCIsXG4gIFwiXFxcXG1hdGhyaW5nXCIsXG4gIFwiXFxcXCdcIiwgXCJcXFxcXlwiLCBcIlxcXFx+XCIsIFwiXFxcXD1cIiwgXCJcXFxcdVwiLCBcIlxcXFwuXCIsICdcXFxcXCInLCBcIlxcXFxyXCIsIFwiXFxcXEhcIiwgXCJcXFxcdlwiXG5dKTtcblxuY29uc3QgY29tYmluaW5nQ2hhciA9IHtcbiAgXCJcXFxcYFwiOiBcIlxcdTAzMDBcIixcbiAgXCJcXFxcJ1wiOiBcIlxcdTAzMDFcIixcbiAgXCJcXFxcXlwiOiBcIlxcdTAzMDJcIixcbiAgXCJcXFxcflwiOiBcIlxcdTAzMDNcIixcbiAgXCJcXFxcPVwiOiBcIlxcdTAzMDRcIixcbiAgXCJcXFxcdVwiOiBcIlxcdTAzMDZcIixcbiAgXCJcXFxcLlwiOiBcIlxcdTAzMDdcIixcbiAgJ1xcXFxcIic6IFwiXFx1MDMwOFwiLFxuICBcIlxcXFxyXCI6IFwiXFx1MDMwQVwiLFxuICBcIlxcXFxIXCI6IFwiXFx1MDMwQlwiLFxuICBcIlxcXFx2XCI6IFwiXFx1MDMwQ1wiXG59O1xuXG4vLyBBY2NlbnRzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcYWN1dGVcIixcbiAgICBcIlxcXFxncmF2ZVwiLFxuICAgIFwiXFxcXGRkb3RcIixcbiAgICBcIlxcXFxkZGRvdFwiLFxuICAgIFwiXFxcXGRkZGRvdFwiLFxuICAgIFwiXFxcXHRpbGRlXCIsXG4gICAgXCJcXFxcYmFyXCIsXG4gICAgXCJcXFxcYnJldmVcIixcbiAgICBcIlxcXFxjaGVja1wiLFxuICAgIFwiXFxcXGhhdFwiLFxuICAgIFwiXFxcXHZlY1wiLFxuICAgIFwiXFxcXGRvdFwiLFxuICAgIFwiXFxcXG1hdGhyaW5nXCIsXG4gICAgXCJcXFxcb3ZlcnBhcmVuXCIsXG4gICAgXCJcXFxcd2lkZWNoZWNrXCIsXG4gICAgXCJcXFxcd2lkZWhhdFwiLFxuICAgIFwiXFxcXHdpZGVwYXJlblwiLFxuICAgIFwiXFxcXHdpZGV0aWxkZVwiLFxuICAgIFwiXFxcXG92ZXJyaWdodGFycm93XCIsXG4gICAgXCJcXFxcb3ZlcmxlZnRhcnJvd1wiLFxuICAgIFwiXFxcXE92ZXJyaWdodGFycm93XCIsXG4gICAgXCJcXFxcb3ZlcmxlZnRyaWdodGFycm93XCIsXG4gICAgXCJcXFxcb3Zlcmdyb3VwXCIsXG4gICAgXCJcXFxcb3ZlcmxlZnRoYXJwb29uXCIsXG4gICAgXCJcXFxcb3ZlcnJpZ2h0aGFycG9vblwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcblxuICAgIGNvbnN0IGlzU3RyZXRjaHkgPSAhbm9uU3RyZXRjaHlBY2NlbnRzLmhhcyhjb250ZXh0LmZ1bmNOYW1lKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBjb250ZXh0LmZ1bmNOYW1lLFxuICAgICAgaXNTdHJldGNoeTogaXNTdHJldGNoeSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJGFcbn0pO1xuXG4vLyBUZXh0LW1vZGUgYWNjZW50c1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFwiLFxuICBuYW1lczogW1wiXFxcXCdcIiwgXCJcXFxcYFwiLCBcIlxcXFxeXCIsIFwiXFxcXH5cIiwgXCJcXFxcPVwiLCBcIlxcXFxjXCIsIFwiXFxcXHVcIiwgXCJcXFxcLlwiLCAnXFxcXFwiJywgXCJcXFxcclwiLCBcIlxcXFxIXCIsIFwiXFxcXHZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcbiAgICBjb25zdCBtb2RlID0gY29udGV4dC5wYXJzZXIubW9kZTtcblxuICAgIGlmIChtb2RlID09PSBcIm1hdGhcIiAmJiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIC8vIExhVGVYIG9ubHkgd3JpdGVzIGEgd2FybmluZy4gSXQgZG9lc24ndCBzdG9wLiBXZSdsbCBpc3N1ZSB0aGUgc2FtZSB3YXJuaW5nLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKGBUZW1tbCBwYXJzZSBlcnJvcjogQ29tbWFuZCAke2NvbnRleHQuZnVuY05hbWV9IGlzIGludmFsaWQgaW4gbWF0aCBtb2RlLmApO1xuICAgIH1cblxuICAgIGlmIChtb2RlID09PSBcInRleHRcIiAmJiBiYXNlLnRleHQgJiYgYmFzZS50ZXh0Lmxlbmd0aCA9PT0gMVxuICAgICAgICAmJiBjb250ZXh0LmZ1bmNOYW1lIGluIGNvbWJpbmluZ0NoYXIgICYmIHNtYWxscy5pbmRleE9mKGJhc2UudGV4dCkgPiAtMSkge1xuICAgICAgLy8gUmV0dXJuIGEgY29tYmluaW5nIGFjY2VudCBjaGFyYWN0ZXJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogYmFzZS50ZXh0ICsgY29tYmluaW5nQ2hhcltjb250ZXh0LmZ1bmNOYW1lXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCdWlsZCB1cCB0aGUgYWNjZW50XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgICAgaXNTdHJldGNoeTogZmFsc2UsXG4gICAgICAgIGJhc2U6IGJhc2VcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkYVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJhY2NlbnRVbmRlclwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXHVuZGVybGVmdGFycm93XCIsXG4gICAgXCJcXFxcdW5kZXJyaWdodGFycm93XCIsXG4gICAgXCJcXFxcdW5kZXJsZWZ0cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHVuZGVyZ3JvdXBcIixcbiAgICBcIlxcXFx1bmRlcnBhcmVuXCIsXG4gICAgXCJcXFxcdXRpbGRlXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5LmFjY2VudE5vZGUoZ3JvdXApO1xuICAgIGFjY2VudE5vZGUuc3R5bGVbXCJtYXRoLWRlcHRoXCJdID0gMDtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW1xuICAgICAgYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UsIHN0eWxlKSxcbiAgICAgIGFjY2VudE5vZGVcbiAgICBdKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgY29udmVyc2lvbiBiZXR3ZWVuIHVuaXRzLiAgSW4gcGFydGljdWxhciwgaXQgcHJvdmlkZXNcbiAqIGNhbGN1bGF0ZVNpemUgdG8gY29udmVydCBvdGhlciB1bml0cyBpbnRvIENTUyB1bml0cy5cbiAqL1xuXG5cbmNvbnN0IHB0UGVyVW5pdCA9IHtcbiAgLy8gQ29udmVydCB0byBDU1MgKFBvc3RzY2lwdCkgcG9pbnRzLCBub3QgVGVYIHBvaW50c1xuICAvLyBodHRwczovL2VuLndpa2lib29rcy5vcmcvd2lraS9MYVRlWC9MZW5ndGhzIGFuZFxuICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzgyNjNcbiAgcHQ6IDgwMCAvIDgwMywgLy8gY29udmVydCBUZVggcG9pbnQgdG8gQ1NTIChQb3N0c2NyaXB0KSBwb2ludFxuICBwYzogKDEyICogODAwKSAvIDgwMywgLy8gcGljYVxuICBkZDogKCgxMjM4IC8gMTE1NykgKiA4MDApIC8gODAzLCAvLyBkaWRvdFxuICBjYzogKCgxNDg1NiAvIDExNTcpICogODAwKSAvIDgwMywgLy8gY2ljZXJvICgxMiBkaWRvdClcbiAgbmQ6ICgoNjg1IC8gNjQyKSAqIDgwMCkgLyA4MDMsIC8vIG5ldyBkaWRvdFxuICBuYzogKCgxMzcwIC8gMTA3KSAqIDgwMCkgLyA4MDMsIC8vIG5ldyBjaWNlcm8gKDEyIG5ldyBkaWRvdClcbiAgc3A6ICgoMSAvIDY1NTM2KSAqIDgwMCkgLyA4MDMsIC8vIHNjYWxlZCBwb2ludCAoVGVYJ3MgaW50ZXJuYWwgc21hbGxlc3QgdW5pdClcbiAgbW06ICgyNS40IC8gNzIpLFxuICBjbTogKDIuNTQgLyA3MiksXG4gIGluOiAoMSAvIDcyKSxcbiAgcHg6ICg5NiAvIDcyKVxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgc3BlY2lmaWVkIHVuaXQgKGVpdGhlciBhIHN0cmluZyBkZWZpbmluZyB0aGUgdW5pdFxuICogb3IgYSBcInNpemVcIiBwYXJzZSBub2RlIGNvbnRhaW5pbmcgYSB1bml0IGZpZWxkKSBpcyB2YWxpZC5cbiAqL1xuY29uc3QgdmFsaWRVbml0cyA9IFtcbiAgXCJlbVwiLFxuICBcImV4XCIsXG4gIFwibXVcIixcbiAgXCJwdFwiLFxuICBcIm1tXCIsXG4gIFwiY21cIixcbiAgXCJpblwiLFxuICBcInB4XCIsXG4gIFwiYnBcIixcbiAgXCJwY1wiLFxuICBcImRkXCIsXG4gIFwiY2NcIixcbiAgXCJuZFwiLFxuICBcIm5jXCIsXG4gIFwic3BcIlxuXTtcblxuY29uc3QgdmFsaWRVbml0ID0gZnVuY3Rpb24odW5pdCkge1xuICBpZiAodHlwZW9mIHVuaXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bml0ID0gdW5pdC51bml0O1xuICB9XG4gIHJldHVybiB2YWxpZFVuaXRzLmluZGV4T2YodW5pdCkgPiAtMVxufTtcblxuY29uc3QgZW1TY2FsZSA9IHN0eWxlTGV2ZWwgPT4ge1xuICBjb25zdCBzY3JpcHRMZXZlbCA9IE1hdGgubWF4KHN0eWxlTGV2ZWwgLSAxLCAwKTtcbiAgcmV0dXJuIFsxLCAwLjcsIDAuNV1bc2NyaXB0TGV2ZWxdXG59O1xuXG4vKlxuICogQ29udmVydCBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgKHdpdGggbnVtZXJpYyBcIm51bWJlclwiIGFuZCBzdHJpbmcgXCJ1bml0XCIgZmllbGRzLFxuICogYXMgcGFyc2VkIGJ5IGZ1bmN0aW9ucy5qcyBhcmdUeXBlIFwic2l6ZVwiKSBpbnRvIGEgQ1NTIHZhbHVlLlxuICovXG5jb25zdCBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24oc2l6ZVZhbHVlLCBzdHlsZSkge1xuICBsZXQgbnVtYmVyID0gc2l6ZVZhbHVlLm51bWJlcjtcbiAgaWYgKHN0eWxlLm1heFNpemVbMF0gPCAwICYmIG51bWJlciA+IDApIHtcbiAgICByZXR1cm4geyBudW1iZXI6IDAsIHVuaXQ6IFwiZW1cIiB9XG4gIH1cbiAgY29uc3QgdW5pdCA9IHNpemVWYWx1ZS51bml0O1xuICBzd2l0Y2ggKHVuaXQpIHtcbiAgICBjYXNlIFwibW1cIjpcbiAgICBjYXNlIFwiY21cIjpcbiAgICBjYXNlIFwiaW5cIjpcbiAgICBjYXNlIFwicHhcIjoge1xuICAgICAgY29uc3QgbnVtSW5Dc3NQdHMgPSBudW1iZXIgKiBwdFBlclVuaXRbdW5pdF07XG4gICAgICBpZiAobnVtSW5Dc3NQdHMgPiBzdHlsZS5tYXhTaXplWzFdKSB7XG4gICAgICAgIHJldHVybiB7IG51bWJlcjogc3R5bGUubWF4U2l6ZVsxXSwgdW5pdDogXCJwdFwiIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG51bWJlciwgdW5pdCB9OyAvLyBhYnNvbHV0ZSBDU1MgdW5pdHMuXG4gICAgfVxuICAgIGNhc2UgXCJlbVwiOlxuICAgIGNhc2UgXCJleFwiOiB7XG4gICAgICAvLyBJbiBUZVgsIGVtIGFuZCBleCBkbyBub3QgY2hhbmdlIHNpemUgaW4gXFxzY3JpcHRzdHlsZS5cbiAgICAgIGlmICh1bml0ID09PSBcImV4XCIpIHsgbnVtYmVyICo9IDAuNDMxOyB9XG4gICAgICBudW1iZXIgPSBNYXRoLm1pbihudW1iZXIgLyBlbVNjYWxlKHN0eWxlLmxldmVsKSwgc3R5bGUubWF4U2l6ZVswXSk7XG4gICAgICByZXR1cm4geyBudW1iZXI6IHV0aWxzLnJvdW5kKG51bWJlciksIHVuaXQ6IFwiZW1cIiB9O1xuICAgIH1cbiAgICBjYXNlIFwiYnBcIjoge1xuICAgICAgaWYgKG51bWJlciA+IHN0eWxlLm1heFNpemVbMV0pIHsgbnVtYmVyID0gc3R5bGUubWF4U2l6ZVsxXTsgfVxuICAgICAgcmV0dXJuIHsgbnVtYmVyLCB1bml0OiBcInB0XCIgfTsgLy8gVGVYIGJwIGlzIGEgQ1NTIHB0LiAoMS83MiBpbmNoKS5cbiAgICB9XG4gICAgY2FzZSBcInB0XCI6XG4gICAgY2FzZSBcInBjXCI6XG4gICAgY2FzZSBcImRkXCI6XG4gICAgY2FzZSBcImNjXCI6XG4gICAgY2FzZSBcIm5kXCI6XG4gICAgY2FzZSBcIm5jXCI6XG4gICAgY2FzZSBcInNwXCI6IHtcbiAgICAgIG51bWJlciA9IE1hdGgubWluKG51bWJlciAqIHB0UGVyVW5pdFt1bml0XSwgc3R5bGUubWF4U2l6ZVsxXSk7XG4gICAgICByZXR1cm4geyBudW1iZXI6IHV0aWxzLnJvdW5kKG51bWJlciksIHVuaXQ6IFwicHRcIiB9XG4gICAgfVxuICAgIGNhc2UgXCJtdVwiOiB7XG4gICAgICBudW1iZXIgPSBNYXRoLm1pbihudW1iZXIgLyAxOCwgc3R5bGUubWF4U2l6ZVswXSk7XG4gICAgICByZXR1cm4geyBudW1iZXI6IHV0aWxzLnJvdW5kKG51bWJlciksIHVuaXQ6IFwiZW1cIiB9XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgdW5pdCArIFwiJ1wiKVxuICB9XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5cbmNvbnN0IHBhZGRpbmckMSA9IHdpZHRoID0+IHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoICsgXCJlbVwiKTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmNvbnN0IHBhZGRlZE5vZGUgPSAoZ3JvdXAsIGxzcGFjZSA9IDAuMywgcnNwYWNlID0gMCwgbXVzdFNtYXNoID0gZmFsc2UpID0+IHtcbiAgaWYgKGdyb3VwID09IG51bGwgJiYgcnNwYWNlID09PSAwKSB7IHJldHVybiBwYWRkaW5nJDEobHNwYWNlKSB9XG4gIGNvbnN0IHJvdyA9IGdyb3VwID8gW2dyb3VwXSA6IFtdO1xuICBpZiAobHNwYWNlICE9PSAwKSAgIHsgcm93LnVuc2hpZnQocGFkZGluZyQxKGxzcGFjZSkpOyB9XG4gIGlmIChyc3BhY2UgPiAwKSB7IHJvdy5wdXNoKHBhZGRpbmckMShyc3BhY2UpKTsgfVxuICBpZiAobXVzdFNtYXNoKSB7XG4gICAgLy8gVXNlZCBmb3IgdGhlIGJvdHRvbSBhcnJvdyBpbiBhIHtDRH0gZW52aXJvbm1lbnRcbiAgICBjb25zdCBtcGFkZGVkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIHJvdyk7XG4gICAgbXBhZGRlZC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwXCIpO1xuICAgIHJldHVybiBtcGFkZGVkXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCByb3cpXG4gIH1cbn07XG5cbmNvbnN0IGxhYmVsU2l6ZSA9IChzaXplLCBzY3JpcHRMZXZlbCkgPT4gIE51bWJlcihzaXplKSAvIGVtU2NhbGUoc2NyaXB0TGV2ZWwpO1xuXG5jb25zdCBtdW5kZXJvdmVyTm9kZSA9IChmTmFtZSwgYm9keSwgYmVsb3csIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGFycm93Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZk5hbWUpO1xuICAvLyBJcyB0aGlzIHRoZSBzaG9ydCBwYXJ0IG9mIGEgbWhjaGVtIGVxdWlsaWJyaXVtIGFycm93P1xuICBjb25zdCBpc0VxID0gZk5hbWUuc2xpY2UoMSwgMykgPT09IFwiZXFcIjtcbiAgY29uc3QgbWluV2lkdGggPSBmTmFtZS5jaGFyQXQoMSkgPT09IFwieFwiXG4gICAgPyBcIjEuNzVcIiAgLy8gbWF0aHRvb2xzIGV4dGVuc2libGUgYXJyb3dzIGFyZSDiiaUgMS43NWVtIGxvbmdcbiAgICA6IGZOYW1lLnNsaWNlKDIsIDQpID09PSBcImNkXCJcbiAgICA/IFwiMy4wXCIgIC8vIGNkIHBhY2thZ2UgYXJyb3dzXG4gICAgOiBpc0VxXG4gICAgPyBcIjEuMFwiICAvLyBUaGUgc2hvcnRlciBoYXJwb29uIG9mIGEgbWhjaGVtIGVxdWlsaWJyaXVtIGFycm93XG4gICAgOiBcIjIuMFwiOyAvLyBvdGhlciBtaGNoZW0gYXJyb3dzXG4gIC8vIFRPRE86IFdoZW4gRmlyZWZveCBzdXBwb3J0cyBtaW5zaXplLCB1c2UgdGhlIG5leHQgbGluZS5cbiAgLy9hcnJvd05vZGUuc2V0QXR0cmlidXRlKFwibWluc2l6ZVwiLCBTdHJpbmcobWluV2lkdGgpICsgXCJlbVwiKVxuICBhcnJvd05vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMFwiKTtcbiAgYXJyb3dOb2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCAoaXNFcSA/IFwiMC41ZW1cIiA6IFwiMFwiKSk7XG5cbiAgLy8gPG11bmRlcm92ZXI+IHVwcGVyIGFuZCBsb3dlciBsYWJlbHMgYXJlIHNldCB0byBzY3JpcHRsZXZlbCBieSBNYXRoTUxcbiAgLy8gU28gd2UgaGF2ZSB0byBhZGp1c3Qgb3VyIGxhYmVsIGRpbWVuc2lvbnMgYWNjb3JkaW5nbHkuXG4gIGNvbnN0IGxhYmVsU3R5bGUgPSBzdHlsZS53aXRoTGV2ZWwoc3R5bGUubGV2ZWwgPCAyID8gMiA6IDMpO1xuICBjb25zdCBtaW5BcnJvd1dpZHRoID0gbGFiZWxTaXplKG1pbldpZHRoLCBsYWJlbFN0eWxlLmxldmVsKTtcbiAgLy8gVGhlIGR1bW15Tm9kZSB3aWxsIGJlIGluc2lkZSBhIDxtb3Zlcj4gaW5zaWRlIGEgPG1vdmVyPlxuICAvLyBTbyBpdCB3aWxsIGJlIGF0IHNjcmlwdGxldmVsIDNcbiAgY29uc3QgZHVtbXlXaWR0aCA9IGxhYmVsU2l6ZShtaW5XaWR0aCwgMyk7XG4gIGNvbnN0IGVtcHR5TGFiZWwgPSBwYWRkZWROb2RlKG51bGwsIG1pbkFycm93V2lkdGgudG9GaXhlZCg0KSwgMCk7XG4gIGNvbnN0IGR1bW15Tm9kZSA9IHBhZGRlZE5vZGUobnVsbCwgZHVtbXlXaWR0aC50b0ZpeGVkKDQpLCAwKTtcbiAgLy8gVGhlIGFycm93IGlzIGEgbGl0dGxlIGxvbmdlciB0aGFuIHRoZSBsYWJlbC4gU2V0IGEgc3BhY2VyIGxlbmd0aC5cbiAgY29uc3Qgc3BhY2UgPSBsYWJlbFNpemUoKGlzRXEgPyAwIDogMC4zKSwgbGFiZWxTdHlsZS5sZXZlbCkudG9GaXhlZCg0KTtcbiAgbGV0IHVwcGVyTm9kZTtcbiAgbGV0IGxvd2VyTm9kZTtcblxuICBjb25zdCBnb3RVcHBlciA9IChib2R5ICYmIGJvZHkuYm9keSAmJlxuICAgIC8vIFxcaHBoYW50b20gICAgICAgIHZpc2libGUgY29udGVudFxuICAgIChib2R5LmJvZHkuYm9keSB8fCBib2R5LmJvZHkubGVuZ3RoID4gMCkpO1xuICBpZiAoZ290VXBwZXIpIHtcbiAgICBsZXQgbGFiZWwgPSAgYnVpbGRHcm91cCQxKGJvZHksIGxhYmVsU3R5bGUpO1xuICAgIGNvbnN0IG11c3RTbWFzaCA9IChmTmFtZSA9PT0gXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiIHx8IGZOYW1lID09PSBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIik7XG4gICAgbGFiZWwgPSBwYWRkZWROb2RlKGxhYmVsLCBzcGFjZSwgc3BhY2UsIG11c3RTbWFzaCk7XG4gICAgLy8gU2luY2UgRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IG1pbnNpemUsIHN0YWNrIGEgaW52aXNpYmxlIG5vZGVcbiAgICAvLyBvbiB0b3Agb2YgdGhlIGxhYmVsLiBJdHMgd2lkdGggd2lsbCBzZXJ2ZSBhcyBhIG1pbi13aWR0aC5cbiAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGlzIGFmdGVyIEZpcmVmb3ggc3VwcG9ydHMgbWluc2l6ZS5cbiAgICB1cHBlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFtsYWJlbCwgZHVtbXlOb2RlXSk7XG4gIH1cbiAgY29uc3QgZ290TG93ZXIgPSAoYmVsb3cgJiYgYmVsb3cuYm9keSAmJlxuICAgIChiZWxvdy5ib2R5LmJvZHkgfHwgYmVsb3cuYm9keS5sZW5ndGggPiAwKSk7XG4gIGlmIChnb3RMb3dlcikge1xuICAgIGxldCBsYWJlbCA9ICBidWlsZEdyb3VwJDEoYmVsb3csIGxhYmVsU3R5bGUpO1xuICAgIGxhYmVsID0gcGFkZGVkTm9kZShsYWJlbCwgc3BhY2UsIHNwYWNlKTtcbiAgICBsb3dlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbbGFiZWwsIGR1bW15Tm9kZV0pO1xuICB9XG5cbiAgbGV0IG5vZGU7XG4gIGlmICghZ290VXBwZXIgJiYgIWdvdExvd2VyKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgZW1wdHlMYWJlbF0pO1xuICB9IGVsc2UgaWYgKGdvdFVwcGVyICYmIGdvdExvd2VyKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyb3ZlclwiLCBbYXJyb3dOb2RlLCBsb3dlck5vZGUsIHVwcGVyTm9kZV0pO1xuICB9IGVsc2UgaWYgKGdvdFVwcGVyKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2Fycm93Tm9kZSwgdXBwZXJOb2RlXSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFthcnJvd05vZGUsIGxvd2VyTm9kZV0pO1xuICB9XG4gIGlmIChtaW5XaWR0aCA9PT0gXCIzLjBcIikgeyBub2RlLnN0eWxlLmhlaWdodCA9IFwiMWVtXCI7IH0gLy8gQ0QgZW52aXJvbm1lbnRcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJmYWxzZVwiKTsgLy8gTmVjZXNzYXJ5IGZvciBNUyBXb3JkXG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBTdHJldGNoeSBhcnJvd3Mgd2l0aCBhbiBvcHRpb25hbCBhcmd1bWVudFxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInhBcnJvd1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXHhsZWZ0YXJyb3dcIixcbiAgICBcIlxcXFx4cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhMZWZ0YXJyb3dcIixcbiAgICBcIlxcXFx4UmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhsZWZ0cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhMZWZ0cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhob29rbGVmdGFycm93XCIsXG4gICAgXCJcXFxceGhvb2tyaWdodGFycm93XCIsXG4gICAgXCJcXFxceG1hcHN0b1wiLFxuICAgIFwiXFxcXHhyaWdodGhhcnBvb25kb3duXCIsXG4gICAgXCJcXFxceHJpZ2h0aGFycG9vbnVwXCIsXG4gICAgXCJcXFxceGxlZnRoYXJwb29uZG93blwiLFxuICAgIFwiXFxcXHhsZWZ0aGFycG9vbnVwXCIsXG4gICAgXCJcXFxceGxvbmdlcXVhbFwiLFxuICAgIFwiXFxcXHh0d29oZWFkcmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHh0d29oZWFkbGVmdGFycm93XCIsXG4gICAgLy8gVGhlIG5leHQgNSBmdW5jdGlvbnMgYXJlIGhlcmUgb25seSB0byBzdXBwb3J0IG1oY2hlbVxuICAgIFwiXFxcXHlpZWxkc1wiLFxuICAgIFwiXFxcXHlpZWxkc0xlZnRcIixcbiAgICBcIlxcXFxtZXNvbWVyaXNtXCIsXG4gICAgXCJcXFxcbG9uZ3JpZ2h0aGFycG9vbnVwXCIsXG4gICAgXCJcXFxcbG9uZ2xlZnRoYXJwb29uZG93blwiLFxuICAgIC8vIFRoZSBuZXh0IDMgZnVuY3Rpb25zIGFyZSBoZXJlIG9ubHkgdG8gc3VwcG9ydCB0aGUge0NEfSBlbnZpcm9ubWVudC5cbiAgICBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsXG4gICAgXCJcXFxcXFxcXGNkbGVmdGFycm93XCIsXG4gICAgXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwieEFycm93XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYXJnc1swXSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBCdWlsZCB0aGUgYXJyb3cgYW5kIGl0cyBsYWJlbHMuXG4gICAgY29uc3Qgbm9kZSA9IG11bmRlcm92ZXJOb2RlKGdyb3VwLm5hbWUsIGdyb3VwLmJvZHksIGdyb3VwLmJlbG93LCBzdHlsZSk7XG4gICAgLy8gQ3JlYXRlIG9wZXJhdG9yIHNwYWNpbmcgZm9yIGEgcmVsYXRpb24uXG4gICAgY29uc3Qgcm93ID0gW25vZGVdO1xuICAgIHJvdy51bnNoaWZ0KHBhZGRpbmckMSgwLjI3NzgpKTtcbiAgICByb3cucHVzaChwYWRkaW5nJDEoMC4yNzc4KSk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCByb3cpXG4gIH1cbn0pO1xuXG5jb25zdCBhcnJvd0NvbXBvbmVudCA9IHtcbiAgXCJcXFxceHRvZnJvbVwiOiBbXCJcXFxceHJpZ2h0YXJyb3dcIiwgXCJcXFxceGxlZnRhcnJvd1wiXSxcbiAgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCI6IFtcIlxcXFx4bGVmdGhhcnBvb251cFwiLCBcIlxcXFx4cmlnaHRoYXJwb29uZG93blwiXSxcbiAgXCJcXFxceHJpZ2h0bGVmdGhhcnBvb25zXCI6IFtcIlxcXFx4cmlnaHRoYXJwb29udXBcIiwgXCJcXFxceGxlZnRoYXJwb29uZG93blwiXSxcbiAgXCJcXFxceWllbGRzTGVmdFJpZ2h0XCI6IFtcIlxcXFx5aWVsZHNcIiwgXCJcXFxceWllbGRzTGVmdFwiXSxcbiAgLy8gVGhlIG5leHQgdGhyZWUgYWxsIGdldCB0aGUgc2FtZSBoYXJwb29uIGdseXBocy4gT25seSB0aGUgbGVuZ3RocyBhbmQgcGFkZGluZ3MgZGlmZmVyLlxuICBcIlxcXFxlcXVpbGlicml1bVwiOiBbXCJcXFxcbG9uZ3JpZ2h0aGFycG9vbnVwXCIsIFwiXFxcXGxvbmdsZWZ0aGFycG9vbmRvd25cIl0sXG4gIFwiXFxcXGVxdWlsaWJyaXVtUmlnaHRcIjogW1wiXFxcXGxvbmdyaWdodGhhcnBvb251cFwiLCBcIlxcXFxlcWxlZnRoYXJwb29uZG93blwiXSxcbiAgXCJcXFxcZXF1aWxpYnJpdW1MZWZ0XCI6IFtcIlxcXFxlcXJpZ2h0aGFycG9vbnVwXCIsIFwiXFxcXGxvbmdsZWZ0aGFycG9vbmRvd25cIl1cbn07XG5cbi8vIEJyb3dzZXJzIGFyZSBub3QgZ29vZCBhdCBzdHJldGNoaW5nIGEgZ2x5cGggdGhhdCBjb250YWlucyBhIHBhaXIgb2Ygc3RhY2tlZCBhcnJvd3Mgc3VjaCBhcyDih4QuXG4vLyBTbyB3ZSBzdGFjayBhIHBhaXIgb2Ygc2luZ2xlIGFycm93cy5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzdGFja2VkQXJyb3dcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFx4dG9mcm9tXCIsICAgICAgICAgICAgICAvLyBleHBmZWlsXG4gICAgXCJcXFxceGxlZnRyaWdodGhhcnBvb25zXCIsICAgLy8gbWF0aHRvb2xzXG4gICAgXCJcXFxceHJpZ2h0bGVmdGhhcnBvb25zXCIsICAgLy8gbWF0aHRvb2xzXG4gICAgXCJcXFxceWllbGRzTGVmdFJpZ2h0XCIsICAgICAgLy8gbWhjaGVtXG4gICAgXCJcXFxcZXF1aWxpYnJpdW1cIiwgICAgICAgICAgLy8gbWhjaGVtXG4gICAgXCJcXFxcZXF1aWxpYnJpdW1SaWdodFwiLFxuICAgIFwiXFxcXGVxdWlsaWJyaXVtTGVmdFwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IGxvd2VyQXJyb3dCb2R5ID0gYXJnc1swXVxuICAgICAgPyB7XG4gICAgICAgIHR5cGU6IFwiaHBoYW50b21cIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICAgIH1cbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCB1cHBlckFycm93QmVsb3cgPSBvcHRBcmdzWzBdXG4gICAgICA/IHtcbiAgICAgICAgdHlwZTogXCJocGhhbnRvbVwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgYm9keTogb3B0QXJnc1swXVxuICAgICAgfVxuICAgICAgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0YWNrZWRBcnJvd1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuYW1lOiBmdW5jTmFtZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF0sXG4gICAgICB1cHBlckFycm93QmVsb3csXG4gICAgICBsb3dlckFycm93Qm9keSxcbiAgICAgIGJlbG93OiBvcHRBcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCB0b3BMYWJlbCA9IGFycm93Q29tcG9uZW50W2dyb3VwLm5hbWVdWzBdO1xuICAgIGNvbnN0IGJvdExhYmVsID0gYXJyb3dDb21wb25lbnRbZ3JvdXAubmFtZV1bMV07XG4gICAgY29uc3QgdG9wQXJyb3cgPSBtdW5kZXJvdmVyTm9kZSh0b3BMYWJlbCwgZ3JvdXAuYm9keSwgZ3JvdXAudXBwZXJBcnJvd0JlbG93LCBzdHlsZSk7XG4gICAgY29uc3QgYm90QXJyb3cgPSBtdW5kZXJvdmVyTm9kZShib3RMYWJlbCwgZ3JvdXAubG93ZXJBcnJvd0JvZHksIGdyb3VwLmJlbG93LCBzdHlsZSk7XG4gICAgbGV0IHdyYXBwZXI7XG5cbiAgICBjb25zdCByYWlzZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3RvcEFycm93XSk7XG4gICAgcmFpc2VOb2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgXCIwLjNlbVwiKTtcbiAgICByYWlzZU5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiKzAuM2VtXCIpO1xuICAgIHJhaXNlTm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIi0wLjNlbVwiKTtcbiAgICAvLyBPbmUgb2YgdGhlIGFycm93cyBpcyBnaXZlbiB+emVybyB3aWR0aC4gc28gdGhlIG90aGVyIGhhcyB0aGUgc2FtZSBob3J6b250YWwgYWxpZ25tZW50LlxuICAgIGlmIChncm91cC5uYW1lID09PSBcIlxcXFxlcXVpbGlicml1bUxlZnRcIikge1xuICAgICAgY29uc3QgYm90Tm9kZSA9ICBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2JvdEFycm93XSk7XG4gICAgICBib3ROb2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC41ZW1cIik7XG4gICAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLFxuICAgICAgICBbcGFkZGluZyQxKDAuMjc3OCksIGJvdE5vZGUsIHJhaXNlTm9kZSwgcGFkZGluZyQxKDAuMjc3OCldXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByYWlzZU5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgKGdyb3VwLm5hbWUgPT09IFwiXFxcXGVxdWlsaWJyaXVtUmlnaHRcIiA/IFwiMC41ZW1cIiA6IFwiMFwiKSk7XG4gICAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLFxuICAgICAgICBbcGFkZGluZyQxKDAuMjc3OCksIHJhaXNlTm9kZSwgYm90QXJyb3csIHBhZGRpbmckMSgwLjI3NzgpXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgXCItMC4xOGVtXCIpO1xuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiLTAuMThlbVwiKTtcbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiKzAuMThlbVwiKTtcbiAgICByZXR1cm4gd3JhcHBlclxuICB9XG59KTtcblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBlbnZpcm9ubWVudHMuXG4gKiBgZW52aXJvbm1lbnRzLmpzYCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkgdmlhIGBlbnZpcm9ubWVudHMuanNgLlxuICovXG5jb25zdCBfZW52aXJvbm1lbnRzID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZUVudmlyb25tZW50KHsgdHlwZSwgbmFtZXMsIHByb3BzLCBoYW5kbGVyLCBtYXRobWxCdWlsZGVyIH0pIHtcbiAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGVudmlyb25tZW50cy5cbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0eXBlLFxuICAgIG51bUFyZ3M6IHByb3BzLm51bUFyZ3MgfHwgMCxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDAsXG4gICAgaGFuZGxlclxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgX2Vudmlyb25tZW50c1tuYW1lc1tpXV0gPSBkYXRhO1xuICB9XG4gIGlmIChtYXRobWxCdWlsZGVyKSB7XG4gICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICB9XG59XG5cbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBub2RlIGlzIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCByZXR1cm5zIGl0IHdpdGggc3RyaWN0ZXJcbiAqIHR5cGluZy4gVGhyb3dzIGlmIHRoZSBub2RlJ3MgdHlwZSBkb2VzIG5vdCBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZVR5cGUobm9kZSwgdHlwZSkge1xuICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSB0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIG5vZGUgb2YgdHlwZSAke3R5cGV9LCBidXQgZ290IGAgK1xuICAgICAgICAobm9kZSA/IGBub2RlIG9mIHR5cGUgJHtub2RlLnR5cGV9YCA6IFN0cmluZyhub2RlKSlcbiAgICApO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbW9yZSBzdHJpY3RseSB0eXBlZCBpZmYgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuIE90aGVyd2lzZSxcbiAqIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBjb25zdCB0eXBlZE5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKG5vZGUpO1xuICBpZiAoIXR5cGVkTm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBub2RlIG9mIHN5bWJvbCBncm91cCB0eXBlLCBidXQgZ290IGAgK1xuICAgICAgICAobm9kZSA/IGBub2RlIG9mIHR5cGUgJHtub2RlLnR5cGV9YCA6IFN0cmluZyhub2RlKSlcbiAgICApO1xuICB9XG4gIHJldHVybiB0eXBlZE5vZGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBjaGVja1N5bWJvbE5vZGVUeXBlKG5vZGUpIHtcbiAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gXCJhdG9tXCIgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChOT05fQVRPTVMsIG5vZGUudHlwZSkpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IGNkQXJyb3dGdW5jdGlvbk5hbWUgPSB7XG4gIFwiPlwiOiBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIsXG4gIFwiPFwiOiBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIixcbiAgXCI9XCI6IFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiLFxuICBBOiBcIlxcXFx1cGFycm93XCIsXG4gIFY6IFwiXFxcXGRvd25hcnJvd1wiLFxuICBcInxcIjogXCJcXFxcVmVydFwiLFxuICBcIi5cIjogXCJubyBhcnJvd1wiXG59O1xuXG5jb25zdCBuZXdDZWxsID0gKCkgPT4ge1xuICAvLyBDcmVhdGUgYW4gZW1wdHkgY2VsbCwgdG8gYmUgZmlsbGVkIGJlbG93IHdpdGggcGFyc2Ugbm9kZXMuXG4gIHJldHVybiB7IHR5cGU6IFwic3R5bGluZ1wiLCBib2R5OiBbXSwgbW9kZTogXCJtYXRoXCIsIHNjcmlwdExldmVsOiBcImRpc3BsYXlcIiB9O1xufTtcblxuY29uc3QgaXNTdGFydE9mQXJyb3cgPSAobm9kZSkgPT4ge1xuICByZXR1cm4gbm9kZS50eXBlID09PSBcInRleHRvcmRcIiAmJiBub2RlLnRleHQgPT09IFwiQFwiO1xufTtcblxuY29uc3QgaXNMYWJlbEVuZCA9IChub2RlLCBlbmRDaGFyKSA9PiB7XG4gIHJldHVybiAobm9kZS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBub2RlLnR5cGUgPT09IFwiYXRvbVwiKSAmJiBub2RlLnRleHQgPT09IGVuZENoYXI7XG59O1xuXG5mdW5jdGlvbiBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGEgcGFyc2UgdHJlZSBvZiBhbiBhcnJvdyBhbmQgaXRzIGxhYmVscy5cbiAgLy8gVGhpcyBhY3RzIGluIGEgd2F5IHNpbWlsYXIgdG8gYSBtYWNybyBleHBhbnNpb24uXG4gIGNvbnN0IGZ1bmNOYW1lID0gY2RBcnJvd0Z1bmN0aW9uTmFtZVthcnJvd0NoYXJdO1xuICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgY2FzZSBcIlxcXFxcXFxcY2RyaWdodGFycm93XCI6XG4gICAgY2FzZSBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIjpcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbGFiZWxzWzBdXSwgW2xhYmVsc1sxXV0pO1xuICAgIGNhc2UgXCJcXFxcdXBhcnJvd1wiOlxuICAgIGNhc2UgXCJcXFxcZG93bmFycm93XCI6IHtcbiAgICAgIGNvbnN0IGxlZnRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkbGVmdFwiLCBbbGFiZWxzWzBdXSwgW10pO1xuICAgICAgY29uc3QgYmFyZUFycm93ID0ge1xuICAgICAgICB0eXBlOiBcImF0b21cIixcbiAgICAgICAgdGV4dDogZnVuY05hbWUsXG4gICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICBmYW1pbHk6IFwicmVsXCJcbiAgICAgIH07XG4gICAgICBjb25zdCBzaXplZEFycm93ID0gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxCaWdcIiwgW2JhcmVBcnJvd10sIFtdKTtcbiAgICAgIGNvbnN0IHJpZ2h0TGFiZWwgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZHJpZ2h0XCIsIFtsYWJlbHNbMV1dLCBbXSk7XG4gICAgICBjb25zdCBhcnJvd0dyb3VwID0ge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICBib2R5OiBbbGVmdExhYmVsLCBzaXplZEFycm93LCByaWdodExhYmVsXSxcbiAgICAgICAgc2VtaXNpbXBsZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZHBhcmVudFwiLCBbYXJyb3dHcm91cF0sIFtdKTtcbiAgICB9XG4gICAgY2FzZSBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIjpcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiLCBbXSwgW10pO1xuICAgIGNhc2UgXCJcXFxcVmVydFwiOiB7XG4gICAgICBjb25zdCBhcnJvdyA9IHsgdHlwZTogXCJ0ZXh0b3JkXCIsIHRleHQ6IFwiXFxcXFZlcnRcIiwgbW9kZTogXCJtYXRoXCIgfTtcbiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXEJpZ1wiLCBbYXJyb3ddLCBbXSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4geyB0eXBlOiBcInRleHRvcmRcIiwgdGV4dDogXCIgXCIsIG1vZGU6IFwibWF0aFwiIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VDRChwYXJzZXIpIHtcbiAgLy8gR2V0IHRoZSBhcnJheSdzIHBhcnNlIG5vZGVzIHdpdGggXFxcXCB0ZW1wb3JhcmlseSBtYXBwZWQgdG8gXFxjci5cbiAgY29uc3QgcGFyc2VkUm93cyA9IFtdO1xuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNyXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIEdldCB0aGUgcGFyc2Ugbm9kZXMgZm9yIHRoZSBuZXh0IHJvdy5cbiAgICBwYXJzZWRSb3dzLnB1c2gocGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJcXFxcXFxcXFwiKSk7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICAgIGlmIChuZXh0ID09PSBcIiZcIiB8fCBuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgaWYgKHBhcnNlZFJvd3NbcGFyc2VkUm93cy5sZW5ndGggLSAxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyc2VkUm93cy5wb3AoKTsgLy8gZmluYWwgcm93IGVuZGVkIGluIFxcXFxcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIFxcXFxcXFxcIG9yIFxcXFxjciBvciBcXFxcZW5kXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIGxldCByb3cgPSBbXTtcbiAgY29uc3QgYm9keSA9IFtyb3ddO1xuXG4gIC8vIExvb3AgdGhydSB0aGUgcGFyc2Ugbm9kZXMuIENvbGxlY3QgdGhlbSBpbnRvIGNlbGxzIGFuZCBhcnJvd3MuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkUm93cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIFN0YXJ0IGEgbmV3IHJvdy5cbiAgICBjb25zdCByb3dOb2RlcyA9IHBhcnNlZFJvd3NbaV07XG4gICAgLy8gQ3JlYXRlIHRoZSBmaXJzdCBjZWxsLlxuICAgIGxldCBjZWxsID0gbmV3Q2VsbCgpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKCFpc1N0YXJ0T2ZBcnJvdyhyb3dOb2Rlc1tqXSkpIHtcbiAgICAgICAgLy8gSWYgYSBwYXJzZU5vZGUgaXMgbm90IGFuIGFycm93LCBpdCBnb2VzIGludG8gYSBjZWxsLlxuICAgICAgICBjZWxsLmJvZHkucHVzaChyb3dOb2Rlc1tqXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQYXJzZSBub2RlIGogaXMgYW4gXCJAXCIsIHRoZSBzdGFydCBvZiBhbiBhcnJvdy5cbiAgICAgICAgLy8gQmVmb3JlIHN0YXJ0aW5nIG9uIHRoZSBhcnJvdywgcHVzaCB0aGUgY2VsbCBpbnRvIGByb3dgLlxuICAgICAgICByb3cucHVzaChjZWxsKTtcblxuICAgICAgICAvLyBOb3cgY29sbGVjdCBwYXJzZU5vZGVzIGludG8gYW4gYXJyb3cuXG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYWZ0ZXIgXCJAXCIgZGVmaW5lcyB0aGUgYXJyb3cgdHlwZS5cbiAgICAgICAgaiArPSAxO1xuICAgICAgICBjb25zdCBhcnJvd0NoYXIgPSBhc3NlcnRTeW1ib2xOb2RlVHlwZShyb3dOb2Rlc1tqXSkudGV4dDtcblxuICAgICAgICAvLyBDcmVhdGUgdHdvIGVtcHR5IGxhYmVsIG5vZGVzLiBXZSBtYXkgb3IgbWF5IG5vdCB1c2UgdGhlbS5cbiAgICAgICAgY29uc3QgbGFiZWxzID0gbmV3IEFycmF5KDIpO1xuICAgICAgICBsYWJlbHNbMF0gPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogXCJtYXRoXCIsIGJvZHk6IFtdIH07XG4gICAgICAgIGxhYmVsc1sxXSA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiBcIm1hdGhcIiwgYm9keTogW10gfTtcblxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBhcnJvdy5cbiAgICAgICAgaWYgKFwiPXwuXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIDsgZWxzZSBpZiAoXCI8PkFWXCIuaW5kZXhPZihhcnJvd0NoYXIpID4gLTEpIHtcbiAgICAgICAgICAvLyBGb3VyIGFycm93cywgYEA+Pj5gLCBgQDw8PGAsIGBAQUFBYCwgYW5kIGBAVlZWYCwgZWFjaCB0YWtlXG4gICAgICAgICAgLy8gdHdvIG9wdGlvbmFsIGxhYmVscy4gRS5nLiB0aGUgcmlnaHQtcG9pbnQgYXJyb3cgc3ludGF4IGlzXG4gICAgICAgICAgLy8gcmVhbGx5OiAgQD57b3B0aW9uYWwgbGFiZWx9PntvcHRpb25hbCBsYWJlbH0+XG4gICAgICAgICAgLy8gQ29sbGVjdCBwYXJzZU5vZGVzIGludG8gbGFiZWxzLlxuICAgICAgICAgIGZvciAobGV0IGxhYmVsTnVtID0gMDsgbGFiZWxOdW0gPCAyOyBsYWJlbE51bSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5MYWJlbCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gaiArIDE7IGsgPCByb3dOb2Rlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoaXNMYWJlbEVuZChyb3dOb2Rlc1trXSwgYXJyb3dDaGFyKSkge1xuICAgICAgICAgICAgICAgIGluTGFiZWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBqID0gaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNTdGFydE9mQXJyb3cocm93Tm9kZXNba10pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIk1pc3NpbmcgYSBcIiArIGFycm93Q2hhciArIFwiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LlwiLFxuICAgICAgICAgICAgICAgICAgcm93Tm9kZXNba11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGFiZWxzW2xhYmVsTnVtXS5ib2R5LnB1c2gocm93Tm9kZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluTGFiZWwpIHtcbiAgICAgICAgICAgICAgLy8gaXNMYWJlbEVuZCBuZXZlciByZXR1cm5lZCBhIHRydWUuXG4gICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiTWlzc2luZyBhIFwiICsgYXJyb3dDaGFyICsgXCIgY2hhcmFjdGVyIHRvIGNvbXBsZXRlIGEgQ0QgYXJyb3cuXCIsXG4gICAgICAgICAgICAgICAgcm93Tm9kZXNbal1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEV4cGVjdGVkIG9uZSBvZiBcIjw+QVY9fC5cIiBhZnRlciBALmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93IGpvaW4gdGhlIGFycm93IHRvIGl0cyBsYWJlbHMuXG4gICAgICAgIGNvbnN0IGFycm93ID0gY2RBcnJvdyhhcnJvd0NoYXIsIGxhYmVscywgcGFyc2VyKTtcblxuICAgICAgICAvLyBXcmFwIHRoZSBhcnJvdyBpbiBhIHN0eWxpbmcgbm9kZVxuICAgICAgICByb3cucHVzaChhcnJvdyk7XG4gICAgICAgIC8vIEluIENEJ3Mgc3ludGF4LCBjZWxscyBhcmUgaW1wbGljaXQuIFRoYXQgaXMsIGV2ZXJ5dGhpbmcgdGhhdFxuICAgICAgICAvLyBpcyBub3QgYW4gYXJyb3cgZ2V0cyBjb2xsZWN0ZWQgaW50byBhIGNlbGwuIFNvIGNyZWF0ZSBhbiBlbXB0eVxuICAgICAgICAvLyBjZWxsIG5vdy4gSXQgd2lsbCBjb2xsZWN0IHVwY29taW5nIHBhcnNlTm9kZXMuXG4gICAgICAgIGNlbGwgPSBuZXdDZWxsKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpICUgMiA9PT0gMCkge1xuICAgICAgLy8gRXZlbi1udW1iZXJlZCByb3dzIGNvbnNpc3Qgb2Y6IGNlbGwsIGFycm93LCBjZWxsLCBhcnJvdywgLi4uIGNlbGxcbiAgICAgIC8vIFRoZSBsYXN0IGNlbGwgaXMgbm90IHlldCBwdXNoZWQgaW50byBgcm93YCwgc286XG4gICAgICByb3cucHVzaChjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2RkLW51bWJlcmVkIHJvd3MgY29uc2lzdCBvZjogdmVydCBhcnJvdywgZW1wdHkgY2VsbCwgLi4uIHZlcnQgYXJyb3dcbiAgICAgIC8vIFJlbW92ZSB0aGUgZW1wdHkgY2VsbCB0aGF0IHdhcyBwbGFjZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBgcm93YC5cbiAgICAgIHJvdy5zaGlmdCgpO1xuICAgIH1cbiAgICByb3cgPSBbXTtcbiAgICBib2R5LnB1c2gocm93KTtcbiAgfVxuICBib2R5LnBvcCgpO1xuXG4gIC8vIEVuZCByb3cgZ3JvdXBcbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAvLyBFbmQgYXJyYXkgZ3JvdXAgZGVmaW5pbmcgXFxcXFxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgYm9keSxcbiAgICB0YWdzOiBudWxsLFxuICAgIGxhYmVsczogbmV3IEFycmF5KGJvZHkubGVuZ3RoICsgMSkuZmlsbChcIlwiKSxcbiAgICBlbnZDbGFzc2VzOiBbXCJqb3RcIiwgXCJjZFwiXSxcbiAgICBjb2xzOiBbXSxcbiAgICBoTGluZXNCZWZvcmVSb3c6IG5ldyBBcnJheShib2R5Lmxlbmd0aCArIDEpLmZpbGwoW10pXG4gIH07XG59XG5cbi8vIFRoZSBmdW5jdGlvbnMgYmVsb3cgYXJlIG5vdCBhdmFpbGFibGUgZm9yIGdlbmVyYWwgdXNlLlxuLy8gVGhleSBhcmUgaGVyZSBvbmx5IGZvciBpbnRlcm5hbCB1c2UgYnkgdGhlIHtDRH0gZW52aXJvbm1lbnQgaW4gcGxhY2luZyBsYWJlbHNcbi8vIG5leHQgdG8gdmVydGljYWwgYXJyb3dzLlxuXG4vLyBXZSBkb24ndCBuZWVkIGFueSBzdWNoIGZ1bmN0aW9ucyBmb3IgaG9yaXpvbnRhbCBhcnJvd3MgYmVjYXVzZSB3ZSBjYW4gcmV1c2Vcbi8vIHRoZSBmdW5jdGlvbmFsaXR5IHRoYXQgYWxyZWFkeSBleGlzdHMgZm9yIGV4dGVuc2libGUgYXJyb3dzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY2RsYWJlbFwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxjZGxlZnRcIiwgXCJcXFxcXFxcXGNkcmlnaHRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2RsYWJlbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaWRlOiBmdW5jTmFtZS5zbGljZSg0KSxcbiAgICAgIGxhYmVsOiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBpZiAoZ3JvdXAubGFiZWwuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgc3R5bGUpICAvLyBlbXB0eSBsYWJlbFxuICAgIH1cbiAgICAvLyBBYnVzZSBhbiA8bXRhYmxlPiB0byBjcmVhdGUgdmVydGljYWxseSBjZW50ZXJlZCBjb250ZW50LlxuICAgIGNvbnN0IG10ZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAubGFiZWwsIHN0eWxlKV0pO1xuICAgIG10ZC5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XG4gICAgY29uc3QgbXRyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgW210ZF0pO1xuICAgIGNvbnN0IG10YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFttdHJdKTtcbiAgICBjb25zdCBsYWJlbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbbXRhYmxlXSk7XG4gICAgLy8gU2V0IHRoZSBsYWJlbCB3aWR0aCB0byB6ZXJvIHNvIHRoYXQgdGhlIGFycm93IHdpbGwgYmUgY2VudGVyZWQgdW5kZXIgdGhlIGNvcm5lciBjZWxsLlxuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMFwiKTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgXCJmYWxzZVwiKTtcbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjFcIik7XG4gICAgaWYgKGdyb3VwLnNpZGUgPT09IFwibGVmdFwiKSB7XG4gICAgICBsYWJlbC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICBsYWJlbC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiZmxleC1lbmRcIjtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNkbGFiZWxwYXJlbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcY2RwYXJlbnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjZGxhYmVscGFyZW50XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZyYWdtZW50OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAuZnJhZ21lbnQsIHN0eWxlKV0pO1xuICB9XG59KTtcblxuY29uc3Qgb3JkR3JvdXAgPSAoYm9keSkgPT4ge1xuICByZXR1cm4ge1xuICAgIFwidHlwZVwiOiBcIm9yZGdyb3VwXCIsXG4gICAgXCJtb2RlXCI6IFwibWF0aFwiLFxuICAgIFwiYm9keVwiOiBib2R5LFxuICAgIFwic2VtaXNpbXBsZVwiOiB0cnVlXG4gIH1cbn07XG5cbmNvbnN0IHBoYW50b20gPSAoYm9keSwgdHlwZSkgPT4ge1xuICByZXR1cm4ge1xuICAgIFwidHlwZVwiOiB0eXBlLFxuICAgIFwibW9kZVwiOiBcIm1hdGhcIixcbiAgICBcImJvZHlcIjogb3JkR3JvdXAoYm9keSlcbiAgfVxufTtcblxuLypcbiAqIEEgaGVscGVyIGZvciBcXGJvcmRlcm1hdHJpeC5cbiAqIHBhcnNlQXJyYXkoKSBoYXMgcGFyc2VkIHRoZSB0b2tlbnMgYXMgaWYgdGhlIGVudmlyb25tZW50XG4gKiB3YXMgXFxiZWdpbnttYXRyaXh9LiBUaGF0IHBhcnNlIHRyZWUgaXMgdGhpcyBmdW5jdGlvbuKAmXMgaW5wdXQuXG4gKiBIZXJlLCB3ZSByZWFycmFuZ2UgdGhlIHBhcnNlIHRyZWUgdG8gZ2V0IG9uZSB0aGF0IHdpbGxcbiAqIHJlc3VsdCBpbiBUZVggXFxib3JkZXJtYXRyaXguXG4gKiBUaGUgZmluYWwgcmVzdWx0IGluY2x1ZGVzIGEge3BtYXRyaXh9LCB3aGljaCBpcyB0aGUgYm90dG9tXG4gKiBoYWxmIG9mIGEgPG1vdmVyPiBlbGVtZW50LiBUaGUgdG9wIG9mIHRoZSA8bW92ZXI+IGNvbnRhaW5zXG4gKiB0aGUgXFxib3JkZXJtYXRyaXggaGVhZGluZ3MuIFRoZSB0b3Agc2VjdGlvbiBhbHNvIGNvbnRhaW5zIHRoZVxuICogY29udGVudHMgb2YgdGhlIGJvdHRvbSB7cG1hdHJpeH0uIFRob3NlIGVsZW1lbnRzIGFyZSBoaWRkZW4gdmlhXG4gKiBcXGhwaGFudG9tLCBidXQgdGhleSBlbnN1cmUgdGhhdCBjb2x1bW4gd2lkdGhzIGFyZSB0aGUgc2FtZSB0b3AgYW5kXG4gKiBib3R0b20uXG4gKlxuICogV2UgYWxzbyBjcmVhdGUgYSBsZWZ0IHttYXRyaXh9IHdpdGggYSBzaW5nbGUgY29sdW1uIHRoYXQgY29udGFpbnNcbiAqIGVsZW1lbnRzIHNoaWZ0ZWQgb3V0IG9mIHRoZSBtYXRyaXguIFRoZSBsZWZ0IHttYXRyaXh9IGFsc29cbiAqIGNvbnRhaW5zIFxcdnBoYW50b20gY29waWVzIG9mIHRoZSBvdGhlciB7cG1hdHJpeH0gZWxlbWVudHMuXG4gKiBBcyBiZWZvcmUsIHRoaXMgZW5zdXJlcyBjb25zaXN0ZW50IHJvdyBoZWlnaHRzIG9mIGxlZnQgYW5kIG1haW4uXG4gKi9cblxuY29uc3QgYm9yZGVybWF0cml4UGFyc2VUcmVlID0gKG1hdHJpeCwgZGVsaW1pdGVycykgPT4ge1xuICBjb25zdCBib2R5ID0gbWF0cml4LmJvZHk7XG4gIGJvZHlbMF0uc2hpZnQoKTsgLy8gZGlzcG9zZSBvZiB0b3AgbGVmdCBjZWxsXG5cbiAgLy8gQ3JlYXRlIGFuIGFycmF5IGZvciB0aGUgbGVmdCBjb2x1bW5cbiAgY29uc3QgbGVmdENvbHVtbkJvZHkgPSBuZXcgQXJyYXkoYm9keS5sZW5ndGggLSAxKS5maWxsKCkubWFwKCgpID0+IFtdKTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gVGhlIHZpc2libGUgcGFydCBvZiB0aGUgY2VsbFxuICAgIGxlZnRDb2x1bW5Cb2R5W2kgLSAxXS5wdXNoKGJvZHlbaV0uc2hpZnQoKSk7XG4gICAgLy8gQSB2cGhhbnRvbSB3aXRoIGNvbnRlbnRzIGZyb20gdGhlIHBtYXRyaXgsIHRvIHNldCBtaW5pbXVtIGNlbGwgaGVpZ2h0XG4gICAgY29uc3QgcGhhbnRvbUJvZHkgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJvZHlbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHBoYW50b21Cb2R5LnB1c2goc3RydWN0dXJlZENsb25lKGJvZHlbaV1bal0pKTtcbiAgICB9XG4gICAgbGVmdENvbHVtbkJvZHlbaSAtIDFdLnB1c2gocGhhbnRvbShwaGFudG9tQm9keSwgXCJ2cGhhbnRvbVwiKSk7XG4gIH1cblxuICAvLyBDcmVhdGUgYW4gYXJyYXkgZm9yIHRoZSB0b3Agcm93XG4gIGNvbnN0IHRvcFJvd0JvZHkgPSBuZXcgQXJyYXkoYm9keS5sZW5ndGgpLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGJvZHlbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICB0b3BSb3dCb2R5WzBdLnB1c2goc3RydWN0dXJlZENsb25lKGJvZHlbMF1bal0pKTtcbiAgfVxuICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSBwbWF0cml4LCBidXQgc3F1YXNoZWQgdmlhIFxcaHBoYW50b21cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBib2R5WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICB0b3BSb3dCb2R5W2ldLnB1c2gocGhhbnRvbShzdHJ1Y3R1cmVkQ2xvbmUoYm9keVtpXVtqXSkuYm9keSwgXCJocGhhbnRvbVwiKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3F1YXNoIHRoZSB0b3Agcm93IG9mIHRoZSBtYWluIHtwbWF0cml4fVxuICBmb3IgKGxldCBqID0gMDsgaiA8IGJvZHlbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICBib2R5WzBdW2pdID0gcGhhbnRvbShzdHJ1Y3R1cmVkQ2xvbmUoYm9keVswXVtqXSkuYm9keSwgXCJocGhhbnRvbVwiKTtcbiAgfVxuXG4gIC8vIE5vdyB3cmFwIHRoZSBhcnJheXMgaW4gdGhlIHByb3BlciBwYXJzZSBub2Rlcy5cblxuICBjb25zdCBsZWZ0Q29sdW1uID0ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBib2R5OiBsZWZ0Q29sdW1uQm9keSxcbiAgICBjb2xzOiBbeyB0eXBlOiBcImFsaWduXCIsIGFsaWduOiBcImNcIiB9XSxcbiAgICByb3dHYXBzOiBuZXcgQXJyYXkobGVmdENvbHVtbkJvZHkubGVuZ3RoIC0gMSkuZmlsbChudWxsKSxcbiAgICBoTGluZXNCZWZvcmVSb3c6IG5ldyBBcnJheShsZWZ0Q29sdW1uQm9keS5sZW5ndGggKyAxKS5maWxsKCkubWFwKCgpID0+IFtdKSxcbiAgICBlbnZDbGFzc2VzOiBbXSxcbiAgICBzY3JpcHRMZXZlbDogXCJ0ZXh0XCIsXG4gICAgYXJyYXlzdHJldGNoOiAxLFxuICAgIGxhYmVsczogbmV3IEFycmF5KGxlZnRDb2x1bW5Cb2R5Lmxlbmd0aCkuZmlsbChcIlwiKSxcbiAgICBhcnJheWNvbHNlcDogeyBcIm51bWJlclwiOiAwLjA0LCB1bml0OiBcImVtXCIgfVxuICB9O1xuXG4gIGNvbnN0IHRvcFJvdyA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgYm9keTogdG9wUm93Qm9keSxcbiAgICBjb2xzOiBuZXcgQXJyYXkodG9wUm93Qm9keS5sZW5ndGgpLmZpbGwoeyB0eXBlOiBcImFsaWduXCIsIGFsaWduOiBcImNcIiB9KSxcbiAgICByb3dHYXBzOiBuZXcgQXJyYXkodG9wUm93Qm9keS5sZW5ndGggLSAxKS5maWxsKG51bGwpLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogbmV3IEFycmF5KHRvcFJvd0JvZHkubGVuZ3RoICsgMSkuZmlsbCgpLm1hcCgoKSA9PiBbXSksXG4gICAgZW52Q2xhc3NlczogW10sXG4gICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiLFxuICAgIGFycmF5c3RyZXRjaDogMSxcbiAgICBsYWJlbHM6IG5ldyBBcnJheSh0b3BSb3dCb2R5Lmxlbmd0aCkuZmlsbChcIlwiKSxcbiAgICBhcnJheWNvbHNlcDogbnVsbFxuICB9O1xuXG4gIGNvbnN0IHRvcFdyYXBwZXIgPSB7XG4gICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiLCAvLyBNdXN0IHNldCB0aGlzIGV4cGxpY2l0bHkuXG4gICAgYm9keTogW3RvcFJvd10gICAgICAgLy8gRGVmYXVsdCBsZXZlbCBpcyBcInNjcmlwdFwiLlxuICB9O1xuXG4gIGNvbnN0IGNvbnRhaW5lciA9IHtcbiAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGJvZHk6IFttYXRyaXhdLFxuICAgIGxlZnQ6IGRlbGltaXRlcnMgPyBkZWxpbWl0ZXJzWzBdIDogXCIoXCIsXG4gICAgcmlnaHQ6IGRlbGltaXRlcnMgPyBkZWxpbWl0ZXJzWzFdIDogXCIpXCIsXG4gICAgcmlnaHRDb2xvcjogdW5kZWZpbmVkXG4gIH07XG5cbiAgY29uc3QgYmFzZSA9IHtcbiAgICB0eXBlOiBcIm9wXCIsICAgLy8gVGhlIGJhc2Ugb2YgYSBUZVggXFxvdmVyc2V0XG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgbGltaXRzOiB0cnVlLFxuICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogdHJ1ZSxcbiAgICBwYXJlbnRJc1N1cFN1YjogdHJ1ZSxcbiAgICBzeW1ib2w6IGZhbHNlLFxuICAgIHN0YWNrOiB0cnVlLFxuICAgIHN1cHByZXNzQmFzZVNoaWZ0OiB0cnVlLFxuICAgIGJvZHk6IFtjb250YWluZXJdXG4gIH07XG5cbiAgY29uc3QgbW92ZXIgPSB7XG4gICAgdHlwZTogXCJzdXBzdWJcIiwgIC8vIFdlJ3JlIHVzaW5nIHRoZSBNYXRoTUwgZXF1aXZhbGVudFxuICAgIG1vZGU6IFwibWF0aFwiLCAgICAvLyBvZiBUZVggXFxvdmVyc2V0LlxuICAgIGJhc2U6IGJhc2UsICAgICAgLy8gVGhhdCBrZWVwcyB0aGUge3BtYXRyaXh9IGFsaWduZWQgd2l0aFxuICAgIHN1cDogdG9wV3JhcHBlciwgLy8gdGhlIG1hdGggY2VudGVybGluZS5cbiAgICBzdWI6IG51bGxcbiAgfTtcblxuICByZXR1cm4gb3JkR3JvdXAoW2xlZnRDb2x1bW4sIG1vdmVyXSlcbn07XG5cbi8qKlxuICogTGV4aW5nIG9yIHBhcnNpbmcgcG9zaXRpb25hbCBpbmZvcm1hdGlvbiBmb3IgZXJyb3IgcmVwb3J0aW5nLlxuICogVGhpcyBvYmplY3QgaXMgaW1tdXRhYmxlLlxuICovXG5jbGFzcyBTb3VyY2VMb2NhdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGxleGVyLCBzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyOyAvLyBMZXhlciBob2xkaW5nIHRoZSBpbnB1dCBzdHJpbmcuXG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0OyAvLyBTdGFydCBvZmZzZXQsIHplcm8tYmFzZWQgaW5jbHVzaXZlLlxuICAgIHRoaXMuZW5kID0gZW5kOyAgICAgLy8gRW5kIG9mZnNldCwgemVyby1iYXNlZCBleGNsdXNpdmUuXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2VzIHR3byBgU291cmNlTG9jYXRpb25gcyBmcm9tIGxvY2F0aW9uIHByb3ZpZGVycywgZ2l2ZW4gdGhleSBhcmVcbiAgICogcHJvdmlkZWQgaW4gb3JkZXIgb2YgYXBwZWFyYW5jZS5cbiAgICogLSBSZXR1cm5zIHRoZSBmaXJzdCBvbmUncyBsb2NhdGlvbiBpZiBvbmx5IHRoZSBmaXJzdCBpcyBwcm92aWRlZC5cbiAgICogLSBSZXR1cm5zIGEgbWVyZ2VkIHJhbmdlIG9mIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgaWYgYm90aCBhcmUgcHJvdmlkZWRcbiAgICogICBhbmQgdGhlaXIgbGV4ZXJzIG1hdGNoLlxuICAgKiAtIE90aGVyd2lzZSwgcmV0dXJucyBudWxsLlxuICAgKi9cbiAgc3RhdGljIHJhbmdlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoIXNlY29uZCkge1xuICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmxvYztcbiAgICB9IGVsc2UgaWYgKCFmaXJzdCB8fCAhZmlyc3QubG9jIHx8ICFzZWNvbmQubG9jIHx8IGZpcnN0LmxvYy5sZXhlciAhPT0gc2Vjb25kLmxvYy5sZXhlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgU291cmNlTG9jYXRpb24oZmlyc3QubG9jLmxleGVyLCBmaXJzdC5sb2Muc3RhcnQsIHNlY29uZC5sb2MuZW5kKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgcmVxdWlyZWQgdG8gYnJlYWsgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIFRva2VuLCBMZXhlciwgYW5kXG4gKiBQYXJzZUVycm9yLlxuICovXG5cbi8qKlxuICogVGhlIHJlc3VsdGluZyB0b2tlbiByZXR1cm5lZCBmcm9tIGBsZXhgLlxuICpcbiAqIEl0IGNvbnNpc3RzIG9mIHRoZSB0b2tlbiB0ZXh0IHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBlc3NlbnRpYWxseSBhIHJhbmdlIGluIGFuIGlucHV0IHN0cmluZyxcbiAqIGJ1dCBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIHRoZSBiYXJlIGlucHV0IHN0cmluZywgd2UgcmVmZXIgdG8gdGhlIGxleGVyLlxuICogVGhhdCB3YXkgaXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGV4dHJhIG1ldGFkYXRhIHRvIHRoZSBpbnB1dCBzdHJpbmcsXG4gKiBsaWtlIGZvciBleGFtcGxlIGEgZmlsZSBuYW1lIG9yIHNpbWlsYXIuXG4gKlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIG9wdGlvbmFsLCBzbyBpdCBpcyBPSyB0byBjb25zdHJ1Y3Qgc3ludGhldGljXG4gKiB0b2tlbnMgaWYgYXBwcm9wcmlhdGUuIE5vdCBwcm92aWRpbmcgYXZhaWxhYmxlIHBvc2l0aW9uIGluZm9ybWF0aW9uIG1heVxuICogbGVhZCB0byBkZWdyYWRlZCBlcnJvciByZXBvcnRpbmcsIHRob3VnaC5cbiAqL1xuY2xhc3MgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcihcbiAgICB0ZXh0LCAvLyB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gICAgbG9jXG4gICkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5sb2MgPSBsb2M7XG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBwYWlyIG9mIHRva2VucyAodGhpcyBhbmQgZW5kVG9rZW4pLCBjb21wdXRlIGEgYFRva2VuYCBlbmNvbXBhc3NpbmdcbiAgICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAgICovXG4gIHJhbmdlKFxuICAgIGVuZFRva2VuLCAvLyBsYXN0IHRva2VuIG9mIHRoZSByYW5nZSwgaW5jbHVzaXZlXG4gICAgdGV4dCAvLyB0aGUgdGV4dCBvZiB0aGUgbmV3bHkgY29uc3RydWN0ZWQgdG9rZW5cbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCBTb3VyY2VMb2NhdGlvbi5yYW5nZSh0aGlzLCBlbmRUb2tlbikpO1xuICB9XG59XG5cbi8vIEluIFRlWCwgdGhlcmUgYXJlIGFjdHVhbGx5IHRocmVlIHNldHMgb2YgZGltZW5zaW9ucywgb25lIGZvciBlYWNoIG9mXG4vLyB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBhbmQgc2NyaXB0c2NyaXB0c3R5bGUuICBUaGVzZSBhcmVcbi8vIHByb3ZpZGVkIGluIHRoZSB0aGUgYXJyYXlzIGJlbG93LCBpbiB0aGF0IG9yZGVyLlxuLy9cblxuLy8gTWF0aCBzdHlsZSBpcyBub3QgcXVpdGUgdGhlIHNhbWUgdGhpbmcgYXMgc2NyaXB0IGxldmVsLlxuY29uc3QgU3R5bGVMZXZlbCA9IHtcbiAgRElTUExBWTogMCxcbiAgVEVYVDogMSxcbiAgU0NSSVBUOiAyLFxuICBTQ1JJUFRTQ1JJUFQ6IDNcbn07XG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZ2xvYmFsL2J1aWx0LWluIG1hY3Jvcy5cbiAqIGBtYWNyb3MuanNgIGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeSB2aWEgYG1hY3Jvcy5qc2AuXG4gKi9cbmNvbnN0IF9tYWNyb3MgPSB7fTtcblxuLy8gVGhpcyBmdW5jdGlvbiBtaWdodCBvbmUgZGF5IGFjY2VwdCBhbiBhZGRpdGlvbmFsIGFyZ3VtZW50IGFuZCBkbyBtb3JlIHRoaW5ncy5cbmZ1bmN0aW9uIGRlZmluZU1hY3JvKG5hbWUsIGJvZHkpIHtcbiAgX21hY3Jvc1tuYW1lXSA9IGJvZHk7XG59XG5cbi8qKlxuICogUHJlZGVmaW5lZCBtYWNyb3MgZm9yIFRlbW1sLlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBkZWZpbmUgc29tZSBjb21tYW5kcyBpbiB0ZXJtcyBvZiBvdGhlcnMuXG4gKi9cblxuY29uc3QgbWFjcm9zID0gX21hY3JvcztcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gbWFjcm8gdG9vbHNcblxuZGVmaW5lTWFjcm8oXCJcXFxcbm9leHBhbmRcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICAvLyBUaGUgZXhwYW5zaW9uIGlzIHRoZSB0b2tlbiBpdHNlbGY7IGJ1dCB0aGF0IHRva2VuIGlzIGludGVycHJldGVkXG4gIC8vIGFzIGlmIGl0cyBtZWFuaW5nIHdlcmUg4oCYXFxyZWxheOKAmSBpZiBpdCBpcyBhIGNvbnRyb2wgc2VxdWVuY2UgdGhhdFxuICAvLyB3b3VsZCBvcmRpbmFyaWx5IGJlIGV4cGFuZGVkIGJ5IFRlWOKAmXMgZXhwYW5zaW9uIHJ1bGVzLlxuICBjb25zdCB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuICBpZiAoY29udGV4dC5pc0V4cGFuZGFibGUodC50ZXh0KSkge1xuICAgIHQubm9leHBhbmQgPSB0cnVlO1xuICAgIHQudHJlYXRBc1JlbGF4ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4geyB0b2tlbnM6IFt0XSwgbnVtQXJnczogMCB9O1xufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGV4cGFuZGFmdGVyXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgLy8gVGVYIGZpcnN0IHJlYWRzIHRoZSB0b2tlbiB0aGF0IGNvbWVzIGltbWVkaWF0ZWx5IGFmdGVyIFxcZXhwYW5kYWZ0ZXIsXG4gIC8vIHdpdGhvdXQgZXhwYW5kaW5nIGl0OyBsZXTigJlzIGNhbGwgdGhpcyB0b2tlbiB0LiBUaGVuIFRlWCByZWFkcyB0aGVcbiAgLy8gdG9rZW4gdGhhdCBjb21lcyBhZnRlciB0IChhbmQgcG9zc2libHkgbW9yZSB0b2tlbnMsIGlmIHRoYXQgdG9rZW5cbiAgLy8gaGFzIGFuIGFyZ3VtZW50KSwgcmVwbGFjaW5nIGl0IGJ5IGl0cyBleHBhbnNpb24uIEZpbmFsbHkgVGVYIHB1dHNcbiAgLy8gdCBiYWNrIGluIGZyb250IG9mIHRoYXQgZXhwYW5zaW9uLlxuICBjb25zdCB0ID0gY29udGV4dC5wb3BUb2tlbigpO1xuICBjb250ZXh0LmV4cGFuZE9uY2UodHJ1ZSk7IC8vIGV4cGFuZCBvbmx5IGFuIGV4cGFuZGFibGUgdG9rZW5cbiAgcmV0dXJuIHsgdG9rZW5zOiBbdF0sIG51bUFyZ3M6IDAgfTtcbn0pO1xuXG4vLyBMYVRlWCdzIFxcQGZpcnN0b2Z0d297IzF9eyMyfSBleHBhbmRzIHRvICMxLCBza2lwcGluZyAjMlxuLy8gVGVYIHNvdXJjZTogXFxsb25nXFxkZWZcXEBmaXJzdG9mdHdvIzEjMnsjMX1cbmRlZmluZU1hY3JvKFwiXFxcXEBmaXJzdG9mdHdvXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIHJldHVybiB7IHRva2VuczogYXJnc1swXSwgbnVtQXJnczogMCB9O1xufSk7XG5cbi8vIExhVGVYJ3MgXFxAc2Vjb25kb2Z0d297IzF9eyMyfSBleHBhbmRzIHRvICMyLCBza2lwcGluZyAjMVxuLy8gVGVYIHNvdXJjZTogXFxsb25nXFxkZWZcXEBzZWNvbmRvZnR3byMxIzJ7IzJ9XG5kZWZpbmVNYWNybyhcIlxcXFxAc2Vjb25kb2Z0d29cIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcbiAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzFdLCBudW1BcmdzOiAwIH07XG59KTtcblxuLy8gTGFUZVgncyBcXEBpZm5leHRjaGFyeyMxfXsjMn17IzN9IGxvb2tzIGFoZWFkIHRvIHRoZSBuZXh0ICh1bmV4cGFuZGVkKVxuLy8gc3ltYm9sIHRoYXQgaXNuJ3QgYSBzcGFjZSwgY29uc3VtaW5nIGFueSBzcGFjZXMgYnV0IG5vdCBjb25zdW1pbmcgdGhlXG4vLyBmaXJzdCBub25zcGFjZSBjaGFyYWN0ZXIuICBJZiB0aGF0IG5vbnNwYWNlIGNoYXJhY3RlciBtYXRjaGVzICMxLCB0aGVuXG4vLyB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMjsgb3RoZXJ3aXNlLCBpdCBleHBhbmRzIHRvICMzLlxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmbmV4dGNoYXJcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygzKTsgLy8gc3ltYm9sLCBpZiwgZWxzZVxuICBjb250ZXh0LmNvbnN1bWVTcGFjZXMoKTtcbiAgY29uc3QgbmV4dFRva2VuID0gY29udGV4dC5mdXR1cmUoKTtcbiAgaWYgKGFyZ3NbMF0ubGVuZ3RoID09PSAxICYmIGFyZ3NbMF1bMF0udGV4dCA9PT0gbmV4dFRva2VuLnRleHQpIHtcbiAgICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMV0sIG51bUFyZ3M6IDAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMl0sIG51bUFyZ3M6IDAgfTtcbiAgfVxufSk7XG5cbi8vIExhVGVYJ3MgXFxAaWZzdGFyeyMxfXsjMn0gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpIHN5bWJvbC5cbi8vIElmIGl0IGlzIGAqYCwgdGhlbiBpdCBjb25zdW1lcyB0aGUgc3ltYm9sLCBhbmQgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzE7XG4vLyBvdGhlcndpc2UsIHRoZSBtYWNybyBleHBhbmRzIHRvICMyICh3aXRob3V0IGNvbnN1bWluZyB0aGUgc3ltYm9sKS5cbi8vIFRlWCBzb3VyY2U6IFxcZGVmXFxAaWZzdGFyIzF7XFxAaWZuZXh0Y2hhciAqe1xcQGZpcnN0b2Z0d297IzF9fX1cbmRlZmluZU1hY3JvKFwiXFxcXEBpZnN0YXJcIiwgXCJcXFxcQGlmbmV4dGNoYXIgKntcXFxcQGZpcnN0b2Z0d297IzF9fVwiKTtcblxuLy8gTGFUZVgncyBcXFRleHRPck1hdGh7IzF9eyMyfSBleHBhbmRzIHRvICMxIGluIHRleHQgbW9kZSwgIzIgaW4gbWF0aCBtb2RlXG5kZWZpbmVNYWNybyhcIlxcXFxUZXh0T3JNYXRoXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIGlmIChjb250ZXh0Lm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzBdLCBudW1BcmdzOiAwIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzFdLCBudW1BcmdzOiAwIH07XG4gIH1cbn0pO1xuXG5jb25zdCBzdHJpbmdGcm9tQXJnID0gYXJnID0+IHtcbiAgLy8gUmV2ZXJzZSB0aGUgb3JkZXIgb2YgdGhlIGFyZyBhbmQgcmV0dXJuIGEgc3RyaW5nLlxuICBsZXQgc3RyID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IGFyZy5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHN0ciArPSBhcmdbaV0udGV4dDtcbiAgfVxuICByZXR1cm4gc3RyXG59O1xuXG4vLyBMb29rdXAgdGFibGUgZm9yIHBhcnNpbmcgbnVtYmVycyBpbiBiYXNlIDggdGhyb3VnaCAxNlxuY29uc3QgZGlnaXRUb051bWJlciA9IHtcbiAgMDogMCxcbiAgMTogMSxcbiAgMjogMixcbiAgMzogMyxcbiAgNDogNCxcbiAgNTogNSxcbiAgNjogNixcbiAgNzogNyxcbiAgODogOCxcbiAgOTogOSxcbiAgYTogMTAsXG4gIEE6IDEwLFxuICBiOiAxMSxcbiAgQjogMTEsXG4gIGM6IDEyLFxuICBDOiAxMixcbiAgZDogMTMsXG4gIEQ6IDEzLFxuICBlOiAxNCxcbiAgRTogMTQsXG4gIGY6IDE1LFxuICBGOiAxNVxufTtcblxuY29uc3QgbmV4dENoYXJOdW1iZXIgPSBjb250ZXh0ID0+IHtcbiAgY29uc3QgbnVtU3RyID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuICBpZiAobnVtU3RyID09PSBcIkVPRlwiKSB7IHJldHVybiBbbnVsbCwgXCJcIl0gfVxuICByZXR1cm4gW2RpZ2l0VG9OdW1iZXJbbnVtU3RyLmNoYXJBdCgwKV0sIG51bVN0cl1cbn07XG5cbmNvbnN0IGFwcGVuZENoYXJOdW1iZXJzID0gKG51bWJlciwgbnVtU3RyLCBiYXNlKSA9PiB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGlnaXQgPSBkaWdpdFRvTnVtYmVyW251bVN0ci5jaGFyQXQoaSldO1xuICAgIG51bWJlciAqPSBiYXNlO1xuICAgIG51bWJlciArPSBkaWdpdDtcbiAgfVxuICByZXR1cm4gbnVtYmVyXG59O1xuXG4vLyBUZVggXFxjaGFyIG1ha2VzIGEgbGl0ZXJhbCBjaGFyYWN0ZXIgKGNhdGNvZGUgMTIpIHVzaW5nIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4vLyAoc2VlIFRoZSBUZVhCb29rLCBwLiA0Mylcbi8vICAgXFxjaGFyMTIzICAtLSBkZWNpbWFsXG4vLyAgIFxcY2hhcicxMjMgLS0gb2N0YWxcbi8vICAgXFxjaGFyXCIxMjMgLS0gaGV4XG4vLyAgIFxcY2hhcmB4ICAgLS0gY2hhcmFjdGVyIHRoYXQgY2FuIGJlIHdyaXR0ZW4gKGkuZS4gaXNuJ3QgYWN0aXZlKVxuLy8gICBcXGNoYXJgXFx4ICAtLSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgd3JpdHRlbiAoZS5nLiAlKVxuLy8gVGhlc2UgYWxsIHJlZmVyIHRvIGNoYXJhY3RlcnMgZnJvbSB0aGUgZm9udCwgc28gd2UgdHVybiB0aGVtIGludG8gc3BlY2lhbFxuLy8gY2FsbHMgdG8gYSBmdW5jdGlvbiBcXEBjaGFyIGRlYWx0IHdpdGggaW4gdGhlIFBhcnNlci5cbmRlZmluZU1hY3JvKFwiXFxcXGNoYXJcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBsZXQgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIGxldCBiYXNlO1xuICBsZXQgbnVtYmVyID0gXCJcIjtcbiAgaWYgKHRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgYmFzZSA9IDg7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gJ1wiJykge1xuICAgIGJhc2UgPSAxNjtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSBcImBcIikge1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICAgIGlmICh0b2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDEpO1xuICAgIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcY2hhcmAgbWlzc2luZyBhcmd1bWVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyID0gdG9rZW4udGV4dC5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlID0gMTA7XG4gIH1cbiAgaWYgKGJhc2UpIHtcbiAgICAvLyBQYXJzZSBhIG51bWJlciBpbiB0aGUgZ2l2ZW4gYmFzZSwgc3RhcnRpbmcgd2l0aCBmaXJzdCBgdG9rZW5gLlxuICAgIGxldCBudW1TdHIgPSB0b2tlbi50ZXh0O1xuICAgIG51bWJlciA9IGRpZ2l0VG9OdW1iZXJbbnVtU3RyLmNoYXJBdCgwKV07XG4gICAgaWYgKG51bWJlciA9PSBudWxsIHx8IG51bWJlciA+PSBiYXNlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBiYXNlLSR7YmFzZX0gZGlnaXQgJHt0b2tlbi50ZXh0fWApO1xuICAgIH1cbiAgICBudW1iZXIgPSBhcHBlbmRDaGFyTnVtYmVycyhudW1iZXIsIG51bVN0ciwgYmFzZSk7XG4gICAgbGV0IGRpZ2l0O1xuICAgIFtkaWdpdCwgbnVtU3RyXSA9IG5leHRDaGFyTnVtYmVyKGNvbnRleHQpO1xuICAgIHdoaWxlIChkaWdpdCAhPSBudWxsICYmIGRpZ2l0IDwgYmFzZSkge1xuICAgICAgbnVtYmVyICo9IGJhc2U7XG4gICAgICBudW1iZXIgKz0gZGlnaXQ7XG4gICAgICBudW1iZXIgPSBhcHBlbmRDaGFyTnVtYmVycyhudW1iZXIsIG51bVN0ciwgYmFzZSk7XG4gICAgICBjb250ZXh0LnBvcFRva2VuKCk7XG4gICAgICBbZGlnaXQsIG51bVN0cl0gPSBuZXh0Q2hhck51bWJlcihjb250ZXh0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGBcXFxcQGNoYXJ7JHtudW1iZXJ9fWA7XG59KTtcblxuZnVuY3Rpb24gcmVjcmVhdGVBcmdTdHIoY29udGV4dCkge1xuICAvLyBSZWNyZWF0ZSB0aGUgbWFjcm8ncyBvcmlnaW5hbCBhcmd1bWVudCBzdHJpbmcgZnJvbSB0aGUgYXJyYXkgb2YgcGFyc2UgdG9rZW5zLlxuICBjb25zdCB0b2tlbnMgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdO1xuICBsZXQgc3RyID0gXCJcIjtcbiAgbGV0IGV4cGVjdGVkTG9jID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5sb2Muc3RhcnQ7XG4gIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBhY3R1YWxMb2MgPSB0b2tlbnNbaV0ubG9jLnN0YXJ0O1xuICAgIGlmIChhY3R1YWxMb2MgPiBleHBlY3RlZExvYykge1xuICAgICAgLy8gY29udGV4dC5jb25zdW1lQXJncyBoYXMgZWF0ZW4gYSBzcGFjZS5cbiAgICAgIHN0ciArPSBcIiBcIjtcbiAgICAgIGV4cGVjdGVkTG9jID0gYWN0dWFsTG9jO1xuICAgIH1cbiAgICBzdHIgKz0gdG9rZW5zW2ldLnRleHQ7XG4gICAgZXhwZWN0ZWRMb2MgKz0gdG9rZW5zW2ldLnRleHQubGVuZ3RoO1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuLy8gVGhlIExhdGluIE1vZGVybiBmb250IHJlbmRlcnMgPG1pPuKImjwvbWk+IGF0IHRoZSB3cm9uZyB2ZXJ0aWNhbCBhbGlnbm1lbnQuXG4vLyBUaGlzIG1hY3JvIHByb3ZpZGVzIGEgYmV0dGVyIHJlbmRlcmluZy5cbmRlZmluZU1hY3JvKFwiXFxcXHN1cmRcIiwgJ1xcXFxzcXJ0e1xcXFx2cGhhbnRvbXt8fX0nKTtcblxuLy8gU2VlIGNvbW1lbnQgZm9yIFxcb3BsdXMgaW4gc3ltYm9scy5qcy5cbmRlZmluZU1hY3JvKFwiXFx1MjI5NVwiLCBcIlxcXFxvcGx1c1wiKTtcblxuLy8gU2luY2UgVGVtbWwgaGFzIG5vIFxccGFyLCBpZ25vcmUgXFxsb25nLlxuZGVmaW5lTWFjcm8oXCJcXFxcbG9uZ1wiLCBcIlwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gR3JvdXBpbmdcbi8vIFxcbGV0XFxiZ3JvdXA9eyBcXGxldFxcZWdyb3VwPX1cbmRlZmluZU1hY3JvKFwiXFxcXGJncm91cFwiLCBcIntcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlZ3JvdXBcIiwgXCJ9XCIpO1xuXG4vLyBTeW1ib2xzIGZyb20gbGF0ZXgubHR4OlxuLy8gXFxkZWZ+e1xcbm9icmVha3NwYWNle319XG4vLyBcXGRlZlxcbHF7YH1cbi8vIFxcZGVmXFxycXsnfVxuLy8gXFxkZWYgXFxhYSB7XFxyIGF9XG5kZWZpbmVNYWNybyhcIn5cIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHFcIiwgXCJgXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccnFcIiwgXCInXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWFcIiwgXCJcXFxcciBhXCIpO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxCYmJrXCIsIFwiXFxcXEJiYntrfVwiKTtcblxuLy8gXFxtYXRoc3RydXQgZnJvbSB0aGUgVGVYYm9vaywgcCAzNjBcbmRlZmluZU1hY3JvKFwiXFxcXG1hdGhzdHJ1dFwiLCBcIlxcXFx2cGhhbnRvbXsofVwiKTtcblxuLy8gXFx1bmRlcmJhciBmcm9tIFRlWGJvb2sgcCAzNTNcbmRlZmluZU1hY3JvKFwiXFxcXHVuZGVyYmFyXCIsIFwiXFxcXHVuZGVybGluZXtcXFxcdGV4dHsjMX19XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMYVRlWF8yzrVcblxuLy8gXFx2ZG90c3tcXHZib3h7XFxiYXNlbGluZXNraXA0XFxwQCAgXFxsaW5lc2tpcGxpbWl0XFx6QFxuLy8gXFxrZXJuNlxccEBcXGhib3h7Ln1cXGhib3h7Ln1cXGhib3h7Ln19fVxuLy8gV2UnbGwgY2FsbCBcXHZhcnZkb3RzLCB3aGljaCBnZXRzIGEgZ2x5cGggZnJvbSBzeW1ib2xzLmpzLlxuLy8gVGhlIHplcm8td2lkdGggcnVsZSBnZXRzIHVzIGFuIGVxdWl2YWxlbnQgdG8gdGhlIHZlcnRpY2FsIDZwdCBrZXJuLlxuZGVmaW5lTWFjcm8oXCJcXFxcdmRvdHNcIiwgXCJ7XFxcXHZhcnZkb3RzXFxcXHJ1bGV7MHB0fXsxNXB0fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcdTIyZWVcIiwgXCJcXFxcdmRvdHNcIik7XG5cbi8vIHthcnJheX0gZW52aXJvbm1lbnQgZ2Fwc1xuZGVmaW5lTWFjcm8oXCJcXFxcYXJyYXlzdHJldGNoXCIsIFwiMVwiKTsgICAgIC8vIGxpbmUgc3BhY2luZyBmYWN0b3IgdGltZXMgMTJwdFxuZGVmaW5lTWFjcm8oXCJcXFxcYXJyYXljb2xzZXBcIiwgXCI2cHRcIik7ICAgIC8vIGhhbGYgdGhlIHdpZHRoIHNlcGFyYXRpbmcgY29sdW1uc1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhbXNtYXRoLnN0eVxuLy8gaHR0cDovL21pcnJvcnMuY29uY2VydHBhc3MuY29tL3RleC1hcmNoaXZlL21hY3Jvcy9sYXRleC9yZXF1aXJlZC9hbXNtYXRoL2Ftc21hdGgucGRmXG5cbi8vXFxuZXdjb21tYW5ke1xcc3Vic3RhY2t9WzFde1xcc3ViYXJyYXl7Y30jMVxcZW5kc3ViYXJyYXl9XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJzdGFja1wiLCBcIlxcXFxiZWdpbntzdWJhcnJheX17Y30jMVxcXFxlbmR7c3ViYXJyYXl9XCIpO1xuXG4vLyBcXGRlZlxcaWZme1xcRE9UU0JcXDtcXExvbmdsZWZ0cmlnaHRhcnJvd1xcO31cbi8vIFxcZGVmXFxpbXBsaWVze1xcRE9UU0JcXDtcXExvbmdyaWdodGFycm93XFw7fVxuLy8gXFxkZWZcXGltcGxpZWRieXtcXERPVFNCXFw7XFxMb25nbGVmdGFycm93XFw7fVxuZGVmaW5lTWFjcm8oXCJcXFxcaWZmXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ2xlZnRyaWdodGFycm93XFxcXDtcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbXBsaWVzXCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ3JpZ2h0YXJyb3dcXFxcO1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltcGxpZWRieVwiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdsZWZ0YXJyb3dcXFxcO1wiKTtcblxuLy8gQU1TTWF0aCdzIGF1dG9tYXRpYyBcXGRvdHMsIGJhc2VkIG9uIFxcbWRvdHNAQCBtYWNyby5cbmNvbnN0IGRvdHNCeVRva2VuID0ge1xuICBcIixcIjogXCJcXFxcZG90c2NcIixcbiAgXCJcXFxcbm90XCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFxca2V5YmluQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gIFwiK1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIj1cIjogXCJcXFxcZG90c2JcIixcbiAgXCI8XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiPlwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIi1cIjogXCJcXFxcZG90c2JcIixcbiAgXCIqXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiOlwiOiBcIlxcXFxkb3RzYlwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTQjpcbiAgXCJcXFxcRE9UU0JcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcY29wcm9kXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3ZlZVwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWd3ZWRnZVwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWd1cGx1c1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdjYXBcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnY3VwXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXHByb2RcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcc3VtXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ290aW1lc1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdvcGx1c1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdvZG90XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3NxY2FwXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3NxY3VwXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3RpbWVzXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXEFuZFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxsb25ncmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxMb25ncmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxsb25nbGVmdGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXExvbmdsZWZ0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcbG9uZ2xlZnRyaWdodGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXExvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxtYXBzdG9cIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcbG9uZ21hcHN0b1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxob29rcmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxkb3RlcVwiOiBcIlxcXFxkb3RzYlwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxtYXRoYmluOlxuICBcIlxcXFxtYXRoYmluXCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXG1hdGhyZWw6XG4gIFwiXFxcXG1hdGhyZWxcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxccmVsYmFyXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXFJlbGJhclwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFx4cmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFx4bGVmdGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNJOlxuICBcIlxcXFxET1RTSVwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpbnRcIjogXCJcXFxcZG90c2lcIixcbiAgXCJcXFxcb2ludFwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXGlpaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXGlpaWludFwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpZG90c2ludFwiOiBcIlxcXFxkb3RzaVwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTWDpcbiAgXCJcXFxcRE9UU1hcIjogXCJcXFxcZG90c3hcIlxufTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIC8vIFRPRE86IElmIHVzZWQgaW4gdGV4dCBtb2RlLCBzaG91bGQgZXhwYW5kIHRvIFxcdGV4dGVsbGlwc2lzLlxuICAvLyBIb3dldmVyLCBpbiBUZW1tbCwgXFx0ZXh0ZWxsaXBzaXMgYW5kIFxcbGRvdHMgYmVoYXZlIHRoZSBzYW1lXG4gIC8vIChpbiB0ZXh0IG1vZGUpLCBhbmQgaXQncyB1bmxpa2VseSB3ZSdkIHNlZSBhbnkgb2YgdGhlIG1hdGggY29tbWFuZHNcbiAgLy8gdGhhdCBhZmZlY3QgdGhlIGJlaGF2aW9yIG9mIFxcZG90cyB3aGVuIGluIHRleHQgbW9kZS4gIFNvIGZpbmUgZm9yIG5vd1xuICAvLyAodW50aWwgd2Ugc3VwcG9ydCBcXGlmbW1vZGUgLi4uIFxcZWxzZSAuLi4gXFxmaSkuXG4gIGxldCB0aGVkb3RzID0gXCJcXFxcZG90c29cIjtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZXhwYW5kQWZ0ZXJGdXR1cmUoKS50ZXh0O1xuICBpZiAobmV4dCBpbiBkb3RzQnlUb2tlbikge1xuICAgIHRoZWRvdHMgPSBkb3RzQnlUb2tlbltuZXh0XTtcbiAgfSBlbHNlIGlmIChuZXh0LnNsaWNlKDAsIDQpID09PSBcIlxcXFxub3RcIikge1xuICAgIHRoZWRvdHMgPSBcIlxcXFxkb3RzYlwiO1xuICB9IGVsc2UgaWYgKG5leHQgaW4gc3ltYm9scy5tYXRoKSB7XG4gICAgaWYgKFtcImJpblwiLCBcInJlbFwiXS5pbmNsdWRlcyhzeW1ib2xzLm1hdGhbbmV4dF0uZ3JvdXApKSB7XG4gICAgICB0aGVkb3RzID0gXCJcXFxcZG90c2JcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoZWRvdHM7XG59KTtcblxuY29uc3Qgc3BhY2VBZnRlckRvdHMgPSB7XG4gIC8vIFxccmlnaHRkZWxpbUAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICBcIilcIjogdHJ1ZSxcbiAgXCJdXCI6IHRydWUsXG4gIFwiXFxcXHJicmFja1wiOiB0cnVlLFxuICBcIlxcXFx9XCI6IHRydWUsXG4gIFwiXFxcXHJicmFjZVwiOiB0cnVlLFxuICBcIlxcXFxyYW5nbGVcIjogdHJ1ZSxcbiAgXCJcXFxccmNlaWxcIjogdHJ1ZSxcbiAgXCJcXFxccmZsb29yXCI6IHRydWUsXG4gIFwiXFxcXHJncm91cFwiOiB0cnVlLFxuICBcIlxcXFxybW91c3RhY2hlXCI6IHRydWUsXG4gIFwiXFxcXHJpZ2h0XCI6IHRydWUsXG4gIFwiXFxcXGJpZ3JcIjogdHJ1ZSxcbiAgXCJcXFxcYmlnZ3JcIjogdHJ1ZSxcbiAgXCJcXFxcQmlnclwiOiB0cnVlLFxuICBcIlxcXFxCaWdnclwiOiB0cnVlLFxuICAvLyBcXGV4dHJhQCBhbHNvIHRlc3RzIGZvciB0aGUgZm9sbG93aW5nOlxuICAkOiB0cnVlLFxuICAvLyBcXGV4dHJhcEAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICBcIjtcIjogdHJ1ZSxcbiAgXCIuXCI6IHRydWUsXG4gIFwiLFwiOiB0cnVlXG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3Rzb1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNjXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcbiAgLy8gXFxkb3RzYyB1c2VzIFxcZXh0cmFAIGJ1dCBub3QgXFxleHRyYXBALCBpbnN0ZWFkIHNwZWNpYWxseSBjaGVja2luZyBmb3JcbiAgLy8gJzsnIGFuZCAnLicsIGJ1dCBkb2Vzbid0IGNoZWNrIGZvciAnLCcuXG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzICYmIG5leHQgIT09IFwiLFwiKSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcIjtcbiAgfVxufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNkb3RzXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXFxcXCxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcXFxcQGNkb3RzXCI7XG4gIH1cbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzYlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNtXCIsIFwiXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2lcIiwgXCJcXFxcIVxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlkb3RzaW50XCIsIFwiXFxcXGRvdHNpXCIpO1xuLy8gYW1zbWF0aCBkb2Vzbid0IGFjdHVhbGx5IGRlZmluZSBcXGRvdHN4LCBidXQgXFxkb3RzIGZvbGxvd2VkIGJ5IGEgbWFjcm9cbi8vIHN0YXJ0aW5nIHdpdGggXFxET1RTWCBpbXBsaWVzIFxcZG90c28sIGFuZCB0aGVuIFxcZXh0cmFAIGRldGVjdHMgdGhpcyBjYXNlXG4vLyBhbmQgZm9yY2VzIHRoZSBhZGRlZCBgXFwsYC5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHN4XCIsIFwiXFxcXGxkb3RzXFxcXCxcIik7XG5cbi8vIFxcbGV0XFxET1RTSVxccmVsYXhcbi8vIFxcbGV0XFxET1RTQlxccmVsYXhcbi8vIFxcbGV0XFxET1RTWFxccmVsYXhcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNJXCIsIFwiXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU0JcIiwgXCJcXFxccmVsYXhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxET1RTWFwiLCBcIlxcXFxyZWxheFwiKTtcblxuLy8gU3BhY2luZywgYmFzZWQgb24gYW1zbWF0aC5zdHkncyBvdmVycmlkZSBvZiBMYVRlWCBkZWZhdWx0c1xuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXHRtc3BhY2V9WzNdeyVcbi8vICAgXFxpZm1tb2RlXFxtc2tpcCMxIzJcXGVsc2VcXGtlcm4jMSMzXFxmaVxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFx0bXNwYWNlXCIsIFwiXFxcXFRleHRPck1hdGh7XFxcXGtlcm4jMSMzfXtcXFxcbXNraXAjMSMyfVxcXFxyZWxheFwiKTtcbi8vIFxccmVuZXdjb21tYW5ke1xcLH17XFx0bXNwYWNlK1xcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuZGVmaW5lTWFjcm8oXCJcXFxcLFwiLCBcIntcXFxcdG1zcGFjZSt7M211fXsuMTY2N2VtfX1cIik7XG4vLyBcXGxldFxcdGhpbnNwYWNlXFwsXG5kZWZpbmVNYWNybyhcIlxcXFx0aGluc3BhY2VcIiwgXCJcXFxcLFwiKTtcbi8vIFxcZGVmXFw+e1xcbXNraXBcXG1lZG11c2tpcH1cbi8vIFxccmVuZXdjb21tYW5ke1xcOn17XFx0bXNwYWNlK1xcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogXFw+IGFuZCBtYXRoIG1vZGUgb2YgXFw6IHNob3VsZCB1c2UgXFxtZWRtdXNraXAgPSA0bXUgcGx1cyAybXUgbWludXMgNG11XG5kZWZpbmVNYWNybyhcIlxcXFw+XCIsIFwiXFxcXG1za2lwezRtdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFw6XCIsIFwie1xcXFx0bXNwYWNlK3s0bXV9ey4yMjIyZW19fVwiKTtcbi8vIFxcbGV0XFxtZWRzcGFjZVxcOlxuZGVmaW5lTWFjcm8oXCJcXFxcbWVkc3BhY2VcIiwgXCJcXFxcOlwiKTtcbi8vIFxccmVuZXdjb21tYW5ke1xcO317XFx0bXNwYWNlK1xcdGhpY2ttdXNraXB7LjI3NzdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaWNrbXVza2lwID0gNW11IHBsdXMgNW11XG5kZWZpbmVNYWNybyhcIlxcXFw7XCIsIFwie1xcXFx0bXNwYWNlK3s1bXV9ey4yNzc3ZW19fVwiKTtcbi8vIFxcbGV0XFx0aGlja3NwYWNlXFw7XG5kZWZpbmVNYWNybyhcIlxcXFx0aGlja3NwYWNlXCIsIFwiXFxcXDtcIik7XG4vLyBcXHJlbmV3Y29tbWFuZHtcXCF9e1xcdG1zcGFjZS1cXHRoaW5tdXNraXB7LjE2NjdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaW5tdXNraXBcbmRlZmluZU1hY3JvKFwiXFxcXCFcIiwgXCJ7XFxcXHRtc3BhY2UtezNtdX17LjE2NjdlbX19XCIpO1xuLy8gXFxsZXRcXG5lZ3RoaW5zcGFjZVxcIVxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpbnNwYWNlXCIsIFwiXFxcXCFcIik7XG4vLyBcXG5ld2NvbW1hbmR7XFxuZWdtZWRzcGFjZX17XFx0bXNwYWNlLVxcbWVkbXVza2lwey4yMjIyZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFxtZWRtdXNraXBcbmRlZmluZU1hY3JvKFwiXFxcXG5lZ21lZHNwYWNlXCIsIFwie1xcXFx0bXNwYWNlLXs0bXV9ey4yMjIyZW19fVwiKTtcbi8vIFxcbmV3Y29tbWFuZHtcXG5lZ3RoaWNrc3BhY2V9e1xcdG1zcGFjZS1cXHRoaWNrbXVza2lwey4yNzc3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlja211c2tpcFxuZGVmaW5lTWFjcm8oXCJcXFxcbmVndGhpY2tzcGFjZVwiLCBcIntcXFxcdG1zcGFjZS17NW11fXsuMjc3ZW19fVwiKTtcbi8vIFxcZGVmXFxlbnNwYWNle1xca2Vybi41ZW0gfVxuZGVmaW5lTWFjcm8oXCJcXFxcZW5zcGFjZVwiLCBcIlxcXFxrZXJuLjVlbSBcIik7XG4vLyBcXGRlZlxcZW5za2lwe1xcaHNraXAuNWVtXFxyZWxheH1cbmRlZmluZU1hY3JvKFwiXFxcXGVuc2tpcFwiLCBcIlxcXFxoc2tpcC41ZW1cXFxccmVsYXhcIik7XG4vLyBcXGRlZlxccXVhZHtcXGhza2lwMWVtXFxyZWxheH1cbmRlZmluZU1hY3JvKFwiXFxcXHF1YWRcIiwgXCJcXFxcaHNraXAxZW1cXFxccmVsYXhcIik7XG4vLyBcXGRlZlxccXF1YWR7XFxoc2tpcDJlbVxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFxxcXVhZFwiLCBcIlxcXFxoc2tpcDJlbVxcXFxyZWxheFwiKTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcQUFcIiwgXCJcXFxcVGV4dE9yTWF0aHtcXFxcQW5nc3Ryb219e1xcXFxtYXRocmluZ3tBfX1cXFxccmVsYXhcIik7XG5cbi8vIFxcdGFnQGluQGRpc3BsYXkgZm9ybSBvZiBcXHRhZ1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnXCIsIFwiXFxcXEBpZnN0YXJcXFxcdGFnQGxpdGVyYWxcXFxcdGFnQHBhcmVuXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQHBhcmVuXCIsIFwiXFxcXHRhZ0BsaXRlcmFseyh7IzF9KX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0YWdAbGl0ZXJhbFwiLCAoY29udGV4dCkgPT4ge1xuICBpZiAoY29udGV4dC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTXVsdGlwbGUgXFxcXHRhZ1wiKTtcbiAgfVxuICByZXR1cm4gXCJcXFxcZ2RlZlxcXFxkZkB0YWd7XFxcXHRleHR7IzF9fVwiO1xufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxub3RhZ1wiLCBcIlxcXFxub251bWJlclwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vbnVtYmVyXCIsIFwiXFxcXGdkZWZcXFxcQGVxbnN3ezB9XCIpO1xuXG4vLyBcXHJlbmV3Y29tbWFuZHtcXGJtb2R9e1xcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXVcXG1hdGhiaW5cbi8vICAge1xcb3BlcmF0b3JAZm9udCBtb2R9XFxwZW5hbHR5OTAwXG4vLyAgIFxcbWtlcm41bXVcXG5vbnNjcmlwdFxcbXNraXAtXFxtZWRtdXNraXB9XG4vLyBcXG5ld2NvbW1hbmR7XFxwb2R9WzFde1xcYWxsb3dicmVha1xuLy8gICBcXGlmQGRpc3BsYXlcXG1rZXJuMThtdVxcZWxzZVxcbWtlcm44bXVcXGZpKCMxKX1cbi8vIFxccmVuZXdjb21tYW5ke1xccG1vZH1bMV17XFxwb2R7e1xcb3BlcmF0b3JAZm9udCBtb2R9XFxta2VybjZtdSMxfX1cbi8vIFxcbmV3Y29tbWFuZHtcXG1vZH1bMV17XFxhbGxvd2JyZWFrXFxpZkBkaXNwbGF5XFxta2VybjE4bXVcbi8vICAgXFxlbHNlXFxta2VybjEybXVcXGZpe1xcb3BlcmF0b3JAZm9udCBtb2R9XFwsXFwsIzF9XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcbmRlZmluZU1hY3JvKFwiXFxcXGJtb2RcIiwgXCJcXFxcbWF0aGJpbntcXFxcdGV4dHttb2R9fVwiKTtcbmRlZmluZU1hY3JvKFxuICBcIlxcXFxwb2RcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiICsgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4xOG11fXtcXFxcbWtlcm44bXV9e1xcXFxta2VybjhtdX17XFxcXG1rZXJuOG11fSgjMSlcIlxuKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBtb2RcIiwgXCJcXFxccG9ke3tcXFxccm0gbW9kfVxcXFxta2VybjZtdSMxfVwiKTtcbmRlZmluZU1hY3JvKFxuICBcIlxcXFxtb2RcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiICtcbiAgICBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2VybjE4bXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9e1xcXFxta2VybjEybXV9XCIgK1xuICAgIFwie1xcXFxybSBtb2R9XFxcXCxcXFxcLCMxXCJcbik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExhVGVYIHNvdXJjZTJlXG5cbi8vIFxcZXhwYW5kYWZ0ZXJcXGxldFxcZXhwYW5kYWZ0ZXJcXEBub3JtYWxjclxuLy8gICAgIFxcY3NuYW1lXFxleHBhbmRhZnRlclxcQGdvYmJsZVxcc3RyaW5nXFxcXCBcXGVuZGNzbmFtZVxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcbmV3bGluZXtcXEBub3JtYWxjclxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFxuZXdsaW5lXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG5cbi8vIFxcZGVmXFxUZVh7VFxca2Vybi0uMTY2N2VtXFxsb3dlci41ZXhcXGhib3h7RX1cXGtlcm4tLjEyNWVtWFxcQH1cbi8vIFRPRE86IERvZXNuJ3Qgbm9ybWFsbHkgd29yayBpbiBtYXRoIG1vZGUgYmVjYXVzZSBcXEAgZmFpbHMuXG5kZWZpbmVNYWNybyhcIlxcXFxUZVhcIiwgXCJcXFxcdGV4dHJte1R9XFxcXGtlcm4tLjE2NjdlbVxcXFxyYWlzZWJveHstLjVleH17RX1cXFxca2Vybi0uMTI1ZW1cXFxcdGV4dHJte1h9XCIpO1xuXG5kZWZpbmVNYWNybyhcbiAgXCJcXFxcTGFUZVhcIixcbiAgICBcIlxcXFx0ZXh0cm17TH1cXFxca2Vybi0uMzVlbVxcXFxyYWlzZWJveHswLjJlbX17XFxcXHNjcmlwdHN0eWxlIEF9XFxcXGtlcm4tLjE1ZW1cXFxcVGVYXCJcbik7XG5cbmRlZmluZU1hY3JvKFxuICBcIlxcXFxUZW1tbFwiLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBcIlxcXFx0ZXh0cm17VH1cXFxca2Vybi0wLjJlbVxcXFxsb3dlcnswLjJlbX17XFxcXHRleHRybXtFfX1cXFxca2Vybi0wLjA4ZW17XFxcXHRleHRybXtNfVxcXFxrZXJuLTAuMDhlbVxcXFxyYWlzZXswLjJlbX1cXFxcdGV4dHJte019XFxcXGtlcm4tMC4wOGVtXFxcXHRleHRybXtMfX1cIlxuKTtcblxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcaHNwYWNle1xcQGlmc3RhclxcQGhzcGFjZXJcXEBoc3BhY2V9XG4vLyBcXGRlZlxcQGhzcGFjZSMxe1xcaHNraXAgICMxXFxyZWxheH1cbi8vIFxcZGVmXFxAaHNwYWNlciMxe1xcdnJ1bGUgXFxAd2lkdGhcXHpAXFxub2JyZWFrXG4vLyAgICAgICAgICAgICAgICAgXFxoc2tpcCAjMVxcaHNraXAgXFx6QHNraXB9XG5kZWZpbmVNYWNybyhcIlxcXFxoc3BhY2VcIiwgXCJcXFxcQGlmc3RhclxcXFxAaHNwYWNlclxcXFxAaHNwYWNlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZVwiLCBcIlxcXFxoc2tpcCAjMVxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEBoc3BhY2VyXCIsIFwiXFxcXHJ1bGV7MHB0fXswcHR9XFxcXGhza2lwICMxXFxcXHJlbGF4XCIpO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvblwiLCBgXFxcXG1hdGhwdW5jdHtcXFxcY2hhclwiM2F9YCk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIG1hdGh0b29scy5zdHlcblxuZGVmaW5lTWFjcm8oXCJcXFxccHJlc2NyaXB0XCIsIFwiXFxcXHByZXNAY3JpcHR7X3sjMX1eeyMyfX17fXsjM31cIik7XG5cbi8vXFxwcm92aWRlY29tbWFuZFxcb3JkaW5hcnljb2xvbns6fVxuZGVmaW5lTWFjcm8oXCJcXFxcb3JkaW5hcnljb2xvblwiLCBgXFxcXGNoYXJcIjNhYCk7XG4vLyBSYWlzZSB0byBjZW50ZXIgb24gdGhlIG1hdGggYXhpcywgYXMgY2xvc2VseSBhcyBwb3NzaWJsZS5cbmRlZmluZU1hY3JvKFwiXFxcXHZjZW50Y29sb25cIiwgXCJcXFxcbWF0aHJlbHtcXFxccmFpc2Vib3h7MC4wMzVlbX17XFxcXG9yZGluYXJ5Y29sb259fVwiKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbmVxe1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcbWF0aHJlbHstfX1cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uZXFcIiwgJ1xcXFxtYXRocmVse1xcXFxyYWlzZWJveHswLjAzNWVtfXtcXFxcb3JkaW5hcnljb2xvbn1cXFxcY2hhclwiMjIxMn0nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbmVxe1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXG1hdGhyZWx7LX19XG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmVxXCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjIzN1xcXFxjaGFyXCIyMjEyfScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxcWNvbG9uez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuZGVmaW5lTWFjcm8oXCJcXFxcRXFxY29sb25cIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIzZFxcXFxjaGFyXCIyMjM3fScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXEVxY29sb257XFxtYXRocmVsey19XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn1cbmRlZmluZU1hY3JvKFwiXFxcXEVxY29sb25cIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIyMjEyXFxcXGNoYXJcIjIyMzd9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25hcHByb3h7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmFwcHJveFwiLCAnXFxcXG1hdGhyZWx7XFxcXHJhaXNlYm94ezAuMDM1ZW19e1xcXFxvcmRpbmFyeWNvbG9ufVxcXFxjaGFyXCIyMjQ4fScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uYXBwcm94e1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGFwcHJveH1cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uYXBwcm94XCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjIzN1xcXFxjaGFyXCIyMjQ4fScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uc2lte1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcc2ltfVxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25zaW1cIiwgJ1xcXFxtYXRocmVse1xcXFxyYWlzZWJveHswLjAzNWVtfXtcXFxcb3JkaW5hcnljb2xvbn1cXFxcY2hhclwiMjIzY30nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbnNpbXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbnNpbVwiLCAnXFxcXG1hdGhyZWx7XFxcXHJhaXNlYm94ezAuMDM1ZW19e1xcXFxvcmRpbmFyeWNvbG9ufVxcXFxjaGFyXCIyMjNjfScpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjb2xvbmVxdWFscy5zdHlcblxuLy8gQWx0ZXJuYXRlIG5hbWVzIGZvciBtYXRodG9vbHMncyBtYWNyb3M6XG5kZWZpbmVNYWNybyhcIlxcXFxyYXRpb1wiLCBcIlxcXFx2Y2VudGNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvblwiLCBcIlxcXFxkYmxjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uZXF1YWxzXCIsIFwiXFxcXGNvbG9uZXFxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmVxdWFsc1wiLCBcIlxcXFxDb2xvbmVxcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVxdWFsc2NvbG9uXCIsIFwiXFxcXGVxcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXF1YWxzY29sb25jb2xvblwiLCBcIlxcXFxFcXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9ubWludXNcIiwgXCJcXFxcY29sb25lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25taW51c1wiLCBcIlxcXFxDb2xvbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludXNjb2xvblwiLCBcIlxcXFxlcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWludXNjb2xvbmNvbG9uXCIsIFwiXFxcXEVxY29sb25cIik7XG4vLyBcXGNvbG9uYXBwcm94IG5hbWUgaXMgc2FtZSBpbiBtYXRodG9vbHMgYW5kIGNvbG9uZXF1YWxzLlxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbmFwcHJveFwiLCBcIlxcXFxDb2xvbmFwcHJveFwiKTtcbi8vIFxcY29sb25zaW0gbmFtZSBpcyBzYW1lIGluIG1hdGh0b29scyBhbmQgY29sb25lcXVhbHMuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uc2ltXCIsIFwiXFxcXENvbG9uc2ltXCIpO1xuXG4vLyBQcmVzZW50IGluIG5ld3R4bWF0aCwgcHhmb250cyBhbmQgdHhmb250c1xuZGVmaW5lTWFjcm8oXCJcXFxcbm90bmlcIiwgXCJcXFxcbWF0aHJlbHtcXFxcY2hhcmBcXHUyMjBDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsc3VwfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxpbWluZlwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2xpbVxcXFwsaW5mfVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRnJvbSBhbXNvcG4uc3R5XG5kZWZpbmVNYWNybyhcIlxcXFxpbmpsaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntpbmpcXFxcLGxpbX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwcm9qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7cHJvalxcXFwsbGltfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmxpbXN1cFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFxvdmVybGluZXtcXFxcdGV4dHtsaW19fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJsaW1pbmZcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJsaW5le1xcXFx0ZXh0e2xpbX19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmluamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFx1bmRlcnJpZ2h0YXJyb3d7XFxcXHRleHR7bGltfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFycHJvamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFx1bmRlcmxlZnRhcnJvd3tcXFxcdGV4dHtsaW19fX1cIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNlbnRlcmRvdFwiLCBcIntcXFxcbWVkc3BhY2VcXFxccnVsZXswLjE2N2VtfXswLjE4OWVtfVxcXFxtZWRzcGFjZX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHN0YXRtYXRoLnN0eVxuLy8gaHR0cHM6Ly9jdGFuLm1hdGguaWxsaW5vaXMuZWR1L21hY3Jvcy9sYXRleC9jb250cmliL3N0YXRtYXRoL3N0YXRtYXRoLnBkZlxuXG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtaW5cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1pbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhcmdtYXhcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKnthcmdcXFxcLG1heH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7cGxpbX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIE1uU3ltYm9sLnN0eVxuXG5kZWZpbmVNYWNybyhcIlxcXFxsZWZ0bW9kZWxzXCIsIFwiXFxcXG1hdGhvcHtcXFxccmVmbGVjdGJveHskXFxcXG1vZGVscyR9fVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYnJha2V0LnN0eVxuLy8gaHR0cDovL2N0YW4ubWF0aC53YXNoaW5ndG9uLmVkdS90ZXgtYXJjaGl2ZS9tYWNyb3MvbGF0ZXgvY29udHJpYi9icmFrZXQvYnJha2V0LnBkZlxuXG5kZWZpbmVNYWNybyhcIlxcXFxicmFcIiwgXCJcXFxcbWF0aGlubmVye1xcXFxsYW5nbGV7IzF9fH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxrZXRcIiwgXCJcXFxcbWF0aGlubmVye3x7IzF9XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxicmFrZXRcIiwgXCJcXFxcbWF0aGlubmVye1xcXFxsYW5nbGV7IzF9XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxCcmFcIiwgXCJcXFxcbGVmdFxcXFxsYW5nbGUjMVxcXFxyaWdodHxcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxLZXRcIiwgXCJcXFxcbGVmdHwjMVxcXFxyaWdodFxcXFxyYW5nbGVcIik7XG4vLyBBIGhlbHBlciBmb3IgXFxCcmFrZXQgYW5kIFxcU2V0XG5jb25zdCByZXBsYWNlVmVydCA9IChhcmdTdHIsIG1hdGNoKSA9PiB7XG4gIGNvbnN0IGNoID0gbWF0Y2hbMF0gPT09IFwifFwiID8gXCJcXFxcdmVydFwiIDogXCJcXFxcVmVydFwiO1xuICBjb25zdCByZXBsYWNlU3RyID0gYH1cXFxcLFxcXFxtaWRkbGUke2NofVxcXFwse2A7XG4gIHJldHVybiBhcmdTdHIuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgcmVwbGFjZVN0ciArIGFyZ1N0ci5zbGljZShtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aClcbn07XG5kZWZpbmVNYWNybyhcIlxcXFxCcmFrZXRcIiwgIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgbGV0IGFyZ1N0ciA9IHJlY3JlYXRlQXJnU3RyKGNvbnRleHQpO1xuICBjb25zdCByZWdFeCA9IC9cXHxcXHx8XFx8fFxcXFxcXHwvZztcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gcmVnRXguZXhlYyhhcmdTdHIpKSAhPT0gbnVsbCkge1xuICAgIGFyZ1N0ciA9IHJlcGxhY2VWZXJ0KGFyZ1N0ciwgbWF0Y2gpO1xuICB9XG4gIHJldHVybiBcIlxcXFxsZWZ0XFxcXGxhbmdsZXtcIiArIGFyZ1N0ciArIFwifVxcXFxyaWdodFxcXFxyYW5nbGVcIlxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxTZXRcIiwgIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgbGV0IGFyZ1N0ciA9IHJlY3JlYXRlQXJnU3RyKGNvbnRleHQpO1xuICBjb25zdCBtYXRjaCA9IC9cXHxcXHx8XFx8fFxcXFxcXHwvLmV4ZWMoYXJnU3RyKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgYXJnU3RyID0gcmVwbGFjZVZlcnQoYXJnU3RyLCBtYXRjaCk7XG4gIH1cbiAgcmV0dXJuIFwiXFxcXGxlZnRcXFxce1xcXFw6e1wiICsgYXJnU3RyICsgXCJ9XFxcXDpcXFxccmlnaHRcXFxcfVwiXG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXHNldFwiLCAgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdTdHIgPSByZWNyZWF0ZUFyZ1N0cihjb250ZXh0KTtcbiAgcmV0dXJuIFwiXFxcXHt7XCIgKyBhcmdTdHIucmVwbGFjZSgvXFx8LywgXCJ9XFxcXG1pZHtcIikgKyBcIn1cXFxcfVwiXG59KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYWN0dWFyaWFsYW5nbGUuZHR4XG5kZWZpbmVNYWNybyhcIlxcXFxhbmdsblwiLCBcIntcXFxcYW5nbCBufVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gZGVyaXZhdGl2ZS5zdHlcbmRlZmluZU1hY3JvKFwiXFxcXG9kdlwiLCBcIlxcXFxAaWZzdGFyXFxcXG9kdkBuZXh0XFxcXG9kdkBudW1lcmF0b3JcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxvZHZAbnVtZXJhdG9yXCIsIFwiXFxcXGZyYWN7XFxcXG1hdGhybXtkfSMxfXtcXFxcbWF0aHJte2R9IzJ9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb2R2QG5leHRcIiwgXCJcXFxcZnJhY3tcXFxcbWF0aHJte2R9fXtcXFxcbWF0aHJte2R9IzJ9IzFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwZHZcIiwgXCJcXFxcQGlmc3RhclxcXFxwZHZAbmV4dFxcXFxwZHZAbnVtZXJhdG9yXCIpO1xuXG5jb25zdCBwZHZIZWxwZXIgPSBhcmdzID0+IHtcbiAgY29uc3QgbnVtZXJhdG9yID0gYXJnc1swXVswXS50ZXh0O1xuICBjb25zdCBkZW5vbXMgPSBzdHJpbmdGcm9tQXJnKGFyZ3NbMV0pLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgcG93ZXIgPSBTdHJpbmcoZGVub21zLmxlbmd0aCk7XG4gIGNvbnN0IG51bU9wID0gcG93ZXIgPT09IFwiMVwiID8gXCJcXFxccGFydGlhbFwiIDogYFxcXFxwYXJ0aWFsXiR7cG93ZXJ9YDtcbiAgbGV0IGRlbm9taW5hdG9yID0gXCJcIjtcbiAgZGVub21zLm1hcChlID0+IHsgZGVub21pbmF0b3IgKz0gXCJcXFxccGFydGlhbCBcIiArIGUudHJpbSgpICsgIFwiXFxcXCxcIjt9KTtcbiAgcmV0dXJuIFtudW1lcmF0b3IsIG51bU9wLCAgZGVub21pbmF0b3IucmVwbGFjZSgvXFxcXCwkLywgXCJcIildXG59O1xuZGVmaW5lTWFjcm8oXCJcXFxccGR2QG51bWVyYXRvclwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IFtudW1lcmF0b3IsIG51bU9wLCBkZW5vbWluYXRvcl0gPSBwZHZIZWxwZXIoY29udGV4dC5jb25zdW1lQXJncygyKSk7XG4gIHJldHVybiBgXFxcXGZyYWN7JHtudW1PcH0gJHtudW1lcmF0b3J9fXske2Rlbm9taW5hdG9yfX1gXG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXHBkdkBuZXh0XCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgW251bWVyYXRvciwgbnVtT3AsIGRlbm9taW5hdG9yXSA9IHBkdkhlbHBlcihjb250ZXh0LmNvbnN1bWVBcmdzKDIpKTtcbiAgcmV0dXJuIGBcXFxcZnJhY3ske251bU9wfX17JHtkZW5vbWluYXRvcn19ICR7bnVtZXJhdG9yfWBcbn0pO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB1cGdyZWVrLmR0eFxuZGVmaW5lTWFjcm8oXCJcXFxcdXBhbHBoYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcYWxwaGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBiZXRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxiZXRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwZ2FtbWFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGdhbW1hfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwZGVsdGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGRlbHRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwZXBzaWxvblwiLCBcIlxcXFx1cEBncmVla3tcXFxcZXBzaWxvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHpldGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHpldGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBldGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHRoZXRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFx0aGV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGlvdGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGlvdGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBrYXBwYVwiLCBcIlxcXFx1cEBncmVla3tcXFxca2FwcGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBsYW1iZGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGxhbWJkYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG11XCIsIFwiXFxcXHVwQGdyZWVre1xcXFxtdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG51XCIsIFwiXFxcXHVwQGdyZWVre1xcXFxudX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHhpXCIsIFwiXFxcXHVwQGdyZWVre1xcXFx4aX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG9taWNyb25cIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXG9taWNyb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBwaVwiLCBcIlxcXFx1cEBncmVla3tcXFxccGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBhbHBoYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcYWxwaGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXByaG9cIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHJob31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHNpZ21hXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxzaWdtYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHRhdVwiLCBcIlxcXFx1cEBncmVla3tcXFxcdGF1fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwdXBzaWxvblwiLCBcIlxcXFx1cEBncmVla3tcXFxcdXBzaWxvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHBoaVwiLCBcIlxcXFx1cEBncmVla3tcXFxccGhpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwY2hpXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxjaGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBwc2lcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHBzaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cG9tZWdhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxvbWVnYX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNtbGwgcGFja2FnZVxuZGVmaW5lTWFjcm8oXCJcXFxcaW52YW1wXCIsICdcXFxcbWF0aGJpbntcXFxcY2hhclwiMjE0Yn0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBhcnJcIiwgJ1xcXFxtYXRoYmlue1xcXFxjaGFyXCIyMTRifScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcd2l0aFwiLCAnXFxcXG1hdGhiaW57XFxcXGNoYXJcIjI2fScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbXVsdGltYXBpbnZcIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIyN2RjfScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbXVsdGltYXBib3RoXCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjlkZn0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNjb2hcIiwgJ3tcXFxcbWtlcm41bXVcXFxcY2hhclwiMjMyMlxcXFxta2VybjVtdX0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNpbmNvaFwiLCAne1xcXFxta2VybjVtdVxcXFxjaGFyXCIyMzIzXFxcXG1rZXJuNW11fScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29oXCIsIGB7XFxcXG1rZXJuNW11XFxcXHJ1bGV7fXswLjdlbX1cXFxcbWF0aHJsYXB7XFxcXHNtYXNoe1xcXFxyYWlzZTJtdXtcXFxcY2hhclwiMjMyMn19fVxue1xcXFxzbWFzaHtcXFxcbG93ZXI0bXV7XFxcXGNoYXJcIjIzMjN9fX1cXFxcbWtlcm41bXV9YCk7XG5kZWZpbmVNYWNybyhcIlxcXFxpbmNvaFwiLCBge1xcXFxta2VybjVtdVxcXFxydWxle317MC43ZW19XFxcXG1hdGhybGFwe1xcXFxzbWFzaHtcXFxccmFpc2UybXV7XFxcXGNoYXJcIjIzMjN9fX1cbntcXFxcc21hc2h7XFxcXGxvd2VyNG11e1xcXFxjaGFyXCIyMzIyfX19XFxcXG1rZXJuNW11fWApO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNoZW1zdHlsZSBwYWNrYWdlXG5kZWZpbmVNYWNybyhcIlxcXFxzdGFuZGFyZHN0YXRlXCIsIFwiXFxcXHRleHR7XFxcXHRpbnlcXFxcY2hhcmDiprV9XCIpO1xuXG7vu78vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyogLSotIE1vZGU6IEphdmFTY3JpcHQ7IGluZGVudC10YWJzLW1vZGU6bmlsOyBqcy1pbmRlbnQtbGV2ZWw6IDIgLSotICovXG4vKiB2aW06IHNldCB0cz0yIGV0IHN3PTIgdHc9ODA6ICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogIFRlbW1sIG1oY2hlbS5qc1xuICpcbiAqICBUaGlzIGZpbGUgaW1wbGVtZW50cyBhIFRlbW1sIHZlcnNpb24gb2YgbWhjaGVtIHZlcnNpb24gMy4zLjAuXG4gKiAgSXQgaXMgYWRhcHRlZCBmcm9tIE1hdGhKYXgvZXh0ZW5zaW9ucy9UZVgvbWhjaGVtLmpzXG4gKiAgSXQgZGlmZmVycyBmcm9tIHRoZSBNYXRoSmF4IHZlcnNpb24gYXMgZm9sbG93czpcbiAqICAgIDEuIFRoZSBpbnRlcmZhY2UgaXMgY2hhbmdlZCBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBUZW1tbCwgbm90IE1hdGhKYXguXG4gKiAgICAyLiBcXHJsYXAgYW5kIFxcbGxhcCBhcmUgcmVwbGFjZWQgd2l0aCBcXG1hdGhybGFwIGFuZCBcXG1hdGhsbGFwLlxuICogICAgMy4gVGhlIHJlYWN0aW9uIGFycm93IGNvZGUgaXMgc2ltcGxpZmllZC4gQWxsIHJlYWN0aW9uIGFycm93cyBhcmUgcmVuZGVyZWRcbiAqICAgICAgIHVzaW5nIFRlbW1sIGV4dGVuc2libGUgYXJyb3dzIGluc3RlYWQgb2YgYnVpbGRpbmcgbm9uLWV4dGVuc2libGUgYXJyb3dzLlxuICogICAgNC4gVGhlIH5ib25kIGZvcm1zIGFyZSBjb21wb3NlZCBlbnRpcmVseSBvZiBcXHJ1bGUgZWxlbWVudHMuXG4gKiAgICA1LiBUd28gZGFzaGVzIGluIF9nZXRCb25kIGFyZSB3cmFwcGVkIGluIGJyYWNlcyB0byBzdXBwcmVzcyBzcGFjaW5nLiBpLmUuLCB7LX1cbiAqICAgIDYuIFRoZSBlbGVjdHJvbiBkb3QgdXNlcyBcXHRleHRidWxsZXQgaW5zdGVhZCBvZiBcXGJ1bGxldC5cbiAqICAgIDcuIFxcc21hc2hbVF0gaGFzIGJlZW4gcmVtb3ZlZC4gKFdlYktpdCBoaWRlcyBhbnl0aGluZyBpbnNpZGUgXFxzbWFzaHvigKZ9KVxuICpcbiAqICAgIFRoaXMgY29kZSwgYXMgb3RoZXIgVGVtbWwgY29kZSwgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogXG4gKiAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcbiAqICBNYXRoSmF4L2V4dGVuc2lvbnMvVGVYL21oY2hlbS5qc1xuICpcbiAqICBJbXBsZW1lbnRzIHRoZSBcXGNlIGNvbW1hbmQgZm9yIGhhbmRsaW5nIGNoZW1pY2FsIGZvcm11bGFzXG4gKiAgZnJvbSB0aGUgbWhjaGVtIExhVGVYIHBhY2thZ2UuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNSBUaGUgTWF0aEpheCBDb25zb3J0aXVtXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE1LTIwMTggTWFydGluIEhlbnNlbFxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vL1xuLy8gQ29kaW5nIFN0eWxlXG4vLyAgIC0gdXNlICcnIGZvciBpZGVudGlmaWVycyB0aGF0IGNhbiBieSBtaW5pZmllZC91Z2xpZmllZFxuLy8gICAtIHVzZSBcIlwiIGZvciBzdHJpbmdzIHRoYXQgbmVlZCB0byBzdGF5IHVudG91Y2hlZFxuXG4vLyB2ZXJzaW9uOiBcIjMuMy4wXCIgZm9yIE1hdGhKYXggYW5kIFRlbW1sXG5cblxuLy8gQWRkIFxcY2UsIFxccHUsIGFuZCBcXHRyaXBsZURhc2ggdG8gdGhlIFRlbW1sIG1hY3Jvcy5cblxuZGVmaW5lTWFjcm8oXCJcXFxcY2VcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gY2hlbVBhcnNlKGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF0sIFwiY2VcIilcbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxwdVwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBjaGVtUGFyc2UoY29udGV4dC5jb25zdW1lQXJncygxKVswXSwgXCJwdVwiKTtcbn0pO1xuXG4vLyBNYXRoIGZvbnRzIGRvIG5vdCBpbmNsdWRlIGdseXBocyBmb3IgdGhlIH4gZm9ybSBvZiBib25kcy4gU28gd2UnbGwgc2VuZCBwYXRoIGdlb21ldHJ5XG4vLyBTbyB3ZSdsbCBjb21wb3NlIGNoYXJhY3RlcnMgYnVpbHQgZnJvbSBcXHJ1bGUgZWxlbWVudHMuXG5kZWZpbmVNYWNybyhcIlxcXFx1bmlEYXNoXCIsIGB7XFxcXHJ1bGV7MC42NzJlbX17MC4wNmVtfX1gKVxuZGVmaW5lTWFjcm8oXCJcXFxcdHJpRGFzaFwiLCBge1xcXFxydWxlezAuMTVlbX17MC4wNmVtfVxcXFxrZXJuMm11XFxcXHJ1bGV7MC4xNWVtfXswLjA2ZW19XFxcXGtlcm4ybXVcXFxccnVsZXswLjE1ZW19ezAuMDZlbX19YClcbmRlZmluZU1hY3JvKFwiXFxcXHRyaXBsZURhc2hcIiwgYFxcXFxrZXJuMC4wNzVlbVxcXFxyYWlzZTAuMjVlbXtcXFxcdHJpRGFzaH1cXFxca2VybjAuMDc1ZW1gKVxuZGVmaW5lTWFjcm8oXCJcXFxcdHJpcGxlRGFzaE92ZXJMaW5lXCIsIGBcXFxca2VybjAuMDc1ZW1cXFxcbWF0aHJsYXB7XFxcXHJhaXNlMC4xMjVlbXtcXFxcdW5pRGFzaH19XFxcXHJhaXNlMC4zNGVte1xcXFx0cmlEYXNofVxcXFxrZXJuMC4wNzVlbWApXG5kZWZpbmVNYWNybyhcIlxcXFx0cmlwbGVEYXNoT3ZlckRvdWJsZUxpbmVcIiwgYFxcXFxrZXJuMC4wNzVlbVxcXFxtYXRocmxhcHtcXFxcbWF0aHJsYXB7XFxcXHJhaXNlMC40OGVte1xcXFx0cmlEYXNofX1cXFxccmFpc2UwLjI3ZW17XFxcXHVuaURhc2h9fXtcXFxccmFpc2UwLjA1ZW17XFxcXHVuaURhc2h9fVxcXFxrZXJuMC4wNzVlbWApXG5kZWZpbmVNYWNybyhcIlxcXFx0cmlwbGVEYXNoQmV0d2VlbkRvdWJsZUxpbmVcIiwgYFxcXFxrZXJuMC4wNzVlbVxcXFxtYXRocmxhcHtcXFxcbWF0aHJsYXB7XFxcXHJhaXNlMC40OGVte1xcXFx1bmlEYXNofX1cXFxccmFpc2UwLjI3ZW17XFxcXHRyaURhc2h9fXtcXFxccmFpc2UwLjA1ZW17XFxcXHVuaURhc2h9fVxcXFxrZXJuMC4wNzVlbWApXG5cbiAgLy9cbiAgLy8gIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIGhhbmRpbmcgdGhlIFxcY2UgYW5kIFxccHUgY29tbWFuZHMuXG4gIC8vICBJdCB0YWtlcyB0aGUgYXJndW1lbnQgdG8gXFxjZSBvciBcXHB1IGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIFRlWCBzdHJpbmcuXG4gIC8vXG5cbiAgdmFyIGNoZW1QYXJzZSA9IGZ1bmN0aW9uICh0b2tlbnMsIHN0YXRlTWFjaGluZSkge1xuICAgIC8vIFJlY3JlYXRlIHRoZSBhcmd1bWVudCBzdHJpbmcgZnJvbSBUZW1tbCdzIGFycmF5IG9mIHRva2Vucy5cbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgZXhwZWN0ZWRMb2MgPSB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ubG9jLnN0YXJ0XG4gICAgZm9yICh2YXIgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYodG9rZW5zW2ldLmxvYy5zdGFydCA+IGV4cGVjdGVkTG9jKSB7XG4gICAgICAgIC8vIGNvbnRleHQuY29uc3VtZUFyZ3MgaGFzIGVhdGVuIGEgc3BhY2UuXG4gICAgICAgIHN0ciArPSBcIiBcIjtcbiAgICAgICAgZXhwZWN0ZWRMb2MgPSB0b2tlbnNbaV0ubG9jLnN0YXJ0O1xuICAgICAgfVxuICAgICAgc3RyICs9IHRva2Vuc1tpXS50ZXh0O1xuICAgICAgZXhwZWN0ZWRMb2MgKz0gdG9rZW5zW2ldLnRleHQubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBDYWxsIHRoZSBtaGNoZW0gY29yZSBwYXJzZXIuXG4gICAgdmFyIHRleCA9IHRleGlmeS5nbyhtaGNoZW1QYXJzZXIuZ28oc3RyLCBzdGF0ZU1hY2hpbmUpKTtcbiAgICByZXR1cm4gdGV4O1xuICB9O1xuXG4gIC8vXG4gIC8vIENvcmUgcGFyc2VyIGZvciBtaGNoZW0gc3ludGF4ICAocmVjdXJzaXZlKVxuICAvL1xuICAvKiogQHR5cGUge01oY2hlbVBhcnNlcn0gKi9cbiAgdmFyIG1oY2hlbVBhcnNlciA9IHtcbiAgICAvL1xuICAgIC8vIFBhcnNlcyBtY2hlbSBcXGNlIHN5bnRheFxuICAgIC8vXG4gICAgLy8gQ2FsbCBsaWtlXG4gICAgLy8gICBnbyhcIkgyT1wiKTtcbiAgICAvL1xuICAgIGdvOiBmdW5jdGlvbiAoaW5wdXQsIHN0YXRlTWFjaGluZSkge1xuICAgICAgaWYgKCFpbnB1dCkgeyByZXR1cm4gW107IH1cbiAgICAgIGlmIChzdGF0ZU1hY2hpbmUgPT09IHVuZGVmaW5lZCkgeyBzdGF0ZU1hY2hpbmUgPSAnY2UnOyB9XG4gICAgICB2YXIgc3RhdGUgPSAnMCc7XG5cbiAgICAgIC8vXG4gICAgICAvLyBTdHJpbmcgYnVmZmVycyBmb3IgcGFyc2luZzpcbiAgICAgIC8vXG4gICAgICAvLyBidWZmZXIuYSA9PSBhbW91bnRcbiAgICAgIC8vIGJ1ZmZlci5vID09IGVsZW1lbnRcbiAgICAgIC8vIGJ1ZmZlci5iID09IGxlZnQtc2lkZSBzdXBlcnNjcmlwdFxuICAgICAgLy8gYnVmZmVyLnAgPT0gbGVmdC1zaWRlIHN1YnNjcmlwdFxuICAgICAgLy8gYnVmZmVyLnEgPT0gcmlnaHQtc2lkZSBzdWJzY3JpcHRcbiAgICAgIC8vIGJ1ZmZlci5kID09IHJpZ2h0LXNpZGUgc3VwZXJzY3JpcHRcbiAgICAgIC8vXG4gICAgICAvLyBidWZmZXIuciA9PSBhcnJvd1xuICAgICAgLy8gYnVmZmVyLnJkdCA9PSBhcnJvdywgc2NyaXB0IGFib3ZlLCB0eXBlXG4gICAgICAvLyBidWZmZXIucmQgPT0gYXJyb3csIHNjcmlwdCBhYm92ZSwgY29udGVudFxuICAgICAgLy8gYnVmZmVyLnJxdCA9PSBhcnJvdywgc2NyaXB0IGJlbG93LCB0eXBlXG4gICAgICAvLyBidWZmZXIucnEgPT0gYXJyb3csIHNjcmlwdCBiZWxvdywgY29udGVudFxuICAgICAgLy9cbiAgICAgIC8vIGJ1ZmZlci50ZXh0X1xuICAgICAgLy8gYnVmZmVyLnJtXG4gICAgICAvLyBldGMuXG4gICAgICAvL1xuICAgICAgLy8gYnVmZmVyLnBhcmVudGhlc2lzTGV2ZWwgPT0gaW50LCBzdGFydGluZyBhdCAwXG4gICAgICAvLyBidWZmZXIuc2IgPT0gYm9vbCwgc3BhY2UgYmVmb3JlXG4gICAgICAvLyBidWZmZXIuYmVnaW5zV2l0aEJvbmQgPT0gYm9vbFxuICAgICAgLy9cbiAgICAgIC8vIFRoZXNlIGxldHRlcnMgYXJlIGFsc28gdXNlZCBhcyBzdGF0ZSBuYW1lcy5cbiAgICAgIC8vXG4gICAgICAvLyBPdGhlciBzdGF0ZXM6XG4gICAgICAvLyAwID09IGJlZ2luIG9mIG1haW4gcGFydCAoYXJyb3cvb3BlcmF0b3IgdW5saWtlbHkpXG4gICAgICAvLyAxID09IG5leHQgZW50aXR5XG4gICAgICAvLyAyID09IG5leHQgZW50aXR5IChhcnJvdy9vcGVyYXRvciB1bmxpa2VseSlcbiAgICAgIC8vIDMgPT0gbmV4dCBhdG9tXG4gICAgICAvLyBjID09IG1hY3JvXG4gICAgICAvL1xuICAgICAgLyoqIEB0eXBlIHtCdWZmZXJ9ICovXG4gICAgICB2YXIgYnVmZmVyID0ge307XG4gICAgICBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXSA9IDA7XG5cbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvXFxuL2csIFwiIFwiKTtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW1xcdTIyMTJcXHUyMDEzXFx1MjAxNFxcdTIwMTBdL2csIFwiLVwiKTtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSgvW1xcdTIwMjZdL2csIFwiLi4uXCIpO1xuXG4gICAgICAvL1xuICAgICAgLy8gTG9va3MgdGhyb3VnaCBtaGNoZW1QYXJzZXIudHJhbnNpdGlvbnMsIHRvIGV4ZWN1dGUgYSBtYXRjaGluZyBhY3Rpb25cbiAgICAgIC8vIChyZWN1cnNpdmUpXG4gICAgICAvL1xuICAgICAgdmFyIGxhc3RJbnB1dDtcbiAgICAgIHZhciB3YXRjaGRvZyA9IDEwO1xuICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChsYXN0SW5wdXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgd2F0Y2hkb2cgPSAxMDtcbiAgICAgICAgICBsYXN0SW5wdXQgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXRjaGRvZy0tO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEZpbmQgYWN0aW9ucyBpbiB0cmFuc2l0aW9uIHRhYmxlXG4gICAgICAgIC8vXG4gICAgICAgIHZhciBtYWNoaW5lID0gbWhjaGVtUGFyc2VyLnN0YXRlTWFjaGluZXNbc3RhdGVNYWNoaW5lXTtcbiAgICAgICAgdmFyIHQgPSBtYWNoaW5lLnRyYW5zaXRpb25zW3N0YXRlXSB8fCBtYWNoaW5lLnRyYW5zaXRpb25zWycqJ107XG4gICAgICAgIGl0ZXJhdGVUcmFuc2l0aW9uczpcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8odFtpXS5wYXR0ZXJuLCBpbnB1dCk7XG4gICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGFjdGlvbnNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgdGFzayA9IHRbaV0udGFzaztcbiAgICAgICAgICAgIGZvciAodmFyIGlBPTA7IGlBPHRhc2suYWN0aW9uXy5sZW5ndGg7IGlBKyspIHtcbiAgICAgICAgICAgICAgdmFyIG87XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIEZpbmQgYW5kIGV4ZWN1dGUgYWN0aW9uXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIGlmIChtYWNoaW5lLmFjdGlvbnNbdGFzay5hY3Rpb25fW2lBXS50eXBlX10pIHtcbiAgICAgICAgICAgICAgICBvID0gbWFjaGluZS5hY3Rpb25zW3Rhc2suYWN0aW9uX1tpQV0udHlwZV9dKGJ1ZmZlciwgbWF0Y2hlcy5tYXRjaF8sIHRhc2suYWN0aW9uX1tpQV0ub3B0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtaGNoZW1QYXJzZXIuYWN0aW9uc1t0YXNrLmFjdGlvbl9baUFdLnR5cGVfXSkge1xuICAgICAgICAgICAgICAgIG8gPSBtaGNoZW1QYXJzZXIuYWN0aW9uc1t0YXNrLmFjdGlvbl9baUFdLnR5cGVfXShidWZmZXIsIG1hdGNoZXMubWF0Y2hfLCB0YXNrLmFjdGlvbl9baUFdLm9wdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnQVwiLCBcIm1oY2hlbSBidWcgQS4gUGxlYXNlIHJlcG9ydC4gKFwiICsgdGFzay5hY3Rpb25fW2lBXS50eXBlXyArIFwiKVwiXTsgIC8vIFRyeWluZyB0byB1c2Ugbm9uLWV4aXN0aW5nIGFjdGlvblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIEFkZCBvdXRwdXRcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KG91dHB1dCwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gU2V0IG5leHQgc3RhdGUsXG4gICAgICAgICAgICAvLyBTaG9ydGVuIGlucHV0LFxuICAgICAgICAgICAgLy8gQ29udGludWUgd2l0aCBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gICAoPSBhcHBseSBvbmx5IG9uZSB0cmFuc2l0aW9uIHBlciBwb3NpdGlvbilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBzdGF0ZSA9IHRhc2submV4dFN0YXRlIHx8IHN0YXRlO1xuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaWYgKCF0YXNrLnJldmlzaXQpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1hdGNoZXMucmVtYWluZGVyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghdGFzay50b0NvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWsgaXRlcmF0ZVRyYW5zaXRpb25zO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BcbiAgICAgICAgLy9cbiAgICAgICAgaWYgKHdhdGNoZG9nIDw9IDApIHtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdVXCIsIFwibWhjaGVtIGJ1ZyBVLiBQbGVhc2UgcmVwb3J0LlwiXTsgIC8vIFVuZXhwZWN0ZWQgY2hhcmFjdGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmNhdEFycmF5OiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICBmb3IgKHZhciBpQj0wOyBpQjxiLmxlbmd0aDsgaUIrKykge1xuICAgICAgICAgICAgYS5wdXNoKGJbaUJdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYS5wdXNoKGIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBhdHRlcm5zOiB7XG4gICAgICAvL1xuICAgICAgLy8gTWF0Y2hpbmcgcGF0dGVybnNcbiAgICAgIC8vIGVpdGhlciByZWdleHBzIG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJuIG51bGwgb3Ige21hdGNoXzpcImFcIiwgcmVtYWluZGVyOlwiYmNcIn1cbiAgICAgIC8vXG4gICAgICBwYXR0ZXJuczoge1xuICAgICAgICAvLyBwcm9wZXJ0eSBuYW1lcyBtdXN0IG5vdCBsb29rIGxpa2UgaW50ZWdlcnMgKFwiMlwiKSBmb3IgY29ycmVjdCBwcm9wZXJ0eSB0cmF2ZXJzYWwgb3JkZXIsIGxhdGVyIG9uXG4gICAgICAgICdlbXB0eSc6IC9eJC8sXG4gICAgICAgICdlbHNlJzogL14uLyxcbiAgICAgICAgJ2Vsc2UyJzogL14uLyxcbiAgICAgICAgJ3NwYWNlJzogL15cXHMvLFxuICAgICAgICAnc3BhY2UgQSc6IC9eXFxzKD89W0EtWlxcXFwkXSkvLFxuICAgICAgICAnc3BhY2UkJzogL15cXHMkLyxcbiAgICAgICAgJ2Eteic6IC9eW2Etel0vLFxuICAgICAgICAneCc6IC9eeC8sXG4gICAgICAgICd4JCc6IC9eeCQvLFxuICAgICAgICAnaSQnOiAvXmkkLyxcbiAgICAgICAgJ2xldHRlcnMnOiAvXig/OlthLXpBLVpcXHUwM0IxLVxcdTAzQzlcXHUwMzkxLVxcdTAzQTk/QF18KD86XFxcXCg/OmFscGhhfGJldGF8Z2FtbWF8ZGVsdGF8ZXBzaWxvbnx6ZXRhfGV0YXx0aGV0YXxpb3RhfGthcHBhfGxhbWJkYXxtdXxudXx4aXxvbWljcm9ufHBpfHJob3xzaWdtYXx0YXV8dXBzaWxvbnxwaGl8Y2hpfHBzaXxvbWVnYXxHYW1tYXxEZWx0YXxUaGV0YXxMYW1iZGF8WGl8UGl8U2lnbWF8VXBzaWxvbnxQaGl8UHNpfE9tZWdhKSg/Olxccyt8XFx7XFx9fCg/IVthLXpBLVpdKSkpKSsvLFxuICAgICAgICAnXFxcXGdyZWVrJzogL15cXFxcKD86YWxwaGF8YmV0YXxnYW1tYXxkZWx0YXxlcHNpbG9ufHpldGF8ZXRhfHRoZXRhfGlvdGF8a2FwcGF8bGFtYmRhfG11fG51fHhpfG9taWNyb258cGl8cmhvfHNpZ21hfHRhdXx1cHNpbG9ufHBoaXxjaGl8cHNpfG9tZWdhfEdhbW1hfERlbHRhfFRoZXRhfExhbWJkYXxYaXxQaXxTaWdtYXxVcHNpbG9ufFBoaXxQc2l8T21lZ2EpKD86XFxzK3xcXHtcXH18KD8hW2EtekEtWl0pKS8sXG4gICAgICAgICdvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciAkJzogL14oPzooW2Etel0pKD86JHxbXmEtekEtWl0pKSQvLFxuICAgICAgICAnJG9uZSBsb3dlcmNhc2UgbGF0aW4gbGV0dGVyJCAkJzogL15cXCQoPzooW2Etel0pKD86JHxbXmEtekEtWl0pKVxcJCQvLFxuICAgICAgICAnb25lIGxvd2VyY2FzZSBncmVlayBsZXR0ZXIgJCc6IC9eKD86XFwkP1tcXHUwM0IxLVxcdTAzQzldXFwkP3xcXCQ/XFxcXCg/OmFscGhhfGJldGF8Z2FtbWF8ZGVsdGF8ZXBzaWxvbnx6ZXRhfGV0YXx0aGV0YXxpb3RhfGthcHBhfGxhbWJkYXxtdXxudXx4aXxvbWljcm9ufHBpfHJob3xzaWdtYXx0YXV8dXBzaWxvbnxwaGl8Y2hpfHBzaXxvbWVnYSlcXHMqXFwkPykoPzpcXHMrfFxce1xcfXwoPyFbYS16QS1aXSkpJC8sXG4gICAgICAgICdkaWdpdHMnOiAvXlswLTldKy8sXG4gICAgICAgICctOS4sOSc6IC9eWytcXC1dPyg/OlswLTldKyg/OlssLl1bMC05XSspP3xbMC05XSooPzpcXC5bMC05XSspKS8sXG4gICAgICAgICctOS4sOSBubyBtaXNzaW5nIDAnOiAvXlsrXFwtXT9bMC05XSsoPzpbLixdWzAtOV0rKT8vLFxuICAgICAgICAnKC0pKDkuLDkpKGUpKDk5KSc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oXFwrXFwtfFxcK1xcL1xcLXxcXCt8XFwtfFxcXFxwbVxccz8pPyhbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKSk/KFxcKCg/OlswLTldKyg/OlssLl1bMC05XSspP3xbMC05XSooPzpcXC5bMC05XSspKVxcKSk/KD86KFtlRV18XFxzKihcXCp8eHxcXFxcdGltZXN8XFx1MDBENylcXHMqMTBcXF4pKFsrXFwtXT9bMC05XSt8XFx7WytcXC1dP1swLTldK1xcfSkpPy8pO1xuICAgICAgICAgIGlmIChtICYmIG1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbS5zcGxpY2UoMSksIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1bMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJygtKSg5KV4oLTkpJzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXCtcXC18XFwrXFwvXFwtfFxcK3xcXC18XFxcXHBtXFxzPyk/KFswLTldKyg/OlssLl1bMC05XSspP3xbMC05XSooPzpcXC5bMC05XSspPylcXF4oWytcXC1dP1swLTldK3xcXHtbK1xcLV0/WzAtOV0rXFx9KS8pO1xuICAgICAgICAgIGlmIChtICYmIG1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbS5zcGxpY2UoMSksIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1bMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uICQnOiBmdW5jdGlvbiAoaW5wdXQpIHsgIC8vIC4uLiBvciBjcnlzdGFsIHN5c3RlbVxuICAgICAgICAgIHZhciBhID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCAvXlxcKFthLXpdezEsM30oPz1bXFwpLF0pLywgXCIpXCIsIFwiXCIpOyAgLy8gKGFxKSwgKGFxLCRcXGluZnR5JCksIChhcSwgc2F0KVxuICAgICAgICAgIGlmIChhICAmJiAgYS5yZW1haW5kZXIubWF0Y2goL14oJHxbXFxzLDtcXClcXF1cXH1dKS8pKSB7IHJldHVybiBhOyB9ICAvLyAgQU5EIGVuZCBvZiAncGhyYXNlJ1xuICAgICAgICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oPzpcXCgoPzpcXFxcY2FcXHM/KT9cXCRbYW1vdGhjXVxcJFxcKSkvKTsgIC8vIE9SIGNyeXN0YWwgc3lzdGVtICgkbyQpIChcXGNhJGMkKVxuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1bMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1bMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ197KHN0YXRlIG9mIGFnZ3JlZ2F0aW9uKX0kJzogL15fXFx7KFxcKFthLXpdezEsM31cXCkpXFx9LyxcbiAgICAgICAgJ3tbKCc6IC9eKD86XFxcXFxce3xcXFt8XFwoKS8sXG4gICAgICAgICcpXX0nOiAvXig/OlxcKXxcXF18XFxcXFxcfSkvLFxuICAgICAgICAnLCAnOiAvXlssO11cXHMqLyxcbiAgICAgICAgJywnOiAvXlssO10vLFxuICAgICAgICAnLic6IC9eWy5dLyxcbiAgICAgICAgJy4gJzogL14oWy5cXHUyMkM1XFx1MDBCN1xcdTIwMjJdKVxccyovLFxuICAgICAgICAnLi4uJzogL15cXC5cXC5cXC4oPz0kfFteLl0pLyxcbiAgICAgICAgJyogJzogL14oWypdKVxccyovLFxuICAgICAgICAnXnsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJee1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdeKCQuLi4kKSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl5cIiwgXCIkXCIsIFwiJFwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ15hJzogL15cXF4oWzAtOV0rfFteXFxcXF9dKS8sXG4gICAgICAgICdeXFxcXHh7fXt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgJ15cXFxceHt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIik7IH0sXG4gICAgICAgICdeXFxcXHgnOiAvXlxcXihcXFxcW2EtekEtWl0rKVxccyovLFxuICAgICAgICAnXigtMSknOiAvXlxcXigtP1xcZCspLyxcbiAgICAgICAgJ1xcJyc6IC9eJy8sXG4gICAgICAgICdfeyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl97XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ18oJC4uLiQpJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCBcIiRcIiwgXCIkXCIsIFwiXCIpOyB9LFxuICAgICAgICAnXzknOiAvXl8oWytcXC1dP1swLTldK3xbXlxcXFxdKS8sXG4gICAgICAgICdfXFxcXHh7fXt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgJ19cXFxceHt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX1wiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIik7IH0sXG4gICAgICAgICdfXFxcXHgnOiAvXl8oXFxcXFthLXpBLVpdKylcXHMqLyxcbiAgICAgICAgJ15fJzogL14oPzpcXF4oPz1fKXxcXF8oPz1cXF4pfFtcXF5fXSQpLyxcbiAgICAgICAgJ3t9JzogL15cXHtcXH0vLFxuICAgICAgICAney4uLn0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ3soLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJyQuLi4kJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIFwiJFwiLCBcIiRcIiwgXCJcIik7IH0sXG4gICAgICAgICckeyguLi4pfSQnOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCIke1wiLCBcIlwiLCBcIlwiLCBcIn0kXCIpOyB9LFxuICAgICAgICAnJCguLi4pJCc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIiRcIiwgXCJcIiwgXCJcIiwgXCIkXCIpOyB9LFxuICAgICAgICAnPTw+JzogL15bPTw+XS8sXG4gICAgICAgICcjJzogL15bI1xcdTIyNjFdLyxcbiAgICAgICAgJysnOiAvXlxcKy8sXG4gICAgICAgICctJCc6IC9eLSg/PVtcXHNffSw7XFxdL118JHxcXChbYS16XStcXCkpLywgIC8vIC1zcGFjZSAtLCAtOyAtXSAtLyAtJCAtc3RhdGUtb2YtYWdncmVnYXRpb25cbiAgICAgICAgJy05JzogL14tKD89WzAtOV0pLyxcbiAgICAgICAgJy0gb3JiaXRhbCBvdmVybGFwJzogL14tKD89KD86W3NwZF18c3ApKD86JHxbXFxzLDtcXClcXF1cXH1dKSkvLFxuICAgICAgICAnLSc6IC9eLS8sXG4gICAgICAgICdwbS1vcGVyYXRvcic6IC9eKD86XFxcXHBtfFxcJFxcXFxwbVxcJHxcXCstfFxcK1xcLy0pLyxcbiAgICAgICAgJ29wZXJhdG9yJzogL14oPzpcXCt8KD86W1xcLT08Pl18PDx8Pj58XFxcXGFwcHJveHxcXCRcXFxcYXBwcm94XFwkKSg/PVxcc3wkfC0/WzAtOV0pKS8sXG4gICAgICAgICdhcnJvd1VwRG93bic6IC9eKD86dnxcXCh2XFwpfFxcXnxcXChcXF5cXCkpKD89JHxbXFxzLDtcXClcXF1cXH1dKS8sXG4gICAgICAgICdcXFxcYm9uZHsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcYm9uZHtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnLT4nOiAvXig/OjwtPnw8LS0+fC0+fDwtfDw9Pj58PDw9Pnw8PT58W1xcdTIxOTJcXHUyN0Y2XFx1MjFDQ10pLyxcbiAgICAgICAgJ0NNVCc6IC9eW0NNVF0oPz1cXFspLyxcbiAgICAgICAgJ1soLi4uKV0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJbXCIsIFwiXCIsIFwiXCIsIFwiXVwiKTsgfSxcbiAgICAgICAgJzFzdC1sZXZlbCBlc2NhcGUnOiAvXigmfFxcXFxcXFxcfFxcXFxobGluZSlcXHMqLyxcbiAgICAgICAgJ1xcXFwsJzogL14oPzpcXFxcWyxcXCA7Ol0pLywgIC8vIFxcXFx4IC0gYnV0IG91dHB1dCBubyBzcGFjZSBiZWZvcmVcbiAgICAgICAgJ1xcXFx4e317fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIiwgXCJcIiwgXCJ7XCIsIFwifVwiLCBcIlwiLCB0cnVlKTsgfSxcbiAgICAgICAgJ1xcXFx4e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIpOyB9LFxuICAgICAgICAnXFxcXGNhJzogL15cXFxcY2EoPzpcXHMrfCg/IVthLXpBLVpdKSkvLFxuICAgICAgICAnXFxcXHgnOiAvXig/OlxcXFxbYS16QS1aXStcXHMqfFxcXFxbXyZ7fSVdKS8sXG4gICAgICAgICdvcmJpdGFsJzogL14oPzpbMC05XXsxLDJ9W3NwZGZnaF18WzAtOV17MCwyfXNwKSg/PSR8W15hLXpBLVpdKS8sICAvLyBvbmx5IHRob3NlIHdpdGggbnVtYmVycyBpbiBmcm9udCwgYmVjYXVzZSB0aGUgb3RoZXJzIHdpbGwgYmUgZm9ybWF0dGVkIGNvcnJlY3RseSBhbnl3YXlcbiAgICAgICAgJ290aGVycyc6IC9eW1xcL358XS8sXG4gICAgICAgICdcXFxcZnJhY3soLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcZnJhY3tcIiwgXCJcIiwgXCJcIiwgXCJ9XCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcb3ZlcnNldHsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcb3ZlcnNldHtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcdW5kZXJzZXR7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXHVuZGVyc2V0e1wiLCBcIlwiLCBcIlwiLCBcIn1cIiwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFx1bmRlcmJyYWNleyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFx1bmRlcmJyYWNle1wiLCBcIlwiLCBcIlwiLCBcIn1fXCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9MCc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxjb2xvcntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0xJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNvbG9ye1wiLCBcIlwiLCBcIlwiLCBcIn1cIiwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFxjb2xvciguLi4peyguLi4pfTInOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcY29sb3JcIiwgXCJcXFxcXCIsIFwiXCIsIC9eKD89XFx7KS8sIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNle1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdveGlkYXRpb24kJzogL14oPzpbKy1dW0lWWF0rfFxcXFxwbVxccyowfFxcJFxcXFxwbVxcJFxccyowKSQvLFxuICAgICAgICAnZC1veGlkYXRpb24kJzogL14oPzpbKy1dP1xccz9bSVZYXSt8XFxcXHBtXFxzKjB8XFwkXFxcXHBtXFwkXFxzKjApJC8sICAvLyAwIGNvdWxkIGJlIG94aWRhdGlvbiBvciBjaGFyZ2VcbiAgICAgICAgJ3JvbWFuIG51bWVyYWwnOiAvXltJVlhdKy8sXG4gICAgICAgICcxLzIkJzogL15bK1xcLV0/KD86WzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcL1swLTldKyg/OlxcJFthLXpdXFwkfFthLXpdKT8kLyxcbiAgICAgICAgJ2Ftb3VudCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgICAvLyBlLmcuIDIsIDAuNSwgMS8yLCAtMiwgbi8yLCArOyAgJGEkIGNvdWxkIGJlIGFkZGVkIGxhdGVyIGluIHBhcnNpbmdcbiAgICAgICAgICBtYXRjaCA9IGlucHV0Lm1hdGNoKC9eKD86KD86KD86XFwoWytcXC1dP1swLTldK1xcL1swLTldK1xcKXxbK1xcLV0/KD86WzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcL1swLTldK3xbK1xcLV0/WzAtOV0rWy4sXVswLTldK3xbK1xcLV0/XFwuWzAtOV0rfFsrXFwtXT9bMC05XSspKD86W2Etel0oPz1cXHMqW0EtWl0pKT8pfFsrXFwtXT9bYS16XSg/PVxccypbQS1aXSl8XFwrKD8hXFxzKSkvKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbWF0Y2hbMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIFwiJFwiLCBcIiRcIiwgXCJcIik7XG4gICAgICAgICAgaWYgKGEpIHsgIC8vIGUuZy4gJDJuLTEkLCAkLSRcbiAgICAgICAgICAgIG1hdGNoID0gYS5tYXRjaF8ubWF0Y2goL15cXCQoPzpcXCg/WytcXC1dPyg/OlswLTldKlthLXpdP1srXFwtXSk/WzAtOV0qW2Etel0oPzpbK1xcLV1bMC05XSpbYS16XT8pP1xcKT98XFwrfC0pXFwkJC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbWF0Y2hbMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgICdhbW91bnQyJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiB0aGlzWydhbW91bnQnXShpbnB1dCk7IH0sXG4gICAgICAgICcoS1YgbGV0dGVycyksJzogL14oPzpbQS1aXVthLXpdezAsMn18aSkoPz0sKS8sXG4gICAgICAgICdmb3JtdWxhJCc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXlxcKFthLXpdK1xcKSQvKSkgeyByZXR1cm4gbnVsbDsgfSAgLy8gc3RhdGUgb2YgYWdncmVnYXRpb24gPSBubyBmb3JtdWxhXG4gICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2goL14oPzpbYS16XXwoPzpbMC05XFwgXFwrXFwtXFwsXFwuXFwoXFwpXStbYS16XSkrWzAtOVxcIFxcK1xcLVxcLFxcLlxcKFxcKV0qfCg/OlthLXpdWzAtOVxcIFxcK1xcLVxcLFxcLlxcKFxcKV0rKStbYS16XT8pJC8pO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtYXRjaFswXSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ3VwcmlnaHRFbnRpdGllcyc6IC9eKD86cEh8cE9IfHBDfHBLfGlQcnxpQnUpKD89JHxbXmEtekEtWl0pLyxcbiAgICAgICAgJy8nOiAvXlxccyooXFwvKVxccyovLFxuICAgICAgICAnLy8nOiAvXlxccyooXFwvXFwvKVxccyovLFxuICAgICAgICAnKic6IC9eXFxzKlsqLl1cXHMqL1xuICAgICAgfSxcbiAgICAgIGZpbmRPYnNlcnZlR3JvdXBzOiBmdW5jdGlvbiAoaW5wdXQsIGJlZ0V4Y2wsIGJlZ0luY2wsIGVuZEluY2wsIGVuZEV4Y2wsIGJlZzJFeGNsLCBiZWcySW5jbCwgZW5kMkluY2wsIGVuZDJFeGNsLCBjb21iaW5lKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7eyhpbnB1dDogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcgfCBSZWdFeHApOiBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bGw7fX0gKi9cbiAgICAgICAgdmFyIF9tYXRjaCA9IGZ1bmN0aW9uIChpbnB1dCwgcGF0dGVybikge1xuICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKGlucHV0LmluZGV4T2YocGF0dGVybikgIT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaFswXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBAdHlwZSB7eyhpbnB1dDogc3RyaW5nLCBpOiBudW1iZXIsIGVuZENoYXJzOiBzdHJpbmcgfCBSZWdFeHApOiB7ZW5kTWF0Y2hCZWdpbjogbnVtYmVyLCBlbmRNYXRjaEVuZDogbnVtYmVyfSB8IG51bGw7fX0gKi9cbiAgICAgICAgdmFyIF9maW5kT2JzZXJ2ZUdyb3VwcyA9IGZ1bmN0aW9uIChpbnB1dCwgaSwgZW5kQ2hhcnMpIHtcbiAgICAgICAgICB2YXIgYnJhY2VzID0gMDtcbiAgICAgICAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGEgPSBpbnB1dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBfbWF0Y2goaW5wdXQuc3Vic3RyKGkpLCBlbmRDaGFycyk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwgICYmICBicmFjZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgZW5kTWF0Y2hCZWdpbjogaSwgZW5kTWF0Y2hFbmQ6IGkgKyBtYXRjaC5sZW5ndGggfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgYnJhY2VzKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgIGlmIChicmFjZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBbXCJFeHRyYUNsb3NlTWlzc2luZ09wZW5cIiwgXCJFeHRyYSBjbG9zZSBicmFjZSBvciBtaXNzaW5nIG9wZW4gYnJhY2VcIl07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJhY2VzLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJyYWNlcyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1hdGNoID0gX21hdGNoKGlucHV0LCBiZWdFeGNsKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKG1hdGNoLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoID0gX21hdGNoKGlucHV0LCBiZWdJbmNsKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBlID0gX2ZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBtYXRjaC5sZW5ndGgsIGVuZEluY2wgfHwgZW5kRXhjbCk7XG4gICAgICAgIGlmIChlID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgIHZhciBtYXRjaDEgPSBpbnB1dC5zdWJzdHJpbmcoMCwgKGVuZEluY2wgPyBlLmVuZE1hdGNoRW5kIDogZS5lbmRNYXRjaEJlZ2luKSk7XG4gICAgICAgIGlmICghKGJlZzJFeGNsIHx8IGJlZzJJbmNsKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXRjaF86IG1hdGNoMSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKGUuZW5kTWF0Y2hFbmQpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZ3JvdXAyID0gdGhpcy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dC5zdWJzdHIoZS5lbmRNYXRjaEVuZCksIGJlZzJFeGNsLCBiZWcySW5jbCwgZW5kMkluY2wsIGVuZDJFeGNsKTtcbiAgICAgICAgICBpZiAoZ3JvdXAyID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgICAgICB2YXIgbWF0Y2hSZXQgPSBbbWF0Y2gxLCBncm91cDIubWF0Y2hfXTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2hfOiAoY29tYmluZSA/IG1hdGNoUmV0LmpvaW4oXCJcIikgOiBtYXRjaFJldCksXG4gICAgICAgICAgICByZW1haW5kZXI6IGdyb3VwMi5yZW1haW5kZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvL1xuICAgICAgLy8gTWF0Y2hpbmcgZnVuY3Rpb25cbiAgICAgIC8vIGUuZy4gbWF0Y2goXCJhXCIsIGlucHV0KSB3aWxsIGxvb2sgZm9yIHRoZSByZWdleHAgY2FsbGVkIFwiYVwiIGFuZCBzZWUgaWYgaXQgbWF0Y2hlc1xuICAgICAgLy8gcmV0dXJucyBudWxsIG9yIHttYXRjaF86XCJhXCIsIHJlbWFpbmRlcjpcImJjXCJ9XG4gICAgICAvL1xuICAgICAgbWF0Y2hfOiBmdW5jdGlvbiAobSwgaW5wdXQpIHtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBtaGNoZW1QYXJzZXIucGF0dGVybnMucGF0dGVybnNbbV07XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdQXCIsIFwibWhjaGVtIGJ1ZyBQLiBQbGVhc2UgcmVwb3J0LiAoXCIgKyBtICsgXCIpXCJdOyAgLy8gVHJ5aW5nIHRvIHVzZSBub24tZXhpc3RpbmcgcGF0dGVyblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLnBhdHRlcm5zW21dKGlucHV0KTsgIC8vIGNhbm5vdCB1c2UgY2FjaGVkIHZhciBwYXR0ZXJuIGhlcmUsIGJlY2F1c2Ugc29tZSBwYXR0ZXJuIGZ1bmN0aW9ucyBuZWVkIHRoaXM9PT1taGNoZW1QYXJzZXJcbiAgICAgICAgfSBlbHNlIHsgIC8vIFJlZ0V4cFxuICAgICAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIG1tO1xuICAgICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICAgIG1tID0gWyBtYXRjaFsxXSwgbWF0Y2hbMl0gXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgbW0gPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1tID0gbWF0Y2hbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1tLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vXG4gICAgLy8gR2VuZXJpYyBzdGF0ZSBtYWNoaW5lIGFjdGlvbnNcbiAgICAvL1xuICAgIGFjdGlvbnM6IHtcbiAgICAgICdhPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLmEgPSAoYnVmZmVyLmEgfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ2I9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuYiA9IChidWZmZXIuYiB8fCBcIlwiKSArIG07IH0sXG4gICAgICAncD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5wID0gKGJ1ZmZlci5wIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdvPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLm8gPSAoYnVmZmVyLm8gfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ3E9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucSA9IChidWZmZXIucSB8fCBcIlwiKSArIG07IH0sXG4gICAgICAnZD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5kID0gKGJ1ZmZlci5kIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdybT0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ybSA9IChidWZmZXIucm0gfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ3RleHQ9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIudGV4dF8gPSAoYnVmZmVyLnRleHRfIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdpbnNlcnQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBhKSB7IHJldHVybiB7IHR5cGVfOiBhIH07IH0sXG4gICAgICAnaW5zZXJ0K3AxJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgYSkgeyByZXR1cm4geyB0eXBlXzogYSwgcDE6IG0gfTsgfSxcbiAgICAgICdpbnNlcnQrcDErcDInOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBhKSB7IHJldHVybiB7IHR5cGVfOiBhLCBwMTogbVswXSwgcDI6IG1bMV0gfTsgfSxcbiAgICAgICdjb3B5JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbTsgfSxcbiAgICAgICdybSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIHsgdHlwZV86ICdybScsIHAxOiBtIHx8IFwiXCJ9OyB9LFxuICAgICAgJ3RleHQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiBtaGNoZW1QYXJzZXIuZ28obSwgJ3RleHQnKTsgfSxcbiAgICAgICd7dGV4dH0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgIHZhciByZXQgPSBbIFwie1wiIF07XG4gICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtLCAndGV4dCcpKTtcbiAgICAgICAgcmV0LnB1c2goXCJ9XCIpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICAgICd0ZXgtbWF0aCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtLCAndGV4LW1hdGgnKTsgfSxcbiAgICAgICd0ZXgtbWF0aCB0aWdodCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtLCAndGV4LW1hdGggdGlnaHQnKTsgfSxcbiAgICAgICdib25kJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgaykgeyByZXR1cm4geyB0eXBlXzogJ2JvbmQnLCBraW5kXzogayB8fCBtIH07IH0sXG4gICAgICAnY29sb3IwLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIHsgdHlwZV86ICdjb2xvcjAnLCBjb2xvcjogbVswXSB9OyB9LFxuICAgICAgJ2NlJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLmdvKG0pOyB9LFxuICAgICAgJzEvMic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICBpZiAobS5tYXRjaCgvXlsrXFwtXS8pKSB7XG4gICAgICAgICAgcmV0LnB1c2gobS5zdWJzdHIoMCwgMSkpO1xuICAgICAgICAgIG0gPSBtLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbiA9IG0ubWF0Y2goL14oWzAtOV0rfFxcJFthLXpdXFwkfFthLXpdKVxcLyhbMC05XSspKFxcJFthLXpdXFwkfFthLXpdKT8kLyk7XG4gICAgICAgIG5bMV0gPSBuWzFdLnJlcGxhY2UoL1xcJC9nLCBcIlwiKTtcbiAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2ZyYWMnLCBwMTogblsxXSwgcDI6IG5bMl0gfSk7XG4gICAgICAgIGlmIChuWzNdKSB7XG4gICAgICAgICAgblszXSA9IG5bM10ucmVwbGFjZSgvXFwkL2csIFwiXCIpO1xuICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICd0ZXgtbWF0aCcsIHAxOiBuWzNdIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgJzksOSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtLCAnOSw5Jyk7IH1cbiAgICB9LFxuICAgIC8vXG4gICAgLy8gY3JlYXRlVHJhbnNpdGlvbnNcbiAgICAvLyBjb252ZXJ0ICB7ICdsZXR0ZXInOiB7ICdzdGF0ZSc6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9IH0gIHRvICB7ICdzdGF0ZScgPT4gWyB7IHBhdHRlcm46ICdsZXR0ZXInLCB0YXNrOiB7IGFjdGlvbl86IFt7dHlwZV86ICdvdXRwdXQnfV0gfSB9IF0gfVxuICAgIC8vIHdpdGggZXhwYW5zaW9uIG9mICdhfGInIHRvICdhJyBhbmQgJ2InIChhdCAyIHBsYWNlcylcbiAgICAvL1xuICAgIGNyZWF0ZVRyYW5zaXRpb25zOiBmdW5jdGlvbiAobykge1xuICAgICAgdmFyIHBhdHRlcm4sIHN0YXRlO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICAgIHZhciBzdGF0ZUFycmF5O1xuICAgICAgdmFyIGk7XG4gICAgICAvL1xuICAgICAgLy8gMS4gQ29sbGVjdCBhbGwgc3RhdGVzXG4gICAgICAvL1xuICAgICAgLyoqIEB0eXBlIHtUcmFuc2l0aW9uc30gKi9cbiAgICAgIHZhciB0cmFuc2l0aW9ucyA9IHt9O1xuICAgICAgZm9yIChwYXR0ZXJuIGluIG8pIHtcbiAgICAgICAgZm9yIChzdGF0ZSBpbiBvW3BhdHRlcm5dKSB7XG4gICAgICAgICAgc3RhdGVBcnJheSA9IHN0YXRlLnNwbGl0KFwifFwiKTtcbiAgICAgICAgICBvW3BhdHRlcm5dW3N0YXRlXS5zdGF0ZUFycmF5ID0gc3RhdGVBcnJheTtcbiAgICAgICAgICBmb3IgKGk9MDsgaTxzdGF0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uc1tzdGF0ZUFycmF5W2ldXSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9cbiAgICAgIC8vIDIuIEZpbGwgc3RhdGVzXG4gICAgICAvL1xuICAgICAgZm9yIChwYXR0ZXJuIGluIG8pIHtcbiAgICAgICAgZm9yIChzdGF0ZSBpbiBvW3BhdHRlcm5dKSB7XG4gICAgICAgICAgc3RhdGVBcnJheSA9IG9bcGF0dGVybl1bc3RhdGVdLnN0YXRlQXJyYXkgfHwgW107XG4gICAgICAgICAgZm9yIChpPTA7IGk8c3RhdGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDJhLiBOb3JtYWxpemUgYWN0aW9ucyBpbnRvIGFycmF5OiAgJ3RleHQ9JyA9PT4gW3t0eXBlXzondGV4dD0nfV1cbiAgICAgICAgICAgIC8vIChOb3RlIHRvIG15c2VsZjogUmVzb2x2aW5nIHRoZSBmdW5jdGlvbiBoZXJlIHdvdWxkIGJlIHByb2JsZW1hdGljLiBJdCB3b3VsZCBuZWVkIC5iaW5kIChmb3IgKnRoaXMqKSBhbmQgY3VycnlpbmcgKGZvciAqb3B0aW9uKikuKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgICAgICAgICAgdmFyIHAgPSBvW3BhdHRlcm5dW3N0YXRlXTtcbiAgICAgICAgICAgIGlmIChwLmFjdGlvbl8pIHtcbiAgICAgICAgICAgICAgcC5hY3Rpb25fID0gW10uY29uY2F0KHAuYWN0aW9uXyk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGs9MDsgazxwLmFjdGlvbl8ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHAuYWN0aW9uX1trXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgcC5hY3Rpb25fW2tdID0geyB0eXBlXzogcC5hY3Rpb25fW2tdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLmFjdGlvbl8gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAyLmIgTXVsdGktaW5zZXJ0XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHBhdHRlcm5BcnJheSA9IHBhdHRlcm4uc3BsaXQoXCJ8XCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaj0wOyBqPHBhdHRlcm5BcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVBcnJheVtpXSA9PT0gJyonKSB7ICAvLyBpbnNlcnQgaW50byBhbGxcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0IGluIHRyYW5zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1t0XS5wdXNoKHsgcGF0dGVybjogcGF0dGVybkFycmF5W2pdLCB0YXNrOiBwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uc1tzdGF0ZUFycmF5W2ldXS5wdXNoKHsgcGF0dGVybjogcGF0dGVybkFycmF5W2pdLCB0YXNrOiBwIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbnM7XG4gICAgfSxcbiAgICBzdGF0ZU1hY2hpbmVzOiB7fVxuICB9O1xuXG4gIC8vXG4gIC8vIERlZmluaXRpb24gb2Ygc3RhdGUgbWFjaGluZXNcbiAgLy9cbiAgbWhjaGVtUGFyc2VyLnN0YXRlTWFjaGluZXMgPSB7XG4gICAgLy9cbiAgICAvLyBcXGNlIHN0YXRlIG1hY2hpbmVzXG4gICAgLy9cbiAgICAvLyNyZWdpb24gY2VcbiAgICAnY2UnOiB7ICAvLyBtYWluIHBhcnNlclxuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnZWxzZSc6ICB7XG4gICAgICAgICAgJzB8MXwyJzogeyBhY3Rpb25fOiAnYmVnaW5zV2l0aEJvbmQ9ZmFsc2UnLCByZXZpc2l0OiB0cnVlLCB0b0NvbnRpbnVlOiB0cnVlIH0gfSxcbiAgICAgICAgJ294aWRhdGlvbiQnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdveGlkYXRpb24tb3V0cHV0JyB9IH0sXG4gICAgICAgICdDTVQnOiB7XG4gICAgICAgICAgJ3InOiB7IGFjdGlvbl86ICdyZHQ9JywgbmV4dFN0YXRlOiAncnQnIH0sXG4gICAgICAgICAgJ3JkJzogeyBhY3Rpb25fOiAncnF0PScsIG5leHRTdGF0ZTogJ3JkdCcgfSB9LFxuICAgICAgICAnYXJyb3dVcERvd24nOiB7XG4gICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiBbICdzYj1mYWxzZScsICdvdXRwdXQnLCAnb3BlcmF0b3InIF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ3VwcmlnaHRFbnRpdGllcyc6IHtcbiAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86IFsgJ289JywgJ291dHB1dCcgXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnb3JiaXRhbCc6IHtcbiAgICAgICAgICAnMHwxfDJ8Myc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnLT4nOiB7XG4gICAgICAgICAgJzB8MXwyfDMnOiB7IGFjdGlvbl86ICdyPScsIG5leHRTdGF0ZTogJ3InIH0sXG4gICAgICAgICAgJ2F8YXMnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdyPScgXSwgbmV4dFN0YXRlOiAncicgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3I9JyBdLCBuZXh0U3RhdGU6ICdyJyB9IH0sXG4gICAgICAgICcrJzoge1xuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiAnZD0ga3YnLCAgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnZHxEJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiAnZD0nLCAgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ3FkfHFEJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAnZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdkPScgXSwgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnMyc6IHsgYWN0aW9uXzogWyAnc2I9ZmFsc2UnLCAnb3V0cHV0JywgJ29wZXJhdG9yJyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdhbW91bnQnOiB7XG4gICAgICAgICAgJzB8Mic6IHsgYWN0aW9uXzogJ2E9JywgbmV4dFN0YXRlOiAnYScgfSB9LFxuICAgICAgICAncG0tb3BlcmF0b3InOiB7XG4gICAgICAgICAgJzB8MXwyfGF8YXMnOiB7IGFjdGlvbl86IFsgJ3NiPWZhbHNlJywgJ291dHB1dCcsIHsgdHlwZV86ICdvcGVyYXRvcicsIG9wdGlvbjogJ1xcXFxwbScgfSBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdvcGVyYXRvcic6IHtcbiAgICAgICAgICAnMHwxfDJ8YXxhcyc6IHsgYWN0aW9uXzogWyAnc2I9ZmFsc2UnLCAnb3V0cHV0JywgJ29wZXJhdG9yJyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICctJCc6IHtcbiAgICAgICAgICAnb3xxJzogeyBhY3Rpb25fOiBbICdjaGFyZ2Ugb3IgYm9uZCcsICdvdXRwdXQnIF0sICBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnRCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogJ2Q9JywgIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdxZCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ3FEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICctOSc6IHtcbiAgICAgICAgICAnM3xvJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9IF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJy0gb3JiaXRhbCBvdmVybGFwJzoge1xuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9IF0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJ2QnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdoeXBoZW4nIH0gXSwgbmV4dFN0YXRlOiAnMicgfSB9LFxuICAgICAgICAnLSc6IHtcbiAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnYmVnaW5zV2l0aEJvbmQ9dHJ1ZScsIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgJzMnOiB7IGFjdGlvbl86IHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IH0sXG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdoeXBoZW4nIH0gXSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnYXMnOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICdiJzogeyBhY3Rpb25fOiAnYj0nIH0sXG4gICAgICAgICAgJ28nOiB7IGFjdGlvbl86IHsgdHlwZV86ICctIGFmdGVyIG8vZCcsIG9wdGlvbjogZmFsc2UgfSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogeyB0eXBlXzogJy0gYWZ0ZXIgby9kJywgb3B0aW9uOiBmYWxzZSB9LCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICdkfHFkfGRxJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnLSBhZnRlciBvL2QnLCBvcHRpb246IHRydWUgfSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnRHxxRHxwJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdhbW91bnQyJzoge1xuICAgICAgICAgICcxfDMnOiB7IGFjdGlvbl86ICdhPScsIG5leHRTdGF0ZTogJ2EnIH0gfSxcbiAgICAgICAgJ2xldHRlcnMnOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xifHB8YnB8byc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAncXxkcSc6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnbz0nXSwgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAnZHxEfHFkfHFEJzogeyBhY3Rpb25fOiAnbyBhZnRlciBkJywgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnZGlnaXRzJzoge1xuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdxJyB9LFxuICAgICAgICAgICdkfEQnOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ2RxJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nIF0sIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJ3NwYWNlIEEnOiB7XG4gICAgICAgICAgJ2J8cHxicCc6IHt9IH0sXG4gICAgICAgICdzcGFjZSc6IHtcbiAgICAgICAgICAnYSc6IHsgbmV4dFN0YXRlOiAnYXMnIH0sXG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdzYj1mYWxzZScgfSxcbiAgICAgICAgICAnMXwyJzogeyBhY3Rpb25fOiAnc2I9dHJ1ZScgfSxcbiAgICAgICAgICAncnxydHxyZHxyZHR8cmRxJzogeyBhY3Rpb25fOiAnb3V0cHV0JywgbmV4dFN0YXRlOiAnMCcgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3NiPXRydWUnIF0sIG5leHRTdGF0ZTogJzEnfSB9LFxuICAgICAgICAnMXN0LWxldmVsIGVzY2FwZSc6IHtcbiAgICAgICAgICAnMXwyJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0K3AxJywgb3B0aW9uOiAnMXN0LWxldmVsIGVzY2FwZScgfSBdIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQrcDEnLCBvcHRpb246ICcxc3QtbGV2ZWwgZXNjYXBlJyB9IF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ1soLi4uKV0nOiB7XG4gICAgICAgICAgJ3J8cnQnOiB7IGFjdGlvbl86ICdyZD0nLCBuZXh0U3RhdGU6ICdyZCcgfSxcbiAgICAgICAgICAncmR8cmR0JzogeyBhY3Rpb25fOiAncnE9JywgbmV4dFN0YXRlOiAncmRxJyB9IH0sXG4gICAgICAgICcuLi4nOiB7XG4gICAgICAgICAgJ298ZHxEfGRxfHFkfHFEJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCIuLi5cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnZWxsaXBzaXMnIH0gXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnLiB8KiAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdhZGRpdGlvbiBjb21wb3VuZCcgfSBdLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbiAkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnc3RhdGUgb2YgYWdncmVnYXRpb24nIF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ3tbKCc6IHtcbiAgICAgICAgICAnYXxhc3xvJzogeyBhY3Rpb25fOiBbICdvPScsICdvdXRwdXQnLCAncGFyZW50aGVzaXNMZXZlbCsrJyBdLCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICcwfDF8MnwzJzogeyBhY3Rpb25fOiBbICdvPScsICdvdXRwdXQnLCAncGFyZW50aGVzaXNMZXZlbCsrJyBdLCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nLCAnb3V0cHV0JywgJ3BhcmVudGhlc2lzTGV2ZWwrKycgXSwgbmV4dFN0YXRlOiAnMicgfSB9LFxuICAgICAgICAnKV19Jzoge1xuICAgICAgICAgICcwfDF8MnwzfGJ8cHxicHxvJzogeyBhY3Rpb25fOiBbICdvPScsICdwYXJlbnRoZXNpc0xldmVsLS0nIF0sIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgJ2F8YXN8ZHxEfHF8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdvPScsICdwYXJlbnRoZXNpc0xldmVsLS0nIF0sIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJywgJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY29tbWEnIF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ15fJzogeyAgLy8gXiBhbmQgXyB3aXRob3V0IGEgc2Vuc2libGUgYXJndW1lbnRcbiAgICAgICAgICAnKic6IHsgfSB9LFxuICAgICAgICAnXnsoLi4uKX18XigkLi4uJCknOiB7XG4gICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdiJyB9LFxuICAgICAgICAgICdwJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdicCcgfSxcbiAgICAgICAgICAnM3xvJzogeyBhY3Rpb25fOiAnZD0ga3YnLCBuZXh0U3RhdGU6ICdEJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxRCcgfSxcbiAgICAgICAgICAnZHxEfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnZD0nIF0sIG5leHRTdGF0ZTogJ0QnIH0gfSxcbiAgICAgICAgJ15hfF5cXFxceHt9e318XlxcXFx4e318XlxcXFx4fFxcJyc6IHtcbiAgICAgICAgICAnMHwxfDJ8YXMnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2InIH0sXG4gICAgICAgICAgJ3AnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2JwJyB9LFxuICAgICAgICAgICczfG8nOiB7IGFjdGlvbl86ICdkPSBrdicsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJ3EnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdkfHFkfER8cUQnOiB7IGFjdGlvbl86ICdkPScgfSxcbiAgICAgICAgICAnZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdkPScgXSwgbmV4dFN0YXRlOiAnZCcgfSB9LFxuICAgICAgICAnX3soc3RhdGUgb2YgYWdncmVnYXRpb24pfSQnOiB7XG4gICAgICAgICAgJ2R8RHxxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAncT0nIF0sIG5leHRTdGF0ZTogJ3EnIH0gfSxcbiAgICAgICAgJ197KC4uLil9fF8oJC4uLiQpfF85fF9cXFxceHt9e318X1xcXFx4e318X1xcXFx4Jzoge1xuICAgICAgICAgICcwfDF8Mnxhcyc6IHsgYWN0aW9uXzogJ3A9JywgbmV4dFN0YXRlOiAncCcgfSxcbiAgICAgICAgICAnYic6IHsgYWN0aW9uXzogJ3A9JywgbmV4dFN0YXRlOiAnYnAnIH0sXG4gICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogJ3E9JywgbmV4dFN0YXRlOiAncScgfSxcbiAgICAgICAgICAnZHxEJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdkcScgfSxcbiAgICAgICAgICAncXxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3E9JyBdLCBuZXh0U3RhdGU6ICdxJyB9IH0sXG4gICAgICAgICc9PD4nOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xvfHF8ZHxEfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ2JvbmQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJyMnOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xvJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiI1wiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAne30nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ3suLi59Jzoge1xuICAgICAgICAgICcwfDF8MnwzfGF8YXN8YnxwfGJwJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICdvfGR8RHxxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nIF0sIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJyQuLi4kJzoge1xuICAgICAgICAgICdhJzogeyBhY3Rpb25fOiAnYT0nIH0sICAvLyAyJG4kXG4gICAgICAgICAgJzB8MXwyfDN8YXN8YnxwfGJwfG8nOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0sICAvLyBub3QgJ2Ftb3VudCdcbiAgICAgICAgICAnYXN8byc6IHsgYWN0aW9uXzogJ289JyB9LFxuICAgICAgICAgICdxfGR8RHxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ289JyBdLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICdcXFxcYm9uZHsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnYm9uZCcgXSwgbmV4dFN0YXRlOiBcIjNcIiB9IH0sXG4gICAgICAgICdcXFxcZnJhY3soLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnZnJhYy1vdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFxvdmVyc2V0eyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdvdmVyc2V0LW91dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXHVuZGVyc2V0eyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICd1bmRlcnNldC1vdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFx1bmRlcmJyYWNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICd1bmRlcmJyYWNlLW91dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0xfFxcXFxjb2xvciguLi4peyguLi4pfTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnY29sb3Itb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9MCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdjb2xvcjAtb3V0cHV0JyBdIH0gfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnY2UnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFwsJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgJ2NvcHknIF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ1xcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcwfDF8MnwzfGF8YXN8YnxwfGJwfG98YzAnOiB7IGFjdGlvbl86IFsgJ289JywgJ291dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWydvdXRwdXQnLCAnbz0nLCAnb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdvdGhlcnMnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnY29weScgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86ICdhIHRvIG8nLCBuZXh0U3RhdGU6ICdvJywgcmV2aXNpdDogdHJ1ZSB9LFxuICAgICAgICAgICdhcyc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3NiPXRydWUnIF0sIG5leHRTdGF0ZTogJzEnLCByZXZpc2l0OiB0cnVlIH0sXG4gICAgICAgICAgJ3J8cnR8cmR8cmR0fHJkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICcwJywgcmV2aXNpdDogdHJ1ZSB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY29weScgXSwgbmV4dFN0YXRlOiAnMycgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ28gYWZ0ZXIgZCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIGlmICgoYnVmZmVyLmQgfHwgXCJcIikubWF0Y2goL15bMC05XSskLykpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBidWZmZXIuZDtcbiAgICAgICAgICAgIGJ1ZmZlci5kID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0ID0gdGhpc1snb3V0cHV0J10oYnVmZmVyKTtcbiAgICAgICAgICAgIGJ1ZmZlci5iID0gdG1wO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzWydvdXRwdXQnXShidWZmZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaGNoZW1QYXJzZXIuYWN0aW9uc1snbz0nXShidWZmZXIsIG0pO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdkPSBrdic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICBidWZmZXIuZCA9IG07XG4gICAgICAgICAgYnVmZmVyLmRUeXBlID0gJ2t2JztcbiAgICAgICAgfSxcbiAgICAgICAgJ2NoYXJnZSBvciBib25kJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIGlmIChidWZmZXJbJ2JlZ2luc1dpdGhCb25kJ10pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCB0aGlzWydvdXRwdXQnXShidWZmZXIpKTtcbiAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5hY3Rpb25zWydib25kJ10oYnVmZmVyLCBtLCBcIi1cIikpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyLmQgPSBtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJy0gYWZ0ZXIgby9kJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgaXNBZnRlckQpIHtcbiAgICAgICAgICB2YXIgYzEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdvcmJpdGFsJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgdmFyIGMyID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnb25lIGxvd2VyY2FzZSBncmVlayBsZXR0ZXIgJCcsIGJ1ZmZlci5vIHx8IFwiXCIpO1xuICAgICAgICAgIHZhciBjMyA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ29uZSBsb3dlcmNhc2UgbGF0aW4gbGV0dGVyICQnLCBidWZmZXIubyB8fCBcIlwiKTtcbiAgICAgICAgICB2YXIgYzQgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCckb25lIGxvd2VyY2FzZSBsYXRpbiBsZXR0ZXIkICQnLCBidWZmZXIubyB8fCBcIlwiKTtcbiAgICAgICAgICB2YXIgaHlwaGVuRm9sbG93cyA9ICBtPT09XCItXCIgJiYgKCBjMSAmJiBjMS5yZW1haW5kZXI9PT1cIlwiICB8fCAgYzIgIHx8ICBjMyAgfHwgIGM0ICk7XG4gICAgICAgICAgaWYgKGh5cGhlbkZvbGxvd3MgJiYgIWJ1ZmZlci5hICYmICFidWZmZXIuYiAmJiAhYnVmZmVyLnAgJiYgIWJ1ZmZlci5kICYmICFidWZmZXIucSAmJiAhYzEgJiYgYzMpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5vID0gJyQnICsgYnVmZmVyLm8gKyAnJCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgIGlmIChoeXBoZW5Gb2xsb3dzKSB7XG4gICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCB0aGlzWydvdXRwdXQnXShidWZmZXIpKTtcbiAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICdoeXBoZW4nIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjMSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ2RpZ2l0cycsIGJ1ZmZlci5kIHx8IFwiXCIpO1xuICAgICAgICAgICAgaWYgKGlzQWZ0ZXJEICYmIGMxICYmIGMxLnJlbWFpbmRlcj09PScnKSB7XG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5hY3Rpb25zWydkPSddKGJ1ZmZlciwgbSkpO1xuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCB0aGlzWydvdXRwdXQnXShidWZmZXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIHRoaXNbJ291dHB1dCddKGJ1ZmZlcikpO1xuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuYWN0aW9uc1snYm9uZCddKGJ1ZmZlciwgbSwgXCItXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ2EgdG8gbyc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICBidWZmZXIubyA9IGJ1ZmZlci5hO1xuICAgICAgICAgIGJ1ZmZlci5hID0gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICAnc2I9dHJ1ZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyLnNiID0gdHJ1ZTsgfSxcbiAgICAgICAgJ3NiPWZhbHNlJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXIuc2IgPSBmYWxzZTsgfSxcbiAgICAgICAgJ2JlZ2luc1dpdGhCb25kPXRydWUnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlclsnYmVnaW5zV2l0aEJvbmQnXSA9IHRydWU7IH0sXG4gICAgICAgICdiZWdpbnNXaXRoQm9uZD1mYWxzZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyWydiZWdpbnNXaXRoQm9uZCddID0gZmFsc2U7IH0sXG4gICAgICAgICdwYXJlbnRoZXNpc0xldmVsKysnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlclsncGFyZW50aGVzaXNMZXZlbCddKys7IH0sXG4gICAgICAgICdwYXJlbnRoZXNpc0xldmVsLS0nOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlclsncGFyZW50aGVzaXNMZXZlbCddLS07IH0sXG4gICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJywgcDE6IG1oY2hlbVBhcnNlci5nbyhtLCAnbycpIH07XG4gICAgICAgIH0sXG4gICAgICAgICdjb21tYSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICB2YXIgYSA9IG0ucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG4gICAgICAgICAgdmFyIHdpdGhTcGFjZSA9IChhICE9PSBtKTtcbiAgICAgICAgICBpZiAod2l0aFNwYWNlICAmJiAgYnVmZmVyWydwYXJlbnRoZXNpc0xldmVsJ10gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29tbWEgZW51bWVyYXRpb24gTCcsIHAxOiBhIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29tbWEgZW51bWVyYXRpb24gTScsIHAxOiBhIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgZW50aXR5Rm9sbG93cykge1xuICAgICAgICAgIC8vIGVudGl0eUZvbGxvd3M6XG4gICAgICAgICAgLy8gICB1bmRlZmluZWQgPSBpZiB3ZSBoYXZlIG5vdGhpbmcgZWxzZSB0byBvdXRwdXQsIGFsc28gaWdub3JlIHRoZSBqdXN0IHJlYWQgc3BhY2UgKGJ1ZmZlci5zYilcbiAgICAgICAgICAvLyAgIDEgPSBhbiBlbnRpdHkgZm9sbG93cywgbmV2ZXIgb21pdCB0aGUgc3BhY2UgaWYgdGhlcmUgd2FzIG9uZSBqdXN0IHJlYWQgYmVmb3JlIChjYW4gb25seSBhcHBseSB0byBzdGF0ZSAxKVxuICAgICAgICAgIC8vICAgMiA9IDEgKyB0aGUgZW50aXR5IGNhbiBoYXZlIGFuIGFtb3VudCwgc28gb3V0cHV0IGFcXCwgaW5zdGVhZCBvZiBjb252ZXJ0aW5nIGl0IHRvIG8gKGNhbiBvbmx5IGFwcGx5IHRvIHN0YXRlcyBhfGFzKVxuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0IHwgUGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICBpZiAoIWJ1ZmZlci5yKSB7XG4gICAgICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgICAgIGlmICghYnVmZmVyLmEgJiYgIWJ1ZmZlci5iICYmICFidWZmZXIucCAmJiAhYnVmZmVyLm8gJiYgIWJ1ZmZlci5xICYmICFidWZmZXIuZCAmJiAhZW50aXR5Rm9sbG93cykge1xuICAgICAgICAgICAgICAvL3JldCA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5zYikge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICdlbnRpdHlTa2lwJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWJ1ZmZlci5vICYmICFidWZmZXIucSAmJiAhYnVmZmVyLmQgJiYgIWJ1ZmZlci5iICYmICFidWZmZXIucCAmJiBlbnRpdHlGb2xsb3dzIT09Mikge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5vID0gYnVmZmVyLmE7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWJ1ZmZlci5vICYmICFidWZmZXIucSAmJiAhYnVmZmVyLmQgJiYgKGJ1ZmZlci5iIHx8IGJ1ZmZlci5wKSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5vID0gYnVmZmVyLmE7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmQgPSBidWZmZXIuYjtcbiAgICAgICAgICAgICAgICBidWZmZXIucSA9IGJ1ZmZlci5wO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hID0gYnVmZmVyLmIgPSBidWZmZXIucCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLm8gJiYgYnVmZmVyLmRUeXBlPT09J2t2JyAmJiBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdkLW94aWRhdGlvbiQnLCBidWZmZXIuZCB8fCBcIlwiKSkge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyLmRUeXBlID0gJ294aWRhdGlvbic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIubyAmJiBidWZmZXIuZFR5cGU9PT0na3YnICYmICFidWZmZXIucSkge1xuICAgICAgICAgICAgICAgICAgYnVmZmVyLmRUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZV86ICdjaGVtZml2ZScsXG4gICAgICAgICAgICAgICAgYTogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5hLCAnYScpLFxuICAgICAgICAgICAgICAgIGI6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIuYiwgJ2JkJyksXG4gICAgICAgICAgICAgICAgcDogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5wLCAncHEnKSxcbiAgICAgICAgICAgICAgICBvOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLm8sICdvJyksXG4gICAgICAgICAgICAgICAgcTogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5xLCAncHEnKSxcbiAgICAgICAgICAgICAgICBkOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLmQsIChidWZmZXIuZFR5cGUgPT09ICdveGlkYXRpb24nID8gJ294aWRhdGlvbicgOiAnYmQnKSksXG4gICAgICAgICAgICAgICAgZFR5cGU6IGJ1ZmZlci5kVHlwZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgeyAgLy8gclxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICAgIHZhciByZDtcbiAgICAgICAgICAgIGlmIChidWZmZXIucmR0ID09PSAnTScpIHtcbiAgICAgICAgICAgICAgcmQgPSBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnJkLCAndGV4LW1hdGgnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLnJkdCA9PT0gJ1QnKSB7XG4gICAgICAgICAgICAgIHJkID0gWyB7IHR5cGVfOiAndGV4dCcsIHAxOiBidWZmZXIucmQgfHwgXCJcIiB9IF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZCA9IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICAgIHZhciBycTtcbiAgICAgICAgICAgIGlmIChidWZmZXIucnF0ID09PSAnTScpIHtcbiAgICAgICAgICAgICAgcnEgPSBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnJxLCAndGV4LW1hdGgnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLnJxdCA9PT0gJ1QnKSB7XG4gICAgICAgICAgICAgIHJxID0gWyB7IHR5cGVfOiAndGV4dCcsIHAxOiBidWZmZXIucnEgfHwgXCJcIn0gXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJxID0gbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5ycSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQgPSB7XG4gICAgICAgICAgICAgIHR5cGVfOiAnYXJyb3cnLFxuICAgICAgICAgICAgICByOiBidWZmZXIucixcbiAgICAgICAgICAgICAgcmQ6IHJkLFxuICAgICAgICAgICAgICBycTogcnFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAocCAhPT0gJ3BhcmVudGhlc2lzTGV2ZWwnICAmJiAgcCAhPT0gJ2JlZ2luc1dpdGhCb25kJykge1xuICAgICAgICAgICAgICBkZWxldGUgYnVmZmVyW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnb3hpZGF0aW9uLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICB2YXIgcmV0ID0gWyBcIntcIiBdO1xuICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtLCAnb3hpZGF0aW9uJykpO1xuICAgICAgICAgIHJldC5wdXNoKFwifVwiKTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnZnJhYy1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdmcmFjLWNlJywgcDE6IG1oY2hlbVBhcnNlci5nbyhtWzBdKSwgcDI6IG1oY2hlbVBhcnNlci5nbyhtWzFdKSB9O1xuICAgICAgICB9LFxuICAgICAgICAnb3ZlcnNldC1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdvdmVyc2V0JywgcDE6IG1oY2hlbVBhcnNlci5nbyhtWzBdKSwgcDI6IG1oY2hlbVBhcnNlci5nbyhtWzFdKSB9O1xuICAgICAgICB9LFxuICAgICAgICAndW5kZXJzZXQtb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAndW5kZXJzZXQnLCBwMTogbWhjaGVtUGFyc2VyLmdvKG1bMF0pLCBwMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0pIH07XG4gICAgICAgIH0sXG4gICAgICAgICd1bmRlcmJyYWNlLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ3VuZGVyYnJhY2UnLCBwMTogbWhjaGVtUGFyc2VyLmdvKG1bMF0pLCBwMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0pIH07XG4gICAgICAgIH0sXG4gICAgICAgICdjb2xvci1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb2xvcicsIGNvbG9yMTogbVswXSwgY29sb3IyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3I9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuciA9IG07IH0sXG4gICAgICAgICdyZHQ9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucmR0ID0gbTsgfSxcbiAgICAgICAgJ3JkPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJkID0gbTsgfSxcbiAgICAgICAgJ3JxdD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ycXQgPSBtOyB9LFxuICAgICAgICAncnE9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucnEgPSBtOyB9LFxuICAgICAgICAnb3BlcmF0b3InOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBwMSkgeyByZXR1cm4geyB0eXBlXzogJ29wZXJhdG9yJywga2luZF86IChwMSB8fCBtKSB9OyB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnYSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAnMS8yJCc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJzEvMicgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnMScsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnJCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoIHRpZ2h0JywgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnLCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2NvbW1hRGVjaW1hbCcgfSB9IH0sXG4gICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7fVxuICAgIH0sXG4gICAgJ28nOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJzEvMiQnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICcxLzInIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJzEnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJ2xldHRlcnMnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybScgfSB9LFxuICAgICAgICAnXFxcXGNhJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnY2lyY2EnIH0gfSB9LFxuICAgICAgICAnXFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICd7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAne3RleHR9JyB9IH0sXG4gICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7fVxuICAgIH0sXG4gICAgJ3RleHQnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0sXG4gICAgICAgICd7Li4ufSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQ9JyB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICdcXFxcZ3JlZWsnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdybScgXSB9IH0sXG4gICAgICAgICdcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2NvcHknIF0gfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQ9JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIGlmIChidWZmZXIudGV4dF8pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0fSAqL1xuICAgICAgICAgICAgdmFyIHJldCA9IHsgdHlwZV86ICd0ZXh0JywgcDE6IGJ1ZmZlci50ZXh0XyB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdwcSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAnc3RhdGUgb2YgYWdncmVnYXRpb24gJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJyB9IH0sXG4gICAgICAgICdpJCc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnIWYnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJyhLViBsZXR0ZXJzKSwnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdybScsIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ2Zvcm11bGEkJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICdmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICcxLzIkJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnMS8yJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICchZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnJHsoLi4uKX0kfCQoLi4uKSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAneyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQnIH0gfSxcbiAgICAgICAgJ2Eteic6IHtcbiAgICAgICAgICAnZic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICdsZXR0ZXJzJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm0nIH0gfSxcbiAgICAgICAgJy05Liw5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnOSw5JyAgfSB9LFxuICAgICAgICAnLCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCtwMScsIG9wdGlvbjogJ2NvbW1hIGVudW1lcmF0aW9uIFMnIH0gfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0xfFxcXFxjb2xvciguLi4peyguLi4pfTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvci1vdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX0wJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29sb3IwLW91dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NlJyB9IH0sXG4gICAgICAgICdcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfSxcbiAgICAgICAgJ2Vsc2UyJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnc3RhdGUgb2YgYWdncmVnYXRpb24gc3Vic2NyaXB0JywgcDE6IG1oY2hlbVBhcnNlci5nbyhtLCAnbycpIH07XG4gICAgICAgIH0sXG4gICAgICAgICdjb2xvci1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb2xvcicsIGNvbG9yMTogbVswXSwgY29sb3IyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSwgJ3BxJykgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2JkJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHt9IH0sXG4gICAgICAgICd4JCc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnIWYnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJ2Zvcm11bGEkJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICdmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICchZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnLTkuLDkgbm8gbWlzc2luZyAwJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnOSw5JyB9IH0sXG4gICAgICAgICcuJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnZWxlY3Ryb24gZG90JyB9IH0gfSxcbiAgICAgICAgJ2Eteic6IHtcbiAgICAgICAgICAnZic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICd4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnS1YgeCcgfSB9IH0sXG4gICAgICAgICdsZXR0ZXJzJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm0nIH0gfSxcbiAgICAgICAgJ1xcJyc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ3ByaW1lJyB9IH0gfSxcbiAgICAgICAgJyR7KC4uLil9JHwkKC4uLikkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ3soLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0JyB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9eyguLi4pfTF8XFxcXGNvbG9yKC4uLil7KC4uLil9Mic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvbG9yLW91dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfTAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvcjAtb3V0cHV0JyB9IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY2UnIH0gfSxcbiAgICAgICAgJ1xcXFwsfFxcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9LFxuICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnY29sb3Itb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29sb3InLCBjb2xvcjE6IG1bMF0sIGNvbG9yMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0sICdiZCcpIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdveGlkYXRpb24nOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJ3JvbWFuIG51bWVyYWwnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdyb21hbi1udW1lcmFsJyB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ3JvbWFuLW51bWVyYWwnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiB7IHR5cGVfOiAncm9tYW4gbnVtZXJhbCcsIHAxOiBtIHx8IFwiXCIgfTsgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3RleC1tYXRoJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2NlJyBdIH0gfSxcbiAgICAgICAgJ3suLi59fFxcXFwsfFxcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnbz0nIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvPScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLm8pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0fSAqL1xuICAgICAgICAgICAgdmFyIHJldCA9IHsgdHlwZV86ICd0ZXgtbWF0aCcsIHAxOiBidWZmZXIubyB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICd0ZXgtbWF0aCB0aWdodCc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdjZScgXSB9IH0sXG4gICAgICAgICd7Li4ufXxcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ289JyB9IH0sXG4gICAgICAgICctfCsnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0aWdodCBvcGVyYXRvcicgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ289JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAndGlnaHQgb3BlcmF0b3InOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5vID0gKGJ1ZmZlci5vIHx8IFwiXCIpICsgXCJ7XCIrbStcIn1cIjsgfSxcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLm8pIHtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0fSAqL1xuICAgICAgICAgICAgdmFyIHJldCA9IHsgdHlwZV86ICd0ZXgtbWF0aCcsIHAxOiBidWZmZXIubyB9O1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICc5LDknOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJywnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb21tYScgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdjb21tYSc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICdjb21tYURlY2ltYWwnIH07IH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vI2VuZHJlZ2lvblxuICAgIC8vXG4gICAgLy8gXFxwdSBzdGF0ZSBtYWNoaW5lc1xuICAgIC8vXG4gICAgLy8jcmVnaW9uIHB1XG4gICAgJ3B1Jzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnc3BhY2UkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnc3BhY2UnIF0gfSB9LFxuICAgICAgICAne1sofCldfSc6IHtcbiAgICAgICAgICAnMHxhJzogeyBhY3Rpb25fOiAnY29weScgfSB9LFxuICAgICAgICAnKC0pKDkpXigtOSknOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdudW1iZXJeJywgbmV4dFN0YXRlOiAnYScgfSB9LFxuICAgICAgICAnKC0pKDkuLDkpKGUpKDk5KSc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ2VudW1iZXInLCBuZXh0U3RhdGU6ICdhJyB9IH0sXG4gICAgICAgICdzcGFjZSc6IHtcbiAgICAgICAgICAnMHxhJzoge30gfSxcbiAgICAgICAgJ3BtLW9wZXJhdG9yJzoge1xuICAgICAgICAgICcwfGEnOiB7IGFjdGlvbl86IHsgdHlwZV86ICdvcGVyYXRvcicsIG9wdGlvbjogJ1xcXFxwbScgfSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnb3BlcmF0b3InOiB7XG4gICAgICAgICAgJzB8YSc6IHsgYWN0aW9uXzogJ2NvcHknLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICcvLyc6IHtcbiAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnLycgfSB9LFxuICAgICAgICAnLyc6IHtcbiAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnLycgfSB9LFxuICAgICAgICAney4uLn18ZWxzZSc6IHtcbiAgICAgICAgICAnMHxkJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICdhJzogeyBhY3Rpb25fOiBbICdzcGFjZScsICdkPScgXSwgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnL3xxJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdxJyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnZW51bWJlcic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBpZiAobVswXSA9PT0gXCIrLVwiICB8fCAgbVswXSA9PT0gXCIrLy1cIikge1xuICAgICAgICAgICAgcmV0LnB1c2goXCJcXFxccG0gXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobVswXSkge1xuICAgICAgICAgICAgcmV0LnB1c2gobVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtWzFdKSB7XG4gICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuZ28obVsxXSwgJ3B1LTksOScpKTtcbiAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgIGlmIChtWzJdLm1hdGNoKC9bLC5dLykpIHtcbiAgICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuZ28obVsyXSwgJ3B1LTksOScpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChtWzJdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbVszXSA9IG1bNF0gfHwgbVszXTtcbiAgICAgICAgICAgIGlmIChtWzNdKSB7XG4gICAgICAgICAgICAgIG1bM10gPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgICAgICAgaWYgKG1bM10gPT09IFwiZVwiICB8fCAgbVszXS5zdWJzdHIoMCwgMSkgPT09IFwiKlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2Nkb3QnIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICd0aW1lcycgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1bM10pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKFwiMTBee1wiK21bNV0rXCJ9XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnbnVtYmVyXic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBpZiAobVswXSA9PT0gXCIrLVwiICB8fCAgbVswXSA9PT0gXCIrLy1cIikge1xuICAgICAgICAgICAgcmV0LnB1c2goXCJcXFxccG0gXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobVswXSkge1xuICAgICAgICAgICAgcmV0LnB1c2gobVswXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtWzFdLCAncHUtOSw5JykpO1xuICAgICAgICAgIHJldC5wdXNoKFwiXntcIittWzJdK1wifVwiKTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnb3BlcmF0b3InOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBwMSkgeyByZXR1cm4geyB0eXBlXzogJ29wZXJhdG9yJywga2luZF86IChwMSB8fCBtKSB9OyB9LFxuICAgICAgICAnc3BhY2UnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAncHUtc3BhY2UtMScgfTsgfSxcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dCB8IFBhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgdmFyIG1kID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygneyguLi4pfScsIGJ1ZmZlci5kIHx8IFwiXCIpO1xuICAgICAgICAgIGlmIChtZCAgJiYgIG1kLnJlbWFpbmRlciA9PT0gJycpIHsgYnVmZmVyLmQgPSBtZC5tYXRjaF87IH1cbiAgICAgICAgICB2YXIgbXEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCd7KC4uLil9JywgYnVmZmVyLnEgfHwgXCJcIik7XG4gICAgICAgICAgaWYgKG1xICAmJiAgbXEucmVtYWluZGVyID09PSAnJykgeyBidWZmZXIucSA9IG1xLm1hdGNoXzsgfVxuICAgICAgICAgIGlmIChidWZmZXIuZCkge1xuICAgICAgICAgICAgYnVmZmVyLmQgPSBidWZmZXIuZC5yZXBsYWNlKC9cXHUwMEIwQ3xcXF5vQ3xcXF57b31DL2csIFwie31ee1xcXFxjaXJjfUNcIik7XG4gICAgICAgICAgICBidWZmZXIuZCA9IGJ1ZmZlci5kLnJlcGxhY2UoL1xcdTAwQjBGfFxcXm9GfFxcXntvfUYvZywgXCJ7fV57XFxcXGNpcmN9RlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJ1ZmZlci5xKSB7ICAvLyBmcmFjdGlvblxuICAgICAgICAgICAgYnVmZmVyLnEgPSBidWZmZXIucS5yZXBsYWNlKC9cXHUwMEIwQ3xcXF5vQ3xcXF57b31DL2csIFwie31ee1xcXFxjaXJjfUNcIik7XG4gICAgICAgICAgICBidWZmZXIucSA9IGJ1ZmZlci5xLnJlcGxhY2UoL1xcdTAwQjBGfFxcXm9GfFxcXntvfUYvZywgXCJ7fV57XFxcXGNpcmN9RlwiKTtcbiAgICAgICAgICAgIHZhciBiNSA9IHtcbiAgICAgICAgICAgICAgZDogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5kLCAncHUnKSxcbiAgICAgICAgICAgICAgcTogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5xLCAncHUnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChidWZmZXIubyA9PT0gJy8vJykge1xuICAgICAgICAgICAgICByZXQgPSB7IHR5cGVfOiAncHUtZnJhYycsIHAxOiBiNS5kLCBwMjogYjUucSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0gYjUuZDtcbiAgICAgICAgICAgICAgaWYgKGI1LmQubGVuZ3RoID4gMSAgfHwgIGI1LnEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcgLyAnIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcvJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBiNS5xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgeyAgLy8gbm8gZnJhY3Rpb25cbiAgICAgICAgICAgIHJldCA9IG1oY2hlbVBhcnNlci5nbyhidWZmZXIuZCwgJ3B1LTInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdwdS0yJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnKic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2Nkb3QnIF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ1xcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm09JyB9IH0sXG4gICAgICAgICdzcGFjZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3NwYWNlJyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdeeyguLi4pfXxeKC0xKSc6IHtcbiAgICAgICAgICAnMSc6IHsgYWN0aW9uXzogJ14oLTEpJyB9IH0sXG4gICAgICAgICctOS4sOSc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ3JtPScsIG5leHRTdGF0ZTogJzAnIH0sXG4gICAgICAgICAgJzEnOiB7IGFjdGlvbl86ICdeKC0xKScsIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ3suLi59fGVsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybT0nLCBuZXh0U3RhdGU6ICcxJyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnY2RvdCc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICd0aWdodCBjZG90JyB9OyB9LFxuICAgICAgICAnXigtMSknOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ybSArPSBcIl57XCIrbStcIn1cIjsgfSxcbiAgICAgICAgJ3NwYWNlJzogZnVuY3Rpb24gKCkgeyByZXR1cm4geyB0eXBlXzogJ3B1LXNwYWNlLTInIH07IH0sXG4gICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXQgfCBQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgaWYgKGJ1ZmZlci5ybSkge1xuICAgICAgICAgICAgdmFyIG1ybSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ3soLi4uKX0nLCBidWZmZXIucm0gfHwgXCJcIik7XG4gICAgICAgICAgICBpZiAobXJtICAmJiAgbXJtLnJlbWFpbmRlciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0ID0gbWhjaGVtUGFyc2VyLmdvKG1ybS5tYXRjaF8sICdwdScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0geyB0eXBlXzogJ3JtJywgcDE6IGJ1ZmZlci5ybSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3B1LTksOSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdvdXRwdXQtMCcgfSxcbiAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogJ291dHB1dC1vJyB9IH0sXG4gICAgICAgICcsJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiBbICdvdXRwdXQtMCcsICdjb21tYScgXSwgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnLic6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0LTAnLCAnY29weScgXSwgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQ9JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnY29tbWEnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAnY29tbWFEZWNpbWFsJyB9OyB9LFxuICAgICAgICAnb3V0cHV0LTAnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgYnVmZmVyLnRleHRfID0gYnVmZmVyLnRleHRfIHx8IFwiXCI7XG4gICAgICAgICAgaWYgKGJ1ZmZlci50ZXh0Xy5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGJ1ZmZlci50ZXh0Xy5sZW5ndGggJSAzO1xuICAgICAgICAgICAgaWYgKGEgPT09IDApIHsgYSA9IDM7IH1cbiAgICAgICAgICAgIGZvciAodmFyIGk9YnVmZmVyLnRleHRfLmxlbmd0aC0zOyBpPjA7IGktPTMpIHtcbiAgICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfLnN1YnN0cihpLCAzKSk7XG4gICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcxMDAwIHNlcGFyYXRvcicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKDAsIGEpKTtcbiAgICAgICAgICAgIHJldC5yZXZlcnNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnb3V0cHV0LW8nOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgYnVmZmVyLnRleHRfID0gYnVmZmVyLnRleHRfIHx8IFwiXCI7XG4gICAgICAgICAgaWYgKGJ1ZmZlci50ZXh0Xy5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICB2YXIgYSA9IGJ1ZmZlci50ZXh0Xy5sZW5ndGggLSAzO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGE7IGkrPTMpIHtcbiAgICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfLnN1YnN0cihpLCAzKSk7XG4gICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICcxMDAwIHNlcGFyYXRvcicgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKGkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8jZW5kcmVnaW9uXG4gIH07XG5cbiAgLy9cbiAgLy8gdGV4aWZ5OiBUYWtlIE1oY2hlbVBhcnNlciBvdXRwdXQgYW5kIGNvbnZlcnQgaXQgdG8gVGVYXG4gIC8vXG4gIC8qKiBAdHlwZSB7VGV4aWZ5fSAqL1xuICB2YXIgdGV4aWZ5ID0ge1xuICAgIGdvOiBmdW5jdGlvbiAoaW5wdXQsIGlzSW5uZXIpIHsgIC8vIChyZWN1cnNpdmUsIG1heCA0IGxldmVscylcbiAgICAgIGlmICghaW5wdXQpIHsgcmV0dXJuIFwiXCI7IH1cbiAgICAgIHZhciByZXMgPSBcIlwiO1xuICAgICAgdmFyIGNlZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaT0wOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0aSA9IGlucHV0W2ldO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0aSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJlcyArPSBpbnB1dGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzICs9IHRleGlmeS5fZ28yKGlucHV0aSk7XG4gICAgICAgICAgaWYgKGlucHV0aS50eXBlXyA9PT0gJzFzdC1sZXZlbCBlc2NhcGUnKSB7IGNlZSA9IHRydWU7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc0lubmVyICYmICFjZWUgJiYgcmVzKSB7XG4gICAgICAgIHJlcyA9IFwie1wiICsgcmVzICsgXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgX2dvSW5uZXI6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgaWYgKCFpbnB1dCkgeyByZXR1cm4gaW5wdXQ7IH1cbiAgICAgIHJldHVybiB0ZXhpZnkuZ28oaW5wdXQsIHRydWUpO1xuICAgIH0sXG4gICAgX2dvMjogZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgLyoqIEB0eXBlIHt1bmRlZmluZWQgfCBzdHJpbmd9ICovXG4gICAgICB2YXIgcmVzO1xuICAgICAgc3dpdGNoIChidWYudHlwZV8pIHtcbiAgICAgICAgY2FzZSAnY2hlbWZpdmUnOlxuICAgICAgICAgIHJlcyA9IFwiXCI7XG4gICAgICAgICAgdmFyIGI1ID0ge1xuICAgICAgICAgICAgYTogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5hKSxcbiAgICAgICAgICAgIGI6IHRleGlmeS5fZ29Jbm5lcihidWYuYiksXG4gICAgICAgICAgICBwOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLnApLFxuICAgICAgICAgICAgbzogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5vKSxcbiAgICAgICAgICAgIHE6IHRleGlmeS5fZ29Jbm5lcihidWYucSksXG4gICAgICAgICAgICBkOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLmQpXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGFcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChiNS5hKSB7XG4gICAgICAgICAgICBpZiAoYjUuYS5tYXRjaCgvXlsrXFwtXS8pKSB7IGI1LmEgPSBcIntcIitiNS5hK1wifVwiOyB9XG4gICAgICAgICAgICByZXMgKz0gYjUuYSArIFwiXFxcXCxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBiIGFuZCBwXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoYjUuYiB8fCBiNS5wKSB7XG4gICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgcmVzICs9IFwiXntcXFxcaHBoYW50b217XCIrKGI1LmJ8fFwiXCIpK1wifX1fe1xcXFxocGhhbnRvbXtcIisoYjUucHx8XCJcIikrXCJ9fVwiO1xuICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgIC8vIEluIHRoZSBuZXh0IHR3byBsaW5lcywgSSd2ZSByZW1vdmVkIFxcc21hc2hbdF0gKHJvbilcbiAgICAgICAgICAgIC8vIFRPRE86IFJldmVydCBcXHNtYXNoW3RdIHdoZW4gV2ViS2l0IHByb3Blcmx5IHJlbmRlcnMgPG1wYWRkZWQ+IHcvaGVpZ2h0PVwiMFwiXG4gICAgICAgICAgICAvL3JlcyArPSBcIl57XFxcXHNtYXNoW3Rde1xcXFx2cGhhbnRvbXsyfX1cXFxcbWF0aGxsYXB7XCIrKGI1LmJ8fFwiXCIpK1wifX1cIjtcbiAgICAgICAgICAgIHJlcyArPSBcIl57XFxcXHZwaGFudG9tezJ9XFxcXG1hdGhsbGFwe1wiKyhiNS5ifHxcIlwiKStcIn19XCI7XG4gICAgICAgICAgICAvL3JlcyArPSBcIl97XFxcXHZwaGFudG9tezJ9XFxcXG1hdGhsbGFwe1xcXFxzbWFzaFt0XXtcIisoYjUucHx8XCJcIikrXCJ9fX1cIjtcbiAgICAgICAgICAgIHJlcyArPSBcIl97XFxcXHZwaGFudG9tezJ9XFxcXG1hdGhsbGFwe1wiKyhiNS5wfHxcIlwiKStcIn19XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gb1xuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKGI1Lm8pIHtcbiAgICAgICAgICAgIGlmIChiNS5vLm1hdGNoKC9eWytcXC1dLykpIHsgYjUubyA9IFwie1wiK2I1Lm8rXCJ9XCI7IH1cbiAgICAgICAgICAgIHJlcyArPSBiNS5vO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIHEgYW5kIGRcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChidWYuZFR5cGUgPT09ICdrdicpIHtcbiAgICAgICAgICAgIGlmIChiNS5kIHx8IGI1LnEpIHtcbiAgICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5kKSB7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl57XCIrYjUuZCtcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5xKSB7XG4gICAgICAgICAgICAgIC8vIEluIHRoZSBuZXh0IGxpbmUsIEkndmUgcmVtb3ZlZCBcXHNtYXNoW3RdIChyb24pXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJldmVydCBcXHNtYXNoW3RdIHdoZW4gV2ViS2l0IHByb3Blcmx5IHJlbmRlcnMgPG1wYWRkZWQ+IHcvaGVpZ2h0PVwiMFwiXG4gICAgICAgICAgICAgIC8vcmVzICs9IFwiX3tcXFxcc21hc2hbdF17XCIrYjUucStcIn19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl97XCIrYjUucStcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGJ1Zi5kVHlwZSA9PT0gJ294aWRhdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChiNS5kKSB7XG4gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl57XCIrYjUuZCtcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5xKSB7XG4gICAgICAgICAgICAgIC8vIEEgRmlyZWZveCBidWcgYWRkcyBhIGJvZ3VzIGRlcHRoIHRvIDxtcGhhbnRvbT4sIHNvIHdlIGNoYW5nZSBcXHZwaGFudG9te1h9IHRvIHt9XG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlaW5zdGF0ZSBcXHZwaGFudG9te1h9IHdoZW4gdGhlIEZpcmVmb3ggYnVnIGlzIGZpeGVkLlxuLy8gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcInt7fX1cIjtcbiAgICAgICAgICAgICAgLy8gSW4gdGhlIG5leHQgbGluZSwgSSd2ZSByZW1vdmVkIFxcc21hc2hbdF0gKHJvbilcbiAgICAgICAgICAgICAgLy8gVE9ETzogUmV2ZXJ0IFxcc21hc2hbdF0gd2hlbiBXZWJLaXQgcHJvcGVybHkgcmVuZGVycyA8bXBhZGRlZD4gdy9oZWlnaHQ9XCIwXCJcbiAgICAgICAgICAgICAgLy9yZXMgKz0gXCJfe1xcXFxzbWFzaFt0XXtcIitiNS5xK1wifX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwiX3tcIitiNS5xK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYjUucSkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBSZWluc3RhdGUgXFx2cGhhbnRvbXtYfSB3aGVuIHRoZSBGaXJlZm94IGJ1ZyBpcyBmaXhlZC5cbi8vICAgICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJ7e319XCI7XG4gICAgICAgICAgICAgIC8vIEluIHRoZSBuZXh0IGxpbmUsIEkndmUgcmVtb3ZlZCBcXHNtYXNoW3RdIChyb24pXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJldmVydCBcXHNtYXNoW3RdIHdoZW4gV2ViS2l0IHByb3Blcmx5IHJlbmRlcnMgPG1wYWRkZWQ+IHcvaGVpZ2h0PVwiMFwiXG4gICAgICAgICAgICAgIC8vcmVzICs9IFwiX3tcXFxcc21hc2hbdF17XCIrYjUucStcIn19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl97XCIrYjUucStcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiNS5kKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlaW5zdGF0ZSBcXHZwaGFudG9te1h9IHdoZW4gdGhlIEZpcmVmb3ggYnVnIGlzIGZpeGVkLlxuLy8gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcInt7fX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwiXntcIitiNS5kK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncm0nOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhybXtcIitidWYucDErXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgIGlmIChidWYucDEubWF0Y2goL1tcXF5fXS8pKSB7XG4gICAgICAgICAgICBidWYucDEgPSBidWYucDEucmVwbGFjZShcIiBcIiwgXCJ+XCIpLnJlcGxhY2UoXCItXCIsIFwiXFxcXHRleHR7LX1cIik7XG4gICAgICAgICAgICByZXMgPSBcIlxcXFxtYXRocm17XCIrYnVmLnAxK1wifVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBcIlxcXFx0ZXh0e1wiK2J1Zi5wMStcIn1cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JvbWFuIG51bWVyYWwnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhybXtcIitidWYucDErXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxtc2tpcDJtdSBcIit0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RhdGUgb2YgYWdncmVnYXRpb24gc3Vic2NyaXB0JzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxtc2tpcDFtdSBcIit0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm9uZCc6XG4gICAgICAgICAgcmVzID0gdGV4aWZ5Ll9nZXRCb25kKGJ1Zi5raW5kXyk7XG4gICAgICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgICAgIHRocm93IFtcIk1oY2hlbUVycm9yQm9uZFwiLCBcIm1oY2hlbSBFcnJvci4gVW5rbm93biBib25kIHR5cGUgKFwiICsgYnVmLmtpbmRfICsgXCIpXCJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnJhYyc6XG4gICAgICAgICAgdmFyIGMgPSBcIlxcXFxmcmFje1wiICsgYnVmLnAxICsgXCJ9e1wiICsgYnVmLnAyICsgXCJ9XCI7XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWF0aGNob2ljZXtcXFxcdGV4dHN0eWxlXCIrYytcIn17XCIrYytcIn17XCIrYytcIn17XCIrYytcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHUtZnJhYyc6XG4gICAgICAgICAgdmFyIGQgPSBcIlxcXFxmcmFje1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhjaG9pY2V7XFxcXHRleHRzdHlsZVwiK2QrXCJ9e1wiK2QrXCJ9e1wiK2QrXCJ9e1wiK2QrXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RleC1tYXRoJzpcbiAgICAgICAgICByZXMgPSBidWYucDEgKyBcIiBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnJhYy1jZSc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcZnJhY3tcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3ZlcnNldCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcb3ZlcnNldHtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndW5kZXJzZXQnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXHVuZGVyc2V0e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1bmRlcmJyYWNlJzpcbiAgICAgICAgICByZXMgPSAgXCJcXFxcdW5kZXJicmFjZXtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9X3tcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDIpICsgXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICByZXMgPSBcIntcXFxcY29sb3J7XCIgKyBidWYuY29sb3IxICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5jb2xvcjIpICsgXCJ9fVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2xvcjAnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXGNvbG9ye1wiICsgYnVmLmNvbG9yICsgXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Fycm93JzpcbiAgICAgICAgICB2YXIgYjYgPSB7XG4gICAgICAgICAgICByZDogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5yZCksXG4gICAgICAgICAgICBycTogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5ycSlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBhcnJvdyA9IHRleGlmeS5fZ2V0QXJyb3coYnVmLnIpO1xuICAgICAgICAgIGlmIChiNi5ycSkgeyBhcnJvdyArPSBcIlt7XFxcXHJtIFwiICsgYjYucnEgKyBcIn1dXCI7IH1cbiAgICAgICAgICBpZiAoYjYucmQpIHtcbiAgICAgICAgICAgIGFycm93ICs9IFwie1xcXFxybSBcIiArIGI2LnJkICsgXCJ9XCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycm93ICs9IFwie31cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzID0gYXJyb3c7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29wZXJhdG9yJzpcbiAgICAgICAgICByZXMgPSB0ZXhpZnkuX2dldE9wZXJhdG9yKGJ1Zi5raW5kXyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzFzdC1sZXZlbCBlc2NhcGUnOlxuICAgICAgICAgIHJlcyA9IGJ1Zi5wMStcIiBcIjsgIC8vICYsIFxcXFxcXFxcLCBcXFxcaGxpblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgcmVzID0gXCIgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VudGl0eVNraXAnOlxuICAgICAgICAgIHJlcyA9IFwiflwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwdS1zcGFjZS0xJzpcbiAgICAgICAgICByZXMgPSBcIn5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHUtc3BhY2UtMic6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWtlcm4zbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJzEwMDAgc2VwYXJhdG9yJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjJtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29tbWFEZWNpbWFsJzpcbiAgICAgICAgICByZXMgPSBcInssfVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NvbW1hIGVudW1lcmF0aW9uIEwnOlxuICAgICAgICAgIHJlcyA9IFwie1wiK2J1Zi5wMStcIn1cXFxcbWtlcm42bXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbW1hIGVudW1lcmF0aW9uIE0nOlxuICAgICAgICAgIHJlcyA9IFwie1wiK2J1Zi5wMStcIn1cXFxcbWtlcm4zbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbW1hIGVudW1lcmF0aW9uIFMnOlxuICAgICAgICAgIHJlcyA9IFwie1wiK2J1Zi5wMStcIn1cXFxcbWtlcm4xbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2h5cGhlbic6XG4gICAgICAgICAgcmVzID0gXCJcXFxcdGV4dHstfVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhZGRpdGlvbiBjb21wb3VuZCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcLHtcXFxcY2RvdH1cXFxcLFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbGVjdHJvbiBkb3QnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1rZXJuMW11IFxcXFx0ZXh0e1xcXFx0ZXh0YnVsbGV0fVxcXFxta2VybjFtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnS1YgeCc6XG4gICAgICAgICAgcmVzID0gXCJ7XFxcXHRpbWVzfVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwcmltZSc6XG4gICAgICAgICAgcmVzID0gXCJcXFxccHJpbWUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Nkb3QnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXGNkb3QgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RpZ2h0IGNkb3QnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1rZXJuMW11e1xcXFxjZG90fVxcXFxta2VybjFtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGltZXMnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXHRpbWVzIFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaXJjYSc6XG4gICAgICAgICAgcmVzID0gXCJ7XFxcXHNpbX1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgcmVzID0gXCJ1cGFycm93XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgIHJlcyA9IFwiZG93bmFycm93XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VsbGlwc2lzJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxsZG90cyBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgcmVzID0gXCIvXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyAvICc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcLC9cXFxcLFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydE5ldmVyKGJ1Zik7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07ICAvLyBNaXNzaW5nIHRleGlmeSBydWxlIG9yIHVua25vd24gTWhjaGVtUGFyc2VyIG91dHB1dFxuICAgICAgfVxuICAgICAgYXNzZXJ0U3RyaW5nKHJlcyk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgX2dldEFycm93OiBmdW5jdGlvbiAoYSkge1xuICAgICAgc3dpdGNoIChhKSB7XG4gICAgICAgIGNhc2UgXCItPlwiOiByZXR1cm4gXCJcXFxceWllbGRzXCI7XG4gICAgICAgIGNhc2UgXCJcXHUyMTkyXCI6IHJldHVybiBcIlxcXFx5aWVsZHNcIjtcbiAgICAgICAgY2FzZSBcIlxcdTI3RjZcIjogcmV0dXJuIFwiXFxcXHlpZWxkc1wiO1xuICAgICAgICBjYXNlIFwiPC1cIjogcmV0dXJuIFwiXFxcXHlpZWxkc0xlZnRcIjtcbiAgICAgICAgY2FzZSBcIjwtPlwiOiByZXR1cm4gXCJcXFxcbWVzb21lcmlzbVwiO1xuICAgICAgICBjYXNlIFwiPC0tPlwiOiByZXR1cm4gXCJcXFxceWllbGRzTGVmdFJpZ2h0XCI7XG4gICAgICAgIGNhc2UgXCI8PT5cIjogcmV0dXJuIFwiXFxcXGVxdWlsaWJyaXVtXCI7XG4gICAgICAgIGNhc2UgXCJcXHUyMUNDXCI6IHJldHVybiBcIlxcXFxlcXVpbGlicml1bVwiO1xuICAgICAgICBjYXNlIFwiPD0+PlwiOiByZXR1cm4gXCJcXFxcZXF1aWxpYnJpdW1SaWdodFwiO1xuICAgICAgICBjYXNlIFwiPDw9PlwiOiByZXR1cm4gXCJcXFxcZXF1aWxpYnJpdW1MZWZ0XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXNzZXJ0TmV2ZXIoYSk7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0Qm9uZDogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gXCJ7LX1cIjtcbiAgICAgICAgY2FzZSBcIjFcIjogcmV0dXJuIFwiey19XCI7XG4gICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiBcIns9fVwiO1xuICAgICAgICBjYXNlIFwiMlwiOiByZXR1cm4gXCJ7PX1cIjtcbiAgICAgICAgY2FzZSBcIiNcIjogcmV0dXJuIFwie1xcXFxlcXVpdn1cIjtcbiAgICAgICAgY2FzZSBcIjNcIjogcmV0dXJuIFwie1xcXFxlcXVpdn1cIjtcbiAgICAgICAgY2FzZSBcIn5cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVEYXNofVwiO1xuICAgICAgICBjYXNlIFwifi1cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVEYXNoT3ZlckxpbmV9XCI7XG4gICAgICAgIGNhc2UgXCJ+PVwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2hPdmVyRG91YmxlTGluZX1cIjtcbiAgICAgICAgY2FzZSBcIn4tLVwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2hPdmVyRG91YmxlTGluZX1cIjtcbiAgICAgICAgY2FzZSBcIi1+LVwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2hCZXR3ZWVuRG91YmxlTGluZX1cIjtcbiAgICAgICAgY2FzZSBcIi4uLlwiOiByZXR1cm4gXCJ7e1xcXFxjZG90fXtcXFxcY2RvdH17XFxcXGNkb3R9fVwiO1xuICAgICAgICBjYXNlIFwiLi4uLlwiOiByZXR1cm4gXCJ7e1xcXFxjZG90fXtcXFxcY2RvdH17XFxcXGNkb3R9e1xcXFxjZG90fX1cIjtcbiAgICAgICAgY2FzZSBcIi0+XCI6IHJldHVybiBcIntcXFxccmlnaHRhcnJvd31cIjtcbiAgICAgICAgY2FzZSBcIjwtXCI6IHJldHVybiBcIntcXFxcbGVmdGFycm93fVwiO1xuICAgICAgICBjYXNlIFwiPFwiOiByZXR1cm4gXCJ7PH1cIjtcbiAgICAgICAgY2FzZSBcIj5cIjogcmV0dXJuIFwiez59XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXNzZXJ0TmV2ZXIoYSk7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0T3BlcmF0b3I6IGZ1bmN0aW9uIChhKSB7XG4gICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgY2FzZSBcIitcIjogcmV0dXJuIFwiIHt9K3t9IFwiO1xuICAgICAgICBjYXNlIFwiLVwiOiByZXR1cm4gXCIge30te30gXCI7XG4gICAgICAgIGNhc2UgXCI9XCI6IHJldHVybiBcIiB7fT17fSBcIjtcbiAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIFwiIHt9PHt9IFwiO1xuICAgICAgICBjYXNlIFwiPlwiOiByZXR1cm4gXCIge30+e30gXCI7XG4gICAgICAgIGNhc2UgXCI8PFwiOiByZXR1cm4gXCIge31cXFxcbGx7fSBcIjtcbiAgICAgICAgY2FzZSBcIj4+XCI6IHJldHVybiBcIiB7fVxcXFxnZ3t9IFwiO1xuICAgICAgICBjYXNlIFwiXFxcXHBtXCI6IHJldHVybiBcIiB7fVxcXFxwbXt9IFwiO1xuICAgICAgICBjYXNlIFwiXFxcXGFwcHJveFwiOiByZXR1cm4gXCIge31cXFxcYXBwcm94e30gXCI7XG4gICAgICAgIGNhc2UgXCIkXFxcXGFwcHJveCRcIjogcmV0dXJuIFwiIHt9XFxcXGFwcHJveHt9IFwiO1xuICAgICAgICBjYXNlIFwidlwiOiByZXR1cm4gXCIgXFxcXGRvd25hcnJvd3t9IFwiO1xuICAgICAgICBjYXNlIFwiKHYpXCI6IHJldHVybiBcIiBcXFxcZG93bmFycm93e30gXCI7XG4gICAgICAgIGNhc2UgXCJeXCI6IHJldHVybiBcIiBcXFxcdXBhcnJvd3t9IFwiO1xuICAgICAgICBjYXNlIFwiKF4pXCI6IHJldHVybiBcIiBcXFxcdXBhcnJvd3t9IFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydE5ldmVyKGEpO1xuICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1RcIiwgXCJtaGNoZW0gYnVnIFQuIFBsZWFzZSByZXBvcnQuXCJdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvL1xuICAvLyBIZWxwZXJzIGZvciBjb2RlIGFuYWx5c2lzXG4gIC8vIFdpbGwgc2hvdyB0eXBlIGVycm9yIGF0IGNhbGxpbmcgcG9zaXRpb25cbiAgLy9cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBhICovXG4gIGZ1bmN0aW9uIGFzc2VydE5ldmVyKGEpIHt9XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gYSAqL1xuICBmdW5jdGlvbiBhc3NlcnRTdHJpbmcoYSkge31cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdGV4dmMuc3R5XG5cbi8vIFRoZSB0ZXh2YyBwYWNrYWdlIGNvbnRhaW5zIG1hY3JvcyBhdmFpbGFibGUgaW4gbWVkaWF3aWtpIHBhZ2VzLlxuLy8gV2Ugb21pdCB0aGUgZnVuY3Rpb25zIGRlcHJlY2F0ZWQgYXRcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlbHA6RGlzcGxheWluZ19hX2Zvcm11bGEjRGVwcmVjYXRlZF9zeW50YXhcblxuLy8gV2UgYWxzbyBvbWl0IHRleHZjJ3MgXFxPLCB3aGljaCBjb25mbGljdHMgd2l0aCBcXHRleHR7XFxPfVxuXG5kZWZpbmVNYWNybyhcIlxcXFxkYXJyXCIsIFwiXFxcXGRvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRBcnJcIiwgXCJcXFxcRG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRGFyclwiLCBcIlxcXFxEb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYW5nXCIsIFwiXFxcXGxhbmdsZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhbmdcIiwgXCJcXFxccmFuZ2xlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdWFyclwiLCBcIlxcXFx1cGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdUFyclwiLCBcIlxcXFxVcGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcVWFyclwiLCBcIlxcXFxVcGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTlwiLCBcIlxcXFxtYXRoYmJ7Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFpcIiwgXCJcXFxcbWF0aGJie1p9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWxlZlwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFsZWZzeW1cIiwgXCJcXFxcYWxlcGhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxidWxsXCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNsdWJzXCIsIFwiXFxcXGNsdWJzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY251bXNcIiwgXCJcXFxcbWF0aGJie0N9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQ29tcGxleFwiLCBcIlxcXFxtYXRoYmJ7Q31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxEYWdnZXJcIiwgXCJcXFxcZGRhZ2dlclwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRpYW1vbmRzXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZW1wdHlcIiwgXCJcXFxcZW1wdHlzZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxleGlzdFwiLCBcIlxcXFxleGlzdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoYXJyXCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaEFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEhhcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoZWFydHNcIiwgXCJcXFxcaGVhcnRzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1hZ2VcIiwgXCJcXFxcSW1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbmZpblwiLCBcIlxcXFxpbmZ0eVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlzaW5cIiwgXCJcXFxcaW5cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYXJyXCIsIFwiXFxcXGxlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxBcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTGFyclwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxscmFyclwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcTHJhcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxuYXRudW1zXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBsdXNtblwiLCBcIlxcXFxwbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhcnJcIiwgXCJcXFxccmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJBcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJhcnJcIiwgXCJcXFxcUmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxcIiwgXCJcXFxcUmVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSZWFsc1wiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZG90XCIsIFwiXFxcXGNkb3RcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzZWN0XCIsIFwiXFxcXFNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzcGFkZXNcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3ViXCIsIFwiXFxcXHN1YnNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YmVcIiwgXCJcXFxcc3Vic2V0ZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdXBlXCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGhldGFzeW1cIiwgXCJcXFxcdmFydGhldGFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx3ZWllcnBcIiwgXCJcXFxcd3BcIik7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogIHBoeXNpY3MuanNcbiAqXG4gKiAgSW1wbGVtZW50cyB0aGUgUGh5c2ljcyBQYWNrYWdlIGZvciBMYVRlWCBpbnB1dC5cbiAqXG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogIFRoZSBvcmlnaW5hbCB2ZXJzaW9uIG9mIHRoaXMgZmlsZSBpcyBsaWNlbnNlZCBhcyBmb2xsb3dzOlxuICogIENvcHlyaWdodCAoYykgMjAxNS0yMDE2IEtvbGVuIENoZXVuZyA8aHR0cHM6Ly9naXRodWIuY29tL2lja2MvTWF0aEpheC10aGlyZC1wYXJ0eS1leHRlbnNpb25zPi5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICBUaGlzIGZpbGUgaGFzIGJlZW4gcmV2aXNlZCBmcm9tIHRoZSBvcmlnaW5hbCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAgMS4gVGhlIGludGVyZmFjZSBpcyBjaGFuZ2VkIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIFRlbW1sLCBub3QgTWF0aEpheC5cbiAqICAyLiBcXFJlIGFuZCBcXEltIGFyZSBub3QgdXNlZCwgdG8gYXZvaWQgY29uZmxpY3Qgd2l0aCBleGlzdGluZyBMYVRlWCBsZXR0ZXJzLlxuICpcbiAqICBUaGlzIHJldmlzaW9uIG9mIHRoZSBmaWxlIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqICBodHRwczovL21pdC1saWNlbnNlLm9yZy9cbiAqL1xuZGVmaW5lTWFjcm8oXCJcXFxccXVhbnRpdHlcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxdHlcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwcXR5XCIsIFwie1xcXFxsZWZ0KCAjMSBcXFxccmlnaHQpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJxdHlcIiwgXCJ7XFxcXGxlZnRbICMxIFxcXFxyaWdodF19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdnF0eVwiLCBcIntcXFxcbGVmdFxcXFx2ZXJ0ICMxIFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJxdHlcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhYnNvbHV0ZXZhbHVlXCIsIFwie1xcXFxsZWZ0XFxcXHZlcnQgIzEgXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWJzXCIsIFwie1xcXFxsZWZ0XFxcXHZlcnQgIzEgXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbm9ybVwiLCBcIntcXFxcbGVmdFxcXFxWZXJ0ICMxIFxcXFxyaWdodFxcXFxWZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV2YWx1YXRlZFwiLCBcIntcXFxcbGVmdC4jMSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxldmFsXCIsIFwie1xcXFxsZWZ0LiMxIFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9yZGVyXCIsIFwie1xcXFxtYXRoY2Fse099IFxcXFxsZWZ0KCAjMSBcXFxccmlnaHQpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbW11dGF0b3JcIiwgXCJ7XFxcXGxlZnRbICMxICwgIzIgXFxcXHJpZ2h0XX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb21tXCIsIFwie1xcXFxsZWZ0WyAjMSAsICMyIFxcXFxyaWdodF19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYW50aWNvbW11dGF0b3JcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSAsICMyIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFjb21tXCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgLCAjMiBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwb2lzc29uYnJhY2tldFwiLCBcIntcXFxcbGVmdFxcXFx7ICMxICwgIzIgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGJcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSAsICMyIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZlY3RvcmJvbGRcIiwgXCJ7XFxcXGJvbGRzeW1ib2x7ICMxIH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmJcIiwgXCJ7XFxcXGJvbGRzeW1ib2x7ICMxIH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmVjdG9yYXJyb3dcIiwgXCJ7XFxcXHZlY3tcXFxcYm9sZHN5bWJvbHsgIzEgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFcIiwgXCJ7XFxcXHZlY3tcXFxcYm9sZHN5bWJvbHsgIzEgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmVjdG9ydW5pdFwiLCBcInt7XFxcXGJvbGRzeW1ib2x7XFxcXGhhdHsgIzEgfX19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZ1XCIsIFwie3tcXFxcYm9sZHN5bWJvbHtcXFxcaGF0eyAjMSB9fX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90cHJvZHVjdFwiLCBcIlxcXFxtYXRoYmlue1xcXFxib2xkc3ltYm9sXFxcXGNkb3R9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmRvdFwiLCBcIntcXFxcYm9sZHN5bWJvbFxcXFxjZG90fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNyb3NzcHJvZHVjdFwiLCBcIlxcXFxtYXRoYmlue1xcXFxib2xkc3ltYm9sXFxcXHRpbWVzfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNyb3NzXCIsIFwiXFxcXG1hdGhiaW57XFxcXGJvbGRzeW1ib2xcXFxcdGltZXN9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY3BcIiwgXCJcXFxcbWF0aGJpbntcXFxcYm9sZHN5bWJvbFxcXFx0aW1lc31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmFkaWVudFwiLCBcIntcXFxcYm9sZHN5bWJvbFxcXFxuYWJsYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxncmFkXCIsIFwie1xcXFxib2xkc3ltYm9sXFxcXG5hYmxhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRpdmVyZ2VuY2VcIiwgXCJ7XFxcXGdyYWRcXFxcdmRvdH1cIik7XG4vL2RlZmluZU1hY3JvKFwiXFxcXGRpdlwiLCBcIntcXFxcZ3JhZFxcXFx2ZG90fVwiKTsgTm90IGluY2x1ZGVkIGluIFRlbW1sLiBDb25mbGljdHMgdy9MYVRlWCBcXGRpdlxuZGVmaW5lTWFjcm8oXCJcXFxcY3VybFwiLCBcIntcXFxcZ3JhZFxcXFxjcm9zc31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsYXBsYWNpYW5cIiwgXCJcXFxcbmFibGFeMlwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRyXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7dHJ9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFRyXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7VHJ9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJhbmtcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtyYW5rfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcmZcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtlcmZ9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJlc1wiLCBcIntcXFxcb3BlcmF0b3JuYW1le1Jlc319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHJpbmNpcGFsdmFsdWVcIiwgXCJ7XFxcXG1hdGhjYWx7UH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHZcIiwgXCJ7XFxcXG1hdGhjYWx7UH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUFZcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtQLlYufX1cIik7XG4vLyBUZW1tbCBkb2VzIG5vdCB1c2UgdGhlIG5leHQgdHdvIGxpbmVzLiBUaGV5IGNvbmZsaWN0IHdpdGggTGFUZVggbGV0dGVycy5cbi8vZGVmaW5lTWFjcm8oXCJcXFxcUmVcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtSZX0gXFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG4vL2RlZmluZU1hY3JvKFwiXFxcXEltXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7SW19IFxcXFxsZWZ0XFxcXHsgIzEgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXF0ZXh0XCIsIFwie1xcXFxxdWFkXFxcXHRleHR7ICMxIH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxcVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0eyAjMSB9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWNvbW1hXCIsIFwie1xcXFx0ZXh0eyx9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWNcIiwgXCJ7XFxcXHRleHR7LH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxY2NcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtjLmMufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFpZlwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2lmfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHF0aGVuXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7dGhlbn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxZWxzZVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2Vsc2V9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccW90aGVyd2lzZVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e290aGVyd2lzZX1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxdW5sZXNzXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7dW5sZXNzfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFnaXZlblwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2dpdmVufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHF1c2luZ1wiLCBcIntcXFxccXVhZFxcXFx0ZXh0e3VzaW5nfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFhc3N1bWVcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHthc3N1bWV9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXNpbmNlXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7c2luY2V9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWxldFwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2xldH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxZm9yXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7Zm9yfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFhbGxcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHthbGx9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWV2ZW5cIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtldmVufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFvZGRcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtvZGR9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWludGVnZXJcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtpbnRlZ2VyfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFhbmRcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHthbmR9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccW9yXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7b3J9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWFzXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7YXN9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWluXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7aW59XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGlmZmVyZW50aWFsXCIsIFwie1xcXFx0ZXh0e2R9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRkXCIsIFwie1xcXFx0ZXh0e2R9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRlcml2YXRpdmVcIiwgXCJ7XFxcXGZyYWN7XFxcXHRleHR7ZH17ICMxIH19e1xcXFx0ZXh0e2R9eyAjMiB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkdlwiLCBcIntcXFxcZnJhY3tcXFxcdGV4dHtkfXsgIzEgfX17XFxcXHRleHR7ZH17ICMyIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBhcnRpYWxkZXJpdmF0aXZlXCIsIFwie1xcXFxmcmFje1xcXFxwYXJ0aWFseyAjMSB9fXtcXFxccGFydGlhbHsgIzIgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyaWF0aW9uXCIsIFwie1xcXFxkZWx0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJcIiwgXCJ7XFxcXGRlbHRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGZ1bmN0aW9uYWxkZXJpdmF0aXZlXCIsIFwie1xcXFxmcmFje1xcXFxkZWx0YXsgIzEgfX17XFxcXGRlbHRheyAjMiB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxmZHZcIiwgXCJ7XFxcXGZyYWN7XFxcXGRlbHRheyAjMSB9fXtcXFxcZGVsdGF7ICMyIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGlubmVycHJvZHVjdFwiLCBcIntcXFxcbGVmdFxcXFxsYW5nbGUgeyMxfSBcXFxcbWlkIHsgIzJ9IFxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb3V0ZXJwcm9kdWN0XCIsXG4gIFwie1xcXFxsZWZ0XFxcXHZlcnQgeyAjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGVcXFxcbGVmdFxcXFxsYW5nbGUgeyAjMn0gXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZHlhZFwiLFxuICBcIntcXFxcbGVmdFxcXFx2ZXJ0IHsgIzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlXFxcXGxlZnRcXFxcbGFuZ2xlIHsgIzJ9IFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGtldGJyYVwiLFxuICBcIntcXFxcbGVmdFxcXFx2ZXJ0IHsgIzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlXFxcXGxlZnRcXFxcbGFuZ2xlIHsgIzJ9IFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9wXCIsXG4gIFwie1xcXFxsZWZ0XFxcXHZlcnQgeyAjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGVcXFxcbGVmdFxcXFxsYW5nbGUgeyAjMn0gXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXhwZWN0YXRpb252YWx1ZVwiLCBcIntcXFxcbGVmdFxcXFxsYW5nbGUgeyMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxleHB2YWxcIiwgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xlIHsjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXZcIiwgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xlIHsjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWF0cml4ZWxlbWVudFwiLFxuICBcIntcXFxcbGVmdFxcXFxsYW5nbGV7ICMxIH1cXFxccmlnaHRcXFxcdmVydHsgIzIgfVxcXFxsZWZ0XFxcXHZlcnR7IzN9XFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXRyaXhlbFwiLFxuICBcIntcXFxcbGVmdFxcXFxsYW5nbGV7ICMxIH1cXFxccmlnaHRcXFxcdmVydHsgIzIgfVxcXFxsZWZ0XFxcXHZlcnR7IzN9XFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtZWxcIixcbiAgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xleyAjMSB9XFxcXHJpZ2h0XFxcXHZlcnR7ICMyIH1cXFxcbGVmdFxcXFx2ZXJ0eyMzfVxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBnZXRITGluZXMocGFyc2VyKSB7XG4gIC8vIFJldHVybiBhbiBhcnJheS4gVGhlIGFycmF5IGxlbmd0aCA9IG51bWJlciBvZiBobGluZXMuXG4gIC8vIEVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgdGVsbHMgaWYgdGhlIGxpbmUgaXMgZGFzaGVkLlxuICBjb25zdCBobGluZUluZm8gPSBbXTtcbiAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgbGV0IG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gIGlmIChueHQgPT09IFwiXFxcXHJlbGF4XCIpIHtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgfVxuICB3aGlsZSAobnh0ID09PSBcIlxcXFxobGluZVwiIHx8IG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpIHtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIGhsaW5lSW5mby5wdXNoKG54dCA9PT0gXCJcXFxcaGRhc2hsaW5lXCIpO1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgfVxuICByZXR1cm4gaGxpbmVJbmZvO1xufVxuXG5jb25zdCB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dCA9IGNvbnRleHQgPT4ge1xuICBjb25zdCBzZXR0aW5ncyA9IGNvbnRleHQucGFyc2VyLnNldHRpbmdzO1xuICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYHske2NvbnRleHQuZW52TmFtZX19IGNhbiBiZSB1c2VkIG9ubHkgaW4gZGlzcGxheSBtb2RlLmApO1xuICB9XG59O1xuXG5jb25zdCBzaXplUmVnRXgkMSA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS87XG5jb25zdCBhcnJheUdhcHMgPSBtYWNyb3MgPT4ge1xuICBsZXQgYXJyYXlzdHJldGNoID0gbWFjcm9zLmdldChcIlxcXFxhcnJheXN0cmV0Y2hcIik7XG4gIGlmICh0eXBlb2YgYXJyYXlzdHJldGNoICE9PSBcInN0cmluZ1wiKSB7XG4gICAgYXJyYXlzdHJldGNoID0gc3RyaW5nRnJvbUFyZyhhcnJheXN0cmV0Y2gudG9rZW5zKTtcbiAgfVxuICBhcnJheXN0cmV0Y2ggPSBpc05hTihhcnJheXN0cmV0Y2gpID8gbnVsbCA6IE51bWJlcihhcnJheXN0cmV0Y2gpO1xuICBsZXQgYXJyYXljb2xzZXBTdHIgPSBtYWNyb3MuZ2V0KFwiXFxcXGFycmF5Y29sc2VwXCIpO1xuICBpZiAodHlwZW9mIGFycmF5Y29sc2VwU3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgYXJyYXljb2xzZXBTdHIgPSBzdHJpbmdGcm9tQXJnKGFycmF5Y29sc2VwU3RyLnRva2Vucyk7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBzaXplUmVnRXgkMS5leGVjKGFycmF5Y29sc2VwU3RyKTtcbiAgY29uc3QgYXJyYXljb2xzZXAgPSBtYXRjaFxuICAgID8geyBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksIHVuaXQ6IG1hdGNoWzNdIH1cbiAgICA6IG51bGw7XG4gIHJldHVybiBbYXJyYXlzdHJldGNoLCBhcnJheWNvbHNlcF1cbn07XG5cbmNvbnN0IGNoZWNrQ2VsbEZvckxhYmVscyA9IGNlbGwgPT4ge1xuICAvLyBDaGVjayBpZiB0aGUgYXV0aG9yIHdyb3RlIGEgXFx0YWd7fSBpbnNpZGUgdGhpcyBjZWxsLlxuICBsZXQgcm93TGFiZWwgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGwubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY2VsbFtpXS50eXBlID09PSBcImxhYmVsXCIpIHtcbiAgICAgIGlmIChyb3dMYWJlbCkgeyB0aHJvdyBuZXcgUGFyc2VFcnJvcigoXCJNdWx0aXBsZSBcXFxcbGFiZWxzIGluIG9uZSByb3dcIikpIH1cbiAgICAgIHJvd0xhYmVsID0gY2VsbFtpXS5zdHJpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiByb3dMYWJlbFxufTtcblxuLy8gYXV0b1RhZyAoYW4gYXJndW1lbnQgdG8gcGFyc2VBcnJheSkgY2FuIGJlIG9uZSBvZiB0aHJlZSB2YWx1ZXM6XG4vLyAqIHVuZGVmaW5lZDogUmVndWxhciAobm90LXRvcC1sZXZlbCkgYXJyYXk7IG5vIHRhZ3Mgb24gZWFjaCByb3dcbi8vICogdHJ1ZTogQXV0b21hdGljIGVxdWF0aW9uIG51bWJlcmluZywgb3ZlcnJpZGFibGUgYnkgXFx0YWdcbi8vICogZmFsc2U6IFRhZ3MgYWxsb3dlZCBvbiBlYWNoIHJvdywgYnV0IG5vIGF1dG9tYXRpYyBudW1iZXJpbmdcbi8vIFRoaXMgZnVuY3Rpb24gKmRvZXNuJ3QqIHdvcmsgd2l0aCB0aGUgXCJzcGxpdFwiIGVudmlyb25tZW50IG5hbWUuXG5mdW5jdGlvbiBnZXRBdXRvVGFnKG5hbWUpIHtcbiAgaWYgKG5hbWUuaW5kZXhPZihcImVkXCIpID09PSAtMSkge1xuICAgIHJldHVybiBuYW1lLmluZGV4T2YoXCIqXCIpID09PSAtMTtcbiAgfVxuICAvLyByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBib2R5IG9mIHRoZSBlbnZpcm9ubWVudCwgd2l0aCByb3dzIGRlbGltaXRlZCBieSBcXFxcIGFuZFxuICogY29sdW1ucyBkZWxpbWl0ZWQgYnkgJiwgYW5kIGNyZWF0ZSBhIG5lc3RlZCBsaXN0IGluIHJvdy1tYWpvciBvcmRlclxuICogd2l0aCBvbmUgZ3JvdXAgcGVyIGNlbGwuICBJZiBnaXZlbiBhbiBvcHRpb25hbCBhcmd1bWVudCBzY3JpcHRMZXZlbFxuICogKFwidGV4dFwiLCBcImRpc3BsYXlcIiwgZXRjLiksIHRoZW4gZWFjaCBjZWxsIGlzIGNhc3QgaW50byB0aGF0IHNjcmlwdExldmVsLlxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5KFxuICBwYXJzZXIsXG4gIHtcbiAgICBjb2xzLCAvLyBbeyB0eXBlOiBzdHJpbmcgLCBhbGlnbjogbHxjfHJ8bnVsbCB9XVxuICAgIGVudkNsYXNzZXMsIC8vIGFsaWduKGVkfGF0fGVkYXQpIHwgYXJyYXkgfCBjYXNlcyB8IGNkIHwgc21hbGwgfCBtdWx0bGluZVxuICAgIGF1dG9UYWcsICAgICAgICAvLyBib29sZWFuXG4gICAgc2luZ2xlUm93LCAgICAgIC8vIGJvb2xlYW5cbiAgICBlbXB0eVNpbmdsZVJvdywgLy8gYm9vbGVhblxuICAgIG1heE51bUNvbHMsICAgICAvLyBudW1iZXJcbiAgICBsZXFubywgICAgICAgICAgLy8gYm9vbGVhblxuICAgIGFycmF5c3RyZXRjaCwgICAvLyBudW1iZXIgIHwgbnVsbFxuICAgIGFycmF5Y29sc2VwICAgICAvLyBzaXplIHZhbHVlIHwgbnVsbFxufSxcbiAgc2NyaXB0TGV2ZWxcbikge1xuICBjb25zdCBlbmRUb2tlbiA9IGVudkNsYXNzZXMgJiYgZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImJvcmRlcm1hdHJpeFwiKSA/IFwifVwiIDogXCJcXFxcZW5kXCI7XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICBpZiAoIXNpbmdsZVJvdykge1xuICAgIC8vIFxcY3IgaXMgZXF1aXZhbGVudCB0byBcXFxcIHdpdGhvdXQgdGhlIG9wdGlvbmFsIHNpemUgYXJndW1lbnQgKHNlZSBiZWxvdylcbiAgICAvLyBUT0RPOiBwcm92aWRlIGhlbHBmdWwgZXJyb3Igd2hlbiBcXGNyIGlzIHVzZWQgb3V0c2lkZSBhcnJheSBlbnZpcm9ubWVudFxuICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjclwiLCBcIlxcXFxcXFxcXFxcXHJlbGF4XCIpO1xuICB9XG5cbiAgLy8gU3RhcnQgZ3JvdXAgZm9yIGZpcnN0IGNlbGxcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgbGV0IHJvdyA9IFtdO1xuICBjb25zdCBib2R5ID0gW3Jvd107XG4gIGNvbnN0IHJvd0dhcHMgPSBbXTtcbiAgY29uc3QgbGFiZWxzID0gW107XG5cbiAgY29uc3QgaExpbmVzQmVmb3JlUm93ID0gW107XG5cbiAgY29uc3QgdGFncyA9IChhdXRvVGFnICE9IG51bGwgPyBbXSA6IHVuZGVmaW5lZCk7XG5cbiAgLy8gYW1zbWF0aCB1c2VzIFxcZ2xvYmFsXFxAZXFuc3d0cnVlIGFuZCBcXGdsb2JhbFxcQGVxbnN3ZmFsc2UgdG8gcmVwcmVzZW50XG4gIC8vIHdoZXRoZXIgdGhpcyByb3cgc2hvdWxkIGhhdmUgYW4gZXF1YXRpb24gbnVtYmVyLiAgU2ltdWxhdGUgdGhpcyB3aXRoXG4gIC8vIGEgXFxAZXFuc3cgbWFjcm8gc2V0IHRvIDEgb3IgMC5cbiAgZnVuY3Rpb24gYmVnaW5Sb3coKSB7XG4gICAgaWYgKGF1dG9UYWcpIHtcbiAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxAZXFuc3dcIiwgXCIxXCIsIHRydWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlbmRSb3coKSB7XG4gICAgaWYgKHRhZ3MpIHtcbiAgICAgIGlmIChwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgICAgIHRhZ3MucHVzaChwYXJzZXIuc3VicGFyc2UoW25ldyBUb2tlbihcIlxcXFxkZkB0YWdcIildKSk7XG4gICAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxkZkB0YWdcIiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZ3MucHVzaChCb29sZWFuKGF1dG9UYWcpICYmXG4gICAgICAgICAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcQGVxbnN3XCIpID09PSBcIjFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGJlZ2luUm93KCk7XG5cbiAgLy8gVGVzdCBmb3IgXFxobGluZSBhdCB0aGUgdG9wIG9mIHRoZSBhcnJheS5cbiAgaExpbmVzQmVmb3JlUm93LnB1c2goZ2V0SExpbmVzKHBhcnNlcikpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gUGFyc2UgZWFjaCBjZWxsIGluIGl0cyBvd24gZ3JvdXAgKG5hbWVzcGFjZSlcbiAgICBsZXQgY2VsbCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIHNpbmdsZVJvdyA/IFwiXFxcXGVuZFwiIDogXCJcXFxcXFxcXFwiKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgICBjZWxsID0ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBjZWxsLFxuICAgICAgc2VtaXNpbXBsZTogdHJ1ZVxuICAgIH07XG4gICAgcm93LnB1c2goY2VsbCk7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gICAgaWYgKG5leHQgPT09IFwiJlwiKSB7XG4gICAgICBpZiAobWF4TnVtQ29scyAmJiByb3cubGVuZ3RoID09PSBtYXhOdW1Db2xzKSB7XG4gICAgICAgIGlmIChlbnZDbGFzc2VzLmluY2x1ZGVzKFwiYXJyYXlcIikpIHtcbiAgICAgICAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUb28gZmV3IGNvbHVtbnMgXCIgKyBcInNwZWNpZmllZCBpbiB0aGUge2FycmF5fSBjb2x1bW4gYXJndW1lbnQuXCIsXG4gICAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1heE51bUNvbHMgPT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRoZSBzcGxpdCBlbnZpcm9ubWVudCBhY2NlcHRzIG5vIG1vcmUgdGhhbiB0d28gY29sdW1uc1wiLFxuICAgICAgICAgICAgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUaGUgZXF1YXRpb24gZW52aXJvbm1lbnQgYWNjZXB0cyBvbmx5IG9uZSBjb2x1bW5cIixcbiAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBlbmRUb2tlbikge1xuICAgICAgZW5kUm93KCk7XG4gICAgICAvLyBBcnJheXMgdGVybWluYXRlIG5ld2xpbmVzIHdpdGggYFxcY3JjcmAgd2hpY2ggY29uc3VtZXMgYSBgXFxjcmAgaWZcbiAgICAgIC8vIHRoZSBsYXN0IGxpbmUgaXMgZW1wdHkuICBIb3dldmVyLCBBTVMgZW52aXJvbm1lbnRzIGtlZXAgdGhlXG4gICAgICAvLyBlbXB0eSByb3cgaWYgaXQncyB0aGUgb25seSBvbmUuXG4gICAgICAvLyBOT1RFOiBDdXJyZW50bHksIGBjZWxsYCBpcyB0aGUgbGFzdCBpdGVtIGFkZGVkIGludG8gYHJvd2AuXG4gICAgICBpZiAocm93Lmxlbmd0aCA9PT0gMSAmJiBjZWxsLmJvZHkubGVuZ3RoID09PSAwICYmIChib2R5Lmxlbmd0aCA+IDEgfHwgIWVtcHR5U2luZ2xlUm93KSkge1xuICAgICAgICBib2R5LnBvcCgpO1xuICAgICAgfVxuICAgICAgbGFiZWxzLnB1c2goY2hlY2tDZWxsRm9yTGFiZWxzKGNlbGwuYm9keSkpO1xuICAgICAgaWYgKGhMaW5lc0JlZm9yZVJvdy5sZW5ndGggPCBib2R5Lmxlbmd0aCArIDEpIHtcbiAgICAgICAgaExpbmVzQmVmb3JlUm93LnB1c2goW10pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxcXFxcXCIpIHtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICBsZXQgc2l6ZTtcbiAgICAgIC8vIFxcZGVmXFxMZXRAe1xcbGV0XFxcXFxcbWF0aEBjcn1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyey4uLlxcbWF0aEBjckB9XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjckB7XFxuZXdAaWZuZXh0Y2hhcltcXG1hdGhAY3JAQHtcXG1hdGhAY3JAQFtcXHpAXX19XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjckBAWyMxXXsuLi5cXG1hdGhAY3JAQEAuLi59XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjckBAQHtcXGNyfVxuICAgICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCIgXCIpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlci5wYXJzZVNpemVHcm91cCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJvd0dhcHMucHVzaChzaXplID8gc2l6ZS52YWx1ZSA6IG51bGwpO1xuICAgICAgZW5kUm93KCk7XG5cbiAgICAgIGxhYmVscy5wdXNoKGNoZWNrQ2VsbEZvckxhYmVscyhjZWxsLmJvZHkpKTtcblxuICAgICAgLy8gY2hlY2sgZm9yIFxcaGxpbmUocykgZm9sbG93aW5nIHRoZSByb3cgc2VwYXJhdG9yXG4gICAgICBoTGluZXNCZWZvcmVSb3cucHVzaChnZXRITGluZXMocGFyc2VyKSk7XG5cbiAgICAgIHJvdyA9IFtdO1xuICAgICAgYm9keS5wdXNoKHJvdyk7XG4gICAgICBiZWdpblJvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkICYgb3IgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFwiICsgZW5kVG9rZW4sIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEVuZCBjZWxsIGdyb3VwXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgLy8gRW5kIGFycmF5IGdyb3VwIGRlZmluaW5nIFxcY3JcbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgIGJvZHksXG4gICAgY29scyxcbiAgICByb3dHYXBzLFxuICAgIGhMaW5lc0JlZm9yZVJvdyxcbiAgICBlbnZDbGFzc2VzLFxuICAgIGF1dG9UYWcsXG4gICAgc2NyaXB0TGV2ZWwsXG4gICAgdGFncyxcbiAgICBsYWJlbHMsXG4gICAgbGVxbm8sXG4gICAgYXJyYXlzdHJldGNoLFxuICAgIGFycmF5Y29sc2VwXG4gIH07XG59XG5cbi8vIERlY2lkZXMgb24gYSBzY3JpcHRMZXZlbCBmb3IgY2VsbHMgaW4gYW4gYXJyYXkgYWNjb3JkaW5nIHRvIHdoZXRoZXIgdGhlIGdpdmVuXG4vLyBlbnZpcm9ubWVudCBuYW1lIHN0YXJ0cyB3aXRoIHRoZSBsZXR0ZXIgJ2QnLlxuZnVuY3Rpb24gZENlbGxTdHlsZShlbnZOYW1lKSB7XG4gIHJldHVybiBlbnZOYW1lLnNsaWNlKDAsIDEpID09PSBcImRcIiA/IFwiZGlzcGxheVwiIDogXCJ0ZXh0XCJcbn1cblxuY29uc3QgYWxpZ25NYXAgPSB7XG4gIGM6IFwiY2VudGVyIFwiLFxuICBsOiBcImxlZnQgXCIsXG4gIHI6IFwicmlnaHQgXCJcbn07XG5cbmNvbnN0IGdsdWUgPSBncm91cCA9PiB7XG4gIGNvbnN0IGdsdWVOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10pO1xuICBnbHVlTm9kZS5zdHlsZSA9IHsgcGFkZGluZzogXCIwXCIsIHdpZHRoOiBcIjUwJVwiIH07XG4gIGlmIChncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwibXVsdGxpbmVcIikpIHtcbiAgICBnbHVlTm9kZS5zdHlsZS53aWR0aCA9IFwiNy41JVwiO1xuICB9XG4gIHJldHVybiBnbHVlTm9kZVxufTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ5ID0gZnVuY3Rpb24oZ3JvdXAsIHN0eWxlKSB7XG4gIGNvbnN0IHRibCA9IFtdO1xuICBjb25zdCBudW1Sb3dzID0gZ3JvdXAuYm9keS5sZW5ndGg7XG4gIGNvbnN0IGhsaW5lcyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVJvd3M7IGkrKykge1xuICAgIGNvbnN0IHJ3ID0gZ3JvdXAuYm9keVtpXTtcbiAgICBjb25zdCByb3cgPSBbXTtcbiAgICBjb25zdCBjZWxsTGV2ZWwgPSBncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJ0ZXh0XCJcbiAgICAgID8gU3R5bGVMZXZlbC5URVhUXG4gICAgICA6IGdyb3VwLnNjcmlwdExldmVsID09PSBcInNjcmlwdFwiXG4gICAgICA/IFN0eWxlTGV2ZWwuU0NSSVBUXG4gICAgICA6IFN0eWxlTGV2ZWwuRElTUExBWTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcncubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IG10ZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm10ZFwiLFxuICAgICAgICBbYnVpbGRHcm91cCQxKHJ3W2pdLCBzdHlsZS53aXRoTGV2ZWwoY2VsbExldmVsKSldXG4gICAgICApO1xuXG4gICAgICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcIm11bHRsaW5lXCIpKSB7XG4gICAgICAgIGNvbnN0IGFsaWduID0gaSA9PT0gMCA/IFwibGVmdFwiIDogaSA9PT0gbnVtUm93cyAtIDEgPyBcInJpZ2h0XCIgOiBcImNlbnRlclwiO1xuICAgICAgICBtdGQuc2V0QXR0cmlidXRlKFwiY29sdW1uYWxpZ25cIiwgYWxpZ24pO1xuICAgICAgICBpZiAoYWxpZ24gIT09IFwiY2VudGVyXCIpIHtcbiAgICAgICAgICBtdGQuY2xhc3Nlcy5wdXNoKFwidG1sLVwiICsgYWxpZ24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByb3cucHVzaChtdGQpO1xuICAgIH1cbiAgICBjb25zdCBudW1Db2x1bW5zID0gZ3JvdXAuYm9keVswXS5sZW5ndGg7XG4gICAgLy8gRmlsbCBvdXQgYSBzaG9ydCByb3cgd2l0aCBlbXB0eSA8bXRkPiBlbGVtZW50cy5cbiAgICBmb3IgKGxldCBrID0gMDsgayA8IG51bUNvbHVtbnMgLSBydy5sZW5ndGg7IGsrKykge1xuICAgICAgcm93LnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW10sIHN0eWxlKSk7XG4gICAgfVxuICAgIGlmIChncm91cC5hdXRvVGFnKSB7XG4gICAgICBjb25zdCB0YWcgPSBncm91cC50YWdzW2ldO1xuICAgICAgbGV0IHRhZ0VsZW1lbnQ7XG4gICAgICBpZiAodGFnID09PSB0cnVlKSB7ICAvLyBhdXRvbWF0aWMgbnVtYmVyaW5nXG4gICAgICAgIHRhZ0VsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgU3BhbihbXCJ0bWwtZXFuXCJdKV0pO1xuICAgICAgfSBlbHNlIGlmICh0YWcgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFxcbm9udW1iZXIvXFxub3RhZyBvciBzdGFycmVkIGVudmlyb25tZW50XG4gICAgICAgIHRhZ0VsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtdLCBbXSk7XG4gICAgICB9IGVsc2UgeyAgLy8gbWFudWFsIFxcdGFnXG4gICAgICAgIHRhZ0VsZW1lbnQgPSBidWlsZEV4cHJlc3Npb25Sb3codGFnWzBdLmJvZHksIHN0eWxlLndpdGhMZXZlbChjZWxsTGV2ZWwpLCB0cnVlKTtcbiAgICAgICAgdGFnRWxlbWVudCA9IGNvbnNvbGlkYXRlVGV4dCh0YWdFbGVtZW50KTtcbiAgICAgICAgdGFnRWxlbWVudC5jbGFzc2VzID0gW1widG1sLXRhZ1wiXTtcbiAgICAgIH1cbiAgICAgIGlmICh0YWdFbGVtZW50KSB7XG4gICAgICAgIHJvdy51bnNoaWZ0KGdsdWUoZ3JvdXApKTtcbiAgICAgICAgcm93LnB1c2goZ2x1ZShncm91cCkpO1xuICAgICAgICBpZiAoZ3JvdXAubGVxbm8pIHtcbiAgICAgICAgICByb3dbMF0uY2hpbGRyZW4ucHVzaCh0YWdFbGVtZW50KTtcbiAgICAgICAgICByb3dbMF0uY2xhc3Nlcy5wdXNoKFwidG1sLWxlZnRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5jaGlsZHJlbi5wdXNoKHRhZ0VsZW1lbnQpO1xuICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0uY2xhc3Nlcy5wdXNoKFwidG1sLXJpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG10ciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIHJvdywgW10pO1xuICAgIGNvbnN0IGxhYmVsID0gZ3JvdXAubGFiZWxzLnNoaWZ0KCk7XG4gICAgaWYgKGxhYmVsICYmIGdyb3VwLnRhZ3MgJiYgZ3JvdXAudGFnc1tpXSkge1xuICAgICAgbXRyLnNldEF0dHJpYnV0ZShcImlkXCIsIGxhYmVsKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwLnRhZ3NbaV0pKSB7IG10ci5jbGFzc2VzLnB1c2goXCJ0bWwtdGFnZXFuXCIpOyB9XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgaG9yaXpvbnRhbCBydWxlc1xuICAgIGlmIChpID09PSAwICYmIGhsaW5lc1swXS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaGxpbmVzWzBdLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHsgY2VsbC5zdHlsZS5ib3JkZXJUb3AgPSBcIjAuMTVlbSBkb3VibGVcIjsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICBjZWxsLnN0eWxlLmJvcmRlclRvcCA9IGhsaW5lc1swXVswXSA/IFwiMC4wNmVtIGRhc2hlZFwiIDogXCIwLjA2ZW0gc29saWRcIjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChobGluZXNbaSArIDFdLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChobGluZXNbaSArIDFdLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHsgY2VsbC5zdHlsZS5ib3JkZXJCb3R0b20gPSBcIjAuMTVlbSBkb3VibGVcIjsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdHIuY2hpbGRyZW4uZm9yRWFjaChjZWxsID0+IHtcbiAgICAgICAgICBjZWxsLnN0eWxlLmJvcmRlckJvdHRvbSA9IGhsaW5lc1tpICsgMV1bMF0gPyBcIjAuMDZlbSBkYXNoZWRcIiA6IFwiMC4wNmVtIHNvbGlkXCI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBcXGhwaGFudG9tIFxcZnJvbSBcXGJvcmRlcm1hdHJpeFxuICAgIGxldCBtdXN0U3F1YXNoUm93ID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG10ci5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBtdHIuY2hpbGRyZW5bal0uY2hpbGRyZW5bMF07XG4gICAgICBpZiAoIShjaGlsZCAmJiBjaGlsZC50eXBlID09PSBcIm1wYWRkZWRcIiAmJiBjaGlsZC5hdHRyaWJ1dGVzLmhlaWdodCA9PT0gXCIwcHhcIikpIHtcbiAgICAgICAgbXVzdFNxdWFzaFJvdyA9IGZhbHNlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobXVzdFNxdWFzaFJvdykge1xuICAgICAgLy8gQWxsIHRoZSBjZWxsIGNvbnRlbnRzIGFyZSBcXGhwaGFudG9tLiBTcXVhc2ggdGhlIHBhZGRpbmcuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG10ci5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBtdHIuY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ1RvcCA9IFwiMFwiO1xuICAgICAgICBtdHIuY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ0JvdHRvbSA9IFwiMFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRibC5wdXNoKG10cik7XG4gIH1cblxuICBpZiAoZ3JvdXAuYXJyYXlzdHJldGNoICYmIGdyb3VwLmFycmF5c3RyZXRjaCAhPT0gMSkge1xuICAgIC8vIEluIExhVGVYLCBcXGFycmF5c3RyZXRjaCBpcyBhIGZhY3RvciBhcHBsaWVkIHRvIGEgMTJwdCBzdHJ1dCBoZWlnaHQuXG4gICAgLy8gSXQgZGVmaW5lcyBhIGJhc2VsaW5lIHRvIGJhc2VsaW5lIGRpc3RhbmNlLlxuICAgIC8vIEhlcmUsIHdlIGRvIGFuIGFwcHJveGltYXRpb24gb2YgdGhhdCBhcHByb2FjaC5cbiAgICBjb25zdCBwYWQgPSBTdHJpbmcoMS40ICogZ3JvdXAuYXJyYXlzdHJldGNoIC0gMC44KSArIFwiZXhcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRibC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGJsW2ldLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdUb3AgPSBwYWQ7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nQm90dG9tID0gcGFkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBzaWRlUGFkZGluZztcbiAgbGV0IHNpZGVQYWRVbml0O1xuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgc2lkZVBhZGRpbmcgPSBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiYWJ1dFwiKVxuICAgICAgPyBcIjBcIlxuICAgICAgOiBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiY2FzZXNcIilcbiAgICAgID8gXCIwXCJcbiAgICAgIDogZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcInNtYWxsXCIpXG4gICAgICA/IFwiMC4xMzg5XCJcbiAgICAgIDogZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImNkXCIpXG4gICAgICA/IFwiMC4yNVwiXG4gICAgICA6IFwiMC40XCI7IC8vIGRlZmF1bHQgc2lkZSBwYWRkaW5nXG4gICAgc2lkZVBhZFVuaXQgPSBcImVtXCI7XG4gIH1cbiAgaWYgKGdyb3VwLmFycmF5Y29sc2VwKSB7XG4gICAgY29uc3QgYXJyYXlTaWRlUGFkID0gY2FsY3VsYXRlU2l6ZShncm91cC5hcnJheWNvbHNlcCwgc3R5bGUpO1xuICAgIHNpZGVQYWRkaW5nID0gYXJyYXlTaWRlUGFkLm51bWJlci50b0ZpeGVkKDQpO1xuICAgIHNpZGVQYWRVbml0ID0gYXJyYXlTaWRlUGFkLnVuaXQ7XG4gIH1cbiAgaWYgKHNpZGVQYWRkaW5nKSB7XG4gICAgY29uc3QgbnVtQ29scyA9IHRibC5sZW5ndGggPT09IDAgPyAwIDogdGJsWzBdLmNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGNvbnN0IHNpZGVQYWQgPSAoaiwgaGFuZCkgPT4ge1xuICAgICAgaWYgKGogPT09IDAgJiYgaGFuZCA9PT0gMCkgeyByZXR1cm4gXCIwXCIgfVxuICAgICAgaWYgKGogPT09IG51bUNvbHMgLSAxICYmIGhhbmQgPT09IDEpIHsgcmV0dXJuIFwiMFwiIH1cbiAgICAgIGlmIChncm91cC5lbnZDbGFzc2VzWzBdICE9PSBcImFsaWduXCIpIHsgcmV0dXJuIHNpZGVQYWRkaW5nIH1cbiAgICAgIGlmIChoYW5kID09PSAxKSB7IHJldHVybiBcIjBcIiB9XG4gICAgICBpZiAoZ3JvdXAuYXV0b1RhZykge1xuICAgICAgICByZXR1cm4gKGogJSAyKSA/IFwiMVwiIDogXCIwXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoaiAlIDIpID8gXCIwXCIgOiBcIjFcIlxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTaWRlIHBhZGRpbmdcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRibC5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGJsW2ldLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdMZWZ0ID0gYCR7c2lkZVBhZChqLCAwKX0ke3NpZGVQYWRVbml0fWA7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHtzaWRlUGFkKGosIDEpfSR7c2lkZVBhZFVuaXR9YDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gU2V0IHplcm8gcGFkZGluZyBvbiBzaWRlIG9mIHRoZSBtYXRyaXhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRibC5sZW5ndGg7IGkrKykge1xuICAgICAgdGJsW2ldLmNoaWxkcmVuWzBdLnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIwZW1cIjtcbiAgICAgIGlmICh0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSB0YmxbMF0uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlblt0YmxbaV0uY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwZW1cIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gSnVzdGlmaWNhdGlvblxuICAgIGNvbnN0IGFsaWduID0gZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImFsaWduXCIpIHx8IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJhbGlnbmF0XCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGJsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByb3cgPSB0YmxbaV07XG4gICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3cuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAvLyBDaHJvbWl1bSBkb2VzIG5vdCByZWNvZ25pemUgdGV4dC1hbGlnbjogbGVmdC4gVXNlIC13ZWJraXQtXG4gICAgICAgICAgLy8gVE9ETzogUmVtb3ZlIC13ZWJraXQtIHdoZW4gQ2hyb21pdW0gbm8gbG9uZ2VyIG5lZWRzIGl0LlxuICAgICAgICAgIHJvdy5jaGlsZHJlbltqXS5jbGFzc2VzID0gW1widG1sLVwiICsgKGogJSAyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JvdXAuYXV0b1RhZykge1xuICAgICAgICAgIGNvbnN0IGsgPSBncm91cC5sZXFubyA/IDAgOiByb3cuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICAgICAgICByb3cuY2hpbGRyZW5ba10uY2xhc3NlcyA9IFtcInRtbC1cIiArIChncm91cC5sZXFubyA/IFwibGVmdFwiIDogXCJyaWdodFwiKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyb3cuY2hpbGRyZW4ubGVuZ3RoID4gMSAmJiBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiY2FzZXNcIikpIHtcbiAgICAgICAgcm93LmNoaWxkcmVuWzFdLnN0eWxlLnBhZGRpbmdMZWZ0ID0gXCIxZW1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJjYXNlc1wiKSB8fCBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwic3ViYXJyYXlcIikpIHtcbiAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdy5jaGlsZHJlbikge1xuICAgICAgICAgIGNlbGwuY2xhc3Nlcy5wdXNoKFwidG1sLWxlZnRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCB0YmwpO1xuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gVG9wICYgYm90dG9tIHBhZGRpbmdcbiAgICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImpvdFwiKSkge1xuICAgICAgdGFibGUuY2xhc3Nlcy5wdXNoKFwidG1sLWpvdFwiKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJzbWFsbFwiKSkge1xuICAgICAgdGFibGUuY2xhc3Nlcy5wdXNoKFwidG1sLXNtYWxsXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwiZGlzcGxheVwiKSB7IHRhYmxlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcInRydWVcIik7IH1cblxuICBpZiAoZ3JvdXAuYXV0b1RhZyB8fCBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwibXVsdGxpbmVcIikpIHtcbiAgICB0YWJsZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICB9XG5cbiAgLy8gQ29sdW1uIHNlcGFyYXRvciBsaW5lcyBhbmQgY29sdW1uIGFsaWdubWVudFxuICBsZXQgYWxpZ24gPSBcIlwiO1xuXG4gIGlmIChncm91cC5jb2xzICYmIGdyb3VwLmNvbHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGNvbHMgPSBncm91cC5jb2xzO1xuICAgIGxldCBwcmV2VHlwZVdhc0FsaWduID0gZmFsc2U7XG4gICAgbGV0IGlTdGFydCA9IDA7XG4gICAgbGV0IGlFbmQgPSBjb2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChjb2xzW2lTdGFydF0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgaVN0YXJ0ICs9IDE7XG4gICAgfVxuICAgIHdoaWxlIChjb2xzW2lFbmQgLSAxXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBpRW5kIC09IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbHNbMF0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgY29uc3Qgc2VwID0gY29sc1sxXS50eXBlID09PSBcInNlcGFyYXRvclwiXG4gICAgICAgID8gXCIwLjE1ZW0gZG91YmxlXCJcbiAgICAgICAgOiBjb2xzWzBdLnNlcGFyYXRvciA9PT0gXCJ8XCJcbiAgICAgICAgPyBcIjAuMDZlbSBzb2xpZCBcIlxuICAgICAgICA6IFwiMC4wNmVtIGRhc2hlZCBcIjtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJvdy5jaGlsZHJlblswXS5zdHlsZS5ib3JkZXJMZWZ0ID0gc2VwO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaUNvbCA9IGdyb3VwLmF1dG9UYWcgPyAwIDogLTE7XG4gICAgZm9yIChsZXQgaSA9IGlTdGFydDsgaSA8IGlFbmQ7IGkrKykge1xuICAgICAgaWYgKGNvbHNbaV0udHlwZSA9PT0gXCJhbGlnblwiKSB7XG4gICAgICAgIGNvbnN0IGNvbEFsaWduID0gYWxpZ25NYXBbY29sc1tpXS5hbGlnbl07XG4gICAgICAgIGFsaWduICs9IGNvbEFsaWduO1xuICAgICAgICBpQ29sICs9IDE7XG4gICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGNvbEFsaWduLnRyaW0oKSAhPT0gXCJjZW50ZXJcIiAmJiBpQ29sIDwgcm93LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgcm93LmNoaWxkcmVuW2lDb2xdLmNsYXNzZXMgPSBbXCJ0bWwtXCIgKyBjb2xBbGlnbi50cmltKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2VHlwZVdhc0FsaWduID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY29sc1tpXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgIC8vIE1hdGhNTCBhY2NlcHRzIG9ubHkgc2luZ2xlIGxpbmVzIGJldHdlZW4gY2VsbHMuXG4gICAgICAgIC8vIFNvIHdlIHJlYWQgb25seSB0aGUgZmlyc3Qgb2YgY29uc2VjdXRpdmUgc2VwYXJhdG9ycy5cbiAgICAgICAgaWYgKHByZXZUeXBlV2FzQWxpZ24pIHtcbiAgICAgICAgICBjb25zdCBzZXAgPSBjb2xzW2kgKyAxXS50eXBlID09PSBcInNlcGFyYXRvclwiXG4gICAgICAgICAgICA/IFwiMC4xNWVtIGRvdWJsZVwiXG4gICAgICAgICAgICA6IGNvbHNbaV0uc2VwYXJhdG9yID09PSBcInxcIlxuICAgICAgICAgICAgPyBcIjAuMDZlbSBzb2xpZFwiXG4gICAgICAgICAgICA6IFwiMC4wNmVtIGRhc2hlZFwiO1xuICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoaUNvbCA8IHJvdy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcm93LmNoaWxkcmVuW2lDb2xdLnN0eWxlLmJvcmRlclJpZ2h0ID0gc2VwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2VHlwZVdhc0FsaWduID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2xzW2NvbHMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgY29uc3Qgc2VwID0gY29sc1tjb2xzLmxlbmd0aCAtIDJdLnR5cGUgPT09IFwic2VwYXJhdG9yXCJcbiAgICAgICAgPyBcIjAuMTVlbSBkb3VibGVcIlxuICAgICAgICA6IGNvbHNbY29scy5sZW5ndGggLSAxXS5zZXBhcmF0b3IgPT09IFwifFwiXG4gICAgICAgID8gXCIwLjA2ZW0gc29saWRcIlxuICAgICAgICA6IFwiMC4wNmVtIGRhc2hlZFwiO1xuICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcm93LmNoaWxkcmVuW3Jvdy5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdHlsZS5ib3JkZXJSaWdodCA9IHNlcDtcbiAgICAgICAgcm93LmNoaWxkcmVuW3Jvdy5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIjAuNGVtXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChncm91cC5hdXRvVGFnKSB7XG4gICAgIC8vIGFsbG93IGZvciBnbHVlIGNlbGxzIG9uIGVhY2ggc2lkZVxuICAgIGFsaWduID0gXCJsZWZ0IFwiICsgKGFsaWduLmxlbmd0aCA+IDAgPyBhbGlnbiA6IFwiY2VudGVyIFwiKSArIFwicmlnaHQgXCI7XG4gIH1cbiAgaWYgKGFsaWduKSB7XG4gICAgLy8gRmlyZWZveCByZWFkcyB0aGlzIGF0dHJpYnV0ZSwgbm90IHRoZSAtd2Via2l0LWxlZnR8cmlnaHQgd3JpdHRlbiBhYm92ZS5cbiAgICAvLyBUT0RPOiBXaGVuIENocm9tZSBubyBsb25nZXIgbmVlZHMgXCItd2Via2l0LVwiLCB1c2UgQ1NTIGFuZCBkZWxldGUgdGhlIG5leHQgbGluZS5cbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5hbGlnblwiLCBhbGlnbi50cmltKCkpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJzbWFsbFwiKSkge1xuICAgIC8vIEEgc21hbGwgYXJyYXkuIFdyYXAgaW4gc2NyaXB0c3R5bGUuXG4gICAgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbdGFibGVdKTtcbiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjFcIik7XG4gIH1cblxuICByZXR1cm4gdGFibGVcbn07XG5cbi8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBhbGlnbiwgYWxpZ24qLCBhbGlnbmVkLCBhbGlnbmF0LCBhbGlnbmF0KiwgYWxpZ25lZGF0LCBzcGxpdC5cbmNvbnN0IGFsaWduZWRIYW5kbGVyID0gZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICBpZiAoY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJlZFwiKSA9PT0gLTEpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgfVxuICBjb25zdCBpc1NwbGl0ID0gY29udGV4dC5lbnZOYW1lID09PSBcInNwbGl0XCI7XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgY29uc3QgcmVzID0gcGFyc2VBcnJheShcbiAgICBjb250ZXh0LnBhcnNlcixcbiAgICB7XG4gICAgICBjb2xzLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBhdXRvVGFnOiBpc1NwbGl0ID8gdW5kZWZpbmVkIDogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW52Q2xhc3NlczogW1wiYWJ1dFwiLCBcImpvdFwiXSwgLy8gc2V0IHJvdyBzcGFjaW5nICYgcHJvdmlzaW9uYWwgY29sdW1uIHNwYWNpbmdcbiAgICAgIG1heE51bUNvbHM6IGNvbnRleHQuZW52TmFtZSA9PT0gXCJzcGxpdFwiID8gMiA6IHVuZGVmaW5lZCxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH0sXG4gICAgXCJkaXNwbGF5XCJcbiAgKTtcblxuICAvLyBEZXRlcm1pbmluZyBudW1iZXIgb2YgY29sdW1ucy5cbiAgLy8gMS4gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdpdmVuLCB3ZSB1c2UgaXQgYXMgYSBudW1iZXIgb2YgY29sdW1ucyxcbiAgLy8gICAgYW5kIG1ha2VzIHN1cmUgdGhhdCBlYWNoIHJvdyBkb2Vzbid0IGV4Y2VlZCB0aGF0IG51bWJlci5cbiAgLy8gMi4gT3RoZXJ3aXNlLCBqdXN0IGNvdW50IG51bWJlciBvZiBjb2x1bW5zID0gbWF4aW11bSBudW1iZXJcbiAgLy8gICAgb2YgY2VsbHMgaW4gZWFjaCByb3cgKFwiYWxpZ25lZFwiIG1vZGUgLS0gaXNBbGlnbmVkIHdpbGwgYmUgdHJ1ZSkuXG4gIC8vXG4gIC8vIEF0IHRoZSBzYW1lIHRpbWUsIHByZXBlbmQgZW1wdHkgZ3JvdXAge30gYXQgYmVnaW5uaW5nIG9mIGV2ZXJ5IHNlY29uZFxuICAvLyBjZWxsIGluIGVhY2ggcm93IChzdGFydGluZyB3aXRoIHNlY29uZCBjZWxsKSBzbyB0aGF0IG9wZXJhdG9ycyBiZWNvbWVcbiAgLy8gYmluYXJ5LiAgVGhpcyBiZWhhdmlvciBpcyBpbXBsZW1lbnRlZCBpbiBhbXNtYXRoJ3MgXFxzdGFydEBhbGlnbmVkLlxuICBsZXQgbnVtTWF0aHM7XG4gIGxldCBudW1Db2xzID0gMDtcbiAgY29uc3QgaXNBbGlnbmVkQXQgPSBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcImF0XCIpID4gLTE7XG4gIGlmIChhcmdzWzBdICYmIGlzQWxpZ25lZEF0KSB7XG4gICAgLy8gYWxpZ25hdCBlbnZpcm9ubWVudCB0YWtlcyBhbiBhcmd1bWVudCB3LyBudW1iZXIgb2YgY29sdW1uc1xuICAgIGxldCBhcmcwID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3NbMF0uYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dG9yZCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0uYm9keVtpXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgYXJnMCArPSB0ZXh0b3JkLnRleHQ7XG4gICAgfVxuICAgIGlmIChpc05hTihhcmcwKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUaGUgYWxpZ25hdCBlbnZpcm9tZW50IHJlcXVpcmVzIGEgbnVtZXJpYyBmaXJzdCBhcmd1bWVudC5cIilcbiAgICB9XG4gICAgbnVtTWF0aHMgPSBOdW1iZXIoYXJnMCk7XG4gICAgbnVtQ29scyA9IG51bU1hdGhzICogMjtcbiAgfVxuICByZXMuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGlmIChpc0FsaWduZWRBdCkge1xuICAgICAgLy8gQ2FzZSAxXG4gICAgICBjb25zdCBjdXJNYXRocyA9IHJvdy5sZW5ndGggLyAyO1xuICAgICAgaWYgKG51bU1hdGhzIDwgY3VyTWF0aHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgXCJUb28gbWFueSBtYXRoIGluIGEgcm93OiBcIiArIGBleHBlY3RlZCAke251bU1hdGhzfSwgYnV0IGdvdCAke2N1ck1hdGhzfWAsXG4gICAgICAgICAgcm93WzBdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChudW1Db2xzIDwgcm93Lmxlbmd0aCkge1xuICAgICAgLy8gQ2FzZSAyXG4gICAgICBudW1Db2xzID0gcm93Lmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEFkanVzdGluZyBhbGlnbm1lbnQuXG4gIC8vIEluIGFsaWduZWQgbW9kZSwgd2UgYWRkIG9uZSBcXHFxdWFkIGJldHdlZW4gY29sdW1ucztcbiAgLy8gb3RoZXJ3aXNlIHdlIGFkZCBub3RoaW5nLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvbHM7ICsraSkge1xuICAgIGxldCBhbGlnbiA9IFwiclwiO1xuICAgIGlmIChpICUgMiA9PT0gMSkge1xuICAgICAgYWxpZ24gPSBcImxcIjtcbiAgICB9XG4gICAgY29sc1tpXSA9IHtcbiAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgIGFsaWduOiBhbGlnblxuICAgIH07XG4gIH1cbiAgaWYgKGNvbnRleHQuZW52TmFtZSA9PT0gXCJzcGxpdFwiKSA7IGVsc2UgaWYgKGlzQWxpZ25lZEF0KSB7XG4gICAgcmVzLmVudkNsYXNzZXMucHVzaChcImFsaWduYXRcIik7IC8vIFNldHMganVzdGlmaWNhdGlvblxuICB9IGVsc2Uge1xuICAgIHJlcy5lbnZDbGFzc2VzWzBdID0gXCJhbGlnblwiOyAvLyBTZXRzIGNvbHVtbiBzcGFjaW5nICYganVzdGlmaWNhdGlvblxuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG4vLyBBcnJheXMgYXJlIHBhcnQgb2YgTGFUZVgsIGRlZmluZWQgaW4gbHR0YWIuZHR4IHNvIGl0cyBkb2N1bWVudGF0aW9uXG4vLyBpcyBwYXJ0IG9mIHRoZSBzb3VyY2UyZS5wZGYgZmlsZSBvZiBMYVRlWDJlIHNvdXJjZSBkb2N1bWVudGF0aW9uLlxuLy8ge2RhcnJheX0gaXMgYW4ge2FycmF5fSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBuY2NtYXRoLnN0eS5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYXJyYXlcIiwgXCJkYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBTaW5jZSBubyB0eXBlcyBhcmUgc3BlY2lmaWVkIGFib3ZlLCB0aGUgdHdvIHBvc3NpYmlsaXRpZXMgYXJlXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgd3JhcHBlZCBpbiB7fSBvciBbXSwgaW4gd2hpY2ggY2FzZSBQYXJzZXInc1xuICAgIC8vICAgcGFyc2VHcm91cCgpIHJldHVybnMgYW4gXCJvcmRncm91cFwiIHdyYXBwaW5nIHNvbWUgc3ltYm9sIG5vZGUuXG4gICAgLy8gLSBUaGUgYXJndW1lbnQgaXMgYSBiYXJlIHN5bWJvbCBub2RlLlxuICAgIGNvbnN0IHN5bU5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKGFyZ3NbMF0pO1xuICAgIGNvbnN0IGNvbGFsaWduID0gc3ltTm9kZSA/IFthcmdzWzBdXSA6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIikuYm9keTtcbiAgICBjb25zdCBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5kZSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7XG4gICAgICBjb25zdCBjYSA9IG5vZGUudGV4dDtcbiAgICAgIGlmIChcImxjclwiLmluZGV4T2YoY2EpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwifFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwifFwiXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGNhID09PSBcIjpcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgc2VwYXJhdG9yOiBcIjpcIlxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmtub3duIGNvbHVtbiBhbGlnbm1lbnQ6IFwiICsgY2EsIG5kZSk7XG4gICAgfSk7XG4gICAgY29uc3QgW2FycmF5c3RyZXRjaCwgYXJyYXljb2xzZXBdID0gYXJyYXlHYXBzKGNvbnRleHQucGFyc2VyLmd1bGxldC5tYWNyb3MpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGNvbHMsXG4gICAgICBlbnZDbGFzc2VzOiBbXCJhcnJheVwiXSxcbiAgICAgIG1heE51bUNvbHM6IGNvbHMubGVuZ3RoLFxuICAgICAgYXJyYXlzdHJldGNoLFxuICAgICAgYXJyYXljb2xzZXBcbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIFRoZSBtYXRyaXggZW52aXJvbm1lbnRzIG9mIGFtc21hdGggYnVpbGQgb24gdGhlIGFycmF5IGVudmlyb25tZW50XG4vLyBvZiBMYVRlWCwgd2hpY2ggaXMgZGlzY3Vzc2VkIGFib3ZlLlxuLy8gVGhlIG1hdGh0b29scyBwYWNrYWdlIGFkZHMgc3RhcnJlZCB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBlbnZpcm9ubWVudHMuXG4vLyBUaGVzZSBoYXZlIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGNob29zZSBsZWZ0fGNlbnRlcnxyaWdodCBqdXN0aWZpY2F0aW9uLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXG4gICAgXCJtYXRyaXhcIixcbiAgICBcInBtYXRyaXhcIixcbiAgICBcImJtYXRyaXhcIixcbiAgICBcIkJtYXRyaXhcIixcbiAgICBcInZtYXRyaXhcIixcbiAgICBcIlZtYXRyaXhcIixcbiAgICBcIm1hdHJpeCpcIixcbiAgICBcInBtYXRyaXgqXCIsXG4gICAgXCJibWF0cml4KlwiLFxuICAgIFwiQm1hdHJpeCpcIixcbiAgICBcInZtYXRyaXgqXCIsXG4gICAgXCJWbWF0cml4KlwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBkZWxpbWl0ZXJzID0ge1xuICAgICAgbWF0cml4OiBudWxsLFxuICAgICAgcG1hdHJpeDogW1wiKFwiLCBcIilcIl0sXG4gICAgICBibWF0cml4OiBbXCJbXCIsIFwiXVwiXSxcbiAgICAgIEJtYXRyaXg6IFtcIlxcXFx7XCIsIFwiXFxcXH1cIl0sXG4gICAgICB2bWF0cml4OiBbXCJ8XCIsIFwifFwiXSxcbiAgICAgIFZtYXRyaXg6IFtcIlxcXFxWZXJ0XCIsIFwiXFxcXFZlcnRcIl1cbiAgICB9W2NvbnRleHQuZW52TmFtZS5yZXBsYWNlKFwiKlwiLCBcIlwiKV07XG4gICAgLy8gXFxoc2tpcCAtXFxhcnJheWNvbHNlcCBpbiBhbXNtYXRoXG4gICAgbGV0IGNvbEFsaWduID0gXCJjXCI7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGVudkNsYXNzZXM6IFtdLFxuICAgICAgY29sczogW11cbiAgICB9O1xuICAgIGlmIChjb250ZXh0LmVudk5hbWUuY2hhckF0KGNvbnRleHQuZW52TmFtZS5sZW5ndGggLSAxKSA9PT0gXCIqXCIpIHtcbiAgICAgIC8vIEl0J3Mgb25lIG9mIHRoZSBtYXRodG9vbHMgc3RhcnJlZCBmdW5jdGlvbnMuXG4gICAgICAvLyBQYXJzZSB0aGUgb3B0aW9uYWwgYWxpZ25tZW50IGFyZ3VtZW50LlxuICAgICAgY29uc3QgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7XG4gICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgaWYgKHBhcnNlci5mZXRjaCgpLnRleHQgPT09IFwiW1wiKSB7XG4gICAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgICAgIGNvbEFsaWduID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjb2xBbGlnbikgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBsIG9yIGMgb3IgclwiLCBwYXJzZXIubmV4dFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICBwYXJzZXIuZXhwZWN0KFwiXVwiKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGF5bG9hZC5jb2xzID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIFwidGV4dFwiKTtcbiAgICByZXMuY29scyA9IG5ldyBBcnJheShyZXMuYm9keVswXS5sZW5ndGgpLmZpbGwoeyB0eXBlOiBcImFsaWduXCIsIGFsaWduOiBjb2xBbGlnbiB9KTtcbiAgICBjb25zdCBbYXJyYXlzdHJldGNoLCBhcnJheWNvbHNlcF0gPSBhcnJheUdhcHMoY29udGV4dC5wYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgcmVzLmFycmF5c3RyZXRjaCA9IGFycmF5c3RyZXRjaDtcbiAgICBpZiAoYXJyYXljb2xzZXAgJiYgIShhcnJheWNvbHNlcCA9PT0gNiAmJiBhcnJheWNvbHNlcCA9PT0gXCJwdFwiKSkge1xuICAgICAgcmVzLmFycmF5Y29sc2VwID0gYXJyYXljb2xzZXA7XG4gICAgfVxuICAgIHJldHVybiBkZWxpbWl0ZXJzXG4gICAgICA/IHtcbiAgICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgICBib2R5OiBbcmVzXSxcbiAgICAgICAgbGVmdDogZGVsaW1pdGVyc1swXSxcbiAgICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV0sXG4gICAgICAgIHJpZ2h0Q29sb3I6IHVuZGVmaW5lZCAvLyBcXHJpZ2h0IHVuaW5mbHVlbmNlZCBieSBcXGNvbG9yIGluIGFycmF5XG4gICAgICB9XG4gICAgICA6IHJlcztcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJib3JkZXJtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXlsb2FkID0geyBjb2xzOiBbXSwgZW52Q2xhc3NlczogW1wiYm9yZGVybWF0cml4XCJdIH07XG4gICAgY29uc3QgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgXCJ0ZXh0XCIpO1xuICAgIHJlcy5jb2xzID0gbmV3IEFycmF5KHJlcy5ib2R5WzBdLmxlbmd0aCkuZmlsbCh7IHR5cGU6IFwiYWxpZ25cIiwgYWxpZ246IFwiY1wiIH0pO1xuICAgIHJlcy5lbnZDbGFzc2VzID0gW107XG4gICAgcmVzLmFycmF5c3RyZXRjaCA9IDE7XG4gICAgaWYgKGNvbnRleHQuZW52TmFtZSA9PT0gXCJtYXRyaXhcIikgeyByZXR1cm4gcmVzfVxuICAgIHJldHVybiBib3JkZXJtYXRyaXhQYXJzZVRyZWUocmVzLCBjb250ZXh0LmRlbGltaXRlcnMpXG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic21hbGxtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXlsb2FkID0geyB0eXBlOiBcInNtYWxsXCIgfTtcbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBcInNjcmlwdFwiKTtcbiAgICByZXMuZW52Q2xhc3NlcyA9IFtcInNtYWxsXCJdO1xuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wic3ViYXJyYXlcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAvLyBQYXJzaW5nIG9mIHtzdWJhcnJheX0gaXMgc2ltaWxhciB0byB7YXJyYXl9XG4gICAgY29uc3Qgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7XG4gICAgY29uc3QgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIGNvbnN0IGNvbHMgPSBjb2xhbGlnbi5tYXAoZnVuY3Rpb24obmRlKSB7XG4gICAgICBjb25zdCBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIGNvbnN0IGNhID0gbm9kZS50ZXh0O1xuICAgICAgLy8ge3N1YmFycmF5fSBvbmx5IHJlY29nbml6ZXMgXCJsXCIgJiBcImNcIlxuICAgICAgaWYgKFwibGNcIi5pbmRleE9mKGNhKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gY29sdW1uIGFsaWdubWVudDogXCIgKyBjYSwgbmRlKTtcbiAgICB9KTtcbiAgICBpZiAoY29scy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIntzdWJhcnJheX0gY2FuIGNvbnRhaW4gb25seSBvbmUgY29sdW1uXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzID0ge1xuICAgICAgY29scyxcbiAgICAgIGVudkNsYXNzZXM6IFtcInNtYWxsXCJdXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwic2NyaXB0XCIpO1xuICAgIGlmIChyZXMuYm9keS5sZW5ndGggPiAwICYmIHJlcy5ib2R5WzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwie3N1YmFycmF5fSBjYW4gY29udGFpbiBvbmx5IG9uZSBjb2x1bW5cIik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIEEgY2FzZXMgZW52aXJvbm1lbnQgKGluIGFtc21hdGguc3R5KSBpcyBhbG1vc3QgZXF1aXZhbGVudCB0b1xuLy8gXFxkZWZcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbi8vIHtkY2FzZXN9IGlzIGEge2Nhc2VzfSBlbnZpcm9ubWVudCB3aGVyZSBjZWxscyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLFxuLy8gYXMgZGVmaW5lZCBpbiBtYXRodG9vbHMuc3R5LlxuLy8ge3JjYXNlc30gaXMgYW5vdGhlciBtYXRodG9vbHMgZW52aXJvbm1lbnQuIEl0J3MgYnJhY2UgaXMgb24gdGhlIHJpZ2h0IHNpZGUuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImNhc2VzXCIsIFwiZGNhc2VzXCIsIFwicmNhc2VzXCIsIFwiZHJjYXNlc1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBjb2xzOiBbXSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImNhc2VzXCJdXG4gICAgfTtcbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5tb2RlLFxuICAgICAgYm9keTogW3Jlc10sXG4gICAgICBsZWZ0OiBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcInJcIikgPiAtMSA/IFwiLlwiIDogXCJcXFxce1wiLFxuICAgICAgcmlnaHQ6IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiclwiKSA+IC0xID8gXCJcXFxcfVwiIDogXCIuXCIsXG4gICAgICByaWdodENvbG9yOiB1bmRlZmluZWRcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBJbiB0aGUgYWxpZ24gZW52aXJvbm1lbnQsIG9uZSB1c2VzIGFtcGVyc2FuZHMsICYsIHRvIHNwZWNpZnkgbnVtYmVyIG9mXG4vLyBjb2x1bW5zIGluIGVhY2ggcm93LCBhbmQgdG8gbG9jYXRlIHNwYWNpbmcgYmV0d2VlbiBlYWNoIGNvbHVtbi5cbi8vIGFsaWduIGdldHMgYXV0b21hdGljIG51bWJlcmluZy4gYWxpZ24qIGFuZCBhbGlnbmVkIGRvIG5vdC5cbi8vIFRoZSBhbGlnbmVkYXQgZW52aXJvbm1lbnQgY2FuIGJlIHVzZWQgaW4gbWF0aCBtb2RlLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnblwiLCBcImFsaWduKlwiLCBcImFsaWduZWRcIiwgXCJzcGxpdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBhbGlnbmF0IGVudmlyb25tZW50IGlzIGxpa2UgYW4gYWxpZ24gZW52aXJvbm1lbnQsIGJ1dCBvbmUgbXVzdCBleHBsaWNpdGx5XG4vLyBzcGVjaWZ5IG1heGltdW0gbnVtYmVyIG9mIGNvbHVtbnMgaW4gZWFjaCByb3csIGFuZCBjYW4gYWRqdXN0IHdoZXJlIHNwYWNpbmcgb2NjdXJzLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhbGlnbmF0XCIsIFwiYWxpZ25hdCpcIiwgXCJhbGlnbmVkYXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiBhbGlnbmVkSGFuZGxlcixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gQSBnYXRoZXJlZCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFycmF5IGVudmlyb25tZW50IHdpdGggb25lIGNlbnRlcmVkXG4vLyBjb2x1bW4sIGJ1dCB3aGVyZSByb3dzIGFyZSBjb25zaWRlcmVkIGxpbmVzIHNvIGdldCBcXGpvdCBsaW5lIHNwYWNpbmdcbi8vIGFuZCBjb250ZW50cyBhcmUgc2V0IGluIFxcZGlzcGxheXN0eWxlLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJnYXRoZXJlZFwiLCBcImdhdGhlclwiLCBcImdhdGhlcipcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5lbnZOYW1lICE9PSBcImdhdGhlcmVkXCIpIHtcbiAgICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBjb2xzOiBbXSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImFidXRcIiwgXCJqb3RcIl0sXG4gICAgICBhdXRvVGFnOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgICBlbXB0eVNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJkaXNwbGF5XCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImVxdWF0aW9uXCIsIFwiZXF1YXRpb24qXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBzaW5nbGVSb3c6IHRydWUsXG4gICAgICBtYXhOdW1Db2xzOiAxLFxuICAgICAgZW52Q2xhc3NlczogW1wiYWxpZ25cIl0sXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJtdWx0bGluZVwiLCBcIm11bHRsaW5lKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGF1dG9UYWc6IGNvbnRleHQuZW52TmFtZSA9PT0gXCJtdWx0bGluZVwiLFxuICAgICAgbWF4TnVtQ29sczogMSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImpvdFwiLCBcIm11bHRsaW5lXCJdLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiQ0RcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICByZXR1cm4gcGFyc2VDRChjb250ZXh0LnBhcnNlcik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIENhdGNoIFxcaGxpbmUgb3V0c2lkZSBhcnJheSBlbnZpcm9ubWVudFxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIiwgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXGhsaW5lXCIsIFwiXFxcXGhkYXNobGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgJHtjb250ZXh0LmZ1bmNOYW1lfSB2YWxpZCBvbmx5IHdpdGhpbiBhcnJheSBlbnZpcm9ubWVudGApO1xuICB9XG59KTtcblxuY29uc3QgZW52aXJvbm1lbnRzID0gX2Vudmlyb25tZW50cztcblxuLy8gXFxib3JkZXJtYXRyaXggIGZyb20gVGVYYm9vayBwcCAxNzcgJiAzNjFcbi8vIE9wdGlvbmFsIGFyZ3VtZW50IGZyb20gSGVyYmVydCBWb8OfLCBNYXRoIG1vZGUsIHAgMjBcbi8vIFJlZjogaHR0cHM6Ly90dWcuY3Rhbi5vcmcvb2Jzb2xldGUvaW5mby9tYXRoL3Zvc3MvbWF0aG1vZGUvTWF0aG1vZGUucGRmXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJib3JkZXJtYXRyaXhcIixcbiAgbmFtZXM6IFtcIlxcXFxib3JkZXJtYXRyaXhcIiwgXCJcXFxcbWF0cml4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykgPT4ge1xuICAgIC8vIEZpbmQgb3V0IGlmIHRoZSBhdXRob3IgaGFzIGRlZmluZWQgY3VzdG9tIGRlbGltaXRlcnNcbiAgICBsZXQgZGVsaW1pdGVycyA9IFtcIihcIiwgXCIpXCJdO1xuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcYm9yZGVybWF0cml4XCIgJiYgb3B0QXJnc1swXSAmJiBvcHRBcmdzWzBdLmJvZHkpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRBcmdzWzBdLmJvZHk7XG4gICAgICBpZiAoYm9keS5sZW5ndGggPT09IDIgJiYgYm9keVswXS50eXBlID09PSBcImF0b21cIiAmJiBib2R5WzFdLnR5cGUgPT09IFwiYXRvbVwiKSB7XG4gICAgICAgIGlmIChib2R5WzBdLmZhbWlseSA9PT0gXCJvcGVuXCIgJiYgYm9keVsxXS5mYW1pbHkgPT09IFwiY2xvc2VcIikge1xuICAgICAgICAgIGRlbGltaXRlcnMgPSBbYm9keVswXS50ZXh0LCBib2R5WzFdLnRleHRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnN1bWUgdGhlIG9wZW5pbmcgYnJhY2VcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIHBhcnNlci5jb25zdW1lKCk7XG5cbiAgICAvLyBQYXNzIGNvbnRyb2wgdG8gdGhlIGVudmlyb25tZW50IGhhbmRsZXIgaW4gYXJyYXkuanMuXG4gICAgY29uc3QgZW52ID0gZW52aXJvbm1lbnRzW1wiYm9yZGVybWF0cml4XCJdO1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGVudk5hbWU6IGZ1bmNOYW1lLnNsaWNlKDEpLFxuICAgICAgZGVsaW1pdGVycyxcbiAgICAgIHBhcnNlclxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCk7XG4gICAgcGFyc2VyLmV4cGVjdChcIn1cIiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59KTtcblxuLy8gXFxAY2hhciBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHRha2VzIGEgZ3JvdXBlZCBkZWNpbWFsIGFyZ3VtZW50IGxpa2Vcbi8vIHsxMjN9IGFuZCBjb252ZXJ0cyBpbnRvIHN5bWJvbCB3aXRoIGNvZGUgMTIzLiAgSXQgaXMgdXNlZCBieSB0aGUgKm1hY3JvKlxuLy8gXFxjaGFyIGRlZmluZWQgaW4gbWFjcm9zLmpzLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRvcmRcIixcbiAgbmFtZXM6IFtcIlxcXFxAY2hhclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgdG9rZW4gfSwgYXJncykge1xuICAgIGNvbnN0IGFyZyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG4gICAgY29uc3QgZ3JvdXAgPSBhcmcuYm9keTtcbiAgICBsZXQgbnVtYmVyID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gYXNzZXJ0Tm9kZVR5cGUoZ3JvdXBbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIG51bWJlciArPSBub2RlLnRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBwYXJzZUludChudW1iZXIpO1xuICAgIGlmIChpc05hTihjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFxcXFxAY2hhciBoYXMgbm9uLW51bWVyaWMgYXJndW1lbnQgJHtudW1iZXJ9YCwgdG9rZW4pXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgdGV4dDogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBIZWxwZXJzXG5jb25zdCBodG1sUmVnRXggPSAvXigjW2EtZjAtOV17M318Iz9bYS1mMC05XXs2fSkkL2k7XG5jb25zdCBodG1sT3JOYW1lUmVnRXggPSAvXigjW2EtZjAtOV17M318Iz9bYS1mMC05XXs2fXxbYS16XSspJC9pO1xuY29uc3QgUkdCcmVnRXggPSAvXiAqXFxkezEsM30gKig/OiwgKlxcZHsxLDN9ICopezJ9JC87XG5jb25zdCByZ2JSZWdFeCA9IC9eICpbMTBdKD86XFwuXFxkKik/ICooPzosICpbMTBdKD86XFwuXFxkKik/ICopezJ9JC87XG5jb25zdCB4Y29sb3JIdG1sUmVnRXggPSAvXlthLWYwLTldezZ9JC9pO1xuY29uc3QgdG9IZXggPSBudW0gPT4ge1xuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDEpIHsgc3RyID0gXCIwXCIgKyBzdHI7IH1cbiAgcmV0dXJuIHN0clxufTtcblxuLy8gQ29sb3JzIGZyb20gVGFibGVzIDQuMSBhbmQgNC4yIG9mIHRoZSB4Y29sb3IgcGFja2FnZS5cbi8vIFRhYmxlIDQuMSAobG93ZXIgY2FzZSkgUkdCIHZhbHVlcyBhcmUgdGFrZW4gZnJvbSBjaHJvbWEgYW5kIHhjb2xvci5kdHguXG4vLyBUYWJsZSA0LjIgKENhcGl0YWxpenplZCkgdmFsdWVzIHdlcmUgc2FtcGxlZCwgYmVjYXVzZSBDaHJvbWEgY29udGFpbnMgYSB1bnJlbGlhYmxlXG4vLyBjb252ZXJzaW9uIGZyb20gY215ayB0byBSR0IuIFNlZSBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9hLzUzNzI3NC5cbmNvbnN0IHhjb2xvcnMgPSBKU09OLnBhcnNlKGB7XG4gIFwiQXByaWNvdFwiOiBcIiNmZmI0ODRcIixcbiAgXCJBcXVhbWFyaW5lXCI6IFwiIzA4YjRiY1wiLFxuICBcIkJpdHRlcnN3ZWV0XCI6IFwiI2M4NGMxNFwiLFxuICBcImJsdWVcIjogXCIjMDAwMEZGXCIsXG4gIFwiQmx1ZVwiOiBcIiMzMDM0OTRcIixcbiAgXCJCbHVlR3JlZW5cIjogXCIjMDhiNGJjXCIsXG4gIFwiQmx1ZVZpb2xldFwiOiBcIiM1MDNjOTRcIixcbiAgXCJCcmlja1JlZFwiOiBcIiNiODM0MWNcIixcbiAgXCJicm93blwiOiBcIiNCRjgwNDBcIixcbiAgXCJCcm93blwiOiBcIiM4MDI0MDRcIixcbiAgXCJCdXJudE9yYW5nZVwiOiBcIiNmODk0MWNcIixcbiAgXCJDYWRldEJsdWVcIjogXCIjNzg3NDljXCIsXG4gIFwiQ2FybmF0aW9uUGlua1wiOiBcIiNmODg0YjRcIixcbiAgXCJDZXJ1bGVhblwiOiBcIiMwOGE0ZTRcIixcbiAgXCJDb3JuZmxvd2VyQmx1ZVwiOiBcIiM0MGFjZTRcIixcbiAgXCJjeWFuXCI6IFwiIzAwRkZGRlwiLFxuICBcIkN5YW5cIjogXCIjMDhhY2VjXCIsXG4gIFwiRGFuZGVsaW9uXCI6IFwiI2ZmYmM0NFwiLFxuICBcImRhcmtncmF5XCI6IFwiIzQwNDA0MFwiLFxuICBcIkRhcmtPcmNoaWRcIjogXCIjYTg1NDhjXCIsXG4gIFwiRW1lcmFsZFwiOiBcIiMwOGFjOWNcIixcbiAgXCJGb3Jlc3RHcmVlblwiOiBcIiMwODljNTRcIixcbiAgXCJGdWNoc2lhXCI6IFwiIzkwMzQ4Y1wiLFxuICBcIkdvbGRlbnJvZFwiOiBcIiNmZmRjNDRcIixcbiAgXCJncmF5XCI6IFwiIzgwODA4MFwiLFxuICBcIkdyYXlcIjogXCIjOTg5NDljXCIsXG4gIFwiZ3JlZW5cIjogXCIjMDBGRjAwXCIsXG4gIFwiR3JlZW5cIjogXCIjMDhhNDRjXCIsXG4gIFwiR3JlZW5ZZWxsb3dcIjogXCIjZTBlNDc0XCIsXG4gIFwiSnVuZ2xlR3JlZW5cIjogXCIjMDhhYzljXCIsXG4gIFwiTGF2ZW5kZXJcIjogXCIjZjg5Y2M0XCIsXG4gIFwibGlnaHRncmF5XCI6IFwiI2MwYzBjMFwiLFxuICBcImxpbWVcIjogXCIjQkZGRjAwXCIsXG4gIFwiTGltZUdyZWVuXCI6IFwiIzkwYzQzY1wiLFxuICBcIm1hZ2VudGFcIjogXCIjRkYwMEZGXCIsXG4gIFwiTWFnZW50YVwiOiBcIiNmMDA0OGNcIixcbiAgXCJNYWhvZ2FueVwiOiBcIiNiMDM0MWNcIixcbiAgXCJNYXJvb25cIjogXCIjYjAzNDM0XCIsXG4gIFwiTWVsb25cIjogXCIjZjg5YzdjXCIsXG4gIFwiTWlkbmlnaHRCbHVlXCI6IFwiIzA4NjQ5NFwiLFxuICBcIk11bGJlcnJ5XCI6IFwiI2IwM2M5NFwiLFxuICBcIk5hdnlCbHVlXCI6IFwiIzA4NmNiY1wiLFxuICBcIm9saXZlXCI6IFwiIzdGN0YwMFwiLFxuICBcIk9saXZlR3JlZW5cIjogXCIjNDA3YzM0XCIsXG4gIFwib3JhbmdlXCI6IFwiI0ZGODAwMFwiLFxuICBcIk9yYW5nZVwiOiBcIiNmODg0M2NcIixcbiAgXCJPcmFuZ2VSZWRcIjogXCIjZjAxNDVjXCIsXG4gIFwiT3JjaGlkXCI6IFwiI2IwNzRhY1wiLFxuICBcIlBlYWNoXCI6IFwiI2Y4OTQ1Y1wiLFxuICBcIlBlcml3aW5rbGVcIjogXCIjODA3NGJjXCIsXG4gIFwiUGluZUdyZWVuXCI6IFwiIzA4OGM3NFwiLFxuICBcInBpbmtcIjogXCIjZmY3ZjdmXCIsXG4gIFwiUGx1bVwiOiBcIiM5ODI0OGNcIixcbiAgXCJQcm9jZXNzQmx1ZVwiOiBcIiMwOGI0ZWNcIixcbiAgXCJwdXJwbGVcIjogXCIjQkYwMDQwXCIsXG4gIFwiUHVycGxlXCI6IFwiI2EwNDQ5Y1wiLFxuICBcIlJhd1NpZW5uYVwiOiBcIiM5ODNjMDRcIixcbiAgXCJyZWRcIjogXCIjZmYwMDAwXCIsXG4gIFwiUmVkXCI6IFwiI2YwMWMyNFwiLFxuICBcIlJlZE9yYW5nZVwiOiBcIiNmODY0MzRcIixcbiAgXCJSZWRWaW9sZXRcIjogXCIjYTAyNDZjXCIsXG4gIFwiUmhvZGFtaW5lXCI6IFwiI2YwNTQ5Y1wiLFxuICBcIlJveWFsbHVlXCI6IFwiIzA4NzRiY1wiLFxuICBcIlJveWFsUHVycGxlXCI6IFwiIzY4M2M5Y1wiLFxuICBcIlJ1YmluZVJlZFwiOiBcIiNmMDA0N2NcIixcbiAgXCJTYWxtb25cIjogXCIjZjg5NDhjXCIsXG4gIFwiU2VhR3JlZW5cIjogXCIjMzBiYzljXCIsXG4gIFwiU2VwaWFcIjogXCIjNzAxNDA0XCIsXG4gIFwiU2t5Qmx1ZVwiOiBcIiM0OGM0ZGNcIixcbiAgXCJTcHJpbmdHcmVlblwiOiBcIiNjOGRjNjRcIixcbiAgXCJUYW5cIjogXCIjZTA5Yzc0XCIsXG4gIFwidGVhbFwiOiBcIiMwMDdGN0ZcIixcbiAgXCJUZWFsQmx1ZVwiOiBcIiMwOGFjYjRcIixcbiAgXCJUaGlzdGxlXCI6IFwiI2Q4ODRiNFwiLFxuICBcIlR1cnF1b2lzZVwiOiBcIiMwOGI0Y2NcIixcbiAgXCJ2aW9sZXRcIjogXCIjODAwMDgwXCIsXG4gIFwiVmlvbGV0XCI6IFwiIzYwNDQ5Y1wiLFxuICBcIlZpb2xldFJlZFwiOiBcIiNmMDU0YTRcIixcbiAgXCJXaWxkU3RyYXdiZXJyeVwiOiBcIiNmMDI0NmNcIixcbiAgXCJ5ZWxsb3dcIjogXCIjRkZGRjAwXCIsXG4gIFwiWWVsbG93XCI6IFwiI2ZmZjQwNFwiLFxuICBcIlllbGxvd0dyZWVuXCI6IFwiIzk4Y2M2Y1wiLFxuICBcIlllbGxvd09yYW5nZVwiOiBcIiNmZmE0MWNcIlxufWApO1xuXG5jb25zdCBjb2xvckZyb21TcGVjID0gKG1vZGVsLCBzcGVjKSA9PiB7XG4gIGxldCBjb2xvciA9IFwiXCI7XG4gIGlmIChtb2RlbCA9PT0gXCJIVE1MXCIpIHtcbiAgICBpZiAoIWh0bWxSZWdFeC50ZXN0KHNwZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgSFRNTCBpbnB1dC5cIilcbiAgICB9XG4gICAgY29sb3IgPSBzcGVjO1xuICB9IGVsc2UgaWYgKG1vZGVsID09PSBcIlJHQlwiKSB7XG4gICAgaWYgKCFSR0JyZWdFeC50ZXN0KHNwZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgUkdCIGlucHV0LlwiKVxuICAgIH1cbiAgICBzcGVjLnNwbGl0KFwiLFwiKS5tYXAoZSA9PiB7IGNvbG9yICs9IHRvSGV4KE51bWJlcihlLnRyaW0oKSkpOyB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXJnYlJlZ0V4LnRlc3Qoc3BlYykpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCByYmcgaW5wdXQuXCIpXG4gICAgfVxuICAgIHNwZWMuc3BsaXQoXCIsXCIpLm1hcChlID0+IHtcbiAgICAgIGNvbnN0IG51bSA9IE51bWJlcihlLnRyaW0oKSk7XG4gICAgICBpZiAobnVtID4gMSkgeyB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNvbG9yIHJnYiBpbnB1dCBtdXN0IGJlIDwgMS5cIikgfVxuICAgICAgY29sb3IgKz0gdG9IZXgoTnVtYmVyKChudW0gKiAyNTUpLnRvRml4ZWQoMCkpKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoY29sb3IuY2hhckF0KDApICE9PSBcIiNcIikgeyBjb2xvciA9IFwiI1wiICsgY29sb3I7IH1cbiAgcmV0dXJuIGNvbG9yXG59O1xuXG5jb25zdCB2YWxpZGF0ZUNvbG9yID0gKGNvbG9yLCBtYWNyb3MsIHRva2VuKSA9PiB7XG4gIGNvbnN0IG1hY3JvTmFtZSA9IGBcXFxcXFxcXGNvbG9yQCR7Y29sb3J9YDsgLy8gZnJvbSBcXGRlZmluZUNvbG9yLlxuICBjb25zdCBtYXRjaCA9IGh0bWxPck5hbWVSZWdFeC5leGVjKGNvbG9yKTtcbiAgaWYgKCFtYXRjaCkgeyB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgY29sb3I6ICdcIiArIGNvbG9yICsgXCInXCIsIHRva2VuKSB9XG4gIC8vIFdlIGFsbG93IGEgNi1kaWdpdCBIVE1MIGNvbG9yIHNwZWMgd2l0aG91dCBhIGxlYWRpbmcgXCIjXCIuXG4gIC8vIFRoaXMgZm9sbG93cyB0aGUgeGNvbG9yIHBhY2thZ2UncyBIVE1MIGNvbG9yIG1vZGVsLlxuICAvLyBQcmVkZWZpbmVkIGNvbG9yIG5hbWVzIGFyZSBhbGwgbWlzc2VkIGJ5IHRoaXMgUmVnRXggcGF0dGVybi5cbiAgaWYgKHhjb2xvckh0bWxSZWdFeC50ZXN0KGNvbG9yKSkge1xuICAgIHJldHVybiBcIiNcIiArIGNvbG9yXG4gIH0gZWxzZSBpZiAoY29sb3IuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgIHJldHVybiBjb2xvclxuICB9IGVsc2UgaWYgKG1hY3Jvcy5oYXMobWFjcm9OYW1lKSkge1xuICAgIGNvbG9yID0gbWFjcm9zLmdldChtYWNyb05hbWUpLnRva2Vuc1swXS50ZXh0O1xuICB9IGVsc2UgaWYgKHhjb2xvcnNbY29sb3JdKSB7XG4gICAgY29sb3IgPSB4Y29sb3JzW2NvbG9yXTtcbiAgfVxuICByZXR1cm4gY29sb3Jcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkOCA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgLy8gSW4gTGFUZVgsIGNvbG9yIGlzIG5vdCBzdXBwb3NlZCB0byBjaGFuZ2UgdGhlIHNwYWNpbmcgb2YgYW55IG5vZGUuXG4gIC8vIFNvIGluc3RlYWQgb2Ygd3JhcHBpbmcgdGhlIGdyb3VwIGluIGFuIDxtc3R5bGU+LCB3ZSBhcHBseVxuICAvLyB0aGUgY29sb3IgaW5kaXZpZHVhbGx5IHRvIGVhY2ggbm9kZSBhbmQgcmV0dXJuIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG4gIGxldCBleHByID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlLndpdGhDb2xvcihncm91cC5jb2xvcikpO1xuICBleHByID0gZXhwci5tYXAoZSA9PiB7XG4gICAgZS5zdHlsZS5jb2xvciA9IGdyb3VwLmNvbG9yO1xuICAgIHJldHVybiBlXG4gIH0pO1xuICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KGV4cHIpXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFx0ZXh0Y29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwicmF3XCIsIFwib3JpZ2luYWxcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgdG9rZW4gfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0QXJnc1swXSAmJiBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgbGV0IGNvbG9yID0gXCJcIjtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IHNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBjb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIHNwZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3JvcywgdG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb2xvcixcbiAgICAgIGlzVGV4dENvbG9yOiB0cnVlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInJhd1wiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBicmVha09uVG9rZW5UZXh0LCB0b2tlbiB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBsZXQgY29sb3IgPSBcIlwiO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3Qgc3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICAgIGNvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgc3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gdmFsaWRhdGVDb2xvcihhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmcsIHBhcnNlci5ndWxsZXQubWFjcm9zLCB0b2tlbik7XG4gICAgfVxuXG4gICAgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5IHRoYXQgc2hvdWxkIGJlIGNvbG9yZWQuXG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb2xvcixcbiAgICAgIGlzVGV4dENvbG9yOiBmYWxzZSxcbiAgICAgIGJvZHlcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOFxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXGRlZmluZWNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwicmF3XCIsIFwicmF3XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSB7XG4gICAgY29uc3QgbmFtZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBpZiAoIS9eW0EtWmEtel0rJC8udGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDb2xvciBuYW1lIG11c3QgYmUgbGF0aW4gbGV0dGVycy5cIiwgdG9rZW4pXG4gICAgfVxuICAgIGNvbnN0IG1vZGVsID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGlmICghW1wiSFRNTFwiLCBcIlJHQlwiLCBcInJnYlwiXS5pbmNsdWRlcyhtb2RlbCkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ29sb3IgbW9kZWwgbXVzdCBiZSBIVE1MLCBSR0IsIG9yIHJnYi5cIiwgdG9rZW4pXG4gICAgfVxuICAgIGNvbnN0IHNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzJdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgY29uc3QgY29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBzcGVjKTtcbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoYFxcXFxcXFxcY29sb3JAJHtuYW1lfWAsIHsgdG9rZW5zOiBbeyB0ZXh0OiBjb2xvciB9XSwgbnVtQXJnczogMCB9KTtcbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH1cbiAgfVxuICAvLyBObyBtYXRobWxCdWlsZGVyLiBUaGUgcG9pbnQgb2YgXFxkZWZpbmVjb2xvciBpcyB0byBzZXQgYSBtYWNyby5cbn0pO1xuXG4vLyBSb3cgYnJlYWtzIHdpdGhpbiB0YWJ1bGFyIGVudmlyb25tZW50cywgYW5kIGxpbmUgYnJlYWtzIGF0IHRvcCBsZXZlbFxuXG5cbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXFxcey4uLlxcQHhuZXdsaW5lfVxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNyXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG5cbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCA9PT0gXCJbXCIgPyBwYXJzZXIucGFyc2VTaXplR3JvdXAodHJ1ZSkgOiBudWxsO1xuICAgIGNvbnN0IG5ld0xpbmUgPSAhcGFyc2VyLnNldHRpbmdzLmRpc3BsYXlNb2RlO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5ld0xpbmUsXG4gICAgICBzaXplOiBzaXplICYmIGFzc2VydE5vZGVUeXBlKHNpemUsIFwic2l6ZVwiKS52YWx1ZVxuICAgIH1cbiAgfSxcblxuICAvLyBUaGUgZm9sbG93aW5nIGJ1aWxkZXIgaXMgY2FsbGVkIG9ubHkgYXQgdGhlIHRvcCBsZXZlbCxcbiAgLy8gbm90IHdpdGhpbiB0YWJ1bGFyL2FycmF5IGVudmlyb25tZW50cy5cblxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIE1hdGhNTCAzLjAgY2FsbHMgZm9yIG5ld2xpbmUgdG8gb2NjdXIgaW4gYW4gPG1vPiBvciBhbiA8bXNwYWNlPi5cbiAgICAvLyBSZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9NYXRoTUwzL2NoYXB0ZXIzLmh0bWwjcHJlc20ubGluZWJyZWFraW5nXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIik7XG4gICAgaWYgKGdyb3VwLm5ld0xpbmUpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZWJyZWFrXCIsIFwibmV3bGluZVwiKTtcbiAgICAgIGlmIChncm91cC5zaXplKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBjYWxjdWxhdGVTaXplKGdyb3VwLnNpemUsIHN0eWxlKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc2l6ZS5udW1iZXIgKyBzaXplLnVuaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuY29uc3QgZ2xvYmFsTWFwID0ge1xuICBcIlxcXFxnbG9iYWxcIjogXCJcXFxcZ2xvYmFsXCIsXG4gIFwiXFxcXGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIjogXCJcXFxcXFxcXGdsb2JhbGxvbmdcIixcbiAgXCJcXFxcZGVmXCI6IFwiXFxcXGdkZWZcIixcbiAgXCJcXFxcZ2RlZlwiOiBcIlxcXFxnZGVmXCIsXG4gIFwiXFxcXGVkZWZcIjogXCJcXFxceGRlZlwiLFxuICBcIlxcXFx4ZGVmXCI6IFwiXFxcXHhkZWZcIixcbiAgXCJcXFxcbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxsZXRcIixcbiAgXCJcXFxcZnV0dXJlbGV0XCI6IFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIlxufTtcblxuY29uc3QgY2hlY2tDb250cm9sU2VxdWVuY2UgPSAodG9rKSA9PiB7XG4gIGNvbnN0IG5hbWUgPSB0b2sudGV4dDtcbiAgaWYgKC9eKD86W1xcXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBjb250cm9sIHNlcXVlbmNlXCIsIHRvayk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuXG5jb25zdCBnZXRSSFMgPSAocGFyc2VyKSA9PiB7XG4gIGxldCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gIGlmICh0b2sudGV4dCA9PT0gXCI9XCIpIHtcbiAgICAvLyBjb25zdW1lIG9wdGlvbmFsIGVxdWFsc1xuICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBpZiAodG9rLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAvLyBjb25zdW1lIG9uZSBvcHRpb25hbCBzcGFjZVxuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rO1xufTtcblxuY29uc3QgbGV0Q29tbWFuZCA9IChwYXJzZXIsIG5hbWUsIHRvaywgZ2xvYmFsKSA9PiB7XG4gIGxldCBtYWNybyA9IHBhcnNlci5ndWxsZXQubWFjcm9zLmdldCh0b2sudGV4dCk7XG4gIGlmIChtYWNybyA9PSBudWxsKSB7XG4gICAgLy8gZG9uJ3QgZXhwYW5kIGl0IGxhdGVyIGV2ZW4gaWYgYSBtYWNybyB3aXRoIHRoZSBzYW1lIG5hbWUgaXMgZGVmaW5lZFxuICAgIC8vIGUuZy4sIFxcbGV0XFxmb289XFxmcmFjIFxcZGVmXFxmcmFje1xccmVsYXh9IFxcZnJhYzEyXG4gICAgdG9rLm5vZXhwYW5kID0gdHJ1ZTtcbiAgICBtYWNybyA9IHtcbiAgICAgIHRva2VuczogW3Rva10sXG4gICAgICBudW1BcmdzOiAwLFxuICAgICAgLy8gcmVwcm9kdWNlIHRoZSBzYW1lIGJlaGF2aW9yIGluIGV4cGFuc2lvblxuICAgICAgdW5leHBhbmRhYmxlOiAhcGFyc2VyLmd1bGxldC5pc0V4cGFuZGFibGUodG9rLnRleHQpXG4gICAgfTtcbiAgfVxuICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQobmFtZSwgbWFjcm8sIGdsb2JhbCk7XG59O1xuXG4vLyA8YXNzaWdubWVudD4gLT4gPG5vbi1tYWNybyBhc3NpZ25tZW50Pnw8bWFjcm8gYXNzaWdubWVudD5cbi8vIDxub24tbWFjcm8gYXNzaWdubWVudD4gLT4gPHNpbXBsZSBhc3NpZ25tZW50PnxcXGdsb2JhbDxub24tbWFjcm8gYXNzaWdubWVudD5cbi8vIDxtYWNybyBhc3NpZ25tZW50PiAtPiA8ZGVmaW5pdGlvbj58PHByZWZpeD48bWFjcm8gYXNzaWdubWVudD5cbi8vIDxwcmVmaXg+IC0+IFxcZ2xvYmFsfFxcbG9uZ3xcXG91dGVyXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxnbG9iYWxcIixcbiAgICBcIlxcXFxsb25nXCIsXG4gICAgXCJcXFxcXFxcXGdsb2JhbGxvbmdcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgY29uc3QgdG9rZW4gPSBwYXJzZXIuZmV0Y2goKTtcbiAgICBpZiAoZ2xvYmFsTWFwW3Rva2VuLnRleHRdKSB7XG4gICAgICAvLyBUZW1tbCBkb2Vzbid0IGhhdmUgXFxwYXIsIHNvIGlnbm9yZSBcXGxvbmdcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcZ2xvYmFsXCIgfHwgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIpIHtcbiAgICAgICAgdG9rZW4udGV4dCA9IGdsb2JhbE1hcFt0b2tlbi50ZXh0XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImludGVybmFsXCIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCB0b2tlbiBhZnRlciBtYWNybyBwcmVmaXhgLCB0b2tlbik7XG4gIH1cbn0pO1xuXG4vLyBCYXNpYyBzdXBwb3J0IGZvciBtYWNybyBkZWZpbml0aW9uczogXFxkZWYsIFxcZ2RlZiwgXFxlZGVmLCBcXHhkZWZcbi8vIDxkZWZpbml0aW9uPiAtPiA8ZGVmPjxjb250cm9sIHNlcXVlbmNlPjxkZWZpbml0aW9uIHRleHQ+XG4vLyA8ZGVmPiAtPiBcXGRlZnxcXGdkZWZ8XFxlZGVmfFxceGRlZlxuLy8gPGRlZmluaXRpb24gdGV4dD4gLT4gPHBhcmFtZXRlciB0ZXh0PjxsZWZ0IGJyYWNlPjxiYWxhbmNlZCB0ZXh0PjxyaWdodCBicmFjZT5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXGRlZlwiLCBcIlxcXFxnZGVmXCIsIFwiXFxcXGVkZWZcIiwgXCJcXFxceGRlZlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBsZXQgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGNvbnN0IG5hbWUgPSB0b2sudGV4dDtcbiAgICBpZiAoL14oPzpbXFxcXHt9JCYjXl9dfEVPRikkLy50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGEgY29udHJvbCBzZXF1ZW5jZVwiLCB0b2spO1xuICAgIH1cblxuICAgIGxldCBudW1BcmdzID0gMDtcbiAgICBsZXQgaW5zZXJ0O1xuICAgIGNvbnN0IGRlbGltaXRlcnMgPSBbW11dO1xuICAgIC8vIDxwYXJhbWV0ZXIgdGV4dD4gY29udGFpbnMgbm8gYnJhY2VzXG4gICAgd2hpbGUgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCJ7XCIpIHtcbiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICAgIGlmICh0b2sudGV4dCA9PT0gXCIjXCIpIHtcbiAgICAgICAgLy8gSWYgdGhlIHZlcnkgbGFzdCBjaGFyYWN0ZXIgb2YgdGhlIDxwYXJhbWV0ZXIgdGV4dD4gaXMgIywgc28gdGhhdFxuICAgICAgICAvLyB0aGlzICMgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgeywgVGVYIHdpbGwgYmVoYXZlIGFzIGlmIHRoZSB7XG4gICAgICAgIC8vIGhhZCBiZWVuIGluc2VydGVkIGF0IHRoZSByaWdodCBlbmQgb2YgYm90aCB0aGUgcGFyYW1ldGVyIHRleHRcbiAgICAgICAgLy8gYW5kIHRoZSByZXBsYWNlbWVudCB0ZXh0LlxuICAgICAgICBpZiAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ID09PSBcIntcIikge1xuICAgICAgICAgIGluc2VydCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCk7XG4gICAgICAgICAgZGVsaW1pdGVyc1tudW1BcmdzXS5wdXNoKFwie1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgcGFyYW1ldGVyLCB0aGUgZmlyc3QgYXBwZWFyYW5jZSBvZiAjIG11c3QgYmUgZm9sbG93ZWQgYnkgMSxcbiAgICAgICAgLy8gdGhlIG5leHQgYnkgMiwgYW5kIHNvIG9uOyB1cCB0byBuaW5lICPigJlzIGFyZSBhbGxvd2VkXG4gICAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICAgICAgaWYgKCEvXlsxLTldJC8udGVzdCh0b2sudGV4dCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBhcmd1bWVudCBudW1iZXIgXCIke3Rvay50ZXh0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlSW50KHRvay50ZXh0KSAhPT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgQXJndW1lbnQgbnVtYmVyIFwiJHt0b2sudGV4dH1cIiBvdXQgb2Ygb3JkZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBudW1BcmdzKys7XG4gICAgICAgIGRlbGltaXRlcnMucHVzaChbXSk7XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBtYWNybyBkZWZpbml0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsaW1pdGVyc1tudW1BcmdzXS5wdXNoKHRvay50ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcmVwbGFjZW1lbnQgdGV4dCwgZW5jbG9zZWQgaW4gJ3snIGFuZCAnfScgYW5kIHByb3Blcmx5IG5lc3RlZFxuICAgIGxldCB7IHRva2VucyB9ID0gcGFyc2VyLmd1bGxldC5jb25zdW1lQXJnKCk7XG4gICAgaWYgKGluc2VydCkge1xuICAgICAgdG9rZW5zLnVuc2hpZnQoaW5zZXJ0KTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGVkZWZcIiB8fCBmdW5jTmFtZSA9PT0gXCJcXFxceGRlZlwiKSB7XG4gICAgICB0b2tlbnMgPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZFRva2Vucyh0b2tlbnMpO1xuICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiBwYXJzZXIuZ3VsbGV0LnNldHRpbmdzLm1heEV4cGFuZCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRvbyBtYW55IGV4cGFuc2lvbnMgaW4gYW4gXCIgKyBmdW5jTmFtZSk7XG4gICAgICB9XG4gICAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayBvcmRlclxuICAgIH1cbiAgICAvLyBGaW5hbCBhcmcgaXMgdGhlIGV4cGFuc2lvbiBvZiB0aGUgbWFjcm9cbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXG4gICAgICBuYW1lLFxuICAgICAgeyB0b2tlbnMsIG51bUFyZ3MsIGRlbGltaXRlcnMgfSxcbiAgICAgIGZ1bmNOYW1lID09PSBnbG9iYWxNYXBbZnVuY05hbWVdXG4gICAgKTtcbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG4gIH1cbn0pO1xuXG4vLyA8c2ltcGxlIGFzc2lnbm1lbnQ+IC0+IDxsZXQgYXNzaWdubWVudD5cbi8vIDxsZXQgYXNzaWdubWVudD4gLT4gXFxmdXR1cmVsZXQ8Y29udHJvbCBzZXF1ZW5jZT48dG9rZW4+PHRva2VuPlxuLy8gICAgIHwgXFxsZXQ8Y29udHJvbCBzZXF1ZW5jZT48ZXF1YWxzPjxvbmUgb3B0aW9uYWwgc3BhY2U+PHRva2VuPlxuLy8gPGVxdWFscz4gLT4gPG9wdGlvbmFsIHNwYWNlcz58PG9wdGlvbmFsIHNwYWNlcz49XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxsZXRcIixcbiAgICBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgY29uc3QgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgcGFyc2VyLmd1bGxldC5jb25zdW1lU3BhY2VzKCk7XG4gICAgY29uc3QgdG9rID0gZ2V0UkhTKHBhcnNlcik7XG4gICAgbGV0Q29tbWFuZChwYXJzZXIsIG5hbWUsIHRvaywgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxsZXRcIik7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcm5hbFwiLCBtb2RlOiBwYXJzZXIubW9kZSB9O1xuICB9XG59KTtcblxuLy8gcmVmOiBodHRwczovL3d3dy50dWcub3JnL1RVR2JvYXQvdGIwOS0zL3RiMjJiZWNodG9sc2hlaW0ucGRmXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxmdXR1cmVsZXRcIixcbiAgICBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgY29uc3QgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgY29uc3QgbWlkZGxlID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGNvbnN0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBsZXRDb21tYW5kKHBhcnNlciwgbmFtZSwgdG9rLCBmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiKTtcbiAgICBwYXJzZXIuZ3VsbGV0LnB1c2hUb2tlbih0b2spO1xuICAgIHBhcnNlci5ndWxsZXQucHVzaFRva2VuKG1pZGRsZSk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcm5hbFwiLCBtb2RlOiBwYXJzZXIubW9kZSB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcbmV3Y29tbWFuZFwiLCBcIlxcXFxyZW5ld2NvbW1hbmRcIiwgXCJcXFxccHJvdmlkZWNvbW1hbmRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgbGV0IG5hbWUgPSBcIlwiO1xuICAgIGNvbnN0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBpZiAodG9rLnRleHQgPT09IFwie1wiKSB7XG4gICAgICBuYW1lID0gY2hlY2tDb250cm9sU2VxdWVuY2UocGFyc2VyLmd1bGxldC5wb3BUb2tlbigpKTtcbiAgICAgIHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHRvayk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RzID0gcGFyc2VyLmd1bGxldC5pc0RlZmluZWQobmFtZSk7XG4gICAgaWYgKGV4aXN0cyAmJiBmdW5jTmFtZSA9PT0gXCJcXFxcbmV3Y29tbWFuZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgYFxcXFxuZXdjb21tYW5keyR7bmFtZX19IGF0dGVtcHRpbmcgdG8gcmVkZWZpbmUgJHtuYW1lfTsgdXNlIFxcXFxyZW5ld2NvbW1hbmRgXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWV4aXN0cyAmJiBmdW5jTmFtZSA9PT0gXCJcXFxccmVuZXdjb21tYW5kXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBgXFxcXHJlbmV3Y29tbWFuZHske25hbWV9fSB3aGVuIGNvbW1hbmQgJHtuYW1lfSBkb2VzIG5vdCB5ZXQgZXhpc3Q7IHVzZSBcXFxcbmV3Y29tbWFuZGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG51bUFyZ3MgPSAwO1xuICAgIGlmIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgPT09IFwiW1wiKSB7XG4gICAgICBsZXQgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgaWYgKCEvXlswLTldJC8udGVzdCh0b2sudGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50czogXCIke3Rvay50ZXh0fVwiYCk7XG4gICAgICB9XG4gICAgICBudW1BcmdzID0gcGFyc2VJbnQodG9rLnRleHQpO1xuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgaWYgKHRvay50ZXh0ICE9PSBcIl1cIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBhcmd1bWVudCBcIiR7dG9rLnRleHR9XCJgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXBsYWNlbWVudCB0ZXh0LCBlbmNsb3NlZCBpbiAneycgYW5kICd9JyBhbmQgcHJvcGVybHkgbmVzdGVkXG4gICAgY29uc3QgeyB0b2tlbnMgfSA9IHBhcnNlci5ndWxsZXQuY29uc3VtZUFyZygpO1xuXG4gICAgaWYgKCEoZnVuY05hbWUgPT09IFwiXFxcXHByb3ZpZGVjb21tYW5kXCIgJiYgcGFyc2VyLmd1bGxldC5tYWNyb3MuaGFzKG5hbWUpKSkge1xuICAgICAgLy8gSWdub3JlIFxccHJvdmlkZWNvbW1hbmRcbiAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcbiAgICAgICAgbmFtZSxcbiAgICAgICAgeyB0b2tlbnMsIG51bUFyZ3MgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG5cbiAgfVxufSk7XG5cbi8vIEV4dHJhIGRhdGEgbmVlZGVkIGZvciB0aGUgZGVsaW1pdGVyIGhhbmRsZXIgZG93biBiZWxvd1xuY29uc3QgZGVsaW1pdGVyU2l6ZXMgPSB7XG4gIFwiXFxcXGJpZ2xcIjogeyBtY2xhc3M6IFwibW9wZW5cIiwgc2l6ZTogMSB9LFxuICBcIlxcXFxCaWdsXCI6IHsgbWNsYXNzOiBcIm1vcGVuXCIsIHNpemU6IDIgfSxcbiAgXCJcXFxcYmlnZ2xcIjogeyBtY2xhc3M6IFwibW9wZW5cIiwgc2l6ZTogMyB9LFxuICBcIlxcXFxCaWdnbFwiOiB7IG1jbGFzczogXCJtb3BlblwiLCBzaXplOiA0IH0sXG4gIFwiXFxcXGJpZ3JcIjogeyBtY2xhc3M6IFwibWNsb3NlXCIsIHNpemU6IDEgfSxcbiAgXCJcXFxcQmlnclwiOiB7IG1jbGFzczogXCJtY2xvc2VcIiwgc2l6ZTogMiB9LFxuICBcIlxcXFxiaWdnclwiOiB7IG1jbGFzczogXCJtY2xvc2VcIiwgc2l6ZTogMyB9LFxuICBcIlxcXFxCaWdnclwiOiB7IG1jbGFzczogXCJtY2xvc2VcIiwgc2l6ZTogNCB9LFxuICBcIlxcXFxiaWdtXCI6IHsgbWNsYXNzOiBcIm1yZWxcIiwgc2l6ZTogMSB9LFxuICBcIlxcXFxCaWdtXCI6IHsgbWNsYXNzOiBcIm1yZWxcIiwgc2l6ZTogMiB9LFxuICBcIlxcXFxiaWdnbVwiOiB7IG1jbGFzczogXCJtcmVsXCIsIHNpemU6IDMgfSxcbiAgXCJcXFxcQmlnZ21cIjogeyBtY2xhc3M6IFwibXJlbFwiLCBzaXplOiA0IH0sXG4gIFwiXFxcXGJpZ1wiOiB7IG1jbGFzczogXCJtb3JkXCIsIHNpemU6IDEgfSxcbiAgXCJcXFxcQmlnXCI6IHsgbWNsYXNzOiBcIm1vcmRcIiwgc2l6ZTogMiB9LFxuICBcIlxcXFxiaWdnXCI6IHsgbWNsYXNzOiBcIm1vcmRcIiwgc2l6ZTogMyB9LFxuICBcIlxcXFxCaWdnXCI6IHsgbWNsYXNzOiBcIm1vcmRcIiwgc2l6ZTogNCB9XG59O1xuXG5jb25zdCBkZWxpbWl0ZXJzID0gW1xuICBcIihcIixcbiAgXCJcXFxcbHBhcmVuXCIsXG4gIFwiKVwiLFxuICBcIlxcXFxycGFyZW5cIixcbiAgXCJbXCIsXG4gIFwiXFxcXGxicmFja1wiLFxuICBcIl1cIixcbiAgXCJcXFxccmJyYWNrXCIsXG4gIFwiXFxcXHtcIixcbiAgXCJcXFxcbGJyYWNlXCIsXG4gIFwiXFxcXH1cIixcbiAgXCJcXFxccmJyYWNlXCIsXG4gIFwi4qaHXCIsXG4gIFwiXFxcXGxscGFyZW50aGVzaXNcIixcbiAgXCLipohcIixcbiAgXCJcXFxccnJwYXJlbnRoZXNpc1wiLFxuICBcIlxcXFxsZmxvb3JcIixcbiAgXCJcXFxccmZsb29yXCIsXG4gIFwiXFx1MjMwYVwiLFxuICBcIlxcdTIzMGJcIixcbiAgXCJcXFxcbGNlaWxcIixcbiAgXCJcXFxccmNlaWxcIixcbiAgXCJcXHUyMzA4XCIsXG4gIFwiXFx1MjMwOVwiLFxuICBcIjxcIixcbiAgXCI+XCIsXG4gIFwiXFxcXGxhbmdsZVwiLFxuICBcIlxcdTI3ZThcIixcbiAgXCJcXFxccmFuZ2xlXCIsXG4gIFwiXFx1MjdlOVwiLFxuICBcIlxcXFxsQW5nbGVcIixcbiAgXCJcXHUyN2VhXCIsXG4gIFwiXFxcXHJBbmdsZVwiLFxuICBcIlxcdTI3ZWJcIixcbiAgXCJcXFxcbGxhbmdsZVwiLFxuICBcIuKmiVwiLFxuICBcIlxcXFxycmFuZ2xlXCIsXG4gIFwi4qaKXCIsXG4gIFwiXFxcXGx0XCIsXG4gIFwiXFxcXGd0XCIsXG4gIFwiXFxcXGx2ZXJ0XCIsXG4gIFwiXFxcXHJ2ZXJ0XCIsXG4gIFwiXFxcXGxWZXJ0XCIsXG4gIFwiXFxcXHJWZXJ0XCIsXG4gIFwiXFxcXGxncm91cFwiLFxuICBcIlxcXFxyZ3JvdXBcIixcbiAgXCJcXHUyN2VlXCIsXG4gIFwiXFx1MjdlZlwiLFxuICBcIlxcXFxsbW91c3RhY2hlXCIsXG4gIFwiXFxcXHJtb3VzdGFjaGVcIixcbiAgXCJcXHUyM2IwXCIsXG4gIFwiXFx1MjNiMVwiLFxuICBcIlxcXFxsbGJyYWNrZXRcIixcbiAgXCJcXFxccnJicmFja2V0XCIsXG4gIFwiXFx1MjdlNlwiLFxuICBcIlxcdTI3ZTZcIixcbiAgXCJcXFxcbEJyYWNlXCIsXG4gIFwiXFxcXHJCcmFjZVwiLFxuICBcIlxcdTI5ODNcIixcbiAgXCJcXHUyOTg0XCIsXG4gIFwiL1wiLFxuICBcIlxcXFxiYWNrc2xhc2hcIixcbiAgXCJ8XCIsXG4gIFwiXFxcXHZlcnRcIixcbiAgXCJcXFxcfFwiLFxuICBcIlxcXFxWZXJ0XCIsXG4gIFwiXFx1MjAxNlwiLFxuICBcIlxcXFx1cGFycm93XCIsXG4gIFwiXFxcXFVwYXJyb3dcIixcbiAgXCJcXFxcZG93bmFycm93XCIsXG4gIFwiXFxcXERvd25hcnJvd1wiLFxuICBcIlxcXFx1cGRvd25hcnJvd1wiLFxuICBcIlxcXFxVcGRvd25hcnJvd1wiLFxuICBcIi5cIlxuXTtcblxuLy8gRXhwb3J0IGlzRGVsaW1pdGVyIGZvciBiZW5lZml0IG9mIHBhcnNlci5cbmNvbnN0IGRlbHMgPSBbXCJ9XCIsIFwiXFxcXGxlZnRcIiwgXCJcXFxcbWlkZGxlXCIsIFwiXFxcXHJpZ2h0XCJdO1xuY29uc3QgaXNEZWxpbWl0ZXIgPSBzdHIgPT4gc3RyLmxlbmd0aCA+IDAgJiZcbiAgKGRlbGltaXRlcnMuaW5jbHVkZXMoc3RyKSB8fCBkZWxpbWl0ZXJTaXplc1tzdHJdIHx8IGRlbHMuaW5jbHVkZXMoc3RyKSk7XG5cbi8vIE1ldHJpY3Mgb2YgdGhlIGRpZmZlcmVudCBzaXplcy4gRm91bmQgYnkgbG9va2luZyBhdCBUZVgncyBvdXRwdXQgb2Zcbi8vICRcXGJpZ2x8IC8vIFxcQmlnbHwgXFxiaWdnbHwgXFxCaWdnbHwgXFxzaG93bGlzdHMkXG4vLyBVc2VkIHRvIGNyZWF0ZSBzdGFja2VkIGRlbGltaXRlcnMgb2YgYXBwcm9wcmlhdGUgc2l6ZXMgaW4gbWFrZVNpemVkRGVsaW0uXG5jb25zdCBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcblxuLy8gRGVsaW1pdGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gY2hlY2tEZWxpbWl0ZXIoZGVsaW0sIGNvbnRleHQpIHtcbiAgY29uc3Qgc3ltRGVsaW0gPSBjaGVja1N5bWJvbE5vZGVUeXBlKGRlbGltKTtcbiAgaWYgKHN5bURlbGltICYmIGRlbGltaXRlcnMuaW5jbHVkZXMoc3ltRGVsaW0udGV4dCkpIHtcbiAgICAvLyBJZiBhIGNoYXJhY3RlciBpcyBub3QgaW4gdGhlIE1hdGhNTCBvcGVyYXRvciBkaWN0aW9uYXJ5LCBpdCB3aWxsIG5vdCBzdHJldGNoLlxuICAgIC8vIFJlcGxhY2Ugc3VjaCBjaGFyYWN0ZXJzIHcvY2hhcmFjdGVycyB0aGF0IHdpbGwgc3RyZXRjaC5cbiAgICBpZiAoW1wiPFwiLCBcIlxcXFxsdFwiXS5pbmNsdWRlcyhzeW1EZWxpbS50ZXh0KSkgeyBzeW1EZWxpbS50ZXh0ID0gXCLin6hcIjsgfVxuICAgIGlmIChbXCI+XCIsIFwiXFxcXGd0XCJdLmluY2x1ZGVzKHN5bURlbGltLnRleHQpKSB7IHN5bURlbGltLnRleHQgPSBcIuKfqVwiOyB9XG4gICAgcmV0dXJuIHN5bURlbGltO1xuICB9IGVsc2UgaWYgKHN5bURlbGltKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgZGVsaW1pdGVyICcke3N5bURlbGltLnRleHR9JyBhZnRlciAnJHtjb250ZXh0LmZ1bmNOYW1lfSdgLCBkZWxpbSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgZGVsaW1pdGVyIHR5cGUgJyR7ZGVsaW0udHlwZX0nYCwgZGVsaW0pO1xuICB9XG59XG5cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICBcXFxuY29uc3QgbmVlZEV4cGxpY2l0U3RyZXRjaCA9IFtcIlxcdTAwMkZcIiwgXCJcXHUwMDVDXCIsIFwiXFxcXGJhY2tzbGFzaFwiLCBcIlxcXFx2ZXJ0XCIsIFwifFwiXTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcYmlnbFwiLFxuICAgIFwiXFxcXEJpZ2xcIixcbiAgICBcIlxcXFxiaWdnbFwiLFxuICAgIFwiXFxcXEJpZ2dsXCIsXG4gICAgXCJcXFxcYmlnclwiLFxuICAgIFwiXFxcXEJpZ3JcIixcbiAgICBcIlxcXFxiaWdnclwiLFxuICAgIFwiXFxcXEJpZ2dyXCIsXG4gICAgXCJcXFxcYmlnbVwiLFxuICAgIFwiXFxcXEJpZ21cIixcbiAgICBcIlxcXFxiaWdnbVwiLFxuICAgIFwiXFxcXEJpZ2dtXCIsXG4gICAgXCJcXFxcYmlnXCIsXG4gICAgXCJcXFxcQmlnXCIsXG4gICAgXCJcXFxcYmlnZ1wiLFxuICAgIFwiXFxcXEJpZ2dcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkZWxpbXNpemluZ1wiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICBtY2xhc3M6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLm1jbGFzcyxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwKSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC5kZWxpbSA9PT0gXCIuXCIpIHsgZ3JvdXAuZGVsaW0gPSBcIlwiOyB9XG4gICAgY2hpbGRyZW4ucHVzaChtYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSkpO1xuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgY2hpbGRyZW4pO1xuXG4gICAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgLy8gT25seSBzb21lIG9mIHRoZSBkZWxpbXNpemluZyBmdW5jdGlvbnMgYWN0IGFzIGZlbmNlcywgYW5kIHRoZXlcbiAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXhwbGljaXRseSBkaXNhYmxlIGZlbmNpbmcgaWYgaXQncyBub3QgYSBmZW5jZSwgdG8gb3ZlcnJpZGUgdGhlXG4gICAgICAvLyBkZWZhdWx0cy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG4gICAgaWYgKG5lZWRFeHBsaWNpdFN0cmV0Y2guaW5jbHVkZXMoZ3JvdXAuZGVsaW0pIHx8IGdyb3VwLmRlbGltLmluZGV4T2YoXCJhcnJvd1wiKSA+IC0xKSB7XG4gICAgICAvLyBXZSBoYXZlIHRvIGV4cGxpY2l0bHkgc2V0IHN0cmV0Y2h5IHRvIHRydWUuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzeW1tZXRyaWNcIiwgXCJ0cnVlXCIpOyAvLyBOZWVkZWQgZm9yIHRhbGwgYXJyb3dzIGluIEZpcmVmb3guXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtaW5zaXplXCIsIHNpemVUb01heEhlaWdodFtncm91cC5zaXplXSArIFwiZW1cIik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXhzaXplXCIsIHNpemVUb01heEhlaWdodFtncm91cC5zaXplXSArIFwiZW1cIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhc3NlcnRQYXJzZWQoZ3JvdXApIHtcbiAgaWYgKCFncm91cC5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnOiBUaGUgbGVmdHJpZ2h0IFBhcnNlTm9kZSB3YXNuJ3QgZnVsbHkgcGFyc2VkLlwiKTtcbiAgfVxufVxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gIG5hbWVzOiBbXCJcXFxccmlnaHRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0LXJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpLnRleHRcbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICBuYW1lczogW1wiXFxcXGxlZnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcblxuICAgIGNvbnN0IHBhcnNlciA9IGNvbnRleHQucGFyc2VyO1xuICAgIC8vIFBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keVxuICAgICsrcGFyc2VyLmxlZnRyaWdodERlcHRoO1xuICAgIC8vIHBhcnNlRXhwcmVzc2lvbiBzdG9wcyBiZWZvcmUgJ1xcXFxyaWdodCcgb3IgYFxcXFxtaWRkbGVgXG4gICAgbGV0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBudWxsLCB0cnVlKTtcbiAgICBsZXQgbmV4dFRva2VuID0gcGFyc2VyLmZldGNoKCk7XG4gICAgd2hpbGUgKG5leHRUb2tlbi50ZXh0ID09PSBcIlxcXFxtaWRkbGVcIikge1xuICAgICAgLy8gYFxcbWlkZGxlYCwgZnJvbSB0aGUgzrUtVGVYIHBhY2thZ2UsIGVuZHMgb25lIGdyb3VwIGFuZCBzdGFydHMgYW5vdGhlciBncm91cC5cbiAgICAgIC8vIFdlIGhhZCB0byBwYXJzZSB0aGlzIGV4cHJlc3Npb24gd2l0aCBgYnJlYWtPbk1pZGRsZWAgZW5hYmxlZCBpbiBvcmRlclxuICAgICAgLy8gdG8gZ2V0IFRlWC1jb21wbGlhbnQgcGFyc2luZyBvZiBcXG92ZXIuXG4gICAgICAvLyBCdXQgd2UgZG8gbm90IHdhbnQsIGF0IHRoaXMgcG9pbnQsIHRvIGVuZCBvbiBcXG1pZGRsZSwgc28gY29udGludWVcbiAgICAgIC8vIHRvIHBhcnNlIHVudGlsIHdlIGZldGNoIGEgYFxccmlnaHRgLlxuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgIGNvbnN0IG1pZGRsZSA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gICAgICBpZiAoIXN5bWJvbHMubWF0aFttaWRkbGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIGRlbGltaXRlciAnJHttaWRkbGV9JyBhZnRlciAnXFxcXG1pZGRsZSdgKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrRGVsaW1pdGVyKHsgdHlwZTogXCJhdG9tXCIsIG1vZGU6IFwibWF0aFwiLCB0ZXh0OiBtaWRkbGUgfSwgeyBmdW5jTmFtZTogXCJcXFxcbWlkZGxlXCIgfSk7XG4gICAgICBib2R5LnB1c2goeyB0eXBlOiBcIm1pZGRsZVwiLCBtb2RlOiBcIm1hdGhcIiwgZGVsaW06IG1pZGRsZSB9KTtcbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICBib2R5ID0gYm9keS5jb25jYXQocGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgbnVsbCwgdHJ1ZSkpO1xuICAgICAgbmV4dFRva2VuID0gcGFyc2VyLmZldGNoKCk7XG4gICAgfVxuICAgIC0tcGFyc2VyLmxlZnRyaWdodERlcHRoO1xuICAgIC8vIENoZWNrIHRoZSBuZXh0IHRva2VuXG4gICAgcGFyc2VyLmV4cGVjdChcIlxcXFxyaWdodFwiLCBmYWxzZSk7XG4gICAgY29uc3QgcmlnaHQgPSBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImxlZnRyaWdodC1yaWdodFwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIGxlZnQ6IGRlbGltLnRleHQsXG4gICAgICByaWdodDogcmlnaHQuZGVsaW1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgYXNzZXJ0UGFyc2VkKGdyb3VwKTtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSk7XG5cbiAgICBpZiAoZ3JvdXAubGVmdCA9PT0gXCIuXCIpIHsgZ3JvdXAubGVmdCA9IFwiXCI7IH1cbiAgICBjb25zdCBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLmxlZnQsIGdyb3VwLm1vZGUpXSk7XG4gICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIGxlZnROb2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwcmVmaXhcIik7XG4gICAgaWYgKGdyb3VwLmxlZnQgPT09IFwiL1wiIHx8IGdyb3VwLmxlZnQgPT09IFwiXFx1MDA1Q1wiIHx8IGdyb3VwLmxlZnQuaW5kZXhPZihcImFycm93XCIpID4gLTEpIHtcbiAgICAgIGxlZnROb2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG5cbiAgICBpZiAoZ3JvdXAucmlnaHQgPT09IFwiLlwiKSB7IGdyb3VwLnJpZ2h0ID0gXCJcIjsgfVxuICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnJpZ2h0LCBncm91cC5tb2RlKV0pO1xuICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwb3N0Zml4XCIpO1xuICAgIGlmIChncm91cC5yaWdodCA9PT0gXCJcXHUyMjE2XCIgfHwgZ3JvdXAucmlnaHQuaW5kZXhPZihcImFycm93XCIpID4gLTEpIHtcbiAgICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGxhc3RFbGVtZW50ID0gZ3JvdXAuYm9keVtncm91cC5ib2R5Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RFbGVtZW50LnR5cGUgPT09IFwiY29sb3JcIiAmJiAhbGFzdEVsZW1lbnQuaXNUZXh0Q29sb3IpIHtcbiAgICAgICAgLy8gXFxjb2xvciBpcyBhIHN3aXRjaC4gSWYgdGhlIGxhc3QgZWxlbWVudCBpcyBvZiB0eXBlIFwiY29sb3JcIiB0aGVuXG4gICAgICAgIC8vIHRoZSB1c2VyIHNldCB0aGUgXFxjb2xvciBzd2l0Y2ggYW5kIGxlZnQgaXQgb24uXG4gICAgICAgIC8vIEEgXFxyaWdodCBkZWxpbWl0ZXIgdHVybnMgdGhlIHN3aXRjaCBvZmYsIGJ1dCB0aGUgZGVsaW1pdGVyIGl0c2VsZiBnZXRzIHRoZSBjb2xvci5cbiAgICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBsYXN0RWxlbWVudC5jb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcblxuICAgIHJldHVybiBtYWtlUm93KGlubmVyKTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtaWRkbGVcIixcbiAgbmFtZXM6IFtcIlxcXFxtaWRkbGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQucGFyc2VyLmxlZnRyaWdodERlcHRoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxtaWRkbGUgd2l0aG91dCBwcmVjZWRpbmcgXFxcXGxlZnRcIiwgZGVsaW0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGRlbGltOiBkZWxpbS50ZXh0XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IHRleHROb2RlID0gbWFrZVRleHQoZ3JvdXAuZGVsaW0sIGdyb3VwLm1vZGUpO1xuICAgIGNvbnN0IG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFt0ZXh0Tm9kZV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIGlmIChncm91cC5kZWxpbS5pbmRleE9mKFwiYXJyb3dcIikgPiAtMSkge1xuICAgICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIC8vIFRoZSBuZXh0IGxpbmUgaXMgbm90IHNlbWFudGljYWxseSBjb3JyZWN0LCBidXRcbiAgICAvLyBDaHJvbWl1bSBmYWlscyB0byBzdHJldGNoIGlmIGl0IGlzIG5vdCB0aGVyZS5cbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwcmVmaXhcIik7XG4gICAgLy8gTWF0aE1MIGdpdmVzIDUvMThlbSBzcGFjaW5nIHRvIGVhY2ggPG1vPiBlbGVtZW50LlxuICAgIC8vIFxcbWlkZGxlIHNob3VsZCBnZXQgZGVsaW1pdGVyIHNwYWNpbmcgaW5zdGVhZC5cbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjAuMDVlbVwiKTtcbiAgICByZXR1cm4gbWlkZGxlTm9kZTtcbiAgfVxufSk7XG5cbmNvbnN0IHBhZGRpbmcgPSBfID0+IHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiM3B0XCIpO1xuICByZXR1cm4gbm9kZVxufTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ3ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBsZXQgbm9kZTtcbiAgaWYgKGdyb3VwLmxhYmVsLmluZGV4T2YoXCJjb2xvcmJveFwiKSA+IC0xIHx8IGdyb3VwLmxhYmVsID09PSBcIlxcXFxib3hlZFwiKSB7XG4gICAgLy8gTWF0aE1MIGNvcmUgZG9lcyBub3Qgc3VwcG9ydCArd2lkdGggYXR0cmlidXRlIGluIDxtcGFkZGVkPi5cbiAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlbGlhYmx5IGFkZCBzaWRlIHBhZGRpbmcuXG4gICAgLy8gSW5zZXJ0IDxtc3BhY2U+XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXG4gICAgICBwYWRkaW5nKCksXG4gICAgICBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpLFxuICAgICAgcGFkZGluZygpXG4gICAgXSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWVuY2xvc2VcIiwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSldKTtcbiAgfVxuICBzd2l0Y2ggKGdyb3VwLmxhYmVsKSB7XG4gICAgY2FzZSBcIlxcXFxvdmVybGluZVwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInRvcFwiKTsgLy8gZm9yIEZpcmVmb3ggJiBXZWJLaXRcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLW92ZXJsaW5lXCIpOyAgICAvLyBmb3IgQ2hyb21pdW1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFx1bmRlcmxpbmVcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJib3R0b21cIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC11bmRlcmxpbmVcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInRtbC1jYW5jZWxcIiwgXCJ1cHN0cmlrZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGJjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJ0bWwtY2FuY2VsXCIsIFwiZG93bnN0cmlrZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXHNvdXRcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJob3Jpem9udGFsc3RyaWtlXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1widG1sLWNhbmNlbFwiLCBcInNvdXRcIl0pKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFx4Y2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidXBkaWFnb25hbHN0cmlrZSBkb3duZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC14Y2FuY2VsXCIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGxvbmdkaXZcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJsb25nZGl2XCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJsb25nZGl2LXRvcFwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcImxvbmdkaXYtYXJjXCJdKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxccGhhc2VcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJwaGFzb3JhbmdsZVwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwicGhhc29yLWJvdHRvbVwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInBoYXNvci1hbmdsZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXHRleHRjaXJjbGVkXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiY2lyY2xlXCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJjaXJjbGUtcGFkXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1widGV4dGNpcmNsZVwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGFuZ2xcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJhY3R1YXJpYWxcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcImFjdHVhcmlhbFwiKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxib3hlZFwiOlxuICAgICAgLy8gXFxuZXdjb21tYW5ke1xcYm94ZWR9WzFde1xcZmJveHtcXG1AdGgkXFxkaXNwbGF5c3R5bGUjMSR9fSBmcm9tIGFtc21hdGguc3R5XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYm94XCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJ0bWwtYm94XCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjBcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcInRydWVcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcZmJveFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImJveFwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLWZib3hcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcZmNvbG9yYm94XCI6XG4gICAgY2FzZSBcIlxcXFxjb2xvcmJveFwiOiB7XG4gICAgICAvLyA8bWVuY2xvc2U+IGRvZXNuJ3QgaGF2ZSBhIGdvb2Qgbm90YXRpb24gb3B0aW9uIGZvciBcXGNvbG9yYm94LlxuICAgICAgLy8gU28gdXNlIDxtcGFkZGVkPiBpbnN0ZWFkLiBTZXQgc29tZSBhdHRyaWJ1dGVzIHRoYXQgY29tZVxuICAgICAgLy8gaW5jbHVkZWQgd2l0aCA8bWVuY2xvc2U+LlxuICAgICAgLy9jb25zdCBmYm94c2VwID0gMzsgLy8gMyBwdCBmcm9tIExhVGVYIHNvdXJjZTJlXG4gICAgICAvL25vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGArJHsyICogZmJveHNlcH1wdGApXG4gICAgICAvL25vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBgJHtmYm94c2VwfXB0YClcbiAgICAgIGNvbnN0IHN0eWxlID0geyBwYWRkaW5nOiBcIjNwdCAwIDNwdCAwXCIgfTtcblxuICAgICAgaWYgKGdyb3VwLmxhYmVsID09PSBcIlxcXFxmY29sb3Jib3hcIikge1xuICAgICAgICBzdHlsZS5ib3JkZXIgPSBcIjAuMDY2N2VtIHNvbGlkIFwiICsgU3RyaW5nKGdyb3VwLmJvcmRlckNvbG9yKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3R5bGUgPSBzdHlsZTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhiYWNrZ3JvdW5kXCIsIGdyb3VwLmJhY2tncm91bmRDb2xvcik7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGNvbG9yYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInJhd1wiLCBcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0QXJnc1swXSAmJiBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgbGV0IGNvbG9yID0gXCJcIjtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IHNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBjb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIHNwZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZjb2xvcmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJyYXdcIiwgXCJyYXdcIiwgXCJ0ZXh0XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBtb2RlbCA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGxldCBib3JkZXJDb2xvciA9IFwiXCI7XG4gICAgbGV0IGJhY2tncm91bmRDb2xvcjtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IGJvcmRlclNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kU3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICAgIGJvcmRlckNvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgYm9yZGVyU3BlYyk7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBiYWNrZ3JvdW5kU3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvcmRlckNvbG9yID0gdmFsaWRhdGVDb2xvcihhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmcsIHBhcnNlci5ndWxsZXQubWFjcm9zKTtcbiAgICAgIGJhY2tncm91bmRDb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFja2dyb3VuZENvbG9yLFxuICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxmYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcImhib3hcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBcIlxcXFxmYm94XCIsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcYW5nbFwiLCBcIlxcXFxjYW5jZWxcIiwgXCJcXFxcYmNhbmNlbFwiLCBcIlxcXFx4Y2FuY2VsXCIsIFwiXFxcXHNvdXRcIiwgXCJcXFxcb3ZlcmxpbmVcIixcbiAgICBcIlxcXFxib3hlZFwiLCBcIlxcXFxsb25nZGl2XCIsIFwiXFxcXHBoYXNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkN1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcdW5kZXJsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXHRleHRjaXJjbGVkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl0sXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuLy8gRW52aXJvbm1lbnQgZGVsaW1pdGVycy4gSFRNTC9NYXRoTUwgcmVuZGVyaW5nIGlzIGRlZmluZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmdcbi8vIGRlZmluZUVudmlyb25tZW50IGRlZmluaXRpb25zLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcYmVnaW5cIiwgXCJcXFxcZW5kXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IG5hbWVHcm91cCA9IGFyZ3NbMF07XG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBlbnZpcm9ubWVudCBuYW1lXCIsIG5hbWVHcm91cCk7XG4gICAgfVxuICAgIGxldCBlbnZOYW1lID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVHcm91cC5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBlbnZOYW1lICs9IGFzc2VydE5vZGVUeXBlKG5hbWVHcm91cC5ib2R5W2ldLCBcInRleHRvcmRcIikudGV4dDtcbiAgICB9XG5cbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGJlZ2luXCIpIHtcbiAgICAgIC8vIGJlZ2luLi4uZW5kIGlzIHNpbWlsYXIgdG8gbGVmdC4uLnJpZ2h0XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbnZpcm9ubWVudHMsIGVudk5hbWUgKSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgbmFtZUdyb3VwKTtcbiAgICAgIH1cbiAgICAgIC8vIEJ1aWxkIHRoZSBlbnZpcm9ubWVudCBvYmplY3QuIEFyZ3VtZW50cyBhbmQgb3RoZXIgaW5mb3JtYXRpb24gd2lsbFxuICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuICAgICAgY29uc3QgZW52ID0gZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuICAgICAgY29uc3QgeyBhcmdzLCBvcHRBcmdzIH0gPSBwYXJzZXIucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgZW52TmFtZSxcbiAgICAgICAgcGFyc2VyXG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgICBwYXJzZXIuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmROYW1lVG9rZW4gPSBwYXJzZXIubmV4dFRva2VuO1xuICAgICAgY29uc3QgZW5kID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJlbnZpcm9ubWVudFwiKTtcbiAgICAgIGlmIChlbmQubmFtZSAhPT0gZW52TmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICBgTWlzbWF0Y2g6IFxcXFxiZWdpbnske2Vudk5hbWV9fSBtYXRjaGVkIGJ5IFxcXFxlbmR7JHtlbmQubmFtZX19YCxcbiAgICAgICAgICBlbmROYW1lVG9rZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW52aXJvbm1lbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmFtZTogZW52TmFtZSxcbiAgICAgIG5hbWVHcm91cFxuICAgIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW52VGFnXCIsXG4gIG5hbWVzOiBbXCJcXFxcZW52QHRhZ1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVudlRhZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm5vVGFnXCIsXG4gIG5hbWVzOiBbXCJcXFxcZW52QG5vdGFnXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibm9UYWdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICB9XG59KTtcblxuY29uc3QgaXNMb25nVmFyaWFibGVOYW1lID0gKGdyb3VwLCBmb250KSA9PiB7XG4gIGlmIChmb250ICE9PSBcIm1hdGhybVwiIHx8IGdyb3VwLmJvZHkudHlwZSAhPT0gXCJvcmRncm91cFwiIHx8IGdyb3VwLmJvZHkuYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoZ3JvdXAuYm9keS5ib2R5WzBdLnR5cGUgIT09IFwibWF0aG9yZFwiKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgZ3JvdXAuYm9keS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGFyc2VOb2RlVHlwZSA9IGdyb3VwLmJvZHkuYm9keVtpXS50eXBlO1xuICAgIGlmICghKHBhcnNlTm9kZVR5cGUgPT09ICBcIm1hdGhvcmRcIiB8fFxuICAgIChwYXJzZU5vZGVUeXBlID09PSAgXCJ0ZXh0b3JkXCIgJiYgIWlzTmFOKGdyb3VwLmJvZHkuYm9keVtpXS50ZXh0KSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkNiA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgY29uc3QgZm9udCA9IGdyb3VwLmZvbnQ7XG4gIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aEZvbnQoZm9udCk7XG4gIGNvbnN0IG1hdGhHcm91cCA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBuZXdTdHlsZSk7XG5cbiAgaWYgKG1hdGhHcm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHsgcmV0dXJuIG1hdGhHcm91cCB9IC8vIGVtcHR5IGdyb3VwLCBlLmcuLCBcXG1hdGhybXt9XG4gIGlmIChmb250ID09PSBcImJvbGRzeW1ib2xcIiAmJiBbXCJtb1wiLCBcIm1wYWRkZWRcIiwgXCJtcm93XCJdLmluY2x1ZGVzKG1hdGhHcm91cC50eXBlKSkge1xuICAgIG1hdGhHcm91cC5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgcmV0dXJuIG1hdGhHcm91cFxuICB9XG4gIC8vIENoZWNrIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGNvbnNvbGlkYXRlIGVsZW1lbnRzIGludG8gYSBzaW5nbGUgPG1pPiBlbGVtZW50LlxuICBpZiAoaXNMb25nVmFyaWFibGVOYW1lKGdyb3VwLCBmb250KSkge1xuICAgIC8vIFRoaXMgaXMgYSBcXG1hdGhybXvigKZ9IGdyb3VwLiBJdCBnZXRzIHNwZWNpYWwgdHJlYXRtZW50IGJlY2F1c2Ugc3ltYm9sc09yZC5qc1xuICAgIC8vIHdyYXBzIDxtaT4gZWxlbWVudHMgd2l0aCA8bXJvdz5zIHRvIHdvcmsgYXJvdW5kIGEgRmlyZWZveCBidWcuXG4gICAgY29uc3QgbWkgPSBtYXRoR3JvdXAuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF07XG4gICAgZGVsZXRlIG1pLmF0dHJpYnV0ZXMubWF0aHZhcmlhbnQ7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRoR3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1pLmNoaWxkcmVuWzBdLnRleHQgKz0gbWF0aEdyb3VwLmNoaWxkcmVuW2ldLnR5cGUgPT09IFwibW5cIlxuICAgICAgICA/IG1hdGhHcm91cC5jaGlsZHJlbltpXS5jaGlsZHJlblswXS50ZXh0XG4gICAgICAgIDogbWF0aEdyb3VwLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLnRleHQ7XG4gICAgfVxuICAgIC8vIFdyYXAgaW4gYSA8bXJvdz4gdG8gcHJldmVudCB0aGUgc2FtZSBGaXJlZm94IGJ1Zy5cbiAgICBjb25zdCBib2d1cyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDBiXCIpKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtib2d1cywgbWldKVxuICB9XG4gIGxldCBjYW5Db25zb2xpZGF0ZSA9IG1hdGhHcm91cC5jaGlsZHJlblswXS50eXBlID09PSBcIm1vXCI7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0aEdyb3VwLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1hdGhHcm91cC5jaGlsZHJlbltpXS50eXBlID09PSBcIm1vXCIgJiYgZm9udCA9PT0gXCJib2xkc3ltYm9sXCIpIHtcbiAgICAgIG1hdGhHcm91cC5jaGlsZHJlbltpXS5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGlmIChtYXRoR3JvdXAuY2hpbGRyZW5baV0udHlwZSAhPT0gXCJtaVwiKSB7IGNhbkNvbnNvbGlkYXRlID0gZmFsc2U7IH1cbiAgICBjb25zdCBsb2NhbFZhcmlhbnQgPSBtYXRoR3JvdXAuY2hpbGRyZW5baV0uYXR0cmlidXRlcyAmJlxuICAgICAgbWF0aEdyb3VwLmNoaWxkcmVuW2ldLmF0dHJpYnV0ZXMubWF0aHZhcmlhbnQgfHwgXCJcIjtcbiAgICBpZiAobG9jYWxWYXJpYW50ICE9PSBcIm5vcm1hbFwiKSB7IGNhbkNvbnNvbGlkYXRlID0gZmFsc2U7IH1cbiAgfVxuICBpZiAoIWNhbkNvbnNvbGlkYXRlKSB7IHJldHVybiBtYXRoR3JvdXAgfVxuICAvLyBDb25zb2xpZGF0ZSB0aGUgPG1pPiBlbGVtZW50cy5cbiAgY29uc3QgbWkgPSBtYXRoR3JvdXAuY2hpbGRyZW5bMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0aEdyb3VwLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbWkuY2hpbGRyZW4ucHVzaChtYXRoR3JvdXAuY2hpbGRyZW5baV0uY2hpbGRyZW5bMF0pO1xuICB9XG4gIGlmIChtaS5hdHRyaWJ1dGVzLm1hdGh2YXJpYW50ICYmIG1pLmF0dHJpYnV0ZXMubWF0aHZhcmlhbnQgPT09IFwibm9ybWFsXCIpIHtcbiAgICAvLyBXb3JrYXJvdW5kIGZvciBhIEZpcmVmb3ggYnVnIHRoYXQgcmVuZGVycyBzcHVyaW91cyBzcGFjZSBhcm91bmRcbiAgICAvLyBhIDxtaSBtYXRodmFyaWFudD1cIm5vcm1hbFwiPlxuICAgIC8vIFJlZjogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTA5N1xuICAgIC8vIFdlIGluc2VydCBhIHRleHQgbm9kZSB0aGF0IGNvbnRhaW5zIGEgemVyby13aWR0aCBzcGFjZSBhbmQgd3JhcCBpbiBhbiBtcm93LlxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgdGhpcyA8bWk+IHdvcmthcm91bmQgd2hlbiB0aGUgRmlyZWZveCBidWcgaXMgZml4ZWQuXG4gICAgY29uc3QgYm9ndXMgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAwYlwiKSk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbYm9ndXMsIG1pXSlcbiAgfVxuICByZXR1cm4gbWlcbn07XG5cbmNvbnN0IGZvbnRBbGlhc2VzID0ge1xuICBcIlxcXFxCYmJcIjogXCJcXFxcbWF0aGJiXCIsXG4gIFwiXFxcXGJvbGRcIjogXCJcXFxcbWF0aGJmXCIsXG4gIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIixcbiAgXCJcXFxcYm1cIjogXCJcXFxcYm9sZHN5bWJvbFwiXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZm9udFwiLFxuICBuYW1lczogW1xuICAgIC8vIHN0eWxlc1xuICAgIFwiXFxcXG1hdGhybVwiLFxuICAgIFwiXFxcXG1hdGhpdFwiLFxuICAgIFwiXFxcXG1hdGhiZlwiLFxuICAgIFwiXFxcXG1hdGhub3JtYWxcIixcbiAgICBcIlxcXFx1cEBncmVla1wiLFxuICAgIFwiXFxcXGJvbGRzeW1ib2xcIixcblxuICAgIC8vIGZhbWlsaWVzXG4gICAgXCJcXFxcbWF0aGJiXCIsXG4gICAgXCJcXFxcbWF0aGNhbFwiLFxuICAgIFwiXFxcXG1hdGhmcmFrXCIsXG4gICAgXCJcXFxcbWF0aHNjclwiLFxuICAgIFwiXFxcXG1hdGhzZlwiLFxuICAgIFwiXFxcXG1hdGhzZml0XCIsXG4gICAgXCJcXFxcbWF0aHR0XCIsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgXCJcXFxcQmJiXCIsXG4gICAgXCJcXFxcYm1cIixcbiAgICBcIlxcXFxib2xkXCIsXG4gICAgXCJcXFxcZnJha1wiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgbGV0IGZ1bmMgPSBmdW5jTmFtZTtcbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgZnVuYyA9IGZvbnRBbGlhc2VzW2Z1bmNdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZvbnQ6IGZ1bmMuc2xpY2UoMSksXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTtcblxuLy8gT2xkIGZvbnQgY2hhbmdpbmcgZnVuY3Rpb25zXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZm9udFwiLFxuICBuYW1lczogW1wiXFxcXHJtXCIsIFwiXFxcXHNmXCIsIFwiXFxcXHR0XCIsIFwiXFxcXGJmXCIsIFwiXFxcXGl0XCIsIFwiXFxcXGNhbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSwgYnJlYWtPblRva2VuVGV4dCB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgeyBtb2RlIH0gPSBwYXJzZXI7XG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCwgdHJ1ZSk7XG4gICAgY29uc3QgZm9udFN0eWxlID0gYG1hdGgke2Z1bmNOYW1lLnNsaWNlKDEpfWA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICBtb2RlOiBtb2RlLFxuICAgICAgZm9udDogZm9udFN0eWxlLFxuICAgICAgYm9keToge1xuICAgICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBib2R5XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2XG59KTtcblxuY29uc3Qgc3R5bEFycmF5ID0gW1wiZGlzcGxheVwiLCBcInRleHRcIiwgXCJzY3JpcHRcIiwgXCJzY3JpcHRzY3JpcHRcIl07XG5jb25zdCBzY3JpcHRMZXZlbCA9IHsgYXV0bzogLTEsIGRpc3BsYXk6IDAsIHRleHQ6IDAsIHNjcmlwdDogMSwgc2NyaXB0c2NyaXB0OiAyIH07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkNSA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgLy8gVHJhY2sgdGhlIHNjcmlwdExldmVsIG9mIHRoZSBudW1lcmF0b3IgYW5kIGRlbm9taW5hdG9yLlxuICAvLyBXZSBtYXkgbmVlZCB0aGF0IGluZm8gZm9yIFxcbWF0aGNob2ljZSBvciBmb3IgYWRqdXN0aW5nIGVtIGRpbWVuc2lvbnMuXG4gIGNvbnN0IGNoaWxkT3B0aW9ucyA9IGdyb3VwLnNjcmlwdExldmVsID09PSBcImF1dG9cIlxuICAgID8gc3R5bGUuaW5jcmVtZW50TGV2ZWwoKVxuICAgIDogZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwiZGlzcGxheVwiXG4gICAgPyBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5URVhUKVxuICAgIDogZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwidGV4dFwiXG4gICAgPyBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5TQ1JJUFQpXG4gICAgOiBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5TQ1JJUFRTQ1JJUFQpO1xuXG4gIC8vIENocm9taXVtICh3cm9uZ2x5KSBjb250aW51ZXMgdG8gc2hyaW5rIGZyYWN0aW9ucyBiZXlvbmQgc2NyaXB0c2NyaXB0bGV2ZWwuXG4gIC8vIFNvIHdlIGNoZWNrIGZvciBsZXZlbHMgdGhhdCBDaHJvbWl1bSBzaHJpbmtzIHRvbyBzbWFsbC5cbiAgLy8gSWYgbmVjZXNzYXJ5LCBzZXQgYW4gZXhwbGljaXQgZnJhY3Rpb24gZGVwdGguXG4gIGNvbnN0IG51bWVyID0gYnVpbGRHcm91cCQxKGdyb3VwLm51bWVyLCBjaGlsZE9wdGlvbnMpO1xuICBjb25zdCBkZW5vbSA9IGJ1aWxkR3JvdXAkMShncm91cC5kZW5vbSwgY2hpbGRPcHRpb25zKTtcbiAgaWYgKHN0eWxlLmxldmVsID09PSAzKSB7XG4gICAgbnVtZXIuc3R5bGUubWF0aERlcHRoID0gXCIyXCI7XG4gICAgbnVtZXIuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIyXCIpO1xuICAgIGRlbm9tLnN0eWxlLm1hdGhEZXB0aCA9IFwiMlwiO1xuICAgIGRlbm9tLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMlwiKTtcbiAgfVxuXG4gIGxldCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZnJhY1wiLCBbbnVtZXIsIGRlbm9tXSk7XG5cbiAgaWYgKCFncm91cC5oYXNCYXJMaW5lKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLmJhclNpemUpIHtcbiAgICBjb25zdCBydWxlV2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLmJhclNpemUsIHN0eWxlKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmV0aGlja25lc3NcIiwgcnVsZVdpZHRoLm51bWJlciArIHJ1bGVXaWR0aC51bml0KTtcbiAgfVxuXG4gIGlmIChncm91cC5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICBjb25zdCB3aXRoRGVsaW1zID0gW107XG5cbiAgICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGxlZnRPcCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW1xuICAgICAgICBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5sZWZ0RGVsaW0ucmVwbGFjZShcIlxcXFxcIiwgXCJcIikpXG4gICAgICBdKTtcbiAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gobGVmdE9wKTtcbiAgICB9XG5cbiAgICB3aXRoRGVsaW1zLnB1c2gobm9kZSk7XG5cbiAgICBpZiAoZ3JvdXAucmlnaHREZWxpbSAhPSBudWxsKSB7XG4gICAgICBjb25zdCByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbXG4gICAgICAgIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKGdyb3VwLnJpZ2h0RGVsaW0ucmVwbGFjZShcIlxcXFxcIiwgXCJcIikpXG4gICAgICBdKTtcbiAgICAgIHJpZ2h0T3Auc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgd2l0aERlbGltcy5wdXNoKHJpZ2h0T3ApO1xuICAgIH1cblxuICAgIG5vZGUgPSBtYWtlUm93KHdpdGhEZWxpbXMpO1xuICB9XG5cbiAgaWYgKGdyb3VwLnNjcmlwdExldmVsICE9PSBcImF1dG9cIikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbbm9kZV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFN0cmluZyhncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJkaXNwbGF5XCIpKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIHNjcmlwdExldmVsW2dyb3VwLnNjcmlwdExldmVsXSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcZGZyYWNcIixcbiAgICBcIlxcXFxmcmFjXCIsXG4gICAgXCJcXFxcdGZyYWNcIixcbiAgICBcIlxcXFxkYmlub21cIixcbiAgICBcIlxcXFxiaW5vbVwiLFxuICAgIFwiXFxcXHRiaW5vbVwiLFxuICAgIFwiXFxcXFxcXFxhdG9wZnJhY1wiLCAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgICBcIlxcXFxcXFxcYnJhY2VmcmFjXCIsXG4gICAgXCJcXFxcXFxcXGJyYWNrZnJhY1wiIC8vIGRpdHRvXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbMF07XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzFdO1xuICAgIGxldCBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgbGV0IGxlZnREZWxpbSA9IG51bGw7XG4gICAgbGV0IHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIGxldCBzY3JpcHRMZXZlbCA9IFwiYXV0b1wiO1xuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXHRmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcXFxcXGF0b3BmcmFjXCI6XG4gICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFxiaW5vbVwiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgbGVmdERlbGltID0gXCIoXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXFxcXFxicmFjZWZyYWNcIjpcbiAgICAgICAgbGVmdERlbGltID0gXCJcXFxce1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJcXFxcfVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcXFxcXGJyYWNrZnJhY1wiOlxuICAgICAgICBsZWZ0RGVsaW0gPSBcIltcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBnZW5mcmFjIGNvbW1hbmRcIik7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgICAgc2NyaXB0TGV2ZWwgPSBcImRpc3BsYXlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXHRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXHRiaW5vbVwiOlxuICAgICAgICBzY3JpcHRMZXZlbCA9IFwidGV4dFwiO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW0sXG4gICAgICBzY3JpcHRMZXZlbCxcbiAgICAgIGJhclNpemU6IG51bGxcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDVcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGNmcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGRlbm9tID0gYXJnc1sxXTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29udGludWVkOiB0cnVlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGhhc0JhckxpbmU6IHRydWUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2NyaXB0TGV2ZWw6IFwiZGlzcGxheVwiLFxuICAgICAgYmFyU2l6ZTogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBJbmZpeCBnZW5lcmFsaXplZCBmcmFjdGlvbnMgLS0gdGhlc2UgYXJlIG5vdCByZW5kZXJlZCBkaXJlY3RseSwgYnV0IHJlcGxhY2VkXG4vLyBpbW1lZGlhdGVseSBieSBvbmUgb2YgdGhlIHZhcmlhbnRzIGFib3ZlLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlclwiLCBcIlxcXFxjaG9vc2VcIiwgXCJcXFxcYXRvcFwiLCBcIlxcXFxicmFjZVwiLCBcIlxcXFxicmFja1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9KSB7XG4gICAgbGV0IHJlcGxhY2VXaXRoO1xuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcb3ZlclwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGNob29zZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxhdG9wXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGF0b3BmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxicmFjZVwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxicmFjZWZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGJyYWNrXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGJyYWNrZnJhY1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBpbmZpeCBnZW5mcmFjIGNvbW1hbmRcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoLFxuICAgICAgdG9rZW5cbiAgICB9O1xuICB9XG59KTtcblxuY29uc3QgZGVsaW1Gcm9tVmFsdWUgPSBmdW5jdGlvbihkZWxpbVN0cmluZykge1xuICBsZXQgZGVsaW0gPSBudWxsO1xuICBpZiAoZGVsaW1TdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIGRlbGltID0gZGVsaW1TdHJpbmc7XG4gICAgZGVsaW0gPSBkZWxpbSA9PT0gXCIuXCIgPyBudWxsIDogZGVsaW07XG4gIH1cbiAgcmV0dXJuIGRlbGltO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxnZW5mcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDYsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIiwgXCJtYXRoXCIsIFwic2l6ZVwiLCBcInRleHRcIiwgXCJtYXRoXCIsIFwibWF0aFwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbNF07XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzVdO1xuXG4gICAgLy8gTG9vayBpbnRvIHRoZSBwYXJzZSBub2RlcyB0byBnZXQgdGhlIGRlc2lyZWQgZGVsaW1pdGVycy5cbiAgICBjb25zdCBsZWZ0Tm9kZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgIGNvbnN0IGxlZnREZWxpbSA9IGxlZnROb2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIGxlZnROb2RlLmZhbWlseSA9PT0gXCJvcGVuXCJcbiAgICAgID8gZGVsaW1Gcm9tVmFsdWUobGVmdE5vZGUudGV4dClcbiAgICAgIDogbnVsbDtcbiAgICBjb25zdCByaWdodE5vZGUgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzFdKTtcbiAgICBjb25zdCByaWdodERlbGltID1cbiAgICAgIHJpZ2h0Tm9kZS50eXBlID09PSBcImF0b21cIiAmJiByaWdodE5vZGUuZmFtaWx5ID09PSBcImNsb3NlXCJcbiAgICAgICAgPyBkZWxpbUZyb21WYWx1ZShyaWdodE5vZGUudGV4dClcbiAgICAgICAgOiBudWxsO1xuXG4gICAgY29uc3QgYmFyTm9kZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMl0sIFwic2l6ZVwiKTtcbiAgICBsZXQgaGFzQmFyTGluZTtcbiAgICBsZXQgYmFyU2l6ZSA9IG51bGw7XG4gICAgaWYgKGJhck5vZGUuaXNCbGFuaykge1xuICAgICAgLy8gXFxnZW5mcmFjIGFjdHMgZGlmZmVyZW50bHkgdGhhbiBcXGFib3ZlLlxuICAgICAgLy8gXFxnZW5mcmFjIHRyZWF0cyBhbiBlbXB0eSBzaXplIGdyb3VwIGFzIGEgc2lnbmFsIHRvIHVzZSBhXG4gICAgICAvLyBzdGFuZGFyZCBiYXIgc2l6ZS4gXFxhYm92ZSB3b3VsZCBzZWUgc2l6ZSA9IDAgYW5kIG9taXQgdGhlIGJhci5cbiAgICAgIGhhc0JhckxpbmUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXJTaXplID0gYmFyTm9kZS52YWx1ZTtcbiAgICAgIGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgfVxuXG4gICAgLy8gRmluZCBvdXQgaWYgd2Ugd2FudCBkaXNwbGF5c3R5bGUsIHRleHRzdHlsZSwgZXRjLlxuICAgIGxldCBzY3JpcHRMZXZlbCA9IFwiYXV0b1wiO1xuICAgIGxldCBzdHlsID0gYXJnc1szXTtcbiAgICBpZiAoc3R5bC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgIGlmIChzdHlsLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0ZXh0T3JkID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bC5ib2R5WzBdLCBcInRleHRvcmRcIik7XG4gICAgICAgIHNjcmlwdExldmVsID0gc3R5bEFycmF5W051bWJlcih0ZXh0T3JkLnRleHQpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bCA9IGFzc2VydE5vZGVUeXBlKHN0eWwsIFwidGV4dG9yZFwiKTtcbiAgICAgIHNjcmlwdExldmVsID0gc3R5bEFycmF5W051bWJlcihzdHlsLnRleHQpXTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW0sXG4gICAgICByaWdodERlbGltLFxuICAgICAgc2NyaXB0TGV2ZWxcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDVcbn0pO1xuXG4vLyBcXGFib3ZlIGlzIGFuIGluZml4IGZyYWN0aW9uIHRoYXQgYWxzbyBkZWZpbmVzIGEgZnJhY3Rpb24gYmFyIHNpemUuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5maXhcIixcbiAgbmFtZXM6IFtcIlxcXFxhYm92ZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIGluZml4OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW5maXhcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgcmVwbGFjZVdpdGg6IFwiXFxcXFxcXFxhYm92ZWZyYWNcIixcbiAgICAgIGJhclNpemU6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKS52YWx1ZSxcbiAgICAgIHRva2VuXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXGFib3ZlZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCIsIFwic2l6ZVwiLCBcIm1hdGhcIl1cbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGJhclNpemUgPSBhc3NlcnQoYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJpbmZpeFwiKS5iYXJTaXplKTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbMl07XG5cbiAgICBjb25zdCBoYXNCYXJMaW5lID0gYmFyU2l6ZS5udW1iZXIgPiAwO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgYmFyU2l6ZSxcbiAgICAgIGxlZnREZWxpbTogbnVsbCxcbiAgICAgIHJpZ2h0RGVsaW06IG51bGwsXG4gICAgICBzY3JpcHRMZXZlbDogXCJhdXRvXCJcbiAgICB9O1xuICB9LFxuXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7XG5cbi8vIFxcaGJveCBpcyBwcm92aWRlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIExhVGVYIGZ1bmN0aW9ucyB0aGF0IGFjdCBvbiBhIGJveC5cbi8vIFRoaXMgZnVuY3Rpb24gYnkgaXRzZWxmIGRvZXNuJ3QgZG8gYW55dGhpbmcgYnV0IHNldCBzY3JpcHRsZXZlbCB0byBcXHRleHRzdHlsZVxuLy8gYW5kIHByZXZlbnQgYSBzb2Z0IGxpbmUgYnJlYWsuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJoYm94XCIsXG4gIG5hbWVzOiBbXCJcXFxcaGJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhib3hcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1swXSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aExldmVsKFN0eWxlTGV2ZWwuVEVYVCk7XG4gICAgY29uc3QgbXJvdyA9IGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBuZXdTdHlsZSk7XG4gICAgcmV0dXJuIGNvbnNvbGlkYXRlVGV4dChtcm93KVxuICB9XG59KTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ0ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBjb25zdCBhY2NlbnROb2RlID0gc3RyZXRjaHkubWF0aE1Mbm9kZShncm91cC5sYWJlbCk7XG4gIGFjY2VudE5vZGUuc3R5bGVbXCJtYXRoLWRlcHRoXCJdID0gMDtcbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKGdyb3VwLmlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCIsIFtcbiAgICBidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgc3R5bGUpLFxuICAgIGFjY2VudE5vZGVcbiAgXSk7XG59O1xuXG4vLyBIb3Jpem9udGFsIHN0cmV0Y2h5IGJyYWNlc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgbmFtZXM6IFtcIlxcXFxvdmVyYnJhY2VcIiwgXCJcXFxcdW5kZXJicmFjZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJob3JpekJyYWNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGlzT3ZlcjogL15cXFxcb3Zlci8udGVzdChmdW5jTmFtZSksXG4gICAgICBiYXNlOiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ0XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFxocmVmXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInVybFwiLCBcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCB0b2tlbiB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgY29uc3QgaHJlZiA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmIChcbiAgICAgICFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgICAgY29tbWFuZDogXCJcXFxcaHJlZlwiLFxuICAgICAgICB1cmw6IGhyZWZcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCJcXFxcaHJlZlwiIGlzIG5vdCB0cnVzdGVkYCwgdG9rZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgbWF0aCA9IG5ldyBNYXRoTm9kZShcIm1hdGhcIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBzdHlsZSldKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gbmV3IEFuY2hvck5vZGUoZ3JvdXAuaHJlZiwgW10sIFttYXRoXSk7XG4gICAgcmV0dXJuIGFuY2hvck5vZGVcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxcdXJsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInVybFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgdG9rZW4gfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoXG4gICAgICAhcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICAgIGNvbW1hbmQ6IFwiXFxcXHVybFwiLFxuICAgICAgICB1cmw6IGhyZWZcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCJcXFxcdXJsXCIgaXMgbm90IHRydXN0ZWRgLCB0b2tlbilcbiAgICB9XG5cbiAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGMgPSBocmVmW2ldO1xuICAgICAgaWYgKGMgPT09IFwiflwiKSB7XG4gICAgICAgIGMgPSBcIlxcXFx0ZXh0YXNjaWl0aWxkZVwiO1xuICAgICAgfVxuICAgICAgY2hhcnMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgdGV4dDogY1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZm9udDogXCJcXFxcdGV4dHR0XCIsXG4gICAgICBib2R5OiBjaGFyc1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBocmVmLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImh0bWxcIixcbiAgbmFtZXM6IFtcIlxcXFxjbGFzc1wiLCBcIlxcXFxpZFwiLCBcIlxcXFxzdHlsZVwiLCBcIlxcXFxkYXRhXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuXG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBGdW5jdGlvbiBcIiR7ZnVuY05hbWV9XCIgaXMgZGlzYWJsZWQgaW4gc3RyaWN0IG1vZGVgLCB0b2tlbilcbiAgICB9XG5cbiAgICBsZXQgdHJ1c3RDb250ZXh0O1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcY2xhc3NcIjpcbiAgICAgICAgYXR0cmlidXRlcy5jbGFzcyA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcY2xhc3NcIixcbiAgICAgICAgICBjbGFzczogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGlkXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuaWQgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGlkXCIsXG4gICAgICAgICAgaWQ6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxzdHlsZVwiOlxuICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxzdHlsZVwiLFxuICAgICAgICAgIHN0eWxlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcZGF0YVwiOiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleVZhbCA9IGRhdGFbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgIGlmIChrZXlWYWwubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkVycm9yIHBhcnNpbmcga2V5LXZhbHVlIGZvciBcXFxcZGF0YVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0cmlidXRlc1tcImRhdGEtXCIgKyBrZXlWYWxbMF0udHJpbSgpXSA9IGtleVZhbFsxXS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcZGF0YVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaHRtbCBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh0cnVzdENvbnRleHQpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCIke2Z1bmNOYW1lfVwiIGlzIG5vdCB0cnVzdGVkYCwgdG9rZW4pXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImh0bWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAgYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIHN0eWxlKTtcblxuICAgIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgICBpZiAoZ3JvdXAuYXR0cmlidXRlcy5jbGFzcykge1xuICAgICAgY2xhc3Nlcy5wdXNoKC4uLmdyb3VwLmF0dHJpYnV0ZXMuY2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLykpO1xuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzZXMgPSBjbGFzc2VzO1xuXG4gICAgZm9yIChjb25zdCBhdHRyIGluIGdyb3VwLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChhdHRyICE9PSBcImNsYXNzXCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGdyb3VwLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIGdyb3VwLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59KTtcblxuY29uc3Qgc2l6ZURhdGEgPSBmdW5jdGlvbihzdHIpIHtcbiAgaWYgKC9eWy0rXT8gKihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKSQvLnRlc3Qoc3RyKSkge1xuICAgIC8vIHN0ciBpcyBhIG51bWJlciB3aXRoIG5vIHVuaXQgc3BlY2lmaWVkLlxuICAgIC8vIGRlZmF1bHQgdW5pdCBpcyBicCwgcGVyIGdyYXBoaXggcGFja2FnZS5cbiAgICByZXR1cm4geyBudW1iZXI6ICtzdHIsIHVuaXQ6IFwiYnBcIiB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2ggPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgc2l6ZTogJ1wiICsgc3RyICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3NcIik7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyXG4gICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG4gICAgaWYgKCF2YWxpZFVuaXQoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljcy5cIik7XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmNsdWRlZ3JhcGhpY3NcIixcbiAgbmFtZXM6IFtcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInVybFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIHRva2VuIH0sIGFyZ3MsIG9wdEFyZ3MpID0+IHtcbiAgICBsZXQgd2lkdGggPSB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH07XG4gICAgbGV0IGhlaWdodCA9IHsgbnVtYmVyOiAwLjksIHVuaXQ6IFwiZW1cIiB9OyAgLy8gc29ydGEgY2hhcmFjdGVyIHNpemVkLlxuICAgIGxldCB0b3RhbGhlaWdodCA9IHsgbnVtYmVyOiAwLCB1bml0OiBcImVtXCIgfTtcbiAgICBsZXQgYWx0ID0gXCJcIjtcblxuICAgIGlmIChvcHRBcmdzWzBdKSB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVTdHIgPSBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG5cbiAgICAgIC8vIFBhcnNlci5qcyBkb2VzIG5vdCBwYXJzZSBrZXkvdmFsdWUgcGFpcnMuIFdlIGdldCBhIHN0cmluZy5cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVTdHIuc3BsaXQoXCIsXCIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleVZhbCA9IGF0dHJpYnV0ZXNbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGNvbnN0IHN0ciA9IGtleVZhbFsxXS50cmltKCk7XG4gICAgICAgICAgc3dpdGNoIChrZXlWYWxbMF0udHJpbSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWx0XCI6XG4gICAgICAgICAgICAgIGFsdCA9IHN0cjtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgICAgICAgICB3aWR0aCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICAgICAgICAgIGhlaWdodCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFwidG90YWxoZWlnaHRcIjpcbiAgICAgICAgICAgICAgdG90YWxoZWlnaHQgPSBzaXplRGF0YShzdHIpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGtleTogJ1wiICsga2V5VmFsWzBdICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3MuXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3JjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKGFsdCA9PT0gXCJcIikge1xuICAgICAgLy8gTm8gYWx0IGdpdmVuLiBVc2UgdGhlIGZpbGUgbmFtZS4gU3RyaXAgYXdheSB0aGUgcGF0aC5cbiAgICAgIGFsdCA9IHNyYztcbiAgICAgIGFsdCA9IGFsdC5yZXBsYWNlKC9eLipbXFxcXC9dLywgXCJcIik7XG4gICAgICBhbHQgPSBhbHQuc3Vic3RyaW5nKDAsIGFsdC5sYXN0SW5kZXhPZihcIi5cIikpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgICAgY29tbWFuZDogXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIsXG4gICAgICAgIHVybDogc3JjXG4gICAgICB9KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEZ1bmN0aW9uIFwiXFxcXGluY2x1ZGVncmFwaGljc1wiIGlzIG5vdCB0cnVzdGVkYCwgdG9rZW4pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW5jbHVkZWdyYXBoaWNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGFsdDogYWx0LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB0b3RhbGhlaWdodDogdG90YWxoZWlnaHQsXG4gICAgICBzcmM6IHNyY1xuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBzdHlsZSk7XG4gICAgY29uc3QgZGVwdGggPSB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH07XG5cbiAgICBpZiAoZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyID4gMCkge1xuICAgICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0LnVuaXQgPT09IGhlaWdodC51bml0ICYmXG4gICAgICAgIGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IGhlaWdodC5udW1iZXIpIHtcbiAgICAgICAgZGVwdGgubnVtYmVyID0gZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyIC0gaGVpZ2h0Lm51bWJlcjtcbiAgICAgICAgZGVwdGgudW5pdCA9IGhlaWdodC51bml0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB3aWR0aCA9IDA7XG4gICAgaWYgKGdyb3VwLndpZHRoLm51bWJlciA+IDApIHtcbiAgICAgIHdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgc3R5bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGdyYXBoaWNTdHlsZSA9IHsgaGVpZ2h0OiBoZWlnaHQubnVtYmVyICsgZGVwdGgubnVtYmVyICsgXCJlbVwiIH07XG4gICAgaWYgKHdpZHRoLm51bWJlciA+IDApIHtcbiAgICAgIGdyYXBoaWNTdHlsZS53aWR0aCA9IHdpZHRoLm51bWJlciArIHdpZHRoLnVuaXQ7XG4gICAgfVxuICAgIGlmIChkZXB0aC5udW1iZXIgPiAwKSB7XG4gICAgICBncmFwaGljU3R5bGUudmVydGljYWxBbGlnbiA9IC1kZXB0aC5udW1iZXIgKyBkZXB0aC51bml0O1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBuZXcgSW1nKGdyb3VwLnNyYywgZ3JvdXAuYWx0LCBncmFwaGljU3R5bGUpO1xuICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIG5vZGUuZGVwdGggPSBkZXB0aDtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbbm9kZV0pXG4gIH1cbn0pO1xuXG4vLyBIb3Jpem9udGFsIHNwYWNpbmcgY29tbWFuZHNcblxuXG4vLyBUT0RPOiBcXGhza2lwIGFuZCBcXG1za2lwIHNob3VsZCBzdXBwb3J0IHBsdXMgYW5kIG1pbnVzIGluIGxlbmd0aHNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImtlcm5cIixcbiAgbmFtZXM6IFtcIlxcXFxrZXJuXCIsIFwiXFxcXG1rZXJuXCIsIFwiXFxcXGhza2lwXCIsIFwiXFxcXG1za2lwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIl0sXG4gICAgcHJpbWl0aXZlOiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBzaXplID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpO1xuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICBjb25zdCBtYXRoRnVuY3Rpb24gPSBmdW5jTmFtZVsxXSA9PT0gXCJtXCI7IC8vIFxcbWtlcm4sIFxcbXNraXBcbiAgICAgIGNvbnN0IG11VW5pdCA9IHNpemUudmFsdWUudW5pdCA9PT0gXCJtdVwiO1xuICAgICAgaWYgKG1hdGhGdW5jdGlvbikge1xuICAgICAgICBpZiAoIW11VW5pdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBMYVRlWCdzICR7ZnVuY05hbWV9IHN1cHBvcnRzIG9ubHkgbXUgdW5pdHMsIGAgK1xuICAgICAgICAgICAgYG5vdCAke3NpemUudmFsdWUudW5pdH0gdW5pdHNgLCB0b2tlbilcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VyLm1vZGUgIT09IFwibWF0aFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYExhVGVYJ3MgJHtmdW5jTmFtZX0gd29ya3Mgb25seSBpbiBtYXRoIG1vZGVgLCB0b2tlbilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIW1hdGhGdW5jdGlvblxuICAgICAgICBpZiAobXVVbml0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYExhVGVYJ3MgJHtmdW5jTmFtZX0gZG9lc24ndCBzdXBwb3J0IG11IHVuaXRzYCwgdG9rZW4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaW1lbnNpb246IHNpemUudmFsdWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZGltZW5zaW9uLCBzdHlsZSk7XG4gICAgY29uc3QgY2ggPSBkaW1lbnNpb24udW5pdCA9PT0gXCJlbVwiID8gc3BhY2VDaGFyYWN0ZXIoZGltZW5zaW9uLm51bWJlcikgOiBcIlwiO1xuICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIiAmJiBjaC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShjaCk7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbY2hhcmFjdGVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgZGltZW5zaW9uLm51bWJlciArIGRpbWVuc2lvbi51bml0KTtcbiAgICAgIGlmIChkaW1lbnNpb24ubnVtYmVyIDwgMCkge1xuICAgICAgICBub2RlLnN0eWxlLm1hcmdpbkxlZnQgPSBkaW1lbnNpb24ubnVtYmVyICsgZGltZW5zaW9uLnVuaXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cbn0pO1xuXG5jb25zdCBzcGFjZUNoYXJhY3RlciA9IGZ1bmN0aW9uKHdpZHRoKSB7XG4gIGlmICh3aWR0aCA+PSAwLjA1NTU1ICYmIHdpZHRoIDw9IDAuMDU1NTYpIHtcbiAgICByZXR1cm4gXCJcXHUyMDBhXCI7IC8vICZWZXJ5VGhpblNwYWNlO1xuICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMTY2NiAmJiB3aWR0aCA8PSAwLjE2NjcpIHtcbiAgICByZXR1cm4gXCJcXHUyMDA5XCI7IC8vICZUaGluU3BhY2U7XG4gIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yMjIyICYmIHdpZHRoIDw9IDAuMjIyMykge1xuICAgIHJldHVybiBcIlxcdTIwMDVcIjsgLy8gJk1lZGl1bVNwYWNlO1xuICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMjc3NyAmJiB3aWR0aCA8PSAwLjI3NzgpIHtcbiAgICByZXR1cm4gXCJcXHUyMDA1XFx1MjAwYVwiOyAvLyAmVGhpY2tTcGFjZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxufTtcblxuLy8gTGltaXQgdmFsaWQgY2hhcmFjdGVycyB0byBhIHNtYWxsIHNldCwgZm9yIHNhZmV0eS5cbmNvbnN0IGludmFsaWRJZFJlZ0V4ID0gL1teQS1aYS16XzAtOS1dL2c7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsYWJlbFwiLFxuICBuYW1lczogW1wiXFxcXGxhYmVsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsYWJlbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzdHJpbmc6IGFyZ3NbMF0uc3RyaW5nLnJlcGxhY2UoaW52YWxpZElkUmVnRXgsIFwiXCIpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBSZXR1cm4gYSBuby13aWR0aCwgbm8taW5rIGVsZW1lbnQgd2l0aCBhbiBIVE1MIGlkLlxuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInRtbC1sYWJlbFwiXSk7XG4gICAgaWYgKGdyb3VwLnN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlLnNldExhYmVsKGdyb3VwLnN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG4vLyBIb3Jpem9udGFsIG92ZXJsYXAgZnVuY3Rpb25zXG5cbmNvbnN0IHRleHRNb2RlTGFwID0gW1wiXFxcXGNsYXBcIiwgXCJcXFxcbGxhcFwiLCBcIlxcXFxybGFwXCJdO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGFwXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGxsYXBcIiwgXCJcXFxcbWF0aHJsYXBcIiwgXCJcXFxcbWF0aGNsYXBcIiwgXCJcXFxcY2xhcFwiLCBcIlxcXFxsbGFwXCIsIFwiXFxcXHJsYXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpID0+IHtcbiAgICBpZiAodGV4dE1vZGVMYXAuaW5jbHVkZXMoZnVuY05hbWUpKSB7XG4gICAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCAmJiBwYXJzZXIubW9kZSAhPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYHske2Z1bmNOYW1lfX0gY2FuIGJlIHVzZWQgb25seSBpbiB0ZXh0IG1vZGUuXG4gVHJ5IFxcXFxtYXRoJHtmdW5jTmFtZS5zbGljZSgxKX1gLCB0b2tlbilcbiAgICAgIH1cbiAgICAgIGZ1bmNOYW1lID0gZnVuY05hbWUuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bmNOYW1lID0gZnVuY05hbWUuc2xpY2UoNSk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxhcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbGlnbm1lbnQ6IGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIC8vIG1hdGhsbGFwLCBtYXRocmxhcCwgbWF0aGNsYXBcbiAgICBsZXQgc3RydXQ7XG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJsbGFwXCIpIHtcbiAgICAgIC8vIFdlIG5lZWQgYW4gaW52aXNpYmxlIHN0cnV0IHdpdGggdGhlIHNhbWUgZGVwdGggYXMgdGhlIGdyb3VwLlxuICAgICAgLy8gV2UgY2FuJ3QganVzdCByZWFkIHRoZSBkZXB0aCwgc28gd2UgdXNlIFxcdnBoYW50b20gbWV0aG9kcy5cbiAgICAgIGNvbnN0IHBoYW50b21Jbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgc3R5bGUpO1xuICAgICAgY29uc3QgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgcGhhbnRvbUlubmVyKTtcbiAgICAgIHN0cnV0ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgICBzdHJ1dC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSk7XG4gICAgbGV0IG5vZGU7XG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJsbGFwXCIpIHtcbiAgICAgIGlubmVyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgaW5uZXIuc3R5bGUucmlnaHQgPSBcIjBcIjtcbiAgICAgIGlubmVyLnN0eWxlLmJvdHRvbSA9IGAwYDsgLy8gSWYgd2UgY291bGQgaGF2ZSByZWFkIHRoZSBpbmsgZGVwdGgsIGl0IHdvdWxkIGdvIGhlcmUuXG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtzdHJ1dCwgaW5uZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbaW5uZXJdKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ID09PSBcInJsYXBcIikge1xuICAgICAgaWYgKGdyb3VwLmJvZHkuYm9keS5sZW5ndGggPiAwICYmIGdyb3VwLmJvZHkuYm9keVswXS50eXBlID09PSBcImdlbmZyYWNcIikge1xuICAgICAgICAvLyBJbiBGaXJlZm94LCBhIDxtcGFkZGVkPiBzcXVhc2hlcyB0aGUgMy8xOGVtIHBhZGRpbmcgb2YgYSBjaGlsZCBcXGZyYWMuIFB1dCBpdCBiYWNrLlxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMTY2NjdlbVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gZ3JvdXAuYWxpZ25tZW50ID09PSBcImxsYXBcIiA/IFwiLTFcIiA6IFwiLTAuNVwiO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgb2Zmc2V0ICsgXCJ3aWR0aFwiKTtcbiAgICAgIGlmIChncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgICAgbm9kZS5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IFwiY2VudGVyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbi8vIFN3aXRjaGluZyBmcm9tIHRleHQgbW9kZSBiYWNrIHRvIG1hdGggbW9kZVxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gIG5hbWVzOiBbXCJcXFxcKFwiLCBcIiRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIoeyBmdW5jTmFtZSwgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBvdXRlck1vZGUgPSBwYXJzZXIubW9kZTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShcIm1hdGhcIik7XG4gICAgY29uc3QgY2xvc2UgPSBmdW5jTmFtZSA9PT0gXCJcXFxcKFwiID8gXCJcXFxcKVwiIDogXCIkXCI7XG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGNsb3NlKTtcbiAgICBwYXJzZXIuZXhwZWN0KGNsb3NlKTtcbiAgICBwYXJzZXIuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gQ2hlY2sgZm9yIGV4dHJhIGNsb3NpbmcgbWF0aCBkZWxpbWl0ZXJzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLCAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgaXMuXG4gIG5hbWVzOiBbXCJcXFxcKVwiLCBcIlxcXFxdXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIHRva2VuKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYE1pc21hdGNoZWQgJHtjb250ZXh0LmZ1bmNOYW1lfWAsIHRva2VuKTtcbiAgfVxufSk7XG5cbmNvbnN0IGNob29zZVN0eWxlID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBzd2l0Y2ggKHN0eWxlLmxldmVsKSB7XG4gICAgY2FzZSBTdHlsZUxldmVsLkRJU1BMQVk6ICAgICAgIC8vIDBcbiAgICAgIHJldHVybiBncm91cC5kaXNwbGF5O1xuICAgIGNhc2UgU3R5bGVMZXZlbC5URVhUOiAgICAgICAgICAvLyAxXG4gICAgICByZXR1cm4gZ3JvdXAudGV4dDtcbiAgICBjYXNlIFN0eWxlTGV2ZWwuU0NSSVBUOiAgICAgICAgLy8gMlxuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdDtcbiAgICBjYXNlIFN0eWxlTGV2ZWwuU0NSSVBUU0NSSVBUOiAgLy8gM1xuICAgICAgcmV0dXJuIGdyb3VwLnNjcmlwdHNjcmlwdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7XG4gIH1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtYXRoY2hvaWNlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aGNob2ljZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA0LFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1hdGhjaG9pY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZGlzcGxheTogb3JkYXJndW1lbnQoYXJnc1swXSksXG4gICAgICB0ZXh0OiBvcmRhcmd1bWVudChhcmdzWzFdKSxcbiAgICAgIHNjcmlwdDogb3JkYXJndW1lbnQoYXJnc1syXSksXG4gICAgICBzY3JpcHRzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbM10pXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBjaG9vc2VTdHlsZShncm91cCwgc3R5bGUpO1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coYm9keSwgc3R5bGUpO1xuICB9XG59KTtcblxuY29uc3QgdGV4dEF0b21UeXBlcyA9IFtcInRleHRcIiwgXCJ0ZXh0b3JkXCIsIFwibWF0aG9yZFwiLCBcImF0b21cIl07XG5cbmZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIkMyhncm91cCwgc3R5bGUpIHtcbiAgbGV0IG5vZGU7XG4gIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlKTtcblxuICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1pbm5lclwiKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBpbm5lcik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcmRcIikge1xuICAgIGlmIChncm91cC5pc0NoYXJhY3RlckJveCB8fCBpbm5lclswXS50eXBlID09PSBcIm1hdGhvcmRcIikge1xuICAgICAgbm9kZSA9IGlubmVyWzBdO1xuICAgICAgbm9kZS50eXBlID0gXCJtaVwiO1xuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuY2hpbGRyZW5bMF0udGV4dCAmJiBub2RlLmNoaWxkcmVuWzBdLnRleHQgPT09IFwi4oiHXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm5vcm1hbFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgaW5uZXIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcbiAgICBpZiAoZ3JvdXAubXVzdFByb21vdGUpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibW9cIjtcbiAgICAgIGlmIChncm91cC5pc0NoYXJhY3RlckJveCAmJiBncm91cC5ib2R5WzBdLnRleHQgJiYgL1tBLVphLXpdLy50ZXN0KGdyb3VwLmJvZHlbMF0udGV4dCkpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIml0YWxpY1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBpbm5lcik7XG4gICAgfVxuXG4gICAgLy8gU2V0IHNwYWNpbmcgYmFzZWQgb24gd2hhdCBpcyB0aGUgbW9zdCBsaWtlbHkgYWRqYWNlbnQgYXRvbSB0eXBlLlxuICAgIC8vIFNlZSBUZVhib29rIHAxNzAuXG4gICAgY29uc3QgZG9TcGFjaW5nID0gc3R5bGUubGV2ZWwgPCAyOyAvLyBPcGVyYXRvciBzcGFjaW5nIGlzIHplcm8gaW5zaWRlIGEgKHN1YnxzdXBlcilzY3JpcHQuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJtcm93XCIpIHtcbiAgICAgIGlmIChkb1NwYWNpbmcgKSB7XG4gICAgICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibWJpblwiKSB7XG4gICAgICAgICAgLy8gbWVkaXVtIHNwYWNlXG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi51bnNoaWZ0KHBhZGRpbmckMSgwLjIyMjIpKTtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gocGFkZGluZyQxKDAuMjIyMikpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtcmVsXCIpIHtcbiAgICAgICAgICAvLyB0aGlja3NwYWNlXG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi51bnNoaWZ0KHBhZGRpbmckMSgwLjI3NzgpKTtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gocGFkZGluZyQxKDAuMjc3OCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtcHVuY3RcIikge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChwYWRkaW5nJDEoMC4xNjY3KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1pbm5lclwiKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi51bnNoaWZ0KHBhZGRpbmckMSgwLjA1NTYpKTsgIC8vIDEgbXUgaXMgdGhlIG1vc3QgbGlrZWx5IG9wdGlvblxuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChwYWRkaW5nJDEoMC4wNTU2KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtYmluXCIpIHtcbiAgICAgICAgLy8gbWVkaXVtIHNwYWNlXG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSAoZG9TcGFjaW5nID8gXCIwLjIyMjJlbVwiIDogXCIwXCIpO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4yMjIyZW1cIiA6IFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1yZWxcIikge1xuICAgICAgICAvLyB0aGlja3NwYWNlXG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSAoZG9TcGFjaW5nID8gXCIwLjI3NzhlbVwiIDogXCIwXCIpO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4yNzc4ZW1cIiA6IFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1wdW5jdFwiKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4xNjY3ZW1cIiA6IFwiMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcGVuXCIgfHwgZ3JvdXAubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1pbm5lclwiICYmIGRvU3BhY2luZykge1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjA1NTZlbVwiOyAvLyAxIG11IGlzIHRoZSBtb3N0IGxpa2VseSBvcHRpb25cbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLndpZHRoID0gXCIrMC4xMTExZW1cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShncm91cC5tY2xhc3MgPT09IFwibW9wZW5cIiB8fCBncm91cC5tY2xhc3MgPT09IFwibWNsb3NlXCIpKSB7XG4gICAgICBkZWxldGUgbm9kZS5hdHRyaWJ1dGVzLnN0cmV0Y2h5O1xuICAgICAgZGVsZXRlIG5vZGUuYXR0cmlidXRlcy5mb3JtO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxtYXRob3JkXCIsXG4gICAgXCJcXFxcbWF0aGJpblwiLFxuICAgIFwiXFxcXG1hdGhyZWxcIixcbiAgICBcIlxcXFxtYXRob3BlblwiLFxuICAgIFwiXFxcXG1hdGhjbG9zZVwiLFxuICAgIFwiXFxcXG1hdGhwdW5jdFwiLFxuICAgIFwiXFxcXG1hdGhpbm5lclwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGlzQ2hhcmFjdGVyQm94ID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYm9keSk7XG4gICAgLy8gV2Ugc2hvdWxkIG5vdCB3cmFwIGEgPG1vPiBhcm91bmQgYSA8bWk+IG9yIDxtb3JkPi4gVGhhdCB3b3VsZCBiZSBpbnZhbGlkIE1hdGhNTC5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIGluc3RlYWQgcHJvbW90ZSB0aGUgdGV4dCBjb250ZW50cyBvZiB0aGUgYm9keSB0byB0aGUgcGFyZW50LlxuICAgIGxldCBtdXN0UHJvbW90ZSA9IHRydWU7XG4gICAgY29uc3QgbW9yZCA9IHsgdHlwZTogXCJtYXRob3JkXCIsIHRleHQ6IFwiXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG4gICAgY29uc3QgYXJyID0gKGJvZHkuYm9keSkgPyBib2R5LmJvZHkgOiBbYm9keV07XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJyKSB7XG4gICAgICBpZiAodGV4dEF0b21UeXBlcy5pbmNsdWRlcyhhcmcudHlwZSkpIHtcbiAgICAgICAgaWYgKHN5bWJvbHNbcGFyc2VyLm1vZGVdW2FyZy50ZXh0XSkge1xuICAgICAgICAgIG1vcmQudGV4dCArPSBzeW1ib2xzW3BhcnNlci5tb2RlXVthcmcudGV4dF0ucmVwbGFjZTtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcudGV4dCkge1xuICAgICAgICAgIG1vcmQudGV4dCArPSBhcmcudGV4dDtcbiAgICAgICAgfSBlbHNlIGlmIChhcmcuYm9keSkge1xuICAgICAgICAgIGFyZy5ib2R5Lm1hcChlID0+IHsgbW9yZC50ZXh0ICs9IGUudGV4dDsgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG11c3RQcm9tb3RlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtdXN0UHJvbW90ZSAmJiBmdW5jTmFtZSA9PT0gXCJcXFxcbWF0aG9yZFwiICYmIG1vcmQudHlwZSA9PT0gXCJtYXRob3JkXCJcbiAgICAgICAgICAgICAgICAgICAgJiYgbW9yZC50ZXh0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBtb3JkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBtY2xhc3M6IFwibVwiICsgZnVuY05hbWUuc2xpY2UoNSksXG4gICAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KG11c3RQcm9tb3RlID8gbW9yZCA6IGJvZHkpLFxuICAgICAgICBpc0NoYXJhY3RlckJveCxcbiAgICAgICAgbXVzdFByb21vdGVcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDNcbn0pO1xuXG5jb25zdCBiaW5yZWxDbGFzcyA9IChhcmcpID0+IHtcbiAgLy8gXFxiaW5yZWxAIHNwYWNpbmcgdmFyaWVzIHdpdGggKGJpbnxyZWx8b3JkKSBvZiB0aGUgYXRvbSBpbiB0aGUgYXJndW1lbnQuXG4gIC8vIChieSByZW5kZXJpbmcgc2VwYXJhdGVseSBhbmQgd2l0aCB7fXMgYmVmb3JlIGFuZCBhZnRlciwgYW5kIG1lYXN1cmluZ1xuICAvLyB0aGUgY2hhbmdlIGluIHNwYWNpbmcpLiAgV2UnbGwgZG8gcm91Z2hseSB0aGUgc2FtZSBieSBkZXRlY3RpbmcgdGhlXG4gIC8vIGF0b20gdHlwZSBkaXJlY3RseS5cbiAgY29uc3QgYXRvbSA9IGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgJiYgYXJnLmJvZHkubGVuZ3RoID8gYXJnLmJvZHlbMF0gOiBhcmc7XG4gIGlmIChhdG9tLnR5cGUgPT09IFwiYXRvbVwiICYmIChhdG9tLmZhbWlseSA9PT0gXCJiaW5cIiB8fCBhdG9tLmZhbWlseSA9PT0gXCJyZWxcIikpIHtcbiAgICByZXR1cm4gXCJtXCIgKyBhdG9tLmZhbWlseTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJtb3JkXCI7XG4gIH1cbn07XG5cbi8vIFxcQGJpbnJlbHt4fXt5fSByZW5kZXJzIGxpa2UgeSBidXQgYXMgbWJpbi9tcmVsL21vcmQgaWYgeCBpcyBtYmluL21yZWwvbW9yZC5cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCB0byBcXGJpbnJlbEB7eH1cXGJpbnJlbEBAe3l9IGluIEFNU1RlWC5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxAYmlucmVsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG1jbGFzczogYmlucmVsQ2xhc3MoYXJnc1swXSksXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChhcmdzWzFdKSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChhcmdzWzFdKVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBCdWlsZCBhIHJlbGF0aW9uIG9yIHN0YWNrZWQgb3AgYnkgcGxhY2luZyBvbmUgc3ltYm9sIG9uIHRvcCBvZiBhbm90aGVyXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcc3RhY2tyZWxcIiwgXCJcXFxcb3ZlcnNldFwiLCBcIlxcXFx1bmRlcnNldFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBiYXNlQXJnID0gYXJnc1sxXTtcbiAgICBjb25zdCBzaGlmdGVkQXJnID0gYXJnc1swXTtcblxuICAgIGNvbnN0IGJhc2VPcCA9IHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IGJhc2VBcmcubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBzdGFjazogdHJ1ZSxcbiAgICAgIHN1cHByZXNzQmFzZVNoaWZ0OiBmdW5jTmFtZSAhPT0gXCJcXFxcc3RhY2tyZWxcIixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJhc2VBcmcpXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgbW9kZTogc2hpZnRlZEFyZy5tb2RlLFxuICAgICAgYmFzZTogYmFzZU9wLFxuICAgICAgc3VwOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IG51bGwgOiBzaGlmdGVkQXJnLFxuICAgICAgc3ViOiBmdW5jTmFtZSA9PT0gXCJcXFxcdW5kZXJzZXRcIiA/IHNoaWZ0ZWRBcmcgOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQzXG59KTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uXG5jb25zdCBidWlsZEdyb3VwID0gKGVsLCBzdHlsZSwgbm9uZU5vZGUpID0+IHtcbiAgaWYgKCFlbCkgeyByZXR1cm4gbm9uZU5vZGUgfVxuICBjb25zdCBub2RlID0gYnVpbGRHcm91cCQxKGVsLCBzdHlsZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IFwibXJvd1wiICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7IHJldHVybiBub25lTm9kZSB9XG4gIHJldHVybiBub2RlXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibXVsdGlzY3JpcHRcIixcbiAgbmFtZXM6IFtcIlxcXFxzaWRlc2V0XCIsIFwiXFxcXHByZXNAY3JpcHRcIl0sIC8vIFNlZSBtYWNyb3MuanMgZm9yIFxccHJlc2NyaXB0XG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogM1xuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykge1xuICAgIGlmIChhcmdzWzJdLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihmdW5jTmFtZSArIGBjYW5ub3QgcGFyc2UgYW4gZW1wdHkgYmFzZS5gKVxuICAgIH1cbiAgICBjb25zdCBiYXNlID0gYXJnc1syXS5ib2R5WzBdO1xuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0ICYmIGZ1bmNOYW1lID09PSBcIlxcXFxzaWRlc2V0XCIgJiYgIWJhc2Uuc3ltYm9sKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVGhlIGJhc2Ugb2YgXFxcXHNpZGVzZXQgbXVzdCBiZSBhIGJpZyBvcGVyYXRvci4gVHJ5IFxcXFxwcmVzY3JpcHQuYClcbiAgICB9XG5cbiAgICBpZiAoKGFyZ3NbMF0uYm9keS5sZW5ndGggPiAwICYmIGFyZ3NbMF0uYm9keVswXS50eXBlICE9PSBcInN1cHN1YlwiKSB8fFxuICAgICAgICAoYXJnc1sxXS5ib2R5Lmxlbmd0aCA+IDAgJiYgYXJnc1sxXS5ib2R5WzBdLnR5cGUgIT09IFwic3Vwc3ViXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxzaWRlc2V0IGNhbiBwYXJzZSBvbmx5IHN1YnNjcmlwdHMgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN1cGVyc2NyaXB0cyBpbiBpdHMgZmlyc3QgdHdvIGFyZ3VtZW50c1wiLCB0b2tlbilcbiAgICB9XG5cbiAgICAvLyBUaGUgcHJlc2NyaXB0cyBhbmQgcG9zdHNjcmlwdHMgY29tZSB3cmFwcGVkIGluIGEgc3Vwc3ViLlxuICAgIGNvbnN0IHByZXNjcmlwdHMgPSBhcmdzWzBdLmJvZHkubGVuZ3RoID4gMCA/IGFyZ3NbMF0uYm9keVswXSA6IG51bGw7XG4gICAgY29uc3QgcG9zdHNjcmlwdHMgPSBhcmdzWzFdLmJvZHkubGVuZ3RoID4gMCA/IGFyZ3NbMV0uYm9keVswXSA6IG51bGw7XG5cbiAgICBpZiAoIXByZXNjcmlwdHMgJiYgIXBvc3RzY3JpcHRzKSB7XG4gICAgICByZXR1cm4gYmFzZVxuICAgIH0gZWxzZSBpZiAoIXByZXNjcmlwdHMpIHtcbiAgICAgIC8vIEl0J3Mgbm90IGEgbXVsdGktc2NyaXB0LiBHZXQgYSBcXHRleHRzdHlsZSBzdXBzdWIuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIHNjcmlwdExldmVsOiBcInRleHRcIixcbiAgICAgICAgYm9keTogW3tcbiAgICAgICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICAgIGJhc2UsXG4gICAgICAgICAgc3VwOiBwb3N0c2NyaXB0cy5zdXAsXG4gICAgICAgICAgc3ViOiBwb3N0c2NyaXB0cy5zdWJcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJtdWx0aXNjcmlwdFwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgaXNTaWRlc2V0OiBmdW5jTmFtZSA9PT0gXCJcXFxcc2lkZXNldFwiLFxuICAgICAgICBwcmVzY3JpcHRzLFxuICAgICAgICBwb3N0c2NyaXB0cyxcbiAgICAgICAgYmFzZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBiYXNlID0gIGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBzdHlsZSk7XG5cbiAgICBjb25zdCBwcmVzY3JpcHRzTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXByZXNjcmlwdHNcIik7XG4gICAgY29uc3Qgbm9uZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm5vbmVcIik7XG4gICAgbGV0IGNoaWxkcmVuID0gW107XG5cbiAgICBjb25zdCBwcmVTdWIgPSBidWlsZEdyb3VwKGdyb3VwLnByZXNjcmlwdHMuc3ViLCBzdHlsZSwgbm9uZU5vZGUpO1xuICAgIGNvbnN0IHByZVN1cCA9IGJ1aWxkR3JvdXAoZ3JvdXAucHJlc2NyaXB0cy5zdXAsIHN0eWxlLCBub25lTm9kZSk7XG4gICAgaWYgKGdyb3VwLmlzU2lkZXNldCkge1xuICAgICAgLy8gVGhpcyBzZWVtcyBzaWxseSwgYnV0IExhVGVYIGRvZXMgdGhpcy4gRmlyZWZveCBpZ25vcmVzIGl0LCB3aGljaCBkb2VzIG5vdCBtYWtlIG1lIHNhZC5cbiAgICAgIHByZVN1Yi5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInRleHQtYWxpZ246IGxlZnQ7XCIpO1xuICAgICAgcHJlU3VwLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwidGV4dC1hbGlnbjogbGVmdDtcIik7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnBvc3RzY3JpcHRzKSB7XG4gICAgICBjb25zdCBwb3N0U3ViID0gYnVpbGRHcm91cChncm91cC5wb3N0c2NyaXB0cy5zdWIsIHN0eWxlLCBub25lTm9kZSk7XG4gICAgICBjb25zdCBwb3N0U3VwID0gYnVpbGRHcm91cChncm91cC5wb3N0c2NyaXB0cy5zdXAsIHN0eWxlLCBub25lTm9kZSk7XG4gICAgICBjaGlsZHJlbiA9IFtiYXNlLCBwb3N0U3ViLCBwb3N0U3VwLCBwcmVzY3JpcHRzTm9kZSwgcHJlU3ViLCBwcmVTdXBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbiA9IFtiYXNlLCBwcmVzY3JpcHRzTm9kZSwgcHJlU3ViLCBwcmVTdXBdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1tdWx0aXNjcmlwdHNcIiwgY2hpbGRyZW4pO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm5vdFwiLFxuICBuYW1lczogW1wiXFxcXG5vdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBpc0NoYXJhY3RlckJveCA9IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGFyZ3NbMF0pO1xuICAgIGxldCBib2R5O1xuICAgIGlmIChpc0NoYXJhY3RlckJveCkge1xuICAgICAgYm9keSA9IG9yZGFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgICAgaWYgKGJvZHlbMF0udGV4dC5jaGFyQXQoMCkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIGJvZHlbMF0udGV4dCA9IHN5bWJvbHMubWF0aFtib2R5WzBdLnRleHRdLnJlcGxhY2U7XG4gICAgICB9XG4gICAgICAvLyBcXHUwMzM4IGlzIHRoZSBVbmljb2RlIENvbWJpbmluZyBMb25nIFNvbGlkdXMgT3ZlcmxheVxuICAgICAgYm9keVswXS50ZXh0ID0gYm9keVswXS50ZXh0LnNsaWNlKDAsIDEpICsgXCJcXHUwMzM4XCIgKyBib2R5WzBdLnRleHQuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gdGhlIGFyZ3VtZW50IGlzIG5vdCBhIGNoYXJhY3RlciBib3gsIFRlWCBkb2VzIGFuIGF3a3dhcmQsIHBvb3JseSBwbGFjZWQgb3ZlcmxheS5cbiAgICAgIC8vIFdlJ2xsIGRvIHRoZSBzYW1lLlxuICAgICAgY29uc3Qgbm90Tm9kZSA9IHsgdHlwZTogXCJ0ZXh0b3JkXCIsIG1vZGU6IFwibWF0aFwiLCB0ZXh0OiBcIlxcdTAzMzhcIiB9O1xuICAgICAgY29uc3Qga2Vybk5vZGUgPSB7IHR5cGU6IFwia2VyblwiLCBtb2RlOiBcIm1hdGhcIiwgZGltZW5zaW9uOiB7IG51bWJlcjogLTAuNiwgdW5pdDogXCJlbVwiIH0gfTtcbiAgICAgIGJvZHkgPSBbbm90Tm9kZSwga2Vybk5vZGUsIGFyZ3NbMF1dO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJub3RcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIGlzQ2hhcmFjdGVyQm94XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlLCB0cnVlKTtcbiAgICAgIHJldHVybiBpbm5lclswXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIHN0eWxlKVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIExpbWl0cywgc3ltYm9sc1xuXG4vLyBTb21lIGhlbHBlcnNcblxuY29uc3Qgb3JkQXRvbVR5cGVzID0gW1widGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgXCJhdG9tXCJdO1xuXG4vLyBNb3N0IG9wZXJhdG9ycyBoYXZlIGEgbGFyZ2Ugc3VjY2Vzc29yIHN5bWJvbCwgYnV0IHRoZXNlIGRvbid0LlxuY29uc3Qgbm9TdWNjZXNzb3IgPSBbXCJcXFxcc21hbGxpbnRcIl07XG5cbi8vIE1hdGggb3BlcmF0b3JzIChlLmcuIFxcc2luKSBuZWVkIGEgc3BhY2UgYmV0d2VlbiB0aGVzZSB0eXBlcyBhbmQgdGhlbXNlbHZlczpcbmNvbnN0IG9yZFR5cGVzID0gW1widGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgXCJvcmRncm91cFwiLCBcImNsb3NlXCIsIFwibGVmdHJpZ2h0XCIsIFwiZm9udFwiXTtcblxuLy8gTk9URTogVW5saWtlIG1vc3QgYGJ1aWxkZXJzYHMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHkgXCJvcFwiLCBidXQgYWxzb1xuLy8gXCJzdXBzdWJcIiBzaW5jZSBzb21lIG9mIHRoZW0gKGxpa2UgXFxpbnQpIGNhbiBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxuXG5jb25zdCBzZXRTcGFjaW5nID0gbm9kZSA9PiB7XG4gIC8vIFRoZSB1c2VyIHdyb3RlIGEgXFxtYXRob3B74oCmfSBmdW5jdGlvbi4gQ2hhbmdlIHNwYWNpbmcgZnJvbSBkZWZhdWx0IHRvIE9QIHNwYWNpbmcuXG4gIC8vIFRoZSBtb3N0IGxpa2VseSBzcGFjaW5nIGZvciBhbiBPUCBpcyBhIHRoaW4gc3BhY2UgcGVyIFRlWGJvb2sgcDE3MC5cbiAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4xNjY3ZW1cIjtcbiAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMC4xNjY3ZW1cIjtcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkMiA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgbGV0IG5vZGU7XG5cbiAgaWYgKGdyb3VwLnN5bWJvbCkge1xuICAgIC8vIFRoaXMgaXMgYSBzeW1ib2wuIEp1c3QgYWRkIHRoZSBzeW1ib2wuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5uYW1lLCBncm91cC5tb2RlKV0pO1xuICAgIGlmIChub1N1Y2Nlc3Nvci5pbmNsdWRlcyhncm91cC5uYW1lKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsYXJnZW9wXCIsIFwiZmFsc2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibW92YWJsZWxpbWl0c1wiLCBcImZhbHNlXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAuZnJvbU1hdGhPcCkgeyBzZXRTcGFjaW5nKG5vZGUpOyB9XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYm9keSkge1xuICAgIC8vIFRoaXMgaXMgYW4gb3BlcmF0b3Igd2l0aCBjaGlsZHJlbi4gQWRkIHRoZW0uXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSkpO1xuICAgIGlmIChncm91cC5mcm9tTWF0aE9wKSB7IHNldFNwYWNpbmcobm9kZSk7IH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQWRkIGFsbCBvZiB0aGUgY2hhcmFjdGVycyBmcm9tIHRoZSBvcGVyYXRvcidzIG5hbWUuXG4gICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1pXCIsIFtuZXcgVGV4dE5vZGUoZ3JvdXAubmFtZS5zbGljZSgxKSldKTtcblxuICAgIGlmICghZ3JvdXAucGFyZW50SXNTdXBTdWIpIHtcbiAgICAgIC8vIEFwcGVuZCBhbiBpbnZpc2libGUgPG1vPiZBcHBseUZ1bmN0aW9uOzwvbW8+LlxuICAgICAgLy8gcmVmOiBodHRwczovL3d3dy53My5vcmcvVFIvUkVDLU1hdGhNTC9jaGFwM18yLmh0bWwjc2VjMy4yLjRcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcbiAgICAgIGNvbnN0IHJvdyA9IFtub2RlLCBvcGVyYXRvcl07XG4gICAgICAvLyBTZXQgc3BhY2luZ1xuICAgICAgaWYgKGdyb3VwLm5lZWRzTGVhZGluZ1NwYWNlKSB7XG4gICAgICAgIGNvbnN0IGxlYWQgPSBuZXcgTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIGxlYWQuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgICAgcm93LnVuc2hpZnQobGVhZCk7XG4gICAgICB9XG4gICAgICBpZiAoIWdyb3VwLmlzRm9sbG93ZWRCeURlbGltaXRlcikge1xuICAgICAgICBjb25zdCB0cmFpbCA9IG5ldyBNYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgICAgdHJhaWwuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgICAgcm93LnB1c2godHJhaWwpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5ldyBNYXRoTm9kZShcIm1yb3dcIiwgcm93KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmNvbnN0IHNpbmdsZUNoYXJCaWdPcHMgPSB7XG4gIFwiXFx1MjIwRlwiOiBcIlxcXFxwcm9kXCIsXG4gIFwiXFx1MjIxMFwiOiBcIlxcXFxjb3Byb2RcIixcbiAgXCJcXHUyMjExXCI6IFwiXFxcXHN1bVwiLFxuICBcIlxcdTIyYzBcIjogXCJcXFxcYmlnd2VkZ2VcIixcbiAgXCJcXHUyMmMxXCI6IFwiXFxcXGJpZ3ZlZVwiLFxuICBcIlxcdTIyYzJcIjogXCJcXFxcYmlnY2FwXCIsXG4gIFwiXFx1MjJjM1wiOiBcIlxcXFxiaWdjdXBcIixcbiAgXCJcXHUyYTAwXCI6IFwiXFxcXGJpZ29kb3RcIixcbiAgXCJcXHUyYTAxXCI6IFwiXFxcXGJpZ29wbHVzXCIsXG4gIFwiXFx1MmEwMlwiOiBcIlxcXFxiaWdvdGltZXNcIixcbiAgXCJcXHUyYTA0XCI6IFwiXFxcXGJpZ3VwbHVzXCIsXG4gIFwiXFx1MmEwNVwiOiBcIlxcXFxiaWdzcWNhcFwiLFxuICBcIlxcdTJhMDZcIjogXCJcXFxcYmlnc3FjdXBcIixcbiAgXCJcXHUyYTAzXCI6IFwiXFxcXGJpZ2N1cGRvdFwiLFxuICBcIlxcdTJhMDdcIjogXCJcXFxcYmlnZG91YmxldmVlXCIsXG4gIFwiXFx1MmEwOFwiOiBcIlxcXFxiaWdkb3VibGV3ZWRnZVwiLFxuICBcIlxcdTJhMDlcIjogXCJcXFxcYmlndGltZXNcIlxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcY29wcm9kXCIsXG4gICAgXCJcXFxcYmlndmVlXCIsXG4gICAgXCJcXFxcYmlnd2VkZ2VcIixcbiAgICBcIlxcXFxiaWd1cGx1c1wiLFxuICAgIFwiXFxcXGJpZ2N1cHBsdXNcIixcbiAgICBcIlxcXFxiaWdjdXBkb3RcIixcbiAgICBcIlxcXFxiaWdjYXBcIixcbiAgICBcIlxcXFxiaWdjdXBcIixcbiAgICBcIlxcXFxiaWdkb3VibGV2ZWVcIixcbiAgICBcIlxcXFxiaWdkb3VibGV3ZWRnZVwiLFxuICAgIFwiXFxcXGludG9wXCIsXG4gICAgXCJcXFxccHJvZFwiLFxuICAgIFwiXFxcXHN1bVwiLFxuICAgIFwiXFxcXGJpZ290aW1lc1wiLFxuICAgIFwiXFxcXGJpZ29wbHVzXCIsXG4gICAgXCJcXFxcYmlnb2RvdFwiLFxuICAgIFwiXFxcXGJpZ3NxY2FwXCIsXG4gICAgXCJcXFxcYmlnc3FjdXBcIixcbiAgICBcIlxcXFxiaWd0aW1lc1wiLFxuICAgIFwiXFxcXHNtYWxsaW50XCIsXG4gICAgXCJcXHUyMjBGXCIsXG4gICAgXCJcXHUyMjEwXCIsXG4gICAgXCJcXHUyMjExXCIsXG4gICAgXCJcXHUyMmMwXCIsXG4gICAgXCJcXHUyMmMxXCIsXG4gICAgXCJcXHUyMmMyXCIsXG4gICAgXCJcXHUyMmMzXCIsXG4gICAgXCJcXHUyYTAwXCIsXG4gICAgXCJcXHUyYTAxXCIsXG4gICAgXCJcXHUyYTAyXCIsXG4gICAgXCJcXHUyYTA0XCIsXG4gICAgXCJcXHUyYTA2XCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGxldCBmTmFtZSA9IGZ1bmNOYW1lO1xuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckJpZ09wc1tmTmFtZV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSwgLy8gVGhpcyBpcyB0cnVlIGZvciBcXHN0YWNrcmVse30sIG5vdCBoZXJlLlxuICAgICAgbmFtZTogZk5hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBOb3RlOiBjYWxsaW5nIGRlZmluZUZ1bmN0aW9uIHdpdGggYSB0eXBlIHRoYXQncyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBvbmx5XG4vLyB3b3JrcyBiZWNhdXNlIHRoZSBzYW1lIG1hdGhtbEJ1aWxkZXIgaXMgYmVpbmcgdXNlZC5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhvcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIC8vIEl0IHdvdWxkIGJlIGNvbnZpZW5pZW50IHRvIGp1c3Qgd3JhcCBhIDxtbz4gYXJvdW5kIHRoZSBhcmd1bWVudC5cbiAgICAvLyBCdXQgaWYgdGhlIGFyZ3VtZW50IGlzIGEgPG1pPiBvciA8bW9yZD4sIHRoYXQgd291bGQgYmUgaW52YWxpZCBNYXRoTUwuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBpbnN0ZWFkIHByb21vdGUgdGhlIHRleHQgY29udGVudHMgb2YgdGhlIGJvZHkgdG8gdGhlIHBhcmVudC5cbiAgICBjb25zdCBhcnIgPSAoYm9keS5ib2R5KSA/IGJvZHkuYm9keSA6IFtib2R5XTtcbiAgICBjb25zdCBpc1N5bWJvbCA9IGFyci5sZW5ndGggPT09IDEgJiYgb3JkQXRvbVR5cGVzLmluY2x1ZGVzKGFyclswXS50eXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGlzU3ltYm9sLFxuICAgICAgZnJvbU1hdGhPcDogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIG5hbWU6IGlzU3ltYm9sID8gYXJyWzBdLnRleHQgOiBudWxsLFxuICAgICAgYm9keTogaXNTeW1ib2wgPyBudWxsIDogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBUaGVyZSBhcmUgMiBmbGFncyBmb3Igb3BlcmF0b3JzOyB3aGV0aGVyIHRoZXkgcHJvZHVjZSBsaW1pdHMgaW5cbi8vIGRpc3BsYXlzdHlsZSwgYW5kIHdoZXRoZXIgdGhleSBhcmUgc3ltYm9scyBhbmQgc2hvdWxkIGdyb3cgaW5cbi8vIGRpc3BsYXlzdHlsZS4gVGhlc2UgZm91ciBncm91cHMgY292ZXIgdGhlIGZvdXIgcG9zc2libGUgY2hvaWNlcy5cblxuY29uc3Qgc2luZ2xlQ2hhckludGVncmFscyA9IHtcbiAgXCJcXHUyMjJiXCI6IFwiXFxcXGludFwiLFxuICBcIlxcdTIyMmNcIjogXCJcXFxcaWludFwiLFxuICBcIlxcdTIyMmRcIjogXCJcXFxcaWlpbnRcIixcbiAgXCJcXHUyMjJlXCI6IFwiXFxcXG9pbnRcIixcbiAgXCJcXHUyMjJmXCI6IFwiXFxcXG9paW50XCIsXG4gIFwiXFx1MjIzMFwiOiBcIlxcXFxvaWlpbnRcIixcbiAgXCJcXHUyMjMxXCI6IFwiXFxcXGludGNsb2Nrd2lzZVwiLFxuICBcIlxcdTIyMzJcIjogXCJcXFxcdmFyb2ludGNsb2Nrd2lzZVwiLFxuICBcIlxcdTJhMGNcIjogXCJcXFxcaWlpaW50XCIsXG4gIFwiXFx1MmEwZFwiOiBcIlxcXFxpbnRiYXJcIixcbiAgXCJcXHUyYTBlXCI6IFwiXFxcXGludEJhclwiLFxuICBcIlxcdTJhMGZcIjogXCJcXFxcZmludFwiLFxuICBcIlxcdTJhMTJcIjogXCJcXFxccnBwb2xpbnRcIixcbiAgXCJcXHUyYTEzXCI6IFwiXFxcXHNjcG9saW50XCIsXG4gIFwiXFx1MmExNVwiOiBcIlxcXFxwb2ludGludFwiLFxuICBcIlxcdTJhMTZcIjogXCJcXFxcc3FpbnRcIixcbiAgXCJcXHUyYTE3XCI6IFwiXFxcXGludGxhcmhrXCIsXG4gIFwiXFx1MmExOFwiOiBcIlxcXFxpbnR4XCIsXG4gIFwiXFx1MmExOVwiOiBcIlxcXFxpbnRjYXBcIixcbiAgXCJcXHUyYTFhXCI6IFwiXFxcXGludGN1cFwiXG59O1xuXG4vLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxhcmNzaW5cIixcbiAgICBcIlxcXFxhcmNjb3NcIixcbiAgICBcIlxcXFxhcmN0YW5cIixcbiAgICBcIlxcXFxhcmN0Z1wiLFxuICAgIFwiXFxcXGFyY2N0Z1wiLFxuICAgIFwiXFxcXGFyZ1wiLFxuICAgIFwiXFxcXGNoXCIsXG4gICAgXCJcXFxcY29zXCIsXG4gICAgXCJcXFxcY29zZWNcIixcbiAgICBcIlxcXFxjb3NoXCIsXG4gICAgXCJcXFxcY290XCIsXG4gICAgXCJcXFxcY290Z1wiLFxuICAgIFwiXFxcXGNvdGhcIixcbiAgICBcIlxcXFxjc2NcIixcbiAgICBcIlxcXFxjdGdcIixcbiAgICBcIlxcXFxjdGhcIixcbiAgICBcIlxcXFxkZWdcIixcbiAgICBcIlxcXFxkaW1cIixcbiAgICBcIlxcXFxleHBcIixcbiAgICBcIlxcXFxob21cIixcbiAgICBcIlxcXFxrZXJcIixcbiAgICBcIlxcXFxsZ1wiLFxuICAgIFwiXFxcXGxuXCIsXG4gICAgXCJcXFxcbG9nXCIsXG4gICAgXCJcXFxcc2VjXCIsXG4gICAgXCJcXFxcc2luXCIsXG4gICAgXCJcXFxcc2luaFwiLFxuICAgIFwiXFxcXHNoXCIsXG4gICAgXCJcXFxcc2duXCIsXG4gICAgXCJcXFxcdGFuXCIsXG4gICAgXCJcXFxcdGFuaFwiLFxuICAgIFwiXFxcXHRnXCIsXG4gICAgXCJcXFxcdGhcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGNvbnN0IHByZXZBdG9tVHlwZSA9IHBhcnNlci5wcmV2QXRvbVR5cGU7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIGlzRm9sbG93ZWRCeURlbGltaXRlcjogaXNEZWxpbWl0ZXIobmV4dCksXG4gICAgICBuZWVkc0xlYWRpbmdTcGFjZTogcHJldkF0b21UeXBlLmxlbmd0aCA+IDAgJiYgb3JkVHlwZXMuaW5jbHVkZXMocHJldkF0b21UeXBlKSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQyXG59KTtcblxuLy8gTGltaXRzLCBub3Qgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGV0XCIsIFwiXFxcXGdjZFwiLCBcIlxcXFxpbmZcIiwgXCJcXFxcbGltXCIsIFwiXFxcXG1heFwiLCBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGNvbnN0IHByZXZBdG9tVHlwZSA9IHBhcnNlci5wcmV2QXRvbVR5cGU7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyOiBpc0RlbGltaXRlcihuZXh0KSxcbiAgICAgIG5lZWRzTGVhZGluZ1NwYWNlOiBwcmV2QXRvbVR5cGUubGVuZ3RoID4gMCAmJiBvcmRUeXBlcy5pbmNsdWRlcyhwcmV2QXRvbVR5cGUpLFxuICAgICAgbmFtZTogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBObyBsaW1pdHMsIHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGludFwiLFxuICAgIFwiXFxcXGlpbnRcIixcbiAgICBcIlxcXFxpaWludFwiLFxuICAgIFwiXFxcXGlpaWludFwiLFxuICAgIFwiXFxcXG9pbnRcIixcbiAgICBcIlxcXFxvaWludFwiLFxuICAgIFwiXFxcXG9paWludFwiLFxuICAgIFwiXFxcXGludGNsb2Nrd2lzZVwiLFxuICAgIFwiXFxcXHZhcm9pbnRjbG9ja3dpc2VcIixcbiAgICBcIlxcXFxpbnRiYXJcIixcbiAgICBcIlxcXFxpbnRCYXJcIixcbiAgICBcIlxcXFxmaW50XCIsXG4gICAgXCJcXFxccnBwb2xpbnRcIixcbiAgICBcIlxcXFxzY3BvbGludFwiLFxuICAgIFwiXFxcXHBvaW50aW50XCIsXG4gICAgXCJcXFxcc3FpbnRcIixcbiAgICBcIlxcXFxpbnRsYXJoa1wiLFxuICAgIFwiXFxcXGludHhcIixcbiAgICBcIlxcXFxpbnRjYXBcIixcbiAgICBcIlxcXFxpbnRjdXBcIixcbiAgICBcIlxcdTIyMmJcIixcbiAgICBcIlxcdTIyMmNcIixcbiAgICBcIlxcdTIyMmRcIixcbiAgICBcIlxcdTIyMmVcIixcbiAgICBcIlxcdTIyMmZcIixcbiAgICBcIlxcdTIyMzBcIixcbiAgICBcIlxcdTIyMzFcIixcbiAgICBcIlxcdTIyMzJcIixcbiAgICBcIlxcdTJhMGNcIixcbiAgICBcIlxcdTJhMGRcIixcbiAgICBcIlxcdTJhMGVcIixcbiAgICBcIlxcdTJhMGZcIixcbiAgICBcIlxcdTJhMTJcIixcbiAgICBcIlxcdTJhMTNcIixcbiAgICBcIlxcdTJhMTVcIixcbiAgICBcIlxcdTJhMTZcIixcbiAgICBcIlxcdTJhMTdcIixcbiAgICBcIlxcdTJhMThcIixcbiAgICBcIlxcdTJhMTlcIixcbiAgICBcIlxcdTJhMWFcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGxldCBmTmFtZSA9IGZ1bmNOYW1lO1xuICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZOYW1lID0gc2luZ2xlQ2hhckludGVncmFsc1tmTmFtZV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBzdGFjazogZmFsc2UsXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMlxufSk7XG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGJ1aWxkZXJzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5XG4vLyBcIm9wZXJhdG9ybmFtZVwiLCBidXQgYWxzbyAgXCJzdXBzdWJcIiBzaW5jZSBcXG9wZXJhdG9ybmFtZSogY2FuXG4vLyBhZmZlY3Qgc3VwZXIvc3Vic2NyaXB0aW5nLlxuXG5jb25zdCBtYXRobWxCdWlsZGVyJDEgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGxldCBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlLndpdGhGb250KFwibWF0aHJtXCIpKTtcblxuICAvLyBJcyBleHByZXNzaW9uIGEgc3RyaW5nIG9yIGhhcyBpdCBzb21ldGhpbmcgbGlrZSBhIGZyYWN0aW9uP1xuICBsZXQgaXNBbGxTdHJpbmcgPSB0cnVlOyAvLyBkZWZhdWx0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIGxldCBub2RlID0gZXhwcmVzc2lvbltpXTtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuTWF0aE5vZGUpIHtcbiAgICAgIGlmICgobm9kZS50eXBlID09PSBcIm1yb3dcIiB8fCBub2RlLnR5cGUgPT09IFwibXBhZGRlZFwiKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgIG5vZGUuY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBtYXRoTUxUcmVlLk1hdGhOb2RlKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1pXCI6XG4gICAgICAgIGNhc2UgXCJtblwiOlxuICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgY2FzZSBcIm10ZXh0XCI6XG4gICAgICAgICAgYnJlYWs7IC8vIERvIG5vdGhpbmcgeWV0LlxuICAgICAgICBjYXNlIFwibXNwYWNlXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5vZGUuYXR0cmlidXRlcy53aWR0aCkge1xuICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IG5vZGUuYXR0cmlidXRlcy53aWR0aC5yZXBsYWNlKFwiZW1cIiwgXCJcIik7XG4gICAgICAgICAgICAgIGNvbnN0IGNoID0gc3BhY2VDaGFyYWN0ZXIoTnVtYmVyKHdpZHRoKSk7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbltpXSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKGNoKV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgXCJtb1wiOiB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBjaGlsZCBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuVGV4dE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1xcdTIyMTIvLCBcIi1cIikucmVwbGFjZSgvXFx1MjIxNy8sIFwiKlwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzQWxsU3RyaW5nKSB7XG4gICAgLy8gV3JpdGUgYSBzaW5nbGUgVGV4dE5vZGUgaW5zdGVhZCBvZiBtdWx0aXBsZSBuZXN0ZWQgdGFncy5cbiAgICBjb25zdCB3b3JkID0gZXhwcmVzc2lvbi5tYXAoKG5vZGUpID0+IG5vZGUudG9UZXh0KCkpLmpvaW4oXCJcIik7XG4gICAgZXhwcmVzc2lvbiA9IFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh3b3JkKV07XG4gIH0gZWxzZSBpZiAoXG4gICAgZXhwcmVzc2lvbi5sZW5ndGggPT09IDFcbiAgICAmJiBbXCJtb3ZlclwiLCBcIm11bmRlclwiXS5pbmNsdWRlcyhleHByZXNzaW9uWzBdLnR5cGUpICYmXG4gICAgKGV4cHJlc3Npb25bMF0uY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJtaVwiIHx8IGV4cHJlc3Npb25bMF0uY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJtdGV4dFwiKVxuICApIHtcbiAgICBleHByZXNzaW9uWzBdLmNoaWxkcmVuWzBdLnR5cGUgPSBcIm1pXCI7XG4gICAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGV4cHJlc3Npb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuICAgICAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChbZXhwcmVzc2lvblswXSwgb3BlcmF0b3JdKVxuICAgIH1cbiAgfVxuXG4gIGxldCB3cmFwcGVyO1xuICBpZiAoaXNBbGxTdHJpbmcpIHtcbiAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBleHByZXNzaW9uKTtcbiAgICBpZiAoZXhwcmVzc2lvblswXS50ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm5vcm1hbFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKTtcbiAgfVxuXG4gIGlmICghZ3JvdXAucGFyZW50SXNTdXBTdWIpIHtcbiAgICAvLyBBcHBlbmQgYW4gPG1vPiZBcHBseUZ1bmN0aW9uOzwvbW8+LlxuICAgIC8vIHJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL1JFQy1NYXRoTUwvY2hhcDNfMi5odG1sI3NlYzMuMi40XG4gICAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBbd3JhcHBlciwgb3BlcmF0b3JdO1xuICAgIGlmIChncm91cC5uZWVkc0xlYWRpbmdTcGFjZSkge1xuICAgICAgLy8gTGFUZVggZ2l2ZXMgb3BlcmF0b3Igc3BhY2luZywgYnV0IGEgPG1pPiBnZXRzIG9yZCBzcGFjaW5nLlxuICAgICAgLy8gU28gYWRkIGEgbGVhZGluZyBzcGFjZS5cbiAgICAgIGNvbnN0IHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICBzcGFjZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgZnJhZ21lbnQudW5zaGlmdChzcGFjZSk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuaXNGb2xsb3dlZEJ5RGVsaW1pdGVyKSB7XG4gICAgICBjb25zdCB0cmFpbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgdHJhaWwuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgIGZyYWdtZW50LnB1c2godHJhaWwpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KGZyYWdtZW50KVxuICB9XG5cbiAgcmV0dXJuIHdyYXBwZXJcbn07XG5cbi8vIFxcb3BlcmF0b3JuYW1lXG4vLyBhbXNvcG4uZHR4OiBcXG1hdGhvcHsjMVxca2VyblxcekBcXG9wZXJhdG9yQGZvbnQjM31cXG5ld21jb2Rlc0BcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcGVyYXRvcm5hbWVcIixcbiAgbmFtZXM6IFtcIlxcXFxvcGVyYXRvcm5hbWVAXCIsIFwiXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICBjb25zdCBwcmV2QXRvbVR5cGUgPSBwYXJzZXIucHJldkF0b21UeXBlO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BlcmF0b3JuYW1lXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiAoZnVuY05hbWUgPT09IFwiXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcIiksXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyOiBpc0RlbGltaXRlcihuZXh0KSxcbiAgICAgIG5lZWRzTGVhZGluZ1NwYWNlOiBwcmV2QXRvbVR5cGUubGVuZ3RoID4gMCAmJiBvcmRUeXBlcy5pbmNsdWRlcyhwcmV2QXRvbVR5cGUpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxXG59KTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcb3BlcmF0b3JuYW1lXCIsXG4gIFwiXFxcXEBpZnN0YXJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1xcXFxvcGVyYXRvcm5hbWVAXCIpO1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJvcmRncm91cFwiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgc3R5bGUsIGdyb3VwLnNlbWlzaW1wbGUpO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFxwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXGhwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24ob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIHN0eWxlKTtcbiAgICBjb25zdCBwaGFudG9tID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcGhhbnRvbV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidnBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFx2cGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ2cGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKG9yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBzdHlsZSk7XG4gICAgY29uc3QgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLy8gSW4gTGFUZVgsIFxccG1iIGlzIGEgc2ltdWxhdGlvbiBvZiBib2xkIGZvbnQuXG4vLyBUaGUgdmVyc2lvbiBvZiBcXHBtYiBpbiBhbWJzeS5zdHkgd29ya3MgYnkgdHlwZXNldHRpbmcgdGhyZWUgY29waWVzIG9mIHRoZSBhcmd1bWVudFxuLy8gd2l0aCBzbWFsbCBvZmZzZXRzLiBXZSB1c2UgQ1NTIGZvbnQtd2VpZ2h0OmJvbGQuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJwbWJcIixcbiAgbmFtZXM6IFtcIlxcXFxwbWJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInBtYlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChhcmdzWzBdKVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSk7XG4gICAgLy8gV3JhcCB3aXRoIGFuIDxtc3R5bGU+IGVsZW1lbnQuXG4gICAgY29uc3Qgbm9kZSA9IHdyYXBXaXRoTXN0eWxlKGlubmVyKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiZm9udC13ZWlnaHQ6Ym9sZFwiKTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gXFxyYWlzZSwgXFxsb3dlciwgYW5kIFxccmFpc2Vib3hcblxuY29uc3QgbWF0aG1sQnVpbGRlciA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5URVhUKTtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG5ld1N0eWxlKV0pO1xuICBjb25zdCBkeSA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZHksIHN0eWxlKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIGR5Lm51bWJlciArIGR5LnVuaXQpO1xuICAvLyBBZGQgcGFkZGluZywgd2hpY2ggYWN0cyB0byBpbmNyZWFzZSBoZWlnaHQgaW4gQ2hyb21pdW0uXG4gIC8vIFRPRE86IEZpZ3VyZSBvdXQgc29tZSB3YXkgdG8gY2hhbmdlIGhlaWdodCBpbiBGaXJlZm94IHcvbyBicmVha2luZyBDaHJvbWl1bS5cbiAgaWYgKGR5Lm51bWJlciA+IDApIHtcbiAgICBub2RlLnN0eWxlLnBhZGRpbmcgPSBkeS5udW1iZXIgKyBkeS51bml0ICsgXCIgMCAwIDBcIjtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnN0eWxlLnBhZGRpbmcgPSBcIjAgMCBcIiArIE1hdGguYWJzKGR5Lm51bWJlcikgKyBkeS51bml0ICsgXCIgMFwiO1xuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmFpc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxyYWlzZVwiLCBcIlxcXFxsb3dlclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwicHJpbWl0aXZlXCJdLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYW1vdW50ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlO1xuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcbG93ZXJcIikgeyBhbW91bnQubnVtYmVyICo9IC0xOyB9XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmFpc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZHk6IGFtb3VudCxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyXG59KTtcblxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmFpc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxyYWlzZWJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBhbW91bnQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWU7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmFpc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZHk6IGFtb3VudCxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJlZlwiLFxuICBuYW1lczogW1wiXFxcXHJlZlwiLCBcIlxcXFxlcXJlZlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJlZlwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIHN0cmluZzogYXJnc1swXS5zdHJpbmcucmVwbGFjZShpbnZhbGlkSWRSZWdFeCwgXCJcIilcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIENyZWF0ZSBhbiBlbXB0eSA8YT4gbm9kZS4gU2V0IGEgY2xhc3MgYW5kIGFuIGhyZWYgYXR0cmlidXRlLlxuICAgIC8vIFRoZSBwb3N0LXByb2Nlc3NvciB3aWxsIHBvcHVsYXRlIHdpdGggdGhlIHRhcmdldCdzIHRhZyBvciBlcXVhdGlvbiBudW1iZXIuXG4gICAgY29uc3QgY2xhc3NlcyA9IGdyb3VwLmZ1bmNOYW1lID09PSBcIlxcXFxyZWZcIiA/IFtcInRtbC1yZWZcIl0gOiBbXCJ0bWwtcmVmXCIsIFwidG1sLWVxcmVmXCJdO1xuICAgIHJldHVybiBuZXcgQW5jaG9yTm9kZShcIiNcIiArIGdyb3VwLnN0cmluZywgY2xhc3NlcywgbnVsbClcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJyZWZsZWN0XCIsXG4gIG5hbWVzOiBbXCJcXFxccmVmbGVjdGJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmVmbGVjdFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBub2RlID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIHN0eWxlKTtcbiAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGVYKC0xKVwiO1xuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxyZWxheFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJydWxlXCIsXG4gIG5hbWVzOiBbXCJcXFxccnVsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIiwgXCJzaXplXCIsIFwic2l6ZVwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBzaGlmdCA9IG9wdEFyZ3NbMF07XG4gICAgY29uc3Qgd2lkdGggPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIik7XG4gICAgY29uc3QgaGVpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgXCJzaXplXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJ1bGVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc2hpZnQ6IHNoaWZ0ICYmIGFzc2VydE5vZGVUeXBlKHNoaWZ0LCBcInNpemVcIikudmFsdWUsXG4gICAgICB3aWR0aDogd2lkdGgudmFsdWUsXG4gICAgICBoZWlnaHQ6IGhlaWdodC52YWx1ZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3Qgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBzdHlsZSk7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIHN0eWxlKTtcbiAgICBjb25zdCBzaGlmdCA9IGdyb3VwLnNoaWZ0XG4gICAgICA/IGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2hpZnQsIHN0eWxlKVxuICAgICAgOiB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH07XG4gICAgY29uc3QgY29sb3IgPSAoc3R5bGUuY29sb3IgJiYgc3R5bGUuZ2V0Q29sb3IoKSkgfHwgXCJibGFja1wiO1xuXG4gICAgY29uc3QgcnVsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgIGlmICh3aWR0aC5udW1iZXIgPiAwICYmIGhlaWdodC5udW1iZXIgPiAwKSB7XG4gICAgICBydWxlLnNldEF0dHJpYnV0ZShcIm1hdGhiYWNrZ3JvdW5kXCIsIGNvbG9yKTtcbiAgICB9XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aC5udW1iZXIgKyB3aWR0aC51bml0KTtcbiAgICBydWxlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQubnVtYmVyICsgaGVpZ2h0LnVuaXQpO1xuICAgIGlmIChzaGlmdC5udW1iZXIgPT09IDApIHsgcmV0dXJuIHJ1bGUgfVxuXG4gICAgY29uc3Qgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcnVsZV0pO1xuICAgIGlmIChzaGlmdC5udW1iZXIgPj0gMCkge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIrXCIgKyBzaGlmdC5udW1iZXIgKyBzaGlmdC51bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc2hpZnQubnVtYmVyICsgc2hpZnQudW5pdCk7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiK1wiICsgLXNoaWZ0Lm51bWJlciArIHNoaWZ0LnVuaXQpO1xuICAgIH1cbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgc2hpZnQubnVtYmVyICsgc2hpZnQudW5pdCk7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG4gIH1cbn0pO1xuXG4vLyBUaGUgc2l6ZSBtYXBwaW5ncyBhcmUgdGFrZW4gZnJvbSBUZVggd2l0aCBcXG5vcm1hbHNpemU9MTBwdC5cbi8vIFdlIGRvbid0IGhhdmUgdG8gdHJhY2sgc2NyaXB0IGxldmVsLiBNYXRoTUwgZG9lcyB0aGF0LlxuY29uc3Qgc2l6ZU1hcCA9IHtcbiAgXCJcXFxcdGlueVwiOiAwLjUsXG4gIFwiXFxcXHNpeHB0c2l6ZVwiOiAwLjYsXG4gIFwiXFxcXFRpbnlcIjogMC42LFxuICBcIlxcXFxzY3JpcHRzaXplXCI6IDAuNyxcbiAgXCJcXFxcZm9vdG5vdGVzaXplXCI6IDAuOCxcbiAgXCJcXFxcc21hbGxcIjogMC45LFxuICBcIlxcXFxub3JtYWxzaXplXCI6IDEuMCxcbiAgXCJcXFxcbGFyZ2VcIjogMS4yLFxuICBcIlxcXFxMYXJnZVwiOiAxLjQ0LFxuICBcIlxcXFxMQVJHRVwiOiAxLjcyOCxcbiAgXCJcXFxcaHVnZVwiOiAyLjA3NCxcbiAgXCJcXFxcSHVnZVwiOiAyLjQ4OFxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNpemluZ1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXHRpbnlcIixcbiAgICBcIlxcXFxzaXhwdHNpemVcIixcbiAgICBcIlxcXFxUaW55XCIsXG4gICAgXCJcXFxcc2NyaXB0c2l6ZVwiLFxuICAgIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLFxuICAgIFwiXFxcXHNtYWxsXCIsXG4gICAgXCJcXFxcbm9ybWFsc2l6ZVwiLFxuICAgIFwiXFxcXGxhcmdlXCIsXG4gICAgXCJcXFxcTGFyZ2VcIixcbiAgICBcIlxcXFxMQVJHRVwiLFxuICAgIFwiXFxcXGh1Z2VcIixcbiAgICBcIlxcXFxIdWdlXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgYnJlYWtPblRva2VuVGV4dCwgZnVuY05hbWUsIHBhcnNlciB9LCBhcmdzKSA9PiB7XG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QgJiYgcGFyc2VyLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coYFRlbW1sIHN0cmljdC1tb2RlIHdhcm5pbmc6IENvbW1hbmQgJHtmdW5jTmFtZX0gaXMgaW52YWxpZCBpbiBtYXRoIG1vZGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBicmVha09uVG9rZW5UZXh0LCB0cnVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaXppbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aEZvbnRTaXplKHNpemVNYXBbZ3JvdXAuZnVuY05hbWVdKTtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBuZXdTdHlsZSk7XG4gICAgLy8gV3JhcCB3aXRoIGFuIDxtc3R5bGU+IGVsZW1lbnQuXG4gICAgY29uc3Qgbm9kZSA9IHdyYXBXaXRoTXN0eWxlKGlubmVyKTtcbiAgICBjb25zdCBmYWN0b3IgPSAoc2l6ZU1hcFtncm91cC5mdW5jTmFtZV0gLyBzdHlsZS5mb250U2l6ZSkudG9GaXhlZCg0KTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIGZhY3RvciArIFwiZW1cIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vLyBzbWFzaCwgd2l0aCBvcHRpb25hbCBbdGJdLCBhcyBpbiBBTVNcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNtYXNoXCIsXG4gIG5hbWVzOiBbXCJcXFxcc21hc2hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncywgb3B0QXJncykgPT4ge1xuICAgIGxldCBzbWFzaEhlaWdodCA9IGZhbHNlO1xuICAgIGxldCBzbWFzaERlcHRoID0gZmFsc2U7XG4gICAgY29uc3QgdGJBcmcgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwib3JkZ3JvdXBcIik7XG4gICAgaWYgKHRiQXJnKSB7XG4gICAgICAvLyBPcHRpb25hbCBbdGJdIGFyZ3VtZW50IGlzIGVuZ2FnZWQuXG4gICAgICAvLyByZWY6IGFtc21hdGg6IFxccmVuZXdjb21tYW5ke1xcc21hc2h9WzFdW3RiXXslXG4gICAgICAvLyAgICAgICAgICAgICAgIGRlZlxcbWJAdHtcXGh0fVxcZGVmXFxtYkBie1xcZHB9XFxkZWZcXG1iQHRie1xcaHRcXHpAXFx6QFxcZHB9JVxuICAgICAgbGV0IGxldHRlciA9IFwiXCI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRiQXJnLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRiQXJnLmJvZHlbaV07XG4gICAgICAgIC8vIFRPRE86IFdyaXRlIGFuIEFzc2VydFN5bWJvbE5vZGVcbiAgICAgICAgbGV0dGVyID0gbm9kZS50ZXh0O1xuICAgICAgICBpZiAobGV0dGVyID09PSBcInRcIikge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiYlwiKSB7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc21hc2hIZWlnaHQgPSBmYWxzZTtcbiAgICAgICAgICBzbWFzaERlcHRoID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc21hc2hIZWlnaHQgPSB0cnVlO1xuICAgICAgc21hc2hEZXB0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic21hc2hcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIHNtYXNoSGVpZ2h0LFxuICAgICAgc21hc2hEZXB0aFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpXSk7XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hIZWlnaHQpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zbWFzaERlcHRoKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInNxcnRcIixcbiAgbmFtZXM6IFtcIlxcXFxzcXJ0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IGluZGV4ID0gb3B0QXJnc1swXTtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzcXJ0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBpbmRleFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgeyBib2R5LCBpbmRleCB9ID0gZ3JvdXA7XG4gICAgcmV0dXJuIGluZGV4XG4gICAgICA/IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvb3RcIiwgW1xuICAgICAgICBidWlsZEdyb3VwJDEoYm9keSwgc3R5bGUpLFxuICAgICAgICBidWlsZEdyb3VwJDEoaW5kZXgsIHN0eWxlLmluY3JlbWVudExldmVsKCkpXG4gICAgICBdKVxuICAgIDogbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3FydFwiLCBbYnVpbGRHcm91cCQxKGJvZHksIHN0eWxlKV0pO1xuICB9XG59KTtcblxuY29uc3Qgc3R5bGVNYXAgPSB7XG4gIGRpc3BsYXk6IDAsXG4gIHRleHQ6IDEsXG4gIHNjcmlwdDogMixcbiAgc2NyaXB0c2NyaXB0OiAzXG59O1xuXG5jb25zdCBzdHlsZUF0dHJpYnV0ZXMgPSB7XG4gIGRpc3BsYXk6IFtcIjBcIiwgXCJ0cnVlXCJdLFxuICB0ZXh0OiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gIHNjcmlwdDogW1wiMVwiLCBcImZhbHNlXCJdLFxuICBzY3JpcHRzY3JpcHQ6IFtcIjJcIiwgXCJmYWxzZVwiXVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInN0eWxpbmdcIixcbiAgbmFtZXM6IFtcIlxcXFxkaXNwbGF5c3R5bGVcIiwgXCJcXFxcdGV4dHN0eWxlXCIsIFwiXFxcXHNjcmlwdHN0eWxlXCIsIFwiXFxcXHNjcmlwdHNjcmlwdHN0eWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IGJyZWFrT25Ub2tlblRleHQsIGZ1bmNOYW1lLCBwYXJzZXIgfSwgYXJncykge1xuICAgIC8vIHBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keVxuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQsIHRydWUpO1xuXG4gICAgY29uc3Qgc2NyaXB0TGV2ZWwgPSBmdW5jTmFtZS5zbGljZSgxLCBmdW5jTmFtZS5sZW5ndGggLSA1KTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzY3JpcHRMZXZlbCB0byB1c2UgYnkgcHVsbGluZyBvdXQgdGhlIHNjcmlwdExldmVsIGZyb21cbiAgICAgIC8vIHRoZSBmdW5jdGlvbiBuYW1lXG4gICAgICBzY3JpcHRMZXZlbCxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCBzY3JpcHRMZXZlbCB3ZSdyZSBjaGFuZ2luZyB0by5cbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlLndpdGhMZXZlbChzdHlsZU1hcFtncm91cC5zY3JpcHRMZXZlbF0pO1xuICAgIC8vIFRoZSBzdHlsZSBhcmd1bWVudCBpbiB0aGUgbmV4dCBsaW5lIGRvZXMgTk9UIGRpcmVjdGx5IHNldCBhIE1hdGhNTCBzY3JpcHQgbGV2ZWwuXG4gICAgLy8gSXQganVzdCB0cmFja3MgdGhlIHN0eWxlIGxldmVsLCBpbiBjYXNlIHdlIG5lZWQgdG8ga25vdyBpdCBmb3Igc3Vwc3ViIG9yIG1hdGhjaG9pY2UuXG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3U3R5bGUpO1xuICAgIC8vIFdyYXAgd2l0aCBhbiA8bXN0eWxlPiBlbGVtZW50LlxuICAgIGNvbnN0IG5vZGUgPSB3cmFwV2l0aE1zdHlsZShpbm5lcik7XG5cbiAgICBjb25zdCBhdHRyID0gc3R5bGVBdHRyaWJ1dGVzW2dyb3VwLnNjcmlwdExldmVsXTtcblxuICAgIC8vIEhlcmUgaXMgd2hlcmUgd2Ugc2V0IHRoZSBNYXRoTUwgc2NyaXB0IGxldmVsLlxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG5cbi8vIEhlbHBlcnNcbmNvbnN0IHN5bWJvbFJlZ0V4ID0gL15tKG92ZXJ8dW5kZXJ8dW5kZXJvdmVyKSQvO1xuXG4vLyBTdXBlciBzY3JpcHRzIGFuZCBzdWJzY3JpcHRzLCB3aG9zZSBwcmVjaXNlIHBsYWNlbWVudCBjYW4gZGVwZW5kIG9uIG90aGVyXG4vLyBmdW5jdGlvbnMgdGhhdCBwcmVjZWRlIHRoZW0uXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJzdXBzdWJcIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBJcyB0aGUgaW5uZXIgZ3JvdXAgYSByZWxldmFudCBob3Jpem9udGFsIGJyYWNlP1xuICAgIGxldCBpc0JyYWNlID0gZmFsc2U7XG4gICAgbGV0IGlzT3ZlcjtcbiAgICBsZXQgaXNTdXA7XG4gICAgbGV0IGFwcGVuZEFwcGx5RnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgYXBwZW5kU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgbmVlZHNMZWFkaW5nU3BhY2UgPSBmYWxzZTtcblxuICAgIGlmIChncm91cC5iYXNlICYmIGdyb3VwLmJhc2UudHlwZSA9PT0gXCJob3JpekJyYWNlXCIpIHtcbiAgICAgIGlzU3VwID0gISFncm91cC5zdXA7XG4gICAgICBpZiAoaXNTdXAgPT09IGdyb3VwLmJhc2UuaXNPdmVyKSB7XG4gICAgICAgIGlzQnJhY2UgPSB0cnVlO1xuICAgICAgICBpc092ZXIgPSBncm91cC5iYXNlLmlzT3ZlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiAhZ3JvdXAuYmFzZS5zdGFjayAmJlxuICAgICAgKGdyb3VwLmJhc2UudHlwZSA9PT0gXCJvcFwiIHx8IGdyb3VwLmJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIikpIHtcbiAgICAgIGdyb3VwLmJhc2UucGFyZW50SXNTdXBTdWIgPSB0cnVlO1xuICAgICAgYXBwZW5kQXBwbHlGdW5jdGlvbiA9ICFncm91cC5iYXNlLnN5bWJvbDtcbiAgICAgIGFwcGVuZFNwYWNlID0gYXBwZW5kQXBwbHlGdW5jdGlvbiAmJiAhZ3JvdXAuaXNGb2xsb3dlZEJ5RGVsaW1pdGVyO1xuICAgICAgbmVlZHNMZWFkaW5nU3BhY2UgPSBncm91cC5iYXNlLm5lZWRzTGVhZGluZ1NwYWNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnN0YWNrXG4gICAgICA/IFtidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZS5ib2R5WzBdLCBzdHlsZSldXG4gICAgICA6IFtidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgc3R5bGUpXTtcblxuICAgIC8vIE5vdGUgcmVnYXJkaW5nIHNjcmlwdHN0eWxlIGxldmVsLlxuICAgIC8vIChTdWJ8c3VwZXIpc2NyaXB0cyBzaG91bGQgbm90IHNocmluayBiZXlvbmQgTWF0aE1MIHNjcmlwdGxldmVsIDIgYWthIFxcc2NyaXB0c2NyaXB0c3R5bGVcbiAgICAvLyBSZWY6IGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9tYXRobWwtY29yZS8jdGhlLWRpc3BsYXlzdHlsZS1hbmQtc2NyaXB0bGV2ZWwtYXR0cmlidXRlc1xuICAgIC8vIChCVFcsIE1hdGhNTCBzY3JpcHRsZXZlbCAyIGlzIGVxdWFsIHRvIFRlbW1sIGxldmVsIDMuKVxuICAgIC8vIEJ1dCBDaHJvbWl1bSBjb250aW51ZXMgdG8gc2hyaW5rIHRoZSAoc3VifHN1cGVyKXNjcmlwdHMuIFNvIHdlIGV4cGxpY2l0bHkgc2V0IHNjcmlwdGxldmVsIDIuXG5cbiAgICBjb25zdCBjaGlsZFN0eWxlID0gc3R5bGUuaW5TdWJPclN1cCgpO1xuICAgIGlmIChncm91cC5zdWIpIHtcbiAgICAgIGNvbnN0IHN1YiA9IGJ1aWxkR3JvdXAkMShncm91cC5zdWIsIGNoaWxkU3R5bGUpO1xuICAgICAgaWYgKHN0eWxlLmxldmVsID09PSAzKSB7IHN1Yi5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjJcIik7IH1cbiAgICAgIGNoaWxkcmVuLnB1c2goc3ViKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc3VwKSB7XG4gICAgICBjb25zdCBzdXAgPSBidWlsZEdyb3VwJDEoZ3JvdXAuc3VwLCBjaGlsZFN0eWxlKTtcbiAgICAgIGlmIChzdHlsZS5sZXZlbCA9PT0gMykgeyBzdXAuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIyXCIpOyB9XG4gICAgICBjb25zdCB0ZXN0Tm9kZSA9IHN1cC50eXBlID09PSBcIm1yb3dcIiA/IHN1cC5jaGlsZHJlblswXSA6IHN1cDtcbiAgICAgIGlmICgodGVzdE5vZGUgJiYgdGVzdE5vZGUudHlwZSA9PT0gXCJtb1wiICYmIHRlc3ROb2RlLmNsYXNzZXMuaW5jbHVkZXMoXCJ0bWwtcHJpbWVcIikpXG4gICAgICAgICYmIGdyb3VwLmJhc2UgJiYgZ3JvdXAuYmFzZS50ZXh0ICYmIFwiZkZcIi5pbmRleE9mKGdyb3VwLmJhc2UudGV4dCkgPiAtMSkge1xuICAgICAgICAvLyBDaHJvbWl1bSBkb2VzIG5vdCBhZGRyZXNzIGl0YWxpYyBjb3JyZWN0aW9uIG9uIHByaW1lLiAgUHJldmVudCBm4oCyIGZyb20gb3ZlcmxhcHBpbmcuXG4gICAgICAgIHRlc3ROb2RlLmNsYXNzZXMucHVzaChcInByaW1lLXBhZFwiKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnB1c2goc3VwKTtcbiAgICB9XG5cbiAgICBsZXQgbm9kZVR5cGU7XG4gICAgaWYgKGlzQnJhY2UpIHtcbiAgICAgIG5vZGVUeXBlID0gaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIjtcbiAgICB9IGVsc2UgaWYgKCFncm91cC5zdWIpIHtcbiAgICAgIGNvbnN0IGJhc2UgPSBncm91cC5iYXNlO1xuICAgICAgaWYgKFxuICAgICAgICBiYXNlICYmXG4gICAgICAgIGJhc2UudHlwZSA9PT0gXCJvcFwiICYmXG4gICAgICAgIGJhc2UubGltaXRzICYmXG4gICAgICAgIChzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtb3ZlclwiO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgYmFzZSAmJlxuICAgICAgICBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiZcbiAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiZcbiAgICAgICAgKGJhc2UubGltaXRzIHx8IHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1vdmVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1cFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1cCkge1xuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmJhc2U7XG4gICAgICBpZiAoXG4gICAgICAgIGJhc2UgJiZcbiAgICAgICAgYmFzZS50eXBlID09PSBcIm9wXCIgJiZcbiAgICAgICAgYmFzZS5saW1pdHMgJiZcbiAgICAgICAgKHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlclwiO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgYmFzZSAmJlxuICAgICAgICBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiZcbiAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiZcbiAgICAgICAgKGJhc2UubGltaXRzIHx8IHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmJhc2U7XG4gICAgICBpZiAoYmFzZSAmJiAoKGJhc2UudHlwZSA9PT0gXCJvcFwiICYmIGJhc2UubGltaXRzKSB8fCBiYXNlLnR5cGUgPT09IFwibXVsdGlzY3JpcHRcIikgJiZcbiAgICAgICAgKHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGJhc2UgJiZcbiAgICAgICAgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmXG4gICAgICAgIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmXG4gICAgICAgIChzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZIHx8IGJhc2UubGltaXRzKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJvdmVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YnN1cFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcbiAgICBpZiAoYXBwZW5kQXBwbHlGdW5jdGlvbikge1xuICAgICAgLy8gQXBwZW5kIGFuIDxtbz4mQXBwbHlGdW5jdGlvbjs8L21vPi5cbiAgICAgIC8vIHJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL1JFQy1NYXRoTUwvY2hhcDNfMi5odG1sI3NlYzMuMi40XG4gICAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcbiAgICAgIGlmIChuZWVkc0xlYWRpbmdTcGFjZSkge1xuICAgICAgICBjb25zdCBzcGFjZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgICBzcGFjZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgICBub2RlID0gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KFtzcGFjZSwgbm9kZSwgb3BlcmF0b3JdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoW25vZGUsIG9wZXJhdG9yXSk7XG4gICAgICB9XG4gICAgICBpZiAoYXBwZW5kU3BhY2UpIHtcbiAgICAgICAgY29uc3Qgc3BhY2UgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgICAgc3BhY2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHNwYWNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN5bWJvbFJlZ0V4LnRlc3Qobm9kZVR5cGUpKSB7XG4gICAgICAvLyBXcmFwIGluIGEgPG1yb3c+LiBPdGhlcndpc2UgRmlyZWZveCBzdHJldGNoeSBwYXJlbnMgd2lsbCBub3Qgc3RyZXRjaCB0byBpbmNsdWRlIGxpbWl0cy5cbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW25vZGVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gT3BlcmF0b3IgUGFyc2VOb2RlcyBjcmVhdGVkIGluIFBhcnNlci5qcyBmcm9tIHN5bWJvbCBHcm91cHMgaW4gc3JjL3N5bWJvbHMuanMuXG5cbmNvbnN0IHNob3J0ID0gW1wiXFxcXHNob3J0bWlkXCIsIFwiXFxcXG5zaG9ydG1pZFwiLCBcIlxcXFxzaG9ydHBhcmFsbGVsXCIsXG4gIFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIsIFwiXFxcXHNtYWxsc2V0bWludXNcIl07XG5cbmNvbnN0IGFycm93cyA9IFtcIlxcXFxSc2hcIiwgXCJcXFxcTHNoXCIsIFwiXFxcXHJlc3RyaWN0aW9uXCJdO1xuXG5jb25zdCBpc0Fycm93ID0gc3RyID0+IHtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoMCk7XG4gICAgcmV0dXJuICgweDIxOGYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgyMjAwKVxuICB9XG4gIHJldHVybiBzdHIuaW5kZXhPZihcImFycm93XCIpID4gLTEgfHwgc3RyLmluZGV4T2YoXCJoYXJwb29uXCIpID4gLTEgfHwgYXJyb3dzLmluY2x1ZGVzKHN0cilcbn07XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcImF0b21cIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSldKTtcbiAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcInB1bmN0XCIpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2VwYXJhdG9yXCIsIFwidHJ1ZVwiKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJvcGVuXCIgfHwgZ3JvdXAuZmFtaWx5ID09PSBcImNsb3NlXCIpIHtcbiAgICAgIC8vIERlbGltcyBidWlsdCBoZXJlIHNob3VsZCBub3Qgc3RyZXRjaCB2ZXJ0aWNhbGx5LlxuICAgICAgLy8gU2VlIGRlbGltc2l6aW5nLmpzIGZvciBzdHJldGNoeSBkZWxpbXMuXG4gICAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcIm9wZW5cIikge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwcmVmaXhcIik7XG4gICAgICAgIC8vIFNldCBhbiBleHBsaWNpdCBhdHRyaWJ1dGUgZm9yIHN0cmV0Y2guIE90aGVyd2lzZSBGaXJlZm94IG1heSBkbyBpdCB3cm9uZy5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwiY2xvc2VcIikge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZvcm1cIiwgXCJwb3N0Zml4XCIpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChncm91cC50ZXh0ID09PSBcIlxcXFxtaWRcIikge1xuICAgICAgLy8gRmlyZWZveCBtZXNzZXMgdXAgdGhpcyBzcGFjaW5nIGlmIGF0IHRoZSBlbmQgb2YgYW4gPG1yb3c+LiBTZWUgaXQgZXhwbGljaXRseS5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMC4yMmVtXCIpOyAvLyBtZWRpdW0gc3BhY2VcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMC4yMmVtXCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcInJlbFwiICYmIGlzQXJyb3coZ3JvdXAudGV4dCkpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJmYWxzZVwiKTtcbiAgICB9IGVsc2UgaWYgKHNob3J0LmluY2x1ZGVzKGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhzaXplXCIsIFwiNzAlXCIpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudGV4dCA9PT0gXCI6XCIpIHtcbiAgICAgIC8vIFwiOlwiIGlzIG5vdCBpbiB0aGUgTWF0aE1MIG9wZXJhdG9yIGRpY3Rpb25hcnkuIEdpdmUgaXQgQklOIHNwYWNpbmcuXG4gICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjIyMjJlbVwiO1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMC4yMjIyZW1cIjtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLm5lZWRzU3BhY2luZykge1xuICAgICAgLy8gRml4IGEgTWF0aE1MIGJ1ZyB0aGF0IG9jY3VycyB3aGVuIGEgPG1vPiBpcyBiZXR3ZWVuIHR3byA8bXRleHQ+IGVsZW1lbnRzLlxuICAgICAgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJiaW5cIikge1xuICAgICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtwYWRkaW5nJDEoMC4yMjIpLCBub2RlLCBwYWRkaW5nJDEoMC4yMjIpXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJFTCBzcGFjaW5nXG4gICAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW3BhZGRpbmckMSgwLjI3NzgpLCBub2RlLCBwYWRkaW5nJDEoMC4yNzc4KV0pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLyoqXG4gKiBNYXBzIFRlWCBmb250IGNvbW1hbmRzIHRvIFwibWF0aHZhcmlhbnRcIiBhdHRyaWJ1dGUgaW4gYnVpbGRNYXRoTUwuanNcbiAqL1xuY29uc3QgZm9udE1hcCA9IHtcbiAgLy8gc3R5bGVzXG4gIG1hdGhiZjogXCJib2xkXCIsXG4gIG1hdGhybTogXCJub3JtYWxcIixcbiAgdGV4dGl0OiBcIml0YWxpY1wiLFxuICBtYXRoaXQ6IFwiaXRhbGljXCIsXG4gIG1hdGhub3JtYWw6IFwiaXRhbGljXCIsXG5cbiAgLy8gZmFtaWxpZXNcbiAgbWF0aGJiOiBcImRvdWJsZS1zdHJ1Y2tcIixcbiAgbWF0aGNhbDogXCJzY3JpcHRcIixcbiAgbWF0aGZyYWs6IFwiZnJha3R1clwiLFxuICBtYXRoc2NyOiBcInNjcmlwdFwiLFxuICBtYXRoc2Y6IFwic2Fucy1zZXJpZlwiLFxuICBtYXRodHQ6IFwibW9ub3NwYWNlXCJcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF0aCB2YXJpYW50IGFzIGEgc3RyaW5nIG9yIG51bGwgaWYgbm9uZSBpcyByZXF1aXJlZC5cbiAqL1xuY29uc3QgZ2V0VmFyaWFudCA9IGZ1bmN0aW9uKGdyb3VwLCBzdHlsZSkge1xuICAvLyBIYW5kbGUgZm9udCBzcGVjaWZpZXJzIGFzIGJlc3Qgd2UgY2FuLlxuICAvLyBDaHJvbWl1bSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBNYXRoTUwgbWF0aHZhcmlhbnQgYXR0cmlidXRlLlxuICAvLyBTbyB3ZSdsbCB1c2UgVW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGluc3RlYWQuXG4gIC8vIEJ1dCBmaXJzdCwgZGV0ZXJtaW5lIHRoZSBtYXRoIHZhcmlhbnQuXG5cbiAgLy8gRGVhbCB3aXRoIHRoZSBcXHRleHRpdCwgXFx0ZXh0YmYsIGV0Yy4sIGZ1bmN0aW9ucy5cbiAgaWYgKHN0eWxlLmZvbnRGYW1pbHkgPT09IFwidGV4dHR0XCIpIHtcbiAgICByZXR1cm4gXCJtb25vc3BhY2VcIlxuICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRGYW1pbHkgPT09IFwidGV4dHNjXCIpIHtcbiAgICByZXR1cm4gXCJub3JtYWxcIjsgLy8gaGFuZGxlZCB2aWEgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbiBpbiBzeW1ib2xzT3JkLmpzLlxuICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRGYW1pbHkgPT09IFwidGV4dHNmXCIpIHtcbiAgICBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiICYmIHN0eWxlLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIlxuICAgIH0gZWxzZSBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWl0YWxpY1wiXG4gICAgfSBlbHNlIGlmIChzdHlsZS5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWJvbGRcIlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmXCJcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiICYmIHN0eWxlLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiXG4gIH0gZWxzZSBpZiAoc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiKSB7XG4gICAgcmV0dXJuIFwiaXRhbGljXCJcbiAgfSBlbHNlIGlmIChzdHlsZS5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZFwiXG4gIH1cblxuICAvLyBEZWFsIHdpdGggdGhlIFxcbWF0aGl0LCBtYXRoYmYsIGV0YywgZnVuY3Rpb25zLlxuICBjb25zdCBmb250ID0gc3R5bGUuZm9udDtcbiAgaWYgKCFmb250IHx8IGZvbnQgPT09IFwibWF0aG5vcm1hbFwiKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IG1vZGUgPSBncm91cC5tb2RlO1xuICBzd2l0Y2ggKGZvbnQpIHtcbiAgICBjYXNlIFwibWF0aGl0XCI6XG4gICAgICByZXR1cm4gXCJpdGFsaWNcIlxuICAgIGNhc2UgXCJtYXRocm1cIjoge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gZ3JvdXAudGV4dC5jb2RlUG9pbnRBdCgwKTtcbiAgICAgIC8vIExhVGVYIFxcbWF0aHJtIHJldHVybnMgaXRhbGljIGZvciBHcmVlayBjaGFyYWN0ZXJzLlxuICAgICAgcmV0dXJuICAoMHgwM2FiIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MDNjZikgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIlxuICAgIH1cbiAgICBjYXNlIFwiZ3JlZWtJdGFsaWNcIjpcbiAgICAgIHJldHVybiBcIml0YWxpY1wiXG4gICAgY2FzZSBcInVwQGdyZWVrXCI6XG4gICAgICByZXR1cm4gXCJub3JtYWxcIlxuICAgIGNhc2UgXCJib2xkc3ltYm9sXCI6XG4gICAgY2FzZSBcIm1hdGhib2xkc3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJib2xkLWl0YWxpY1wiXG4gICAgY2FzZSBcIm1hdGhiZlwiOlxuICAgICAgcmV0dXJuIFwiYm9sZFwiXG4gICAgY2FzZSBcIm1hdGhiYlwiOlxuICAgICAgcmV0dXJuIFwiZG91YmxlLXN0cnVja1wiXG4gICAgY2FzZSBcIm1hdGhmcmFrXCI6XG4gICAgICByZXR1cm4gXCJmcmFrdHVyXCJcbiAgICBjYXNlIFwibWF0aHNjclwiOlxuICAgIGNhc2UgXCJtYXRoY2FsXCI6XG4gICAgICByZXR1cm4gXCJzY3JpcHRcIlxuICAgIGNhc2UgXCJtYXRoc2ZcIjpcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWZcIlxuICAgIGNhc2UgXCJtYXRoc2ZpdFwiOlxuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1pdGFsaWNcIlxuICAgIGNhc2UgXCJtYXRodHRcIjpcbiAgICAgIHJldHVybiBcIm1vbm9zcGFjZVwiXG4gIH1cblxuICBsZXQgdGV4dCA9IGdyb3VwLnRleHQ7XG4gIGlmIChzeW1ib2xzW21vZGVdW3RleHRdICYmIHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZSkge1xuICAgIHRleHQgPSBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2U7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvbnRNYXAsIGZvbnQpID8gZm9udE1hcFtmb250XSA6IG51bGxcbn07XG5cbi8vIENocm9taXVtIGRvZXMgbm90IHN1cHBvcnQgdGhlIE1hdGhNTCBgbWF0aHZhcmlhbnRgIGF0dHJpYnV0ZS5cbi8vIEluc3RlYWQsIHdlIHJlcGxhY2UgQVNDSUkgY2hhcmFjdGVycyB3aXRoIFVuaWNvZGUgY2hhcmFjdGVycyB0aGF0XG4vLyBhcmUgZGVmaW5lZCBpbiB0aGUgZm9udCBhcyBib2xkLCBpdGFsaWMsIGRvdWJsZS1zdHJ1Y2ssIGV0Yy5cbi8vIFRoaXMgbW9kdWxlIGlkZW50aWZpZXMgdGhvc2UgVW5pY29kZSBjb2RlIHBvaW50cy5cblxuLy8gRmlyc3QsIGEgZmV3IGhlbHBlcnMuXG5jb25zdCBzY3JpcHQgPSBPYmplY3QuZnJlZXplKHtcbiAgQjogMHgyMEVBLCAvLyBPZmZzZXQgZnJvbSBBU0NJSSBCIHRvIFVuaWNvZGUgc2NyaXB0IEJcbiAgRTogMHgyMEVCLFxuICBGOiAweDIwRUIsXG4gIEg6IDB4MjBDMyxcbiAgSTogMHgyMEM3LFxuICBMOiAweDIwQzYsXG4gIE06IDB4MjBFNixcbiAgUjogMHgyMEM5LFxuICBlOiAweDIwQ0EsXG4gIGc6IDB4MjBBMyxcbiAgbzogMHgyMEM1XG59KTtcblxuY29uc3QgZnJhayA9IE9iamVjdC5mcmVlemUoe1xuICBDOiAweDIwRUEsXG4gIEg6IDB4MjBDNCxcbiAgSTogMHgyMEM4LFxuICBSOiAweDIwQ0EsXG4gIFo6IDB4MjBDRVxufSk7XG5cbmNvbnN0IGJiYiA9IE9iamVjdC5mcmVlemUoe1xuICBDOiAweDIwQkYsIC8vIGJsYWNrYm9hcmQgYm9sZFxuICBIOiAweDIwQzUsXG4gIE46IDB4MjBDNyxcbiAgUDogMHgyMEM5LFxuICBROiAweDIwQzksXG4gIFI6IDB4MjBDQixcbiAgWjogMHgyMENBXG59KTtcblxuY29uc3QgYm9sZCA9IE9iamVjdC5mcmVlemUoe1xuICBcIlxcdTAzZjVcIjogMHgxRDJFNywgLy8gbHVuYXRlIGVwc2lsb25cbiAgXCJcXHUwM2QxXCI6IDB4MUQzMEMsIC8vIHZhcnRoZXRhXG4gIFwiXFx1MDNmMFwiOiAweDFEMkVFLCAvLyB2YXJrYXBwYVxuICBcIlxcdTAzYzZcIjogMHgxRDMxOSwgLy8gdmFycGhpXG4gIFwiXFx1MDNmMVwiOiAweDFEMkVGLCAvLyB2YXJyaG9cbiAgXCJcXHUwM2Q2XCI6IDB4MUQzMEIgIC8vIHZhcnBpXG59KTtcblxuY29uc3QgYm9sZEl0YWxpYyA9IE9iamVjdC5mcmVlemUoe1xuICBcIlxcdTAzZjVcIjogMHgxRDM1QiwgLy8gbHVuYXRlIGVwc2lsb25cbiAgXCJcXHUwM2QxXCI6IDB4MUQzODAsIC8vIHZhcnRoZXRhXG4gIFwiXFx1MDNmMFwiOiAweDFEMzYyLCAvLyB2YXJrYXBwYVxuICBcIlxcdTAzYzZcIjogMHgxRDM4RCwgLy8gdmFycGhpXG4gIFwiXFx1MDNmMVwiOiAweDFEMzYzLCAvLyB2YXJyaG9cbiAgXCJcXHUwM2Q2XCI6IDB4MUQzN0YgIC8vIHZhcnBpXG59KTtcblxuY29uc3QgYm9sZHNmID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFwiXFx1MDNmNVwiOiAweDFEMzk1LCAvLyBsdW5hdGUgZXBzaWxvblxuICBcIlxcdTAzZDFcIjogMHgxRDNCQSwgLy8gdmFydGhldGFcbiAgXCJcXHUwM2YwXCI6IDB4MUQzOUMsIC8vIHZhcmthcHBhXG4gIFwiXFx1MDNjNlwiOiAweDFEM0M3LCAvLyB2YXJwaGlcbiAgXCJcXHUwM2YxXCI6IDB4MUQzOUQsIC8vIHZhcnJob1xuICBcIlxcdTAzZDZcIjogMHgxRDNCOSAgLy8gdmFycGlcbn0pO1xuXG5jb25zdCBiaXNmID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFwiXFx1MDNmNVwiOiAweDFEM0NGLCAvLyBsdW5hdGUgZXBzaWxvblxuICBcIlxcdTAzZDFcIjogMHgxRDNGNCwgLy8gdmFydGhldGFcbiAgXCJcXHUwM2YwXCI6IDB4MUQzRDYsIC8vIHZhcmthcHBhXG4gIFwiXFx1MDNjNlwiOiAweDFENDAxLCAvLyB2YXJwaGlcbiAgXCJcXHUwM2YxXCI6IDB4MUQzRDcsIC8vIHZhcnJob1xuICBcIlxcdTAzZDZcIjogMHgxRDNGMyAgLy8gdmFycGlcbn0pO1xuXG4vLyBDb2RlIHBvaW50IG9mZnNldHMgYmVsb3cgYXJlIGRlcml2ZWQgZnJvbSBodHRwczovL3d3dy51bmljb2RlLm9yZy9jaGFydHMvUERGL1UxRDQwMC5wZGZcbmNvbnN0IG9mZnNldCA9IE9iamVjdC5mcmVlemUoe1xuICB1cHBlckNhc2VMYXRpbjogeyAvLyBBLVpcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEM0JGIH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzRjMgfSxcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMHgxRDQyNyB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiBzY3JpcHRbY2hdIHx8IDB4MUQ0NUIgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMHgxRDQ4RiB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiBmcmFrW2NoXSB8fCAweDFENEMzIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDB4MUQ1MkIgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gYmJiW2NoXSB8fCAweDFENEY3IH0sXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ1NUYgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDU5MyB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAweDFENUM3IH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDB4MUQ2M0MgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDYyRiB9XG4gIH0sXG4gIGxvd2VyQ2FzZUxhdGluOiB7IC8vIGEtelxuICAgIFwibm9ybWFsXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkXCI6IGNoID0+ICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzQjkgfSxcbiAgICBcIml0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gY2ggPT09IFwiaFwiID8gMHgyMEE2IDogMHgxRDNFRCB9LFxuICAgIFwiYm9sZC1pdGFsaWNcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAweDFENDIxIH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIHNjcmlwdFtjaF0gfHwgMHgxRDQ1NSB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAweDFENDg5IH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ0QkQgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMHgxRDUyNSB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAweDFENEYxIH0sXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ1NTkgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDU4RCB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAweDFENUMxIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDB4MUQ1RjUgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDYyOSB9XG4gIH0sXG4gIHVwcGVyQ2FzZUdyZWVrOiB7IC8vIEEtzqlcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEMzE3IH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzNTEgfSxcbiAgICAvLyBcXGJvbGRzeW1ib2wgYWN0dWFsbHkgcmV0dXJucyB1cHJpZ2h0IGJvbGQgZm9yIHVwcGVyQ2FzZUdyZWVrXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzMTcgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgLy8gVW5pY29kZSBoYXMgbm8gY29kZSBwb2ludHMgZm9yIHJlZ3VsYXItd2VpZ2h0IHNhbi1zZXJpZiBHcmVlay4gVXNlIGJvbGQuXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzQzUgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDNDNSB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDB4MUQzRkYgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMCB9XG4gIH0sXG4gIGxvd2VyQ2FzZUdyZWVrOiB7IC8vIM6xLc+JXG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDMxMSB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEMzRCIH0sXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIGNoID09PSBcIlxcdTAzZDVcIiA/IDB4MUQzN0UgOiAweDFEMzg1IH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIC8vIFVuaWNvZGUgaGFzIG5vIGNvZGUgcG9pbnRzIGZvciByZWd1bGFyLXdlaWdodCBzYW4tc2VyaWYgR3JlZWsuIFVzZSBib2xkLlxuICAgIFwic2Fucy1zZXJpZlwiOiBjaCA9PiAgICAgICAgICAgICB7IHJldHVybiAweDFEM0JGIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIDB4MUQzQkYgfSxcbiAgICBcInNhbnMtc2VyaWYtaXRhbGljXCI6IGNoID0+ICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiOiBjaCA9PiB7IHJldHVybiAweDFEM0Y5IH0sXG4gICAgXCJtb25vc3BhY2VcIjogY2ggPT4gICAgICAgICAgICAgIHsgcmV0dXJuIDAgfVxuICB9LFxuICB2YXJHcmVlazogeyAvLyBcXHZhckdhbW1hLCBldGNcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAgYm9sZFtjaF0gfHwgLTUxIH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gYm9sZEl0YWxpY1tjaF0gfHwgMHgzQSB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzY3JpcHQtYm9sZFwiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXJcIjogY2ggPT4gICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1ci1ib2xkXCI6IGNoID0+ICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJkb3VibGUtc3RydWNrXCI6IGNoID0+ICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNhbnMtc2VyaWZcIjogY2ggPT4gICAgICAgICAgICAgeyByZXR1cm4gYm9sZHNmW2NoXSB8fCAweDc0IH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIGJvbGRzZltjaF0gfHwgMHg3NCB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIGJpc2ZbY2hdIHx8IDB4QUUgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMCB9XG4gIH0sXG4gIG51bWVyYWw6IHsgLy8gMC05XG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDc5RSB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAweDFEN0E4IH0sXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ3QjIgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDdCQyB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDAgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDdDNiB9XG4gIH1cbn0pO1xuXG5jb25zdCB2YXJpYW50Q2hhciA9IChjaCwgdmFyaWFudCkgPT4ge1xuICBjb25zdCBjb2RlUG9pbnQgPSBjaC5jb2RlUG9pbnRBdCgwKTtcbiAgY29uc3QgYmxvY2sgPSAweDQwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4NWJcbiAgICA/IFwidXBwZXJDYXNlTGF0aW5cIlxuICAgIDogMHg2MCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDdiXG4gICAgPyBcImxvd2VyQ2FzZUxhdGluXCJcbiAgICA6ICgweDM5MCAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgzQUEpXG4gICAgPyBcInVwcGVyQ2FzZUdyZWVrXCJcbiAgICA6IDB4M0IwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4M0NBIHx8IGNoID09PSBcIlxcdTAzZDVcIlxuICAgID8gXCJsb3dlckNhc2VHcmVla1wiXG4gICAgOiAweDFENkUxIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MUQ2RkMgIHx8IGJvbGRbY2hdXG4gICAgPyBcInZhckdyZWVrXCJcbiAgICA6ICgweDJGIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8ICAweDNBKVxuICAgID8gXCJudW1lcmFsXCJcbiAgICA6IFwib3RoZXJcIjtcbiAgcmV0dXJuIGJsb2NrID09PSBcIm90aGVyXCJcbiAgICA/IGNoXG4gICAgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlUG9pbnQgKyBvZmZzZXRbYmxvY2tdW3ZhcmlhbnRdKGNoKSlcbn07XG5cbmNvbnN0IHNtYWxsQ2FwcyA9IE9iamVjdC5mcmVlemUoe1xuICBhOiBcIuG0gFwiLFxuICBiOiBcIsqZXCIsXG4gIGM6IFwi4bSEXCIsXG4gIGQ6IFwi4bSFXCIsXG4gIGU6IFwi4bSHXCIsXG4gIGY6IFwi6pywXCIsXG4gIGc6IFwiyaJcIixcbiAgaDogXCLKnFwiLFxuICBpOiBcIsmqXCIsXG4gIGo6IFwi4bSKXCIsXG4gIGs6IFwi4bSLXCIsXG4gIGw6IFwiyp9cIixcbiAgbTogXCLhtI1cIixcbiAgbjogXCLJtFwiLFxuICBvOiBcIuG0j1wiLFxuICBwOiBcIuG0mFwiLFxuICBxOiBcIserXCIsXG4gIHI6IFwiyoBcIixcbiAgczogXCJzXCIsXG4gIHQ6IFwi4bSbXCIsXG4gIHU6IFwi4bScXCIsXG4gIHY6IFwi4bSgXCIsXG4gIHc6IFwi4bShXCIsXG4gIHg6IFwieFwiLFxuICB5OiBcIsqPXCIsXG4gIHo6IFwi4bSiXCJcbn0pO1xuXG4vLyBcIm1hdGhvcmRcIiBhbmQgXCJ0ZXh0b3JkXCIgUGFyc2VOb2RlcyBjcmVhdGVkIGluIFBhcnNlci5qcyBmcm9tIHN5bWJvbCBHcm91cHMgaW5cbi8vIHNyYy9zeW1ib2xzLmpzLlxuXG5jb25zdCBudW1iZXJSZWdFeCA9IC9eXFxkKD86W1xcZCwuXSpcXGQpPyQvO1xuY29uc3QgbGF0aW5SZWdFeCA9IC9bQS1CYS16XS87XG5jb25zdCBwcmltZXMgPSBuZXcgU2V0KFtcIlxcXFxwcmltZVwiLCBcIlxcXFxkcHJpbWVcIiwgXCJcXFxcdHJwcmltZVwiLCBcIlxcXFxxcHJpbWVcIixcbiAgXCJcXFxcYmFja3ByaW1lXCIsIFwiXFxcXGJhY2tkcHJpbWVcIiwgXCJcXFxcYmFja3RycHJpbWVcIl0pO1xuXG5jb25zdCBpdGFsaWNOdW1iZXIgPSAodGV4dCwgdmFyaWFudCwgdGFnKSA9PiB7XG4gIGNvbnN0IG1uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUodGFnLCBbdGV4dF0pO1xuICBjb25zdCB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW21uXSk7XG4gIHdyYXBwZXIuc3R5bGVbXCJmb250LXN0eWxlXCJdID0gXCJpdGFsaWNcIjtcbiAgd3JhcHBlci5zdHlsZVtcImZvbnQtZmFtaWx5XCJdID0gXCJDYW1icmlhLCAnVGltZXMgTmV3IFJvbWFuJywgc2VyaWZcIjtcbiAgaWYgKHZhcmlhbnQgPT09IFwiYm9sZC1pdGFsaWNcIikgeyB3cmFwcGVyLnN0eWxlW1wiZm9udC13ZWlnaHRcIl0gPSBcImJvbGRcIjsgfVxuICByZXR1cm4gd3JhcHBlclxufTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwibWF0aG9yZFwiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IHRleHQgPSBtYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBzdHlsZSk7XG4gICAgY29uc3QgY29kZVBvaW50ID0gdGV4dC50ZXh0LmNvZGVQb2ludEF0KDApO1xuICAgIC8vIFRlc3QgZm9yIHVwcGVyLWNhc2UgR3JlZWtcbiAgICBjb25zdCBkZWZhdWx0VmFyaWFudCA9ICgweDAzOTAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgwM2FhKSA/IFwibm9ybWFsXCIgOiBcIml0YWxpY1wiO1xuICAgIGNvbnN0IHZhcmlhbnQgPSBnZXRWYXJpYW50KGdyb3VwLCBzdHlsZSkgfHwgZGVmYXVsdFZhcmlhbnQ7XG4gICAgaWYgKHZhcmlhbnQgPT09IFwic2NyaXB0XCIpIHtcbiAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBbdGV4dF0sIFtzdHlsZS5mb250XSlcbiAgICB9IGVsc2UgaWYgKHZhcmlhbnQgIT09IFwiaXRhbGljXCIpIHtcbiAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBbdGV4dF0pO1xuICAgIC8vIFRPRE86IEhhbmRsZSBVKzFENDlDIC0gVSsxRDRDRiBwZXIgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG4gICAgaWYgKHZhcmlhbnQgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJub3JtYWxcIik7XG4gICAgICBpZiAodGV4dC50ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBBIEZpcmVmb3ggYnVnIHdpbGwgYXBwbHkgc3BhY2luZyBoZXJlLCBidXQgdGhlcmUgc2hvdWxkIGJlIG5vbmUuIEZpeCBpdC5cbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbbm9kZV0pO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjBcIik7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInRleHRvcmRcIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBsZXQgY2ggPSBncm91cC50ZXh0O1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoLmNvZGVQb2ludEF0KDApO1xuICAgIGlmIChzdHlsZS5mb250RmFtaWx5ID09PSBcInRleHRzY1wiKSB7XG4gICAgICAvLyBDb252ZXJ0IHNtYWxsIGxhdGluIGxldHRlcnMgdG8gc21hbGwgY2Fwcy5cbiAgICAgIGlmICg5NiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAxMjMpIHtcbiAgICAgICAgY2ggPSBzbWFsbENhcHNbY2hdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gbWFrZVRleHQoY2gsIGdyb3VwLm1vZGUsIHN0eWxlKTtcbiAgICBjb25zdCB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgc3R5bGUpIHx8IFwibm9ybWFsXCI7XG5cbiAgICBsZXQgbm9kZTtcbiAgICBpZiAobnVtYmVyUmVnRXgudGVzdChncm91cC50ZXh0KSkge1xuICAgICAgY29uc3QgdGFnID0gZ3JvdXAubW9kZSA9PT0gXCJ0ZXh0XCIgPyBcIm10ZXh0XCIgOiBcIm1uXCI7XG4gICAgICBpZiAodmFyaWFudCA9PT0gXCJpdGFsaWNcIiB8fCB2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0YWxpY051bWJlcih0ZXh0LCB2YXJpYW50LCB0YWcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFyaWFudCAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIHRleHQudGV4dCA9IHRleHQudGV4dC5zcGxpdChcIlwiKS5tYXAoYyA9PiB2YXJpYW50Q2hhcihjLCB2YXJpYW50KSkuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUodGFnLCBbdGV4dF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmICh2YXJpYW50ICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIH0gZWxzZSBpZiAocHJpbWVzLmhhcyhncm91cC50ZXh0KSkge1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHRdKTtcbiAgICAgIC8vIFRPRE86IElmL3doZW4gQ2hyb21pdW0gdXNlcyBzc3R5IHZhcmlhbnQgZm9yIHByaW1lLCByZW1vdmUgdGhlIG5leHQgbGluZS5cbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLXByaW1lXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcmlnVGV4dCA9IHRleHQudGV4dDtcbiAgICAgIGlmICh2YXJpYW50ICE9PSBcIml0YWxpY1wiKSB7XG4gICAgICAgIHRleHQudGV4dCA9IHZhcmlhbnRDaGFyKHRleHQudGV4dCwgdmFyaWFudCk7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBbdGV4dF0pO1xuICAgICAgaWYgKHRleHQudGV4dCA9PT0gb3JpZ1RleHQgJiYgbGF0aW5SZWdFeC50ZXN0KG9yaWdUZXh0KSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwiaXRhbGljXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gQSBtYXAgb2YgQ1NTLWJhc2VkIHNwYWNpbmcgZnVuY3Rpb25zIHRvIHRoZWlyIENTUyBjbGFzcy5cbmNvbnN0IGNzc1NwYWNlID0ge1xuICBcIlxcXFxub2JyZWFrXCI6IFwibm9icmVha1wiLFxuICBcIlxcXFxhbGxvd2JyZWFrXCI6IFwiYWxsb3dicmVha1wiXG59O1xuXG4vLyBBIGxvb2t1cCB0YWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNwYWNpbmcgZnVuY3Rpb24vc3ltYm9sIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBsaWtlIGEgcmVndWxhciBzcGFjZSBjaGFyYWN0ZXIuICBJZiBhIHN5bWJvbCBvciBjb21tYW5kIGlzIGEga2V5XG4vLyBpbiB0aGlzIHRhYmxlLCB0aGVuIGl0IHNob3VsZCBiZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgRnVydGhlcm1vcmUsXG4vLyB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBtYXkgaGF2ZSBhIGBjbGFzc05hbWVgIHNwZWNpZnlpbmcgYW4gZXh0cmEgQ1NTIGNsYXNzXG4vLyB0byBhZGQgdG8gdGhlIGNyZWF0ZWQgYHNwYW5gLlxuY29uc3QgcmVndWxhclNwYWNlID0ge1xuICBcIiBcIjoge30sXG4gIFwiXFxcXCBcIjoge30sXG4gIFwiflwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9LFxuICBcIlxcXFxzcGFjZVwiOiB7fSxcbiAgXCJcXFxcbm9icmVha3NwYWNlXCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH1cbn07XG5cbi8vIFBhcnNlTm9kZTxcInNwYWNpbmdcIj4gY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSB0aGUgXCJzcGFjaW5nXCIgc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJzcGFjaW5nXCIsXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZ3VsYXJTcGFjZSwgZ3JvdXAudGV4dCkpIHtcbiAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgcmVuZGVyIGEgc3BhY2UgaW4gYSA8bXRleHQ+IDwvbXRleHQ+LiBTbyB3cml0ZSBhIG5vLWJyZWFrIHNwYWNlLlxuICAgICAgLy8gVE9ETzogSWYgRmlyZWZveCBmaXhlcyB0aGF0IGJ1ZywgdW5jb21tZW50IHRoZSBuZXh0IGxpbmUgYW5kIHdyaXRlIGNoIGludG8gdGhlIG5vZGUuXG4gICAgICAvL2NvbnN0IGNoID0gKHJlZ3VsYXJTcGFjZVtncm91cC50ZXh0XS5jbGFzc05hbWUgPT09IFwibm9icmVha1wiKSA/IFwiXFx1MDBhMFwiIDogXCIgXCJcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTAwYTBcIildKTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjc3NTcGFjZSwgZ3JvdXAudGV4dCkpIHtcbiAgICAgIC8vIE1hdGhNTCAzLjAgY2FsbHMgZm9yIG5vYnJlYWsgdG8gb2NjdXIgaW4gYW4gPG1vPiwgbm90IGFuIDxtdGV4dD5cbiAgICAgIC8vIFJlZjogaHR0cHM6Ly93d3cudzMub3JnL01hdGgvZHJhZnQtc3BlYy9tYXRobWwuaHRtbCNjaGFwdGVyM19wcmVzbS5sYmF0dHJzXG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiKTtcbiAgICAgIGlmIChncm91cC50ZXh0ID09PSBcIlxcXFxub2JyZWFrXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5lYnJlYWtcIiwgXCJub2JyZWFrXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVW5rbm93biB0eXBlIG9mIHNwYWNlIFwiJHtncm91cC50ZXh0fVwiYClcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwidGFnXCJcbn0pO1xuXG4vLyBGb3IgYSBcXHRhZywgdGhlIHdvcmsgdXN1YWxseSBkb25lIGluIGEgbWF0aG1sQnVpbGRlciBpcyBpbnN0ZWFkIGRvbmUgaW4gYnVpbGRNYXRoTUwuanMuXG4vLyBUaGF0IHdheSwgYSBcXHRhZyBjYW4gYmUgcHVsbGVkIG91dCBvZiB0aGUgcGFyc2UgdHJlZSBhbmQgd3JhcHBlZCBhcm91bmQgdGhlIG91dGVyIG5vZGUuXG5cbi8vIE5vbi1tYXRoeSB0ZXh0LCBwb3NzaWJseSBpbiBhIGZvbnRcbmNvbnN0IHRleHRGb250RmFtaWxpZXMgPSB7XG4gIFwiXFxcXHRleHRcIjogdW5kZWZpbmVkLFxuICBcIlxcXFx0ZXh0cm1cIjogXCJ0ZXh0cm1cIixcbiAgXCJcXFxcdGV4dHNmXCI6IFwidGV4dHNmXCIsXG4gIFwiXFxcXHRleHR0dFwiOiBcInRleHR0dFwiLFxuICBcIlxcXFx0ZXh0bm9ybWFsXCI6IFwidGV4dHJtXCIsXG4gIFwiXFxcXHRleHRzY1wiOiBcInRleHRzY1wiICAgICAgLy8gc21hbGwgY2Fwc1xufTtcblxuY29uc3QgdGV4dEZvbnRXZWlnaHRzID0ge1xuICBcIlxcXFx0ZXh0YmZcIjogXCJ0ZXh0YmZcIixcbiAgXCJcXFxcdGV4dG1kXCI6IFwidGV4dG1kXCJcbn07XG5cbmNvbnN0IHRleHRGb250U2hhcGVzID0ge1xuICBcIlxcXFx0ZXh0aXRcIjogXCJ0ZXh0aXRcIixcbiAgXCJcXFxcdGV4dHVwXCI6IFwidGV4dHVwXCJcbn07XG5cbmNvbnN0IHN0eWxlV2l0aEZvbnQgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGZvbnQgPSBncm91cC5mb250O1xuICAvLyBDaGVja3MgaWYgdGhlIGFyZ3VtZW50IGlzIGEgZm9udCBmYW1pbHkgb3IgYSBmb250IHN0eWxlLlxuICBpZiAoIWZvbnQpIHtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0gZWxzZSBpZiAodGV4dEZvbnRGYW1pbGllc1tmb250XSkge1xuICAgIHJldHVybiBzdHlsZS53aXRoVGV4dEZvbnRGYW1pbHkodGV4dEZvbnRGYW1pbGllc1tmb250XSk7XG4gIH0gZWxzZSBpZiAodGV4dEZvbnRXZWlnaHRzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIHN0eWxlLndpdGhUZXh0Rm9udFdlaWdodCh0ZXh0Rm9udFdlaWdodHNbZm9udF0pO1xuICB9IGVsc2UgaWYgKGZvbnQgPT09IFwiXFxcXGVtcGhcIikge1xuICAgIHJldHVybiBzdHlsZS5mb250U2hhcGUgPT09IFwidGV4dGl0XCJcbiAgICAgID8gc3R5bGUud2l0aFRleHRGb250U2hhcGUoXCJ0ZXh0dXBcIilcbiAgICAgIDogc3R5bGUud2l0aFRleHRGb250U2hhcGUoXCJ0ZXh0aXRcIilcbiAgfVxuICByZXR1cm4gc3R5bGUud2l0aFRleHRGb250U2hhcGUodGV4dEZvbnRTaGFwZXNbZm9udF0pXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLFxuICBuYW1lczogW1xuICAgIC8vIEZvbnQgZmFtaWxpZXNcbiAgICBcIlxcXFx0ZXh0XCIsXG4gICAgXCJcXFxcdGV4dHJtXCIsXG4gICAgXCJcXFxcdGV4dHNmXCIsXG4gICAgXCJcXFxcdGV4dHR0XCIsXG4gICAgXCJcXFxcdGV4dG5vcm1hbFwiLFxuICAgIFwiXFxcXHRleHRzY1wiLFxuICAgIC8vIEZvbnQgd2VpZ2h0c1xuICAgIFwiXFxcXHRleHRiZlwiLFxuICAgIFwiXFxcXHRleHRtZFwiLFxuICAgIC8vIEZvbnQgU2hhcGVzXG4gICAgXCJcXFxcdGV4dGl0XCIsXG4gICAgXCJcXFxcdGV4dHVwXCIsXG4gICAgXCJcXFxcZW1waFwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgZm9udDogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGVXaXRoRm9udChncm91cCwgc3R5bGUpO1xuICAgIGNvbnN0IG1yb3cgPSBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgbmV3U3R5bGUpO1xuICAgIHJldHVybiBjb25zb2xpZGF0ZVRleHQobXJvdylcbiAgfVxufSk7XG5cbi8vIFxcdmNlbnRlcjogIFZlcnRpY2FsbHkgY2VudGVyIHRoZSBhcmd1bWVudCBncm91cCBvbiB0aGUgbWF0aCBheGlzLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmNlbnRlclwiLFxuICBuYW1lczogW1wiXFxcXHZjZW50ZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidmNlbnRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBhcmdzWzBdXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBVc2UgYSBtYXRoIHRhYmxlIHRvIGNyZWF0ZSB2ZXJ0aWNhbGx5IGNlbnRlcmVkIGNvbnRlbnQuXG4gICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSldKTtcbiAgICBtdGQuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xuICAgIGNvbnN0IG10ciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFttdGRdKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgW210cl0pXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidmVyYlwiLFxuICBuYW1lczogW1wiXFxcXHZlcmJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncykge1xuICAgIC8vIFxcdmVyYiBhbmQgXFx2ZXJiKiBhcmUgZGVhbHQgd2l0aCBkaXJlY3RseSBpbiBQYXJzZXIuanMuXG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl0J3MgYmVjYXVzZSBvZiBhIGZhaWx1cmUgdG8gbWF0Y2ggdGhlIHR3byBkZWxpbWl0ZXJzXG4gICAgLy8gaW4gdGhlIHJlZ2V4IGluIExleGVyLmpzLiAgTGFUZVggcmFpc2VzIHRoZSBmb2xsb3dpbmcgZXJyb3Igd2hlbiBcXHZlcmIgaXNcbiAgICAvLyB0ZXJtaW5hdGVkIGJ5IGVuZCBvZiBsaW5lIChvciBmaWxlKS5cbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFx2ZXJiIGVuZGVkIGJ5IGVuZCBvZiBsaW5lIGluc3RlYWQgb2YgbWF0Y2hpbmcgZGVsaW1pdGVyXCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShtYWtlVmVyYihncm91cCkpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFt0ZXh0XSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm1vbm9zcGFjZVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ29udmVydHMgdmVyYiBncm91cCBpbnRvIGJvZHkgc3RyaW5nLlxuICpcbiAqIFxcdmVyYiogcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGFuIG9wZW4gYm94IFxcdTI0MjNcbiAqIFxcdmVyYiByZXBsYWNlcyBlYWNoIHNwYWNlIHdpdGggYSBuby1icmVhayBzcGFjZSBcXHhBMFxuICovXG5jb25zdCBtYWtlVmVyYiA9IChncm91cCkgPT4gZ3JvdXAuYm9keS5yZXBsYWNlKC8gL2csIGdyb3VwLnN0YXIgPyBcIlxcdTI0MjNcIiA6IFwiXFx4QTBcIik7XG5cbi8qKiBJbmNsdWRlIHRoaXMgdG8gZW5zdXJlIHRoYXQgYWxsIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZC4gKi9cblxuY29uc3QgZnVuY3Rpb25zID0gX2Z1bmN0aW9ucztcblxuLyoqXG4gKiBUaGUgTGV4ZXIgY2xhc3MgaGFuZGxlcyB0b2tlbml6aW5nIHRoZSBpbnB1dCBpbiB2YXJpb3VzIHdheXMuIFNpbmNlIG91clxuICogcGFyc2VyIGV4cGVjdHMgdXMgdG8gYmUgYWJsZSB0byBiYWNrdHJhY2ssIHRoZSBsZXhlciBhbGxvd3MgbGV4aW5nIGZyb20gYW55XG4gKiBnaXZlbiBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBJdHMgbWFpbiBleHBvc2VkIGZ1bmN0aW9uIGlzIHRoZSBgbGV4YCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwb3NpdGlvbiB0b1xuICogbGV4IGZyb20gYW5kIGEgdHlwZSBvZiB0b2tlbiB0byBsZXguIEl0IGRlZmVycyB0byB0aGUgYXBwcm9wcmlhdGUgYF9pbm5lckxleGBcbiAqIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSB2YXJpb3VzIGBfaW5uZXJMZXhgIGZ1bmN0aW9ucyBwZXJmb3JtIHRoZSBhY3R1YWwgbGV4aW5nIG9mIGRpZmZlcmVudFxuICoga2luZHMuXG4gKi9cblxuXG4vKiBUaGUgZm9sbG93aW5nIHRva2VuUmVnZXhcbiAqIC0gbWF0Y2hlcyB0eXBpY2FsIHdoaXRlc3BhY2UgKGJ1dCBub3QgTkJTUCBldGMuKSB1c2luZyBpdHMgZmlyc3QgdHdvIGdyb3Vwc1xuICogLSBkb2VzIG5vdCBtYXRjaCBhbnkgY29udHJvbCBjaGFyYWN0ZXIgXFx4MDAtXFx4MWYgZXhjZXB0IHdoaXRlc3BhY2VcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYSBiYXJlIGJhY2tzbGFzaFxuICogLSBtYXRjaGVzIGFueSBBU0NJSSBjaGFyYWN0ZXIgZXhjZXB0IHRob3NlIGp1c3QgbWVudGlvbmVkXG4gKiAtIGRvZXMgbm90IG1hdGNoIHRoZSBCTVAgcHJpdmF0ZSB1c2UgYXJlYSBcXHVFMDAwLVxcdUY4RkZcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYmFyZSBzdXJyb2dhdGUgY29kZSB1bml0c1xuICogLSBtYXRjaGVzIGFueSBCTVAgY2hhcmFjdGVyIGV4Y2VwdCBmb3IgdGhvc2UganVzdCBkZXNjcmliZWRcbiAqIC0gbWF0Y2hlcyBhbnkgdmFsaWQgVW5pY29kZSBzdXJyb2dhdGUgcGFpclxuICogLSBtYXRoY2hlcyBudW1lcmFsc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IG9uZSBvciBtb3JlIGxldHRlcnMgdGhlbiB3aGl0ZXNwYWNlXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgYW55IEJNUCBjaGFyYWN0ZXJcbiAqIENhcHR1cmluZyBncm91cHM6XG4gKiAgIFsxXSByZWd1bGFyIHdoaXRlc3BhY2VcbiAqICAgWzJdIGJhY2tzbGFzaCBmb2xsb3dlZCBieSB3aGl0ZXNwYWNlXG4gKiAgIFszXSBhbnl0aGluZyBlbHNlLCB3aGljaCBtYXkgaW5jbHVkZTpcbiAqICAgICBbNF0gbGVmdCBjaGFyYWN0ZXIgb2YgXFx2ZXJiKlxuICogICAgIFs1XSBsZWZ0IGNoYXJhY3RlciBvZiBcXHZlcmJcbiAqICAgICBbNl0gYmFja3NsYXNoIGZvbGxvd2VkIGJ5IHdvcmQsIGV4Y2x1ZGluZyBhbnkgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICogSnVzdCBiZWNhdXNlIHRoZSBMZXhlciBtYXRjaGVzIHNvbWV0aGluZyBkb2Vzbid0IG1lYW4gaXQncyB2YWxpZCBpbnB1dDpcbiAqIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGZ1bmN0aW9uIG9yIHN5bWJvbCBkZWZpbml0aW9uLCB0aGUgUGFyc2VyIHdpbGxcbiAqIHN0aWxsIHJlamVjdCB0aGUgaW5wdXQuXG4gKi9cbmNvbnN0IHNwYWNlUmVnZXhTdHJpbmcgPSBcIlsgXFxyXFxuXFx0XVwiO1xuY29uc3QgY29udHJvbFdvcmRSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbYS16QS1aQF0rXCI7XG5jb25zdCBjb250cm9sU3ltYm9sUmVnZXhTdHJpbmcgPSBcIlxcXFxcXFxcW15cXHVEODAwLVxcdURGRkZdXCI7XG5jb25zdCBjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleFN0cmluZyA9IGAoJHtjb250cm9sV29yZFJlZ2V4U3RyaW5nfSkke3NwYWNlUmVnZXhTdHJpbmd9KmA7XG5jb25zdCBjb250cm9sU3BhY2VSZWdleFN0cmluZyA9IFwiXFxcXFxcXFwoXFxufFsgXFxyXFx0XStcXG4/KVsgXFxyXFx0XSpcIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyA9IFwiW1xcdTAzMDAtXFx1MDM2Zl1cIjtcbmNvbnN0IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleCA9IG5ldyBSZWdFeHAoYCR7Y29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nfSskYCk7XG5jb25zdCB0b2tlblJlZ2V4U3RyaW5nID1cbiAgYCgke3NwYWNlUmVnZXhTdHJpbmd9Kyl8YCArIC8vIHdoaXRlc3BhY2VcbiAgYCR7Y29udHJvbFNwYWNlUmVnZXhTdHJpbmd9fGAgKyAgLy8gd2hpdGVzcGFjZVxuICBcIihbIS1cXFxcW1xcXFxdLVxcdTIwMjdcXHUyMDJBLVxcdUQ3RkZcXHVGOTAwLVxcdUZGRkZdXCIgKyAvLyBzaW5nbGUgY29kZXBvaW50XG4gIGAke2NvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZ30qYCArIC8vIC4uLnBsdXMgYWNjZW50c1xuICBcInxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdXCIgKyAvLyBzdXJyb2dhdGUgcGFpclxuICBgJHtjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmd9KmAgKyAvLyAuLi5wbHVzIGFjY2VudHNcbiAgXCJ8XFxcXFxcXFx2ZXJiXFxcXCooW15dKS4qP1xcXFw0XCIgKyAvLyBcXHZlcmIqXG4gIFwifFxcXFxcXFxcdmVyYihbXiphLXpBLVpdKS4qP1xcXFw1XCIgKyAvLyBcXHZlcmIgdW5zdGFycmVkXG4gIGB8JHtjb250cm9sV29yZFdoaXRlc3BhY2VSZWdleFN0cmluZ31gICsgLy8gXFxtYWNyb05hbWUgKyBzcGFjZXNcbiAgYHwke2NvbnRyb2xTeW1ib2xSZWdleFN0cmluZ30pYDsgLy8gXFxcXCwgXFwnLCBldGMuXG5cbi8qKiBNYWluIExleGVyIGNsYXNzICovXG5jbGFzcyBMZXhlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncykge1xuICAgIC8vIFNlcGFyYXRlIGFjY2VudHMgZnJvbSBjaGFyYWN0ZXJzXG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLnRva2VuUmVnZXggPSBuZXcgUmVnRXhwKHRva2VuUmVnZXhTdHJpbmcsICdnJyk7XG4gICAgLy8gQ2F0ZWdvcnkgY29kZXMuIFRoZSBsZXhlciBvbmx5IHN1cHBvcnRzIGNvbW1lbnQgY2hhcmFjdGVycyAoMTQpIGZvciBub3cuXG4gICAgLy8gTWFjcm9FeHBhbmRlciBhZGRpdGlvbmFsbHkgZGlzdGluZ3Vpc2hlcyBhY3RpdmUgKDEzKS5cbiAgICB0aGlzLmNhdGNvZGVzID0ge1xuICAgICAgXCIlXCI6IDE0LCAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgICAgXCJ+XCI6IDEzICAvLyBhY3RpdmUgY2hhcmFjdGVyXG4gICAgfTtcbiAgfVxuXG4gIHNldENhdGNvZGUoY2hhciwgY29kZSkge1xuICAgIHRoaXMuY2F0Y29kZXNbY2hhcl0gPSBjb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gbGV4ZXMgYSBzaW5nbGUgdG9rZW4uXG4gICAqL1xuICBsZXgoKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmlucHV0O1xuICAgIGNvbnN0IHBvcyA9IHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXg7XG4gICAgaWYgKHBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFRva2VuKFwiRU9GXCIsIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHBvcykpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHRoaXMudG9rZW5SZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2guaW5kZXggIT09IHBvcykge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogJyR7aW5wdXRbcG9zXX0nYCxcbiAgICAgICAgbmV3IFRva2VuKGlucHV0W3Bvc10sIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHBvcyArIDEpKVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IG1hdGNoWzZdIHx8IG1hdGNoWzNdIHx8IChtYXRjaFsyXSA/IFwiXFxcXCBcIiA6IFwiIFwiKTtcblxuICAgIGlmICh0aGlzLmNhdGNvZGVzW3RleHRdID09PSAxNCkge1xuICAgICAgLy8gY29tbWVudCBjaGFyYWN0ZXJcbiAgICAgIGNvbnN0IG5sSW5kZXggPSBpbnB1dC5pbmRleE9mKFwiXFxuXCIsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpO1xuICAgICAgaWYgKG5sSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBpbnB1dC5sZW5ndGg7IC8vIEVPRlxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIiUgY29tbWVudCBoYXMgbm8gdGVybWluYXRpbmcgbmV3bGluZTsgTGFUZVggd291bGQgXCIgK1xuICAgICAgICAgICAgICBcImZhaWwgYmVjYXVzZSBvZiBjb21tZW50aW5nIHRoZSBlbmQgb2YgbWF0aCBtb2RlXCIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBubEluZGV4ICsgMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCkpO1xuICB9XG59XG5cbi8qKlxuICogQSBgTmFtZXNwYWNlYCByZWZlcnMgdG8gYSBzcGFjZSBvZiBuYW1lYWJsZSB0aGluZ3MgbGlrZSBtYWNyb3Mgb3IgbGVuZ3RocyxcbiAqIHdoaWNoIGNhbiBiZSBgc2V0YCBlaXRoZXIgZ2xvYmFsbHkgb3IgbG9jYWwgdG8gYSBuZXN0ZWQgZ3JvdXAsIHVzaW5nIGFuXG4gKiB1bmRvIHN0YWNrIHNpbWlsYXIgdG8gaG93IFRlWCBpbXBsZW1lbnRzIHRoaXMgZnVuY3Rpb25hbGl0eS5cbiAqIFBlcmZvcm1hbmNlLXdpc2UsIGBnZXRgIGFuZCBsb2NhbCBgc2V0YCB0YWtlIGNvbnN0YW50IHRpbWUsIHdoaWxlIGdsb2JhbFxuICogYHNldGAgdGFrZXMgdGltZSBwcm9wb3J0aW9uYWwgdG8gdGhlIGRlcHRoIG9mIGdyb3VwIG5lc3RpbmcuXG4gKi9cblxuXG5jbGFzcyBOYW1lc3BhY2Uge1xuICAvKipcbiAgICogQm90aCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiAgVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvZlxuICAgKiBidWlsdC1pbiBtYXBwaW5ncyB3aGljaCBuZXZlciBjaGFuZ2UuICBUaGUgc2Vjb25kIGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICAgKiBvZiBpbml0aWFsIChnbG9iYWwtbGV2ZWwpIG1hcHBpbmdzLCB3aGljaCB3aWxsIGNvbnN0YW50bHkgY2hhbmdlXG4gICAqIGFjY29yZGluZyB0byBhbnkgZ2xvYmFsL3RvcC1sZXZlbCBgc2V0YHMgZG9uZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJ1aWx0aW5zID0ge30sIGdsb2JhbE1hY3JvcyA9IHt9KSB7XG4gICAgdGhpcy5jdXJyZW50ID0gZ2xvYmFsTWFjcm9zO1xuICAgIHRoaXMuYnVpbHRpbnMgPSBidWlsdGlucztcbiAgICB0aGlzLnVuZGVmU3RhY2sgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBuZXN0ZWQgZ3JvdXAsIGFmZmVjdGluZyBmdXR1cmUgbG9jYWwgYHNldGBzLlxuICAgKi9cbiAgYmVnaW5Hcm91cCgpIHtcbiAgICB0aGlzLnVuZGVmU3RhY2sucHVzaCh7fSk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIGN1cnJlbnQgbmVzdGVkIGdyb3VwLCByZXN0b3JpbmcgdmFsdWVzIGJlZm9yZSB0aGUgZ3JvdXAgYmVnYW4uXG4gICAqL1xuICBlbmRHcm91cCgpIHtcbiAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIFwiVW5iYWxhbmNlZCBuYW1lc3BhY2UgZGVzdHJ1Y3Rpb246IGF0dGVtcHQgXCIgK1xuICAgICAgICAgIFwidG8gcG9wIGdsb2JhbCBuYW1lc3BhY2U7IHBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1Z1wiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1bmRlZnMgPSB0aGlzLnVuZGVmU3RhY2sucG9wKCk7XG4gICAgZm9yIChjb25zdCB1bmRlZiBpbiB1bmRlZnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodW5kZWZzLCB1bmRlZiApKSB7XG4gICAgICAgIGlmICh1bmRlZnNbdW5kZWZdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50W3VuZGVmXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRbdW5kZWZdID0gdW5kZWZzW3VuZGVmXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3Qgd2hldGhlciBgbmFtZWAgaGFzIGEgZGVmaW5pdGlvbi4gIEVxdWl2YWxlbnQgdG9cbiAgICogYGdldChuYW1lKSAhPSBudWxsYC5cbiAgICovXG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1cnJlbnQsIG5hbWUgKSB8fFxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJ1aWx0aW5zLCBuYW1lICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgbmFtZSwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gdmFsdWUuXG4gICAqXG4gICAqIE5vdGU6IERvIG5vdCB1c2UgYGlmIChuYW1lc3BhY2UuZ2V0KC4uLikpYCB0byBkZXRlY3Qgd2hldGhlciBhIG1hY3JvXG4gICAqIGlzIGRlZmluZWQsIGFzIHRoZSBkZWZpbml0aW9uIG1heSBiZSB0aGUgZW1wdHkgc3RyaW5nIHdoaWNoIGV2YWx1YXRlc1xuICAgKiB0byBgZmFsc2VgIGluIEphdmFTY3JpcHQuICBVc2UgYGlmIChuYW1lc3BhY2UuZ2V0KC4uLikgIT0gbnVsbClgIG9yXG4gICAqIGBpZiAobmFtZXNwYWNlLmhhcyguLi4pKWAuXG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJyZW50LCBuYW1lICkpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1aWx0aW5zW25hbWVdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBhbmQgb3B0aW9uYWxseSBzZXQgaXQgZ2xvYmFsbHkgdG9vLlxuICAgKiBMb2NhbCBzZXQoKSBzZXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCAod2hlbiBhcHByb3ByaWF0ZSkgYWRkcyBhbiB1bmRvXG4gICAqIG9wZXJhdGlvbiB0byB0aGUgdW5kbyBzdGFjay4gIEdsb2JhbCBzZXQoKSBtYXkgY2hhbmdlIHRoZSB1bmRvXG4gICAqIG9wZXJhdGlvbiBhdCBldmVyeSBsZXZlbCwgc28gdGFrZXMgdGltZSBsaW5lYXIgaW4gdGhlaXIgbnVtYmVyLlxuICAgKi9cbiAgc2V0KG5hbWUsIHZhbHVlLCBnbG9iYWwgPSBmYWxzZSkge1xuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIC8vIEdsb2JhbCBzZXQgaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIGluIGFsbCBncm91cHMuICBTaW11bGF0ZSB0aGlzXG4gICAgICAvLyBieSBkZXN0cm95aW5nIGFueSB1bmRvcyBjdXJyZW50bHkgc2NoZWR1bGVkIGZvciB0aGlzIG5hbWUsXG4gICAgICAvLyBhbmQgYWRkaW5nIGFuIHVuZG8gd2l0aCB0aGUgKm5ldyogdmFsdWUgKGluIGNhc2UgaXQgbGF0ZXIgZ2V0c1xuICAgICAgLy8gbG9jYWxseSByZXNldCB3aXRoaW4gdGhpcyBlbnZpcm9ubWVudCkuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudW5kZWZTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhpcy51bmRlZlN0YWNrW2ldW25hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudW5kZWZTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMudW5kZWZTdGFja1t0aGlzLnVuZGVmU3RhY2subGVuZ3RoIC0gMV1bbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5kbyB0aGlzIHNldCBhdCBlbmQgb2YgdGhpcyBncm91cCAocG9zc2libHkgdG8gYHVuZGVmaW5lZGApLFxuICAgICAgLy8gdW5sZXNzIGFuIHVuZG8gaXMgYWxyZWFkeSBpbiBwbGFjZSwgaW4gd2hpY2ggY2FzZSB0aGF0IG9sZGVyXG4gICAgICAvLyB2YWx1ZSBpcyB0aGUgY29ycmVjdCBvbmUuXG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnVuZGVmU3RhY2tbdGhpcy51bmRlZlN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKHRvcCAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvcCwgbmFtZSApKSB7XG4gICAgICAgIHRvcFtuYW1lXSA9IHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50W25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIOKAnGd1bGxldOKAnSB3aGVyZSBtYWNyb3MgYXJlIGV4cGFuZGVkXG4gKiB1bnRpbCBvbmx5IG5vbi1tYWNybyB0b2tlbnMgcmVtYWluLlxuICovXG5cblxuLy8gTGlzdCBvZiBjb21tYW5kcyB0aGF0IGFjdCBsaWtlIG1hY3JvcyBidXQgYXJlbid0IGRlZmluZWQgYXMgYSBtYWNybyxcbi8vIGZ1bmN0aW9uLCBvciBzeW1ib2wuICBVc2VkIGluIGBpc0RlZmluZWRgLlxuY29uc3QgaW1wbGljaXRDb21tYW5kcyA9IHtcbiAgXCJeXCI6IHRydWUsIC8vIFBhcnNlci5qc1xuICBfOiB0cnVlLCAvLyBQYXJzZXIuanNcbiAgXCJcXFxcbGltaXRzXCI6IHRydWUsIC8vIFBhcnNlci5qc1xuICBcIlxcXFxub2xpbWl0c1wiOiB0cnVlIC8vIFBhcnNlci5qc1xufTtcblxuY2xhc3MgTWFjcm9FeHBhbmRlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncywgbW9kZSkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ID0gMDtcbiAgICB0aGlzLmZlZWQoaW5wdXQpO1xuICAgIC8vIE1ha2UgbmV3IGdsb2JhbCBuYW1lc3BhY2VcbiAgICB0aGlzLm1hY3JvcyA9IG5ldyBOYW1lc3BhY2UobWFjcm9zLCBzZXR0aW5ncy5tYWNyb3MpO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICB9XG5cbiAgLyoqXG4gICAqIEZlZWQgYSBuZXcgaW5wdXQgc3RyaW5nIHRvIHRoZSBzYW1lIE1hY3JvRXhwYW5kZXJcbiAgICogKHdpdGggZXhpc3RpbmcgbWFjcm9zIGV0Yy4pLlxuICAgKi9cbiAgZmVlZChpbnB1dCkge1xuICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIoaW5wdXQsIHRoaXMuc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cbiAgc3dpdGNoTW9kZShuZXdNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIG5ldyBncm91cCBuZXN0aW5nIHdpdGhpbiBhbGwgbmFtZXNwYWNlcy5cbiAgICovXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuYmVnaW5Hcm91cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBjdXJyZW50IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cbiAgZW5kR3JvdXAoKSB7XG4gICAgdGhpcy5tYWNyb3MuZW5kR3JvdXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b3Btb3N0IHRva2VuIG9uIHRoZSBzdGFjaywgd2l0aG91dCBleHBhbmRpbmcgaXQuXG4gICAqIFNpbWlsYXIgaW4gYmVoYXZpb3IgdG8gVGVYJ3MgYFxcZnV0dXJlbGV0YC5cbiAgICovXG4gIGZ1dHVyZSgpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKHRoaXMubGV4ZXIubGV4KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIG5leHQgdW5leHBhbmRlZCB0b2tlbi5cbiAgICovXG4gIHBvcFRva2VuKCkge1xuICAgIHRoaXMuZnV0dXJlKCk7IC8vIGVuc3VyZSBub24tZW1wdHkgc3RhY2tcbiAgICByZXR1cm4gdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBnaXZlbiB0b2tlbiB0byB0aGUgdG9rZW4gc3RhY2suICBJbiBwYXJ0aWN1bGFyLCB0aGlzIGdldCBiZSB1c2VkXG4gICAqIHRvIHB1dCBiYWNrIGEgdG9rZW4gcmV0dXJuZWQgZnJvbSBvbmUgb2YgdGhlIG90aGVyIG1ldGhvZHMuXG4gICAqL1xuICBwdXNoVG9rZW4odG9rZW4pIHtcbiAgICB0aGlzLnN0YWNrLnB1c2godG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBhbiBhcnJheSBvZiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLlxuICAgKi9cbiAgcHVzaFRva2Vucyh0b2tlbnMpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goLi4udG9rZW5zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGFuIG1hY3JvIGFyZ3VtZW50IHdpdGhvdXQgZXhwYW5kaW5nIHRva2VucyBhbmQgYXBwZW5kIHRoZSBhcnJheSBvZlxuICAgKiB0b2tlbnMgdG8gdGhlIHRva2VuIHN0YWNrLiBVc2VzIFRva2VuIGFzIGEgY29udGFpbmVyIGZvciB0aGUgcmVzdWx0LlxuICAgKi9cbiAgc2NhbkFyZ3VtZW50KGlzT3B0aW9uYWwpIHtcbiAgICBsZXQgc3RhcnQ7XG4gICAgbGV0IGVuZDtcbiAgICBsZXQgdG9rZW5zO1xuICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gXFxAaWZuZXh0Y2hhciBnb2JibGVzIGFueSBzcGFjZSBmb2xsb3dpbmcgaXRcbiAgICAgIGlmICh0aGlzLmZ1dHVyZSgpLnRleHQgIT09IFwiW1wiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSB0aGlzLnBvcFRva2VuKCk7IC8vIGRvbid0IGluY2x1ZGUgWyBpbiB0b2tlbnNcbiAgICAgICh7IHRva2VucywgZW5kIH0gPSB0aGlzLmNvbnN1bWVBcmcoW1wiXVwiXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoeyB0b2tlbnMsIHN0YXJ0LCBlbmQgfSA9IHRoaXMuY29uc3VtZUFyZygpKTtcbiAgICB9XG5cbiAgICAvLyBpbmRpY2F0ZSB0aGUgZW5kIG9mIGFuIGFyZ3VtZW50XG4gICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKFwiRU9GXCIsIGVuZC5sb2MpKTtcblxuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiBzdGFydC5yYW5nZShlbmQsIFwiXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWUgYWxsIGZvbGxvd2luZyBzcGFjZSB0b2tlbnMsIHdpdGhvdXQgZXhwYW5zaW9uLlxuICAgKi9cbiAgY29uc3VtZVNwYWNlcygpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZnV0dXJlKCk7XG4gICAgICBpZiAodG9rZW4udGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lIGFuIGFyZ3VtZW50IGZyb20gdGhlIHRva2VuIHN0cmVhbSwgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5XG4gICAqIG9mIHRva2VucyBhbmQgc3RhcnQvZW5kIHRva2VuLlxuICAgKi9cbiAgY29uc3VtZUFyZyhkZWxpbXMpIHtcbiAgICAvLyBUaGUgYXJndW1lbnQgZm9yIGEgZGVsaW1pdGVkIHBhcmFtZXRlciBpcyB0aGUgc2hvcnRlc3QgKHBvc3NpYmx5XG4gICAgLy8gZW1wdHkpIHNlcXVlbmNlIG9mIHRva2VucyB3aXRoIHByb3Blcmx5IG5lc3RlZCB7Li4ufSBncm91cHMgdGhhdCBpc1xuICAgIC8vIGZvbGxvd2VkIC4uLiBieSB0aGlzIHBhcnRpY3VsYXIgbGlzdCBvZiBub24tcGFyYW1ldGVyIHRva2Vucy5cbiAgICAvLyBUaGUgYXJndW1lbnQgZm9yIGFuIHVuZGVsaW1pdGVkIHBhcmFtZXRlciBpcyB0aGUgbmV4dCBub25ibGFua1xuICAgIC8vIHRva2VuLCB1bmxlc3MgdGhhdCB0b2tlbiBpcyDigJh74oCZLCB3aGVuIHRoZSBhcmd1bWVudCB3aWxsIGJlIHRoZVxuICAgIC8vIGVudGlyZSB7Li4ufSBncm91cCB0aGF0IGZvbGxvd3MuXG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgaXNEZWxpbWl0ZWQgPSBkZWxpbXMgJiYgZGVsaW1zLmxlbmd0aCA+IDA7XG4gICAgaWYgKCFpc0RlbGltaXRlZCkge1xuICAgICAgLy8gSWdub3JlIHNwYWNlcyBiZXR3ZWVuIGFyZ3VtZW50cy4gIEFzIHRoZSBUZVhib29rIHNheXM6XG4gICAgICAvLyBcIkFmdGVyIHlvdSBoYXZlIHNhaWQg4oCYXFxkZWZcXHJvdyMxIzJ7Li4ufeKAmSwgeW91IGFyZSBhbGxvd2VkIHRvXG4gICAgICAvLyAgcHV0IHNwYWNlcyBiZXR3ZWVuIHRoZSBhcmd1bWVudHMgKGUuZy4sIOKAmFxccm93IHggbuKAmSksIGJlY2F1c2VcbiAgICAgIC8vICBUZVggZG9lc27igJl0IHVzZSBzaW5nbGUgc3BhY2VzIGFzIHVuZGVsaW1pdGVkIGFyZ3VtZW50cy5cIlxuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5mdXR1cmUoKTtcbiAgICBsZXQgdG9rO1xuICAgIGxldCBkZXB0aCA9IDA7XG4gICAgbGV0IG1hdGNoID0gMDtcbiAgICBkbyB7XG4gICAgICB0b2sgPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgICAgaWYgKHRvay50ZXh0ID09PSBcIntcIikge1xuICAgICAgICArK2RlcHRoO1xuICAgICAgfSBlbHNlIGlmICh0b2sudGV4dCA9PT0gXCJ9XCIpIHtcbiAgICAgICAgLS1kZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXh0cmEgfVwiLCB0b2spO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgIFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQgaW4gYSBtYWNybyBhcmd1bWVudFwiICtcbiAgICAgICAgICAgIFwiLCBleHBlY3RlZCAnXCIgK1xuICAgICAgICAgICAgKGRlbGltcyAmJiBpc0RlbGltaXRlZCA/IGRlbGltc1ttYXRjaF0gOiBcIn1cIikgK1xuICAgICAgICAgICAgXCInXCIsXG4gICAgICAgICAgdG9rXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGVsaW1zICYmIGlzRGVsaW1pdGVkKSB7XG4gICAgICAgIGlmICgoZGVwdGggPT09IDAgfHwgKGRlcHRoID09PSAxICYmIGRlbGltc1ttYXRjaF0gPT09IFwie1wiKSkgJiYgdG9rLnRleHQgPT09IGRlbGltc1ttYXRjaF0pIHtcbiAgICAgICAgICArK21hdGNoO1xuICAgICAgICAgIGlmIChtYXRjaCA9PT0gZGVsaW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgaW5jbHVkZSBkZWxpbXMgaW4gdG9rZW5zXG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKC1tYXRjaCwgbWF0Y2gpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gd2hpbGUgKGRlcHRoICE9PSAwIHx8IGlzRGVsaW1pdGVkKTtcbiAgICAvLyBJZiB0aGUgYXJndW1lbnQgZm91bmQgLi4uIGhhcyB0aGUgZm9ybSDigJh7PG5lc3RlZCB0b2tlbnM+feKAmSxcbiAgICAvLyAuLi4gdGhlIG91dGVybW9zdCBicmFjZXMgZW5jbG9zaW5nIHRoZSBhcmd1bWVudCBhcmUgcmVtb3ZlZFxuICAgIGlmIChzdGFydC50ZXh0ID09PSBcIntcIiAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnRleHQgPT09IFwifVwiKSB7XG4gICAgICB0b2tlbnMucG9wKCk7XG4gICAgICB0b2tlbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcbiAgICByZXR1cm4geyB0b2tlbnMsIHN0YXJ0LCBlbmQ6IHRvayB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWUgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgKGRlbGltaXRlZCkgYXJndW1lbnRzIGZyb20gdGhlIHRva2VuXG4gICAqIHN0cmVhbSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3VtZUFyZ3MobnVtQXJncywgZGVsaW1pdGVycykge1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICBpZiAoZGVsaW1pdGVycy5sZW5ndGggIT09IG51bUFyZ3MgKyAxKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVGhlIGxlbmd0aCBvZiBkZWxpbWl0ZXJzIGRvZXNuJ3QgbWF0Y2ggdGhlIG51bWJlciBvZiBhcmdzIVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbGltcyA9IGRlbGltaXRlcnNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2sgPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgICAgIGlmIChkZWxpbXNbaV0gIT09IHRvay50ZXh0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVc2Ugb2YgdGhlIG1hY3JvIGRvZXNuJ3QgbWF0Y2ggaXRzIGRlZmluaXRpb25cIiwgdG9rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUFyZ3M7IGkrKykge1xuICAgICAgYXJncy5wdXNoKHRoaXMuY29uc3VtZUFyZyhkZWxpbWl0ZXJzICYmIGRlbGltaXRlcnNbaSArIDFdKS50b2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBJZiB0aGUgdG9rZW4gaXMgZXhwYW5kZWQsIHRoZSByZXN1bHRpbmcgdG9rZW5zIHdpbGwgYmUgcHVzaGVkIG9udG9cbiAgICogdGhlIHN0YWNrIGluIHJldmVyc2Ugb3JkZXIsIGFuZCB0aGUgbnVtYmVyIG9mIHN1Y2ggdG9rZW5zIHdpbGwgYmVcbiAgICogcmV0dXJuZWQuICBUaGlzIG51bWJlciBtaWdodCBiZSB6ZXJvIG9yIHBvc2l0aXZlLlxuICAgKlxuICAgKiBJZiBub3QsIHRoZSByZXR1cm4gdmFsdWUgaXMgYGZhbHNlYCwgYW5kIHRoZSBuZXh0IHRva2VuIHJlbWFpbnMgYXQgdGhlXG4gICAqIHRvcCBvZiB0aGUgc3RhY2suXG4gICAqXG4gICAqIEluIGVpdGhlciBjYXNlLCB0aGUgbmV4dCB0b2tlbiB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLFxuICAgKiBvciB0aGUgc3RhY2sgd2lsbCBiZSBlbXB0eSAoaW4gY2FzZSBvZiBlbXB0eSBleHBhbnNpb25cbiAgICogYW5kIG5vIG90aGVyIHRva2VucykuXG4gICAqXG4gICAqIFVzZWQgdG8gaW1wbGVtZW50IGBleHBhbmRBZnRlckZ1dHVyZWAgYW5kIGBleHBhbmROZXh0VG9rZW5gLlxuICAgKlxuICAgKiBJZiBleHBhbmRhYmxlT25seSwgb25seSBleHBhbmRhYmxlIHRva2VucyBhcmUgZXhwYW5kZWQgYW5kXG4gICAqIGFuIHVuZGVmaW5lZCBjb250cm9sIHNlcXVlbmNlIHJlc3VsdHMgaW4gYW4gZXJyb3IuXG4gICAqL1xuICBleHBhbmRPbmNlKGV4cGFuZGFibGVPbmx5KSB7XG4gICAgY29uc3QgdG9wVG9rZW4gPSB0aGlzLnBvcFRva2VuKCk7XG4gICAgY29uc3QgbmFtZSA9IHRvcFRva2VuLnRleHQ7XG4gICAgY29uc3QgZXhwYW5zaW9uID0gIXRvcFRva2VuLm5vZXhwYW5kID8gdGhpcy5fZ2V0RXhwYW5zaW9uKG5hbWUpIDogbnVsbDtcbiAgICBpZiAoZXhwYW5zaW9uID09IG51bGwgfHwgKGV4cGFuZGFibGVPbmx5ICYmIGV4cGFuc2lvbi51bmV4cGFuZGFibGUpKSB7XG4gICAgICBpZiAoZXhwYW5kYWJsZU9ubHkgJiYgZXhwYW5zaW9uID09IG51bGwgJiYgbmFtZVswXSA9PT0gXCJcXFxcXCIgJiYgIXRoaXMuaXNEZWZpbmVkKG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5kZWZpbmVkIGNvbnRyb2wgc2VxdWVuY2U6IFwiICsgbmFtZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnB1c2hUb2tlbih0b3BUb2tlbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQrKztcbiAgICBpZiAodGhpcy5leHBhbnNpb25Db3VudCA+IHRoaXMuc2V0dGluZ3MubWF4RXhwYW5kKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgXCJUb28gbWFueSBleHBhbnNpb25zOiBpbmZpbml0ZSBsb29wIG9yIFwiICsgXCJuZWVkIHRvIGluY3JlYXNlIG1heEV4cGFuZCBzZXR0aW5nXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGxldCB0b2tlbnMgPSBleHBhbnNpb24udG9rZW5zO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmNvbnN1bWVBcmdzKGV4cGFuc2lvbi5udW1BcmdzLCBleHBhbnNpb24uZGVsaW1pdGVycyk7XG4gICAgaWYgKGV4cGFuc2lvbi5udW1BcmdzKSB7XG4gICAgICAvLyBwYXN0ZSBhcmd1bWVudHMgaW4gcGxhY2Ugb2YgdGhlIHBsYWNlaG9sZGVyc1xuICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7IC8vIG1ha2UgYSBzaGFsbG93IGNvcHlcbiAgICAgIGZvciAobGV0IGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbGV0IHRvayA9IHRva2Vuc1tpXTtcbiAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkluY29tcGxldGUgcGxhY2Vob2xkZXIgYXQgZW5kIG9mIG1hY3JvIGJvZHlcIiwgdG9rKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rID0gdG9rZW5zWy0taV07IC8vIG5leHQgdG9rZW4gb24gc3RhY2tcbiAgICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAvLyAjIyDihpIgI1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMSk7IC8vIGRyb3AgZmlyc3QgI1xuICAgICAgICAgIH0gZWxzZSBpZiAoL15bMS05XSQvLnRlc3QodG9rLnRleHQpKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aXRoIHRoZSBpbmRpY2F0ZWQgYXJndW1lbnRcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMiwgLi4uYXJnc1srdG9rLnRleHQgLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTm90IGEgdmFsaWQgYXJndW1lbnQgbnVtYmVyXCIsIHRvayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENvbmNhdGVuYXRlIGV4cGFuc2lvbiBvbnRvIHRvcCBvZiBzdGFjay5cbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIChpZiBwb3NzaWJsZSksIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZ1xuICAgKiB0b3AgdG9rZW4gb24gdGhlIHN0YWNrICh3aXRob3V0IHJlbW92aW5nIGFueXRoaW5nIGZyb20gdGhlIHN0YWNrKS5cbiAgICogU2ltaWxhciBpbiBiZWhhdmlvciB0byBUZVgncyBgXFxleHBhbmRhZnRlclxcZnV0dXJlbGV0YC5cbiAgICogRXF1aXZhbGVudCB0byBleHBhbmRPbmNlKCkgZm9sbG93ZWQgYnkgZnV0dXJlKCkuXG4gICAqL1xuICBleHBhbmRBZnRlckZ1dHVyZSgpIHtcbiAgICB0aGlzLmV4cGFuZE9uY2UoKTtcbiAgICByZXR1cm4gdGhpcy5mdXR1cmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBleHBhbmQgZmlyc3QgdG9rZW4sIHRoZW4gcmV0dXJuIGZpcnN0IG5vbi1leHBhbmRhYmxlIHRva2VuLlxuICAgKi9cbiAgZXhwYW5kTmV4dFRva2VuKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLmV4cGFuZE9uY2UoKSA9PT0gZmFsc2UpIHsgLy8gZnVsbHkgZXhwYW5kZWRcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvLyBUaGUgdG9rZW4gYWZ0ZXIgXFxub2V4cGFuZCBpcyBpbnRlcnByZXRlZCBhcyBpZiBpdHMgbWVhbmluZyB3ZXJlIOKAmFxccmVsYXjigJlcbiAgICAgICAgaWYgKHRva2VuLnRyZWF0QXNSZWxheCkge1xuICAgICAgICAgIHRva2VuLnRleHQgPSBcIlxcXFxyZWxheFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlblxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgcGF0aHdheSBpcyBpbXBvc3NpYmxlLlxuICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVucmVhY2hhYmxlXG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiBtYWNybyBuYW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBsaXN0IG9mXG4gICAqIHRva2Vucywgb3IgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggbWFjcm8gaXMgZGVmaW5lZC5cbiAgICovXG4gIGV4cGFuZE1hY3JvKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpID8gdGhpcy5leHBhbmRUb2tlbnMoW25ldyBUb2tlbihuYW1lKV0pIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gdG9rZW4gc3RyZWFtIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBsaXN0IG9mXG4gICAqIHRva2Vucy4gIE5vdGUgdGhhdCB0aGUgaW5wdXQgdG9rZW5zIGFyZSBpbiByZXZlcnNlIG9yZGVyLCBidXQgdGhlXG4gICAqIG91dHB1dCB0b2tlbnMgYXJlIGluIGZvcndhcmQgb3JkZXIuXG4gICAqL1xuICBleHBhbmRUb2tlbnModG9rZW5zKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3Qgb2xkU3RhY2tMZW5ndGggPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiBvbGRTdGFja0xlbmd0aCkge1xuICAgICAgLy8gRXhwYW5kIG9ubHkgZXhwYW5kYWJsZSB0b2tlbnNcbiAgICAgIGlmICh0aGlzLmV4cGFuZE9uY2UodHJ1ZSkgPT09IGZhbHNlKSB7ICAvLyBmdWxseSBleHBhbmRlZFxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHtcbiAgICAgICAgICAvLyB0aGUgZXhwYW5zaW9uIG9mIFxcbm9leHBhbmQgaXMgdGhlIHRva2VuIGl0c2VsZlxuICAgICAgICAgIHRva2VuLm5vZXhwYW5kID0gZmFsc2U7XG4gICAgICAgICAgdG9rZW4udHJlYXRBc1JlbGF4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHQgYXMgYSBzdHJpbmcsXG4gICAqIG9yIHJldHVybiBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIG1hY3JvIGlzIGRlZmluZWQuXG4gICAqL1xuICBleHBhbmRNYWNyb0FzVGV4dChuYW1lKSB7XG4gICAgY29uc3QgdG9rZW5zID0gdGhpcy5leHBhbmRNYWNybyhuYW1lKTtcbiAgICBpZiAodG9rZW5zKSB7XG4gICAgICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4pID0+IHRva2VuLnRleHQpLmpvaW4oXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cGFuZGVkIG1hY3JvIGFzIGEgcmV2ZXJzZWQgYXJyYXkgb2YgdG9rZW5zIGFuZCBhIG1hY3JvXG4gICAqIGFyZ3VtZW50IGNvdW50LiAgT3IgcmV0dXJucyBgbnVsbGAgaWYgbm8gc3VjaCBtYWNyby5cbiAgICovXG4gIF9nZXRFeHBhbnNpb24obmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLm1hY3Jvcy5nZXQobmFtZSk7XG4gICAgaWYgKGRlZmluaXRpb24gPT0gbnVsbCkge1xuICAgICAgLy8gbWFpbmx5IGNoZWNraW5nIGZvciB1bmRlZmluZWQgaGVyZVxuICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuICAgIC8vIElmIGEgc2luZ2xlIGNoYXJhY3RlciBoYXMgYW4gYXNzb2NpYXRlZCBjYXRjb2RlIG90aGVyIHRoYW4gMTNcbiAgICAvLyAoYWN0aXZlIGNoYXJhY3RlciksIHRoZW4gZG9uJ3QgZXhwYW5kIGl0LlxuICAgIGlmIChuYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY2F0Y29kZSA9IHRoaXMubGV4ZXIuY2F0Y29kZXNbbmFtZV07XG4gICAgICBpZiAoY2F0Y29kZSAhPSBudWxsICYmIGNhdGNvZGUgIT09IDEzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBhbnNpb24gPSB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiID8gZGVmaW5pdGlvbih0aGlzKSA6IGRlZmluaXRpb247XG4gICAgaWYgKHR5cGVvZiBleHBhbnNpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxldCBudW1BcmdzID0gMDtcbiAgICAgIGlmIChleHBhbnNpb24uaW5kZXhPZihcIiNcIikgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkID0gZXhwYW5zaW9uLnJlcGxhY2UoLyMjL2csIFwiXCIpO1xuICAgICAgICB3aGlsZSAoc3RyaXBwZWQuaW5kZXhPZihcIiNcIiArIChudW1BcmdzICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICsrbnVtQXJncztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYm9keUxleGVyID0gbmV3IExleGVyKGV4cGFuc2lvbiwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICAgIGxldCB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICB3aGlsZSAodG9rLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICAgICAgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgfVxuICAgICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgdXNpbmcgcHVzaCBhbmQgcG9wXG4gICAgICBjb25zdCBleHBhbmRlZCA9IHsgdG9rZW5zLCBudW1BcmdzIH07XG4gICAgICByZXR1cm4gZXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cGFuc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgY3VycmVudGx5IFwiZGVmaW5lZFwiIChoYXMgc29tZVxuICAgKiBmdW5jdGlvbmFsaXR5KSwgbWVhbmluZyB0aGF0IGl0J3MgYSBtYWNybyAoaW4gdGhlIGN1cnJlbnQgZ3JvdXApLFxuICAgKiBhIGZ1bmN0aW9uLCBhIHN5bWJvbCwgb3Igb25lIG9mIHRoZSBzcGVjaWFsIGNvbW1hbmRzIGxpc3RlZCBpblxuICAgKiBgaW1wbGljaXRDb21tYW5kc2AuXG4gICAqL1xuICBpc0RlZmluZWQobmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm1hY3Jvcy5oYXMobmFtZSkgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmdW5jdGlvbnMsIG5hbWUgKSB8fFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN5bWJvbHMubWF0aCwgbmFtZSApIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3ltYm9scy50ZXh0LCBuYW1lICkgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbXBsaWNpdENvbW1hbmRzLCBuYW1lIClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBleHBhbmRhYmxlLlxuICAgKi9cbiAgaXNFeHBhbmRhYmxlKG5hbWUpIHtcbiAgICBjb25zdCBtYWNybyA9IHRoaXMubWFjcm9zLmdldChuYW1lKTtcbiAgICByZXR1cm4gbWFjcm8gIT0gbnVsbFxuICAgICAgPyB0eXBlb2YgbWFjcm8gPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hY3JvID09PSBcImZ1bmN0aW9uXCIgfHwgIW1hY3JvLnVuZXhwYW5kYWJsZVxuICAgICAgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZnVuY3Rpb25zLCBuYW1lICkgJiYgIWZ1bmN0aW9uc1tuYW1lXS5wcmltaXRpdmU7XG4gIH1cbn1cblxuLy8gSGVscGVycyBmb3IgUGFyc2VyLmpzIGhhbmRsaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHQgY2hhcmFjdGVycy5cblxuY29uc3QgdW5pY29kZVN1YlJlZ0V4ID0gL15b4oKK4oKL4oKM4oKN4oKO4oKA4oKB4oKC4oKD4oKE4oKF4oKG4oKH4oKI4oKJ4oKQ4oKR4oKV4bWi4rG84oKW4oKX4oKY4oKZ4oKS4oKa4bWj4oKb4oKc4bWk4bWl4oKT4bWm4bWn4bWo4bWp4bWqXS87XG5cbmNvbnN0IHVTdWJzQW5kU3VwcyA9IE9iamVjdC5mcmVlemUoe1xuICAn4oKKJzogJysnLFxuICAn4oKLJzogJy0nLFxuICAn4oKMJzogJz0nLFxuICAn4oKNJzogJygnLFxuICAn4oKOJzogJyknLFxuICAn4oKAJzogJzAnLFxuICAn4oKBJzogJzEnLFxuICAn4oKCJzogJzInLFxuICAn4oKDJzogJzMnLFxuICAn4oKEJzogJzQnLFxuICAn4oKFJzogJzUnLFxuICAn4oKGJzogJzYnLFxuICAn4oKHJzogJzcnLFxuICAn4oKIJzogJzgnLFxuICAn4oKJJzogJzknLFxuICAnXFx1MjA5MCc6ICdhJyxcbiAgJ1xcdTIwOTEnOiAnZScsXG4gICdcXHUyMDk1JzogJ2gnLFxuICAnXFx1MUQ2Mic6ICdpJyxcbiAgJ1xcdTJDN0MnOiAnaicsXG4gICdcXHUyMDk2JzogJ2snLFxuICAnXFx1MjA5Nyc6ICdsJyxcbiAgJ1xcdTIwOTgnOiAnbScsXG4gICdcXHUyMDk5JzogJ24nLFxuICAnXFx1MjA5Mic6ICdvJyxcbiAgJ1xcdTIwOUEnOiAncCcsXG4gICdcXHUxRDYzJzogJ3InLFxuICAnXFx1MjA5Qic6ICdzJyxcbiAgJ1xcdTIwOUMnOiAndCcsXG4gICdcXHUxRDY0JzogJ3UnLFxuICAnXFx1MUQ2NSc6ICd2JyxcbiAgJ1xcdTIwOTMnOiAneCcsXG4gICdcXHUxRDY2JzogJ86yJyxcbiAgJ1xcdTFENjcnOiAnzrMnLFxuICAnXFx1MUQ2OCc6ICfPgScsXG4gICdcXHUxRDY5JzogJ1xcdTAzZDUnLFxuICAnXFx1MUQ2QSc6ICfPhycsXG4gICfigbonOiAnKycsXG4gICfigbsnOiAnLScsXG4gICfigbwnOiAnPScsXG4gICfigb0nOiAnKCcsXG4gICfigb4nOiAnKScsXG4gICfigbAnOiAnMCcsXG4gICfCuSc6ICcxJyxcbiAgJ8KyJzogJzInLFxuICAnwrMnOiAnMycsXG4gICfigbQnOiAnNCcsXG4gICfigbUnOiAnNScsXG4gICfigbYnOiAnNicsXG4gICfigbcnOiAnNycsXG4gICfigbgnOiAnOCcsXG4gICfigbknOiAnOScsXG4gICdcXHUxRDJDJzogJ0EnLFxuICAnXFx1MUQyRSc6ICdCJyxcbiAgJ1xcdTFEMzAnOiAnRCcsXG4gICdcXHUxRDMxJzogJ0UnLFxuICAnXFx1MUQzMyc6ICdHJyxcbiAgJ1xcdTFEMzQnOiAnSCcsXG4gICdcXHUxRDM1JzogJ0knLFxuICAnXFx1MUQzNic6ICdKJyxcbiAgJ1xcdTFEMzcnOiAnSycsXG4gICdcXHUxRDM4JzogJ0wnLFxuICAnXFx1MUQzOSc6ICdNJyxcbiAgJ1xcdTFEM0EnOiAnTicsXG4gICdcXHUxRDNDJzogJ08nLFxuICAnXFx1MUQzRSc6ICdQJyxcbiAgJ1xcdTFEM0YnOiAnUicsXG4gICdcXHUxRDQwJzogJ1QnLFxuICAnXFx1MUQ0MSc6ICdVJyxcbiAgJ1xcdTJDN0QnOiAnVicsXG4gICdcXHUxRDQyJzogJ1cnLFxuICAnXFx1MUQ0Myc6ICdhJyxcbiAgJ1xcdTFENDcnOiAnYicsXG4gICdcXHUxRDlDJzogJ2MnLFxuICAnXFx1MUQ0OCc6ICdkJyxcbiAgJ1xcdTFENDknOiAnZScsXG4gICdcXHUxREEwJzogJ2YnLFxuICAnXFx1MUQ0RCc6ICdnJyxcbiAgJ1xcdTAyQjAnOiAnaCcsXG4gICdcXHUyMDcxJzogJ2knLFxuICAnXFx1MDJCMic6ICdqJyxcbiAgJ1xcdTFENEYnOiAnaycsXG4gICdcXHUwMkUxJzogJ2wnLFxuICAnXFx1MUQ1MCc6ICdtJyxcbiAgJ1xcdTIwN0YnOiAnbicsXG4gICdcXHUxRDUyJzogJ28nLFxuICAnXFx1MUQ1Nic6ICdwJyxcbiAgJ1xcdTAyQjMnOiAncicsXG4gICdcXHUwMkUyJzogJ3MnLFxuICAnXFx1MUQ1Nyc6ICd0JyxcbiAgJ1xcdTFENTgnOiAndScsXG4gICdcXHUxRDVCJzogJ3YnLFxuICAnXFx1MDJCNyc6ICd3JyxcbiAgJ1xcdTAyRTMnOiAneCcsXG4gICdcXHUwMkI4JzogJ3knLFxuICAnXFx1MURCQic6ICd6JyxcbiAgJ1xcdTFENUQnOiAnzrInLFxuICAnXFx1MUQ1RSc6ICfOsycsXG4gICdcXHUxRDVGJzogJ860JyxcbiAgJ1xcdTFENjAnOiAnXFx1MDNkNScsXG4gICdcXHUxRDYxJzogJ8+HJyxcbiAgJ1xcdTFEQkYnOiAnzrgnXG59KTtcblxuLy8gVXNlZCBmb3IgVW5pY29kZSBpbnB1dCBvZiBjYWxsaWdyYXBoaWMgYW5kIHNjcmlwdCBsZXR0ZXJzXG5jb25zdCBhc2NpaUZyb21TY3JpcHQgPSBPYmplY3QuZnJlZXplKHtcbiAgXCJcXHVkODM1XFx1ZGM5Y1wiOiBcIkFcIixcbiAgXCJcXHUyMTJjXCI6IFwiQlwiLFxuICBcIlxcdWQ4MzVcXHVkYzllXCI6IFwiQ1wiLFxuICBcIlxcdWQ4MzVcXHVkYzlmXCI6IFwiRFwiLFxuICBcIlxcdTIxMzBcIjogXCJFXCIsXG4gIFwiXFx1MjEzMVwiOiBcIkZcIixcbiAgXCJcXHVkODM1XFx1ZGNhMlwiOiBcIkdcIixcbiAgXCJcXHUyMTBCXCI6IFwiSFwiLFxuICBcIlxcdTIxMTBcIjogXCJJXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYTVcIjogXCJKXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYTZcIjogXCJLXCIsXG4gIFwiXFx1MjExMlwiOiBcIkxcIixcbiAgXCJcXHUyMTMzXCI6IFwiTVwiLFxuICBcIlxcdWQ4MzVcXHVkY2E5XCI6IFwiTlwiLFxuICBcIlxcdWQ4MzVcXHVkY2FhXCI6IFwiT1wiLFxuICBcIlxcdWQ4MzVcXHVkY2FiXCI6IFwiUFwiLFxuICBcIlxcdWQ4MzVcXHVkY2FjXCI6IFwiUVwiLFxuICBcIlxcdTIxMUJcIjogXCJSXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYWVcIjogXCJTXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYWZcIjogXCJUXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjBcIjogXCJVXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjFcIjogXCJWXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjJcIjogXCJXXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjNcIjogXCJYXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjRcIjogXCJZXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYjVcIjogXCJaXCJcbn0pO1xuXG4vLyBNYXBwaW5nIG9mIFVuaWNvZGUgYWNjZW50IGNoYXJhY3RlcnMgdG8gdGhlaXIgTGFUZVggZXF1aXZhbGVudCBpbiB0ZXh0IGFuZFxuLy8gbWF0aCBtb2RlICh3aGVuIHRoZXkgZXhpc3QpLlxudmFyIHVuaWNvZGVBY2NlbnRzID0ge1xuICBcIlxcdTAzMDFcIjogeyB0ZXh0OiBcIlxcXFwnXCIsIG1hdGg6IFwiXFxcXGFjdXRlXCIgfSxcbiAgXCJcXHUwMzAwXCI6IHsgdGV4dDogXCJcXFxcYFwiLCBtYXRoOiBcIlxcXFxncmF2ZVwiIH0sXG4gIFwiXFx1MDMwOFwiOiB7IHRleHQ6ICdcXFxcXCInLCBtYXRoOiBcIlxcXFxkZG90XCIgfSxcbiAgXCJcXHUwMzAzXCI6IHsgdGV4dDogXCJcXFxcflwiLCBtYXRoOiBcIlxcXFx0aWxkZVwiIH0sXG4gIFwiXFx1MDMwNFwiOiB7IHRleHQ6IFwiXFxcXD1cIiwgbWF0aDogXCJcXFxcYmFyXCIgfSxcbiAgXCJcXHUwMzA2XCI6IHsgdGV4dDogXCJcXFxcdVwiLCBtYXRoOiBcIlxcXFxicmV2ZVwiIH0sXG4gIFwiXFx1MDMwY1wiOiB7IHRleHQ6IFwiXFxcXHZcIiwgbWF0aDogXCJcXFxcY2hlY2tcIiB9LFxuICBcIlxcdTAzMDJcIjogeyB0ZXh0OiBcIlxcXFxeXCIsIG1hdGg6IFwiXFxcXGhhdFwiIH0sXG4gIFwiXFx1MDMwN1wiOiB7IHRleHQ6IFwiXFxcXC5cIiwgbWF0aDogXCJcXFxcZG90XCIgfSxcbiAgXCJcXHUwMzBhXCI6IHsgdGV4dDogXCJcXFxcclwiLCBtYXRoOiBcIlxcXFxtYXRocmluZ1wiIH0sXG4gIFwiXFx1MDMwYlwiOiB7IHRleHQ6IFwiXFxcXEhcIiB9LFxuICAnXFx1MDMyNyc6IHsgdGV4dDogJ1xcXFxjJyB9XG59O1xuXG52YXIgdW5pY29kZVN5bWJvbHMgPSB7XG4gIFwiw6FcIjogXCJhzIFcIixcbiAgXCLDoFwiOiBcImHMgFwiLFxuICBcIsOkXCI6IFwiYcyIXCIsXG4gIFwix59cIjogXCJhzIjMhFwiLFxuICBcIsOjXCI6IFwiYcyDXCIsXG4gIFwixIFcIjogXCJhzIRcIixcbiAgXCLEg1wiOiBcImHMhlwiLFxuICBcIuG6r1wiOiBcImHMhsyBXCIsXG4gIFwi4bqxXCI6IFwiYcyGzIBcIixcbiAgXCLhurVcIjogXCJhzIbMg1wiLFxuICBcIseOXCI6IFwiYcyMXCIsXG4gIFwiw6JcIjogXCJhzIJcIixcbiAgXCLhuqVcIjogXCJhzILMgVwiLFxuICBcIuG6p1wiOiBcImHMgsyAXCIsXG4gIFwi4bqrXCI6IFwiYcyCzINcIixcbiAgXCLIp1wiOiBcImHMh1wiLFxuICBcIsehXCI6IFwiYcyHzIRcIixcbiAgXCLDpVwiOiBcImHMilwiLFxuICBcIse7XCI6IFwiYcyKzIFcIixcbiAgXCLhuINcIjogXCJizIdcIixcbiAgXCLEh1wiOiBcImPMgVwiLFxuICBcIsSNXCI6IFwiY8yMXCIsXG4gIFwixIlcIjogXCJjzIJcIixcbiAgXCLEi1wiOiBcImPMh1wiLFxuICBcIsSPXCI6IFwiZMyMXCIsXG4gIFwi4biLXCI6IFwiZMyHXCIsXG4gIFwiw6lcIjogXCJlzIFcIixcbiAgXCLDqFwiOiBcImXMgFwiLFxuICBcIsOrXCI6IFwiZcyIXCIsXG4gIFwi4bq9XCI6IFwiZcyDXCIsXG4gIFwixJNcIjogXCJlzIRcIixcbiAgXCLhuJdcIjogXCJlzITMgVwiLFxuICBcIuG4lVwiOiBcImXMhMyAXCIsXG4gIFwixJVcIjogXCJlzIZcIixcbiAgXCLEm1wiOiBcImXMjFwiLFxuICBcIsOqXCI6IFwiZcyCXCIsXG4gIFwi4bq/XCI6IFwiZcyCzIFcIixcbiAgXCLhu4FcIjogXCJlzILMgFwiLFxuICBcIuG7hVwiOiBcImXMgsyDXCIsXG4gIFwixJdcIjogXCJlzIdcIixcbiAgXCLhuJ9cIjogXCJmzIdcIixcbiAgXCLHtVwiOiBcImfMgVwiLFxuICBcIuG4oVwiOiBcImfMhFwiLFxuICBcIsSfXCI6IFwiZ8yGXCIsXG4gIFwix6dcIjogXCJnzIxcIixcbiAgXCLEnVwiOiBcImfMglwiLFxuICBcIsShXCI6IFwiZ8yHXCIsXG4gIFwi4binXCI6IFwiaMyIXCIsXG4gIFwiyJ9cIjogXCJozIxcIixcbiAgXCLEpVwiOiBcImjMglwiLFxuICBcIuG4o1wiOiBcImjMh1wiLFxuICBcIsOtXCI6IFwiacyBXCIsXG4gIFwiw6xcIjogXCJpzIBcIixcbiAgXCLDr1wiOiBcImnMiFwiLFxuICBcIuG4r1wiOiBcImnMiMyBXCIsXG4gIFwixKlcIjogXCJpzINcIixcbiAgXCLEq1wiOiBcImnMhFwiLFxuICBcIsStXCI6IFwiacyGXCIsXG4gIFwix5BcIjogXCJpzIxcIixcbiAgXCLDrlwiOiBcImnMglwiLFxuICBcIsewXCI6IFwiasyMXCIsXG4gIFwixLVcIjogXCJqzIJcIixcbiAgXCLhuLFcIjogXCJrzIFcIixcbiAgXCLHqVwiOiBcImvMjFwiLFxuICBcIsS6XCI6IFwibMyBXCIsXG4gIFwixL5cIjogXCJszIxcIixcbiAgXCLhuL9cIjogXCJtzIFcIixcbiAgXCLhuYFcIjogXCJtzIdcIixcbiAgXCLFhFwiOiBcIm7MgVwiLFxuICBcIse5XCI6IFwibsyAXCIsXG4gIFwiw7FcIjogXCJuzINcIixcbiAgXCLFiFwiOiBcIm7MjFwiLFxuICBcIuG5hVwiOiBcIm7Mh1wiLFxuICBcIsOzXCI6IFwib8yBXCIsXG4gIFwiw7JcIjogXCJvzIBcIixcbiAgXCLDtlwiOiBcIm/MiFwiLFxuICBcIsirXCI6IFwib8yIzIRcIixcbiAgXCLDtVwiOiBcIm/Mg1wiLFxuICBcIuG5jVwiOiBcIm/Mg8yBXCIsXG4gIFwi4bmPXCI6IFwib8yDzIhcIixcbiAgXCLIrVwiOiBcIm/Mg8yEXCIsXG4gIFwixY1cIjogXCJvzIRcIixcbiAgXCLhuZNcIjogXCJvzITMgVwiLFxuICBcIuG5kVwiOiBcIm/MhMyAXCIsXG4gIFwixY9cIjogXCJvzIZcIixcbiAgXCLHklwiOiBcIm/MjFwiLFxuICBcIsO0XCI6IFwib8yCXCIsXG4gIFwi4buRXCI6IFwib8yCzIFcIixcbiAgXCLhu5NcIjogXCJvzILMgFwiLFxuICBcIuG7l1wiOiBcIm/MgsyDXCIsXG4gIFwiyK9cIjogXCJvzIdcIixcbiAgXCLIsVwiOiBcIm/Mh8yEXCIsXG4gIFwixZFcIjogXCJvzItcIixcbiAgXCLhuZVcIjogXCJwzIFcIixcbiAgXCLhuZdcIjogXCJwzIdcIixcbiAgXCLFlVwiOiBcInLMgVwiLFxuICBcIsWZXCI6IFwicsyMXCIsXG4gIFwi4bmZXCI6IFwicsyHXCIsXG4gIFwixZtcIjogXCJzzIFcIixcbiAgXCLhuaVcIjogXCJzzIHMh1wiLFxuICBcIsWhXCI6IFwic8yMXCIsXG4gIFwi4bmnXCI6IFwic8yMzIdcIixcbiAgXCLFnVwiOiBcInPMglwiLFxuICBcIuG5oVwiOiBcInPMh1wiLFxuICBcIuG6l1wiOiBcInTMiFwiLFxuICBcIsWlXCI6IFwidMyMXCIsXG4gIFwi4bmrXCI6IFwidMyHXCIsXG4gIFwiw7pcIjogXCJ1zIFcIixcbiAgXCLDuVwiOiBcInXMgFwiLFxuICBcIsO8XCI6IFwidcyIXCIsXG4gIFwix5hcIjogXCJ1zIjMgVwiLFxuICBcIsecXCI6IFwidcyIzIBcIixcbiAgXCLHllwiOiBcInXMiMyEXCIsXG4gIFwix5pcIjogXCJ1zIjMjFwiLFxuICBcIsWpXCI6IFwidcyDXCIsXG4gIFwi4bm5XCI6IFwidcyDzIFcIixcbiAgXCLFq1wiOiBcInXMhFwiLFxuICBcIuG5u1wiOiBcInXMhMyIXCIsXG4gIFwixa1cIjogXCJ1zIZcIixcbiAgXCLHlFwiOiBcInXMjFwiLFxuICBcIsO7XCI6IFwidcyCXCIsXG4gIFwixa9cIjogXCJ1zIpcIixcbiAgXCLFsVwiOiBcInXMi1wiLFxuICBcIuG5vVwiOiBcInbMg1wiLFxuICBcIuG6g1wiOiBcInfMgVwiLFxuICBcIuG6gVwiOiBcInfMgFwiLFxuICBcIuG6hVwiOiBcInfMiFwiLFxuICBcIsW1XCI6IFwid8yCXCIsXG4gIFwi4bqHXCI6IFwid8yHXCIsXG4gIFwi4bqYXCI6IFwid8yKXCIsXG4gIFwi4bqNXCI6IFwieMyIXCIsXG4gIFwi4bqLXCI6IFwieMyHXCIsXG4gIFwiw71cIjogXCJ5zIFcIixcbiAgXCLhu7NcIjogXCJ5zIBcIixcbiAgXCLDv1wiOiBcInnMiFwiLFxuICBcIuG7uVwiOiBcInnMg1wiLFxuICBcIsizXCI6IFwiecyEXCIsXG4gIFwixbdcIjogXCJ5zIJcIixcbiAgXCLhuo9cIjogXCJ5zIdcIixcbiAgXCLhuplcIjogXCJ5zIpcIixcbiAgXCLFulwiOiBcInrMgVwiLFxuICBcIsW+XCI6IFwiesyMXCIsXG4gIFwi4bqRXCI6IFwiesyCXCIsXG4gIFwixbxcIjogXCJ6zIdcIixcbiAgXCLDgVwiOiBcIkHMgVwiLFxuICBcIsOAXCI6IFwiQcyAXCIsXG4gIFwiw4RcIjogXCJBzIhcIixcbiAgXCLHnlwiOiBcIkHMiMyEXCIsXG4gIFwiw4NcIjogXCJBzINcIixcbiAgXCLEgFwiOiBcIkHMhFwiLFxuICBcIsSCXCI6IFwiQcyGXCIsXG4gIFwi4bquXCI6IFwiQcyGzIFcIixcbiAgXCLhurBcIjogXCJBzIbMgFwiLFxuICBcIuG6tFwiOiBcIkHMhsyDXCIsXG4gIFwix41cIjogXCJBzIxcIixcbiAgXCLDglwiOiBcIkHMglwiLFxuICBcIuG6pFwiOiBcIkHMgsyBXCIsXG4gIFwi4bqmXCI6IFwiQcyCzIBcIixcbiAgXCLhuqpcIjogXCJBzILMg1wiLFxuICBcIsimXCI6IFwiQcyHXCIsXG4gIFwix6BcIjogXCJBzIfMhFwiLFxuICBcIsOFXCI6IFwiQcyKXCIsXG4gIFwix7pcIjogXCJBzIrMgVwiLFxuICBcIuG4glwiOiBcIkLMh1wiLFxuICBcIsSGXCI6IFwiQ8yBXCIsXG4gIFwixIxcIjogXCJDzIxcIixcbiAgXCLEiFwiOiBcIkPMglwiLFxuICBcIsSKXCI6IFwiQ8yHXCIsXG4gIFwixI5cIjogXCJEzIxcIixcbiAgXCLhuIpcIjogXCJEzIdcIixcbiAgXCLDiVwiOiBcIkXMgVwiLFxuICBcIsOIXCI6IFwiRcyAXCIsXG4gIFwiw4tcIjogXCJFzIhcIixcbiAgXCLhurxcIjogXCJFzINcIixcbiAgXCLEklwiOiBcIkXMhFwiLFxuICBcIuG4llwiOiBcIkXMhMyBXCIsXG4gIFwi4biUXCI6IFwiRcyEzIBcIixcbiAgXCLElFwiOiBcIkXMhlwiLFxuICBcIsSaXCI6IFwiRcyMXCIsXG4gIFwiw4pcIjogXCJFzIJcIixcbiAgXCLhur5cIjogXCJFzILMgVwiLFxuICBcIuG7gFwiOiBcIkXMgsyAXCIsXG4gIFwi4buEXCI6IFwiRcyCzINcIixcbiAgXCLEllwiOiBcIkXMh1wiLFxuICBcIuG4nlwiOiBcIkbMh1wiLFxuICBcIse0XCI6IFwiR8yBXCIsXG4gIFwi4bigXCI6IFwiR8yEXCIsXG4gIFwixJ5cIjogXCJHzIZcIixcbiAgXCLHplwiOiBcIkfMjFwiLFxuICBcIsScXCI6IFwiR8yCXCIsXG4gIFwixKBcIjogXCJHzIdcIixcbiAgXCLhuKZcIjogXCJIzIhcIixcbiAgXCLInlwiOiBcIkjMjFwiLFxuICBcIsSkXCI6IFwiSMyCXCIsXG4gIFwi4biiXCI6IFwiSMyHXCIsXG4gIFwiw41cIjogXCJJzIFcIixcbiAgXCLDjFwiOiBcIknMgFwiLFxuICBcIsOPXCI6IFwiScyIXCIsXG4gIFwi4biuXCI6IFwiScyIzIFcIixcbiAgXCLEqFwiOiBcIknMg1wiLFxuICBcIsSqXCI6IFwiScyEXCIsXG4gIFwixKxcIjogXCJJzIZcIixcbiAgXCLHj1wiOiBcIknMjFwiLFxuICBcIsOOXCI6IFwiScyCXCIsXG4gIFwixLBcIjogXCJJzIdcIixcbiAgXCLEtFwiOiBcIkrMglwiLFxuICBcIuG4sFwiOiBcIkvMgVwiLFxuICBcIseoXCI6IFwiS8yMXCIsXG4gIFwixLlcIjogXCJMzIFcIixcbiAgXCLEvVwiOiBcIkzMjFwiLFxuICBcIuG4vlwiOiBcIk3MgVwiLFxuICBcIuG5gFwiOiBcIk3Mh1wiLFxuICBcIsWDXCI6IFwiTsyBXCIsXG4gIFwix7hcIjogXCJOzIBcIixcbiAgXCLDkVwiOiBcIk7Mg1wiLFxuICBcIsWHXCI6IFwiTsyMXCIsXG4gIFwi4bmEXCI6IFwiTsyHXCIsXG4gIFwiw5NcIjogXCJPzIFcIixcbiAgXCLDklwiOiBcIk/MgFwiLFxuICBcIsOWXCI6IFwiT8yIXCIsXG4gIFwiyKpcIjogXCJPzIjMhFwiLFxuICBcIsOVXCI6IFwiT8yDXCIsXG4gIFwi4bmMXCI6IFwiT8yDzIFcIixcbiAgXCLhuY5cIjogXCJPzIPMiFwiLFxuICBcIsisXCI6IFwiT8yDzIRcIixcbiAgXCLFjFwiOiBcIk/MhFwiLFxuICBcIuG5klwiOiBcIk/MhMyBXCIsXG4gIFwi4bmQXCI6IFwiT8yEzIBcIixcbiAgXCLFjlwiOiBcIk/MhlwiLFxuICBcIseRXCI6IFwiT8yMXCIsXG4gIFwiw5RcIjogXCJPzIJcIixcbiAgXCLhu5BcIjogXCJPzILMgVwiLFxuICBcIuG7klwiOiBcIk/MgsyAXCIsXG4gIFwi4buWXCI6IFwiT8yCzINcIixcbiAgXCLIrlwiOiBcIk/Mh1wiLFxuICBcIsiwXCI6IFwiT8yHzIRcIixcbiAgXCLFkFwiOiBcIk/Mi1wiLFxuICBcIuG5lFwiOiBcIlDMgVwiLFxuICBcIuG5llwiOiBcIlDMh1wiLFxuICBcIsWUXCI6IFwiUsyBXCIsXG4gIFwixZhcIjogXCJSzIxcIixcbiAgXCLhuZhcIjogXCJSzIdcIixcbiAgXCLFmlwiOiBcIlPMgVwiLFxuICBcIuG5pFwiOiBcIlPMgcyHXCIsXG4gIFwixaBcIjogXCJTzIxcIixcbiAgXCLhuaZcIjogXCJTzIzMh1wiLFxuICBcIsWcXCI6IFwiU8yCXCIsXG4gIFwi4bmgXCI6IFwiU8yHXCIsXG4gIFwixaRcIjogXCJUzIxcIixcbiAgXCLhuapcIjogXCJUzIdcIixcbiAgXCLDmlwiOiBcIlXMgVwiLFxuICBcIsOZXCI6IFwiVcyAXCIsXG4gIFwiw5xcIjogXCJVzIhcIixcbiAgXCLHl1wiOiBcIlXMiMyBXCIsXG4gIFwix5tcIjogXCJVzIjMgFwiLFxuICBcIseVXCI6IFwiVcyIzIRcIixcbiAgXCLHmVwiOiBcIlXMiMyMXCIsXG4gIFwixahcIjogXCJVzINcIixcbiAgXCLhubhcIjogXCJVzIPMgVwiLFxuICBcIsWqXCI6IFwiVcyEXCIsXG4gIFwi4bm6XCI6IFwiVcyEzIhcIixcbiAgXCLFrFwiOiBcIlXMhlwiLFxuICBcIseTXCI6IFwiVcyMXCIsXG4gIFwiw5tcIjogXCJVzIJcIixcbiAgXCLFrlwiOiBcIlXMilwiLFxuICBcIsWwXCI6IFwiVcyLXCIsXG4gIFwi4bm8XCI6IFwiVsyDXCIsXG4gIFwi4bqCXCI6IFwiV8yBXCIsXG4gIFwi4bqAXCI6IFwiV8yAXCIsXG4gIFwi4bqEXCI6IFwiV8yIXCIsXG4gIFwixbRcIjogXCJXzIJcIixcbiAgXCLhuoZcIjogXCJXzIdcIixcbiAgXCLhuoxcIjogXCJYzIhcIixcbiAgXCLhuopcIjogXCJYzIdcIixcbiAgXCLDnVwiOiBcIlnMgVwiLFxuICBcIuG7slwiOiBcIlnMgFwiLFxuICBcIsW4XCI6IFwiWcyIXCIsXG4gIFwi4bu4XCI6IFwiWcyDXCIsXG4gIFwiyLJcIjogXCJZzIRcIixcbiAgXCLFtlwiOiBcIlnMglwiLFxuICBcIuG6jlwiOiBcIlnMh1wiLFxuICBcIsW5XCI6IFwiWsyBXCIsXG4gIFwixb1cIjogXCJazIxcIixcbiAgXCLhupBcIjogXCJazIJcIixcbiAgXCLFu1wiOiBcIlrMh1wiLFxuICBcIs6sXCI6IFwizrHMgVwiLFxuICBcIuG9sFwiOiBcIs6xzIBcIixcbiAgXCLhvrFcIjogXCLOscyEXCIsXG4gIFwi4b6wXCI6IFwizrHMhlwiLFxuICBcIs6tXCI6IFwizrXMgVwiLFxuICBcIuG9slwiOiBcIs61zIBcIixcbiAgXCLOrlwiOiBcIs63zIFcIixcbiAgXCLhvbRcIjogXCLOt8yAXCIsXG4gIFwizq9cIjogXCLOucyBXCIsXG4gIFwi4b22XCI6IFwizrnMgFwiLFxuICBcIs+KXCI6IFwizrnMiFwiLFxuICBcIs6QXCI6IFwizrnMiMyBXCIsXG4gIFwi4b+SXCI6IFwizrnMiMyAXCIsXG4gIFwi4b+RXCI6IFwizrnMhFwiLFxuICBcIuG/kFwiOiBcIs65zIZcIixcbiAgXCLPjFwiOiBcIs6/zIFcIixcbiAgXCLhvbhcIjogXCLOv8yAXCIsXG4gIFwiz41cIjogXCLPhcyBXCIsXG4gIFwi4b26XCI6IFwiz4XMgFwiLFxuICBcIs+LXCI6IFwiz4XMiFwiLFxuICBcIs6wXCI6IFwiz4XMiMyBXCIsXG4gIFwi4b+iXCI6IFwiz4XMiMyAXCIsXG4gIFwi4b+hXCI6IFwiz4XMhFwiLFxuICBcIuG/oFwiOiBcIs+FzIZcIixcbiAgXCLPjlwiOiBcIs+JzIFcIixcbiAgXCLhvbxcIjogXCLPicyAXCIsXG4gIFwizo5cIjogXCLOpcyBXCIsXG4gIFwi4b+qXCI6IFwizqXMgFwiLFxuICBcIs6rXCI6IFwizqXMiFwiLFxuICBcIuG/qVwiOiBcIs6lzIRcIixcbiAgXCLhv6hcIjogXCLOpcyGXCIsXG4gIFwizo9cIjogXCLOqcyBXCIsXG4gIFwi4b+6XCI6IFwizqnMgFwiXG59O1xuXG4vKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOjAgKi9cblxuY29uc3QgYmluTGVmdENhbmNlbGxlcnMgPSBbXCJiaW5cIiwgXCJvcFwiLCBcIm9wZW5cIiwgXCJwdW5jdFwiLCBcInJlbFwiXTtcbmNvbnN0IHNpemVSZWdFeCA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS87XG5jb25zdCB0ZXh0UmVnRXggPSAvXiAqXFxcXHRleHQvO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUgcGFyc2VyIHVzZWQgdG8gcGFyc2Ugb3V0IGEgVGVYIGV4cHJlc3Npb24gZnJvbSB0aGVcbiAqIGlucHV0LiBTaW5jZSBUZVggaXNuJ3QgY29udGV4dC1mcmVlLCBzdGFuZGFyZCBwYXJzZXJzIGRvbid0IHdvcmsgcGFydGljdWxhcmx5XG4gKiB3ZWxsLlxuICpcbiAqIFRoZSBzdHJhdGVneSBvZiB0aGlzIHBhcnNlciBpcyBhcyBzdWNoOlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyAodGhlIGAucGFyc2UuLi5gIG9uZXMpIHRha2UgYSBwb3NpdGlvbiBpbiB0aGUgY3VycmVudFxuICogcGFyc2Ugc3RyaW5nIHRvIHBhcnNlIHRva2VucyBmcm9tLiBUaGUgbGV4ZXIgKGZvdW5kIGluIExleGVyLmpzLCBzdG9yZWQgYXRcbiAqIHRoaXMuZ3VsbGV0LmxleGVyKSBhbHNvIHN1cHBvcnRzIHB1bGxpbmcgb3V0IHRva2VucyBhdCBhcmJpdHJhcnkgcGxhY2VzLiBXaGVuXG4gKiBpbmRpdmlkdWFsIHRva2VucyBhcmUgbmVlZGVkIGF0IGEgcG9zaXRpb24sIHRoZSBsZXhlciBpcyBjYWxsZWQgdG8gcHVsbCBvdXQgYVxuICogdG9rZW4sIHdoaWNoIGlzIHRoZW4gdXNlZC5cbiAqXG4gKiBUaGUgcGFyc2VyIGhhcyBhIHByb3BlcnR5IGNhbGxlZCBcIm1vZGVcIiBpbmRpY2F0aW5nIHRoZSBtb2RlIHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IGluLiBDdXJyZW50bHkgaXQgaGFzIHRvIGJlIG9uZSBvZiBcIm1hdGhcIiBvclxuICogXCJ0ZXh0XCIsIHdoaWNoIGRlbm90ZXMgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG1hdGgteVxuICogb25lIG9yIGEgdGV4dC15IG9uZSAoZS5nLiBpbnNpZGUgXFx0ZXh0KS4gQ3VycmVudGx5LCB0aGlzIHNlcnZlcyB0b1xuICogbGltaXQgdGhlIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0ZXh0IG1vZGUuXG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgdXNlZnVsIGRhdGEgdGhhdFxuICogd2FzIHBhcnNlZCBhdCBpdHMgZ2l2ZW4gcG9pbnQsIGFuZCBhIG5ldyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZWRcbiAqIGRhdGEuIFRoZSBtYWluIGZ1bmN0aW9ucyBjYW4gY2FsbCBlYWNoIG90aGVyIGFuZCBjb250aW51ZSB0aGUgcGFyc2luZyBieVxuICogdXNpbmcgdGhlIHJldHVybmVkIHBvc2l0aW9uIGFzIGEgbmV3IHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGV4dHJhIGAuaGFuZGxlLi4uYCBmdW5jdGlvbnMsIHdoaWNoIHB1bGwgb3V0IHNvbWUgcmV1c2VkXG4gKiBmdW5jdGlvbmFsaXR5IGludG8gc2VsZi1jb250YWluZWQgZnVuY3Rpb25zLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgcmV0dXJuIFBhcnNlTm9kZXMuXG4gKi9cblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzLCBpc1ByZWFtYmxlID0gZmFsc2UpIHtcbiAgICAvLyBTdGFydCBpbiBtYXRoIG1vZGVcbiAgICB0aGlzLm1vZGUgPSBcIm1hdGhcIjtcbiAgICAvLyBDcmVhdGUgYSBuZXcgbWFjcm8gZXhwYW5kZXIgKGd1bGxldCkgYW5kIChpbmRpcmVjdGx5IHZpYSB0aGF0KSBhbHNvIGFcbiAgICAvLyBuZXcgbGV4ZXIgKG1vdXRoKSBmb3IgdGhpcyBwYXJzZXIgKHN0b21hY2gsIGluIHRoZSBsYW5ndWFnZSBvZiBUZVgpXG4gICAgdGhpcy5ndWxsZXQgPSBuZXcgTWFjcm9FeHBhbmRlcihpbnB1dCwgc2V0dGluZ3MsIHRoaXMubW9kZSk7XG4gICAgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAvLyBBcmUgd2UgZGVmaW5pbmcgYSBwcmVhbWJsZT9cbiAgICB0aGlzLmlzUHJlYW1ibGUgPSBpc1ByZWFtYmxlO1xuICAgIC8vIENvdW50IGxlZnRyaWdodCBkZXB0aCAoZm9yIFxcbWlkZGxlIGVycm9ycylcbiAgICB0aGlzLmxlZnRyaWdodERlcHRoID0gMDtcbiAgICB0aGlzLnByZXZBdG9tVHlwZSA9IFwiXCI7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGEgcmVzdWx0IHRvIG1ha2Ugc3VyZSBpdCBoYXMgdGhlIHJpZ2h0IHR5cGUsIGFuZCB0aHJvd3MgYW5cbiAgICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICAgKi9cbiAgZXhwZWN0KHRleHQsIGNvbnN1bWUgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ICE9PSB0ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRXhwZWN0ZWQgJyR7dGV4dH0nLCBnb3QgJyR7dGhpcy5mZXRjaCgpLnRleHR9J2AsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzY2FyZHMgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBjb25zaWRlcmluZyBpdCBjb25zdW1lZC5cbiAgICovXG4gIGNvbnN1bWUoKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIG9yIGlmIHRoZXJlIGlzbid0IG9uZSAoYXQgdGhlXG4gICAqIGJlZ2lubmluZywgb3IgaWYgdGhlIHByZXZpb3VzIGxvb2thaGVhZCB0b2tlbiB3YXMgY29uc3VtZSgpZCksXG4gICAqIGZldGNoIHRoZSBuZXh0IHRva2VuIGFzIHRoZSBuZXcgbG9va2FoZWFkIHRva2VuIGFuZCByZXR1cm4gaXQuXG4gICAqL1xuICBmZXRjaCgpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5leHBhbmROZXh0VG9rZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gXCJ0ZXh0XCIgYW5kIFwibWF0aFwiIG1vZGVzLlxuICAgKi9cbiAgc3dpdGNoTW9kZShuZXdNb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbmV3TW9kZTtcbiAgICB0aGlzLmd1bGxldC5zd2l0Y2hNb2RlKG5ld01vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAgICovXG4gIHBhcnNlKCkge1xuICAgIC8vIENyZWF0ZSBhIGdyb3VwIG5hbWVzcGFjZSBmb3IgZXZlcnkgJC4uLiQsICQkLi4uJCQsIFxcWy4uLlxcXS4pXG4gICAgLy8gQSBcXGRlZiBpcyB0aGVuIHZhbGlkIG9ubHkgd2l0aGluIHRoYXQgcGFpciBvZiBkZWxpbWl0ZXJzLlxuICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcblxuICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbG9ySXNUZXh0Q29sb3IpIHtcbiAgICAgIC8vIFVzZSBvbGQgXFxjb2xvciBiZWhhdmlvciAoc2FtZSBhcyBMYVRlWCdzIFxcdGV4dGNvbG9yKSBpZiByZXF1ZXN0ZWQuXG4gICAgICAvLyBXZSBkbyB0aGlzIHdpdGhpbiB0aGUgZ3JvdXAgZm9yIHRoZSBtYXRoIGV4cHJlc3Npb24sIHNvIGl0IGRvZXNuJ3RcbiAgICAgIC8vIHBvbGx1dGUgc2V0dGluZ3MubWFjcm9zLlxuICAgICAgdGhpcy5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjb2xvclwiLCBcIlxcXFx0ZXh0Y29sb3JcIik7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSBpbnB1dFxuICAgIGNvbnN0IHBhcnNlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuXG4gICAgLy8gSWYgd2Ugc3VjY2VlZGVkLCBtYWtlIHN1cmUgdGhlcmUncyBhbiBFT0YgYXQgdGhlIGVuZFxuICAgIHRoaXMuZXhwZWN0KFwiRU9GXCIpO1xuXG4gICAgaWYgKHRoaXMuaXNQcmVhbWJsZSkge1xuICAgICAgY29uc3QgbWFjcm9zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgbWFjcm9zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIHJldHVybiBtYWNyb3NcbiAgICB9XG5cbiAgICAvLyBUaGUgb25seSBsb2NhbCBtYWNybyB0aGF0IHdlIHdhbnQgdG8gc2F2ZSBpcyBmcm9tIFxcdGFnLlxuICAgIGNvbnN0IHRhZyA9IHRoaXMuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpO1xuXG4gICAgLy8gRW5kIHRoZSBncm91cCBuYW1lc3BhY2UgZm9yIHRoZSBleHByZXNzaW9uXG4gICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcblxuICAgIGlmICh0YWcpIHsgdGhpcy5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdID0gdGFnOyB9XG5cbiAgICByZXR1cm4gcGFyc2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGVuZE9mRXhwcmVzc2lvbigpIHtcbiAgICByZXR1cm4gW1wifVwiLCBcIlxcXFxlbmRncm91cFwiLCBcIlxcXFxlbmRcIiwgXCJcXFxccmlnaHRcIiwgXCJcXFxcZW5kdG9nZ2xlXCIsIFwiJlwiXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxseSBwYXJzZSBhIHNlcGFyYXRlIHNlcXVlbmNlIG9mIHRva2VucyBhcyBhIHNlcGFyYXRlIGpvYi5cbiAgICogVG9rZW5zIHNob3VsZCBiZSBzcGVjaWZpZWQgaW4gcmV2ZXJzZSBvcmRlciwgYXMgaW4gYSBNYWNyb0RlZmluaXRpb24uXG4gICAqL1xuICBzdWJwYXJzZSh0b2tlbnMpIHtcbiAgICAvLyBTYXZlIHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIGN1cnJlbnQgam9iLlxuICAgIGNvbnN0IG9sZFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgdGhpcy5jb25zdW1lKCk7XG5cbiAgICAvLyBSdW4gdGhlIG5ldyBqb2IsIHRlcm1pbmF0aW5nIGl0IHdpdGggYW4gZXhjZXNzICd9J1xuICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbihuZXcgVG9rZW4oXCJ9XCIpKTtcbiAgICB0aGlzLmd1bGxldC5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgY29uc3QgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7XG4gICAgdGhpcy5leHBlY3QoXCJ9XCIpO1xuXG4gICAgLy8gUmVzdG9yZSB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBjdXJyZW50IGpvYi5cbiAgICB0aGlzLm5leHRUb2tlbiA9IG9sZFRva2VuO1xuXG4gICAgcmV0dXJuIHBhcnNlO1xuICB9XG5cbi8qKlxuICAgKiBQYXJzZXMgYW4gXCJleHByZXNzaW9uXCIsIHdoaWNoIGlzIGEgbGlzdCBvZiBhdG9tcy5cbiAgICpcbiAgICogYGJyZWFrT25JbmZpeGA6IFNob3VsZCB0aGUgcGFyc2luZyBzdG9wIHdoZW4gd2UgaGl0IGluZml4IG5vZGVzPyBUaGlzXG4gICAqICAgICAgICAgICAgICAgICBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlZGVuY2UgaGFuIGluZml4XG4gICAqICAgICAgICAgICAgICAgICBub2RlcyBpbiBpbXBsaWNpdCBwYXJzZXMuXG4gICAqXG4gICAqIGBicmVha09uVG9rZW5UZXh0YDogVGhlIHRleHQgb2YgdGhlIHRva2VuIHRoYXQgdGhlIGV4cHJlc3Npb24gc2hvdWxkIGVuZFxuICAgKiAgICAgICAgICAgICAgICAgICAgIHdpdGgsIG9yIGBudWxsYCBpZiBzb21ldGhpbmcgZWxzZSBzaG91bGQgZW5kIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIGBicmVha09uTWlkZGxlYDogXFxjb2xvciwgXFxvdmVyLCBhbmQgb2xkIHN0eWxpbmcgZnVuY3Rpb25zIHdvcmsgb24gYW4gaW1wbGljaXQgZ3JvdXAuXG4gICAqICAgICAgICAgICAgICAgICAgVGhlc2UgZ3JvdXBzIGVuZCBqdXN0IGJlZm9yZSB0aGUgdXN1YWwgdG9rZW5zLCBidXQgdGhleSBhbHNvXG4gICAqICAgICAgICAgICAgICAgICAgZW5kIGp1c3QgYmVmb3JlIGBcXG1pZGRsZWAuXG4gICAqL1xuICBwYXJzZUV4cHJlc3Npb24oYnJlYWtPbkluZml4LCBicmVha09uVG9rZW5UZXh0LCBicmVha09uTWlkZGxlKSB7XG4gICAgY29uc3QgYm9keSA9IFtdO1xuICAgIHRoaXMucHJldkF0b21UeXBlID0gXCJcIjtcbiAgICAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWdub3JlIHNwYWNlcyBpbiBtYXRoIG1vZGVcbiAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGV4ID0gdGhpcy5mZXRjaCgpO1xuICAgICAgaWYgKFBhcnNlci5lbmRPZkV4cHJlc3Npb24uaW5kZXhPZihsZXgudGV4dCkgIT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGJyZWFrT25Ub2tlblRleHQgJiYgbGV4LnRleHQgPT09IGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYnJlYWtPbk1pZGRsZSAmJiBsZXgudGV4dCA9PT0gXCJcXFxcbWlkZGxlXCIpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChicmVha09uSW5maXggJiYgZnVuY3Rpb25zW2xleC50ZXh0XSAmJiBmdW5jdGlvbnNbbGV4LnRleHRdLmluZml4KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYXRvbSA9IHRoaXMucGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpO1xuICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChhdG9tLnR5cGUgPT09IFwiaW50ZXJuYWxcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJvZHkucHVzaChhdG9tKTtcbiAgICAgIC8vIEtlZXAgYSByZWNvcmQgb2YgdGhlIGF0b20gdHlwZSwgc28gdGhhdCBvcC5qcyBjYW4gc2V0IGNvcnJlY3Qgc3BhY2luZy5cbiAgICAgIHRoaXMucHJldkF0b21UeXBlID0gYXRvbS50eXBlID09PSBcImF0b21cIiA/IGF0b20uZmFtaWx5IDogYXRvbS50eXBlO1xuICAgIH1cbiAgICBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgdGhpcy5mb3JtTGlnYXR1cmVzKGJvZHkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5oYW5kbGVJbmZpeE5vZGVzKGJvZHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJld3JpdGVzIGluZml4IG9wZXJhdG9ycyBzdWNoIGFzIFxcb3ZlciB3aXRoIGNvcnJlc3BvbmRpbmcgY29tbWFuZHMgc3VjaFxuICAgKiBhcyBcXGZyYWMuXG4gICAqXG4gICAqIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXAuICBJZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmVcbiAgICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uXG4gICAqL1xuICBoYW5kbGVJbmZpeE5vZGVzKGJvZHkpIHtcbiAgICBsZXQgb3ZlckluZGV4ID0gLTE7XG4gICAgbGV0IGZ1bmNOYW1lO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYm9keVtpXS50eXBlID09PSBcImluZml4XCIpIHtcbiAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIm9ubHkgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cFwiLCBib2R5W2ldLnRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICBmdW5jTmFtZSA9IGJvZHlbaV0ucmVwbGFjZVdpdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEgJiYgZnVuY05hbWUpIHtcbiAgICAgIGxldCBudW1lck5vZGU7XG4gICAgICBsZXQgZGVub21Ob2RlO1xuXG4gICAgICBjb25zdCBudW1lckJvZHkgPSBib2R5LnNsaWNlKDAsIG92ZXJJbmRleCk7XG4gICAgICBjb25zdCBkZW5vbUJvZHkgPSBib2R5LnNsaWNlKG92ZXJJbmRleCArIDEpO1xuXG4gICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIG51bWVyTm9kZSA9IG51bWVyQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG51bWVyTm9kZSA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiB0aGlzLm1vZGUsIGJvZHk6IG51bWVyQm9keSB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVub21Cb2R5Lmxlbmd0aCA9PT0gMSAmJiBkZW5vbUJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IGRlbm9tQm9keVswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbm9tTm9kZSA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiB0aGlzLm1vZGUsIGJvZHk6IGRlbm9tQm9keSB9O1xuICAgICAgfVxuXG4gICAgICBsZXQgbm9kZTtcbiAgICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGFib3ZlZnJhY1wiKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgYm9keVtvdmVySW5kZXhdLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzdWJzY3JpcHQgb3Igc3VwZXJzY3JpcHQgd2l0aCBuaWNlIGVycm9ycy5cbiAgICovXG4gIGhhbmRsZVN1cFN1YnNjcmlwdChcbiAgICBuYW1lIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gICkge1xuICAgIGNvbnN0IHN5bWJvbFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHN5bWJvbFRva2VuLnRleHQ7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIGlnbm9yZSBzcGFjZXMgYmVmb3JlIHN1cC9zdWJzY3JpcHQgYXJndW1lbnRcbiAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VHcm91cChuYW1lKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsIHN5bWJvbFRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHR1YWwgaW5wdXQgb2YgYW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBpbnRvIGEgdGV4dCBub2RlXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gYSBjb2xvciBub2RlIHdob3NlIGNvbG9yIGlzIGRldGVybWluZWQgYnkgZXJyb3JDb2xvclxuICAgKi9cbiAgZm9ybWF0VW5zdXBwb3J0ZWRDbWQodGV4dCkge1xuICAgIGNvbnN0IHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0b3JkQXJyYXkucHVzaCh7IHR5cGU6IFwidGV4dG9yZFwiLCBtb2RlOiBcInRleHRcIiwgdGV4dDogdGV4dFtpXSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXh0Tm9kZSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgYm9keTogdGV4dG9yZEFycmF5XG4gICAgfTtcblxuICAgIGNvbnN0IGNvbG9yTm9kZSA9IHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGNvbG9yOiB0aGlzLnNldHRpbmdzLmVycm9yQ29sb3IsXG4gICAgICBib2R5OiBbdGV4dE5vZGVdXG4gICAgfTtcblxuICAgIHJldHVybiBjb2xvck5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2l0aCBvcHRpb25hbCBzdXBlci9zdWJzY3JpcHRzLlxuICAgKi9cbiAgcGFyc2VBdG9tKGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICAvLyBUaGUgYm9keSBvZiBhbiBhdG9tIGlzIGFuIGltcGxpY2l0IGdyb3VwLCBzbyB0aGF0IHRoaW5ncyBsaWtlXG4gICAgLy8gXFxsZWZ0KHhcXHJpZ2h0KV4yIHdvcmsgY29ycmVjdGx5LlxuICAgIGNvbnN0IGJhc2UgPSB0aGlzLnBhcnNlR3JvdXAoXCJhdG9tXCIsIGJyZWFrT25Ub2tlblRleHQpO1xuXG4gICAgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIC8vIE5vdGUgdGhhdCBiYXNlIG1heSBiZSBlbXB0eSAoaS5lLiBudWxsKSBhdCB0aGlzIHBvaW50LlxuXG4gICAgbGV0IHN1cGVyc2NyaXB0O1xuICAgIGxldCBzdWJzY3JpcHQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIEd1YXJhbnRlZWQgaW4gbWF0aCBtb2RlLCBzbyBlYXQgYW55IHNwYWNlcyBmaXJzdC5cbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuXG4gICAgICAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG4gICAgICBjb25zdCBsZXggPSB0aGlzLmZldGNoKCk7XG5cbiAgICAgIGlmIChsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCIgfHwgbGV4LnRleHQgPT09IFwiXFxcXG5vbGltaXRzXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgbGltaXQgY29udHJvbFxuICAgICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BcIikge1xuICAgICAgICAgIGNvbnN0IGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICBiYXNlLmxpbWl0cyA9IGxpbWl0cztcbiAgICAgICAgICBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIpIHtcbiAgICAgICAgICBpZiAoYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpIHtcbiAgICAgICAgICAgIGJhc2UubGltaXRzID0gbGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkxpbWl0IGNvbnRyb2xzIG11c3QgZm9sbG93IGEgbWF0aCBvcGVyYXRvclwiLCBsZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgc3VwZXJzY3JpcHQgc3RhcnRcbiAgICAgICAgaWYgKHN1cGVyc2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcnNjcmlwdCA9IHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3VwZXJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl9cIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBzdWJzY3JpcHQgc3RhcnRcbiAgICAgICAgaWYgKHN1YnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRG91YmxlIHN1YnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmlwdCA9IHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3Vic2NyaXB0XCIpO1xuICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgcHJpbWVcbiAgICAgICAgaWYgKHN1cGVyc2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3VwZXJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmltZSA9IHsgdHlwZTogXCJ0ZXh0b3JkXCIsIG1vZGU6IHRoaXMubW9kZSwgdGV4dDogXCJcXFxccHJpbWVcIiB9O1xuXG4gICAgICAgIC8vIE1hbnkgcHJpbWVzIGNhbiBiZSBncm91cGVkIHRvZ2V0aGVyLCBzbyB3ZSBoYW5kbGUgdGhpcyBoZXJlXG4gICAgICAgIGNvbnN0IHByaW1lcyA9IFtwcmltZV07XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBLZWVwIGxleGluZyB0b2tlbnMgdW50aWwgd2UgZ2V0IHNvbWV0aGluZyB0aGF0J3Mgbm90IGEgcHJpbWVcbiAgICAgICAgd2hpbGUgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAgIC8vIEZvciBlYWNoIG9uZSwgYWRkIGFub3RoZXIgcHJpbWUgdG8gdGhlIGxpc3RcbiAgICAgICAgICBwcmltZXMucHVzaChwcmltZSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBhIHN1cGVyc2NyaXB0IGZvbGxvd2luZyB0aGUgcHJpbWVzLCBjb21iaW5lIHRoYXRcbiAgICAgICAgLy8gc3VwZXJzY3JpcHQgaW4gd2l0aCB0aGUgcHJpbWVzLlxuICAgICAgICBpZiAodGhpcy5mZXRjaCgpLnRleHQgPT09IFwiXlwiKSB7XG4gICAgICAgICAgcHJpbWVzLnB1c2godGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHV0IGV2ZXJ5dGhpbmcgaW50byBhbiBvcmRncm91cCBhcyB0aGUgc3VwZXJzY3JpcHRcbiAgICAgICAgc3VwZXJzY3JpcHQgPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogdGhpcy5tb2RlLCBib2R5OiBwcmltZXMgfTtcbiAgICAgIH0gZWxzZSBpZiAodVN1YnNBbmRTdXBzW2xleC50ZXh0XSkge1xuICAgICAgICAvLyBBIFVuaWNvZGUgc3Vic2NyaXB0IG9yIHN1cGVyc2NyaXB0IGNoYXJhY3Rlci5cbiAgICAgICAgLy8gV2UgdHJlYXQgdGhlc2Ugc2ltaWxhcmx5IHRvIHRoZSB1bmljb2RlLW1hdGggcGFja2FnZS5cbiAgICAgICAgLy8gU28gd2UgcmVuZGVyIGEgc3RyaW5nIG9mIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHRzIHRoZVxuICAgICAgICAvLyBzYW1lIGFzIGEgKHN1YnxzdXBlcilzY3JpcHQgb2YgcmVndWxhciBjaGFyYWN0ZXJzLlxuICAgICAgICBjb25zdCBpc1N1YiA9IHVuaWNvZGVTdWJSZWdFeC50ZXN0KGxleC50ZXh0KTtcbiAgICAgICAgY29uc3Qgc3Vic3VwVG9rZW5zID0gW107XG4gICAgICAgIHN1YnN1cFRva2Vucy5wdXNoKG5ldyBUb2tlbih1U3Vic0FuZFN1cHNbbGV4LnRleHRdKSk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBDb250aW51ZSBmZXRjaGluZyB0b2tlbnMgdG8gZmlsbCBvdXQgdGhlIGdyb3VwLlxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5mZXRjaCgpLnRleHQ7XG4gICAgICAgICAgaWYgKCEodVN1YnNBbmRTdXBzW3Rva2VuXSkpIHsgYnJlYWsgfVxuICAgICAgICAgIGlmICh1bmljb2RlU3ViUmVnRXgudGVzdCh0b2tlbikgIT09IGlzU3ViKSB7IGJyZWFrIH1cbiAgICAgICAgICBzdWJzdXBUb2tlbnMudW5zaGlmdChuZXcgVG9rZW4odVN1YnNBbmRTdXBzW3Rva2VuXSkpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBjcmVhdGUgYSAoc3VifHN1cGVyKXNjcmlwdC5cbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuc3VicGFyc2Uoc3Vic3VwVG9rZW5zKTtcbiAgICAgICAgaWYgKGlzU3ViKSB7XG4gICAgICAgICAgc3Vic2NyaXB0ID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IFwibWF0aFwiLCBib2R5IH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VwZXJzY3JpcHQgPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogXCJtYXRoXCIsIGJvZHkgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgaXQgd2Fzbid0IF4sIF8sIGEgVW5pY29kZSAoc3VifHN1cGVyKXNjcmlwdCwgb3IgJywgc3RvcCBwYXJzaW5nIHN1cGVyL3N1YnNjcmlwdHNcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm11bHRpc2NyaXB0XCIgJiYgIWJhc2UucG9zdHNjcmlwdHMpIHtcbiAgICAgICAgLy8gYmFzZSBpcyB0aGUgcmVzdWx0IG9mIGEgXFxwcmVzY3JpcHQgZnVuY3Rpb24uXG4gICAgICAgIC8vIFdyaXRlIHRoZSBzdWItICYgc3VwZXJzY3JpcHRzIGludG8gdGhlIG11bHRpc2NyaXB0IGVsZW1lbnQuXG4gICAgICAgIGJhc2UucG9zdHNjcmlwdHMgPSB7IHN1cDogc3VwZXJzY3JpcHQsIHN1Yjogc3Vic2NyaXB0IH07XG4gICAgICAgIHJldHVybiBiYXNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgICAgY29uc3QgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyID0gKCFiYXNlIHx8IGJhc2UudHlwZSAhPT0gXCJvcFwiICYmIGJhc2UudHlwZSAhPT0gXCJvcGVyYXRvcm5hbWVcIilcbiAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgIDogaXNEZWxpbWl0ZXIodGhpcy5uZXh0VG9rZW4udGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzdXBzdWJcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICBzdXA6IHN1cGVyc2NyaXB0LFxuICAgICAgICAgIHN1Yjogc3Vic2NyaXB0LFxuICAgICAgICAgIGlzRm9sbG93ZWRCeURlbGltaXRlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gZW50aXJlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgaXRzIGJhc2UgYW5kIGFsbCBvZiBpdHMgYXJndW1lbnRzLlxuICAgKi9cbiAgcGFyc2VGdW5jdGlvbihcbiAgICBicmVha09uVG9rZW5UZXh0LFxuICAgIG5hbWUgLy8gRm9yIGRldGVybWluaW5nIGl0cyBjb250ZXh0XG4gICkge1xuICAgIGNvbnN0IHRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IGZ1bmMgPSB0b2tlbi50ZXh0O1xuICAgIGNvbnN0IGZ1bmNEYXRhID0gZnVuY3Rpb25zW2Z1bmNdO1xuICAgIGlmICghZnVuY0RhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gY29uc3VtZSBjb21tYW5kIHRva2VuXG5cbiAgICBpZiAobmFtZSAmJiBuYW1lICE9PSBcImF0b21cIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluQXJndW1lbnQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIHdpdGggbm8gYXJndW1lbnRzXCIgKyAobmFtZSA/IFwiIGFzIFwiICsgbmFtZSA6IFwiXCIpLFxuICAgICAgICB0b2tlblxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIgJiYgIWZ1bmNEYXRhLmFsbG93ZWRJblRleHQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsIHRva2VuKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIgJiYgZnVuY0RhdGEuYWxsb3dlZEluTWF0aCA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gbWF0aCBtb2RlXCIsIHRva2VuKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2QXRvbVR5cGUgPSB0aGlzLnByZXZBdG9tVHlwZTtcbiAgICBjb25zdCB7IGFyZ3MsIG9wdEFyZ3MgfSA9IHRoaXMucGFyc2VBcmd1bWVudHMoZnVuYywgZnVuY0RhdGEpO1xuICAgIHRoaXMucHJldkF0b21UeXBlID0gcHJldkF0b21UeXBlO1xuICAgIHJldHVybiB0aGlzLmNhbGxGdW5jdGlvbihmdW5jLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCBhIGZ1bmN0aW9uIGhhbmRsZXIgd2l0aCBhIHN1aXRhYmxlIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAgICovXG4gIGNhbGxGdW5jdGlvbihuYW1lLCBhcmdzLCBvcHRBcmdzLCB0b2tlbiwgYnJlYWtPblRva2VuVGV4dCkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBmdW5jTmFtZTogbmFtZSxcbiAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgIHRva2VuLFxuICAgICAgYnJlYWtPblRva2VuVGV4dFxuICAgIH07XG4gICAgY29uc3QgZnVuYyA9IGZ1bmN0aW9uc1tuYW1lXTtcbiAgICBpZiAoZnVuYyAmJiBmdW5jLmhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBmdW5jLmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBObyBmdW5jdGlvbiBoYW5kbGVyIGZvciAke25hbWV9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gb3IgZW52aXJvbm1lbnRcbiAgICovXG4gIHBhcnNlQXJndW1lbnRzKFxuICAgIGZ1bmMsIC8vIFNob3VsZCBsb29rIGxpa2UgXCJcXG5hbWVcIiBvciBcIlxcYmVnaW57bmFtZX1cIi5cbiAgICBmdW5jRGF0YVxuICApIHtcbiAgICBjb25zdCB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgIHJldHVybiB7IGFyZ3M6IFtdLCBvcHRBcmdzOiBbXSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGFyZ3MgPSBbXTtcbiAgICBjb25zdCBvcHRBcmdzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsQXJnczsgaSsrKSB7XG4gICAgICBsZXQgYXJnVHlwZSA9IGZ1bmNEYXRhLmFyZ1R5cGVzICYmIGZ1bmNEYXRhLmFyZ1R5cGVzW2ldO1xuICAgICAgY29uc3QgaXNPcHRpb25hbCA9IGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3M7XG5cbiAgICAgIGlmIChcbiAgICAgICAgKGZ1bmNEYXRhLnByaW1pdGl2ZSAmJiBhcmdUeXBlID09IG51bGwpIHx8XG4gICAgICAgIC8vIFxcc3FydCBleHBhbmRzIGludG8gcHJpbWl0aXZlIGlmIG9wdGlvbmFsIGFyZ3VtZW50IGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgKGZ1bmNEYXRhLnR5cGUgPT09IFwic3FydFwiICYmIGkgPT09IDEgJiYgb3B0QXJnc1swXSA9PSBudWxsKVxuICAgICAgKSB7XG4gICAgICAgIGFyZ1R5cGUgPSBcInByaW1pdGl2ZVwiO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmcgPSB0aGlzLnBhcnNlR3JvdXBPZlR5cGUoYGFyZ3VtZW50IHRvICcke2Z1bmN9J2AsIGFyZ1R5cGUsIGlzT3B0aW9uYWwpO1xuICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgb3B0QXJncy5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2UgaWYgKGFyZyAhPSBudWxsKSB7XG4gICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlXG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTnVsbCBhcmd1bWVudCwgcGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGFyZ3MsIG9wdEFyZ3MgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCB3aGVuIHRoZSBtb2RlIGlzIGNoYW5naW5nLlxuICAgKi9cbiAgcGFyc2VHcm91cE9mVHlwZShuYW1lLCB0eXBlLCBvcHRpb25hbCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuICAgICAgY2FzZSBcInVybFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVVybEdyb3VwKG9wdGlvbmFsKTtcbiAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICBjYXNlIFwidGV4dFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIHR5cGUpO1xuICAgICAgY2FzZSBcImhib3hcIjoge1xuICAgICAgICAvLyBoYm94IGFyZ3VtZW50IHR5cGUgd3JhcHMgdGhlIGFyZ3VtZW50IGluIHRoZSBlcXVpdmFsZW50IG9mXG4gICAgICAgIC8vIFxcaGJveCwgd2hpY2ggaXMgbGlrZSBcXHRleHQgYnV0IHN3aXRjaGluZyB0byBcXHRleHRzdHlsZSBzaXplLlxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCBcInRleHRcIik7XG4gICAgICAgIHJldHVybiBncm91cCAhPSBudWxsXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgICAgICAgIG1vZGU6IGdyb3VwLm1vZGUsXG4gICAgICAgICAgICBib2R5OiBbZ3JvdXBdLFxuICAgICAgICAgICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiIC8vIHNpbXVsYXRlIFxcdGV4dHN0eWxlXG4gICAgICAgICAgfVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJyYXdcIjoge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInJhd1wiLCBvcHRpb25hbCk7XG4gICAgICAgIHJldHVybiB0b2tlbiAhPSBudWxsXG4gICAgICAgICAgPyB7XG4gICAgICAgICAgICB0eXBlOiBcInJhd1wiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBzdHJpbmc6IHRva2VuLnRleHRcbiAgICAgICAgICB9XG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuICAgICAgY2FzZSBcInByaW1pdGl2ZVwiOiB7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQSBwcmltaXRpdmUgYXJndW1lbnQgY2Fubm90IGJlIG9wdGlvbmFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUpO1xuICAgICAgICBpZiAoZ3JvdXAgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgZ3JvdXAgYXMgXCIgKyBuYW1lLCB0aGlzLmZldGNoKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvcmlnaW5hbFwiOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gZ3JvdXAgdHlwZSBhcyBcIiArIG5hbWUsIHRoaXMuZmV0Y2goKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2NhcmQgYW55IHNwYWNlIHRva2VucywgZmV0Y2hpbmcgdGhlIG5leHQgbm9uLXNwYWNlIHRva2VuLlxuICAgKi9cbiAgY29uc3VtZVNwYWNlcygpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmZldGNoKCkudGV4dDtcbiAgICAgIC8vIFxcdWZlMGUgaXMgdGhlIFVuaWNvZGUgdmFyaWF0aW9uIHNlbGVjdG9yIHRvIHN1cHJlc3MgZW1vamkuIElnbm9yZSBpdC5cbiAgICAgIGlmIChjaCA9PT0gXCIgXCIgfHwgY2ggPT09IFwiXFx1MDBhMFwiIHx8IGNoID09PSBcIlxcdWZlMGVcIikge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwLCBlc3NlbnRpYWxseSByZXR1cm5pbmcgdGhlIHN0cmluZyBmb3JtZWQgYnkgdGhlXG4gICAqIGJyYWNlLWVuY2xvc2VkIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBwYXJzZVN0cmluZ0dyb3VwKFxuICAgIG1vZGVOYW1lLCAvLyBVc2VkIHRvIGRlc2NyaWJlIHRoZSBtb2RlIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgIG9wdGlvbmFsXG4gICkge1xuICAgIGNvbnN0IGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTtcbiAgICBpZiAoYXJnVG9rZW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGxldCBuZXh0VG9rZW47XG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IFwiRU9GXCIpIHtcbiAgICAgIHN0ciArPSBuZXh0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnN1bWUoKTsgLy8gY29uc3VtZSB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudFxuICAgIGFyZ1Rva2VuLnRleHQgPSBzdHI7XG4gICAgcmV0dXJuIGFyZ1Rva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gICAqIHdob3NlIGNvbmNhdGVuYXRlZCBzdHJpbmdzIG1hdGNoIGByZWdleGAuIFJldHVybnMgdGhlIHN0cmluZ1xuICAgKiBmb3JtZWQgYnkgdGhlIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBwYXJzZVJlZ2V4R3JvdXAoXG4gICAgcmVnZXgsXG4gICAgbW9kZU5hbWUgLy8gVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlcy5cbiAgKSB7XG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBsZXQgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBsZXQgbmV4dFRva2VuO1xuICAgIHdoaWxlICgobmV4dFRva2VuID0gdGhpcy5mZXRjaCgpKS50ZXh0ICE9PSBcIkVPRlwiICYmIHJlZ2V4LnRlc3Qoc3RyICsgbmV4dFRva2VuLnRleHQpKSB7XG4gICAgICBsYXN0VG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gICAgaWYgKHN0ciA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIFwiICsgbW9kZU5hbWUgKyBcIjogJ1wiICsgZmlyc3RUb2tlbi50ZXh0ICsgXCInXCIsIGZpcnN0VG9rZW4pO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgc2l6ZSBzcGVjaWZpY2F0aW9uLCBjb25zaXN0aW5nIG9mIG1hZ25pdHVkZSBhbmQgdW5pdC5cbiAgICovXG4gIHBhcnNlU2l6ZUdyb3VwKG9wdGlvbmFsKSB7XG4gICAgbGV0IHJlcztcbiAgICBsZXQgaXNCbGFuayA9IGZhbHNlO1xuICAgIC8vIGRvbid0IGV4cGFuZCBiZWZvcmUgcGFyc2VTdHJpbmdHcm91cFxuICAgIHRoaXMuZ3VsbGV0LmNvbnN1bWVTcGFjZXMoKTtcbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwie1wiKSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlUmVnZXhHcm91cCgvXlstK10/ICooPzokfFxcZCt8XFxkK1xcLlxcZCp8XFwuXFxkKikgKlthLXpdezAsMn0gKiQvLCBcInNpemVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInNpemVcIiwgb3B0aW9uYWwpO1xuICAgIH1cbiAgICBpZiAoIXJlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghb3B0aW9uYWwgJiYgcmVzLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBCZWNhdXNlIHdlJ3ZlIHRlc3RlZCBmb3Igd2hhdCBpcyAhb3B0aW9uYWwsIHRoaXMgYmxvY2sgd29uJ3RcbiAgICAgIC8vIGFmZmVjdCBcXGtlcm4sIFxcaHNwYWNlLCBldGMuIEl0IHdpbGwgY2FwdHVyZSB0aGUgbWFuZGF0b3J5IGFyZ3VtZW50c1xuICAgICAgLy8gdG8gXFxnZW5mcmFjIGFuZCBcXGFib3ZlLlxuICAgICAgcmVzLnRleHQgPSBcIjBwdFwiOyAvLyBFbmFibGUgXFxhYm92ZXt9XG4gICAgICBpc0JsYW5rID0gdHJ1ZTsgLy8gVGhpcyBpcyBoZXJlIHNwZWNpZmljYWxseSBmb3IgXFxnZW5mcmFjXG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gc2l6ZVJlZ0V4LmV4ZWMocmVzLnRleHQpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgdW5pdDogbWF0Y2hbM11cbiAgICB9O1xuICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgZGF0YS51bml0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemVcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgaXNCbGFua1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIFVSTCwgY2hlY2tpbmcgZXNjYXBlZCBsZXR0ZXJzIGFuZCBhbGxvd2VkIHByb3RvY29scyxcbiAgICogYW5kIHNldHRpbmcgdGhlIGNhdGNvZGUgb2YgJSBhcyBhbiBhY3RpdmUgY2hhcmFjdGVyIChhcyBpbiBcXGh5cGVycmVmKS5cbiAgICovXG4gIHBhcnNlVXJsR3JvdXAob3B0aW9uYWwpIHtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxMyk7IC8vIGFjdGl2ZSBjaGFyYWN0ZXJcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiflwiLCAxMik7IC8vIG90aGVyIGNoYXJhY3RlclxuICAgIGNvbnN0IHJlcyA9IHRoaXMucGFyc2VTdHJpbmdHcm91cChcInVybFwiLCBvcHRpb25hbCk7XG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIiVcIiwgMTQpOyAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCJ+XCIsIDEzKTsgLy8gYWN0aXZlIGNoYXJhY3RlclxuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIGh5cGVycmVmIHBhY2thZ2UgYWxsb3dzIGJhY2tzbGFzaGVzIGFsb25lIGluIGhyZWYsIGJ1dCBkb2Vzbid0XG4gICAgLy8gZ2VuZXJhdGUgdmFsaWQgbGlua3MgaW4gc3VjaCBjYXNlczsgd2UgaW50ZXJwcmV0IHRoaXMgYXNcbiAgICAvLyBcInVuZGVmaW5lZFwiIGJlaGF2aW91ciwgYW5kIGtlZXAgdGhlbSBhcy1pcy4gU29tZSBicm93c2VyIHdpbGxcbiAgICAvLyByZXBsYWNlIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZCBzbGFzaGVzLlxuICAgIGxldCB1cmwgPSByZXMudGV4dC5yZXBsYWNlKC9cXFxcKFsjJCUmfl9ee31dKS9nLCBcIiQxXCIpO1xuICAgIHVybCA9IHJlcy50ZXh0LnJlcGxhY2UoL3tcXHUyMDQ0fS9nLCBcIi9cIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB1cmxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBhcmd1bWVudCB3aXRoIHRoZSBtb2RlIHNwZWNpZmllZC5cbiAgICovXG4gIHBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgbW9kZSkge1xuICAgIGNvbnN0IGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTtcbiAgICBpZiAoYXJnVG9rZW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG91dGVyTW9kZSA9IHRoaXMubW9kZTtcbiAgICBpZiAobW9kZSkge1xuICAgICAgLy8gU3dpdGNoIHRvIHNwZWNpZmllZCBtb2RlXG4gICAgICB0aGlzLnN3aXRjaE1vZGUobW9kZSk7XG4gICAgfVxuXG4gICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgXCJFT0ZcIik7XG4gICAgLy8gVE9ETzogZmluZCBhbiBhbHRlcm5hdGl2ZSB3YXkgdG8gZGVub3RlIHRoZSBlbmRcbiAgICB0aGlzLmV4cGVjdChcIkVPRlwiKTsgLy8gZXhwZWN0IHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50XG4gICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBsb2M6IGFyZ1Rva2VuLmxvYyxcbiAgICAgIGJvZHk6IGV4cHJlc3Npb25cbiAgICB9O1xuXG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIC8vIFN3aXRjaCBtb2RlIGJhY2tcbiAgICAgIHRoaXMuc3dpdGNoTW9kZShvdXRlck1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCwgd2hpY2ggaXMgZWl0aGVyIGEgc2luZ2xlIG51Y2xldXMgKGxpa2UgXCJ4XCIpXG4gICAqIG9yIGFuIGV4cHJlc3Npb24gaW4gYnJhY2VzIChsaWtlIFwie3greX1cIikgb3IgYW4gaW1wbGljaXQgZ3JvdXAsIGEgZ3JvdXBcbiAgICogdGhhdCBzdGFydHMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCBlbmRzIHJpZ2h0IGJlZm9yZSBhIGhpZ2hlciBleHBsaWNpdFxuICAgKiBncm91cCBlbmRzLCBvciBhdCBFT0YuXG4gICAqL1xuICBwYXJzZUdyb3VwKFxuICAgIG5hbWUsIC8vIEZvciBlcnJvciByZXBvcnRpbmcuXG4gICAgYnJlYWtPblRva2VuVGV4dFxuICApIHtcbiAgICBjb25zdCBmaXJzdFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGNvbnN0IHRleHQgPSBmaXJzdFRva2VuLnRleHQ7XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIC8vIFRyeSB0byBwYXJzZSBhbiBvcGVuIGJyYWNlIG9yIFxcYmVnaW5ncm91cFxuICAgIGlmICh0ZXh0ID09PSBcIntcIiB8fCB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIgfHwgdGV4dCA9PT0gXCJcXFxcdG9nZ2xlXCIpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgY29uc3QgZ3JvdXBFbmQgPSB0ZXh0ID09PSBcIntcIlxuICAgICAgICA/IFwifVwiXG4gICAgICAgIDogdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiXG4gICAgICAgID8gXCJcXFxcZW5kZ3JvdXBcIlxuICAgICAgICA6IFwiXFxcXGVuZHRvZ2dsZVwiO1xuXG4gICAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gICAgICAvLyBJZiB3ZSBnZXQgYSBicmFjZSwgcGFyc2UgYW4gZXhwcmVzc2lvblxuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBncm91cEVuZCk7XG4gICAgICBjb25zdCBsYXN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgICB0aGlzLmV4cGVjdChncm91cEVuZCk7IC8vIENoZWNrIHRoYXQgd2UgZ290IGEgbWF0Y2hpbmcgY2xvc2luZyBicmFjZVxuICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogKGxhc3RUb2tlbi50ZXh0ID09PSBcIlxcXFxlbmR0b2dnbGVcIiA/IFwidG9nZ2xlXCIgOiBcIm9yZGdyb3VwXCIpLFxuICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoZmlyc3RUb2tlbiwgbGFzdFRva2VuKSxcbiAgICAgICAgYm9keTogZXhwcmVzc2lvbixcbiAgICAgICAgLy8gQSBncm91cCBmb3JtZWQgYnkgXFxiZWdpbmdyb3VwLi4uXFxlbmRncm91cCBpcyBhIHNlbWktc2ltcGxlIGdyb3VwXG4gICAgICAgIC8vIHdoaWNoIGRvZXNuJ3QgYWZmZWN0IHNwYWNpbmcgaW4gbWF0aCBtb2RlLCBpLmUuLCBpcyB0cmFuc3BhcmVudC5cbiAgICAgICAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE5MzAvXG4gICAgICAgIHNlbWlzaW1wbGU6IHRleHQgPT09IFwiXFxcXGJlZ2luZ3JvdXBcIiB8fCB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBhIGZ1bmN0aW9uIHdpdGggdGhpcyBuYW1lLCBwYXJzZSB0aGUgZnVuY3Rpb24uXG4gICAgICAvLyBPdGhlcndpc2UsIGp1c3QgcmV0dXJuIGEgbnVjbGV1c1xuICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUpIHx8IHRoaXMucGFyc2VTeW1ib2woKTtcbiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiB0ZXh0WzBdID09PSBcIlxcXFxcIiAmJlxuICAgICAgICAgICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW1wbGljaXRDb21tYW5kcywgdGV4dCApKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZm9ybWF0VW5zdXBwb3J0ZWRDbWQodGV4dCk7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm0gbGlnYXR1cmUtbGlrZSBjb21iaW5hdGlvbnMgb2YgY2hhcmFjdGVycyBmb3IgdGV4dCBtb2RlLlxuICAgKiBUaGlzIGluY2x1ZGVzIGlucHV0cyBsaWtlIFwiLS1cIiwgXCItLS1cIiwgXCJgYFwiIGFuZCBcIicnXCIuXG4gICAqIFRoZSByZXN1bHQgd2lsbCBzaW1wbHkgcmVwbGFjZSBtdWx0aXBsZSB0ZXh0b3JkIG5vZGVzIHdpdGggYSBzaW5nbGVcbiAgICogY2hhcmFjdGVyIGluIGVhY2ggdmFsdWUgYnkgYSBzaW5nbGUgdGV4dG9yZCBub2RlIGhhdmluZyBtdWx0aXBsZVxuICAgKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuXG4gICAqIFRoZSBncm91cCB3aWxsIGJlIG1vZGlmaWVkIGluIHBsYWNlLlxuICAgKi9cbiAgZm9ybUxpZ2F0dXJlcyhncm91cCkge1xuICAgIGxldCBuID0gZ3JvdXAubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgYSA9IGdyb3VwW2ldO1xuICAgICAgY29uc3QgdiA9IGEudGV4dDtcbiAgICAgIGlmICh2ID09PSBcIi1cIiAmJiBncm91cFtpICsgMV0udGV4dCA9PT0gXCItXCIpIHtcbiAgICAgICAgaWYgKGkgKyAxIDwgbiAmJiBncm91cFtpICsgMl0udGV4dCA9PT0gXCItXCIpIHtcbiAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMywge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDJdKSxcbiAgICAgICAgICAgIHRleHQ6IFwiLS0tXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuIC09IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAxXSksXG4gICAgICAgICAgICB0ZXh0OiBcIi0tXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuIC09IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgodiA9PT0gXCInXCIgfHwgdiA9PT0gXCJgXCIpICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSB2KSB7XG4gICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgIHRleHQ6IHYgKyB2XG4gICAgICAgIH0pO1xuICAgICAgICBuIC09IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgc2luZ2xlIHN5bWJvbCBvdXQgb2YgdGhlIHN0cmluZy4gSGVyZSwgd2UgaGFuZGxlIHNpbmdsZSBjaGFyYWN0ZXJcbiAgICogc3ltYm9scyBhbmQgc3BlY2lhbCBmdW5jdGlvbnMgbGlrZSBcXHZlcmIuXG4gICAqL1xuICBwYXJzZVN5bWJvbCgpIHtcbiAgICBjb25zdCBudWNsZXVzID0gdGhpcy5mZXRjaCgpO1xuICAgIGxldCB0ZXh0ID0gbnVjbGV1cy50ZXh0O1xuXG4gICAgaWYgKC9eXFxcXHZlcmJbXmEtekEtWl0vLnRlc3QodGV4dCkpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgbGV0IGFyZyA9IHRleHQuc2xpY2UoNSk7XG4gICAgICBjb25zdCBzdGFyID0gYXJnLmNoYXJBdCgwKSA9PT0gXCIqXCI7XG4gICAgICBpZiAoc3Rhcikge1xuICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICAvLyBMZXhlcidzIHRva2VuUmVnZXggaXMgY29uc3RydWN0ZWQgdG8gYWx3YXlzIGhhdmUgbWF0Y2hpbmdcbiAgICAgIC8vIGZpcnN0L2xhc3QgY2hhcmFjdGVycy5cbiAgICAgIGlmIChhcmcubGVuZ3RoIDwgMiB8fCBhcmcuY2hhckF0KDApICE9PSBhcmcuc2xpY2UoLTEpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBcXFxcdmVyYiBhc3NlcnRpb24gZmFpbGVkIC0tXG4gICAgICAgICAgICAgICAgICAgIHBsZWFzZSByZXBvcnQgd2hhdCBpbnB1dCBjYXVzZWQgdGhpcyBidWdgKTtcbiAgICAgIH1cbiAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7IC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBjaGFyXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInZlcmJcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IGFyZyxcbiAgICAgICAgc3RhclxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2Ugc2hvdWxkIGhhdmUgYSBzeW1ib2wsIHBvc3NpYmx5IHdpdGggYWNjZW50cy5cbiAgICAvLyBGaXJzdCBleHBhbmQgYW55IGFjY2VudGVkIGJhc2Ugc3ltYm9sIGFjY29yZGluZyB0byB1bmljb2RlU3ltYm9scy5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHVuaWNvZGVTeW1ib2xzLCB0ZXh0WzBdKSAmJlxuICAgICAgdGhpcy5tb2RlID09PSBcIm1hdGhcIiAmJiAhc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRbMF1dKSB7XG4gICAgICAvLyBUaGlzIGJlaGF2aW9yIGlzIG5vdCBzdHJpY3QgKFhlVGVYLWNvbXBhdGlibGUpIGluIG1hdGggbW9kZS5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBBY2NlbnRlZCBVbmljb2RlIHRleHQgY2hhcmFjdGVyIFwiJHt0ZXh0WzBdfVwiIHVzZWQgaW4gYCArIGBtYXRoIG1vZGVgLFxuICAgICAgICAgIG51Y2xldXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRleHQgPSB1bmljb2RlU3ltYm9sc1t0ZXh0WzBdXSArIHRleHQuc2xpY2UoMSk7XG4gICAgfVxuICAgIC8vIFN0cmlwIG9mZiBhbnkgY29tYmluaW5nIGNoYXJhY3RlcnNcbiAgICBjb25zdCBtYXRjaCA9IHRoaXMubW9kZSA9PT0gXCJtYXRoXCJcbiAgICAgID8gY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4LmV4ZWModGV4dClcbiAgICAgIDogbnVsbDtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG4gICAgICBpZiAodGV4dCA9PT0gXCJpXCIpIHtcbiAgICAgICAgdGV4dCA9IFwiXFx1MDEzMVwiOyAvLyBkb3RsZXNzIGksIGluIG1hdGggYW5kIHRleHQgbW9kZVxuICAgICAgfSBlbHNlIGlmICh0ZXh0ID09PSBcImpcIikge1xuICAgICAgICB0ZXh0ID0gXCJcXHUwMjM3XCI7IC8vIGRvdGxlc3MgaiwgaW4gbWF0aCBhbmQgdGV4dCBtb2RlXG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlY29nbml6ZSBiYXNlIHN5bWJvbFxuICAgIGxldCBzeW1ib2w7XG4gICAgaWYgKHN5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0XSkge1xuICAgICAgbGV0IGdyb3VwID0gc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRdLmdyb3VwO1xuICAgICAgaWYgKGdyb3VwID09PSBcImJpblwiICYmIGJpbkxlZnRDYW5jZWxsZXJzLmluY2x1ZGVzKHRoaXMucHJldkF0b21UeXBlKSkge1xuICAgICAgICAvLyBDaGFuZ2UgZnJvbSBhIGJpbmFyeSBvcGVyYXRvciB0byBhIHVuYXJ5IChwcmVmaXgpIG9wZXJhdG9yXG4gICAgICAgIGdyb3VwID0gXCJvcGVuXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2MgPSBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKTtcbiAgICAgIGxldCBzO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChBVE9NUywgZ3JvdXAgKSkge1xuICAgICAgICBjb25zdCBmYW1pbHkgPSBncm91cDtcbiAgICAgICAgcyA9IHtcbiAgICAgICAgICB0eXBlOiBcImF0b21cIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgZmFtaWx5LFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICAgIGlmICgoZmFtaWx5ID09PSBcInJlbFwiIHx8IGZhbWlseSA9PT0gXCJiaW5cIikgJiYgdGhpcy5wcmV2QXRvbVR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgaWYgKHRleHRSZWdFeC50ZXN0KGxvYy5sZXhlci5pbnB1dC5zbGljZShsb2MuZW5kKSkpIHtcbiAgICAgICAgICAgIHMubmVlZHNTcGFjaW5nID0gdHJ1ZTsgIC8vIEZpeCBhIE1hdGhNTCBidWcuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYXNjaWlGcm9tU2NyaXB0W3RleHRdKSB7XG4gICAgICAgICAgLy8gVW5pY29kZSAxNCBkaXNhbWJpZ3VhdGVzIGNoYW5jZXJ5IGZyb20gcm91bmRoYW5kLlxuICAgICAgICAgIC8vIFNlZSBodHRwczovL3d3dy51bmljb2RlLm9yZy9jaGFydHMvUERGL1UxRDQwMC5wZGZcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICBjb25zdCBuZXh0Q29kZSA9IHRoaXMuZmV0Y2goKS50ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgLy8gbWF0aGNhbCBpcyBUZW1tbCBkZWZhdWx0LiBVc2UgbWF0aHNjcmlwdCBpZiBjYWxsZWQgZm9yLlxuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXh0Q29kZSA9PT0gMHhmZTAxID8gXCJtYXRoc2NyXCIgOiBcIm1hdGhjYWxcIjtcbiAgICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4ZmUwMCB8fCBuZXh0Q29kZSA9PT0gMHhmZTAxKSB7IHRoaXMuY29uc3VtZSgpOyB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgYm9keTogeyB0eXBlOiBcIm1hdGhvcmRcIiwgbW9kZTogXCJtYXRoXCIsIGxvYywgdGV4dDogYXNjaWlGcm9tU2NyaXB0W3RleHRdIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVmYXVsdCBvcmQgY2hhcmFjdGVyLiBObyBkaXNhbWJpZ3VhdGlvbiBuZWNlc3NhcnkuXG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogZ3JvdXAsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzeW1ib2wgPSBzO1xuICAgIH0gZWxzZSBpZiAodGV4dC5jaGFyQ29kZUF0KDApID49IDB4ODAgfHwgY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4LmV4ZWModGV4dCkpIHtcbiAgICAgIC8vIG5vIHN5bWJvbCBmb3IgZS5nLiBeXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QgJiYgdGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcIiR7dGV4dFswXX1cIiB1c2VkIGluIG1hdGggbW9kZWAsIG51Y2xldXMpXG4gICAgICB9XG4gICAgICAvLyBBbGwgbm9ubWF0aGVtYXRpY2FsIFVuaWNvZGUgY2hhcmFjdGVycyBhcmUgcmVuZGVyZWQgYXMgaWYgdGhleVxuICAgICAgLy8gYXJlIGluIHRleHQgbW9kZSAod3JhcHBlZCBpbiBcXHRleHQpIGJlY2F1c2UgdGhhdCdzIHdoYXQgaXRcbiAgICAgIC8vIHRha2VzIHRvIHJlbmRlciB0aGVtIGluIExhVGVYLlxuICAgICAgc3ltYm9sID0ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgIHRleHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBFT0YsIF4sIF8sIHssIH0sIGV0Yy5cbiAgICB9XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgLy8gVHJhbnNmb3JtIGNvbWJpbmluZyBjaGFyYWN0ZXJzIGludG8gYWNjZW50c1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaFswXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhY2NlbnQgPSBtYXRjaFswXVtpXTtcbiAgICAgICAgaWYgKCF1bmljb2RlQWNjZW50c1thY2NlbnRdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFVua25vd24gYWNjZW50ICcgJHthY2NlbnR9J2AsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB1bmljb2RlQWNjZW50c1thY2NlbnRdW3RoaXMubW9kZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaWNvZGVBY2NlbnRzW2FjY2VudF0udGV4dDtcbiAgICAgICAgaWYgKCFjb21tYW5kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEFjY2VudCAke2FjY2VudH0gdW5zdXBwb3J0ZWQgaW4gJHt0aGlzLm1vZGV9IG1vZGVgLCBudWNsZXVzKTtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2wgPSB7XG4gICAgICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgICBsYWJlbDogY29tbWFuZCxcbiAgICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgICAgICBiYXNlOiBzeW1ib2xcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbmNvbnN0IHBhcnNlVHJlZSA9IGZ1bmN0aW9uKHRvUGFyc2UsIHNldHRpbmdzKSB7XG4gIGlmICghKHR5cGVvZiB0b1BhcnNlID09PSBcInN0cmluZ1wiIHx8IHRvUGFyc2UgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbW1sIGNhbiBvbmx5IHBhcnNlIHN0cmluZyB0eXBlZCBleHByZXNzaW9uXCIpXG4gIH1cbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7XG4gIC8vIEJsYW5rIG91dCBhbnkgXFxkZkB0YWcgdG8gYXZvaWQgc3B1cmlvdXMgXCJEdXBsaWNhdGUgXFx0YWdcIiBlcnJvcnNcbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdO1xuXG4gIGxldCB0cmVlID0gcGFyc2VyLnBhcnNlKCk7XG5cbiAgLy8gTGFUZVggaWdub3JlcyBhIFxcdGFnIHBsYWNlZCBvdXRzaWRlIGFuIEFNUyBlbnZpcm9ubWVudC5cbiAgaWYgKCEodHJlZS5sZW5ndGggPiAwICYmICB0cmVlWzBdLnR5cGUgJiYgdHJlZVswXS50eXBlID09PSBcImFycmF5XCIgJiYgdHJlZVswXS5hZGRFcW5OdW0pKSB7XG4gICAgLy8gSWYgdGhlIGlucHV0IHVzZWQgXFx0YWcsIGl0IHdpbGwgc2V0IHRoZSBcXGRmQHRhZyBtYWNybyB0byB0aGUgdGFnLlxuICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugc2VwYXJhdGVseSBwYXJzZSB0aGUgdGFnIGFuZCB3cmFwIHRoZSB0cmVlLlxuICAgIGlmIChwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgICBpZiAoIXNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXHRhZyB3b3JrcyBvbmx5IGluIGRpc3BsYXkgbW9kZVwiKVxuICAgICAgfVxuICAgICAgcGFyc2VyLmd1bGxldC5mZWVkKFwiXFxcXGRmQHRhZ1wiKTtcbiAgICAgIHRyZWUgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInRhZ1wiLFxuICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgIGJvZHk6IHRyZWUsXG4gICAgICAgICAgdGFnOiBwYXJzZXIucGFyc2UoKVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cmVlXG59O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3R5bGUgdGhhdCB0aGUgbWF0aG1sQnVpbGRlciBjYXJyaWVzXG4gKiBhcm91bmQgd2l0aCBpdC4gRGF0YSBpcyBoZWxkIGluIGFuIGBTdHlsZWAgb2JqZWN0LCBhbmQgd2hlblxuICogcmVjdXJzaW5nLCBhIG5ldyBgU3R5bGVgIG9iamVjdCBjYW4gYmUgY3JlYXRlZCB3aXRoIHRoZSBgLndpdGgqYCBmdW5jdGlvbnMuXG4gKi9cblxuY29uc3Qgc3ViT3JTdXBMZXZlbCA9IFsyLCAyLCAzLCAzXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIFN0eWxlIGNsYXNzLiBJdCBjb250YWlucyB0aGUgY3VycmVudCBzdHlsZS5sZXZlbCwgY29sb3IsIGFuZCBmb250LlxuICpcbiAqIFN0eWxlIG9iamVjdHMgc2hvdWxkIG5vdCBiZSBtb2RpZmllZC4gVG8gY3JlYXRlIGEgbmV3IFN0eWxlIHdpdGhcbiAqIGRpZmZlcmVudCBwcm9wZXJ0aWVzLCBjYWxsIGEgYC53aXRoKmAgbWV0aG9kLlxuICovXG5jbGFzcyBTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICAvLyBTdHlsZS5sZXZlbCBjYW4gYmUgMCB8IDEgfCAyIHwgMywgd2hpY2ggY29ycmVzcG9uZCB0b1xuICAgIC8vICAgICAgIGRpc3BsYXlzdHlsZSwgdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlLlxuICAgIC8vIHN0eWxlLmxldmVsIHVzdWFsbHkgZG9lcyBub3QgZGlyZWN0bHkgc2V0IE1hdGhNTCdzIHNjcmlwdCBsZXZlbC4gTWF0aE1MIGRvZXMgdGhhdCBpdHNlbGYuXG4gICAgLy8gSG93ZXZlciwgQ2hyb21pdW0gZG9lcyBub3Qgc3RvcCBzaHJpbmtpbmcgYWZ0ZXIgc2NyaXB0c2NyaXB0c3R5bGUsIHNvIHdlIGRvIGV4cGxpY2l0bHlcbiAgICAvLyBzZXQgYSBzY3JpcHRsZXZlbCBhdHRyaWJ1dGUgaW4gdGhvc2UgY29uZGl0aW9ucy5cbiAgICAvLyBXZSBhbHNvIHVzZSBzdHlsZS5sZXZlbCB0byB0cmFjayBtYXRoIHN0eWxlIHNvIHRoYXQgd2UgY2FuIGdldCB0aGUgY29ycmVjdFxuICAgIC8vIHNjcmlwdGxldmVsIHdoZW4gbmVlZGVkIGluIHN1cHN1Yi5qcywgbWF0aGNob2ljZS5qcywgb3IgZm9yIGRpbWVuc2lvbnMgaW4gZW0uXG4gICAgdGhpcy5sZXZlbCA9IGRhdGEubGV2ZWw7XG4gICAgdGhpcy5jb2xvciA9IGRhdGEuY29sb3I7ICAvLyBzdHJpbmcgfCB2b2lkXG4gICAgLy8gQSBmb250IGZhbWlseSBhcHBsaWVzIHRvIGEgZ3JvdXAgb2YgZm9udHMgKGkuZS4gU2Fuc1NlcmlmKSwgd2hpbGUgYSBmb250XG4gICAgLy8gcmVwcmVzZW50cyBhIHNwZWNpZmljIGZvbnQgKGkuZS4gU2Fuc1NlcmlmIEJvbGQpLlxuICAgIC8vIFNlZTogaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIyMzUwL2RpZmZlcmVuY2UtYmV0d2Vlbi10ZXh0cm0tYW5kLW1hdGhybVxuICAgIHRoaXMuZm9udCA9IGRhdGEuZm9udCB8fCBcIlwiOyAgICAgICAgICAgICAgICAvLyBzdHJpbmdcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBkYXRhLmZvbnRGYW1pbHkgfHwgXCJcIjsgICAgLy8gc3RyaW5nXG4gICAgdGhpcy5mb250U2l6ZSA9IGRhdGEuZm9udFNpemUgfHwgMS4wOyAgICAgICAvLyBudW1iZXJcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBkYXRhLmZvbnRXZWlnaHQgfHwgXCJcIjtcbiAgICB0aGlzLmZvbnRTaGFwZSA9IGRhdGEuZm9udFNoYXBlIHx8IFwiXCI7XG4gICAgdGhpcy5tYXhTaXplID0gZGF0YS5tYXhTaXplOyAgICAgICAgICAgICAgICAvLyBbbnVtYmVyLCBudW1iZXJdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIFwidGhpc1wiLiAgUHJvcGVydGllc1xuICAgKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBzdHlsZSBvYmplY3QuXG4gICAqL1xuICBleHRlbmQoZXh0ZW5zaW9uKSB7XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIGxldmVsOiB0aGlzLmxldmVsLFxuICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICBmb250OiB0aGlzLmZvbnQsXG4gICAgICBmb250RmFtaWx5OiB0aGlzLmZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZTogdGhpcy5mb250U2l6ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCxcbiAgICAgIGZvbnRTaGFwZTogdGhpcy5mb250U2hhcGUsXG4gICAgICBtYXhTaXplOiB0aGlzLm1heFNpemVcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4dGVuc2lvbiwga2V5KSkge1xuICAgICAgICBkYXRhW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0eWxlKGRhdGEpO1xuICB9XG5cbiAgd2l0aExldmVsKG4pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgbGV2ZWw6IG5cbiAgICB9KTtcbiAgfVxuXG4gIGluY3JlbWVudExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBsZXZlbDogTWF0aC5taW4odGhpcy5sZXZlbCArIDEsIDMpXG4gICAgfSk7XG4gIH1cblxuICBpblN1Yk9yU3VwKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBsZXZlbDogc3ViT3JTdXBMZXZlbFt0aGlzLmxldmVsXVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2xvci5cbiAgICovXG4gIHdpdGhDb2xvcihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBtYXRoIGZvbnQgb3Igb2xkIHRleHQgZm9udC5cbiAgICogQHR5cGUge1t0eXBlXX1cbiAgICovXG4gIHdpdGhGb250KGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzdHlsZSBvYmplY3RzIHdpdGggdGhlIGdpdmVuIGZvbnRGYW1pbHkuXG4gICAqL1xuICB3aXRoVGV4dEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250RmFtaWx5LFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3R5bGUgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgc2l6ZVxuICAgKi9cbiAgd2l0aEZvbnRTaXplKG51bSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250U2l6ZTogbnVtXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG4gIHdpdGhUZXh0Rm9udFdlaWdodChmb250V2VpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHRcbiAgICovXG4gIHdpdGhUZXh0Rm9udFNoYXBlKGZvbnRTaGFwZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250U2hhcGUsXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgQ1NTIGNvbG9yIG9mIHRoZSBjdXJyZW50IHN0eWxlIG9iamVjdFxuICAgKi9cbiAgZ2V0Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gIH1cbn1cblxuLyogVGVtbWwgUG9zdCBQcm9jZXNzXG4gKiBQb3B1bGF0ZSB0aGUgdGV4dCBjb250ZW50cyBvZiBlYWNoIFxccmVmICYgXFxlcXJlZlxuICpcbiAqIEFzIHdpdGggb3RoZXIgVGVtbWwgY29kZSwgdGhpcyBmaWxlIGlzIHJlbGVhc2VkIHVuZGVyIHRlcm1zIG9mIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHBzOi8vbWl0LWxpY2Vuc2Uub3JnL1xuICovXG5cbmNvbnN0IHZlcnNpb24gPSBcIjAuMTEuMDJcIjtcblxuZnVuY3Rpb24gcG9zdFByb2Nlc3MoYmxvY2spIHtcbiAgY29uc3QgbGFiZWxNYXAgPSB7fTtcbiAgbGV0IGkgPSAwO1xuXG4gIC8vIEdldCBhIGNvbGxlY3Rpb24gb2YgdGhlIHBhcmVudHMgb2YgZWFjaCBcXHRhZyAmIGF1dG8tbnVtYmVyZWQgZXF1YXRpb25cbiAgY29uc3QgYW1zRXFucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RtbC1lcW4nKTtcbiAgZm9yIChsZXQgcGFyZW50IG9mIGFtc0VxbnMpIHtcbiAgICAvLyBBTVMgYXV0b21hdGljYWxseSBudW1iZXJlZCBlcXVhdGlvbi5cbiAgICAvLyBBc3NpZ24gYW4gaWQuXG4gICAgaSArPSAxO1xuICAgIHBhcmVudC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcInRtbC1lcW4tXCIgKyBTdHJpbmcoaSkpO1xuICAgIC8vIE5vIG5lZWQgdG8gd3JpdGUgYSBudW1iZXIgaW50byB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBlbGVtZW50LlxuICAgIC8vIEEgQ1NTIGNvdW50ZXIgaGFzIGRvbmUgdGhhdCBldmVuIGlmIHRoaXMgcG9zdFByb2Nlc3MoKSBmdW5jdGlvbiBpcyBub3QgdXNlZC5cblxuICAgIC8vIEZpbmQgYW55IFxcbGFiZWwgdGhhdCByZWZlcnMgdG8gYW4gQU1TIGF1dG9tYXRpYyBlcW4gbnVtYmVyLlxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09IFwibXRhYmxlXCIpIHsgYnJlYWsgfVxuICAgICAgY29uc3QgbGFiZWxzID0gcGFyZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0bWwtbGFiZWxcIik7XG4gICAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaWQgPSBwYXJlbnQuYXR0cmlidXRlcy5pZC52YWx1ZTtcbiAgICAgICAgbGFiZWxNYXBbaWRdID0gU3RyaW5nKGkpO1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCBcXGxhYmVscyBhc3NvY2lhdGVkIHdpdGggXFx0YWdcbiAgY29uc3QgdGFnZ2VkRXFucyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RtbC10YWdlcW4nKTtcbiAgZm9yIChjb25zdCBwYXJlbnQgb2YgdGFnZ2VkRXFucykge1xuICAgIGNvbnN0IGxhYmVscyA9IHBhcmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG1sLWxhYmVsXCIpO1xuICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGFncyA9IHBhcmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG1sLXRhZ1wiKTtcbiAgICAgIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaWQgPSBwYXJlbnQuYXR0cmlidXRlcy5pZC52YWx1ZTtcbiAgICAgICAgbGFiZWxNYXBbaWRdID0gdGFnc1swXS50ZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQb3B1bGF0ZSBcXHJlZiAmIFxcZXFyZWYgdGV4dCBjb250ZW50XG4gIGNvbnN0IHJlZnMgPSBibG9jay5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG1sLXJlZlwiKTtcbiAgWy4uLnJlZnNdLmZvckVhY2gocmVmID0+IHtcbiAgICBjb25zdCBhdHRyID0gcmVmLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgbGV0IHN0ciA9IGxhYmVsTWFwW2F0dHIuc2xpY2UoMSldO1xuICAgIGlmIChyZWYuY2xhc3NOYW1lLmluZGV4T2YoXCJ0bWwtZXFyZWZcIikgPT09IC0xKSB7XG4gICAgICAvLyBcXHJlZi4gT21pdCBwYXJlbnMuXG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXlxcKC8sIFwiXCIpO1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xcKSQvLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gXFxlcXJlZi4gSW5jbHVkZSBwYXJlbnNcbiAgICAgIGlmIChzdHIuY2hhckF0KDApICE9PSBcIihcIikgeyBzdHIgPSBcIihcIiArIHN0cjsgfVxuICAgICAgaWYgKHN0ci5zbGljZSgtMSkgIT09IFwiKVwiKSB7IHN0ciA9ICBzdHIgKyBcIilcIjsgfVxuICAgIH1cbiAgICBjb25zdCBtdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtdGV4dFwiKTtcbiAgICBtdGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHIpKTtcbiAgICBjb25zdCBtYXRoID0gIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgXCJtYXRoXCIpO1xuICAgIG1hdGguYXBwZW5kQ2hpbGQobXRleHQpO1xuICAgIHJlZi50ZXh0Q29udGVudCA9ICcnO1xuICAgIHJlZi5hcHBlbmRDaGlsZChtYXRoKTtcbiAgfSk7XG59XG5cbmNvbnN0IGZpbmRFbmRPZk1hdGggPSBmdW5jdGlvbihkZWxpbWl0ZXIsIHRleHQsIHN0YXJ0SW5kZXgpIHtcbiAgLy8gQWRhcHRlZCBmcm9tXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9LaGFuL3BlcnNldXMvYmxvYi9tYXN0ZXIvc3JjL3BlcnNldXMtbWFya2Rvd24uanN4XG4gIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XG4gIGxldCBicmFjZUxldmVsID0gMDtcblxuICBjb25zdCBkZWxpbUxlbmd0aCA9IGRlbGltaXRlci5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBjb25zdCBjaGFyYWN0ZXIgPSB0ZXh0W2luZGV4XTtcblxuICAgIGlmIChicmFjZUxldmVsIDw9IDAgJiYgdGV4dC5zbGljZShpbmRleCwgaW5kZXggKyBkZWxpbUxlbmd0aCkgPT09IGRlbGltaXRlcikge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBcIlxcXFxcIikge1xuICAgICAgaW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gXCJ7XCIpIHtcbiAgICAgIGJyYWNlTGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gXCJ9XCIpIHtcbiAgICAgIGJyYWNlTGV2ZWwtLTtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuY29uc3QgZXNjYXBlUmVnZXggPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKTtcbn07XG5cbmNvbnN0IGFtc1JlZ2V4ID0gL15cXFxcKD86YmVnaW58KD86ZXEpP3JlZil7LztcblxuY29uc3Qgc3BsaXRBdERlbGltaXRlcnMgPSBmdW5jdGlvbih0ZXh0LCBkZWxpbWl0ZXJzKSB7XG4gIGxldCBpbmRleDtcbiAgY29uc3QgZGF0YSA9IFtdO1xuXG4gIGNvbnN0IHJlZ2V4TGVmdCA9IG5ldyBSZWdFeHAoXG4gICAgXCIoXCIgKyBkZWxpbWl0ZXJzLm1hcCgoeCkgPT4gZXNjYXBlUmVnZXgoeC5sZWZ0KSkuam9pbihcInxcIikgKyBcIilcIlxuICApO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSB0ZXh0LnNlYXJjaChyZWdleExlZnQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICBkYXRhLnB1c2goe1xuICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgZGF0YTogdGV4dC5zbGljZSgwLCBpbmRleClcbiAgICAgIH0pO1xuICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaW5kZXgpOyAvLyBub3cgdGV4dCBzdGFydHMgd2l0aCBkZWxpbWl0ZXJcbiAgICB9XG4gICAgLy8gLi4uIHNvIHRoaXMgYWx3YXlzIHN1Y2NlZWRzOlxuICAgIGNvbnN0IGkgPSBkZWxpbWl0ZXJzLmZpbmRJbmRleCgoZGVsaW0pID0+IHRleHQuc3RhcnRzV2l0aChkZWxpbS5sZWZ0KSk7XG4gICAgaW5kZXggPSBmaW5kRW5kT2ZNYXRoKGRlbGltaXRlcnNbaV0ucmlnaHQsIHRleHQsIGRlbGltaXRlcnNbaV0ubGVmdC5sZW5ndGgpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCByYXdEYXRhID0gdGV4dC5zbGljZSgwLCBpbmRleCArIGRlbGltaXRlcnNbaV0ucmlnaHQubGVuZ3RoKTtcbiAgICBjb25zdCBtYXRoID0gYW1zUmVnZXgudGVzdChyYXdEYXRhKVxuICAgICAgPyByYXdEYXRhXG4gICAgICA6IHRleHQuc2xpY2UoZGVsaW1pdGVyc1tpXS5sZWZ0Lmxlbmd0aCwgaW5kZXgpO1xuICAgIGRhdGEucHVzaCh7XG4gICAgICB0eXBlOiBcIm1hdGhcIixcbiAgICAgIGRhdGE6IG1hdGgsXG4gICAgICByYXdEYXRhLFxuICAgICAgZGlzcGxheTogZGVsaW1pdGVyc1tpXS5kaXNwbGF5XG4gICAgfSk7XG4gICAgdGV4dCA9IHRleHQuc2xpY2UoaW5kZXggKyBkZWxpbWl0ZXJzW2ldLnJpZ2h0Lmxlbmd0aCk7XG4gIH1cblxuICBpZiAodGV4dCAhPT0gXCJcIikge1xuICAgIGRhdGEucHVzaCh7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIGRhdGE6IHRleHRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuY29uc3QgZGVmYXVsdERlbGltaXRlcnMgPSBbXG4gIHsgbGVmdDogXCIkJFwiLCByaWdodDogXCIkJFwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcKFwiLCByaWdodDogXCJcXFxcKVwiLCBkaXNwbGF5OiBmYWxzZSB9LFxuICAvLyBMYVRlWCB1c2VzICTigKYkLCBidXQgaXQgcnVpbnMgdGhlIGRpc3BsYXkgb2Ygbm9ybWFsIGAkYCBpbiB0ZXh0OlxuICAvLyB7bGVmdDogXCIkXCIsIHJpZ2h0OiBcIiRcIiwgZGlzcGxheTogZmFsc2V9LFxuICAvLyAkIG11c3QgY29tZSBhZnRlciAkJFxuXG4gIC8vIFJlbmRlciBBTVMgZW52aXJvbm1lbnRzIGV2ZW4gaWYgb3V0c2lkZSAkJOKApiQkIGRlbGltaXRlcnMuXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57ZXF1YXRpb259XCIsIHJpZ2h0OiBcIlxcXFxlbmR7ZXF1YXRpb259XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntlcXVhdGlvbip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7ZXF1YXRpb24qfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ259XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ259XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ24qfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ25hdH1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbmF0fVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ25hdCp9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ25hdCp9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntnYXRoZXJ9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Z2F0aGVyfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Z2F0aGVyKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtnYXRoZXIqfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Q0R9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Q0R9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgLy8gRGl0dG8gXFxyZWYgJiBcXGVxcmVmXG4gIHsgbGVmdDogXCJcXFxccmVme1wiLCByaWdodDogXCJ9XCIsIGRpc3BsYXk6IGZhbHNlIH0sXG4gIHsgbGVmdDogXCJcXFxcZXFyZWZ7XCIsIHJpZ2h0OiBcIn1cIiwgZGlzcGxheTogZmFsc2UgfSxcblxuICB7IGxlZnQ6IFwiXFxcXFtcIiwgcmlnaHQ6IFwiXFxcXF1cIiwgZGlzcGxheTogdHJ1ZSB9XG5dO1xuXG5jb25zdCBmaXJzdERyYWZ0RGVsaW1pdGVycyA9IHtcbiAgXCIkXCI6IFtcbiAgICAgICAgIHsgbGVmdDogXCIkJFwiLCByaWdodDogXCIkJFwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gICAgICAgICB7IGxlZnQ6IFwiJGBcIiwgcmlnaHQ6IFwiYCRcIiwgZGlzcGxheTogZmFsc2UgfSxcbiAgICAgICAgIHsgbGVmdDogXCIkXCIsIHJpZ2h0OiBcIiRcIiwgZGlzcGxheTogZmFsc2UgfVxuICBdLFxuICBcIihcIjogW1xuICAgIHsgbGVmdDogXCJcXFxcW1wiLCByaWdodDogXCJcXFxcXVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gICAgeyBsZWZ0OiBcIlxcXFwoXCIsIHJpZ2h0OiBcIlxcXFwpXCIsIGRpc3BsYXk6IGZhbHNlIH1cbiAgXVxufTtcblxuY29uc3QgYW1zRGVsaW1pdGVycyA9IFtcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntlcXVhdGlvbn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtlcXVhdGlvbn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2VxdWF0aW9uKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtlcXVhdGlvbip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWduKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbmF0fVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWduYXR9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbmF0Kn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbmF0Kn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2dhdGhlcn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtnYXRoZXJ9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntnYXRoZXIqfVwiLCByaWdodDogXCJcXFxcZW5ke2dhdGhlcip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntDRH1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtDRH1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXHJlZntcIiwgcmlnaHQ6IFwifVwiLCBkaXNwbGF5OiBmYWxzZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGVxcmVme1wiLCByaWdodDogXCJ9XCIsIGRpc3BsYXk6IGZhbHNlIH1cbl07XG5cbmNvbnN0IGRlbGltaXRlcnNGcm9tS2V5ID0ga2V5ID0+IHtcbiAgaWYgKGtleSA9PT0gXCIkXCIgfHwga2V5ID09PSBcIihcIikge1xuICAgIHJldHVybiBmaXJzdERyYWZ0RGVsaW1pdGVyc1trZXldO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCIkK1wiIHx8IGtleSA9PT0gXCIoK1wiKSB7XG4gICAgY29uc3QgZmlyc3REcmFmdCA9IGZpcnN0RHJhZnREZWxpbWl0ZXJzW2tleS5zbGljZSgwLCAxKV07XG4gICAgcmV0dXJuIGZpcnN0RHJhZnQuY29uY2F0KGFtc0RlbGltaXRlcnMpXG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcImFtc1wiKSB7XG4gICAgcmV0dXJuIGFtc0RlbGltaXRlcnNcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwiYWxsXCIpIHtcbiAgICByZXR1cm4gKGZpcnN0RHJhZnREZWxpbWl0ZXJzW1wiKFwiXSkuY29uY2F0KGZpcnN0RHJhZnREZWxpbWl0ZXJzW1wiJFwiXSkuY29uY2F0KGFtc0RlbGltaXRlcnMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHREZWxpbWl0ZXJzXG4gIH1cbn07XG5cbi8qIE5vdGU6IG9wdGlvbnNDb3B5IGlzIG11dGF0ZWQgYnkgdGhpcyBtZXRob2QuIElmIGl0IGlzIGV2ZXIgZXhwb3NlZCBpbiB0aGVcbiAqIEFQSSwgd2Ugc2hvdWxkIGNvcHkgaXQgYmVmb3JlIG11dGF0aW5nLlxuICovXG5jb25zdCByZW5kZXJNYXRoSW5UZXh0ID0gZnVuY3Rpb24odGV4dCwgb3B0aW9uc0NvcHkpIHtcbiAgY29uc3QgZGF0YSA9IHNwbGl0QXREZWxpbWl0ZXJzKHRleHQsIG9wdGlvbnNDb3B5LmRlbGltaXRlcnMpO1xuICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXS50eXBlID09PSBcInRleHRcIikge1xuICAgIC8vIFRoZXJlIGlzIG5vIGZvcm11bGEgaW4gdGhlIHRleHQuXG4gICAgLy8gTGV0J3MgcmV0dXJuIG51bGwgd2hpY2ggbWVhbnMgdGhlcmUgaXMgbm8gbmVlZCB0byByZXBsYWNlXG4gICAgLy8gdGhlIGN1cnJlbnQgdGV4dCBub2RlIHdpdGggYSBuZXcgb25lLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRhdGFbaV0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGFbaV0uZGF0YSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBsZXQgbWF0aCA9IGRhdGFbaV0uZGF0YTtcbiAgICAgIC8vIE92ZXJyaWRlIGFueSBkaXNwbGF5IG1vZGUgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3Mgd2l0aCB0aGF0XG4gICAgICAvLyBkZWZpbmVkIGJ5IHRoZSB0ZXh0IGl0c2VsZlxuICAgICAgb3B0aW9uc0NvcHkuZGlzcGxheU1vZGUgPSBkYXRhW2ldLmRpc3BsYXk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAob3B0aW9uc0NvcHkucHJlUHJvY2Vzcykge1xuICAgICAgICAgIG1hdGggPSBvcHRpb25zQ29weS5wcmVQcm9jZXNzKG1hdGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEltcG9ydGluZyByZW5kZXIoKSBmcm9tIHRlbW1sLmpzIHdvdWxkIGJlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeS5cbiAgICAgICAgLy8gU28gY2FsbCB0aGUgZ2xvYmFsIHZlcnNpb24uXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0ZW1tbC5yZW5kZXIobWF0aCwgc3Bhbiwgb3B0aW9uc0NvcHkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgUGFyc2VFcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNDb3B5LmVycm9yQ2FsbGJhY2soXG4gICAgICAgICAgXCJUZW1tbCBhdXRvLXJlbmRlcjogRmFpbGVkIHRvIHBhcnNlIGBcIiArIGRhdGFbaV0uZGF0YSArIFwiYCB3aXRoIFwiLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YVtpXS5yYXdEYXRhKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuY29uc3QgcmVuZGVyRWxlbSA9IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnNDb3B5KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hpbGROb2RlID0gZWxlbS5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgIC8vIFRleHQgbm9kZVxuICAgICAgY29uc3QgZnJhZyA9IHJlbmRlck1hdGhJblRleHQoY2hpbGROb2RlLnRleHRDb250ZW50LCBvcHRpb25zQ29weSk7XG4gICAgICBpZiAoZnJhZykge1xuICAgICAgICBpICs9IGZyYWcuY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBlbGVtLnJlcGxhY2VDaGlsZChmcmFnLCBjaGlsZE5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAvLyBFbGVtZW50IG5vZGVcbiAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IFwiIFwiICsgY2hpbGROb2RlLmNsYXNzTmFtZSArIFwiIFwiO1xuICAgICAgY29uc3Qgc2hvdWxkUmVuZGVyID1cbiAgICAgICAgb3B0aW9uc0NvcHkuaWdub3JlZFRhZ3MuaW5kZXhPZihjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xICYmXG4gICAgICAgIG9wdGlvbnNDb3B5Lmlnbm9yZWRDbGFzc2VzLmV2ZXJ5KCh4KSA9PiBjbGFzc05hbWUuaW5kZXhPZihcIiBcIiArIHggKyBcIiBcIikgPT09IC0xKTtcblxuICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xuICAgICAgICByZW5kZXJFbGVtKGNoaWxkTm9kZSwgb3B0aW9uc0NvcHkpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGl0J3Mgc29tZXRoaW5nIGVsc2UsIGFuZCBpZ25vcmUgaXQuXG4gIH1cbn07XG5cbmNvbnN0IHJlbmRlck1hdGhJbkVsZW1lbnQgPSBmdW5jdGlvbihlbGVtLCBvcHRpb25zKSB7XG4gIGlmICghZWxlbSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVsZW1lbnQgcHJvdmlkZWQgdG8gcmVuZGVyXCIpO1xuICB9XG5cbiAgY29uc3Qgb3B0aW9uc0NvcHkgPSB7fTtcblxuICAvLyBPYmplY3QuYXNzaWduKG9wdGlvbnNDb3B5LCBvcHRpb24pXG4gIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIG9wdGlvbikpIHtcbiAgICAgIG9wdGlvbnNDb3B5W29wdGlvbl0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnNDb3B5LmZlbmNlcykge1xuICAgIG9wdGlvbnNDb3B5LmRlbGltaXRlcnMgPSBkZWxpbWl0ZXJzRnJvbUtleShvcHRpb25zQ29weS5mZW5jZXMpO1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnNDb3B5LmRlbGltaXRlcnMgPSBvcHRpb25zQ29weS5kZWxpbWl0ZXJzIHx8IGRlZmF1bHREZWxpbWl0ZXJzO1xuICB9XG4gIG9wdGlvbnNDb3B5Lmlnbm9yZWRUYWdzID0gb3B0aW9uc0NvcHkuaWdub3JlZFRhZ3MgfHwgW1xuICAgIFwic2NyaXB0XCIsXG4gICAgXCJub3NjcmlwdFwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInRleHRhcmVhXCIsXG4gICAgXCJwcmVcIixcbiAgICBcImNvZGVcIixcbiAgICBcIm9wdGlvblwiXG4gIF07XG4gIG9wdGlvbnNDb3B5Lmlnbm9yZWRDbGFzc2VzID0gb3B0aW9uc0NvcHkuaWdub3JlZENsYXNzZXMgfHwgW107XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIG9wdGlvbnNDb3B5LmVycm9yQ2FsbGJhY2sgPSBvcHRpb25zQ29weS5lcnJvckNhbGxiYWNrIHx8IGNvbnNvbGUuZXJyb3I7XG5cbiAgLy8gRW5hYmxlIHNoYXJpbmcgb2YgZ2xvYmFsIG1hY3JvcyBkZWZpbmVkIHZpYSBgXFxnZGVmYCBiZXR3ZWVuIGRpZmZlcmVudFxuICAvLyBtYXRoIGVsZW1lbnRzIHdpdGhpbiBhIHNpbmdsZSBjYWxsIHRvIGByZW5kZXJNYXRoSW5FbGVtZW50YC5cbiAgb3B0aW9uc0NvcHkubWFjcm9zID0gb3B0aW9uc0NvcHkubWFjcm9zIHx8IHt9O1xuXG4gIHJlbmRlckVsZW0oZWxlbSwgb3B0aW9uc0NvcHkpO1xuICBwb3N0UHJvY2VzcyhlbGVtKTtcbn07XG5cbi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3IgVGVtbWwuIEhlcmUsIHdlIGV4cG9zZSBmdW5jdGlvbnMgZm9yXG4gKiByZW5kZXJpbmcgZXhwcmVzc2lvbnMgZWl0aGVyIHRvIERPTSBub2RlcyBvciB0byBtYXJrdXAgc3RyaW5ncy5cbiAqXG4gKiBXZSBhbHNvIGV4cG9zZSB0aGUgUGFyc2VFcnJvciBjbGFzcyB0byBjaGVjayBpZiBlcnJvcnMgdGhyb3duIGZyb20gVGVtbWwgYXJlXG4gKiBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24sIG9yIGVycm9ycyBpbiBqYXZhc2NyaXB0IGhhbmRsaW5nLlxuICovXG5cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykucmVuZGVyfVxuICogUGFyc2UgYW5kIGJ1aWxkIGFuIGV4cHJlc3Npb24sIGFuZCBwbGFjZSB0aGF0IGV4cHJlc3Npb24gaW4gdGhlIERPTSBub2RlXG4gKiBnaXZlbi5cbiAqL1xubGV0IHJlbmRlciA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIGJhc2VOb2RlLCBvcHRpb25zID0ge30pIHtcbiAgYmFzZU5vZGUudGV4dENvbnRlbnQgPSBcIlwiO1xuICBjb25zdCBhbHJlYWR5SW5NYXRoRWxlbWVudCA9IGJhc2VOb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJtYXRoXCI7XG4gIGlmIChhbHJlYWR5SW5NYXRoRWxlbWVudCkgeyBvcHRpb25zLndyYXAgPSBcIm5vbmVcIjsgfVxuICBjb25zdCBtYXRoID0gcmVuZGVyVG9NYXRoTUxUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpO1xuICBpZiAoYWxyZWFkeUluTWF0aEVsZW1lbnQpIHtcbiAgICAvLyBUaGUgPG1hdGg+IGVsZW1lbnQgYWxyZWFkeSBleGlzdHMuIFBvcHVsYXRlIGl0LlxuICAgIGJhc2VOb2RlLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICBtYXRoLmNoaWxkcmVuLmZvckVhY2goZSA9PiB7IGJhc2VOb2RlLmFwcGVuZENoaWxkKGUudG9Ob2RlKCkpOyB9KTtcbiAgfSBlbHNlIGlmIChtYXRoLmNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICBiYXNlTm9kZS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgbWF0aC5jaGlsZHJlbi5mb3JFYWNoKGUgPT4geyBiYXNlTm9kZS5hcHBlbmRDaGlsZChlLnRvTm9kZSgpKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobWF0aC50b05vZGUoKSk7XG4gIH1cbn07XG5cbi8vIFRlbW1sJ3Mgc3R5bGVzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gcXVpcmtzIG1vZGUuIFByaW50IG91dCBhbiBlcnJvciwgYW5kXG4vLyBkaXNhYmxlIHJlbmRlcmluZy5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJXYXJuaW5nOiBUZW1tbCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuIE1ha2Ugc3VyZSB5b3VyIFwiICtcbiAgICAgICAgICBcIndlYnNpdGUgaGFzIGEgc3VpdGFibGUgZG9jdHlwZS5cIlxuICAgICAgKTtcblxuICAgIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUZW1tbCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykucmVuZGVyVG9TdHJpbmd9XG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHJldHVybiB0aGUgbWFya3VwIGZvciB0aGF0LlxuICovXG5jb25zdCByZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3QgbWFya3VwID0gcmVuZGVyVG9NYXRoTUxUcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpLnRvTWFya3VwKCk7XG4gIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5nZW5lcmF0ZVBhcnNlVHJlZX1cbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xuY29uc3QgZ2VuZXJhdGVQYXJzZVRyZWUgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90ZW1tbCcpLmRlZmluZVByZWFtYmxlfVxuICogVGFrZSBhbiBleHByZXNzaW9uIHdoaWNoIGNvbnRhaW5zIGEgcHJlYW1ibGUuXG4gKiBQYXJzZSBpdCBhbmQgcmV0dXJuIHRoZSBtYWNyb3MuXG4gKi9cbmNvbnN0IGRlZmluZVByZWFtYmxlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgc2V0dGluZ3MubWFjcm9zID0ge307XG4gIGlmICghKHR5cGVvZiBleHByZXNzaW9uID09PSBcInN0cmluZ1wiIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbW1sIGNhbiBvbmx5IHBhcnNlIHN0cmluZyB0eXBlZCBleHByZXNzaW9uXCIpXG4gIH1cbiAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcihleHByZXNzaW9uLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIC8vIEJsYW5rIG91dCBhbnkgXFxkZkB0YWcgdG8gYXZvaWQgc3B1cmlvdXMgXCJEdXBsaWNhdGUgXFx0YWdcIiBlcnJvcnNcbiAgZGVsZXRlIHBhcnNlci5ndWxsZXQubWFjcm9zLmN1cnJlbnRbXCJcXFxcZGZAdGFnXCJdO1xuICBjb25zdCBtYWNyb3MgPSBwYXJzZXIucGFyc2UoKTtcbiAgcmV0dXJuIG1hY3Jvc1xufTtcblxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYSBUZW1tbCBQYXJzZUVycm9yLFxuICogcmVuZGVycyB0aGUgaW52YWxpZCBMYVRlWCBhcyBhIHNwYW4gd2l0aCBob3ZlciB0aXRsZSBnaXZpbmcgdGhlIFRlbW1sXG4gKiBlcnJvciBtZXNzYWdlLiAgT3RoZXJ3aXNlLCBzaW1wbHkgdGhyb3dzIHRoZSBlcnJvci5cbiAqL1xuY29uc3QgcmVuZGVyRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIFBhcnNlRXJyb3IpKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgY29uc3Qgbm9kZSA9IG5ldyBTcGFuKFtcInRlbW1sLWVycm9yXCJdLCBbbmV3IFRleHROb2RlJDEoZXhwcmVzc2lvbiArIFwiXFxuXFxuXCIgKyBlcnJvci50b1N0cmluZygpKV0pO1xuICBub2RlLnN0eWxlLmNvbG9yID0gb3B0aW9ucy5lcnJvckNvbG9yO1xuICBub2RlLnN0eWxlLndoaXRlU3BhY2UgPSBcInByZS1saW5lXCI7XG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykucmVuZGVyVG9NYXRoTUxUcmVlfVxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIHRoZSBUZW1tbCBidWlsZCB0cmVlLiBUaGlzIGlzIHVzZWQgZm9yIGFkdmFuY2VkXG4gKiB1c2UgY2FzZXMgKGxpa2UgcmVuZGVyaW5nIHRvIGN1c3RvbSBvdXRwdXQpLlxuICovXG5jb25zdCByZW5kZXJUb01hdGhNTFRyZWUgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICB0cnkge1xuICAgIGNvbnN0IHRyZWUgPSBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICAgIGNvbnN0IHN0eWxlID0gbmV3IFN0eWxlKHtcbiAgICAgIGxldmVsOiBzZXR0aW5ncy5kaXNwbGF5TW9kZSA/IFN0eWxlTGV2ZWwuRElTUExBWSA6IFN0eWxlTGV2ZWwuVEVYVCxcbiAgICAgIG1heFNpemU6IHNldHRpbmdzLm1heFNpemVcbiAgICB9KTtcbiAgICByZXR1cm4gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgc3R5bGUsIHNldHRpbmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gcmVuZGVyRXJyb3IoZXJyb3IsIGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgfVxufTtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5kZWZhdWx0fSAqL1xudmFyIHRlbW1sJDEgPSB7XG4gIC8qKlxuICAgKiBDdXJyZW50IFRlbW1sIHZlcnNpb25cbiAgICovXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIE1hdGhNTCwgYW5kIGFkZHNcbiAgICogaXQgYXMgYSBjaGlsZCB0byB0aGUgc3BlY2lmaWVkIERPTSBub2RlLlxuICAgKi9cbiAgcmVuZGVyLFxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBNYXRoTUwgc3RyaW5nLFxuICAgKiBmb3Igc2VuZGluZyB0byB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVuZGVyVG9TdHJpbmcsXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgdGhlIG1hdGggZGVsaW1pdGVycyBpbiBhIGdpdmVuIGVsZW1lbnQgb2YgYSBydW5uaW5nIEhUTUwgZG9jdW1lbnRcbiAgICogYW5kIGNvbnZlcnRzIHRoZSBjb250ZW50cyBvZiBlYWNoIGluc3RhbmNlIGludG8gYSA8bWF0aD4gZWxlbWVudC5cbiAgICovXG4gIHJlbmRlck1hdGhJbkVsZW1lbnQsXG4gIC8qKlxuICAgKiBQb3N0LXByb2Nlc3MgYW4gZW50aXJlIEhUTUwgYmxvY2suXG4gICAqIFdyaXRlcyBBTVMgYXV0by1udW1iZXJzIGFuZCBpbXBsZW1lbnRzIFxccmVme30uXG4gICAqIFR5cGNhbGx5IGNhbGxlZCBvbmNlLCBhZnRlciBhIGxvb3AgaGFzIHJlbmRlcmVkIG1hbnkgaW5kaXZpZHVhbCBzcGFucy5cbiAgICovXG4gIHBvc3RQcm9jZXNzLFxuICAvKipcbiAgICogVGVtbWwgZXJyb3IsIHVzdWFsbHkgZHVyaW5nIHBhcnNpbmcuXG4gICAqL1xuICBQYXJzZUVycm9yLFxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNldCBvZiBtYWNyb3Mgd2l0aCBkb2N1bWVudC13aWRlIHNjb3BlLlxuICAgKi9cbiAgZGVmaW5lUHJlYW1ibGUsXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIExhVGVYIGludG8gVGVtbWwncyBpbnRlcm5hbCBwYXJzZSB0cmVlIHN0cnVjdHVyZSxcbiAgICogd2l0aG91dCByZW5kZXJpbmcgdG8gSFRNTCBvciBNYXRoTUwuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19wYXJzZTogZ2VuZXJhdGVQYXJzZVRyZWUsXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGEgTWF0aE1MIGludGVybmFsIERPTSB0cmVlXG4gICAqIHJlcHJlc2VudGF0aW9uLCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3JlbmRlclRvTWF0aE1MVHJlZTogcmVuZGVyVG9NYXRoTUxUcmVlLFxuICAvKipcbiAgICogYWRkcyBhIG5ldyBzeW1ib2wgdG8gYnVpbHRpbiBzeW1ib2xzIHRhYmxlXG4gICAqL1xuICBfX2RlZmluZVN5bWJvbDogZGVmaW5lU3ltYm9sLFxuICAvKipcbiAgICogYWRkcyBhIG5ldyBtYWNybyB0byBidWlsdGluIG1hY3JvIGxpc3RcbiAgICovXG4gIF9fZGVmaW5lTWFjcm86IGRlZmluZU1hY3JvXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbW1sJDE7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiZXhwb3J0IHsgRGVmdWRkbGUgfSBmcm9tICcuL2RlZnVkZGxlJztcbmV4cG9ydCB0eXBlIHsgRGVmdWRkbGVPcHRpb25zLCBEZWZ1ZGRsZVJlc3BvbnNlLCBEZWZ1ZGRsZU1ldGFkYXRhIH0gZnJvbSAnLi90eXBlcyc7ICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==