(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Defuddle"] = factory();
	else
		root["Defuddle"] = factory();
})(typeof self !== "undefined" ? self : this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 315:
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mathStandardizationRules = exports.createCleanMathEl = exports.isBlockDisplay = exports.getLatexFromElement = exports.getMathMLFromElement = void 0;
const mathml_to_latex_1 = __webpack_require__(/*! mathml-to-latex */ 354);
const temml = __importStar(__webpack_require__(/*! temml */ 914));
const getMathMLFromElement = (el) => {
    // 1. Direct MathML content
    if (el.tagName.toLowerCase() === 'math') {
        const isBlock = el.getAttribute('display') === 'block';
        return {
            mathml: el.outerHTML,
            latex: el.getAttribute('alttext') || null,
            isBlock
        };
    }
    // 2. MathML in data-mathml attribute
    const mathmlStr = el.getAttribute('data-mathml');
    if (mathmlStr) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathmlStr;
        const mathElement = tempDiv.querySelector('math');
        if (mathElement) {
            const isBlock = mathElement.getAttribute('display') === 'block';
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 3. MathJax assistive MathML
    const assistiveMmlContainer = el.querySelector('.MJX_Assistive_MathML, mjx-assistive-mml');
    if (assistiveMmlContainer) {
        const mathElement = assistiveMmlContainer.querySelector('math');
        if (mathElement) {
            // Check both the math element and container for display mode
            const mathDisplayAttr = mathElement.getAttribute('display');
            const containerDisplayAttr = assistiveMmlContainer.getAttribute('display');
            const isBlock = mathDisplayAttr === 'block' || containerDisplayAttr === 'block';
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 4. KaTeX MathML
    const katexMathml = el.querySelector('.katex-mathml math');
    if (katexMathml) {
        return {
            mathml: katexMathml.outerHTML,
            latex: null, // We'll get LaTeX separately for KaTeX
            isBlock: false // We'll determine this from container
        };
    }
    ;
    return null;
};
exports.getMathMLFromElement = getMathMLFromElement;
const getLatexFromElement = (el) => {
    var _a, _b, _c;
    // Direct data-latex attribute
    const dataLatex = el.getAttribute('data-latex');
    if (dataLatex) {
        return dataLatex;
    }
    // WordPress LaTeX images
    if (el instanceof HTMLImageElement && el.classList.contains('latex')) {
        // Try alt text first as it's cleaner
        const altLatex = el.getAttribute('alt');
        if (altLatex) {
            return altLatex;
        }
        // Fallback to extracting from URL
        const src = el.getAttribute('src');
        if (src) {
            const match = src.match(/latex\.php\?latex=([^&]+)/);
            if (match) {
                return decodeURIComponent(match[1])
                    .replace(/\+/g, ' ') // Replace + with spaces
                    .replace(/%5C/g, '\\'); // Fix escaped backslashes
            }
        }
    }
    // LaTeX in annotation
    const annotation = el.querySelector('annotation[encoding="application/x-tex"]');
    if (annotation === null || annotation === void 0 ? void 0 : annotation.textContent) {
        return annotation.textContent.trim();
    }
    // KaTeX formats
    if (el.matches('.katex')) {
        const katexAnnotation = el.querySelector('.katex-mathml annotation[encoding="application/x-tex"]');
        if (katexAnnotation === null || katexAnnotation === void 0 ? void 0 : katexAnnotation.textContent) {
            return katexAnnotation.textContent.trim();
        }
    }
    // MathJax scripts
    // Important: this will only work if the script has not been removed at an earlier stage
    if (el.matches('script[type="math/tex"]') || el.matches('script[type="math/tex; mode=display"]')) {
        return ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || null;
    }
    // Check for sibling script element
    if (el.parentElement) {
        const siblingScript = el.parentElement.querySelector('script[type="math/tex"], script[type="math/tex; mode=display"]');
        if (siblingScript) {
            return ((_b = siblingScript.textContent) === null || _b === void 0 ? void 0 : _b.trim()) || null;
        }
    }
    // Try to convert MathML to LaTeX as last resort
    const mathml = (0, exports.getMathMLFromElement)(el);
    if (mathml === null || mathml === void 0 ? void 0 : mathml.mathml) {
        try {
            return mathml_to_latex_1.MathMLToLaTeX.convert(mathml.mathml);
        }
        catch (error) {
            console.error('Error converting MathML to LaTeX:', error);
            return null;
        }
    }
    // Fallback to alt text or text content
    return el.getAttribute('alt') || ((_c = el.textContent) === null || _c === void 0 ? void 0 : _c.trim()) || null;
};
exports.getLatexFromElement = getLatexFromElement;
const isBlockDisplay = (el) => {
    // Check explicit display attribute
    const displayAttr = el.getAttribute('display');
    if (displayAttr === 'block') {
        return true;
    }
    // Check common class names
    const classNames = el.className.toLowerCase();
    if (classNames.includes('display') || classNames.includes('block')) {
        return true;
    }
    // Check container classes
    const container = el.closest('.katex-display, .MathJax_Display, [data-display="block"]');
    if (container) {
        return true;
    }
    // Check if preceded by block element
    const prevElement = el.previousElementSibling;
    if ((prevElement === null || prevElement === void 0 ? void 0 : prevElement.tagName.toLowerCase()) === 'p') {
        return true;
    }
    // Check specific formats
    if (el.matches('.mwe-math-fallback-image-display')) {
        return true;
    }
    // Check KaTeX display mode
    if (el.matches('.katex')) {
        // KaTeX elements are inline by default
        // Only block if explicitly marked as display
        return el.closest('.katex-display') !== null;
    }
    // Check MathJax v3 display attribute
    if (el.hasAttribute('display')) {
        return el.getAttribute('display') === 'true';
    }
    // Check MathJax script display attribute
    if (el.matches('script[type="math/tex; mode=display"]')) {
        return true;
    }
    if (el.hasAttribute('display')) {
        return el.getAttribute('display') === 'true';
    }
    // Check parent container display attribute
    const parentContainer = el.closest('[display]');
    if (parentContainer) {
        return parentContainer.getAttribute('display') === 'true';
    }
    return false;
};
exports.isBlockDisplay = isBlockDisplay;
const createCleanMathEl = (mathData, latex, isBlock) => {
    const cleanMathEl = document.createElement('math');
    cleanMathEl.setAttribute('xmlns', 'http://www.w3.org/1998/Math/MathML');
    cleanMathEl.setAttribute('display', isBlock ? 'block' : 'inline');
    cleanMathEl.setAttribute('data-latex', latex || '');
    // First try to use existing MathML content
    if (mathData === null || mathData === void 0 ? void 0 : mathData.mathml) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathData.mathml;
        const mathContent = tempDiv.querySelector('math');
        if (mathContent) {
            cleanMathEl.innerHTML = mathContent.innerHTML;
        }
    }
    // If no MathML content but we have LaTeX, convert using Temml
    else if (latex) {
        try {
            // Convert LaTeX to MathML using Temml
            const mathml = temml.renderToString(latex, {
                displayMode: isBlock,
                throwOnError: false
            });
            if (typeof mathml === 'string') {
                // Extract the inner content of the math element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = mathml;
                const mathContent = tempDiv.querySelector('math');
                if (mathContent) {
                    // Copy attributes except display mode
                    Array.from(mathContent.attributes).forEach(attr => {
                        if (attr.name !== 'display') {
                            cleanMathEl.setAttribute(attr.name, attr.value);
                        }
                    });
                    cleanMathEl.innerHTML = mathContent.innerHTML;
                }
                else {
                    // Use the entire output as fallback
                    cleanMathEl.innerHTML = mathml;
                }
            }
            else {
                cleanMathEl.textContent = latex;
            }
        }
        catch (error) {
            console.error('Error converting LaTeX to MathML:', error);
            cleanMathEl.textContent = latex;
        }
    }
    return cleanMathEl;
};
exports.createCleanMathEl = createCleanMathEl;
// Find math elements
exports.mathStandardizationRules = [
    {
        selector: [
            // WordPress LaTeX images
            'img.latex[src*="latex.php"]',
            // MathJax elements (v2 and v3)
            'span.MathJax',
            'mjx-container',
            '.MathJax_Display',
            '.MathJax_SVG',
            '.MathJax_MathML',
            // MediaWiki math elements
            '.mwe-math-element',
            '.mwe-math-fallback-image-inline',
            '.mwe-math-fallback-image-display',
            '.mwe-math-mathml-inline',
            '.mwe-math-mathml-display',
            // KaTeX elements
            '.katex',
            '.katex-display',
            '.katex-mathml',
            '.katex-html',
            '[data-katex]',
            'script[type="math/katex"]',
            // Generic math elements and other formats
            'math',
            '[data-math]',
            '[data-latex]',
            '[data-tex]',
            'annotation[encoding="application/x-tex"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            const mathData = (0, exports.getMathMLFromElement)(el);
            const latex = (0, exports.getLatexFromElement)(el);
            const isBlock = (0, exports.isBlockDisplay)(el);
            return (0, exports.createCleanMathEl)(mathData, latex, isBlock);
        }
    }
];


/***/ }),

/***/ 354:
/*!*********************************************************!*\
  !*** ./node_modules/mathml-to-latex/dist/bundle.min.js ***!
  \*********************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(()=>(()=>{var e={4582:(e,t)=>{"use strict";function r(e,t){return void 0===t&&(t=Object),t&&"function"==typeof t.freeze?t.freeze(e):e}var a=r({HTML:"text/html",isHTML:function(e){return e===a.HTML},XML_APPLICATION:"application/xml",XML_TEXT:"text/xml",XML_XHTML_APPLICATION:"application/xhtml+xml",XML_SVG_IMAGE:"image/svg+xml"}),n=r({HTML:"http://www.w3.org/1999/xhtml",isHTML:function(e){return e===n.HTML},SVG:"http://www.w3.org/2000/svg",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"});t.assign=function(e,t){if(null===e||"object"!=typeof e)throw new TypeError("target is not an object");for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e},t.find=function(e,t,r){if(void 0===r&&(r=Array.prototype),e&&"function"==typeof r.find)return r.find.call(e,t);for(var a=0;a<e.length;a++)if(Object.prototype.hasOwnProperty.call(e,a)){var n=e[a];if(t.call(void 0,n,a,e))return n}},t.freeze=r,t.MIME_TYPE=a,t.NAMESPACE=n},5752:(e,t,r)=>{var a=r(4582),n=r(4722),o=r(6559),i=r(4466),s=n.DOMImplementation,l=a.NAMESPACE,c=i.ParseError,u=i.XMLReader;function h(e){return e.replace(/\r[\n\u0085]/g,"\n").replace(/[\r\u0085\u2028]/g,"\n")}function d(e){this.options=e||{locator:{}}}function m(){this.cdata=!1}function p(e,t){t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber}function f(e){if(e)return"\n@"+(e.systemId||"")+"#[line:"+e.lineNumber+",col:"+e.columnNumber+"]"}function x(e,t,r){return"string"==typeof e?e.substr(t,r):e.length>=t+r||t?new java.lang.String(e,t,r)+"":e}function g(e,t){e.currentElement?e.currentElement.appendChild(t):e.doc.appendChild(t)}d.prototype.parseFromString=function(e,t){var r=this.options,a=new u,n=r.domBuilder||new m,i=r.errorHandler,s=r.locator,c=r.xmlns||{},d=/\/x?html?$/.test(t),p=d?o.HTML_ENTITIES:o.XML_ENTITIES;s&&n.setDocumentLocator(s),a.errorHandler=function(e,t,r){if(!e){if(t instanceof m)return t;e=t}var a={},n=e instanceof Function;function o(t){var o=e[t];!o&&n&&(o=2==e.length?function(r){e(t,r)}:e),a[t]=o&&function(e){o("[xmldom "+t+"]\t"+e+f(r))}||function(){}}return r=r||{},o("warning"),o("error"),o("fatalError"),a}(i,n,s),a.domBuilder=r.domBuilder||n,d&&(c[""]=l.HTML),c.xml=c.xml||l.XML;var x=r.normalizeLineEndings||h;return e&&"string"==typeof e?a.parse(x(e),c,p):a.errorHandler.error("invalid doc source"),n.doc},m.prototype={startDocument:function(){this.doc=(new s).createDocument(null,null,null),this.locator&&(this.doc.documentURI=this.locator.systemId)},startElement:function(e,t,r,a){var n=this.doc,o=n.createElementNS(e,r||t),i=a.length;g(this,o),this.currentElement=o,this.locator&&p(this.locator,o);for(var s=0;s<i;s++){e=a.getURI(s);var l=a.getValue(s),c=(r=a.getQName(s),n.createAttributeNS(e,r));this.locator&&p(a.getLocator(s),c),c.value=c.nodeValue=l,o.setAttributeNode(c)}},endElement:function(e,t,r){var a=this.currentElement;a.tagName,this.currentElement=a.parentNode},startPrefixMapping:function(e,t){},endPrefixMapping:function(e){},processingInstruction:function(e,t){var r=this.doc.createProcessingInstruction(e,t);this.locator&&p(this.locator,r),g(this,r)},ignorableWhitespace:function(e,t,r){},characters:function(e,t,r){if(e=x.apply(this,arguments)){if(this.cdata)var a=this.doc.createCDATASection(e);else a=this.doc.createTextNode(e);this.currentElement?this.currentElement.appendChild(a):/^\s*$/.test(e)&&this.doc.appendChild(a),this.locator&&p(this.locator,a)}},skippedEntity:function(e){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(e){(this.locator=e)&&(e.lineNumber=0)},comment:function(e,t,r){e=x.apply(this,arguments);var a=this.doc.createComment(e);this.locator&&p(this.locator,a),g(this,a)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(e,t,r){var a=this.doc.implementation;if(a&&a.createDocumentType){var n=a.createDocumentType(e,t,r);this.locator&&p(this.locator,n),g(this,n),this.doc.doctype=n}},warning:function(e){console.warn("[xmldom warning]\t"+e,f(this.locator))},error:function(e){console.error("[xmldom error]\t"+e,f(this.locator))},fatalError:function(e){throw new c(e,this.locator)}},"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,(function(e){m.prototype[e]=function(){return null}})),t.DOMParser=d},4722:(e,t,r)=>{var a=r(4582),n=a.find,o=a.NAMESPACE;function i(e){return""!==e}function s(e,t){return e.hasOwnProperty(t)||(e[t]=!0),e}function l(e){if(!e)return[];var t=function(e){return e?e.split(/[\t\n\f\r ]+/).filter(i):[]}(e);return Object.keys(t.reduce(s,{}))}function c(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function u(e,t){var r=e.prototype;if(!(r instanceof t)){function a(){}a.prototype=t.prototype,c(r,a=new a),e.prototype=r=a}r.constructor!=e&&("function"!=typeof e&&console.error("unknown Class:"+e),r.constructor=e)}var h={},d=h.ELEMENT_NODE=1,m=h.ATTRIBUTE_NODE=2,p=h.TEXT_NODE=3,f=h.CDATA_SECTION_NODE=4,x=h.ENTITY_REFERENCE_NODE=5,g=h.ENTITY_NODE=6,w=h.PROCESSING_INSTRUCTION_NODE=7,b=h.COMMENT_NODE=8,v=h.DOCUMENT_NODE=9,C=h.DOCUMENT_TYPE_NODE=10,A=h.DOCUMENT_FRAGMENT_NODE=11,E=h.NOTATION_NODE=12,_={},y={},q=(_.INDEX_SIZE_ERR=(y[1]="Index size error",1),_.DOMSTRING_SIZE_ERR=(y[2]="DOMString size error",2),_.HIERARCHY_REQUEST_ERR=(y[3]="Hierarchy request error",3)),D=(_.WRONG_DOCUMENT_ERR=(y[4]="Wrong document",4),_.INVALID_CHARACTER_ERR=(y[5]="Invalid character",5),_.NO_DATA_ALLOWED_ERR=(y[6]="No data allowed",6),_.NO_MODIFICATION_ALLOWED_ERR=(y[7]="No modification allowed",7),_.NOT_FOUND_ERR=(y[8]="Not found",8)),M=(_.NOT_SUPPORTED_ERR=(y[9]="Not supported",9),_.INUSE_ATTRIBUTE_ERR=(y[10]="Attribute in use",10));function T(e,t){if(t instanceof Error)var r=t;else r=this,Error.call(this,y[e]),this.message=y[e],Error.captureStackTrace&&Error.captureStackTrace(this,T);return r.code=e,t&&(this.message=this.message+": "+t),r}function N(){}function O(e,t){this._node=e,this._refresh=t,L(this)}function L(e){var t=e._node._inc||e._node.ownerDocument._inc;if(e._inc!==t){var r=e._refresh(e._node);if(we(e,"length",r.length),!e.$$length||r.length<e.$$length)for(var a=r.length;a in e;a++)Object.prototype.hasOwnProperty.call(e,a)&&delete e[a];c(r,e),e._inc=t}}function B(){}function S(e,t){for(var r=e.length;r--;)if(e[r]===t)return r}function F(e,t,r,a){if(a?t[S(t,a)]=r:t[t.length++]=r,e){r.ownerElement=e;var n=e.ownerDocument;n&&(a&&V(n,e,a),function(e,t,r){e&&e._inc++,r.namespaceURI===o.XMLNS&&(t._nsMap[r.prefix?r.localName:""]=r.value)}(n,e,r))}}function P(e,t,r){var a=S(t,r);if(!(a>=0))throw new T(D,new Error(e.tagName+"@"+r));for(var n=t.length-1;a<n;)t[a]=t[++a];if(t.length=n,e){var o=e.ownerDocument;o&&(V(o,e,r),r.ownerElement=null)}}function k(){}function R(){}function I(e){return("<"==e?"&lt;":">"==e&&"&gt;")||"&"==e&&"&amp;"||'"'==e&&"&quot;"||"&#"+e.charCodeAt()+";"}function U(e,t){if(t(e))return!0;if(e=e.firstChild)do{if(U(e,t))return!0}while(e=e.nextSibling)}function j(){this.ownerDocument=this}function V(e,t,r,a){e&&e._inc++,r.namespaceURI===o.XMLNS&&delete t._nsMap[r.prefix?r.localName:""]}function G(e,t,r){if(e&&e._inc){e._inc++;var a=t.childNodes;if(r)a[a.length++]=r;else{for(var n=t.firstChild,o=0;n;)a[o++]=n,n=n.nextSibling;a.length=o,delete a[a.length]}}}function $(e,t){var r=t.previousSibling,a=t.nextSibling;return r?r.nextSibling=a:e.firstChild=a,a?a.previousSibling=r:e.lastChild=r,t.parentNode=null,t.previousSibling=null,t.nextSibling=null,G(e.ownerDocument,e),t}function X(e){return e&&e.nodeType===R.DOCUMENT_TYPE_NODE}function H(e){return e&&e.nodeType===R.ELEMENT_NODE}function W(e){return e&&e.nodeType===R.TEXT_NODE}function z(e,t){var r=e.childNodes||[];if(n(r,H)||X(t))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function Y(e,t){var r=e.childNodes||[];if(n(r,(function(e){return H(e)&&e!==t})))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function J(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!z(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!z(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,X))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element");if(!r&&s)throw new T(q,"Doctype can not be appended since element is present")}}function Z(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!Y(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!Y(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,(function(e){return X(e)&&e!==r})))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element")}}function Q(e,t,r,a){(function(e,t,r){if(!function(e){return e&&(e.nodeType===R.DOCUMENT_NODE||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.ELEMENT_NODE)}(e))throw new T(q,"Unexpected parent node type "+e.nodeType);if(r&&r.parentNode!==e)throw new T(D,"child not in parent");if(!function(e){return e&&(H(e)||W(e)||X(e)||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.COMMENT_NODE||e.nodeType===R.PROCESSING_INSTRUCTION_NODE)}(t)||X(t)&&e.nodeType!==R.DOCUMENT_NODE)throw new T(q,"Unexpected node type "+t.nodeType+" for parent node type "+e.nodeType)})(e,t,r),e.nodeType===R.DOCUMENT_NODE&&(a||J)(e,t,r);var n=t.parentNode;if(n&&n.removeChild(t),t.nodeType===A){var o=t.firstChild;if(null==o)return t;var i=t.lastChild}else o=i=t;var s=r?r.previousSibling:e.lastChild;o.previousSibling=s,i.nextSibling=r,s?s.nextSibling=o:e.firstChild=o,null==r?e.lastChild=i:r.previousSibling=i;do{o.parentNode=e}while(o!==i&&(o=o.nextSibling));return G(e.ownerDocument||e,e),t.nodeType==A&&(t.firstChild=t.lastChild=null),t}function K(){this._nsMap={}}function ee(){}function te(){}function re(){}function ae(){}function ne(){}function oe(){}function ie(){}function se(){}function le(){}function ce(){}function ue(){}function he(){}function de(e,t){var r=[],a=9==this.nodeType&&this.documentElement||this,n=a.prefix,o=a.namespaceURI;if(o&&null==n&&null==(n=a.lookupPrefix(o)))var i=[{namespace:o,prefix:null}];return fe(this,r,e,t,i),r.join("")}function me(e,t,r){var a=e.prefix||"",n=e.namespaceURI;if(!n)return!1;if("xml"===a&&n===o.XML||n===o.XMLNS)return!1;for(var i=r.length;i--;){var s=r[i];if(s.prefix===a)return s.namespace!==n}return!0}function pe(e,t,r){e.push(" ",t,'="',r.replace(/[<>&"\t\n\r]/g,I),'"')}function fe(e,t,r,a,n){if(n||(n=[]),a){if(!(e=a(e)))return;if("string"==typeof e)return void t.push(e)}switch(e.nodeType){case d:var i=e.attributes,s=i.length,l=e.firstChild,c=e.tagName,u=c;if(!(r=o.isHTML(e.namespaceURI)||r)&&!e.prefix&&e.namespaceURI){for(var h,g=0;g<i.length;g++)if("xmlns"===i.item(g).name){h=i.item(g).value;break}if(!h)for(var E=n.length-1;E>=0;E--)if(""===(_=n[E]).prefix&&_.namespace===e.namespaceURI){h=_.namespace;break}if(h!==e.namespaceURI)for(E=n.length-1;E>=0;E--){var _;if((_=n[E]).namespace===e.namespaceURI){_.prefix&&(u=_.prefix+":"+c);break}}}t.push("<",u);for(var y=0;y<s;y++)"xmlns"==(q=i.item(y)).prefix?n.push({prefix:q.localName,namespace:q.value}):"xmlns"==q.nodeName&&n.push({prefix:"",namespace:q.value});for(y=0;y<s;y++){var q,D,M;me(q=i.item(y),0,n)&&(pe(t,(D=q.prefix||"")?"xmlns:"+D:"xmlns",M=q.namespaceURI),n.push({prefix:D,namespace:M})),fe(q,t,r,a,n)}if(c===u&&me(e,0,n)&&(pe(t,(D=e.prefix||"")?"xmlns:"+D:"xmlns",M=e.namespaceURI),n.push({prefix:D,namespace:M})),l||r&&!/^(?:meta|link|img|br|hr|input)$/i.test(c)){if(t.push(">"),r&&/^script$/i.test(c))for(;l;)l.data?t.push(l.data):fe(l,t,r,a,n.slice()),l=l.nextSibling;else for(;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;t.push("</",u,">")}else t.push("/>");return;case v:case A:for(l=e.firstChild;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;return;case m:return pe(t,e.name,e.value);case p:return t.push(e.data.replace(/[<&>]/g,I));case f:return t.push("<![CDATA[",e.data,"]]>");case b:return t.push("\x3c!--",e.data,"--\x3e");case C:var T=e.publicId,N=e.systemId;if(t.push("<!DOCTYPE ",e.name),T)t.push(" PUBLIC ",T),N&&"."!=N&&t.push(" ",N),t.push(">");else if(N&&"."!=N)t.push(" SYSTEM ",N,">");else{var O=e.internalSubset;O&&t.push(" [",O,"]"),t.push(">")}return;case w:return t.push("<?",e.target," ",e.data,"?>");case x:return t.push("&",e.nodeName,";");default:t.push("??",e.nodeName)}}function xe(e,t,r){var a;switch(t.nodeType){case d:(a=t.cloneNode(!1)).ownerDocument=e;case A:break;case m:r=!0}if(a||(a=t.cloneNode(!1)),a.ownerDocument=e,a.parentNode=null,r)for(var n=t.firstChild;n;)a.appendChild(xe(e,n,r)),n=n.nextSibling;return a}function ge(e,t,r){var a=new t.constructor;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var o=t[n];"object"!=typeof o&&o!=a[n]&&(a[n]=o)}switch(t.childNodes&&(a.childNodes=new N),a.ownerDocument=e,a.nodeType){case d:var i=t.attributes,s=a.attributes=new B,l=i.length;s._ownerElement=a;for(var c=0;c<l;c++)a.setAttributeNode(ge(e,i.item(c),!0));break;case m:r=!0}if(r)for(var u=t.firstChild;u;)a.appendChild(ge(e,u,r)),u=u.nextSibling;return a}function we(e,t,r){e[t]=r}_.INVALID_STATE_ERR=(y[11]="Invalid state",11),_.SYNTAX_ERR=(y[12]="Syntax error",12),_.INVALID_MODIFICATION_ERR=(y[13]="Invalid modification",13),_.NAMESPACE_ERR=(y[14]="Invalid namespace",14),_.INVALID_ACCESS_ERR=(y[15]="Invalid access",15),T.prototype=Error.prototype,c(_,T),N.prototype={length:0,item:function(e){return e>=0&&e<this.length?this[e]:null},toString:function(e,t){for(var r=[],a=0;a<this.length;a++)fe(this[a],r,e,t);return r.join("")},filter:function(e){return Array.prototype.filter.call(this,e)},indexOf:function(e){return Array.prototype.indexOf.call(this,e)}},O.prototype.item=function(e){return L(this),this[e]||null},u(O,N),B.prototype={length:0,item:N.prototype.item,getNamedItem:function(e){for(var t=this.length;t--;){var r=this[t];if(r.nodeName==e)return r}},setNamedItem:function(e){var t=e.ownerElement;if(t&&t!=this._ownerElement)throw new T(M);var r=this.getNamedItem(e.nodeName);return F(this._ownerElement,this,e,r),r},setNamedItemNS:function(e){var t,r=e.ownerElement;if(r&&r!=this._ownerElement)throw new T(M);return t=this.getNamedItemNS(e.namespaceURI,e.localName),F(this._ownerElement,this,e,t),t},removeNamedItem:function(e){var t=this.getNamedItem(e);return P(this._ownerElement,this,t),t},removeNamedItemNS:function(e,t){var r=this.getNamedItemNS(e,t);return P(this._ownerElement,this,r),r},getNamedItemNS:function(e,t){for(var r=this.length;r--;){var a=this[r];if(a.localName==t&&a.namespaceURI==e)return a}return null}},k.prototype={hasFeature:function(e,t){return!0},createDocument:function(e,t,r){var a=new j;if(a.implementation=this,a.childNodes=new N,a.doctype=r||null,r&&a.appendChild(r),t){var n=a.createElementNS(e,t);a.appendChild(n)}return a},createDocumentType:function(e,t,r){var a=new oe;return a.name=e,a.nodeName=e,a.publicId=t||"",a.systemId=r||"",a}},R.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(e,t){return Q(this,e,t)},replaceChild:function(e,t){Q(this,e,t,Z),t&&this.removeChild(t)},removeChild:function(e){return $(this,e)},appendChild:function(e){return this.insertBefore(e,null)},hasChildNodes:function(){return null!=this.firstChild},cloneNode:function(e){return ge(this.ownerDocument||this,this,e)},normalize:function(){for(var e=this.firstChild;e;){var t=e.nextSibling;t&&t.nodeType==p&&e.nodeType==p?(this.removeChild(t),e.appendData(t.data)):(e.normalize(),e=t)}},isSupported:function(e,t){return this.ownerDocument.implementation.hasFeature(e,t)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(e){for(var t=this;t;){var r=t._nsMap;if(r)for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a)&&r[a]===e)return a;t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},lookupNamespaceURI:function(e){for(var t=this;t;){var r=t._nsMap;if(r&&Object.prototype.hasOwnProperty.call(r,e))return r[e];t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},isDefaultNamespace:function(e){return null==this.lookupPrefix(e)}},c(h,R),c(h,R.prototype),j.prototype={nodeName:"#document",nodeType:v,doctype:null,documentElement:null,_inc:1,insertBefore:function(e,t){if(e.nodeType==A){for(var r=e.firstChild;r;){var a=r.nextSibling;this.insertBefore(r,t),r=a}return e}return Q(this,e,t),e.ownerDocument=this,null===this.documentElement&&e.nodeType===d&&(this.documentElement=e),e},removeChild:function(e){return this.documentElement==e&&(this.documentElement=null),$(this,e)},replaceChild:function(e,t){Q(this,e,t,Z),e.ownerDocument=this,t&&this.removeChild(t),H(e)&&(this.documentElement=e)},importNode:function(e,t){return xe(this,e,t)},getElementById:function(e){var t=null;return U(this.documentElement,(function(r){if(r.nodeType==d&&r.getAttribute("id")==e)return t=r,!0})),t},getElementsByClassName:function(e){var t=l(e);return new O(this,(function(r){var a=[];return t.length>0&&U(r.documentElement,(function(n){if(n!==r&&n.nodeType===d){var o=n.getAttribute("class");if(o){var i=e===o;if(!i){var s=l(o);i=t.every((c=s,function(e){return c&&-1!==c.indexOf(e)}))}i&&a.push(n)}}var c})),a}))},createElement:function(e){var t=new K;return t.ownerDocument=this,t.nodeName=e,t.tagName=e,t.localName=e,t.childNodes=new N,(t.attributes=new B)._ownerElement=t,t},createDocumentFragment:function(){var e=new ce;return e.ownerDocument=this,e.childNodes=new N,e},createTextNode:function(e){var t=new re;return t.ownerDocument=this,t.appendData(e),t},createComment:function(e){var t=new ae;return t.ownerDocument=this,t.appendData(e),t},createCDATASection:function(e){var t=new ne;return t.ownerDocument=this,t.appendData(e),t},createProcessingInstruction:function(e,t){var r=new ue;return r.ownerDocument=this,r.tagName=r.nodeName=r.target=e,r.nodeValue=r.data=t,r},createAttribute:function(e){var t=new ee;return t.ownerDocument=this,t.name=e,t.nodeName=e,t.localName=e,t.specified=!0,t},createEntityReference:function(e){var t=new le;return t.ownerDocument=this,t.nodeName=e,t},createElementNS:function(e,t){var r=new K,a=t.split(":"),n=r.attributes=new B;return r.childNodes=new N,r.ownerDocument=this,r.nodeName=t,r.tagName=t,r.namespaceURI=e,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,n._ownerElement=r,r},createAttributeNS:function(e,t){var r=new ee,a=t.split(":");return r.ownerDocument=this,r.nodeName=t,r.name=t,r.namespaceURI=e,r.specified=!0,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,r}},u(j,R),K.prototype={nodeType:d,hasAttribute:function(e){return null!=this.getAttributeNode(e)},getAttribute:function(e){var t=this.getAttributeNode(e);return t&&t.value||""},getAttributeNode:function(e){return this.attributes.getNamedItem(e)},setAttribute:function(e,t){var r=this.ownerDocument.createAttribute(e);r.value=r.nodeValue=""+t,this.setAttributeNode(r)},removeAttribute:function(e){var t=this.getAttributeNode(e);t&&this.removeAttributeNode(t)},appendChild:function(e){return e.nodeType===A?this.insertBefore(e,null):function(e,t){return t.parentNode&&t.parentNode.removeChild(t),t.parentNode=e,t.previousSibling=e.lastChild,t.nextSibling=null,t.previousSibling?t.previousSibling.nextSibling=t:e.firstChild=t,e.lastChild=t,G(e.ownerDocument,e,t),t}(this,e)},setAttributeNode:function(e){return this.attributes.setNamedItem(e)},setAttributeNodeNS:function(e){return this.attributes.setNamedItemNS(e)},removeAttributeNode:function(e){return this.attributes.removeNamedItem(e.nodeName)},removeAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);r&&this.removeAttributeNode(r)},hasAttributeNS:function(e,t){return null!=this.getAttributeNodeNS(e,t)},getAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);return r&&r.value||""},setAttributeNS:function(e,t,r){var a=this.ownerDocument.createAttributeNS(e,t);a.value=a.nodeValue=""+r,this.setAttributeNode(a)},getAttributeNodeNS:function(e,t){return this.attributes.getNamedItemNS(e,t)},getElementsByTagName:function(e){return new O(this,(function(t){var r=[];return U(t,(function(a){a===t||a.nodeType!=d||"*"!==e&&a.tagName!=e||r.push(a)})),r}))},getElementsByTagNameNS:function(e,t){return new O(this,(function(r){var a=[];return U(r,(function(n){n===r||n.nodeType!==d||"*"!==e&&n.namespaceURI!==e||"*"!==t&&n.localName!=t||a.push(n)})),a}))}},j.prototype.getElementsByTagName=K.prototype.getElementsByTagName,j.prototype.getElementsByTagNameNS=K.prototype.getElementsByTagNameNS,u(K,R),ee.prototype.nodeType=m,u(ee,R),te.prototype={data:"",substringData:function(e,t){return this.data.substring(e,e+t)},appendData:function(e){e=this.data+e,this.nodeValue=this.data=e,this.length=e.length},insertData:function(e,t){this.replaceData(e,0,t)},appendChild:function(e){throw new Error(y[q])},deleteData:function(e,t){this.replaceData(e,t,"")},replaceData:function(e,t,r){r=this.data.substring(0,e)+r+this.data.substring(e+t),this.nodeValue=this.data=r,this.length=r.length}},u(te,R),re.prototype={nodeName:"#text",nodeType:p,splitText:function(e){var t=this.data,r=t.substring(e);t=t.substring(0,e),this.data=this.nodeValue=t,this.length=t.length;var a=this.ownerDocument.createTextNode(r);return this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling),a}},u(re,te),ae.prototype={nodeName:"#comment",nodeType:b},u(ae,te),ne.prototype={nodeName:"#cdata-section",nodeType:f},u(ne,te),oe.prototype.nodeType=C,u(oe,R),ie.prototype.nodeType=E,u(ie,R),se.prototype.nodeType=g,u(se,R),le.prototype.nodeType=x,u(le,R),ce.prototype.nodeName="#document-fragment",ce.prototype.nodeType=A,u(ce,R),ue.prototype.nodeType=w,u(ue,R),he.prototype.serializeToString=function(e,t,r){return de.call(e,t,r)},R.prototype.toString=de;try{if(Object.defineProperty){function be(e){switch(e.nodeType){case d:case A:var t=[];for(e=e.firstChild;e;)7!==e.nodeType&&8!==e.nodeType&&t.push(be(e)),e=e.nextSibling;return t.join("");default:return e.nodeValue}}Object.defineProperty(O.prototype,"length",{get:function(){return L(this),this.$$length}}),Object.defineProperty(R.prototype,"textContent",{get:function(){return be(this)},set:function(e){switch(this.nodeType){case d:case A:for(;this.firstChild;)this.removeChild(this.firstChild);(e||String(e))&&this.appendChild(this.ownerDocument.createTextNode(e));break;default:this.data=e,this.value=e,this.nodeValue=e}}}),we=function(e,t,r){e["$$"+t]=r}}}catch(ve){}t.DocumentType=oe,t.DOMException=T,t.DOMImplementation=k,t.Element=K,t.Node=R,t.NodeList=N,t.XMLSerializer=he},6559:(e,t,r)=>{"use strict";var a=r(4582).freeze;t.XML_ENTITIES=a({amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}),t.HTML_ENTITIES=a({Aacute:"Ã",aacute:"Ã¡",Abreve:"Ä‚",abreve:"Äƒ",ac:"âˆ¾",acd:"âˆ¿",acE:"âˆ¾Ì³",Acirc:"Ã‚",acirc:"Ã¢",acute:"Â´",Acy:"Ğ",acy:"Ğ°",AElig:"Ã†",aelig:"Ã¦",af:"â¡",Afr:"ğ”„",afr:"ğ”",Agrave:"Ã€",agrave:"Ã ",alefsym:"â„µ",aleph:"â„µ",Alpha:"Î‘",alpha:"Î±",Amacr:"Ä€",amacr:"Ä",amalg:"â¨¿",AMP:"&",amp:"&",And:"â©“",and:"âˆ§",andand:"â©•",andd:"â©œ",andslope:"â©˜",andv:"â©š",ang:"âˆ ",ange:"â¦¤",angle:"âˆ ",angmsd:"âˆ¡",angmsdaa:"â¦¨",angmsdab:"â¦©",angmsdac:"â¦ª",angmsdad:"â¦«",angmsdae:"â¦¬",angmsdaf:"â¦­",angmsdag:"â¦®",angmsdah:"â¦¯",angrt:"âˆŸ",angrtvb:"âŠ¾",angrtvbd:"â¦",angsph:"âˆ¢",angst:"Ã…",angzarr:"â¼",Aogon:"Ä„",aogon:"Ä…",Aopf:"ğ”¸",aopf:"ğ•’",ap:"â‰ˆ",apacir:"â©¯",apE:"â©°",ape:"â‰Š",apid:"â‰‹",apos:"'",ApplyFunction:"â¡",approx:"â‰ˆ",approxeq:"â‰Š",Aring:"Ã…",aring:"Ã¥",Ascr:"ğ’œ",ascr:"ğ’¶",Assign:"â‰”",ast:"*",asymp:"â‰ˆ",asympeq:"â‰",Atilde:"Ãƒ",atilde:"Ã£",Auml:"Ã„",auml:"Ã¤",awconint:"âˆ³",awint:"â¨‘",backcong:"â‰Œ",backepsilon:"Ï¶",backprime:"â€µ",backsim:"âˆ½",backsimeq:"â‹",Backslash:"âˆ–",Barv:"â«§",barvee:"âŠ½",Barwed:"âŒ†",barwed:"âŒ…",barwedge:"âŒ…",bbrk:"âµ",bbrktbrk:"â¶",bcong:"â‰Œ",Bcy:"Ğ‘",bcy:"Ğ±",bdquo:"â€",becaus:"âˆµ",Because:"âˆµ",because:"âˆµ",bemptyv:"â¦°",bepsi:"Ï¶",bernou:"â„¬",Bernoullis:"â„¬",Beta:"Î’",beta:"Î²",beth:"â„¶",between:"â‰¬",Bfr:"ğ”…",bfr:"ğ”Ÿ",bigcap:"â‹‚",bigcirc:"â—¯",bigcup:"â‹ƒ",bigodot:"â¨€",bigoplus:"â¨",bigotimes:"â¨‚",bigsqcup:"â¨†",bigstar:"â˜…",bigtriangledown:"â–½",bigtriangleup:"â–³",biguplus:"â¨„",bigvee:"â‹",bigwedge:"â‹€",bkarow:"â¤",blacklozenge:"â§«",blacksquare:"â–ª",blacktriangle:"â–´",blacktriangledown:"â–¾",blacktriangleleft:"â—‚",blacktriangleright:"â–¸",blank:"â£",blk12:"â–’",blk14:"â–‘",blk34:"â–“",block:"â–ˆ",bne:"=âƒ¥",bnequiv:"â‰¡âƒ¥",bNot:"â«­",bnot:"âŒ",Bopf:"ğ”¹",bopf:"ğ•“",bot:"âŠ¥",bottom:"âŠ¥",bowtie:"â‹ˆ",boxbox:"â§‰",boxDL:"â•—",boxDl:"â•–",boxdL:"â••",boxdl:"â”",boxDR:"â•”",boxDr:"â•“",boxdR:"â•’",boxdr:"â”Œ",boxH:"â•",boxh:"â”€",boxHD:"â•¦",boxHd:"â•¤",boxhD:"â•¥",boxhd:"â”¬",boxHU:"â•©",boxHu:"â•§",boxhU:"â•¨",boxhu:"â”´",boxminus:"âŠŸ",boxplus:"âŠ",boxtimes:"âŠ ",boxUL:"â•",boxUl:"â•œ",boxuL:"â•›",boxul:"â”˜",boxUR:"â•š",boxUr:"â•™",boxuR:"â•˜",boxur:"â””",boxV:"â•‘",boxv:"â”‚",boxVH:"â•¬",boxVh:"â•«",boxvH:"â•ª",boxvh:"â”¼",boxVL:"â•£",boxVl:"â•¢",boxvL:"â•¡",boxvl:"â”¤",boxVR:"â• ",boxVr:"â•Ÿ",boxvR:"â•",boxvr:"â”œ",bprime:"â€µ",Breve:"Ë˜",breve:"Ë˜",brvbar:"Â¦",Bscr:"â„¬",bscr:"ğ’·",bsemi:"â",bsim:"âˆ½",bsime:"â‹",bsol:"\\",bsolb:"â§…",bsolhsub:"âŸˆ",bull:"â€¢",bullet:"â€¢",bump:"â‰",bumpE:"âª®",bumpe:"â‰",Bumpeq:"â‰",bumpeq:"â‰",Cacute:"Ä†",cacute:"Ä‡",Cap:"â‹’",cap:"âˆ©",capand:"â©„",capbrcup:"â©‰",capcap:"â©‹",capcup:"â©‡",capdot:"â©€",CapitalDifferentialD:"â……",caps:"âˆ©ï¸€",caret:"â",caron:"Ë‡",Cayleys:"â„­",ccaps:"â©",Ccaron:"ÄŒ",ccaron:"Ä",Ccedil:"Ã‡",ccedil:"Ã§",Ccirc:"Äˆ",ccirc:"Ä‰",Cconint:"âˆ°",ccups:"â©Œ",ccupssm:"â©",Cdot:"ÄŠ",cdot:"Ä‹",cedil:"Â¸",Cedilla:"Â¸",cemptyv:"â¦²",cent:"Â¢",CenterDot:"Â·",centerdot:"Â·",Cfr:"â„­",cfr:"ğ” ",CHcy:"Ğ§",chcy:"Ñ‡",check:"âœ“",checkmark:"âœ“",Chi:"Î§",chi:"Ï‡",cir:"â—‹",circ:"Ë†",circeq:"â‰—",circlearrowleft:"â†º",circlearrowright:"â†»",circledast:"âŠ›",circledcirc:"âŠš",circleddash:"âŠ",CircleDot:"âŠ™",circledR:"Â®",circledS:"â“ˆ",CircleMinus:"âŠ–",CirclePlus:"âŠ•",CircleTimes:"âŠ—",cirE:"â§ƒ",cire:"â‰—",cirfnint:"â¨",cirmid:"â«¯",cirscir:"â§‚",ClockwiseContourIntegral:"âˆ²",CloseCurlyDoubleQuote:"â€",CloseCurlyQuote:"â€™",clubs:"â™£",clubsuit:"â™£",Colon:"âˆ·",colon:":",Colone:"â©´",colone:"â‰”",coloneq:"â‰”",comma:",",commat:"@",comp:"âˆ",compfn:"âˆ˜",complement:"âˆ",complexes:"â„‚",cong:"â‰…",congdot:"â©­",Congruent:"â‰¡",Conint:"âˆ¯",conint:"âˆ®",ContourIntegral:"âˆ®",Copf:"â„‚",copf:"ğ•”",coprod:"âˆ",Coproduct:"âˆ",COPY:"Â©",copy:"Â©",copysr:"â„—",CounterClockwiseContourIntegral:"âˆ³",crarr:"â†µ",Cross:"â¨¯",cross:"âœ—",Cscr:"ğ’",cscr:"ğ’¸",csub:"â«",csube:"â«‘",csup:"â«",csupe:"â«’",ctdot:"â‹¯",cudarrl:"â¤¸",cudarrr:"â¤µ",cuepr:"â‹",cuesc:"â‹Ÿ",cularr:"â†¶",cularrp:"â¤½",Cup:"â‹“",cup:"âˆª",cupbrcap:"â©ˆ",CupCap:"â‰",cupcap:"â©†",cupcup:"â©Š",cupdot:"âŠ",cupor:"â©…",cups:"âˆªï¸€",curarr:"â†·",curarrm:"â¤¼",curlyeqprec:"â‹",curlyeqsucc:"â‹Ÿ",curlyvee:"â‹",curlywedge:"â‹",curren:"Â¤",curvearrowleft:"â†¶",curvearrowright:"â†·",cuvee:"â‹",cuwed:"â‹",cwconint:"âˆ²",cwint:"âˆ±",cylcty:"âŒ­",Dagger:"â€¡",dagger:"â€ ",daleth:"â„¸",Darr:"â†¡",dArr:"â‡“",darr:"â†“",dash:"â€",Dashv:"â«¤",dashv:"âŠ£",dbkarow:"â¤",dblac:"Ë",Dcaron:"Ä",dcaron:"Ä",Dcy:"Ğ”",dcy:"Ğ´",DD:"â……",dd:"â…†",ddagger:"â€¡",ddarr:"â‡Š",DDotrahd:"â¤‘",ddotseq:"â©·",deg:"Â°",Del:"âˆ‡",Delta:"Î”",delta:"Î´",demptyv:"â¦±",dfisht:"â¥¿",Dfr:"ğ”‡",dfr:"ğ”¡",dHar:"â¥¥",dharl:"â‡ƒ",dharr:"â‡‚",DiacriticalAcute:"Â´",DiacriticalDot:"Ë™",DiacriticalDoubleAcute:"Ë",DiacriticalGrave:"`",DiacriticalTilde:"Ëœ",diam:"â‹„",Diamond:"â‹„",diamond:"â‹„",diamondsuit:"â™¦",diams:"â™¦",die:"Â¨",DifferentialD:"â…†",digamma:"Ï",disin:"â‹²",div:"Ã·",divide:"Ã·",divideontimes:"â‹‡",divonx:"â‹‡",DJcy:"Ğ‚",djcy:"Ñ’",dlcorn:"âŒ",dlcrop:"âŒ",dollar:"$",Dopf:"ğ”»",dopf:"ğ••",Dot:"Â¨",dot:"Ë™",DotDot:"âƒœ",doteq:"â‰",doteqdot:"â‰‘",DotEqual:"â‰",dotminus:"âˆ¸",dotplus:"âˆ”",dotsquare:"âŠ¡",doublebarwedge:"âŒ†",DoubleContourIntegral:"âˆ¯",DoubleDot:"Â¨",DoubleDownArrow:"â‡“",DoubleLeftArrow:"â‡",DoubleLeftRightArrow:"â‡”",DoubleLeftTee:"â«¤",DoubleLongLeftArrow:"âŸ¸",DoubleLongLeftRightArrow:"âŸº",DoubleLongRightArrow:"âŸ¹",DoubleRightArrow:"â‡’",DoubleRightTee:"âŠ¨",DoubleUpArrow:"â‡‘",DoubleUpDownArrow:"â‡•",DoubleVerticalBar:"âˆ¥",DownArrow:"â†“",Downarrow:"â‡“",downarrow:"â†“",DownArrowBar:"â¤“",DownArrowUpArrow:"â‡µ",DownBreve:"Ì‘",downdownarrows:"â‡Š",downharpoonleft:"â‡ƒ",downharpoonright:"â‡‚",DownLeftRightVector:"â¥",DownLeftTeeVector:"â¥",DownLeftVector:"â†½",DownLeftVectorBar:"â¥–",DownRightTeeVector:"â¥Ÿ",DownRightVector:"â‡",DownRightVectorBar:"â¥—",DownTee:"âŠ¤",DownTeeArrow:"â†§",drbkarow:"â¤",drcorn:"âŒŸ",drcrop:"âŒŒ",Dscr:"ğ’Ÿ",dscr:"ğ’¹",DScy:"Ğ…",dscy:"Ñ•",dsol:"â§¶",Dstrok:"Ä",dstrok:"Ä‘",dtdot:"â‹±",dtri:"â–¿",dtrif:"â–¾",duarr:"â‡µ",duhar:"â¥¯",dwangle:"â¦¦",DZcy:"Ğ",dzcy:"ÑŸ",dzigrarr:"âŸ¿",Eacute:"Ã‰",eacute:"Ã©",easter:"â©®",Ecaron:"Äš",ecaron:"Ä›",ecir:"â‰–",Ecirc:"ÃŠ",ecirc:"Ãª",ecolon:"â‰•",Ecy:"Ğ­",ecy:"Ñ",eDDot:"â©·",Edot:"Ä–",eDot:"â‰‘",edot:"Ä—",ee:"â…‡",efDot:"â‰’",Efr:"ğ”ˆ",efr:"ğ”¢",eg:"âªš",Egrave:"Ãˆ",egrave:"Ã¨",egs:"âª–",egsdot:"âª˜",el:"âª™",Element:"âˆˆ",elinters:"â§",ell:"â„“",els:"âª•",elsdot:"âª—",Emacr:"Ä’",emacr:"Ä“",empty:"âˆ…",emptyset:"âˆ…",EmptySmallSquare:"â—»",emptyv:"âˆ…",EmptyVerySmallSquare:"â–«",emsp:"â€ƒ",emsp13:"â€„",emsp14:"â€…",ENG:"ÅŠ",eng:"Å‹",ensp:"â€‚",Eogon:"Ä˜",eogon:"Ä™",Eopf:"ğ”¼",eopf:"ğ•–",epar:"â‹•",eparsl:"â§£",eplus:"â©±",epsi:"Îµ",Epsilon:"Î•",epsilon:"Îµ",epsiv:"Ïµ",eqcirc:"â‰–",eqcolon:"â‰•",eqsim:"â‰‚",eqslantgtr:"âª–",eqslantless:"âª•",Equal:"â©µ",equals:"=",EqualTilde:"â‰‚",equest:"â‰Ÿ",Equilibrium:"â‡Œ",equiv:"â‰¡",equivDD:"â©¸",eqvparsl:"â§¥",erarr:"â¥±",erDot:"â‰“",Escr:"â„°",escr:"â„¯",esdot:"â‰",Esim:"â©³",esim:"â‰‚",Eta:"Î—",eta:"Î·",ETH:"Ã",eth:"Ã°",Euml:"Ã‹",euml:"Ã«",euro:"â‚¬",excl:"!",exist:"âˆƒ",Exists:"âˆƒ",expectation:"â„°",ExponentialE:"â…‡",exponentiale:"â…‡",fallingdotseq:"â‰’",Fcy:"Ğ¤",fcy:"Ñ„",female:"â™€",ffilig:"ï¬ƒ",fflig:"ï¬€",ffllig:"ï¬„",Ffr:"ğ”‰",ffr:"ğ”£",filig:"ï¬",FilledSmallSquare:"â—¼",FilledVerySmallSquare:"â–ª",fjlig:"fj",flat:"â™­",fllig:"ï¬‚",fltns:"â–±",fnof:"Æ’",Fopf:"ğ”½",fopf:"ğ•—",ForAll:"âˆ€",forall:"âˆ€",fork:"â‹”",forkv:"â«™",Fouriertrf:"â„±",fpartint:"â¨",frac12:"Â½",frac13:"â…“",frac14:"Â¼",frac15:"â…•",frac16:"â…™",frac18:"â…›",frac23:"â…”",frac25:"â…–",frac34:"Â¾",frac35:"â…—",frac38:"â…œ",frac45:"â…˜",frac56:"â…š",frac58:"â…",frac78:"â…",frasl:"â„",frown:"âŒ¢",Fscr:"â„±",fscr:"ğ’»",gacute:"Çµ",Gamma:"Î“",gamma:"Î³",Gammad:"Ïœ",gammad:"Ï",gap:"âª†",Gbreve:"Ä",gbreve:"ÄŸ",Gcedil:"Ä¢",Gcirc:"Äœ",gcirc:"Ä",Gcy:"Ğ“",gcy:"Ğ³",Gdot:"Ä ",gdot:"Ä¡",gE:"â‰§",ge:"â‰¥",gEl:"âªŒ",gel:"â‹›",geq:"â‰¥",geqq:"â‰§",geqslant:"â©¾",ges:"â©¾",gescc:"âª©",gesdot:"âª€",gesdoto:"âª‚",gesdotol:"âª„",gesl:"â‹›ï¸€",gesles:"âª”",Gfr:"ğ”Š",gfr:"ğ”¤",Gg:"â‹™",gg:"â‰«",ggg:"â‹™",gimel:"â„·",GJcy:"Ğƒ",gjcy:"Ñ“",gl:"â‰·",gla:"âª¥",glE:"âª’",glj:"âª¤",gnap:"âªŠ",gnapprox:"âªŠ",gnE:"â‰©",gne:"âªˆ",gneq:"âªˆ",gneqq:"â‰©",gnsim:"â‹§",Gopf:"ğ”¾",gopf:"ğ•˜",grave:"`",GreaterEqual:"â‰¥",GreaterEqualLess:"â‹›",GreaterFullEqual:"â‰§",GreaterGreater:"âª¢",GreaterLess:"â‰·",GreaterSlantEqual:"â©¾",GreaterTilde:"â‰³",Gscr:"ğ’¢",gscr:"â„Š",gsim:"â‰³",gsime:"âª",gsiml:"âª",Gt:"â‰«",GT:">",gt:">",gtcc:"âª§",gtcir:"â©º",gtdot:"â‹—",gtlPar:"â¦•",gtquest:"â©¼",gtrapprox:"âª†",gtrarr:"â¥¸",gtrdot:"â‹—",gtreqless:"â‹›",gtreqqless:"âªŒ",gtrless:"â‰·",gtrsim:"â‰³",gvertneqq:"â‰©ï¸€",gvnE:"â‰©ï¸€",Hacek:"Ë‡",hairsp:"â€Š",half:"Â½",hamilt:"â„‹",HARDcy:"Ğª",hardcy:"ÑŠ",hArr:"â‡”",harr:"â†”",harrcir:"â¥ˆ",harrw:"â†­",Hat:"^",hbar:"â„",Hcirc:"Ä¤",hcirc:"Ä¥",hearts:"â™¥",heartsuit:"â™¥",hellip:"â€¦",hercon:"âŠ¹",Hfr:"â„Œ",hfr:"ğ”¥",HilbertSpace:"â„‹",hksearow:"â¤¥",hkswarow:"â¤¦",hoarr:"â‡¿",homtht:"âˆ»",hookleftarrow:"â†©",hookrightarrow:"â†ª",Hopf:"â„",hopf:"ğ•™",horbar:"â€•",HorizontalLine:"â”€",Hscr:"â„‹",hscr:"ğ’½",hslash:"â„",Hstrok:"Ä¦",hstrok:"Ä§",HumpDownHump:"â‰",HumpEqual:"â‰",hybull:"âƒ",hyphen:"â€",Iacute:"Ã",iacute:"Ã­",ic:"â£",Icirc:"Ã",icirc:"Ã®",Icy:"Ğ˜",icy:"Ğ¸",Idot:"Ä°",IEcy:"Ğ•",iecy:"Ğµ",iexcl:"Â¡",iff:"â‡”",Ifr:"â„‘",ifr:"ğ”¦",Igrave:"ÃŒ",igrave:"Ã¬",ii:"â…ˆ",iiiint:"â¨Œ",iiint:"âˆ­",iinfin:"â§œ",iiota:"â„©",IJlig:"Ä²",ijlig:"Ä³",Im:"â„‘",Imacr:"Äª",imacr:"Ä«",image:"â„‘",ImaginaryI:"â…ˆ",imagline:"â„",imagpart:"â„‘",imath:"Ä±",imof:"âŠ·",imped:"Æµ",Implies:"â‡’",in:"âˆˆ",incare:"â„…",infin:"âˆ",infintie:"â§",inodot:"Ä±",Int:"âˆ¬",int:"âˆ«",intcal:"âŠº",integers:"â„¤",Integral:"âˆ«",intercal:"âŠº",Intersection:"â‹‚",intlarhk:"â¨—",intprod:"â¨¼",InvisibleComma:"â£",InvisibleTimes:"â¢",IOcy:"Ğ",iocy:"Ñ‘",Iogon:"Ä®",iogon:"Ä¯",Iopf:"ğ•€",iopf:"ğ•š",Iota:"Î™",iota:"Î¹",iprod:"â¨¼",iquest:"Â¿",Iscr:"â„",iscr:"ğ’¾",isin:"âˆˆ",isindot:"â‹µ",isinE:"â‹¹",isins:"â‹´",isinsv:"â‹³",isinv:"âˆˆ",it:"â¢",Itilde:"Ä¨",itilde:"Ä©",Iukcy:"Ğ†",iukcy:"Ñ–",Iuml:"Ã",iuml:"Ã¯",Jcirc:"Ä´",jcirc:"Äµ",Jcy:"Ğ™",jcy:"Ğ¹",Jfr:"ğ”",jfr:"ğ”§",jmath:"È·",Jopf:"ğ•",jopf:"ğ•›",Jscr:"ğ’¥",jscr:"ğ’¿",Jsercy:"Ğˆ",jsercy:"Ñ˜",Jukcy:"Ğ„",jukcy:"Ñ”",Kappa:"Îš",kappa:"Îº",kappav:"Ï°",Kcedil:"Ä¶",kcedil:"Ä·",Kcy:"Ğš",kcy:"Ğº",Kfr:"ğ”",kfr:"ğ”¨",kgreen:"Ä¸",KHcy:"Ğ¥",khcy:"Ñ…",KJcy:"ĞŒ",kjcy:"Ñœ",Kopf:"ğ•‚",kopf:"ğ•œ",Kscr:"ğ’¦",kscr:"ğ“€",lAarr:"â‡š",Lacute:"Ä¹",lacute:"Äº",laemptyv:"â¦´",lagran:"â„’",Lambda:"Î›",lambda:"Î»",Lang:"âŸª",lang:"âŸ¨",langd:"â¦‘",langle:"âŸ¨",lap:"âª…",Laplacetrf:"â„’",laquo:"Â«",Larr:"â†",lArr:"â‡",larr:"â†",larrb:"â‡¤",larrbfs:"â¤Ÿ",larrfs:"â¤",larrhk:"â†©",larrlp:"â†«",larrpl:"â¤¹",larrsim:"â¥³",larrtl:"â†¢",lat:"âª«",lAtail:"â¤›",latail:"â¤™",late:"âª­",lates:"âª­ï¸€",lBarr:"â¤",lbarr:"â¤Œ",lbbrk:"â²",lbrace:"{",lbrack:"[",lbrke:"â¦‹",lbrksld:"â¦",lbrkslu:"â¦",Lcaron:"Ä½",lcaron:"Ä¾",Lcedil:"Ä»",lcedil:"Ä¼",lceil:"âŒˆ",lcub:"{",Lcy:"Ğ›",lcy:"Ğ»",ldca:"â¤¶",ldquo:"â€œ",ldquor:"â€",ldrdhar:"â¥§",ldrushar:"â¥‹",ldsh:"â†²",lE:"â‰¦",le:"â‰¤",LeftAngleBracket:"âŸ¨",LeftArrow:"â†",Leftarrow:"â‡",leftarrow:"â†",LeftArrowBar:"â‡¤",LeftArrowRightArrow:"â‡†",leftarrowtail:"â†¢",LeftCeiling:"âŒˆ",LeftDoubleBracket:"âŸ¦",LeftDownTeeVector:"â¥¡",LeftDownVector:"â‡ƒ",LeftDownVectorBar:"â¥™",LeftFloor:"âŒŠ",leftharpoondown:"â†½",leftharpoonup:"â†¼",leftleftarrows:"â‡‡",LeftRightArrow:"â†”",Leftrightarrow:"â‡”",leftrightarrow:"â†”",leftrightarrows:"â‡†",leftrightharpoons:"â‡‹",leftrightsquigarrow:"â†­",LeftRightVector:"â¥",LeftTee:"âŠ£",LeftTeeArrow:"â†¤",LeftTeeVector:"â¥š",leftthreetimes:"â‹‹",LeftTriangle:"âŠ²",LeftTriangleBar:"â§",LeftTriangleEqual:"âŠ´",LeftUpDownVector:"â¥‘",LeftUpTeeVector:"â¥ ",LeftUpVector:"â†¿",LeftUpVectorBar:"â¥˜",LeftVector:"â†¼",LeftVectorBar:"â¥’",lEg:"âª‹",leg:"â‹š",leq:"â‰¤",leqq:"â‰¦",leqslant:"â©½",les:"â©½",lescc:"âª¨",lesdot:"â©¿",lesdoto:"âª",lesdotor:"âªƒ",lesg:"â‹šï¸€",lesges:"âª“",lessapprox:"âª…",lessdot:"â‹–",lesseqgtr:"â‹š",lesseqqgtr:"âª‹",LessEqualGreater:"â‹š",LessFullEqual:"â‰¦",LessGreater:"â‰¶",lessgtr:"â‰¶",LessLess:"âª¡",lesssim:"â‰²",LessSlantEqual:"â©½",LessTilde:"â‰²",lfisht:"â¥¼",lfloor:"âŒŠ",Lfr:"ğ”",lfr:"ğ”©",lg:"â‰¶",lgE:"âª‘",lHar:"â¥¢",lhard:"â†½",lharu:"â†¼",lharul:"â¥ª",lhblk:"â–„",LJcy:"Ğ‰",ljcy:"Ñ™",Ll:"â‹˜",ll:"â‰ª",llarr:"â‡‡",llcorner:"âŒ",Lleftarrow:"â‡š",llhard:"â¥«",lltri:"â—º",Lmidot:"Ä¿",lmidot:"Å€",lmoust:"â°",lmoustache:"â°",lnap:"âª‰",lnapprox:"âª‰",lnE:"â‰¨",lne:"âª‡",lneq:"âª‡",lneqq:"â‰¨",lnsim:"â‹¦",loang:"âŸ¬",loarr:"â‡½",lobrk:"âŸ¦",LongLeftArrow:"âŸµ",Longleftarrow:"âŸ¸",longleftarrow:"âŸµ",LongLeftRightArrow:"âŸ·",Longleftrightarrow:"âŸº",longleftrightarrow:"âŸ·",longmapsto:"âŸ¼",LongRightArrow:"âŸ¶",Longrightarrow:"âŸ¹",longrightarrow:"âŸ¶",looparrowleft:"â†«",looparrowright:"â†¬",lopar:"â¦…",Lopf:"ğ•ƒ",lopf:"ğ•",loplus:"â¨­",lotimes:"â¨´",lowast:"âˆ—",lowbar:"_",LowerLeftArrow:"â†™",LowerRightArrow:"â†˜",loz:"â—Š",lozenge:"â—Š",lozf:"â§«",lpar:"(",lparlt:"â¦“",lrarr:"â‡†",lrcorner:"âŒŸ",lrhar:"â‡‹",lrhard:"â¥­",lrm:"â€",lrtri:"âŠ¿",lsaquo:"â€¹",Lscr:"â„’",lscr:"ğ“",Lsh:"â†°",lsh:"â†°",lsim:"â‰²",lsime:"âª",lsimg:"âª",lsqb:"[",lsquo:"â€˜",lsquor:"â€š",Lstrok:"Å",lstrok:"Å‚",Lt:"â‰ª",LT:"<",lt:"<",ltcc:"âª¦",ltcir:"â©¹",ltdot:"â‹–",lthree:"â‹‹",ltimes:"â‹‰",ltlarr:"â¥¶",ltquest:"â©»",ltri:"â—ƒ",ltrie:"âŠ´",ltrif:"â—‚",ltrPar:"â¦–",lurdshar:"â¥Š",luruhar:"â¥¦",lvertneqq:"â‰¨ï¸€",lvnE:"â‰¨ï¸€",macr:"Â¯",male:"â™‚",malt:"âœ ",maltese:"âœ ",Map:"â¤…",map:"â†¦",mapsto:"â†¦",mapstodown:"â†§",mapstoleft:"â†¤",mapstoup:"â†¥",marker:"â–®",mcomma:"â¨©",Mcy:"Ğœ",mcy:"Ğ¼",mdash:"â€”",mDDot:"âˆº",measuredangle:"âˆ¡",MediumSpace:"âŸ",Mellintrf:"â„³",Mfr:"ğ”",mfr:"ğ”ª",mho:"â„§",micro:"Âµ",mid:"âˆ£",midast:"*",midcir:"â«°",middot:"Â·",minus:"âˆ’",minusb:"âŠŸ",minusd:"âˆ¸",minusdu:"â¨ª",MinusPlus:"âˆ“",mlcp:"â«›",mldr:"â€¦",mnplus:"âˆ“",models:"âŠ§",Mopf:"ğ•„",mopf:"ğ•",mp:"âˆ“",Mscr:"â„³",mscr:"ğ“‚",mstpos:"âˆ¾",Mu:"Îœ",mu:"Î¼",multimap:"âŠ¸",mumap:"âŠ¸",nabla:"âˆ‡",Nacute:"Åƒ",nacute:"Å„",nang:"âˆ âƒ’",nap:"â‰‰",napE:"â©°Ì¸",napid:"â‰‹Ì¸",napos:"Å‰",napprox:"â‰‰",natur:"â™®",natural:"â™®",naturals:"â„•",nbsp:"Â ",nbump:"â‰Ì¸",nbumpe:"â‰Ì¸",ncap:"â©ƒ",Ncaron:"Å‡",ncaron:"Åˆ",Ncedil:"Å…",ncedil:"Å†",ncong:"â‰‡",ncongdot:"â©­Ì¸",ncup:"â©‚",Ncy:"Ğ",ncy:"Ğ½",ndash:"â€“",ne:"â‰ ",nearhk:"â¤¤",neArr:"â‡—",nearr:"â†—",nearrow:"â†—",nedot:"â‰Ì¸",NegativeMediumSpace:"â€‹",NegativeThickSpace:"â€‹",NegativeThinSpace:"â€‹",NegativeVeryThinSpace:"â€‹",nequiv:"â‰¢",nesear:"â¤¨",nesim:"â‰‚Ì¸",NestedGreaterGreater:"â‰«",NestedLessLess:"â‰ª",NewLine:"\n",nexist:"âˆ„",nexists:"âˆ„",Nfr:"ğ”‘",nfr:"ğ”«",ngE:"â‰§Ì¸",nge:"â‰±",ngeq:"â‰±",ngeqq:"â‰§Ì¸",ngeqslant:"â©¾Ì¸",nges:"â©¾Ì¸",nGg:"â‹™Ì¸",ngsim:"â‰µ",nGt:"â‰«âƒ’",ngt:"â‰¯",ngtr:"â‰¯",nGtv:"â‰«Ì¸",nhArr:"â‡",nharr:"â†®",nhpar:"â«²",ni:"âˆ‹",nis:"â‹¼",nisd:"â‹º",niv:"âˆ‹",NJcy:"ĞŠ",njcy:"Ñš",nlArr:"â‡",nlarr:"â†š",nldr:"â€¥",nlE:"â‰¦Ì¸",nle:"â‰°",nLeftarrow:"â‡",nleftarrow:"â†š",nLeftrightarrow:"â‡",nleftrightarrow:"â†®",nleq:"â‰°",nleqq:"â‰¦Ì¸",nleqslant:"â©½Ì¸",nles:"â©½Ì¸",nless:"â‰®",nLl:"â‹˜Ì¸",nlsim:"â‰´",nLt:"â‰ªâƒ’",nlt:"â‰®",nltri:"â‹ª",nltrie:"â‹¬",nLtv:"â‰ªÌ¸",nmid:"âˆ¤",NoBreak:"â ",NonBreakingSpace:"Â ",Nopf:"â„•",nopf:"ğ•Ÿ",Not:"â«¬",not:"Â¬",NotCongruent:"â‰¢",NotCupCap:"â‰­",NotDoubleVerticalBar:"âˆ¦",NotElement:"âˆ‰",NotEqual:"â‰ ",NotEqualTilde:"â‰‚Ì¸",NotExists:"âˆ„",NotGreater:"â‰¯",NotGreaterEqual:"â‰±",NotGreaterFullEqual:"â‰§Ì¸",NotGreaterGreater:"â‰«Ì¸",NotGreaterLess:"â‰¹",NotGreaterSlantEqual:"â©¾Ì¸",NotGreaterTilde:"â‰µ",NotHumpDownHump:"â‰Ì¸",NotHumpEqual:"â‰Ì¸",notin:"âˆ‰",notindot:"â‹µÌ¸",notinE:"â‹¹Ì¸",notinva:"âˆ‰",notinvb:"â‹·",notinvc:"â‹¶",NotLeftTriangle:"â‹ª",NotLeftTriangleBar:"â§Ì¸",NotLeftTriangleEqual:"â‹¬",NotLess:"â‰®",NotLessEqual:"â‰°",NotLessGreater:"â‰¸",NotLessLess:"â‰ªÌ¸",NotLessSlantEqual:"â©½Ì¸",NotLessTilde:"â‰´",NotNestedGreaterGreater:"âª¢Ì¸",NotNestedLessLess:"âª¡Ì¸",notni:"âˆŒ",notniva:"âˆŒ",notnivb:"â‹¾",notnivc:"â‹½",NotPrecedes:"âŠ€",NotPrecedesEqual:"âª¯Ì¸",NotPrecedesSlantEqual:"â‹ ",NotReverseElement:"âˆŒ",NotRightTriangle:"â‹«",NotRightTriangleBar:"â§Ì¸",NotRightTriangleEqual:"â‹­",NotSquareSubset:"âŠÌ¸",NotSquareSubsetEqual:"â‹¢",NotSquareSuperset:"âŠÌ¸",NotSquareSupersetEqual:"â‹£",NotSubset:"âŠ‚âƒ’",NotSubsetEqual:"âŠˆ",NotSucceeds:"âŠ",NotSucceedsEqual:"âª°Ì¸",NotSucceedsSlantEqual:"â‹¡",NotSucceedsTilde:"â‰¿Ì¸",NotSuperset:"âŠƒâƒ’",NotSupersetEqual:"âŠ‰",NotTilde:"â‰",NotTildeEqual:"â‰„",NotTildeFullEqual:"â‰‡",NotTildeTilde:"â‰‰",NotVerticalBar:"âˆ¤",npar:"âˆ¦",nparallel:"âˆ¦",nparsl:"â«½âƒ¥",npart:"âˆ‚Ì¸",npolint:"â¨”",npr:"âŠ€",nprcue:"â‹ ",npre:"âª¯Ì¸",nprec:"âŠ€",npreceq:"âª¯Ì¸",nrArr:"â‡",nrarr:"â†›",nrarrc:"â¤³Ì¸",nrarrw:"â†Ì¸",nRightarrow:"â‡",nrightarrow:"â†›",nrtri:"â‹«",nrtrie:"â‹­",nsc:"âŠ",nsccue:"â‹¡",nsce:"âª°Ì¸",Nscr:"ğ’©",nscr:"ğ“ƒ",nshortmid:"âˆ¤",nshortparallel:"âˆ¦",nsim:"â‰",nsime:"â‰„",nsimeq:"â‰„",nsmid:"âˆ¤",nspar:"âˆ¦",nsqsube:"â‹¢",nsqsupe:"â‹£",nsub:"âŠ„",nsubE:"â«…Ì¸",nsube:"âŠˆ",nsubset:"âŠ‚âƒ’",nsubseteq:"âŠˆ",nsubseteqq:"â«…Ì¸",nsucc:"âŠ",nsucceq:"âª°Ì¸",nsup:"âŠ…",nsupE:"â«†Ì¸",nsupe:"âŠ‰",nsupset:"âŠƒâƒ’",nsupseteq:"âŠ‰",nsupseteqq:"â«†Ì¸",ntgl:"â‰¹",Ntilde:"Ã‘",ntilde:"Ã±",ntlg:"â‰¸",ntriangleleft:"â‹ª",ntrianglelefteq:"â‹¬",ntriangleright:"â‹«",ntrianglerighteq:"â‹­",Nu:"Î",nu:"Î½",num:"#",numero:"â„–",numsp:"â€‡",nvap:"â‰âƒ’",nVDash:"âŠ¯",nVdash:"âŠ®",nvDash:"âŠ­",nvdash:"âŠ¬",nvge:"â‰¥âƒ’",nvgt:">âƒ’",nvHarr:"â¤„",nvinfin:"â§",nvlArr:"â¤‚",nvle:"â‰¤âƒ’",nvlt:"<âƒ’",nvltrie:"âŠ´âƒ’",nvrArr:"â¤ƒ",nvrtrie:"âŠµâƒ’",nvsim:"âˆ¼âƒ’",nwarhk:"â¤£",nwArr:"â‡–",nwarr:"â†–",nwarrow:"â†–",nwnear:"â¤§",Oacute:"Ã“",oacute:"Ã³",oast:"âŠ›",ocir:"âŠš",Ocirc:"Ã”",ocirc:"Ã´",Ocy:"Ğ",ocy:"Ğ¾",odash:"âŠ",Odblac:"Å",odblac:"Å‘",odiv:"â¨¸",odot:"âŠ™",odsold:"â¦¼",OElig:"Å’",oelig:"Å“",ofcir:"â¦¿",Ofr:"ğ”’",ofr:"ğ”¬",ogon:"Ë›",Ograve:"Ã’",ograve:"Ã²",ogt:"â§",ohbar:"â¦µ",ohm:"Î©",oint:"âˆ®",olarr:"â†º",olcir:"â¦¾",olcross:"â¦»",oline:"â€¾",olt:"â§€",Omacr:"ÅŒ",omacr:"Å",Omega:"Î©",omega:"Ï‰",Omicron:"ÎŸ",omicron:"Î¿",omid:"â¦¶",ominus:"âŠ–",Oopf:"ğ•†",oopf:"ğ• ",opar:"â¦·",OpenCurlyDoubleQuote:"â€œ",OpenCurlyQuote:"â€˜",operp:"â¦¹",oplus:"âŠ•",Or:"â©”",or:"âˆ¨",orarr:"â†»",ord:"â©",order:"â„´",orderof:"â„´",ordf:"Âª",ordm:"Âº",origof:"âŠ¶",oror:"â©–",orslope:"â©—",orv:"â©›",oS:"â“ˆ",Oscr:"ğ’ª",oscr:"â„´",Oslash:"Ã˜",oslash:"Ã¸",osol:"âŠ˜",Otilde:"Ã•",otilde:"Ãµ",Otimes:"â¨·",otimes:"âŠ—",otimesas:"â¨¶",Ouml:"Ã–",ouml:"Ã¶",ovbar:"âŒ½",OverBar:"â€¾",OverBrace:"â",OverBracket:"â´",OverParenthesis:"âœ",par:"âˆ¥",para:"Â¶",parallel:"âˆ¥",parsim:"â«³",parsl:"â«½",part:"âˆ‚",PartialD:"âˆ‚",Pcy:"ĞŸ",pcy:"Ğ¿",percnt:"%",period:".",permil:"â€°",perp:"âŠ¥",pertenk:"â€±",Pfr:"ğ”“",pfr:"ğ”­",Phi:"Î¦",phi:"Ï†",phiv:"Ï•",phmmat:"â„³",phone:"â˜",Pi:"Î ",pi:"Ï€",pitchfork:"â‹”",piv:"Ï–",planck:"â„",planckh:"â„",plankv:"â„",plus:"+",plusacir:"â¨£",plusb:"âŠ",pluscir:"â¨¢",plusdo:"âˆ”",plusdu:"â¨¥",pluse:"â©²",PlusMinus:"Â±",plusmn:"Â±",plussim:"â¨¦",plustwo:"â¨§",pm:"Â±",Poincareplane:"â„Œ",pointint:"â¨•",Popf:"â„™",popf:"ğ•¡",pound:"Â£",Pr:"âª»",pr:"â‰º",prap:"âª·",prcue:"â‰¼",prE:"âª³",pre:"âª¯",prec:"â‰º",precapprox:"âª·",preccurlyeq:"â‰¼",Precedes:"â‰º",PrecedesEqual:"âª¯",PrecedesSlantEqual:"â‰¼",PrecedesTilde:"â‰¾",preceq:"âª¯",precnapprox:"âª¹",precneqq:"âªµ",precnsim:"â‹¨",precsim:"â‰¾",Prime:"â€³",prime:"â€²",primes:"â„™",prnap:"âª¹",prnE:"âªµ",prnsim:"â‹¨",prod:"âˆ",Product:"âˆ",profalar:"âŒ®",profline:"âŒ’",profsurf:"âŒ“",prop:"âˆ",Proportion:"âˆ·",Proportional:"âˆ",propto:"âˆ",prsim:"â‰¾",prurel:"âŠ°",Pscr:"ğ’«",pscr:"ğ“…",Psi:"Î¨",psi:"Ïˆ",puncsp:"â€ˆ",Qfr:"ğ””",qfr:"ğ”®",qint:"â¨Œ",Qopf:"â„š",qopf:"ğ•¢",qprime:"â—",Qscr:"ğ’¬",qscr:"ğ“†",quaternions:"â„",quatint:"â¨–",quest:"?",questeq:"â‰Ÿ",QUOT:'"',quot:'"',rAarr:"â‡›",race:"âˆ½Ì±",Racute:"Å”",racute:"Å•",radic:"âˆš",raemptyv:"â¦³",Rang:"âŸ«",rang:"âŸ©",rangd:"â¦’",range:"â¦¥",rangle:"âŸ©",raquo:"Â»",Rarr:"â† ",rArr:"â‡’",rarr:"â†’",rarrap:"â¥µ",rarrb:"â‡¥",rarrbfs:"â¤ ",rarrc:"â¤³",rarrfs:"â¤",rarrhk:"â†ª",rarrlp:"â†¬",rarrpl:"â¥…",rarrsim:"â¥´",Rarrtl:"â¤–",rarrtl:"â†£",rarrw:"â†",rAtail:"â¤œ",ratail:"â¤š",ratio:"âˆ¶",rationals:"â„š",RBarr:"â¤",rBarr:"â¤",rbarr:"â¤",rbbrk:"â³",rbrace:"}",rbrack:"]",rbrke:"â¦Œ",rbrksld:"â¦",rbrkslu:"â¦",Rcaron:"Å˜",rcaron:"Å™",Rcedil:"Å–",rcedil:"Å—",rceil:"âŒ‰",rcub:"}",Rcy:"Ğ ",rcy:"Ñ€",rdca:"â¤·",rdldhar:"â¥©",rdquo:"â€",rdquor:"â€",rdsh:"â†³",Re:"â„œ",real:"â„œ",realine:"â„›",realpart:"â„œ",reals:"â„",rect:"â–­",REG:"Â®",reg:"Â®",ReverseElement:"âˆ‹",ReverseEquilibrium:"â‡‹",ReverseUpEquilibrium:"â¥¯",rfisht:"â¥½",rfloor:"âŒ‹",Rfr:"â„œ",rfr:"ğ”¯",rHar:"â¥¤",rhard:"â‡",rharu:"â‡€",rharul:"â¥¬",Rho:"Î¡",rho:"Ï",rhov:"Ï±",RightAngleBracket:"âŸ©",RightArrow:"â†’",Rightarrow:"â‡’",rightarrow:"â†’",RightArrowBar:"â‡¥",RightArrowLeftArrow:"â‡„",rightarrowtail:"â†£",RightCeiling:"âŒ‰",RightDoubleBracket:"âŸ§",RightDownTeeVector:"â¥",RightDownVector:"â‡‚",RightDownVectorBar:"â¥•",RightFloor:"âŒ‹",rightharpoondown:"â‡",rightharpoonup:"â‡€",rightleftarrows:"â‡„",rightleftharpoons:"â‡Œ",rightrightarrows:"â‡‰",rightsquigarrow:"â†",RightTee:"âŠ¢",RightTeeArrow:"â†¦",RightTeeVector:"â¥›",rightthreetimes:"â‹Œ",RightTriangle:"âŠ³",RightTriangleBar:"â§",RightTriangleEqual:"âŠµ",RightUpDownVector:"â¥",RightUpTeeVector:"â¥œ",RightUpVector:"â†¾",RightUpVectorBar:"â¥”",RightVector:"â‡€",RightVectorBar:"â¥“",ring:"Ëš",risingdotseq:"â‰“",rlarr:"â‡„",rlhar:"â‡Œ",rlm:"â€",rmoust:"â±",rmoustache:"â±",rnmid:"â«®",roang:"âŸ­",roarr:"â‡¾",robrk:"âŸ§",ropar:"â¦†",Ropf:"â„",ropf:"ğ•£",roplus:"â¨®",rotimes:"â¨µ",RoundImplies:"â¥°",rpar:")",rpargt:"â¦”",rppolint:"â¨’",rrarr:"â‡‰",Rrightarrow:"â‡›",rsaquo:"â€º",Rscr:"â„›",rscr:"ğ“‡",Rsh:"â†±",rsh:"â†±",rsqb:"]",rsquo:"â€™",rsquor:"â€™",rthree:"â‹Œ",rtimes:"â‹Š",rtri:"â–¹",rtrie:"âŠµ",rtrif:"â–¸",rtriltri:"â§",RuleDelayed:"â§´",ruluhar:"â¥¨",rx:"â„",Sacute:"Åš",sacute:"Å›",sbquo:"â€š",Sc:"âª¼",sc:"â‰»",scap:"âª¸",Scaron:"Å ",scaron:"Å¡",sccue:"â‰½",scE:"âª´",sce:"âª°",Scedil:"Å",scedil:"ÅŸ",Scirc:"Åœ",scirc:"Å",scnap:"âªº",scnE:"âª¶",scnsim:"â‹©",scpolint:"â¨“",scsim:"â‰¿",Scy:"Ğ¡",scy:"Ñ",sdot:"â‹…",sdotb:"âŠ¡",sdote:"â©¦",searhk:"â¤¥",seArr:"â‡˜",searr:"â†˜",searrow:"â†˜",sect:"Â§",semi:";",seswar:"â¤©",setminus:"âˆ–",setmn:"âˆ–",sext:"âœ¶",Sfr:"ğ”–",sfr:"ğ”°",sfrown:"âŒ¢",sharp:"â™¯",SHCHcy:"Ğ©",shchcy:"Ñ‰",SHcy:"Ğ¨",shcy:"Ñˆ",ShortDownArrow:"â†“",ShortLeftArrow:"â†",shortmid:"âˆ£",shortparallel:"âˆ¥",ShortRightArrow:"â†’",ShortUpArrow:"â†‘",shy:"Â­",Sigma:"Î£",sigma:"Ïƒ",sigmaf:"Ï‚",sigmav:"Ï‚",sim:"âˆ¼",simdot:"â©ª",sime:"â‰ƒ",simeq:"â‰ƒ",simg:"âª",simgE:"âª ",siml:"âª",simlE:"âªŸ",simne:"â‰†",simplus:"â¨¤",simrarr:"â¥²",slarr:"â†",SmallCircle:"âˆ˜",smallsetminus:"âˆ–",smashp:"â¨³",smeparsl:"â§¤",smid:"âˆ£",smile:"âŒ£",smt:"âªª",smte:"âª¬",smtes:"âª¬ï¸€",SOFTcy:"Ğ¬",softcy:"ÑŒ",sol:"/",solb:"â§„",solbar:"âŒ¿",Sopf:"ğ•Š",sopf:"ğ•¤",spades:"â™ ",spadesuit:"â™ ",spar:"âˆ¥",sqcap:"âŠ“",sqcaps:"âŠ“ï¸€",sqcup:"âŠ”",sqcups:"âŠ”ï¸€",Sqrt:"âˆš",sqsub:"âŠ",sqsube:"âŠ‘",sqsubset:"âŠ",sqsubseteq:"âŠ‘",sqsup:"âŠ",sqsupe:"âŠ’",sqsupset:"âŠ",sqsupseteq:"âŠ’",squ:"â–¡",Square:"â–¡",square:"â–¡",SquareIntersection:"âŠ“",SquareSubset:"âŠ",SquareSubsetEqual:"âŠ‘",SquareSuperset:"âŠ",SquareSupersetEqual:"âŠ’",SquareUnion:"âŠ”",squarf:"â–ª",squf:"â–ª",srarr:"â†’",Sscr:"ğ’®",sscr:"ğ“ˆ",ssetmn:"âˆ–",ssmile:"âŒ£",sstarf:"â‹†",Star:"â‹†",star:"â˜†",starf:"â˜…",straightepsilon:"Ïµ",straightphi:"Ï•",strns:"Â¯",Sub:"â‹",sub:"âŠ‚",subdot:"âª½",subE:"â«…",sube:"âŠ†",subedot:"â«ƒ",submult:"â«",subnE:"â«‹",subne:"âŠŠ",subplus:"âª¿",subrarr:"â¥¹",Subset:"â‹",subset:"âŠ‚",subseteq:"âŠ†",subseteqq:"â«…",SubsetEqual:"âŠ†",subsetneq:"âŠŠ",subsetneqq:"â«‹",subsim:"â«‡",subsub:"â«•",subsup:"â«“",succ:"â‰»",succapprox:"âª¸",succcurlyeq:"â‰½",Succeeds:"â‰»",SucceedsEqual:"âª°",SucceedsSlantEqual:"â‰½",SucceedsTilde:"â‰¿",succeq:"âª°",succnapprox:"âªº",succneqq:"âª¶",succnsim:"â‹©",succsim:"â‰¿",SuchThat:"âˆ‹",Sum:"âˆ‘",sum:"âˆ‘",sung:"â™ª",Sup:"â‹‘",sup:"âŠƒ",sup1:"Â¹",sup2:"Â²",sup3:"Â³",supdot:"âª¾",supdsub:"â«˜",supE:"â«†",supe:"âŠ‡",supedot:"â«„",Superset:"âŠƒ",SupersetEqual:"âŠ‡",suphsol:"âŸ‰",suphsub:"â«—",suplarr:"â¥»",supmult:"â«‚",supnE:"â«Œ",supne:"âŠ‹",supplus:"â«€",Supset:"â‹‘",supset:"âŠƒ",supseteq:"âŠ‡",supseteqq:"â«†",supsetneq:"âŠ‹",supsetneqq:"â«Œ",supsim:"â«ˆ",supsub:"â«”",supsup:"â«–",swarhk:"â¤¦",swArr:"â‡™",swarr:"â†™",swarrow:"â†™",swnwar:"â¤ª",szlig:"ÃŸ",Tab:"\t",target:"âŒ–",Tau:"Î¤",tau:"Ï„",tbrk:"â´",Tcaron:"Å¤",tcaron:"Å¥",Tcedil:"Å¢",tcedil:"Å£",Tcy:"Ğ¢",tcy:"Ñ‚",tdot:"âƒ›",telrec:"âŒ•",Tfr:"ğ”—",tfr:"ğ”±",there4:"âˆ´",Therefore:"âˆ´",therefore:"âˆ´",Theta:"Î˜",theta:"Î¸",thetasym:"Ï‘",thetav:"Ï‘",thickapprox:"â‰ˆ",thicksim:"âˆ¼",ThickSpace:"âŸâ€Š",thinsp:"â€‰",ThinSpace:"â€‰",thkap:"â‰ˆ",thksim:"âˆ¼",THORN:"Ã",thorn:"Ã¾",Tilde:"âˆ¼",tilde:"Ëœ",TildeEqual:"â‰ƒ",TildeFullEqual:"â‰…",TildeTilde:"â‰ˆ",times:"Ã—",timesb:"âŠ ",timesbar:"â¨±",timesd:"â¨°",tint:"âˆ­",toea:"â¤¨",top:"âŠ¤",topbot:"âŒ¶",topcir:"â«±",Topf:"ğ•‹",topf:"ğ•¥",topfork:"â«š",tosa:"â¤©",tprime:"â€´",TRADE:"â„¢",trade:"â„¢",triangle:"â–µ",triangledown:"â–¿",triangleleft:"â—ƒ",trianglelefteq:"âŠ´",triangleq:"â‰œ",triangleright:"â–¹",trianglerighteq:"âŠµ",tridot:"â—¬",trie:"â‰œ",triminus:"â¨º",TripleDot:"âƒ›",triplus:"â¨¹",trisb:"â§",tritime:"â¨»",trpezium:"â¢",Tscr:"ğ’¯",tscr:"ğ“‰",TScy:"Ğ¦",tscy:"Ñ†",TSHcy:"Ğ‹",tshcy:"Ñ›",Tstrok:"Å¦",tstrok:"Å§",twixt:"â‰¬",twoheadleftarrow:"â†",twoheadrightarrow:"â† ",Uacute:"Ãš",uacute:"Ãº",Uarr:"â†Ÿ",uArr:"â‡‘",uarr:"â†‘",Uarrocir:"â¥‰",Ubrcy:"Ğ",ubrcy:"Ñ",Ubreve:"Å¬",ubreve:"Å­",Ucirc:"Ã›",ucirc:"Ã»",Ucy:"Ğ£",ucy:"Ñƒ",udarr:"â‡…",Udblac:"Å°",udblac:"Å±",udhar:"â¥®",ufisht:"â¥¾",Ufr:"ğ”˜",ufr:"ğ”²",Ugrave:"Ã™",ugrave:"Ã¹",uHar:"â¥£",uharl:"â†¿",uharr:"â†¾",uhblk:"â–€",ulcorn:"âŒœ",ulcorner:"âŒœ",ulcrop:"âŒ",ultri:"â—¸",Umacr:"Åª",umacr:"Å«",uml:"Â¨",UnderBar:"_",UnderBrace:"âŸ",UnderBracket:"âµ",UnderParenthesis:"â",Union:"â‹ƒ",UnionPlus:"âŠ",Uogon:"Å²",uogon:"Å³",Uopf:"ğ•Œ",uopf:"ğ•¦",UpArrow:"â†‘",Uparrow:"â‡‘",uparrow:"â†‘",UpArrowBar:"â¤’",UpArrowDownArrow:"â‡…",UpDownArrow:"â†•",Updownarrow:"â‡•",updownarrow:"â†•",UpEquilibrium:"â¥®",upharpoonleft:"â†¿",upharpoonright:"â†¾",uplus:"âŠ",UpperLeftArrow:"â†–",UpperRightArrow:"â†—",Upsi:"Ï’",upsi:"Ï…",upsih:"Ï’",Upsilon:"Î¥",upsilon:"Ï…",UpTee:"âŠ¥",UpTeeArrow:"â†¥",upuparrows:"â‡ˆ",urcorn:"âŒ",urcorner:"âŒ",urcrop:"âŒ",Uring:"Å®",uring:"Å¯",urtri:"â—¹",Uscr:"ğ’°",uscr:"ğ“Š",utdot:"â‹°",Utilde:"Å¨",utilde:"Å©",utri:"â–µ",utrif:"â–´",uuarr:"â‡ˆ",Uuml:"Ãœ",uuml:"Ã¼",uwangle:"â¦§",vangrt:"â¦œ",varepsilon:"Ïµ",varkappa:"Ï°",varnothing:"âˆ…",varphi:"Ï•",varpi:"Ï–",varpropto:"âˆ",vArr:"â‡•",varr:"â†•",varrho:"Ï±",varsigma:"Ï‚",varsubsetneq:"âŠŠï¸€",varsubsetneqq:"â«‹ï¸€",varsupsetneq:"âŠ‹ï¸€",varsupsetneqq:"â«Œï¸€",vartheta:"Ï‘",vartriangleleft:"âŠ²",vartriangleright:"âŠ³",Vbar:"â««",vBar:"â«¨",vBarv:"â«©",Vcy:"Ğ’",vcy:"Ğ²",VDash:"âŠ«",Vdash:"âŠ©",vDash:"âŠ¨",vdash:"âŠ¢",Vdashl:"â«¦",Vee:"â‹",vee:"âˆ¨",veebar:"âŠ»",veeeq:"â‰š",vellip:"â‹®",Verbar:"â€–",verbar:"|",Vert:"â€–",vert:"|",VerticalBar:"âˆ£",VerticalLine:"|",VerticalSeparator:"â˜",VerticalTilde:"â‰€",VeryThinSpace:"â€Š",Vfr:"ğ”™",vfr:"ğ”³",vltri:"âŠ²",vnsub:"âŠ‚âƒ’",vnsup:"âŠƒâƒ’",Vopf:"ğ•",vopf:"ğ•§",vprop:"âˆ",vrtri:"âŠ³",Vscr:"ğ’±",vscr:"ğ“‹",vsubnE:"â«‹ï¸€",vsubne:"âŠŠï¸€",vsupnE:"â«Œï¸€",vsupne:"âŠ‹ï¸€",Vvdash:"âŠª",vzigzag:"â¦š",Wcirc:"Å´",wcirc:"Åµ",wedbar:"â©Ÿ",Wedge:"â‹€",wedge:"âˆ§",wedgeq:"â‰™",weierp:"â„˜",Wfr:"ğ”š",wfr:"ğ”´",Wopf:"ğ•",wopf:"ğ•¨",wp:"â„˜",wr:"â‰€",wreath:"â‰€",Wscr:"ğ’²",wscr:"ğ“Œ",xcap:"â‹‚",xcirc:"â—¯",xcup:"â‹ƒ",xdtri:"â–½",Xfr:"ğ”›",xfr:"ğ”µ",xhArr:"âŸº",xharr:"âŸ·",Xi:"Î",xi:"Î¾",xlArr:"âŸ¸",xlarr:"âŸµ",xmap:"âŸ¼",xnis:"â‹»",xodot:"â¨€",Xopf:"ğ•",xopf:"ğ•©",xoplus:"â¨",xotime:"â¨‚",xrArr:"âŸ¹",xrarr:"âŸ¶",Xscr:"ğ’³",xscr:"ğ“",xsqcup:"â¨†",xuplus:"â¨„",xutri:"â–³",xvee:"â‹",xwedge:"â‹€",Yacute:"Ã",yacute:"Ã½",YAcy:"Ğ¯",yacy:"Ñ",Ycirc:"Å¶",ycirc:"Å·",Ycy:"Ğ«",ycy:"Ñ‹",yen:"Â¥",Yfr:"ğ”œ",yfr:"ğ”¶",YIcy:"Ğ‡",yicy:"Ñ—",Yopf:"ğ•",yopf:"ğ•ª",Yscr:"ğ’´",yscr:"ğ“",YUcy:"Ğ®",yucy:"Ñ",Yuml:"Å¸",yuml:"Ã¿",Zacute:"Å¹",zacute:"Åº",Zcaron:"Å½",zcaron:"Å¾",Zcy:"Ğ—",zcy:"Ğ·",Zdot:"Å»",zdot:"Å¼",zeetrf:"â„¨",ZeroWidthSpace:"â€‹",Zeta:"Î–",zeta:"Î¶",Zfr:"â„¨",zfr:"ğ”·",ZHcy:"Ğ–",zhcy:"Ğ¶",zigrarr:"â‡",Zopf:"â„¤",zopf:"ğ•«",Zscr:"ğ’µ",zscr:"ğ“",zwj:"â€",zwnj:"â€Œ"}),t.entityMap=t.HTML_ENTITIES},8978:(e,t,r)=>{var a=r(4722);t.DOMImplementation=a.DOMImplementation,t.XMLSerializer=a.XMLSerializer,t.DOMParser=r(5752).DOMParser},4466:(e,t,r)=>{var a=r(4582).NAMESPACE,n=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,o=new RegExp("[\\-\\.0-9"+n.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),i=new RegExp("^"+n.source+o.source+"*(?::"+n.source+o.source+"*)?$");function s(e,t){this.message=e,this.locator=t,Error.captureStackTrace&&Error.captureStackTrace(this,s)}function l(){}function c(e,t){return t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber,t}function u(e,t,r,n,o,i){function s(e,t,a){r.attributeNames.hasOwnProperty(e)&&i.fatalError("Attribute "+e+" redefined"),r.addValue(e,t.replace(/[\t\n\r]/g," ").replace(/&#?\w+;/g,o),a)}for(var l,c=++t,u=0;;){var h=e.charAt(c);switch(h){case"=":if(1===u)l=e.slice(t,c),u=3;else{if(2!==u)throw new Error("attribute equal must after attrName");u=3}break;case"'":case'"':if(3===u||1===u){if(1===u&&(i.warning('attribute value must after "="'),l=e.slice(t,c)),t=c+1,!((c=e.indexOf(h,t))>0))throw new Error("attribute value no end '"+h+"' match");s(l,d=e.slice(t,c),t-1),u=5}else{if(4!=u)throw new Error('attribute value must after "="');s(l,d=e.slice(t,c),t),i.warning('attribute "'+l+'" missed start quot('+h+")!!"),t=c+1,u=5}break;case"/":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:u=7,r.closed=!0;case 4:case 1:break;case 2:r.closed=!0;break;default:throw new Error("attribute invalid close char('/')")}break;case"":return i.error("unexpected end of input"),0==u&&r.setTagName(e.slice(t,c)),c;case">":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:break;case 4:case 1:"/"===(d=e.slice(t,c)).slice(-1)&&(r.closed=!0,d=d.slice(0,-1));case 2:2===u&&(d=l),4==u?(i.warning('attribute "'+d+'" missed quot(")!'),s(l,d,t)):(a.isHTML(n[""])&&d.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+d+'" missed value!! "'+d+'" instead!!'),s(d,d,t));break;case 3:throw new Error("attribute value missed!!")}return c;case"Â€":h=" ";default:if(h<=" ")switch(u){case 0:r.setTagName(e.slice(t,c)),u=6;break;case 1:l=e.slice(t,c),u=2;break;case 4:var d=e.slice(t,c);i.warning('attribute "'+d+'" missed quot(")!!'),s(l,d,t);case 5:u=6}else switch(u){case 2:r.tagName,a.isHTML(n[""])&&l.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+l+'" missed value!! "'+l+'" instead2!!'),s(l,l,t),t=c,u=1;break;case 5:i.warning('attribute space is required"'+l+'"!!');case 6:u=1,t=c;break;case 3:u=4,t=c;break;case 7:throw new Error("elements closed character '/' and '>' must be connected to")}}c++}}function h(e,t,r){for(var n=e.tagName,o=null,i=e.length;i--;){var s=e[i],l=s.qName,c=s.value;if((m=l.indexOf(":"))>0)var u=s.prefix=l.slice(0,m),h=l.slice(m+1),d="xmlns"===u&&h;else h=l,u=null,d="xmlns"===l&&"";s.localName=h,!1!==d&&(null==o&&(o={},p(r,r={})),r[d]=o[d]=c,s.uri=a.XMLNS,t.startPrefixMapping(d,c))}for(i=e.length;i--;)(u=(s=e[i]).prefix)&&("xml"===u&&(s.uri=a.XML),"xmlns"!==u&&(s.uri=r[u||""]));var m;(m=n.indexOf(":"))>0?(u=e.prefix=n.slice(0,m),h=e.localName=n.slice(m+1)):(u=null,h=e.localName=n);var f=e.uri=r[u||""];if(t.startElement(f,h,n,e),!e.closed)return e.currentNSMap=r,e.localNSMap=o,!0;if(t.endElement(f,h,n),o)for(u in o)Object.prototype.hasOwnProperty.call(o,u)&&t.endPrefixMapping(u)}function d(e,t,r,a,n){if(/^(?:script|textarea)$/i.test(r)){var o=e.indexOf("</"+r+">",t),i=e.substring(t+1,o);if(/[&<]/.test(i))return/^script$/i.test(r)?(n.characters(i,0,i.length),o):(i=i.replace(/&#?\w+;/g,a),n.characters(i,0,i.length),o)}return t+1}function m(e,t,r,a){var n=a[r];return null==n&&((n=e.lastIndexOf("</"+r+">"))<t&&(n=e.lastIndexOf("</"+r)),a[r]=n),n<t}function p(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function f(e,t,r,a){if("-"===e.charAt(t+2))return"-"===e.charAt(t+3)?(n=e.indexOf("--\x3e",t+4))>t?(r.comment(e,t+4,n-t-4),n+3):(a.error("Unclosed comment"),-1):-1;if("CDATA["==e.substr(t+3,6)){var n=e.indexOf("]]>",t+9);return r.startCDATA(),r.characters(e,t+9,n-t-9),r.endCDATA(),n+3}var o=function(e,t){var r,a=[],n=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;for(n.lastIndex=t,n.exec(e);r=n.exec(e);)if(a.push(r),r[1])return a}(e,t),i=o.length;if(i>1&&/!doctype/i.test(o[0][0])){var s=o[1][0],l=!1,c=!1;i>3&&(/^public$/i.test(o[2][0])?(l=o[3][0],c=i>4&&o[4][0]):/^system$/i.test(o[2][0])&&(c=o[3][0]));var u=o[i-1];return r.startDTD(s,l,c),r.endDTD(),u.index+u[0].length}return-1}function x(e,t,r){var a=e.indexOf("?>",t);if(a){var n=e.substring(t,a).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);return n?(n[0].length,r.processingInstruction(n[1],n[2]),a+2):-1}return-1}function g(){this.attributeNames={}}s.prototype=new Error,s.prototype.name=s.name,l.prototype={parse:function(e,t,r){var n=this.domBuilder;n.startDocument(),p(t,t={}),function(e,t,r,n,o){function i(e){var t=e.slice(1,-1);return Object.hasOwnProperty.call(r,t)?r[t]:"#"===t.charAt(0)?function(e){if(e>65535){var t=55296+((e-=65536)>>10),r=56320+(1023&e);return String.fromCharCode(t,r)}return String.fromCharCode(e)}(parseInt(t.substr(1).replace("x","0x"))):(o.error("entity not found:"+e),e)}function l(t){if(t>_){var r=e.substring(_,t).replace(/&#?\w+;/g,i);C&&p(_),n.characters(r,0,t-_),_=t}}function p(t,r){for(;t>=b&&(r=v.exec(e));)w=r.index,b=w+r[0].length,C.lineNumber++;C.columnNumber=t-w+1}for(var w=0,b=0,v=/.*(?:\r\n?|\n)|.*$/g,C=n.locator,A=[{currentNSMap:t}],E={},_=0;;){try{var y=e.indexOf("<",_);if(y<0){if(!e.substr(_).match(/^\s*$/)){var q=n.doc,D=q.createTextNode(e.substr(_));q.appendChild(D),n.currentElement=D}return}switch(y>_&&l(y),e.charAt(y+1)){case"/":var M=e.indexOf(">",y+3),T=e.substring(y+2,M).replace(/[ \t\n\r]+$/g,""),N=A.pop();M<0?(T=e.substring(y+2).replace(/[\s<].*/,""),o.error("end tag name: "+T+" is not complete:"+N.tagName),M=y+1+T.length):T.match(/\s</)&&(T=T.replace(/[\s<].*/,""),o.error("end tag name: "+T+" maybe not complete"),M=y+1+T.length);var O=N.localNSMap,L=N.tagName==T;if(L||N.tagName&&N.tagName.toLowerCase()==T.toLowerCase()){if(n.endElement(N.uri,N.localName,T),O)for(var B in O)Object.prototype.hasOwnProperty.call(O,B)&&n.endPrefixMapping(B);L||o.fatalError("end tag name: "+T+" is not match the current start tagName:"+N.tagName)}else A.push(N);M++;break;case"?":C&&p(y),M=x(e,y,n);break;case"!":C&&p(y),M=f(e,y,n,o);break;default:C&&p(y);var S=new g,F=A[A.length-1].currentNSMap,P=(M=u(e,y,S,F,i,o),S.length);if(!S.closed&&m(e,M,S.tagName,E)&&(S.closed=!0,r.nbsp||o.warning("unclosed xml attribute")),C&&P){for(var k=c(C,{}),R=0;R<P;R++){var I=S[R];p(I.offset),I.locator=c(C,{})}n.locator=k,h(S,n,F)&&A.push(S),n.locator=C}else h(S,n,F)&&A.push(S);a.isHTML(S.uri)&&!S.closed?M=d(e,M,S.tagName,i,n):M++}}catch(e){if(e instanceof s)throw e;o.error("element parse error: "+e),M=-1}M>_?_=M:l(Math.max(y,_)+1)}}(e,t,r,n,this.errorHandler),n.endDocument()}},g.prototype={setTagName:function(e){if(!i.test(e))throw new Error("invalid tagName:"+e);this.tagName=e},addValue:function(e,t,r){if(!i.test(e))throw new Error("invalid attribute:"+e);this.attributeNames[e]=this.length,this[this.length++]={qName:e,value:t,offset:r}},length:0,getLocalName:function(e){return this[e].localName},getLocator:function(e){return this[e].locator},getQName:function(e){return this[e].qName},getURI:function(e){return this[e].uri},getValue:function(e){return this[e].value}},t.XMLReader=l,t.ParseError=s},8917:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;var a=r(6200);Object.defineProperty(t,"InvalidNumberOfChildrenError",{enumerable:!0,get:function(){return a.InvalidNumberOfChildrenError}})},6200:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;class r extends Error{constructor(e,t,r,a="exactly"){super(`${e} tag must have ${a} ${t} children. It's actually ${r}`),this.name="InvalidNumberOfChildrenError"}}t.InvalidNumberOfChildrenError=r},4279:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(828),t),n(r(5975),t),n(r(799),t),n(r(2424),t)},5975:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JoinWithManySeparators=void 0;class r{constructor(e){this._separators=e}static join(e,t){return new r(t)._join(e)}_join(e){return e.reduce(((e,t,r,a)=>e+t+(r===a.length-1?"":this._get(r))),"")}_get(e){return this._separators[e]?this._separators[e]:this._separators.length>0?this._separators[this._separators.length-1]:","}}t.JoinWithManySeparators=r},799:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathMLElementToLaTeXConverter=void 0;const a=r(5443);t.mathMLElementToLaTeXConverter=e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter()},2424:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.normalizeWhiteSpaces=void 0,t.normalizeWhiteSpaces=e=>e.replace(/\s+/g," ")},7192:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BracketWrapper=void 0;const a=r(1855);t.BracketWrapper=class{constructor(){this._open="{",this._close="}"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},5025:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=void 0;const a=r(1855);t.GenericWrapper=class{constructor(e,t){this._open="\\left"+e,this._close="\\right"+t}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},828:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=t.ParenthesisWrapper=t.BracketWrapper=void 0;var a=r(7192);Object.defineProperty(t,"BracketWrapper",{enumerable:!0,get:function(){return a.BracketWrapper}});var n=r(1168);Object.defineProperty(t,"ParenthesisWrapper",{enumerable:!0,get:function(){return n.ParenthesisWrapper}});var o=r(5025);Object.defineProperty(t,"GenericWrapper",{enumerable:!0,get:function(){return o.GenericWrapper}})},1168:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ParenthesisWrapper=void 0;const a=r(1855);t.ParenthesisWrapper=class{constructor(){this._open="\\left(",this._close="\\right)"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}wrapIfMoreThanOneChar(e){return e.length<=1?e:this.wrap(e)}}},1855:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Wrapper=void 0,t.Wrapper=class{constructor(e,t){this._open=e,this._close=t}wrap(e){return this._open+e+this._close}}},2697:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VoidMathMLElement=void 0,t.VoidMathMLElement=class{constructor(){this.name="void",this.value="",this.children=[],this.attributes={}}}},4760:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericSpacingWrapper=void 0;const a=r(4279);t.GenericSpacingWrapper=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}},9376:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericUnderOver=void 0;const a=r(799),n=r(8917),o=r(472);t.GenericUnderOver=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert(),i=(0,a.mathMLElementToLaTeXConverter)(t[1]).convert();return this._applyCommand(o,i)}_applyCommand(e,t){const r=this._mathmlElement.name.match(/under/)?s.Under:s.Over;return new i(r).apply(e,t)}};class i{constructor(e){this._type=e}apply(e,t){return o.latexAccents.includes(t)?`${t}{${e}}`:`${this._defaultCommand}{${t}}{${e}}`}get _defaultCommand(){return this._type===s.Under?"\\underset":"\\overset"}}var s;!function(e){e[e.Under=0]="Under",e[e.Over=1]="Over"}(s||(s={}))},6959:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=t.GenericUnderOver=t.GenericSpacingWrapper=t.MTr=t.MTable=t.MUnderover=t.MText=t.MMultiscripts=t.MSubsup=t.MSub=t.MSup=t.MPhantom=t.MError=t.MEnclose=t.MAction=t.MRoot=t.MFrac=t.MFenced=t.MSqrt=t.MN=t.MO=t.MI=t.Math=void 0;var a=r(393);Object.defineProperty(t,"Math",{enumerable:!0,get:function(){return a.Math}});var n=r(7037);Object.defineProperty(t,"MI",{enumerable:!0,get:function(){return n.MI}});var o=r(3487);Object.defineProperty(t,"MO",{enumerable:!0,get:function(){return o.MO}});var i=r(4464);Object.defineProperty(t,"MN",{enumerable:!0,get:function(){return i.MN}});var s=r(8686);Object.defineProperty(t,"MSqrt",{enumerable:!0,get:function(){return s.MSqrt}});var l=r(9511);Object.defineProperty(t,"MFenced",{enumerable:!0,get:function(){return l.MFenced}});var c=r(6440);Object.defineProperty(t,"MFrac",{enumerable:!0,get:function(){return c.MFrac}});var u=r(6052);Object.defineProperty(t,"MRoot",{enumerable:!0,get:function(){return u.MRoot}});var h=r(1678);Object.defineProperty(t,"MAction",{enumerable:!0,get:function(){return h.MAction}});var d=r(2631);Object.defineProperty(t,"MEnclose",{enumerable:!0,get:function(){return d.MEnclose}});var m=r(1840);Object.defineProperty(t,"MError",{enumerable:!0,get:function(){return m.MError}});var p=r(7443);Object.defineProperty(t,"MPhantom",{enumerable:!0,get:function(){return p.MPhantom}});var f=r(6926);Object.defineProperty(t,"MSup",{enumerable:!0,get:function(){return f.MSup}});var x=r(2564);Object.defineProperty(t,"MSub",{enumerable:!0,get:function(){return x.MSub}});var g=r(1358);Object.defineProperty(t,"MSubsup",{enumerable:!0,get:function(){return g.MSubsup}});var w=r(8303);Object.defineProperty(t,"MMultiscripts",{enumerable:!0,get:function(){return w.MMultiscripts}});var b=r(3951);Object.defineProperty(t,"MText",{enumerable:!0,get:function(){return b.MText}});var v=r(1222);Object.defineProperty(t,"MUnderover",{enumerable:!0,get:function(){return v.MUnderover}});var C=r(2350);Object.defineProperty(t,"MTable",{enumerable:!0,get:function(){return C.MTable}});var A=r(1586);Object.defineProperty(t,"MTr",{enumerable:!0,get:function(){return A.MTr}});var E=r(4760);Object.defineProperty(t,"GenericSpacingWrapper",{enumerable:!0,get:function(){return E.GenericSpacingWrapper}});var _=r(9376);Object.defineProperty(t,"GenericUnderOver",{enumerable:!0,get:function(){return _.GenericUnderOver}});var y=r(9165);Object.defineProperty(t,"Void",{enumerable:!0,get:function(){return y.Void}})},1678:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAction=void 0;const a=r(799);t.MAction=class{constructor(e){this._mathmlElement=e}convert(){const{children:e}=this._mathmlElement;return this._isToggle()?e.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\Longrightarrow "):(0,a.mathMLElementToLaTeXConverter)(e[0]).convert()}_isToggle(){const{actiontype:e}=this._mathmlElement.attributes;return"toggle"===e||!e}}},393:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Math=void 0;const a=r(799),n=r(2424);t.Math=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return(0,n.normalizeWhiteSpaces)(e)}}},2631:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MEnclose=void 0;const a=r(799);t.MEnclose=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return"actuarial"===this._notation?`\\overline{\\left.${e}\\right|}`:"radical"===this._notation?`\\sqrt{${e}}`:["box","roundedbox","circle"].includes(this._notation)?`\\boxed{${e}}`:"left"===this._notation?`\\left|${e}`:"right"===this._notation?`${e}\\right|`:"top"===this._notation?`\\overline{${e}}`:"bottom"===this._notation?`\\underline{${e}}`:"updiagonalstrike"===this._notation?`\\cancel{${e}}`:"downdiagonalstrike"===this._notation?`\\bcancel{${e}}`:"updiagonalarrow"===this._notation?`\\cancelto{}{${e}}`:["verticalstrike","horizontalstrike"].includes(this._notation)?`\\hcancel{${e}}`:"madruwb"===this._notation?`\\underline{${e}\\right|}`:"phasorangle"===this._notation?`{\\angle \\underline{${e}}}`:`\\overline{\\left.\\right)${e}}`}get _notation(){return this._mathmlElement.attributes.notation||"longdiv"}}},1840:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MError=void 0;const a=r(799);t.MError=class{constructor(e){this._mathmlElement=e}convert(){return`\\color{red}{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},9511:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFenced=void 0;const a=r(799),n=r(4279);t.MFenced=class{constructor(e){this._mathmlElement=e,this._open=this._mathmlElement.attributes.open||"",this._close=this._mathmlElement.attributes.close||"",this._separators=Array.from(this._mathmlElement.attributes.separators||"")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert()));return this._isThereRelativeOfName(this._mathmlElement.children,"mtable")?new i(this._open,this._close).apply(e):new o(this._open,this._close,this._separators).apply(e)}_isThereRelativeOfName(e,t){return e.some((e=>e.name===t||this._isThereRelativeOfName(e.children,t)))}};class o{constructor(e,t,r){this._open=e||"(",this._close=t||")",this._separators=r}apply(e){const t=n.JoinWithManySeparators.join(e,this._separators);return new n.GenericWrapper(this._open,this._close).wrap(t)}}class i{constructor(e,t){this._genericCommand="matrix",this._separators=new s(e,t)}apply(e){const t=this._command,r=`\\begin{${t}}\n${e.join("")}\n\\end{${t}}`;return t===this._genericCommand?this._separators.wrap(r):r}get _command(){return this._separators.areParentheses()?"pmatrix":this._separators.areSquareBrackets()?"bmatrix":this._separators.areBrackets()?"Bmatrix":this._separators.areDivides()?"vmatrix":this._separators.areParallels()?"Vmatrix":this._separators.areNotEqual()?this._genericCommand:"bmatrix"}}class s{constructor(e,t){this._open=e,this._close=t}wrap(e){return new n.GenericWrapper(this._open,this._close).wrap(e)}areParentheses(){return this._compare("(",")")}areSquareBrackets(){return this._compare("[","]")}areBrackets(){return this._compare("{","}")}areDivides(){return this._compare("|","|")}areParallels(){return this._compare("||","||")}areNotEqual(){return this._open!==this._close}_compare(e,t){return this._open===e&&this._close===t}}},6440:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFrac=void 0;const a=r(8917),n=r(4279);t.MFrac=class{constructor(e){this._mathmlElement=e}convert(){const{children:e,name:t}=this._mathmlElement,r=e.length;if(2!==r)throw new a.InvalidNumberOfChildrenError(t,2,r);const o=(0,n.mathMLElementToLaTeXConverter)(e[0]).convert(),i=(0,n.mathMLElementToLaTeXConverter)(e[1]).convert();return this._isBevelled()?`${this._wrapIfMoreThanOneChar(o)}/${this._wrapIfMoreThanOneChar(i)}`:`\\frac{${o}}{${i}}`}_wrapIfMoreThanOneChar(e){return(new n.ParenthesisWrapper).wrapIfMoreThanOneChar(e)}_isBevelled(){return!!this._mathmlElement.attributes.bevelled}}},7037:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MI=void 0;const a=r(4279),n=r(5406),o=r(6122);t.MI=class{constructor(e){this.utf8Converter=new o.HashUTF8ToLtXConverter,this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value);if(" "===e)return i.apply(e);const t=e.trim(),r=i.apply(t),n=this.utf8Converter.convert(r);return n!==r?n:this.wrapInMathVariant(r,this.getMathVariant(this._mathmlElement.attributes))}getMathVariant(e){if(e&&e.mathvariant)return e.mathvariant}wrapInMathVariant(e,t){switch(t){case"bold":return`\\mathbf{${e}}`;case"italic":return`\\mathit{${e}}`;case"bold-italic":return`\\mathbf{\\mathit{${e}}}`;case"double-struck":return`\\mathbb{${e}}`;case"bold-fraktur":return`\\mathbf{\\mathfrak{${e}}}`;case"script":return`\\mathcal{${e}}`;case"bold-script":return`\\mathbf{\\mathcal{${e}}}`;case"fraktur":return`\\mathfrak{${e}}`;case"sans-serif":return`\\mathsf{${e}}`;case"bold-sans-serif":return`\\mathbf{\\mathsf{${e}}}`;case"sans-serif-italic":return`\\mathsf{\\mathit{${e}}}`;case"sans-serif-bold-italic":return`\\mathbf{\\mathsf{\\mathit{${e}}}}`;case"monospace":return`\\mathtt{${e}}`;default:return e}}};class i{constructor(e){this._value=e}static apply(e){return new i(e)._apply()}_apply(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new o.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathSymbolsByChar[this._value]}_findByGlyph(){return n.allMathSymbolsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},8303:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MMultiscripts=void 0;const a=r(4279),n=r(8917);t.MMultiscripts=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(r<3)throw new n.InvalidNumberOfChildrenError(e,3,r,"at least");const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return this._prescriptLatex()+this._wrapInParenthesisIfThereIsSpace(o)+this._postscriptLatex()}_prescriptLatex(){const{children:e}=this._mathmlElement;let t,r;if(this._isPrescripts(e[1]))t=e[2],r=e[3];else{if(!this._isPrescripts(e[3]))return"";t=e[4],r=e[5]}return`\\_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_postscriptLatex(){const{children:e}=this._mathmlElement;if(this._isPrescripts(e[1]))return"";const t=e[1],r=e[2];return`_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_wrapInParenthesisIfThereIsSpace(e){return e.match(/\s+/g)?(new a.ParenthesisWrapper).wrap(e):e}_isPrescripts(e){return"mprescripts"===(null==e?void 0:e.name)}}},4464:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MN=void 0;const a=r(4279),n=r(5406);t.MN=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return n.mathNumberByGlyph[e]||e}}},3487:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MO=void 0;const a=r(4279),n=r(5406);t.MO=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return o.operate(e)}};class o{constructor(e){this._value=e}static operate(e){return new o(e)._operate()}_operate(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new n.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathOperatorsByChar[this._value]}_findByGlyph(){return n.allMathOperatorsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},7443:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MPhantom=void 0,t.MPhantom=class{constructor(e){this._mathmlElement=e}convert(){return""}}},6052:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MRoot=void 0;const a=r(4279),n=r(8917);t.MRoot=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return`\\sqrt[${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}]{${o}}`}}},8686:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSqrt=void 0;const a=r(4279);t.MSqrt=class{constructor(e){this._mathmlElement=e}convert(){return`\\sqrt{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},2564:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSub=void 0;const a=r(4279),n=r(8917);t.MSub=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},1358:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSubsup=void 0;const a=r(4279),n=r(8917);t.MSubsup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);const a=t[0],o=t[1],i=t[2];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}^${this._handleSuperscriptChild(i)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}_handleSuperscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},6926:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSup=void 0;const a=r(4279),n=r(8917);t.MSup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}^${this._handleExponentChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleExponentChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},2350:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTable=void 0;const a=r(4279);t.MTable=class{constructor(e){this._mathmlElement=e,this._addFlagRecursiveIfName(this._mathmlElement.children,"mtable","innerTable")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\\\\n");return this._hasFlag("innerTable")?this._wrap(e):e}_wrap(e){return`\\begin{matrix}${e}\\end{matrix}`}_addFlagRecursiveIfName(e,t,r){e.forEach((e=>{e.name===t&&(e.attributes[r]=r),this._addFlagRecursiveIfName(e.children,t,r)}))}_hasFlag(e){return!!this._mathmlElement.attributes[e]}}},3951:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MText=void 0;const a=r(7037);t.MText=class{constructor(e){this._mathmlElement=e}convert(){const{attributes:e,value:t}=this._mathmlElement;return[...t].map((e=>/^[a-zA-Z0-9]$/.test(e)||" "===e?{value:e,isAlphanumeric:!0}:{value:e,isAlphanumeric:!1})).reduce(((e,t)=>{if(t.isAlphanumeric){const r=e[e.length-1];if(r&&r.isAlphanumeric)return r.value+=t.value,e}return[...e,t]}),[]).map((t=>t.isAlphanumeric?new n(e.mathvariant).apply(t.value):new a.MI({name:"mi",attributes:{},children:[],value:t.value}).convert())).join("")}};class n{constructor(e){this._mathvariant=e||"normal"}apply(e){return this._commands.reduce(((t,r,a)=>0===a?`${r}{${e}}`:`${r}{${t}}`),"")}get _commands(){switch(this._mathvariant){case"bold":return["\\textbf"];case"italic":return["\\textit"];case"bold-italic":return["\\textit","\\textbf"];case"double-struck":return["\\mathbb"];case"monospace":return["\\mathtt"];case"bold-fraktur":case"fraktur":return["\\mathfrak"];default:return["\\text"]}}}},1586:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTr=void 0;const a=r(4279);t.MTr=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" & ")}}},1222:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MUnderover=void 0;const a=r(4279),n=r(8917);t.MUnderover=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);return`${(0,a.mathMLElementToLaTeXConverter)(t[0]).convert()}_{${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(t[2]).convert()}}`}}},9165:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=void 0,t.Void=class{constructor(e){this._mathmlElement=e}convert(){return""}}},5443:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return n(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLElementToLatexConverterAdapter=void 0;const i=o(r(6959)),s=r(2697);t.MathMLElementToLatexConverterAdapter=class{constructor(e){this._mathMLElement=null!=e?e:new s.VoidMathMLElement}toLatexConverter(){const{name:e}=this._mathMLElement;return new(l[e]||i.GenericSpacingWrapper)(this._mathMLElement)}};const l={math:i.Math,mi:i.MI,mo:i.MO,mn:i.MN,msqrt:i.MSqrt,mfenced:i.MFenced,mfrac:i.MFrac,mroot:i.MRoot,maction:i.MAction,menclose:i.MEnclose,merror:i.MError,mphantom:i.MPhantom,msup:i.MSup,msub:i.MSub,msubsup:i.MSubsup,mmultiscripts:i.MMultiscripts,mtext:i.MText,munderover:i.MUnderover,mtable:i.MTable,mtr:i.MTr,mover:i.GenericUnderOver,munder:i.GenericUnderOver,mrow:i.GenericSpacingWrapper,mpadded:i.GenericSpacingWrapper,void:i.Void}},5243:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorHandler=void 0,t.ErrorHandler=class{constructor(){this._errors=[],this.errorLocator={}}fixError(e,t){return this._isMissingAttributeValueError(t)?(this._errors.push(t),this._fixMissingAttribute(t,e)):e}isThereAnyErrors(){return this._errors.length>0}cleanErrors(){this._errors=[]}_fixMissingAttribute(e,t){const r=e.split('"')[1];if(r)return t.replace(this._matchMissingValueForAttribute(r),"");for(;this._mathGenericMissingValue().exec(t);)t=t.replace(this._mathGenericMissingValue(),"$1$3");return t}_matchMissingValueForAttribute(e){return new RegExp(`(${e}=(?!("|')))|(${e}(?!("|')))`,"gm")}_mathGenericMissingValue(){return/(\<.* )(\w+=(?!\"|\'))(.*\>)/gm}_isMissingAttributeValueError(e){return!!e.includes("attribute")&&!!e.includes("missed")||e.includes("attribute value missed")}}},9208:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(9548),t),n(r(5243),t),n(r(1101),t)},1101:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ElementsToMathMLAdapter=void 0,t.ElementsToMathMLAdapter=class{convert(e){return e.filter((e=>void 0!==e.tagName)).map((e=>this._convertElement(e)))}_convertElement(e){return{name:e.tagName,attributes:this._convertElementAttributes(e.attributes),value:this._hasElementChild(e)?"":e.textContent||"",children:this._hasElementChild(e)?this.convert(Array.from(e.childNodes)):[]}}_convertElementAttributes(e){return Array.from(e).reduce(((e,t)=>Object.assign({[t.nodeName]:t.nodeValue===t.nodeName?"":t.nodeValue},e)),{})}_hasElementChild(e){const t=e.childNodes;return!!t&&0!==t.length&&this._isThereAnyNoTextNode(t)}_isThereAnyNoTextNode(e){return Array.from(e).some((e=>"#text"!==e.nodeName))}}},9548:function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.XmlToMathMLAdapter=void 0;const n=a(r(8978));t.XmlToMathMLAdapter=class{constructor(e,t){this._xml="",this._elementsConvertor=e,this._errorHandler=t,this._xmlDOM=new n.default.DOMParser({locator:this._errorHandler.errorLocator,errorHandler:this._fixError.bind(this)})}convert(e){return this._xml=this._removeLineBreaks(e),this._xml=this._removeMsWordPrefixes(this._xml),this._elementsConvertor.convert(this._mathMLElements)}_fixError(e){this._xml=this._errorHandler.fixError(this._xml,e)}_removeLineBreaks(e){return e.replace(/\n|\r\n|\r/g,"")}_removeMsWordPrefixes(e){return e.replace(/mml:/g,"")}get _mathMLElements(){let e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math");return this._errorHandler.isThereAnyErrors()&&(this._errorHandler.cleanErrors(),e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math")),Array.from(e)}}},7941:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(8585),t)},8585:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeToMathElementsConverter=void 0;const a=r(9208);t.makeToMathElementsConverter=()=>{const e=new a.ElementsToMathMLAdapter,t=new a.ErrorHandler;return new a.XmlToMathMLAdapter(e,t)}},8672:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(3798),t)},3798:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLToLaTeX=void 0;const a=r(5443),n=r(7941);t.MathMLToLaTeX=class{static convert(e){return(0,n.makeToMathElementsConverter)().convert(e).map((e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter())).map((e=>e.convert())).join("").trim()}}},2965:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByChar=void 0,t.allMathOperatorsByChar={_:"\\underline","&#x23E1;":"\\underbrace","&#x23E0;":"\\overbrace","&#x23DF;":"\\underbrace","&#x23DE;":"\\overbrace","&#x23DD;":"\\underbrace","&#x23DC;":"\\overbrace","&#x23B5;":"\\underbrace","&#x23B4;":"\\overbrace","&#x20DC;":"\\square","&#x20DB;":"\\square","&#x2064;":"","&#x2057;":"''''","&#x203E;":"\\bar","&#x2037;":"```","&#x2036;":"``","&#x2035;":"`","&#x2034;":"'''","&#x2033;":"''","&#x201F;":"``","&#x201E;":",,","&#x201B;":"`","&#x201A;":",","&#x302;":"\\hat","&#x2F7;":"\\sim","&#x2DD;":"\\sim","&#x2DC;":"\\sim","&#x2DA;":"\\circ","&#x2D9;":"\\cdot","&#x2D8;":"","&#x2CD;":"\\_","&#x2CB;":"Ë‹","&#x2CA;":"ËŠ","&#x2C9;":"Ë‰","&#x2C7;":"","&#x2C6;":"\\hat","&#xBA;":"o","&#xB9;":"1","&#xB8;":"Â¸","&#xB4;":"Â´","&#xB3;":"3","&#xB2;":"2","&#xB0;":"\\circ","&#xAF;":"\\bar","&#xAA;":"a","&#xA8;":"\\cdot\\cdot","~":"\\sim","`":"`","^":"\\hat","--":"--","++":"++","&amp;":"\\&","&#x2061;":"","&#x221C;":"\\sqrt[4]{}","&#x221B;":"\\sqrt[3]{}","&#x221A;":"\\sqrt{}","&#x2146;":"d","&#x2145;":"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","&#x266F;":"\\#","&#x266E;":"","&#x266D;":"","&#x2032;":"'","&lt;>":"<>","**":"\\star\\star","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x2299;":"\\bigodot","&#xAC;":"\\neg","&#x2222;":"\\measuredangle","&#x2221;":"\\measuredangle","&#x2220;":"\\angle","&#xF7;":"\\div","/":"/","&#x2216;":"\\backslash","\\":"\\backslash","%":"\\%","&#x2297;":"\\bigotimes","&#xB7;":"\\cdot","&#x2A3F;":"\\coprod","&#x2A2F;":"\\times","&#x22C5;":"\\cdot","&#x22A1;":"\\boxdot","&#x22A0;":"\\boxtimes","&#x2062;":"","&#x2043;":"-","&#x2022;":"\\cdot","&#xD7;":"\\times",".":".","*":"\\star","&#x222A;":"\\cup","&#x2229;":"\\cap","&#x2210;":"\\coprod","&#x220F;":"\\prod","&#x2240;":"","&#x2AFF;":"","&#x2AFC;":"\\mid\\mid\\mid","&#x2A09;":"\\times","&#x2A08;":"","&#x2A07;":"","&#x2A06;":"\\sqcup","&#x2A05;":"\\sqcap","&#x2A02;":"\\otimes","&#x2A00;":"\\odot","&#x22C2;":"\\cap","&#x22C1;":"\\vee","&#x22C0;":"\\wedge","&#x2A04;":"\\uplus","&#x2A03;":"\\cup","&#x22C3;":"\\cup","&#x2A1C;":"\\underline{\\int}","&#x2A1B;":"\\overline{\\int}","&#x2A1A;":"\\int","&#x2A19;":"\\int","&#x2A18;":"\\int","&#x2A17;":"\\int","&#x2A16;":"\\oint","&#x2A15;":"\\oint","&#x2A14;":"\\int","&#x2A13;":"\\int","&#x2A12;":"\\int","&#x2A11;":"\\int","&#x2A10;":"\\int","&#x2A0F;":"\\bcancel{\\int}","&#x2A0E;":"","&#x2A0D;":"\\hcancel{\\int}","&#x2A0C;":"\\iiiint","&#x2233;":"\\oint","&#x2232;":"\\oint","&#x2231;":"\\int","&#x2230;":"\\oiint","&#x222F;":"\\oiint","&#x222E;":"\\oint","&#x222B;":"\\int","&#x2A01;":"\\oplus","&#x2298;":"\\oslash","&#x2296;":"\\ominus","&#x2295;":"\\oplus","&#x222D;":"\\iiint","&#x222C;":"\\iint","&#x2A0B;":"","&#x2A0A;":"","&#x2211;":"\\sum","&#x229F;":"\\boxminus","&#x229E;":"\\boxplus","&#x2214;":"\\dot{+}","&#x2213;":"+-","&#x2212;":"-","&#xB1;":"\\pm","-":"-","+":"+","&#x2B46;":"\\Rrightarrow","&#x2B45;":"\\Lleftarrow","&#x29F4;":":\\rightarrow","&#x29EF;":"","&#x29DF;":"\\bullet-\\bullet","&#x299F;":"\\angle","&#x299E;":"\\measuredangle","&#x299D;":"\\measuredangle","&#x299C;":"\\perp","&#x299B;":"\\measuredangle","&#x299A;":"","&#x2999;":"\\vdots","&#x297F;":"","&#x297E;":"","&#x297D;":"\\prec","&#x297C;":"\\succ","&#x297B;":"\\underset{\\rightarrow}{\\supset}","&#x297A;":"","&#x2979;":"\\underset{\\rightarrow}{\\subset}","&#x2978;":"\\underset{\\rightarrow}{>}","&#x2977;":"","&#x2976;":"\\underset{\\leftarrow}{<}","&#x2975;":"\\underset{\\approx}{\\rightarrow}","&#x2974;":"\\underset{\\sim}{\\rightarrow}","&#x2973;":"\\underset{\\sim}{\\leftarrow}","&#x2972;":"\\overset{\\sim}{\\rightarrow}","&#x2971;":"\\overset{=}{\\rightarrow}","&#x2970;":"","&#x296F;":"","&#x296E;":"","&#x296D;":"\\overline{\\rightharpoondown}","&#x296C;":"\\underline{\\rightharpoonup}","&#x296B;":"\\overline{\\leftharpoondown}","&#x296A;":"\\underline{\\leftharpoonup}","&#x2969;":"\\rightleftharpoons","&#x2968;":"\\rightleftharpoons","&#x2967;":"\\rightleftharpoons","&#x2966;":"\\rightleftharpoons","&#x2965;":"\\Downarrow","&#x2964;":"\\Rightarrow","&#x2963;":"\\Uparrow","&#x2962;":"\\Leftarrow","&#x2961;":"\\downarrow","&#x2960;":"\\uparrow","&#x295F;":"\\rightarrow","&#x295E;":"\\leftarrow","&#x295D;":"\\downarrow","&#x295C;":"\\uparrow","&#x295B;":"\\rightarrow","&#x295A;":"\\leftarrow","&#x2959;":"\\downarrow","&#x2958;":"\\uparrow","&#x2957;":"\\rightarrow","&#x2956;":"\\leftarrow","&#x2955;":"\\downarrow","&#x2954;":"\\uparrow","&#x2953;":"\\rightarrow","&#x2952;":"\\leftarrow","&#x2951;":"\\updownarrow","&#x2950;":"\\leftrightarrow","&#x294F;":"\\updownarrow","&#x294E;":"\\leftrightarrow","&#x294D;":"\\updownarrow","&#x294C;":"\\updownarrow","&#x294B;":"\\leftrightarrow","&#x294A;":"\\leftrightarrow","&#x2949;":"","&#x2948;":"\\leftrightarrow","&#x2947;":"\\nrightarrow","&#x2946;":"","&#x2945;":"","&#x2944;":"\\rightleftarrows","&#x2943;":"\\leftrightarrows","&#x2942;":"\\rightleftarrows","&#x2941;":"\\circlearrowright","&#x2940;":"\\circlearrowleft","&#x293F;":"\\rightarrow","&#x293E;":"\\leftarrow","&#x293D;":"","&#x293C;":"","&#x293B;":"","&#x293A;":"","&#x2939;":"","&#x2938;":"","&#x2937;":"\\Rsh","&#x2936;":"\\Lsh","&#x2935;":"\\downarrow","&#x2934;":"\\uparrow","&#x2933;":"\\leadsto","&#x2932;":"","&#x2931;":"","&#x2930;":"","&#x292F;":"","&#x292E;":"","&#x292D;":"","&#x292C;":"\\times","&#x292B;":"\\times","&#x292A;":"","&#x2929;":"","&#x2928;":"","&#x2927;":"","&#x2926;":"","&#x2925;":"","&#x2924;":"","&#x2923;":"","&#x2922;":"","&#x2921;":"","&#x2920;":"\\mapsto\\cdot","&#x291F;":"\\cdot\\leftarrow","&#x291E;":"\\rightarrow\\cdot","&#x291D;":"\\leftarrow","&#x291C;":"\\rightarrow","&#x291B;":"\\leftarrow","&#x291A;":"\\rightarrow","&#x2919;":"\\leftarrow","&#x2918;":"\\rightarrow","&#x2917;":"\\rightarrow","&#x2916;":"\\rightarrow","&#x2915;":"\\rightarrow","&#x2914;":"\\rightarrow","&#x2913;":"\\downarrow","&#x2912;":"\\uparrow","&#x2911;":"\\rightarrow","&#x2910;":"\\rightarrow","&#x290F;":"\\rightarrow","&#x290E;":"\\leftarrow","&#x290D;":"\\rightarrow","&#x290C;":"\\leftarrow","&#x290B;":"\\Downarrow","&#x290A;":"\\Uparrow","&#x2909;":"\\uparrow","&#x2908;":"\\downarrow","&#x2907;":"\\Rightarrow","&#x2906;":"\\Leftarrow","&#x2905;":"\\mapsto","&#x2904;":"\\nLeftrightarrow","&#x2903;":"\\nRightarrow","&#x2902;":"\\nLeftarrow","&#x2901;":"\\rightsquigarrow","&#x2900;":"\\rightsquigarrow","&#x27FF;":"\\rightsquigarrow","&#x27FE;":"\\Rightarrow","&#x27FD;":"\\Leftarrow","&#x27FC;":"\\mapsto","&#x27FB;":"\\leftarrow","&#x27FA;":"\\Longleftrightarrow","&#x27F9;":"\\Longrightarrow","&#x27F8;":"\\Longleftarrow","&#x27F7;":"\\leftrightarrow","&#x27F6;":"\\rightarrow","&#x27F5;":"\\leftarrow","&#x27F1;":"\\Downarrow","&#x27F0;":"\\Uparrow","&#x22B8;":"\\rightarrow","&#x21FF;":"\\leftrightarrow","&#x21FE;":"\\rightarrow","&#x21FD;":"\\leftarrow","&#x21FC;":"\\nleftrightarrow","&#x21FB;":"\\nrightarrow","&#x21FA;":"\\nleftarrow","&#x21F9;":"\\nleftrightarrow","&#x21F8;":"\\nrightarrow","&#x21F7;":"\\nleftarrow","&#x21F6;":"\\Rrightarrow","&#x21F5;":"","&#x21F4;":"\\rightarrow","&#x21F3;":"\\Updownarrow","&#x21F2;":"\\searrow","&#x21F1;":"\\nwarrow","&#x21F0;":"\\Leftarrow","&#x21EF;":"\\Uparrow","&#x21EE;":"\\Uparrow","&#x21ED;":"\\Uparrow","&#x21EC;":"\\Uparrow","&#x21EB;":"\\Uparrow","&#x21EA;":"\\Uparrow","&#x21E9;":"\\Downarrow","&#x21E8;":"\\Rightarrow","&#x21E7;":"\\Uparrow","&#x21E6;":"\\Leftarrow","&#x21E5;":"\\rightarrow","&#x21E4;":"\\leftarrow","&#x21E3;":"\\downarrow","&#x21E2;":"\\rightarrow","&#x21E1;":"\\uparrow","&#x21E0;":"\\leftarrow","&#x21DF;":"\\downarrow","&#x21DE;":"\\uparrow","&#x21DD;":"\\rightsquigarrow","&#x21DC;":"\\leftarrow","&#x21DB;":"\\Rrightarrow","&#x21DA;":"\\Lleftarrow","&#x21D9;":"\\swarrow","&#x21D8;":"\\searrow","&#x21D7;":"\\nearrow","&#x21D6;":"\\nwarrow","&#x21D5;":"\\Updownarrow","&#x21D4;":"\\Leftrightarrow","&#x21D3;":"\\Downarrow","&#x21D2;":"\\Rightarrow","&#x21D1;":"\\Uparrow","&#x21D0;":"\\Leftarrow","&#x21CF;":"\\nRightarrow","&#x21CE;":"\\nLeftrightarrow","&#x21CD;":"\\nLeftarrow","&#x21CC;":"\\rightleftharpoons","&#x21CB;":"\\leftrightharpoons","&#x21CA;":"\\downdownarrows","&#x21C9;":"\\rightrightarrows","&#x21C8;":"\\upuparrows","&#x21C7;":"\\leftleftarrows","&#x21C6;":"\\leftrightarrows","&#x21C5;":"","&#x21C4;":"\\rightleftarrows","&#x21C3;":"\\downharpoonleft","&#x21C2;":"\\downharpoonright","&#x21C1;":"\\rightharpoondown","&#x21C0;":"\\rightharpoonup","&#x21BF;":"\\upharpoonleft","&#x21BE;":"\\upharpoonright","&#x21BD;":"\\leftharpoondown","&#x21BC;":"\\leftharpoonup","&#x21BB;":"\\circlearrowright","&#x21BA;":"\\circlearrowleft","&#x21B9;":"\\leftrightarrows","&#x21B8;":"\\overline{\\nwarrow}","&#x21B7;":"\\curvearrowright","&#x21B6;":"\\curvearrowleft","&#x21B5;":"\\swarrow","&#x21B4;":"\\searrow","&#x21B3;":"\\Rsh","&#x21B2;":"\\Lsh","&#x21B1;":"\\Rsh","&#x21B0;":"\\Lsh","&#x21AF;":"\\swarrow","&#x21AE;":"","&#x21AD;":"\\leftrightsquigarrow","&#x21AC;":"\\looparrowright","&#x21AB;":"\\looparrowleft","&#x21AA;":"\\hookrightarrow","&#x21A9;":"\\hookleftarrow","&#x21A8;":"\\underline{\\updownarrow}","&#x21A7;":"\\downarrow","&#x21A6;":"\\rightarrowtail","&#x21A5;":"\\uparrow","&#x21A4;":"\\leftarrowtail","&#x21A3;":"\\rightarrowtail","&#x21A2;":"\\leftarrowtail","&#x21A1;":"\\downarrow","&#x21A0;":"\\twoheadrightarrow","&#x219F;":"\\uparrow","&#x219E;":"\\twoheadleftarrow","&#x219D;":"\\nearrow","&#x219C;":"\\nwarrow","&#x219B;":"","&#x219A;":"","&#x2199;":"\\swarrow","&#x2198;":"\\searrow","&#x2197;":"\\nearrow","&#x2196;":"\\nwarrow","&#x2195;":"\\updownarrow","&#x2194;":"\\leftrightarrow","&#x2193;":"\\downarrow","&#x2192;":"\\rightarrow","&#x2191;":"\\uparrow","&#x2190;":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\left|\\right.","&#x2AFE;":"","&#x2AFD;":"//","&#x2AFB;":"///","&#x2AFA;":"","&#x2AF9;":"","&#x2AF8;":"","&#x2AF7;":"","&#x2AF6;":"\\vdots","&#x2AF5;":"","&#x2AF4;":"","&#x2AF3;":"","&#x2AF2;":"\\nparallel","&#x2AF1;":"","&#x2AF0;":"","&#x2AEF;":"","&#x2AEE;":"\\bcancel{\\mid}","&#x2AED;":"","&#x2AEC;":"","&#x2AEB;":"","&#x2AEA;":"","&#x2AE9;":"","&#x2AE8;":"\\underline{\\perp}","&#x2AE7;":"\\overline{\\top}","&#x2AE6;":"","&#x2AE5;":"","&#x2AE4;":"","&#x2AE3;":"","&#x2AE2;":"","&#x2AE1;":"","&#x2AE0;":"\\perp","&#x2ADF;":"\\top","&#x2ADE;":"\\dashv","&#x2ADD;&#x338;":"","&#x2ADD;":"","&#x2ADB;":"\\pitchfork","&#x2ADA;":"","&#x2AD9;":"","&#x2AD8;":"","&#x2AD7;":"","&#x2AD6;":"","&#x2AD5;":"","&#x2AD4;":"","&#x2AD3;":"","&#x2AD2;":"","&#x2AD1;":"","&#x2AD0;":"","&#x2ACF;":"","&#x2ACE;":"","&#x2ACD;":"","&#x2ACC;":"\\underset{\\neq}{\\supset}","&#x2ACB;":"\\underset{\\neq}{\\subset}","&#x2ACA;":"\\underset{\\approx}{\\supset}","&#x2AC9;":"\\underset{\\approx}{\\subset}","&#x2AC8;":"\\underset{\\sim}{\\supset}","&#x2AC7;":"\\underset{\\sim}{\\subset}","&#x2AC6;":"\\supseteqq","&#x2AC5;":"\\subseteqq","&#x2AC4;":"\\dot{\\supseteq}","&#x2AC3;":"\\dot{\\subseteq}","&#x2AC2;":"\\underset{\\times}{\\supset}","&#x2AC1;":"\\underset{\\times}{\\subset}","&#x2AC0;":"\\underset{+}{\\supset}","&#x2ABF;":"\\underset{+}{\\subset}","&#x2ABE;":"","&#x2ABD;":"","&#x2ABC;":"\\gg ","&#x2ABB;":"\\ll","&#x2ABA;":"\\underset{\\cancel{\\approx}}{\\succ}","&#x2AB9;":"\\underset{\\cancel{\\approx}}{\\prec}","&#x2AB8;":"\\underset{\\approx}{\\succ}","&#x2AB7;":"\\underset{\\approx}{\\prec}","&#x2AB6;":"\\underset{\\cancel{=}}{\\succ}","&#x2AB5;":"\\underset{\\cancel{=}}{\\prec}","&#x2AB4;":"\\underset{=}{\\succ}","&#x2AB3;":"\\underset{=}{\\prec}","&#x2AB2;":"","&#x2AB1;":"","&#x2AAE;":"","&#x2AAD;":"\\underline{\\hcancel{>}}","&#x2AAC;":"\\underline{\\hcancel{>}}","&#x2AAB;":"\\hcancel{>}","&#x2AAA;":"\\hcancel{<}","&#x2AA9;":"","&#x2AA8;":"","&#x2AA7;":"\\vartriangleright","&#x2AA6;":"\\vartriangleleft","&#x2AA5;":"><","&#x2AA4;":"><","&#x2AA3;":"\\underline{\\ll}","&#x2AA2;&#x338;":"\\cancel{\\gg}","&#x2AA2;":"\\gg","&#x2AA1;&#x338;":"\\cancel{\\ll}","&#x2AA1;":"\\ll","&#x2AA0;":"\\overset{\\sim}{\\geqq}","&#x2A9F;":"\\overset{\\sim}{\\leqq}","&#x2A9E;":"\\overset{\\sim}{>}","&#x2A9D;":"\\overset{\\sim}{<}","&#x2A9C;":"","&#x2A9B;":"","&#x2A9A;":"\\overset{=}{>}","&#x2A99;":"\\overset{=}{<}","&#x2A98;":"","&#x2A97;":"","&#x2A96;":"","&#x2A95;":"","&#x2A94;":"","&#x2A93;":"","&#x2A92;":"\\underset{=}{\\gtrless}","&#x2A91;":"\\underset{=}{\\lessgtr}","&#x2A90;":"\\underset{<}{\\gtrsim}","&#x2A8F;":"\\underset{>}{\\lesssim}","&#x2A8E;":"\\underset{\\simeq}{>}","&#x2A8D;":"\\underset{\\simeq}{<}","&#x2A8C;":"\\gtreqqless","&#x2A8B;":"\\lesseqqgtr","&#x2A8A;":"\\underset{\\cancel{\\approx}}{>}","&#x2A89;":"\\underset{\\approx}{<}","&#x2A86;":"\\underset{\\approx}{>}","&#x2A85;":"\\underset{\\approx}{<}","&#x2A84;":"","&#x2A83;":"","&#x2A82;":"","&#x2A81;":"","&#x2A80;":"","&#x2A7F;":"","&#x2A7E;&#x338;":"\\bcancel{\\geq}","&#x2A7E;":"\\geq","&#x2A7D;&#x338;":"\\bcancel{\\leq}","&#x2A7D;":"\\leq","&#x2A7C;":"","&#x2A7B;":"","&#x2A7A;":"","&#x2A79;":"","&#x2A78;":"\\overset{\\dots}{\\equiv}","&#x2A77;":"","&#x2A76;":"===","&#x2A75;":"==","&#x2A74;":"::=","&#x2A73;":"","&#x2A72;":"\\underset{=}{+}","&#x2A71;":"\\overset{=}{+}","&#x2A70;":"\\overset{\\approx}{=}","&#x2A6F;":"\\overset{\\wedge}{=}","&#x2A6E;":"\\overset{*}{=}","&#x2A6D;":"\\dot{\\approx}","&#x2A6C;":"","&#x2A6B;":"","&#x2A6A;":"\\dot{\\sim}","&#x2A69;":"","&#x2A68;":"","&#x2A67;":"\\dot{\\equiv}","&#x2A66;":"\\underset{\\cdot}{=}","&#x2A65;":"","&#x2A64;":"","&#x2A63;":"\\underset{=}{\\vee}","&#x2A62;":"\\overset{=}{\\vee}","&#x2A61;":"ul(vv)","&#x2A60;":"\\underset{=}{\\wedge}","&#x2A5F;":"\\underline{\\wedge}","&#x2A5E;":"\\overset{=}{\\wedge}","&#x2A5D;":"\\hcancel{\\vee}","&#x2A5C;":"\\hcancel{\\wedge}","&#x2A5B;":"","&#x2A5A;":"","&#x2A59;":"","&#x2A58;":"\\vee","&#x2A57;":"\\wedge","&#x2A56;":"","&#x2A55;":"","&#x2A54;":"","&#x2A53;":"","&#x2A52;":"\\dot{\\vee}","&#x2A51;":"\\dot{\\wedge}","&#x2A50;":"","&#x2A4F;":"","&#x2A4E;":"","&#x2A4D;":"\\overline{\\cap}","&#x2A4C;":"\\overline{\\cup}","&#x2A4B;":"","&#x2A4A;":"","&#x2A49;":"","&#x2A48;":"","&#x2A47;":"","&#x2A46;":"","&#x2A45;":"","&#x2A44;":"","&#x2A43;":"\\overline{\\cap}","&#x2A42;":"\\overline{\\cup}","&#x2A41;":"","&#x2A40;":"","&#x2A3E;":"","&#x2A3D;":"\\llcorner","&#x2A3C;":"\\lrcorner","&#x2A3B;":"","&#x2A3A;":"","&#x2A39;":"","&#x2A38;":"","&#x2A37;":"","&#x2A36;":"\\hat{\\otimes}","&#x2A35;":"","&#x2A34;":"","&#x2A33;":"","&#x2A32;":"\\underline{\\times}","&#x2A31;":"\\underline{\\times}","&#x2A30;":"\\dot{\\times}","&#x2A2E;":"","&#x2A2D;":"","&#x2A2C;":"","&#x2A2B;":"","&#x2A2A;":"","&#x2A29;":"","&#x2A28;":"","&#x2A27;":"","&#x2A26;":"\\underset{\\sim}{+}","&#x2A25;":"\\underset{\\circ}{+}","&#x2A24;":"\\overset{\\sim}{+}","&#x2A23;":"\\hat{+}","&#x2A22;":"\\dot{+}","&#x2A21;":"\\upharpoonright","&#x2A20;":">>","&#x2A1F;":"","&#x2A1E;":"\\triangleleft","&#x2A1D;":"\\bowtie","&#x29FF;":"","&#x29FE;":"+","&#x29FB;":"\\hcancel{|||}","&#x29FA;":"\\hcancel{||}","&#x29F9;":"\\backslash","&#x29F8;":"/","&#x29F7;":"hcancel{\backslash}","&#x29F6;":"","&#x29F5;":"\\backslash","&#x29F2;":"\\Phi","&#x29F1;":"","&#x29F0;":"","&#x29EE;":"","&#x29ED;":"","&#x29EC;":"","&#x29EB;":"\\lozenge","&#x29EA;":"","&#x29E9;":"","&#x29E8;":"","&#x29E7;":"\\ddagger","&#x29E2;":"\\sqcup\\sqcup","&#x29E1;":"","&#x29E0;":"\\square","&#x29DE;":"","&#x29DD;":"","&#x29DC;":"","&#x29DB;":"\\{\\{","&#x29D9;":"\\{","&#x29D8;":"\\}","&#x29D7;":"","&#x29D6;":"","&#x29D5;":"\\bowtie","&#x29D4;":"\\bowtie","&#x29D3;":"\\bowtie","&#x29D2;":"\\bowtie","&#x29D1;":"\\bowtie","&#x29D0;&#x338;":"| \\not\\triangleright","&#x29D0;":"| \\triangleright","&#x29CF;&#x338;":"\\not\\triangleleft |","&#x29CF;":"\\triangleleft |","&#x29CE;":"","&#x29CD;":"\\triangle","&#x29CC;":"","&#x29CB;":"\\underline{\\triangle}","&#x29CA;":"\\dot{\\triangle}","&#x29C9;":"","&#x29C8;":"\\boxed{\\circ}","&#x29C7;":"\\boxed{\\circ}","&#x29C6;":"\\boxed{\\rightarrow}","&#x29C5;":"\\bcancel{\\square}","&#x29C4;":"\\cancel{\\square}","&#x29C3;":"\\odot","&#x29C2;":"\\odot","&#x29BF;":"\\odot","&#x29BE;":"\\odot","&#x29BD;":"\\varnothing","&#x29BC;":"\\oplus","&#x29BB;":"\\otimes","&#x29BA;":"","&#x29B9;":"\\varnothing","&#x29B8;":"\\varnothing","&#x29B7;":"\\ominus","&#x29B6;":"\\ominus","&#x29B5;":"\\ominus","&#x29B4;":"\\vec{\\varnothing}","&#x29B3;":"\\vec{\\varnothing}","&#x29B2;":"\\dot{\\varnothing}","&#x29B1;":"\\overline{\\varnothing}","&#x29B0;":"\\varnothing","&#x29AF;":"","&#x29AE;":"","&#x29AD;":"","&#x29AC;":"","&#x29AB;":"","&#x29AA;":"","&#x29A9;":"","&#x29A8;":"","&#x29A7;":"","&#x29A6;":"","&#x29A5;":"","&#x29A4;":"","&#x29A3;":"","&#x29A2;":"","&#x29A1;":"\\not\\lor","&#x29A0;":"\\bcancel{>}","&#x2982;":":","&#x2981;":"\\circ","&#x2758;":"|","&#x25B2;":"\\bigtriangleup","&#x22FF;":"\\Epsilon","&#x22FE;":"\\overline{\\ni}","&#x22FD;":"\\overline{\\ni}","&#x22FC;":"\\in","&#x22FB;":"\\in","&#x22FA;":"\\in","&#x22F9;":"\\underline{\\in}","&#x22F8;":"\\underline{\\in}","&#x22F7;":"\\overline{\\in}","&#x22F6;":"\\overline{\\in}","&#x22F5;":"\\dot{\\in}","&#x22F4;":"\\in","&#x22F3;":"\\in","&#x22F2;":"\\in","&#x22F0;":"\\ddots","&#x22E9;":"\\underset{\\sim}{\\succ}","&#x22E8;":"\\underset{\\sim}{\\prec}","&#x22E7;":"\\underset{\\not\\sim}{>}","&#x22E6;":"\\underset{\\not\\sim}{<}","&#x22E5;":"\\not\\sqsupseteq","&#x22E4;":"\\not\\sqsubseteq","&#x22E3;":"\\not\\sqsupseteq","&#x22E2;":"\\not\\sqsubseteq","&#x22E1;":"\\nsucc","&#x22E0;":"\\nprec","&#x22DF;":"\\succ","&#x22DE;":"\\prec","&#x22DD;":"\\overline{>}","&#x22DC;":"\\overline{<}","&#x22DB;":"\\underset{>}{\\leq}","&#x22DA;":"\\underset{<}{\\geq}","&#x22D5;":"\\#","&#x22D3;":"\\cup","&#x22D2;":"\\cap","&#x22D1;":"\\supset","&#x22D0;":"\\subset","&#x22CF;":"\\wedge","&#x22CE;":"\\vee","&#x22CD;":"\\simeq","&#x22C8;":"\\bowtie","&#x22C7;":"\\ast","&#x22C6;":"\\star","&#x22C4;":"\\diamond","&#x22BF;":"\\triangle","&#x22BE;":"\\measuredangle","&#x22BD;":"\\overline{\\lor}","&#x22BC;":"\\overline{\\land}","&#x22BB;":"\\underline{\\lor}","&#x22BA;":"\\top","&#x22B9;":"","&#x22B7;":"\\circ\\multimap","&#x22B6;":"\\circ\\multimap","&#x22B3;":"\\triangleright","&#x22B2;":"\\triangleleft","&#x22B1;":"\\succ","&#x22B0;":"\\prec","&#x22AB;":"|\\models","&#x22AA;":"|\\models","&#x22A7;":"\\models","&#x22A6;":"\\vdash","&#x229D;":"\\ominus","&#x229C;":"\\ominus","&#x229B;":"\\odot","&#x229A;":"\\odot","&#x2294;":"\\sqcup","&#x2293;":"\\sqcap","&#x2292;":"\\sqsupseteq","&#x2291;":"\\sqsubseteq","&#x2290;&#x338;":"\\not\\sqsupset","&#x2290;":"\\sqsupset","&#x228F;&#x338;":"\\not\\sqsubset","&#x228F;":"\\sqsubset","&#x228E;":"\\cup","&#x228D;":"\\cup","&#x228C;":"\\cup","&#x227F;&#x338;":"\\not\\succsim","&#x227F;":"\\succsim","&#x227E;":"\\precsim","&#x2279;":"\\not\\overset{>}{<}","&#x2278;":"\\not\\overset{>}{<}","&#x2277;":"\\overset{>}{<}","&#x2276;":"\\overset{<}{>}","&#x2275;":"\\not\\geg","&#x2274;":"\\not\\leq","&#x2273;":"\\geg","&#x2272;":"\\leq","&#x226C;":"","&#x2267;":"\\geg","&#x2266;&#x338;":"\\not\\leq","&#x2266;":"\\leq","&#x2263;":"\\overset{=}{=} ","&#x225E;":"\\overset{m}{=} ","&#x225D;":"\\overset{def}{=}","&#x2258;":"=","&#x2256;":"=","&#x2255;":"=:","&#x2253;":"\\doteq","&#x2252;":"\\doteq","&#x2251;":"\\doteq","&#x2250;":"\\doteq","&#x224F;&#x338;":"","&#x224F;":"","&#x224E;&#x338;":"","&#x224E;":"","&#x224C;":"\\approx","&#x224B;":"\\approx","&#x224A;":"\\approx","&#x2242;&#x338;":"\\neq","&#x2242;":"=","&#x223F;":"\\sim","&#x223E;":"\\infty","&#x223D;&#x331;":"\\sim","&#x223D;":"\\sim","&#x223B;":"\\sim","&#x223A;":":-:","&#x2239;":"-:","&#x2238;":"\\bot","&#x2237;":"::","&#x2236;":":","&#x2223;":"|","&#x221F;":"\\llcorner","&#x2219;":"\\cdot","&#x2218;":"\\circ","&#x2217;":"*","&#x2215;":"/","&#x220E;":"\\square","&#x220D;":"\\ni","&#x220A;":"\\in","&#x2206;":"\\Delta","&#x2044;":"/","&#x2AB0;&#x338;":"\\nsucceq","&#x2AB0;":"\\succeq","&#x2AAF;&#x338;":"\\npreceq","&#x2AAF;":"\\preceq","&#x2A88;":"\\ngeqslant","&#x2A87;":"\\nleqslant","&#x29F3;":"\\Phi","&#x29E6;":"\\models","&#x29E5;":"\\not\\equiv","&#x29E4;":"\\approx\\neq","&#x29E3;":"\\neq","&#x29C1;":"\\circle","&#x29C0;":"\\circle","&#x25E6;":"\\circle","&#x25D7;":"\\circle","&#x25D6;":"\\circle","&#x25CF;":"\\circle","&#x25CE;":"\\circledcirc","&#x25CD;":"\\circledcirc","&#x25CC;":"\\circledcirc","&#x25C9;":"\\circledcirc","&#x25C8;":"\\diamond","&#x25C7;":"\\diamond","&#x25C6;":"\\diamond","&#x25C5;":"\\triangleleft","&#x25C4;":"\\triangleleft","&#x25C3;":"\\triangleleft","&#x25C2;":"\\triangleleft","&#x25C1;":"\\triangleleft","&#x25C0;":"\\triangleleft","&#x25BF;":"\\triangledown","&#x25BE;":"\\triangledown","&#x25BD;":"\\triangledown","&#x25BC;":"\\triangledown","&#x25B9;":"\\triangleright","&#x25B8;":"\\triangleright","&#x25B7;":"\\triangleright","&#x25B6;":"\\triangleright","&#x25B5;":"\\triangle","&#x25B4;":"\\triangle","&#x25B3;":"\\triangle","&#x25B1;":"\\square","&#x25B0;":"\\square","&#x25AF;":"\\square","&#x25AE;":"\\square","&#x25AD;":"\\square","&#x25AB;":"\\square","&#x25AA;":"\\square","&#x25A1;":"\\square","&#x25A0;":"\\square","&#x22ED;":"\\not\\triangleright","&#x22EC;":"\\not\\triangleleft","&#x22EB;":"\\not\\triangleright","&#x22EA;":"\\not\\triangleleft","&#x22D9;":"\\ggg","&#x22D8;":"\\lll","&#x22D7;":"*>","&#x22D6;":"<*","&#x22D4;":"\\pitchfork","&#x22CC;":"","&#x22CB;":"","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#x22B5;":"\\triangleright","&#x22B4;":"","&#x22A5;":"\\bot","&#x2281;":"\\nsucc","&#x2280;":"\\preceq","&#x227D;":"\\succeq","&#x227C;":"\\preceq","&#x227B;":"\\succ","&#x227A;":"\\prec","&#x2271;":"\\geq/","&#x2270;":"\\leq/","&#x226D;":"\\neq","&#x226B;&#x338;":"\\not\\gg","&#x226B;":"\\gg","&#x226A;&#x338;":"\\not\\ll","&#x226A;":"\\ll","&#x2269;":"\\ngeqslant","&#x2268;":"\\nleqslant","&#x2261;":"\\equiv","&#x225F;":"\\doteq","&#x225C;":"\\triangleq","&#x225B;":"\\doteq","&#x225A;":"\\triangleq","&#x2259;":"\\triangleq","&#x2257;":"\\doteq","&#x2254;":":=","&#x224D;":"\\asymp","&#x2247;":"\\ncong","&#x2246;":"\\ncong","&#x2245;":"\\cong","&#x2244;":"\\not\\simeq","&#x2243;":"\\simeq","&#x2241;":"\\not\\sim","&#x2226;":"\\not\\parallel","&#x2225;":"\\parallel","&#x2224;":"\\not|","&#x221D;":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","&#x2260;":"\\neq","&#x2262;":"\\equiv /","&#x2249;":"\\approx /","&#x223C;":"sim","&#x2248;":"\\approx","&#x226E;":"</","&lt;":"<","&#x226F;":">/",">=":">=",">":">","&#x2265;":"\\geq","&#x2264;":"\\leq","&lt;=":"<=","&#x228B;":"\\supsetneq","&#x228A;":"\\subsetneq","&#x2289;":"\\nsupseteq","&#x2288;":"\\nsubseteq","&#x2287;":"\\supseteq","&#x2286;":"\\subseteq","&#x2285;":"\\not\\supset","&#x2284;":"\\not\\subset","&#x2283;&#x20D2;":"\\supset |","&#x2283;":"\\supset","&#x2282;&#x20D2;":"\\subset |","&#x2282;":"\\subset","&#x220C;":"\\not\\in","&#x2209;":"\\notin","&#x2208;":"\\in","&#x2201;":"C","&#x2204;":"\\nexists","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x2227;":"\\land","&amp;&amp;":"\\&\\&","&#x2228;":"\\lor","&#x22AF;":"\\cancel{\\vDash}","&#x22AE;":"\\cancel{\\Vdash}","&#x22AD;":"\\nvDash","&#x22AC;":"\\nvDash","&#x22A9;":"\\Vdash","&#x22A8;":"\\vDash","&#x22A4;":"\\top","&#x22A3;":"\\dashv","&#x22A2;":"\\vdash","&#x220B;":"\\ni","&#x22F1;":"\\ddots","&#x22EF;":"\\hdots","&#x22EE;":"\\vdots","&#x2026;":"\\hdots","&#x3F6;":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","&#x2235;":"\\because","&#x2234;":"\\therefore ","&#x2063;":"",",":",",";":";","&#x29FD;":"\\}","&#x29FC;":"\\{","&#x2998;":"\\]","&#x2997;":"\\[","&#x2996;":"\\ll","&#x2995;":"\\gg","&#x2994;":"\\gg","&#x2993;":"\\ll","&#x2992;":"\\gg","&#x2991;":"\\ll","&#x2990;":"\\]","&#x298F;":"\\]","&#x298E;":"\\]","&#x298D;":"\\[","&#x298C;":"\\[","&#x298B;":"\\]","&#x298A;":"\\triangleright","&#x2989;":"\\triangleleft","&#x2988;":"|\\)","&#x2987;":"\\(|","&#x2986;":"|\\)","&#x2985;":"\\(\\(","&#x2984;":"|\\}","&#x2983;":"\\{|","&#x2980;":"\\||","&#x27EF;":"\\left. \\right]","&#x27EE;":"\\left[ \\right.","&#x27ED;":"\\left. \\right]]","&#x27EC;":"\\left[[ \\right.","&#x27EB;":"\\gg","&#x27EA;":"\\ll","&#x27E9;":"\\rangle","&#x27E8;":"\\langle","&#x27E7;":"\\left. \\right]]","&#x27E6;":"\\left[[ \\right.","&#x2773;":"\\left.\\right)","&#x2772;":"\\left(\\right.","&#x232A;":"\\rangle","&#x2329;":"\\langle","&#x230B;":"\\rfloor","&#x230A;":"\\lfloor","&#x2309;":"\\rceil","&#x2308;":"\\lceil","&#x2016;":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","&#x201D;":'"',"&#x201C;":"``","&#x2019;":"'","&#x2018;":"`","%CE%B1":"\\alpha","%CE%B2":"\\beta","%CE%B3":"\\gamma","%CE%93":"\\Gamma","%CE%B4":"\\delta","%CE%94":"\\Delta","%CF%B5":"\\epsilon","%CE%B6":"\\zeta","%CE%B7":"\\eta","%CE%B8":"\\theta","%CE%98":"\\Theta","%CE%B9":"\\iota","%CE%BA":"\\kappa","%CE%BB":"\\lambda","%CE%BC":"\\mu","%CE%BD":"\\nu","%CE%BF":"\\omicron","%CF%80":"\\pi","%CE%A0":"\\Pi","%CF%81":"\\pho","%CF%83":"\\sigma","%CE%A3":"\\Sigma","%CF%84":"\\tau","%CF%85":"\\upsilon","%CE%A5":"\\Upsilon","%CF%95":"\\phi","%CE%A6":"\\Phi","%CF%87":"\\chi","%CF%88":"\\psi","%CE%A8":"\\Psi","%CF%89":"\\omega","%CE%A9":"\\Omega"}},9039:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByGlyph=void 0,t.allMathOperatorsByGlyph={_:"\\underline","â¡":"\\underbrace","â ":"\\overbrace","âŸ":"\\underbrace","â":"\\overbrace","â":"\\underbrace","âœ":"\\overbrace","âµ":"\\underbrace","â´":"\\overbrace","âƒœ":"\\square","âƒ›":"\\square","â¤":"","â—":"''''","â€¾":"\\overline","â€·":"```","â€¶":"``","â€µ":"`","â€´":"'''","â€³":"''","â€Ÿ":"``","â€":",,","â€›":"`","â€š":",","^":"\\hat","Ë·":"\\sim","Ë":"\\sim","Ëœ":"\\sim","Ëš":"\\circ","Ë™":"\\cdot","Ë˜":" ",Ë:"\\_",Ë‹:"Ë‹",ËŠ:"ËŠ",Ë‰:"Ë‰",Ë‡:"",Ë†:"\\hat",Âº:"o","Â¹":"1","Â¸":",","Â´":"Â´","Â³":"3","Â²":"2","Â°":"\\circ","Â¯":"\\bar",Âª:"a","â†›":"\\nrightarrow","Â¨":"\\cdot\\cdot","~":"\\sim","`":"`","--":"--","++":"++","&":"\\&","âˆœ":"\\sqrt[4]{}","âˆ›":"\\sqrt[3]{}","âˆš":"\\sqrt{}",â…†:"d",â……:"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","â™¯":"\\#","â™®":"","â™­":"","â€²":"'","<>":"<>","**":"\\star\\star","âˆ‡":"\\nabla","âˆ‚":"\\partial","âŠ™":"\\bigodot","Â¬":"\\neg","âˆ¢":"\\measuredangle","âˆ¡":"\\measuredangle","âˆ ":"\\angle","Ã·":"\\div","/":"/","âˆ–":"\\backslash","\\":"\\backslash","%":"\\%","âŠ—":"\\bigotimes","Â·":"\\cdot","â¨¿":"\\coprod","â¨¯":"\\times","â‹…":"\\cdot","âŠ¡":"\\boxdot","âŠ ":"\\boxtimes","â¢":"","âƒ":"-","â€¢":"\\cdot",".":".","*":"\\star","âˆª":"\\cup","âˆ©":"\\cap","âˆ":"\\coprod","âˆ":"\\prod","â‰€":"","â«¿":"","â«¼":"\\mid\\mid\\mid","â¨‰":"\\times","â¨ˆ":"","â¨‡":"","â¨†":"\\sqcup","â¨…":"\\sqcap","â¨‚":"\\otimes","â¨€":"\\odot","â‹‚":"\\cap","â‹":"\\vee","â‹€":"\\wedge","â¨„":"\\uplus","â¨ƒ":"\\cup","â‹ƒ":"\\cup","â¨œ":"\\underline{\\int}","â¨›":"\\overline{\\int}","â¨š":"\\int","â¨™":"\\int","â¨˜":"\\int","â¨—":"\\int","â¨–":"\\oint","â¨•":"\\oint","â¨”":"\\int","â¨“":"\\int","â¨’":"\\int","â¨‘":"\\int","â¨":"\\int","â¨":"\\bcancel{\\int}","â¨":"","â¨":"\\hcancel{\\int}","â¨Œ":"\\iiiint","âˆ³":"\\oint","âˆ²":"\\oint","âˆ±":"\\int","âˆ°":"\\oiint","âˆ¯":"\\oiint","âˆ®":"\\oint","âˆ«":"\\int","â¨":"\\oplus","âŠ˜":"\\oslash","âŠ–":"\\ominus","âŠ•":"\\oplus","âˆ­":"\\iiint","âˆ¬":"\\iint","â¨‹":"","â¨Š":"","âˆ‘":"\\sum","âŠŸ":"\\boxminus","âŠ":"\\boxplus","âˆ”":"\\dot{+}","âˆ“":"+-","âˆ’":"-","Â±":"\\pm","-":"-","+":"+","â­†":"\\Rrightarrow","â­…":"\\Lleftarrow","â§´":":\\rightarrow","â§¯":"","â§Ÿ":"\\bullet-\\bullet","â¦Ÿ":"\\angle","â¦":"\\measuredangle","â¦":"\\measuredangle","â¦œ":"\\perp","â¦›":"\\measuredangle","â¦š":"","â¦™":"\\vdots","â¥¿":"","â¥¾":"","â¥½":"\\prec","â¥¼":"\\succ","â¥»":"\\underset{\\rightarrow}{\\supset}","â¥º":"","â¥¹":"\\underset{\\rightarrow}{\\subset}","â¥¸":"\\underset{\\rightarrow}{>}","â¥·":"","â¥¶":"\\underset{\\leftarrow}{<}","â¥µ":"\\underset{\\approx}{\\rightarrow}","â¥´":"\\underset{\\sim}{\\rightarrow}","â¥³":"\\underset{\\sim}{\\leftarrow}","â¥²":"\\overset{\\sim}{\\rightarrow}","â¥±":"\\overset{=}{\\rightarrow}","â¥°":"","â¥¯":"","â¥®":"","â¥­":"\\overline{\\rightharpoondown}","â¥¬":"\\underline{\\rightharpoonup}","â¥«":"\\overline{\\leftharpoondown}","â¥ª":"\\underline{\\leftharpoonup}","â¥©":"\\rightleftharpoons","â¥¨":"\\rightleftharpoons","â¥§":"\\rightleftharpoons","â¥¦":"\\rightleftharpoons","â¥¥":"\\Downarrow","â¥¤":"\\Rightarrow","â¥£":"\\Uparrow","â¥¢":"\\Leftarrow","â¥¡":"\\downarrow","â¥ ":"\\uparrow","â¥Ÿ":"\\rightarrow","â¥":"\\leftarrow","â¥":"\\downarrow","â¥œ":"\\uparrow","â¥›":"\\rightarrow","â¥š":"\\leftarrow","â¥™":"\\downarrow","â¥˜":"\\uparrow","â¥—":"\\rightarrow","â¥–":"\\leftarrow","â¥•":"\\downarrow","â¥”":"\\uparrow","â¥“":"\\rightarrow","â¥’":"\\leftarrow","â¥‘":"\\updownarrow","â¥":"\\leftrightarrow","â¥":"\\updownarrow","â¥":"\\leftrightarrow","â¥":"\\updownarrow","â¥Œ":"\\updownarrow","â¥‹":"\\leftrightarrow","â¥Š":"\\leftrightarrow","â¥‰":"","â¥ˆ":"\\leftrightarrow","â¥‡":"\\nrightarrow","â¥†":"","â¥…":"","â¥„":"\\rightleftarrows","â¥ƒ":"\\leftrightarrows","â¥‚":"\\rightleftarrows","â¥":"\\circlearrowright","â¥€":"\\circlearrowleft","â¤¿":"\\rightarrow","â¤¾":"\\leftarrow","â¤½":"\\leftarrow","â¤¼":"\\rightarrow","â¤»":"\\rightarrow","â¤º":"\\leftarrow","â¤¹":"\\downarrow","â¤¸":"\\downarrow","â¤·":"\\Rsh","â¤¶":"\\Lsh","â¤µ":"\\downarrow","â¤´":"\\uparrow","â¤³":"\\rightarrow","â¤²":"\\leftarrow","â¤±":" ","â¤°":" ","â¤¯":" ","â¤®":" ","â¤­":" ","â¤¬":"\\times","â¤«":"\\times","â¤ª":" ","â¤©":" ","â¤¨":" ","â¤§":" ","â¤¦":" ","â¤¥":" ","â¤¤":" ","â¤£":" ","â¤¢":" ","â¤¡":" ","â¤ ":"\\mapsto\\cdot","â¤Ÿ":"\\cdot\\leftarrow","â¤":"\\rightarrow\\cdot","â¤":"\\leftarrow","â¤œ":"\\rightarrow","â¤›":"\\leftarrow","â¤š":"\\rightarrow","â¤™":"\\leftarrow","â¤˜":"\\rightarrow","â¤—":"\\rightarrow","â¤–":"\\rightarrow","â¤•":"\\rightarrow","â¤”":"\\rightarrow","â¤“":"\\downarrow","â¤’":"\\uparrow","â¤‘":"\\rightarrow","â¤":"\\rightarrow","â¤":"\\rightarrow","â¤":"\\leftarrow","â¤":"\\rightarrow","â¤Œ":"\\leftarrow","â¤‹":"\\Downarrow","â¤Š":"\\Uparrow","â¤‰":"\\uparrow","â¤ˆ":"\\downarrow","â¤‡":"\\Rightarrow","â¤†":"\\Leftarrow","â¤…":"\\mapsto","â¤„":"\\nLeftrightarrow","â¤ƒ":"\\nRightarrow","â¤‚":"\\nLeftarrow","â¤":"\\rightsquigarrow","â¤€":"\\rightsquigarrow","âŸ¿":"\\rightsquigarrow","âŸ¾":"\\Rightarrow","âŸ½":"\\Leftarrow","âŸ¼":"\\mapsto","âŸ»":"\\leftarrow","âŸº":"\\Longleftrightarrow","âŸ¹":"\\Longrightarrow","âŸ¸":"\\Longleftarrow","âŸ·":"\\leftrightarrow","âŸ¶":"\\rightarrow","âŸµ":"\\leftarrow","âŸ±":"\\Downarrow","âŸ°":"\\Uparrow","âŠ¸":"\\rightarrow","â‡¿":"\\leftrightarrow","â‡¾":"\\rightarrow","â‡½":"\\leftarrow","â‡¼":"\\nleftrightarrow","â‡»":"\\nrightarrow","â‡º":"\\nleftarrow","â‡¹":"\\nleftrightarrow","â‡¸":"\\nrightarrow","â‡·":"\\nleftarrow","â‡¶":"\\Rrightarrow","â‡µ":"","â‡´":"\\rightarrow","â‡³":"\\Updownarrow","â‡²":"\\searrow","â‡±":"\\nwarrow","â‡°":"\\Leftarrow","â‡¯":"\\Uparrow","â‡®":"\\Uparrow","â‡­":"\\Uparrow","â‡¬":"\\Uparrow","â‡«":"\\Uparrow","â‡ª":"\\Uparrow","â‡©":"\\Downarrow","â‡¨":"\\Rightarrow","â‡§":"\\Uparrow","â‡¦":"\\Leftarrow","â‡¥":"\\rightarrow","â‡¤":"\\leftarrow","â‡£":"\\downarrow","â‡¢":"\\rightarrow","â‡¡":"\\uparrow","â‡ ":"\\leftarrow","â‡Ÿ":"\\downarrow","â‡":"\\uparrow","â‡":"\\rightsquigarrow","â‡œ":"\\leftarrow","â‡›":"\\Rrightarrow","â‡š":"\\Lleftarrow","â‡™":"\\swarrow","â‡˜":"\\searrow","â‡—":"\\nearrow","â‡–":"\\nwarrow","â‡•":"\\Updownarrow","â‡”":"\\Leftrightarrow","â‡“":"\\Downarrow","â‡’":"\\Rightarrow","â‡‘":"\\Uparrow","â‡":"\\Leftarrow","â‡":"\\nRightarrow","â‡":"\\nLeftrightarrow","â‡":"\\nLeftarrow","â‡Œ":"\\rightleftharpoons","â‡‹":"\\leftrightharpoons","â‡Š":"\\downdownarrows","â‡‰":"\\rightrightarrows","â‡ˆ":"\\upuparrows","â‡‡":"\\leftleftarrows","â‡†":"\\leftrightarrows","â‡…":"","â‡„":"\\rightleftarrows","â‡ƒ":"\\downharpoonleft","â‡‚":"\\downharpoonright","â‡":"\\rightharpoondown","â‡€":"\\rightharpoonup","â†¿":"\\upharpoonleft","â†¾":"\\upharpoonright","â†½":"\\leftharpoondown","â†¼":"\\leftharpoonup","â†»":"\\circlearrowright","â†º":"\\circlearrowleft","â†¹":"\\leftrightarrows","â†¸":"\\overline{\\nwarrow}","â†·":"\\curvearrowright","â†¶":"\\curvearrowleft","â†µ":"\\swarrow","â†´":"\\searrow","â†³":"\\Rsh","â†²":"\\Lsh","â†±":"\\Rsh","â†°":"\\Lsh","â†¯":"\\swarrow","â†®":"","â†­":"\\leftrightsquigarrow","â†¬":"\\looparrowright","â†«":"\\looparrowleft","â†ª":"\\hookrightarrow","â†©":"\\hookleftarrow","â†¨":"\\underline{\\updownarrow}","â†§":"\\downarrow","â†¦":"\\rightarrowtail","â†¥":"\\uparrow","â†¤":"\\leftarrowtail","â†£":"\\rightarrowtail","â†¢":"\\leftarrowtail","â†¡":"\\downarrow","â† ":"\\twoheadrightarrow","â†Ÿ":"\\uparrow","â†":"\\twoheadleftarrow","â†":"\\nearrow","â†œ":"\\nwarrow","â†š":"","â†™":"\\swarrow","â†˜":"\\searrow","â†—":"\\nearrow","â†–":"\\nwarrow","â†•":"\\updownarrow","â†”":"\\leftrightarrow","â†“":"\\downarrow","â†’":"\\rightarrow","â†‘":"\\uparrow","â†":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\mid","â«¾":"","â«½":"//","â«»":"///","â«º":"","â«¹":"","â«¸":"","â«·":"","â«¶":"\\vdots","â«µ":"","â«´":"","â«³":"","â«²":"\\nparallel","â«±":"","â«°":"","â«¯":"","â«®":"\\bcancel{\\mid}","â«­":"","â«¬":"","â««":"","â«ª":"","â«©":"","â«¨":"\\underline{\\perp}","â«§":"\\overline{\\top}","â«¦":"","â«¥":"","â«¤":"","â«£":"","â«¢":"","â«¡":"","â« ":"\\perp","â«Ÿ":"\\top","â«":"\\dashv","â«Ì¸":"","â«":"","â«›":"\\pitchfork","â«š":"","â«™":"","â«˜":"","â«—":"","â«–":"","â«•":"","â«”":"","â«“":"","â«’":"","â«‘":"","â«":"","â«":"","â«":"","â«":"","â«Œ":"\\underset{\\neq}{\\supset}","â«‹":"\\underset{\\neq}{\\subset}","â«Š":"\\underset{\\approx}{\\supset}","â«‰":"\\underset{\\approx}{\\subset}","â«ˆ":"\\underset{\\sim}{\\supset}","â«‡":"\\underset{\\sim}{\\subset}","â«†":"\\supseteqq","â«…":"\\subseteqq","â«„":"\\dot{\\supseteq}","â«ƒ":"\\dot{\\subseteq}","â«‚":"\\underset{\\times}{\\supset}","â«":"\\underset{\\times}{\\subset}","â«€":"\\underset{+}{\\supset}","âª¿":"\\underset{+}{\\subset}","âª¾":"","âª½":"","âª¼":"\\gg ","âª»":"\\ll","âªº":"\\underset{\\cancel{\\approx}}{\\succ}","âª¹":"\\underset{\\cancel{\\approx}}{\\prec}","âª¸":"\\underset{\\approx}{\\succ}","âª·":"\\underset{\\approx}{\\prec}","âª¶":"\\underset{\\cancel{=}}{\\succ}","âªµ":"\\underset{\\cancel{=}}{\\prec}","âª´":"\\underset{=}{\\succ}","âª³":"\\underset{=}{\\prec}","âª²":"","âª±":"","âª®":"","âª­":"\\underline{\\hcancel{>}}","âª¬":"\\underline{\\hcancel{>}}","âª«":"\\hcancel{>}","âªª":"\\hcancel{<}","âª©":"","âª¨":"","âª§":"\\vartriangleright","âª¦":"\\vartriangleleft","âª¥":"><","âª¤":"><","âª£":"\\underline{\\ll}","âª¢Ì¸":"\\cancel{\\gg}","âª¢":"\\gg","âª¡Ì¸":"\\cancel{\\ll}","âª¡":"\\ll","âª ":"\\overset{\\sim}{\\geqq}","âªŸ":"\\overset{\\sim}{\\leqq}","âª":"\\overset{\\sim}{>}","âª":"\\overset{\\sim}{<}","âªœ":"","âª›":"","âªš":"\\overset{=}{>}","âª™":"\\overset{=}{<}","âª˜":"","âª—":"","âª–":"","âª•":"","âª”":"","âª“":"","âª’":"\\underset{=}{\\gtrless}","âª‘":"\\underset{=}{\\lessgtr}","âª":"\\underset{<}{\\gtrsim}","âª":"\\underset{>}{\\lesssim}","âª":"\\underset{\\simeq}{>}","âª":"\\underset{\\simeq}{<}","âªŒ":"\\gtreqqless","âª‹":"\\lesseqqgtr","âªŠ":"\\underset{\\cancel{\\approx}}{>}","âª‰":"\\underset{\\approx}{<}","âª†":"\\underset{\\approx}{>}","âª…":"\\underset{\\approx}{<}","âª„":"","âªƒ":"","âª‚":"","âª":"","âª€":"","â©¿":"","â©¾Ì¸":"\\bcancel{\\geq}","â©¾":"\\geq","â©½Ì¸":"\\bcancel{\\leq}","â©½":"\\leq","â©¼":"","â©»":"","â©º":"","â©¹":"","â©¸":"\\overset{\\dots}{\\equiv}","â©·":"","â©¶":"===","â©µ":"==","â©´":"::=","â©³":"","â©²":"\\underset{=}{+}","â©±":"\\overset{=}{+}","â©°":"\\overset{\\approx}{=}","â©¯":"\\overset{\\wedge}{=}","â©®":"\\overset{*}{=}","â©­":"\\dot{\\approx}","â©¬":"","â©«":"","â©ª":"\\dot{\\sim}","â©©":"","â©¨":"","â©§":"\\dot{\\equiv}","â©¦":"\\underset{\\cdot}{=}","â©¥":"","â©¤":"","â©£":"\\underset{=}{\\vee}","â©¢":"\\overset{=}{\\vee}","â©¡":"ul(vv)","â© ":"\\underset{=}{\\wedge}","â©Ÿ":"\\underline{\\wedge}","â©":"\\overset{=}{\\wedge}","â©":"\\hcancel{\\vee}","â©œ":"\\hcancel{\\wedge}","â©›":"","â©š":"","â©™":"","â©˜":"\\vee","â©—":"\\wedge","â©–":"","â©•":"","â©”":"","â©“":"","â©’":"\\dot{\\vee}","â©‘":"\\dot{\\wedge}","â©":"","â©":"","â©":"","â©":"\\overline{\\cap}","â©Œ":"\\overline{\\cup}","â©‹":"","â©Š":"","â©‰":"","â©ˆ":"","â©‡":"","â©†":"","â©…":"","â©„":"","â©ƒ":"\\overline{\\cap}","â©‚":"\\overline{\\cup}","â©":"","â©€":"","â¨¾":"","â¨½":"\\llcorner","â¨¼":"\\lrcorner","â¨»":"","â¨º":"","â¨¹":"","â¨¸":"","â¨·":"","â¨¶":"\\hat{\\otimes}","â¨µ":"","â¨´":"","â¨³":"","â¨²":"\\underline{\\times}","â¨±":"\\underline{\\times}","â¨°":"\\dot{\\times}","â¨®":"\\bigodot","â¨­":"\\bigodot","â¨¬":"","â¨«":"","â¨ª":"","â¨©":"","â¨¨":"","â¨§":"","â—»":"\\Box","â¨¦":"\\underset{\\sim}{+}","â¨¥":"\\underset{\\circ}{+}","â¨¤":"\\overset{\\sim}{+}","â¨£":"\\hat{+}","â¨¢":"\\dot{+}","â¨¡":"\\upharpoonright","â¨ ":">>","â¨Ÿ":"","â¨":"\\triangleleft","â¨":"\\bowtie","â§¿":"","â§¾":"+","â§»":"\\hcancel{|||}","â§º":"\\hcancel{||}","â§¹":"\\backslash","â§¸":"/","â§·":"hcancel{\backslash}","â§¶":"","â§µ":"\\backslash","â§²":"\\Phi","â§±":"","â§°":"","â§®":"","â§­":"","â§¬":"","â§«":"\\lozenge","â§ª":"","â§©":"","â§¨":"","â§§":"\\ddagger","â§¢":"\\sqcup\\sqcup","â§¡":"","â§ ":"\\square","â§":"","â§":"","â§œ":"","â§›":"\\{\\{","â§™":"\\{","â§˜":"\\}","â§—":"","â§–":"","â§•":"\\bowtie","â§”":"\\bowtie","â§“":"\\bowtie","â§’":"\\bowtie","â§‘":"\\bowtie","â§Ì¸":"| \\not\\triangleright","â§":"| \\triangleright","â§Ì¸":"\\not\\triangleleft |","â§":"\\triangleleft |","â§":"","â§":"\\triangle","â§Œ":"","â§‹":"\\underline{\\triangle}","â§Š":"\\dot{\\triangle}","â§‰":"","â§ˆ":"\\boxed{\\circ}","â§‡":"\\boxed{\\circ}","â§†":"\\boxed{\\rightarrow}","â§…":"\\bcancel{\\square}","â§„":"\\cancel{\\square}","â§ƒ":"\\odot","â§‚":"\\odot","â¦¿":"\\odot","â¦¾":"\\odot","â¦½":"\\varnothing","â¦¼":"\\oplus","â¦»":"\\otimes","â¦º":"","â¦¹":"\\varnothing","â¦¸":"\\varnothing","â¦·":"\\ominus","â¦¶":"\\ominus","â¦µ":"\\ominus","â¦´":"\\vec{\\varnothing}","â¦³":"\\vec{\\varnothing}","â¦²":"\\dot{\\varnothing}","â¦±":"\\overline{\\varnothing}","â¦°":"\\varnothing","â¦¯":"\\measuredangle","â¦®":"\\measuredangle","â¦­":"\\measuredangle","â¦¬":"\\measuredangle","â¦«":"\\measuredangle","â¦ª":"\\measuredangle","â¦©":"\\measuredangle","â¦¨":"\\measuredangle","â¦§":"","â¦¦":"","â¦¥":"","â¦¤":"","â¦£":"\\ulcorner","â¦¢":"\\measuredangle","â¦¡":"\\not\\lor","â¦ ":"\\bcancel{>}","â¦‚":":","â¦":"\\cdot","â˜":"\\mid","â–²":"\\bigtriangleup","â‹¿":"\\Epsilon","â‹¾":"\\overline{\\ni}","â‹½":"\\overline{\\ni}","â‹¼":"\\in","â‹»":"\\in","â‹º":"\\in","â‹¹":"\\underline{\\in}","â‹¸":"\\underline{\\in}","â‹·":"\\overline{\\in}","â‹¶":"\\overline{\\in}","â‹µ":"\\dot{\\in}","â‹´":"\\in","â‹³":"\\in","â‹²":"\\in","â‹°":"\\ddots","Ö‰":":","â‹©":"\\underset{\\sim}{\\succ}","â‹¨":"\\underset{\\sim}{\\prec}","â‹§":"\\underset{\\not\\sim}{>}","â‹¦":"\\underset{\\not\\sim}{<}","â‹¥":"\\not\\sqsupseteq","â‹¤":"\\not\\sqsubseteq","â‹£":"\\not\\sqsupseteq","â‹¢":"\\not\\sqsubseteq","â‹¡":"\\nsucc","â‹ ":"\\nprec","â‹Ÿ":"\\succ","â‹":"\\prec","â‹":"\\overline{>}","â‹œ":"\\overline{<}","â‹›":"\\underset{>}{\\leq}","â‹š":"\\underset{<}{\\geq}","â‹•":"\\#","â‹“":"\\cup","â‹’":"\\cap","â‹‘":"\\supset","â‹":"\\subset","â‹":"\\wedge","â‹":"\\vee","â‹":"\\simeq","â‹ˆ":"\\Join","â‹‡":"\\ast","â‹†":"\\star","â‹„":"\\diamond","âŠ¿":"\\triangle","âŠ¾":"\\measuredangle","âŠ½":"\\overline{\\lor}","âŠ¼":"\\overline{\\land}","âŠ»":"\\underline{\\lor}","âŠº":"\\top",åœŸ:"\\pm",å:"+","âŠ¹":"","âŠ·":"\\circ\\multimap","âŠ¶":"\\circ\\multimap","âŠ³":"\\triangleright","âŠ²":"\\triangleleft","âŠ±":"\\succ","âŠ°":"\\prec","âŠ«":"|\\models","âŠª":"|\\models","âŠ§":"\\models","âŠ¦":"\\vdash","âŠ":"\\ominus","âŠœ":"\\ominus","âŠ›":"\\odot","âŠš":"\\odot","âŠ”":"\\sqcup","âŠ“":"\\sqcap","âŠ’":"\\sqsupseteq","âŠ‘":"\\sqsubseteq","âŠÌ¸":"\\not\\sqsupset","âŠ":"\\sqsupset","âŠÌ¸":"\\not\\sqsubset","âŠ":"\\sqsubset","âŠ":"\\cup","âŠ":"\\cup","âŠŒ":"\\cup","â‰¿Ì¸":"\\not\\succsim","â‰¿":"\\succsim","â‰¾":"\\precsim","â‰¹":"\\not\\overset{>}{<}","â‰¸":"\\not\\overset{>}{<}","â‰·":"\\overset{>}{<}","â‰¶":"\\overset{<}{>}","â‰µ":"\\not\\geg","â‰´":"\\not\\leq","â‰³":"\\geg","â‰²":"\\leq","â‰¬":"","â‰§":"\\geg","â‰¦Ì¸":"\\not\\leq","â‰¦":"\\leq","â‰£":"\\overset{=}{=} ","â‰":"\\overset{m}{=} ","â‰":"\\overset{def}{=}","â‰˜":"=","â‰–":"=","â‰•":"=:","â‰“":"\\doteq","â‰’":"\\doteq","â‰‘":"\\doteq","â‰":"\\doteq","â‰Ì¸":"","â‰":"","â‰Ì¸":"","â‰":"","â‰Œ":"\\approx","â‰‹":"\\approx","â‰Š":"\\approx","â‰‚Ì¸":"\\neq","â‰‚":"=","âˆ¿":"\\sim","âˆ¾":"\\infty","âˆ½Ì±":"\\sim","âˆ½":"\\sim","âˆ»":"\\sim","âˆº":":-:","âˆ¹":"-:","âˆ¸":"\\bot","âˆ·":"::","âˆ¶":":","âˆ£":"\\mid","âˆŸ":"\\llcorner","âˆ˜":"\\circ","âˆ—":"*","âˆ•":"/","âˆ":"\\square","âˆ":"\\ni","âˆŠ":"\\in","âˆ†":"\\Delta","â„":"/","âª°Ì¸":"\\nsucceq","âª°":"\\succeq","âª¯Ì¸":"\\npreceq","âª¯":"\\preceq","âªˆ":"\\ngeqslant","âª‡":"\\nleqslant","â§³":"\\Phi","â§¦":"\\models","â§¥":"\\not\\equiv","â§¤":"\\approx\\neq","â§£":"\\neq","â§":"\\circle","â§€":"\\circle","â—¦":"\\circle","â——":"\\circle","â—–":"\\circle","â—":"\\circle","â—":"\\circledcirc","â—":"\\circledcirc","â—Œ":"\\circledcirc","â—‰":"\\circledcirc","â—ˆ":"\\diamond","â—‡":"\\diamond","â—†":"\\diamond","â—…":"\\triangleleft","â—„":"\\triangleleft","â—ƒ":"\\triangleleft","â—‚":"\\triangleleft","â—":"\\triangleleft","â—€":"\\triangleleft","â–¿":"\\triangledown","â–¾":"\\triangledown","â–½":"\\triangledown","â–¼":"\\triangledown","â–¹":"\\triangleright","â–¸":"\\triangleright","â–·":"\\triangleright","â–¶":"\\triangleright","â–µ":"\\triangle","â–´":"\\triangle","â–³":"\\triangle","â–±":"\\square","â–°":"\\blacksquare","â–¯":"\\square","â–®":"\\blacksquare","â–­":"\\square","â–«":"\\square","â–ª":"\\square","â–¡":"\\square","â– ":"\\blacksquare","â‹­":"\\not\\triangleright","â‹¬":"\\not\\triangleleft","â‹«":"\\not\\triangleright","â‹ª":"\\not\\triangleleft","â‹™":"\\ggg","â‹˜":"\\lll","â‹—":"*>","â‹–":"<*","â‹”":"\\pitchfork","â‹Œ":"","â‹‹":"\\bowtie","â‹Š":"\\ltimes","â‹‰":"\\rtimes","âŠµ":"\\triangleright","\\triangleleft":"","âŠ¥":"\\bot","âŠ":"\\nsucc","âŠ€":"\\preceq","â‰½":"\\succeq","â‰¼":"\\preceq","â‰»":"\\succ","â‰º":"\\prec","â‰±":"\\geq/","â‰°":"\\leq/","â‰­":"\\neq","â‰«Ì¸":"\\not\\gg","â‰«":"\\gg","â‰ªÌ¸":"\\not\\ll","â‰ª":"\\ll","â‰©":"\\ngeqslant","â‰¨":"\\nleqslant","â‰¡":"\\equiv","â‰Ÿ":"\\doteq","â‰œ":"\\triangleq","â‰›":"\\doteq","â‰š":"\\triangleq","â‰™":"\\triangleq","â‰—":"\\doteq","â‰”":":=","â‰":"\\asymp","â‰‡":"\\ncong","â‰†":"\\ncong","â‰…":"\\cong","â‰„":"\\not\\simeq","â‰ƒ":"\\simeq","â‰":"\\not\\sim","âˆ¦":"\\not\\parallel","âˆ¥":"\\parallel","âˆ¤":"\\not|","âˆ":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","â‰ ":"\\neq","â‰¢":"\\equiv /","â‰‰":"\\approx /","âˆ¼":"sim","â‰ˆ":"\\approx","â‰®":"</","<":"<","â‰¯":">/",">=":">=",">":">","â‰¥":"\\geq","â‰¤":"\\leq","<=":"<=","âŠ‹":"\\supsetneq","âŠŠ":"\\subsetneq","âŠ‰":"\\nsupseteq","âŠˆ":"\\nsubseteq","âŠ‡":"\\supseteq","âŠ†":"\\subseteq","âŠ…":"\\not\\supset","âŠ„":"\\not\\subset","âŠƒâƒ’":"\\supset |","âŠƒ":"\\supset","âŠ‚âƒ’":"\\subset |","âŠ‚":"\\subset","âˆŒ":"\\not\\in","âˆ‰":"\\notin","âˆˆ":"\\in","âˆ":"C","âˆ„":"\\nexists","âˆƒ":"\\exists","âˆ€":"\\forall","âˆ§":"\\land","&&":"\\&\\&","âˆ¨":"\\lor","âŠ¯":"\\cancel{\\vDash}","âŠ®":"\\cancel{\\Vdash}","âŠ­":"\\nvDash","âŠ¬":"\\nvDash","âŠ©":"\\Vdash","âŠ¨":"\\vDash","âŠ¤":"\\top","âŠ£":"\\dashv","âŠ¢":"\\vdash","âˆ‹":"\\ni","â‹±":"\\ddots","â‹¯":"\\hdots","â‹®":"\\vdots","Ï¶":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","âˆµ":"\\because","âˆ´":"\\therefore ","â£":"\\llbracket",",":",",";":";","â§½":"\\}","â§¼":"\\{","â¦˜":"\\]","â¦—":"\\[","â¦–":"\\ll","â¦•":"\\gg","â¦”":"\\gg","â¦“":"\\ll","â¦’":"\\gg","â¦‘":"\\ll","â¦":"\\]","â¦":"\\]","â¦":"\\]","â¦":"\\[","â¦Œ":"\\[","â¦‹":"\\]","â¦Š":"\\triangleright","â¦‰":"\\triangleleft","â¦ˆ":"|\\)","â¦‡":"\\(|","â¦†":"|\\)","â¦…":"\\(\\(","â¦„":"|\\}","â¦ƒ":"\\{|","â¦€":"\\||","âŸ¯":"\\left. \\right]","âŸ®":"\\left[ \\right.","âŸ­":"\\left. \\right]]","âŸ¬":"\\left[[ \\right.","âŸ«":"\\gg","âŸª":"\\ll","âŸ§":"\\)|","âŸ¦":"\\(|","â³":"\\left.\\right)","â²":"\\left(\\right.","âŒª":"\\rangle","âŒ©":"\\langle","âŒ‹":"\\rfloor","âŒŠ":"\\lfloor","âŒ‰":"\\rceil","âŒˆ":"\\lceil","â€–":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","â€":'\\"',"â€œ":"\\text{``}","â€™":"'","â€˜":"`",Î±:"\\alpha",Î²:"\\beta",Î³:"\\gamma",Î“:"\\Gamma",Î´:"\\delta",Î”:"\\Delta",Ïµ:"\\epsilon",Î¶:"\\zeta",Î·:"\\eta",Î¸:"\\theta",Î˜:"\\Theta",Î¹:"\\iota",Îº:"\\kappa",Î»:"\\lambda",Î½:"\\nu",Î¿:"\\omicron",Ï€:"\\pi",Î :"\\Pi",Ï:"\\rho",Ïƒ:"\\sigma",Î£:"\\Sigma",Ï„:"\\tau",Ï…:"\\upsilon",Î¥:"\\Upsilon",Ï•:"\\phi",Î¦:"\\Phi",Ï‡:"\\chi",Ïˆ:"\\psi",Î¨:"\\Psi",Ï‰:"\\omega",Î©:"\\Omega",â„¦:"\\Omega","âˆ…":"\\emptyset","âŸ²":"\\circlearrowleft","âŸ³":"\\circlearrowright","Ã—":"\\times","Â½":"\\dfrac{1}{2}",Î¼:"\\mu",Ó¨:"\\theta","âœ“":"\\checkmark","âŸ©":"\\rangle","âŸ¨":"\\langle","Â¼":"\\dfrac{1}{4}","â€¦":"\\ldots",â„:"\\hbar",â„œ:"\\mathfrak{R}",Ñ²:"\\theta",Ã˜:"\\emptyset",Ï±:"\\varrho",Ñ„:"\\phi",â„‡:"\\varepsilon",T:"T","âˆ™":"\\cdot",Î¡:"P","âˆ":"\\infty",á:"\\nabla",Æ:"\\eta","âº":"^{+}","â»":"^{-}","â¼":"^{=}","â½":"^{(}","â¾":"^{)}","ã€—":"\\)|","ã€–":"\\langle","Í¾":";","àµ¦":"\\circ","â”´":"\\perp","âœ•":"\\times","â»":"-","Â»":"\\gg","â¬†":"\\uparrow","â¬‡":"\\downarrow","â¬…":"\\leftarrow","â¡":"\\rightarrow","â¼":"-","âœ":"\\mid","â¥":"\\mid",Ä§:"\\hbar","â®•":"\\rightarrow","ãƒ»":"\\cdot","Â¦":"\\mid","Â£":"\\pounds","Â¥":"\\yen","âœ—":"\\times","âœ”":"\\checkmark",â¿:"^{n}","Â«":"\\ll",à¹€:"\\prime","â€ ":"\\dagger","â”‚":"\\mid",$:"\\$","#":"\\#","â„ƒ":"\\text{\\textdegree C}","â„‰":"\\text{\\textdegree F}","â–ˆ":"\\blacksquare","â„§":"\\mho",â…‡:"\\text{e}",É¼:"r","â€¡":"\\ddagger",á¼±:"i",Ï’:"\\Upsilon",ğ›¿:"\\delta","Ë³":"\\cdot",Ñ³:"\\theta",ğœ™:"\\phi",ĞŸ:"\\prod",Ğ¾:"o",Ñ’:"\\hbar",É…:"\\Lambda","à¥¤":"\\mid","â‚¬":"\\euro",á¿¡:"\\bar{u}",Ï†:"\\varphi",È¼:"c",ğ®:"\\epsilon",Î§:"\\mathsf{X}",â‚™:"_{n}"}},8249:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByChar=void 0,t.allMathSymbolsByChar={"&#xA0;":"\\textrm{ }","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x21D4;":"\\iff","&#x21D2;":"=>","&#xAC;":"\\neg","&#x2124;":"\\mathbb{Z}","&#x211D;":"\\mathbb{R}","&#x211A;":"\\mathbb{Q}","&#x2115;":"\\mathbb{N}","&#x2102;":"CC","&#x25A1;":"\\square","&#x22C4;":"\\diamond","&#x25B3;":"\\triangle","&#x2322;":"\\frown","&#x2220;":"\\angle","&#x22F1;":"\\ddots","&#x22EE;":"\\vdots","&#x2235;":"\\because","&#x2234;":"\\therefore","&#x2135;":"\\aleph","&#x2205;":"\\oslash","&#xB1;":"\\pm","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x222E;":"\\oint","&#x222B;":"\\int","&#x22C3;":"\\cup","&#x222A;":"\\cup","&#x22C2;":"\\cap","&#x2229;":"\\cap","&#x22C1;":"\\vee","&#x2228;":"\\vee","&#x22C0;":"\\wedge","&#x2227;":"\\wedge","&#x220F;":"\\prod","&#x2211;":"\\sum","&#x2299;":"\\bigodot","&#x2297;":"\\bigoplus","&#x2295;":"o+","&#x2218;":"@","&#x22C8;":"\\bowtie","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#xF7;":"\\div","&#xD7;":"\\times","\\":"\\backslash","&#x22C6;":"\\star","&#x2217;":"\\star","&#x22C5;":"\\cdot","&#x3A9;":"\\Omega","&#x3C9;":"\\omega","&#x3A8;":"\\Psi","&#x3C8;":"\\psi","&#x3C7;":"\\chi","&#x3C6;":"\\varphi","&#x3A6;":"\\Phi","&#x3D5;":"\\phi","&#x3C5;":"\\upsilon","&#x3C4;":"\\tau","&#x3A3;":"\\Sigma","&#x3C3;":"\\sigma","&#x3C1;":"\\rho","&#x3A0;":"\\Pi","&#x3C0;":"\\pi","&#x39E;":"\\Xi","&#x3BE;":"\\xi","&#x3BD;":"\\nu","&#x3BC;":"\\mu","&#x39B;":"\\Lambda","&#x3BB;":"\\lambda","&#x3BA;":"\\kappa","&#x3B9;":"\\iota","&#x3D1;":"\\vartheta","&#x398;":"\\Theta","&#x3B8;":"\\theta","&#x3B7;":"\\eta","&#x3B6;":"\\zeta","&#x25B;":"\\varepsilon","&#x3B5;":"\\epsilon","&#x394;":"\\Delta","&#x3B4;":"\\delta","&#x393;":"\\Gamma","&#x3B3;":"\\gamma","&#x3B2;":"\\beta","&#x3B1;":"\\alpha","&#x221E;":"\\infty","â€¬":"\\text{\\textdir TRT}","â€":"\\text{\\textdir LTR}"}},8171:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByGlyph=void 0,t.allMathSymbolsByGlyph={" ":"\\textrm{ }","âˆƒ":"\\exists","âˆ€":"\\forall","â‡”":"\\iff","â‡’":"\\Rightarrow","Â¬":"\\neg","â–¡":"\\square","â‹„":"\\diamond","â–³":"\\triangle","âŒ¢":"\\frown","âˆ ":"\\angle","â‹±":"\\ddots","â‹®":"\\vdots","âˆµ":"\\because","âˆ´":"\\therefore",â„µ:"\\aleph","âˆ…":"\\emptyset","Â±":"\\pm","âˆ‡":"\\nabla","âˆ‚":"\\partial","âˆ®":"\\oint","âˆ«":"\\int","â‹ƒ":"\\cup","âˆª":"\\cup","â‹‚":"\\cap","âˆ©":"\\cap","â‹":"\\vee","âˆ¨":"\\vee","â‹€":"\\wedge","âˆ§":"\\wedge","âˆ":"\\prod","âˆ‘":"\\sum","âŠ™":"\\bigodot","âŠ—":"\\bigoplus","âŠ•":"o+","âˆ˜":"@","â‹ˆ":"\\bowtie","â‹Š":"\\rtimes","â‹‰":"\\ltimes","Ã·":"\\div","Ã—":"\\times","\\":"\\backslash","â‹†":"\\star","âˆ—":"\\star","â‹…":"\\cdot",Î©:"\\Omega",Ï‰:"\\omega",Î¨:"\\Psi",Ïˆ:"\\psi",Ï‡:"\\chi",Ï†:"\\varphi",Î¦:"\\Phi",Ï•:"\\phi",Ï…:"\\upsilon",Ï„:"\\tau",Î£:"\\Sigma",Ïƒ:"\\sigma",Ï:"\\rho",Î :"\\Pi",Ï€:"\\pi",Î:"\\Xi",Î¾:"\\xi",Î½:"\\nu",Î¼:"\\mu",Î›:"\\Lambda",Î»:"\\lambda",Îº:"\\kappa",Î¹:"\\iota",Ï‘:"\\vartheta",Î˜:"\\Theta",Î¸:"\\theta",Î·:"\\eta",Î¶:"\\zeta",É›:"\\varepsilon",Îµ:"\\epsilon",Î”:"\\Delta",Î´:"\\delta",Î“:"\\Gamma",Î³:"\\gamma",Î²:"\\beta",Î±:"\\alpha","âˆ":"\\infty",Ïµ:"\\epsilon",Âµ:"\\mu","Â²":"^{2}",Ä±:"\\imath","âˆ":"\\blacksquare",à¸¡:"\\mathbf{m}",â„¦:"\\Omega","âŸ²":"\\circlearrowleft","âŸ³":"\\circlearrowright",à¤¤:" ","Â¥":"\\yen","â½":"^{(}","â¾":"^{)}",ÃŸ:"\\ss",Ğ‹:"\\hbar","â¦µ":"\\ominus","âŠ¿":"\\bigtriangleup","â†›'":"\\nrightarrow","â€ ":"\\dagger",à¹€:"\\prime",ç™½:" ","â¿±":" ",â„¸:"\\wp",í“°:" ",â¿:"^{n}","âœ”":"\\checkmark","âœ—":"\\times","Â½":"\\dfrac{1}{2}",Ó¨:"\\theta","âœ“":"\\checkmark","âŸ©":"\\rangle","âŸ¨":"\\langle","âŒ©":"\\langle","Â¼":"\\dfrac{1}{4}","â€¦":"\\ldots",â„:"\\hbar",â„œ:"\\mathfrak{R}",Ñ²:"\\theta",Ã˜:"\\emptyset",Ï±:"\\varrho",Ñ„:"\\phi",T:"T","âˆ™":"\\cdot",Î¡:"P",á:"\\nabla",Æ:"\\eta",É£:"\\gamma",Ñ›:"\\hbar",Æ:"\\varepsilon",â……:"\\_{D}",ğœ†:"\\lambda","ã€—":"\\rangle","ã€–":"\\langle","Í¾":";",ğ‘¥:"x",ğ‘¦:"y",ğ‘§:"z",ğ‘–:"i",ğ‘—:"j",ğ‘˜:"k",ğ‘š:"m",ğ‘’:"e",ğ‘Ÿ:"r",É³:"\\eta",ğ›½:"\\beta","âµ":"\\omega",â„˜:"\\wp",ğœ‹:"\\pi",Ğ„:"\\epsilon",Ñ”:"\\epsilon",ğœ€:"\\epsilon",Ğ¿:"\\pi",Î:"\\nu",Éµ:"\\theta",ğœ“:"\\psi",Ï´:"\\theta",É¸:"\\phi",Ó¶:"\\Gamma",É­:"\\ell",Ê‹:"\\upsilon",ğ›Ÿ:"\\varphi","â¬":"\\theta",Ğ¤:"\\Phi",ğœ‘:"\\varphi",â…ˆ:"i",Î¿:"o",Æ¡:"o",Æ’:"f","â´":"\\rho","ğŸ‡½":"x",ğ‘:"p",ğ‘:"q",ğ‘ :"s",ğ‘¡:"t",ğ‘¢:"u",ğ‘£:"v",ğ‘¤:"w",ğ‘:"a",ğ‘:"b",ğ‘:"c",ğ‘‘:"d",ğ‘“:"f",ğ‘”:"g",ğ‘™:"l",ğ‘›:"n",ğ‘œ:"o",ğ”€:"w",ğšŸ:"v",á¹:"m","àµ¦":"\\circ","â”´":"\\perp","âœ•":"\\times","âˆ£":"\\mid",Õ“:"\\Phi","âœ":"\\mid",Ä§:"\\hbar",áˆ:" ","â¦¨":"\\llbracket",áº¿:"\\hat{e}","Â¢":"\\cent","â¤¹":"\\downarrow","â¤¸":"\\downarrow","â¤·":"\\Rsh","â¤¶":"\\Lsh","â¤µ":"\\downarrow","â¤´":"\\uparrow","â¤³":"\\rightarrow","|":"\\mid","â¥":"\\mid","â™¥":"\\heartsuit",Ğ:"0",Î¥:"Y",Ñ…:"x",ğ“:"z",ğ“:"y",ğ“:"x",Ñ€:"p",Ğ°:"a","Â£":"\\pounds",m:"m",ğšµ:"\\Xi","â“ª":"\\textcircled{0}","â‘ ":"\\textcircled{1}","â‘¡":"\\textcircled{2}","â‘¢":"\\textcircled{3}","â‘£":"\\textcircled{4}","â‘¤":"\\textcircled{5}","â‘¥":"\\textcircled{6}","â‘¦":"\\textcircled{7}","â‘§":"\\textcircled{8}","â‘¨":"\\textcircled{9}","â‘©":"\\textcircled{10}","â‘ª":"\\textcircled{11}","â‘«":"\\textcircled{12}","â‘¬":"\\textcircled{13}","â‘­":"\\textcircled{14}","â‘®":"\\textcircled{15}","â‘¯":"\\textcircled{16}","â‘°":"\\textcircled{17}","â‘±":"\\textcircled{18}","â‘²":"\\textcircled{19}","â‘³":"\\textcircled{20}","ã‰‘":"\\textcircled{21}","ã‰’":"\\textcircled{22}","ã‰“":"\\textcircled{23}","ã‰”":"\\textcircled{24}","ã‰•":"\\textcircled{25}","ã‰–":"\\textcircled{26}","ã‰—":"\\textcircled{27}","ã‰˜":"\\textcircled{28}","ã‰™":"\\textcircled{29}","ã‰š":"\\textcircled{30}","ã‰›":"\\textcircled{31}","ã‰œ":"\\textcircled{32}","ã‰":"\\textcircled{33}","ã‰":"\\textcircled{34}","ã‰Ÿ":"\\textcircled{35}","ãŠ±":"\\textcircled{36}","ãŠ²":"\\textcircled{37}","ãŠ³":"\\textcircled{38}","ãŠ´":"\\textcircled{39}","ãŠµ":"\\textcircled{40}","ãŠ¶":"\\textcircled{41}","ãŠ·":"\\textcircled{42}","ãŠ¸":"\\textcircled{43}","ãŠ¹":"\\textcircled{44}","ãŠº":"\\textcircled{45}","ãŠ»":"\\textcircled{46}","ãŠ¼":"\\textcircled{47}","ãŠ½":"\\textcircled{48}","ãŠ¾":"\\textcircled{49}","ãŠ¿":"\\textcircled{50}","&":"\\&","â€–":"\\parallel","%":"\\%","â€œ":"\\text{``}",$:"\\$","#":"\\#","â„ƒ":"\\text{\\textdegree C}","â„‰":"\\text{\\textdegree F}","â–ˆ":"\\blacksquare","â„§":"\\mho","âŒ‹":"\\rfloor","âŒŠ":"\\lfloor","âŒ‰":"\\rceil","âŒˆ":"\\lceil",â„‡:"\\varepsilon",â…‡:"\\text{e}",É¼:"r","â†›":"\\nrightarrow",Ë†:"\\hat{}","â€¾":"\\overline","â†’":"\\rightarrow","â€¡":"\\ddagger","ãƒ»":"\\cdot","â–±":"\\square","âˆ†":"\\Delta",á¼±:"i","âˆ¡":"\\angle",Ï’:"\\Upsilon","â†“":"\\downarrow","â†‘":"\\uparrow","Â»":"\\gg","âŠ¤":"\\top","â§¸":"/",ğ›¿:"\\delta","Ë³":"\\cdot","Ö‰":":","â¦ª":"\\measuredangle","â¦©":"\\measuredangle","â¦«":"\\measuredangle","â¦":"\\cdot",Ñ³:"\\theta","â¦¢":"\\measuredangle","Â¸":",","â»":"\\overline","âŸ¦":"\\llbracket",ğœ™:"\\phi",ĞŸ:"\\prod",Ğ¾:"o","â‰ˆ":"\\approx","â‰¤":"\\leq",Ñ’:"\\hbar",É…:"\\Lambda",åœŸ:"\\pm","â¼":"-",å:"+","â‰ ":"\\neq","â†":"\\leftarrow","à¥¤":"\\mid","â‚¬":"\\euro","Ë˜":" ",á¿¡:"\\bar{u}","âˆ¥":"\\parallel","â†”":"\\leftrightarrow","âˆš":"\\sqrt{}",È¼:"c",ğ®:"\\epsilon","Â·":"\\cdot","â¦¬":"\\measuredangle","â¦®":"\\measuredangle","â¦­":"\\measuredangle","Â«":"\\ll",Î§:"\\mathsf{X}","â”‚":"\\mid","âŒª":"\\rangle",â‚™:"_{n}","â–«":"\\square","â—":"\\circle","â€":'\\"'}},5406:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(2965),t),n(r(9039),t),n(r(8249),t),n(r(8171),t),n(r(472),t),n(r(4320),t),n(r(6122),t)},472:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.latexAccents=void 0,t.latexAccents=["\\hat","\\bar","\\underbrace","\\overbrace"]},4320:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathNumberByGlyph=void 0,t.mathNumberByGlyph={"â‚€":"_{0}","â‚":"_{1}","â‚‚":"_{2}","â‚ƒ":"_{3}","â‚„":"_{4}","â‚…":"_{5}","â‚†":"_{6}","â‚‡":"_{7}","â‚ˆ":"_{8}","â‚‰":"_{9}","â°":"^{0}","Â¹":"^{1}","Â²":"^{2}","Â³":"^{3}","â´":"^{4}","âµ":"^{5}","â¶":"^{6}","â·":"^{7}","â¸":"^{8}","â¹":"^{9}",â¿:"^{n}",â‚™:"_{n}","â“ª":"\\textcircled{0}","â‘ ":"\\textcircled{1}","â‘¡":"\\textcircled{2}","â‘¢":"\\textcircled{3}","â‘£":"\\textcircled{4}","â‘¤":"\\textcircled{5}","â‘¥":"\\textcircled{6}","â‘¦":"\\textcircled{7}","â‘§":"\\textcircled{8}","â‘¨":"\\textcircled{9}","â‘©":"\\textcircled{10}","â‘ª":"\\textcircled{11}","â‘«":"\\textcircled{12}","â‘¬":"\\textcircled{13}","â‘­":"\\textcircled{14}","â‘®":"\\textcircled{15}","â‘¯":"\\textcircled{16}","â‘°":"\\textcircled{17}","â‘±":"\\textcircled{18}","â‘²":"\\textcircled{19}","â‘³":"\\textcircled{20}","ã‰‘":"\\textcircled{21}","ã‰’":"\\textcircled{22}","ã‰“":"\\textcircled{23}","ã‰”":"\\textcircled{24}","ã‰•":"\\textcircled{25}","ã‰–":"\\textcircled{26}","ã‰—":"\\textcircled{27}","ã‰˜":"\\textcircled{28}","ã‰™":"\\textcircled{29}","ã‰š":"\\textcircled{30}","ã‰›":"\\textcircled{31}","ã‰œ":"\\textcircled{32}","ã‰":"\\textcircled{33}","ã‰":"\\textcircled{34}","ã‰Ÿ":"\\textcircled{35}","ãŠ±":"\\textcircled{36}","ãŠ²":"\\textcircled{37}","ãŠ³":"\\textcircled{38}","ãŠ´":"\\textcircled{39}","ãŠµ":"\\textcircled{40}","ãŠ¶":"\\textcircled{41}","ãŠ·":"\\textcircled{42}","ãŠ¸":"\\textcircled{43}","ãŠ¹":"\\textcircled{44}","ãŠº":"\\textcircled{45}","ãŠ»":"\\textcircled{46}","ãŠ¼":"\\textcircled{47}","ãŠ½":"\\textcircled{48}","ãŠ¾":"\\textcircled{49}","ãŠ¿":"\\textcircled{50}","Â½":"\\dfrac{1}{2}","â…“":"\\dfrac{1}{3}","â…”":"\\dfrac{2}{3}","Â¼":"\\dfrac{1}{4}","Â¾":"\\dfrac{3}{4}","â…•":"\\dfrac{1}{5}","â…–":"\\dfrac{2}{5}","â…—":"\\dfrac{3}{5}","â…˜":"\\dfrac{4}{5}","â…™":"\\dfrac{1}{6}","â…š":"\\dfrac{5}{6}","â…":"\\dfrac{1}{7}","â…›":"\\dfrac{1}{8}","â…œ":"\\dfrac{3}{8}","â…":"\\dfrac{5}{8}","â…":"\\dfrac{7}{8}","â…‘":"\\dfrac{1}{9}","â…’":"\\dfrac{1}{10}"}},6122:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HashUTF8ToLtXConverter=void 0,t.HashUTF8ToLtXConverter=class{convert(e){if(e.match(/[a-z0-9]/i))return e;const t=r[e];if(t){return this.convertAccentCharToLtX(t)||e}return this.convertSpecialCharToLtX(e)||e}convertAccentCharToLtX(e){const{char:t,accent:r}=e,n=a[r];return n?`\\${n}{${t}}`:null}convertSpecialCharToLtX(e){const t=n[e];if(!t)return null;const{letter:r,fontCmd:a}=t;return`\\${a}{${r}}`}};const r={Ã¡:{char:"a",accent:"Â´"},Ã :{char:"a",accent:"`"},Ã¢:{char:"a",accent:"^"},Ã£:{char:"a",accent:"~"},Ã¤:{char:"a",accent:"Â¨"},Ã¥:{char:"a",accent:"Ëš"},Ä…:{char:"a",accent:"Ë™"},Äƒ:{char:"a",accent:"Ë˜"},Ç:{char:"a",accent:"Ë‡"},ÇŸ:{char:"a",accent:"Ë†"},Ç»:{char:"a",accent:"Ë™"},Ç¡:{char:"a",accent:"-"},Ä:{char:"a",accent:"-"},Ã©:{char:"e",accent:"Â´"},Ã¨:{char:"e",accent:"`"},Ãª:{char:"e",accent:"^"},Ã«:{char:"e",accent:"Â¨"},Ä™:{char:"e",accent:"Ë™"},Ä›:{char:"e",accent:"Ë‡"},È‡:{char:"i",accent:"^"},Ñ‘:{char:"e",accent:"Â¨"},Ä“:{char:"e",accent:"-"},Ã­:{char:"i",accent:"Â´"},Ã¬:{char:"i",accent:"`"},Ã®:{char:"i",accent:"^"},Ã¯:{char:"i",accent:"Â¨"},Ä¯:{char:"i",accent:"Ë™"},Ç:{char:"i",accent:"Ë‡"},È‰:{char:"i",accent:"`"},È‹:{char:"i",accent:"Â¨"},Ä«:{char:"i",accent:"-"},Ã³:{char:"o",accent:"Â´"},Ã²:{char:"o",accent:"`"},Ã´:{char:"o",accent:"^"},Ãµ:{char:"o",accent:"~"},Ã¶:{char:"o",accent:"Â¨"},Å‘:{char:"o",accent:"Ë"},Ç’:{char:"o",accent:"Ë‡"},È:{char:"o",accent:"`"},È:{char:"o",accent:"Â¨"},È«:{char:"o",accent:"Ë˜"},È­:{char:"o",accent:"Ë"},È¯:{char:"o",accent:"Ë™"},Å:{char:"o",accent:"-"},Ãº:{char:"u",accent:"Â´"},Ã¹:{char:"u",accent:"`"},Ã»:{char:"u",accent:"^"},Ã¼:{char:"u",accent:"Â¨"},Å±:{char:"u",accent:"Ë"},Ç”:{char:"u",accent:"Ë‡"},Ç–:{char:"u",accent:"Â¨"},Ç˜:{char:"u",accent:"Â¨"},Çš:{char:"u",accent:"Â¨"},Çœ:{char:"u",accent:"Â¨"},È•:{char:"u",accent:"`"},È—:{char:"u",accent:"Â¨"},Å«:{char:"u",accent:"-"},Ã½:{char:"y",accent:"Â´"},á»³:{char:"y",accent:"`"},Å·:{char:"y",accent:"^"},Ã¿:{char:"y",accent:"Â¨"},È³:{char:"y",accent:"-"},Ã:{char:"A",accent:"Â´"},Ã€:{char:"A",accent:"`"},Ã‚:{char:"A",accent:"^"},Ãƒ:{char:"A",accent:"~"},Ã„:{char:"A",accent:"Â¨"},Ã…:{char:"A",accent:"Ëš"},â„«:{char:"A",accent:"Ëš"},È¦:{char:"A",accent:"Ë™"},Ä‚:{char:"A",accent:"Ë˜"},Ç:{char:"A",accent:"Ë‡"},Ç:{char:"A",accent:"Ë"},Çº:{char:"A",accent:"Ëš"},Ç :{char:"A",accent:"-"},Ä€:{char:"A",accent:"-"},Ã‰:{char:"E",accent:"Â´"},Ãˆ:{char:"E",accent:"`"},Ä–:{char:"E",accent:"Ë™"},ÃŠ:{char:"E",accent:"^"},Ã‹:{char:"E",accent:"Â¨"},Äš:{char:"E",accent:"Ë‡"},È„:{char:"E",accent:"`"},È†:{char:"E",accent:"Â¨"},Ä’:{char:"E",accent:"-"},Ã:{char:"I",accent:"Â´"},ÃŒ:{char:"I",accent:"`"},Ã:{char:"I",accent:"^"},Ã:{char:"I",accent:"Â¨"},Ä¬:{char:"I",accent:"Ë˜"},Ç:{char:"I",accent:"Ë‡"},Èˆ:{char:"I",accent:"`"},ÈŠ:{char:"I",accent:"Â¨"},Äª:{char:"I",accent:"-"},Ã“:{char:"O",accent:"Â´"},Ã’:{char:"O",accent:"`"},Ã”:{char:"O",accent:"^"},Ã•:{char:"O",accent:"~"},Ã–:{char:"O",accent:"Â¨"},Å:{char:"O",accent:"Ë"},Ç‘:{char:"O",accent:"Ë‡"},ÈŒ:{char:"O",accent:"`"},È:{char:"O",accent:"Â¨"},Èª:{char:"O",accent:"Ë˜"},È¬:{char:"O",accent:"Ë"},È®:{char:"O",accent:"Ë™"},ÅŒ:{char:"O",accent:"-"},Ãš:{char:"U",accent:"Â´"},Ã™:{char:"U",accent:"`"},Ã›:{char:"U",accent:"^"},Ãœ:{char:"U",accent:"Â¨"},Å°:{char:"U",accent:"Ë"},Ç“:{char:"U",accent:"Ë‡"},Ç•:{char:"U",accent:"Â¨"},È”:{char:"U",accent:"`"},È–:{char:"U",accent:"Â¨"},Åª:{char:"U",accent:"-"},Ã:{char:"Y",accent:"Â´"},á»²:{char:"Y",accent:"`"},Å¶:{char:"Y",accent:"^"},Å¸:{char:"Y",accent:"Â¨"},È²:{char:"Y",accent:"-"},Ã±:{char:"n",accent:"~"},Ã‘:{char:"N",accent:"~"},Ã§:{char:"c",accent:"Ë™"},Ã‡:{char:"C",accent:"Ë™"},á¹½:{char:"v",accent:"~"},á¹¼:{char:"V",accent:"~"},Äµ:{char:"j",accent:"^"},Ä´:{char:"J",accent:"^"},Åº:{char:"z",accent:"Â´"},Å¹:{char:"Z",accent:"Â´"},Å»:{char:"Z",accent:"^"},Å¼:{char:"z",accent:"^"},Å½:{char:"Z",accent:"Ë‡"},Å¾:{char:"z",accent:"Ë‡"},áº‘:{char:"z",accent:"Ë†"}},a={"Â´":"grave","`":"acute","^":"hat","~":"tilde","Â¨":"ddot","Ëš":"mathring","Ë˜":"breve",Ë‡:"check","Ë":"ddot","Ë™":"dot","-":"bar",Ë†:"hat","Ëœ":"tilde"},n={ğ€:{letter:"A",fontCmd:"mathbf"},ğ:{letter:"B",fontCmd:"mathbf"},ğ‚:{letter:"C",fontCmd:"mathbf"},ğƒ:{letter:"D",fontCmd:"mathbf"},ğ„:{letter:"E",fontCmd:"mathbf"},Î•:{letter:"E",fontCmd:"mathbf"},ğ…:{letter:"F",fontCmd:"mathbf"},ğ†:{letter:"G",fontCmd:"mathbf"},ğ‡:{letter:"H",fontCmd:"mathbf"},ğˆ:{letter:"I",fontCmd:"mathbf"},ğ‰:{letter:"J",fontCmd:"mathbf"},ğŠ:{letter:"K",fontCmd:"mathbf"},ğ‹:{letter:"L",fontCmd:"mathbf"},ğŒ:{letter:"M",fontCmd:"mathbf"},ğ:{letter:"N",fontCmd:"mathbf"},ğ:{letter:"O",fontCmd:"mathbf"},ğ:{letter:"P",fontCmd:"mathbf"},ğ:{letter:"Q",fontCmd:"mathbf"},ğ‘:{letter:"R",fontCmd:"mathbf"},ğ’:{letter:"S",fontCmd:"mathbf"},ğ“:{letter:"T",fontCmd:"mathbf"},ğ”:{letter:"U",fontCmd:"mathbf"},ğ•:{letter:"V",fontCmd:"mathbf"},ğ–:{letter:"W",fontCmd:"mathbf"},ğ—:{letter:"X",fontCmd:"mathbf"},ğ†:{letter:"X",fontCmd:"mathbf"},ğ˜:{letter:"Y",fontCmd:"mathbf"},ğ™:{letter:"Z",fontCmd:"mathbf"},"ğŸ":{letter:"0",fontCmd:"mathbf"},"ğŸ":{letter:"1",fontCmd:"mathbf"},"ğŸ":{letter:"2",fontCmd:"mathbf"},"ğŸ‘":{letter:"3",fontCmd:"mathbf"},"ğŸ’":{letter:"4",fontCmd:"mathbf"},"ğŸ“":{letter:"5",fontCmd:"mathbf"},"ğŸ”":{letter:"6",fontCmd:"mathbf"},"ğŸ•":{letter:"7",fontCmd:"mathbf"},"ğŸ–":{letter:"8",fontCmd:"mathbf"},"ğŸ—":{letter:"9",fontCmd:"mathbf"},ğ´:{letter:"A",fontCmd:"mathit"},ğµ:{letter:"B",fontCmd:"mathit"},ğ¶:{letter:"C",fontCmd:"mathit"},ğ·:{letter:"D",fontCmd:"mathit"},ğ¸:{letter:"E",fontCmd:"mathit"},ğ¹:{letter:"F",fontCmd:"mathit"},ğº:{letter:"G",fontCmd:"mathit"},ğ»:{letter:"H",fontCmd:"mathit"},ğ¼:{letter:"I",fontCmd:"mathit"},Î™:{letter:"I",fontCmd:"mathit"},ğ½:{letter:"J",fontCmd:"mathit"},ğ¾:{letter:"K",fontCmd:"mathit"},ğ¿:{letter:"L",fontCmd:"mathit"},ğ‘€:{letter:"M",fontCmd:"mathit"},ğ‘:{letter:"N",fontCmd:"mathit"},ğ‘‚:{letter:"O",fontCmd:"mathit"},ğ‘ƒ:{letter:"P",fontCmd:"mathit"},ğ‘„:{letter:"Q",fontCmd:"mathit"},ğ‘…:{letter:"R",fontCmd:"mathit"},ğ‘†:{letter:"S",fontCmd:"mathit"},ğ‘‡:{letter:"T",fontCmd:"mathit"},ğ‘ˆ:{letter:"U",fontCmd:"mathit"},ğ‘‰:{letter:"V",fontCmd:"mathit"},ğ‘Š:{letter:"W",fontCmd:"mathit"},ğ‘‹:{letter:"X",fontCmd:"mathit"},ğ‘Œ:{letter:"Y",fontCmd:"mathit"},ğ‘:{letter:"Z",fontCmd:"mathit"},ğ”¸:{letter:"A",fontCmd:"mathbb"},ğ”¹:{letter:"B",fontCmd:"mathbb"},â„‚:{letter:"C",fontCmd:"mathbb"},ğ”»:{letter:"D",fontCmd:"mathbb"},ğ”¼:{letter:"E",fontCmd:"mathbb"},ğ”½:{letter:"F",fontCmd:"mathbb"},ğ”¾:{letter:"G",fontCmd:"mathbb"},â„:{letter:"H",fontCmd:"mathbb"},ğ•€:{letter:"I",fontCmd:"mathbb"},ğ•:{letter:"J",fontCmd:"mathbb"},ğ•‚:{letter:"K",fontCmd:"mathbb"},ğ•ƒ:{letter:"L",fontCmd:"mathbb"},ğ•„:{letter:"M",fontCmd:"mathbb"},â„•:{letter:"N",fontCmd:"mathbb"},ğ•†:{letter:"O",fontCmd:"mathbb"},â„™:{letter:"P",fontCmd:"mathbb"},â„š:{letter:"Q",fontCmd:"mathbb"},â„:{letter:"R",fontCmd:"mathbb"},ğ•Š:{letter:"S",fontCmd:"mathbb"},ğ•‹:{letter:"T",fontCmd:"mathbb"},ğ•Œ:{letter:"U",fontCmd:"mathbb"},ğ•:{letter:"V",fontCmd:"mathbb"},ğ•:{letter:"W",fontCmd:"mathbb"},ğ•:{letter:"X",fontCmd:"mathbb"},ğ•:{letter:"Y",fontCmd:"mathbb"},â„¤:{letter:"Z",fontCmd:"mathbb"},"ğŸ˜":{letter:"0",fontCmd:"mathbb"},"ğŸ™":{letter:"1",fontCmd:"mathbb"},"ğŸš":{letter:"2",fontCmd:"mathbb"},"ğŸ›":{letter:"3",fontCmd:"mathbb"},"ğŸœ":{letter:"4",fontCmd:"mathbb"},"ğŸ":{letter:"5",fontCmd:"mathbb"},"ğŸ":{letter:"6",fontCmd:"mathbb"},"ğŸŸ":{letter:"7",fontCmd:"mathbb"},"ğŸ ":{letter:"8",fontCmd:"mathbb"},"ğŸ¡":{letter:"9",fontCmd:"mathbb"},ğ’œ:{letter:"A",fontCmd:"mathcal"},ğ“:{letter:"A",fontCmd:"mathcal"},â„¬:{letter:"B",fontCmd:"mathcal"},ğ’:{letter:"C",fontCmd:"mathcal"},ğ’Ÿ:{letter:"D",fontCmd:"mathcal"},ğ““:{letter:"D",fontCmd:"mathcal"},â„°:{letter:"E",fontCmd:"mathcal"},â„±:{letter:"F",fontCmd:"mathcal"},ğ“•:{letter:"F",fontCmd:"mathcal"},ğ’¢:{letter:"G",fontCmd:"mathcal"},â„‹:{letter:"H",fontCmd:"mathcal"},â„:{letter:"I",fontCmd:"mathcal"},ğ’¥:{letter:"J",fontCmd:"mathcal"},ğ’¦:{letter:"K",fontCmd:"mathcal"},â„’:{letter:"L",fontCmd:"mathcal"},ğ“›:{letter:"L",fontCmd:"mathcal"},â„³:{letter:"M",fontCmd:"mathcal"},ğ’©:{letter:"N",fontCmd:"mathcal"},ğ’ª:{letter:"O",fontCmd:"mathcal"},ğ“:{letter:"O",fontCmd:"mathcal"},ğ’«:{letter:"P",fontCmd:"mathcal"},ğ’¬:{letter:"Q",fontCmd:"mathcal"},â„›:{letter:"R",fontCmd:"mathcal"},ğ•½:{letter:"R",fontCmd:"mathcal"},"â„Ÿ":{letter:"R",fontCmd:"mathcal"},ğ’®:{letter:"S",fontCmd:"mathcal"},ğ’¯:{letter:"T",fontCmd:"mathcal"},ğ’°:{letter:"U",fontCmd:"mathcal"},ğ’±:{letter:"V",fontCmd:"mathcal"},ğ’²:{letter:"W",fontCmd:"mathcal"},ğ’³:{letter:"X",fontCmd:"mathcal"},ğ’´:{letter:"Y",fontCmd:"mathcal"},ğ’µ:{letter:"Z",fontCmd:"mathcal"},ğ”„:{letter:"A",fontCmd:"mathfrak"},ğ”…:{letter:"B",fontCmd:"mathfrak"},â„­:{letter:"C",fontCmd:"mathfrak"},ğ”‡:{letter:"D",fontCmd:"mathfrak"},ğ”ˆ:{letter:"E",fontCmd:"mathfrak"},ğ”‰:{letter:"F",fontCmd:"mathfrak"},ğ”Š:{letter:"G",fontCmd:"mathfrak"},â„Œ:{letter:"H",fontCmd:"mathfrak"},â„‘:{letter:"I",fontCmd:"mathfrak"},ğ”:{letter:"J",fontCmd:"mathfrak"},ğ”:{letter:"K",fontCmd:"mathfrak"},ğ”:{letter:"L",fontCmd:"mathfrak"},ğ”:{letter:"M",fontCmd:"mathfrak"},ğ”‘:{letter:"N",fontCmd:"mathfrak"},ğ”’:{letter:"O",fontCmd:"mathfrak"},ğ”“:{letter:"P",fontCmd:"mathfrak"},ğ””:{letter:"Q",fontCmd:"mathfrak"},â„œ:{letter:"R",fontCmd:"mathfrak"},ğ”–:{letter:"S",fontCmd:"mathfrak"},ğ”—:{letter:"T",fontCmd:"mathfrak"},ğ”˜:{letter:"U",fontCmd:"mathfrak"},ğ”™:{letter:"V",fontCmd:"mathfrak"},ğ”š:{letter:"W",fontCmd:"mathfrak"},ğ”›:{letter:"X",fontCmd:"mathfrak"},ğ”œ:{letter:"Y",fontCmd:"mathfrak"},â„¨:{letter:"Z",fontCmd:"mathfrak"},ğ– :{letter:"A",fontCmd:"mathsf"},Î‘:{letter:"A",fontCmd:"mathsf"},ğ–¡:{letter:"B",fontCmd:"mathsf"},Î’:{letter:"B",fontCmd:"mathsf"},ğ–¢:{letter:"C",fontCmd:"mathsf"},ğ–£:{letter:"D",fontCmd:"mathsf"},ğ–¤:{letter:"E",fontCmd:"mathsf"},ğ–¥:{letter:"F",fontCmd:"mathsf"},ğ–¦:{letter:"G",fontCmd:"mathsf"},ğ–§:{letter:"H",fontCmd:"mathsf"},ğ–¨:{letter:"I",fontCmd:"mathsf"},ğ–©:{letter:"J",fontCmd:"mathsf"},È·:{letter:"J",fontCmd:"mathsf"},ğ–ª:{letter:"K",fontCmd:"mathsf"},Îš:{letter:"K",fontCmd:"mathsf"},ğ–«:{letter:"L",fontCmd:"mathsf"},ğ–¬:{letter:"M",fontCmd:"mathsf"},ğ–­:{letter:"N",fontCmd:"mathsf"},ğ–®:{letter:"O",fontCmd:"mathsf"},ğ–¯:{letter:"P",fontCmd:"mathsf"},ğ–°:{letter:"Q",fontCmd:"mathsf"},ğ–±:{letter:"R",fontCmd:"mathsf"},ğ–²:{letter:"S",fontCmd:"mathsf"},ğ–³:{letter:"T",fontCmd:"mathsf"},ğ–´:{letter:"U",fontCmd:"mathsf"},ğ–µ:{letter:"V",fontCmd:"mathsf"},ğ–¶:{letter:"W",fontCmd:"mathsf"},ğ–·:{letter:"X",fontCmd:"mathsf"},Î§:{letter:"X",fontCmd:"mathsf"},ğ–¸:{letter:"Y",fontCmd:"mathsf"},ğ–¹:{letter:"Z",fontCmd:"mathsf"},ğš¨:{letter:"A",fontCmd:"mathtt"},ğš©:{letter:"B",fontCmd:"mathtt"},ğšª:{letter:"\\Gamma",fontCmd:"mathtt"},ğš«:{letter:"\\Delta",fontCmd:"mathtt"},ğš¬:{letter:"E",fontCmd:"mathtt"},ğš­:{letter:"F",fontCmd:"mathtt"},ğš®:{letter:"G",fontCmd:"mathtt"},ğš¯:{letter:"\\Theta",fontCmd:"mathtt"},ğš°:{letter:"I",fontCmd:"mathtt"},ğš±:{letter:"J",fontCmd:"mathtt"},ğš²:{letter:"\\Lambda",fontCmd:"mathtt"},ğš³:{letter:"L",fontCmd:"mathtt"},ğš´:{letter:"M",fontCmd:"mathtt"},ğšµ:{letter:"\\Pi",fontCmd:"mathtt"},ğš¶:{letter:"O",fontCmd:"mathtt"},ğš·:{letter:"\\Pi",fontCmd:"mathtt"},ğš¸:{letter:"Q",fontCmd:"mathtt"},ğš¹:{letter:"R",fontCmd:"mathtt"},ğšº:{letter:"S",fontCmd:"mathtt"},ğš»:{letter:"T",fontCmd:"mathtt"},ğš¼:{letter:"U",fontCmd:"mathtt"},ğš½:{letter:"\\Phi",fontCmd:"mathtt"},ğš¾:{letter:"W",fontCmd:"mathtt"},ğš¿:{letter:"\\Psi",fontCmd:"mathtt"},ğ›€:{letter:"\\Omega",fontCmd:"mathtt"}}}},t={};function r(a){var n=t[a];if(void 0!==n)return n.exports;var o=t[a]={exports:{}};return e[a].call(o.exports,o,o.exports,r),o.exports}var a={};return(()=>{"use strict";var e=a;Object.defineProperty(e,"__esModule",{value:!0}),e.MathMLToLaTeX=void 0;var t=r(8672);Object.defineProperty(e,"MathMLToLaTeX",{enumerable:!0,get:function(){return t.MathMLToLaTeX}})})(),a})()));
//# sourceMappingURL=bundle.min.js.map

/***/ }),

/***/ 608:
/*!*************************!*\
  !*** ./src/metadata.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetadataExtractor = void 0;
class MetadataExtractor {
    static extract(doc, schemaOrgData) {
        var _a, _b;
        let domain = '';
        let url = '';
        try {
            // Try to get URL from document location
            url = ((_a = doc.location) === null || _a === void 0 ? void 0 : _a.href) || '';
            // If no URL from location, try other sources
            if (!url) {
                url = this.getMetaContent(doc, "property", "og:url") ||
                    this.getMetaContent(doc, "property", "twitter:url") ||
                    this.getSchemaProperty(doc, schemaOrgData, 'url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntityOfPage.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntity.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'WebSite.url') ||
                    ((_b = doc.querySelector('link[rel="canonical"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('href')) || '';
            }
            if (url) {
                domain = new URL(url).hostname.replace(/^www\./, '');
            }
        }
        catch (e) {
            // If URL parsing fails, try to get from base tag
            const baseTag = doc.querySelector('base[href]');
            if (baseTag) {
                try {
                    url = baseTag.getAttribute('href') || '';
                    domain = new URL(url).hostname.replace(/^www\./, '');
                }
                catch (e) {
                    console.warn('Failed to parse base URL:', e);
                }
            }
        }
        return {
            title: this.getTitle(doc, schemaOrgData),
            description: this.getDescription(doc, schemaOrgData),
            domain,
            favicon: this.getFavicon(doc, url),
            image: this.getImage(doc, schemaOrgData),
            published: this.getPublished(doc, schemaOrgData),
            author: this.getAuthor(doc, schemaOrgData),
            site: this.getSite(doc, schemaOrgData),
            schemaOrgData,
            wordCount: 0,
            parseTime: 0
        };
    }
    static getAuthor(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "sailthru.author") ||
            this.getSchemaProperty(doc, schemaOrgData, 'author.name') ||
            this.getMetaContent(doc, "property", "author") ||
            this.getMetaContent(doc, "name", "byl") ||
            this.getMetaContent(doc, "name", "author") ||
            this.getMetaContent(doc, "name", "authorList") ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "twitter:creator") ||
            this.getMetaContent(doc, "name", "application-name") ||
            '');
    }
    static getSite(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'WebSite.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "application-name") ||
            this.getAuthor(doc, schemaOrgData) ||
            '');
    }
    static getTitle(doc, schemaOrgData) {
        var _a, _b;
        const rawTitle = (this.getMetaContent(doc, "property", "og:title") ||
            this.getMetaContent(doc, "name", "twitter:title") ||
            this.getSchemaProperty(doc, schemaOrgData, 'headline') ||
            this.getMetaContent(doc, "name", "title") ||
            this.getMetaContent(doc, "name", "sailthru.title") ||
            ((_b = (_a = doc.querySelector('title')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) ||
            '');
        return this.cleanTitle(rawTitle, this.getSite(doc, schemaOrgData));
    }
    static cleanTitle(title, siteName) {
        if (!title || !siteName)
            return title;
        // Remove site name if it exists
        const siteNameEscaped = siteName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const patterns = [
            `\\s*[\\|\\-â€“â€”]\\s*${siteNameEscaped}\\s*$`, // Title | Site Name
            `^\\s*${siteNameEscaped}\\s*[\\|\\-â€“â€”]\\s*`, // Site Name | Title
        ];
        for (const pattern of patterns) {
            const regex = new RegExp(pattern, 'i');
            if (regex.test(title)) {
                title = title.replace(regex, '');
                break;
            }
        }
        return title.trim();
    }
    static getDescription(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "description") ||
            this.getMetaContent(doc, "property", "description") ||
            this.getMetaContent(doc, "property", "og:description") ||
            this.getSchemaProperty(doc, schemaOrgData, 'description') ||
            this.getMetaContent(doc, "name", "twitter:description") ||
            this.getMetaContent(doc, "name", "sailthru.description") ||
            '');
    }
    static getImage(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "property", "og:image") ||
            this.getMetaContent(doc, "name", "twitter:image") ||
            this.getSchemaProperty(doc, schemaOrgData, 'image.url') ||
            this.getMetaContent(doc, "name", "sailthru.image.full") ||
            '');
    }
    static getFavicon(doc, baseUrl) {
        var _a, _b;
        const iconFromMeta = this.getMetaContent(doc, "property", "og:image:favicon");
        if (iconFromMeta)
            return iconFromMeta;
        const iconLink = (_a = doc.querySelector("link[rel='icon']")) === null || _a === void 0 ? void 0 : _a.getAttribute("href");
        if (iconLink)
            return iconLink;
        const shortcutLink = (_b = doc.querySelector("link[rel='shortcut icon']")) === null || _b === void 0 ? void 0 : _b.getAttribute("href");
        if (shortcutLink)
            return shortcutLink;
        // Only try to construct favicon URL if we have a valid base URL
        if (baseUrl) {
            try {
                return new URL("/favicon.ico", baseUrl).href;
            }
            catch (e) {
                console.warn('Failed to construct favicon URL:', e);
            }
        }
        return '';
    }
    static getPublished(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'datePublished') ||
            this.getMetaContent(doc, "name", "publishDate") ||
            this.getMetaContent(doc, "property", "article:published_time") ||
            this.getTimeElement(doc) ||
            this.getMetaContent(doc, "name", "sailthru.date") ||
            '');
    }
    static getMetaContent(doc, attr, value) {
        var _a, _b;
        const selector = `meta[${attr}]`;
        const element = Array.from(doc.querySelectorAll(selector))
            .find(el => { var _a; return ((_a = el.getAttribute(attr)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === value.toLowerCase(); });
        const content = element ? (_b = (_a = element.getAttribute("content")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : "" : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static getTimeElement(doc) {
        var _a, _b, _c, _d;
        const selector = `time`;
        const element = Array.from(doc.querySelectorAll(selector))[0];
        const content = element ? ((_d = (_b = (_a = element.getAttribute("datetime")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.trim()) !== null && _d !== void 0 ? _d : "") : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static decodeHTMLEntities(text, doc) {
        const textarea = doc.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }
    static getSchemaProperty(doc, schemaOrgData, property, defaultValue = '') {
        if (!schemaOrgData)
            return defaultValue;
        const searchSchema = (data, props, fullPath, isExactMatch = true) => {
            if (typeof data === 'string') {
                return props.length === 0 ? [data] : [];
            }
            if (!data || typeof data !== 'object') {
                return [];
            }
            if (Array.isArray(data)) {
                const currentProp = props[0];
                if (/^\[\d+\]$/.test(currentProp)) {
                    const index = parseInt(currentProp.slice(1, -1));
                    if (data[index]) {
                        return searchSchema(data[index], props.slice(1), fullPath, isExactMatch);
                    }
                    return [];
                }
                if (props.length === 0 && data.every(item => typeof item === 'string' || typeof item === 'number')) {
                    return data.map(String);
                }
                return data.flatMap(item => searchSchema(item, props, fullPath, isExactMatch));
            }
            const [currentProp, ...remainingProps] = props;
            if (!currentProp) {
                if (typeof data === 'string')
                    return [data];
                if (typeof data === 'object' && data.name) {
                    return [data.name];
                }
                return [];
            }
            if (data.hasOwnProperty(currentProp)) {
                return searchSchema(data[currentProp], remainingProps, fullPath ? `${fullPath}.${currentProp}` : currentProp, true);
            }
            if (!isExactMatch) {
                const nestedResults = [];
                for (const key in data) {
                    if (typeof data[key] === 'object') {
                        const results = searchSchema(data[key], props, fullPath ? `${fullPath}.${key}` : key, false);
                        nestedResults.push(...results);
                    }
                }
                if (nestedResults.length > 0) {
                    return nestedResults;
                }
            }
            return [];
        };
        try {
            let results = searchSchema(schemaOrgData, property.split('.'), '', true);
            if (results.length === 0) {
                results = searchSchema(schemaOrgData, property.split('.'), '', false);
            }
            const result = results.length > 0 ? results.filter(Boolean).join(', ') : defaultValue;
            return this.decodeHTMLEntities(result, doc);
        }
        catch (error) {
            console.error(`Error in getSchemaProperty for ${property}:`, error);
            return defaultValue;
        }
    }
    static extractSchemaOrgData(doc) {
        const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
        const schemaData = [];
        schemaScripts.forEach(script => {
            let jsonContent = script.textContent || '';
            try {
                jsonContent = jsonContent
                    .replace(/\/\*[\s\S]*?\*\/|^\s*\/\/.*$/gm, '')
                    .replace(/^\s*<!\[CDATA\[([\s\S]*?)\]\]>\s*$/, '$1')
                    .replace(/^\s*(\*\/|\/\*)\s*|\s*(\*\/|\/\*)\s*$/g, '')
                    .trim();
                const jsonData = JSON.parse(jsonContent);
                if (jsonData['@graph'] && Array.isArray(jsonData['@graph'])) {
                    schemaData.push(...jsonData['@graph']);
                }
                else {
                    schemaData.push(jsonData);
                }
            }
            catch (error) {
                console.error('Error parsing schema.org data:', error);
                console.error('Problematic JSON content:', jsonContent);
            }
        });
        return schemaData;
    }
}
exports.MetadataExtractor = MetadataExtractor;


/***/ }),

/***/ 628:
/*!*************************!*\
  !*** ./src/defuddle.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
const metadata_1 = __webpack_require__(/*! ./metadata */ 608);
const constants_1 = __webpack_require__(/*! ./constants */ 640);
const math_1 = __webpack_require__(/*! ./math */ 315);
const ELEMENT_STANDARDIZATION_RULES = [
    // Math elements
    ...math_1.mathStandardizationRules,
    // Code blocks
    {
        selector: 'pre',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Function to get language from class
            const getLanguageFromClass = (element) => {
                // Check data-lang attribute first
                const dataLang = element.getAttribute('data-lang');
                if (dataLang) {
                    return dataLang.toLowerCase();
                }
                // Define language patterns
                const languagePatterns = [
                    /^language-(\w+)$/, // language-javascript
                    /^lang-(\w+)$/, // lang-javascript
                    /^(\w+)-code$/, // javascript-code
                    /^code-(\w+)$/, // code-javascript
                    /^syntax-(\w+)$/, // syntax-javascript
                    /^code-snippet__(\w+)$/, // code-snippet__javascript
                    /^highlight-(\w+)$/, // highlight-javascript
                    /^(\w+)-snippet$/ // javascript-snippet
                ];
                // Then check the class attribute for patterns
                if (element.className && typeof element.className === 'string') {
                    for (const pattern of languagePatterns) {
                        const match = element.className.toLowerCase().match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                    // Then check for supported language
                    if (constants_1.SUPPORTED_LANGUAGES.has(element.className.toLowerCase())) {
                        return element.className.toLowerCase();
                    }
                }
                const classNames = Array.from(element.classList);
                for (const className of classNames) {
                    // Check patterns first
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                }
                // Only check bare language names if no patterns were found
                for (const className of classNames) {
                    if (constants_1.SUPPORTED_LANGUAGES.has(className.toLowerCase())) {
                        return className.toLowerCase();
                    }
                }
                return '';
            };
            // Try to get the language from the element and its ancestors
            let language = '';
            let currentElement = el;
            while (currentElement && !language) {
                language = getLanguageFromClass(currentElement);
                // Also check for code elements within the current element
                if (!language && currentElement.querySelector('code')) {
                    language = getLanguageFromClass(currentElement.querySelector('code'));
                }
                currentElement = currentElement.parentElement;
            }
            // Function to recursively extract text content while preserving structure
            const extractStructuredText = (element) => {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent || '';
                }
                let text = '';
                if (element instanceof HTMLElement) {
                    // Handle line breaks
                    if (element.tagName === 'BR') {
                        return '\n';
                    }
                    // Handle code elements and their children
                    element.childNodes.forEach(child => {
                        text += extractStructuredText(child);
                    });
                    // Add newline after each code element
                    if (element.tagName === 'CODE') {
                        text += '\n';
                    }
                }
                return text;
            };
            // Extract all text content
            let codeContent = extractStructuredText(el);
            // Clean up the content
            codeContent = codeContent
                // Remove any extra newlines at the start
                .replace(/^\n+/, '')
                // Remove any extra newlines at the end
                .replace(/\n+$/, '')
                // Replace multiple consecutive newlines with a single newline
                .replace(/\n{3,}/g, '\n\n');
            // Create new pre element
            const newPre = document.createElement('pre');
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    newPre.setAttribute(attr.name, attr.value);
                }
            });
            // Create code element
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    },
    // Simplify headings by removing internal navigation elements
    {
        selector: 'h1, h2, h3, h4, h5, h6',
        element: 'keep',
        transform: (el) => {
            var _a, _b, _c, _d, _e;
            // If heading only contains a single anchor with internal link
            if (el.children.length === 1 &&
                ((_a = el.firstElementChild) === null || _a === void 0 ? void 0 : _a.tagName) === 'A' &&
                (((_b = el.firstElementChild.getAttribute('href')) === null || _b === void 0 ? void 0 : _b.includes('#')) ||
                    ((_c = el.firstElementChild.getAttribute('href')) === null || _c === void 0 ? void 0 : _c.startsWith('#')))) {
                // Create new heading of same level
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes from original heading
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                return newHeading;
            }
            // If heading contains navigation buttons or other utility elements
            const buttons = el.querySelectorAll('button');
            if (buttons.length > 0) {
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_e = el.textContent) === null || _e === void 0 ? void 0 : _e.trim()) || '';
                return newHeading;
            }
            return el;
        }
    },
    // Convert divs with paragraph role to actual paragraphs
    {
        selector: 'div[data-testid^="paragraph"], div[role="paragraph"]',
        element: 'p',
        transform: (el) => {
            const p = document.createElement('p');
            // Copy innerHTML
            p.innerHTML = el.innerHTML;
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    p.setAttribute(attr.name, attr.value);
                }
            });
            return p;
        }
    },
    // Convert divs with list roles to actual lists
    {
        selector: 'div[role="list"]',
        element: 'ul',
        // Custom handler for list type detection and transformation
        transform: (el) => {
            var _a;
            // First determine if this is an ordered list
            const firstItem = el.querySelector('div[role="listitem"] .label');
            const label = ((_a = firstItem === null || firstItem === void 0 ? void 0 : firstItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
            const isOrdered = label.match(/^\d+\)/);
            // Create the appropriate list type
            const list = document.createElement(isOrdered ? 'ol' : 'ul');
            // Process each list item
            const items = el.querySelectorAll('div[role="listitem"]');
            items.forEach(item => {
                const li = document.createElement('li');
                const content = item.querySelector('.content');
                if (content) {
                    // Convert any paragraph divs inside content
                    const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
                    paragraphDivs.forEach(div => {
                        const p = document.createElement('p');
                        p.innerHTML = div.innerHTML;
                        div.replaceWith(p);
                    });
                    // Convert any nested lists recursively
                    const nestedLists = content.querySelectorAll('div[role="list"]');
                    nestedLists.forEach(nestedList => {
                        var _a;
                        const firstNestedItem = nestedList.querySelector('div[role="listitem"] .label');
                        const nestedLabel = ((_a = firstNestedItem === null || firstNestedItem === void 0 ? void 0 : firstNestedItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        const isNestedOrdered = nestedLabel.match(/^\d+\)/);
                        const newNestedList = document.createElement(isNestedOrdered ? 'ol' : 'ul');
                        // Process nested items
                        const nestedItems = nestedList.querySelectorAll('div[role="listitem"]');
                        nestedItems.forEach(nestedItem => {
                            const nestedLi = document.createElement('li');
                            const nestedContent = nestedItem.querySelector('.content');
                            if (nestedContent) {
                                // Convert paragraph divs in nested items
                                const nestedParagraphs = nestedContent.querySelectorAll('div[role="paragraph"]');
                                nestedParagraphs.forEach(div => {
                                    const p = document.createElement('p');
                                    p.innerHTML = div.innerHTML;
                                    div.replaceWith(p);
                                });
                                nestedLi.innerHTML = nestedContent.innerHTML;
                            }
                            newNestedList.appendChild(nestedLi);
                        });
                        nestedList.replaceWith(newNestedList);
                    });
                    li.innerHTML = content.innerHTML;
                }
                list.appendChild(li);
            });
            return list;
        }
    },
    {
        selector: 'div[role="listitem"]',
        element: 'li',
        // Custom handler for list item content
        transform: (el) => {
            const content = el.querySelector('.content');
            if (!content)
                return el;
            // Convert any paragraph divs inside content
            const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
            paragraphDivs.forEach(div => {
                const p = document.createElement('p');
                p.innerHTML = div.innerHTML;
                div.replaceWith(p);
            });
            return content;
        }
    },
    // Code blocks with syntax highlighting
    {
        selector: '.wp-block-syntaxhighlighter-code, .syntaxhighlighter, .highlight, .highlight-source, .wp-block-code, pre[class*="language-"], pre[class*="brush:"]',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Create new pre element
            const newPre = document.createElement('pre');
            // Try to detect language
            let language = '';
            // Check for WordPress syntax highlighter specific format
            const syntaxEl = el.querySelector('.syntaxhighlighter');
            if (syntaxEl) {
                // Get language from syntaxhighlighter class
                const classes = Array.from(syntaxEl.classList);
                const langClass = classes.find(c => !['syntaxhighlighter', 'nogutter'].includes(c));
                if (langClass && constants_1.SUPPORTED_LANGUAGES.has(langClass.toLowerCase())) {
                    language = langClass.toLowerCase();
                }
            }
            // If no language found yet, check other common patterns
            if (!language) {
                const classNames = Array.from(el.classList);
                const languagePatterns = [
                    /(?:^|\s)(?:language|lang|brush|syntax)-(\w+)(?:\s|$)/i,
                    /(?:^|\s)(\w+)(?:\s|$)/i
                ];
                for (const className of classNames) {
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match && match[1] && constants_1.SUPPORTED_LANGUAGES.has(match[1].toLowerCase())) {
                            language = match[1].toLowerCase();
                            break;
                        }
                    }
                    if (language)
                        break;
                }
            }
            // Extract code content, handling various formats
            let codeContent = '';
            // Handle WordPress syntax highlighter table format
            const codeContainer = el.querySelector('.syntaxhighlighter table .code .container');
            if (codeContainer) {
                // Process each line
                const lines = Array.from(codeContainer.children);
                codeContent = lines
                    .map(line => {
                    // Get all code elements in this line
                    const codeParts = Array.from(line.querySelectorAll('code'))
                        .map(code => {
                        // Get the text content, preserving spaces
                        let text = code.textContent || '';
                        // If this is a 'spaces' class element, convert to actual spaces
                        if (code.classList.contains('spaces')) {
                            text = ' '.repeat(text.length);
                        }
                        return text;
                    })
                        .join('');
                    return codeParts || line.textContent || '';
                })
                    .join('\n');
            }
            else {
                // Handle WordPress syntax highlighter non-table format
                const codeLines = el.querySelectorAll('.code .line');
                if (codeLines.length > 0) {
                    codeContent = Array.from(codeLines)
                        .map(line => {
                        const codeParts = Array.from(line.querySelectorAll('code'))
                            .map(code => code.textContent || '')
                            .join('');
                        return codeParts || line.textContent || '';
                    })
                        .join('\n');
                }
                else {
                    // Fallback to regular text content
                    codeContent = el.textContent || '';
                }
            }
            // Clean up the content
            codeContent = codeContent
                .replace(/^\s+|\s+$/g, '') // Trim start/end whitespace
                .replace(/\t/g, '    ') // Convert tabs to spaces
                .replace(/\n{3,}/g, '\n\n') // Normalize multiple newlines
                .replace(/\u00a0/g, ' '); // Replace non-breaking spaces with regular spaces
            // Create code element with language class if detected
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    }
];
class Defuddle {
    /**
     * Create a new Defuddle instance
     * @param doc - The document to parse
     * @param options - Options for parsing
     */
    constructor(doc, options = {}) {
        this.doc = doc;
        this.options = options;
        this.debug = options.debug || false;
    }
    /**
     * Parse the document and extract its main content
     */
    parse() {
        const startTime = performance.now();
        // Extract metadata first since we'll need it in multiple places
        const schemaOrgData = metadata_1.MetadataExtractor.extractSchemaOrgData(this.doc);
        const metadata = metadata_1.MetadataExtractor.extract(this.doc, schemaOrgData);
        try {
            // Evaluate styles and sizes on original document
            const mobileStyles = this._evaluateMediaQueries(this.doc);
            // Check for small images in original document, excluding lazy-loaded ones
            const smallImages = this.findSmallImages(this.doc);
            // Clone document
            const clone = this.doc.cloneNode(true);
            // Apply mobile style to clone
            this.applyMobileStyles(clone, mobileStyles);
            // Find main content
            const mainContent = this.findMainContent(clone);
            if (!mainContent) {
                const endTime = performance.now();
                return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
            }
            // Remove small images identified from original document
            this.removeSmallImages(clone, smallImages);
            // Perform other destructive operations on the clone
            this.removeHiddenElements(clone);
            this.removeClutter(clone);
            // Clean up the main content
            this.cleanContent(mainContent, metadata);
            const content = mainContent ? mainContent.outerHTML : this.doc.body.innerHTML;
            const endTime = performance.now();
            return Object.assign(Object.assign({ content }, metadata), { wordCount: this.countWords(content), parseTime: Math.round(endTime - startTime) });
        }
        catch (error) {
            console.error('Defuddle', 'Error processing document:', error);
            const endTime = performance.now();
            return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
        }
    }
    countWords(content) {
        // Create a temporary div to parse HTML content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        // Get text content, removing extra whitespace
        const text = tempDiv.textContent || '';
        const words = text
            .trim()
            .replace(/\s+/g, ' ') // Replace multiple spaces with single space
            .split(' ')
            .filter(word => word.length > 0); // Filter out empty strings
        return words.length;
    }
    // Make all other methods private by removing the static keyword and using private
    _log(...args) {
        if (this.debug) {
            console.log('Defuddle:', ...args);
        }
    }
    _evaluateMediaQueries(doc) {
        const mobileStyles = [];
        const maxWidthRegex = /max-width[^:]*:\s*(\d+)/;
        try {
            // Get all styles, including inline styles
            const sheets = Array.from(doc.styleSheets).filter(sheet => {
                try {
                    // Access rules once to check validity
                    sheet.cssRules;
                    return true;
                }
                catch (e) {
                    // Expected error for cross-origin stylesheets
                    if (e instanceof DOMException && e.name === 'SecurityError') {
                        return false;
                    }
                    throw e;
                }
            });
            // Process all sheets in a single pass
            const mediaRules = sheets.flatMap(sheet => {
                try {
                    return Array.from(sheet.cssRules)
                        .filter((rule) => rule instanceof CSSMediaRule &&
                        rule.conditionText.includes('max-width'));
                }
                catch (e) {
                    if (this.debug) {
                        console.warn('Defuddle: Failed to process stylesheet:', e);
                    }
                    return [];
                }
            });
            // Process all media rules in a single pass
            mediaRules.forEach(rule => {
                const match = rule.conditionText.match(maxWidthRegex);
                if (match) {
                    const maxWidth = parseInt(match[1]);
                    if (constants_1.MOBILE_WIDTH <= maxWidth) {
                        // Batch process all style rules
                        const styleRules = Array.from(rule.cssRules)
                            .filter((r) => r instanceof CSSStyleRule);
                        styleRules.forEach(cssRule => {
                            try {
                                mobileStyles.push({
                                    selector: cssRule.selectorText,
                                    styles: cssRule.style.cssText
                                });
                            }
                            catch (e) {
                                if (this.debug) {
                                    console.warn('Defuddle: Failed to process CSS rule:', e);
                                }
                            }
                        });
                    }
                }
            });
        }
        catch (e) {
            console.error('Defuddle: Error evaluating media queries:', e);
        }
        return mobileStyles;
    }
    applyMobileStyles(doc, mobileStyles) {
        let appliedCount = 0;
        mobileStyles.forEach(({ selector, styles }) => {
            try {
                const elements = doc.querySelectorAll(selector);
                elements.forEach(element => {
                    element.setAttribute('style', (element.getAttribute('style') || '') + styles);
                    appliedCount++;
                });
            }
            catch (e) {
                console.error('Defuddle', 'Error applying styles for selector:', selector, e);
            }
        });
    }
    removeHiddenElements(doc) {
        let count = 0;
        const elementsToRemove = new Set();
        // First pass: Get all elements matching hidden selectors
        const hiddenElements = doc.querySelectorAll(constants_1.HIDDEN_ELEMENT_SELECTORS);
        hiddenElements.forEach(el => elementsToRemove.add(el));
        count += hiddenElements.length;
        // Second pass: Use TreeWalker for efficient traversal
        const treeWalker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, {
            acceptNode: (node) => {
                // Skip elements already marked for removal
                if (elementsToRemove.has(node)) {
                    return NodeFilter.FILTER_REJECT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        // Batch style computations
        const elements = [];
        let currentNode;
        while (currentNode = treeWalker.nextNode()) {
            elements.push(currentNode);
        }
        // Process styles in batches to minimize layout thrashing
        const BATCH_SIZE = 100;
        for (let i = 0; i < elements.length; i += BATCH_SIZE) {
            const batch = elements.slice(i, i + BATCH_SIZE);
            // Read phase - gather all computedStyles
            const styles = batch.map(el => window.getComputedStyle(el));
            // Write phase - mark elements for removal
            batch.forEach((element, index) => {
                const computedStyle = styles[index];
                if (computedStyle.display === 'none' ||
                    computedStyle.visibility === 'hidden' ||
                    computedStyle.opacity === '0') {
                    elementsToRemove.add(element);
                    count++;
                }
            });
        }
        // Final pass: Batch remove all hidden elements
        elementsToRemove.forEach(el => el.remove());
        this._log('Removed hidden elements:', count);
    }
    removeClutter(doc) {
        const startTime = performance.now();
        let exactSelectorCount = 0;
        let partialSelectorCount = 0;
        // Track all elements to be removed
        const elementsToRemove = new Set();
        // First collect elements matching exact selectors
        const exactElements = doc.querySelectorAll(constants_1.EXACT_SELECTORS.join(','));
        exactElements.forEach(el => {
            if (el === null || el === void 0 ? void 0 : el.parentNode) {
                elementsToRemove.add(el);
                exactSelectorCount++;
            }
        });
        // Pre-compile regexes and combine into a single regex for better performance
        const combinedPattern = constants_1.PARTIAL_SELECTORS.join('|');
        const partialRegex = new RegExp(combinedPattern, 'i');
        // Create an efficient attribute selector for elements we care about
        const attributeSelector = '[class],[id],[data-testid],[data-qa],[data-cy]';
        const allElements = doc.querySelectorAll(attributeSelector);
        // Process elements for partial matches
        allElements.forEach(el => {
            // Skip if already marked for removal
            if (elementsToRemove.has(el)) {
                return;
            }
            // Get all relevant attributes and combine into a single string
            const attrs = [
                el.className && typeof el.className === 'string' ? el.className : '',
                el.id || '',
                el.getAttribute('data-testid') || '',
                el.getAttribute('data-qa') || '',
                el.getAttribute('data-cy') || ''
            ].join(' ').toLowerCase();
            // Skip if no attributes to check
            if (!attrs.trim()) {
                return;
            }
            // Check for partial match using single regex test
            if (partialRegex.test(attrs)) {
                elementsToRemove.add(el);
                partialSelectorCount++;
            }
        });
        // Remove all collected elements in a single pass
        elementsToRemove.forEach(el => el.remove());
        const endTime = performance.now();
        this._log('Removed clutter elements:', {
            exactSelectors: exactSelectorCount,
            partialSelectors: partialSelectorCount,
            total: elementsToRemove.size,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    flattenDivs(element) {
        let processedCount = 0;
        const startTime = performance.now();
        // Process in batches to maintain performance
        let keepProcessing = true;
        const shouldPreserveElement = (el) => {
            const tagName = el.tagName.toLowerCase();
            // Check if element should be preserved
            if (constants_1.PRESERVE_ELEMENTS.has(tagName))
                return true;
            // Check for semantic roles
            const role = el.getAttribute('role');
            if (role && ['article', 'main', 'navigation', 'banner', 'contentinfo'].includes(role)) {
                return true;
            }
            // Check for semantic classes
            const className = el.className.toLowerCase();
            if (className.match(/(?:article|main|content|footnote|reference|bibliography)/)) {
                return true;
            }
            // Check if div contains mixed content types that should be preserved
            if (tagName === 'div') {
                const children = Array.from(el.children);
                const hasPreservedElements = children.some(child => constants_1.PRESERVE_ELEMENTS.has(child.tagName.toLowerCase()) ||
                    child.getAttribute('role') === 'article' ||
                    child.className.toLowerCase().includes('article'));
                if (hasPreservedElements)
                    return true;
            }
            return false;
        };
        const isWrapperDiv = (div) => {
            var _a;
            // Check if it's just empty space
            if (!((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim()))
                return true;
            // Check if it only contains other divs or block elements
            const children = Array.from(div.children);
            if (children.length === 0)
                return true;
            // Check if all children are block elements
            const allBlockElements = children.every(child => {
                const tag = child.tagName.toLowerCase();
                return tag === 'div' || tag === 'p' || tag === 'h1' || tag === 'h2' ||
                    tag === 'h3' || tag === 'h4' || tag === 'h5' || tag === 'h6' ||
                    tag === 'ul' || tag === 'ol' || tag === 'pre' || tag === 'blockquote' ||
                    tag === 'figure';
            });
            if (allBlockElements)
                return true;
            // Check for common wrapper patterns
            const className = div.className.toLowerCase();
            const isWrapper = /(?:wrapper|container|layout|row|col|grid|flex|outer|inner|content-area)/i.test(className);
            if (isWrapper)
                return true;
            // Check if it has excessive whitespace or empty text nodes
            const textNodes = Array.from(div.childNodes).filter(node => { var _a; return node.nodeType === Node.TEXT_NODE && ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.trim()); });
            if (textNodes.length === 0)
                return true;
            // Check if it's a div that only contains block elements
            const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                const tag = child.tagName.toLowerCase();
                return constants_1.INLINE_ELEMENTS.has(tag);
            });
            if (hasOnlyBlockElements)
                return true;
            return false;
        };
        // Function to process a single div
        const processDiv = (div) => {
            var _a, _b;
            // Skip processing if div has been removed or should be preserved
            if (!div.isConnected || shouldPreserveElement(div))
                return false;
            // Case 1: Empty div or div with only whitespace
            if (!div.hasChildNodes() || !((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim())) {
                div.remove();
                processedCount++;
                return true;
            }
            // Case 2: Top-level div - be more aggressive
            if (div.parentElement === element) {
                const children = Array.from(div.children);
                const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (hasOnlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
            }
            // Case 3: Wrapper div - merge up aggressively
            if (isWrapperDiv(div)) {
                // Special case: if div only contains block elements, merge them up
                const children = Array.from(div.children);
                const onlyBlockElements = !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (onlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
                // Otherwise handle as normal wrapper
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            // Case 4: Div only contains text content - convert to paragraph
            if (!div.children.length && ((_b = div.textContent) === null || _b === void 0 ? void 0 : _b.trim())) {
                const p = document.createElement('p');
                p.textContent = div.textContent;
                div.replaceWith(p);
                processedCount++;
                return true;
            }
            // Case 5: Div has single child
            if (div.children.length === 1) {
                const child = div.firstElementChild;
                const childTag = child.tagName.toLowerCase();
                // Don't unwrap if child is inline or should be preserved
                if (!constants_1.INLINE_ELEMENTS.has(childTag) && !shouldPreserveElement(child)) {
                    div.replaceWith(child);
                    processedCount++;
                    return true;
                }
            }
            // Case 6: Deeply nested div - merge up
            let nestingDepth = 0;
            let parent = div.parentElement;
            while (parent) {
                if (parent.tagName.toLowerCase() === 'div') {
                    nestingDepth++;
                }
                parent = parent.parentElement;
            }
            if (nestingDepth > 0) { // Changed from > 1 to > 0 to be more aggressive
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            return false;
        };
        // First pass: Process top-level divs
        const processTopLevelDivs = () => {
            const topDivs = Array.from(element.children).filter(el => el.tagName.toLowerCase() === 'div');
            let modified = false;
            topDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Second pass: Process remaining divs from deepest to shallowest
        const processRemainingDivs = () => {
            const allDivs = Array.from(element.getElementsByTagName('div'))
                .sort((a, b) => {
                // Count nesting depth
                const getDepth = (el) => {
                    let depth = 0;
                    let parent = el.parentElement;
                    while (parent) {
                        if (parent.tagName.toLowerCase() === 'div')
                            depth++;
                        parent = parent.parentElement;
                    }
                    return depth;
                };
                return getDepth(b) - getDepth(a); // Process deepest first
            });
            let modified = false;
            allDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Final cleanup pass - aggressively flatten remaining divs
        const finalCleanup = () => {
            const remainingDivs = Array.from(element.getElementsByTagName('div'));
            let modified = false;
            remainingDivs.forEach(div => {
                // Check if div only contains paragraphs
                const children = Array.from(div.children);
                const onlyParagraphs = children.every(child => child.tagName.toLowerCase() === 'p');
                if (onlyParagraphs || (!shouldPreserveElement(div) && isWrapperDiv(div))) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    modified = true;
                }
            });
            return modified;
        };
        // Execute all passes until no more changes
        do {
            keepProcessing = false;
            if (processTopLevelDivs())
                keepProcessing = true;
            if (processRemainingDivs())
                keepProcessing = true;
            if (finalCleanup())
                keepProcessing = true;
        } while (keepProcessing);
        const endTime = performance.now();
        this._log('Flattened divs:', {
            count: processedCount,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    cleanContent(element, metadata) {
        // Remove HTML comments
        this.removeHtmlComments(element);
        // Handle H1 elements - remove first one and convert others to H2
        this.handleHeadings(element, metadata.title);
        // Standardize footnotes and citations
        this.standardizeFootnotes(element);
        // Handle lazy-loaded images
        this.handleLazyImages(element);
        // Convert embedded content to standard formats
        this.standardizeElements(element);
        // Skip div flattening in debug mode
        if (!this.debug) {
            // First pass of div flattening
            this.flattenDivs(element);
            // Strip unwanted attributes
            this.stripUnwantedAttributes(element);
            // Remove empty elements
            this.removeEmptyElements(element);
            // Remove trailing headings
            this.removeTrailingHeadings(element);
            // Final pass of div flattening after cleanup operations
            this.flattenDivs(element);
        }
        else {
            // In debug mode, still do basic cleanup but preserve structure
            this.stripUnwantedAttributes(element);
            this.removeEmptyElements(element);
            this.removeTrailingHeadings(element);
            this._log('Debug mode: Skipping div flattening to preserve structure');
        }
    }
    removeTrailingHeadings(element) {
        let removedCount = 0;
        const hasContentAfter = (el) => {
            // Check if there's any meaningful content after this element
            let nextContent = '';
            let sibling = el.nextSibling;
            // First check direct siblings
            while (sibling) {
                if (sibling.nodeType === Node.TEXT_NODE) {
                    nextContent += sibling.textContent || '';
                }
                else if (sibling.nodeType === Node.ELEMENT_NODE) {
                    // If we find an element sibling, check its content
                    nextContent += sibling.textContent || '';
                }
                sibling = sibling.nextSibling;
            }
            // If we found meaningful content at this level, return true
            if (nextContent.trim()) {
                return true;
            }
            // If no content found at this level and we have a parent,
            // check for content after the parent
            const parent = el.parentElement;
            if (parent && parent !== element) {
                return hasContentAfter(parent);
            }
            return false;
        };
        // Process all headings from bottom to top
        const headings = Array.from(element.querySelectorAll('h1, h2, h3, h4, h5, h6'))
            .reverse();
        headings.forEach(heading => {
            if (!hasContentAfter(heading)) {
                heading.remove();
                removedCount++;
            }
            else {
                // Stop processing once we find a heading with content after it
                return;
            }
        });
        if (removedCount > 0) {
            this._log('Removed trailing headings:', removedCount);
        }
    }
    handleHeadings(element, title) {
        var _a;
        const h1s = element.getElementsByTagName('h1');
        Array.from(h1s).forEach(h1 => {
            var _a;
            const h2 = document.createElement('h2');
            h2.innerHTML = h1.innerHTML;
            // Copy allowed attributes
            Array.from(h1.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    h2.setAttribute(attr.name, attr.value);
                }
            });
            (_a = h1.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(h2, h1);
        });
        // Remove first H2 if it matches title
        const h2s = element.getElementsByTagName('h2');
        if (h2s.length > 0) {
            const firstH2 = h2s[0];
            const firstH2Text = ((_a = firstH2.textContent) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) || '';
            const normalizedTitle = title.toLowerCase().trim();
            if (normalizedTitle && normalizedTitle === firstH2Text) {
                firstH2.remove();
            }
        }
    }
    removeHtmlComments(element) {
        const comments = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_COMMENT, null);
        let node;
        while (node = walker.nextNode()) {
            comments.push(node);
        }
        comments.forEach(comment => {
            comment.remove();
        });
        this._log('Removed HTML comments:', comments.length);
    }
    stripUnwantedAttributes(element) {
        let attributeCount = 0;
        const processElement = (el) => {
            // Skip SVG elements - preserve all their attributes
            if (el instanceof SVGElement) {
                return;
            }
            const attributes = Array.from(el.attributes);
            attributes.forEach(attr => {
                const attrName = attr.name.toLowerCase();
                // In debug mode, allow debug attributes and data- attributes
                if (this.debug) {
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName) &&
                        !constants_1.ALLOWED_ATTRIBUTES_DEBUG.has(attrName) &&
                        !attrName.startsWith('data-')) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
                else {
                    // In normal mode, only allow standard attributes
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName)) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
            });
        };
        processElement(element);
        element.querySelectorAll('*').forEach(processElement);
        this._log('Stripped attributes:', attributeCount);
    }
    removeEmptyElements(element) {
        let removedCount = 0;
        let iterations = 0;
        let keepRemoving = true;
        while (keepRemoving) {
            iterations++;
            keepRemoving = false;
            // Get all elements without children, working from deepest first
            const emptyElements = Array.from(element.getElementsByTagName('*')).filter(el => {
                if (constants_1.ALLOWED_EMPTY_ELEMENTS.has(el.tagName.toLowerCase())) {
                    return false;
                }
                // Check if element has only whitespace or &nbsp;
                const textContent = el.textContent || '';
                const hasOnlyWhitespace = textContent.trim().length === 0;
                const hasNbsp = textContent.includes('\u00A0'); // Unicode non-breaking space
                // Check if element has no meaningful children
                const hasNoChildren = !el.hasChildNodes() ||
                    (Array.from(el.childNodes).every(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            const nodeText = node.textContent || '';
                            return nodeText.trim().length === 0 && !nodeText.includes('\u00A0');
                        }
                        return false;
                    }));
                // Special case: Check for divs that only contain spans with commas
                if (el.tagName.toLowerCase() === 'div') {
                    const children = Array.from(el.children);
                    const hasOnlyCommaSpans = children.length > 0 && children.every(child => {
                        var _a;
                        if (child.tagName.toLowerCase() !== 'span')
                            return false;
                        const content = ((_a = child.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        return content === ',' || content === '' || content === ' ';
                    });
                    if (hasOnlyCommaSpans)
                        return true;
                }
                return hasOnlyWhitespace && !hasNbsp && hasNoChildren;
            });
            if (emptyElements.length > 0) {
                emptyElements.forEach(el => {
                    el.remove();
                    removedCount++;
                });
                keepRemoving = true;
            }
        }
        this._log('Removed empty elements:', {
            count: removedCount,
            iterations
        });
    }
    createFootnoteItem(footnoteNumber, content, refs) {
        const newItem = document.createElement('li');
        newItem.className = 'footnote';
        newItem.id = `fn:${footnoteNumber}`;
        // Handle content
        if (typeof content === 'string') {
            const paragraph = document.createElement('p');
            paragraph.innerHTML = content;
            newItem.appendChild(paragraph);
        }
        else {
            // Get all paragraphs from the content
            const paragraphs = Array.from(content.querySelectorAll('p'));
            if (paragraphs.length === 0) {
                // If no paragraphs, wrap content in a paragraph
                const paragraph = document.createElement('p');
                paragraph.innerHTML = content.innerHTML;
                newItem.appendChild(paragraph);
            }
            else {
                // Copy existing paragraphs
                paragraphs.forEach(p => {
                    const newP = document.createElement('p');
                    newP.innerHTML = p.innerHTML;
                    newItem.appendChild(newP);
                });
            }
        }
        // Add backlink(s) to the last paragraph
        const lastParagraph = newItem.querySelector('p:last-of-type') || newItem;
        refs.forEach((refId, index) => {
            const backlink = document.createElement('a');
            backlink.href = `#${refId}`;
            backlink.title = 'return to article';
            backlink.className = 'footnote-backref';
            backlink.innerHTML = 'â†©';
            if (index < refs.length - 1) {
                backlink.innerHTML += ' ';
            }
            lastParagraph.appendChild(backlink);
        });
        return newItem;
    }
    collectFootnotes(element) {
        const footnotes = {};
        let footnoteCount = 1;
        const processedIds = new Set(); // Track processed IDs
        // Collect all footnotes and their IDs from footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => {
            // Substack has individual footnote divs with no parent
            if (list.matches('div.footnote[data-component-name="FootnoteToDOM"]')) {
                const anchor = list.querySelector('a.footnote-number');
                const content = list.querySelector('.footnote-content');
                if (anchor && content) {
                    const id = anchor.id.replace('footnote-', '').toLowerCase();
                    if (id && !processedIds.has(id)) {
                        footnotes[footnoteCount] = {
                            content: content,
                            originalId: id,
                            refs: []
                        };
                        processedIds.add(id);
                        footnoteCount++;
                    }
                }
                return;
            }
            // Common format using OL/UL and LI elements
            const items = list.querySelectorAll('li, div[role="listitem"]');
            items.forEach(li => {
                var _a, _b, _c, _d;
                let id = '';
                let content = null;
                // Handle citations with .citations class
                const citationsDiv = li.querySelector('.citations');
                if ((_a = citationsDiv === null || citationsDiv === void 0 ? void 0 : citationsDiv.id) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith('r')) {
                    id = citationsDiv.id.toLowerCase();
                    // Look for citation content within the citations div
                    const citationContent = citationsDiv.querySelector('.citation-content');
                    if (citationContent) {
                        content = citationContent;
                    }
                }
                else {
                    // Extract ID from various formats
                    if (li.id.toLowerCase().startsWith('bib.bib')) {
                        id = li.id.replace('bib.bib', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn:')) {
                        id = li.id.replace('fn:', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn')) {
                        id = li.id.replace('fn', '').toLowerCase();
                        // Nature.com
                    }
                    else if (li.hasAttribute('data-counter')) {
                        id = ((_c = (_b = li.getAttribute('data-counter')) === null || _b === void 0 ? void 0 : _b.replace(/\.$/, '')) === null || _c === void 0 ? void 0 : _c.toLowerCase()) || '';
                    }
                    else {
                        const match = (_d = li.id.split('/').pop()) === null || _d === void 0 ? void 0 : _d.match(/cite_note-(.+)/);
                        id = match ? match[1].toLowerCase() : li.id.toLowerCase();
                    }
                    content = li;
                }
                if (id && !processedIds.has(id)) {
                    footnotes[footnoteCount] = {
                        content: content || li,
                        originalId: id,
                        refs: []
                    };
                    processedIds.add(id);
                    footnoteCount++;
                }
            });
        });
        return footnotes;
    }
    findOuterFootnoteContainer(el) {
        let current = el;
        let parent = el.parentElement;
        // Keep going up until we find an element that's not a span or sup
        while (parent && (parent.tagName.toLowerCase() === 'span' ||
            parent.tagName.toLowerCase() === 'sup')) {
            current = parent;
            parent = parent.parentElement;
        }
        return current;
    }
    // Every footnote reference should be a sup element with an anchor inside
    // e.g. <sup id="fnref:1"><a href="#fn:1">1</a></sup>
    createFootnoteReference(footnoteNumber, refId) {
        const sup = document.createElement('sup');
        sup.id = refId;
        const link = document.createElement('a');
        link.href = `#fn:${footnoteNumber}`;
        link.textContent = footnoteNumber;
        sup.appendChild(link);
        return sup;
    }
    standardizeFootnotes(element) {
        const footnotes = this.collectFootnotes(element);
        // Standardize inline footnotes using the collected IDs
        const footnoteInlineReferences = element.querySelectorAll(constants_1.FOOTNOTE_INLINE_REFERENCES);
        // Group references by their parent sup element
        const supGroups = new Map();
        footnoteInlineReferences.forEach(el => {
            var _a, _b, _c, _d;
            if (!(el instanceof HTMLElement))
                return;
            let footnoteId = '';
            let footnoteContent = '';
            // Extract footnote ID based on element type
            // Nature.com
            if (el.matches('a[id^="ref-link"]')) {
                footnoteId = ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                // Science.org
            }
            else if (el.matches('a[role="doc-biblioref"]')) {
                const xmlRid = el.getAttribute('data-xml-rid');
                if (xmlRid) {
                    footnoteId = xmlRid;
                }
                else {
                    const href = el.getAttribute('href');
                    if (href === null || href === void 0 ? void 0 : href.startsWith('#core-R')) {
                        footnoteId = href.replace('#core-', '');
                    }
                }
                // Substack
            }
            else if (el.matches('a.footnote-anchor, span.footnote-hovercard-target a')) {
                const id = ((_b = el.id) === null || _b === void 0 ? void 0 : _b.replace('footnote-anchor-', '')) || '';
                if (id) {
                    footnoteId = id.toLowerCase();
                }
                // Arxiv
            }
            else if (el.matches('cite.ltx_cite')) {
                const link = el.querySelector('a');
                if (link) {
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_c = href.split('/').pop()) === null || _c === void 0 ? void 0 : _c.match(/bib\.bib(\d+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                }
            }
            else if (el.matches('sup.reference')) {
                const links = el.querySelectorAll('a');
                Array.from(links).forEach(link => {
                    var _a;
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_a = href.split('/').pop()) === null || _a === void 0 ? void 0 : _a.match(/(?:cite_note|cite_ref)-(.+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                });
            }
            else if (el.matches('sup[id^="fnref:"]')) {
                footnoteId = el.id.replace('fnref:', '').toLowerCase();
            }
            else if (el.matches('sup[id^="fnr"]')) {
                footnoteId = el.id.replace('fnr', '').toLowerCase();
            }
            else if (el.matches('span.footnote-reference')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
            }
            else if (el.matches('span.footnote-link')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
                footnoteContent = el.getAttribute('data-footnote-content') || '';
            }
            else if (el.matches('a.citation')) {
                footnoteId = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                footnoteContent = el.getAttribute('href') || '';
            }
            else if (el.matches('a[id^="fnref"]')) {
                footnoteId = el.id.replace('fnref', '').toLowerCase();
            }
            else {
                // Other citation types
                const href = el.getAttribute('href');
                if (href) {
                    const id = href.replace(/^[#]/, '');
                    footnoteId = id.toLowerCase();
                }
            }
            if (footnoteId) {
                // Find the footnote number by matching the original ID
                const footnoteEntry = Object.entries(footnotes).find(([_, data]) => data.originalId === footnoteId.toLowerCase());
                if (footnoteEntry) {
                    const [footnoteNumber, footnoteData] = footnoteEntry;
                    // Create footnote reference ID
                    const refId = footnoteData.refs.length > 0 ?
                        `fnref:${footnoteNumber}-${footnoteData.refs.length + 1}` :
                        `fnref:${footnoteNumber}`;
                    footnoteData.refs.push(refId);
                    // Find the outermost container (span or sup)
                    const container = this.findOuterFootnoteContainer(el);
                    // If container is a sup, group references
                    if (container.tagName.toLowerCase() === 'sup') {
                        if (!supGroups.has(container)) {
                            supGroups.set(container, []);
                        }
                        const group = supGroups.get(container);
                        group.push(this.createFootnoteReference(footnoteNumber, refId));
                    }
                    else {
                        // Replace the container directly
                        container.replaceWith(this.createFootnoteReference(footnoteNumber, refId));
                    }
                }
            }
        });
        // Handle grouped references
        supGroups.forEach((references, container) => {
            if (references.length > 0) {
                // Create a document fragment to hold all the references
                const fragment = document.createDocumentFragment();
                // Add each reference as its own sup element
                references.forEach((ref, index) => {
                    const link = ref.querySelector('a');
                    if (link) {
                        const sup = document.createElement('sup');
                        sup.id = ref.id;
                        sup.appendChild(link.cloneNode(true));
                        fragment.appendChild(sup);
                    }
                });
                container.replaceWith(fragment);
            }
        });
        // Create the standardized footnote list
        const newList = document.createElement('footnotes');
        newList.className = 'footnotes';
        const orderedList = document.createElement('ol');
        // Create footnote items in order
        Object.entries(footnotes).forEach(([number, data]) => {
            const newItem = this.createFootnoteItem(parseInt(number), data.content, data.refs);
            orderedList.appendChild(newItem);
        });
        // Remove original footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => list.remove());
        // If we have any footnotes, add the new list to the document
        if (orderedList.children.length > 0) {
            newList.appendChild(orderedList);
            element.appendChild(newList);
        }
    }
    handleLazyImages(element) {
        let processedCount = 0;
        const lazyImages = element.querySelectorAll('img[data-src], img[data-srcset]');
        lazyImages.forEach(img => {
            if (!(img instanceof HTMLImageElement))
                return;
            // Handle data-src
            const dataSrc = img.getAttribute('data-src');
            if (dataSrc && !img.src) {
                img.src = dataSrc;
                processedCount++;
            }
            // Handle data-srcset
            const dataSrcset = img.getAttribute('data-srcset');
            if (dataSrcset && !img.srcset) {
                img.srcset = dataSrcset;
                processedCount++;
            }
            // Remove lazy loading related classes and attributes
            img.classList.remove('lazy', 'lazyload');
            img.removeAttribute('data-ll-status');
            img.removeAttribute('data-src');
            img.removeAttribute('data-srcset');
        });
        this._log('Processed lazy images:', processedCount);
    }
    standardizeElements(element) {
        let processedCount = 0;
        // Convert elements based on standardization rules
        ELEMENT_STANDARDIZATION_RULES.forEach(rule => {
            const elements = element.querySelectorAll(rule.selector);
            elements.forEach(el => {
                if (rule.transform) {
                    // If there's a transform function, use it to create the new element
                    const transformed = rule.transform(el);
                    el.replaceWith(transformed);
                    processedCount++;
                }
            });
        });
        // Convert lite-youtube elements
        const liteYoutubeElements = element.querySelectorAll('lite-youtube');
        liteYoutubeElements.forEach(el => {
            const videoId = el.getAttribute('videoid');
            if (!videoId)
                return;
            const iframe = document.createElement('iframe');
            iframe.width = '560';
            iframe.height = '315';
            iframe.src = `https://www.youtube.com/embed/${videoId}`;
            iframe.title = el.getAttribute('videotitle') || 'YouTube video player';
            iframe.frameBorder = '0';
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.setAttribute('allowfullscreen', '');
            el.replaceWith(iframe);
            processedCount++;
        });
        this._log('Converted embedded elements:', processedCount);
    }
    // Find small IMG and SVG elements
    findSmallImages(doc) {
        const MIN_DIMENSION = 33;
        const smallImages = new Set();
        const transformRegex = /scale\(([\d.]+)\)/;
        const startTime = performance.now();
        let processedCount = 0;
        // 1. Read phase - Gather all elements in a single pass
        const elements = [
            ...Array.from(doc.getElementsByTagName('img')),
            ...Array.from(doc.getElementsByTagName('svg'))
        ].filter(element => {
            // Skip lazy-loaded images that haven't been processed yet
            // and math images which may be small
            if (element instanceof HTMLImageElement) {
                const ignoredImage = element.classList.contains('lazy') ||
                    element.classList.contains('lazyload') ||
                    element.classList.contains('latex') ||
                    element.hasAttribute('decoding') ||
                    element.hasAttribute('data-src') ||
                    element.hasAttribute('data-srcset');
                return !ignoredImage;
            }
            return true;
        });
        if (elements.length === 0) {
            return smallImages;
        }
        // 2. Batch process - Collect all measurements in one go
        const measurements = elements.map(element => ({
            element,
            // Static attributes (no reflow)
            naturalWidth: element instanceof HTMLImageElement ? element.naturalWidth : 0,
            naturalHeight: element instanceof HTMLImageElement ? element.naturalHeight : 0,
            attrWidth: parseInt(element.getAttribute('width') || '0'),
            attrHeight: parseInt(element.getAttribute('height') || '0')
        }));
        // 3. Batch compute styles - Process in chunks to avoid long tasks
        const BATCH_SIZE = 50;
        for (let i = 0; i < measurements.length; i += BATCH_SIZE) {
            const batch = measurements.slice(i, i + BATCH_SIZE);
            try {
                // Read phase - compute all styles at once
                const styles = batch.map(({ element }) => window.getComputedStyle(element));
                const rects = batch.map(({ element }) => element.getBoundingClientRect());
                // Process phase - no DOM operations
                batch.forEach((measurement, index) => {
                    var _a;
                    try {
                        const style = styles[index];
                        const rect = rects[index];
                        // Get transform scale in the same batch
                        const transform = style.transform;
                        const scale = transform ?
                            parseFloat(((_a = transform.match(transformRegex)) === null || _a === void 0 ? void 0 : _a[1]) || '1') : 1;
                        // Calculate effective dimensions
                        const widths = [
                            measurement.naturalWidth,
                            measurement.attrWidth,
                            parseInt(style.width) || 0,
                            rect.width * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        const heights = [
                            measurement.naturalHeight,
                            measurement.attrHeight,
                            parseInt(style.height) || 0,
                            rect.height * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        // Decision phase - no DOM operations
                        if (widths.length > 0 && heights.length > 0) {
                            const effectiveWidth = Math.min(...widths);
                            const effectiveHeight = Math.min(...heights);
                            if (effectiveWidth < MIN_DIMENSION || effectiveHeight < MIN_DIMENSION) {
                                const identifier = this.getElementIdentifier(measurement.element);
                                if (identifier) {
                                    smallImages.add(identifier);
                                    processedCount++;
                                }
                            }
                        }
                    }
                    catch (e) {
                        if (this.debug) {
                            console.warn('Defuddle: Failed to process element dimensions:', e);
                        }
                    }
                });
            }
            catch (e) {
                if (this.debug) {
                    console.warn('Defuddle: Failed to process batch:', e);
                }
            }
        }
        const endTime = performance.now();
        this._log('Found small elements:', {
            count: processedCount,
            totalElements: elements.length,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        return smallImages;
    }
    removeSmallImages(doc, smallImages) {
        let removedCount = 0;
        ['img', 'svg'].forEach(tag => {
            const elements = doc.getElementsByTagName(tag);
            Array.from(elements).forEach(element => {
                const identifier = this.getElementIdentifier(element);
                if (identifier && smallImages.has(identifier)) {
                    element.remove();
                    removedCount++;
                }
            });
        });
        this._log('Removed small elements:', removedCount);
    }
    getElementIdentifier(element) {
        // Try to create a unique identifier using various attributes
        if (element instanceof HTMLImageElement) {
            // For lazy-loaded images, use data-src as identifier if available
            const dataSrc = element.getAttribute('data-src');
            if (dataSrc)
                return `src:${dataSrc}`;
            const src = element.src || '';
            const srcset = element.srcset || '';
            const dataSrcset = element.getAttribute('data-srcset');
            if (src)
                return `src:${src}`;
            if (srcset)
                return `srcset:${srcset}`;
            if (dataSrcset)
                return `srcset:${dataSrcset}`;
        }
        const id = element.id || '';
        const className = element.className || '';
        const viewBox = element instanceof SVGElement ? element.getAttribute('viewBox') || '' : '';
        if (id)
            return `id:${id}`;
        if (viewBox)
            return `viewBox:${viewBox}`;
        if (className)
            return `class:${className}`;
        return null;
    }
    findMainContent(doc) {
        // Find all potential content containers
        const candidates = [];
        constants_1.ENTRY_POINT_ELEMENTS.forEach((selector, index) => {
            const elements = doc.querySelectorAll(selector);
            elements.forEach(element => {
                // Base score from selector priority (earlier = higher)
                let score = (constants_1.ENTRY_POINT_ELEMENTS.length - index) * 10;
                // Add score based on content analysis
                score += this.scoreElement(element);
                candidates.push({ element, score });
            });
        });
        if (candidates.length === 0) {
            // Fall back to scoring block elements
            // Currently <body> element is used as the fallback, so this is not used
            return this.findContentByScoring(doc);
        }
        // Sort by score descending
        candidates.sort((a, b) => b.score - a.score);
        if (this.debug) {
            this._log('Content candidates:', candidates.map(c => ({
                element: c.element.tagName,
                selector: this.getElementSelector(c.element),
                score: c.score
            })));
        }
        return candidates[0].element;
    }
    findContentByScoring(doc) {
        const candidates = this.scoreElements(doc);
        return candidates.length > 0 ? candidates[0].element : null;
    }
    getElementSelector(element) {
        const parts = [];
        let current = element;
        while (current && current !== this.doc.documentElement) {
            let selector = current.tagName.toLowerCase();
            if (current.id) {
                selector += '#' + current.id;
            }
            else if (current.className && typeof current.className === 'string') {
                selector += '.' + current.className.trim().split(/\s+/).join('.');
            }
            parts.unshift(selector);
            current = current.parentElement;
        }
        return parts.join(' > ');
    }
    scoreElements(doc) {
        const candidates = [];
        constants_1.BLOCK_ELEMENTS.forEach((tag) => {
            Array.from(doc.getElementsByTagName(tag)).forEach((element) => {
                const score = this.scoreElement(element);
                if (score > 0) {
                    candidates.push({ score, element });
                }
            });
        });
        return candidates.sort((a, b) => b.score - a.score);
    }
    scoreElement(element) {
        let score = 0;
        // Score based on element properties
        const className = element.className && typeof element.className === 'string' ?
            element.className.toLowerCase() : '';
        const id = element.id ? element.id.toLowerCase() : '';
        // Score based on content
        const text = element.textContent || '';
        const words = text.split(/\s+/).length;
        score += Math.min(Math.floor(words / 100), 3);
        // Score based on link density
        const links = element.getElementsByTagName('a');
        const linkText = Array.from(links).reduce((acc, link) => { var _a; return acc + (((_a = link.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0); }, 0);
        const linkDensity = text.length ? linkText / text.length : 0;
        if (linkDensity > 0.5) {
            score -= 10;
        }
        // Score based on presence of meaningful elements
        const paragraphs = element.getElementsByTagName('p').length;
        score += paragraphs;
        const images = element.getElementsByTagName('img').length;
        score += Math.min(images * 3, 9);
        return score;
    }
}
exports.Defuddle = Defuddle;


/***/ }),

/***/ 640:
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SUPPORTED_LANGUAGES = exports.ALLOWED_ATTRIBUTES_DEBUG = exports.ALLOWED_ATTRIBUTES = exports.ALLOWED_EMPTY_ELEMENTS = exports.FOOTNOTE_LIST_SELECTORS = exports.FOOTNOTE_INLINE_REFERENCES = exports.PARTIAL_SELECTORS = exports.EXACT_SELECTORS = exports.HIDDEN_ELEMENT_SELECTORS = exports.INLINE_ELEMENTS = exports.PRESERVE_ELEMENTS = exports.BLOCK_ELEMENTS = exports.MOBILE_WIDTH = exports.ENTRY_POINT_ELEMENTS = void 0;
// Entry point elements
// These are the elements that will be used to find the main content
exports.ENTRY_POINT_ELEMENTS = [
    'article',
    '[role="article"]',
    '.post-content',
    '.article-content',
    '#article-content',
    '.content-article',
    'main',
    '[role="main"]',
    'body' // ensures there is always a match
];
exports.MOBILE_WIDTH = 600;
exports.BLOCK_ELEMENTS = ['div', 'section', 'article', 'main'];
// Elements that should not be unwrapped
exports.PRESERVE_ELEMENTS = new Set([
    'pre', 'code', 'table', 'thead', 'tbody', 'tr', 'td', 'th',
    'ul', 'ol', 'li', 'dl', 'dt', 'dd',
    'figure', 'figcaption', 'picture',
    'details', 'summary',
    'blockquote',
    'form', 'fieldset'
]);
// Inline elements that should not be unwrapped
exports.INLINE_ELEMENTS = new Set([
    'a', 'span', 'strong', 'em', 'i', 'b', 'u', 'code', 'br', 'small',
    'sub', 'sup', 'mark', 'del', 'ins', 'q', 'abbr', 'cite', 'time'
]);
// Hidden elements that should be removed
exports.HIDDEN_ELEMENT_SELECTORS = [
    '[hidden]',
    //	'[aria-hidden="true"]', needed for math formulas
    //	'[style*="display: none"]', needed for for math formulas
    //	'[style*="display:none"]',
    '[style*="visibility: hidden"]',
    '[style*="visibility:hidden"]',
    '.hidden',
    '.invisible'
].join(',');
// Selectors to be removed
exports.EXACT_SELECTORS = [
    // scripts, styles
    'noscript',
    'script:not([type^="math/"])',
    'style',
    // ads
    '.ad:not([class*="gradient"])',
    '[class^="ad-" i]',
    '[class$="-ad" i]',
    '[id^="ad-" i]',
    '[id$="-ad" i]',
    '[role="banner" i]',
    '.promo',
    '.Promo',
    '#barrier-page', // ft.com
    // comments
    '[id="comments" i]',
    // header, nav
    'header',
    '.header',
    '#header',
    'nav',
    '.navigation',
    '#navigation',
    '[role="navigation" i]',
    '[role="dialog" i]',
    '[role*="complementary" i]',
    '[class*="pagination" i]',
    '.menu',
    '#menu',
    '#siteSub',
    // metadata
    '.author',
    '.Author',
    '.contributor',
    '.date',
    '.meta',
    '.tags',
    '.toc',
    '.Toc',
    '#toc',
    '#title',
    '#Title',
    '[href*="/category"]',
    '[href*="/categories"]',
    '[href*="/tag/"]',
    '[href*="/tags/"]',
    '[href*="/topics"]',
    '[href*="author"]',
    '[href="#site-content"]',
    '[src*="author"]',
    // footer
    'footer',
    // inputs, forms, elements
    'aside',
    'button',
    // '[role="button"]', Medium images
    'canvas',
    'dialog',
    'fieldset',
    'form',
    'input:not([type="checkbox"])',
    'label',
    'link',
    'option',
    'select',
    'textarea',
    'time',
    // iframes
    'instaread-player',
    'iframe:not([src*="youtube"]):not([src*="youtu.be"]):not([src*="vimeo"]):not([src*="twitter"])',
    // logos
    '[class="logo" i]',
    '#logo',
    '#Logo',
    // newsletter
    '#newsletter',
    '#Newsletter',
    // hidden for print
    '.noprint',
    '[data-link-name*="skip" i]',
    '[data-print-layout="hide" i]',
    '[data-block="donotprint" i]',
    // footnotes, citations
    '[class*="clickable-icon" i]',
    'li span[class*="ltx_tag" i][class*="ltx_tag_item" i]',
    'a[href^="#"][class*="anchor" i]',
    'a[href^="#"][class*="ref" i]',
    // link lists
    '[data-container*="most-viewed" i]',
    // sidebar
    '.sidebar',
    '.Sidebar',
    '#sidebar',
    '#Sidebar',
    '#sitesub',
    // other
    '#primaryaudio', // NPR
    '#NYT_ABOVE_MAIN_CONTENT_REGION',
    '[data-testid="photoviewer-children-figure"] > span', // New York Times
    'table.infobox',
    '.pencraft:not(.pc-display-contents)', // Substack
    '[data-optimizely="related-articles-section" i]' // The Economist
];
// Removal patterns tested against attributes: class, id, data-testid, and data-qa
// Case insensitive, partial matches allowed
exports.PARTIAL_SELECTORS = [
    'access-wall',
    'activitypub',
    'actioncall',
    'appendix',
    'avatar',
    'advert',
    '-ad-',
    '_ad_',
    'allterms',
    'alert-box',
    'around-the-web',
    'article-bottom-section',
    'article__copy',
    'article_date',
    'article-end ',
    'article_header',
    'article__header',
    'article__info',
    'article-info',
    'article__meta',
    'article-subject',
    'article_subject',
    'article-snippet',
    'article-separator',
    'article--share',
    'article--topics',
    'articletags',
    'article-tags',
    'article_tags',
    'article-title',
    'article_title',
    'articletopics',
    'article-topics',
    'article-type',
    'article--lede', // The Verge
    'articlewell',
    'associated-people',
    'audio-card',
    //	'author', Gwern
    'authored-by',
    'author-box',
    'author-name',
    'author-bio',
    'author-mini-bio',
    'back-to-top',
    'backlinks-section',
    'banner',
    'bio-block',
    'blog-pager',
    'bookmark-',
    '-bookmark',
    'bottom-of-article',
    'brand-bar',
    'breadcrumb',
    'button-wrapper',
    'btn-',
    '-btn',
    'byline',
    'captcha',
    'card-text',
    'card-media',
    'cat_header',
    'catlinks',
    'chapter-list', // The Economist
    'collections',
    'comments',
    //	'-comment', Syntax highlighting
    'commentbox',
    'comment-count',
    'comment-content',
    'comment-form',
    'comment-number',
    'comment-respond',
    'comment-thread',
    'complementary',
    'consent',
    'content-card', // The Verge
    'content-topics',
    'contentpromo',
    'context-widget', // Reuters
    'core-collateral',
    '_cta',
    '-cta',
    'cta-',
    'cta_',
    'current-issue', // The Nation
    'custom-list-number',
    'dateline',
    'dateheader',
    'date-header',
    'date_header-',
    //	'dialog',
    'disclaimer',
    'disclosure',
    'discussion',
    'discuss_',
    'disqus',
    'donate',
    'dropdown', // Ars Technica
    'eletters',
    'emailsignup',
    'engagement-widget',
    'entry-author-info',
    'entry-categories',
    'entry-date',
    'entry-meta',
    'entry-title',
    'entry-utility',
    'eyebrow',
    'expand-reduce',
    'externallinkembedwrapper', // The New Yorker
    'extra-services',
    'extra-title',
    'facebook',
    'favorite',
    'feedback',
    'feed-links',
    'field-site-sections',
    'fixed',
    'floating-vid',
    'follow',
    'footer',
    'footnote-back',
    'footnoteback',
    'for-you',
    'frontmatter',
    'further-reading',
    'gist-meta',
    //	'global',
    'google',
    'goog-',
    'graph-view',
    'header-logo',
    'header-pattern', // The Verge
    'hero-list',
    'hide-for-print',
    'hide-print',
    'hide-when-no-script',
    'hidden-sidenote',
    'interlude',
    'interaction',
    'jumplink',
    'jump-to-',
    //	'keyword', // used in syntax highlighting
    'kicker',
    'labstab', // Arxiv
    '-labels',
    'language-name',
    'latest-content',
    '-ledes-', // The Verge
    '-license',
    'link-box',
    'links-grid', // BBC
    'links-title', // BBC
    'listing-dynamic-terms', // Boston Review
    'list-tags',
    'loading',
    'loa-info',
    'logo_container',
    'ltx_role_refnum', // Arxiv
    'ltx_tag_bibitem',
    'ltx_error',
    'marketing',
    'media-inquiry',
    'menu-',
    'meta-',
    'metadata',
    'might-like',
    '_modal',
    '-modal',
    'more-',
    'morenews',
    'morestories',
    'move-helper',
    'mw-editsection',
    'mw-cite-backlink',
    'mw-indicators',
    'mw-jump-link',
    'nav-',
    'nav_',
    'navbar',
    //	'navigation',
    'next-',
    'news-story-title',
    //	'newsletter', used on Substack
    'newsletter_',
    'newsletter-signup',
    'newslettersignup',
    'newsletterwidget',
    'newsletterwrapper',
    'not-found',
    'nomobile',
    'noprint',
    'originally-published', // Mercury News
    'outline-view',
    'overlay',
    'page-title',
    '-partners',
    'plea',
    'popular',
    //	'popup', Gwern
    'pop-up',
    'popover',
    'post-bottom',
    'post__category',
    'postcomment',
    'postdate',
    'post-author',
    'post-date',
    'post_date',
    'post-feeds',
    'postinfo',
    'post-info',
    'post_info',
    'post-inline-date',
    'post-links',
    'post-meta',
    'postmeta',
    'postsnippet',
    'post_snippet',
    'post-snippet',
    'posttitle',
    'post-title',
    'post_title',
    'posttax',
    'post-tax',
    'post_tax',
    'posttag',
    'post_tag',
    'post-tag',
    //	'preview', used on Obsidian Publish
    'prevnext',
    'previousnext',
    'press-inquiries',
    'print-none',
    'print-header',
    'profile',
    //	'promo',
    'promo-box',
    'pubdate',
    'pub_date',
    'pub-date',
    'publication-date',
    'publicationName', // Medium
    'qr-code',
    'qr_code',
    '_rail',
    'readmore',
    'read-next',
    'read_next',
    'read_time',
    'read-time',
    'reading_time',
    'reading-time',
    'reading-list',
    'recentpost',
    'recent_post',
    'recent-post',
    'recommend',
    'redirectedfrom',
    'recirc',
    'register',
    'related',
    'relevant',
    'reversefootnote',
    'screen-reader-text',
    //	'share',
    //	'-share', scitechdaily.com
    'share-box',
    'sharedaddy',
    'share-icons',
    'sharelinks',
    'share-section',
    'sidebartitle',
    'sidebar_',
    'sidebar-content',
    'similar-',
    'similar_',
    'similars-',
    'sideitems',
    'side-box',
    'site-index',
    'site-header',
    'site-logo',
    'site-name',
    //	'skip-',
    //	'skip-link', TechCrunch
    '_skip-link',
    'slug-wrap',
    'social',
    'speechify-ignore',
    'sponsor',
    'springercitation',
    //	'-stats',
    '_stats',
    'sticky',
    'storyreadtime', // Medium
    'storypublishdate', // Medium
    'subject-label',
    'subscribe',
    '_tags',
    'tags__item',
    'tag_list',
    'taxonomy',
    'table-of-contents',
    'tabs-',
    //	'teaser', Nature
    'terminaltout',
    'time-rubric',
    'timestamp',
    'tip_off',
    'tiptout',
    '-tout-',
    '-toc',
    'toggle-caption',
    'topic-list',
    'toolbar',
    'tooltip',
    'top-wrapper',
    'tree-item',
    'trending',
    'trust-feat',
    'trust-badge',
    'twitter',
    'visually-hidden',
    'welcomebox'
    //	'widget-'
];
// Selectors for footnotes and citations
exports.FOOTNOTE_INLINE_REFERENCES = [
    'sup.reference',
    'cite.ltx_cite',
    'sup[id^="fnr"]',
    'sup[id^="fnref:"]',
    'span.footnote-link',
    'a.citation',
    'a[id^="ref-link"]',
    'a[href^="#fn"]',
    'a[href^="#cite"]',
    'a[href^="#reference"]',
    'a[href^="#footnote"]',
    'a[href^="#r"]', // Common in academic papers
    'a[href^="#b"]', // Common for bibliography references
    'a[href*="cite_note"]',
    'a[href*="cite_ref"]',
    'a.footnote-anchor', // Substack
    'span.footnote-hovercard-target a', // Substack
    'a[role="doc-biblioref"]', // Science.org
    'a[id^="fnref"]',
    'a[id^="ref-link"]', // Nature.com
].join(',');
exports.FOOTNOTE_LIST_SELECTORS = [
    'div.footnote ol',
    'div.footnotes ol',
    'div[role="doc-endnotes"]',
    'div[role="doc-footnotes"]',
    'ol.footnotes-list',
    'ol.footnotes',
    'ol.references',
    'ol[class*="article-references"]',
    'section.footnotes ol',
    'section[role="doc-endnotes"]',
    'section[role="doc-footnotes"]',
    'section[role="doc-bibliography"]',
    'ul.footnotes-list',
    'ul.ltx_biblist',
    'div.footnote[data-component-name="FootnoteToDOM"]' // Substack
].join(',');
// Elements that are allowed to be empty
// These are not removed even if they have no content
exports.ALLOWED_EMPTY_ELEMENTS = new Set([
    'area',
    'audio',
    'base',
    'br',
    'circle',
    'col',
    'defs',
    'ellipse',
    'embed',
    'figure',
    'g',
    'hr',
    'iframe',
    'img',
    'input',
    'line',
    'link',
    'mask',
    'meta',
    'object',
    'param',
    'path',
    'pattern',
    'picture',
    'polygon',
    'polyline',
    'rect',
    'source',
    'stop',
    'svg',
    'td',
    'th',
    'track',
    'use',
    'video',
    'wbr'
]);
// Attributes to keep
exports.ALLOWED_ATTRIBUTES = new Set([
    'alt',
    'allow',
    'allowfullscreen',
    'aria-label',
    'checked',
    'colspan',
    'controls',
    'data-latex',
    'data-src',
    'data-srcset',
    'data-lang',
    'dir',
    'display',
    'frameborder',
    'headers',
    'height',
    'href',
    'lang',
    'role',
    'rowspan',
    'src',
    'srcset',
    'title',
    'type',
    'width',
    // MathML attributes
    'accent',
    'accentunder',
    'align',
    'columnalign',
    'columnlines',
    'columnspacing',
    'columnspan',
    'data-mjx-texclass',
    'depth',
    'displaystyle',
    'fence',
    'frame',
    'framespacing',
    'linethickness',
    'lspace',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'scriptlevel',
    'separator',
    'stretchy',
    'symmetric',
    'voffset',
    'xmlns'
]);
exports.ALLOWED_ATTRIBUTES_DEBUG = new Set([
    'class',
    'id',
]);
// Supported languages for code blocks
exports.SUPPORTED_LANGUAGES = new Set([
    // Markup & Web
    'markup', 'html', 'xml', 'svg', 'mathml', 'ssml', 'atom', 'rss',
    'javascript', 'js', 'jsx', 'typescript', 'ts', 'tsx',
    'webassembly', 'wasm',
    // Common Programming Languages
    'python',
    'java',
    'csharp', 'cs', 'dotnet', 'aspnet',
    'cpp', 'c++', 'c', 'objc',
    'ruby', 'rb',
    'php',
    'golang',
    'rust',
    'swift',
    'kotlin',
    'scala',
    'dart',
    // Shell & Scripting
    'bash', 'shell', 'sh',
    'powershell',
    'batch',
    // Data & Config
    'json', 'jsonp',
    'yaml', 'yml',
    'toml',
    'dockerfile',
    'gitignore',
    // Query Languages
    'sql', 'mysql', 'postgresql',
    'graphql',
    'mongodb',
    'sparql',
    // Markup & Documentation
    'markdown', 'md',
    'latex', 'tex',
    'asciidoc', 'adoc',
    'jsdoc',
    // Functional Languages
    'haskell', 'hs',
    'elm',
    'elixir',
    'erlang',
    'ocaml',
    'fsharp',
    'scheme',
    'lisp', 'elisp',
    'clojure',
    // Other Languages
    'matlab',
    'fortran',
    'cobol',
    'pascal',
    'perl',
    'lua',
    'julia',
    'groovy',
    'crystal',
    'nim',
    'zig',
    // Domain Specific
    'regex',
    'gradle',
    'cmake',
    'makefile',
    'nix',
    'terraform',
    'solidity',
    'glsl',
    'hlsl',
    // Assembly
    'nasm',
    'masm',
    'armasm',
    // Game Development
    'gdscript',
    'unrealscript',
    // Others
    'abap',
    'actionscript',
    'ada',
    'agda',
    'antlr4',
    'applescript',
    'arduino',
    'coffeescript',
    'django',
    'erlang',
    'fortran',
    'haxe',
    'idris',
    'kotlin',
    'livescript',
    'matlab',
    'nginx',
    'pascal',
    'prolog',
    'puppet',
    'scala',
    'scheme',
    'tcl',
    'verilog',
    'vhdl'
]);


/***/ }),

/***/ 914:
/*!*******************************************!*\
  !*** ./node_modules/temml/dist/temml.cjs ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/**
 * This is the ParseError class, which is the main error thrown by Temml
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */
class ParseError {
  constructor(
    message, // The error message
    token // An object providing position information
  ) {
    let error = " " + message;
    let start;

    const loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      // If we have the input and a position, make the error a bit fancier

      // Get the input
      const input = loc.lexer.input;

      // Prepend some information
      start = loc.start;
      const end = loc.end;
      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": \n";
      }

      // Underline token in question using combining underscores
      const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

      // Extract some context from the input and add it to the error
      let left;
      if (start > 15) {
        left = "â€¦" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      let right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "â€¦";
      } else {
        right = input.slice(end);
      }
      error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    const self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;
    self.position = start;
    return self;
  }
}

ParseError.prototype.__proto__ = Error.prototype;

//
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide a default value if a setting is undefined
 */
const deflt = function(setting, defaultIfUndefined) {
  return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

const uppercase = /([A-Z])/g;
const hyphenate = function(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};

const ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};

const ESCAPE_REGEX = /[&><"']/g;

/**
 * Escapes text to prevent scripting attacks.
 */
function escape(text) {
  return String(text).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
const getBaseElem = function(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem(group.body);
  } else {
    return group;
  }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
const isCharacterBox = function(group) {
  const baseElem = getBaseElem(group);

  // These are all the types of groups which hold single characters
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom"
};

const assert = function(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};

/**
 * Return the protocol of a URL, or "_relative" if the URL does not specify a
 * protocol (and thus is relative), or `null` if URL has invalid protocol
 * (so should be outright rejected).
 */
const protocolFromUrl = function(url) {
  // Check for possible leading protocol.
  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace
  // (\x00) or C0 control (\x00-\x1F) characters.
  // eslint-disable-next-line no-control-regex
  const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
  if (!protocol) {
    return "_relative";
  }
  // Reject weird colons
  if (protocol[2] !== ":") {
    return null;
  }
  // Reject invalid characters in scheme according to
  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  // Lowercase the protocol
  return protocol[1].toLowerCase();
};

/**
 * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. The TeXbook
 * gives an acceptable rounding error of 100sp (which would be the nearest
 * 1/6551.6em with our ptPerEm = 10):
 * http://www.ctex.org/documents/shredder/src/texbook.pdf#page=69
 */
const round = function(n) {
  return +n.toFixed(4);
};

var utils = {
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl,
  round
};

/**
 * This is a module for storing settings passed into Temml. It correctly handles
 * default settings.
 */


/**
 * The main Settings object
 */
class Settings {
  constructor(options) {
    // allow null options
    options = options || {};
    this.displayMode = utils.deflt(options.displayMode, false);    // boolean
    this.annotate = utils.deflt(options.annotate, false);           // boolean
    this.leqno = utils.deflt(options.leqno, false);                // boolean
    this.throwOnError = utils.deflt(options.throwOnError, false);  // boolean
    this.errorColor = utils.deflt(options.errorColor, "#b22222");  // string
    this.macros = options.macros || {};
    this.wrap = utils.deflt(options.wrap, "tex");                    // "tex" | "="
    this.xml = utils.deflt(options.xml, false);                     // boolean
    this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);  // booelean
    this.strict = utils.deflt(options.strict, false);    // boolean
    this.trust = utils.deflt(options.trust, false);  // trust context. See html.js.
    this.maxSize = (options.maxSize === undefined
      ? [Infinity, Infinity]
      : Array.isArray(options.maxSize)
      ? options.maxSize
      : [Infinity, Infinity]
    );
    this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000)); // number
  }

  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      const protocol = utils.protocolFromUrl(context.url);
      if (protocol == null) {
        return false
      }
      context.protocol = protocol;
    }
    const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
}

/**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */
const _functions = {};

/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */
const _mathmlGroupBuilders = {};

function defineFunction({
  type,
  names,
  props,
  handler,
  mathmlBuilder
}) {
  // Set default values of functions
  const data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler: handler
  };
  for (let i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }
  if (type) {
    if (mathmlBuilder) {
      _mathmlGroupBuilders[type] = mathmlBuilder;
    }
  }
}

/**
 * Use this to register only the MathML builder for a function(e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */
function defineFunctionBuilders({ type, mathmlBuilder }) {
  defineFunction({
    type,
    names: [],
    props: { numArgs: 0 },
    handler() {
      throw new Error("Should never be called.")
    },
    mathmlBuilder
  });
}

const normalizeArgument = function(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg
};

// Since the corresponding buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
const ordargument = function(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg]
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */
class DocumentFragment {
  constructor(children) {
    this.children = children;
    this.classes = [];
    this.style = {};
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  /** Convert the fragment into a node. */
  toNode() {
    const frag = document.createDocumentFragment();

    for (let i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }

    return frag;
  }

  /** Convert the fragment into HTML markup. */
  toMarkup() {
    let markup = "";

    // Simply concatenate the markup for the children together.
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    // To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    const toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
}

/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 */

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */
const createClass = function(classes) {
  return classes.filter((cls) => cls).join(" ");
};

const initNode = function(classes, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.style = style || {};
};

/**
 * Convert into an HTML node
 */
const toNode = function(tagName) {
  const node = document.createElement(tagName);

  // Apply the class
  node.className = createClass(this.classes);

  // Apply inline styles
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      node.style[style] = this.style[style];
    }
  }

  // Apply attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  }

  // Append the children, also as HTML nodes
  for (let i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }

  return node;
};

/**
 * Convert into an HTML markup string
 */
const toMarkup = function(tagName) {
  let markup = `<${tagName}`;

  // Add the class
  if (this.classes.length) {
    markup += ` class="${utils.escape(createClass(this.classes))}"`;
  }

  let styles = "";

  // Add the styles, after hyphenation
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      styles += `${utils.hyphenate(style)}:${this.style[style]};`;
    }
  }

  if (styles) {
    markup += ` style="${styles}"`;
  }

  // Add the attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      markup += ` ${attr}="${utils.escape(this.attributes[attr])}"`;
    }
  }

  markup += ">";

  // Add the markup of the children, also as markup
  for (let i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }

  markup += `</${tagName}>`;

  return markup;
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style.
 *
 */
class Span {
  constructor(classes, children, style) {
    initNode.call(this, classes, style);
    this.children = children || [];
  }

  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  toNode() {
    return toNode.call(this, "span");
  }

  toMarkup() {
    return toMarkup.call(this, "span");
  }
}

let TextNode$1 = class TextNode {
  constructor(text) {
    this.text = text;
  }
  toNode() {
    return document.createTextNode(this.text);
  }
  toMarkup() {
    return utils.escape(this.text);
  }
};

// Create an <a href="â€¦"> node.
class AnchorNode {
  constructor(href, classes, children) {
    this.href = href;
    this.classes = classes;
    this.children = children || [];
  }

  toNode() {
    const node = document.createElement("a");
    node.setAttribute("href", this.href);
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node
  }

  toMarkup() {
    let markup = `<a href='${utils.escape(this.href)}'`;
    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }
    markup += ">";
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</a>";
    return markup
  }
}

/*
 * This node represents an image embed (<img>) element.
 */
class Img {
  constructor(src, alt, style) {
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  toNode() {
    const node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    return node;
  }

  toMarkup() {
    let markup = `<img src='${this.src}' alt='${this.alt}'`;

    // Add the styles, after hyphenation
    let styles = "";
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }
    if (styles) {
      markup += ` style="${utils.escape(styles)}"`;
    }

    markup += ">";
    return markup;
  }
}

//
/**
 * These objects store data about MathML nodes.
 * The `toNode` and `toMarkup` functions  create namespaced DOM nodes and
 * HTML text markup respectively.
 */


function newDocumentFragment(children) {
  return new DocumentFragment(children);
}

/**
 * This node represents a general purpose MathML node of any type,
 * for example, `"mo"` or `"mspace"`, corresponding to `<mo>` and
 * `<mspace>` tags).
 */
class MathNode {
  constructor(type, children, classes, style) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
    this.style = style || {};   // Used for <mstyle> elements
    this.label = "";
  }

  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value) {
    this.attributes[name] = value;
  }

  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }

  setLabel(value) {
    this.label = value;
  }

  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }

  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    let markup = "<" + this.type;

    // Add the attributes
    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils.escape(this.attributes[attr]);
        markup += '"';
      }
    }

    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }

    let styles = "";

    // Add the styles, after hyphenation
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }

    if (styles) {
      markup += ` style="${styles}"`;
    }

    markup += ">";

    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}

/**
 * This node represents a piece of text.
 */
class TextNode {
  constructor(text) {
    this.text = text;
  }

  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }

  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }

  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}

// Do not make an <mrow> the only child of a <mstyle>.
// An <mstyle> acts as its own implicit <mrow>.
const wrapWithMstyle = expression => {
  let node;
  if (expression.length === 1 && expression[0].type === "mrow") {
    node = expression.pop();
    node.type = "mstyle";
  } else {
    node = new MathNode("mstyle", expression);
  }
  return node
};

var mathMLTree = {
  MathNode,
  TextNode,
  newDocumentFragment
};

/**
 * This file provides support for building horizontal stretchy elements.
 */


// TODO: Remove when Chromium stretches \widetilde & \widehat
const estimatedWidth = node => {
  let width = 0;
  if (node.body) {
    for (const item of node.body) {
      width += estimatedWidth(item);
    }
  } else if (node.type === "supsub") {
    width += estimatedWidth(node.base);
    if (node.sub) { width += 0.7 * estimatedWidth(node.sub); }
    if (node.sup) { width += 0.7 * estimatedWidth(node.sup); }
  } else if (node.type === "mathord" || node.type === "textord") {
    for (const ch of node.text.split('')) {
      const codePoint = ch.codePointAt(0);
      if ((0x60 < codePoint && codePoint < 0x7B) || (0x03B0 < codePoint && codePoint < 0x3CA)) {
        width += 0.56; // lower case latin or greek. Use advance width of letter n
      } else if (0x2F < codePoint && codePoint < 0x3A) {
        width += 0.50; // numerals.
      } else {
        width += 0.92; // advance width of letter M
      }
    }
  } else {
    width += 1.0;
  }
  return width
};

const stretchyCodePoint = {
  widehat: "^",
  widecheck: "Ë‡",
  widetilde: "~",
  wideparen: "âœ", // \u23dc
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23df",
  overbrace: "\u23de",
  overgroup: "\u23e0",
  overparen: "âœ",
  undergroup: "\u23e1",
  underparen: "\u23dd",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21d2",
  xRightarrow: "\u21d2",
  overleftharpoon: "\u21bc",
  xleftharpoonup: "\u21bc",
  overrightharpoon: "\u21c0",
  xrightharpoonup: "\u21c0",
  xLeftarrow: "\u21d0",
  xLeftrightarrow: "\u21d4",
  xhookleftarrow: "\u21a9",
  xhookrightarrow: "\u21aa",
  xmapsto: "\u21a6",
  xrightharpoondown: "\u21c1",
  xleftharpoondown: "\u21bd",
  xtwoheadleftarrow: "\u219e",
  xtwoheadrightarrow: "\u21a0",
  xlongequal: "=",
  xrightleftarrows: "\u21c4",
  yields: "\u2192",
  yieldsLeft: "\u2190",
  mesomerism: "\u2194",
  longrightharpoonup: "\u21c0",
  longleftharpoondown: "\u21bd",
  eqrightharpoonup: "\u21c0",
  eqleftharpoondown: "\u21bd",
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};

const mathMLnode = function(label) {
  const child = new mathMLTree.TextNode(stretchyCodePoint[label.slice(1)]);
  const node = new mathMLTree.MathNode("mo", [child]);
  node.setAttribute("stretchy", "true");
  return node
};

const crookedWides = ["\\widetilde", "\\widehat", "\\widecheck", "\\utilde"];

// TODO: Remove when Chromium stretches \widetilde & \widehat
const accentNode = (group) => {
  const mo = mathMLnode(group.label);
  if (crookedWides.includes(group.label)) {
    const width = estimatedWidth(group.base);
    if (1 < width && width < 1.6) {
      mo.classes.push("tml-crooked-2");
    } else if (1.6 <= width && width < 2.5) {
      mo.classes.push("tml-crooked-3");
    } else if (2.5 <= width) {
      mo.classes.push("tml-crooked-4");
    }
  }
  return mo
};

var stretchy = {
  mathMLnode,
  accentNode
};

/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are two properties they can have:
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

// Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
const ATOMS = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
};
const NON_ATOMS = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
};

const symbols = {
  math: {},
  text: {}
};

/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */
function defineSymbol(mode, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = { group, replace };

  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
const math = "math";
const text = "text";

// groups:
const accent = "accent-token";
const bin = "bin";
const close = "close";
const inner = "inner";
const mathord = "mathord";
const op = "op-token";
const open = "open";
const punct = "punct";
const rel = "rel";
const spacing = "spacing";
const textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, rel, "\u2261", "\\equiv", true);
defineSymbol(math, rel, "\u227a", "\\prec", true);
defineSymbol(math, rel, "\u227b", "\\succ", true);
defineSymbol(math, rel, "\u223c", "\\sim", true);
defineSymbol(math, rel, "\u27c2", "\\perp", true);
defineSymbol(math, rel, "\u2aaf", "\\preceq", true);
defineSymbol(math, rel, "\u2ab0", "\\succeq", true);
defineSymbol(math, rel, "\u2243", "\\simeq", true);
defineSymbol(math, rel, "\u224c", "\\backcong", true);
defineSymbol(math, rel, "|", "\\mid", true);
defineSymbol(math, rel, "\u226a", "\\ll", true);
defineSymbol(math, rel, "\u226b", "\\gg", true);
defineSymbol(math, rel, "\u224d", "\\asymp", true);
defineSymbol(math, rel, "\u2225", "\\parallel");
defineSymbol(math, rel, "\u2323", "\\smile", true);
defineSymbol(math, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, rel, "\u2250", "\\doteq", true);
defineSymbol(math, rel, "\u2322", "\\frown", true);
defineSymbol(math, rel, "\u220b", "\\ni", true);
defineSymbol(math, rel, "\u220c", "\\notni", true);
defineSymbol(math, rel, "\u221d", "\\propto", true);
defineSymbol(math, rel, "\u22a2", "\\vdash", true);
defineSymbol(math, rel, "\u22a3", "\\dashv", true);
defineSymbol(math, rel, "\u220b", "\\owns");
defineSymbol(math, rel, "\u2258", "\\arceq", true);
defineSymbol(math, rel, "\u2259", "\\wedgeq", true);
defineSymbol(math, rel, "\u225a", "\\veeeq", true);
defineSymbol(math, rel, "\u225b", "\\stareq", true);
defineSymbol(math, rel, "\u225d", "\\eqdef", true);
defineSymbol(math, rel, "\u225e", "\\measeq", true);
defineSymbol(math, rel, "\u225f", "\\questeq", true);
defineSymbol(math, rel, "\u2260", "\\ne", true);
defineSymbol(math, rel, "\u2260", "\\neq");
// unicodemath
defineSymbol(math, rel, "\u2a75", "\\eqeq", true);
defineSymbol(math, rel, "\u2a76", "\\eqeqeq", true);
// mathtools.sty
defineSymbol(math, rel, "\u2237", "\\dblcolon", true);
defineSymbol(math, rel, "\u2254", "\\coloneqq", true);
defineSymbol(math, rel, "\u2255", "\\eqqcolon", true);
defineSymbol(math, rel, "\u2239", "\\eqcolon", true);
defineSymbol(math, rel, "\u2A74", "\\Coloneqq", true);

// Punctuation
defineSymbol(math, punct, "\u002e", "\\ldotp");
defineSymbol(math, punct, "\u00b7", "\\cdotp");

// Misc Symbols
defineSymbol(math, textord, "\u0023", "\\#");
defineSymbol(text, textord, "\u0023", "\\#");
defineSymbol(math, textord, "\u0026", "\\&");
defineSymbol(text, textord, "\u0026", "\\&");
defineSymbol(math, textord, "\u2135", "\\aleph", true);
defineSymbol(math, textord, "\u2200", "\\forall", true);
defineSymbol(math, textord, "\u210f", "\\hbar", true);
defineSymbol(math, textord, "\u2203", "\\exists", true);
// âˆ‡ is actually a unary operator, not binary. But this works.
defineSymbol(math, bin, "\u2207", "\\nabla", true);
defineSymbol(math, textord, "\u266d", "\\flat", true);
defineSymbol(math, textord, "\u2113", "\\ell", true);
defineSymbol(math, textord, "\u266e", "\\natural", true);
defineSymbol(math, textord, "â„«", "\\Angstrom", true);
defineSymbol(text, textord, "â„«", "\\Angstrom", true);
defineSymbol(math, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, textord, "\u2667", "\\varclubsuit", true);
defineSymbol(math, textord, "\u2118", "\\wp", true);
defineSymbol(math, textord, "\u266f", "\\sharp", true);
defineSymbol(math, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, textord, "\u2666", "\\vardiamondsuit", true);
defineSymbol(math, textord, "\u211c", "\\Re", true);
defineSymbol(math, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, textord, "\u2665", "\\varheartsuit", true);
defineSymbol(math, textord, "\u2111", "\\Im", true);
defineSymbol(math, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, textord, "\u2664", "\\varspadesuit", true);
defineSymbol(math, textord, "\u2640", "\\female", true);
defineSymbol(math, textord, "\u2642", "\\male", true);
defineSymbol(math, textord, "\u00a7", "\\S", true);
defineSymbol(text, textord, "\u00a7", "\\S");
defineSymbol(math, textord, "\u00b6", "\\P", true);
defineSymbol(text, textord, "\u00b6", "\\P");
defineSymbol(text, textord, "\u263a", "\\smiley", true);
defineSymbol(math, textord, "\u263a", "\\smiley", true);

// Math and Text
defineSymbol(math, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\textdagger");
defineSymbol(math, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\textdaggerdbl");

// Large Delimiters
defineSymbol(math, close, "\u23b1", "\\rmoustache", true);
defineSymbol(math, open, "\u23b0", "\\lmoustache", true);
defineSymbol(math, close, "\u27ef", "\\rgroup", true);
defineSymbol(math, open, "\u27ee", "\\lgroup", true);

// Binary Operators
defineSymbol(math, bin, "\u2213", "\\mp", true);
defineSymbol(math, bin, "\u2296", "\\ominus", true);
defineSymbol(math, bin, "\u228e", "\\uplus", true);
defineSymbol(math, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, bin, "\u2217", "\\ast");
defineSymbol(math, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, bin, "\u25ef", "\\bigcirc", true);
defineSymbol(math, bin, "\u2219", "\\bullet", true);
defineSymbol(math, bin, "\u2021", "\\ddagger");
defineSymbol(math, bin, "\u2240", "\\wr", true);
defineSymbol(math, bin, "\u2a3f", "\\amalg");
defineSymbol(math, bin, "\u0026", "\\And"); // from amsmath
defineSymbol(math, bin, "\u2AFD", "\\sslash", true); // from stmaryrd

// Arrow Symbols
defineSymbol(math, rel, "\u27f5", "\\longleftarrow", true);
defineSymbol(math, rel, "\u21d0", "\\Leftarrow", true);
defineSymbol(math, rel, "\u27f8", "\\Longleftarrow", true);
defineSymbol(math, rel, "\u27f6", "\\longrightarrow", true);
defineSymbol(math, rel, "\u21d2", "\\Rightarrow", true);
defineSymbol(math, rel, "\u27f9", "\\Longrightarrow", true);
defineSymbol(math, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, rel, "\u27f7", "\\longleftrightarrow", true);
defineSymbol(math, rel, "\u21d4", "\\Leftrightarrow", true);
defineSymbol(math, rel, "\u27fa", "\\Longleftrightarrow", true);
defineSymbol(math, rel, "\u21a4", "\\mapsfrom", true);
defineSymbol(math, rel, "\u21a6", "\\mapsto", true);
defineSymbol(math, rel, "\u27fc", "\\longmapsto", true);
defineSymbol(math, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, rel, "\u21a9", "\\hookleftarrow", true);
defineSymbol(math, rel, "\u21aa", "\\hookrightarrow", true);
defineSymbol(math, rel, "\u2198", "\\searrow", true);
defineSymbol(math, rel, "\u21bc", "\\leftharpoonup", true);
defineSymbol(math, rel, "\u21c0", "\\rightharpoonup", true);
defineSymbol(math, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, rel, "\u21bd", "\\leftharpoondown", true);
defineSymbol(math, rel, "\u21c1", "\\rightharpoondown", true);
defineSymbol(math, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, rel, "\u21cc", "\\rightleftharpoons", true);
defineSymbol(math, mathord, "\u21af", "\\lightning", true);
defineSymbol(math, mathord, "\u220E", "\\QED", true);
defineSymbol(math, mathord, "\u2030", "\\permil", true);
defineSymbol(text, textord, "\u2030", "\\permil");
defineSymbol(math, mathord, "\u2609", "\\astrosun", true);
defineSymbol(math, mathord, "\u263c", "\\sun", true);
defineSymbol(math, mathord, "\u263e", "\\leftmoon", true);
defineSymbol(math, mathord, "\u263d", "\\rightmoon", true);
defineSymbol(math, mathord, "\u2295", "\\Earth");

// AMS Negated Binary Relations
defineSymbol(math, rel, "\u226e", "\\nless", true);
// Symbol names preceeded by "@" each have a corresponding macro.
defineSymbol(math, rel, "\u2a87", "\\lneq", true);
defineSymbol(math, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, rel, "\u2268\ufe00", "\\lvertneqq");
defineSymbol(math, rel, "\u22e6", "\\lnsim", true);
defineSymbol(math, rel, "\u2a89", "\\lnapprox", true);
defineSymbol(math, rel, "\u2280", "\\nprec", true);
// unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e0", "\\npreceq", true);
defineSymbol(math, rel, "\u22e8", "\\precnsim", true);
defineSymbol(math, rel, "\u2ab9", "\\precnapprox", true);
defineSymbol(math, rel, "\u2241", "\\nsim", true);
defineSymbol(math, rel, "\u2224", "\\nmid", true);
defineSymbol(math, rel, "\u2224", "\\nshortmid");
defineSymbol(math, rel, "\u22ac", "\\nvdash", true);
defineSymbol(math, rel, "\u22ad", "\\nvDash", true);
defineSymbol(math, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, rel, "\u22ec", "\\ntrianglelefteq", true);
defineSymbol(math, rel, "\u2284", "\\nsubset", true);
defineSymbol(math, rel, "\u2285", "\\nsupset", true);
defineSymbol(math, rel, "\u228a", "\\subsetneq", true);
defineSymbol(math, rel, "\u228a\ufe00", "\\varsubsetneq");
defineSymbol(math, rel, "\u2acb", "\\subsetneqq", true);
defineSymbol(math, rel, "\u2acb\ufe00", "\\varsubsetneqq");
defineSymbol(math, rel, "\u226f", "\\ngtr", true);
defineSymbol(math, rel, "\u2a88", "\\gneq", true);
defineSymbol(math, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, rel, "\u2269\ufe00", "\\gvertneqq");
defineSymbol(math, rel, "\u22e7", "\\gnsim", true);
defineSymbol(math, rel, "\u2a8a", "\\gnapprox", true);
defineSymbol(math, rel, "\u2281", "\\nsucc", true);
// unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e1", "\\nsucceq", true);
defineSymbol(math, rel, "\u22e9", "\\succnsim", true);
defineSymbol(math, rel, "\u2aba", "\\succnapprox", true);
// unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u2246", "\\ncong", true);
defineSymbol(math, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, rel, "\u2226", "\\nshortparallel");
defineSymbol(math, rel, "\u22af", "\\nVDash", true);
defineSymbol(math, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, rel, "\u22ed", "\\ntrianglerighteq", true);
defineSymbol(math, rel, "\u228b", "\\supsetneq", true);
defineSymbol(math, rel, "\u228b", "\\varsupsetneq");
defineSymbol(math, rel, "\u2acc", "\\supsetneqq", true);
defineSymbol(math, rel, "\u2acc\ufe00", "\\varsupsetneqq");
defineSymbol(math, rel, "\u22ae", "\\nVdash", true);
defineSymbol(math, rel, "\u2ab5", "\\precneqq", true);
defineSymbol(math, rel, "\u2ab6", "\\succneqq", true);
defineSymbol(math, bin, "\u22b4", "\\unlhd");
defineSymbol(math, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, rel, "\u219a", "\\nleftarrow", true);
defineSymbol(math, rel, "\u219b", "\\nrightarrow", true);
defineSymbol(math, rel, "\u21cd", "\\nLeftarrow", true);
defineSymbol(math, rel, "\u21cf", "\\nRightarrow", true);
defineSymbol(math, rel, "\u21ae", "\\nleftrightarrow", true);
defineSymbol(math, rel, "\u21ce", "\\nLeftrightarrow", true);

// AMS Misc
defineSymbol(math, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, textord, "\u210f", "\\hslash");
defineSymbol(math, textord, "\u25bd", "\\triangledown");
defineSymbol(math, textord, "\u25ca", "\\lozenge");
defineSymbol(math, textord, "\u24c8", "\\circledS");
defineSymbol(math, textord, "\u00ae", "\\circledR", true);
defineSymbol(text, textord, "\u00ae", "\\circledR");
defineSymbol(text, textord, "\u00ae", "\\textregistered");
defineSymbol(math, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, textord, "\u2204", "\\nexists");
defineSymbol(math, textord, "\u2127", "\\mho");
defineSymbol(math, textord, "\u2132", "\\Finv", true);
defineSymbol(math, textord, "\u2141", "\\Game", true);
defineSymbol(math, textord, "\u2035", "\\backprime");
defineSymbol(math, textord, "\u2036", "\\backdprime");
defineSymbol(math, textord, "\u2037", "\\backtrprime");
defineSymbol(math, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, textord, "\u2605", "\\bigstar");
defineSymbol(math, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, textord, "\u2201", "\\complement", true);
// unicode-math maps U+F0 to \matheth. We map to AMS function \eth
defineSymbol(math, textord, "\u00f0", "\\eth", true);
defineSymbol(text, textord, "\u00f0", "\u00f0");
defineSymbol(math, textord, "\u2571", "\\diagup");
defineSymbol(math, textord, "\u2572", "\\diagdown");
defineSymbol(math, textord, "\u25a1", "\\square");
defineSymbol(math, textord, "\u25a1", "\\Box");
defineSymbol(math, textord, "\u25ca", "\\Diamond");
// unicode-math maps U+A5 to \mathyen. We map to AMS function \yen
defineSymbol(math, textord, "\u00a5", "\\yen", true);
defineSymbol(text, textord, "\u00a5", "\\yen", true);
defineSymbol(math, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, textord, "\u2713", "\\checkmark");
defineSymbol(math, textord, "\u2717", "\\ballotx", true);
defineSymbol(text, textord, "\u2717", "\\ballotx");
defineSymbol(text, textord, "\u2022", "\\textbullet");

// AMS Hebrew
defineSymbol(math, textord, "\u2136", "\\beth", true);
defineSymbol(math, textord, "\u2138", "\\daleth", true);
defineSymbol(math, textord, "\u2137", "\\gimel", true);

// AMS Greek
defineSymbol(math, textord, "\u03dd", "\\digamma", true);
defineSymbol(math, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, open, "\u231C", "\\ulcorner", true);
defineSymbol(math, close, "\u231D", "\\urcorner", true);
defineSymbol(math, open, "\u231E", "\\llcorner", true);
defineSymbol(math, close, "\u231F", "\\lrcorner", true);

// AMS Binary Relations
defineSymbol(math, rel, "\u2266", "\\leqq", true);
defineSymbol(math, rel, "\u2a7d", "\\leqslant", true);
defineSymbol(math, rel, "\u2a95", "\\eqslantless", true);
defineSymbol(math, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, rel, "\u2a85", "\\lessapprox", true);
defineSymbol(math, rel, "\u224a", "\\approxeq", true);
defineSymbol(math, bin, "\u22d6", "\\lessdot");
defineSymbol(math, rel, "\u22d8", "\\lll", true);
defineSymbol(math, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, rel, "\u22da", "\\lesseqgtr", true);
defineSymbol(math, rel, "\u2a8b", "\\lesseqqgtr", true);
defineSymbol(math, rel, "\u2251", "\\doteqdot");
defineSymbol(math, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, rel, "\u223d", "\\backsim", true);
defineSymbol(math, rel, "\u22cd", "\\backsimeq", true);
defineSymbol(math, rel, "\u2ac5", "\\subseteqq", true);
defineSymbol(math, rel, "\u22d0", "\\Subset", true);
defineSymbol(math, rel, "\u228f", "\\sqsubset", true);
defineSymbol(math, rel, "\u227c", "\\preccurlyeq", true);
defineSymbol(math, rel, "\u22de", "\\curlyeqprec", true);
defineSymbol(math, rel, "\u227e", "\\precsim", true);
defineSymbol(math, rel, "\u2ab7", "\\precapprox", true);
defineSymbol(math, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, rel, "\u22a8", "\\vDash", true);
defineSymbol(math, rel, "\u22ab", "\\VDash", true);
defineSymbol(math, rel, "\u22aa", "\\Vvdash", true);
defineSymbol(math, rel, "\u2323", "\\smallsmile");
defineSymbol(math, rel, "\u2322", "\\smallfrown");
defineSymbol(math, rel, "\u224f", "\\bumpeq", true);
defineSymbol(math, rel, "\u224e", "\\Bumpeq", true);
defineSymbol(math, rel, "\u2267", "\\geqq", true);
defineSymbol(math, rel, "\u2a7e", "\\geqslant", true);
defineSymbol(math, rel, "\u2a96", "\\eqslantgtr", true);
defineSymbol(math, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, rel, "\u2a86", "\\gtrapprox", true);
defineSymbol(math, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, rel, "\u22d9", "\\ggg", true);
defineSymbol(math, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, rel, "\u22db", "\\gtreqless", true);
defineSymbol(math, rel, "\u2a8c", "\\gtreqqless", true);
defineSymbol(math, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, rel, "\u2257", "\\circeq", true);
defineSymbol(math, rel, "\u225c", "\\triangleq", true);
defineSymbol(math, rel, "\u223c", "\\thicksim");
defineSymbol(math, rel, "\u2248", "\\thickapprox");
defineSymbol(math, rel, "\u2ac6", "\\supseteqq", true);
defineSymbol(math, rel, "\u22d1", "\\Supset", true);
defineSymbol(math, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, rel, "\u227d", "\\succcurlyeq", true);
defineSymbol(math, rel, "\u22df", "\\curlyeqsucc", true);
defineSymbol(math, rel, "\u227f", "\\succsim", true);
defineSymbol(math, rel, "\u2ab8", "\\succapprox", true);
defineSymbol(math, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, rel, "\u22a9", "\\Vdash", true);
defineSymbol(math, rel, "\u2223", "\\shortmid");
defineSymbol(math, rel, "\u2225", "\\shortparallel");
defineSymbol(math, rel, "\u226c", "\\between", true);
defineSymbol(math, rel, "\u22d4", "\\pitchfork", true);
defineSymbol(math, rel, "\u221d", "\\varpropto");
defineSymbol(math, rel, "\u25c0", "\\blacktriangleleft");
// unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2234", "\\therefore", true);
defineSymbol(math, rel, "\u220d", "\\backepsilon");
defineSymbol(math, rel, "\u25b6", "\\blacktriangleright");
// unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2235", "\\because", true);
defineSymbol(math, rel, "\u22d8", "\\llless");
defineSymbol(math, rel, "\u22d9", "\\gggtr");
defineSymbol(math, bin, "\u22b2", "\\lhd");
defineSymbol(math, bin, "\u22b3", "\\rhd");
defineSymbol(math, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, rel, "\u2251", "\\Doteq", true);
defineSymbol(math, rel, "\u297d", "\\strictif", true);
defineSymbol(math, rel, "\u297c", "\\strictfi", true);

// AMS Binary Operators
defineSymbol(math, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, bin, "\u22d2", "\\Cap", true);
defineSymbol(math, bin, "\u22d3", "\\Cup", true);
defineSymbol(math, bin, "\u2a5e", "\\doublebarwedge", true);
defineSymbol(math, bin, "\u229f", "\\boxminus", true);
defineSymbol(math, bin, "\u229e", "\\boxplus", true);
defineSymbol(math, bin, "\u29C4", "\\boxslash", true);
defineSymbol(math, bin, "\u22c7", "\\divideontimes", true);
defineSymbol(math, bin, "\u22c9", "\\ltimes", true);
defineSymbol(math, bin, "\u22ca", "\\rtimes", true);
defineSymbol(math, bin, "\u22cb", "\\leftthreetimes", true);
defineSymbol(math, bin, "\u22cc", "\\rightthreetimes", true);
defineSymbol(math, bin, "\u22cf", "\\curlywedge", true);
defineSymbol(math, bin, "\u22ce", "\\curlyvee", true);
defineSymbol(math, bin, "\u229d", "\\circleddash", true);
defineSymbol(math, bin, "\u229b", "\\circledast", true);
defineSymbol(math, bin, "\u22ba", "\\intercal", true);
defineSymbol(math, bin, "\u22d2", "\\doublecap");
defineSymbol(math, bin, "\u22d3", "\\doublecup");
defineSymbol(math, bin, "\u22a0", "\\boxtimes", true);
defineSymbol(math, bin, "\u22c8", "\\bowtie", true);
defineSymbol(math, bin, "\u22c8", "\\Join");
defineSymbol(math, bin, "\u27d5", "\\leftouterjoin", true);
defineSymbol(math, bin, "\u27d6", "\\rightouterjoin", true);
defineSymbol(math, bin, "\u27d7", "\\fullouterjoin", true);

// stix Binary Operators
defineSymbol(math, bin, "\u2238", "\\dotminus", true);
defineSymbol(math, bin, "\u27D1", "\\wedgedot", true);
defineSymbol(math, bin, "\u27C7", "\\veedot", true);
defineSymbol(math, bin, "\u2A62", "\\doublebarvee", true);
defineSymbol(math, bin, "\u2A63", "\\veedoublebar", true);
defineSymbol(math, bin, "\u2A5F", "\\wedgebar", true);
defineSymbol(math, bin, "\u2A60", "\\wedgedoublebar", true);
defineSymbol(math, bin, "\u2A54", "\\Vee", true);
defineSymbol(math, bin, "\u2A53", "\\Wedge", true);
defineSymbol(math, bin, "\u2A43", "\\barcap", true);
defineSymbol(math, bin, "\u2A42", "\\barcup", true);
defineSymbol(math, bin, "\u2A48", "\\capbarcup", true);
defineSymbol(math, bin, "\u2A40", "\\capdot", true);
defineSymbol(math, bin, "\u2A47", "\\capovercup", true);
defineSymbol(math, bin, "\u2A46", "\\cupovercap", true);
defineSymbol(math, bin, "\u2A4D", "\\closedvarcap", true);
defineSymbol(math, bin, "\u2A4C", "\\closedvarcup", true);
defineSymbol(math, bin, "\u2A2A", "\\minusdot", true);
defineSymbol(math, bin, "\u2A2B", "\\minusfdots", true);
defineSymbol(math, bin, "\u2A2C", "\\minusrdots", true);
defineSymbol(math, bin, "\u22BB", "\\Xor", true);
defineSymbol(math, bin, "\u22BC", "\\Nand", true);
defineSymbol(math, bin, "\u22BD", "\\Nor", true);
defineSymbol(math, bin, "\u22BD", "\\barvee");
defineSymbol(math, bin, "\u2AF4", "\\interleave", true);
defineSymbol(math, bin, "\u29E2", "\\shuffle", true);
defineSymbol(math, bin, "\u2AF6", "\\threedotcolon", true);
defineSymbol(math, bin, "\u2982", "\\typecolon", true);
defineSymbol(math, bin, "\u223E", "\\invlazys", true);
defineSymbol(math, bin, "\u2A4B", "\\twocaps", true);
defineSymbol(math, bin, "\u2A4A", "\\twocups", true);
defineSymbol(math, bin, "\u2A4E", "\\Sqcap", true);
defineSymbol(math, bin, "\u2A4F", "\\Sqcup", true);
defineSymbol(math, bin, "\u2A56", "\\veeonvee", true);
defineSymbol(math, bin, "\u2A55", "\\wedgeonwedge", true);
defineSymbol(math, bin, "\u29D7", "\\blackhourglass", true);
defineSymbol(math, bin, "\u29C6", "\\boxast", true);
defineSymbol(math, bin, "\u29C8", "\\boxbox", true);
defineSymbol(math, bin, "\u29C7", "\\boxcircle", true);
defineSymbol(math, bin, "\u229C", "\\circledequal", true);
defineSymbol(math, bin, "\u29B7", "\\circledparallel", true);
defineSymbol(math, bin, "\u29B6", "\\circledvert", true);
defineSymbol(math, bin, "\u29B5", "\\circlehbar", true);
defineSymbol(math, bin, "\u27E1", "\\concavediamond", true);
defineSymbol(math, bin, "\u27E2", "\\concavediamondtickleft", true);
defineSymbol(math, bin, "\u27E3", "\\concavediamondtickright", true);
defineSymbol(math, bin, "\u22C4", "\\diamond", true);
defineSymbol(math, bin, "\u29D6", "\\hourglass", true);
defineSymbol(math, bin, "\u27E0", "\\lozengeminus", true);
defineSymbol(math, bin, "\u233D", "\\obar", true);
defineSymbol(math, bin, "\u29B8", "\\obslash", true);
defineSymbol(math, bin, "\u2A38", "\\odiv", true);
defineSymbol(math, bin, "\u29C1", "\\ogreaterthan", true);
defineSymbol(math, bin, "\u29C0", "\\olessthan", true);
defineSymbol(math, bin, "\u29B9", "\\operp", true);
defineSymbol(math, bin, "\u2A37", "\\Otimes", true);
defineSymbol(math, bin, "\u2A36", "\\otimeshat", true);
defineSymbol(math, bin, "\u22C6", "\\star", true);
defineSymbol(math, bin, "\u25B3", "\\triangle", true);
defineSymbol(math, bin, "\u2A3A", "\\triangleminus", true);
defineSymbol(math, bin, "\u2A39", "\\triangleplus", true);
defineSymbol(math, bin, "\u2A3B", "\\triangletimes", true);
defineSymbol(math, bin, "\u27E4", "\\whitesquaretickleft", true);
defineSymbol(math, bin, "\u27E5", "\\whitesquaretickright", true);
defineSymbol(math, bin, "\u2A33", "\\smashtimes", true);

// AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.
defineSymbol(math, rel, "\u21e2", "\\dashrightarrow", true);
// unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21e0", "\\dashleftarrow", true);
defineSymbol(math, rel, "\u21c7", "\\leftleftarrows", true);
defineSymbol(math, rel, "\u21c6", "\\leftrightarrows", true);
defineSymbol(math, rel, "\u21da", "\\Lleftarrow", true);
defineSymbol(math, rel, "\u219e", "\\twoheadleftarrow", true);
defineSymbol(math, rel, "\u21a2", "\\leftarrowtail", true);
defineSymbol(math, rel, "\u21ab", "\\looparrowleft", true);
defineSymbol(math, rel, "\u21cb", "\\leftrightharpoons", true);
defineSymbol(math, rel, "\u21b6", "\\curvearrowleft", true);
// unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21ba", "\\circlearrowleft", true);
defineSymbol(math, rel, "\u21b0", "\\Lsh", true);
defineSymbol(math, rel, "\u21c8", "\\upuparrows", true);
defineSymbol(math, rel, "\u21bf", "\\upharpoonleft", true);
defineSymbol(math, rel, "\u21c3", "\\downharpoonleft", true);
defineSymbol(math, rel, "\u22b6", "\\origof", true);
defineSymbol(math, rel, "\u22b7", "\\imageof", true);
defineSymbol(math, rel, "\u22b8", "\\multimap", true);
defineSymbol(math, rel, "\u21ad", "\\leftrightsquigarrow", true);
defineSymbol(math, rel, "\u21c9", "\\rightrightarrows", true);
defineSymbol(math, rel, "\u21c4", "\\rightleftarrows", true);
defineSymbol(math, rel, "\u21a0", "\\twoheadrightarrow", true);
defineSymbol(math, rel, "\u21a3", "\\rightarrowtail", true);
defineSymbol(math, rel, "\u21ac", "\\looparrowright", true);
defineSymbol(math, rel, "\u21b7", "\\curvearrowright", true);
// unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21bb", "\\circlearrowright", true);
defineSymbol(math, rel, "\u21b1", "\\Rsh", true);
defineSymbol(math, rel, "\u21ca", "\\downdownarrows", true);
defineSymbol(math, rel, "\u21be", "\\upharpoonright", true);
defineSymbol(math, rel, "\u21c2", "\\downharpoonright", true);
defineSymbol(math, rel, "\u21dd", "\\rightsquigarrow", true);
defineSymbol(math, rel, "\u21dd", "\\leadsto");
defineSymbol(math, rel, "\u21db", "\\Rrightarrow", true);
defineSymbol(math, rel, "\u21be", "\\restriction");

defineSymbol(math, textord, "\u2018", "`");
defineSymbol(math, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\textdollar");
defineSymbol(math, textord, "Â¢", "\\cent");
defineSymbol(text, textord, "Â¢", "\\cent");
defineSymbol(math, textord, "%", "\\%");
defineSymbol(text, textord, "%", "\\%");
defineSymbol(math, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\textunderscore");
defineSymbol(text, textord, "\u2423", "\\textvisiblespace", true);
defineSymbol(math, textord, "\u2220", "\\angle", true);
defineSymbol(math, textord, "\u221e", "\\infty", true);
defineSymbol(math, textord, "\u2032", "\\prime");
defineSymbol(math, textord, "\u2033", "\\dprime");
defineSymbol(math, textord, "\u2034", "\\trprime");
defineSymbol(math, textord, "\u2057", "\\qprime");
defineSymbol(math, textord, "\u25b3", "\\triangle");
defineSymbol(text, textord, "\u0391", "\\Alpha", true);
defineSymbol(text, textord, "\u0392", "\\Beta", true);
defineSymbol(text, textord, "\u0393", "\\Gamma", true);
defineSymbol(text, textord, "\u0394", "\\Delta", true);
defineSymbol(text, textord, "\u0395", "\\Epsilon", true);
defineSymbol(text, textord, "\u0396", "\\Zeta", true);
defineSymbol(text, textord, "\u0397", "\\Eta", true);
defineSymbol(text, textord, "\u0398", "\\Theta", true);
defineSymbol(text, textord, "\u0399", "\\Iota", true);
defineSymbol(text, textord, "\u039a", "\\Kappa", true);
defineSymbol(text, textord, "\u039b", "\\Lambda", true);
defineSymbol(text, textord, "\u039c", "\\Mu", true);
defineSymbol(text, textord, "\u039d", "\\Nu", true);
defineSymbol(text, textord, "\u039e", "\\Xi", true);
defineSymbol(text, textord, "\u039f", "\\Omicron", true);
defineSymbol(text, textord, "\u03a0", "\\Pi", true);
defineSymbol(text, textord, "\u03a1", "\\Rho", true);
defineSymbol(text, textord, "\u03a3", "\\Sigma", true);
defineSymbol(text, textord, "\u03a4", "\\Tau", true);
defineSymbol(text, textord, "\u03a5", "\\Upsilon", true);
defineSymbol(text, textord, "\u03a6", "\\Phi", true);
defineSymbol(text, textord, "\u03a7", "\\Chi", true);
defineSymbol(text, textord, "\u03a8", "\\Psi", true);
defineSymbol(text, textord, "\u03a9", "\\Omega", true);
defineSymbol(math, mathord, "\u0391", "\\Alpha", true);
defineSymbol(math, mathord, "\u0392", "\\Beta", true);
defineSymbol(math, mathord, "\u0393", "\\Gamma", true);
defineSymbol(math, mathord, "\u0394", "\\Delta", true);
defineSymbol(math, mathord, "\u0395", "\\Epsilon", true);
defineSymbol(math, mathord, "\u0396", "\\Zeta", true);
defineSymbol(math, mathord, "\u0397", "\\Eta", true);
defineSymbol(math, mathord, "\u0398", "\\Theta", true);
defineSymbol(math, mathord, "\u0399", "\\Iota", true);
defineSymbol(math, mathord, "\u039a", "\\Kappa", true);
defineSymbol(math, mathord, "\u039b", "\\Lambda", true);
defineSymbol(math, mathord, "\u039c", "\\Mu", true);
defineSymbol(math, mathord, "\u039d", "\\Nu", true);
defineSymbol(math, mathord, "\u039e", "\\Xi", true);
defineSymbol(math, mathord, "\u039f", "\\Omicron", true);
defineSymbol(math, mathord, "\u03a0", "\\Pi", true);
defineSymbol(math, mathord, "\u03a1", "\\Rho", true);
defineSymbol(math, mathord, "\u03a3", "\\Sigma", true);
defineSymbol(math, mathord, "\u03a4", "\\Tau", true);
defineSymbol(math, mathord, "\u03a5", "\\Upsilon", true);
defineSymbol(math, mathord, "\u03a6", "\\Phi", true);
defineSymbol(math, mathord, "\u03a7", "\\Chi", true);
defineSymbol(math, mathord, "\u03a8", "\\Psi", true);
defineSymbol(math, mathord, "\u03a9", "\\Omega", true);
defineSymbol(math, open, "\u00ac", "\\neg", true);
defineSymbol(math, open, "\u00ac", "\\lnot");
defineSymbol(math, textord, "\u22a4", "\\top");
defineSymbol(math, textord, "\u22a5", "\\bot");
defineSymbol(math, textord, "\u2205", "\\emptyset");
defineSymbol(math, textord, "\u2300", "\\varnothing");
defineSymbol(math, mathord, "\u03b1", "\\alpha", true);
defineSymbol(math, mathord, "\u03b2", "\\beta", true);
defineSymbol(math, mathord, "\u03b3", "\\gamma", true);
defineSymbol(math, mathord, "\u03b4", "\\delta", true);
defineSymbol(math, mathord, "\u03f5", "\\epsilon", true);
defineSymbol(math, mathord, "\u03b6", "\\zeta", true);
defineSymbol(math, mathord, "\u03b7", "\\eta", true);
defineSymbol(math, mathord, "\u03b8", "\\theta", true);
defineSymbol(math, mathord, "\u03b9", "\\iota", true);
defineSymbol(math, mathord, "\u03ba", "\\kappa", true);
defineSymbol(math, mathord, "\u03bb", "\\lambda", true);
defineSymbol(math, mathord, "\u03bc", "\\mu", true);
defineSymbol(math, mathord, "\u03bd", "\\nu", true);
defineSymbol(math, mathord, "\u03be", "\\xi", true);
defineSymbol(math, mathord, "\u03bf", "\\omicron", true);
defineSymbol(math, mathord, "\u03c0", "\\pi", true);
defineSymbol(math, mathord, "\u03c1", "\\rho", true);
defineSymbol(math, mathord, "\u03c3", "\\sigma", true);
defineSymbol(math, mathord, "\u03c4", "\\tau", true);
defineSymbol(math, mathord, "\u03c5", "\\upsilon", true);
defineSymbol(math, mathord, "\u03d5", "\\phi", true);
defineSymbol(math, mathord, "\u03c7", "\\chi", true);
defineSymbol(math, mathord, "\u03c8", "\\psi", true);
defineSymbol(math, mathord, "\u03c9", "\\omega", true);
defineSymbol(math, mathord, "\u03b5", "\\varepsilon", true);
defineSymbol(math, mathord, "\u03d1", "\\vartheta", true);
defineSymbol(math, mathord, "\u03d6", "\\varpi", true);
defineSymbol(math, mathord, "\u03f1", "\\varrho", true);
defineSymbol(math, mathord, "\u03c2", "\\varsigma", true);
defineSymbol(math, mathord, "\u03c6", "\\varphi", true);
defineSymbol(math, mathord, "\u03d8", "\\Coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\varcoppa", true);
defineSymbol(math, mathord, "\u03de", "\\Koppa", true);
defineSymbol(math, mathord, "\u03df", "\\koppa", true);
defineSymbol(math, mathord, "\u03e0", "\\Sampi", true);
defineSymbol(math, mathord, "\u03e1", "\\sampi", true);
defineSymbol(math, mathord, "\u03da", "\\Stigma", true);
defineSymbol(math, mathord, "\u03db", "\\stigma", true);
defineSymbol(math, mathord, "\u2aeb", "\\Bot");
defineSymbol(math, bin, "\u2217", "\u2217", true);
defineSymbol(math, bin, "+", "+");
defineSymbol(math, bin, "\u2217", "*");
defineSymbol(math, bin, "\u2044", "/", true);
defineSymbol(math, bin, "\u2044", "\u2044");
defineSymbol(math, bin, "\u2212", "-", true);
defineSymbol(math, bin, "\u22c5", "\\cdot", true);
defineSymbol(math, bin, "\u2218", "\\circ", true);
defineSymbol(math, bin, "\u00f7", "\\div", true);
defineSymbol(math, bin, "\u00b1", "\\pm", true);
defineSymbol(math, bin, "\u00d7", "\\times", true);
defineSymbol(math, bin, "\u2229", "\\cap", true);
defineSymbol(math, bin, "\u222a", "\\cup", true);
defineSymbol(math, bin, "\u2216", "\\setminus", true);
defineSymbol(math, bin, "\u2227", "\\land");
defineSymbol(math, bin, "\u2228", "\\lor");
defineSymbol(math, bin, "\u2227", "\\wedge", true);
defineSymbol(math, bin, "\u2228", "\\vee", true);
defineSymbol(math, open, "\u27e6", "\\llbracket", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u27e7", "\\rrbracket", true);
defineSymbol(math, open, "\u27e8", "\\langle", true);
defineSymbol(math, open, "\u27ea", "\\lAngle", true);
defineSymbol(math, open, "\u2989", "\\llangle", true);
defineSymbol(math, open, "|", "\\lvert");
defineSymbol(math, open, "\u2016", "\\lVert", true);
defineSymbol(math, textord, "!", "\\oc"); // cmll package
defineSymbol(math, textord, "?", "\\wn");
defineSymbol(math, textord, "\u2193", "\\shpos");
defineSymbol(math, textord, "\u2195", "\\shift");
defineSymbol(math, textord, "\u2191", "\\shneg");
defineSymbol(math, close, "?", "?");
defineSymbol(math, close, "!", "!");
defineSymbol(math, close, "â€¼", "â€¼");
defineSymbol(math, close, "\u27e9", "\\rangle", true);
defineSymbol(math, close, "\u27eb", "\\rAngle", true);
defineSymbol(math, close, "\u298a", "\\rrangle", true);
defineSymbol(math, close, "|", "\\rvert");
defineSymbol(math, close, "\u2016", "\\rVert");
defineSymbol(math, open, "\u2983", "\\lBrace", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u2984", "\\rBrace", true);
defineSymbol(math, rel, "=", "\\equal", true);
defineSymbol(math, rel, ":", ":");
defineSymbol(math, rel, "\u2248", "\\approx", true);
defineSymbol(math, rel, "\u2245", "\\cong", true);
defineSymbol(math, rel, "\u2265", "\\ge");
defineSymbol(math, rel, "\u2265", "\\geq", true);
defineSymbol(math, rel, "\u2190", "\\gets");
defineSymbol(math, rel, ">", "\\gt", true);
defineSymbol(math, rel, "\u2208", "\\in", true);
defineSymbol(math, rel, "\u2209", "\\notin", true);
defineSymbol(math, rel, "\ue020", "\\@not");
defineSymbol(math, rel, "\u2282", "\\subset", true);
defineSymbol(math, rel, "\u2283", "\\supset", true);
defineSymbol(math, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteqq");
defineSymbol(math, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, rel, "\u2289", "\\nsupseteqq");
defineSymbol(math, rel, "\u22a8", "\\models");
defineSymbol(math, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, rel, "\u2264", "\\le");
defineSymbol(math, rel, "\u2264", "\\leq", true);
defineSymbol(math, rel, "<", "\\lt", true);
defineSymbol(math, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, rel, "\u2192", "\\to");
defineSymbol(math, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, rel, "\u2271", "\\ngeqq");
defineSymbol(math, rel, "\u2271", "\\ngeqslant");
defineSymbol(math, rel, "\u2270", "\\nleq", true);
defineSymbol(math, rel, "\u2270", "\\nleqq");
defineSymbol(math, rel, "\u2270", "\\nleqslant");
defineSymbol(math, rel, "\u2aeb", "\\Perp", true); //cmll package
defineSymbol(math, spacing, "\u00a0", "\\ ");
defineSymbol(math, spacing, "\u00a0", "\\space");
// Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%
defineSymbol(math, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(text, spacing, "\u00a0", "\\ ");
defineSymbol(text, spacing, "\u00a0", " ");
defineSymbol(text, spacing, "\u00a0", "\\space");
defineSymbol(text, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(math, spacing, null, "\\nobreak");
defineSymbol(math, spacing, null, "\\allowbreak");
defineSymbol(math, punct, ",", ",");
defineSymbol(text, punct, ":", ":");
defineSymbol(math, punct, ";", ";");
defineSymbol(math, bin, "\u22bc", "\\barwedge");
defineSymbol(math, bin, "\u22bb", "\\veebar");
defineSymbol(math, bin, "\u2299", "\\odot", true);
// Firefox turns âŠ• into an emoji. So append \uFE0E. Define Unicode character in macros, not here.
defineSymbol(math, bin, "\u2295\uFE0E", "\\oplus");
defineSymbol(math, bin, "\u2297", "\\otimes", true);
defineSymbol(math, textord, "\u2202", "\\partial", true);
defineSymbol(math, bin, "\u2298", "\\oslash", true);
defineSymbol(math, bin, "\u229a", "\\circledcirc", true);
defineSymbol(math, bin, "\u22a1", "\\boxdot", true);
defineSymbol(math, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, bin, "\u2020", "\\dagger");
defineSymbol(math, bin, "\u22c4", "\\diamond");
defineSymbol(math, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, bin, "\u25b9", "\\triangleright");
defineSymbol(math, open, "{", "\\{");
defineSymbol(text, textord, "{", "\\{");
defineSymbol(text, textord, "{", "\\textbraceleft");
defineSymbol(math, close, "}", "\\}");
defineSymbol(text, textord, "}", "\\}");
defineSymbol(text, textord, "}", "\\textbraceright");
defineSymbol(math, open, "{", "\\lbrace");
defineSymbol(math, close, "}", "\\rbrace");
defineSymbol(math, open, "[", "\\lbrack", true);
defineSymbol(text, textord, "[", "\\lbrack", true);
defineSymbol(math, close, "]", "\\rbrack", true);
defineSymbol(text, textord, "]", "\\rbrack", true);
defineSymbol(math, open, "(", "\\lparen", true);
defineSymbol(math, close, ")", "\\rparen", true);
defineSymbol(math, open, "â¦‡", "\\llparenthesis", true);
defineSymbol(math, close, "â¦ˆ", "\\rrparenthesis", true);
defineSymbol(text, textord, "<", "\\textless", true); // in T1 fontenc
defineSymbol(text, textord, ">", "\\textgreater", true); // in T1 fontenc
defineSymbol(math, open, "\u230a", "\\lfloor", true);
defineSymbol(math, close, "\u230b", "\\rfloor", true);
defineSymbol(math, open, "\u2308", "\\lceil", true);
defineSymbol(math, close, "\u2309", "\\rceil", true);
defineSymbol(math, textord, "\\", "\\backslash");
defineSymbol(math, textord, "|", "|");
defineSymbol(math, textord, "|", "\\vert");
defineSymbol(text, textord, "|", "\\textbar", true); // in T1 fontenc
defineSymbol(math, textord, "\u2016", "\\|");
defineSymbol(math, textord, "\u2016", "\\Vert");
defineSymbol(text, textord, "\u2016", "\\textbardbl");
defineSymbol(text, textord, "~", "\\textasciitilde");
defineSymbol(text, textord, "\\", "\\textbackslash");
defineSymbol(text, textord, "^", "\\textasciicircum");
defineSymbol(math, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, rel, "\u21d1", "\\Uparrow", true);
defineSymbol(math, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, rel, "\u21d3", "\\Downarrow", true);
defineSymbol(math, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, rel, "\u21d5", "\\Updownarrow", true);
defineSymbol(math, op, "\u2210", "\\coprod");
defineSymbol(math, op, "\u22c1", "\\bigvee");
defineSymbol(math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, op, "\u2a04", "\\biguplus");
defineSymbol(math, op, "\u2a04", "\\bigcupplus");
defineSymbol(math, op, "\u2a03", "\\bigcupdot");
defineSymbol(math, op, "\u2a07", "\\bigdoublevee");
defineSymbol(math, op, "\u2a08", "\\bigdoublewedge");
defineSymbol(math, op, "\u22c2", "\\bigcap");
defineSymbol(math, op, "\u22c3", "\\bigcup");
defineSymbol(math, op, "\u222b", "\\int");
defineSymbol(math, op, "\u222b", "\\intop");
defineSymbol(math, op, "\u222c", "\\iint");
defineSymbol(math, op, "\u222d", "\\iiint");
defineSymbol(math, op, "\u220f", "\\prod");
defineSymbol(math, op, "\u2211", "\\sum");
defineSymbol(math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, op, "\u2a00", "\\bigodot");
defineSymbol(math, op, "\u2a09", "\\bigtimes");
defineSymbol(math, op, "\u222e", "\\oint");
defineSymbol(math, op, "\u222f", "\\oiint");
defineSymbol(math, op, "\u2230", "\\oiiint");
defineSymbol(math, op, "\u2231", "\\intclockwise");
defineSymbol(math, op, "\u2232", "\\varointclockwise");
defineSymbol(math, op, "\u2a0c", "\\iiiint");
defineSymbol(math, op, "\u2a0d", "\\intbar");
defineSymbol(math, op, "\u2a0e", "\\intBar");
defineSymbol(math, op, "\u2a0f", "\\fint");
defineSymbol(math, op, "\u2a12", "\\rppolint");
defineSymbol(math, op, "\u2a13", "\\scpolint");
defineSymbol(math, op, "\u2a15", "\\pointint");
defineSymbol(math, op, "\u2a16", "\\sqint");
defineSymbol(math, op, "\u2a17", "\\intlarhk");
defineSymbol(math, op, "\u2a18", "\\intx");
defineSymbol(math, op, "\u2a19", "\\intcap");
defineSymbol(math, op, "\u2a1a", "\\intcup");
defineSymbol(math, op, "\u2a05", "\\bigsqcap");
defineSymbol(math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, op, "\u222b", "\\smallint");
defineSymbol(text, inner, "\u2026", "\\textellipsis");
defineSymbol(math, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u22f0", "\\iddots", true);
defineSymbol(math, inner, "\u22ef", "\\@cdots", true);
defineSymbol(math, inner, "\u22f1", "\\ddots", true);
defineSymbol(math, textord, "\u22ee", "\\varvdots"); // \vdots is a macro
defineSymbol(text, textord, "\u22ee", "\\varvdots");
defineSymbol(math, accent, "\u02ca", "\\acute");
defineSymbol(math, accent, "\u0060", "\\grave");
defineSymbol(math, accent, "\u00a8", "\\ddot");
defineSymbol(math, accent, "\u2026", "\\dddot");
defineSymbol(math, accent, "\u2026\u002e", "\\ddddot");
defineSymbol(math, accent, "\u007e", "\\tilde");
defineSymbol(math, accent, "\u203e", "\\bar");
defineSymbol(math, accent, "\u02d8", "\\breve");
defineSymbol(math, accent, "\u02c7", "\\check");
defineSymbol(math, accent, "\u005e", "\\hat");
defineSymbol(math, accent, "\u2192", "\\vec");
defineSymbol(math, accent, "\u02d9", "\\dot");
defineSymbol(math, accent, "\u02da", "\\mathring");
defineSymbol(math, mathord, "\u0131", "\\imath", true);
defineSymbol(math, mathord, "\u0237", "\\jmath", true);
defineSymbol(math, textord, "\u0131", "\u0131");
defineSymbol(math, textord, "\u0237", "\u0237");
defineSymbol(text, textord, "\u0131", "\\i", true);
defineSymbol(text, textord, "\u0237", "\\j", true);
defineSymbol(text, textord, "\u00df", "\\ss", true);
defineSymbol(text, textord, "\u00e6", "\\ae", true);
defineSymbol(text, textord, "\u0153", "\\oe", true);
defineSymbol(text, textord, "\u00f8", "\\o", true);
defineSymbol(math, mathord, "\u00f8", "\\o", true);
defineSymbol(text, textord, "\u00c6", "\\AE", true);
defineSymbol(text, textord, "\u0152", "\\OE", true);
defineSymbol(text, textord, "\u00d8", "\\O", true);
defineSymbol(math, mathord, "\u00d8", "\\O", true);
defineSymbol(text, accent, "\u02ca", "\\'"); // acute
defineSymbol(text, accent, "\u02cb", "\\`"); // grave
defineSymbol(text, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(text, accent, "\u02dc", "\\~"); // tilde
defineSymbol(text, accent, "\u02c9", "\\="); // macron
defineSymbol(text, accent, "\u02d8", "\\u"); // breve
defineSymbol(text, accent, "\u02d9", "\\."); // dot above
defineSymbol(text, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(text, accent, "\u02da", "\\r"); // ring above
defineSymbol(text, accent, "\u02c7", "\\v"); // caron
defineSymbol(text, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(text, accent, "\u02dd", "\\H"); // double acute
defineSymbol(math, accent, "\u02ca", "\\'"); // acute
defineSymbol(math, accent, "\u02cb", "\\`"); // grave
defineSymbol(math, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(math, accent, "\u02dc", "\\~"); // tilde
defineSymbol(math, accent, "\u02c9", "\\="); // macron
defineSymbol(math, accent, "\u02d8", "\\u"); // breve
defineSymbol(math, accent, "\u02d9", "\\."); // dot above
defineSymbol(math, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(math, accent, "\u02da", "\\r"); // ring above
defineSymbol(math, accent, "\u02c7", "\\v"); // caron
defineSymbol(math, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(math, accent, "\u02dd", "\\H"); // double acute

// These ligatures are detected and created in Parser.js's `formLigatures`.
const ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};

defineSymbol(text, textord, "\u2013", "--", true);
defineSymbol(text, textord, "\u2013", "\\textendash");
defineSymbol(text, textord, "\u2014", "---", true);
defineSymbol(text, textord, "\u2014", "\\textemdash");
defineSymbol(text, textord, "\u2018", "`", true);
defineSymbol(text, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, textord, "\u2019", "'", true);
defineSymbol(text, textord, "\u2019", "\\textquoteright");
defineSymbol(text, textord, "\u201c", "``", true);
defineSymbol(text, textord, "\u201c", "\\textquotedblleft");
defineSymbol(text, textord, "\u201d", "''", true);
defineSymbol(text, textord, "\u201d", "\\textquotedblright");
//  \degree from gensymb package
defineSymbol(math, textord, "\u00b0", "\\degree", true);
defineSymbol(text, textord, "\u00b0", "\\degree");
// \textdegree from inputenc package
defineSymbol(text, textord, "\u00b0", "\\textdegree", true);
// TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Regular defines this character "163".
defineSymbol(math, textord, "\u00a3", "\\pounds");
defineSymbol(math, textord, "\u00a3", "\\mathsterling", true);
defineSymbol(text, textord, "\u00a3", "\\pounds");
defineSymbol(text, textord, "\u00a3", "\\textsterling", true);
defineSymbol(math, textord, "\u2720", "\\maltese");
defineSymbol(text, textord, "\u2720", "\\maltese");
defineSymbol(math, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\texteuro");
defineSymbol(math, textord, "\u00a9", "\\copyright", true);
defineSymbol(text, textord, "\u00a9", "\\textcopyright");
defineSymbol(math, textord, "\u2300", "\\diameter", true);
defineSymbol(text, textord, "\u2300", "\\diameter");

// Italic Greek
defineSymbol(math, textord, "ğ›¤", "\\varGamma");
defineSymbol(math, textord, "ğ›¥", "\\varDelta");
defineSymbol(math, textord, "ğ›©", "\\varTheta");
defineSymbol(math, textord, "ğ›¬", "\\varLambda");
defineSymbol(math, textord, "ğ›¯", "\\varXi");
defineSymbol(math, textord, "ğ›±", "\\varPi");
defineSymbol(math, textord, "ğ›´", "\\varSigma");
defineSymbol(math, textord, "ğ›¶", "\\varUpsilon");
defineSymbol(math, textord, "ğ›·", "\\varPhi");
defineSymbol(math, textord, "ğ›¹", "\\varPsi");
defineSymbol(math, textord, "ğ›º", "\\varOmega");
defineSymbol(text, textord, "ğ›¤", "\\varGamma");
defineSymbol(text, textord, "ğ›¥", "\\varDelta");
defineSymbol(text, textord, "ğ›©", "\\varTheta");
defineSymbol(text, textord, "ğ›¬", "\\varLambda");
defineSymbol(text, textord, "ğ›¯", "\\varXi");
defineSymbol(text, textord, "ğ›±", "\\varPi");
defineSymbol(text, textord, "ğ›´", "\\varSigma");
defineSymbol(text, textord, "ğ›¶", "\\varUpsilon");
defineSymbol(text, textord, "ğ›·", "\\varPhi");
defineSymbol(text, textord, "ğ›¹", "\\varPsi");
defineSymbol(text, textord, "ğ›º", "\\varOmega");


// There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode
const mathTextSymbols = '0123456789/@."';
for (let i = 0; i < mathTextSymbols.length; i++) {
  const ch = mathTextSymbols.charAt(i);
  defineSymbol(math, textord, ch, ch);
}

// All of these are textords in text mode
const textSymbols = '0123456789!@*()-=+";:?/.,';
for (let i = 0; i < textSymbols.length; i++) {
  const ch = textSymbols.charAt(i);
  defineSymbol(text, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (let i = 0; i < letters.length; i++) {
  const ch = letters.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// Some more letters in Unicode Basic Multilingual Plane.
const narrow = "Ã‡ÃÃÃ§Ã¾â„‚â„â„•â„™â„šâ„â„¤â„â„â„Šâ„‹â„Œâ„â„‘â„’â„“â„˜â„›â„œâ„¬â„°â„±â„³â„­â„¨";
for (let i = 0; i < narrow.length; i++) {
  const ch = narrow.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
let wideChar = "";
for (let i = 0; i < letters.length; i++) {
  // The hex numbers in the next line are a surrogate pair.
  // 0xD835 is the high surrogate for all letters in the range we support.
  // 0xDC00 is the low surrogate for bold A.
  wideChar = String.fromCharCode(0xd835, 0xdc00 + i); // A-Z a-z bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc34 + i); // A-Z a-z italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc68 + i); // A-Z a-z bold italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd04 + i); // A-Z a-z Fractur
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdda0 + i); // A-Z a-z sans-serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xddd4 + i); // A-Z a-z sans bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde08 + i); // A-Z a-z sans italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde70 + i); // A-Z a-z monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd38 + i); // A-Z a-z double struck
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  const ch = letters.charAt(i);
  wideChar = String.fromCharCode(0xd835, 0xdc9c + i); // A-Z a-z calligraphic
  defineSymbol(math, mathord, ch, wideChar);
  defineSymbol(text, textord, ch, wideChar);
}

// Next, some wide character numerals
for (let i = 0; i < 10; i++) {
  wideChar = String.fromCharCode(0xd835, 0xdfce + i); // 0-9 bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfe2 + i); // 0-9 sans serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfec + i); // 0-9 bold sans
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdff6 + i); // 0-9 monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);
}

/*
 * Neither Firefox nor Chrome support hard line breaks or soft line breaks.
 * (Despite https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs)
 * So Temml has work-arounds for both hard and soft breaks.
 * The work-arounds sadly do not work simultaneously. Any top-level hard
 * break makes soft line breaks impossible.
 *
 * Hard breaks are simulated by creating a <mtable> and putting each line in its own <mtr>.
 *
 * To create soft line breaks, Temml avoids using the <semantics> and <annotation> tags.
 * Then the top level of a <math> element can be occupied by <mrow> elements, and the browser
 * will break after a <mrow> if the expression extends beyond the container limit.
 *
 * The default is for soft line breaks after each top-level binary or
 * relational operator, per TeXbook p. 173. So we gather the expression into <mrow>s so that
 * each <mrow> ends in a binary or relational operator.
 *
 * An option is for soft line breaks before an "=" sign. That changes the <mrow>s.
 *
 * Soft line breaks will not work in Chromium and Safari, only Firefox.
 *
 * Hopefully browsers will someday do their own linebreaking and we will be able to delete
 * much of this module.
 */

const openDelims = "([{âŒŠâŒˆâŸ¨âŸ®â°âŸ¦â¦ƒ";
const closeDelims = ")]}âŒ‹âŒ‰âŸ©âŸ¯â±âŸ¦â¦„";

function setLineBreaks(expression, wrapMode, isDisplayMode) {
  const mtrs = [];
  let mrows = [];
  let block = [];
  let numTopLevelEquals = 0;
  let i = 0;
  let level = 0;
  while (i < expression.length) {
    while (expression[i] instanceof DocumentFragment) {
      expression.splice(i, 1, ...expression[i].children); // Expand the fragment.
    }
    const node = expression[i];
    if (node.attributes && node.attributes.linebreak &&
      node.attributes.linebreak === "newline") {
      // A hard line break. Create a <mtr> for the current block.
      if (block.length > 0) {
        mrows.push(new mathMLTree.MathNode("mrow", block));
      }
      mrows.push(node);
      block = [];
      const mtd = new mathMLTree.MathNode("mtd", mrows);
      mtd.style.textAlign = "left";
      mtrs.push(new mathMLTree.MathNode("mtr", [mtd]));
      mrows = [];
      i += 1;
      continue
    }
    block.push(node);
    if (node.type && node.type === "mo" && node.children.length === 1 &&
        !Object.prototype.hasOwnProperty.call(node.attributes, "movablelimits")) {
      const ch = node.children[0].text;
      if (openDelims.indexOf(ch) > -1) {
        level += 1;
      } else if (closeDelims.indexOf(ch) > -1) {
        level -= 1;
      } else if (level === 0 && wrapMode === "=" && ch === "=") {
        numTopLevelEquals += 1;
        if (numTopLevelEquals > 1) {
          block.pop();
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [node];
        }
      } else if (level === 0 && wrapMode === "tex" && ch !== "âˆ‡") {
        // Check if the following node is a \nobreak text node, e.g. "~""
        const next = i < expression.length - 1 ? expression[i + 1] : null;
        let glueIsFreeOfNobreak = true;
        if (
          !(
            next &&
            next.type === "mtext" &&
            next.attributes.linebreak &&
            next.attributes.linebreak === "nobreak"
          )
        ) {
          // We may need to start a new block.
          // First, put any post-operator glue on same line as operator.
          for (let j = i + 1; j < expression.length; j++) {
            const nd = expression[j];
            if (
              nd.type &&
              nd.type === "mspace" &&
              !(nd.attributes.linebreak && nd.attributes.linebreak === "newline")
            ) {
              block.push(nd);
              i += 1;
              if (
                nd.attributes &&
                nd.attributes.linebreak &&
                nd.attributes.linebreak === "nobreak"
              ) {
                glueIsFreeOfNobreak = false;
              }
            } else {
              break;
            }
          }
        }
        if (glueIsFreeOfNobreak) {
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [];
        }
      }
    }
    i += 1;
  }
  if (block.length > 0) {
    const element = new mathMLTree.MathNode("mrow", block);
    mrows.push(element);
  }
  if (mtrs.length > 0) {
    const mtd = new mathMLTree.MathNode("mtd", mrows);
    mtd.style.textAlign = "left";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    mtrs.push(mtr);
    const mtable = new mathMLTree.MathNode("mtable", mtrs);
    if (!isDisplayMode) {
      mtable.setAttribute("columnalign", "left");
      mtable.setAttribute("rowspacing", "0em");
    }
    return mtable
  }
  return mathMLTree.newDocumentFragment(mrows);
}

/**
 * This file converts a parse tree into a corresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */


/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
const makeText = function(text, mode, style) {
  if (
    symbols[mode][text] &&
    symbols[mode][text].replace &&
    text.charCodeAt(0) !== 0xd835 &&
    !(
      Object.prototype.hasOwnProperty.call(ligatures, text) &&
      style &&
      ((style.fontFamily && style.fontFamily.slice(4, 6) === "tt") ||
        (style.font && style.font.slice(4, 6) === "tt"))
    )
  ) {
    text = symbols[mode][text].replace;
  }

  return new mathMLTree.TextNode(text);
};

const copyChar = (newRow, child) => {
  if (newRow.children.length === 0 ||
      newRow.children[newRow.children.length - 1].type !== "mtext") {
    const mtext = new mathMLTree.MathNode(
      "mtext",
      [new mathMLTree.TextNode(child.children[0].text)]
    );
    newRow.children.push(mtext);
  } else {
    newRow.children[newRow.children.length - 1].children[0].text += child.children[0].text;
  }
};

const consolidateText = mrow => {
  // If possible, consolidate adjacent <mtext> elements into a single element.
  if (mrow.type !== "mrow" && mrow.type !== "mstyle") { return mrow }
  if (mrow.children.length === 0) { return mrow } // empty group, e.g., \text{}
  const newRow = new mathMLTree.MathNode("mrow");
  for (let i = 0; i < mrow.children.length; i++) {
    const child = mrow.children[i];
    if (child.type === "mtext" && Object.keys(child.attributes).length === 0) {
      copyChar(newRow, child);
    } else if (child.type === "mrow") {
      // We'll also check the children of an mrow. One level only. No recursion.
      let canConsolidate = true;
      for (let j = 0; j < child.children.length; j++) {
        const grandChild = child.children[j];
        if (grandChild.type !== "mtext" || Object.keys(child.attributes).length !== 0) {
          canConsolidate = false;
          break
        }
      }
      if (canConsolidate) {
        for (let j = 0; j < child.children.length; j++) {
          const grandChild = child.children[j];
          copyChar(newRow, grandChild);
        }
      } else {
        newRow.children.push(child);
      }
    } else {
      newRow.children.push(child);
    }
  }
  for (let i = 0; i < newRow.children.length; i++) {
    if (newRow.children[i].type === "mtext") {
      const mtext = newRow.children[i];
      // Firefox does not render a space at either end of an <mtext> string.
      // To get proper rendering, we replace leading or trailing spaces with no-break spaces.
      if (mtext.children[0].text.charAt(0) === " ") {
        mtext.children[0].text = "\u00a0" + mtext.children[0].text.slice(1);
      }
      const L = mtext.children[0].text.length;
      if (L > 0 && mtext.children[0].text.charAt(L - 1) === " ") {
        mtext.children[0].text = mtext.children[0].text.slice(0, -1) + "\u00a0";
      }
      for (const [key, value] of Object.entries(mrow.attributes)) {
        mtext.attributes[key] = value;
      }
    }
  }
  if (newRow.children.length === 1 && newRow.children[0].type === "mtext") {
    return newRow.children[0]; // A consolidated <mtext>
  } else {
    return newRow
  }
};

/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */
const makeRow = function(body, semisimple = false) {
  if (body.length === 1 && !(body[0] instanceof DocumentFragment)) {
    return body[0];
  } else if (!semisimple) {
    // Suppress spacing on <mo> nodes at both ends of the row.
    if (body[0] instanceof MathNode && body[0].type === "mo" && !body[0].attributes.fence) {
      body[0].attributes.lspace = "0em";
      body[0].attributes.rspace = "0em";
    }
    const end = body.length - 1;
    if (body[end] instanceof MathNode && body[end].type === "mo" && !body[end].attributes.fence) {
      body[end].attributes.lspace = "0em";
      body[end].attributes.rspace = "0em";
    }
  }
  return new mathMLTree.MathNode("mrow", body);
};

/**
 * Check for <mi>.</mi> which is how a dot renders in MathML,
 * or <mo separator="true" lspace="0em" rspace="0em">,</mo>
 * which is how a braced comma {,} renders in MathML
 */
function isNumberPunctuation(group) {
  if (!group) {
    return false
  }
  if (group.type === 'mi' && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '.'
  } else if (group.type === "mtext" && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '\u2008' // punctuation space
  } else if (group.type === 'mo' && group.children.length === 1 &&
    group.getAttribute('separator') === 'true' &&
    group.getAttribute('lspace') === '0em' &&
    group.getAttribute('rspace') === '0em') {
    const child = group.children[0];
    return child instanceof TextNode && child.text === ','
  } else {
    return false
  }
}
const isComma = (expression, i) => {
  const node = expression[i];
  const followingNode = expression[i + 1];
  return (node.type === "atom" && node.text === ",") &&
    // Don't consolidate if there is a space after the comma.
    node.loc && followingNode.loc && node.loc.end === followingNode.loc.start
};

const isRel = item => {
  return (item.type === "atom" && item.family === "rel") ||
      (item.type === "mclass" && item.mclass === "mrel")
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also do a couple chores along the way:
 * (1) Suppress spacing when an author wraps an operator w/braces, as in {=}.
 * (2) Suppress spacing between two adjacent relations.
 */
const buildExpression = function(expression, style, semisimple = false) {
  if (!semisimple && expression.length === 1) {
    const group = buildGroup$1(expression[0], style);
    if (group instanceof MathNode && group.type === "mo") {
      // When TeX writers want to suppress spacing on an operator,
      // they often put the operator by itself inside braces.
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }

  const groups = [];
  const groupArray = [];
  let lastGroup;
  for (let i = 0; i < expression.length; i++) {
    groupArray.push(buildGroup$1(expression[i], style));
  }

  for (let i = 0; i < groupArray.length; i++) {
    const group = groupArray[i];

    // Suppress spacing between adjacent relations
    if (i < expression.length - 1 && isRel(expression[i]) && isRel(expression[i + 1])) {
      group.setAttribute("rspace", "0em");
    }
    if (i > 0 && isRel(expression[i]) && isRel(expression[i - 1])) {
      group.setAttribute("lspace", "0em");
    }

    // Concatenate numbers
    if (group.type === 'mn' && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (isNumberPunctuation(group) && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (lastGroup && lastGroup.type === "mn" && i < groupArray.length - 1 &&
      groupArray[i + 1].type === "mn" && isComma(expression, i)) {
      lastGroup.children.push(...group.children);
      continue
    } else if (group.type === 'mn' && isNumberPunctuation(lastGroup)) {
      // Concatenate <mi>.</mi> followed by <mn>...</mn>
      group.children = [...lastGroup.children, ...group.children];
      groups.pop();
    } else if ((group.type === 'msup' || group.type === 'msub') &&
        group.children.length >= 1 && lastGroup &&
        (lastGroup.type === 'mn' || isNumberPunctuation(lastGroup))) {
      // Put preceding <mn>...</mn> or <mi>.</mi> inside base of
      // <msup><mn>...base...</mn>...exponent...</msup> (or <msub>)
      const base = group.children[0];
      if (base instanceof MathNode && base.type === 'mn' && lastGroup) {
        base.children = [...lastGroup.children, ...base.children];
        groups.pop();
      }
    }
    groups.push(group);
    lastGroup = group;
  }
  return groups
};

/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */
const buildExpressionRow = function(expression, style, semisimple = false) {
  return makeRow(buildExpression(expression, style, semisimple), semisimple);
};

/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */
const buildGroup$1 = function(group, style) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }

  if (_mathmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    const result = _mathmlGroupBuilders[group.type](group, style);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};

const glue$1 = _ => {
  return new mathMLTree.MathNode("mtd", [], [], { padding: "0", width: "50%" })
};

const labelContainers = ["mrow", "mtd", "mtable", "mtr"];
const getLabel = parent => {
  for (const node of parent.children) {
    if (node.type && labelContainers.includes(node.type)) {
      if (node.classes && node.classes[0] === "tml-label") {
        const label = node.label;
        return label
      } else {
        const label = getLabel(node);
        if (label) { return label }
      }
    } else if (!node.type) {
      const label = getLabel(node);
      if (label) { return label }
    }
  }
};

const taggedExpression = (expression, tag, style, leqno) => {
  tag = buildExpressionRow(tag[0].body, style);
  tag = consolidateText(tag);
  tag.classes.push("tml-tag");

  const label = getLabel(expression); // from a \label{} function.
  expression = new mathMLTree.MathNode("mtd", [expression]);
  const rowArray = [glue$1(), expression, glue$1()];
  rowArray[leqno ? 0 : 2].classes.push(leqno ? "tml-left" : "tml-right");
  rowArray[leqno ? 0 : 2].children.push(tag);
  const mtr = new mathMLTree.MathNode("mtr", rowArray, ["tml-tageqn"]);
  if (label) { mtr.setAttribute("id", label); }
  const table = new mathMLTree.MathNode("mtable", [mtr]);
  table.style.width = "100%";
  table.setAttribute("displaystyle", "true");
  return table
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it.
 */
function buildMathML(tree, texExpression, style, settings) {
  // Strip off outer tag wrapper for processing below.
  let tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }

  const expression = buildExpression(tree, style);

  if (expression.length === 1 && expression[0] instanceof AnchorNode) {
    return expression[0]
  }

  const wrap = (settings.displayMode || settings.annotate) ? "none" : settings.wrap;

  const n1 = expression.length === 0 ? null : expression[0];
  let wrapper = expression.length === 1 && tag === null && (n1 instanceof MathNode)
      ? expression[0]
      : setLineBreaks(expression, wrap, settings.displayMode);

  if (tag) {
    wrapper = taggedExpression(wrapper, tag, style, settings.leqno);
  }

  if (settings.annotate) {
    // Build a TeX annotation of the source
    const annotation = new mathMLTree.MathNode(
      "annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    wrapper = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  }

  const math = new mathMLTree.MathNode("math", [wrapper]);

  if (settings.xml) {
    math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  }
  if (wrapper.style.width) {
    math.style.width = "100%";
  }
  if (settings.displayMode) {
    math.setAttribute("display", "block");
    math.style.display = "block math"; // necessary in Chromium.
    // Firefox and Safari do not recognize display: "block math".
    // Set a class so that the CSS file can set display: block.
    math.classes = ["tml-display"];
  }
  return math;
}

const smalls = "acegÄ±È·mnopqrsuvwxyzÎ±Î³ÎµÎ·Î¹ÎºÎ¼Î½Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï‡Ï‰Ï•ğšğœğğ ğ¦ğ§ğ¨ğ©ğªğ«ğ¬ğ®ğ¯ğ°ğ±ğ²ğ³";
const talls = "ABCDEFGHIJKLMNOPQRSTUVWXYZbdfhkltÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î²Î´Î»Î¶Ï†Î¸Ïˆ"
             + "ğ€ğğ‚ğƒğ„ğ…ğ†ğ‡ğˆğ‰ğŠğ‹ğŒğğğğğ‘ğ’ğ“ğ”ğ•ğ–ğ—ğ˜ğ™ğ›ğğŸğ¡ğ¤ğ¥ğ­";
const longSmalls = new Set(["\\alpha", "\\gamma", "\\delta", "\\epsilon", "\\eta", "\\iota",
  "\\kappa", "\\mu", "\\nu", "\\pi", "\\rho", "\\sigma", "\\tau", "\\upsilon", "\\chi", "\\psi",
  "\\omega", "\\imath", "\\jmath"]);
const longTalls = new Set(["\\Gamma", "\\Delta", "\\Sigma", "\\Omega", "\\beta", "\\delta",
  "\\lambda", "\\theta", "\\psi"]);

const mathmlBuilder$a = (group, style) => {
  const accentNode = group.isStretchy
    ? stretchy.accentNode(group)
    : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);

  if (group.label === "\\vec") {
    accentNode.style.transform = "scale(0.75) translate(10%, 30%)";
  } else {
    accentNode.style.mathStyle = "normal";
    accentNode.style.mathDepth = "0";
    if (needWebkitShift.has(group.label) &&  utils.isCharacterBox(group.base)) {
      let shift = "";
      const ch = group.base.text;
      if (smalls.indexOf(ch) > -1 || longSmalls.has(ch)) { shift = "tml-xshift"; }
      if (talls.indexOf(ch) > -1  || longTalls.has(ch))  { shift = "tml-capshift"; }
      if (shift) { accentNode.classes.push(shift); }
    }
  }
  if (!group.isStretchy) {
    accentNode.setAttribute("stretchy", "false");
  }

  const node = new mathMLTree.MathNode((group.label === "\\c" ? "munder" : "mover"),
    [buildGroup$1(group.base, style), accentNode]
  );

  return node;
};

const nonStretchyAccents = new Set([
  "\\acute",
  "\\grave",
  "\\ddot",
  "\\dddot",
  "\\ddddot",
  "\\tilde",
  "\\bar",
  "\\breve",
  "\\check",
  "\\hat",
  "\\vec",
  "\\dot",
  "\\mathring"
]);

const needWebkitShift = new Set([
  "\\acute",
  "\\bar",
  "\\breve",
  "\\check",
  "\\dot",
  "\\ddot",
  "\\grave",
  "\\hat",
  "\\mathring",
  "\\'", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"
]);

const combiningChar = {
  "\\`": "\u0300",
  "\\'": "\u0301",
  "\\^": "\u0302",
  "\\~": "\u0303",
  "\\=": "\u0304",
  "\\u": "\u0306",
  "\\.": "\u0307",
  '\\"': "\u0308",
  "\\r": "\u030A",
  "\\H": "\u030B",
  "\\v": "\u030C"
};

// Accents
defineFunction({
  type: "accent",
  names: [
    "\\acute",
    "\\grave",
    "\\ddot",
    "\\dddot",
    "\\ddddot",
    "\\tilde",
    "\\bar",
    "\\breve",
    "\\check",
    "\\hat",
    "\\vec",
    "\\dot",
    "\\mathring",
    "\\overparen",
    "\\widecheck",
    "\\widehat",
    "\\wideparen",
    "\\widetilde",
    "\\overrightarrow",
    "\\overleftarrow",
    "\\Overrightarrow",
    "\\overleftrightarrow",
    "\\overgroup",
    "\\overleftharpoon",
    "\\overrightharpoon"
  ],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);

    const isStretchy = !nonStretchyAccents.has(context.funcName);

    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: isStretchy,
      base: base
    };
  },
  mathmlBuilder: mathmlBuilder$a
});

// Text-mode accents
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\c", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);
    const mode = context.parser.mode;

    if (mode === "math" && context.parser.settings.strict) {
      // LaTeX only writes a warning. It doesn't stop. We'll issue the same warning.
      // eslint-disable-next-line no-console
      console.log(`Temml parse error: Command ${context.funcName} is invalid in math mode.`);
    }

    if (mode === "text" && base.text && base.text.length === 1
        && context.funcName in combiningChar  && smalls.indexOf(base.text) > -1) {
      // Return a combining accent character
      return {
        type: "textord",
        mode: "text",
        text: base.text + combiningChar[context.funcName]
      }
    } else {
      // Build up the accent
      return {
        type: "accent",
        mode: mode,
        label: context.funcName,
        isStretchy: false,
        base: base
      }
    }
  },
  mathmlBuilder: mathmlBuilder$a
});

defineFunction({
  type: "accentUnder",
  names: [
    "\\underleftarrow",
    "\\underrightarrow",
    "\\underleftrightarrow",
    "\\undergroup",
    "\\underparen",
    "\\utilde"
  ],
  props: {
    numArgs: 1
  },
  handler: ({ parser, funcName }, args) => {
    const base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base
    };
  },
  mathmlBuilder: (group, style) => {
    const accentNode = stretchy.accentNode(group);
    accentNode.style["math-depth"] = 0;
    const node = new mathMLTree.MathNode("munder", [
      buildGroup$1(group.base, style),
      accentNode
    ]);
    return node;
  }
});

/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into CSS units.
 */


const ptPerUnit = {
  // Convert to CSS (Postscipt) points, not TeX points
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 800 / 803, // convert TeX point to CSS (Postscript) point
  pc: (12 * 800) / 803, // pica
  dd: ((1238 / 1157) * 800) / 803, // didot
  cc: ((14856 / 1157) * 800) / 803, // cicero (12 didot)
  nd: ((685 / 642) * 800) / 803, // new didot
  nc: ((1370 / 107) * 800) / 803, // new cicero (12 new didot)
  sp: ((1 / 65536) * 800) / 803, // scaled point (TeX's internal smallest unit)
  mm: (25.4 / 72),
  cm: (2.54 / 72),
  in: (1 / 72),
  px: (96 / 72)
};

/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */
const validUnits = [
  "em",
  "ex",
  "mu",
  "pt",
  "mm",
  "cm",
  "in",
  "px",
  "bp",
  "pc",
  "dd",
  "cc",
  "nd",
  "nc",
  "sp"
];

const validUnit = function(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return validUnits.indexOf(unit) > -1
};

const emScale = styleLevel => {
  const scriptLevel = Math.max(styleLevel - 1, 0);
  return [1, 0.7, 0.5][scriptLevel]
};

/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS value.
 */
const calculateSize = function(sizeValue, style) {
  let number = sizeValue.number;
  if (style.maxSize[0] < 0 && number > 0) {
    return { number: 0, unit: "em" }
  }
  const unit = sizeValue.unit;
  switch (unit) {
    case "mm":
    case "cm":
    case "in":
    case "px": {
      const numInCssPts = number * ptPerUnit[unit];
      if (numInCssPts > style.maxSize[1]) {
        return { number: style.maxSize[1], unit: "pt" }
      }
      return { number, unit }; // absolute CSS units.
    }
    case "em":
    case "ex": {
      // In TeX, em and ex do not change size in \scriptstyle.
      if (unit === "ex") { number *= 0.431; }
      number = Math.min(number / emScale(style.level), style.maxSize[0]);
      return { number: utils.round(number), unit: "em" };
    }
    case "bp": {
      if (number > style.maxSize[1]) { number = style.maxSize[1]; }
      return { number, unit: "pt" }; // TeX bp is a CSS pt. (1/72 inch).
    }
    case "pt":
    case "pc":
    case "dd":
    case "cc":
    case "nd":
    case "nc":
    case "sp": {
      number = Math.min(number * ptPerUnit[unit], style.maxSize[1]);
      return { number: utils.round(number), unit: "pt" }
    }
    case "mu": {
      number = Math.min(number / 18, style.maxSize[0]);
      return { number: utils.round(number), unit: "em" }
    }
    default:
      throw new ParseError("Invalid unit: '" + unit + "'")
  }
};

// Helper functions

const padding$1 = width => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", width + "em");
  return node
};

const paddedNode = (group, lspace = 0.3, rspace = 0, mustSmash = false) => {
  if (group == null && rspace === 0) { return padding$1(lspace) }
  const row = group ? [group] : [];
  if (lspace !== 0)   { row.unshift(padding$1(lspace)); }
  if (rspace > 0) { row.push(padding$1(rspace)); }
  if (mustSmash) {
    // Used for the bottom arrow in a {CD} environment
    const mpadded = new mathMLTree.MathNode("mpadded", row);
    mpadded.setAttribute("height", "0");
    return mpadded
  } else {
    return new mathMLTree.MathNode("mrow", row)
  }
};

const labelSize = (size, scriptLevel) =>  Number(size) / emScale(scriptLevel);

const munderoverNode = (fName, body, below, style) => {
  const arrowNode = stretchy.mathMLnode(fName);
  // Is this the short part of a mhchem equilibrium arrow?
  const isEq = fName.slice(1, 3) === "eq";
  const minWidth = fName.charAt(1) === "x"
    ? "1.75"  // mathtools extensible arrows are â‰¥ 1.75em long
    : fName.slice(2, 4) === "cd"
    ? "3.0"  // cd package arrows
    : isEq
    ? "1.0"  // The shorter harpoon of a mhchem equilibrium arrow
    : "2.0"; // other mhchem arrows
  // TODO: When Firefox supports minsize, use the next line.
  //arrowNode.setAttribute("minsize", String(minWidth) + "em")
  arrowNode.setAttribute("lspace", "0");
  arrowNode.setAttribute("rspace", (isEq ? "0.5em" : "0"));

  // <munderover> upper and lower labels are set to scriptlevel by MathML
  // So we have to adjust our label dimensions accordingly.
  const labelStyle = style.withLevel(style.level < 2 ? 2 : 3);
  const minArrowWidth = labelSize(minWidth, labelStyle.level);
  // The dummyNode will be inside a <mover> inside a <mover>
  // So it will be at scriptlevel 3
  const dummyWidth = labelSize(minWidth, 3);
  const emptyLabel = paddedNode(null, minArrowWidth.toFixed(4), 0);
  const dummyNode = paddedNode(null, dummyWidth.toFixed(4), 0);
  // The arrow is a little longer than the label. Set a spacer length.
  const space = labelSize((isEq ? 0 : 0.3), labelStyle.level).toFixed(4);
  let upperNode;
  let lowerNode;

  const gotUpper = (body && body.body &&
    // \hphantom        visible content
    (body.body.body || body.body.length > 0));
  if (gotUpper) {
    let label =  buildGroup$1(body, labelStyle);
    const mustSmash = (fName === "\\\\cdrightarrow" || fName === "\\\\cdleftarrow");
    label = paddedNode(label, space, space, mustSmash);
    // Since Firefox does not support minsize, stack a invisible node
    // on top of the label. Its width will serve as a min-width.
    // TODO: Refactor this after Firefox supports minsize.
    upperNode = new mathMLTree.MathNode("mover", [label, dummyNode]);
  }
  const gotLower = (below && below.body &&
    (below.body.body || below.body.length > 0));
  if (gotLower) {
    let label =  buildGroup$1(below, labelStyle);
    label = paddedNode(label, space, space);
    lowerNode = new mathMLTree.MathNode("munder", [label, dummyNode]);
  }

  let node;
  if (!gotUpper && !gotLower) {
    node = new mathMLTree.MathNode("mover", [arrowNode, emptyLabel]);
  } else if (gotUpper && gotLower) {
    node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
  } else if (gotUpper) {
    node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
  } else {
    node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
  }
  if (minWidth === "3.0") { node.style.height = "1em"; } // CD environment
  node.setAttribute("accent", "false"); // Necessary for MS Word
  return node
};

// Stretchy arrows with an optional argument
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    // The next 5 functions are here only to support mhchem
    "\\yields",
    "\\yieldsLeft",
    "\\mesomerism",
    "\\longrightharpoonup",
    "\\longleftharpoondown",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    return {
      type: "xArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    // Build the arrow and its labels.
    const node = munderoverNode(group.name, group.body, group.below, style);
    // Create operator spacing for a relation.
    const row = [node];
    row.unshift(padding$1(0.2778));
    row.push(padding$1(0.2778));
    return new mathMLTree.MathNode("mrow", row)
  }
});

const arrowComponent = {
  "\\xtofrom": ["\\xrightarrow", "\\xleftarrow"],
  "\\xleftrightharpoons": ["\\xleftharpoonup", "\\xrightharpoondown"],
  "\\xrightleftharpoons": ["\\xrightharpoonup", "\\xleftharpoondown"],
  "\\yieldsLeftRight": ["\\yields", "\\yieldsLeft"],
  // The next three all get the same harpoon glyphs. Only the lengths and paddings differ.
  "\\equilibrium": ["\\longrightharpoonup", "\\longleftharpoondown"],
  "\\equilibriumRight": ["\\longrightharpoonup", "\\eqleftharpoondown"],
  "\\equilibriumLeft": ["\\eqrightharpoonup", "\\longleftharpoondown"]
};

// Browsers are not good at stretching a glyph that contains a pair of stacked arrows such as â‡„.
// So we stack a pair of single arrows.
defineFunction({
  type: "stackedArrow",
  names: [
    "\\xtofrom",              // expfeil
    "\\xleftrightharpoons",   // mathtools
    "\\xrightleftharpoons",   // mathtools
    "\\yieldsLeftRight",      // mhchem
    "\\equilibrium",          // mhchem
    "\\equilibriumRight",
    "\\equilibriumLeft"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    const lowerArrowBody = args[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: args[0]
      }
      : null;
    const upperArrowBelow = optArgs[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: optArgs[0]
      }
      : null;
    return {
      type: "stackedArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      upperArrowBelow,
      lowerArrowBody,
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    const topLabel = arrowComponent[group.name][0];
    const botLabel = arrowComponent[group.name][1];
    const topArrow = munderoverNode(topLabel, group.body, group.upperArrowBelow, style);
    const botArrow = munderoverNode(botLabel, group.lowerArrowBody, group.below, style);
    let wrapper;

    const raiseNode = new mathMLTree.MathNode("mpadded", [topArrow]);
    raiseNode.setAttribute("voffset", "0.3em");
    raiseNode.setAttribute("height", "+0.3em");
    raiseNode.setAttribute("depth", "-0.3em");
    // One of the arrows is given ~zero width. so the other has the same horzontal alignment.
    if (group.name === "\\equilibriumLeft") {
      const botNode =  new mathMLTree.MathNode("mpadded", [botArrow]);
      botNode.setAttribute("width", "0.5em");
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), botNode, raiseNode, padding$1(0.2778)]
      );
    } else {
      raiseNode.setAttribute("width", (group.name === "\\equilibriumRight" ? "0.5em" : "0"));
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), raiseNode, botArrow, padding$1(0.2778)]
      );
    }

    wrapper.setAttribute("voffset", "-0.18em");
    wrapper.setAttribute("height", "-0.18em");
    wrapper.setAttribute("depth", "+0.18em");
    return wrapper
  }
});

/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */
const _environments = {};

function defineEnvironment({ type, names, props, handler, mathmlBuilder }) {
  // Set default values of environments.
  const data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (let i = 0; i < names.length; ++i) {
    _environments[names[i]] = data;
  }
  if (mathmlBuilder) {
    _mathmlGroupBuilders[type] = mathmlBuilder;
  }
}

/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error(
      `Expected node of type ${type}, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return node;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function assertSymbolNodeType(node) {
  const typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error(
      `Expected node of symbol group type, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return typedNode;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" ||
      Object.prototype.hasOwnProperty.call(NON_ATOMS, node.type))) {
    return node;
  }
  return null;
}

const cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};

const newCell = () => {
  // Create an empty cell, to be filled below with parse nodes.
  return { type: "styling", body: [], mode: "math", scriptLevel: "display" };
};

const isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};

const isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};

function cdArrow(arrowChar, labels, parser) {
  // Return a parse tree of an arrow and its labels.
  // This acts in a way similar to a macro expansion.
  const funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      const bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      const arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel],
        semisimple: true
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      const arrow = { type: "textord", text: "\\Vert", mode: "math" };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return { type: "textord", text: " ", mode: "math" };
  }
}

function parseCD(parser) {
  // Get the array's parse nodes with \\ temporarily mapped to \cr.
  const parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    // Get the parse nodes for the next row.
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    const next = parser.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop(); // final row ended in \\
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }

  let row = [];
  const body = [row];

  // Loop thru the parse nodes. Collect them into cells and arrows.
  for (let i = 0; i < parsedRows.length; i++) {
    // Start a new row.
    const rowNodes = parsedRows[i];
    // Create the first cell.
    let cell = newCell();

    for (let j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        // If a parseNode is not an arrow, it goes into a cell.
        cell.body.push(rowNodes[j]);
      } else {
        // Parse node j is an "@", the start of an arrow.
        // Before starting on the arrow, push the cell into `row`.
        row.push(cell);

        // Now collect parseNodes into an arrow.
        // The character after "@" defines the arrow type.
        j += 1;
        const arrowChar = assertSymbolNodeType(rowNodes[j]).text;

        // Create two empty label nodes. We may or may not use them.
        const labels = new Array(2);
        labels[0] = { type: "ordgroup", mode: "math", body: [] };
        labels[1] = { type: "ordgroup", mode: "math", body: [] };

        // Process the arrow.
        if ("=|.".indexOf(arrowChar) > -1) ; else if ("<>AV".indexOf(arrowChar) > -1) {
          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take
          // two optional labels. E.g. the right-point arrow syntax is
          // really:  @>{optional label}>{optional label}>
          // Collect parseNodes into labels.
          for (let labelNum = 0; labelNum < 2; labelNum++) {
            let inLabel = true;
            for (let k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError(
                  "Missing a " + arrowChar + " character to complete a CD arrow.",
                  rowNodes[k]
                );
              }

              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              // isLabelEnd never returned a true.
              throw new ParseError(
                "Missing a " + arrowChar + " character to complete a CD arrow.",
                rowNodes[j]
              );
            }
          }
        } else {
          throw new ParseError(`Expected one of "<>AV=|." after @.`);
        }

        // Now join the arrow to its labels.
        const arrow = cdArrow(arrowChar, labels, parser);

        // Wrap the arrow in a styling node
        row.push(arrow);
        // In CD's syntax, cells are implicit. That is, everything that
        // is not an arrow gets collected into a cell. So create an empty
        // cell now. It will collect upcoming parseNodes.
        cell = newCell();
      }
    }
    if (i % 2 === 0) {
      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell
      // The last cell is not yet pushed into `row`, so:
      row.push(cell);
    } else {
      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow
      // Remove the empty cell that was placed at the beginning of `row`.
      row.shift();
    }
    row = [];
    body.push(row);
  }
  body.pop();

  // End row group
  parser.gullet.endGroup();
  // End array group defining \\
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: "math",
    body,
    tags: null,
    labels: new Array(body.length + 1).fill(""),
    envClasses: ["jot", "cd"],
    cols: [],
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}

// The functions below are not available for general use.
// They are here only for internal use by the {CD} environment in placing labels
// next to vertical arrows.

// We don't need any such functions for horizontal arrows because we can reuse
// the functionality that already exists for extensible arrows.

defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  mathmlBuilder(group, style) {
    if (group.label.body.length === 0) {
      return new mathMLTree.MathNode("mrow", style)  // empty label
    }
    // Abuse an <mtable> to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.label, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    const mtable = new mathMLTree.MathNode("mtable", [mtr]);
    const label = new mathMLTree.MathNode("mpadded", [mtable]);
    // Set the label width to zero so that the arrow will be centered under the corner cell.
    label.setAttribute("width", "0");
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    if (group.side === "left") {
      label.style.display = "flex";
      label.style.justifyContent = "flex-end";
    }
    return label;
  }
});

defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler({ parser }, args) {
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow", [buildGroup$1(group.fragment, style)]);
  }
});

const ordGroup = (body) => {
  return {
    "type": "ordgroup",
    "mode": "math",
    "body": body,
    "semisimple": true
  }
};

const phantom = (body, type) => {
  return {
    "type": type,
    "mode": "math",
    "body": ordGroup(body)
  }
};

/*
 * A helper for \bordermatrix.
 * parseArray() has parsed the tokens as if the environment
 * was \begin{matrix}. That parse tree is this functionâ€™s input.
 * Here, we rearrange the parse tree to get one that will
 * result in TeX \bordermatrix.
 * The final result includes a {pmatrix}, which is the bottom
 * half of a <mover> element. The top of the <mover> contains
 * the \bordermatrix headings. The top section also contains the
 * contents of the bottom {pmatrix}. Those elements are hidden via
 * \hphantom, but they ensure that column widths are the same top and
 * bottom.
 *
 * We also create a left {matrix} with a single column that contains
 * elements shifted out of the matrix. The left {matrix} also
 * contains \vphantom copies of the other {pmatrix} elements.
 * As before, this ensures consistent row heights of left and main.
 */

const bordermatrixParseTree = (matrix, delimiters) => {
  const body = matrix.body;
  body[0].shift(); // dispose of top left cell

  // Create an array for the left column
  const leftColumnBody = new Array(body.length - 1).fill().map(() => []);
  for (let i = 1; i < body.length; i++) {
    // The visible part of the cell
    leftColumnBody[i - 1].push(body[i].shift());
    // A vphantom with contents from the pmatrix, to set minimum cell height
    const phantomBody = [];
    for (let j = 0; j < body[i].length; j++) {
      phantomBody.push(structuredClone(body[i][j]));
    }
    leftColumnBody[i - 1].push(phantom(phantomBody, "vphantom"));
  }

  // Create an array for the top row
  const topRowBody = new Array(body.length).fill().map(() => []);
  for (let j = 0; j < body[0].length; j++) {
    topRowBody[0].push(structuredClone(body[0][j]));
  }
  // Copy the rest of the pmatrix, but squashed via \hphantom
  for (let i = 1; i < body.length; i++) {
    for (let j = 0; j < body[0].length; j++) {
      topRowBody[i].push(phantom(structuredClone(body[i][j]).body, "hphantom"));
    }
  }

  // Squash the top row of the main {pmatrix}
  for (let j = 0; j < body[0].length; j++) {
    body[0][j] = phantom(structuredClone(body[0][j]).body, "hphantom");
  }

  // Now wrap the arrays in the proper parse nodes.

  const leftColumn = {
    type: "array",
    mode: "math",
    body: leftColumnBody,
    cols: [{ type: "align", align: "c" }],
    rowGaps: new Array(leftColumnBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(leftColumnBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(leftColumnBody.length).fill(""),
    arraycolsep: { "number": 0.04, unit: "em" }
  };

  const topRow = {
    type: "array",
    mode: "math",
    body: topRowBody,
    cols: new Array(topRowBody.length).fill({ type: "align", align: "c" }),
    rowGaps: new Array(topRowBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(topRowBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(topRowBody.length).fill(""),
    arraycolsep: null
  };

  const topWrapper = {
    type: "styling",
    mode: "math",
    scriptLevel: "text", // Must set this explicitly.
    body: [topRow]       // Default level is "script".
  };

  const container = {
    type: "leftright",
    mode: "math",
    body: [matrix],
    left: delimiters ? delimiters[0] : "(",
    right: delimiters ? delimiters[1] : ")",
    rightColor: undefined
  };

  const base = {
    type: "op",   // The base of a TeX \overset
    mode: "math",
    limits: true,
    alwaysHandleSupSub: true,
    parentIsSupSub: true,
    symbol: false,
    stack: true,
    suppressBaseShift: true,
    body: [container]
  };

  const mover = {
    type: "supsub",  // We're using the MathML equivalent
    mode: "math",    // of TeX \overset.
    base: base,      // That keeps the {pmatrix} aligned with
    sup: topWrapper, // the math centerline.
    sub: null
  };

  return ordGroup([leftColumn, mover])
};

/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */
class SourceLocation {
  constructor(lexer, start, end) {
    this.lexer = lexer; // Lexer holding the input string.
    this.start = start; // Start offset, zero-based inclusive.
    this.end = end;     // End offset, zero-based exclusive.
  }

  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
}

/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */
class Token {
  constructor(
    text, // the text of this token
    loc
  ) {
    this.text = text;
    this.loc = loc;
  }

  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(
    endToken, // last token of the range, inclusive
    text // the text of the newly constructed token
  ) {
    return new Token(text, SourceLocation.range(this, endToken));
  }
}

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are
// provided in the the arrays below, in that order.
//

// Math style is not quite the same thing as script level.
const StyleLevel = {
  DISPLAY: 0,
  TEXT: 1,
  SCRIPT: 2,
  SCRIPTSCRIPT: 3
};

/**
 * All registered global/built-in macros.
 * `macros.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `macros.js`.
 */
const _macros = {};

// This function might one day accept an additional argument and do more things.
function defineMacro(name, body) {
  _macros[name] = body;
}

/**
 * Predefined macros for Temml.
 * This can be used to define some commands in terms of others.
 */

const macros = _macros;

//////////////////////////////////////////////////////////////////////
// macro tools

defineMacro("\\noexpand", function(context) {
  // The expansion is the token itself; but that token is interpreted
  // as if its meaning were â€˜\relaxâ€™ if it is a control sequence that
  // would ordinarily be expanded by TeXâ€™s expansion rules.
  const t = context.popToken();
  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }
  return { tokens: [t], numArgs: 0 };
});

defineMacro("\\expandafter", function(context) {
  // TeX first reads the token that comes immediately after \expandafter,
  // without expanding it; letâ€™s call this token t. Then TeX reads the
  // token that comes after t (and possibly more tokens, if that token
  // has an argument), replacing it by its expansion. Finally TeX puts
  // t back in front of that expansion.
  const t = context.popToken();
  context.expandOnce(true); // expand only an expandable token
  return { tokens: [t], numArgs: 0 };
});

// LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}
defineMacro("\\@firstoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[0], numArgs: 0 };
});

// LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}
defineMacro("\\@secondoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[1], numArgs: 0 };
});

// LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol that isn't a space, consuming any spaces but not consuming the
// first nonspace character.  If that nonspace character matches #1, then
// the macro expands to #2; otherwise, it expands to #3.
defineMacro("\\@ifnextchar", function(context) {
  const args = context.consumeArgs(3); // symbol, if, else
  context.consumeSpaces();
  const nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return { tokens: args[1], numArgs: 0 };
  } else {
    return { tokens: args[2], numArgs: 0 };
  }
});

// LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");

// LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode
defineMacro("\\TextOrMath", function(context) {
  const args = context.consumeArgs(2);
  if (context.mode === "text") {
    return { tokens: args[0], numArgs: 0 };
  } else {
    return { tokens: args[1], numArgs: 0 };
  }
});

const stringFromArg = arg => {
  // Reverse the order of the arg and return a string.
  let str = "";
  for (let i = arg.length - 1; i > -1; i--) {
    str += arg[i].text;
  }
  return str
};

// Lookup table for parsing numbers in base 8 through 16
const digitToNumber = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

const nextCharNumber = context => {
  const numStr = context.future().text;
  if (numStr === "EOF") { return [null, ""] }
  return [digitToNumber[numStr.charAt(0)], numStr]
};

const appendCharNumbers = (number, numStr, base) => {
  for (let i = 1; i < numStr.length; i++) {
    const digit = digitToNumber[numStr.charAt(i)];
    number *= base;
    number += digit;
  }
  return number
};

// TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.
defineMacro("\\char", function(context) {
  let token = context.popToken();
  let base;
  let number = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    // Parse a number in the given base, starting with first `token`.
    let numStr = token.text;
    number = digitToNumber[numStr.charAt(0)];
    if (number == null || number >= base) {
      throw new ParseError(`Invalid base-${base} digit ${token.text}`);
    }
    number = appendCharNumbers(number, numStr, base);
    let digit;
    [digit, numStr] = nextCharNumber(context);
    while (digit != null && digit < base) {
      number *= base;
      number += digit;
      number = appendCharNumbers(number, numStr, base);
      context.popToken();
      [digit, numStr] = nextCharNumber(context);
    }
  }
  return `\\@char{${number}}`;
});

function recreateArgStr(context) {
  // Recreate the macro's original argument string from the array of parse tokens.
  const tokens = context.consumeArgs(1)[0];
  let str = "";
  let expectedLoc = tokens[tokens.length - 1].loc.start;
  for (let i = tokens.length - 1; i >= 0; i--) {
    const actualLoc = tokens[i].loc.start;
    if (actualLoc > expectedLoc) {
      // context.consumeArgs has eaten a space.
      str += " ";
      expectedLoc = actualLoc;
    }
    str += tokens[i].text;
    expectedLoc += tokens[i].text.length;
  }
  return str
}

// The Latin Modern font renders <mi>âˆš</mi> at the wrong vertical alignment.
// This macro provides a better rendering.
defineMacro("\\surd", '\\sqrt{\\vphantom{|}}');

// See comment for \oplus in symbols.js.
defineMacro("\u2295", "\\oplus");

// Since Temml has no \par, ignore \long.
defineMacro("\\long", "");

//////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");

// Symbols from latex.ltx:
// \def~{\nobreakspace{}}
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");

defineMacro("\\Bbbk", "\\Bbb{k}");

// \mathstrut from the TeXbook, p 360
defineMacro("\\mathstrut", "\\vphantom{(}");

// \underbar from TeXbook p 353
defineMacro("\\underbar", "\\underline{\\text{#1}}");

//////////////////////////////////////////////////////////////////////
// LaTeX_2Îµ

// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.
defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22ee", "\\vdots");

// {array} environment gaps
defineMacro("\\arraystretch", "1");     // line spacing factor times 12pt
defineMacro("\\arraycolsep", "6pt");    // half the width separating columns

//////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf

//\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");

// \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");

// AMSMath's automatic \dots, based on \mdots@@ macro.
const dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcap": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\bigtimes": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};

defineMacro("\\dots", function(context) {
  // TODO: If used in text mode, should expand to \textellipsis.
  // However, in Temml, \textellipsis and \ldots behave the same
  // (in text mode), and it's unlikely we'd see any of the math commands
  // that affect the behavior of \dots when in text mode.  So fine for now
  // (until we support \ifmmode ... \else ... \fi).
  let thedots = "\\dotso";
  const next = context.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (["bin", "rel"].includes(symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});

const spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  $: true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};

defineMacro("\\dotso", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\dotsc", function(context) {
  const next = context.future().text;
  // \dotsc uses \extra@ but not \extrap@, instead specially checking for
  // ';' and '.', but doesn't check for ','.
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\cdots", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});

defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\idotsint", "\\dotsi");
// amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.
defineMacro("\\dotsx", "\\ldots\\,");

// \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");

// Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
// \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\,", "{\\tmspace+{3mu}{.1667em}}");
// \let\thinspace\,
defineMacro("\\thinspace", "\\,");
// \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "{\\tmspace+{4mu}{.2222em}}");
// \let\medspace\:
defineMacro("\\medspace", "\\:");
// \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu
defineMacro("\\;", "{\\tmspace+{5mu}{.2777em}}");
// \let\thickspace\;
defineMacro("\\thickspace", "\\;");
// \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\!", "{\\tmspace-{3mu}{.1667em}}");
// \let\negthinspace\!
defineMacro("\\negthinspace", "\\!");
// \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip
defineMacro("\\negmedspace", "{\\tmspace-{4mu}{.2222em}}");
// \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip
defineMacro("\\negthickspace", "{\\tmspace-{5mu}{.277em}}");
// \def\enspace{\kern.5em }
defineMacro("\\enspace", "\\kern.5em ");
// \def\enskip{\hskip.5em\relax}
defineMacro("\\enskip", "\\hskip.5em\\relax");
// \def\quad{\hskip1em\relax}
defineMacro("\\quad", "\\hskip1em\\relax");
// \def\qquad{\hskip2em\relax}
defineMacro("\\qquad", "\\hskip2em\\relax");

defineMacro("\\AA", "\\TextOrMath{\\Angstrom}{\\mathring{A}}\\relax");

// \tag@in@display form of \tag
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\notag", "\\nonumber");
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");

// \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\bmod", "\\mathbin{\\text{mod}}");
defineMacro(
  "\\pod",
  "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"
);
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro(
  "\\mod",
  "\\allowbreak" +
    "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" +
    "{\\rm mod}\\,\\,#1"
);

//////////////////////////////////////////////////////////////////////
// LaTeX source2e

// \expandafter\let\expandafter\@normalcr
//     \csname\expandafter\@gobble\string\\ \endcsname
// \DeclareRobustCommand\newline{\@normalcr\relax}
defineMacro("\\newline", "\\\\\\relax");

// \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.
defineMacro("\\TeX", "\\textrm{T}\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125em\\textrm{X}");

defineMacro(
  "\\LaTeX",
    "\\textrm{L}\\kern-.35em\\raisebox{0.2em}{\\scriptstyle A}\\kern-.15em\\TeX"
);

defineMacro(
  "\\Temml",
  // eslint-disable-next-line max-len
  "\\textrm{T}\\kern-0.2em\\lower{0.2em}{\\textrm{E}}\\kern-0.08em{\\textrm{M}\\kern-0.08em\\raise{0.2em}\\textrm{M}\\kern-0.08em\\textrm{L}}"
);

// \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");

defineMacro("\\colon", `\\mathpunct{\\char"3a}`);

//////////////////////////////////////////////////////////////////////
// mathtools.sty

defineMacro("\\prescript", "\\pres@cript{_{#1}^{#2}}{}{#3}");

//\providecommand\ordinarycolon{:}
defineMacro("\\ordinarycolon", `\\char"3a`);
// Raise to center on the math axis, as closely as possible.
defineMacro("\\vcentcolon", "\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}}");
// \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\coloneq", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2212}');
// \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\Coloneq", '\\mathrel{\\char"2237\\char"2212}');
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqqcolon", '\\mathrel{\\char"3d\\char"2237}');
// \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqcolon", '\\mathrel{\\char"2212\\char"2237}');
// \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\colonapprox", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2248}');
// \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\Colonapprox", '\\mathrel{\\char"2237\\char"2248}');
// \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');
// \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\Colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');

//////////////////////////////////////////////////////////////////////
// colonequals.sty

// Alternate names for mathtools's macros:
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
// \colonapprox name is same in mathtools and colonequals.
defineMacro("\\coloncolonapprox", "\\Colonapprox");
// \colonsim name is same in mathtools and colonequals.
defineMacro("\\coloncolonsim", "\\Colonsim");

// Present in newtxmath, pxfonts and txfonts
defineMacro("\\notni", "\\mathrel{\\char`\u220C}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");

//////////////////////////////////////////////////////////////////////
// From amsopn.sty
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{\\text{lim}}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{\\text{lim}}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{\\text{lim}}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{\\text{lim}}}");

defineMacro("\\centerdot", "{\\medspace\\rule{0.167em}{0.189em}\\medspace}");

//////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\operatorname*{plim}");

//////////////////////////////////////////////////////////////////////
// MnSymbol.sty

defineMacro("\\leftmodels", "\\mathop{\\reflectbox{$\\models$}}");

//////////////////////////////////////////////////////////////////////
// braket.sty
// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf

defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
// A helper for \Braket and \Set
const replaceVert = (argStr, match) => {
  const ch = match[0] === "|" ? "\\vert" : "\\Vert";
  const replaceStr = `}\\,\\middle${ch}\\,{`;
  return argStr.slice(0, match.index) + replaceStr + argStr.slice(match.index + match[0].length)
};
defineMacro("\\Braket",  function(context) {
  let argStr = recreateArgStr(context);
  const regEx = /\|\||\||\\\|/g;
  let match;
  while ((match = regEx.exec(argStr)) !== null) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\langle{" + argStr + "}\\right\\rangle"
});
defineMacro("\\Set",  function(context) {
  let argStr = recreateArgStr(context);
  const match = /\|\||\||\\\|/.exec(argStr);
  if (match) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\{\\:{" + argStr + "}\\:\\right\\}"
});
defineMacro("\\set",  function(context) {
  const argStr = recreateArgStr(context);
  return "\\{{" + argStr.replace(/\|/, "}\\mid{") + "}\\}"
});

//////////////////////////////////////////////////////////////////////
// actuarialangle.dtx
defineMacro("\\angln", "{\\angl n}");

//////////////////////////////////////////////////////////////////////
// derivative.sty
defineMacro("\\odv", "\\@ifstar\\odv@next\\odv@numerator");
defineMacro("\\odv@numerator", "\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}");
defineMacro("\\odv@next", "\\frac{\\mathrm{d}}{\\mathrm{d}#2}#1");
defineMacro("\\pdv", "\\@ifstar\\pdv@next\\pdv@numerator");

const pdvHelper = args => {
  const numerator = args[0][0].text;
  const denoms = stringFromArg(args[1]).split(",");
  const power = String(denoms.length);
  const numOp = power === "1" ? "\\partial" : `\\partial^${power}`;
  let denominator = "";
  denoms.map(e => { denominator += "\\partial " + e.trim() +  "\\,";});
  return [numerator, numOp,  denominator.replace(/\\,$/, "")]
};
defineMacro("\\pdv@numerator", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp} ${numerator}}{${denominator}}`
});
defineMacro("\\pdv@next", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp}}{${denominator}} ${numerator}`
});

//////////////////////////////////////////////////////////////////////
// upgreek.dtx
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\upbeta", "\\up@greek{\\beta}");
defineMacro("\\upgamma", "\\up@greek{\\gamma}");
defineMacro("\\updelta", "\\up@greek{\\delta}");
defineMacro("\\upepsilon", "\\up@greek{\\epsilon}");
defineMacro("\\upzeta", "\\up@greek{\\zeta}");
defineMacro("\\upeta", "\\up@greek{\\eta}");
defineMacro("\\uptheta", "\\up@greek{\\theta}");
defineMacro("\\upiota", "\\up@greek{\\iota}");
defineMacro("\\upkappa", "\\up@greek{\\kappa}");
defineMacro("\\uplambda", "\\up@greek{\\lambda}");
defineMacro("\\upmu", "\\up@greek{\\mu}");
defineMacro("\\upnu", "\\up@greek{\\nu}");
defineMacro("\\upxi", "\\up@greek{\\xi}");
defineMacro("\\upomicron", "\\up@greek{\\omicron}");
defineMacro("\\uppi", "\\up@greek{\\pi}");
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\uprho", "\\up@greek{\\rho}");
defineMacro("\\upsigma", "\\up@greek{\\sigma}");
defineMacro("\\uptau", "\\up@greek{\\tau}");
defineMacro("\\upupsilon", "\\up@greek{\\upsilon}");
defineMacro("\\upphi", "\\up@greek{\\phi}");
defineMacro("\\upchi", "\\up@greek{\\chi}");
defineMacro("\\uppsi", "\\up@greek{\\psi}");
defineMacro("\\upomega", "\\up@greek{\\omega}");

//////////////////////////////////////////////////////////////////////
// cmll package
defineMacro("\\invamp", '\\mathbin{\\char"214b}');
defineMacro("\\parr", '\\mathbin{\\char"214b}');
defineMacro("\\with", '\\mathbin{\\char"26}');
defineMacro("\\multimapinv", '\\mathrel{\\char"27dc}');
defineMacro("\\multimapboth", '\\mathrel{\\char"29df}');
defineMacro("\\scoh", '{\\mkern5mu\\char"2322\\mkern5mu}');
defineMacro("\\sincoh", '{\\mkern5mu\\char"2323\\mkern5mu}');
defineMacro("\\coh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2322}}}
{\\smash{\\lower4mu{\\char"2323}}}\\mkern5mu}`);
defineMacro("\\incoh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2323}}}
{\\smash{\\lower4mu{\\char"2322}}}\\mkern5mu}`);


//////////////////////////////////////////////////////////////////////
// chemstyle package
defineMacro("\\standardstate", "\\text{\\tiny\\char`â¦µ}");

ï»¿/* eslint-disable */
/* -*- Mode: JavaScript; indent-tabs-mode:nil; js-indent-level: 2 -*- */
/* vim: set ts=2 et sw=2 tw=80: */

/*************************************************************
 *
 *  Temml mhchem.js
 *
 *  This file implements a Temml version of mhchem version 3.3.0.
 *  It is adapted from MathJax/extensions/TeX/mhchem.js
 *  It differs from the MathJax version as follows:
 *    1. The interface is changed so that it can be called from Temml, not MathJax.
 *    2. \rlap and \llap are replaced with \mathrlap and \mathllap.
 *    3. The reaction arrow code is simplified. All reaction arrows are rendered
 *       using Temml extensible arrows instead of building non-extensible arrows.
 *    4. The ~bond forms are composed entirely of \rule elements.
 *    5. Two dashes in _getBond are wrapped in braces to suppress spacing. i.e., {-}
 *    6. The electron dot uses \textbullet instead of \bullet.
 *    7. \smash[T] has been removed. (WebKit hides anything inside \smash{â€¦})
 *
 *    This code, as other Temml code, is released under the MIT license.
 * 
 * /*************************************************************
 *
 *  MathJax/extensions/TeX/mhchem.js
 *
 *  Implements the \ce command for handling chemical formulas
 *  from the mhchem LaTeX package.
 *
 *  ---------------------------------------------------------------------
 *
 *  Copyright (c) 2011-2015 The MathJax Consortium
 *  Copyright (c) 2015-2018 Martin Hensel
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

//
// Coding Style
//   - use '' for identifiers that can by minified/uglified
//   - use "" for strings that need to stay untouched

// version: "3.3.0" for MathJax and Temml


// Add \ce, \pu, and \tripleDash to the Temml macros.

defineMacro("\\ce", function(context) {
  return chemParse(context.consumeArgs(1)[0], "ce")
});

defineMacro("\\pu", function(context) {
  return chemParse(context.consumeArgs(1)[0], "pu");
});

// Math fonts do not include glyphs for the ~ form of bonds. So we'll send path geometry
// So we'll compose characters built from \rule elements.
defineMacro("\\uniDash", `{\\rule{0.672em}{0.06em}}`)
defineMacro("\\triDash", `{\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}}`)
defineMacro("\\tripleDash", `\\kern0.075em\\raise0.25em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverLine", `\\kern0.075em\\mathrlap{\\raise0.125em{\\uniDash}}\\raise0.34em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\triDash}}\\raise0.27em{\\uniDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)
defineMacro("\\tripleDashBetweenDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\uniDash}}\\raise0.27em{\\triDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)

  //
  //  This is the main function for handing the \ce and \pu commands.
  //  It takes the argument to \ce or \pu and returns the corresponding TeX string.
  //

  var chemParse = function (tokens, stateMachine) {
    // Recreate the argument string from Temml's array of tokens.
    var str = "";
    var expectedLoc = tokens.length && tokens[tokens.length - 1].loc.start
    for (var i = tokens.length - 1; i >= 0; i--) {
      if(tokens[i].loc.start > expectedLoc) {
        // context.consumeArgs has eaten a space.
        str += " ";
        expectedLoc = tokens[i].loc.start;
      }
      str += tokens[i].text;
      expectedLoc += tokens[i].text.length;
    }
    // Call the mhchem core parser.
    var tex = texify.go(mhchemParser.go(str, stateMachine));
    return tex;
  };

  //
  // Core parser for mhchem syntax  (recursive)
  //
  /** @type {MhchemParser} */
  var mhchemParser = {
    //
    // Parses mchem \ce syntax
    //
    // Call like
    //   go("H2O");
    //
    go: function (input, stateMachine) {
      if (!input) { return []; }
      if (stateMachine === undefined) { stateMachine = 'ce'; }
      var state = '0';

      //
      // String buffers for parsing:
      //
      // buffer.a == amount
      // buffer.o == element
      // buffer.b == left-side superscript
      // buffer.p == left-side subscript
      // buffer.q == right-side subscript
      // buffer.d == right-side superscript
      //
      // buffer.r == arrow
      // buffer.rdt == arrow, script above, type
      // buffer.rd == arrow, script above, content
      // buffer.rqt == arrow, script below, type
      // buffer.rq == arrow, script below, content
      //
      // buffer.text_
      // buffer.rm
      // etc.
      //
      // buffer.parenthesisLevel == int, starting at 0
      // buffer.sb == bool, space before
      // buffer.beginsWithBond == bool
      //
      // These letters are also used as state names.
      //
      // Other states:
      // 0 == begin of main part (arrow/operator unlikely)
      // 1 == next entity
      // 2 == next entity (arrow/operator unlikely)
      // 3 == next atom
      // c == macro
      //
      /** @type {Buffer} */
      var buffer = {};
      buffer['parenthesisLevel'] = 0;

      input = input.replace(/\n/g, " ");
      input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
      input = input.replace(/[\u2026]/g, "...");

      //
      // Looks through mhchemParser.transitions, to execute a matching action
      // (recursive)
      //
      var lastInput;
      var watchdog = 10;
      /** @type {ParserOutput[]} */
      var output = [];
      while (true) {
        if (lastInput !== input) {
          watchdog = 10;
          lastInput = input;
        } else {
          watchdog--;
        }
        //
        // Find actions in transition table
        //
        var machine = mhchemParser.stateMachines[stateMachine];
        var t = machine.transitions[state] || machine.transitions['*'];
        iterateTransitions:
        for (var i=0; i<t.length; i++) {
          var matches = mhchemParser.patterns.match_(t[i].pattern, input);
          if (matches) {
            //
            // Execute actions
            //
            var task = t[i].task;
            for (var iA=0; iA<task.action_.length; iA++) {
              var o;
              //
              // Find and execute action
              //
              if (machine.actions[task.action_[iA].type_]) {
                o = machine.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else if (mhchemParser.actions[task.action_[iA].type_]) {
                o = mhchemParser.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else {
                throw ["MhchemBugA", "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"];  // Trying to use non-existing action
              }
              //
              // Add output
              //
              mhchemParser.concatArray(output, o);
            }
            //
            // Set next state,
            // Shorten input,
            // Continue with next character
            //   (= apply only one transition per position)
            //
            state = task.nextState || state;
            if (input.length > 0) {
              if (!task.revisit) {
                input = matches.remainder;
              }
              if (!task.toContinue) {
                break iterateTransitions;
              }
            } else {
              return output;
            }
          }
        }
        //
        // Prevent infinite loop
        //
        if (watchdog <= 0) {
          throw ["MhchemBugU", "mhchem bug U. Please report."];  // Unexpected character
        }
      }
    },
    concatArray: function (a, b) {
      if (b) {
        if (Array.isArray(b)) {
          for (var iB=0; iB<b.length; iB++) {
            a.push(b[iB]);
          }
        } else {
          a.push(b);
        }
      }
    },

    patterns: {
      //
      // Matching patterns
      // either regexps or function that return null or {match_:"a", remainder:"bc"}
      //
      patterns: {
        // property names must not look like integers ("2") for correct property traversal order, later on
        'empty': /^$/,
        'else': /^./,
        'else2': /^./,
        'space': /^\s/,
        'space A': /^\s(?=[A-Z\\$])/,
        'space$': /^\s$/,
        'a-z': /^[a-z]/,
        'x': /^x/,
        'x$': /^x$/,
        'i$': /^i$/,
        'letters': /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
        '\\greek': /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
        'one lowercase latin letter $': /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
        '$one lowercase latin letter$ $': /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
        'one lowercase greek letter $': /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
        'digits': /^[0-9]+/,
        '-9.,9': /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
        '-9.,9 no missing 0': /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
        '(-)(9.,9)(e)(99)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '(-)(9)^(-9)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        'state of aggregation $': function (input) {  // ... or crystal system
          var a = mhchemParser.patterns.findObserveGroups(input, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");  // (aq), (aq,$\infty$), (aq, sat)
          if (a  &&  a.remainder.match(/^($|[\s,;\)\]\}])/)) { return a; }  //  AND end of 'phrase'
          var m = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);  // OR crystal system ($o$) (\ca$c$)
          if (m) {
            return { match_: m[0], remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '_{(state of aggregation)}$': /^_\{(\([a-z]{1,3}\))\}/,
        '{[(': /^(?:\\\{|\[|\()/,
        ')]}': /^(?:\)|\]|\\\})/,
        ', ': /^[,;]\s*/,
        ',': /^[,;]/,
        '.': /^[.]/,
        '. ': /^([.\u22C5\u00B7\u2022])\s*/,
        '...': /^\.\.\.(?=$|[^.])/,
        '* ': /^([*])\s*/,
        '^{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^{", "", "", "}"); },
        '^($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", "$", "$", ""); },
        '^a': /^\^([0-9]+|[^\\_])/,
        '^\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '^\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", ""); },
        '^\\x': /^\^(\\[a-zA-Z]+)\s*/,
        '^(-1)': /^\^(-?\d+)/,
        '\'': /^'/,
        '_{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_{", "", "", "}"); },
        '_($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", "$", "$", ""); },
        '_9': /^_([+\-]?[0-9]+|[^\\])/,
        '_\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '_\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", ""); },
        '_\\x': /^_(\\[a-zA-Z]+)\s*/,
        '^_': /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
        '{}': /^\{\}/,
        '{...}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "{", "}", ""); },
        '{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}"); },
        '$...$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "$", "$", ""); },
        '${(...)}$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "${", "", "", "}$"); },
        '$(...)$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$"); },
        '=<>': /^[=<>]/,
        '#': /^[#\u2261]/,
        '+': /^\+/,
        '-$': /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,  // -space -, -; -] -/ -$ -state-of-aggregation
        '-9': /^-(?=[0-9])/,
        '- orbital overlap': /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
        '-': /^-/,
        'pm-operator': /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
        'operator': /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
        'arrowUpDown': /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
        '\\bond{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\bond{", "", "", "}"); },
        '->': /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
        'CMT': /^[CMT](?=\[)/,
        '[(...)]': function (input) { return mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]"); },
        '1st-level escape': /^(&|\\\\|\\hline)\s*/,
        '\\,': /^(?:\\[,\ ;:])/,  // \\x - but output no space before
        '\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", ""); },
        '\\ca': /^\\ca(?:\s+|(?![a-zA-Z]))/,
        '\\x': /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
        'orbital': /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,  // only those with numbers in front, because the others will be formatted correctly anyway
        'others': /^[\/~|]/,
        '\\frac{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\frac{", "", "", "}", "{", "", "", "}"); },
        '\\overset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\overset{", "", "", "}", "{", "", "", "}"); },
        '\\underset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underset{", "", "", "}", "{", "", "", "}"); },
        '\\underbrace{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underbrace{", "", "", "}_", "{", "", "", "}"); },
        '\\color{(...)}0': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}"); },
        '\\color{(...)}{(...)}1': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}", "{", "", "", "}"); },
        '\\color(...){(...)}2': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}"); },
        '\\ce{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\ce{", "", "", "}"); },
        'oxidation$': /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
        'd-oxidation$': /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,  // 0 could be oxidation or charge
        'roman numeral': /^[IVX]+/,
        '1/2$': /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
        'amount': function (input) {
          var match;
          // e.g. 2, 0.5, 1/2, -2, n/2, +;  $a$ could be added later in parsing
          match = input.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          var a = mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
          if (a) {  // e.g. $2n-1$, $-$
            match = a.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/);
            if (match) {
              return { match_: match[0], remainder: input.substr(match[0].length) };
            }
          }
          return null;
        },
        'amount2': function (input) { return this['amount'](input); },
        '(KV letters),': /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
        'formula$': function (input) {
          if (input.match(/^\([a-z]+\)$/)) { return null; }  // state of aggregation = no formula
          var match = input.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          return null;
        },
        'uprightEntities': /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
        '/': /^\s*(\/)\s*/,
        '//': /^\s*(\/\/)\s*/,
        '*': /^\s*[*.]\s*/
      },
      findObserveGroups: function (input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
        /** @type {{(input: string, pattern: string | RegExp): string | string[] | null;}} */
        var _match = function (input, pattern) {
          if (typeof pattern === "string") {
            if (input.indexOf(pattern) !== 0) { return null; }
            return pattern;
          } else {
            var match = input.match(pattern);
            if (!match) { return null; }
            return match[0];
          }
        };
        /** @type {{(input: string, i: number, endChars: string | RegExp): {endMatchBegin: number, endMatchEnd: number} | null;}} */
        var _findObserveGroups = function (input, i, endChars) {
          var braces = 0;
          while (i < input.length) {
            var a = input.charAt(i);
            var match = _match(input.substr(i), endChars);
            if (match !== null  &&  braces === 0) {
              return { endMatchBegin: i, endMatchEnd: i + match.length };
            } else if (a === "{") {
              braces++;
            } else if (a === "}") {
              if (braces === 0) {
                throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
              } else {
                braces--;
              }
            }
            i++;
          }
          if (braces > 0) {
            return null;
          }
          return null;
        };
        var match = _match(input, begExcl);
        if (match === null) { return null; }
        input = input.substr(match.length);
        match = _match(input, begIncl);
        if (match === null) { return null; }
        var e = _findObserveGroups(input, match.length, endIncl || endExcl);
        if (e === null) { return null; }
        var match1 = input.substring(0, (endIncl ? e.endMatchEnd : e.endMatchBegin));
        if (!(beg2Excl || beg2Incl)) {
          return {
            match_: match1,
            remainder: input.substr(e.endMatchEnd)
          };
        } else {
          var group2 = this.findObserveGroups(input.substr(e.endMatchEnd), beg2Excl, beg2Incl, end2Incl, end2Excl);
          if (group2 === null) { return null; }
          /** @type {string[]} */
          var matchRet = [match1, group2.match_];
          return {
            match_: (combine ? matchRet.join("") : matchRet),
            remainder: group2.remainder
          };
        }
      },

      //
      // Matching function
      // e.g. match("a", input) will look for the regexp called "a" and see if it matches
      // returns null or {match_:"a", remainder:"bc"}
      //
      match_: function (m, input) {
        var pattern = mhchemParser.patterns.patterns[m];
        if (pattern === undefined) {
          throw ["MhchemBugP", "mhchem bug P. Please report. (" + m + ")"];  // Trying to use non-existing pattern
        } else if (typeof pattern === "function") {
          return mhchemParser.patterns.patterns[m](input);  // cannot use cached var pattern here, because some pattern functions need this===mhchemParser
        } else {  // RegExp
          var match = input.match(pattern);
          if (match) {
            var mm;
            if (match[2]) {
              mm = [ match[1], match[2] ];
            } else if (match[1]) {
              mm = match[1];
            } else {
              mm = match[0];
            }
            return { match_: mm, remainder: input.substr(match[0].length) };
          }
          return null;
        }
      }
    },

    //
    // Generic state machine actions
    //
    actions: {
      'a=': function (buffer, m) { buffer.a = (buffer.a || "") + m; },
      'b=': function (buffer, m) { buffer.b = (buffer.b || "") + m; },
      'p=': function (buffer, m) { buffer.p = (buffer.p || "") + m; },
      'o=': function (buffer, m) { buffer.o = (buffer.o || "") + m; },
      'q=': function (buffer, m) { buffer.q = (buffer.q || "") + m; },
      'd=': function (buffer, m) { buffer.d = (buffer.d || "") + m; },
      'rm=': function (buffer, m) { buffer.rm = (buffer.rm || "") + m; },
      'text=': function (buffer, m) { buffer.text_ = (buffer.text_ || "") + m; },
      'insert': function (buffer, m, a) { return { type_: a }; },
      'insert+p1': function (buffer, m, a) { return { type_: a, p1: m }; },
      'insert+p1+p2': function (buffer, m, a) { return { type_: a, p1: m[0], p2: m[1] }; },
      'copy': function (buffer, m) { return m; },
      'rm': function (buffer, m) { return { type_: 'rm', p1: m || ""}; },
      'text': function (buffer, m) { return mhchemParser.go(m, 'text'); },
      '{text}': function (buffer, m) {
        var ret = [ "{" ];
        mhchemParser.concatArray(ret, mhchemParser.go(m, 'text'));
        ret.push("}");
        return ret;
      },
      'tex-math': function (buffer, m) { return mhchemParser.go(m, 'tex-math'); },
      'tex-math tight': function (buffer, m) { return mhchemParser.go(m, 'tex-math tight'); },
      'bond': function (buffer, m, k) { return { type_: 'bond', kind_: k || m }; },
      'color0-output': function (buffer, m) { return { type_: 'color0', color: m[0] }; },
      'ce': function (buffer, m) { return mhchemParser.go(m); },
      '1/2': function (buffer, m) {
        /** @type {ParserOutput[]} */
        var ret = [];
        if (m.match(/^[+\-]/)) {
          ret.push(m.substr(0, 1));
          m = m.substr(1);
        }
        var n = m.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
        n[1] = n[1].replace(/\$/g, "");
        ret.push({ type_: 'frac', p1: n[1], p2: n[2] });
        if (n[3]) {
          n[3] = n[3].replace(/\$/g, "");
          ret.push({ type_: 'tex-math', p1: n[3] });
        }
        return ret;
      },
      '9,9': function (buffer, m) { return mhchemParser.go(m, '9,9'); }
    },
    //
    // createTransitions
    // convert  { 'letter': { 'state': { action_: 'output' } } }  to  { 'state' => [ { pattern: 'letter', task: { action_: [{type_: 'output'}] } } ] }
    // with expansion of 'a|b' to 'a' and 'b' (at 2 places)
    //
    createTransitions: function (o) {
      var pattern, state;
      /** @type {string[]} */
      var stateArray;
      var i;
      //
      // 1. Collect all states
      //
      /** @type {Transitions} */
      var transitions = {};
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = state.split("|");
          o[pattern][state].stateArray = stateArray;
          for (i=0; i<stateArray.length; i++) {
            transitions[stateArray[i]] = [];
          }
        }
      }
      //
      // 2. Fill states
      //
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = o[pattern][state].stateArray || [];
          for (i=0; i<stateArray.length; i++) {
            //
            // 2a. Normalize actions into array:  'text=' ==> [{type_:'text='}]
            // (Note to myself: Resolving the function here would be problematic. It would need .bind (for *this*) and currying (for *option*).)
            //
            /** @type {any} */
            var p = o[pattern][state];
            if (p.action_) {
              p.action_ = [].concat(p.action_);
              for (var k=0; k<p.action_.length; k++) {
                if (typeof p.action_[k] === "string") {
                  p.action_[k] = { type_: p.action_[k] };
                }
              }
            } else {
              p.action_ = [];
            }
            //
            // 2.b Multi-insert
            //
            var patternArray = pattern.split("|");
            for (var j=0; j<patternArray.length; j++) {
              if (stateArray[i] === '*') {  // insert into all
                for (var t in transitions) {
                  transitions[t].push({ pattern: patternArray[j], task: p });
                }
              } else {
                transitions[stateArray[i]].push({ pattern: patternArray[j], task: p });
              }
            }
          }
        }
      }
      return transitions;
    },
    stateMachines: {}
  };

  //
  // Definition of state machines
  //
  mhchemParser.stateMachines = {
    //
    // \ce state machines
    //
    //#region ce
    'ce': {  // main parser
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'else':  {
          '0|1|2': { action_: 'beginsWithBond=false', revisit: true, toContinue: true } },
        'oxidation$': {
          '0': { action_: 'oxidation-output' } },
        'CMT': {
          'r': { action_: 'rdt=', nextState: 'rt' },
          'rd': { action_: 'rqt=', nextState: 'rdt' } },
        'arrowUpDown': {
          '0|1|2|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '1' } },
        'uprightEntities': {
          '0|1|2': { action_: [ 'o=', 'output' ], nextState: '1' } },
        'orbital': {
          '0|1|2|3': { action_: 'o=', nextState: 'o' } },
        '->': {
          '0|1|2|3': { action_: 'r=', nextState: 'r' },
          'a|as': { action_: [ 'output', 'r=' ], nextState: 'r' },
          '*': { action_: [ 'output', 'r=' ], nextState: 'r' } },
        '+': {
          'o': { action_: 'd= kv',  nextState: 'd' },
          'd|D': { action_: 'd=', nextState: 'd' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd|qD': { action_: 'd=', nextState: 'qd' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' },
          '3': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        'amount': {
          '0|2': { action_: 'a=', nextState: 'a' } },
        'pm-operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', { type_: 'operator', option: '\\pm' } ], nextState: '0' } },
        'operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        '-$': {
          'o|q': { action_: [ 'charge or bond', 'output' ],  nextState: 'qd' },
          'd': { action_: 'd=', nextState: 'd' },
          'D': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd': { action_: 'd=', nextState: 'qd' },
          'qD|dq': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        '-9': {
          '3|o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '3' } },
        '- orbital overlap': {
          'o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'd': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' } },
        '-': {
          '0|1|2': { action_: [ { type_: 'output', option: 1 }, 'beginsWithBond=true', { type_: 'bond', option: "-" } ], nextState: '3' },
          '3': { action_: { type_: 'bond', option: "-" } },
          'a': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'as': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "-" } ], nextState: '3' },
          'b': { action_: 'b=' },
          'o': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'q': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'd|qd|dq': { action_: { type_: '- after o/d', option: true }, nextState: '2' },
          'D|qD|p': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        'amount2': {
          '1|3': { action_: 'a=', nextState: 'a' } },
        'letters': {
          '0|1|2|3|a|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },
          'q|dq': { action_: ['output', 'o='], nextState: 'o' },
          'd|D|qd|qD': { action_: 'o after d', nextState: 'o' } },
        'digits': {
          'o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q': { action_: [ 'output', 'o=' ], nextState: 'o' },
          'a': { action_: 'o=', nextState: 'o' } },
        'space A': {
          'b|p|bp': {} },
        'space': {
          'a': { nextState: 'as' },
          '0': { action_: 'sb=false' },
          '1|2': { action_: 'sb=true' },
          'r|rt|rd|rdt|rdq': { action_: 'output', nextState: '0' },
          '*': { action_: [ 'output', 'sb=true' ], nextState: '1'} },
        '1st-level escape': {
          '1|2': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ] },
          '*': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ], nextState: '0' } },
        '[(...)]': {
          'r|rt': { action_: 'rd=', nextState: 'rd' },
          'rd|rdt': { action_: 'rq=', nextState: 'rdq' } },
        '...': {
          'o|d|D|dq|qd|qD': { action_: [ 'output', { type_: 'bond', option: "..." } ], nextState: '3' },
          '*': { action_: [ { type_: 'output', option: 1 }, { type_: 'insert', option: 'ellipsis' } ], nextState: '1' } },
        '. |* ': {
          '*': { action_: [ 'output', { type_: 'insert', option: 'addition compound' } ], nextState: '1' } },
        'state of aggregation $': {
          '*': { action_: [ 'output', 'state of aggregation' ], nextState: '1' } },
        '{[(': {
          'a|as|o': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '0|1|2|3': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '*': { action_: [ 'output', 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' } },
        ')]}': {
          '0|1|2|3|b|p|bp|o': { action_: [ 'o=', 'parenthesisLevel--' ], nextState: 'o' },
          'a|as|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=', 'parenthesisLevel--' ], nextState: 'o' } },
        ', ': {
          '*': { action_: [ 'output', 'comma' ], nextState: '0' } },
        '^_': {  // ^ and _ without a sensible argument
          '*': { } },
        '^{(...)}|^($...$)': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'D' },
          'q': { action_: 'd=', nextState: 'qD' },
          'd|D|qd|qD|dq': { action_: [ 'output', 'd=' ], nextState: 'D' } },
        '^a|^\\x{}{}|^\\x{}|^\\x|\'': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'd' },
          'q': { action_: 'd=', nextState: 'qd' },
          'd|qd|D|qD': { action_: 'd=' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' } },
        '_{(state of aggregation)}$': {
          'd|D|q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x': {
          '0|1|2|as': { action_: 'p=', nextState: 'p' },
          'b': { action_: 'p=', nextState: 'bp' },
          '3|o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '=<>': {
          '0|1|2|3|a|as|o|q|d|D|qd|qD|dq': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: '3' } },
        '#': {
          '0|1|2|3|a|as|o': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "#" } ], nextState: '3' } },
        '{}': {
          '*': { action_: { type_: 'output', option: 1 },  nextState: '1' } },
        '{...}': {
          '0|1|2|3|a|as|b|p|bp': { action_: 'o=', nextState: 'o' },
          'o|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '$...$': {
          'a': { action_: 'a=' },  // 2$n$
          '0|1|2|3|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },  // not 'amount'
          'as|o': { action_: 'o=' },
          'q|d|D|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '\\bond{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: "3" } },
        '\\frac{(...)}': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'frac-output' ], nextState: '3' } },
        '\\overset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'overset-output' ], nextState: '3' } },
        '\\underset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underset-output' ], nextState: '3' } },
        '\\underbrace{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underbrace-output' ], nextState: '3' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color-output' ], nextState: '3' } },
        '\\color{(...)}0': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color0-output' ] } },
        '\\ce{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'ce' ], nextState: '3' } },
        '\\,': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '1' } },
        '\\x{}{}|\\x{}|\\x': {
          '0|1|2|3|a|as|b|p|bp|o|c0': { action_: [ 'o=', 'output' ], nextState: '3' },
          '*': { action_: ['output', 'o=', 'output' ], nextState: '3' } },
        'others': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '3' } },
        'else2': {
          'a': { action_: 'a to o', nextState: 'o', revisit: true },
          'as': { action_: [ 'output', 'sb=true' ], nextState: '1', revisit: true },
          'r|rt|rd|rdt|rdq': { action_: [ 'output' ], nextState: '0', revisit: true },
          '*': { action_: [ 'output', 'copy' ], nextState: '3' } }
      }),
      actions: {
        'o after d': function (buffer, m) {
          var ret;
          if ((buffer.d || "").match(/^[0-9]+$/)) {
            var tmp = buffer.d;
            buffer.d = undefined;
            ret = this['output'](buffer);
            buffer.b = tmp;
          } else {
            ret = this['output'](buffer);
          }
          mhchemParser.actions['o='](buffer, m);
          return ret;
        },
        'd= kv': function (buffer, m) {
          buffer.d = m;
          buffer.dType = 'kv';
        },
        'charge or bond': function (buffer, m) {
          if (buffer['beginsWithBond']) {
            /** @type {ParserOutput[]} */
            var ret = [];
            mhchemParser.concatArray(ret, this['output'](buffer));
            mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            return ret;
          } else {
            buffer.d = m;
          }
        },
        '- after o/d': function (buffer, m, isAfterD) {
          var c1 = mhchemParser.patterns.match_('orbital', buffer.o || "");
          var c2 = mhchemParser.patterns.match_('one lowercase greek letter $', buffer.o || "");
          var c3 = mhchemParser.patterns.match_('one lowercase latin letter $', buffer.o || "");
          var c4 = mhchemParser.patterns.match_('$one lowercase latin letter$ $', buffer.o || "");
          var hyphenFollows =  m==="-" && ( c1 && c1.remainder===""  ||  c2  ||  c3  ||  c4 );
          if (hyphenFollows && !buffer.a && !buffer.b && !buffer.p && !buffer.d && !buffer.q && !c1 && c3) {
            buffer.o = '$' + buffer.o + '$';
          }
          /** @type {ParserOutput[]} */
          var ret = [];
          if (hyphenFollows) {
            mhchemParser.concatArray(ret, this['output'](buffer));
            ret.push({ type_: 'hyphen' });
          } else {
            c1 = mhchemParser.patterns.match_('digits', buffer.d || "");
            if (isAfterD && c1 && c1.remainder==='') {
              mhchemParser.concatArray(ret, mhchemParser.actions['d='](buffer, m));
              mhchemParser.concatArray(ret, this['output'](buffer));
            } else {
              mhchemParser.concatArray(ret, this['output'](buffer));
              mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            }
          }
          return ret;
        },
        'a to o': function (buffer) {
          buffer.o = buffer.a;
          buffer.a = undefined;
        },
        'sb=true': function (buffer) { buffer.sb = true; },
        'sb=false': function (buffer) { buffer.sb = false; },
        'beginsWithBond=true': function (buffer) { buffer['beginsWithBond'] = true; },
        'beginsWithBond=false': function (buffer) { buffer['beginsWithBond'] = false; },
        'parenthesisLevel++': function (buffer) { buffer['parenthesisLevel']++; },
        'parenthesisLevel--': function (buffer) { buffer['parenthesisLevel']--; },
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation', p1: mhchemParser.go(m, 'o') };
        },
        'comma': function (buffer, m) {
          var a = m.replace(/\s*$/, '');
          var withSpace = (a !== m);
          if (withSpace  &&  buffer['parenthesisLevel'] === 0) {
            return { type_: 'comma enumeration L', p1: a };
          } else {
            return { type_: 'comma enumeration M', p1: a };
          }
        },
        'output': function (buffer, m, entityFollows) {
          // entityFollows:
          //   undefined = if we have nothing else to output, also ignore the just read space (buffer.sb)
          //   1 = an entity follows, never omit the space if there was one just read before (can only apply to state 1)
          //   2 = 1 + the entity can have an amount, so output a\, instead of converting it to o (can only apply to states a|as)
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          if (!buffer.r) {
            ret = [];
            if (!buffer.a && !buffer.b && !buffer.p && !buffer.o && !buffer.q && !buffer.d && !entityFollows) {
              //ret = [];
            } else {
              if (buffer.sb) {
                ret.push({ type_: 'entitySkip' });
              }
              if (!buffer.o && !buffer.q && !buffer.d && !buffer.b && !buffer.p && entityFollows!==2) {
                buffer.o = buffer.a;
                buffer.a = undefined;
              } else if (!buffer.o && !buffer.q && !buffer.d && (buffer.b || buffer.p)) {
                buffer.o = buffer.a;
                buffer.d = buffer.b;
                buffer.q = buffer.p;
                buffer.a = buffer.b = buffer.p = undefined;
              } else {
                if (buffer.o && buffer.dType==='kv' && mhchemParser.patterns.match_('d-oxidation$', buffer.d || "")) {
                  buffer.dType = 'oxidation';
                } else if (buffer.o && buffer.dType==='kv' && !buffer.q) {
                  buffer.dType = undefined;
                }
              }
              ret.push({
                type_: 'chemfive',
                a: mhchemParser.go(buffer.a, 'a'),
                b: mhchemParser.go(buffer.b, 'bd'),
                p: mhchemParser.go(buffer.p, 'pq'),
                o: mhchemParser.go(buffer.o, 'o'),
                q: mhchemParser.go(buffer.q, 'pq'),
                d: mhchemParser.go(buffer.d, (buffer.dType === 'oxidation' ? 'oxidation' : 'bd')),
                dType: buffer.dType
              });
            }
          } else {  // r
            /** @type {ParserOutput[]} */
            var rd;
            if (buffer.rdt === 'M') {
              rd = mhchemParser.go(buffer.rd, 'tex-math');
            } else if (buffer.rdt === 'T') {
              rd = [ { type_: 'text', p1: buffer.rd || "" } ];
            } else {
              rd = mhchemParser.go(buffer.rd);
            }
            /** @type {ParserOutput[]} */
            var rq;
            if (buffer.rqt === 'M') {
              rq = mhchemParser.go(buffer.rq, 'tex-math');
            } else if (buffer.rqt === 'T') {
              rq = [ { type_: 'text', p1: buffer.rq || ""} ];
            } else {
              rq = mhchemParser.go(buffer.rq);
            }
            ret = {
              type_: 'arrow',
              r: buffer.r,
              rd: rd,
              rq: rq
            };
          }
          for (var p in buffer) {
            if (p !== 'parenthesisLevel'  &&  p !== 'beginsWithBond') {
              delete buffer[p];
            }
          }
          return ret;
        },
        'oxidation-output': function (buffer, m) {
          var ret = [ "{" ];
          mhchemParser.concatArray(ret, mhchemParser.go(m, 'oxidation'));
          ret.push("}");
          return ret;
        },
        'frac-output': function (buffer, m) {
          return { type_: 'frac-ce', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'overset-output': function (buffer, m) {
          return { type_: 'overset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underset-output': function (buffer, m) {
          return { type_: 'underset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underbrace-output': function (buffer, m) {
          return { type_: 'underbrace', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1]) };
        },
        'r=': function (buffer, m) { buffer.r = m; },
        'rdt=': function (buffer, m) { buffer.rdt = m; },
        'rd=': function (buffer, m) { buffer.rd = m; },
        'rqt=': function (buffer, m) { buffer.rqt = m; },
        'rq=': function (buffer, m) { buffer.rq = m; },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; }
      }
    },
    'a': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        '$(...)$': {
          '*': { action_: 'tex-math tight', nextState: '1' } },
        ',': {
          '*': { action_: { type_: 'insert', option: 'commaDecimal' } } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'o': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        'letters': {
          '*': { action_: 'rm' } },
        '\\ca': {
          '*': { action_: { type_: 'insert', option: 'circa' } } },
        '\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: '{text}' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'text': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '{...}': {
          '*': { action_: 'text=' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '\\greek': {
          '*': { action_: [ 'output', 'rm' ] } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: [ 'output', 'copy' ] } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.text_) {
            /** @type {ParserOutput} */
            var ret = { type_: 'text', p1: buffer.text_ };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'pq': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'state of aggregation $': {
          '*': { action_: 'state of aggregation' } },
        'i$': {
          '0': { nextState: '!f', revisit: true } },
        '(KV letters),': {
          '0': { action_: 'rm', nextState: '0' } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'letters': {
          '*': { action_: 'rm' } },
        '-9.,9': {
          '*': { action_: '9,9'  } },
        ',': {
          '*': { action_: { type_: 'insert+p1', option: 'comma enumeration S' } } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation subscript', p1: mhchemParser.go(m, 'o') };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'pq') };
        }
      }
    },
    'bd': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'x$': {
          '0': { nextState: '!f', revisit: true } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '-9.,9 no missing 0': {
          '*': { action_: '9,9' } },
        '.': {
          '*': { action_: { type_: 'insert', option: 'electron dot' } } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'x': {
          '*': { action_: { type_: 'insert', option: 'KV x' } } },
        'letters': {
          '*': { action_: 'rm' } },
        '\'': {
          '*': { action_: { type_: 'insert', option: 'prime' } } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'bd') };
        }
      }
    },
    'oxidation': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'roman numeral': {
          '*': { action_: 'roman-numeral' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'roman-numeral': function (buffer, m) { return { type_: 'roman numeral', p1: m || "" }; }
      }
    },
    'tex-math': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'tex-math tight': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        '-|+': {
          '*': { action_: 'tight operator' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'tight operator': function (buffer, m) { buffer.o = (buffer.o || "") + "{"+m+"}"; },
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    '9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        ',': {
          '*': { action_: 'comma' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; }
      }
    },
    //#endregion
    //
    // \pu state machines
    //
    //#region pu
    'pu': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'space$': {
          '*': { action_: [ 'output', 'space' ] } },
        '{[(|)]}': {
          '0|a': { action_: 'copy' } },
        '(-)(9)^(-9)': {
          '0': { action_: 'number^', nextState: 'a' } },
        '(-)(9.,9)(e)(99)': {
          '0': { action_: 'enumber', nextState: 'a' } },
        'space': {
          '0|a': {} },
        'pm-operator': {
          '0|a': { action_: { type_: 'operator', option: '\\pm' }, nextState: '0' } },
        'operator': {
          '0|a': { action_: 'copy', nextState: '0' } },
        '//': {
          'd': { action_: 'o=', nextState: '/' } },
        '/': {
          'd': { action_: 'o=', nextState: '/' } },
        '{...}|else': {
          '0|d': { action_: 'd=', nextState: 'd' },
          'a': { action_: [ 'space', 'd=' ], nextState: 'd' },
          '/|q': { action_: 'q=', nextState: 'q' } }
      }),
      actions: {
        'enumber': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          if (m[1]) {
            mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
            if (m[2]) {
              if (m[2].match(/[,.]/)) {
                mhchemParser.concatArray(ret, mhchemParser.go(m[2], 'pu-9,9'));
              } else {
                ret.push(m[2]);
              }
            }
            m[3] = m[4] || m[3];
            if (m[3]) {
              m[3] = m[3].trim();
              if (m[3] === "e"  ||  m[3].substr(0, 1) === "*") {
                ret.push({ type_: 'cdot' });
              } else {
                ret.push({ type_: 'times' });
              }
            }
          }
          if (m[3]) {
            ret.push("10^{"+m[5]+"}");
          }
          return ret;
        },
        'number^': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
          ret.push("^{"+m[2]+"}");
          return ret;
        },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; },
        'space': function () { return { type_: 'pu-space-1' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          var md = mhchemParser.patterns.match_('{(...)}', buffer.d || "");
          if (md  &&  md.remainder === '') { buffer.d = md.match_; }
          var mq = mhchemParser.patterns.match_('{(...)}', buffer.q || "");
          if (mq  &&  mq.remainder === '') { buffer.q = mq.match_; }
          if (buffer.d) {
            buffer.d = buffer.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.d = buffer.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
          }
          if (buffer.q) {  // fraction
            buffer.q = buffer.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.q = buffer.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
            var b5 = {
              d: mhchemParser.go(buffer.d, 'pu'),
              q: mhchemParser.go(buffer.q, 'pu')
            };
            if (buffer.o === '//') {
              ret = { type_: 'pu-frac', p1: b5.d, p2: b5.q };
            } else {
              ret = b5.d;
              if (b5.d.length > 1  ||  b5.q.length > 1) {
                ret.push({ type_: ' / ' });
              } else {
                ret.push({ type_: '/' });
              }
              mhchemParser.concatArray(ret, b5.q);
            }
          } else {  // no fraction
            ret = mhchemParser.go(buffer.d, 'pu-2');
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-2': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '*': {
          '*': { action_: [ 'output', 'cdot' ], nextState: '0' } },
        '\\x': {
          '*': { action_: 'rm=' } },
        'space': {
          '*': { action_: [ 'output', 'space' ], nextState: '0' } },
        '^{(...)}|^(-1)': {
          '1': { action_: '^(-1)' } },
        '-9.,9': {
          '0': { action_: 'rm=', nextState: '0' },
          '1': { action_: '^(-1)', nextState: '0' } },
        '{...}|else': {
          '*': { action_: 'rm=', nextState: '1' } }
      }),
      actions: {
        'cdot': function () { return { type_: 'tight cdot' }; },
        '^(-1)': function (buffer, m) { buffer.rm += "^{"+m+"}"; },
        'space': function () { return { type_: 'pu-space-2' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret = [];
          if (buffer.rm) {
            var mrm = mhchemParser.patterns.match_('{(...)}', buffer.rm || "");
            if (mrm  &&  mrm.remainder === '') {
              ret = mhchemParser.go(mrm.match_, 'pu');
            } else {
              ret = { type_: 'rm', p1: buffer.rm };
            }
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '0': { action_: 'output-0' },
          'o': { action_: 'output-o' } },
        ',': {
          '0': { action_: [ 'output-0', 'comma' ], nextState: 'o' } },
        '.': {
          '0': { action_: [ 'output-0', 'copy' ], nextState: 'o' } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; },
        'output-0': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length % 3;
            if (a === 0) { a = 3; }
            for (var i=buffer.text_.length-3; i>0; i-=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(0, a));
            ret.reverse();
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        },
        'output-o': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length - 3;
            for (var i=0; i<a; i+=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(i));
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    }
    //#endregion
  };

  //
  // texify: Take MhchemParser output and convert it to TeX
  //
  /** @type {Texify} */
  var texify = {
    go: function (input, isInner) {  // (recursive, max 4 levels)
      if (!input) { return ""; }
      var res = "";
      var cee = false;
      for (var i=0; i < input.length; i++) {
        var inputi = input[i];
        if (typeof inputi === "string") {
          res += inputi;
        } else {
          res += texify._go2(inputi);
          if (inputi.type_ === '1st-level escape') { cee = true; }
        }
      }
      if (!isInner && !cee && res) {
        res = "{" + res + "}";
      }
      return res;
    },
    _goInner: function (input) {
      if (!input) { return input; }
      return texify.go(input, true);
    },
    _go2: function (buf) {
      /** @type {undefined | string} */
      var res;
      switch (buf.type_) {
        case 'chemfive':
          res = "";
          var b5 = {
            a: texify._goInner(buf.a),
            b: texify._goInner(buf.b),
            p: texify._goInner(buf.p),
            o: texify._goInner(buf.o),
            q: texify._goInner(buf.q),
            d: texify._goInner(buf.d)
          };
          //
          // a
          //
          if (b5.a) {
            if (b5.a.match(/^[+\-]/)) { b5.a = "{"+b5.a+"}"; }
            res += b5.a + "\\,";
          }
          //
          // b and p
          //
          if (b5.b || b5.p) {
            res += "{\\vphantom{X}}";
            res += "^{\\hphantom{"+(b5.b||"")+"}}_{\\hphantom{"+(b5.p||"")+"}}";
            res += "{\\vphantom{X}}";
            // In the next two lines, I've removed \smash[t] (ron)
            // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
            //res += "^{\\smash[t]{\\vphantom{2}}\\mathllap{"+(b5.b||"")+"}}";
            res += "^{\\vphantom{2}\\mathllap{"+(b5.b||"")+"}}";
            //res += "_{\\vphantom{2}\\mathllap{\\smash[t]{"+(b5.p||"")+"}}}";
            res += "_{\\vphantom{2}\\mathllap{"+(b5.p||"")+"}}";
          }
          //
          // o
          //
          if (b5.o) {
            if (b5.o.match(/^[+\-]/)) { b5.o = "{"+b5.o+"}"; }
            res += b5.o;
          }
          //
          // q and d
          //
          if (buf.dType === 'kv') {
            if (b5.d || b5.q) {
              res += "{\\vphantom{X}}";
            }
            if (b5.d) {
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else if (buf.dType === 'oxidation') {
            if (b5.d) {
              res += "{\\vphantom{X}}";
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // A Firefox bug adds a bogus depth to <mphantom>, so we change \vphantom{X} to {}
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else {
            if (b5.q) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
            if (b5.d) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              res += "^{"+b5.d+"}";
            }
          }
          break;
        case 'rm':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'text':
          if (buf.p1.match(/[\^_]/)) {
            buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
            res = "\\mathrm{"+buf.p1+"}";
          } else {
            res = "\\text{"+buf.p1+"}";
          }
          break;
        case 'roman numeral':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'state of aggregation':
          res = "\\mskip2mu "+texify._goInner(buf.p1);
          break;
        case 'state of aggregation subscript':
          res = "\\mskip1mu "+texify._goInner(buf.p1);
          break;
        case 'bond':
          res = texify._getBond(buf.kind_);
          if (!res) {
            throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + buf.kind_ + ")"];
          }
          break;
        case 'frac':
          var c = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
          res = "\\mathchoice{\\textstyle"+c+"}{"+c+"}{"+c+"}{"+c+"}";
          break;
        case 'pu-frac':
          var d = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          res = "\\mathchoice{\\textstyle"+d+"}{"+d+"}{"+d+"}{"+d+"}";
          break;
        case 'tex-math':
          res = buf.p1 + " ";
          break;
        case 'frac-ce':
          res = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'overset':
          res = "\\overset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underset':
          res = "\\underset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underbrace':
          res =  "\\underbrace{" + texify._goInner(buf.p1) + "}_{" + texify._goInner(buf.p2) + "}";
          break;
        case 'color':
          res = "{\\color{" + buf.color1 + "}{" + texify._goInner(buf.color2) + "}}";
          break;
        case 'color0':
          res = "\\color{" + buf.color + "}";
          break;
        case 'arrow':
          var b6 = {
            rd: texify._goInner(buf.rd),
            rq: texify._goInner(buf.rq)
          };
          var arrow = texify._getArrow(buf.r);
          if (b6.rq) { arrow += "[{\\rm " + b6.rq + "}]"; }
          if (b6.rd) {
            arrow += "{\\rm " + b6.rd + "}";
          } else {
            arrow += "{}";
          }
          res = arrow;
          break;
        case 'operator':
          res = texify._getOperator(buf.kind_);
          break;
        case '1st-level escape':
          res = buf.p1+" ";  // &, \\\\, \\hlin
          break;
        case 'space':
          res = " ";
          break;
        case 'entitySkip':
          res = "~";
          break;
        case 'pu-space-1':
          res = "~";
          break;
        case 'pu-space-2':
          res = "\\mkern3mu ";
          break;
        case '1000 separator':
          res = "\\mkern2mu ";
          break;
        case 'commaDecimal':
          res = "{,}";
          break;
          case 'comma enumeration L':
          res = "{"+buf.p1+"}\\mkern6mu ";
          break;
        case 'comma enumeration M':
          res = "{"+buf.p1+"}\\mkern3mu ";
          break;
        case 'comma enumeration S':
          res = "{"+buf.p1+"}\\mkern1mu ";
          break;
        case 'hyphen':
          res = "\\text{-}";
          break;
        case 'addition compound':
          res = "\\,{\\cdot}\\,";
          break;
        case 'electron dot':
          res = "\\mkern1mu \\text{\\textbullet}\\mkern1mu ";
          break;
        case 'KV x':
          res = "{\\times}";
          break;
        case 'prime':
          res = "\\prime ";
          break;
        case 'cdot':
          res = "\\cdot ";
          break;
        case 'tight cdot':
          res = "\\mkern1mu{\\cdot}\\mkern1mu ";
          break;
        case 'times':
          res = "\\times ";
          break;
        case 'circa':
          res = "{\\sim}";
          break;
        case '^':
          res = "uparrow";
          break;
        case 'v':
          res = "downarrow";
          break;
        case 'ellipsis':
          res = "\\ldots ";
          break;
        case '/':
          res = "/";
          break;
        case ' / ':
          res = "\\,/\\,";
          break;
        default:
          assertNever(buf);
          throw ["MhchemBugT", "mhchem bug T. Please report."];  // Missing texify rule or unknown MhchemParser output
      }
      assertString(res);
      return res;
    },
    _getArrow: function (a) {
      switch (a) {
        case "->": return "\\yields";
        case "\u2192": return "\\yields";
        case "\u27F6": return "\\yields";
        case "<-": return "\\yieldsLeft";
        case "<->": return "\\mesomerism";
        case "<-->": return "\\yieldsLeftRight";
        case "<=>": return "\\equilibrium";
        case "\u21CC": return "\\equilibrium";
        case "<=>>": return "\\equilibriumRight";
        case "<<=>": return "\\equilibriumLeft";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getBond: function (a) {
      switch (a) {
        case "-": return "{-}";
        case "1": return "{-}";
        case "=": return "{=}";
        case "2": return "{=}";
        case "#": return "{\\equiv}";
        case "3": return "{\\equiv}";
        case "~": return "{\\tripleDash}";
        case "~-": return "{\\tripleDashOverLine}";
        case "~=": return "{\\tripleDashOverDoubleLine}";
        case "~--": return "{\\tripleDashOverDoubleLine}";
        case "-~-": return "{\\tripleDashBetweenDoubleLine}";
        case "...": return "{{\\cdot}{\\cdot}{\\cdot}}";
        case "....": return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
        case "->": return "{\\rightarrow}";
        case "<-": return "{\\leftarrow}";
        case "<": return "{<}";
        case ">": return "{>}";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getOperator: function (a) {
      switch (a) {
        case "+": return " {}+{} ";
        case "-": return " {}-{} ";
        case "=": return " {}={} ";
        case "<": return " {}<{} ";
        case ">": return " {}>{} ";
        case "<<": return " {}\\ll{} ";
        case ">>": return " {}\\gg{} ";
        case "\\pm": return " {}\\pm{} ";
        case "\\approx": return " {}\\approx{} ";
        case "$\\approx$": return " {}\\approx{} ";
        case "v": return " \\downarrow{} ";
        case "(v)": return " \\downarrow{} ";
        case "^": return " \\uparrow{} ";
        case "(^)": return " \\uparrow{} ";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    }
  };

  //
  // Helpers for code analysis
  // Will show type error at calling position
  //
  /** @param {number} a */
  function assertNever(a) {}
  /** @param {string} a */
  function assertString(a) {}

/* eslint-disable no-undef */

//////////////////////////////////////////////////////////////////////
// texvc.sty

// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax

// We also omit texvc's \O, which conflicts with \text{\O}

defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\bull", "\\bullet");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\isin", "\\in");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");

/* eslint-disable no-undef */

/****************************************************
 *
 *  physics.js
 *
 *  Implements the Physics Package for LaTeX input.
 *
 *  ---------------------------------------------------------------------
 *
 *  The original version of this file is licensed as follows:
 *  Copyright (c) 2015-2016 Kolen Cheung <https://github.com/ickc/MathJax-third-party-extensions>.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  ---------------------------------------------------------------------
 *
 *  This file has been revised from the original in the following ways:
 *  1. The interface is changed so that it can be called from Temml, not MathJax.
 *  2. \Re and \Im are not used, to avoid conflict with existing LaTeX letters.
 *
 *  This revision of the file is released under the MIT license.
 *  https://mit-license.org/
 */
defineMacro("\\quantity", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\qty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\pqty", "{\\left( #1 \\right)}");
defineMacro("\\bqty", "{\\left[ #1 \\right]}");
defineMacro("\\vqty", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\Bqty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\absolutevalue", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\abs", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\norm", "{\\left\\Vert #1 \\right\\Vert}");
defineMacro("\\evaluated", "{\\left.#1 \\right\\vert}");
defineMacro("\\eval", "{\\left.#1 \\right\\vert}");
defineMacro("\\order", "{\\mathcal{O} \\left( #1 \\right)}");
defineMacro("\\commutator", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\comm", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\anticommutator", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\acomm", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\poissonbracket", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\pb", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\vectorbold", "{\\boldsymbol{ #1 }}");
defineMacro("\\vb", "{\\boldsymbol{ #1 }}");
defineMacro("\\vectorarrow", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\va", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\vectorunit", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\vu", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\dotproduct", "\\mathbin{\\boldsymbol\\cdot}");
defineMacro("\\vdot", "{\\boldsymbol\\cdot}");
defineMacro("\\crossproduct", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cross", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cp", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\gradient", "{\\boldsymbol\\nabla}");
defineMacro("\\grad", "{\\boldsymbol\\nabla}");
defineMacro("\\divergence", "{\\grad\\vdot}");
//defineMacro("\\div", "{\\grad\\vdot}"); Not included in Temml. Conflicts w/LaTeX \div
defineMacro("\\curl", "{\\grad\\cross}");
defineMacro("\\laplacian", "\\nabla^2");
defineMacro("\\tr", "{\\operatorname{tr}}");
defineMacro("\\Tr", "{\\operatorname{Tr}}");
defineMacro("\\rank", "{\\operatorname{rank}}");
defineMacro("\\erf", "{\\operatorname{erf}}");
defineMacro("\\Res", "{\\operatorname{Res}}");
defineMacro("\\principalvalue", "{\\mathcal{P}}");
defineMacro("\\pv", "{\\mathcal{P}}");
defineMacro("\\PV", "{\\operatorname{P.V.}}");
// Temml does not use the next two lines. They conflict with LaTeX letters.
//defineMacro("\\Re", "{\\operatorname{Re} \\left\\{ #1 \\right\\}}");
//defineMacro("\\Im", "{\\operatorname{Im} \\left\\{ #1 \\right\\}}");
defineMacro("\\qqtext", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qq", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qcomma", "{\\text{,}\\quad}");
defineMacro("\\qc", "{\\text{,}\\quad}");
defineMacro("\\qcc", "{\\quad\\text{c.c.}\\quad}");
defineMacro("\\qif", "{\\quad\\text{if}\\quad}");
defineMacro("\\qthen", "{\\quad\\text{then}\\quad}");
defineMacro("\\qelse", "{\\quad\\text{else}\\quad}");
defineMacro("\\qotherwise", "{\\quad\\text{otherwise}\\quad}");
defineMacro("\\qunless", "{\\quad\\text{unless}\\quad}");
defineMacro("\\qgiven", "{\\quad\\text{given}\\quad}");
defineMacro("\\qusing", "{\\quad\\text{using}\\quad}");
defineMacro("\\qassume", "{\\quad\\text{assume}\\quad}");
defineMacro("\\qsince", "{\\quad\\text{since}\\quad}");
defineMacro("\\qlet", "{\\quad\\text{let}\\quad}");
defineMacro("\\qfor", "{\\quad\\text{for}\\quad}");
defineMacro("\\qall", "{\\quad\\text{all}\\quad}");
defineMacro("\\qeven", "{\\quad\\text{even}\\quad}");
defineMacro("\\qodd", "{\\quad\\text{odd}\\quad}");
defineMacro("\\qinteger", "{\\quad\\text{integer}\\quad}");
defineMacro("\\qand", "{\\quad\\text{and}\\quad}");
defineMacro("\\qor", "{\\quad\\text{or}\\quad}");
defineMacro("\\qas", "{\\quad\\text{as}\\quad}");
defineMacro("\\qin", "{\\quad\\text{in}\\quad}");
defineMacro("\\differential", "{\\text{d}}");
defineMacro("\\dd", "{\\text{d}}");
defineMacro("\\derivative", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\dv", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\partialderivative", "{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}");
defineMacro("\\variation", "{\\delta}");
defineMacro("\\var", "{\\delta}");
defineMacro("\\functionalderivative", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\fdv", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\innerproduct", "{\\left\\langle {#1} \\mid { #2} \\right\\rangle}");
defineMacro("\\outerproduct",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\dyad",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\ketbra",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\op",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\expectationvalue", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\expval", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\ev", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\matrixelement",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\matrixel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\mel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");

// Helper functions
function getHLines(parser) {
  // Return an array. The array length = number of hlines.
  // Each element in the array tells if the line is dashed.
  const hlineInfo = [];
  parser.consumeSpaces();
  let nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}

const validateAmsEnvironmentContext = context => {
  const settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError(`{${context.envName}} can be used only in display mode.`);
  }
};

const sizeRegEx$1 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const arrayGaps = macros => {
  let arraystretch = macros.get("\\arraystretch");
  if (typeof arraystretch !== "string") {
    arraystretch = stringFromArg(arraystretch.tokens);
  }
  arraystretch = isNaN(arraystretch) ? null : Number(arraystretch);
  let arraycolsepStr = macros.get("\\arraycolsep");
  if (typeof arraycolsepStr !== "string") {
    arraycolsepStr = stringFromArg(arraycolsepStr.tokens);
  }
  const match = sizeRegEx$1.exec(arraycolsepStr);
  const arraycolsep = match
    ? { number: +(match[1] + match[2]), unit: match[3] }
    : null;
  return [arraystretch, arraycolsep]
};

const checkCellForLabels = cell => {
  // Check if the author wrote a \tag{} inside this cell.
  let rowLabel = "";
  for (let i = 0; i < cell.length; i++) {
    if (cell[i].type === "label") {
      if (rowLabel) { throw new ParseError(("Multiple \\labels in one row")) }
      rowLabel = cell[i].string;
    }
  }
  return rowLabel
};

// autoTag (an argument to parseArray) can be one of three values:
// * undefined: Regular (not-top-level) array; no tags on each row
// * true: Automatic equation numbering, overridable by \tag
// * false: Tags allowed on each row, but no automatic numbering
// This function *doesn't* work with the "split" environment name.
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
  // return undefined;
}

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument scriptLevel
 * ("text", "display", etc.), then each cell is cast into that scriptLevel.
 */
function parseArray(
  parser,
  {
    cols, // [{ type: string , align: l|c|r|null }]
    envClasses, // align(ed|at|edat) | array | cases | cd | small | multline
    autoTag,        // boolean
    singleRow,      // boolean
    emptySingleRow, // boolean
    maxNumCols,     // number
    leqno,          // boolean
    arraystretch,   // number  | null
    arraycolsep     // size value | null
},
  scriptLevel
) {
  const endToken = envClasses && envClasses.includes("bordermatrix") ? "}" : "\\end";
  parser.gullet.beginGroup();
  if (!singleRow) {
    // \cr is equivalent to \\ without the optional size argument (see below)
    // TODO: provide helpful error when \cr is used outside array environment
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }

  // Start group for first cell
  parser.gullet.beginGroup();

  let row = [];
  const body = [row];
  const rowGaps = [];
  const labels = [];

  const hLinesBeforeRow = [];

  const tags = (autoTag != null ? [] : undefined);

  // amsmath uses \global\@eqnswtrue and \global\@eqnswfalse to represent
  // whether this row should have an equation number.  Simulate this with
  // a \@eqnsw macro set to 1 or 0.
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", undefined, true);
      } else {
        tags.push(Boolean(autoTag) &&
            parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();

  // Test for \hline at the top of the array.
  hLinesBeforeRow.push(getHLines(parser));

  while (true) {
    // Parse each cell in its own group (namespace)
    let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();

    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell,
      semisimple: true
    };
    row.push(cell);
    const next = parser.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (envClasses.includes("array")) {
          if (parser.settings.strict) {
            throw new ParseError("Too few columns " + "specified in the {array} column argument.",
              parser.nextToken)
          }
        } else if (maxNumCols === 2) {
          throw new ParseError("The split environment accepts no more than two columns",
            parser.nextToken);
        } else {
          throw new ParseError("The equation environment accepts only one column",
            parser.nextToken)
        }
      }
      parser.consume();
    } else if (next === endToken) {
      endRow();
      // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
      // the last line is empty.  However, AMS environments keep the
      // empty row if it's the only one.
      // NOTE: Currently, `cell` is the last item added into `row`.
      if (row.length === 1 && cell.body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      labels.push(checkCellForLabels(cell.body));
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser.consume();
      let size;
      // \def\Let@{\let\\\math@cr}
      // \def\math@cr{...\math@cr@}
      // \def\math@cr@{\new@ifnextchar[\math@cr@@{\math@cr@@[\z@]}}
      // \def\math@cr@@[#1]{...\math@cr@@@...}
      // \def\math@cr@@@{\cr}
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();

      labels.push(checkCellForLabels(cell.body));

      // check for \hline(s) following the row separator
      hLinesBeforeRow.push(getHLines(parser));

      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or " + endToken, parser.nextToken);
    }
  }

  // End cell group
  parser.gullet.endGroup();
  // End array group defining \cr
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: parser.mode,
    body,
    cols,
    rowGaps,
    hLinesBeforeRow,
    envClasses,
    autoTag,
    scriptLevel,
    tags,
    labels,
    leqno,
    arraystretch,
    arraycolsep
  };
}

// Decides on a scriptLevel for cells in an array according to whether the given
// environment name starts with the letter 'd'.
function dCellStyle(envName) {
  return envName.slice(0, 1) === "d" ? "display" : "text"
}

const alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};

const glue = group => {
  const glueNode = new mathMLTree.MathNode("mtd", []);
  glueNode.style = { padding: "0", width: "50%" };
  if (group.envClasses.includes("multline")) {
    glueNode.style.width = "7.5%";
  }
  return glueNode
};

const mathmlBuilder$9 = function(group, style) {
  const tbl = [];
  const numRows = group.body.length;
  const hlines = group.hLinesBeforeRow;

  for (let i = 0; i < numRows; i++) {
    const rw = group.body[i];
    const row = [];
    const cellLevel = group.scriptLevel === "text"
      ? StyleLevel.TEXT
      : group.scriptLevel === "script"
      ? StyleLevel.SCRIPT
      : StyleLevel.DISPLAY;

    for (let j = 0; j < rw.length; j++) {
      const mtd = new mathMLTree.MathNode(
        "mtd",
        [buildGroup$1(rw[j], style.withLevel(cellLevel))]
      );

      if (group.envClasses.includes("multline")) {
        const align = i === 0 ? "left" : i === numRows - 1 ? "right" : "center";
        mtd.setAttribute("columnalign", align);
        if (align !== "center") {
          mtd.classes.push("tml-" + align);
        }
      }
      row.push(mtd);
    }
    const numColumns = group.body[0].length;
    // Fill out a short row with empty <mtd> elements.
    for (let k = 0; k < numColumns - rw.length; k++) {
      row.push(new mathMLTree.MathNode("mtd", [], style));
    }
    if (group.autoTag) {
      const tag = group.tags[i];
      let tagElement;
      if (tag === true) {  // automatic numbering
        tagElement = new mathMLTree.MathNode("mtext", [new Span(["tml-eqn"])]);
      } else if (tag === false) {
        // \nonumber/\notag or starred environment
        tagElement = new mathMLTree.MathNode("mtext", [], []);
      } else {  // manual \tag
        tagElement = buildExpressionRow(tag[0].body, style.withLevel(cellLevel), true);
        tagElement = consolidateText(tagElement);
        tagElement.classes = ["tml-tag"];
      }
      if (tagElement) {
        row.unshift(glue(group));
        row.push(glue(group));
        if (group.leqno) {
          row[0].children.push(tagElement);
          row[0].classes.push("tml-left");
        } else {
          row[row.length - 1].children.push(tagElement);
          row[row.length - 1].classes.push("tml-right");
        }
      }
    }
    const mtr = new mathMLTree.MathNode("mtr", row, []);
    const label = group.labels.shift();
    if (label && group.tags && group.tags[i]) {
      mtr.setAttribute("id", label);
      if (Array.isArray(group.tags[i])) { mtr.classes.push("tml-tageqn"); }
    }

    // Write horizontal rules
    if (i === 0 && hlines[0].length > 0) {
      if (hlines[0].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderTop = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderTop = hlines[0][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }
    if (hlines[i + 1].length > 0) {
      if (hlines[i + 1].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderBottom = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderBottom = hlines[i + 1][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }

    // Check for \hphantom \from \bordermatrix
    let mustSquashRow = true;
    for (let j = 0; j < mtr.children.length; j++) {
      const child = mtr.children[j].children[0];
      if (!(child && child.type === "mpadded" && child.attributes.height === "0px")) {
        mustSquashRow = false;
        break
      }
    }
    if (mustSquashRow) {
      // All the cell contents are \hphantom. Squash the padding.
      for (let j = 0; j < mtr.children.length; j++) {
        mtr.children[j].style.paddingTop = "0";
        mtr.children[j].style.paddingBottom = "0";
      }
    }

    tbl.push(mtr);
  }

  if (group.arraystretch && group.arraystretch !== 1) {
    // In LaTeX, \arraystretch is a factor applied to a 12pt strut height.
    // It defines a baseline to baseline distance.
    // Here, we do an approximation of that approach.
    const pad = String(1.4 * group.arraystretch - 0.8) + "ex";
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingTop = pad;
        tbl[i].children[j].style.paddingBottom = pad;
      }
    }
  }

  let sidePadding;
  let sidePadUnit;
  if (group.envClasses.length > 0) {
    sidePadding = group.envClasses.includes("abut")
      ? "0"
      : group.envClasses.includes("cases")
      ? "0"
      : group.envClasses.includes("small")
      ? "0.1389"
      : group.envClasses.includes("cd")
      ? "0.25"
      : "0.4"; // default side padding
    sidePadUnit = "em";
  }
  if (group.arraycolsep) {
    const arraySidePad = calculateSize(group.arraycolsep, style);
    sidePadding = arraySidePad.number.toFixed(4);
    sidePadUnit = arraySidePad.unit;
  }
  if (sidePadding) {
    const numCols = tbl.length === 0 ? 0 : tbl[0].children.length;

    const sidePad = (j, hand) => {
      if (j === 0 && hand === 0) { return "0" }
      if (j === numCols - 1 && hand === 1) { return "0" }
      if (group.envClasses[0] !== "align") { return sidePadding }
      if (hand === 1) { return "0" }
      if (group.autoTag) {
        return (j % 2) ? "1" : "0"
      } else {
        return (j % 2) ? "0" : "1"
      }
    };

    // Side padding
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingLeft = `${sidePad(j, 0)}${sidePadUnit}`;
        tbl[i].children[j].style.paddingRight = `${sidePad(j, 1)}${sidePadUnit}`;
      }
    }
  }
  if (group.envClasses.length === 0) {
    // Set zero padding on side of the matrix
    for (let i = 0; i < tbl.length; i++) {
      tbl[i].children[0].style.paddingLeft = "0em";
      if (tbl[i].children.length === tbl[0].children.length) {
        tbl[i].children[tbl[i].children.length - 1].style.paddingRight = "0em";
      }
    }
  }

  if (group.envClasses.length > 0) {
    // Justification
    const align = group.envClasses.includes("align") || group.envClasses.includes("alignat");
    for (let i = 0; i < tbl.length; i++) {
      const row = tbl[i];
      if (align) {
        for (let j = 0; j < row.children.length; j++) {
          // Chromium does not recognize text-align: left. Use -webkit-
          // TODO: Remove -webkit- when Chromium no longer needs it.
          row.children[j].classes = ["tml-" + (j % 2 ? "left" : "right")];
        }
        if (group.autoTag) {
          const k = group.leqno ? 0 : row.children.length - 1;
          row.children[k].classes = ["tml-" + (group.leqno ? "left" : "right")];
        }
      }
      if (row.children.length > 1 && group.envClasses.includes("cases")) {
        row.children[1].style.paddingLeft = "1em";
      }

      if (group.envClasses.includes("cases") || group.envClasses.includes("subarray")) {
        for (const cell of row.children) {
          cell.classes.push("tml-left");
        }
      }
    }
  }

  let table = new mathMLTree.MathNode("mtable", tbl);
  if (group.envClasses.length > 0) {
    // Top & bottom padding
    if (group.envClasses.includes("jot")) {
      table.classes.push("tml-jot");
    } else if (group.envClasses.includes("small")) {
      table.classes.push("tml-small");
    }
  }
  if (group.scriptLevel === "display") { table.setAttribute("displaystyle", "true"); }

  if (group.autoTag || group.envClasses.includes("multline")) {
    table.style.width = "100%";
  }

  // Column separator lines and column alignment
  let align = "";

  if (group.cols && group.cols.length > 0) {
    const cols = group.cols;
    let prevTypeWasAlign = false;
    let iStart = 0;
    let iEnd = cols.length;

    while (cols[iStart].type === "separator") {
      iStart += 1;
    }
    while (cols[iEnd - 1].type === "separator") {
      iEnd -= 1;
    }

    if (cols[0].type === "separator") {
      const sep = cols[1].type === "separator"
        ? "0.15em double"
        : cols[0].separator === "|"
        ? "0.06em solid "
        : "0.06em dashed ";
      for (const row of table.children) {
        row.children[0].style.borderLeft = sep;
      }
    }
    let iCol = group.autoTag ? 0 : -1;
    for (let i = iStart; i < iEnd; i++) {
      if (cols[i].type === "align") {
        const colAlign = alignMap[cols[i].align];
        align += colAlign;
        iCol += 1;
        for (const row of table.children) {
          if (colAlign.trim() !== "center" && iCol < row.children.length) {
            row.children[iCol].classes = ["tml-" + colAlign.trim()];
          }
        }
        prevTypeWasAlign = true;
      } else if (cols[i].type === "separator") {
        // MathML accepts only single lines between cells.
        // So we read only the first of consecutive separators.
        if (prevTypeWasAlign) {
          const sep = cols[i + 1].type === "separator"
            ? "0.15em double"
            : cols[i].separator === "|"
            ? "0.06em solid"
            : "0.06em dashed";
          for (const row of table.children) {
            if (iCol < row.children.length) {
              row.children[iCol].style.borderRight = sep;
            }
          }
        }
        prevTypeWasAlign = false;
      }
    }
    if (cols[cols.length - 1].type === "separator") {
      const sep = cols[cols.length - 2].type === "separator"
        ? "0.15em double"
        : cols[cols.length - 1].separator === "|"
        ? "0.06em solid"
        : "0.06em dashed";
      for (const row of table.children) {
        row.children[row.children.length - 1].style.borderRight = sep;
        row.children[row.children.length - 1].style.paddingRight = "0.4em";
      }
    }
  }
  if (group.autoTag) {
     // allow for glue cells on each side
    align = "left " + (align.length > 0 ? align : "center ") + "right ";
  }
  if (align) {
    // Firefox reads this attribute, not the -webkit-left|right written above.
    // TODO: When Chrome no longer needs "-webkit-", use CSS and delete the next line.
    table.setAttribute("columnalign", align.trim());
  }

  if (group.envClasses.includes("small")) {
    // A small array. Wrap in scriptstyle.
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }

  return table
};

// Convenience function for align, align*, aligned, alignat, alignat*, alignedat, split.
const alignedHandler = function(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  const isSplit = context.envName === "split";
  const cols = [];
  const res = parseArray(
    context.parser,
    {
      cols,
      emptySingleRow: true,
      autoTag: isSplit ? undefined : getAutoTag(context.envName),
      envClasses: ["abut", "jot"], // set row spacing & provisional column spacing
      maxNumCols: context.envName === "split" ? 2 : undefined,
      leqno: context.parser.settings.leqno
    },
    "display"
  );

  // Determining number of columns.
  // 1. If the first argument is given, we use it as a number of columns,
  //    and makes sure that each row doesn't exceed that number.
  // 2. Otherwise, just count number of columns = maximum number
  //    of cells in each row ("aligned" mode -- isAligned will be true).
  //
  // At the same time, prepend empty group {} at beginning of every second
  // cell in each row (starting with second cell) so that operators become
  // binary.  This behavior is implemented in amsmath's \start@aligned.
  let numMaths;
  let numCols = 0;
  const isAlignedAt = context.envName.indexOf("at") > -1;
  if (args[0] && isAlignedAt) {
    // alignat environment takes an argument w/ number of columns
    let arg0 = "";
    for (let i = 0; i < args[0].body.length; i++) {
      const textord = assertNodeType(args[0].body[i], "textord");
      arg0 += textord.text;
    }
    if (isNaN(arg0)) {
      throw new ParseError("The alignat enviroment requires a numeric first argument.")
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  res.body.forEach(function(row) {
    if (isAlignedAt) {
      // Case 1
      const curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError(
          "Too many math in a row: " + `expected ${numMaths}, but got ${curMaths}`,
          row[0]
        );
      }
    } else if (numCols < row.length) {
      // Case 2
      numCols = row.length;
    }
  });

  // Adjusting alignment.
  // In aligned mode, we add one \qquad between columns;
  // otherwise we add nothing.
  for (let i = 0; i < numCols; ++i) {
    let align = "r";
    if (i % 2 === 1) {
      align = "l";
    }
    cols[i] = {
      type: "align",
      align: align
    };
  }
  if (context.envName === "split") ; else if (isAlignedAt) {
    res.envClasses.push("alignat"); // Sets justification
  } else {
    res.envClasses[0] = "align"; // Sets column spacing & justification
  }
  return res;
};

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    const res = {
      cols,
      envClasses: ["array"],
      maxNumCols: cols.length,
      arraystretch,
      arraycolsep
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  mathmlBuilder: mathmlBuilder$9
});

// The matrix environments of amsmath build on the array environment
// of LaTeX, which is discussed above.
// The mathtools package adds starred versions of the same environments.
// These have an optional argument to choose left|center|right justification.
defineEnvironment({
  type: "array",
  names: [
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix",
    "matrix*",
    "pmatrix*",
    "bmatrix*",
    "Bmatrix*",
    "vmatrix*",
    "Vmatrix*"
  ],
  props: {
    numArgs: 0
  },
  handler(context) {
    const delimiters = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    // \hskip -\arraycolsep in amsmath
    let colAlign = "c";
    const payload = {
      envClasses: [],
      cols: []
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      // It's one of the mathtools starred functions.
      // Parse the optional alignment argument.
      const parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [];
      }
    }
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: colAlign });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    res.arraystretch = arraystretch;
    if (arraycolsep && !(arraycolsep === 6 && arraycolsep === "pt")) {
      res.arraycolsep = arraycolsep;
    }
    return delimiters
      ? {
        type: "leftright",
        mode: context.mode,
        body: [res],
        left: delimiters[0],
        right: delimiters[1],
        rightColor: undefined // \right uninfluenced by \color in array
      }
      : res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["bordermatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { cols: [], envClasses: ["bordermatrix"] };
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: "c" });
    res.envClasses = [];
    res.arraystretch = 1;
    if (context.envName === "matrix") { return res}
    return bordermatrixParseTree(res, context.delimiters)
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { type: "small" };
    const res = parseArray(context.parser, payload, "script");
    res.envClasses = ["small"];
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Parsing of {subarray} is similar to {array}
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      // {subarray} only recognizes "l" & "c"
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    let res = {
      cols,
      envClasses: ["small"]
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def
// \left\{\begin{array}{@{}l@{\quad}l@{}} â€¦ \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.
// {rcases} is another mathtools environment. It's brace is on the right side.
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = {
      cols: [],
      envClasses: ["cases"]
    };
    const res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: undefined
    };
  },
  mathmlBuilder: mathmlBuilder$9
});

// In the align environment, one uses ampersands, &, to specify number of
// columns in each row, and to locate spacing between each column.
// align gets automatic numbering. align* and aligned do not.
// The alignedat environment can be used in math mode.
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust where spacing occurs.
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (context.envName !== "gathered") {
      validateAmsEnvironmentContext(context);
    }
    const res = {
      cols: [],
      envClasses: ["abut", "jot"],
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      envClasses: ["align"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["multline", "multline*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: context.envName === "multline",
      maxNumCols: 1,
      envClasses: ["jot", "multline"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  mathmlBuilder: mathmlBuilder$9
});

// Catch \hline outside array environment
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(`${context.funcName} valid only within array environment`);
  }
});

const environments = _environments;

// \bordermatrix  from TeXbook pp 177 & 361
// Optional argument from Herbert VoÃŸ, Math mode, p 20
// Ref: https://tug.ctan.org/obsolete/info/math/voss/mathmode/Mathmode.pdf

defineFunction({
  type: "bordermatrix",
  names: ["\\bordermatrix", "\\matrix"],
  props: {
    numArgs: 0,
    numOptionalArgs: 1
  },
  handler: ({ parser, funcName }, args, optArgs) => {
    // Find out if the author has defined custom delimiters
    let delimiters = ["(", ")"];
    if (funcName === "\\bordermatrix" && optArgs[0] && optArgs[0].body) {
      const body = optArgs[0].body;
      if (body.length === 2 && body[0].type === "atom" && body[1].type === "atom") {
        if (body[0].family === "open" && body[1].family === "close") {
          delimiters = [body[0].text, body[1].text];
        }
      }
    }
    // consume the opening brace
    parser.consumeSpaces();
    parser.consume();

    // Pass control to the environment handler in array.js.
    const env = environments["bordermatrix"];
    const context = {
      mode: parser.mode,
      envName: funcName.slice(1),
      delimiters,
      parser
    };
    const result = env.handler(context);
    parser.expect("}", true);
    return result
  }
});

// \@char is an internal function that takes a grouped decimal argument like
// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, token }, args) {
    const arg = assertNodeType(args[0], "ordgroup");
    const group = arg.body;
    let number = "";
    for (let i = 0; i < group.length; i++) {
      const node = assertNodeType(group[i], "textord");
      number += node.text;
    }
    const code = parseInt(number);
    if (isNaN(code)) {
      throw new ParseError(`\\@char has non-numeric argument ${number}`, token)
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: String.fromCodePoint(code)
    }
  }
});

// Helpers
const htmlRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6})$/i;
const htmlOrNameRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i;
const RGBregEx = /^ *\d{1,3} *(?:, *\d{1,3} *){2}$/;
const rgbRegEx = /^ *[10](?:\.\d*)? *(?:, *[10](?:\.\d*)? *){2}$/;
const xcolorHtmlRegEx = /^[a-f0-9]{6}$/i;
const toHex = num => {
  let str = num.toString(16);
  if (str.length === 1) { str = "0" + str; }
  return str
};

// Colors from Tables 4.1 and 4.2 of the xcolor package.
// Table 4.1 (lower case) RGB values are taken from chroma and xcolor.dtx.
// Table 4.2 (Capitalizzed) values were sampled, because Chroma contains a unreliable
// conversion from cmyk to RGB. See https://tex.stackexchange.com/a/537274.
const xcolors = JSON.parse(`{
  "Apricot": "#ffb484",
  "Aquamarine": "#08b4bc",
  "Bittersweet": "#c84c14",
  "blue": "#0000FF",
  "Blue": "#303494",
  "BlueGreen": "#08b4bc",
  "BlueViolet": "#503c94",
  "BrickRed": "#b8341c",
  "brown": "#BF8040",
  "Brown": "#802404",
  "BurntOrange": "#f8941c",
  "CadetBlue": "#78749c",
  "CarnationPink": "#f884b4",
  "Cerulean": "#08a4e4",
  "CornflowerBlue": "#40ace4",
  "cyan": "#00FFFF",
  "Cyan": "#08acec",
  "Dandelion": "#ffbc44",
  "darkgray": "#404040",
  "DarkOrchid": "#a8548c",
  "Emerald": "#08ac9c",
  "ForestGreen": "#089c54",
  "Fuchsia": "#90348c",
  "Goldenrod": "#ffdc44",
  "gray": "#808080",
  "Gray": "#98949c",
  "green": "#00FF00",
  "Green": "#08a44c",
  "GreenYellow": "#e0e474",
  "JungleGreen": "#08ac9c",
  "Lavender": "#f89cc4",
  "lightgray": "#c0c0c0",
  "lime": "#BFFF00",
  "LimeGreen": "#90c43c",
  "magenta": "#FF00FF",
  "Magenta": "#f0048c",
  "Mahogany": "#b0341c",
  "Maroon": "#b03434",
  "Melon": "#f89c7c",
  "MidnightBlue": "#086494",
  "Mulberry": "#b03c94",
  "NavyBlue": "#086cbc",
  "olive": "#7F7F00",
  "OliveGreen": "#407c34",
  "orange": "#FF8000",
  "Orange": "#f8843c",
  "OrangeRed": "#f0145c",
  "Orchid": "#b074ac",
  "Peach": "#f8945c",
  "Periwinkle": "#8074bc",
  "PineGreen": "#088c74",
  "pink": "#ff7f7f",
  "Plum": "#98248c",
  "ProcessBlue": "#08b4ec",
  "purple": "#BF0040",
  "Purple": "#a0449c",
  "RawSienna": "#983c04",
  "red": "#ff0000",
  "Red": "#f01c24",
  "RedOrange": "#f86434",
  "RedViolet": "#a0246c",
  "Rhodamine": "#f0549c",
  "Royallue": "#0874bc",
  "RoyalPurple": "#683c9c",
  "RubineRed": "#f0047c",
  "Salmon": "#f8948c",
  "SeaGreen": "#30bc9c",
  "Sepia": "#701404",
  "SkyBlue": "#48c4dc",
  "SpringGreen": "#c8dc64",
  "Tan": "#e09c74",
  "teal": "#007F7F",
  "TealBlue": "#08acb4",
  "Thistle": "#d884b4",
  "Turquoise": "#08b4cc",
  "violet": "#800080",
  "Violet": "#60449c",
  "VioletRed": "#f054a4",
  "WildStrawberry": "#f0246c",
  "yellow": "#FFFF00",
  "Yellow": "#fff404",
  "YellowGreen": "#98cc6c",
  "YellowOrange": "#ffa41c"
}`);

const colorFromSpec = (model, spec) => {
  let color = "";
  if (model === "HTML") {
    if (!htmlRegEx.test(spec)) {
      throw new ParseError("Invalid HTML input.")
    }
    color = spec;
  } else if (model === "RGB") {
    if (!RGBregEx.test(spec)) {
      throw new ParseError("Invalid RGB input.")
    }
    spec.split(",").map(e => { color += toHex(Number(e.trim())); });
  } else {
    if (!rgbRegEx.test(spec)) {
      throw new ParseError("Invalid rbg input.")
    }
    spec.split(",").map(e => {
      const num = Number(e.trim());
      if (num > 1) { throw new ParseError("Color rgb input must be < 1.") }
      color += toHex(Number((num * 255).toFixed(0)));
    });
  }
  if (color.charAt(0) !== "#") { color = "#" + color; }
  return color
};

const validateColor = (color, macros, token) => {
  const macroName = `\\\\color@${color}`; // from \defineColor.
  const match = htmlOrNameRegEx.exec(color);
  if (!match) { throw new ParseError("Invalid color: '" + color + "'", token) }
  // We allow a 6-digit HTML color spec without a leading "#".
  // This follows the xcolor package's HTML color model.
  // Predefined color names are all missed by this RegEx pattern.
  if (xcolorHtmlRegEx.test(color)) {
    return "#" + color
  } else if (color.charAt(0) === "#") {
    return color
  } else if (macros.has(macroName)) {
    color = macros.get(macroName).tokens[0].text;
  } else if (xcolors[color]) {
    color = xcolors[color];
  }
  return color
};

const mathmlBuilder$8 = (group, style) => {
  // In LaTeX, color is not supposed to change the spacing of any node.
  // So instead of wrapping the group in an <mstyle>, we apply
  // the color individually to each node and return a document fragment.
  let expr = buildExpression(group.body, style.withColor(group.color));
  expr = expr.map(e => {
    e.style.color = group.color;
    return e
  });
  return mathMLTree.newDocumentFragment(expr)
};

defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "original"]
  },
  handler({ parser, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }
    const body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: true,
      body: ordargument(body)
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw"]
  },
  handler({ parser, breakOnTokenText, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }

    // Parse out the implicit body that should be colored.
    const body = parser.parseExpression(true, breakOnTokenText, true);

    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: false,
      body
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\definecolor"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw"]
  },
  handler({ parser, funcName, token }, args) {
    const name = assertNodeType(args[0], "raw").string;
    if (!/^[A-Za-z]+$/.test(name)) {
      throw new ParseError("Color name must be latin letters.", token)
    }
    const model = assertNodeType(args[1], "raw").string;
    if (!["HTML", "RGB", "rgb"].includes(model)) {
      throw new ParseError("Color model must be HTML, RGB, or rgb.", token)
    }
    const spec = assertNodeType(args[2], "raw").string;
    const color = colorFromSpec(model, spec);
    parser.gullet.macros.set(`\\\\color@${name}`, { tokens: [{ text: color }], numArgs: 0 });
    return { type: "internal", mode: parser.mode }
  }
  // No mathmlBuilder. The point of \definecolor is to set a macro.
});

// Row breaks within tabular environments, and line breaks at top level


// \DeclareRobustCommand\\{...\@xnewline}
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },

  handler({ parser }, args, optArgs) {
    const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    const newLine = !parser.settings.displayMode;
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    }
  },

  // The following builder is called only at the top level,
  // not within tabular/array environments.

  mathmlBuilder(group, style) {
    // MathML 3.0 calls for newline to occur in an <mo> or an <mspace>.
    // Ref: https://www.w3.org/TR/MathML3/chapter3.html#presm.linebreaking
    const node = new mathMLTree.MathNode("mo");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        const size = calculateSize(group.size, style);
        node.setAttribute("height", size.number + size.unit);
      }
    }
    return node
  }
});

const globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};

const checkControlSequence = (tok) => {
  const name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};

const getRHS = (parser) => {
  let tok = parser.gullet.popToken();
  if (tok.text === "=") {
    // consume optional equals
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      // consume one optional space
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};

const letCommand = (parser, name, tok, global) => {
  let macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    // don't expand it later even if a macro with the same name is defined
    // e.g., \let\foo=\frac \def\frac{\relax} \frac12
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global);
};

// <assignment> -> <non-macro assignment>|<macro assignment>
// <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
// <macro assignment> -> <definition>|<prefix><macro assignment>
// <prefix> -> \global|\long|\outer
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong" // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser, funcName }) {
    parser.consumeSpaces();
    const token = parser.fetch();
    if (globalMap[token.text]) {
      // Temml doesn't have \par, so ignore \long
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError(`Invalid token after macro prefix`, token);
  }
});

// Basic support for macro definitions: \def, \gdef, \edef, \xdef
// <definition> -> <def><control sequence><definition text>
// <def> -> \def|\gdef|\edef|\xdef
// <definition text> -> <parameter text><left brace><balanced text><right brace>
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let tok = parser.gullet.popToken();
    const name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }

    let numArgs = 0;
    let insert;
    const delimiters = [[]];
    // <parameter text> contains no braces
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        // If the very last character of the <parameter text> is #, so that
        // this # is immediately followed by {, TeX will behave as if the {
        // had been inserted at the right end of both the parameter text
        // and the replacement text.
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters[numArgs].push("{");
          break;
        }

        // A parameter, the first appearance of # must be followed by 1,
        // the next by 2, and so on; up to nine #â€™s are allowed
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError(`Invalid argument number "${tok.text}"`);
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError(`Argument number "${tok.text}" out of order`);
        }
        numArgs++;
        delimiters.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters[numArgs].push(tok.text);
      }
    }
    // replacement text, enclosed in '{' and '}' and properly nested
    let { tokens } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }

    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      if (tokens.length > parser.gullet.settings.maxExpand) {
        throw new ParseError("Too many expansions in an " + funcName);
      }
      tokens.reverse(); // to fit in with stack order
    }
    // Final arg is the expansion of the macro
    parser.gullet.macros.set(
      name,
      { tokens, numArgs, delimiters },
      funcName === globalMap[funcName]
    );
    return { type: "internal", mode: parser.mode };
  }
});

// <simple assignment> -> <let assignment>
// <let assignment> -> \futurelet<control sequence><token><token>
//     | \let<control sequence><equals><one optional space><token>
// <equals> -> <optional spaces>|<optional spaces>=
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet" // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    const tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return { type: "internal", mode: parser.mode };
  }
});

// ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture" // canâ€™t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    const middle = parser.gullet.popToken();
    const tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return { type: "internal", mode: parser.mode };
  }
});

defineFunction({
  type: "internal",
  names: ["\\newcommand", "\\renewcommand", "\\providecommand"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let name = "";
    const tok = parser.gullet.popToken();
    if (tok.text === "{") {
      name = checkControlSequence(parser.gullet.popToken());
      parser.gullet.popToken();
    } else {
      name = checkControlSequence(tok);
    }

    const exists = parser.gullet.isDefined(name);
    if (exists && funcName === "\\newcommand") {
      throw new ParseError(
        `\\newcommand{${name}} attempting to redefine ${name}; use \\renewcommand`
      );
    }
    if (!exists && funcName === "\\renewcommand") {
      throw new ParseError(
        `\\renewcommand{${name}} when command ${name} does not yet exist; use \\newcommand`
      );
    }

    let numArgs = 0;
    if (parser.gullet.future().text === "[") {
      let tok = parser.gullet.popToken();
      tok = parser.gullet.popToken();
      if (!/^[0-9]$/.test(tok.text)) {
        throw new ParseError(`Invalid number of arguments: "${tok.text}"`);
      }
      numArgs = parseInt(tok.text);
      tok = parser.gullet.popToken();
      if (tok.text !== "]") {
        throw new ParseError(`Invalid argument "${tok.text}"`);
      }
    }

    // replacement text, enclosed in '{' and '}' and properly nested
    const { tokens } = parser.gullet.consumeArg();

    if (!(funcName === "\\providecommand" && parser.gullet.macros.has(name))) {
      // Ignore \providecommand
      parser.gullet.macros.set(
        name,
        { tokens, numArgs }
      );
    }

    return { type: "internal", mode: parser.mode };

  }
});

// Extra data needed for the delimiter handler down below
const delimiterSizes = {
  "\\bigl": { mclass: "mopen", size: 1 },
  "\\Bigl": { mclass: "mopen", size: 2 },
  "\\biggl": { mclass: "mopen", size: 3 },
  "\\Biggl": { mclass: "mopen", size: 4 },
  "\\bigr": { mclass: "mclose", size: 1 },
  "\\Bigr": { mclass: "mclose", size: 2 },
  "\\biggr": { mclass: "mclose", size: 3 },
  "\\Biggr": { mclass: "mclose", size: 4 },
  "\\bigm": { mclass: "mrel", size: 1 },
  "\\Bigm": { mclass: "mrel", size: 2 },
  "\\biggm": { mclass: "mrel", size: 3 },
  "\\Biggm": { mclass: "mrel", size: 4 },
  "\\big": { mclass: "mord", size: 1 },
  "\\Big": { mclass: "mord", size: 2 },
  "\\bigg": { mclass: "mord", size: 3 },
  "\\Bigg": { mclass: "mord", size: 4 }
};

const delimiters = [
  "(",
  "\\lparen",
  ")",
  "\\rparen",
  "[",
  "\\lbrack",
  "]",
  "\\rbrack",
  "\\{",
  "\\lbrace",
  "\\}",
  "\\rbrace",
  "â¦‡",
  "\\llparenthesis",
  "â¦ˆ",
  "\\rrparenthesis",
  "\\lfloor",
  "\\rfloor",
  "\u230a",
  "\u230b",
  "\\lceil",
  "\\rceil",
  "\u2308",
  "\u2309",
  "<",
  ">",
  "\\langle",
  "\u27e8",
  "\\rangle",
  "\u27e9",
  "\\lAngle",
  "\u27ea",
  "\\rAngle",
  "\u27eb",
  "\\llangle",
  "â¦‰",
  "\\rrangle",
  "â¦Š",
  "\\lt",
  "\\gt",
  "\\lvert",
  "\\rvert",
  "\\lVert",
  "\\rVert",
  "\\lgroup",
  "\\rgroup",
  "\u27ee",
  "\u27ef",
  "\\lmoustache",
  "\\rmoustache",
  "\u23b0",
  "\u23b1",
  "\\llbracket",
  "\\rrbracket",
  "\u27e6",
  "\u27e6",
  "\\lBrace",
  "\\rBrace",
  "\u2983",
  "\u2984",
  "/",
  "\\backslash",
  "|",
  "\\vert",
  "\\|",
  "\\Vert",
  "\u2016",
  "\\uparrow",
  "\\Uparrow",
  "\\downarrow",
  "\\Downarrow",
  "\\updownarrow",
  "\\Updownarrow",
  "."
];

// Export isDelimiter for benefit of parser.
const dels = ["}", "\\left", "\\middle", "\\right"];
const isDelimiter = str => str.length > 0 &&
  (delimiters.includes(str) || delimiterSizes[str] || dels.includes(str));

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

// Delimiter functions
function checkDelimiter(delim, context) {
  const symDelim = checkSymbolNodeType(delim);
  if (symDelim && delimiters.includes(symDelim.text)) {
    // If a character is not in the MathML operator dictionary, it will not stretch.
    // Replace such characters w/characters that will stretch.
    if (["<", "\\lt"].includes(symDelim.text)) { symDelim.text = "âŸ¨"; }
    if ([">", "\\gt"].includes(symDelim.text)) { symDelim.text = "âŸ©"; }
    return symDelim;
  } else if (symDelim) {
    throw new ParseError(`Invalid delimiter '${symDelim.text}' after '${context.funcName}'`, delim);
  } else {
    throw new ParseError(`Invalid delimiter type '${delim.type}'`, delim);
  }
}

//                               /         \
const needExplicitStretch = ["\u002F", "\u005C", "\\backslash", "\\vert", "|"];

defineFunction({
  type: "delimsizing",
  names: [
    "\\bigl",
    "\\Bigl",
    "\\biggl",
    "\\Biggl",
    "\\bigr",
    "\\Bigr",
    "\\biggr",
    "\\Biggr",
    "\\bigm",
    "\\Bigm",
    "\\biggm",
    "\\Biggm",
    "\\big",
    "\\Big",
    "\\bigg",
    "\\Bigg"
  ],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  mathmlBuilder: (group) => {
    const children = [];

    if (group.delim === ".") { group.delim = ""; }
    children.push(makeText(group.delim, group.mode));

    const node = new mathMLTree.MathNode("mo", children);

    if (group.mclass === "mopen" || group.mclass === "mclose") {
      // Only some of the delimsizing functions act as fences, and they
      // return "mopen" or "mclose" mclass.
      node.setAttribute("fence", "true");
    } else {
      // Explicitly disable fencing if it's not a fence, to override the
      // defaults.
      node.setAttribute("fence", "false");
    }
    if (needExplicitStretch.includes(group.delim) || group.delim.indexOf("arrow") > -1) {
      // We have to explicitly set stretchy to true.
      node.setAttribute("stretchy", "true");
    }
    node.setAttribute("symmetric", "true"); // Needed for tall arrows in Firefox.
    node.setAttribute("minsize", sizeToMaxHeight[group.size] + "em");
    node.setAttribute("maxsize", sizeToMaxHeight[group.size] + "em");
    return node;
  }
});

function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}

defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text
    };
  }
});

defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    const parser = context.parser;
    // Parse out the implicit body
    ++parser.leftrightDepth;
    // parseExpression stops before '\\right' or `\\middle`
    let body = parser.parseExpression(false, null, true);
    let nextToken = parser.fetch();
    while (nextToken.text === "\\middle") {
      // `\middle`, from the Îµ-TeX package, ends one group and starts another group.
      // We had to parse this expression with `breakOnMiddle` enabled in order
      // to get TeX-compliant parsing of \over.
      // But we do not want, at this point, to end on \middle, so continue
      // to parse until we fetch a `\right`.
      parser.consume();
      const middle = parser.fetch().text;
      if (!symbols.math[middle]) {
        throw new ParseError(`Invalid delimiter '${middle}' after '\\middle'`);
      }
      checkDelimiter({ type: "atom", mode: "math", text: middle }, { funcName: "\\middle" });
      body.push({ type: "middle", mode: "math", delim: middle });
      parser.consume();
      body = body.concat(parser.parseExpression(false, null, true));
      nextToken = parser.fetch();
    }
    --parser.leftrightDepth;
    // Check the next token
    parser.expect("\\right", false);
    const right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim
    };
  },
  mathmlBuilder: (group, style) => {
    assertParsed(group);
    const inner = buildExpression(group.body, style);

    if (group.left === ".") { group.left = ""; }
    const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
    leftNode.setAttribute("fence", "true");
    leftNode.setAttribute("form", "prefix");
    if (group.left === "/" || group.left === "\u005C" || group.left.indexOf("arrow") > -1) {
      leftNode.setAttribute("stretchy", "true");
    }
    inner.unshift(leftNode);

    if (group.right === ".") { group.right = ""; }
    const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
    rightNode.setAttribute("fence", "true");
    rightNode.setAttribute("form", "postfix");
    if (group.right === "\u2216" || group.right.indexOf("arrow") > -1) {
      rightNode.setAttribute("stretchy", "true");
    }
    if (group.body.length > 0) {
      const lastElement = group.body[group.body.length - 1];
      if (lastElement.type === "color" && !lastElement.isTextColor) {
        // \color is a switch. If the last element is of type "color" then
        // the user set the \color switch and left it on.
        // A \right delimiter turns the switch off, but the delimiter itself gets the color.
        rightNode.setAttribute("mathcolor", lastElement.color);
      }
    }
    inner.push(rightNode);

    return makeRow(inner);
  }
});

defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  mathmlBuilder: (group, style) => {
    const textNode = makeText(group.delim, group.mode);
    const middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    if (group.delim.indexOf("arrow") > -1) {
      middleNode.setAttribute("stretchy", "true");
    }
    // The next line is not semantically correct, but
    // Chromium fails to stretch if it is not there.
    middleNode.setAttribute("form", "prefix");
    // MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});

const padding = _ => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", "3pt");
  return node
};

const mathmlBuilder$7 = (group, style) => {
  let node;
  if (group.label.indexOf("colorbox") > -1 || group.label === "\\boxed") {
    // MathML core does not support +width attribute in <mpadded>.
    // Firefox does not reliably add side padding.
    // Insert <mspace>
    node = new mathMLTree.MathNode("mrow", [
      padding(),
      buildGroup$1(group.body, style),
      padding()
    ]);
  } else {
    node = new mathMLTree.MathNode("menclose", [buildGroup$1(group.body, style)]);
  }
  switch (group.label) {
    case "\\overline":
      node.setAttribute("notation", "top"); // for Firefox & WebKit
      node.classes.push("tml-overline");    // for Chromium
      break
    case "\\underline":
      node.setAttribute("notation", "bottom");
      node.classes.push("tml-underline");
      break
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "upstrike"]));
      break
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "downstrike"]));
      break
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "sout"]));
      break
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      node.classes.push("tml-xcancel");
      break
    case "\\longdiv":
      node.setAttribute("notation", "longdiv");
      node.classes.push("longdiv-top");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["longdiv-arc"]));
      break
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      node.classes.push("phasor-bottom");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["phasor-angle"]));
      break
    case "\\textcircled":
      node.setAttribute("notation", "circle");
      node.classes.push("circle-pad");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["textcircle"]));
      break
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      node.classes.push("actuarial");
      break
    case "\\boxed":
      // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}} from amsmath.sty
      node.setAttribute("notation", "box");
      node.classes.push("tml-box");
      node.setAttribute("scriptlevel", "0");
      node.setAttribute("displaystyle", "true");
      break
    case "\\fbox":
      node.setAttribute("notation", "box");
      node.classes.push("tml-fbox");
      break
    case "\\fcolorbox":
    case "\\colorbox": {
      // <menclose> doesn't have a good notation option for \colorbox.
      // So use <mpadded> instead. Set some attributes that come
      // included with <menclose>.
      //const fboxsep = 3; // 3 pt from LaTeX source2e
      //node.setAttribute("height", `+${2 * fboxsep}pt`)
      //node.setAttribute("voffset", `${fboxsep}pt`)
      const style = { padding: "3pt 0 3pt 0" };

      if (group.label === "\\fcolorbox") {
        style.border = "0.0667em solid " + String(group.borderColor);
      }
      node.style = style;
      break
    }
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};

defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
    }
    const body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let borderColor = "";
    let backgroundColor;
    if (model) {
      const borderSpec = assertNodeType(args[0], "raw").string;
      const backgroundSpec = assertNodeType(args[0], "raw").string;
      borderColor = colorFromSpec(model, borderSpec);
      backgroundColor = colorFromSpec(model, backgroundSpec);
    } else {
      borderColor = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
      backgroundColor = validateColor(assertNodeType(args[1], "raw").string, parser.gullet.macros);
    }
    const body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});

defineFunction({
  type: "enclose",
  names: ["\\angl", "\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\overline",
    "\\boxed", "\\longdiv", "\\phase"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});


defineFunction({
  type: "enclose",
  names: ["\\textcircled"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

// Environment delimiters. HTML/MathML rendering is defined in the corresponding
// defineEnvironment definitions.
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler({ parser, funcName }, args) {
    const nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    let envName = "";
    for (let i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }

    if (funcName === "\\begin") {
      // begin...end is similar to left...right
      if (!Object.prototype.hasOwnProperty.call(environments, envName )) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      // Build the environment object. Arguments and other information will
      // be made available to the begin and end methods using properties.
      const env = environments[envName];
      const { args, optArgs } = parser.parseArguments("\\begin{" + envName + "}", env);
      const context = {
        mode: parser.mode,
        envName,
        parser
      };
      const result = env.handler(context, args, optArgs);
      parser.expect("\\end", false);
      const endNameToken = parser.nextToken;
      const end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError(
          `Mismatch: \\begin{${envName}} matched by \\end{${end.name}}`,
          endNameToken
        );
      }
      return result;
    }

    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});

defineFunction({
  type: "envTag",
  names: ["\\env@tag"],
  props: {
    numArgs: 1,
    argTypes: ["math"]
  },
  handler({ parser }, args) {
    return {
      type: "envTag",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

defineFunction({
  type: "noTag",
  names: ["\\env@notag"],
  props: {
    numArgs: 0
  },
  handler({ parser }) {
    return {
      type: "noTag",
      mode: parser.mode
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

const isLongVariableName = (group, font) => {
  if (font !== "mathrm" || group.body.type !== "ordgroup" || group.body.body.length === 1) {
    return false
  }
  if (group.body.body[0].type !== "mathord") { return false }
  for (let i = 1; i < group.body.body.length; i++) {
    const parseNodeType = group.body.body[i].type;
    if (!(parseNodeType ===  "mathord" ||
    (parseNodeType ===  "textord" && !isNaN(group.body.body[i].text)))) {
      return false
    }
  }
  return true
};

const mathmlBuilder$6 = (group, style) => {
  const font = group.font;
  const newStyle = style.withFont(font);
  const mathGroup = buildGroup$1(group.body, newStyle);

  if (mathGroup.children.length === 0) { return mathGroup } // empty group, e.g., \mathrm{}
  if (font === "boldsymbol" && ["mo", "mpadded", "mrow"].includes(mathGroup.type)) {
    mathGroup.style.fontWeight = "bold";
    return mathGroup
  }
  // Check if it is possible to consolidate elements into a single <mi> element.
  if (isLongVariableName(group, font)) {
    // This is a \mathrm{â€¦} group. It gets special treatment because symbolsOrd.js
    // wraps <mi> elements with <mrow>s to work around a Firefox bug.
    const mi = mathGroup.children[0].children[0];
    delete mi.attributes.mathvariant;
    for (let i = 1; i < mathGroup.children.length; i++) {
      mi.children[0].text += mathGroup.children[i].type === "mn"
        ? mathGroup.children[i].children[0].text
        : mathGroup.children[i].children[0].children[0].text;
    }
    // Wrap in a <mrow> to prevent the same Firefox bug.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  let canConsolidate = mathGroup.children[0].type === "mo";
  for (let i = 1; i < mathGroup.children.length; i++) {
    if (mathGroup.children[i].type === "mo" && font === "boldsymbol") {
      mathGroup.children[i].style.fontWeight = "bold";
    }
    if (mathGroup.children[i].type !== "mi") { canConsolidate = false; }
    const localVariant = mathGroup.children[i].attributes &&
      mathGroup.children[i].attributes.mathvariant || "";
    if (localVariant !== "normal") { canConsolidate = false; }
  }
  if (!canConsolidate) { return mathGroup }
  // Consolidate the <mi> elements.
  const mi = mathGroup.children[0];
  for (let i = 1; i < mathGroup.children.length; i++) {
    mi.children.push(mathGroup.children[i].children[0]);
  }
  if (mi.attributes.mathvariant && mi.attributes.mathvariant === "normal") {
    // Workaround for a Firefox bug that renders spurious space around
    // a <mi mathvariant="normal">
    // Ref: https://bugs.webkit.org/show_bug.cgi?id=129097
    // We insert a text node that contains a zero-width space and wrap in an mrow.
    // TODO: Get rid of this <mi> workaround when the Firefox bug is fixed.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  return mi
};

const fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};

defineFunction({
  type: "font",
  names: [
    // styles
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\up@greek",
    "\\boldsymbol",

    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathsfit",
    "\\mathtt",

    // aliases
    "\\Bbb",
    "\\bm",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = normalizeArgument(args[0]);
    let func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

// Old font changing functions
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ parser, funcName, breakOnTokenText }, args) => {
    const { mode } = parser;
    const body = parser.parseExpression(true, breakOnTokenText, true);
    const fontStyle = `math${funcName.slice(1)}`;

    return {
      type: "font",
      mode: mode,
      font: fontStyle,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

const stylArray = ["display", "text", "script", "scriptscript"];
const scriptLevel = { auto: -1, display: 0, text: 0, script: 1, scriptscript: 2 };

const mathmlBuilder$5 = (group, style) => {
  // Track the scriptLevel of the numerator and denominator.
  // We may need that info for \mathchoice or for adjusting em dimensions.
  const childOptions = group.scriptLevel === "auto"
    ? style.incrementLevel()
    : group.scriptLevel === "display"
    ? style.withLevel(StyleLevel.TEXT)
    : group.scriptLevel === "text"
    ? style.withLevel(StyleLevel.SCRIPT)
    : style.withLevel(StyleLevel.SCRIPTSCRIPT);

  // Chromium (wrongly) continues to shrink fractions beyond scriptscriptlevel.
  // So we check for levels that Chromium shrinks too small.
  // If necessary, set an explicit fraction depth.
  const numer = buildGroup$1(group.numer, childOptions);
  const denom = buildGroup$1(group.denom, childOptions);
  if (style.level === 3) {
    numer.style.mathDepth = "2";
    numer.setAttribute("scriptlevel", "2");
    denom.style.mathDepth = "2";
    denom.setAttribute("scriptlevel", "2");
  }

  let node = new mathMLTree.MathNode("mfrac", [numer, denom]);

  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    const ruleWidth = calculateSize(group.barSize, style);
    node.setAttribute("linethickness", ruleWidth.number + ruleWidth.unit);
  }

  if (group.leftDelim != null || group.rightDelim != null) {
    const withDelims = [];

    if (group.leftDelim != null) {
      const leftOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))
      ]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }

    withDelims.push(node);

    if (group.rightDelim != null) {
      const rightOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))
      ]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }

    node = makeRow(withDelims);
  }

  if (group.scriptLevel !== "auto") {
    node = new mathMLTree.MathNode("mstyle", [node]);
    node.setAttribute("displaystyle", String(group.scriptLevel === "display"));
    node.setAttribute("scriptlevel", scriptLevel[group.scriptLevel]);
  }

  return node;
};

defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac", // canâ€™t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac" // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];
    let hasBarLine = false;
    let leftDelim = null;
    let rightDelim = null;
    let scriptLevel = "auto";

    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }

    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        scriptLevel = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        scriptLevel = "text";
        break;
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      scriptLevel,
      barSize: null
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "display",
      barSize: null
    };
  }
});

// Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler({ parser, funcName, token }) {
    let replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});

const delimFromValue = function(delimString) {
  let delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};

defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler({ parser }, args) {
    const numer = args[4];
    const denom = args[5];

    // Look into the parse nodes to get the desired delimiters.
    const leftNode = normalizeArgument(args[0]);
    const leftDelim = leftNode.type === "atom" && leftNode.family === "open"
      ? delimFromValue(leftNode.text)
      : null;
    const rightNode = normalizeArgument(args[1]);
    const rightDelim =
      rightNode.type === "atom" && rightNode.family === "close"
        ? delimFromValue(rightNode.text)
        : null;

    const barNode = assertNodeType(args[2], "size");
    let hasBarLine;
    let barSize = null;
    if (barNode.isBlank) {
      // \genfrac acts differently than \above.
      // \genfrac treats an empty size group as a signal to use a
      // standard bar size. \above would see size = 0 and omit the bar.
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }

    // Find out if we want displaystyle, textstyle, etc.
    let scriptLevel = "auto";
    let styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        const textOrd = assertNodeType(styl.body[0], "textord");
        scriptLevel = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      scriptLevel = stylArray[Number(styl.text)];
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      scriptLevel
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

// \above is an infix fraction that also defines a fraction bar size.
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler({ parser, funcName, token }, args) {
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      barSize: assertNodeType(args[0], "size").value,
      token
    };
  }
});

defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const barSize = assert(assertNodeType(args[1], "infix").barSize);
    const denom = args[2];

    const hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "auto"
    };
  },

  mathmlBuilder: mathmlBuilder$5
});

// \hbox is provided for compatibility with LaTeX functions that act on a box.
// This function by itself doesn't do anything but set scriptlevel to \textstyle
// and prevent a soft line break.

defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInArgument: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = style.withLevel(StyleLevel.TEXT);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

const mathmlBuilder$4 = (group, style) => {
  const accentNode = stretchy.mathMLnode(group.label);
  accentNode.style["math-depth"] = 0;
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [
    buildGroup$1(group.base, style),
    accentNode
  ]);
};

// Horizontal stretchy braces
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  mathmlBuilder: mathmlBuilder$4
});

defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const body = args[1];
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\href",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\href" is not trusted`, token)
    }

    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const math = new MathNode("math", [buildExpressionRow(group.body, style)]);
    const anchorNode = new AnchorNode(group.href, [], [math]);
    return anchorNode
  }
});

defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\url",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\url" is not trusted`, token)
    }

    const chars = [];
    for (let i = 0; i < href.length; i++) {
      let c = href[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    const body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});

defineFunction({
  type: "html",
  names: ["\\class", "\\id", "\\style", "\\data"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    const value = assertNodeType(args[0], "raw").string;
    const body = args[1];

    if (parser.settings.strict) {
      throw new ParseError(`Function "${funcName}" is disabled in strict mode`, token)
    }

    let trustContext;
    const attributes = {};

    switch (funcName) {
      case "\\class":
        attributes.class = value;
        trustContext = {
          command: "\\class",
          class: value
        };
        break;
      case "\\id":
        attributes.id = value;
        trustContext = {
          command: "\\id",
          id: value
        };
        break;
      case "\\style":
        attributes.style = value;
        trustContext = {
          command: "\\style",
          style: value
        };
        break;
      case "\\data": {
        const data = value.split(",");
        for (let i = 0; i < data.length; i++) {
          const keyVal = data[i].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\data");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }

        trustContext = {
          command: "\\data",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }

    if (!parser.settings.isTrusted(trustContext)) {
      throw new ParseError(`Function "${funcName}" is not trusted`, token)
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const element =  buildExpressionRow(group.body, style);

    const classes = [];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    element.classes = classes;

    for (const attr in group.attributes) {
      if (attr !== "class" && Object.prototype.hasOwnProperty.call(group.attributes, attr)) {
        element.setAttribute(attr, group.attributes[attr]);
      }
    }

    return element;
  }
});

const sizeData = function(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    // str is a number with no unit specified.
    // default unit is bp, per graphix package.
    return { number: +str, unit: "bp" }
  } else {
    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data
  }
};

defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: ({ parser, token }, args, optArgs) => {
    let width = { number: 0, unit: "em" };
    let height = { number: 0.9, unit: "em" };  // sorta character sized.
    let totalheight = { number: 0, unit: "em" };
    let alt = "";

    if (optArgs[0]) {
      const attributeStr = assertNodeType(optArgs[0], "raw").string;

      // Parser.js does not parse key/value pairs. We get a string.
      const attributes = attributeStr.split(",");
      for (let i = 0; i < attributes.length; i++) {
        const keyVal = attributes[i].split("=");
        if (keyVal.length === 2) {
          const str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break
            case "width":
              width = sizeData(str);
              break
            case "height":
              height = sizeData(str);
              break
            case "totalheight":
              totalheight = sizeData(str);
              break
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.")
          }
        }
      }
    }

    const src = assertNodeType(args[0], "url").url;

    if (alt === "") {
      // No alt given. Use the file name. Strip away the path.
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }

    if (
      !parser.settings.isTrusted({
        command: "\\includegraphics",
        url: src
      })
    ) {
      throw new ParseError(`Function "\\includegraphics" is not trusted`, token)
    }

    return {
      type: "includegraphics",
      mode: parser.mode,
      alt: alt,
      width: width,
      height: height,
      totalheight: totalheight,
      src: src
    }
  },
  mathmlBuilder: (group, style) => {
    const height = calculateSize(group.height, style);
    const depth = { number: 0, unit: "em" };

    if (group.totalheight.number > 0) {
      if (group.totalheight.unit === height.unit &&
        group.totalheight.number > height.number) {
        depth.number = group.totalheight.number - height.number;
        depth.unit = height.unit;
      }
    }

    let width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, style);
    }

    const graphicStyle = { height: height.number + depth.number + "em" };
    if (width.number > 0) {
      graphicStyle.width = width.number + width.unit;
    }
    if (depth.number > 0) {
      graphicStyle.verticalAlign = -depth.number + depth.unit;
    }

    const node = new Img(group.src, group.alt, graphicStyle);
    node.height = height;
    node.depth = depth;
    return new mathMLTree.MathNode("mtext", [node])
  }
});

// Horizontal spacing commands


// TODO: \hskip and \mskip should support plus and minus in lengths

defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler({ parser, funcName, token }, args) {
    const size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      const mathFunction = funcName[1] === "m"; // \mkern, \mskip
      const muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          throw new ParseError(`LaTeX's ${funcName} supports only mu units, ` +
            `not ${size.value.unit} units`, token)
        }
        if (parser.mode !== "math") {
          throw new ParseError(`LaTeX's ${funcName} works only in math mode`, token)
        }
      } else {
        // !mathFunction
        if (muUnit) {
          throw new ParseError(`LaTeX's ${funcName} doesn't support mu units`, token)
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  mathmlBuilder(group, style) {
    const dimension = calculateSize(group.dimension, style);
    const ch = dimension.unit === "em" ? spaceCharacter(dimension.number) : "";
    if (group.mode === "text" && ch.length > 0) {
      const character = new mathMLTree.TextNode(ch);
      return new mathMLTree.MathNode("mtext", [character]);
    } else {
      const node = new mathMLTree.MathNode("mspace");
      node.setAttribute("width", dimension.number + dimension.unit);
      if (dimension.number < 0) {
        node.style.marginLeft = dimension.number + dimension.unit;
      }
      return node;
    }
  }
});

const spaceCharacter = function(width) {
  if (width >= 0.05555 && width <= 0.05556) {
    return "\u200a"; // &VeryThinSpace;
  } else if (width >= 0.1666 && width <= 0.1667) {
    return "\u2009"; // &ThinSpace;
  } else if (width >= 0.2222 && width <= 0.2223) {
    return "\u2005"; // &MediumSpace;
  } else if (width >= 0.2777 && width <= 0.2778) {
    return "\u2005\u200a"; // &ThickSpace;
  } else {
    return "";
  }
};

// Limit valid characters to a small set, for safety.
const invalidIdRegEx = /[^A-Za-z_0-9-]/g;

defineFunction({
  type: "label",
  names: ["\\label"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser }, args) {
    return {
      type: "label",
      mode: parser.mode,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Return a no-width, no-ink element with an HTML id.
    const node = new mathMLTree.MathNode("mrow", [], ["tml-label"]);
    if (group.string.length > 0) {
      node.setLabel(group.string);
    }
    return node
  }
});

// Horizontal overlap functions

const textModeLap = ["\\clap", "\\llap", "\\rlap"];

defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap", "\\clap", "\\llap", "\\rlap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    if (textModeLap.includes(funcName)) {
      if (parser.settings.strict && parser.mode !== "text") {
        throw new ParseError(`{${funcName}} can be used only in text mode.
 Try \\math${funcName.slice(1)}`, token)
      }
      funcName = funcName.slice(1);
    } else {
      funcName = funcName.slice(5);
    }
    const body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName,
      body
    }
  },
  mathmlBuilder: (group, style) => {
    // mathllap, mathrlap, mathclap
    let strut;
    if (group.alignment === "llap") {
      // We need an invisible strut with the same depth as the group.
      // We can't just read the depth, so we use \vphantom methods.
      const phantomInner = buildExpression(ordargument(group.body), style);
      const phantom = new mathMLTree.MathNode("mphantom", phantomInner);
      strut = new mathMLTree.MathNode("mpadded", [phantom]);
      strut.setAttribute("width", "0px");
    }

    const inner = buildGroup$1(group.body, style);
    let node;
    if (group.alignment === "llap") {
      inner.style.position = "absolute";
      inner.style.right = "0";
      inner.style.bottom = `0`; // If we could have read the ink depth, it would go here.
      node = new mathMLTree.MathNode("mpadded", [strut, inner]);
    } else {
      node = new mathMLTree.MathNode("mpadded", [inner]);
    }

    if (group.alignment === "rlap") {
      if (group.body.body.length > 0 && group.body.body[0].type === "genfrac") {
        // In Firefox, a <mpadded> squashes the 3/18em padding of a child \frac. Put it back.
        node.setAttribute("lspace", "0.16667em");
      }
    } else {
      const offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
      if (group.alignment === "llap") {
        node.style.position = "relative";
      } else {
        node.style.display = "flex";
        node.style.justifyContent = "center";
      }
    }
    node.setAttribute("width", "0px");
    return node
  }
});

// Switching from text mode back to math mode
defineFunction({
  type: "ordgroup",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler({ funcName, parser }, args) {
    const outerMode = parser.mode;
    parser.switchMode("math");
    const close = funcName === "\\(" ? "\\)" : "$";
    const body = parser.parseExpression(false, close);
    parser.expect(close);
    parser.switchMode(outerMode);
    return {
      type: "ordgroup",
      mode: parser.mode,
      body
    };
  }
});

// Check for extra closing math delimiters
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, token) {
    throw new ParseError(`Mismatched ${context.funcName}`, token);
  }
});

const chooseStyle = (group, style) => {
  switch (style.level) {
    case StyleLevel.DISPLAY:       // 0
      return group.display;
    case StyleLevel.TEXT:          // 1
      return group.text;
    case StyleLevel.SCRIPT:        // 2
      return group.script;
    case StyleLevel.SCRIPTSCRIPT:  // 3
      return group.scriptscript;
    default:
      return group.text;
  }
};

defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: ({ parser }, args) => {
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  mathmlBuilder: (group, style) => {
    const body = chooseStyle(group, style);
    return buildExpressionRow(body, style);
  }
});

const textAtomTypes = ["text", "textord", "mathord", "atom"];

function mathmlBuilder$3(group, style) {
  let node;
  const inner = buildExpression(group.body, style);

  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox || inner[0].type === "mathord") {
      node = inner[0];
      node.type = "mi";
      if (node.children.length === 1 && node.children[0].text && node.children[0].text === "âˆ‡") {
        node.setAttribute("mathvariant", "normal");
      }
    } else {
      node = new mathMLTree.MathNode("mi", inner);
    }
  } else {
    node = new mathMLTree.MathNode("mrow", inner);
    if (group.mustPromote) {
      node = inner[0];
      node.type = "mo";
      if (group.isCharacterBox && group.body[0].text && /[A-Za-z]/.test(group.body[0].text)) {
        node.setAttribute("mathvariant", "italic");
      }
    } else {
      node = new mathMLTree.MathNode("mrow", inner);
    }

    // Set spacing based on what is the most likely adjacent atom type.
    // See TeXbook p170.
    const doSpacing = style.level < 2; // Operator spacing is zero inside a (sub|super)script.
    if (node.type === "mrow") {
      if (doSpacing ) {
        if (group.mclass === "mbin") {
          // medium space
          node.children.unshift(padding$1(0.2222));
          node.children.push(padding$1(0.2222));
        } else if (group.mclass === "mrel") {
          // thickspace
          node.children.unshift(padding$1(0.2778));
          node.children.push(padding$1(0.2778));
        } else if (group.mclass === "mpunct") {
          node.children.push(padding$1(0.1667));
        } else if (group.mclass === "minner") {
          node.children.unshift(padding$1(0.0556));  // 1 mu is the most likely option
          node.children.push(padding$1(0.0556));
        }
      }
    } else {
      if (group.mclass === "mbin") {
        // medium space
        node.attributes.lspace = (doSpacing ? "0.2222em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2222em" : "0");
      } else if (group.mclass === "mrel") {
        // thickspace
        node.attributes.lspace = (doSpacing ? "0.2778em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2778em" : "0");
      } else if (group.mclass === "mpunct") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = (doSpacing ? "0.1667em" : "0");
      } else if (group.mclass === "mopen" || group.mclass === "mclose") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0em";
      } else if (group.mclass === "minner" && doSpacing) {
        node.attributes.lspace = "0.0556em"; // 1 mu is the most likely option
        node.attributes.width = "+0.1111em";
      }
    }

    if (!(group.mclass === "mopen" || group.mclass === "mclose")) {
      delete node.attributes.stretchy;
      delete node.attributes.form;
    }
  }
  return node;
}

// Math class commands except \mathop
defineFunction({
  type: "mclass",
  names: [
    "\\mathord",
    "\\mathbin",
    "\\mathrel",
    "\\mathopen",
    "\\mathclose",
    "\\mathpunct",
    "\\mathinner"
  ],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    const isCharacterBox = utils.isCharacterBox(body);
    // We should not wrap a <mo> around a <mi> or <mord>. That would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    let mustPromote = true;
    const mord = { type: "mathord", text: "", mode: parser.mode };
    const arr = (body.body) ? body.body : [body];
    for (const arg of arr) {
      if (textAtomTypes.includes(arg.type)) {
        if (symbols[parser.mode][arg.text]) {
          mord.text += symbols[parser.mode][arg.text].replace;
        } else if (arg.text) {
          mord.text += arg.text;
        } else if (arg.body) {
          arg.body.map(e => { mord.text += e.text; });
        }
      } else {
        mustPromote = false;
        break
      }
    }
    if (mustPromote && funcName === "\\mathord" && mord.type === "mathord"
                    && mord.text.length > 1) {
      return mord
    } else {
      return {
        type: "mclass",
        mode: parser.mode,
        mclass: "m" + funcName.slice(5),
        body: ordargument(mustPromote ? mord : body),
        isCharacterBox,
        mustPromote
      };
    }
  },
  mathmlBuilder: mathmlBuilder$3
});

const binrelClass = (arg) => {
  // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
  // (by rendering separately and with {}s before and after, and measuring
  // the change in spacing).  We'll do roughly the same by detecting the
  // atom type directly.
  const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};

// \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler({ parser }, args) {
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});

// Build a relation or stacked op by placing one symbol on top of another
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler({ parser, funcName }, args) {
    const baseArg = args[1];
    const shiftedArg = args[0];

    const baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      stack: true,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };

    return {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
  },
  mathmlBuilder: mathmlBuilder$3
});

// Helper function
const buildGroup = (el, style, noneNode) => {
  if (!el) { return noneNode }
  const node = buildGroup$1(el, style);
  if (node.type === "mrow" && node.children.length === 0) { return noneNode }
  return node
};

defineFunction({
  type: "multiscript",
  names: ["\\sideset", "\\pres@cript"], // See macros.js for \prescript
  props: {
    numArgs: 3
  },
  handler({ parser, funcName, token }, args) {
    if (args[2].body.length === 0) {
      throw new ParseError(funcName + `cannot parse an empty base.`)
    }
    const base = args[2].body[0];
    if (parser.settings.strict && funcName === "\\sideset" && !base.symbol) {
      throw new ParseError(`The base of \\sideset must be a big operator. Try \\prescript.`)
    }

    if ((args[0].body.length > 0 && args[0].body[0].type !== "supsub") ||
        (args[1].body.length > 0 && args[1].body[0].type !== "supsub")) {
      throw new ParseError("\\sideset can parse only subscripts and " +
                            "superscripts in its first two arguments", token)
    }

    // The prescripts and postscripts come wrapped in a supsub.
    const prescripts = args[0].body.length > 0 ? args[0].body[0] : null;
    const postscripts = args[1].body.length > 0 ? args[1].body[0] : null;

    if (!prescripts && !postscripts) {
      return base
    } else if (!prescripts) {
      // It's not a multi-script. Get a \textstyle supsub.
      return {
        type: "styling",
        mode: parser.mode,
        scriptLevel: "text",
        body: [{
          type: "supsub",
          mode: parser.mode,
          base,
          sup: postscripts.sup,
          sub: postscripts.sub
        }]
      }
    } else {
      return {
        type: "multiscript",
        mode: parser.mode,
        isSideset: funcName === "\\sideset",
        prescripts,
        postscripts,
        base
      }
    }
  },
  mathmlBuilder(group, style) {
    const base =  buildGroup$1(group.base, style);

    const prescriptsNode = new mathMLTree.MathNode("mprescripts");
    const noneNode = new mathMLTree.MathNode("none");
    let children = [];

    const preSub = buildGroup(group.prescripts.sub, style, noneNode);
    const preSup = buildGroup(group.prescripts.sup, style, noneNode);
    if (group.isSideset) {
      // This seems silly, but LaTeX does this. Firefox ignores it, which does not make me sad.
      preSub.setAttribute("style", "text-align: left;");
      preSup.setAttribute("style", "text-align: left;");
    }

    if (group.postscripts) {
      const postSub = buildGroup(group.postscripts.sub, style, noneNode);
      const postSup = buildGroup(group.postscripts.sup, style, noneNode);
      children = [base, postSub, postSup, prescriptsNode, preSub, preSup];
    } else {
      children = [base, prescriptsNode, preSub, preSup];
    }

    return new mathMLTree.MathNode("mmultiscripts", children);
  }
});

defineFunction({
  type: "not",
  names: ["\\not"],
  props: {
    numArgs: 1,
    primitive: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    const isCharacterBox = utils.isCharacterBox(args[0]);
    let body;
    if (isCharacterBox) {
      body = ordargument(args[0]);
      if (body[0].text.charAt(0) === "\\") {
        body[0].text = symbols.math[body[0].text].replace;
      }
      // \u0338 is the Unicode Combining Long Solidus Overlay
      body[0].text = body[0].text.slice(0, 1) + "\u0338" + body[0].text.slice(1);
    } else {
      // When the argument is not a character box, TeX does an awkward, poorly placed overlay.
      // We'll do the same.
      const notNode = { type: "textord", mode: "math", text: "\u0338" };
      const kernNode = { type: "kern", mode: "math", dimension: { number: -0.6, unit: "em" } };
      body = [notNode, kernNode, args[0]];
    }
    return {
      type: "not",
      mode: parser.mode,
      body,
      isCharacterBox
    };
  },
  mathmlBuilder(group, style) {
    if (group.isCharacterBox) {
      const inner = buildExpression(group.body, style, true);
      return inner[0]
    } else {
      return buildExpressionRow(group.body, style)
    }
  }
});

// Limits, symbols

// Some helpers

const ordAtomTypes = ["textord", "mathord", "atom"];

// Most operators have a large successor symbol, but these don't.
const noSuccessor = ["\\smallint"];

// Math operators (e.g. \sin) need a space between these types and themselves:
const ordTypes = ["textord", "mathord", "ordgroup", "close", "leftright", "font"];

// NOTE: Unlike most `builders`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.

const setSpacing = node => {
  // The user wrote a \mathop{â€¦} function. Change spacing from default to OP spacing.
  // The most likely spacing for an OP is a thin space per TeXbook p170.
  node.attributes.lspace = "0.1667em";
  node.attributes.rspace = "0.1667em";
};

const mathmlBuilder$2 = (group, style) => {
  let node;

  if (group.symbol) {
    // This is a symbol. Just add the symbol.
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (noSuccessor.includes(group.name)) {
      node.setAttribute("largeop", "false");
    } else {
      node.setAttribute("movablelimits", "false");
    }
    if (group.fromMathOp) { setSpacing(node); }
  } else if (group.body) {
    // This is an operator with children. Add them.
    node = new MathNode("mo", buildExpression(group.body, style));
    if (group.fromMathOp) { setSpacing(node); }
  } else {
    // This is a text operator. Add all of the characters from the operator's name.
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);

    if (!group.parentIsSupSub) {
      // Append an invisible <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new MathNode("mo", [makeText("\u2061", "text")]);
      const row = [node, operator];
      // Set spacing
      if (group.needsLeadingSpace) {
        const lead = new MathNode("mspace");
        lead.setAttribute("width", "0.1667em"); // thin space.
        row.unshift(lead);
      }
      if (!group.isFollowedByDelimiter) {
        const trail = new MathNode("mspace");
        trail.setAttribute("width", "0.1667em"); // thin space.
        row.push(trail);
      }
      node = new MathNode("mrow", row);
    }
  }

  return node;
};

const singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22c0": "\\bigwedge",
  "\u22c1": "\\bigvee",
  "\u22c2": "\\bigcap",
  "\u22c3": "\\bigcup",
  "\u2a00": "\\bigodot",
  "\u2a01": "\\bigoplus",
  "\u2a02": "\\bigotimes",
  "\u2a04": "\\biguplus",
  "\u2a05": "\\bigsqcap",
  "\u2a06": "\\bigsqcup",
  "\u2a03": "\\bigcupdot",
  "\u2a07": "\\bigdoublevee",
  "\u2a08": "\\bigdoublewedge",
  "\u2a09": "\\bigtimes"
};

defineFunction({
  type: "op",
  names: [
    "\\coprod",
    "\\bigvee",
    "\\bigwedge",
    "\\biguplus",
    "\\bigcupplus",
    "\\bigcupdot",
    "\\bigcap",
    "\\bigcup",
    "\\bigdoublevee",
    "\\bigdoublewedge",
    "\\intop",
    "\\prod",
    "\\sum",
    "\\bigotimes",
    "\\bigoplus",
    "\\bigodot",
    "\\bigsqcap",
    "\\bigsqcup",
    "\\bigtimes",
    "\\smallint",
    "\u220F",
    "\u2210",
    "\u2211",
    "\u22c0",
    "\u22c1",
    "\u22c2",
    "\u22c3",
    "\u2a00",
    "\u2a01",
    "\u2a02",
    "\u2a04",
    "\u2a06"
  ],
  props: {
    numArgs: 0
  },
  handler: ({ parser, funcName }, args) => {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      stack: false, // This is true for \stackrel{}, not here.
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Note: calling defineFunction with a type that's already been defined only
// works because the same mathmlBuilder is being used.
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    // It would be convienient to just wrap a <mo> around the argument.
    // But if the argument is a <mi> or <mord>, that would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    const arr = (body.body) ? body.body : [body];
    const isSymbol = arr.length === 1 && ordAtomTypes.includes(arr[0].type);
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: isSymbol,
      fromMathOp: true,
      stack: false,
      name: isSymbol ? arr[0].text : null,
      body: isSymbol ? null : ordargument(body)
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

const singleCharIntegrals = {
  "\u222b": "\\int",
  "\u222c": "\\iint",
  "\u222d": "\\iiint",
  "\u222e": "\\oint",
  "\u222f": "\\oiint",
  "\u2230": "\\oiiint",
  "\u2231": "\\intclockwise",
  "\u2232": "\\varointclockwise",
  "\u2a0c": "\\iiiint",
  "\u2a0d": "\\intbar",
  "\u2a0e": "\\intBar",
  "\u2a0f": "\\fint",
  "\u2a12": "\\rppolint",
  "\u2a13": "\\scpolint",
  "\u2a15": "\\pointint",
  "\u2a16": "\\sqint",
  "\u2a17": "\\intlarhk",
  "\u2a18": "\\intx",
  "\u2a19": "\\intcap",
  "\u2a1a": "\\intcup"
};

// No limits, not symbols
defineFunction({
  type: "op",
  names: [
    "\\arcsin",
    "\\arccos",
    "\\arctan",
    "\\arctg",
    "\\arcctg",
    "\\arg",
    "\\ch",
    "\\cos",
    "\\cosec",
    "\\cosh",
    "\\cot",
    "\\cotg",
    "\\coth",
    "\\csc",
    "\\ctg",
    "\\cth",
    "\\deg",
    "\\dim",
    "\\exp",
    "\\hom",
    "\\ker",
    "\\lg",
    "\\ln",
    "\\log",
    "\\sec",
    "\\sin",
    "\\sinh",
    "\\sh",
    "\\sgn",
    "\\tan",
    "\\tanh",
    "\\tg",
    "\\th"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Limits, not symbols
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// No limits, symbols
defineFunction({
  type: "op",
  names: [
    "\\int",
    "\\iint",
    "\\iiint",
    "\\iiiint",
    "\\oint",
    "\\oiint",
    "\\oiiint",
    "\\intclockwise",
    "\\varointclockwise",
    "\\intbar",
    "\\intBar",
    "\\fint",
    "\\rppolint",
    "\\scpolint",
    "\\pointint",
    "\\sqint",
    "\\intlarhk",
    "\\intx",
    "\\intcap",
    "\\intcup",
    "\u222b",
    "\u222c",
    "\u222d",
    "\u222e",
    "\u222f",
    "\u2230",
    "\u2231",
    "\u2232",
    "\u2a0c",
    "\u2a0d",
    "\u2a0e",
    "\u2a0f",
    "\u2a12",
    "\u2a13",
    "\u2a15",
    "\u2a16",
    "\u2a17",
    "\u2a18",
    "\u2a19",
    "\u2a1a"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      stack: false,
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// NOTE: Unlike most builders, this one handles not only
// "operatorname", but also  "supsub" since \operatorname* can
// affect super/subscripting.

const mathmlBuilder$1 = (group, style) => {
  let expression = buildExpression(group.body, style.withFont("mathrm"));

  // Is expression a string or has it something like a fraction?
  let isAllString = true; // default
  for (let i = 0; i < expression.length; i++) {
    let node = expression[i];
    if (node instanceof mathMLTree.MathNode) {
      if ((node.type === "mrow" || node.type === "mpadded") && node.children.length === 1 &&
          node.children[0] instanceof mathMLTree.MathNode) {
        node = node.children[0];
      }
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mtext":
          break; // Do nothing yet.
        case "mspace":
          {
            if (node.attributes.width) {
              const width = node.attributes.width.replace("em", "");
              const ch = spaceCharacter(Number(width));
              if (ch === "") {
                isAllString = false;
              } else {
                expression[i] = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(ch)]);
              }
            }
          }
          break
        case "mo": {
          const child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }

  if (isAllString) {
    // Write a single TextNode instead of multiple nested tags.
    const word = expression.map((node) => node.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  } else if (
    expression.length === 1
    && ["mover", "munder"].includes(expression[0].type) &&
    (expression[0].children[0].type === "mi" || expression[0].children[0].type === "mtext")
  ) {
    expression[0].children[0].type = "mi";
    if (group.parentIsSupSub) {
      return new mathMLTree.MathNode("mrow", expression)
    } else {
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      return mathMLTree.newDocumentFragment([expression[0], operator])
    }
  }

  let wrapper;
  if (isAllString) {
    wrapper = new mathMLTree.MathNode("mi", expression);
    if (expression[0].text.length === 1) {
      wrapper.setAttribute("mathvariant", "normal");
    }
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }

  if (!group.parentIsSupSub) {
    // Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
    const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
    const fragment = [wrapper, operator];
    if (group.needsLeadingSpace) {
      // LaTeX gives operator spacing, but a <mi> gets ord spacing.
      // So add a leading space.
      const space = new mathMLTree.MathNode("mspace");
      space.setAttribute("width", "0.1667em"); // thin space.
      fragment.unshift(space);
    }
    if (!group.isFollowedByDelimiter) {
      const trail = new mathMLTree.MathNode("mspace");
      trail.setAttribute("width", "0.1667em"); // thin space.
      fragment.push(trail);
    }
    return mathMLTree.newDocumentFragment(fragment)
  }

  return wrapper
};

// \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = args[0];
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: (funcName === "\\operatornamewithlimits"),
      limits: false,
      parentIsSupSub: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType)
    };
  },
  mathmlBuilder: mathmlBuilder$1
});

defineMacro("\\operatorname",
  "\\@ifstar\\operatornamewithlimits\\operatorname@");

defineFunctionBuilders({
  type: "ordgroup",
  mathmlBuilder(group, style) {
    return buildExpressionRow(group.body, style, group.semisimple);
  }
});

defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(group.body, style);
    return new mathMLTree.MathNode("mphantom", inner);
  }
});

defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});

defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});

// In LaTeX, \pmb is a simulation of bold font.
// The version of \pmb in ambsy.sty works by typesetting three copies of the argument
// with small offsets. We use CSS font-weight:bold.

defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "pmb",
      mode: parser.mode,
      body: ordargument(args[0])
    }
  },
  mathmlBuilder(group, style) {
    const inner = buildExpression(group.body, style);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    node.setAttribute("style", "font-weight:bold");
    return node
  }
});

// \raise, \lower, and \raisebox

const mathmlBuilder = (group, style) => {
  const newStyle = style.withLevel(StyleLevel.TEXT);
  const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, newStyle)]);
  const dy = calculateSize(group.dy, style);
  node.setAttribute("voffset", dy.number + dy.unit);
  // Add padding, which acts to increase height in Chromium.
  // TODO: Figure out some way to change height in Firefox w/o breaking Chromium.
  if (dy.number > 0) {
    node.style.padding = dy.number + dy.unit + " 0 0 0";
  } else {
    node.style.padding = "0 0 " + Math.abs(dy.number) + dy.unit + " 0";
  }
  return node
};

defineFunction({
  type: "raise",
  names: ["\\raise", "\\lower"],
  props: {
    numArgs: 2,
    argTypes: ["size", "primitive"],
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    if (funcName === "\\lower") { amount.number *= -1; }
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});


defineFunction({
  type: "raise",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});

defineFunction({
  type: "ref",
  names: ["\\ref", "\\eqref"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser, funcName }, args) {
    return {
      type: "ref",
      mode: parser.mode,
      funcName,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Create an empty <a> node. Set a class and an href attribute.
    // The post-processor will populate with the target's tag or equation number.
    const classes = group.funcName === "\\ref" ? ["tml-ref"] : ["tml-ref", "tml-eqref"];
    return new AnchorNode("#" + group.string, classes, null)
  }
});

defineFunction({
  type: "reflect",
  names: ["\\reflectbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "reflect",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    const node = buildGroup$1(group.body, style);
    node.style.transform = "scaleX(-1)";
    return node
  }
});

defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser }) {
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});

defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["size", "size", "size"]
  },
  handler({ parser }, args, optArgs) {
    const shift = optArgs[0];
    const width = assertNodeType(args[0], "size");
    const height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  mathmlBuilder(group, style) {
    const width = calculateSize(group.width, style);
    const height = calculateSize(group.height, style);
    const shift = group.shift
      ? calculateSize(group.shift, style)
      : { number: 0, unit: "em" };
    const color = (style.color && style.getColor()) || "black";

    const rule = new mathMLTree.MathNode("mspace");
    if (width.number > 0 && height.number > 0) {
      rule.setAttribute("mathbackground", color);
    }
    rule.setAttribute("width", width.number + width.unit);
    rule.setAttribute("height", height.number + height.unit);
    if (shift.number === 0) { return rule }

    const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift.number >= 0) {
      wrapper.setAttribute("height", "+" + shift.number + shift.unit);
    } else {
      wrapper.setAttribute("height", shift.number + shift.unit);
      wrapper.setAttribute("depth", "+" + -shift.number + shift.unit);
    }
    wrapper.setAttribute("voffset", shift.number + shift.unit);
    return wrapper;
  }
});

// The size mappings are taken from TeX with \normalsize=10pt.
// We don't have to track script level. MathML does that.
const sizeMap = {
  "\\tiny": 0.5,
  "\\sixptsize": 0.6,
  "\\Tiny": 0.6,
  "\\scriptsize": 0.7,
  "\\footnotesize": 0.8,
  "\\small": 0.9,
  "\\normalsize": 1.0,
  "\\large": 1.2,
  "\\Large": 1.44,
  "\\LARGE": 1.728,
  "\\huge": 2.074,
  "\\Huge": 2.488
};

defineFunction({
  type: "sizing",
  names: [
    "\\tiny",
    "\\sixptsize",
    "\\Tiny",
    "\\scriptsize",
    "\\footnotesize",
    "\\small",
    "\\normalsize",
    "\\large",
    "\\Large",
    "\\LARGE",
    "\\huge",
    "\\Huge"
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ breakOnTokenText, funcName, parser }, args) => {
    if (parser.settings.strict && parser.mode === "math") {
      // eslint-disable-next-line no-console
      console.log(`Temml strict-mode warning: Command ${funcName} is invalid in math mode.`);
    }
    const body = parser.parseExpression(false, breakOnTokenText, true);
    return {
      type: "sizing",
      mode: parser.mode,
      funcName,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const newStyle = style.withFontSize(sizeMap[group.funcName]);
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    const factor = (sizeMap[group.funcName] / style.fontSize).toFixed(4);
    node.setAttribute("mathsize", factor + "em");
    return node;
  }
});

// smash, with optional [tb], as in AMS

defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args, optArgs) => {
    let smashHeight = false;
    let smashDepth = false;
    const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      // Optional [tb] argument is engaged.
      // ref: amsmath: \renewcommand{\smash}[1][tb]{%
      //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
      let letter = "";
      for (let i = 0; i < tbArg.body.length; ++i) {
        const node = tbArg.body[i];
        // TODO: Write an AssertSymbolNode
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }

    const body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  mathmlBuilder: (group, style) => {
    const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, style)]);

    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }

    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }

    return node;
  }
});

defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser }, args, optArgs) {
    const index = optArgs[0];
    const body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  mathmlBuilder(group, style) {
    const { body, index } = group;
    return index
      ? new mathMLTree.MathNode("mroot", [
        buildGroup$1(body, style),
        buildGroup$1(index, style.incrementLevel())
      ])
    : new mathMLTree.MathNode("msqrt", [buildGroup$1(body, style)]);
  }
});

const styleMap = {
  display: 0,
  text: 1,
  script: 2,
  scriptscript: 3
};

const styleAttributes = {
  display: ["0", "true"],
  text: ["0", "false"],
  script: ["1", "false"],
  scriptscript: ["2", "false"]
};

defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ breakOnTokenText, funcName, parser }, args) {
    // parse out the implicit body
    const body = parser.parseExpression(true, breakOnTokenText, true);

    const scriptLevel = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what scriptLevel to use by pulling out the scriptLevel from
      // the function name
      scriptLevel,
      body
    };
  },
  mathmlBuilder(group, style) {
    // Figure out what scriptLevel we're changing to.
    const newStyle = style.withLevel(styleMap[group.scriptLevel]);
    // The style argument in the next line does NOT directly set a MathML script level.
    // It just tracks the style level, in case we need to know it for supsub or mathchoice.
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);

    const attr = styleAttributes[group.scriptLevel];

    // Here is where we set the MathML script level.
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
  }
});

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */

// Helpers
const symbolRegEx = /^m(over|under|underover)$/;

// Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.
defineFunctionBuilders({
  type: "supsub",
  mathmlBuilder(group, style) {
    // Is the inner group a relevant horizontal brace?
    let isBrace = false;
    let isOver;
    let isSup;
    let appendApplyFunction = false;
    let appendSpace = false;
    let needsLeadingSpace = false;

    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }

    if (group.base && !group.base.stack &&
      (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
      appendApplyFunction = !group.base.symbol;
      appendSpace = appendApplyFunction && !group.isFollowedByDelimiter;
      needsLeadingSpace = group.base.needsLeadingSpace;
    }

    const children = group.base && group.base.stack
      ? [buildGroup$1(group.base.body[0], style)]
      : [buildGroup$1(group.base, style)];

    // Note regarding scriptstyle level.
    // (Sub|super)scripts should not shrink beyond MathML scriptlevel 2 aka \scriptscriptstyle
    // Ref: https://w3c.github.io/mathml-core/#the-displaystyle-and-scriptlevel-attributes
    // (BTW, MathML scriptlevel 2 is equal to Temml level 3.)
    // But Chromium continues to shrink the (sub|super)scripts. So we explicitly set scriptlevel 2.

    const childStyle = style.inSubOrSup();
    if (group.sub) {
      const sub = buildGroup$1(group.sub, childStyle);
      if (style.level === 3) { sub.setAttribute("scriptlevel", "2"); }
      children.push(sub);
    }

    if (group.sup) {
      const sup = buildGroup$1(group.sup, childStyle);
      if (style.level === 3) { sup.setAttribute("scriptlevel", "2"); }
      const testNode = sup.type === "mrow" ? sup.children[0] : sup;
      if ((testNode && testNode.type === "mo" && testNode.classes.includes("tml-prime"))
        && group.base && group.base.text && "fF".indexOf(group.base.text) > -1) {
        // Chromium does not address italic correction on prime.  Prevent fâ€² from overlapping.
        testNode.classes.push("prime-pad");
      }
      children.push(sup);
    }

    let nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "mover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munder";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      const base = group.base;
      if (base && ((base.type === "op" && base.limits) || base.type === "multiscript") &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munderover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (style.level === StyleLevel.DISPLAY || base.limits)
      ) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }

    let node = new mathMLTree.MathNode(nodeType, children);
    if (appendApplyFunction) {
      // Append an <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      if (needsLeadingSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node = mathMLTree.newDocumentFragment([space, node, operator]);
      } else {
        node = mathMLTree.newDocumentFragment([node, operator]);
      }
      if (appendSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node.children.push(space);
      }
    } else if (symbolRegEx.test(nodeType)) {
      // Wrap in a <mrow>. Otherwise Firefox stretchy parens will not stretch to include limits.
      node = new mathMLTree.MathNode("mrow", [node]);
    }

    return node
  }
});

// Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.

const short = ["\\shortmid", "\\nshortmid", "\\shortparallel",
  "\\nshortparallel", "\\smallsetminus"];

const arrows = ["\\Rsh", "\\Lsh", "\\restriction"];

const isArrow = str => {
  if (str.length === 1) {
    const codePoint = str.codePointAt(0);
    return (0x218f < codePoint && codePoint < 0x2200)
  }
  return str.indexOf("arrow") > -1 || str.indexOf("harpoon") > -1 || arrows.includes(str)
};

defineFunctionBuilders({
  type: "atom",
  mathmlBuilder(group, style) {
    const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      // Delims built here should not stretch vertically.
      // See delimsizing.js for stretchy delims.
      if (group.family === "open") {
        node.setAttribute("form", "prefix");
        // Set an explicit attribute for stretch. Otherwise Firefox may do it wrong.
        node.setAttribute("stretchy", "false");
      } else if (group.family === "close") {
        node.setAttribute("form", "postfix");
        node.setAttribute("stretchy", "false");
      }
    } else if (group.text === "\\mid") {
      // Firefox messes up this spacing if at the end of an <mrow>. See it explicitly.
      node.setAttribute("lspace", "0.22em"); // medium space
      node.setAttribute("rspace", "0.22em");
      node.setAttribute("stretchy", "false");
    } else if (group.family === "rel" && isArrow(group.text)) {
      node.setAttribute("stretchy", "false");
    } else if (short.includes(group.text)) {
      node.setAttribute("mathsize", "70%");
    } else if (group.text === ":") {
      // ":" is not in the MathML operator dictionary. Give it BIN spacing.
      node.attributes.lspace = "0.2222em";
      node.attributes.rspace = "0.2222em";
    } else if (group.needsSpacing) {
      // Fix a MathML bug that occurs when a <mo> is between two <mtext> elements.
      if (group.family === "bin") {
        return new mathMLTree.MathNode("mrow", [padding$1(0.222), node, padding$1(0.222)])
      } else {
        // REL spacing
        return new mathMLTree.MathNode("mrow", [padding$1(0.2778), node, padding$1(0.2778)])
      }
    }
    return node;
  }
});

/**
 * Maps TeX font commands to "mathvariant" attribute in buildMathML.js
 */
const fontMap = {
  // styles
  mathbf: "bold",
  mathrm: "normal",
  textit: "italic",
  mathit: "italic",
  mathnormal: "italic",

  // families
  mathbb: "double-struck",
  mathcal: "script",
  mathfrak: "fraktur",
  mathscr: "script",
  mathsf: "sans-serif",
  mathtt: "monospace"
};

/**
 * Returns the math variant as a string or null if none is required.
 */
const getVariant = function(group, style) {
  // Handle font specifiers as best we can.
  // Chromium does not support the MathML mathvariant attribute.
  // So we'll use Unicode replacement characters instead.
  // But first, determine the math variant.

  // Deal with the \textit, \textbf, etc., functions.
  if (style.fontFamily === "texttt") {
    return "monospace"
  } else if (style.fontFamily === "textsc") {
    return "normal"; // handled via character substitution in symbolsOrd.js.
  } else if (style.fontFamily === "textsf") {
    if (style.fontShape === "textit" && style.fontWeight === "textbf") {
      return "sans-serif-bold-italic"
    } else if (style.fontShape === "textit") {
      return "sans-serif-italic"
    } else if (style.fontWeight === "textbf") {
      return "sans-serif-bold"
    } else {
      return "sans-serif"
    }
  } else if (style.fontShape === "textit" && style.fontWeight === "textbf") {
    return "bold-italic"
  } else if (style.fontShape === "textit") {
    return "italic"
  } else if (style.fontWeight === "textbf") {
    return "bold"
  }

  // Deal with the \mathit, mathbf, etc, functions.
  const font = style.font;
  if (!font || font === "mathnormal") {
    return null
  }

  const mode = group.mode;
  switch (font) {
    case "mathit":
      return "italic"
    case "mathrm": {
      const codePoint = group.text.codePointAt(0);
      // LaTeX \mathrm returns italic for Greek characters.
      return  (0x03ab < codePoint && codePoint < 0x03cf) ? "italic" : "normal"
    }
    case "greekItalic":
      return "italic"
    case "up@greek":
      return "normal"
    case "boldsymbol":
    case "mathboldsymbol":
      return "bold-italic"
    case "mathbf":
      return "bold"
    case "mathbb":
      return "double-struck"
    case "mathfrak":
      return "fraktur"
    case "mathscr":
    case "mathcal":
      return "script"
    case "mathsf":
      return "sans-serif"
    case "mathsfit":
      return "sans-serif-italic"
    case "mathtt":
      return "monospace"
  }

  let text = group.text;
  if (symbols[mode][text] && symbols[mode][text].replace) {
    text = symbols[mode][text].replace;
  }

  return Object.prototype.hasOwnProperty.call(fontMap, font) ? fontMap[font] : null
};

// Chromium does not support the MathML `mathvariant` attribute.
// Instead, we replace ASCII characters with Unicode characters that
// are defined in the font as bold, italic, double-struck, etc.
// This module identifies those Unicode code points.

// First, a few helpers.
const script = Object.freeze({
  B: 0x20EA, // Offset from ASCII B to Unicode script B
  E: 0x20EB,
  F: 0x20EB,
  H: 0x20C3,
  I: 0x20C7,
  L: 0x20C6,
  M: 0x20E6,
  R: 0x20C9,
  e: 0x20CA,
  g: 0x20A3,
  o: 0x20C5
});

const frak = Object.freeze({
  C: 0x20EA,
  H: 0x20C4,
  I: 0x20C8,
  R: 0x20CA,
  Z: 0x20CE
});

const bbb = Object.freeze({
  C: 0x20BF, // blackboard bold
  H: 0x20C5,
  N: 0x20C7,
  P: 0x20C9,
  Q: 0x20C9,
  R: 0x20CB,
  Z: 0x20CA
});

const bold = Object.freeze({
  "\u03f5": 0x1D2E7, // lunate epsilon
  "\u03d1": 0x1D30C, // vartheta
  "\u03f0": 0x1D2EE, // varkappa
  "\u03c6": 0x1D319, // varphi
  "\u03f1": 0x1D2EF, // varrho
  "\u03d6": 0x1D30B  // varpi
});

const boldItalic = Object.freeze({
  "\u03f5": 0x1D35B, // lunate epsilon
  "\u03d1": 0x1D380, // vartheta
  "\u03f0": 0x1D362, // varkappa
  "\u03c6": 0x1D38D, // varphi
  "\u03f1": 0x1D363, // varrho
  "\u03d6": 0x1D37F  // varpi
});

const boldsf = Object.freeze({
  "\u03f5": 0x1D395, // lunate epsilon
  "\u03d1": 0x1D3BA, // vartheta
  "\u03f0": 0x1D39C, // varkappa
  "\u03c6": 0x1D3C7, // varphi
  "\u03f1": 0x1D39D, // varrho
  "\u03d6": 0x1D3B9  // varpi
});

const bisf = Object.freeze({
  "\u03f5": 0x1D3CF, // lunate epsilon
  "\u03d1": 0x1D3F4, // vartheta
  "\u03f0": 0x1D3D6, // varkappa
  "\u03c6": 0x1D401, // varphi
  "\u03f1": 0x1D3D7, // varrho
  "\u03d6": 0x1D3F3  // varpi
});

// Code point offsets below are derived from https://www.unicode.org/charts/PDF/U1D400.pdf
const offset = Object.freeze({
  upperCaseLatin: { // A-Z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3BF },
    "italic": ch =>                 { return 0x1D3F3 },
    "bold-italic": ch =>            { return 0x1D427 },
    "script": ch =>                 { return script[ch] || 0x1D45B },
    "script-bold": ch =>            { return 0x1D48F },
    "fraktur": ch =>                { return frak[ch] || 0x1D4C3 },
    "fraktur-bold": ch =>           { return 0x1D52B },
    "double-struck": ch =>          { return bbb[ch] || 0x1D4F7 },
    "sans-serif": ch =>             { return 0x1D55F },
    "sans-serif-bold": ch =>        { return 0x1D593 },
    "sans-serif-italic": ch =>      { return 0x1D5C7 },
    "sans-serif-bold-italic": ch => { return 0x1D63C },
    "monospace": ch =>              { return 0x1D62F }
  },
  lowerCaseLatin: { // a-z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3B9 },
    "italic": ch =>                 { return ch === "h" ? 0x20A6 : 0x1D3ED },
    "bold-italic": ch =>            { return 0x1D421 },
    "script": ch =>                 { return script[ch] || 0x1D455 },
    "script-bold": ch =>            { return 0x1D489 },
    "fraktur": ch =>                { return 0x1D4BD },
    "fraktur-bold": ch =>           { return 0x1D525 },
    "double-struck": ch =>          { return 0x1D4F1 },
    "sans-serif": ch =>             { return 0x1D559 },
    "sans-serif-bold": ch =>        { return 0x1D58D },
    "sans-serif-italic": ch =>      { return 0x1D5C1 },
    "sans-serif-bold-italic": ch => { return 0x1D5F5 },
    "monospace": ch =>              { return 0x1D629 }
  },
  upperCaseGreek: { // A-Î©
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D317 },
    "italic": ch =>                 { return 0x1D351 },
    // \boldsymbol actually returns upright bold for upperCaseGreek
    "bold-italic": ch =>            { return 0x1D317 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3C5 },
    "sans-serif-bold": ch =>        { return 0x1D3C5 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3FF },
    "monospace": ch =>              { return 0 }
  },
  lowerCaseGreek: { // Î±-Ï‰
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D311 },
    "italic": ch =>                 { return 0x1D34B },
    "bold-italic": ch =>            { return ch === "\u03d5" ? 0x1D37E : 0x1D385 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3BF },
    "sans-serif-bold": ch =>        { return 0x1D3BF },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3F9 },
    "monospace": ch =>              { return 0 }
  },
  varGreek: { // \varGamma, etc
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return  bold[ch] || -51 },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return boldItalic[ch] || 0x3A },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    "sans-serif": ch =>             { return boldsf[ch] || 0x74 },
    "sans-serif-bold": ch =>        { return boldsf[ch] || 0x74 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return bisf[ch] || 0xAE },
    "monospace": ch =>              { return 0 }
  },
  numeral: { // 0-9
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D79E },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return 0 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0x1D7A8 },
    "sans-serif": ch =>             { return 0x1D7B2 },
    "sans-serif-bold": ch =>        { return 0x1D7BC },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0 },
    "monospace": ch =>              { return 0x1D7C6 }
  }
});

const variantChar = (ch, variant) => {
  const codePoint = ch.codePointAt(0);
  const block = 0x40 < codePoint && codePoint < 0x5b
    ? "upperCaseLatin"
    : 0x60 < codePoint && codePoint < 0x7b
    ? "lowerCaseLatin"
    : (0x390  < codePoint && codePoint < 0x3AA)
    ? "upperCaseGreek"
    : 0x3B0 < codePoint && codePoint < 0x3CA || ch === "\u03d5"
    ? "lowerCaseGreek"
    : 0x1D6E1 < codePoint && codePoint < 0x1D6FC  || bold[ch]
    ? "varGreek"
    : (0x2F < codePoint && codePoint <  0x3A)
    ? "numeral"
    : "other";
  return block === "other"
    ? ch
    : String.fromCodePoint(codePoint + offset[block][variant](ch))
};

const smallCaps = Object.freeze({
  a: "á´€",
  b: "Ê™",
  c: "á´„",
  d: "á´…",
  e: "á´‡",
  f: "êœ°",
  g: "É¢",
  h: "Êœ",
  i: "Éª",
  j: "á´Š",
  k: "á´‹",
  l: "ÊŸ",
  m: "á´",
  n: "É´",
  o: "á´",
  p: "á´˜",
  q: "Ç«",
  r: "Ê€",
  s: "s",
  t: "á´›",
  u: "á´œ",
  v: "á´ ",
  w: "á´¡",
  x: "x",
  y: "Ê",
  z: "á´¢"
});

// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
// src/symbols.js.

const numberRegEx = /^\d(?:[\d,.]*\d)?$/;
const latinRegEx = /[A-Ba-z]/;
const primes = new Set(["\\prime", "\\dprime", "\\trprime", "\\qprime",
  "\\backprime", "\\backdprime", "\\backtrprime"]);

const italicNumber = (text, variant, tag) => {
  const mn = new mathMLTree.MathNode(tag, [text]);
  const wrapper = new mathMLTree.MathNode("mstyle", [mn]);
  wrapper.style["font-style"] = "italic";
  wrapper.style["font-family"] = "Cambria, 'Times New Roman', serif";
  if (variant === "bold-italic") { wrapper.style["font-weight"] = "bold"; }
  return wrapper
};

defineFunctionBuilders({
  type: "mathord",
  mathmlBuilder(group, style) {
    const text = makeText(group.text, group.mode, style);
    const codePoint = text.text.codePointAt(0);
    // Test for upper-case Greek
    const defaultVariant = (0x0390 < codePoint && codePoint < 0x03aa) ? "normal" : "italic";
    const variant = getVariant(group, style) || defaultVariant;
    if (variant === "script") {
      text.text = variantChar(text.text, variant);
      return new mathMLTree.MathNode("mi", [text], [style.font])
    } else if (variant !== "italic") {
      text.text = variantChar(text.text, variant);
    }
    let node = new mathMLTree.MathNode("mi", [text]);
    // TODO: Handle U+1D49C - U+1D4CF per https://www.unicode.org/charts/PDF/U1D400.pdf
    if (variant === "normal") {
      node.setAttribute("mathvariant", "normal");
      if (text.text.length === 1) {
        // A Firefox bug will apply spacing here, but there should be none. Fix it.
        node = new mathMLTree.MathNode("mpadded", [node]);
        node.setAttribute("lspace", "0");
        node.setAttribute("rspace", "0");
      }
    }
    return node
  }
});

defineFunctionBuilders({
  type: "textord",
  mathmlBuilder(group, style) {
    let ch = group.text;
    const codePoint = ch.codePointAt(0);
    if (style.fontFamily === "textsc") {
      // Convert small latin letters to small caps.
      if (96 < codePoint && codePoint < 123) {
        ch = smallCaps[ch];
      }
    }
    const text = makeText(ch, group.mode, style);
    const variant = getVariant(group, style) || "normal";

    let node;
    if (numberRegEx.test(group.text)) {
      const tag = group.mode === "text" ? "mtext" : "mn";
      if (variant === "italic" || variant === "bold-italic") {
        return italicNumber(text, variant, tag)
      } else {
        if (variant !== "normal") {
          text.text = text.text.split("").map(c => variantChar(c, variant)).join("");
        }
        node = new mathMLTree.MathNode(tag, [text]);
      }
    } else if (group.mode === "text") {
      if (variant !== "normal") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mtext", [text]);
    } else if (primes.has(group.text)) {
      node = new mathMLTree.MathNode("mo", [text]);
      // TODO: If/when Chromium uses ssty variant for prime, remove the next line.
      node.classes.push("tml-prime");
    } else {
      const origText = text.text;
      if (variant !== "italic") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mi", [text]);
      if (text.text === origText && latinRegEx.test(origText)) {
        node.setAttribute("mathvariant", "italic");
      }
    }
    return node
  }
});

// A map of CSS-based spacing functions to their CSS class.
const cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};

// A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.
const regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};

// ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.
defineFunctionBuilders({
  type: "spacing",
  mathmlBuilder(group, style) {
    let node;

    if (Object.prototype.hasOwnProperty.call(regularSpace, group.text)) {
      // Firefox does not render a space in a <mtext> </mtext>. So write a no-break space.
      // TODO: If Firefox fixes that bug, uncomment the next line and write ch into the node.
      //const ch = (regularSpace[group.text].className === "nobreak") ? "\u00a0" : " "
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else if (Object.prototype.hasOwnProperty.call(cssSpace, group.text)) {
      // MathML 3.0 calls for nobreak to occur in an <mo>, not an <mtext>
      // Ref: https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs
      node = new mathMLTree.MathNode("mo");
      if (group.text === "\\nobreak") {
        node.setAttribute("linebreak", "nobreak");
      }
    } else {
      throw new ParseError(`Unknown type of space "${group.text}"`)
    }

    return node
  }
});

defineFunctionBuilders({
  type: "tag"
});

// For a \tag, the work usually done in a mathmlBuilder is instead done in buildMathML.js.
// That way, a \tag can be pulled out of the parse tree and wrapped around the outer node.

// Non-mathy text, possibly in a font
const textFontFamilies = {
  "\\text": undefined,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm",
  "\\textsc": "textsc"      // small caps
};

const textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};

const textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};

const styleWithFont = (group, style) => {
  const font = group.font;
  // Checks if the argument is a font family or a font style.
  if (!font) {
    return style;
  } else if (textFontFamilies[font]) {
    return style.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return style.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return style.fontShape === "textit"
      ? style.withTextFontShape("textup")
      : style.withTextFontShape("textit")
  }
  return style.withTextFontShape(textFontShapes[font])
};

defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    "\\textsc",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = styleWithFont(group, style);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

// \vcenter:  Vertically center the argument group on the math axis.

defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    // Use a math table to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.body, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    return new mathMLTree.MathNode("mtable", [mtr])
  }
});

defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    // \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  mathmlBuilder(group, style) {
    const text = new mathMLTree.TextNode(makeVerb(group));
    const node = new mathMLTree.MathNode("mtext", [text]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});

/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */
const makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");

/** Include this to ensure that all functions are defined. */

const functions = _functions;

/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */


/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first two groups
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - mathches numerals
 * - matches a backslash followed by one or more whitespace characters
 * - matches a backslash followed by one or more letters then whitespace
 * - matches a backslash followed by any BMP character
 * Capturing groups:
 *   [1] regular whitespace
 *   [2] backslash followed by whitespace
 *   [3] anything else, which may include:
 *     [4] left character of \verb*
 *     [5] left character of \verb
 *     [6] backslash followed by word, excluding any trailing whitespace
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
const spaceRegexString = "[ \r\n\t]";
const controlWordRegexString = "\\\\[a-zA-Z@]+";
const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
const controlWordWhitespaceRegexString = `(${controlWordRegexString})${spaceRegexString}*`;
const controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
const combiningDiacriticalMarkString = "[\u0300-\u036f]";
const combiningDiacriticalMarksEndRegex = new RegExp(`${combiningDiacriticalMarkString}+$`);
const tokenRegexString =
  `(${spaceRegexString}+)|` + // whitespace
  `${controlSpaceRegexString}|` +  // whitespace
  "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|\\\\verb\\*([^]).*?\\4" + // \verb*
  "|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
  `|${controlWordWhitespaceRegexString}` + // \macroName + spaces
  `|${controlSymbolRegexString})`; // \\, \', etc.

/** Main Lexer class */
class Lexer {
  constructor(input, settings) {
    // Separate accents from characters
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, 'g');
    // Category codes. The lexer only supports comment characters (14) for now.
    // MacroExpander additionally distinguishes active (13).
    this.catcodes = {
      "%": 14, // comment character
      "~": 13  // active character
    };
  }

  setCatcode(char, code) {
    this.catcodes[char] = code;
  }

  /**
   * This function lexes a single token.
   */
  lex() {
    const input = this.input;
    const pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    const match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError(
        `Unexpected character: '${input[pos]}'`,
        new Token(input[pos], new SourceLocation(this, pos, pos + 1))
      );
    }
    const text = match[6] || match[3] || (match[2] ? "\\ " : " ");

    if (this.catcodes[text] === 14) {
      // comment character
      const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length; // EOF
        if (this.settings.strict) {
          throw new ParseError("% comment has no terminating newline; LaTeX would " +
              "fail because of commenting the end of math mode")
        }
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }

    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}

/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */


class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins = {}, globalMacros = {}) {
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }

  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }

  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError(
        "Unbalanced namespace destruction: attempt " +
          "to pop global namespace; please report this as a bug"
      );
    }
    const undefs = this.undefStack.pop();
    for (const undef in undefs) {
      if (Object.prototype.hasOwnProperty.call(undefs, undef )) {
        if (undefs[undef] === undefined) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }

  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.current, name ) ||
    Object.prototype.hasOwnProperty.call(this.builtins, name );
  }

  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (Object.prototype.hasOwnProperty.call(this.current, name )) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }

  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   */
  set(name, value, global = false) {
    if (global) {
      // Global set is equivalent to setting in all groups.  Simulate this
      // by destroying any undos currently scheduled for this name,
      // and adding an undo with the *new* value (in case it later gets
      // locally reset within this environment).
      for (let i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      // Undo this set at end of this group (possibly to `undefined`),
      // unless an undo is already in place, in which case that older
      // value is the correct one.
      const top = this.undefStack[this.undefStack.length - 1];
      if (top && !Object.prototype.hasOwnProperty.call(top, name )) {
        top[name] = this.current[name];
      }
    }
    this.current[name] = value;
  }
}

/**
 * This file contains the â€œgulletâ€ where macros are expanded
 * until only non-macro tokens remain.
 */


// List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
const implicitCommands = {
  "^": true, // Parser.js
  _: true, // Parser.js
  "\\limits": true, // Parser.js
  "\\nolimits": true // Parser.js
};

class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    // Make new global namespace
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = []; // contains tokens in REVERSE order
  }

  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }

  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }

  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }

  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1]
  }

  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future(); // ensure non-empty stack
    return this.stack.pop();
  }

  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }

  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }

  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    let start;
    let end;
    let tokens;
    if (isOptional) {
      this.consumeSpaces(); // \@ifnextchar gobbles any space following it
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken(); // don't include [ in tokens
      ({ tokens, end } = this.consumeArg(["]"]));
    } else {
      ({ tokens, start, end } = this.consumeArg());
    }

    // indicate the end of an argument
    this.pushToken(new Token("EOF", end.loc));

    this.pushTokens(tokens);
    return start.range(end, "");
  }

  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (;;) {
      const token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }

  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    // The argument for a delimited parameter is the shortest (possibly
    // empty) sequence of tokens with properly nested {...} groups that is
    // followed ... by this particular list of non-parameter tokens.
    // The argument for an undelimited parameter is the next nonblank
    // token, unless that token is â€˜{â€™, when the argument will be the
    // entire {...} group that follows.
    const tokens = [];
    const isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      // Ignore spaces between arguments.  As the TeXbook says:
      // "After you have said â€˜\def\row#1#2{...}â€™, you are allowed to
      //  put spaces between the arguments (e.g., â€˜\row x nâ€™), because
      //  TeX doesnâ€™t use single spaces as undelimited arguments."
      this.consumeSpaces();
    }
    const start = this.future();
    let tok;
    let depth = 0;
    let match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError(
          "Unexpected end of input in a macro argument" +
            ", expected '" +
            (delims && isDelimited ? delims[match] : "}") +
            "'",
          tok
        );
      }
      if (delims && isDelimited) {
        if ((depth === 0 || (depth === 1 && delims[match] === "{")) && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            // don't include delims in tokens
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    // If the argument found ... has the form â€˜{<nested tokens>}â€™,
    // ... the outermost braces enclosing the argument are removed
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse(); // to fit in with stack order
    return { tokens, start, end: tok };
  }

  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters) {
    if (delimiters) {
      if (delimiters.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      const delims = delimiters[0];
      for (let i = 0; i < delims.length; i++) {
        const tok = this.popToken();
        if (delims[i] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }

    const args = [];
    for (let i = 0; i < numArgs; i++) {
      args.push(this.consumeArg(delimiters && delimiters[i + 1]).tokens);
    }
    return args;
  }

  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    const topToken = this.popToken();
    const name = topToken.text;
    const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || (expandableOnly && expansion.unexpandable)) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.expansionCount++;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError(
        "Too many expansions: infinite loop or " + "need to increase maxExpand setting"
      );
    }
    let tokens = expansion.tokens;
    const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      // paste arguments in place of the placeholders
      tokens = tokens.slice(); // make a shallow copy
      for (let i = tokens.length - 1; i >= 0; --i) {
        let tok = tokens[i];
        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i]; // next token on stack
          if (tok.text === "#") {
            // ## â†’ #
            tokens.splice(i + 1, 1); // drop first #
          } else if (/^[1-9]$/.test(tok.text)) {
            // replace the placeholder with the indicated argument
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    // Concatenate expansion onto top of stack.
    this.pushTokens(tokens);
    return tokens.length;
  }

  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }

  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (;;) {
      if (this.expandOnce() === false) { // fully expanded
        const token = this.stack.pop();
        // The token after \noexpand is interpreted as if its meaning were â€˜\relaxâ€™
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token
      }
    }

    // This pathway is impossible.
    throw new Error(); // eslint-disable-line no-unreachable
  }

  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
  }

  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    const output = [];
    const oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      // Expand only expandable tokens
      if (this.expandOnce(true) === false) {  // fully expanded
        const token = this.stack.pop();
        if (token.treatAsRelax) {
          // the expansion of \noexpand is the token itself
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    return output;
  }

  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    const tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }

  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    const definition = this.macros.get(name);
    if (definition == null) {
      // mainly checking for undefined here
      return definition;
    }
    // If a single character has an associated catcode other than 13
    // (active character), then don't expand it.
    if (name.length === 1) {
      const catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return
      }
    }
    const expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      let numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        const stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      const bodyLexer = new Lexer(expansion, this.settings);
      const tokens = [];
      let tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse(); // to fit in with stack using push and pop
      const expanded = { tokens, numArgs };
      return expanded;
    }

    return expansion;
  }

  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return (
      this.macros.has(name) ||
      Object.prototype.hasOwnProperty.call(functions, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.math, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.text, name ) ||
      Object.prototype.hasOwnProperty.call(implicitCommands, name )
    );
  }

  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    const macro = this.macros.get(name);
    return macro != null
      ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable
      : Object.prototype.hasOwnProperty.call(functions, name ) && !functions[name].primitive;
  }
}

// Helpers for Parser.js handling of Unicode (sub|super)script characters.

const unicodeSubRegEx = /^[â‚Šâ‚‹â‚Œâ‚â‚â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰â‚â‚‘â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šáµ£â‚›â‚œáµ¤áµ¥â‚“áµ¦áµ§áµ¨áµ©áµª]/;

const uSubsAndSups = Object.freeze({
  'â‚Š': '+',
  'â‚‹': '-',
  'â‚Œ': '=',
  'â‚': '(',
  'â‚': ')',
  'â‚€': '0',
  'â‚': '1',
  'â‚‚': '2',
  'â‚ƒ': '3',
  'â‚„': '4',
  'â‚…': '5',
  'â‚†': '6',
  'â‚‡': '7',
  'â‚ˆ': '8',
  'â‚‰': '9',
  '\u2090': 'a',
  '\u2091': 'e',
  '\u2095': 'h',
  '\u1D62': 'i',
  '\u2C7C': 'j',
  '\u2096': 'k',
  '\u2097': 'l',
  '\u2098': 'm',
  '\u2099': 'n',
  '\u2092': 'o',
  '\u209A': 'p',
  '\u1D63': 'r',
  '\u209B': 's',
  '\u209C': 't',
  '\u1D64': 'u',
  '\u1D65': 'v',
  '\u2093': 'x',
  '\u1D66': 'Î²',
  '\u1D67': 'Î³',
  '\u1D68': 'Ï',
  '\u1D69': '\u03d5',
  '\u1D6A': 'Ï‡',
  'âº': '+',
  'â»': '-',
  'â¼': '=',
  'â½': '(',
  'â¾': ')',
  'â°': '0',
  'Â¹': '1',
  'Â²': '2',
  'Â³': '3',
  'â´': '4',
  'âµ': '5',
  'â¶': '6',
  'â·': '7',
  'â¸': '8',
  'â¹': '9',
  '\u1D2C': 'A',
  '\u1D2E': 'B',
  '\u1D30': 'D',
  '\u1D31': 'E',
  '\u1D33': 'G',
  '\u1D34': 'H',
  '\u1D35': 'I',
  '\u1D36': 'J',
  '\u1D37': 'K',
  '\u1D38': 'L',
  '\u1D39': 'M',
  '\u1D3A': 'N',
  '\u1D3C': 'O',
  '\u1D3E': 'P',
  '\u1D3F': 'R',
  '\u1D40': 'T',
  '\u1D41': 'U',
  '\u2C7D': 'V',
  '\u1D42': 'W',
  '\u1D43': 'a',
  '\u1D47': 'b',
  '\u1D9C': 'c',
  '\u1D48': 'd',
  '\u1D49': 'e',
  '\u1DA0': 'f',
  '\u1D4D': 'g',
  '\u02B0': 'h',
  '\u2071': 'i',
  '\u02B2': 'j',
  '\u1D4F': 'k',
  '\u02E1': 'l',
  '\u1D50': 'm',
  '\u207F': 'n',
  '\u1D52': 'o',
  '\u1D56': 'p',
  '\u02B3': 'r',
  '\u02E2': 's',
  '\u1D57': 't',
  '\u1D58': 'u',
  '\u1D5B': 'v',
  '\u02B7': 'w',
  '\u02E3': 'x',
  '\u02B8': 'y',
  '\u1DBB': 'z',
  '\u1D5D': 'Î²',
  '\u1D5E': 'Î³',
  '\u1D5F': 'Î´',
  '\u1D60': '\u03d5',
  '\u1D61': 'Ï‡',
  '\u1DBF': 'Î¸'
});

// Used for Unicode input of calligraphic and script letters
const asciiFromScript = Object.freeze({
  "\ud835\udc9c": "A",
  "\u212c": "B",
  "\ud835\udc9e": "C",
  "\ud835\udc9f": "D",
  "\u2130": "E",
  "\u2131": "F",
  "\ud835\udca2": "G",
  "\u210B": "H",
  "\u2110": "I",
  "\ud835\udca5": "J",
  "\ud835\udca6": "K",
  "\u2112": "L",
  "\u2133": "M",
  "\ud835\udca9": "N",
  "\ud835\udcaa": "O",
  "\ud835\udcab": "P",
  "\ud835\udcac": "Q",
  "\u211B": "R",
  "\ud835\udcae": "S",
  "\ud835\udcaf": "T",
  "\ud835\udcb0": "U",
  "\ud835\udcb1": "V",
  "\ud835\udcb2": "W",
  "\ud835\udcb3": "X",
  "\ud835\udcb4": "Y",
  "\ud835\udcb5": "Z"
});

// Mapping of Unicode accent characters to their LaTeX equivalent in text and
// math mode (when they exist).
var unicodeAccents = {
  "\u0301": { text: "\\'", math: "\\acute" },
  "\u0300": { text: "\\`", math: "\\grave" },
  "\u0308": { text: '\\"', math: "\\ddot" },
  "\u0303": { text: "\\~", math: "\\tilde" },
  "\u0304": { text: "\\=", math: "\\bar" },
  "\u0306": { text: "\\u", math: "\\breve" },
  "\u030c": { text: "\\v", math: "\\check" },
  "\u0302": { text: "\\^", math: "\\hat" },
  "\u0307": { text: "\\.", math: "\\dot" },
  "\u030a": { text: "\\r", math: "\\mathring" },
  "\u030b": { text: "\\H" },
  '\u0327': { text: '\\c' }
};

var unicodeSymbols = {
  "Ã¡": "aÌ",
  "Ã ": "aÌ€",
  "Ã¤": "aÌˆ",
  "ÇŸ": "aÌˆÌ„",
  "Ã£": "aÌƒ",
  "Ä": "aÌ„",
  "Äƒ": "aÌ†",
  "áº¯": "aÌ†Ì",
  "áº±": "aÌ†Ì€",
  "áºµ": "aÌ†Ìƒ",
  "Ç": "aÌŒ",
  "Ã¢": "aÌ‚",
  "áº¥": "aÌ‚Ì",
  "áº§": "aÌ‚Ì€",
  "áº«": "aÌ‚Ìƒ",
  "È§": "aÌ‡",
  "Ç¡": "aÌ‡Ì„",
  "Ã¥": "aÌŠ",
  "Ç»": "aÌŠÌ",
  "á¸ƒ": "bÌ‡",
  "Ä‡": "cÌ",
  "Ä": "cÌŒ",
  "Ä‰": "cÌ‚",
  "Ä‹": "cÌ‡",
  "Ä": "dÌŒ",
  "á¸‹": "dÌ‡",
  "Ã©": "eÌ",
  "Ã¨": "eÌ€",
  "Ã«": "eÌˆ",
  "áº½": "eÌƒ",
  "Ä“": "eÌ„",
  "á¸—": "eÌ„Ì",
  "á¸•": "eÌ„Ì€",
  "Ä•": "eÌ†",
  "Ä›": "eÌŒ",
  "Ãª": "eÌ‚",
  "áº¿": "eÌ‚Ì",
  "á»": "eÌ‚Ì€",
  "á»…": "eÌ‚Ìƒ",
  "Ä—": "eÌ‡",
  "á¸Ÿ": "fÌ‡",
  "Çµ": "gÌ",
  "á¸¡": "gÌ„",
  "ÄŸ": "gÌ†",
  "Ç§": "gÌŒ",
  "Ä": "gÌ‚",
  "Ä¡": "gÌ‡",
  "á¸§": "hÌˆ",
  "ÈŸ": "hÌŒ",
  "Ä¥": "hÌ‚",
  "á¸£": "hÌ‡",
  "Ã­": "iÌ",
  "Ã¬": "iÌ€",
  "Ã¯": "iÌˆ",
  "á¸¯": "iÌˆÌ",
  "Ä©": "iÌƒ",
  "Ä«": "iÌ„",
  "Ä­": "iÌ†",
  "Ç": "iÌŒ",
  "Ã®": "iÌ‚",
  "Ç°": "jÌŒ",
  "Äµ": "jÌ‚",
  "á¸±": "kÌ",
  "Ç©": "kÌŒ",
  "Äº": "lÌ",
  "Ä¾": "lÌŒ",
  "á¸¿": "mÌ",
  "á¹": "mÌ‡",
  "Å„": "nÌ",
  "Ç¹": "nÌ€",
  "Ã±": "nÌƒ",
  "Åˆ": "nÌŒ",
  "á¹…": "nÌ‡",
  "Ã³": "oÌ",
  "Ã²": "oÌ€",
  "Ã¶": "oÌˆ",
  "È«": "oÌˆÌ„",
  "Ãµ": "oÌƒ",
  "á¹": "oÌƒÌ",
  "á¹": "oÌƒÌˆ",
  "È­": "oÌƒÌ„",
  "Å": "oÌ„",
  "á¹“": "oÌ„Ì",
  "á¹‘": "oÌ„Ì€",
  "Å": "oÌ†",
  "Ç’": "oÌŒ",
  "Ã´": "oÌ‚",
  "á»‘": "oÌ‚Ì",
  "á»“": "oÌ‚Ì€",
  "á»—": "oÌ‚Ìƒ",
  "È¯": "oÌ‡",
  "È±": "oÌ‡Ì„",
  "Å‘": "oÌ‹",
  "á¹•": "pÌ",
  "á¹—": "pÌ‡",
  "Å•": "rÌ",
  "Å™": "rÌŒ",
  "á¹™": "rÌ‡",
  "Å›": "sÌ",
  "á¹¥": "sÌÌ‡",
  "Å¡": "sÌŒ",
  "á¹§": "sÌŒÌ‡",
  "Å": "sÌ‚",
  "á¹¡": "sÌ‡",
  "áº—": "tÌˆ",
  "Å¥": "tÌŒ",
  "á¹«": "tÌ‡",
  "Ãº": "uÌ",
  "Ã¹": "uÌ€",
  "Ã¼": "uÌˆ",
  "Ç˜": "uÌˆÌ",
  "Çœ": "uÌˆÌ€",
  "Ç–": "uÌˆÌ„",
  "Çš": "uÌˆÌŒ",
  "Å©": "uÌƒ",
  "á¹¹": "uÌƒÌ",
  "Å«": "uÌ„",
  "á¹»": "uÌ„Ìˆ",
  "Å­": "uÌ†",
  "Ç”": "uÌŒ",
  "Ã»": "uÌ‚",
  "Å¯": "uÌŠ",
  "Å±": "uÌ‹",
  "á¹½": "vÌƒ",
  "áºƒ": "wÌ",
  "áº": "wÌ€",
  "áº…": "wÌˆ",
  "Åµ": "wÌ‚",
  "áº‡": "wÌ‡",
  "áº˜": "wÌŠ",
  "áº": "xÌˆ",
  "áº‹": "xÌ‡",
  "Ã½": "yÌ",
  "á»³": "yÌ€",
  "Ã¿": "yÌˆ",
  "á»¹": "yÌƒ",
  "È³": "yÌ„",
  "Å·": "yÌ‚",
  "áº": "yÌ‡",
  "áº™": "yÌŠ",
  "Åº": "zÌ",
  "Å¾": "zÌŒ",
  "áº‘": "zÌ‚",
  "Å¼": "zÌ‡",
  "Ã": "AÌ",
  "Ã€": "AÌ€",
  "Ã„": "AÌˆ",
  "Ç": "AÌˆÌ„",
  "Ãƒ": "AÌƒ",
  "Ä€": "AÌ„",
  "Ä‚": "AÌ†",
  "áº®": "AÌ†Ì",
  "áº°": "AÌ†Ì€",
  "áº´": "AÌ†Ìƒ",
  "Ç": "AÌŒ",
  "Ã‚": "AÌ‚",
  "áº¤": "AÌ‚Ì",
  "áº¦": "AÌ‚Ì€",
  "áºª": "AÌ‚Ìƒ",
  "È¦": "AÌ‡",
  "Ç ": "AÌ‡Ì„",
  "Ã…": "AÌŠ",
  "Çº": "AÌŠÌ",
  "á¸‚": "BÌ‡",
  "Ä†": "CÌ",
  "ÄŒ": "CÌŒ",
  "Äˆ": "CÌ‚",
  "ÄŠ": "CÌ‡",
  "Ä": "DÌŒ",
  "á¸Š": "DÌ‡",
  "Ã‰": "EÌ",
  "Ãˆ": "EÌ€",
  "Ã‹": "EÌˆ",
  "áº¼": "EÌƒ",
  "Ä’": "EÌ„",
  "á¸–": "EÌ„Ì",
  "á¸”": "EÌ„Ì€",
  "Ä”": "EÌ†",
  "Äš": "EÌŒ",
  "ÃŠ": "EÌ‚",
  "áº¾": "EÌ‚Ì",
  "á»€": "EÌ‚Ì€",
  "á»„": "EÌ‚Ìƒ",
  "Ä–": "EÌ‡",
  "á¸": "FÌ‡",
  "Ç´": "GÌ",
  "á¸ ": "GÌ„",
  "Ä": "GÌ†",
  "Ç¦": "GÌŒ",
  "Äœ": "GÌ‚",
  "Ä ": "GÌ‡",
  "á¸¦": "HÌˆ",
  "È": "HÌŒ",
  "Ä¤": "HÌ‚",
  "á¸¢": "HÌ‡",
  "Ã": "IÌ",
  "ÃŒ": "IÌ€",
  "Ã": "IÌˆ",
  "á¸®": "IÌˆÌ",
  "Ä¨": "IÌƒ",
  "Äª": "IÌ„",
  "Ä¬": "IÌ†",
  "Ç": "IÌŒ",
  "Ã": "IÌ‚",
  "Ä°": "IÌ‡",
  "Ä´": "JÌ‚",
  "á¸°": "KÌ",
  "Ç¨": "KÌŒ",
  "Ä¹": "LÌ",
  "Ä½": "LÌŒ",
  "á¸¾": "MÌ",
  "á¹€": "MÌ‡",
  "Åƒ": "NÌ",
  "Ç¸": "NÌ€",
  "Ã‘": "NÌƒ",
  "Å‡": "NÌŒ",
  "á¹„": "NÌ‡",
  "Ã“": "OÌ",
  "Ã’": "OÌ€",
  "Ã–": "OÌˆ",
  "Èª": "OÌˆÌ„",
  "Ã•": "OÌƒ",
  "á¹Œ": "OÌƒÌ",
  "á¹": "OÌƒÌˆ",
  "È¬": "OÌƒÌ„",
  "ÅŒ": "OÌ„",
  "á¹’": "OÌ„Ì",
  "á¹": "OÌ„Ì€",
  "Å": "OÌ†",
  "Ç‘": "OÌŒ",
  "Ã”": "OÌ‚",
  "á»": "OÌ‚Ì",
  "á»’": "OÌ‚Ì€",
  "á»–": "OÌ‚Ìƒ",
  "È®": "OÌ‡",
  "È°": "OÌ‡Ì„",
  "Å": "OÌ‹",
  "á¹”": "PÌ",
  "á¹–": "PÌ‡",
  "Å”": "RÌ",
  "Å˜": "RÌŒ",
  "á¹˜": "RÌ‡",
  "Åš": "SÌ",
  "á¹¤": "SÌÌ‡",
  "Å ": "SÌŒ",
  "á¹¦": "SÌŒÌ‡",
  "Åœ": "SÌ‚",
  "á¹ ": "SÌ‡",
  "Å¤": "TÌŒ",
  "á¹ª": "TÌ‡",
  "Ãš": "UÌ",
  "Ã™": "UÌ€",
  "Ãœ": "UÌˆ",
  "Ç—": "UÌˆÌ",
  "Ç›": "UÌˆÌ€",
  "Ç•": "UÌˆÌ„",
  "Ç™": "UÌˆÌŒ",
  "Å¨": "UÌƒ",
  "á¹¸": "UÌƒÌ",
  "Åª": "UÌ„",
  "á¹º": "UÌ„Ìˆ",
  "Å¬": "UÌ†",
  "Ç“": "UÌŒ",
  "Ã›": "UÌ‚",
  "Å®": "UÌŠ",
  "Å°": "UÌ‹",
  "á¹¼": "VÌƒ",
  "áº‚": "WÌ",
  "áº€": "WÌ€",
  "áº„": "WÌˆ",
  "Å´": "WÌ‚",
  "áº†": "WÌ‡",
  "áºŒ": "XÌˆ",
  "áºŠ": "XÌ‡",
  "Ã": "YÌ",
  "á»²": "YÌ€",
  "Å¸": "YÌˆ",
  "á»¸": "YÌƒ",
  "È²": "YÌ„",
  "Å¶": "YÌ‚",
  "áº": "YÌ‡",
  "Å¹": "ZÌ",
  "Å½": "ZÌŒ",
  "áº": "ZÌ‚",
  "Å»": "ZÌ‡",
  "Î¬": "Î±Ì",
  "á½°": "Î±Ì€",
  "á¾±": "Î±Ì„",
  "á¾°": "Î±Ì†",
  "Î­": "ÎµÌ",
  "á½²": "ÎµÌ€",
  "Î®": "Î·Ì",
  "á½´": "Î·Ì€",
  "Î¯": "Î¹Ì",
  "á½¶": "Î¹Ì€",
  "ÏŠ": "Î¹Ìˆ",
  "Î": "Î¹ÌˆÌ",
  "á¿’": "Î¹ÌˆÌ€",
  "á¿‘": "Î¹Ì„",
  "á¿": "Î¹Ì†",
  "ÏŒ": "Î¿Ì",
  "á½¸": "Î¿Ì€",
  "Ï": "Ï…Ì",
  "á½º": "Ï…Ì€",
  "Ï‹": "Ï…Ìˆ",
  "Î°": "Ï…ÌˆÌ",
  "á¿¢": "Ï…ÌˆÌ€",
  "á¿¡": "Ï…Ì„",
  "á¿ ": "Ï…Ì†",
  "Ï": "Ï‰Ì",
  "á½¼": "Ï‰Ì€",
  "Î": "Î¥Ì",
  "á¿ª": "Î¥Ì€",
  "Î«": "Î¥Ìˆ",
  "á¿©": "Î¥Ì„",
  "á¿¨": "Î¥Ì†",
  "Î": "Î©Ì",
  "á¿º": "Î©Ì€"
};

/* eslint no-constant-condition:0 */

const binLeftCancellers = ["bin", "op", "open", "punct", "rel"];
const sizeRegEx = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const textRegEx = /^ *\\text/;

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */

class Parser {
  constructor(input, settings, isPreamble = false) {
    // Start in math mode
    this.mode = "math";
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings, this.mode);
    // Store the settings for use in parsing
    this.settings = settings;
    // Are we defining a preamble?
    this.isPreamble = isPreamble;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
    this.prevAtomType = "";
  }

  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text, consume = true) {
    if (this.fetch().text !== text) {
      throw new ParseError(`Expected '${text}', got '${this.fetch().text}'`, this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }

  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }

  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }

  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    // Create a group namespace for every $...$, $$...$$, \[...\].)
    // A \def is then valid only within that pair of delimiters.
    this.gullet.beginGroup();

    if (this.settings.colorIsTextColor) {
      // Use old \color behavior (same as LaTeX's \textcolor) if requested.
      // We do this within the group for the math expression, so it doesn't
      // pollute settings.macros.
      this.gullet.macros.set("\\color", "\\textcolor");
    }

    // Try to parse the input
    const parse = this.parseExpression(false);

    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF");

    if (this.isPreamble) {
      const macros = Object.create(null);
      Object.entries(this.gullet.macros.current).forEach(([key, value]) => {
        macros[key] = value;
      });
      this.gullet.endGroup();
      return macros
    }

    // The only local macro that we want to save is from \tag.
    const tag = this.gullet.macros.get("\\df@tag");

    // End the group namespace for the expression
    this.gullet.endGroup();

    if (tag) { this.gullet.macros.current["\\df@tag"] = tag; }

    return parse;
  }

  static get endOfExpression() {
    return ["}", "\\endgroup", "\\end", "\\right", "\\endtoggle", "&"];
  }

  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    // Save the next token from the current job.
    const oldToken = this.nextToken;
    this.consume();

    // Run the new job, terminating it with an excess '}'
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    const parse = this.parseExpression(false);
    this.expect("}");

    // Restore the next token from the current job.
    this.nextToken = oldToken;

    return parse;
  }

/**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   *
   * `breakOnMiddle`: \color, \over, and old styling functions work on an implicit group.
   *                  These groups end just before the usual tokens, but they also
   *                  end just before `\middle`.
   */
  parseExpression(breakOnInfix, breakOnTokenText, breakOnMiddle) {
    const body = [];
    this.prevAtomType = "";
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
      // Ignore spaces in math mode
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      const lex = this.fetch();
      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnMiddle && lex.text === "\\middle") {
        break
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      const atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
      // Keep a record of the atom type, so that op.js can set correct spacing.
      this.prevAtomType = atom.type === "atom" ? atom.family : atom.type;
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }

  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    let overIndex = -1;
    let funcName;

    for (let i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i].token);
        }
        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }

    if (overIndex !== -1 && funcName) {
      let numerNode;
      let denomNode;

      const numerBody = body.slice(0, overIndex);
      const denomBody = body.slice(overIndex + 1);

      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = { type: "ordgroup", mode: this.mode, body: numerBody };
      }

      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = { type: "ordgroup", mode: this.mode, body: denomBody };
      }

      let node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }

  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(
    name // For error reporting.
  ) {
    const symbolToken = this.fetch();
    const symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces(); // ignore spaces before sup/subscript argument
    const group = this.parseGroup(name);

    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }

    return group;
  }

  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text) {
    const textordArray = [];

    for (let i = 0; i < text.length; i++) {
      textordArray.push({ type: "textord", mode: "text", text: text[i] });
    }

    const textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };

    const colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };

    return colorNode;
  }

  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    const base = this.parseGroup("atom", breakOnTokenText);

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
      return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    let superscript;
    let subscript;
    while (true) {
      // Guaranteed in math mode, so eat any spaces first.
      this.consumeSpaces();

      // Lex the first token
      const lex = this.fetch();

      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        // We got a limit control
        if (base && base.type === "op") {
          const limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        // We got a superscript start
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        // We got a subscript start
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        // We got a prime
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        const prime = { type: "textord", mode: this.mode, text: "\\prime" };

        // Many primes can be grouped together, so we handle this here
        const primes = [prime];
        this.consume();
        // Keep lexing tokens until we get something that's not a prime
        while (this.fetch().text === "'") {
          // For each one, add another prime to the list
          primes.push(prime);
          this.consume();
        }
        // If there's a superscript following the primes, combine that
        // superscript in with the primes.
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        // Put everything into an ordgroup as the superscript
        superscript = { type: "ordgroup", mode: this.mode, body: primes };
      } else if (uSubsAndSups[lex.text]) {
        // A Unicode subscript or superscript character.
        // We treat these similarly to the unicode-math package.
        // So we render a string of Unicode (sub|super)scripts the
        // same as a (sub|super)script of regular characters.
        const isSub = unicodeSubRegEx.test(lex.text);
        const subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        // Continue fetching tokens to fill out the group.
        while (true) {
          const token = this.fetch().text;
          if (!(uSubsAndSups[token])) { break }
          if (unicodeSubRegEx.test(token) !== isSub) { break }
          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        }
        // Now create a (sub|super)script.
        const body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = { type: "ordgroup", mode: "math", body };
        } else {
          superscript = { type: "ordgroup", mode: "math", body };
        }
      } else {
        // If it wasn't ^, _, a Unicode (sub|super)script, or ', stop parsing super/subscripts
        break;
      }
    }

    if (superscript || subscript) {
      if (base && base.type === "multiscript" && !base.postscripts) {
        // base is the result of a \prescript function.
        // Write the sub- & superscripts into the multiscript element.
        base.postscripts = { sup: superscript, sub: subscript };
        return base
      } else {
        // We got either a superscript or subscript, create a supsub
        const isFollowedByDelimiter = (!base || base.type !== "op" && base.type !== "operatorname")
          ? undefined
          : isDelimiter(this.nextToken.text);
        return {
          type: "supsub",
          mode: this.mode,
          base: base,
          sup: superscript,
          sub: subscript,
          isFollowedByDelimiter
        }
      }
    } else {
      // Otherwise return the original body
      return base;
    }
  }

  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(
    breakOnTokenText,
    name // For determining its context
  ) {
    const token = this.fetch();
    const func = token.text;
    const funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume(); // consume command token

    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError(
        "Got function '" + func + "' with no arguments" + (name ? " as " + name : ""),
        token
      );
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }

    const prevAtomType = this.prevAtomType;
    const { args, optArgs } = this.parseArguments(func, funcData);
    this.prevAtomType = prevAtomType;
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }

  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    const context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    const func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError(`No function handler for ${name}`);
    }
  }

  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(
    func, // Should look like "\name" or "\begin{name}".
    funcData
  ) {
    const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return { args: [], optArgs: [] };
    }

    const args = [];
    const optArgs = [];

    for (let i = 0; i < totalArgs; i++) {
      let argType = funcData.argTypes && funcData.argTypes[i];
      const isOptional = i < funcData.numOptionalArgs;

      if (
        (funcData.primitive && argType == null) ||
        // \sqrt expands into primitive if optional argument doesn't exist
        (funcData.type === "sqrt" && i === 1 && optArgs[0] == null)
      ) {
        argType = "primitive";
      }

      const arg = this.parseGroupOfType(`argument to '${func}'`, argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        // should be unreachable
        throw new ParseError("Null argument, please report this as a bug");
      }
    }

    return { args, optArgs };
  }

  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        // hbox argument type wraps the argument in the equivalent of
        // \hbox, which is like \text but switching to \textstyle size.
        const group = this.parseArgumentGroup(optional, "text");
        return group != null
          ? {
            type: "styling",
            mode: group.mode,
            body: [group],
            scriptLevel: "text" // simulate \textstyle
          }
          : null;
      }
      case "raw": {
        const token = this.parseStringGroup("raw", optional);
        return token != null
          ? {
            type: "raw",
            mode: "text",
            string: token.text
          }
          : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        const group = this.parseGroup(name);
        if (group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return group;
      }
      case "original":
      case null:
      case undefined:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }

  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (true) {
      const ch = this.fetch().text;
      // \ufe0e is the Unicode variation selector to supress emoji. Ignore it.
      if (ch === " " || ch === "\u00a0" || ch === "\ufe0e") {
        this.consume();
      } else {
        break
      }
    }
  }

  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(
    modeName, // Used to describe the mode in error messages.
    optional
  ) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume(); // consume the end of the argument
    argToken.text = str;
    return argToken;
  }

  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(
    regex,
    modeName // Used to describe the mode in error messages.
  ) {
    const firstToken = this.fetch();
    let lastToken = firstToken;
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }

  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    let res;
    let isBlank = false;
    // don't expand before parseStringGroup
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      // Because we've tested for what is !optional, this block won't
      // affect \kern, \hspace, etc. It will capture the mandatory arguments
      // to \genfrac and \above.
      res.text = "0pt"; // Enable \above{}
      isBlank = true; // This is here specifically for \genfrac
    }
    const match = sizeRegEx.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }

  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13); // active character
    this.gullet.lexer.setCatcode("~", 12); // other character
    const res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14); // comment character
    this.gullet.lexer.setCatcode("~", 13); // active character
    if (res == null) {
      return null;
    }
    // hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.
    let url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    url = res.text.replace(/{\u2044}/g, "/");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }

  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    const outerMode = this.mode;
    if (mode) {
      // Switch to specified mode
      this.switchMode(mode);
    }

    this.gullet.beginGroup();
    const expression = this.parseExpression(false, "EOF");
    // TODO: find an alternative way to denote the end
    this.expect("EOF"); // expect the end of the argument
    this.gullet.endGroup();
    const result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };

    if (mode) {
      // Switch mode back
      this.switchMode(outerMode);
    }
    return result;
  }

  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(
    name, // For error reporting.
    breakOnTokenText
  ) {
    const firstToken = this.fetch();
    const text = firstToken.text;

    let result;
    // Try to parse an open brace or \begingroup
    if (text === "{" || text === "\\begingroup" || text === "\\toggle") {
      this.consume();
      const groupEnd = text === "{"
        ? "}"
        : text === "\\begingroup"
        ? "\\endgroup"
        : "\\endtoggle";

      this.gullet.beginGroup();
      // If we get a brace, parse an expression
      const expression = this.parseExpression(false, groupEnd);
      const lastToken = this.fetch();
      this.expect(groupEnd); // Check that we got a matching closing brace
      this.gullet.endGroup();
      result = {
        type: (lastToken.text === "\\endtoggle" ? "toggle" : "ordgroup"),
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/
        semisimple: text === "\\begingroup" || undefined
      };
    } else {
      // If there exists a function with this name, parse the function.
      // Otherwise, just return a nucleus
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text[0] === "\\" &&
          !Object.prototype.hasOwnProperty.call(implicitCommands, text )) {
        result = this.formatUnsupportedCmd(text);
        this.consume();
      }
    }
    return result;
  }

  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    let n = group.length - 1;
    for (let i = 0; i < n; ++i) {
      const a = group[i];
      const v = a.text;
      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }
      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }

  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    const nucleus = this.fetch();
    let text = nucleus.text;

    if (/^\\verb[^a-zA-Z]/.test(text)) {
      this.consume();
      let arg = text.slice(5);
      const star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      // Lexer's tokenRegex is constructed to always have matching
      // first/last characters.
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
      }
      arg = arg.slice(1, -1); // remove first and last char
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    // At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.
    if (Object.prototype.hasOwnProperty.call(unicodeSymbols, text[0]) &&
      this.mode === "math" && !symbols[this.mode][text[0]]) {
      // This behavior is not strict (XeTeX-compatible) in math mode.
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Accented Unicode text character "${text[0]}" used in ` + `math mode`,
          nucleus
        );
      }
      text = unicodeSymbols[text[0]] + text.slice(1);
    }
    // Strip off any combining characters
    const match = this.mode === "math"
      ? combiningDiacriticalMarksEndRegex.exec(text)
      : null;
    if (match) {
      text = text.substring(0, match.index);
      if (text === "i") {
        text = "\u0131"; // dotless i, in math and text mode
      } else if (text === "j") {
        text = "\u0237"; // dotless j, in math and text mode
      }
    }
    // Recognize base symbol
    let symbol;
    if (symbols[this.mode][text]) {
      let group = symbols[this.mode][text].group;
      if (group === "bin" && binLeftCancellers.includes(this.prevAtomType)) {
        // Change from a binary operator to a unary (prefix) operator
        group = "open";
      }
      const loc = SourceLocation.range(nucleus);
      let s;
      if (Object.prototype.hasOwnProperty.call(ATOMS, group )) {
        const family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text
        };
        if ((family === "rel" || family === "bin") && this.prevAtomType === "text") {
          if (textRegEx.test(loc.lexer.input.slice(loc.end))) {
            s.needsSpacing = true;  // Fix a MathML bug.
          }
        }
      } else {
        if (asciiFromScript[text]) {
          // Unicode 14 disambiguates chancery from roundhand.
          // See https://www.unicode.org/charts/PDF/U1D400.pdf
          this.consume();
          const nextCode = this.fetch().text.charCodeAt(0);
          // mathcal is Temml default. Use mathscript if called for.
          const font = nextCode === 0xfe01 ? "mathscr" : "mathcal";
          if (nextCode === 0xfe00 || nextCode === 0xfe01) { this.consume(); }
          return {
            type: "font",
            mode: "math",
            font,
            body: { type: "mathord", mode: "math", loc, text: asciiFromScript[text] }
          }
        }
        // Default ord character. No disambiguation necessary.
        s = {
          type: group,
          mode: this.mode,
          loc,
          text
        };
      }
      symbol = s;
    } else if (text.charCodeAt(0) >= 0x80 || combiningDiacriticalMarksEndRegex.exec(text)) {
      // no symbol for e.g. ^
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Unicode text character "${text[0]}" used in math mode`, nucleus)
      }
      // All nonmathematical Unicode characters are rendered as if they
      // are in text mode (wrapped in \text) because that's what it
      // takes to render them in LaTeX.
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text
      };
    } else {
      return null; // EOF, ^, _, {, }, etc.
    }
    this.consume();
    // Transform combining characters into accents
    if (match) {
      for (let i = 0; i < match[0].length; i++) {
        const accent = match[0][i];
        if (!unicodeAccents[accent]) {
          throw new ParseError(`Unknown accent ' ${accent}'`, nucleus);
        }
        const command = unicodeAccents[accent][this.mode] ||
                        unicodeAccents[accent].text;
        if (!command) {
          throw new ParseError(`Accent ${accent} unsupported in ${this.mode} mode`, nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          base: symbol
        };
      }
    }
    return symbol;
  }
}

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
const parseTree = function(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(toParse, settings);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];

  let tree = parser.parse();

  // LaTeX ignores a \tag placed outside an AMS environment.
  if (!(tree.length > 0 &&  tree[0].type && tree[0].type === "array" && tree[0].addEqnNum)) {
    // If the input used \tag, it will set the \df@tag macro to the tag.
    // In this case, we separately parse the tag and wrap the tree.
    if (parser.gullet.macros.get("\\df@tag")) {
      if (!settings.displayMode) {
        throw new ParseError("\\tag works only in display mode")
      }
      parser.gullet.feed("\\df@tag");
      tree = [
        {
          type: "tag",
          mode: "text",
          body: tree,
          tag: parser.parse()
        }
      ];
    }
  }

  return tree
};

/**
 * This file contains information about the style that the mathmlBuilder carries
 * around with it. Data is held in an `Style` object, and when
 * recursing, a new `Style` object can be created with the `.with*` functions.
 */

const subOrSupLevel = [2, 2, 3, 3];

/**
 * This is the main Style class. It contains the current style.level, color, and font.
 *
 * Style objects should not be modified. To create a new Style with
 * different properties, call a `.with*` method.
 */
class Style {
  constructor(data) {
    // Style.level can be 0 | 1 | 2 | 3, which correspond to
    //       displaystyle, textstyle, scriptstyle, and scriptscriptstyle.
    // style.level usually does not directly set MathML's script level. MathML does that itself.
    // However, Chromium does not stop shrinking after scriptscriptstyle, so we do explicitly
    // set a scriptlevel attribute in those conditions.
    // We also use style.level to track math style so that we can get the correct
    // scriptlevel when needed in supsub.js, mathchoice.js, or for dimensions in em.
    this.level = data.level;
    this.color = data.color;  // string | void
    // A font family applies to a group of fonts (i.e. SansSerif), while a font
    // represents a specific font (i.e. SansSerif Bold).
    // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
    this.font = data.font || "";                // string
    this.fontFamily = data.fontFamily || "";    // string
    this.fontSize = data.fontSize || 1.0;       // number
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.maxSize = data.maxSize;                // [number, number]
  }

  /**
   * Returns a new style object with the same properties as "this".  Properties
   * from "extension" will be copied to the new style object.
   */
  extend(extension) {
    const data = {
      level: this.level,
      color: this.color,
      font: this.font,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize
    };

    for (const key in extension) {
      if (Object.prototype.hasOwnProperty.call(extension, key)) {
        data[key] = extension[key];
      }
    }

    return new Style(data);
  }

  withLevel(n) {
    return this.extend({
      level: n
    });
  }

  incrementLevel() {
    return this.extend({
      level: Math.min(this.level + 1, 3)
    });
  }

  inSubOrSup() {
    return this.extend({
      level: subOrSupLevel[this.level]
    })
  }

  /**
   * Create a new style object with the given color.
   */
  withColor(color) {
    return this.extend({
      color: color
    });
  }

  /**
   * Creates a new style object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }

  /**
   * Create a new style objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font size
   */
  withFontSize(num) {
    return this.extend({
      fontSize: num
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }

  /**
   * Gets the CSS color of the current style object
   */
  getColor() {
    return this.color;
  }
}

/* Temml Post Process
 * Populate the text contents of each \ref & \eqref
 *
 * As with other Temml code, this file is released under terms of the MIT license.
 * https://mit-license.org/
 */

const version = "0.11.02";

function postProcess(block) {
  const labelMap = {};
  let i = 0;

  // Get a collection of the parents of each \tag & auto-numbered equation
  const amsEqns = document.getElementsByClassName('tml-eqn');
  for (let parent of amsEqns) {
    // AMS automatically numbered equation.
    // Assign an id.
    i += 1;
    parent.setAttribute("id", "tml-eqn-" + String(i));
    // No need to write a number into the text content of the element.
    // A CSS counter has done that even if this postProcess() function is not used.

    // Find any \label that refers to an AMS automatic eqn number.
    while (true) {
      if (parent.tagName === "mtable") { break }
      const labels = parent.getElementsByClassName("tml-label");
      if (labels.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = String(i);
        break
      } else {
        parent = parent.parentElement;
      }
    }
  }

  // Find \labels associated with \tag
  const taggedEqns = document.getElementsByClassName('tml-tageqn');
  for (const parent of taggedEqns) {
    const labels = parent.getElementsByClassName("tml-label");
    if (labels.length > 0) {
      const tags = parent.getElementsByClassName("tml-tag");
      if (tags.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = tags[0].textContent;
      }
    }
  }

  // Populate \ref & \eqref text content
  const refs = block.getElementsByClassName("tml-ref");
  [...refs].forEach(ref => {
    const attr = ref.getAttribute("href");
    let str = labelMap[attr.slice(1)];
    if (ref.className.indexOf("tml-eqref") === -1) {
      // \ref. Omit parens.
      str = str.replace(/^\(/, "");
      str = str.replace(/\)$/, "");
    } else {
      // \eqref. Include parens
      if (str.charAt(0) !== "(") { str = "(" + str; }
      if (str.slice(-1) !== ")") { str =  str + ")"; }
    }
    const mtext = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mtext");
    mtext.appendChild(document.createTextNode(str));
    const math =  document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
    math.appendChild(mtext);
    ref.textContent = '';
    ref.appendChild(math);
  });
}

const findEndOfMath = function(delimiter, text, startIndex) {
  // Adapted from
  // https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx
  let index = startIndex;
  let braceLevel = 0;

  const delimLength = delimiter.length;

  while (index < text.length) {
    const character = text[index];

    if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter) {
      return index;
    } else if (character === "\\") {
      index++;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    }

    index++;
  }

  return -1;
};

const escapeRegex = function(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};

const amsRegex = /^\\(?:begin|(?:eq)?ref){/;

const splitAtDelimiters = function(text, delimiters) {
  let index;
  const data = [];

  const regexLeft = new RegExp(
    "(" + delimiters.map((x) => escapeRegex(x.left)).join("|") + ")"
  );

  while (true) {
    index = text.search(regexLeft);
    if (index === -1) {
      break;
    }
    if (index > 0) {
      data.push({
        type: "text",
        data: text.slice(0, index)
      });
      text = text.slice(index); // now text starts with delimiter
    }
    // ... so this always succeeds:
    const i = delimiters.findIndex((delim) => text.startsWith(delim.left));
    index = findEndOfMath(delimiters[i].right, text, delimiters[i].left.length);
    if (index === -1) {
      break;
    }
    const rawData = text.slice(0, index + delimiters[i].right.length);
    const math = amsRegex.test(rawData)
      ? rawData
      : text.slice(delimiters[i].left.length, index);
    data.push({
      type: "math",
      data: math,
      rawData,
      display: delimiters[i].display
    });
    text = text.slice(index + delimiters[i].right.length);
  }

  if (text !== "") {
    data.push({
      type: "text",
      data: text
    });
  }

  return data;
};

const defaultDelimiters = [
  { left: "$$", right: "$$", display: true },
  { left: "\\(", right: "\\)", display: false },
  // LaTeX uses $â€¦$, but it ruins the display of normal `$` in text:
  // {left: "$", right: "$", display: false},
  // $ must come after $$

  // Render AMS environments even if outside $$â€¦$$ delimiters.
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  // Ditto \ref & \eqref
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false },

  { left: "\\[", right: "\\]", display: true }
];

const firstDraftDelimiters = {
  "$": [
         { left: "$$", right: "$$", display: true },
         { left: "$`", right: "`$", display: false },
         { left: "$", right: "$", display: false }
  ],
  "(": [
    { left: "\\[", right: "\\]", display: true },
    { left: "\\(", right: "\\)", display: false }
  ]
};

const amsDelimiters = [
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false }
];

const delimitersFromKey = key => {
  if (key === "$" || key === "(") {
    return firstDraftDelimiters[key];
  } else if (key === "$+" || key === "(+") {
    const firstDraft = firstDraftDelimiters[key.slice(0, 1)];
    return firstDraft.concat(amsDelimiters)
  } else if (key === "ams") {
    return amsDelimiters
  } else if (key === "all") {
    return (firstDraftDelimiters["("]).concat(firstDraftDelimiters["$"]).concat(amsDelimiters)
  } else {
    return defaultDelimiters
  }
};

/* Note: optionsCopy is mutated by this method. If it is ever exposed in the
 * API, we should copy it before mutating.
 */
const renderMathInText = function(text, optionsCopy) {
  const data = splitAtDelimiters(text, optionsCopy.delimiters);
  if (data.length === 1 && data[0].type === "text") {
    // There is no formula in the text.
    // Let's return null which means there is no need to replace
    // the current text node with a new one.
    return null;
  }

  const fragment = document.createDocumentFragment();

  for (let i = 0; i < data.length; i++) {
    if (data[i].type === "text") {
      fragment.appendChild(document.createTextNode(data[i].data));
    } else {
      const span = document.createElement("span");
      let math = data[i].data;
      // Override any display mode defined in the settings with that
      // defined by the text itself
      optionsCopy.displayMode = data[i].display;
      try {
        if (optionsCopy.preProcess) {
          math = optionsCopy.preProcess(math);
        }
        // Importing render() from temml.js would be a circular dependency.
        // So call the global version.
        // eslint-disable-next-line no-undef
        temml.render(math, span, optionsCopy);
      } catch (e) {
        if (!(e instanceof ParseError)) {
          throw e;
        }
        optionsCopy.errorCallback(
          "Temml auto-render: Failed to parse `" + data[i].data + "` with ",
          e
        );
        fragment.appendChild(document.createTextNode(data[i].rawData));
        continue;
      }
      fragment.appendChild(span);
    }
  }

  return fragment;
};

const renderElem = function(elem, optionsCopy) {
  for (let i = 0; i < elem.childNodes.length; i++) {
    const childNode = elem.childNodes[i];
    if (childNode.nodeType === 3) {
      // Text node
      const frag = renderMathInText(childNode.textContent, optionsCopy);
      if (frag) {
        i += frag.childNodes.length - 1;
        elem.replaceChild(frag, childNode);
      }
    } else if (childNode.nodeType === 1) {
      // Element node
      const className = " " + childNode.className + " ";
      const shouldRender =
        optionsCopy.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 &&
        optionsCopy.ignoredClasses.every((x) => className.indexOf(" " + x + " ") === -1);

      if (shouldRender) {
        renderElem(childNode, optionsCopy);
      }
    }
    // Otherwise, it's something else, and ignore it.
  }
};

const renderMathInElement = function(elem, options) {
  if (!elem) {
    throw new Error("No element provided to render");
  }

  const optionsCopy = {};

  // Object.assign(optionsCopy, option)
  for (const option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      optionsCopy[option] = options[option];
    }
  }

  if (optionsCopy.fences) {
    optionsCopy.delimiters = delimitersFromKey(optionsCopy.fences);
  } else {
    optionsCopy.delimiters = optionsCopy.delimiters || defaultDelimiters;
  }
  optionsCopy.ignoredTags = optionsCopy.ignoredTags || [
    "script",
    "noscript",
    "style",
    "textarea",
    "pre",
    "code",
    "option"
  ];
  optionsCopy.ignoredClasses = optionsCopy.ignoredClasses || [];
  // eslint-disable-next-line no-console
  optionsCopy.errorCallback = optionsCopy.errorCallback || console.error;

  // Enable sharing of global macros defined via `\gdef` between different
  // math elements within a single call to `renderMathInElement`.
  optionsCopy.macros = optionsCopy.macros || {};

  renderElem(elem, optionsCopy);
  postProcess(elem);
};

/* eslint no-console:0 */
/**
 * This is the main entry point for Temml. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from Temml are
 * errors in the expression, or errors in javascript handling.
 */


/**
 * @type {import('./temml').render}
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
let render = function(expression, baseNode, options = {}) {
  baseNode.textContent = "";
  const alreadyInMathElement = baseNode.tagName.toLowerCase() === "math";
  if (alreadyInMathElement) { options.wrap = "none"; }
  const math = renderToMathMLTree(expression, options);
  if (alreadyInMathElement) {
    // The <math> element already exists. Populate it.
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else if (math.children.length > 1) {
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else {
    baseNode.appendChild(math.toNode());
  }
};

// Temml's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" &&
      console.warn(
        "Warning: Temml doesn't work in quirks mode. Make sure your " +
          "website has a suitable doctype."
      );

    render = function() {
      throw new ParseError("Temml doesn't work in quirks mode.");
    };
  }
}

/**
 * @type {import('./temml').renderToString}
 * Parse and build an expression, and return the markup for that.
 */
const renderToString = function(expression, options) {
  const markup = renderToMathMLTree(expression, options).toMarkup();
  return markup;
};

/**
 * @type {import('./temml').generateParseTree}
 * Parse an expression and return the parse tree.
 */
const generateParseTree = function(expression, options) {
  const settings = new Settings(options);
  return parseTree(expression, settings);
};

/**
 * @type {import('./temml').definePreamble}
 * Take an expression which contains a preamble.
 * Parse it and return the macros.
 */
const definePreamble = function(expression, options) {
  const settings = new Settings(options);
  settings.macros = {};
  if (!(typeof expression === "string" || expression instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(expression, settings, true);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];
  const macros = parser.parse();
  return macros
};

/**
 * If the given error is a Temml ParseError,
 * renders the invalid LaTeX as a span with hover title giving the Temml
 * error message.  Otherwise, simply throws the error.
 */
const renderError = function(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }
  const node = new Span(["temml-error"], [new TextNode$1(expression + "\n\n" + error.toString())]);
  node.style.color = options.errorColor;
  node.style.whiteSpace = "pre-line";
  return node;
};

/**
 * @type {import('./temml').renderToMathMLTree}
 * Generates and returns the Temml build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */
const renderToMathMLTree = function(expression, options) {
  const settings = new Settings(options);
  try {
    const tree = parseTree(expression, settings);
    const style = new Style({
      level: settings.displayMode ? StyleLevel.DISPLAY : StyleLevel.TEXT,
      maxSize: settings.maxSize
    });
    return buildMathML(tree, expression, style, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};

/** @type {import('./temml').default} */
var temml$1 = {
  /**
   * Current Temml version
   */
  version: version,
  /**
   * Renders the given LaTeX into MathML, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into MathML string,
   * for sending to the client.
   */
  renderToString,
  /**
   * Finds all the math delimiters in a given element of a running HTML document
   * and converts the contents of each instance into a <math> element.
   */
  renderMathInElement,
  /**
   * Post-process an entire HTML block.
   * Writes AMS auto-numbers and implements \ref{}.
   * Typcally called once, after a loop has rendered many individual spans.
   */
  postProcess,
  /**
   * Temml error, usually during parsing.
   */
  ParseError,
  /**
   * Creates a set of macros with document-wide scope.
   */
  definePreamble,
  /**
   * Parses the given LaTeX into Temml's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into a MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToMathMLTree: renderToMathMLTree,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro
};

module.exports = temml$1;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
var defuddle_1 = __webpack_require__(/*! ./defuddle */ 628);
Object.defineProperty(exports, "Defuddle", ({ enumerable: true, get: function () { return defuddle_1.Defuddle; } }));

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEVBQUUsZUFBZSxHQUFHLEdBQUcsR0FBRyxjQUFjLGFBQWEsc0NBQXNDLFNBQVMsaUVBQWlFLFdBQVcsaUNBQWlDLGFBQWEsTUFBTSx5Q0FBeUMsMENBQTBDLDBCQUEwQixNQUFNLGdCQUFnQixVQUFVLGNBQWMsR0FBRyxFQUFFLEdBQUcsT0FBTywyQkFBMkIsYUFBYSxrQkFBa0IsTUFBTSxtQkFBbUIsR0FBRyxXQUFXLEdBQUcsRUFBRSxHQUFHLElBQUksU0FBUyxHQUFHLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLG9CQUFvQixJQUFJLHFCQUFxQixJQUFJLGlKQUFpSixJQUFJLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLElBQUksNEJBQTRCLElBQUksNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLEtBQUssNEJBQTRCLElBQUksNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLE9BQU8sNEJBQTRCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLElBQUksNkJBQTZCLEtBQUssNkJBQTZCLE1BQU0sNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssNkJBQTZCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLElBQUksOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLElBQUksOEJBQThCLElBQUksOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLElBQUksOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUssOEJBQThCLEtBQUss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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQyw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEI7QUFDOUIsNEJBQTRCLE9BQU87QUFDbkMsOEJBQThCLE9BQU87QUFDckMsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekMsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsT0FBTztBQUNoRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0Qix1QkFBdUIsMkJBQTJCO0FBQ2xELDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QUFDcEQsd0NBQXdDLFFBQVE7QUFDaEQsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNB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Q0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIs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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scURBQXFELFdBQVc7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsYUFBYTtBQUMzQixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBEQUEwRCxFQUFFO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O1VDM2xjQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQSw0REFBc0M7QUFBN0IsNkdBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vRGVmdWRkbGUvLi9zcmMvbWF0aC50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy9tYXRobWwtdG8tbGF0ZXgvZGlzdC9idW5kbGUubWluLmpzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL21ldGFkYXRhLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2RlZnVkZGxlLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy90ZW1tbC9kaXN0L3RlbW1sLmNqcyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHRoaXMsICgpID0+IHtcbnJldHVybiAiLCJpbXBvcnQgeyBNYXRoTUxUb0xhVGVYIH0gZnJvbSAnbWF0aG1sLXRvLWxhdGV4JztcbmltcG9ydCAqIGFzIHRlbW1sIGZyb20gJ3RlbW1sJztcblxuZXhwb3J0IGludGVyZmFjZSBNYXRoRGF0YSB7XG5cdG1hdGhtbDogc3RyaW5nO1xuXHRsYXRleDogc3RyaW5nIHwgbnVsbDtcblx0aXNCbG9jazogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGdldE1hdGhNTEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogTWF0aERhdGEgfCBudWxsID0+IHtcblx0Ly8gMS4gRGlyZWN0IE1hdGhNTCBjb250ZW50XG5cdGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdtYXRoJykge1xuXHRcdGNvbnN0IGlzQmxvY2sgPSBlbC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcblx0XHRyZXR1cm4ge1xuXHRcdFx0bWF0aG1sOiBlbC5vdXRlckhUTUwsXG5cdFx0XHRsYXRleDogZWwuZ2V0QXR0cmlidXRlKCdhbHR0ZXh0JykgfHwgbnVsbCxcblx0XHRcdGlzQmxvY2tcblx0XHR9O1xuXHR9XG5cblx0Ly8gMi4gTWF0aE1MIGluIGRhdGEtbWF0aG1sIGF0dHJpYnV0ZVxuXHRjb25zdCBtYXRobWxTdHIgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWF0aG1sJyk7XG5cdGlmIChtYXRobWxTdHIpIHtcblx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGVtcERpdi5pbm5lckhUTUwgPSBtYXRobWxTdHI7XG5cdFx0Y29uc3QgbWF0aEVsZW1lbnQgPSB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRpZiAobWF0aEVsZW1lbnQpIHtcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdG1hdGhtbDogbWF0aEVsZW1lbnQub3V0ZXJIVE1MLFxuXHRcdFx0XHRsYXRleDogbWF0aEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhbHR0ZXh0JykgfHwgbnVsbCxcblx0XHRcdFx0aXNCbG9ja1xuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHQvLyAzLiBNYXRoSmF4IGFzc2lzdGl2ZSBNYXRoTUxcblx0Y29uc3QgYXNzaXN0aXZlTW1sQ29udGFpbmVyID0gZWwucXVlcnlTZWxlY3RvcignLk1KWF9Bc3Npc3RpdmVfTWF0aE1MLCBtangtYXNzaXN0aXZlLW1tbCcpO1xuXHRcblx0aWYgKGFzc2lzdGl2ZU1tbENvbnRhaW5lcikge1xuXHRcdGNvbnN0IG1hdGhFbGVtZW50ID0gYXNzaXN0aXZlTW1sQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRcblx0XHRpZiAobWF0aEVsZW1lbnQpIHtcblx0XHRcdC8vIENoZWNrIGJvdGggdGhlIG1hdGggZWxlbWVudCBhbmQgY29udGFpbmVyIGZvciBkaXNwbGF5IG1vZGVcblx0XHRcdGNvbnN0IG1hdGhEaXNwbGF5QXR0ciA9IG1hdGhFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzcGxheScpO1xuXHRcdFx0Y29uc3QgY29udGFpbmVyRGlzcGxheUF0dHIgPSBhc3Npc3RpdmVNbWxDb250YWluZXIuZ2V0QXR0cmlidXRlKCdkaXNwbGF5Jyk7XHRcdFx0XG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gbWF0aERpc3BsYXlBdHRyID09PSAnYmxvY2snIHx8IGNvbnRhaW5lckRpc3BsYXlBdHRyID09PSAnYmxvY2snO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRtYXRobWw6IG1hdGhFbGVtZW50Lm91dGVySFRNTCxcblx0XHRcdFx0bGF0ZXg6IG1hdGhFbGVtZW50LmdldEF0dHJpYnV0ZSgnYWx0dGV4dCcpIHx8IG51bGwsXG5cdFx0XHRcdGlzQmxvY2tcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0Ly8gNC4gS2FUZVggTWF0aE1MXG5cdGNvbnN0IGthdGV4TWF0aG1sID0gZWwucXVlcnlTZWxlY3RvcignLmthdGV4LW1hdGhtbCBtYXRoJyk7XG5cdGlmIChrYXRleE1hdGhtbCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRtYXRobWw6IGthdGV4TWF0aG1sLm91dGVySFRNTCxcblx0XHRcdGxhdGV4OiBudWxsLCAvLyBXZSdsbCBnZXQgTGFUZVggc2VwYXJhdGVseSBmb3IgS2FUZVhcblx0XHRcdGlzQmxvY2s6IGZhbHNlIC8vIFdlJ2xsIGRldGVybWluZSB0aGlzIGZyb20gY29udGFpbmVyXG5cdFx0fTtcblx0fVxuO1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRMYXRleEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogc3RyaW5nIHwgbnVsbCA9PiB7XG5cdC8vIERpcmVjdCBkYXRhLWxhdGV4IGF0dHJpYnV0ZVxuXHRjb25zdCBkYXRhTGF0ZXggPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGF0ZXgnKTtcblx0aWYgKGRhdGFMYXRleCkge1xuXHRcdHJldHVybiBkYXRhTGF0ZXg7XG5cdH1cblxuXHQvLyBXb3JkUHJlc3MgTGFUZVggaW1hZ2VzXG5cdGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXRleCcpKSB7XG5cdFx0Ly8gVHJ5IGFsdCB0ZXh0IGZpcnN0IGFzIGl0J3MgY2xlYW5lclxuXHRcdGNvbnN0IGFsdExhdGV4ID0gZWwuZ2V0QXR0cmlidXRlKCdhbHQnKTtcblx0XHRpZiAoYWx0TGF0ZXgpIHtcblx0XHRcdHJldHVybiBhbHRMYXRleDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRmFsbGJhY2sgdG8gZXh0cmFjdGluZyBmcm9tIFVSTFxuXHRcdGNvbnN0IHNyYyA9IGVsLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goL2xhdGV4XFwucGhwXFw/bGF0ZXg9KFteJl0rKS8pO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcKy9nLCAnICcpIC8vIFJlcGxhY2UgKyB3aXRoIHNwYWNlc1xuXHRcdFx0XHRcdC5yZXBsYWNlKC8lNUMvZywgJ1xcXFwnKTsgLy8gRml4IGVzY2FwZWQgYmFja3NsYXNoZXNcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBMYVRlWCBpbiBhbm5vdGF0aW9uXG5cdGNvbnN0IGFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCdhbm5vdGF0aW9uW2VuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIl0nKTtcblx0aWYgKGFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0cmV0dXJuIGFubm90YXRpb24udGV4dENvbnRlbnQudHJpbSgpO1xuXHR9XG5cblx0Ly8gS2FUZVggZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLmthdGV4JykpIHtcblx0XHRjb25zdCBrYXRleEFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCcua2F0ZXgtbWF0aG1sIGFubm90YXRpb25bZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiXScpO1xuXHRcdGlmIChrYXRleEFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0XHRyZXR1cm4ga2F0ZXhBbm5vdGF0aW9uLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHR9XG5cdH1cblxuXHQvLyBNYXRoSmF4IHNjcmlwdHNcblx0Ly8gSW1wb3J0YW50OiB0aGlzIHdpbGwgb25seSB3b3JrIGlmIHRoZSBzY3JpcHQgaGFzIG5vdCBiZWVuIHJlbW92ZWQgYXQgYW4gZWFybGllciBzdGFnZVxuXHRpZiAoZWwubWF0Y2hlcygnc2NyaXB0W3R5cGU9XCJtYXRoL3RleFwiXScpIHx8IGVsLm1hdGNoZXMoJ3NjcmlwdFt0eXBlPVwibWF0aC90ZXg7IG1vZGU9ZGlzcGxheVwiXScpKSB7XG5cdFx0cmV0dXJuIGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBzaWJsaW5nIHNjcmlwdCBlbGVtZW50XG5cdGlmIChlbC5wYXJlbnRFbGVtZW50KSB7XG5cdFx0Y29uc3Qgc2libGluZ1NjcmlwdCA9IGVsLnBhcmVudEVsZW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3R5cGU9XCJtYXRoL3RleFwiXSwgc2NyaXB0W3R5cGU9XCJtYXRoL3RleDsgbW9kZT1kaXNwbGF5XCJdJyk7XG5cdFx0aWYgKHNpYmxpbmdTY3JpcHQpIHtcblx0XHRcdHJldHVybiBzaWJsaW5nU2NyaXB0LnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcblx0XHR9XG5cdH1cblxuXHQvLyBUcnkgdG8gY29udmVydCBNYXRoTUwgdG8gTGFUZVggYXMgbGFzdCByZXNvcnRcblx0Y29uc3QgbWF0aG1sID0gZ2V0TWF0aE1MRnJvbUVsZW1lbnQoZWwpO1xuXHRpZiAobWF0aG1sPy5tYXRobWwpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIE1hdGhNTFRvTGFUZVguY29udmVydChtYXRobWwubWF0aG1sKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY29udmVydGluZyBNYXRoTUwgdG8gTGFUZVg6JywgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0Ly8gRmFsbGJhY2sgdG8gYWx0IHRleHQgb3IgdGV4dCBjb250ZW50XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0Jsb2NrRGlzcGxheSA9IChlbDogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xuXHQvLyBDaGVjayBleHBsaWNpdCBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRjb25zdCBkaXNwbGF5QXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpO1xuXHRpZiAoZGlzcGxheUF0dHIgPT09ICdibG9jaycpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIENoZWNrIGNvbW1vbiBjbGFzcyBuYW1lc1xuXHRjb25zdCBjbGFzc05hbWVzID0gZWwuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGlmIChjbGFzc05hbWVzLmluY2x1ZGVzKCdkaXNwbGF5JykgfHwgY2xhc3NOYW1lcy5pbmNsdWRlcygnYmxvY2snKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgY29udGFpbmVyIGNsYXNzZXNcblx0Y29uc3QgY29udGFpbmVyID0gZWwuY2xvc2VzdCgnLmthdGV4LWRpc3BsYXksIC5NYXRoSmF4X0Rpc3BsYXksIFtkYXRhLWRpc3BsYXk9XCJibG9ja1wiXScpO1xuXHRpZiAoY29udGFpbmVyKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBwcmVjZWRlZCBieSBibG9jayBlbGVtZW50XG5cdGNvbnN0IHByZXZFbGVtZW50ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcblx0aWYgKHByZXZFbGVtZW50Py50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgc3BlY2lmaWMgZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLm13ZS1tYXRoLWZhbGxiYWNrLWltYWdlLWRpc3BsYXknKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gQ2hlY2sgS2FUZVggZGlzcGxheSBtb2RlXG5cdGlmIChlbC5tYXRjaGVzKCcua2F0ZXgnKSkge1xuXHRcdC8vIEthVGVYIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuXHRcdC8vIE9ubHkgYmxvY2sgaWYgZXhwbGljaXRseSBtYXJrZWQgYXMgZGlzcGxheVxuXHRcdHJldHVybiBlbC5jbG9zZXN0KCcua2F0ZXgtZGlzcGxheScpICE9PSBudWxsO1xuXHR9XG5cblx0Ly8gQ2hlY2sgTWF0aEpheCB2MyBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNwbGF5JykpIHtcblx0XHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdkaXNwbGF5JykgPT09ICd0cnVlJztcblx0fVxuXG5cdC8vIENoZWNrIE1hdGhKYXggc2NyaXB0IGRpc3BsYXkgYXR0cmlidXRlXG5cdGlmIChlbC5tYXRjaGVzKCdzY3JpcHRbdHlwZT1cIm1hdGgvdGV4OyBtb2RlPWRpc3BsYXlcIl0nKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0aWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGlzcGxheScpKSB7XG5cdFx0cmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpID09PSAndHJ1ZSc7XG5cdH1cblxuXHQvLyBDaGVjayBwYXJlbnQgY29udGFpbmVyIGRpc3BsYXkgYXR0cmlidXRlXG5cdGNvbnN0IHBhcmVudENvbnRhaW5lciA9IGVsLmNsb3Nlc3QoJ1tkaXNwbGF5XScpO1xuXHRpZiAocGFyZW50Q29udGFpbmVyKSB7XG5cdFx0cmV0dXJuIHBhcmVudENvbnRhaW5lci5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ3RydWUnO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsZWFuTWF0aEVsID0gKG1hdGhEYXRhOiBNYXRoRGF0YSB8IG51bGwsIGxhdGV4OiBzdHJpbmcgfCBudWxsLCBpc0Jsb2NrOiBib29sZWFuKTogRWxlbWVudCA9PiB7XG5cdGNvbnN0IGNsZWFuTWF0aEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWF0aCcpO1xuXG5cdGNsZWFuTWF0aEVsLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcpO1xuXHRjbGVhbk1hdGhFbC5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCBpc0Jsb2NrID8gJ2Jsb2NrJyA6ICdpbmxpbmUnKTtcblx0Y2xlYW5NYXRoRWwuc2V0QXR0cmlidXRlKCdkYXRhLWxhdGV4JywgbGF0ZXggfHwgJycpO1xuXG5cdC8vIEZpcnN0IHRyeSB0byB1c2UgZXhpc3RpbmcgTWF0aE1MIGNvbnRlbnRcblx0aWYgKG1hdGhEYXRhPy5tYXRobWwpIHtcblx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGVtcERpdi5pbm5lckhUTUwgPSBtYXRoRGF0YS5tYXRobWw7XG5cdFx0Y29uc3QgbWF0aENvbnRlbnQgPSB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRpZiAobWF0aENvbnRlbnQpIHtcblx0XHRcdGNsZWFuTWF0aEVsLmlubmVySFRNTCA9IG1hdGhDb250ZW50LmlubmVySFRNTDtcblx0XHR9XG5cdH1cblx0Ly8gSWYgbm8gTWF0aE1MIGNvbnRlbnQgYnV0IHdlIGhhdmUgTGFUZVgsIGNvbnZlcnQgdXNpbmcgVGVtbWxcblx0ZWxzZSBpZiAobGF0ZXgpIHtcblx0XHR0cnkge1x0XHRcdFxuXHRcdFx0Ly8gQ29udmVydCBMYVRlWCB0byBNYXRoTUwgdXNpbmcgVGVtbWxcblx0XHRcdGNvbnN0IG1hdGhtbCA9IHRlbW1sLnJlbmRlclRvU3RyaW5nKGxhdGV4LCB7XG5cdFx0XHRcdGRpc3BsYXlNb2RlOiBpc0Jsb2NrLFxuXHRcdFx0XHR0aHJvd09uRXJyb3I6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKHR5cGVvZiBtYXRobWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEV4dHJhY3QgdGhlIGlubmVyIGNvbnRlbnQgb2YgdGhlIG1hdGggZWxlbWVudFxuXHRcdFx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRcdHRlbXBEaXYuaW5uZXJIVE1MID0gbWF0aG1sO1xuXHRcdFx0XHRjb25zdCBtYXRoQ29udGVudCA9IHRlbXBEaXYucXVlcnlTZWxlY3RvcignbWF0aCcpO1xuXHRcdFx0XHRpZiAobWF0aENvbnRlbnQpIHtcblx0XHRcdFx0XHQvLyBDb3B5IGF0dHJpYnV0ZXMgZXhjZXB0IGRpc3BsYXkgbW9kZVxuXHRcdFx0XHRcdEFycmF5LmZyb20obWF0aENvbnRlbnQuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0XHRcdGlmIChhdHRyLm5hbWUgIT09ICdkaXNwbGF5Jykge1xuXHRcdFx0XHRcdFx0XHRjbGVhbk1hdGhFbC5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjbGVhbk1hdGhFbC5pbm5lckhUTUwgPSBtYXRoQ29udGVudC5pbm5lckhUTUw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gVXNlIHRoZSBlbnRpcmUgb3V0cHV0IGFzIGZhbGxiYWNrXG5cdFx0XHRcdFx0Y2xlYW5NYXRoRWwuaW5uZXJIVE1MID0gbWF0aG1sO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbGVhbk1hdGhFbC50ZXh0Q29udGVudCA9IGxhdGV4O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBjb252ZXJ0aW5nIExhVGVYIHRvIE1hdGhNTDonLCBlcnJvcik7XG5cdFx0XHRjbGVhbk1hdGhFbC50ZXh0Q29udGVudCA9IGxhdGV4O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjbGVhbk1hdGhFbDtcbn07XG5cbi8vIEZpbmQgbWF0aCBlbGVtZW50c1xuZXhwb3J0IGNvbnN0IG1hdGhTdGFuZGFyZGl6YXRpb25SdWxlcyA9IFtcblx0e1xuXHRcdHNlbGVjdG9yOiBbXG5cdFx0Ly8gV29yZFByZXNzIExhVGVYIGltYWdlc1xuXHRcdFx0J2ltZy5sYXRleFtzcmMqPVwibGF0ZXgucGhwXCJdJyxcblxuXHRcdC8vIE1hdGhKYXggZWxlbWVudHMgKHYyIGFuZCB2Mylcblx0XHRcdCdzcGFuLk1hdGhKYXgnLFxuXHRcdFx0J21qeC1jb250YWluZXInLFxuXHRcdFx0Jy5NYXRoSmF4X0Rpc3BsYXknLFxuXHRcdFx0Jy5NYXRoSmF4X1NWRycsXG5cdFx0XHQnLk1hdGhKYXhfTWF0aE1MJyxcblxuXHRcdC8vIE1lZGlhV2lraSBtYXRoIGVsZW1lbnRzXG5cdFx0XHQnLm13ZS1tYXRoLWVsZW1lbnQnLFxuXHRcdFx0Jy5td2UtbWF0aC1mYWxsYmFjay1pbWFnZS1pbmxpbmUnLFxuXHRcdFx0Jy5td2UtbWF0aC1mYWxsYmFjay1pbWFnZS1kaXNwbGF5Jyxcblx0XHRcdCcubXdlLW1hdGgtbWF0aG1sLWlubGluZScsXG5cdFx0XHQnLm13ZS1tYXRoLW1hdGhtbC1kaXNwbGF5JyxcblxuXHRcdC8vIEthVGVYIGVsZW1lbnRzXG5cdFx0XHQnLmthdGV4Jyxcblx0XHRcdCcua2F0ZXgtZGlzcGxheScsXG5cdFx0XHQnLmthdGV4LW1hdGhtbCcsXG5cdFx0XHQnLmthdGV4LWh0bWwnLFxuXHRcdFx0J1tkYXRhLWthdGV4XScsXG5cdFx0XHQnc2NyaXB0W3R5cGU9XCJtYXRoL2thdGV4XCJdJyxcblxuXHRcdC8vIEdlbmVyaWMgbWF0aCBlbGVtZW50cyBhbmQgb3RoZXIgZm9ybWF0c1xuXHRcdFx0J21hdGgnLFxuXHRcdFx0J1tkYXRhLW1hdGhdJyxcblx0XHRcdCdbZGF0YS1sYXRleF0nLFxuXHRcdFx0J1tkYXRhLXRleF0nLFxuXHRcdFx0J2Fubm90YXRpb25bZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiXSdcblx0XHRdLmpvaW4oJywnKSxcblx0XHRlbGVtZW50OiAnbWF0aCcsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdGNvbnN0IG1hdGhEYXRhID0gZ2V0TWF0aE1MRnJvbUVsZW1lbnQoZWwpO1xuXHRcdFx0Y29uc3QgbGF0ZXggPSBnZXRMYXRleEZyb21FbGVtZW50KGVsKTtcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBpc0Jsb2NrRGlzcGxheShlbCk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlQ2xlYW5NYXRoRWwobWF0aERhdGEsIGxhdGV4LCBpc0Jsb2NrKTtcblx0XHR9XG5cdH1cbl07IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5NYXRoTUxUb0xhVGVYPXQoKTplLk1hdGhNTFRvTGFUZVg9dCgpfSh0aGlzLCgoKT0+KCgpPT57dmFyIGU9ezQ1ODI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PU9iamVjdCksdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5mcmVlemU/dC5mcmVlemUoZSk6ZX12YXIgYT1yKHtIVE1MOlwidGV4dC9odG1sXCIsaXNIVE1MOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09YS5IVE1MfSxYTUxfQVBQTElDQVRJT046XCJhcHBsaWNhdGlvbi94bWxcIixYTUxfVEVYVDpcInRleHQveG1sXCIsWE1MX1hIVE1MX0FQUExJQ0FUSU9OOlwiYXBwbGljYXRpb24veGh0bWwreG1sXCIsWE1MX1NWR19JTUFHRTpcImltYWdlL3N2Zyt4bWxcIn0pLG49cih7SFRNTDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixpc0hUTUw6ZnVuY3Rpb24oZSl7cmV0dXJuIGU9PT1uLkhUTUx9LFNWRzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsWE1MOlwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsWE1MTlM6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wifSk7dC5hc3NpZ249ZnVuY3Rpb24oZSx0KXtpZihudWxsPT09ZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcInRhcmdldCBpcyBub3QgYW4gb2JqZWN0XCIpO2Zvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYoZVtyXT10W3JdKTtyZXR1cm4gZX0sdC5maW5kPWZ1bmN0aW9uKGUsdCxyKXtpZih2b2lkIDA9PT1yJiYocj1BcnJheS5wcm90b3R5cGUpLGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHIuZmluZClyZXR1cm4gci5maW5kLmNhbGwoZSx0KTtmb3IodmFyIGE9MDthPGUubGVuZ3RoO2ErKylpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxhKSl7dmFyIG49ZVthXTtpZih0LmNhbGwodm9pZCAwLG4sYSxlKSlyZXR1cm4gbn19LHQuZnJlZXplPXIsdC5NSU1FX1RZUEU9YSx0Lk5BTUVTUEFDRT1ufSw1NzUyOihlLHQscik9Pnt2YXIgYT1yKDQ1ODIpLG49cig0NzIyKSxvPXIoNjU1OSksaT1yKDQ0NjYpLHM9bi5ET01JbXBsZW1lbnRhdGlvbixsPWEuTkFNRVNQQUNFLGM9aS5QYXJzZUVycm9yLHU9aS5YTUxSZWFkZXI7ZnVuY3Rpb24gaChlKXtyZXR1cm4gZS5yZXBsYWNlKC9cXHJbXFxuXFx1MDA4NV0vZyxcIlxcblwiKS5yZXBsYWNlKC9bXFxyXFx1MDA4NVxcdTIwMjhdL2csXCJcXG5cIil9ZnVuY3Rpb24gZChlKXt0aGlzLm9wdGlvbnM9ZXx8e2xvY2F0b3I6e319fWZ1bmN0aW9uIG0oKXt0aGlzLmNkYXRhPSExfWZ1bmN0aW9uIHAoZSx0KXt0LmxpbmVOdW1iZXI9ZS5saW5lTnVtYmVyLHQuY29sdW1uTnVtYmVyPWUuY29sdW1uTnVtYmVyfWZ1bmN0aW9uIGYoZSl7aWYoZSlyZXR1cm5cIlxcbkBcIisoZS5zeXN0ZW1JZHx8XCJcIikrXCIjW2xpbmU6XCIrZS5saW5lTnVtYmVyK1wiLGNvbDpcIitlLmNvbHVtbk51bWJlcitcIl1cIn1mdW5jdGlvbiB4KGUsdCxyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZT9lLnN1YnN0cih0LHIpOmUubGVuZ3RoPj10K3J8fHQ/bmV3IGphdmEubGFuZy5TdHJpbmcoZSx0LHIpK1wiXCI6ZX1mdW5jdGlvbiBnKGUsdCl7ZS5jdXJyZW50RWxlbWVudD9lLmN1cnJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHQpOmUuZG9jLmFwcGVuZENoaWxkKHQpfWQucHJvdG90eXBlLnBhcnNlRnJvbVN0cmluZz1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXMub3B0aW9ucyxhPW5ldyB1LG49ci5kb21CdWlsZGVyfHxuZXcgbSxpPXIuZXJyb3JIYW5kbGVyLHM9ci5sb2NhdG9yLGM9ci54bWxuc3x8e30sZD0vXFwveD9odG1sPyQvLnRlc3QodCkscD1kP28uSFRNTF9FTlRJVElFUzpvLlhNTF9FTlRJVElFUztzJiZuLnNldERvY3VtZW50TG9jYXRvcihzKSxhLmVycm9ySGFuZGxlcj1mdW5jdGlvbihlLHQscil7aWYoIWUpe2lmKHQgaW5zdGFuY2VvZiBtKXJldHVybiB0O2U9dH12YXIgYT17fSxuPWUgaW5zdGFuY2VvZiBGdW5jdGlvbjtmdW5jdGlvbiBvKHQpe3ZhciBvPWVbdF07IW8mJm4mJihvPTI9PWUubGVuZ3RoP2Z1bmN0aW9uKHIpe2UodCxyKX06ZSksYVt0XT1vJiZmdW5jdGlvbihlKXtvKFwiW3htbGRvbSBcIit0K1wiXVxcdFwiK2UrZihyKSl9fHxmdW5jdGlvbigpe319cmV0dXJuIHI9cnx8e30sbyhcIndhcm5pbmdcIiksbyhcImVycm9yXCIpLG8oXCJmYXRhbEVycm9yXCIpLGF9KGksbixzKSxhLmRvbUJ1aWxkZXI9ci5kb21CdWlsZGVyfHxuLGQmJihjW1wiXCJdPWwuSFRNTCksYy54bWw9Yy54bWx8fGwuWE1MO3ZhciB4PXIubm9ybWFsaXplTGluZUVuZGluZ3N8fGg7cmV0dXJuIGUmJlwic3RyaW5nXCI9PXR5cGVvZiBlP2EucGFyc2UoeChlKSxjLHApOmEuZXJyb3JIYW5kbGVyLmVycm9yKFwiaW52YWxpZCBkb2Mgc291cmNlXCIpLG4uZG9jfSxtLnByb3RvdHlwZT17c3RhcnREb2N1bWVudDpmdW5jdGlvbigpe3RoaXMuZG9jPShuZXcgcykuY3JlYXRlRG9jdW1lbnQobnVsbCxudWxsLG51bGwpLHRoaXMubG9jYXRvciYmKHRoaXMuZG9jLmRvY3VtZW50VVJJPXRoaXMubG9jYXRvci5zeXN0ZW1JZCl9LHN0YXJ0RWxlbWVudDpmdW5jdGlvbihlLHQscixhKXt2YXIgbj10aGlzLmRvYyxvPW4uY3JlYXRlRWxlbWVudE5TKGUscnx8dCksaT1hLmxlbmd0aDtnKHRoaXMsbyksdGhpcy5jdXJyZW50RWxlbWVudD1vLHRoaXMubG9jYXRvciYmcCh0aGlzLmxvY2F0b3Isbyk7Zm9yKHZhciBzPTA7czxpO3MrKyl7ZT1hLmdldFVSSShzKTt2YXIgbD1hLmdldFZhbHVlKHMpLGM9KHI9YS5nZXRRTmFtZShzKSxuLmNyZWF0ZUF0dHJpYnV0ZU5TKGUscikpO3RoaXMubG9jYXRvciYmcChhLmdldExvY2F0b3IocyksYyksYy52YWx1ZT1jLm5vZGVWYWx1ZT1sLG8uc2V0QXR0cmlidXRlTm9kZShjKX19LGVuZEVsZW1lbnQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhPXRoaXMuY3VycmVudEVsZW1lbnQ7YS50YWdOYW1lLHRoaXMuY3VycmVudEVsZW1lbnQ9YS5wYXJlbnROb2RlfSxzdGFydFByZWZpeE1hcHBpbmc6ZnVuY3Rpb24oZSx0KXt9LGVuZFByZWZpeE1hcHBpbmc6ZnVuY3Rpb24oZSl7fSxwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmRvYy5jcmVhdGVQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oZSx0KTt0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLHIpLGcodGhpcyxyKX0saWdub3JhYmxlV2hpdGVzcGFjZTpmdW5jdGlvbihlLHQscil7fSxjaGFyYWN0ZXJzOmZ1bmN0aW9uKGUsdCxyKXtpZihlPXguYXBwbHkodGhpcyxhcmd1bWVudHMpKXtpZih0aGlzLmNkYXRhKXZhciBhPXRoaXMuZG9jLmNyZWF0ZUNEQVRBU2VjdGlvbihlKTtlbHNlIGE9dGhpcy5kb2MuY3JlYXRlVGV4dE5vZGUoZSk7dGhpcy5jdXJyZW50RWxlbWVudD90aGlzLmN1cnJlbnRFbGVtZW50LmFwcGVuZENoaWxkKGEpOi9eXFxzKiQvLnRlc3QoZSkmJnRoaXMuZG9jLmFwcGVuZENoaWxkKGEpLHRoaXMubG9jYXRvciYmcCh0aGlzLmxvY2F0b3IsYSl9fSxza2lwcGVkRW50aXR5OmZ1bmN0aW9uKGUpe30sZW5kRG9jdW1lbnQ6ZnVuY3Rpb24oKXt0aGlzLmRvYy5ub3JtYWxpemUoKX0sc2V0RG9jdW1lbnRMb2NhdG9yOmZ1bmN0aW9uKGUpeyh0aGlzLmxvY2F0b3I9ZSkmJihlLmxpbmVOdW1iZXI9MCl9LGNvbW1lbnQ6ZnVuY3Rpb24oZSx0LHIpe2U9eC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGE9dGhpcy5kb2MuY3JlYXRlQ29tbWVudChlKTt0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLGEpLGcodGhpcyxhKX0sc3RhcnRDREFUQTpmdW5jdGlvbigpe3RoaXMuY2RhdGE9ITB9LGVuZENEQVRBOmZ1bmN0aW9uKCl7dGhpcy5jZGF0YT0hMX0sc3RhcnREVEQ6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhPXRoaXMuZG9jLmltcGxlbWVudGF0aW9uO2lmKGEmJmEuY3JlYXRlRG9jdW1lbnRUeXBlKXt2YXIgbj1hLmNyZWF0ZURvY3VtZW50VHlwZShlLHQscik7dGhpcy5sb2NhdG9yJiZwKHRoaXMubG9jYXRvcixuKSxnKHRoaXMsbiksdGhpcy5kb2MuZG9jdHlwZT1ufX0sd2FybmluZzpmdW5jdGlvbihlKXtjb25zb2xlLndhcm4oXCJbeG1sZG9tIHdhcm5pbmddXFx0XCIrZSxmKHRoaXMubG9jYXRvcikpfSxlcnJvcjpmdW5jdGlvbihlKXtjb25zb2xlLmVycm9yKFwiW3htbGRvbSBlcnJvcl1cXHRcIitlLGYodGhpcy5sb2NhdG9yKSl9LGZhdGFsRXJyb3I6ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IGMoZSx0aGlzLmxvY2F0b3IpfX0sXCJlbmREVEQsc3RhcnRFbnRpdHksZW5kRW50aXR5LGF0dHJpYnV0ZURlY2wsZWxlbWVudERlY2wsZXh0ZXJuYWxFbnRpdHlEZWNsLGludGVybmFsRW50aXR5RGVjbCxyZXNvbHZlRW50aXR5LGdldEV4dGVybmFsU3Vic2V0LG5vdGF0aW9uRGVjbCx1bnBhcnNlZEVudGl0eURlY2xcIi5yZXBsYWNlKC9cXHcrL2csKGZ1bmN0aW9uKGUpe20ucHJvdG90eXBlW2VdPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9fSkpLHQuRE9NUGFyc2VyPWR9LDQ3MjI6KGUsdCxyKT0+e3ZhciBhPXIoNDU4Miksbj1hLmZpbmQsbz1hLk5BTUVTUEFDRTtmdW5jdGlvbiBpKGUpe3JldHVyblwiXCIhPT1lfWZ1bmN0aW9uIHMoZSx0KXtyZXR1cm4gZS5oYXNPd25Qcm9wZXJ0eSh0KXx8KGVbdF09ITApLGV9ZnVuY3Rpb24gbChlKXtpZighZSlyZXR1cm5bXTt2YXIgdD1mdW5jdGlvbihlKXtyZXR1cm4gZT9lLnNwbGl0KC9bXFx0XFxuXFxmXFxyIF0rLykuZmlsdGVyKGkpOltdfShlKTtyZXR1cm4gT2JqZWN0LmtleXModC5yZWR1Y2Uocyx7fSkpfWZ1bmN0aW9uIGMoZSx0KXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9ZnVuY3Rpb24gdShlLHQpe3ZhciByPWUucHJvdG90eXBlO2lmKCEociBpbnN0YW5jZW9mIHQpKXtmdW5jdGlvbiBhKCl7fWEucHJvdG90eXBlPXQucHJvdG90eXBlLGMocixhPW5ldyBhKSxlLnByb3RvdHlwZT1yPWF9ci5jb25zdHJ1Y3RvciE9ZSYmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUmJmNvbnNvbGUuZXJyb3IoXCJ1bmtub3duIENsYXNzOlwiK2UpLHIuY29uc3RydWN0b3I9ZSl9dmFyIGg9e30sZD1oLkVMRU1FTlRfTk9ERT0xLG09aC5BVFRSSUJVVEVfTk9ERT0yLHA9aC5URVhUX05PREU9MyxmPWguQ0RBVEFfU0VDVElPTl9OT0RFPTQseD1oLkVOVElUWV9SRUZFUkVOQ0VfTk9ERT01LGc9aC5FTlRJVFlfTk9ERT02LHc9aC5QUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU9NyxiPWguQ09NTUVOVF9OT0RFPTgsdj1oLkRPQ1VNRU5UX05PREU9OSxDPWguRE9DVU1FTlRfVFlQRV9OT0RFPTEwLEE9aC5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFPTExLEU9aC5OT1RBVElPTl9OT0RFPTEyLF89e30seT17fSxxPShfLklOREVYX1NJWkVfRVJSPSh5WzFdPVwiSW5kZXggc2l6ZSBlcnJvclwiLDEpLF8uRE9NU1RSSU5HX1NJWkVfRVJSPSh5WzJdPVwiRE9NU3RyaW5nIHNpemUgZXJyb3JcIiwyKSxfLkhJRVJBUkNIWV9SRVFVRVNUX0VSUj0oeVszXT1cIkhpZXJhcmNoeSByZXF1ZXN0IGVycm9yXCIsMykpLEQ9KF8uV1JPTkdfRE9DVU1FTlRfRVJSPSh5WzRdPVwiV3JvbmcgZG9jdW1lbnRcIiw0KSxfLklOVkFMSURfQ0hBUkFDVEVSX0VSUj0oeVs1XT1cIkludmFsaWQgY2hhcmFjdGVyXCIsNSksXy5OT19EQVRBX0FMTE9XRURfRVJSPSh5WzZdPVwiTm8gZGF0YSBhbGxvd2VkXCIsNiksXy5OT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlI9KHlbN109XCJObyBtb2RpZmljYXRpb24gYWxsb3dlZFwiLDcpLF8uTk9UX0ZPVU5EX0VSUj0oeVs4XT1cIk5vdCBmb3VuZFwiLDgpKSxNPShfLk5PVF9TVVBQT1JURURfRVJSPSh5WzldPVwiTm90IHN1cHBvcnRlZFwiLDkpLF8uSU5VU0VfQVRUUklCVVRFX0VSUj0oeVsxMF09XCJBdHRyaWJ1dGUgaW4gdXNlXCIsMTApKTtmdW5jdGlvbiBUKGUsdCl7aWYodCBpbnN0YW5jZW9mIEVycm9yKXZhciByPXQ7ZWxzZSByPXRoaXMsRXJyb3IuY2FsbCh0aGlzLHlbZV0pLHRoaXMubWVzc2FnZT15W2VdLEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLFQpO3JldHVybiByLmNvZGU9ZSx0JiYodGhpcy5tZXNzYWdlPXRoaXMubWVzc2FnZStcIjogXCIrdCkscn1mdW5jdGlvbiBOKCl7fWZ1bmN0aW9uIE8oZSx0KXt0aGlzLl9ub2RlPWUsdGhpcy5fcmVmcmVzaD10LEwodGhpcyl9ZnVuY3Rpb24gTChlKXt2YXIgdD1lLl9ub2RlLl9pbmN8fGUuX25vZGUub3duZXJEb2N1bWVudC5faW5jO2lmKGUuX2luYyE9PXQpe3ZhciByPWUuX3JlZnJlc2goZS5fbm9kZSk7aWYod2UoZSxcImxlbmd0aFwiLHIubGVuZ3RoKSwhZS4kJGxlbmd0aHx8ci5sZW5ndGg8ZS4kJGxlbmd0aClmb3IodmFyIGE9ci5sZW5ndGg7YSBpbiBlO2ErKylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxhKSYmZGVsZXRlIGVbYV07YyhyLGUpLGUuX2luYz10fX1mdW5jdGlvbiBCKCl7fWZ1bmN0aW9uIFMoZSx0KXtmb3IodmFyIHI9ZS5sZW5ndGg7ci0tOylpZihlW3JdPT09dClyZXR1cm4gcn1mdW5jdGlvbiBGKGUsdCxyLGEpe2lmKGE/dFtTKHQsYSldPXI6dFt0Lmxlbmd0aCsrXT1yLGUpe3Iub3duZXJFbGVtZW50PWU7dmFyIG49ZS5vd25lckRvY3VtZW50O24mJihhJiZWKG4sZSxhKSxmdW5jdGlvbihlLHQscil7ZSYmZS5faW5jKyssci5uYW1lc3BhY2VVUkk9PT1vLlhNTE5TJiYodC5fbnNNYXBbci5wcmVmaXg/ci5sb2NhbE5hbWU6XCJcIl09ci52YWx1ZSl9KG4sZSxyKSl9fWZ1bmN0aW9uIFAoZSx0LHIpe3ZhciBhPVModCxyKTtpZighKGE+PTApKXRocm93IG5ldyBUKEQsbmV3IEVycm9yKGUudGFnTmFtZStcIkBcIityKSk7Zm9yKHZhciBuPXQubGVuZ3RoLTE7YTxuOyl0W2FdPXRbKythXTtpZih0Lmxlbmd0aD1uLGUpe3ZhciBvPWUub3duZXJEb2N1bWVudDtvJiYoVihvLGUsciksci5vd25lckVsZW1lbnQ9bnVsbCl9fWZ1bmN0aW9uIGsoKXt9ZnVuY3Rpb24gUigpe31mdW5jdGlvbiBJKGUpe3JldHVybihcIjxcIj09ZT9cIiZsdDtcIjpcIj5cIj09ZSYmXCImZ3Q7XCIpfHxcIiZcIj09ZSYmXCImYW1wO1wifHwnXCInPT1lJiZcIiZxdW90O1wifHxcIiYjXCIrZS5jaGFyQ29kZUF0KCkrXCI7XCJ9ZnVuY3Rpb24gVShlLHQpe2lmKHQoZSkpcmV0dXJuITA7aWYoZT1lLmZpcnN0Q2hpbGQpZG97aWYoVShlLHQpKXJldHVybiEwfXdoaWxlKGU9ZS5uZXh0U2libGluZyl9ZnVuY3Rpb24gaigpe3RoaXMub3duZXJEb2N1bWVudD10aGlzfWZ1bmN0aW9uIFYoZSx0LHIsYSl7ZSYmZS5faW5jKyssci5uYW1lc3BhY2VVUkk9PT1vLlhNTE5TJiZkZWxldGUgdC5fbnNNYXBbci5wcmVmaXg/ci5sb2NhbE5hbWU6XCJcIl19ZnVuY3Rpb24gRyhlLHQscil7aWYoZSYmZS5faW5jKXtlLl9pbmMrKzt2YXIgYT10LmNoaWxkTm9kZXM7aWYocilhW2EubGVuZ3RoKytdPXI7ZWxzZXtmb3IodmFyIG49dC5maXJzdENoaWxkLG89MDtuOylhW28rK109bixuPW4ubmV4dFNpYmxpbmc7YS5sZW5ndGg9byxkZWxldGUgYVthLmxlbmd0aF19fX1mdW5jdGlvbiAkKGUsdCl7dmFyIHI9dC5wcmV2aW91c1NpYmxpbmcsYT10Lm5leHRTaWJsaW5nO3JldHVybiByP3IubmV4dFNpYmxpbmc9YTplLmZpcnN0Q2hpbGQ9YSxhP2EucHJldmlvdXNTaWJsaW5nPXI6ZS5sYXN0Q2hpbGQ9cix0LnBhcmVudE5vZGU9bnVsbCx0LnByZXZpb3VzU2libGluZz1udWxsLHQubmV4dFNpYmxpbmc9bnVsbCxHKGUub3duZXJEb2N1bWVudCxlKSx0fWZ1bmN0aW9uIFgoZSl7cmV0dXJuIGUmJmUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX1RZUEVfTk9ERX1mdW5jdGlvbiBIKGUpe3JldHVybiBlJiZlLm5vZGVUeXBlPT09Ui5FTEVNRU5UX05PREV9ZnVuY3Rpb24gVyhlKXtyZXR1cm4gZSYmZS5ub2RlVHlwZT09PVIuVEVYVF9OT0RFfWZ1bmN0aW9uIHooZSx0KXt2YXIgcj1lLmNoaWxkTm9kZXN8fFtdO2lmKG4ocixIKXx8WCh0KSlyZXR1cm4hMTt2YXIgYT1uKHIsWCk7cmV0dXJuISh0JiZhJiZyLmluZGV4T2YoYSk+ci5pbmRleE9mKHQpKX1mdW5jdGlvbiBZKGUsdCl7dmFyIHI9ZS5jaGlsZE5vZGVzfHxbXTtpZihuKHIsKGZ1bmN0aW9uKGUpe3JldHVybiBIKGUpJiZlIT09dH0pKSlyZXR1cm4hMTt2YXIgYT1uKHIsWCk7cmV0dXJuISh0JiZhJiZyLmluZGV4T2YoYSk+ci5pbmRleE9mKHQpKX1mdW5jdGlvbiBKKGUsdCxyKXt2YXIgYT1lLmNoaWxkTm9kZXN8fFtdLG89dC5jaGlsZE5vZGVzfHxbXTtpZih0Lm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXt2YXIgaT1vLmZpbHRlcihIKTtpZihpLmxlbmd0aD4xfHxuKG8sVykpdGhyb3cgbmV3IFQocSxcIk1vcmUgdGhhbiBvbmUgZWxlbWVudCBvciB0ZXh0IGluIGZyYWdtZW50XCIpO2lmKDE9PT1pLmxlbmd0aCYmIXooZSxyKSl0aHJvdyBuZXcgVChxLFwiRWxlbWVudCBpbiBmcmFnbWVudCBjYW4gbm90IGJlIGluc2VydGVkIGJlZm9yZSBkb2N0eXBlXCIpfWlmKEgodCkmJiF6KGUscikpdGhyb3cgbmV3IFQocSxcIk9ubHkgb25lIGVsZW1lbnQgY2FuIGJlIGFkZGVkIGFuZCBvbmx5IGFmdGVyIGRvY3R5cGVcIik7aWYoWCh0KSl7aWYobihhLFgpKXRocm93IG5ldyBUKHEsXCJPbmx5IG9uZSBkb2N0eXBlIGlzIGFsbG93ZWRcIik7dmFyIHM9bihhLEgpO2lmKHImJmEuaW5kZXhPZihzKTxhLmluZGV4T2YocikpdGhyb3cgbmV3IFQocSxcIkRvY3R5cGUgY2FuIG9ubHkgYmUgaW5zZXJ0ZWQgYmVmb3JlIGFuIGVsZW1lbnRcIik7aWYoIXImJnMpdGhyb3cgbmV3IFQocSxcIkRvY3R5cGUgY2FuIG5vdCBiZSBhcHBlbmRlZCBzaW5jZSBlbGVtZW50IGlzIHByZXNlbnRcIil9fWZ1bmN0aW9uIFooZSx0LHIpe3ZhciBhPWUuY2hpbGROb2Rlc3x8W10sbz10LmNoaWxkTm9kZXN8fFtdO2lmKHQubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe3ZhciBpPW8uZmlsdGVyKEgpO2lmKGkubGVuZ3RoPjF8fG4obyxXKSl0aHJvdyBuZXcgVChxLFwiTW9yZSB0aGFuIG9uZSBlbGVtZW50IG9yIHRleHQgaW4gZnJhZ21lbnRcIik7aWYoMT09PWkubGVuZ3RoJiYhWShlLHIpKXRocm93IG5ldyBUKHEsXCJFbGVtZW50IGluIGZyYWdtZW50IGNhbiBub3QgYmUgaW5zZXJ0ZWQgYmVmb3JlIGRvY3R5cGVcIil9aWYoSCh0KSYmIVkoZSxyKSl0aHJvdyBuZXcgVChxLFwiT25seSBvbmUgZWxlbWVudCBjYW4gYmUgYWRkZWQgYW5kIG9ubHkgYWZ0ZXIgZG9jdHlwZVwiKTtpZihYKHQpKXtpZihuKGEsKGZ1bmN0aW9uKGUpe3JldHVybiBYKGUpJiZlIT09cn0pKSl0aHJvdyBuZXcgVChxLFwiT25seSBvbmUgZG9jdHlwZSBpcyBhbGxvd2VkXCIpO3ZhciBzPW4oYSxIKTtpZihyJiZhLmluZGV4T2Yocyk8YS5pbmRleE9mKHIpKXRocm93IG5ldyBUKHEsXCJEb2N0eXBlIGNhbiBvbmx5IGJlIGluc2VydGVkIGJlZm9yZSBhbiBlbGVtZW50XCIpfX1mdW5jdGlvbiBRKGUsdCxyLGEpeyhmdW5jdGlvbihlLHQscil7aWYoIWZ1bmN0aW9uKGUpe3JldHVybiBlJiYoZS5ub2RlVHlwZT09PVIuRE9DVU1FTlRfTk9ERXx8ZS5ub2RlVHlwZT09PVIuRE9DVU1FTlRfRlJBR01FTlRfTk9ERXx8ZS5ub2RlVHlwZT09PVIuRUxFTUVOVF9OT0RFKX0oZSkpdGhyb3cgbmV3IFQocSxcIlVuZXhwZWN0ZWQgcGFyZW50IG5vZGUgdHlwZSBcIitlLm5vZGVUeXBlKTtpZihyJiZyLnBhcmVudE5vZGUhPT1lKXRocm93IG5ldyBUKEQsXCJjaGlsZCBub3QgaW4gcGFyZW50XCIpO2lmKCFmdW5jdGlvbihlKXtyZXR1cm4gZSYmKEgoZSl8fFcoZSl8fFgoZSl8fGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLkNPTU1FTlRfTk9ERXx8ZS5ub2RlVHlwZT09PVIuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFKX0odCl8fFgodCkmJmUubm9kZVR5cGUhPT1SLkRPQ1VNRU5UX05PREUpdGhyb3cgbmV3IFQocSxcIlVuZXhwZWN0ZWQgbm9kZSB0eXBlIFwiK3Qubm9kZVR5cGUrXCIgZm9yIHBhcmVudCBub2RlIHR5cGUgXCIrZS5ub2RlVHlwZSl9KShlLHQsciksZS5ub2RlVHlwZT09PVIuRE9DVU1FTlRfTk9ERSYmKGF8fEopKGUsdCxyKTt2YXIgbj10LnBhcmVudE5vZGU7aWYobiYmbi5yZW1vdmVDaGlsZCh0KSx0Lm5vZGVUeXBlPT09QSl7dmFyIG89dC5maXJzdENoaWxkO2lmKG51bGw9PW8pcmV0dXJuIHQ7dmFyIGk9dC5sYXN0Q2hpbGR9ZWxzZSBvPWk9dDt2YXIgcz1yP3IucHJldmlvdXNTaWJsaW5nOmUubGFzdENoaWxkO28ucHJldmlvdXNTaWJsaW5nPXMsaS5uZXh0U2libGluZz1yLHM/cy5uZXh0U2libGluZz1vOmUuZmlyc3RDaGlsZD1vLG51bGw9PXI/ZS5sYXN0Q2hpbGQ9aTpyLnByZXZpb3VzU2libGluZz1pO2Rve28ucGFyZW50Tm9kZT1lfXdoaWxlKG8hPT1pJiYobz1vLm5leHRTaWJsaW5nKSk7cmV0dXJuIEcoZS5vd25lckRvY3VtZW50fHxlLGUpLHQubm9kZVR5cGU9PUEmJih0LmZpcnN0Q2hpbGQ9dC5sYXN0Q2hpbGQ9bnVsbCksdH1mdW5jdGlvbiBLKCl7dGhpcy5fbnNNYXA9e319ZnVuY3Rpb24gZWUoKXt9ZnVuY3Rpb24gdGUoKXt9ZnVuY3Rpb24gcmUoKXt9ZnVuY3Rpb24gYWUoKXt9ZnVuY3Rpb24gbmUoKXt9ZnVuY3Rpb24gb2UoKXt9ZnVuY3Rpb24gaWUoKXt9ZnVuY3Rpb24gc2UoKXt9ZnVuY3Rpb24gbGUoKXt9ZnVuY3Rpb24gY2UoKXt9ZnVuY3Rpb24gdWUoKXt9ZnVuY3Rpb24gaGUoKXt9ZnVuY3Rpb24gZGUoZSx0KXt2YXIgcj1bXSxhPTk9PXRoaXMubm9kZVR5cGUmJnRoaXMuZG9jdW1lbnRFbGVtZW50fHx0aGlzLG49YS5wcmVmaXgsbz1hLm5hbWVzcGFjZVVSSTtpZihvJiZudWxsPT1uJiZudWxsPT0obj1hLmxvb2t1cFByZWZpeChvKSkpdmFyIGk9W3tuYW1lc3BhY2U6byxwcmVmaXg6bnVsbH1dO3JldHVybiBmZSh0aGlzLHIsZSx0LGkpLHIuam9pbihcIlwiKX1mdW5jdGlvbiBtZShlLHQscil7dmFyIGE9ZS5wcmVmaXh8fFwiXCIsbj1lLm5hbWVzcGFjZVVSSTtpZighbilyZXR1cm4hMTtpZihcInhtbFwiPT09YSYmbj09PW8uWE1MfHxuPT09by5YTUxOUylyZXR1cm4hMTtmb3IodmFyIGk9ci5sZW5ndGg7aS0tOyl7dmFyIHM9cltpXTtpZihzLnByZWZpeD09PWEpcmV0dXJuIHMubmFtZXNwYWNlIT09bn1yZXR1cm4hMH1mdW5jdGlvbiBwZShlLHQscil7ZS5wdXNoKFwiIFwiLHQsJz1cIicsci5yZXBsYWNlKC9bPD4mXCJcXHRcXG5cXHJdL2csSSksJ1wiJyl9ZnVuY3Rpb24gZmUoZSx0LHIsYSxuKXtpZihufHwobj1bXSksYSl7aWYoIShlPWEoZSkpKXJldHVybjtpZihcInN0cmluZ1wiPT10eXBlb2YgZSlyZXR1cm4gdm9pZCB0LnB1c2goZSl9c3dpdGNoKGUubm9kZVR5cGUpe2Nhc2UgZDp2YXIgaT1lLmF0dHJpYnV0ZXMscz1pLmxlbmd0aCxsPWUuZmlyc3RDaGlsZCxjPWUudGFnTmFtZSx1PWM7aWYoIShyPW8uaXNIVE1MKGUubmFtZXNwYWNlVVJJKXx8cikmJiFlLnByZWZpeCYmZS5uYW1lc3BhY2VVUkkpe2Zvcih2YXIgaCxnPTA7ZzxpLmxlbmd0aDtnKyspaWYoXCJ4bWxuc1wiPT09aS5pdGVtKGcpLm5hbWUpe2g9aS5pdGVtKGcpLnZhbHVlO2JyZWFrfWlmKCFoKWZvcih2YXIgRT1uLmxlbmd0aC0xO0U+PTA7RS0tKWlmKFwiXCI9PT0oXz1uW0VdKS5wcmVmaXgmJl8ubmFtZXNwYWNlPT09ZS5uYW1lc3BhY2VVUkkpe2g9Xy5uYW1lc3BhY2U7YnJlYWt9aWYoaCE9PWUubmFtZXNwYWNlVVJJKWZvcihFPW4ubGVuZ3RoLTE7RT49MDtFLS0pe3ZhciBfO2lmKChfPW5bRV0pLm5hbWVzcGFjZT09PWUubmFtZXNwYWNlVVJJKXtfLnByZWZpeCYmKHU9Xy5wcmVmaXgrXCI6XCIrYyk7YnJlYWt9fX10LnB1c2goXCI8XCIsdSk7Zm9yKHZhciB5PTA7eTxzO3krKylcInhtbG5zXCI9PShxPWkuaXRlbSh5KSkucHJlZml4P24ucHVzaCh7cHJlZml4OnEubG9jYWxOYW1lLG5hbWVzcGFjZTpxLnZhbHVlfSk6XCJ4bWxuc1wiPT1xLm5vZGVOYW1lJiZuLnB1c2goe3ByZWZpeDpcIlwiLG5hbWVzcGFjZTpxLnZhbHVlfSk7Zm9yKHk9MDt5PHM7eSsrKXt2YXIgcSxELE07bWUocT1pLml0ZW0oeSksMCxuKSYmKHBlKHQsKEQ9cS5wcmVmaXh8fFwiXCIpP1wieG1sbnM6XCIrRDpcInhtbG5zXCIsTT1xLm5hbWVzcGFjZVVSSSksbi5wdXNoKHtwcmVmaXg6RCxuYW1lc3BhY2U6TX0pKSxmZShxLHQscixhLG4pfWlmKGM9PT11JiZtZShlLDAsbikmJihwZSh0LChEPWUucHJlZml4fHxcIlwiKT9cInhtbG5zOlwiK0Q6XCJ4bWxuc1wiLE09ZS5uYW1lc3BhY2VVUkkpLG4ucHVzaCh7cHJlZml4OkQsbmFtZXNwYWNlOk19KSksbHx8ciYmIS9eKD86bWV0YXxsaW5rfGltZ3xicnxocnxpbnB1dCkkL2kudGVzdChjKSl7aWYodC5wdXNoKFwiPlwiKSxyJiYvXnNjcmlwdCQvaS50ZXN0KGMpKWZvcig7bDspbC5kYXRhP3QucHVzaChsLmRhdGEpOmZlKGwsdCxyLGEsbi5zbGljZSgpKSxsPWwubmV4dFNpYmxpbmc7ZWxzZSBmb3IoO2w7KWZlKGwsdCxyLGEsbi5zbGljZSgpKSxsPWwubmV4dFNpYmxpbmc7dC5wdXNoKFwiPC9cIix1LFwiPlwiKX1lbHNlIHQucHVzaChcIi8+XCIpO3JldHVybjtjYXNlIHY6Y2FzZSBBOmZvcihsPWUuZmlyc3RDaGlsZDtsOylmZShsLHQscixhLG4uc2xpY2UoKSksbD1sLm5leHRTaWJsaW5nO3JldHVybjtjYXNlIG06cmV0dXJuIHBlKHQsZS5uYW1lLGUudmFsdWUpO2Nhc2UgcDpyZXR1cm4gdC5wdXNoKGUuZGF0YS5yZXBsYWNlKC9bPCY+XS9nLEkpKTtjYXNlIGY6cmV0dXJuIHQucHVzaChcIjwhW0NEQVRBW1wiLGUuZGF0YSxcIl1dPlwiKTtjYXNlIGI6cmV0dXJuIHQucHVzaChcIlxceDNjIS0tXCIsZS5kYXRhLFwiLS1cXHgzZVwiKTtjYXNlIEM6dmFyIFQ9ZS5wdWJsaWNJZCxOPWUuc3lzdGVtSWQ7aWYodC5wdXNoKFwiPCFET0NUWVBFIFwiLGUubmFtZSksVCl0LnB1c2goXCIgUFVCTElDIFwiLFQpLE4mJlwiLlwiIT1OJiZ0LnB1c2goXCIgXCIsTiksdC5wdXNoKFwiPlwiKTtlbHNlIGlmKE4mJlwiLlwiIT1OKXQucHVzaChcIiBTWVNURU0gXCIsTixcIj5cIik7ZWxzZXt2YXIgTz1lLmludGVybmFsU3Vic2V0O08mJnQucHVzaChcIiBbXCIsTyxcIl1cIiksdC5wdXNoKFwiPlwiKX1yZXR1cm47Y2FzZSB3OnJldHVybiB0LnB1c2goXCI8P1wiLGUudGFyZ2V0LFwiIFwiLGUuZGF0YSxcIj8+XCIpO2Nhc2UgeDpyZXR1cm4gdC5wdXNoKFwiJlwiLGUubm9kZU5hbWUsXCI7XCIpO2RlZmF1bHQ6dC5wdXNoKFwiPz9cIixlLm5vZGVOYW1lKX19ZnVuY3Rpb24geGUoZSx0LHIpe3ZhciBhO3N3aXRjaCh0Lm5vZGVUeXBlKXtjYXNlIGQ6KGE9dC5jbG9uZU5vZGUoITEpKS5vd25lckRvY3VtZW50PWU7Y2FzZSBBOmJyZWFrO2Nhc2UgbTpyPSEwfWlmKGF8fChhPXQuY2xvbmVOb2RlKCExKSksYS5vd25lckRvY3VtZW50PWUsYS5wYXJlbnROb2RlPW51bGwscilmb3IodmFyIG49dC5maXJzdENoaWxkO247KWEuYXBwZW5kQ2hpbGQoeGUoZSxuLHIpKSxuPW4ubmV4dFNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZ2UoZSx0LHIpe3ZhciBhPW5ldyB0LmNvbnN0cnVjdG9yO2Zvcih2YXIgbiBpbiB0KWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pKXt2YXIgbz10W25dO1wib2JqZWN0XCIhPXR5cGVvZiBvJiZvIT1hW25dJiYoYVtuXT1vKX1zd2l0Y2godC5jaGlsZE5vZGVzJiYoYS5jaGlsZE5vZGVzPW5ldyBOKSxhLm93bmVyRG9jdW1lbnQ9ZSxhLm5vZGVUeXBlKXtjYXNlIGQ6dmFyIGk9dC5hdHRyaWJ1dGVzLHM9YS5hdHRyaWJ1dGVzPW5ldyBCLGw9aS5sZW5ndGg7cy5fb3duZXJFbGVtZW50PWE7Zm9yKHZhciBjPTA7YzxsO2MrKylhLnNldEF0dHJpYnV0ZU5vZGUoZ2UoZSxpLml0ZW0oYyksITApKTticmVhaztjYXNlIG06cj0hMH1pZihyKWZvcih2YXIgdT10LmZpcnN0Q2hpbGQ7dTspYS5hcHBlbmRDaGlsZChnZShlLHUscikpLHU9dS5uZXh0U2libGluZztyZXR1cm4gYX1mdW5jdGlvbiB3ZShlLHQscil7ZVt0XT1yfV8uSU5WQUxJRF9TVEFURV9FUlI9KHlbMTFdPVwiSW52YWxpZCBzdGF0ZVwiLDExKSxfLlNZTlRBWF9FUlI9KHlbMTJdPVwiU3ludGF4IGVycm9yXCIsMTIpLF8uSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSPSh5WzEzXT1cIkludmFsaWQgbW9kaWZpY2F0aW9uXCIsMTMpLF8uTkFNRVNQQUNFX0VSUj0oeVsxNF09XCJJbnZhbGlkIG5hbWVzcGFjZVwiLDE0KSxfLklOVkFMSURfQUNDRVNTX0VSUj0oeVsxNV09XCJJbnZhbGlkIGFjY2Vzc1wiLDE1KSxULnByb3RvdHlwZT1FcnJvci5wcm90b3R5cGUsYyhfLFQpLE4ucHJvdG90eXBlPXtsZW5ndGg6MCxpdGVtOmZ1bmN0aW9uKGUpe3JldHVybiBlPj0wJiZlPHRoaXMubGVuZ3RoP3RoaXNbZV06bnVsbH0sdG9TdHJpbmc6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9W10sYT0wO2E8dGhpcy5sZW5ndGg7YSsrKWZlKHRoaXNbYV0scixlLHQpO3JldHVybiByLmpvaW4oXCJcIil9LGZpbHRlcjpmdW5jdGlvbihlKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMsZSl9LGluZGV4T2Y6ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcyxlKX19LE8ucHJvdG90eXBlLml0ZW09ZnVuY3Rpb24oZSl7cmV0dXJuIEwodGhpcyksdGhpc1tlXXx8bnVsbH0sdShPLE4pLEIucHJvdG90eXBlPXtsZW5ndGg6MCxpdGVtOk4ucHJvdG90eXBlLml0ZW0sZ2V0TmFtZWRJdGVtOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD10aGlzLmxlbmd0aDt0LS07KXt2YXIgcj10aGlzW3RdO2lmKHIubm9kZU5hbWU9PWUpcmV0dXJuIHJ9fSxzZXROYW1lZEl0ZW06ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5vd25lckVsZW1lbnQ7aWYodCYmdCE9dGhpcy5fb3duZXJFbGVtZW50KXRocm93IG5ldyBUKE0pO3ZhciByPXRoaXMuZ2V0TmFtZWRJdGVtKGUubm9kZU5hbWUpO3JldHVybiBGKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGUscikscn0sc2V0TmFtZWRJdGVtTlM6ZnVuY3Rpb24oZSl7dmFyIHQscj1lLm93bmVyRWxlbWVudDtpZihyJiZyIT10aGlzLl9vd25lckVsZW1lbnQpdGhyb3cgbmV3IFQoTSk7cmV0dXJuIHQ9dGhpcy5nZXROYW1lZEl0ZW1OUyhlLm5hbWVzcGFjZVVSSSxlLmxvY2FsTmFtZSksRih0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxlLHQpLHR9LHJlbW92ZU5hbWVkSXRlbTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldE5hbWVkSXRlbShlKTtyZXR1cm4gUCh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyx0KSx0fSxyZW1vdmVOYW1lZEl0ZW1OUzpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0TmFtZWRJdGVtTlMoZSx0KTtyZXR1cm4gUCh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxyKSxyfSxnZXROYW1lZEl0ZW1OUzpmdW5jdGlvbihlLHQpe2Zvcih2YXIgcj10aGlzLmxlbmd0aDtyLS07KXt2YXIgYT10aGlzW3JdO2lmKGEubG9jYWxOYW1lPT10JiZhLm5hbWVzcGFjZVVSST09ZSlyZXR1cm4gYX1yZXR1cm4gbnVsbH19LGsucHJvdG90eXBlPXtoYXNGZWF0dXJlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuITB9LGNyZWF0ZURvY3VtZW50OmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1uZXcgajtpZihhLmltcGxlbWVudGF0aW9uPXRoaXMsYS5jaGlsZE5vZGVzPW5ldyBOLGEuZG9jdHlwZT1yfHxudWxsLHImJmEuYXBwZW5kQ2hpbGQociksdCl7dmFyIG49YS5jcmVhdGVFbGVtZW50TlMoZSx0KTthLmFwcGVuZENoaWxkKG4pfXJldHVybiBhfSxjcmVhdGVEb2N1bWVudFR5cGU6ZnVuY3Rpb24oZSx0LHIpe3ZhciBhPW5ldyBvZTtyZXR1cm4gYS5uYW1lPWUsYS5ub2RlTmFtZT1lLGEucHVibGljSWQ9dHx8XCJcIixhLnN5c3RlbUlkPXJ8fFwiXCIsYX19LFIucHJvdG90eXBlPXtmaXJzdENoaWxkOm51bGwsbGFzdENoaWxkOm51bGwscHJldmlvdXNTaWJsaW5nOm51bGwsbmV4dFNpYmxpbmc6bnVsbCxhdHRyaWJ1dGVzOm51bGwscGFyZW50Tm9kZTpudWxsLGNoaWxkTm9kZXM6bnVsbCxvd25lckRvY3VtZW50Om51bGwsbm9kZVZhbHVlOm51bGwsbmFtZXNwYWNlVVJJOm51bGwscHJlZml4Om51bGwsbG9jYWxOYW1lOm51bGwsaW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIFEodGhpcyxlLHQpfSxyZXBsYWNlQ2hpbGQ6ZnVuY3Rpb24oZSx0KXtRKHRoaXMsZSx0LFopLHQmJnRoaXMucmVtb3ZlQ2hpbGQodCl9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiAkKHRoaXMsZSl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmluc2VydEJlZm9yZShlLG51bGwpfSxoYXNDaGlsZE5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPXRoaXMuZmlyc3RDaGlsZH0sY2xvbmVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiBnZSh0aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsdGhpcyxlKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciBlPXRoaXMuZmlyc3RDaGlsZDtlOyl7dmFyIHQ9ZS5uZXh0U2libGluZzt0JiZ0Lm5vZGVUeXBlPT1wJiZlLm5vZGVUeXBlPT1wPyh0aGlzLnJlbW92ZUNoaWxkKHQpLGUuYXBwZW5kRGF0YSh0LmRhdGEpKTooZS5ub3JtYWxpemUoKSxlPXQpfX0saXNTdXBwb3J0ZWQ6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoZSx0KX0saGFzQXR0cmlidXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoPjB9LGxvb2t1cFByZWZpeDpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpczt0Oyl7dmFyIHI9dC5fbnNNYXA7aWYocilmb3IodmFyIGEgaW4gcilpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixhKSYmclthXT09PWUpcmV0dXJuIGE7dD10Lm5vZGVUeXBlPT1tP3Qub3duZXJEb2N1bWVudDp0LnBhcmVudE5vZGV9cmV0dXJuIG51bGx9LGxvb2t1cE5hbWVzcGFjZVVSSTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpczt0Oyl7dmFyIHI9dC5fbnNNYXA7aWYociYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsZSkpcmV0dXJuIHJbZV07dD10Lm5vZGVUeXBlPT1tP3Qub3duZXJEb2N1bWVudDp0LnBhcmVudE5vZGV9cmV0dXJuIG51bGx9LGlzRGVmYXVsdE5hbWVzcGFjZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09dGhpcy5sb29rdXBQcmVmaXgoZSl9fSxjKGgsUiksYyhoLFIucHJvdG90eXBlKSxqLnByb3RvdHlwZT17bm9kZU5hbWU6XCIjZG9jdW1lbnRcIixub2RlVHlwZTp2LGRvY3R5cGU6bnVsbCxkb2N1bWVudEVsZW1lbnQ6bnVsbCxfaW5jOjEsaW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGUsdCl7aWYoZS5ub2RlVHlwZT09QSl7Zm9yKHZhciByPWUuZmlyc3RDaGlsZDtyOyl7dmFyIGE9ci5uZXh0U2libGluZzt0aGlzLmluc2VydEJlZm9yZShyLHQpLHI9YX1yZXR1cm4gZX1yZXR1cm4gUSh0aGlzLGUsdCksZS5vd25lckRvY3VtZW50PXRoaXMsbnVsbD09PXRoaXMuZG9jdW1lbnRFbGVtZW50JiZlLm5vZGVUeXBlPT09ZCYmKHRoaXMuZG9jdW1lbnRFbGVtZW50PWUpLGV9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmRvY3VtZW50RWxlbWVudD09ZSYmKHRoaXMuZG9jdW1lbnRFbGVtZW50PW51bGwpLCQodGhpcyxlKX0scmVwbGFjZUNoaWxkOmZ1bmN0aW9uKGUsdCl7USh0aGlzLGUsdCxaKSxlLm93bmVyRG9jdW1lbnQ9dGhpcyx0JiZ0aGlzLnJlbW92ZUNoaWxkKHQpLEgoZSkmJih0aGlzLmRvY3VtZW50RWxlbWVudD1lKX0saW1wb3J0Tm9kZTpmdW5jdGlvbihlLHQpe3JldHVybiB4ZSh0aGlzLGUsdCl9LGdldEVsZW1lbnRCeUlkOmZ1bmN0aW9uKGUpe3ZhciB0PW51bGw7cmV0dXJuIFUodGhpcy5kb2N1bWVudEVsZW1lbnQsKGZ1bmN0aW9uKHIpe2lmKHIubm9kZVR5cGU9PWQmJnIuZ2V0QXR0cmlidXRlKFwiaWRcIik9PWUpcmV0dXJuIHQ9ciwhMH0pKSx0fSxnZXRFbGVtZW50c0J5Q2xhc3NOYW1lOmZ1bmN0aW9uKGUpe3ZhciB0PWwoZSk7cmV0dXJuIG5ldyBPKHRoaXMsKGZ1bmN0aW9uKHIpe3ZhciBhPVtdO3JldHVybiB0Lmxlbmd0aD4wJiZVKHIuZG9jdW1lbnRFbGVtZW50LChmdW5jdGlvbihuKXtpZihuIT09ciYmbi5ub2RlVHlwZT09PWQpe3ZhciBvPW4uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7aWYobyl7dmFyIGk9ZT09PW87aWYoIWkpe3ZhciBzPWwobyk7aT10LmV2ZXJ5KChjPXMsZnVuY3Rpb24oZSl7cmV0dXJuIGMmJi0xIT09Yy5pbmRleE9mKGUpfSkpfWkmJmEucHVzaChuKX19dmFyIGN9KSksYX0pKX0sY3JlYXRlRWxlbWVudDpmdW5jdGlvbihlKXt2YXIgdD1uZXcgSztyZXR1cm4gdC5vd25lckRvY3VtZW50PXRoaXMsdC5ub2RlTmFtZT1lLHQudGFnTmFtZT1lLHQubG9jYWxOYW1lPWUsdC5jaGlsZE5vZGVzPW5ldyBOLCh0LmF0dHJpYnV0ZXM9bmV3IEIpLl9vd25lckVsZW1lbnQ9dCx0fSxjcmVhdGVEb2N1bWVudEZyYWdtZW50OmZ1bmN0aW9uKCl7dmFyIGU9bmV3IGNlO3JldHVybiBlLm93bmVyRG9jdW1lbnQ9dGhpcyxlLmNoaWxkTm9kZXM9bmV3IE4sZX0sY3JlYXRlVGV4dE5vZGU6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IHJlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0LmFwcGVuZERhdGEoZSksdH0sY3JlYXRlQ29tbWVudDpmdW5jdGlvbihlKXt2YXIgdD1uZXcgYWU7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQuYXBwZW5kRGF0YShlKSx0fSxjcmVhdGVDREFUQVNlY3Rpb246ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IG5lO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0LmFwcGVuZERhdGEoZSksdH0sY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IHVlO3JldHVybiByLm93bmVyRG9jdW1lbnQ9dGhpcyxyLnRhZ05hbWU9ci5ub2RlTmFtZT1yLnRhcmdldD1lLHIubm9kZVZhbHVlPXIuZGF0YT10LHJ9LGNyZWF0ZUF0dHJpYnV0ZTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgZWU7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQubmFtZT1lLHQubm9kZU5hbWU9ZSx0LmxvY2FsTmFtZT1lLHQuc3BlY2lmaWVkPSEwLHR9LGNyZWF0ZUVudGl0eVJlZmVyZW5jZTpmdW5jdGlvbihlKXt2YXIgdD1uZXcgbGU7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQubm9kZU5hbWU9ZSx0fSxjcmVhdGVFbGVtZW50TlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgSyxhPXQuc3BsaXQoXCI6XCIpLG49ci5hdHRyaWJ1dGVzPW5ldyBCO3JldHVybiByLmNoaWxkTm9kZXM9bmV3IE4sci5vd25lckRvY3VtZW50PXRoaXMsci5ub2RlTmFtZT10LHIudGFnTmFtZT10LHIubmFtZXNwYWNlVVJJPWUsMj09YS5sZW5ndGg/KHIucHJlZml4PWFbMF0sci5sb2NhbE5hbWU9YVsxXSk6ci5sb2NhbE5hbWU9dCxuLl9vd25lckVsZW1lbnQ9cixyfSxjcmVhdGVBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3ZhciByPW5ldyBlZSxhPXQuc3BsaXQoXCI6XCIpO3JldHVybiByLm93bmVyRG9jdW1lbnQ9dGhpcyxyLm5vZGVOYW1lPXQsci5uYW1lPXQsci5uYW1lc3BhY2VVUkk9ZSxyLnNwZWNpZmllZD0hMCwyPT1hLmxlbmd0aD8oci5wcmVmaXg9YVswXSxyLmxvY2FsTmFtZT1hWzFdKTpyLmxvY2FsTmFtZT10LHJ9fSx1KGosUiksSy5wcm90b3R5cGU9e25vZGVUeXBlOmQsaGFzQXR0cmlidXRlOmZ1bmN0aW9uKGUpe3JldHVybiBudWxsIT10aGlzLmdldEF0dHJpYnV0ZU5vZGUoZSl9LGdldEF0dHJpYnV0ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldEF0dHJpYnV0ZU5vZGUoZSk7cmV0dXJuIHQmJnQudmFsdWV8fFwiXCJ9LGdldEF0dHJpYnV0ZU5vZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oZSl9LHNldEF0dHJpYnV0ZTpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVBdHRyaWJ1dGUoZSk7ci52YWx1ZT1yLm5vZGVWYWx1ZT1cIlwiK3QsdGhpcy5zZXRBdHRyaWJ1dGVOb2RlKHIpfSxyZW1vdmVBdHRyaWJ1dGU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlKGUpO3QmJnRoaXMucmVtb3ZlQXR0cmlidXRlTm9kZSh0KX0sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUubm9kZVR5cGU9PT1BP3RoaXMuaW5zZXJ0QmVmb3JlKGUsbnVsbCk6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5wYXJlbnROb2RlJiZ0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCksdC5wYXJlbnROb2RlPWUsdC5wcmV2aW91c1NpYmxpbmc9ZS5sYXN0Q2hpbGQsdC5uZXh0U2libGluZz1udWxsLHQucHJldmlvdXNTaWJsaW5nP3QucHJldmlvdXNTaWJsaW5nLm5leHRTaWJsaW5nPXQ6ZS5maXJzdENoaWxkPXQsZS5sYXN0Q2hpbGQ9dCxHKGUub3duZXJEb2N1bWVudCxlLHQpLHR9KHRoaXMsZSl9LHNldEF0dHJpYnV0ZU5vZGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW0oZSl9LHNldEF0dHJpYnV0ZU5vZGVOUzpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnNldE5hbWVkSXRlbU5TKGUpfSxyZW1vdmVBdHRyaWJ1dGVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMucmVtb3ZlTmFtZWRJdGVtKGUubm9kZU5hbWUpfSxyZW1vdmVBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKGUsdCk7ciYmdGhpcy5yZW1vdmVBdHRyaWJ1dGVOb2RlKHIpfSxoYXNBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3JldHVybiBudWxsIT10aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhlLHQpfSxnZXRBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQpe3ZhciByPXRoaXMuZ2V0QXR0cmlidXRlTm9kZU5TKGUsdCk7cmV0dXJuIHImJnIudmFsdWV8fFwiXCJ9LHNldEF0dHJpYnV0ZU5TOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT10aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlTlMoZSx0KTthLnZhbHVlPWEubm9kZVZhbHVlPVwiXCIrcix0aGlzLnNldEF0dHJpYnV0ZU5vZGUoYSl9LGdldEF0dHJpYnV0ZU5vZGVOUzpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtTlMoZSx0KX0sZ2V0RWxlbWVudHNCeVRhZ05hbWU6ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBPKHRoaXMsKGZ1bmN0aW9uKHQpe3ZhciByPVtdO3JldHVybiBVKHQsKGZ1bmN0aW9uKGEpe2E9PT10fHxhLm5vZGVUeXBlIT1kfHxcIipcIiE9PWUmJmEudGFnTmFtZSE9ZXx8ci5wdXNoKGEpfSkpLHJ9KSl9LGdldEVsZW1lbnRzQnlUYWdOYW1lTlM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IE8odGhpcywoZnVuY3Rpb24ocil7dmFyIGE9W107cmV0dXJuIFUociwoZnVuY3Rpb24obil7bj09PXJ8fG4ubm9kZVR5cGUhPT1kfHxcIipcIiE9PWUmJm4ubmFtZXNwYWNlVVJJIT09ZXx8XCIqXCIhPT10JiZuLmxvY2FsTmFtZSE9dHx8YS5wdXNoKG4pfSkpLGF9KSl9fSxqLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZT1LLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSxqLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TPUsucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMsdShLLFIpLGVlLnByb3RvdHlwZS5ub2RlVHlwZT1tLHUoZWUsUiksdGUucHJvdG90eXBlPXtkYXRhOlwiXCIsc3Vic3RyaW5nRGF0YTpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmRhdGEuc3Vic3RyaW5nKGUsZSt0KX0sYXBwZW5kRGF0YTpmdW5jdGlvbihlKXtlPXRoaXMuZGF0YStlLHRoaXMubm9kZVZhbHVlPXRoaXMuZGF0YT1lLHRoaXMubGVuZ3RoPWUubGVuZ3RofSxpbnNlcnREYXRhOmZ1bmN0aW9uKGUsdCl7dGhpcy5yZXBsYWNlRGF0YShlLDAsdCl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcih5W3FdKX0sZGVsZXRlRGF0YTpmdW5jdGlvbihlLHQpe3RoaXMucmVwbGFjZURhdGEoZSx0LFwiXCIpfSxyZXBsYWNlRGF0YTpmdW5jdGlvbihlLHQscil7cj10aGlzLmRhdGEuc3Vic3RyaW5nKDAsZSkrcit0aGlzLmRhdGEuc3Vic3RyaW5nKGUrdCksdGhpcy5ub2RlVmFsdWU9dGhpcy5kYXRhPXIsdGhpcy5sZW5ndGg9ci5sZW5ndGh9fSx1KHRlLFIpLHJlLnByb3RvdHlwZT17bm9kZU5hbWU6XCIjdGV4dFwiLG5vZGVUeXBlOnAsc3BsaXRUZXh0OmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZGF0YSxyPXQuc3Vic3RyaW5nKGUpO3Q9dC5zdWJzdHJpbmcoMCxlKSx0aGlzLmRhdGE9dGhpcy5ub2RlVmFsdWU9dCx0aGlzLmxlbmd0aD10Lmxlbmd0aDt2YXIgYT10aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocik7cmV0dXJuIHRoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRoaXMubmV4dFNpYmxpbmcpLGF9fSx1KHJlLHRlKSxhZS5wcm90b3R5cGU9e25vZGVOYW1lOlwiI2NvbW1lbnRcIixub2RlVHlwZTpifSx1KGFlLHRlKSxuZS5wcm90b3R5cGU9e25vZGVOYW1lOlwiI2NkYXRhLXNlY3Rpb25cIixub2RlVHlwZTpmfSx1KG5lLHRlKSxvZS5wcm90b3R5cGUubm9kZVR5cGU9Qyx1KG9lLFIpLGllLnByb3RvdHlwZS5ub2RlVHlwZT1FLHUoaWUsUiksc2UucHJvdG90eXBlLm5vZGVUeXBlPWcsdShzZSxSKSxsZS5wcm90b3R5cGUubm9kZVR5cGU9eCx1KGxlLFIpLGNlLnByb3RvdHlwZS5ub2RlTmFtZT1cIiNkb2N1bWVudC1mcmFnbWVudFwiLGNlLnByb3RvdHlwZS5ub2RlVHlwZT1BLHUoY2UsUiksdWUucHJvdG90eXBlLm5vZGVUeXBlPXcsdSh1ZSxSKSxoZS5wcm90b3R5cGUuc2VyaWFsaXplVG9TdHJpbmc9ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBkZS5jYWxsKGUsdCxyKX0sUi5wcm90b3R5cGUudG9TdHJpbmc9ZGU7dHJ5e2lmKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSl7ZnVuY3Rpb24gYmUoZSl7c3dpdGNoKGUubm9kZVR5cGUpe2Nhc2UgZDpjYXNlIEE6dmFyIHQ9W107Zm9yKGU9ZS5maXJzdENoaWxkO2U7KTchPT1lLm5vZGVUeXBlJiY4IT09ZS5ub2RlVHlwZSYmdC5wdXNoKGJlKGUpKSxlPWUubmV4dFNpYmxpbmc7cmV0dXJuIHQuam9pbihcIlwiKTtkZWZhdWx0OnJldHVybiBlLm5vZGVWYWx1ZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KE8ucHJvdG90eXBlLFwibGVuZ3RoXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBMKHRoaXMpLHRoaXMuJCRsZW5ndGh9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFIucHJvdG90eXBlLFwidGV4dENvbnRlbnRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGJlKHRoaXMpfSxzZXQ6ZnVuY3Rpb24oZSl7c3dpdGNoKHRoaXMubm9kZVR5cGUpe2Nhc2UgZDpjYXNlIEE6Zm9yKDt0aGlzLmZpcnN0Q2hpbGQ7KXRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTsoZXx8U3RyaW5nKGUpKSYmdGhpcy5hcHBlbmRDaGlsZCh0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZSkpO2JyZWFrO2RlZmF1bHQ6dGhpcy5kYXRhPWUsdGhpcy52YWx1ZT1lLHRoaXMubm9kZVZhbHVlPWV9fX0pLHdlPWZ1bmN0aW9uKGUsdCxyKXtlW1wiJCRcIit0XT1yfX19Y2F0Y2godmUpe310LkRvY3VtZW50VHlwZT1vZSx0LkRPTUV4Y2VwdGlvbj1ULHQuRE9NSW1wbGVtZW50YXRpb249ayx0LkVsZW1lbnQ9Syx0Lk5vZGU9Uix0Lk5vZGVMaXN0PU4sdC5YTUxTZXJpYWxpemVyPWhlfSw2NTU5OihlLHQscik9PntcInVzZSBzdHJpY3RcIjt2YXIgYT1yKDQ1ODIpLmZyZWV6ZTt0LlhNTF9FTlRJVElFUz1hKHthbXA6XCImXCIsYXBvczpcIidcIixndDpcIj5cIixsdDpcIjxcIixxdW90OidcIid9KSx0LkhUTUxfRU5USVRJRVM9YSh7QWFjdXRlOlwiw4FcIixhYWN1dGU6XCLDoVwiLEFicmV2ZTpcIsSCXCIsYWJyZXZlOlwixINcIixhYzpcIuKIvlwiLGFjZDpcIuKIv1wiLGFjRTpcIuKIvsyzXCIsQWNpcmM6XCLDglwiLGFjaXJjOlwiw6JcIixhY3V0ZTpcIsK0XCIsQWN5Olwi0JBcIixhY3k6XCLQsFwiLEFFbGlnOlwiw4ZcIixhZWxpZzpcIsOmXCIsYWY6XCLigaFcIixBZnI6XCLwnZSEXCIsYWZyOlwi8J2UnlwiLEFncmF2ZTpcIsOAXCIsYWdyYXZlOlwiw6BcIixhbGVmc3ltOlwi4oS1XCIsYWxlcGg6XCLihLVcIixBbHBoYTpcIs6RXCIsYWxwaGE6XCLOsVwiLEFtYWNyOlwixIBcIixhbWFjcjpcIsSBXCIsYW1hbGc6XCLiqL9cIixBTVA6XCImXCIsYW1wOlwiJlwiLEFuZDpcIuKpk1wiLGFuZDpcIuKIp1wiLGFuZGFuZDpcIuKplVwiLGFuZGQ6XCLiqZxcIixhbmRzbG9wZTpcIuKpmFwiLGFuZHY6XCLiqZpcIixhbmc6XCLiiKBcIixhbmdlOlwi4qakXCIsYW5nbGU6XCLiiKBcIixhbmdtc2Q6XCLiiKFcIixhbmdtc2RhYTpcIuKmqFwiLGFuZ21zZGFiOlwi4qapXCIsYW5nbXNkYWM6XCLipqpcIixhbmdtc2RhZDpcIuKmq1wiLGFuZ21zZGFlOlwi4qasXCIsYW5nbXNkYWY6XCLipq1cIixhbmdtc2RhZzpcIuKmrlwiLGFuZ21zZGFoOlwi4qavXCIsYW5ncnQ6XCLiiJ9cIixhbmdydHZiOlwi4oq+XCIsYW5ncnR2YmQ6XCLipp1cIixhbmdzcGg6XCLiiKJcIixhbmdzdDpcIsOFXCIsYW5nemFycjpcIuKNvFwiLEFvZ29uOlwixIRcIixhb2dvbjpcIsSFXCIsQW9wZjpcIvCdlLhcIixhb3BmOlwi8J2VklwiLGFwOlwi4omIXCIsYXBhY2lyOlwi4qmvXCIsYXBFOlwi4qmwXCIsYXBlOlwi4omKXCIsYXBpZDpcIuKJi1wiLGFwb3M6XCInXCIsQXBwbHlGdW5jdGlvbjpcIuKBoVwiLGFwcHJveDpcIuKJiFwiLGFwcHJveGVxOlwi4omKXCIsQXJpbmc6XCLDhVwiLGFyaW5nOlwiw6VcIixBc2NyOlwi8J2SnFwiLGFzY3I6XCLwnZK2XCIsQXNzaWduOlwi4omUXCIsYXN0OlwiKlwiLGFzeW1wOlwi4omIXCIsYXN5bXBlcTpcIuKJjVwiLEF0aWxkZTpcIsODXCIsYXRpbGRlOlwiw6NcIixBdW1sOlwiw4RcIixhdW1sOlwiw6RcIixhd2NvbmludDpcIuKIs1wiLGF3aW50Olwi4qiRXCIsYmFja2Nvbmc6XCLiiYxcIixiYWNrZXBzaWxvbjpcIs+2XCIsYmFja3ByaW1lOlwi4oC1XCIsYmFja3NpbTpcIuKIvVwiLGJhY2tzaW1lcTpcIuKLjVwiLEJhY2tzbGFzaDpcIuKIllwiLEJhcnY6XCLiq6dcIixiYXJ2ZWU6XCLiir1cIixCYXJ3ZWQ6XCLijIZcIixiYXJ3ZWQ6XCLijIVcIixiYXJ3ZWRnZTpcIuKMhVwiLGJicms6XCLijrVcIixiYnJrdGJyazpcIuKOtlwiLGJjb25nOlwi4omMXCIsQmN5Olwi0JFcIixiY3k6XCLQsVwiLGJkcXVvOlwi4oCeXCIsYmVjYXVzOlwi4oi1XCIsQmVjYXVzZTpcIuKItVwiLGJlY2F1c2U6XCLiiLVcIixiZW1wdHl2Olwi4qawXCIsYmVwc2k6XCLPtlwiLGJlcm5vdTpcIuKErFwiLEJlcm5vdWxsaXM6XCLihKxcIixCZXRhOlwizpJcIixiZXRhOlwizrJcIixiZXRoOlwi4oS2XCIsYmV0d2VlbjpcIuKJrFwiLEJmcjpcIvCdlIVcIixiZnI6XCLwnZSfXCIsYmlnY2FwOlwi4ouCXCIsYmlnY2lyYzpcIuKXr1wiLGJpZ2N1cDpcIuKLg1wiLGJpZ29kb3Q6XCLiqIBcIixiaWdvcGx1czpcIuKogVwiLGJpZ290aW1lczpcIuKoglwiLGJpZ3NxY3VwOlwi4qiGXCIsYmlnc3RhcjpcIuKYhVwiLGJpZ3RyaWFuZ2xlZG93bjpcIuKWvVwiLGJpZ3RyaWFuZ2xldXA6XCLilrNcIixiaWd1cGx1czpcIuKohFwiLGJpZ3ZlZTpcIuKLgVwiLGJpZ3dlZGdlOlwi4ouAXCIsYmthcm93Olwi4qSNXCIsYmxhY2tsb3plbmdlOlwi4qerXCIsYmxhY2tzcXVhcmU6XCLilqpcIixibGFja3RyaWFuZ2xlOlwi4pa0XCIsYmxhY2t0cmlhbmdsZWRvd246XCLilr5cIixibGFja3RyaWFuZ2xlbGVmdDpcIuKXglwiLGJsYWNrdHJpYW5nbGVyaWdodDpcIuKWuFwiLGJsYW5rOlwi4pCjXCIsYmxrMTI6XCLilpJcIixibGsxNDpcIuKWkVwiLGJsazM0Olwi4paTXCIsYmxvY2s6XCLilohcIixibmU6XCI94oOlXCIsYm5lcXVpdjpcIuKJoeKDpVwiLGJOb3Q6XCLiq61cIixibm90Olwi4oyQXCIsQm9wZjpcIvCdlLlcIixib3BmOlwi8J2Vk1wiLGJvdDpcIuKKpVwiLGJvdHRvbTpcIuKKpVwiLGJvd3RpZTpcIuKLiFwiLGJveGJveDpcIuKniVwiLGJveERMOlwi4pWXXCIsYm94RGw6XCLilZZcIixib3hkTDpcIuKVlVwiLGJveGRsOlwi4pSQXCIsYm94RFI6XCLilZRcIixib3hEcjpcIuKVk1wiLGJveGRSOlwi4pWSXCIsYm94ZHI6XCLilIxcIixib3hIOlwi4pWQXCIsYm94aDpcIuKUgFwiLGJveEhEOlwi4pWmXCIsYm94SGQ6XCLilaRcIixib3hoRDpcIuKVpVwiLGJveGhkOlwi4pSsXCIsYm94SFU6XCLilalcIixib3hIdTpcIuKVp1wiLGJveGhVOlwi4pWoXCIsYm94aHU6XCLilLRcIixib3htaW51czpcIuKKn1wiLGJveHBsdXM6XCLiip5cIixib3h0aW1lczpcIuKKoFwiLGJveFVMOlwi4pWdXCIsYm94VWw6XCLilZxcIixib3h1TDpcIuKVm1wiLGJveHVsOlwi4pSYXCIsYm94VVI6XCLilZpcIixib3hVcjpcIuKVmVwiLGJveHVSOlwi4pWYXCIsYm94dXI6XCLilJRcIixib3hWOlwi4pWRXCIsYm94djpcIuKUglwiLGJveFZIOlwi4pWsXCIsYm94Vmg6XCLilatcIixib3h2SDpcIuKVqlwiLGJveHZoOlwi4pS8XCIsYm94Vkw6XCLilaNcIixib3hWbDpcIuKVolwiLGJveHZMOlwi4pWhXCIsYm94dmw6XCLilKRcIixib3hWUjpcIuKVoFwiLGJveFZyOlwi4pWfXCIsYm94dlI6XCLilZ5cIixib3h2cjpcIuKUnFwiLGJwcmltZTpcIuKAtVwiLEJyZXZlOlwiy5hcIixicmV2ZTpcIsuYXCIsYnJ2YmFyOlwiwqZcIixCc2NyOlwi4oSsXCIsYnNjcjpcIvCdkrdcIixic2VtaTpcIuKBj1wiLGJzaW06XCLiiL1cIixic2ltZTpcIuKLjVwiLGJzb2w6XCJcXFxcXCIsYnNvbGI6XCLip4VcIixic29saHN1YjpcIuKfiFwiLGJ1bGw6XCLigKJcIixidWxsZXQ6XCLigKJcIixidW1wOlwi4omOXCIsYnVtcEU6XCLiqq5cIixidW1wZTpcIuKJj1wiLEJ1bXBlcTpcIuKJjlwiLGJ1bXBlcTpcIuKJj1wiLENhY3V0ZTpcIsSGXCIsY2FjdXRlOlwixIdcIixDYXA6XCLii5JcIixjYXA6XCLiiKlcIixjYXBhbmQ6XCLiqYRcIixjYXBicmN1cDpcIuKpiVwiLGNhcGNhcDpcIuKpi1wiLGNhcGN1cDpcIuKph1wiLGNhcGRvdDpcIuKpgFwiLENhcGl0YWxEaWZmZXJlbnRpYWxEOlwi4oWFXCIsY2FwczpcIuKIqe+4gFwiLGNhcmV0Olwi4oGBXCIsY2Fyb246XCLLh1wiLENheWxleXM6XCLihK1cIixjY2FwczpcIuKpjVwiLENjYXJvbjpcIsSMXCIsY2Nhcm9uOlwixI1cIixDY2VkaWw6XCLDh1wiLGNjZWRpbDpcIsOnXCIsQ2NpcmM6XCLEiFwiLGNjaXJjOlwixIlcIixDY29uaW50Olwi4oiwXCIsY2N1cHM6XCLiqYxcIixjY3Vwc3NtOlwi4qmQXCIsQ2RvdDpcIsSKXCIsY2RvdDpcIsSLXCIsY2VkaWw6XCLCuFwiLENlZGlsbGE6XCLCuFwiLGNlbXB0eXY6XCLiprJcIixjZW50OlwiwqJcIixDZW50ZXJEb3Q6XCLCt1wiLGNlbnRlcmRvdDpcIsK3XCIsQ2ZyOlwi4oStXCIsY2ZyOlwi8J2UoFwiLENIY3k6XCLQp1wiLGNoY3k6XCLRh1wiLGNoZWNrOlwi4pyTXCIsY2hlY2ttYXJrOlwi4pyTXCIsQ2hpOlwizqdcIixjaGk6XCLPh1wiLGNpcjpcIuKXi1wiLGNpcmM6XCLLhlwiLGNpcmNlcTpcIuKJl1wiLGNpcmNsZWFycm93bGVmdDpcIuKGulwiLGNpcmNsZWFycm93cmlnaHQ6XCLihrtcIixjaXJjbGVkYXN0Olwi4oqbXCIsY2lyY2xlZGNpcmM6XCLiippcIixjaXJjbGVkZGFzaDpcIuKKnVwiLENpcmNsZURvdDpcIuKKmVwiLGNpcmNsZWRSOlwiwq5cIixjaXJjbGVkUzpcIuKTiFwiLENpcmNsZU1pbnVzOlwi4oqWXCIsQ2lyY2xlUGx1czpcIuKKlVwiLENpcmNsZVRpbWVzOlwi4oqXXCIsY2lyRTpcIuKng1wiLGNpcmU6XCLiiZdcIixjaXJmbmludDpcIuKokFwiLGNpcm1pZDpcIuKrr1wiLGNpcnNjaXI6XCLip4JcIixDbG9ja3dpc2VDb250b3VySW50ZWdyYWw6XCLiiLJcIixDbG9zZUN1cmx5RG91YmxlUXVvdGU6XCLigJ1cIixDbG9zZUN1cmx5UXVvdGU6XCLigJlcIixjbHViczpcIuKZo1wiLGNsdWJzdWl0Olwi4pmjXCIsQ29sb246XCLiiLdcIixjb2xvbjpcIjpcIixDb2xvbmU6XCLiqbRcIixjb2xvbmU6XCLiiZRcIixjb2xvbmVxOlwi4omUXCIsY29tbWE6XCIsXCIsY29tbWF0OlwiQFwiLGNvbXA6XCLiiIFcIixjb21wZm46XCLiiJhcIixjb21wbGVtZW50Olwi4oiBXCIsY29tcGxleGVzOlwi4oSCXCIsY29uZzpcIuKJhVwiLGNvbmdkb3Q6XCLiqa1cIixDb25ncnVlbnQ6XCLiiaFcIixDb25pbnQ6XCLiiK9cIixjb25pbnQ6XCLiiK5cIixDb250b3VySW50ZWdyYWw6XCLiiK5cIixDb3BmOlwi4oSCXCIsY29wZjpcIvCdlZRcIixjb3Byb2Q6XCLiiJBcIixDb3Byb2R1Y3Q6XCLiiJBcIixDT1BZOlwiwqlcIixjb3B5OlwiwqlcIixjb3B5c3I6XCLihJdcIixDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsOlwi4oizXCIsY3JhcnI6XCLihrVcIixDcm9zczpcIuKor1wiLGNyb3NzOlwi4pyXXCIsQ3NjcjpcIvCdkp5cIixjc2NyOlwi8J2SuFwiLGNzdWI6XCLiq49cIixjc3ViZTpcIuKrkVwiLGNzdXA6XCLiq5BcIixjc3VwZTpcIuKrklwiLGN0ZG90Olwi4ouvXCIsY3VkYXJybDpcIuKkuFwiLGN1ZGFycnI6XCLipLVcIixjdWVwcjpcIuKLnlwiLGN1ZXNjOlwi4oufXCIsY3VsYXJyOlwi4oa2XCIsY3VsYXJycDpcIuKkvVwiLEN1cDpcIuKLk1wiLGN1cDpcIuKIqlwiLGN1cGJyY2FwOlwi4qmIXCIsQ3VwQ2FwOlwi4omNXCIsY3VwY2FwOlwi4qmGXCIsY3VwY3VwOlwi4qmKXCIsY3VwZG90Olwi4oqNXCIsY3Vwb3I6XCLiqYVcIixjdXBzOlwi4oiq77iAXCIsY3VyYXJyOlwi4oa3XCIsY3VyYXJybTpcIuKkvFwiLGN1cmx5ZXFwcmVjOlwi4oueXCIsY3VybHllcXN1Y2M6XCLii59cIixjdXJseXZlZTpcIuKLjlwiLGN1cmx5d2VkZ2U6XCLii49cIixjdXJyZW46XCLCpFwiLGN1cnZlYXJyb3dsZWZ0Olwi4oa2XCIsY3VydmVhcnJvd3JpZ2h0Olwi4oa3XCIsY3V2ZWU6XCLii45cIixjdXdlZDpcIuKLj1wiLGN3Y29uaW50Olwi4oiyXCIsY3dpbnQ6XCLiiLFcIixjeWxjdHk6XCLijK1cIixEYWdnZXI6XCLigKFcIixkYWdnZXI6XCLigKBcIixkYWxldGg6XCLihLhcIixEYXJyOlwi4oahXCIsZEFycjpcIuKHk1wiLGRhcnI6XCLihpNcIixkYXNoOlwi4oCQXCIsRGFzaHY6XCLiq6RcIixkYXNodjpcIuKKo1wiLGRia2Fyb3c6XCLipI9cIixkYmxhYzpcIsudXCIsRGNhcm9uOlwixI5cIixkY2Fyb246XCLEj1wiLERjeTpcItCUXCIsZGN5Olwi0LRcIixERDpcIuKFhVwiLGRkOlwi4oWGXCIsZGRhZ2dlcjpcIuKAoVwiLGRkYXJyOlwi4oeKXCIsRERvdHJhaGQ6XCLipJFcIixkZG90c2VxOlwi4qm3XCIsZGVnOlwiwrBcIixEZWw6XCLiiIdcIixEZWx0YTpcIs6UXCIsZGVsdGE6XCLOtFwiLGRlbXB0eXY6XCLiprFcIixkZmlzaHQ6XCLipb9cIixEZnI6XCLwnZSHXCIsZGZyOlwi8J2UoVwiLGRIYXI6XCLipaVcIixkaGFybDpcIuKHg1wiLGRoYXJyOlwi4oeCXCIsRGlhY3JpdGljYWxBY3V0ZTpcIsK0XCIsRGlhY3JpdGljYWxEb3Q6XCLLmVwiLERpYWNyaXRpY2FsRG91YmxlQWN1dGU6XCLLnVwiLERpYWNyaXRpY2FsR3JhdmU6XCJgXCIsRGlhY3JpdGljYWxUaWxkZTpcIsucXCIsZGlhbTpcIuKLhFwiLERpYW1vbmQ6XCLii4RcIixkaWFtb25kOlwi4ouEXCIsZGlhbW9uZHN1aXQ6XCLimaZcIixkaWFtczpcIuKZplwiLGRpZTpcIsKoXCIsRGlmZmVyZW50aWFsRDpcIuKFhlwiLGRpZ2FtbWE6XCLPnVwiLGRpc2luOlwi4ouyXCIsZGl2Olwiw7dcIixkaXZpZGU6XCLDt1wiLGRpdmlkZW9udGltZXM6XCLii4dcIixkaXZvbng6XCLii4dcIixESmN5Olwi0IJcIixkamN5Olwi0ZJcIixkbGNvcm46XCLijJ5cIixkbGNyb3A6XCLijI1cIixkb2xsYXI6XCIkXCIsRG9wZjpcIvCdlLtcIixkb3BmOlwi8J2VlVwiLERvdDpcIsKoXCIsZG90Olwiy5lcIixEb3REb3Q6XCLig5xcIixkb3RlcTpcIuKJkFwiLGRvdGVxZG90Olwi4omRXCIsRG90RXF1YWw6XCLiiZBcIixkb3RtaW51czpcIuKIuFwiLGRvdHBsdXM6XCLiiJRcIixkb3RzcXVhcmU6XCLiiqFcIixkb3VibGViYXJ3ZWRnZTpcIuKMhlwiLERvdWJsZUNvbnRvdXJJbnRlZ3JhbDpcIuKIr1wiLERvdWJsZURvdDpcIsKoXCIsRG91YmxlRG93bkFycm93Olwi4oeTXCIsRG91YmxlTGVmdEFycm93Olwi4oeQXCIsRG91YmxlTGVmdFJpZ2h0QXJyb3c6XCLih5RcIixEb3VibGVMZWZ0VGVlOlwi4qukXCIsRG91YmxlTG9uZ0xlZnRBcnJvdzpcIuKfuFwiLERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdzpcIuKfulwiLERvdWJsZUxvbmdSaWdodEFycm93Olwi4p+5XCIsRG91YmxlUmlnaHRBcnJvdzpcIuKHklwiLERvdWJsZVJpZ2h0VGVlOlwi4oqoXCIsRG91YmxlVXBBcnJvdzpcIuKHkVwiLERvdWJsZVVwRG93bkFycm93Olwi4oeVXCIsRG91YmxlVmVydGljYWxCYXI6XCLiiKVcIixEb3duQXJyb3c6XCLihpNcIixEb3duYXJyb3c6XCLih5NcIixkb3duYXJyb3c6XCLihpNcIixEb3duQXJyb3dCYXI6XCLipJNcIixEb3duQXJyb3dVcEFycm93Olwi4oe1XCIsRG93bkJyZXZlOlwizJFcIixkb3duZG93bmFycm93czpcIuKHilwiLGRvd25oYXJwb29ubGVmdDpcIuKHg1wiLGRvd25oYXJwb29ucmlnaHQ6XCLih4JcIixEb3duTGVmdFJpZ2h0VmVjdG9yOlwi4qWQXCIsRG93bkxlZnRUZWVWZWN0b3I6XCLipZ5cIixEb3duTGVmdFZlY3RvcjpcIuKGvVwiLERvd25MZWZ0VmVjdG9yQmFyOlwi4qWWXCIsRG93blJpZ2h0VGVlVmVjdG9yOlwi4qWfXCIsRG93blJpZ2h0VmVjdG9yOlwi4oeBXCIsRG93blJpZ2h0VmVjdG9yQmFyOlwi4qWXXCIsRG93blRlZTpcIuKKpFwiLERvd25UZWVBcnJvdzpcIuKGp1wiLGRyYmthcm93Olwi4qSQXCIsZHJjb3JuOlwi4oyfXCIsZHJjcm9wOlwi4oyMXCIsRHNjcjpcIvCdkp9cIixkc2NyOlwi8J2SuVwiLERTY3k6XCLQhVwiLGRzY3k6XCLRlVwiLGRzb2w6XCLip7ZcIixEc3Ryb2s6XCLEkFwiLGRzdHJvazpcIsSRXCIsZHRkb3Q6XCLii7FcIixkdHJpOlwi4pa/XCIsZHRyaWY6XCLilr5cIixkdWFycjpcIuKHtVwiLGR1aGFyOlwi4qWvXCIsZHdhbmdsZTpcIuKmplwiLERaY3k6XCLQj1wiLGR6Y3k6XCLRn1wiLGR6aWdyYXJyOlwi4p+/XCIsRWFjdXRlOlwiw4lcIixlYWN1dGU6XCLDqVwiLGVhc3RlcjpcIuKprlwiLEVjYXJvbjpcIsSaXCIsZWNhcm9uOlwixJtcIixlY2lyOlwi4omWXCIsRWNpcmM6XCLDilwiLGVjaXJjOlwiw6pcIixlY29sb246XCLiiZVcIixFY3k6XCLQrVwiLGVjeTpcItGNXCIsZUREb3Q6XCLiqbdcIixFZG90OlwixJZcIixlRG90Olwi4omRXCIsZWRvdDpcIsSXXCIsZWU6XCLihYdcIixlZkRvdDpcIuKJklwiLEVmcjpcIvCdlIhcIixlZnI6XCLwnZSiXCIsZWc6XCLiqppcIixFZ3JhdmU6XCLDiFwiLGVncmF2ZTpcIsOoXCIsZWdzOlwi4qqWXCIsZWdzZG90Olwi4qqYXCIsZWw6XCLiqplcIixFbGVtZW50Olwi4oiIXCIsZWxpbnRlcnM6XCLij6dcIixlbGw6XCLihJNcIixlbHM6XCLiqpVcIixlbHNkb3Q6XCLiqpdcIixFbWFjcjpcIsSSXCIsZW1hY3I6XCLEk1wiLGVtcHR5Olwi4oiFXCIsZW1wdHlzZXQ6XCLiiIVcIixFbXB0eVNtYWxsU3F1YXJlOlwi4pe7XCIsZW1wdHl2Olwi4oiFXCIsRW1wdHlWZXJ5U21hbGxTcXVhcmU6XCLilqtcIixlbXNwOlwi4oCDXCIsZW1zcDEzOlwi4oCEXCIsZW1zcDE0Olwi4oCFXCIsRU5HOlwixYpcIixlbmc6XCLFi1wiLGVuc3A6XCLigIJcIixFb2dvbjpcIsSYXCIsZW9nb246XCLEmVwiLEVvcGY6XCLwnZS8XCIsZW9wZjpcIvCdlZZcIixlcGFyOlwi4ouVXCIsZXBhcnNsOlwi4qejXCIsZXBsdXM6XCLiqbFcIixlcHNpOlwizrVcIixFcHNpbG9uOlwizpVcIixlcHNpbG9uOlwizrVcIixlcHNpdjpcIs+1XCIsZXFjaXJjOlwi4omWXCIsZXFjb2xvbjpcIuKJlVwiLGVxc2ltOlwi4omCXCIsZXFzbGFudGd0cjpcIuKqllwiLGVxc2xhbnRsZXNzOlwi4qqVXCIsRXF1YWw6XCLiqbVcIixlcXVhbHM6XCI9XCIsRXF1YWxUaWxkZTpcIuKJglwiLGVxdWVzdDpcIuKJn1wiLEVxdWlsaWJyaXVtOlwi4oeMXCIsZXF1aXY6XCLiiaFcIixlcXVpdkREOlwi4qm4XCIsZXF2cGFyc2w6XCLip6VcIixlcmFycjpcIuKlsVwiLGVyRG90Olwi4omTXCIsRXNjcjpcIuKEsFwiLGVzY3I6XCLihK9cIixlc2RvdDpcIuKJkFwiLEVzaW06XCLiqbNcIixlc2ltOlwi4omCXCIsRXRhOlwizpdcIixldGE6XCLOt1wiLEVUSDpcIsOQXCIsZXRoOlwiw7BcIixFdW1sOlwiw4tcIixldW1sOlwiw6tcIixldXJvOlwi4oKsXCIsZXhjbDpcIiFcIixleGlzdDpcIuKIg1wiLEV4aXN0czpcIuKIg1wiLGV4cGVjdGF0aW9uOlwi4oSwXCIsRXhwb25lbnRpYWxFOlwi4oWHXCIsZXhwb25lbnRpYWxlOlwi4oWHXCIsZmFsbGluZ2RvdHNlcTpcIuKJklwiLEZjeTpcItCkXCIsZmN5Olwi0YRcIixmZW1hbGU6XCLimYBcIixmZmlsaWc6XCLvrINcIixmZmxpZzpcIu+sgFwiLGZmbGxpZzpcIu+shFwiLEZmcjpcIvCdlIlcIixmZnI6XCLwnZSjXCIsZmlsaWc6XCLvrIFcIixGaWxsZWRTbWFsbFNxdWFyZTpcIuKXvFwiLEZpbGxlZFZlcnlTbWFsbFNxdWFyZTpcIuKWqlwiLGZqbGlnOlwiZmpcIixmbGF0Olwi4pmtXCIsZmxsaWc6XCLvrIJcIixmbHRuczpcIuKWsVwiLGZub2Y6XCLGklwiLEZvcGY6XCLwnZS9XCIsZm9wZjpcIvCdlZdcIixGb3JBbGw6XCLiiIBcIixmb3JhbGw6XCLiiIBcIixmb3JrOlwi4ouUXCIsZm9ya3Y6XCLiq5lcIixGb3VyaWVydHJmOlwi4oSxXCIsZnBhcnRpbnQ6XCLiqI1cIixmcmFjMTI6XCLCvVwiLGZyYWMxMzpcIuKFk1wiLGZyYWMxNDpcIsK8XCIsZnJhYzE1Olwi4oWVXCIsZnJhYzE2Olwi4oWZXCIsZnJhYzE4Olwi4oWbXCIsZnJhYzIzOlwi4oWUXCIsZnJhYzI1Olwi4oWWXCIsZnJhYzM0Olwiwr5cIixmcmFjMzU6XCLihZdcIixmcmFjMzg6XCLihZxcIixmcmFjNDU6XCLihZhcIixmcmFjNTY6XCLihZpcIixmcmFjNTg6XCLihZ1cIixmcmFjNzg6XCLihZ5cIixmcmFzbDpcIuKBhFwiLGZyb3duOlwi4oyiXCIsRnNjcjpcIuKEsVwiLGZzY3I6XCLwnZK7XCIsZ2FjdXRlOlwix7VcIixHYW1tYTpcIs6TXCIsZ2FtbWE6XCLOs1wiLEdhbW1hZDpcIs+cXCIsZ2FtbWFkOlwiz51cIixnYXA6XCLiqoZcIixHYnJldmU6XCLEnlwiLGdicmV2ZTpcIsSfXCIsR2NlZGlsOlwixKJcIixHY2lyYzpcIsScXCIsZ2NpcmM6XCLEnVwiLEdjeTpcItCTXCIsZ2N5Olwi0LNcIixHZG90OlwixKBcIixnZG90OlwixKFcIixnRTpcIuKJp1wiLGdlOlwi4omlXCIsZ0VsOlwi4qqMXCIsZ2VsOlwi4oubXCIsZ2VxOlwi4omlXCIsZ2VxcTpcIuKJp1wiLGdlcXNsYW50Olwi4qm+XCIsZ2VzOlwi4qm+XCIsZ2VzY2M6XCLiqqlcIixnZXNkb3Q6XCLiqoBcIixnZXNkb3RvOlwi4qqCXCIsZ2VzZG90b2w6XCLiqoRcIixnZXNsOlwi4oub77iAXCIsZ2VzbGVzOlwi4qqUXCIsR2ZyOlwi8J2UilwiLGdmcjpcIvCdlKRcIixHZzpcIuKLmVwiLGdnOlwi4omrXCIsZ2dnOlwi4ouZXCIsZ2ltZWw6XCLihLdcIixHSmN5Olwi0INcIixnamN5Olwi0ZNcIixnbDpcIuKJt1wiLGdsYTpcIuKqpVwiLGdsRTpcIuKqklwiLGdsajpcIuKqpFwiLGduYXA6XCLiqopcIixnbmFwcHJveDpcIuKqilwiLGduRTpcIuKJqVwiLGduZTpcIuKqiFwiLGduZXE6XCLiqohcIixnbmVxcTpcIuKJqVwiLGduc2ltOlwi4ounXCIsR29wZjpcIvCdlL5cIixnb3BmOlwi8J2VmFwiLGdyYXZlOlwiYFwiLEdyZWF0ZXJFcXVhbDpcIuKJpVwiLEdyZWF0ZXJFcXVhbExlc3M6XCLii5tcIixHcmVhdGVyRnVsbEVxdWFsOlwi4omnXCIsR3JlYXRlckdyZWF0ZXI6XCLiqqJcIixHcmVhdGVyTGVzczpcIuKJt1wiLEdyZWF0ZXJTbGFudEVxdWFsOlwi4qm+XCIsR3JlYXRlclRpbGRlOlwi4omzXCIsR3NjcjpcIvCdkqJcIixnc2NyOlwi4oSKXCIsZ3NpbTpcIuKJs1wiLGdzaW1lOlwi4qqOXCIsZ3NpbWw6XCLiqpBcIixHdDpcIuKJq1wiLEdUOlwiPlwiLGd0OlwiPlwiLGd0Y2M6XCLiqqdcIixndGNpcjpcIuKpulwiLGd0ZG90Olwi4ouXXCIsZ3RsUGFyOlwi4qaVXCIsZ3RxdWVzdDpcIuKpvFwiLGd0cmFwcHJveDpcIuKqhlwiLGd0cmFycjpcIuKluFwiLGd0cmRvdDpcIuKLl1wiLGd0cmVxbGVzczpcIuKLm1wiLGd0cmVxcWxlc3M6XCLiqoxcIixndHJsZXNzOlwi4om3XCIsZ3Ryc2ltOlwi4omzXCIsZ3ZlcnRuZXFxOlwi4omp77iAXCIsZ3ZuRTpcIuKJqe+4gFwiLEhhY2VrOlwiy4dcIixoYWlyc3A6XCLigIpcIixoYWxmOlwiwr1cIixoYW1pbHQ6XCLihItcIixIQVJEY3k6XCLQqlwiLGhhcmRjeTpcItGKXCIsaEFycjpcIuKHlFwiLGhhcnI6XCLihpRcIixoYXJyY2lyOlwi4qWIXCIsaGFycnc6XCLihq1cIixIYXQ6XCJeXCIsaGJhcjpcIuKEj1wiLEhjaXJjOlwixKRcIixoY2lyYzpcIsSlXCIsaGVhcnRzOlwi4pmlXCIsaGVhcnRzdWl0Olwi4pmlXCIsaGVsbGlwOlwi4oCmXCIsaGVyY29uOlwi4oq5XCIsSGZyOlwi4oSMXCIsaGZyOlwi8J2UpVwiLEhpbGJlcnRTcGFjZTpcIuKEi1wiLGhrc2Vhcm93Olwi4qSlXCIsaGtzd2Fyb3c6XCLipKZcIixob2FycjpcIuKHv1wiLGhvbXRodDpcIuKIu1wiLGhvb2tsZWZ0YXJyb3c6XCLihqlcIixob29rcmlnaHRhcnJvdzpcIuKGqlwiLEhvcGY6XCLihI1cIixob3BmOlwi8J2VmVwiLGhvcmJhcjpcIuKAlVwiLEhvcml6b250YWxMaW5lOlwi4pSAXCIsSHNjcjpcIuKEi1wiLGhzY3I6XCLwnZK9XCIsaHNsYXNoOlwi4oSPXCIsSHN0cm9rOlwixKZcIixoc3Ryb2s6XCLEp1wiLEh1bXBEb3duSHVtcDpcIuKJjlwiLEh1bXBFcXVhbDpcIuKJj1wiLGh5YnVsbDpcIuKBg1wiLGh5cGhlbjpcIuKAkFwiLElhY3V0ZTpcIsONXCIsaWFjdXRlOlwiw61cIixpYzpcIuKBo1wiLEljaXJjOlwiw45cIixpY2lyYzpcIsOuXCIsSWN5Olwi0JhcIixpY3k6XCLQuFwiLElkb3Q6XCLEsFwiLElFY3k6XCLQlVwiLGllY3k6XCLQtVwiLGlleGNsOlwiwqFcIixpZmY6XCLih5RcIixJZnI6XCLihJFcIixpZnI6XCLwnZSmXCIsSWdyYXZlOlwiw4xcIixpZ3JhdmU6XCLDrFwiLGlpOlwi4oWIXCIsaWlpaW50Olwi4qiMXCIsaWlpbnQ6XCLiiK1cIixpaW5maW46XCLip5xcIixpaW90YTpcIuKEqVwiLElKbGlnOlwixLJcIixpamxpZzpcIsSzXCIsSW06XCLihJFcIixJbWFjcjpcIsSqXCIsaW1hY3I6XCLEq1wiLGltYWdlOlwi4oSRXCIsSW1hZ2luYXJ5STpcIuKFiFwiLGltYWdsaW5lOlwi4oSQXCIsaW1hZ3BhcnQ6XCLihJFcIixpbWF0aDpcIsSxXCIsaW1vZjpcIuKKt1wiLGltcGVkOlwixrVcIixJbXBsaWVzOlwi4oeSXCIsaW46XCLiiIhcIixpbmNhcmU6XCLihIVcIixpbmZpbjpcIuKInlwiLGluZmludGllOlwi4qedXCIsaW5vZG90OlwixLFcIixJbnQ6XCLiiKxcIixpbnQ6XCLiiKtcIixpbnRjYWw6XCLiirpcIixpbnRlZ2VyczpcIuKEpFwiLEludGVncmFsOlwi4oirXCIsaW50ZXJjYWw6XCLiirpcIixJbnRlcnNlY3Rpb246XCLii4JcIixpbnRsYXJoazpcIuKol1wiLGludHByb2Q6XCLiqLxcIixJbnZpc2libGVDb21tYTpcIuKBo1wiLEludmlzaWJsZVRpbWVzOlwi4oGiXCIsSU9jeTpcItCBXCIsaW9jeTpcItGRXCIsSW9nb246XCLErlwiLGlvZ29uOlwixK9cIixJb3BmOlwi8J2VgFwiLGlvcGY6XCLwnZWaXCIsSW90YTpcIs6ZXCIsaW90YTpcIs65XCIsaXByb2Q6XCLiqLxcIixpcXVlc3Q6XCLCv1wiLElzY3I6XCLihJBcIixpc2NyOlwi8J2SvlwiLGlzaW46XCLiiIhcIixpc2luZG90Olwi4ou1XCIsaXNpbkU6XCLii7lcIixpc2luczpcIuKLtFwiLGlzaW5zdjpcIuKLs1wiLGlzaW52Olwi4oiIXCIsaXQ6XCLigaJcIixJdGlsZGU6XCLEqFwiLGl0aWxkZTpcIsSpXCIsSXVrY3k6XCLQhlwiLGl1a2N5Olwi0ZZcIixJdW1sOlwiw49cIixpdW1sOlwiw69cIixKY2lyYzpcIsS0XCIsamNpcmM6XCLEtVwiLEpjeTpcItCZXCIsamN5Olwi0LlcIixKZnI6XCLwnZSNXCIsamZyOlwi8J2Up1wiLGptYXRoOlwiyLdcIixKb3BmOlwi8J2VgVwiLGpvcGY6XCLwnZWbXCIsSnNjcjpcIvCdkqVcIixqc2NyOlwi8J2Sv1wiLEpzZXJjeTpcItCIXCIsanNlcmN5Olwi0ZhcIixKdWtjeTpcItCEXCIsanVrY3k6XCLRlFwiLEthcHBhOlwizppcIixrYXBwYTpcIs66XCIsa2FwcGF2Olwiz7BcIixLY2VkaWw6XCLEtlwiLGtjZWRpbDpcIsS3XCIsS2N5Olwi0JpcIixrY3k6XCLQulwiLEtmcjpcIvCdlI5cIixrZnI6XCLwnZSoXCIsa2dyZWVuOlwixLhcIixLSGN5Olwi0KVcIixraGN5Olwi0YVcIixLSmN5Olwi0IxcIixramN5Olwi0ZxcIixLb3BmOlwi8J2VglwiLGtvcGY6XCLwnZWcXCIsS3NjcjpcIvCdkqZcIixrc2NyOlwi8J2TgFwiLGxBYXJyOlwi4oeaXCIsTGFjdXRlOlwixLlcIixsYWN1dGU6XCLEulwiLGxhZW1wdHl2Olwi4qa0XCIsbGFncmFuOlwi4oSSXCIsTGFtYmRhOlwizptcIixsYW1iZGE6XCLOu1wiLExhbmc6XCLin6pcIixsYW5nOlwi4p+oXCIsbGFuZ2Q6XCLippFcIixsYW5nbGU6XCLin6hcIixsYXA6XCLiqoVcIixMYXBsYWNldHJmOlwi4oSSXCIsbGFxdW86XCLCq1wiLExhcnI6XCLihp5cIixsQXJyOlwi4oeQXCIsbGFycjpcIuKGkFwiLGxhcnJiOlwi4oekXCIsbGFycmJmczpcIuKkn1wiLGxhcnJmczpcIuKknVwiLGxhcnJoazpcIuKGqVwiLGxhcnJscDpcIuKGq1wiLGxhcnJwbDpcIuKkuVwiLGxhcnJzaW06XCLipbNcIixsYXJydGw6XCLihqJcIixsYXQ6XCLiqqtcIixsQXRhaWw6XCLipJtcIixsYXRhaWw6XCLipJlcIixsYXRlOlwi4qqtXCIsbGF0ZXM6XCLiqq3vuIBcIixsQmFycjpcIuKkjlwiLGxiYXJyOlwi4qSMXCIsbGJicms6XCLinbJcIixsYnJhY2U6XCJ7XCIsbGJyYWNrOlwiW1wiLGxicmtlOlwi4qaLXCIsbGJya3NsZDpcIuKmj1wiLGxicmtzbHU6XCLipo1cIixMY2Fyb246XCLEvVwiLGxjYXJvbjpcIsS+XCIsTGNlZGlsOlwixLtcIixsY2VkaWw6XCLEvFwiLGxjZWlsOlwi4oyIXCIsbGN1YjpcIntcIixMY3k6XCLQm1wiLGxjeTpcItC7XCIsbGRjYTpcIuKktlwiLGxkcXVvOlwi4oCcXCIsbGRxdW9yOlwi4oCeXCIsbGRyZGhhcjpcIuKlp1wiLGxkcnVzaGFyOlwi4qWLXCIsbGRzaDpcIuKGslwiLGxFOlwi4ommXCIsbGU6XCLiiaRcIixMZWZ0QW5nbGVCcmFja2V0Olwi4p+oXCIsTGVmdEFycm93Olwi4oaQXCIsTGVmdGFycm93Olwi4oeQXCIsbGVmdGFycm93Olwi4oaQXCIsTGVmdEFycm93QmFyOlwi4oekXCIsTGVmdEFycm93UmlnaHRBcnJvdzpcIuKHhlwiLGxlZnRhcnJvd3RhaWw6XCLihqJcIixMZWZ0Q2VpbGluZzpcIuKMiFwiLExlZnREb3VibGVCcmFja2V0Olwi4p+mXCIsTGVmdERvd25UZWVWZWN0b3I6XCLipaFcIixMZWZ0RG93blZlY3RvcjpcIuKHg1wiLExlZnREb3duVmVjdG9yQmFyOlwi4qWZXCIsTGVmdEZsb29yOlwi4oyKXCIsbGVmdGhhcnBvb25kb3duOlwi4oa9XCIsbGVmdGhhcnBvb251cDpcIuKGvFwiLGxlZnRsZWZ0YXJyb3dzOlwi4oeHXCIsTGVmdFJpZ2h0QXJyb3c6XCLihpRcIixMZWZ0cmlnaHRhcnJvdzpcIuKHlFwiLGxlZnRyaWdodGFycm93Olwi4oaUXCIsbGVmdHJpZ2h0YXJyb3dzOlwi4oeGXCIsbGVmdHJpZ2h0aGFycG9vbnM6XCLih4tcIixsZWZ0cmlnaHRzcXVpZ2Fycm93Olwi4oatXCIsTGVmdFJpZ2h0VmVjdG9yOlwi4qWOXCIsTGVmdFRlZTpcIuKKo1wiLExlZnRUZWVBcnJvdzpcIuKGpFwiLExlZnRUZWVWZWN0b3I6XCLipZpcIixsZWZ0dGhyZWV0aW1lczpcIuKLi1wiLExlZnRUcmlhbmdsZTpcIuKKslwiLExlZnRUcmlhbmdsZUJhcjpcIuKnj1wiLExlZnRUcmlhbmdsZUVxdWFsOlwi4oq0XCIsTGVmdFVwRG93blZlY3RvcjpcIuKlkVwiLExlZnRVcFRlZVZlY3RvcjpcIuKloFwiLExlZnRVcFZlY3RvcjpcIuKGv1wiLExlZnRVcFZlY3RvckJhcjpcIuKlmFwiLExlZnRWZWN0b3I6XCLihrxcIixMZWZ0VmVjdG9yQmFyOlwi4qWSXCIsbEVnOlwi4qqLXCIsbGVnOlwi4ouaXCIsbGVxOlwi4omkXCIsbGVxcTpcIuKJplwiLGxlcXNsYW50Olwi4qm9XCIsbGVzOlwi4qm9XCIsbGVzY2M6XCLiqqhcIixsZXNkb3Q6XCLiqb9cIixsZXNkb3RvOlwi4qqBXCIsbGVzZG90b3I6XCLiqoNcIixsZXNnOlwi4oua77iAXCIsbGVzZ2VzOlwi4qqTXCIsbGVzc2FwcHJveDpcIuKqhVwiLGxlc3Nkb3Q6XCLii5ZcIixsZXNzZXFndHI6XCLii5pcIixsZXNzZXFxZ3RyOlwi4qqLXCIsTGVzc0VxdWFsR3JlYXRlcjpcIuKLmlwiLExlc3NGdWxsRXF1YWw6XCLiiaZcIixMZXNzR3JlYXRlcjpcIuKJtlwiLGxlc3NndHI6XCLiibZcIixMZXNzTGVzczpcIuKqoVwiLGxlc3NzaW06XCLiibJcIixMZXNzU2xhbnRFcXVhbDpcIuKpvVwiLExlc3NUaWxkZTpcIuKJslwiLGxmaXNodDpcIuKlvFwiLGxmbG9vcjpcIuKMilwiLExmcjpcIvCdlI9cIixsZnI6XCLwnZSpXCIsbGc6XCLiibZcIixsZ0U6XCLiqpFcIixsSGFyOlwi4qWiXCIsbGhhcmQ6XCLihr1cIixsaGFydTpcIuKGvFwiLGxoYXJ1bDpcIuKlqlwiLGxoYmxrOlwi4paEXCIsTEpjeTpcItCJXCIsbGpjeTpcItGZXCIsTGw6XCLii5hcIixsbDpcIuKJqlwiLGxsYXJyOlwi4oeHXCIsbGxjb3JuZXI6XCLijJ5cIixMbGVmdGFycm93Olwi4oeaXCIsbGxoYXJkOlwi4qWrXCIsbGx0cmk6XCLil7pcIixMbWlkb3Q6XCLEv1wiLGxtaWRvdDpcIsWAXCIsbG1vdXN0Olwi4o6wXCIsbG1vdXN0YWNoZTpcIuKOsFwiLGxuYXA6XCLiqolcIixsbmFwcHJveDpcIuKqiVwiLGxuRTpcIuKJqFwiLGxuZTpcIuKqh1wiLGxuZXE6XCLiqodcIixsbmVxcTpcIuKJqFwiLGxuc2ltOlwi4oumXCIsbG9hbmc6XCLin6xcIixsb2FycjpcIuKHvVwiLGxvYnJrOlwi4p+mXCIsTG9uZ0xlZnRBcnJvdzpcIuKftVwiLExvbmdsZWZ0YXJyb3c6XCLin7hcIixsb25nbGVmdGFycm93Olwi4p+1XCIsTG9uZ0xlZnRSaWdodEFycm93Olwi4p+3XCIsTG9uZ2xlZnRyaWdodGFycm93Olwi4p+6XCIsbG9uZ2xlZnRyaWdodGFycm93Olwi4p+3XCIsbG9uZ21hcHN0bzpcIuKfvFwiLExvbmdSaWdodEFycm93Olwi4p+2XCIsTG9uZ3JpZ2h0YXJyb3c6XCLin7lcIixsb25ncmlnaHRhcnJvdzpcIuKftlwiLGxvb3BhcnJvd2xlZnQ6XCLihqtcIixsb29wYXJyb3dyaWdodDpcIuKGrFwiLGxvcGFyOlwi4qaFXCIsTG9wZjpcIvCdlYNcIixsb3BmOlwi8J2VnVwiLGxvcGx1czpcIuKorVwiLGxvdGltZXM6XCLiqLRcIixsb3dhc3Q6XCLiiJdcIixsb3diYXI6XCJfXCIsTG93ZXJMZWZ0QXJyb3c6XCLihplcIixMb3dlclJpZ2h0QXJyb3c6XCLihphcIixsb3o6XCLil4pcIixsb3plbmdlOlwi4peKXCIsbG96ZjpcIuKnq1wiLGxwYXI6XCIoXCIsbHBhcmx0Olwi4qaTXCIsbHJhcnI6XCLih4ZcIixscmNvcm5lcjpcIuKMn1wiLGxyaGFyOlwi4oeLXCIsbHJoYXJkOlwi4qWtXCIsbHJtOlwi4oCOXCIsbHJ0cmk6XCLiir9cIixsc2FxdW86XCLigLlcIixMc2NyOlwi4oSSXCIsbHNjcjpcIvCdk4FcIixMc2g6XCLihrBcIixsc2g6XCLihrBcIixsc2ltOlwi4omyXCIsbHNpbWU6XCLiqo1cIixsc2ltZzpcIuKqj1wiLGxzcWI6XCJbXCIsbHNxdW86XCLigJhcIixsc3F1b3I6XCLigJpcIixMc3Ryb2s6XCLFgVwiLGxzdHJvazpcIsWCXCIsTHQ6XCLiiapcIixMVDpcIjxcIixsdDpcIjxcIixsdGNjOlwi4qqmXCIsbHRjaXI6XCLiqblcIixsdGRvdDpcIuKLllwiLGx0aHJlZTpcIuKLi1wiLGx0aW1lczpcIuKLiVwiLGx0bGFycjpcIuKltlwiLGx0cXVlc3Q6XCLiqbtcIixsdHJpOlwi4peDXCIsbHRyaWU6XCLiirRcIixsdHJpZjpcIuKXglwiLGx0clBhcjpcIuKmllwiLGx1cmRzaGFyOlwi4qWKXCIsbHVydWhhcjpcIuKlplwiLGx2ZXJ0bmVxcTpcIuKJqO+4gFwiLGx2bkU6XCLiiajvuIBcIixtYWNyOlwiwq9cIixtYWxlOlwi4pmCXCIsbWFsdDpcIuKcoFwiLG1hbHRlc2U6XCLinKBcIixNYXA6XCLipIVcIixtYXA6XCLihqZcIixtYXBzdG86XCLihqZcIixtYXBzdG9kb3duOlwi4oanXCIsbWFwc3RvbGVmdDpcIuKGpFwiLG1hcHN0b3VwOlwi4oalXCIsbWFya2VyOlwi4pauXCIsbWNvbW1hOlwi4qipXCIsTWN5Olwi0JxcIixtY3k6XCLQvFwiLG1kYXNoOlwi4oCUXCIsbUREb3Q6XCLiiLpcIixtZWFzdXJlZGFuZ2xlOlwi4oihXCIsTWVkaXVtU3BhY2U6XCLigZ9cIixNZWxsaW50cmY6XCLihLNcIixNZnI6XCLwnZSQXCIsbWZyOlwi8J2UqlwiLG1obzpcIuKEp1wiLG1pY3JvOlwiwrVcIixtaWQ6XCLiiKNcIixtaWRhc3Q6XCIqXCIsbWlkY2lyOlwi4quwXCIsbWlkZG90OlwiwrdcIixtaW51czpcIuKIklwiLG1pbnVzYjpcIuKKn1wiLG1pbnVzZDpcIuKIuFwiLG1pbnVzZHU6XCLiqKpcIixNaW51c1BsdXM6XCLiiJNcIixtbGNwOlwi4qubXCIsbWxkcjpcIuKAplwiLG1ucGx1czpcIuKIk1wiLG1vZGVsczpcIuKKp1wiLE1vcGY6XCLwnZWEXCIsbW9wZjpcIvCdlZ5cIixtcDpcIuKIk1wiLE1zY3I6XCLihLNcIixtc2NyOlwi8J2TglwiLG1zdHBvczpcIuKIvlwiLE11OlwizpxcIixtdTpcIs68XCIsbXVsdGltYXA6XCLiirhcIixtdW1hcDpcIuKKuFwiLG5hYmxhOlwi4oiHXCIsTmFjdXRlOlwixYNcIixuYWN1dGU6XCLFhFwiLG5hbmc6XCLiiKDig5JcIixuYXA6XCLiiYlcIixuYXBFOlwi4qmwzLhcIixuYXBpZDpcIuKJi8y4XCIsbmFwb3M6XCLFiVwiLG5hcHByb3g6XCLiiYlcIixuYXR1cjpcIuKZrlwiLG5hdHVyYWw6XCLima5cIixuYXR1cmFsczpcIuKElVwiLG5ic3A6XCLCoFwiLG5idW1wOlwi4omOzLhcIixuYnVtcGU6XCLiiY/MuFwiLG5jYXA6XCLiqYNcIixOY2Fyb246XCLFh1wiLG5jYXJvbjpcIsWIXCIsTmNlZGlsOlwixYVcIixuY2VkaWw6XCLFhlwiLG5jb25nOlwi4omHXCIsbmNvbmdkb3Q6XCLiqa3MuFwiLG5jdXA6XCLiqYJcIixOY3k6XCLQnVwiLG5jeTpcItC9XCIsbmRhc2g6XCLigJNcIixuZTpcIuKJoFwiLG5lYXJoazpcIuKkpFwiLG5lQXJyOlwi4oeXXCIsbmVhcnI6XCLihpdcIixuZWFycm93Olwi4oaXXCIsbmVkb3Q6XCLiiZDMuFwiLE5lZ2F0aXZlTWVkaXVtU3BhY2U6XCLigItcIixOZWdhdGl2ZVRoaWNrU3BhY2U6XCLigItcIixOZWdhdGl2ZVRoaW5TcGFjZTpcIuKAi1wiLE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTpcIuKAi1wiLG5lcXVpdjpcIuKJolwiLG5lc2VhcjpcIuKkqFwiLG5lc2ltOlwi4omCzLhcIixOZXN0ZWRHcmVhdGVyR3JlYXRlcjpcIuKJq1wiLE5lc3RlZExlc3NMZXNzOlwi4omqXCIsTmV3TGluZTpcIlxcblwiLG5leGlzdDpcIuKIhFwiLG5leGlzdHM6XCLiiIRcIixOZnI6XCLwnZSRXCIsbmZyOlwi8J2Uq1wiLG5nRTpcIuKJp8y4XCIsbmdlOlwi4omxXCIsbmdlcTpcIuKJsVwiLG5nZXFxOlwi4omnzLhcIixuZ2Vxc2xhbnQ6XCLiqb7MuFwiLG5nZXM6XCLiqb7MuFwiLG5HZzpcIuKLmcy4XCIsbmdzaW06XCLiibVcIixuR3Q6XCLiiavig5JcIixuZ3Q6XCLiia9cIixuZ3RyOlwi4omvXCIsbkd0djpcIuKJq8y4XCIsbmhBcnI6XCLih45cIixuaGFycjpcIuKGrlwiLG5ocGFyOlwi4quyXCIsbmk6XCLiiItcIixuaXM6XCLii7xcIixuaXNkOlwi4ou6XCIsbml2Olwi4oiLXCIsTkpjeTpcItCKXCIsbmpjeTpcItGaXCIsbmxBcnI6XCLih41cIixubGFycjpcIuKGmlwiLG5sZHI6XCLigKVcIixubEU6XCLiiabMuFwiLG5sZTpcIuKJsFwiLG5MZWZ0YXJyb3c6XCLih41cIixubGVmdGFycm93Olwi4oaaXCIsbkxlZnRyaWdodGFycm93Olwi4oeOXCIsbmxlZnRyaWdodGFycm93Olwi4oauXCIsbmxlcTpcIuKJsFwiLG5sZXFxOlwi4ommzLhcIixubGVxc2xhbnQ6XCLiqb3MuFwiLG5sZXM6XCLiqb3MuFwiLG5sZXNzOlwi4omuXCIsbkxsOlwi4ouYzLhcIixubHNpbTpcIuKJtFwiLG5MdDpcIuKJquKDklwiLG5sdDpcIuKJrlwiLG5sdHJpOlwi4ouqXCIsbmx0cmllOlwi4ousXCIsbkx0djpcIuKJqsy4XCIsbm1pZDpcIuKIpFwiLE5vQnJlYWs6XCLigaBcIixOb25CcmVha2luZ1NwYWNlOlwiwqBcIixOb3BmOlwi4oSVXCIsbm9wZjpcIvCdlZ9cIixOb3Q6XCLiq6xcIixub3Q6XCLCrFwiLE5vdENvbmdydWVudDpcIuKJolwiLE5vdEN1cENhcDpcIuKJrVwiLE5vdERvdWJsZVZlcnRpY2FsQmFyOlwi4oimXCIsTm90RWxlbWVudDpcIuKIiVwiLE5vdEVxdWFsOlwi4omgXCIsTm90RXF1YWxUaWxkZTpcIuKJgsy4XCIsTm90RXhpc3RzOlwi4oiEXCIsTm90R3JlYXRlcjpcIuKJr1wiLE5vdEdyZWF0ZXJFcXVhbDpcIuKJsVwiLE5vdEdyZWF0ZXJGdWxsRXF1YWw6XCLiiafMuFwiLE5vdEdyZWF0ZXJHcmVhdGVyOlwi4omrzLhcIixOb3RHcmVhdGVyTGVzczpcIuKJuVwiLE5vdEdyZWF0ZXJTbGFudEVxdWFsOlwi4qm+zLhcIixOb3RHcmVhdGVyVGlsZGU6XCLiibVcIixOb3RIdW1wRG93bkh1bXA6XCLiiY7MuFwiLE5vdEh1bXBFcXVhbDpcIuKJj8y4XCIsbm90aW46XCLiiIlcIixub3RpbmRvdDpcIuKLtcy4XCIsbm90aW5FOlwi4ou5zLhcIixub3RpbnZhOlwi4oiJXCIsbm90aW52YjpcIuKLt1wiLG5vdGludmM6XCLii7ZcIixOb3RMZWZ0VHJpYW5nbGU6XCLii6pcIixOb3RMZWZ0VHJpYW5nbGVCYXI6XCLip4/MuFwiLE5vdExlZnRUcmlhbmdsZUVxdWFsOlwi4ousXCIsTm90TGVzczpcIuKJrlwiLE5vdExlc3NFcXVhbDpcIuKJsFwiLE5vdExlc3NHcmVhdGVyOlwi4om4XCIsTm90TGVzc0xlc3M6XCLiiarMuFwiLE5vdExlc3NTbGFudEVxdWFsOlwi4qm9zLhcIixOb3RMZXNzVGlsZGU6XCLiibRcIixOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcjpcIuKqosy4XCIsTm90TmVzdGVkTGVzc0xlc3M6XCLiqqHMuFwiLG5vdG5pOlwi4oiMXCIsbm90bml2YTpcIuKIjFwiLG5vdG5pdmI6XCLii75cIixub3RuaXZjOlwi4ou9XCIsTm90UHJlY2VkZXM6XCLiioBcIixOb3RQcmVjZWRlc0VxdWFsOlwi4qqvzLhcIixOb3RQcmVjZWRlc1NsYW50RXF1YWw6XCLii6BcIixOb3RSZXZlcnNlRWxlbWVudDpcIuKIjFwiLE5vdFJpZ2h0VHJpYW5nbGU6XCLii6tcIixOb3RSaWdodFRyaWFuZ2xlQmFyOlwi4qeQzLhcIixOb3RSaWdodFRyaWFuZ2xlRXF1YWw6XCLii61cIixOb3RTcXVhcmVTdWJzZXQ6XCLiio/MuFwiLE5vdFNxdWFyZVN1YnNldEVxdWFsOlwi4ouiXCIsTm90U3F1YXJlU3VwZXJzZXQ6XCLiipDMuFwiLE5vdFNxdWFyZVN1cGVyc2V0RXF1YWw6XCLii6NcIixOb3RTdWJzZXQ6XCLiioLig5JcIixOb3RTdWJzZXRFcXVhbDpcIuKKiFwiLE5vdFN1Y2NlZWRzOlwi4oqBXCIsTm90U3VjY2VlZHNFcXVhbDpcIuKqsMy4XCIsTm90U3VjY2VlZHNTbGFudEVxdWFsOlwi4ouhXCIsTm90U3VjY2VlZHNUaWxkZTpcIuKJv8y4XCIsTm90U3VwZXJzZXQ6XCLiioPig5JcIixOb3RTdXBlcnNldEVxdWFsOlwi4oqJXCIsTm90VGlsZGU6XCLiiYFcIixOb3RUaWxkZUVxdWFsOlwi4omEXCIsTm90VGlsZGVGdWxsRXF1YWw6XCLiiYdcIixOb3RUaWxkZVRpbGRlOlwi4omJXCIsTm90VmVydGljYWxCYXI6XCLiiKRcIixucGFyOlwi4oimXCIsbnBhcmFsbGVsOlwi4oimXCIsbnBhcnNsOlwi4qu94oOlXCIsbnBhcnQ6XCLiiILMuFwiLG5wb2xpbnQ6XCLiqJRcIixucHI6XCLiioBcIixucHJjdWU6XCLii6BcIixucHJlOlwi4qqvzLhcIixucHJlYzpcIuKKgFwiLG5wcmVjZXE6XCLiqq/MuFwiLG5yQXJyOlwi4oePXCIsbnJhcnI6XCLihptcIixucmFycmM6XCLipLPMuFwiLG5yYXJydzpcIuKGncy4XCIsblJpZ2h0YXJyb3c6XCLih49cIixucmlnaHRhcnJvdzpcIuKGm1wiLG5ydHJpOlwi4ourXCIsbnJ0cmllOlwi4outXCIsbnNjOlwi4oqBXCIsbnNjY3VlOlwi4ouhXCIsbnNjZTpcIuKqsMy4XCIsTnNjcjpcIvCdkqlcIixuc2NyOlwi8J2Tg1wiLG5zaG9ydG1pZDpcIuKIpFwiLG5zaG9ydHBhcmFsbGVsOlwi4oimXCIsbnNpbTpcIuKJgVwiLG5zaW1lOlwi4omEXCIsbnNpbWVxOlwi4omEXCIsbnNtaWQ6XCLiiKRcIixuc3BhcjpcIuKIplwiLG5zcXN1YmU6XCLii6JcIixuc3FzdXBlOlwi4oujXCIsbnN1YjpcIuKKhFwiLG5zdWJFOlwi4quFzLhcIixuc3ViZTpcIuKKiFwiLG5zdWJzZXQ6XCLiioLig5JcIixuc3Vic2V0ZXE6XCLiiohcIixuc3Vic2V0ZXFxOlwi4quFzLhcIixuc3VjYzpcIuKKgVwiLG5zdWNjZXE6XCLiqrDMuFwiLG5zdXA6XCLiioVcIixuc3VwRTpcIuKrhsy4XCIsbnN1cGU6XCLiiolcIixuc3Vwc2V0Olwi4oqD4oOSXCIsbnN1cHNldGVxOlwi4oqJXCIsbnN1cHNldGVxcTpcIuKrhsy4XCIsbnRnbDpcIuKJuVwiLE50aWxkZTpcIsORXCIsbnRpbGRlOlwiw7FcIixudGxnOlwi4om4XCIsbnRyaWFuZ2xlbGVmdDpcIuKLqlwiLG50cmlhbmdsZWxlZnRlcTpcIuKLrFwiLG50cmlhbmdsZXJpZ2h0Olwi4ourXCIsbnRyaWFuZ2xlcmlnaHRlcTpcIuKLrVwiLE51Olwizp1cIixudTpcIs69XCIsbnVtOlwiI1wiLG51bWVybzpcIuKEllwiLG51bXNwOlwi4oCHXCIsbnZhcDpcIuKJjeKDklwiLG5WRGFzaDpcIuKKr1wiLG5WZGFzaDpcIuKKrlwiLG52RGFzaDpcIuKKrVwiLG52ZGFzaDpcIuKKrFwiLG52Z2U6XCLiiaXig5JcIixudmd0OlwiPuKDklwiLG52SGFycjpcIuKkhFwiLG52aW5maW46XCLip55cIixudmxBcnI6XCLipIJcIixudmxlOlwi4omk4oOSXCIsbnZsdDpcIjzig5JcIixudmx0cmllOlwi4oq04oOSXCIsbnZyQXJyOlwi4qSDXCIsbnZydHJpZTpcIuKKteKDklwiLG52c2ltOlwi4oi84oOSXCIsbndhcmhrOlwi4qSjXCIsbndBcnI6XCLih5ZcIixud2FycjpcIuKGllwiLG53YXJyb3c6XCLihpZcIixud25lYXI6XCLipKdcIixPYWN1dGU6XCLDk1wiLG9hY3V0ZTpcIsOzXCIsb2FzdDpcIuKKm1wiLG9jaXI6XCLiippcIixPY2lyYzpcIsOUXCIsb2NpcmM6XCLDtFwiLE9jeTpcItCeXCIsb2N5Olwi0L5cIixvZGFzaDpcIuKKnVwiLE9kYmxhYzpcIsWQXCIsb2RibGFjOlwixZFcIixvZGl2Olwi4qi4XCIsb2RvdDpcIuKKmVwiLG9kc29sZDpcIuKmvFwiLE9FbGlnOlwixZJcIixvZWxpZzpcIsWTXCIsb2ZjaXI6XCLipr9cIixPZnI6XCLwnZSSXCIsb2ZyOlwi8J2UrFwiLG9nb246XCLLm1wiLE9ncmF2ZTpcIsOSXCIsb2dyYXZlOlwiw7JcIixvZ3Q6XCLip4FcIixvaGJhcjpcIuKmtVwiLG9obTpcIs6pXCIsb2ludDpcIuKIrlwiLG9sYXJyOlwi4oa6XCIsb2xjaXI6XCLipr5cIixvbGNyb3NzOlwi4qa7XCIsb2xpbmU6XCLigL5cIixvbHQ6XCLip4BcIixPbWFjcjpcIsWMXCIsb21hY3I6XCLFjVwiLE9tZWdhOlwizqlcIixvbWVnYTpcIs+JXCIsT21pY3JvbjpcIs6fXCIsb21pY3JvbjpcIs6/XCIsb21pZDpcIuKmtlwiLG9taW51czpcIuKKllwiLE9vcGY6XCLwnZWGXCIsb29wZjpcIvCdlaBcIixvcGFyOlwi4qa3XCIsT3BlbkN1cmx5RG91YmxlUXVvdGU6XCLigJxcIixPcGVuQ3VybHlRdW90ZTpcIuKAmFwiLG9wZXJwOlwi4qa5XCIsb3BsdXM6XCLiipVcIixPcjpcIuKplFwiLG9yOlwi4oioXCIsb3JhcnI6XCLihrtcIixvcmQ6XCLiqZ1cIixvcmRlcjpcIuKEtFwiLG9yZGVyb2Y6XCLihLRcIixvcmRmOlwiwqpcIixvcmRtOlwiwrpcIixvcmlnb2Y6XCLiirZcIixvcm9yOlwi4qmWXCIsb3JzbG9wZTpcIuKpl1wiLG9ydjpcIuKpm1wiLG9TOlwi4pOIXCIsT3NjcjpcIvCdkqpcIixvc2NyOlwi4oS0XCIsT3NsYXNoOlwiw5hcIixvc2xhc2g6XCLDuFwiLG9zb2w6XCLiiphcIixPdGlsZGU6XCLDlVwiLG90aWxkZTpcIsO1XCIsT3RpbWVzOlwi4qi3XCIsb3RpbWVzOlwi4oqXXCIsb3RpbWVzYXM6XCLiqLZcIixPdW1sOlwiw5ZcIixvdW1sOlwiw7ZcIixvdmJhcjpcIuKMvVwiLE92ZXJCYXI6XCLigL5cIixPdmVyQnJhY2U6XCLij55cIixPdmVyQnJhY2tldDpcIuKOtFwiLE92ZXJQYXJlbnRoZXNpczpcIuKPnFwiLHBhcjpcIuKIpVwiLHBhcmE6XCLCtlwiLHBhcmFsbGVsOlwi4oilXCIscGFyc2ltOlwi4quzXCIscGFyc2w6XCLiq71cIixwYXJ0Olwi4oiCXCIsUGFydGlhbEQ6XCLiiIJcIixQY3k6XCLQn1wiLHBjeTpcItC/XCIscGVyY250OlwiJVwiLHBlcmlvZDpcIi5cIixwZXJtaWw6XCLigLBcIixwZXJwOlwi4oqlXCIscGVydGVuazpcIuKAsVwiLFBmcjpcIvCdlJNcIixwZnI6XCLwnZStXCIsUGhpOlwizqZcIixwaGk6XCLPhlwiLHBoaXY6XCLPlVwiLHBobW1hdDpcIuKEs1wiLHBob25lOlwi4piOXCIsUGk6XCLOoFwiLHBpOlwiz4BcIixwaXRjaGZvcms6XCLii5RcIixwaXY6XCLPllwiLHBsYW5jazpcIuKEj1wiLHBsYW5ja2g6XCLihI5cIixwbGFua3Y6XCLihI9cIixwbHVzOlwiK1wiLHBsdXNhY2lyOlwi4qijXCIscGx1c2I6XCLiip5cIixwbHVzY2lyOlwi4qiiXCIscGx1c2RvOlwi4oiUXCIscGx1c2R1Olwi4qilXCIscGx1c2U6XCLiqbJcIixQbHVzTWludXM6XCLCsVwiLHBsdXNtbjpcIsKxXCIscGx1c3NpbTpcIuKoplwiLHBsdXN0d286XCLiqKdcIixwbTpcIsKxXCIsUG9pbmNhcmVwbGFuZTpcIuKEjFwiLHBvaW50aW50Olwi4qiVXCIsUG9wZjpcIuKEmVwiLHBvcGY6XCLwnZWhXCIscG91bmQ6XCLCo1wiLFByOlwi4qq7XCIscHI6XCLiibpcIixwcmFwOlwi4qq3XCIscHJjdWU6XCLiibxcIixwckU6XCLiqrNcIixwcmU6XCLiqq9cIixwcmVjOlwi4om6XCIscHJlY2FwcHJveDpcIuKqt1wiLHByZWNjdXJseWVxOlwi4om8XCIsUHJlY2VkZXM6XCLiibpcIixQcmVjZWRlc0VxdWFsOlwi4qqvXCIsUHJlY2VkZXNTbGFudEVxdWFsOlwi4om8XCIsUHJlY2VkZXNUaWxkZTpcIuKJvlwiLHByZWNlcTpcIuKqr1wiLHByZWNuYXBwcm94Olwi4qq5XCIscHJlY25lcXE6XCLiqrVcIixwcmVjbnNpbTpcIuKLqFwiLHByZWNzaW06XCLiib5cIixQcmltZTpcIuKAs1wiLHByaW1lOlwi4oCyXCIscHJpbWVzOlwi4oSZXCIscHJuYXA6XCLiqrlcIixwcm5FOlwi4qq1XCIscHJuc2ltOlwi4ouoXCIscHJvZDpcIuKIj1wiLFByb2R1Y3Q6XCLiiI9cIixwcm9mYWxhcjpcIuKMrlwiLHByb2ZsaW5lOlwi4oySXCIscHJvZnN1cmY6XCLijJNcIixwcm9wOlwi4oidXCIsUHJvcG9ydGlvbjpcIuKIt1wiLFByb3BvcnRpb25hbDpcIuKInVwiLHByb3B0bzpcIuKInVwiLHByc2ltOlwi4om+XCIscHJ1cmVsOlwi4oqwXCIsUHNjcjpcIvCdkqtcIixwc2NyOlwi8J2ThVwiLFBzaTpcIs6oXCIscHNpOlwiz4hcIixwdW5jc3A6XCLigIhcIixRZnI6XCLwnZSUXCIscWZyOlwi8J2UrlwiLHFpbnQ6XCLiqIxcIixRb3BmOlwi4oSaXCIscW9wZjpcIvCdlaJcIixxcHJpbWU6XCLigZdcIixRc2NyOlwi8J2SrFwiLHFzY3I6XCLwnZOGXCIscXVhdGVybmlvbnM6XCLihI1cIixxdWF0aW50Olwi4qiWXCIscXVlc3Q6XCI/XCIscXVlc3RlcTpcIuKJn1wiLFFVT1Q6J1wiJyxxdW90OidcIicsckFhcnI6XCLih5tcIixyYWNlOlwi4oi9zLFcIixSYWN1dGU6XCLFlFwiLHJhY3V0ZTpcIsWVXCIscmFkaWM6XCLiiJpcIixyYWVtcHR5djpcIuKms1wiLFJhbmc6XCLin6tcIixyYW5nOlwi4p+pXCIscmFuZ2Q6XCLippJcIixyYW5nZTpcIuKmpVwiLHJhbmdsZTpcIuKfqVwiLHJhcXVvOlwiwrtcIixSYXJyOlwi4oagXCIsckFycjpcIuKHklwiLHJhcnI6XCLihpJcIixyYXJyYXA6XCLipbVcIixyYXJyYjpcIuKHpVwiLHJhcnJiZnM6XCLipKBcIixyYXJyYzpcIuKks1wiLHJhcnJmczpcIuKknlwiLHJhcnJoazpcIuKGqlwiLHJhcnJscDpcIuKGrFwiLHJhcnJwbDpcIuKlhVwiLHJhcnJzaW06XCLipbRcIixSYXJydGw6XCLipJZcIixyYXJydGw6XCLihqNcIixyYXJydzpcIuKGnVwiLHJBdGFpbDpcIuKknFwiLHJhdGFpbDpcIuKkmlwiLHJhdGlvOlwi4oi2XCIscmF0aW9uYWxzOlwi4oSaXCIsUkJhcnI6XCLipJBcIixyQmFycjpcIuKkj1wiLHJiYXJyOlwi4qSNXCIscmJicms6XCLinbNcIixyYnJhY2U6XCJ9XCIscmJyYWNrOlwiXVwiLHJicmtlOlwi4qaMXCIscmJya3NsZDpcIuKmjlwiLHJicmtzbHU6XCLippBcIixSY2Fyb246XCLFmFwiLHJjYXJvbjpcIsWZXCIsUmNlZGlsOlwixZZcIixyY2VkaWw6XCLFl1wiLHJjZWlsOlwi4oyJXCIscmN1YjpcIn1cIixSY3k6XCLQoFwiLHJjeTpcItGAXCIscmRjYTpcIuKkt1wiLHJkbGRoYXI6XCLipalcIixyZHF1bzpcIuKAnVwiLHJkcXVvcjpcIuKAnVwiLHJkc2g6XCLihrNcIixSZTpcIuKEnFwiLHJlYWw6XCLihJxcIixyZWFsaW5lOlwi4oSbXCIscmVhbHBhcnQ6XCLihJxcIixyZWFsczpcIuKEnVwiLHJlY3Q6XCLilq1cIixSRUc6XCLCrlwiLHJlZzpcIsKuXCIsUmV2ZXJzZUVsZW1lbnQ6XCLiiItcIixSZXZlcnNlRXF1aWxpYnJpdW06XCLih4tcIixSZXZlcnNlVXBFcXVpbGlicml1bTpcIuKlr1wiLHJmaXNodDpcIuKlvVwiLHJmbG9vcjpcIuKMi1wiLFJmcjpcIuKEnFwiLHJmcjpcIvCdlK9cIixySGFyOlwi4qWkXCIscmhhcmQ6XCLih4FcIixyaGFydTpcIuKHgFwiLHJoYXJ1bDpcIuKlrFwiLFJobzpcIs6hXCIscmhvOlwiz4FcIixyaG92Olwiz7FcIixSaWdodEFuZ2xlQnJhY2tldDpcIuKfqVwiLFJpZ2h0QXJyb3c6XCLihpJcIixSaWdodGFycm93Olwi4oeSXCIscmlnaHRhcnJvdzpcIuKGklwiLFJpZ2h0QXJyb3dCYXI6XCLih6VcIixSaWdodEFycm93TGVmdEFycm93Olwi4oeEXCIscmlnaHRhcnJvd3RhaWw6XCLihqNcIixSaWdodENlaWxpbmc6XCLijIlcIixSaWdodERvdWJsZUJyYWNrZXQ6XCLin6dcIixSaWdodERvd25UZWVWZWN0b3I6XCLipZ1cIixSaWdodERvd25WZWN0b3I6XCLih4JcIixSaWdodERvd25WZWN0b3JCYXI6XCLipZVcIixSaWdodEZsb29yOlwi4oyLXCIscmlnaHRoYXJwb29uZG93bjpcIuKHgVwiLHJpZ2h0aGFycG9vbnVwOlwi4oeAXCIscmlnaHRsZWZ0YXJyb3dzOlwi4oeEXCIscmlnaHRsZWZ0aGFycG9vbnM6XCLih4xcIixyaWdodHJpZ2h0YXJyb3dzOlwi4oeJXCIscmlnaHRzcXVpZ2Fycm93Olwi4oadXCIsUmlnaHRUZWU6XCLiiqJcIixSaWdodFRlZUFycm93Olwi4oamXCIsUmlnaHRUZWVWZWN0b3I6XCLipZtcIixyaWdodHRocmVldGltZXM6XCLii4xcIixSaWdodFRyaWFuZ2xlOlwi4oqzXCIsUmlnaHRUcmlhbmdsZUJhcjpcIuKnkFwiLFJpZ2h0VHJpYW5nbGVFcXVhbDpcIuKKtVwiLFJpZ2h0VXBEb3duVmVjdG9yOlwi4qWPXCIsUmlnaHRVcFRlZVZlY3RvcjpcIuKlnFwiLFJpZ2h0VXBWZWN0b3I6XCLihr5cIixSaWdodFVwVmVjdG9yQmFyOlwi4qWUXCIsUmlnaHRWZWN0b3I6XCLih4BcIixSaWdodFZlY3RvckJhcjpcIuKlk1wiLHJpbmc6XCLLmlwiLHJpc2luZ2RvdHNlcTpcIuKJk1wiLHJsYXJyOlwi4oeEXCIscmxoYXI6XCLih4xcIixybG06XCLigI9cIixybW91c3Q6XCLijrFcIixybW91c3RhY2hlOlwi4o6xXCIscm5taWQ6XCLiq65cIixyb2FuZzpcIuKfrVwiLHJvYXJyOlwi4oe+XCIscm9icms6XCLin6dcIixyb3BhcjpcIuKmhlwiLFJvcGY6XCLihJ1cIixyb3BmOlwi8J2Vo1wiLHJvcGx1czpcIuKorlwiLHJvdGltZXM6XCLiqLVcIixSb3VuZEltcGxpZXM6XCLipbBcIixycGFyOlwiKVwiLHJwYXJndDpcIuKmlFwiLHJwcG9saW50Olwi4qiSXCIscnJhcnI6XCLih4lcIixScmlnaHRhcnJvdzpcIuKHm1wiLHJzYXF1bzpcIuKAulwiLFJzY3I6XCLihJtcIixyc2NyOlwi8J2Th1wiLFJzaDpcIuKGsVwiLHJzaDpcIuKGsVwiLHJzcWI6XCJdXCIscnNxdW86XCLigJlcIixyc3F1b3I6XCLigJlcIixydGhyZWU6XCLii4xcIixydGltZXM6XCLii4pcIixydHJpOlwi4pa5XCIscnRyaWU6XCLiirVcIixydHJpZjpcIuKWuFwiLHJ0cmlsdHJpOlwi4qeOXCIsUnVsZURlbGF5ZWQ6XCLip7RcIixydWx1aGFyOlwi4qWoXCIscng6XCLihJ5cIixTYWN1dGU6XCLFmlwiLHNhY3V0ZTpcIsWbXCIsc2JxdW86XCLigJpcIixTYzpcIuKqvFwiLHNjOlwi4om7XCIsc2NhcDpcIuKquFwiLFNjYXJvbjpcIsWgXCIsc2Nhcm9uOlwixaFcIixzY2N1ZTpcIuKJvVwiLHNjRTpcIuKqtFwiLHNjZTpcIuKqsFwiLFNjZWRpbDpcIsWeXCIsc2NlZGlsOlwixZ9cIixTY2lyYzpcIsWcXCIsc2NpcmM6XCLFnVwiLHNjbmFwOlwi4qq6XCIsc2NuRTpcIuKqtlwiLHNjbnNpbTpcIuKLqVwiLHNjcG9saW50Olwi4qiTXCIsc2NzaW06XCLiib9cIixTY3k6XCLQoVwiLHNjeTpcItGBXCIsc2RvdDpcIuKLhVwiLHNkb3RiOlwi4oqhXCIsc2RvdGU6XCLiqaZcIixzZWFyaGs6XCLipKVcIixzZUFycjpcIuKHmFwiLHNlYXJyOlwi4oaYXCIsc2VhcnJvdzpcIuKGmFwiLHNlY3Q6XCLCp1wiLHNlbWk6XCI7XCIsc2Vzd2FyOlwi4qSpXCIsc2V0bWludXM6XCLiiJZcIixzZXRtbjpcIuKIllwiLHNleHQ6XCLinLZcIixTZnI6XCLwnZSWXCIsc2ZyOlwi8J2UsFwiLHNmcm93bjpcIuKMolwiLHNoYXJwOlwi4pmvXCIsU0hDSGN5Olwi0KlcIixzaGNoY3k6XCLRiVwiLFNIY3k6XCLQqFwiLHNoY3k6XCLRiFwiLFNob3J0RG93bkFycm93Olwi4oaTXCIsU2hvcnRMZWZ0QXJyb3c6XCLihpBcIixzaG9ydG1pZDpcIuKIo1wiLHNob3J0cGFyYWxsZWw6XCLiiKVcIixTaG9ydFJpZ2h0QXJyb3c6XCLihpJcIixTaG9ydFVwQXJyb3c6XCLihpFcIixzaHk6XCLCrVwiLFNpZ21hOlwizqNcIixzaWdtYTpcIs+DXCIsc2lnbWFmOlwiz4JcIixzaWdtYXY6XCLPglwiLHNpbTpcIuKIvFwiLHNpbWRvdDpcIuKpqlwiLHNpbWU6XCLiiYNcIixzaW1lcTpcIuKJg1wiLHNpbWc6XCLiqp5cIixzaW1nRTpcIuKqoFwiLHNpbWw6XCLiqp1cIixzaW1sRTpcIuKqn1wiLHNpbW5lOlwi4omGXCIsc2ltcGx1czpcIuKopFwiLHNpbXJhcnI6XCLipbJcIixzbGFycjpcIuKGkFwiLFNtYWxsQ2lyY2xlOlwi4oiYXCIsc21hbGxzZXRtaW51czpcIuKIllwiLHNtYXNocDpcIuKos1wiLHNtZXBhcnNsOlwi4qekXCIsc21pZDpcIuKIo1wiLHNtaWxlOlwi4oyjXCIsc210Olwi4qqqXCIsc210ZTpcIuKqrFwiLHNtdGVzOlwi4qqs77iAXCIsU09GVGN5Olwi0KxcIixzb2Z0Y3k6XCLRjFwiLHNvbDpcIi9cIixzb2xiOlwi4qeEXCIsc29sYmFyOlwi4oy/XCIsU29wZjpcIvCdlYpcIixzb3BmOlwi8J2VpFwiLHNwYWRlczpcIuKZoFwiLHNwYWRlc3VpdDpcIuKZoFwiLHNwYXI6XCLiiKVcIixzcWNhcDpcIuKKk1wiLHNxY2FwczpcIuKKk++4gFwiLHNxY3VwOlwi4oqUXCIsc3FjdXBzOlwi4oqU77iAXCIsU3FydDpcIuKImlwiLHNxc3ViOlwi4oqPXCIsc3FzdWJlOlwi4oqRXCIsc3FzdWJzZXQ6XCLiio9cIixzcXN1YnNldGVxOlwi4oqRXCIsc3FzdXA6XCLiipBcIixzcXN1cGU6XCLiipJcIixzcXN1cHNldDpcIuKKkFwiLHNxc3Vwc2V0ZXE6XCLiipJcIixzcXU6XCLilqFcIixTcXVhcmU6XCLilqFcIixzcXVhcmU6XCLilqFcIixTcXVhcmVJbnRlcnNlY3Rpb246XCLiipNcIixTcXVhcmVTdWJzZXQ6XCLiio9cIixTcXVhcmVTdWJzZXRFcXVhbDpcIuKKkVwiLFNxdWFyZVN1cGVyc2V0Olwi4oqQXCIsU3F1YXJlU3VwZXJzZXRFcXVhbDpcIuKKklwiLFNxdWFyZVVuaW9uOlwi4oqUXCIsc3F1YXJmOlwi4paqXCIsc3F1ZjpcIuKWqlwiLHNyYXJyOlwi4oaSXCIsU3NjcjpcIvCdkq5cIixzc2NyOlwi8J2TiFwiLHNzZXRtbjpcIuKIllwiLHNzbWlsZTpcIuKMo1wiLHNzdGFyZjpcIuKLhlwiLFN0YXI6XCLii4ZcIixzdGFyOlwi4piGXCIsc3RhcmY6XCLimIVcIixzdHJhaWdodGVwc2lsb246XCLPtVwiLHN0cmFpZ2h0cGhpOlwiz5VcIixzdHJuczpcIsKvXCIsU3ViOlwi4ouQXCIsc3ViOlwi4oqCXCIsc3ViZG90Olwi4qq9XCIsc3ViRTpcIuKrhVwiLHN1YmU6XCLiioZcIixzdWJlZG90Olwi4quDXCIsc3VibXVsdDpcIuKrgVwiLHN1Ym5FOlwi4quLXCIsc3VibmU6XCLiiopcIixzdWJwbHVzOlwi4qq/XCIsc3VicmFycjpcIuKluVwiLFN1YnNldDpcIuKLkFwiLHN1YnNldDpcIuKKglwiLHN1YnNldGVxOlwi4oqGXCIsc3Vic2V0ZXFxOlwi4quFXCIsU3Vic2V0RXF1YWw6XCLiioZcIixzdWJzZXRuZXE6XCLiiopcIixzdWJzZXRuZXFxOlwi4quLXCIsc3Vic2ltOlwi4quHXCIsc3Vic3ViOlwi4quVXCIsc3Vic3VwOlwi4quTXCIsc3VjYzpcIuKJu1wiLHN1Y2NhcHByb3g6XCLiqrhcIixzdWNjY3VybHllcTpcIuKJvVwiLFN1Y2NlZWRzOlwi4om7XCIsU3VjY2VlZHNFcXVhbDpcIuKqsFwiLFN1Y2NlZWRzU2xhbnRFcXVhbDpcIuKJvVwiLFN1Y2NlZWRzVGlsZGU6XCLiib9cIixzdWNjZXE6XCLiqrBcIixzdWNjbmFwcHJveDpcIuKqulwiLHN1Y2NuZXFxOlwi4qq2XCIsc3VjY25zaW06XCLii6lcIixzdWNjc2ltOlwi4om/XCIsU3VjaFRoYXQ6XCLiiItcIixTdW06XCLiiJFcIixzdW06XCLiiJFcIixzdW5nOlwi4pmqXCIsU3VwOlwi4ouRXCIsc3VwOlwi4oqDXCIsc3VwMTpcIsK5XCIsc3VwMjpcIsKyXCIsc3VwMzpcIsKzXCIsc3VwZG90Olwi4qq+XCIsc3VwZHN1YjpcIuKrmFwiLHN1cEU6XCLiq4ZcIixzdXBlOlwi4oqHXCIsc3VwZWRvdDpcIuKrhFwiLFN1cGVyc2V0Olwi4oqDXCIsU3VwZXJzZXRFcXVhbDpcIuKKh1wiLHN1cGhzb2w6XCLin4lcIixzdXBoc3ViOlwi4quXXCIsc3VwbGFycjpcIuKlu1wiLHN1cG11bHQ6XCLiq4JcIixzdXBuRTpcIuKrjFwiLHN1cG5lOlwi4oqLXCIsc3VwcGx1czpcIuKrgFwiLFN1cHNldDpcIuKLkVwiLHN1cHNldDpcIuKKg1wiLHN1cHNldGVxOlwi4oqHXCIsc3Vwc2V0ZXFxOlwi4quGXCIsc3Vwc2V0bmVxOlwi4oqLXCIsc3Vwc2V0bmVxcTpcIuKrjFwiLHN1cHNpbTpcIuKriFwiLHN1cHN1YjpcIuKrlFwiLHN1cHN1cDpcIuKrllwiLHN3YXJoazpcIuKkplwiLHN3QXJyOlwi4oeZXCIsc3dhcnI6XCLihplcIixzd2Fycm93Olwi4oaZXCIsc3dud2FyOlwi4qSqXCIsc3psaWc6XCLDn1wiLFRhYjpcIlxcdFwiLHRhcmdldDpcIuKMllwiLFRhdTpcIs6kXCIsdGF1Olwiz4RcIix0YnJrOlwi4o60XCIsVGNhcm9uOlwixaRcIix0Y2Fyb246XCLFpVwiLFRjZWRpbDpcIsWiXCIsdGNlZGlsOlwixaNcIixUY3k6XCLQolwiLHRjeTpcItGCXCIsdGRvdDpcIuKDm1wiLHRlbHJlYzpcIuKMlVwiLFRmcjpcIvCdlJdcIix0ZnI6XCLwnZSxXCIsdGhlcmU0Olwi4oi0XCIsVGhlcmVmb3JlOlwi4oi0XCIsdGhlcmVmb3JlOlwi4oi0XCIsVGhldGE6XCLOmFwiLHRoZXRhOlwizrhcIix0aGV0YXN5bTpcIs+RXCIsdGhldGF2Olwiz5FcIix0aGlja2FwcHJveDpcIuKJiFwiLHRoaWNrc2ltOlwi4oi8XCIsVGhpY2tTcGFjZTpcIuKBn+KAilwiLHRoaW5zcDpcIuKAiVwiLFRoaW5TcGFjZTpcIuKAiVwiLHRoa2FwOlwi4omIXCIsdGhrc2ltOlwi4oi8XCIsVEhPUk46XCLDnlwiLHRob3JuOlwiw75cIixUaWxkZTpcIuKIvFwiLHRpbGRlOlwiy5xcIixUaWxkZUVxdWFsOlwi4omDXCIsVGlsZGVGdWxsRXF1YWw6XCLiiYVcIixUaWxkZVRpbGRlOlwi4omIXCIsdGltZXM6XCLDl1wiLHRpbWVzYjpcIuKKoFwiLHRpbWVzYmFyOlwi4qixXCIsdGltZXNkOlwi4qiwXCIsdGludDpcIuKIrVwiLHRvZWE6XCLipKhcIix0b3A6XCLiiqRcIix0b3Bib3Q6XCLijLZcIix0b3BjaXI6XCLiq7FcIixUb3BmOlwi8J2Vi1wiLHRvcGY6XCLwnZWlXCIsdG9wZm9yazpcIuKrmlwiLHRvc2E6XCLipKlcIix0cHJpbWU6XCLigLRcIixUUkFERTpcIuKEolwiLHRyYWRlOlwi4oSiXCIsdHJpYW5nbGU6XCLilrVcIix0cmlhbmdsZWRvd246XCLilr9cIix0cmlhbmdsZWxlZnQ6XCLil4NcIix0cmlhbmdsZWxlZnRlcTpcIuKKtFwiLHRyaWFuZ2xlcTpcIuKJnFwiLHRyaWFuZ2xlcmlnaHQ6XCLilrlcIix0cmlhbmdsZXJpZ2h0ZXE6XCLiirVcIix0cmlkb3Q6XCLil6xcIix0cmllOlwi4omcXCIsdHJpbWludXM6XCLiqLpcIixUcmlwbGVEb3Q6XCLig5tcIix0cmlwbHVzOlwi4qi5XCIsdHJpc2I6XCLip41cIix0cml0aW1lOlwi4qi7XCIsdHJwZXppdW06XCLij6JcIixUc2NyOlwi8J2Sr1wiLHRzY3I6XCLwnZOJXCIsVFNjeTpcItCmXCIsdHNjeTpcItGGXCIsVFNIY3k6XCLQi1wiLHRzaGN5Olwi0ZtcIixUc3Ryb2s6XCLFplwiLHRzdHJvazpcIsWnXCIsdHdpeHQ6XCLiiaxcIix0d29oZWFkbGVmdGFycm93Olwi4oaeXCIsdHdvaGVhZHJpZ2h0YXJyb3c6XCLihqBcIixVYWN1dGU6XCLDmlwiLHVhY3V0ZTpcIsO6XCIsVWFycjpcIuKGn1wiLHVBcnI6XCLih5FcIix1YXJyOlwi4oaRXCIsVWFycm9jaXI6XCLipYlcIixVYnJjeTpcItCOXCIsdWJyY3k6XCLRnlwiLFVicmV2ZTpcIsWsXCIsdWJyZXZlOlwixa1cIixVY2lyYzpcIsObXCIsdWNpcmM6XCLDu1wiLFVjeTpcItCjXCIsdWN5Olwi0YNcIix1ZGFycjpcIuKHhVwiLFVkYmxhYzpcIsWwXCIsdWRibGFjOlwixbFcIix1ZGhhcjpcIuKlrlwiLHVmaXNodDpcIuKlvlwiLFVmcjpcIvCdlJhcIix1ZnI6XCLwnZSyXCIsVWdyYXZlOlwiw5lcIix1Z3JhdmU6XCLDuVwiLHVIYXI6XCLipaNcIix1aGFybDpcIuKGv1wiLHVoYXJyOlwi4oa+XCIsdWhibGs6XCLiloBcIix1bGNvcm46XCLijJxcIix1bGNvcm5lcjpcIuKMnFwiLHVsY3JvcDpcIuKMj1wiLHVsdHJpOlwi4pe4XCIsVW1hY3I6XCLFqlwiLHVtYWNyOlwixatcIix1bWw6XCLCqFwiLFVuZGVyQmFyOlwiX1wiLFVuZGVyQnJhY2U6XCLij59cIixVbmRlckJyYWNrZXQ6XCLijrVcIixVbmRlclBhcmVudGhlc2lzOlwi4o+dXCIsVW5pb246XCLii4NcIixVbmlvblBsdXM6XCLiio5cIixVb2dvbjpcIsWyXCIsdW9nb246XCLFs1wiLFVvcGY6XCLwnZWMXCIsdW9wZjpcIvCdlaZcIixVcEFycm93Olwi4oaRXCIsVXBhcnJvdzpcIuKHkVwiLHVwYXJyb3c6XCLihpFcIixVcEFycm93QmFyOlwi4qSSXCIsVXBBcnJvd0Rvd25BcnJvdzpcIuKHhVwiLFVwRG93bkFycm93Olwi4oaVXCIsVXBkb3duYXJyb3c6XCLih5VcIix1cGRvd25hcnJvdzpcIuKGlVwiLFVwRXF1aWxpYnJpdW06XCLipa5cIix1cGhhcnBvb25sZWZ0Olwi4oa/XCIsdXBoYXJwb29ucmlnaHQ6XCLihr5cIix1cGx1czpcIuKKjlwiLFVwcGVyTGVmdEFycm93Olwi4oaWXCIsVXBwZXJSaWdodEFycm93Olwi4oaXXCIsVXBzaTpcIs+SXCIsdXBzaTpcIs+FXCIsdXBzaWg6XCLPklwiLFVwc2lsb246XCLOpVwiLHVwc2lsb246XCLPhVwiLFVwVGVlOlwi4oqlXCIsVXBUZWVBcnJvdzpcIuKGpVwiLHVwdXBhcnJvd3M6XCLih4hcIix1cmNvcm46XCLijJ1cIix1cmNvcm5lcjpcIuKMnVwiLHVyY3JvcDpcIuKMjlwiLFVyaW5nOlwixa5cIix1cmluZzpcIsWvXCIsdXJ0cmk6XCLil7lcIixVc2NyOlwi8J2SsFwiLHVzY3I6XCLwnZOKXCIsdXRkb3Q6XCLii7BcIixVdGlsZGU6XCLFqFwiLHV0aWxkZTpcIsWpXCIsdXRyaTpcIuKWtVwiLHV0cmlmOlwi4pa0XCIsdXVhcnI6XCLih4hcIixVdW1sOlwiw5xcIix1dW1sOlwiw7xcIix1d2FuZ2xlOlwi4qanXCIsdmFuZ3J0Olwi4qacXCIsdmFyZXBzaWxvbjpcIs+1XCIsdmFya2FwcGE6XCLPsFwiLHZhcm5vdGhpbmc6XCLiiIVcIix2YXJwaGk6XCLPlVwiLHZhcnBpOlwiz5ZcIix2YXJwcm9wdG86XCLiiJ1cIix2QXJyOlwi4oeVXCIsdmFycjpcIuKGlVwiLHZhcnJobzpcIs+xXCIsdmFyc2lnbWE6XCLPglwiLHZhcnN1YnNldG5lcTpcIuKKiu+4gFwiLHZhcnN1YnNldG5lcXE6XCLiq4vvuIBcIix2YXJzdXBzZXRuZXE6XCLiiovvuIBcIix2YXJzdXBzZXRuZXFxOlwi4quM77iAXCIsdmFydGhldGE6XCLPkVwiLHZhcnRyaWFuZ2xlbGVmdDpcIuKKslwiLHZhcnRyaWFuZ2xlcmlnaHQ6XCLiirNcIixWYmFyOlwi4qurXCIsdkJhcjpcIuKrqFwiLHZCYXJ2Olwi4qupXCIsVmN5Olwi0JJcIix2Y3k6XCLQslwiLFZEYXNoOlwi4oqrXCIsVmRhc2g6XCLiiqlcIix2RGFzaDpcIuKKqFwiLHZkYXNoOlwi4oqiXCIsVmRhc2hsOlwi4qumXCIsVmVlOlwi4ouBXCIsdmVlOlwi4oioXCIsdmVlYmFyOlwi4oq7XCIsdmVlZXE6XCLiiZpcIix2ZWxsaXA6XCLii65cIixWZXJiYXI6XCLigJZcIix2ZXJiYXI6XCJ8XCIsVmVydDpcIuKAllwiLHZlcnQ6XCJ8XCIsVmVydGljYWxCYXI6XCLiiKNcIixWZXJ0aWNhbExpbmU6XCJ8XCIsVmVydGljYWxTZXBhcmF0b3I6XCLinZhcIixWZXJ0aWNhbFRpbGRlOlwi4omAXCIsVmVyeVRoaW5TcGFjZTpcIuKAilwiLFZmcjpcIvCdlJlcIix2ZnI6XCLwnZSzXCIsdmx0cmk6XCLiirJcIix2bnN1YjpcIuKKguKDklwiLHZuc3VwOlwi4oqD4oOSXCIsVm9wZjpcIvCdlY1cIix2b3BmOlwi8J2Vp1wiLHZwcm9wOlwi4oidXCIsdnJ0cmk6XCLiirNcIixWc2NyOlwi8J2SsVwiLHZzY3I6XCLwnZOLXCIsdnN1Ym5FOlwi4quL77iAXCIsdnN1Ym5lOlwi4oqK77iAXCIsdnN1cG5FOlwi4quM77iAXCIsdnN1cG5lOlwi4oqL77iAXCIsVnZkYXNoOlwi4oqqXCIsdnppZ3phZzpcIuKmmlwiLFdjaXJjOlwixbRcIix3Y2lyYzpcIsW1XCIsd2VkYmFyOlwi4qmfXCIsV2VkZ2U6XCLii4BcIix3ZWRnZTpcIuKIp1wiLHdlZGdlcTpcIuKJmVwiLHdlaWVycDpcIuKEmFwiLFdmcjpcIvCdlJpcIix3ZnI6XCLwnZS0XCIsV29wZjpcIvCdlY5cIix3b3BmOlwi8J2VqFwiLHdwOlwi4oSYXCIsd3I6XCLiiYBcIix3cmVhdGg6XCLiiYBcIixXc2NyOlwi8J2SslwiLHdzY3I6XCLwnZOMXCIseGNhcDpcIuKLglwiLHhjaXJjOlwi4pevXCIseGN1cDpcIuKLg1wiLHhkdHJpOlwi4pa9XCIsWGZyOlwi8J2Um1wiLHhmcjpcIvCdlLVcIix4aEFycjpcIuKfulwiLHhoYXJyOlwi4p+3XCIsWGk6XCLOnlwiLHhpOlwizr5cIix4bEFycjpcIuKfuFwiLHhsYXJyOlwi4p+1XCIseG1hcDpcIuKfvFwiLHhuaXM6XCLii7tcIix4b2RvdDpcIuKogFwiLFhvcGY6XCLwnZWPXCIseG9wZjpcIvCdlalcIix4b3BsdXM6XCLiqIFcIix4b3RpbWU6XCLiqIJcIix4ckFycjpcIuKfuVwiLHhyYXJyOlwi4p+2XCIsWHNjcjpcIvCdkrNcIix4c2NyOlwi8J2TjVwiLHhzcWN1cDpcIuKohlwiLHh1cGx1czpcIuKohFwiLHh1dHJpOlwi4pazXCIseHZlZTpcIuKLgVwiLHh3ZWRnZTpcIuKLgFwiLFlhY3V0ZTpcIsOdXCIseWFjdXRlOlwiw71cIixZQWN5Olwi0K9cIix5YWN5Olwi0Y9cIixZY2lyYzpcIsW2XCIseWNpcmM6XCLFt1wiLFljeTpcItCrXCIseWN5Olwi0YtcIix5ZW46XCLCpVwiLFlmcjpcIvCdlJxcIix5ZnI6XCLwnZS2XCIsWUljeTpcItCHXCIseWljeTpcItGXXCIsWW9wZjpcIvCdlZBcIix5b3BmOlwi8J2VqlwiLFlzY3I6XCLwnZK0XCIseXNjcjpcIvCdk45cIixZVWN5Olwi0K5cIix5dWN5Olwi0Y5cIixZdW1sOlwixbhcIix5dW1sOlwiw79cIixaYWN1dGU6XCLFuVwiLHphY3V0ZTpcIsW6XCIsWmNhcm9uOlwixb1cIix6Y2Fyb246XCLFvlwiLFpjeTpcItCXXCIsemN5Olwi0LdcIixaZG90OlwixbtcIix6ZG90OlwixbxcIix6ZWV0cmY6XCLihKhcIixaZXJvV2lkdGhTcGFjZTpcIuKAi1wiLFpldGE6XCLOllwiLHpldGE6XCLOtlwiLFpmcjpcIuKEqFwiLHpmcjpcIvCdlLdcIixaSGN5Olwi0JZcIix6aGN5Olwi0LZcIix6aWdyYXJyOlwi4oedXCIsWm9wZjpcIuKEpFwiLHpvcGY6XCLwnZWrXCIsWnNjcjpcIvCdkrVcIix6c2NyOlwi8J2Tj1wiLHp3ajpcIuKAjVwiLHp3bmo6XCLigIxcIn0pLHQuZW50aXR5TWFwPXQuSFRNTF9FTlRJVElFU30sODk3ODooZSx0LHIpPT57dmFyIGE9cig0NzIyKTt0LkRPTUltcGxlbWVudGF0aW9uPWEuRE9NSW1wbGVtZW50YXRpb24sdC5YTUxTZXJpYWxpemVyPWEuWE1MU2VyaWFsaXplcix0LkRPTVBhcnNlcj1yKDU3NTIpLkRPTVBhcnNlcn0sNDQ2NjooZSx0LHIpPT57dmFyIGE9cig0NTgyKS5OQU1FU1BBQ0Usbj0vW0EtWl9hLXpcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXS8sbz1uZXcgUmVnRXhwKFwiW1xcXFwtXFxcXC4wLTlcIituLnNvdXJjZS5zbGljZSgxLC0xKStcIlxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwXVwiKSxpPW5ldyBSZWdFeHAoXCJeXCIrbi5zb3VyY2Urby5zb3VyY2UrXCIqKD86OlwiK24uc291cmNlK28uc291cmNlK1wiKik/JFwiKTtmdW5jdGlvbiBzKGUsdCl7dGhpcy5tZXNzYWdlPWUsdGhpcy5sb2NhdG9yPXQsRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMscyl9ZnVuY3Rpb24gbCgpe31mdW5jdGlvbiBjKGUsdCl7cmV0dXJuIHQubGluZU51bWJlcj1lLmxpbmVOdW1iZXIsdC5jb2x1bW5OdW1iZXI9ZS5jb2x1bW5OdW1iZXIsdH1mdW5jdGlvbiB1KGUsdCxyLG4sbyxpKXtmdW5jdGlvbiBzKGUsdCxhKXtyLmF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KGUpJiZpLmZhdGFsRXJyb3IoXCJBdHRyaWJ1dGUgXCIrZStcIiByZWRlZmluZWRcIiksci5hZGRWYWx1ZShlLHQucmVwbGFjZSgvW1xcdFxcblxccl0vZyxcIiBcIikucmVwbGFjZSgvJiM/XFx3KzsvZyxvKSxhKX1mb3IodmFyIGwsYz0rK3QsdT0wOzspe3ZhciBoPWUuY2hhckF0KGMpO3N3aXRjaChoKXtjYXNlXCI9XCI6aWYoMT09PXUpbD1lLnNsaWNlKHQsYyksdT0zO2Vsc2V7aWYoMiE9PXUpdGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIGVxdWFsIG11c3QgYWZ0ZXIgYXR0ck5hbWVcIik7dT0zfWJyZWFrO2Nhc2VcIidcIjpjYXNlJ1wiJzppZigzPT09dXx8MT09PXUpe2lmKDE9PT11JiYoaS53YXJuaW5nKCdhdHRyaWJ1dGUgdmFsdWUgbXVzdCBhZnRlciBcIj1cIicpLGw9ZS5zbGljZSh0LGMpKSx0PWMrMSwhKChjPWUuaW5kZXhPZihoLHQpKT4wKSl0aHJvdyBuZXcgRXJyb3IoXCJhdHRyaWJ1dGUgdmFsdWUgbm8gZW5kICdcIitoK1wiJyBtYXRjaFwiKTtzKGwsZD1lLnNsaWNlKHQsYyksdC0xKSx1PTV9ZWxzZXtpZig0IT11KXRocm93IG5ldyBFcnJvcignYXR0cmlidXRlIHZhbHVlIG11c3QgYWZ0ZXIgXCI9XCInKTtzKGwsZD1lLnNsaWNlKHQsYyksdCksaS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2wrJ1wiIG1pc3NlZCBzdGFydCBxdW90KCcraCtcIikhIVwiKSx0PWMrMSx1PTV9YnJlYWs7Y2FzZVwiL1wiOnN3aXRjaCh1KXtjYXNlIDA6ci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSk7Y2FzZSA1OmNhc2UgNjpjYXNlIDc6dT03LHIuY2xvc2VkPSEwO2Nhc2UgNDpjYXNlIDE6YnJlYWs7Y2FzZSAyOnIuY2xvc2VkPSEwO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIGludmFsaWQgY2xvc2UgY2hhcignLycpXCIpfWJyZWFrO2Nhc2VcIlwiOnJldHVybiBpLmVycm9yKFwidW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIiksMD09dSYmci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSksYztjYXNlXCI+XCI6c3dpdGNoKHUpe2Nhc2UgMDpyLnNldFRhZ05hbWUoZS5zbGljZSh0LGMpKTtjYXNlIDU6Y2FzZSA2OmNhc2UgNzpicmVhaztjYXNlIDQ6Y2FzZSAxOlwiL1wiPT09KGQ9ZS5zbGljZSh0LGMpKS5zbGljZSgtMSkmJihyLmNsb3NlZD0hMCxkPWQuc2xpY2UoMCwtMSkpO2Nhc2UgMjoyPT09dSYmKGQ9bCksND09dT8oaS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2QrJ1wiIG1pc3NlZCBxdW90KFwiKSEnKSxzKGwsZCx0KSk6KGEuaXNIVE1MKG5bXCJcIl0pJiZkLm1hdGNoKC9eKD86ZGlzYWJsZWR8Y2hlY2tlZHxzZWxlY3RlZCkkL2kpfHxpLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrZCsnXCIgbWlzc2VkIHZhbHVlISEgXCInK2QrJ1wiIGluc3RlYWQhIScpLHMoZCxkLHQpKTticmVhaztjYXNlIDM6dGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIHZhbHVlIG1pc3NlZCEhXCIpfXJldHVybiBjO2Nhc2VcIsKAXCI6aD1cIiBcIjtkZWZhdWx0OmlmKGg8PVwiIFwiKXN3aXRjaCh1KXtjYXNlIDA6ci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSksdT02O2JyZWFrO2Nhc2UgMTpsPWUuc2xpY2UodCxjKSx1PTI7YnJlYWs7Y2FzZSA0OnZhciBkPWUuc2xpY2UodCxjKTtpLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrZCsnXCIgbWlzc2VkIHF1b3QoXCIpISEnKSxzKGwsZCx0KTtjYXNlIDU6dT02fWVsc2Ugc3dpdGNoKHUpe2Nhc2UgMjpyLnRhZ05hbWUsYS5pc0hUTUwobltcIlwiXSkmJmwubWF0Y2goL14oPzpkaXNhYmxlZHxjaGVja2VkfHNlbGVjdGVkKSQvaSl8fGkud2FybmluZygnYXR0cmlidXRlIFwiJytsKydcIiBtaXNzZWQgdmFsdWUhISBcIicrbCsnXCIgaW5zdGVhZDIhIScpLHMobCxsLHQpLHQ9Yyx1PTE7YnJlYWs7Y2FzZSA1Omkud2FybmluZygnYXR0cmlidXRlIHNwYWNlIGlzIHJlcXVpcmVkXCInK2wrJ1wiISEnKTtjYXNlIDY6dT0xLHQ9YzticmVhaztjYXNlIDM6dT00LHQ9YzticmVhaztjYXNlIDc6dGhyb3cgbmV3IEVycm9yKFwiZWxlbWVudHMgY2xvc2VkIGNoYXJhY3RlciAnLycgYW5kICc+JyBtdXN0IGJlIGNvbm5lY3RlZCB0b1wiKX19YysrfX1mdW5jdGlvbiBoKGUsdCxyKXtmb3IodmFyIG49ZS50YWdOYW1lLG89bnVsbCxpPWUubGVuZ3RoO2ktLTspe3ZhciBzPWVbaV0sbD1zLnFOYW1lLGM9cy52YWx1ZTtpZigobT1sLmluZGV4T2YoXCI6XCIpKT4wKXZhciB1PXMucHJlZml4PWwuc2xpY2UoMCxtKSxoPWwuc2xpY2UobSsxKSxkPVwieG1sbnNcIj09PXUmJmg7ZWxzZSBoPWwsdT1udWxsLGQ9XCJ4bWxuc1wiPT09bCYmXCJcIjtzLmxvY2FsTmFtZT1oLCExIT09ZCYmKG51bGw9PW8mJihvPXt9LHAocixyPXt9KSkscltkXT1vW2RdPWMscy51cmk9YS5YTUxOUyx0LnN0YXJ0UHJlZml4TWFwcGluZyhkLGMpKX1mb3IoaT1lLmxlbmd0aDtpLS07KSh1PShzPWVbaV0pLnByZWZpeCkmJihcInhtbFwiPT09dSYmKHMudXJpPWEuWE1MKSxcInhtbG5zXCIhPT11JiYocy51cmk9clt1fHxcIlwiXSkpO3ZhciBtOyhtPW4uaW5kZXhPZihcIjpcIikpPjA/KHU9ZS5wcmVmaXg9bi5zbGljZSgwLG0pLGg9ZS5sb2NhbE5hbWU9bi5zbGljZShtKzEpKToodT1udWxsLGg9ZS5sb2NhbE5hbWU9bik7dmFyIGY9ZS51cmk9clt1fHxcIlwiXTtpZih0LnN0YXJ0RWxlbWVudChmLGgsbixlKSwhZS5jbG9zZWQpcmV0dXJuIGUuY3VycmVudE5TTWFwPXIsZS5sb2NhbE5TTWFwPW8sITA7aWYodC5lbmRFbGVtZW50KGYsaCxuKSxvKWZvcih1IGluIG8pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sdSkmJnQuZW5kUHJlZml4TWFwcGluZyh1KX1mdW5jdGlvbiBkKGUsdCxyLGEsbil7aWYoL14oPzpzY3JpcHR8dGV4dGFyZWEpJC9pLnRlc3Qocikpe3ZhciBvPWUuaW5kZXhPZihcIjwvXCIrcitcIj5cIix0KSxpPWUuc3Vic3RyaW5nKHQrMSxvKTtpZigvWyY8XS8udGVzdChpKSlyZXR1cm4vXnNjcmlwdCQvaS50ZXN0KHIpPyhuLmNoYXJhY3RlcnMoaSwwLGkubGVuZ3RoKSxvKTooaT1pLnJlcGxhY2UoLyYjP1xcdys7L2csYSksbi5jaGFyYWN0ZXJzKGksMCxpLmxlbmd0aCksbyl9cmV0dXJuIHQrMX1mdW5jdGlvbiBtKGUsdCxyLGEpe3ZhciBuPWFbcl07cmV0dXJuIG51bGw9PW4mJigobj1lLmxhc3RJbmRleE9mKFwiPC9cIityK1wiPlwiKSk8dCYmKG49ZS5sYXN0SW5kZXhPZihcIjwvXCIrcikpLGFbcl09biksbjx0fWZ1bmN0aW9uIHAoZSx0KXtmb3IodmFyIHIgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmKHRbcl09ZVtyXSl9ZnVuY3Rpb24gZihlLHQscixhKXtpZihcIi1cIj09PWUuY2hhckF0KHQrMikpcmV0dXJuXCItXCI9PT1lLmNoYXJBdCh0KzMpPyhuPWUuaW5kZXhPZihcIi0tXFx4M2VcIix0KzQpKT50PyhyLmNvbW1lbnQoZSx0KzQsbi10LTQpLG4rMyk6KGEuZXJyb3IoXCJVbmNsb3NlZCBjb21tZW50XCIpLC0xKTotMTtpZihcIkNEQVRBW1wiPT1lLnN1YnN0cih0KzMsNikpe3ZhciBuPWUuaW5kZXhPZihcIl1dPlwiLHQrOSk7cmV0dXJuIHIuc3RhcnRDREFUQSgpLHIuY2hhcmFjdGVycyhlLHQrOSxuLXQtOSksci5lbmRDREFUQSgpLG4rM312YXIgbz1mdW5jdGlvbihlLHQpe3ZhciByLGE9W10sbj0vJ1teJ10rJ3xcIlteXCJdK1wifFteXFxzPD5cXC89XSs9P3woXFwvP1xccyo+fDwpL2c7Zm9yKG4ubGFzdEluZGV4PXQsbi5leGVjKGUpO3I9bi5leGVjKGUpOylpZihhLnB1c2gociksclsxXSlyZXR1cm4gYX0oZSx0KSxpPW8ubGVuZ3RoO2lmKGk+MSYmLyFkb2N0eXBlL2kudGVzdChvWzBdWzBdKSl7dmFyIHM9b1sxXVswXSxsPSExLGM9ITE7aT4zJiYoL15wdWJsaWMkL2kudGVzdChvWzJdWzBdKT8obD1vWzNdWzBdLGM9aT40JiZvWzRdWzBdKTovXnN5c3RlbSQvaS50ZXN0KG9bMl1bMF0pJiYoYz1vWzNdWzBdKSk7dmFyIHU9b1tpLTFdO3JldHVybiByLnN0YXJ0RFREKHMsbCxjKSxyLmVuZERURCgpLHUuaW5kZXgrdVswXS5sZW5ndGh9cmV0dXJuLTF9ZnVuY3Rpb24geChlLHQscil7dmFyIGE9ZS5pbmRleE9mKFwiPz5cIix0KTtpZihhKXt2YXIgbj1lLnN1YnN0cmluZyh0LGEpLm1hdGNoKC9ePFxcPyhcXFMqKVxccyooW1xcc1xcU10qPylcXHMqJC8pO3JldHVybiBuPyhuWzBdLmxlbmd0aCxyLnByb2Nlc3NpbmdJbnN0cnVjdGlvbihuWzFdLG5bMl0pLGErMik6LTF9cmV0dXJuLTF9ZnVuY3Rpb24gZygpe3RoaXMuYXR0cmlidXRlTmFtZXM9e319cy5wcm90b3R5cGU9bmV3IEVycm9yLHMucHJvdG90eXBlLm5hbWU9cy5uYW1lLGwucHJvdG90eXBlPXtwYXJzZTpmdW5jdGlvbihlLHQscil7dmFyIG49dGhpcy5kb21CdWlsZGVyO24uc3RhcnREb2N1bWVudCgpLHAodCx0PXt9KSxmdW5jdGlvbihlLHQscixuLG8pe2Z1bmN0aW9uIGkoZSl7dmFyIHQ9ZS5zbGljZSgxLC0xKTtyZXR1cm4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocix0KT9yW3RdOlwiI1wiPT09dC5jaGFyQXQoMCk/ZnVuY3Rpb24oZSl7aWYoZT42NTUzNSl7dmFyIHQ9NTUyOTYrKChlLT02NTUzNik+PjEwKSxyPTU2MzIwKygxMDIzJmUpO3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHQscil9cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZSl9KHBhcnNlSW50KHQuc3Vic3RyKDEpLnJlcGxhY2UoXCJ4XCIsXCIweFwiKSkpOihvLmVycm9yKFwiZW50aXR5IG5vdCBmb3VuZDpcIitlKSxlKX1mdW5jdGlvbiBsKHQpe2lmKHQ+Xyl7dmFyIHI9ZS5zdWJzdHJpbmcoXyx0KS5yZXBsYWNlKC8mIz9cXHcrOy9nLGkpO0MmJnAoXyksbi5jaGFyYWN0ZXJzKHIsMCx0LV8pLF89dH19ZnVuY3Rpb24gcCh0LHIpe2Zvcig7dD49YiYmKHI9di5leGVjKGUpKTspdz1yLmluZGV4LGI9dytyWzBdLmxlbmd0aCxDLmxpbmVOdW1iZXIrKztDLmNvbHVtbk51bWJlcj10LXcrMX1mb3IodmFyIHc9MCxiPTAsdj0vLiooPzpcXHJcXG4/fFxcbil8LiokL2csQz1uLmxvY2F0b3IsQT1be2N1cnJlbnROU01hcDp0fV0sRT17fSxfPTA7Oyl7dHJ5e3ZhciB5PWUuaW5kZXhPZihcIjxcIixfKTtpZih5PDApe2lmKCFlLnN1YnN0cihfKS5tYXRjaCgvXlxccyokLykpe3ZhciBxPW4uZG9jLEQ9cS5jcmVhdGVUZXh0Tm9kZShlLnN1YnN0cihfKSk7cS5hcHBlbmRDaGlsZChEKSxuLmN1cnJlbnRFbGVtZW50PUR9cmV0dXJufXN3aXRjaCh5Pl8mJmwoeSksZS5jaGFyQXQoeSsxKSl7Y2FzZVwiL1wiOnZhciBNPWUuaW5kZXhPZihcIj5cIix5KzMpLFQ9ZS5zdWJzdHJpbmcoeSsyLE0pLnJlcGxhY2UoL1sgXFx0XFxuXFxyXSskL2csXCJcIiksTj1BLnBvcCgpO008MD8oVD1lLnN1YnN0cmluZyh5KzIpLnJlcGxhY2UoL1tcXHM8XS4qLyxcIlwiKSxvLmVycm9yKFwiZW5kIHRhZyBuYW1lOiBcIitUK1wiIGlzIG5vdCBjb21wbGV0ZTpcIitOLnRhZ05hbWUpLE09eSsxK1QubGVuZ3RoKTpULm1hdGNoKC9cXHM8LykmJihUPVQucmVwbGFjZSgvW1xcczxdLiovLFwiXCIpLG8uZXJyb3IoXCJlbmQgdGFnIG5hbWU6IFwiK1QrXCIgbWF5YmUgbm90IGNvbXBsZXRlXCIpLE09eSsxK1QubGVuZ3RoKTt2YXIgTz1OLmxvY2FsTlNNYXAsTD1OLnRhZ05hbWU9PVQ7aWYoTHx8Ti50YWdOYW1lJiZOLnRhZ05hbWUudG9Mb3dlckNhc2UoKT09VC50b0xvd2VyQ2FzZSgpKXtpZihuLmVuZEVsZW1lbnQoTi51cmksTi5sb2NhbE5hbWUsVCksTylmb3IodmFyIEIgaW4gTylPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTyxCKSYmbi5lbmRQcmVmaXhNYXBwaW5nKEIpO0x8fG8uZmF0YWxFcnJvcihcImVuZCB0YWcgbmFtZTogXCIrVCtcIiBpcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgc3RhcnQgdGFnTmFtZTpcIitOLnRhZ05hbWUpfWVsc2UgQS5wdXNoKE4pO00rKzticmVhaztjYXNlXCI/XCI6QyYmcCh5KSxNPXgoZSx5LG4pO2JyZWFrO2Nhc2VcIiFcIjpDJiZwKHkpLE09ZihlLHksbixvKTticmVhaztkZWZhdWx0OkMmJnAoeSk7dmFyIFM9bmV3IGcsRj1BW0EubGVuZ3RoLTFdLmN1cnJlbnROU01hcCxQPShNPXUoZSx5LFMsRixpLG8pLFMubGVuZ3RoKTtpZighUy5jbG9zZWQmJm0oZSxNLFMudGFnTmFtZSxFKSYmKFMuY2xvc2VkPSEwLHIubmJzcHx8by53YXJuaW5nKFwidW5jbG9zZWQgeG1sIGF0dHJpYnV0ZVwiKSksQyYmUCl7Zm9yKHZhciBrPWMoQyx7fSksUj0wO1I8UDtSKyspe3ZhciBJPVNbUl07cChJLm9mZnNldCksSS5sb2NhdG9yPWMoQyx7fSl9bi5sb2NhdG9yPWssaChTLG4sRikmJkEucHVzaChTKSxuLmxvY2F0b3I9Q31lbHNlIGgoUyxuLEYpJiZBLnB1c2goUyk7YS5pc0hUTUwoUy51cmkpJiYhUy5jbG9zZWQ/TT1kKGUsTSxTLnRhZ05hbWUsaSxuKTpNKyt9fWNhdGNoKGUpe2lmKGUgaW5zdGFuY2VvZiBzKXRocm93IGU7by5lcnJvcihcImVsZW1lbnQgcGFyc2UgZXJyb3I6IFwiK2UpLE09LTF9TT5fP189TTpsKE1hdGgubWF4KHksXykrMSl9fShlLHQscixuLHRoaXMuZXJyb3JIYW5kbGVyKSxuLmVuZERvY3VtZW50KCl9fSxnLnByb3RvdHlwZT17c2V0VGFnTmFtZTpmdW5jdGlvbihlKXtpZighaS50ZXN0KGUpKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgdGFnTmFtZTpcIitlKTt0aGlzLnRhZ05hbWU9ZX0sYWRkVmFsdWU6ZnVuY3Rpb24oZSx0LHIpe2lmKCFpLnRlc3QoZSkpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhdHRyaWJ1dGU6XCIrZSk7dGhpcy5hdHRyaWJ1dGVOYW1lc1tlXT10aGlzLmxlbmd0aCx0aGlzW3RoaXMubGVuZ3RoKytdPXtxTmFtZTplLHZhbHVlOnQsb2Zmc2V0OnJ9fSxsZW5ndGg6MCxnZXRMb2NhbE5hbWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXNbZV0ubG9jYWxOYW1lfSxnZXRMb2NhdG9yOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLmxvY2F0b3J9LGdldFFOYW1lOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLnFOYW1lfSxnZXRVUkk6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXNbZV0udXJpfSxnZXRWYWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpc1tlXS52YWx1ZX19LHQuWE1MUmVhZGVyPWwsdC5QYXJzZUVycm9yPXN9LDg5MTc6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcj12b2lkIDA7dmFyIGE9cig2MjAwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yfX0pfSw2MjAwOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yPXZvaWQgMDtjbGFzcyByIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoZSx0LHIsYT1cImV4YWN0bHlcIil7c3VwZXIoYCR7ZX0gdGFnIG11c3QgaGF2ZSAke2F9ICR7dH0gY2hpbGRyZW4uIEl0J3MgYWN0dWFsbHkgJHtyfWApLHRoaXMubmFtZT1cIkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3JcIn19dC5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yPXJ9LDQyNzk6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDgyOCksdCksbihyKDU5NzUpLHQpLG4ocig3OTkpLHQpLG4ocigyNDI0KSx0KX0sNTk3NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSm9pbldpdGhNYW55U2VwYXJhdG9ycz12b2lkIDA7Y2xhc3Mgcntjb25zdHJ1Y3RvcihlKXt0aGlzLl9zZXBhcmF0b3JzPWV9c3RhdGljIGpvaW4oZSx0KXtyZXR1cm4gbmV3IHIodCkuX2pvaW4oZSl9X2pvaW4oZSl7cmV0dXJuIGUucmVkdWNlKCgoZSx0LHIsYSk9PmUrdCsocj09PWEubGVuZ3RoLTE/XCJcIjp0aGlzLl9nZXQocikpKSxcIlwiKX1fZ2V0KGUpe3JldHVybiB0aGlzLl9zZXBhcmF0b3JzW2VdP3RoaXMuX3NlcGFyYXRvcnNbZV06dGhpcy5fc2VwYXJhdG9ycy5sZW5ndGg+MD90aGlzLl9zZXBhcmF0b3JzW3RoaXMuX3NlcGFyYXRvcnMubGVuZ3RoLTFdOlwiLFwifX10LkpvaW5XaXRoTWFueVNlcGFyYXRvcnM9cn0sNzk5OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyPXZvaWQgMDtjb25zdCBhPXIoNTQ0Myk7dC5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcj1lPT5uZXcgYS5NYXRoTUxFbGVtZW50VG9MYXRleENvbnZlcnRlckFkYXB0ZXIoZSkudG9MYXRleENvbnZlcnRlcigpfSwyNDI0OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5ub3JtYWxpemVXaGl0ZVNwYWNlcz12b2lkIDAsdC5ub3JtYWxpemVXaGl0ZVNwYWNlcz1lPT5lLnJlcGxhY2UoL1xccysvZyxcIiBcIil9LDcxOTI6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuQnJhY2tldFdyYXBwZXI9dm9pZCAwO2NvbnN0IGE9cigxODU1KTt0LkJyYWNrZXRXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fb3Blbj1cIntcIix0aGlzLl9jbG9zZT1cIn1cIn13cmFwKGUpe3JldHVybiBuZXcgYS5XcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAoZSl9fX0sNTAyNTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljV3JhcHBlcj12b2lkIDA7Y29uc3QgYT1yKDE4NTUpO3QuR2VuZXJpY1dyYXBwZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9vcGVuPVwiXFxcXGxlZnRcIitlLHRoaXMuX2Nsb3NlPVwiXFxcXHJpZ2h0XCIrdH13cmFwKGUpe3JldHVybiBuZXcgYS5XcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAoZSl9fX0sODI4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkdlbmVyaWNXcmFwcGVyPXQuUGFyZW50aGVzaXNXcmFwcGVyPXQuQnJhY2tldFdyYXBwZXI9dm9pZCAwO3ZhciBhPXIoNzE5Mik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJCcmFja2V0V3JhcHBlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLkJyYWNrZXRXcmFwcGVyfX0pO3ZhciBuPXIoMTE2OCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJQYXJlbnRoZXNpc1dyYXBwZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5QYXJlbnRoZXNpc1dyYXBwZXJ9fSk7dmFyIG89cig1MDI1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkdlbmVyaWNXcmFwcGVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uR2VuZXJpY1dyYXBwZXJ9fSl9LDExNjg6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuUGFyZW50aGVzaXNXcmFwcGVyPXZvaWQgMDtjb25zdCBhPXIoMTg1NSk7dC5QYXJlbnRoZXNpc1dyYXBwZXI9Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLl9vcGVuPVwiXFxcXGxlZnQoXCIsdGhpcy5fY2xvc2U9XCJcXFxccmlnaHQpXCJ9d3JhcChlKXtyZXR1cm4gbmV3IGEuV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfXdyYXBJZk1vcmVUaGFuT25lQ2hhcihlKXtyZXR1cm4gZS5sZW5ndGg8PTE/ZTp0aGlzLndyYXAoZSl9fX0sMTg1NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuV3JhcHBlcj12b2lkIDAsdC5XcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5fb3Blbj1lLHRoaXMuX2Nsb3NlPXR9d3JhcChlKXtyZXR1cm4gdGhpcy5fb3BlbitlK3RoaXMuX2Nsb3NlfX19LDI2OTc6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlZvaWRNYXRoTUxFbGVtZW50PXZvaWQgMCx0LlZvaWRNYXRoTUxFbGVtZW50PWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5uYW1lPVwidm9pZFwiLHRoaXMudmFsdWU9XCJcIix0aGlzLmNoaWxkcmVuPVtdLHRoaXMuYXR0cmlidXRlcz17fX19fSw0NzYwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkdlbmVyaWNTcGFjaW5nV3JhcHBlcj12b2lkIDA7Y29uc3QgYT1yKDQyNzkpO3QuR2VuZXJpY1NwYWNpbmdXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuIHRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFwiKX19fSw5Mzc2OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkdlbmVyaWNVbmRlck92ZXI9dm9pZCAwO2NvbnN0IGE9cig3OTkpLG49cig4OTE3KSxvPXIoNDcyKTt0LkdlbmVyaWNVbmRlck92ZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtuYW1lOmUsY2hpbGRyZW46dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPXQubGVuZ3RoO2lmKDIhPT1yKXRocm93IG5ldyBuLkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3IoZSwyLHIpO2NvbnN0IG89KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFswXSkuY29udmVydCgpLGk9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFsxXSkuY29udmVydCgpO3JldHVybiB0aGlzLl9hcHBseUNvbW1hbmQobyxpKX1fYXBwbHlDb21tYW5kKGUsdCl7Y29uc3Qgcj10aGlzLl9tYXRobWxFbGVtZW50Lm5hbWUubWF0Y2goL3VuZGVyLyk/cy5VbmRlcjpzLk92ZXI7cmV0dXJuIG5ldyBpKHIpLmFwcGx5KGUsdCl9fTtjbGFzcyBpe2NvbnN0cnVjdG9yKGUpe3RoaXMuX3R5cGU9ZX1hcHBseShlLHQpe3JldHVybiBvLmxhdGV4QWNjZW50cy5pbmNsdWRlcyh0KT9gJHt0fXske2V9fWA6YCR7dGhpcy5fZGVmYXVsdENvbW1hbmR9eyR7dH19eyR7ZX19YH1nZXQgX2RlZmF1bHRDb21tYW5kKCl7cmV0dXJuIHRoaXMuX3R5cGU9PT1zLlVuZGVyP1wiXFxcXHVuZGVyc2V0XCI6XCJcXFxcb3ZlcnNldFwifX12YXIgczshZnVuY3Rpb24oZSl7ZVtlLlVuZGVyPTBdPVwiVW5kZXJcIixlW2UuT3Zlcj0xXT1cIk92ZXJcIn0oc3x8KHM9e30pKX0sNjk1OTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Wb2lkPXQuR2VuZXJpY1VuZGVyT3Zlcj10LkdlbmVyaWNTcGFjaW5nV3JhcHBlcj10Lk1Ucj10Lk1UYWJsZT10Lk1VbmRlcm92ZXI9dC5NVGV4dD10Lk1NdWx0aXNjcmlwdHM9dC5NU3Vic3VwPXQuTVN1Yj10Lk1TdXA9dC5NUGhhbnRvbT10Lk1FcnJvcj10Lk1FbmNsb3NlPXQuTUFjdGlvbj10Lk1Sb290PXQuTUZyYWM9dC5NRmVuY2VkPXQuTVNxcnQ9dC5NTj10Lk1PPXQuTUk9dC5NYXRoPXZvaWQgMDt2YXIgYT1yKDM5Myk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNYXRoXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuTWF0aH19KTt2YXIgbj1yKDcwMzcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUlcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbi5NSX19KTt2YXIgbz1yKDM0ODcpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTU9cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gby5NT319KTt2YXIgaT1yKDQ0NjQpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTU5cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaS5NTn19KTt2YXIgcz1yKDg2ODYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVNxcnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5NU3FydH19KTt2YXIgbD1yKDk1MTEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUZlbmNlZFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsLk1GZW5jZWR9fSk7dmFyIGM9cig2NDQwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1GcmFjXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuTUZyYWN9fSk7dmFyIHU9cig2MDUyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1Sb290XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHUuTVJvb3R9fSk7dmFyIGg9cigxNjc4KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1BY3Rpb25cIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaC5NQWN0aW9ufX0pO3ZhciBkPXIoMjYzMSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNRW5jbG9zZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBkLk1FbmNsb3NlfX0pO3ZhciBtPXIoMTg0MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNRXJyb3JcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbS5NRXJyb3J9fSk7dmFyIHA9cig3NDQzKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1QaGFudG9tXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHAuTVBoYW50b219fSk7dmFyIGY9cig2OTI2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1TdXBcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZi5NU3VwfX0pO3ZhciB4PXIoMjU2NCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNU3ViXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHguTVN1Yn19KTt2YXIgZz1yKDEzNTgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVN1YnN1cFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBnLk1TdWJzdXB9fSk7dmFyIHc9cig4MzAzKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1NdWx0aXNjcmlwdHNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdy5NTXVsdGlzY3JpcHRzfX0pO3ZhciBiPXIoMzk1MSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNVGV4dFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBiLk1UZXh0fX0pO3ZhciB2PXIoMTIyMik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNVW5kZXJvdmVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHYuTVVuZGVyb3Zlcn19KTt2YXIgQz1yKDIzNTApO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVRhYmxlXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEMuTVRhYmxlfX0pO3ZhciBBPXIoMTU4Nik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNVHJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQS5NVHJ9fSk7dmFyIEU9cig0NzYwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkdlbmVyaWNTcGFjaW5nV3JhcHBlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBFLkdlbmVyaWNTcGFjaW5nV3JhcHBlcn19KTt2YXIgXz1yKDkzNzYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiR2VuZXJpY1VuZGVyT3ZlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBfLkdlbmVyaWNVbmRlck92ZXJ9fSk7dmFyIHk9cig5MTY1KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIlZvaWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4geS5Wb2lkfX0pfSwxNjc4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1BY3Rpb249dm9pZCAwO2NvbnN0IGE9cig3OTkpO3QuTUFjdGlvbj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e2NoaWxkcmVuOmV9PXRoaXMuX21hdGhtbEVsZW1lbnQ7cmV0dXJuIHRoaXMuX2lzVG9nZ2xlKCk/ZS5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXFxcXExvbmdyaWdodGFycm93IFwiKTooMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlWzBdKS5jb252ZXJ0KCl9X2lzVG9nZ2xlKCl7Y29uc3R7YWN0aW9udHlwZTplfT10aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXM7cmV0dXJuXCJ0b2dnbGVcIj09PWV8fCFlfX19LDM5MzooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NYXRoPXZvaWQgMDtjb25zdCBhPXIoNzk5KSxuPXIoMjQyNCk7dC5NYXRoPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT10aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIik7cmV0dXJuKDAsbi5ub3JtYWxpemVXaGl0ZVNwYWNlcykoZSl9fX0sMjYzMTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRW5jbG9zZT12b2lkIDA7Y29uc3QgYT1yKDc5OSk7dC5NRW5jbG9zZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0IGU9dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpO3JldHVyblwiYWN0dWFyaWFsXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXG92ZXJsaW5le1xcXFxsZWZ0LiR7ZX1cXFxccmlnaHR8fWA6XCJyYWRpY2FsXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXHNxcnR7JHtlfX1gOltcImJveFwiLFwicm91bmRlZGJveFwiLFwiY2lyY2xlXCJdLmluY2x1ZGVzKHRoaXMuX25vdGF0aW9uKT9gXFxcXGJveGVkeyR7ZX19YDpcImxlZnRcIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcbGVmdHwke2V9YDpcInJpZ2h0XCI9PT10aGlzLl9ub3RhdGlvbj9gJHtlfVxcXFxyaWdodHxgOlwidG9wXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXG92ZXJsaW5leyR7ZX19YDpcImJvdHRvbVwiPT09dGhpcy5fbm90YXRpb24/YFxcXFx1bmRlcmxpbmV7JHtlfX1gOlwidXBkaWFnb25hbHN0cmlrZVwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxjYW5jZWx7JHtlfX1gOlwiZG93bmRpYWdvbmFsc3RyaWtlXCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXGJjYW5jZWx7JHtlfX1gOlwidXBkaWFnb25hbGFycm93XCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXGNhbmNlbHRve317JHtlfX1gOltcInZlcnRpY2Fsc3RyaWtlXCIsXCJob3Jpem9udGFsc3RyaWtlXCJdLmluY2x1ZGVzKHRoaXMuX25vdGF0aW9uKT9gXFxcXGhjYW5jZWx7JHtlfX1gOlwibWFkcnV3YlwiPT09dGhpcy5fbm90YXRpb24/YFxcXFx1bmRlcmxpbmV7JHtlfVxcXFxyaWdodHx9YDpcInBoYXNvcmFuZ2xlXCI9PT10aGlzLl9ub3RhdGlvbj9ge1xcXFxhbmdsZSBcXFxcdW5kZXJsaW5leyR7ZX19fWA6YFxcXFxvdmVybGluZXtcXFxcbGVmdC5cXFxccmlnaHQpJHtlfX1gfWdldCBfbm90YXRpb24oKXtyZXR1cm4gdGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzLm5vdGF0aW9ufHxcImxvbmdkaXZcIn19fSwxODQwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1FcnJvcj12b2lkIDA7Y29uc3QgYT1yKDc5OSk7dC5NRXJyb3I9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5gXFxcXGNvbG9ye3JlZH17JHt0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIil9fWB9fX0sOTUxMTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRmVuY2VkPXZvaWQgMDtjb25zdCBhPXIoNzk5KSxuPXIoNDI3OSk7dC5NRmVuY2VkPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZSx0aGlzLl9vcGVuPXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5vcGVufHxcIlwiLHRoaXMuX2Nsb3NlPXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5jbG9zZXx8XCJcIix0aGlzLl9zZXBhcmF0b3JzPUFycmF5LmZyb20odGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzLnNlcGFyYXRvcnN8fFwiXCIpfWNvbnZlcnQoKXtjb25zdCBlPXRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKTtyZXR1cm4gdGhpcy5faXNUaGVyZVJlbGF0aXZlT2ZOYW1lKHRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4sXCJtdGFibGVcIik/bmV3IGkodGhpcy5fb3Blbix0aGlzLl9jbG9zZSkuYXBwbHkoZSk6bmV3IG8odGhpcy5fb3Blbix0aGlzLl9jbG9zZSx0aGlzLl9zZXBhcmF0b3JzKS5hcHBseShlKX1faXNUaGVyZVJlbGF0aXZlT2ZOYW1lKGUsdCl7cmV0dXJuIGUuc29tZSgoZT0+ZS5uYW1lPT09dHx8dGhpcy5faXNUaGVyZVJlbGF0aXZlT2ZOYW1lKGUuY2hpbGRyZW4sdCkpKX19O2NsYXNzIG97Y29uc3RydWN0b3IoZSx0LHIpe3RoaXMuX29wZW49ZXx8XCIoXCIsdGhpcy5fY2xvc2U9dHx8XCIpXCIsdGhpcy5fc2VwYXJhdG9ycz1yfWFwcGx5KGUpe2NvbnN0IHQ9bi5Kb2luV2l0aE1hbnlTZXBhcmF0b3JzLmpvaW4oZSx0aGlzLl9zZXBhcmF0b3JzKTtyZXR1cm4gbmV3IG4uR2VuZXJpY1dyYXBwZXIodGhpcy5fb3Blbix0aGlzLl9jbG9zZSkud3JhcCh0KX19Y2xhc3MgaXtjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX2dlbmVyaWNDb21tYW5kPVwibWF0cml4XCIsdGhpcy5fc2VwYXJhdG9ycz1uZXcgcyhlLHQpfWFwcGx5KGUpe2NvbnN0IHQ9dGhpcy5fY29tbWFuZCxyPWBcXFxcYmVnaW57JHt0fX1cXG4ke2Uuam9pbihcIlwiKX1cXG5cXFxcZW5keyR7dH19YDtyZXR1cm4gdD09PXRoaXMuX2dlbmVyaWNDb21tYW5kP3RoaXMuX3NlcGFyYXRvcnMud3JhcChyKTpyfWdldCBfY29tbWFuZCgpe3JldHVybiB0aGlzLl9zZXBhcmF0b3JzLmFyZVBhcmVudGhlc2VzKCk/XCJwbWF0cml4XCI6dGhpcy5fc2VwYXJhdG9ycy5hcmVTcXVhcmVCcmFja2V0cygpP1wiYm1hdHJpeFwiOnRoaXMuX3NlcGFyYXRvcnMuYXJlQnJhY2tldHMoKT9cIkJtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZURpdmlkZXMoKT9cInZtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZVBhcmFsbGVscygpP1wiVm1hdHJpeFwiOnRoaXMuX3NlcGFyYXRvcnMuYXJlTm90RXF1YWwoKT90aGlzLl9nZW5lcmljQ29tbWFuZDpcImJtYXRyaXhcIn19Y2xhc3Mgc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX29wZW49ZSx0aGlzLl9jbG9zZT10fXdyYXAoZSl7cmV0dXJuIG5ldyBuLkdlbmVyaWNXcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAoZSl9YXJlUGFyZW50aGVzZXMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcIihcIixcIilcIil9YXJlU3F1YXJlQnJhY2tldHMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcIltcIixcIl1cIil9YXJlQnJhY2tldHMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcIntcIixcIn1cIil9YXJlRGl2aWRlcygpe3JldHVybiB0aGlzLl9jb21wYXJlKFwifFwiLFwifFwiKX1hcmVQYXJhbGxlbHMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcInx8XCIsXCJ8fFwiKX1hcmVOb3RFcXVhbCgpe3JldHVybiB0aGlzLl9vcGVuIT09dGhpcy5fY2xvc2V9X2NvbXBhcmUoZSx0KXtyZXR1cm4gdGhpcy5fb3Blbj09PWUmJnRoaXMuX2Nsb3NlPT09dH19fSw2NDQwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1GcmFjPXZvaWQgMDtjb25zdCBhPXIoODkxNyksbj1yKDQyNzkpO3QuTUZyYWM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtjaGlsZHJlbjplLG5hbWU6dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPWUubGVuZ3RoO2lmKDIhPT1yKXRocm93IG5ldyBhLkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3IodCwyLHIpO2NvbnN0IG89KDAsbi5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZVswXSkuY29udmVydCgpLGk9KDAsbi5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZVsxXSkuY29udmVydCgpO3JldHVybiB0aGlzLl9pc0JldmVsbGVkKCk/YCR7dGhpcy5fd3JhcElmTW9yZVRoYW5PbmVDaGFyKG8pfS8ke3RoaXMuX3dyYXBJZk1vcmVUaGFuT25lQ2hhcihpKX1gOmBcXFxcZnJhY3ske299fXske2l9fWB9X3dyYXBJZk1vcmVUaGFuT25lQ2hhcihlKXtyZXR1cm4obmV3IG4uUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwSWZNb3JlVGhhbk9uZUNoYXIoZSl9X2lzQmV2ZWxsZWQoKXtyZXR1cm4hIXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5iZXZlbGxlZH19fSw3MDM3OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1JPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDU0MDYpLG89cig2MTIyKTt0Lk1JPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudXRmOENvbnZlcnRlcj1uZXcgby5IYXNoVVRGOFRvTHRYQ29udmVydGVyLHRoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT0oMCxhLm5vcm1hbGl6ZVdoaXRlU3BhY2VzKSh0aGlzLl9tYXRobWxFbGVtZW50LnZhbHVlKTtpZihcIiBcIj09PWUpcmV0dXJuIGkuYXBwbHkoZSk7Y29uc3QgdD1lLnRyaW0oKSxyPWkuYXBwbHkodCksbj10aGlzLnV0ZjhDb252ZXJ0ZXIuY29udmVydChyKTtyZXR1cm4gbiE9PXI/bjp0aGlzLndyYXBJbk1hdGhWYXJpYW50KHIsdGhpcy5nZXRNYXRoVmFyaWFudCh0aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMpKX1nZXRNYXRoVmFyaWFudChlKXtpZihlJiZlLm1hdGh2YXJpYW50KXJldHVybiBlLm1hdGh2YXJpYW50fXdyYXBJbk1hdGhWYXJpYW50KGUsdCl7c3dpdGNoKHQpe2Nhc2VcImJvbGRcIjpyZXR1cm5gXFxcXG1hdGhiZnske2V9fWA7Y2FzZVwiaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoaXR7JHtlfX1gO2Nhc2VcImJvbGQtaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhpdHske2V9fX1gO2Nhc2VcImRvdWJsZS1zdHJ1Y2tcIjpyZXR1cm5gXFxcXG1hdGhiYnske2V9fWA7Y2FzZVwiYm9sZC1mcmFrdHVyXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhmcmFreyR7ZX19fWA7Y2FzZVwic2NyaXB0XCI6cmV0dXJuYFxcXFxtYXRoY2FseyR7ZX19YDtjYXNlXCJib2xkLXNjcmlwdFwiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoY2FseyR7ZX19fWA7Y2FzZVwiZnJha3R1clwiOnJldHVybmBcXFxcbWF0aGZyYWt7JHtlfX1gO2Nhc2VcInNhbnMtc2VyaWZcIjpyZXR1cm5gXFxcXG1hdGhzZnske2V9fWA7Y2FzZVwiYm9sZC1zYW5zLXNlcmlmXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhzZnske2V9fX1gO2Nhc2VcInNhbnMtc2VyaWYtaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoc2Z7XFxcXG1hdGhpdHske2V9fX1gO2Nhc2VcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjpyZXR1cm5gXFxcXG1hdGhiZntcXFxcbWF0aHNme1xcXFxtYXRoaXR7JHtlfX19fWA7Y2FzZVwibW9ub3NwYWNlXCI6cmV0dXJuYFxcXFxtYXRodHR7JHtlfX1gO2RlZmF1bHQ6cmV0dXJuIGV9fX07Y2xhc3MgaXtjb25zdHJ1Y3RvcihlKXt0aGlzLl92YWx1ZT1lfXN0YXRpYyBhcHBseShlKXtyZXR1cm4gbmV3IGkoZSkuX2FwcGx5KCl9X2FwcGx5KCl7cmV0dXJuIHRoaXMuX2ZpbmRCeUNoYXJhY3RlcigpfHx0aGlzLl9maW5kQnlHbHlwaCgpfHx0aGlzLl9maW5kQnlOdW1iZXIoKXx8KG5ldyBvLkhhc2hVVEY4VG9MdFhDb252ZXJ0ZXIpLmNvbnZlcnQodGhpcy5fdmFsdWUpfV9maW5kQnlDaGFyYWN0ZXIoKXtyZXR1cm4gbi5hbGxNYXRoU3ltYm9sc0J5Q2hhclt0aGlzLl92YWx1ZV19X2ZpbmRCeUdseXBoKCl7cmV0dXJuIG4uYWxsTWF0aFN5bWJvbHNCeUdseXBoW3RoaXMuX3ZhbHVlXX1fZmluZEJ5TnVtYmVyKCl7cmV0dXJuIG4ubWF0aE51bWJlckJ5R2x5cGhbdGhpcy5fdmFsdWVdfX19LDgzMDM6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTU11bHRpc2NyaXB0cz12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig4OTE3KTt0Lk1NdWx0aXNjcmlwdHM9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtuYW1lOmUsY2hpbGRyZW46dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPXQubGVuZ3RoO2lmKHI8Myl0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMyxyLFwiYXQgbGVhc3RcIik7Y29uc3Qgbz0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzBdKS5jb252ZXJ0KCk7cmV0dXJuIHRoaXMuX3ByZXNjcmlwdExhdGV4KCkrdGhpcy5fd3JhcEluUGFyZW50aGVzaXNJZlRoZXJlSXNTcGFjZShvKSt0aGlzLl9wb3N0c2NyaXB0TGF0ZXgoKX1fcHJlc2NyaXB0TGF0ZXgoKXtjb25zdHtjaGlsZHJlbjplfT10aGlzLl9tYXRobWxFbGVtZW50O2xldCB0LHI7aWYodGhpcy5faXNQcmVzY3JpcHRzKGVbMV0pKXQ9ZVsyXSxyPWVbM107ZWxzZXtpZighdGhpcy5faXNQcmVzY3JpcHRzKGVbM10pKXJldHVyblwiXCI7dD1lWzRdLHI9ZVs1XX1yZXR1cm5gXFxcXF97JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0KS5jb252ZXJ0KCl9fV57JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShyKS5jb252ZXJ0KCl9fWB9X3Bvc3RzY3JpcHRMYXRleCgpe2NvbnN0e2NoaWxkcmVuOmV9PXRoaXMuX21hdGhtbEVsZW1lbnQ7aWYodGhpcy5faXNQcmVzY3JpcHRzKGVbMV0pKXJldHVyblwiXCI7Y29uc3QgdD1lWzFdLHI9ZVsyXTtyZXR1cm5gX3skeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHQpLmNvbnZlcnQoKX19XnskeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHIpLmNvbnZlcnQoKX19YH1fd3JhcEluUGFyZW50aGVzaXNJZlRoZXJlSXNTcGFjZShlKXtyZXR1cm4gZS5tYXRjaCgvXFxzKy9nKT8obmV3IGEuUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwKGUpOmV9X2lzUHJlc2NyaXB0cyhlKXtyZXR1cm5cIm1wcmVzY3JpcHRzXCI9PT0obnVsbD09ZT92b2lkIDA6ZS5uYW1lKX19fSw0NDY0OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1OPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDU0MDYpO3QuTU49Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdCBlPSgwLGEubm9ybWFsaXplV2hpdGVTcGFjZXMpKHRoaXMuX21hdGhtbEVsZW1lbnQudmFsdWUpLnRyaW0oKTtyZXR1cm4gbi5tYXRoTnVtYmVyQnlHbHlwaFtlXXx8ZX19fSwzNDg3OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1PPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDU0MDYpO3QuTU89Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdCBlPSgwLGEubm9ybWFsaXplV2hpdGVTcGFjZXMpKHRoaXMuX21hdGhtbEVsZW1lbnQudmFsdWUpLnRyaW0oKTtyZXR1cm4gby5vcGVyYXRlKGUpfX07Y2xhc3Mgb3tjb25zdHJ1Y3RvcihlKXt0aGlzLl92YWx1ZT1lfXN0YXRpYyBvcGVyYXRlKGUpe3JldHVybiBuZXcgbyhlKS5fb3BlcmF0ZSgpfV9vcGVyYXRlKCl7cmV0dXJuIHRoaXMuX2ZpbmRCeUNoYXJhY3RlcigpfHx0aGlzLl9maW5kQnlHbHlwaCgpfHx0aGlzLl9maW5kQnlOdW1iZXIoKXx8KG5ldyBuLkhhc2hVVEY4VG9MdFhDb252ZXJ0ZXIpLmNvbnZlcnQodGhpcy5fdmFsdWUpfV9maW5kQnlDaGFyYWN0ZXIoKXtyZXR1cm4gbi5hbGxNYXRoT3BlcmF0b3JzQnlDaGFyW3RoaXMuX3ZhbHVlXX1fZmluZEJ5R2x5cGgoKXtyZXR1cm4gbi5hbGxNYXRoT3BlcmF0b3JzQnlHbHlwaFt0aGlzLl92YWx1ZV19X2ZpbmRCeU51bWJlcigpe3JldHVybiBuLm1hdGhOdW1iZXJCeUdseXBoW3RoaXMuX3ZhbHVlXX19fSw3NDQzOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NUGhhbnRvbT12b2lkIDAsdC5NUGhhbnRvbT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe3JldHVyblwiXCJ9fX0sNjA1MjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NUm9vdD12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig4OTE3KTt0Lk1Sb290PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMixyKTtjb25zdCBvPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMF0pLmNvbnZlcnQoKTtyZXR1cm5gXFxcXHNxcnRbJHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzFdKS5jb252ZXJ0KCl9XXske299fWB9fX0sODY4NjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3FydD12b2lkIDA7Y29uc3QgYT1yKDQyNzkpO3QuTVNxcnQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5gXFxcXHNxcnR7JHt0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIil9fWB9fX0sMjU2NDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3ViPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVN1Yj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMiE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDIscik7Y29uc3QgYT10WzBdLG89dFsxXTtyZXR1cm5gJHt0aGlzLl9oYW5kbGVCYXNlQ2hpbGQoYSl9XyR7dGhpcy5faGFuZGxlU3Vic2NyaXB0Q2hpbGQobyl9YH1faGFuZGxlQmFzZUNoaWxkKGUpe2NvbnN0IHQ9ZS5jaGlsZHJlbixyPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4gdC5sZW5ndGg8PTE/cjoobmV3IGEuUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwSWZNb3JlVGhhbk9uZUNoYXIocil9X2hhbmRsZVN1YnNjcmlwdENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX19fSwxMzU4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1TdWJzdXA9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NU3Vic3VwPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigzIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMyxyKTtjb25zdCBhPXRbMF0sbz10WzFdLGk9dFsyXTtyZXR1cm5gJHt0aGlzLl9oYW5kbGVCYXNlQ2hpbGQoYSl9XyR7dGhpcy5faGFuZGxlU3Vic2NyaXB0Q2hpbGQobyl9XiR7dGhpcy5faGFuZGxlU3VwZXJzY3JpcHRDaGlsZChpKX1gfV9oYW5kbGVCYXNlQ2hpbGQoZSl7Y29uc3QgdD1lLmNoaWxkcmVuLHI9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybiB0Lmxlbmd0aDw9MT9yOihuZXcgYS5QYXJlbnRoZXNpc1dyYXBwZXIpLndyYXBJZk1vcmVUaGFuT25lQ2hhcihyKX1faGFuZGxlU3Vic2NyaXB0Q2hpbGQoZSl7Y29uc3QgdD0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKS5jb252ZXJ0KCk7cmV0dXJuKG5ldyBhLkJyYWNrZXRXcmFwcGVyKS53cmFwKHQpfV9oYW5kbGVTdXBlcnNjcmlwdENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX19fSw2OTI2OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1TdXA9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NU3VwPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMixyKTtjb25zdCBhPXRbMF0sbz10WzFdO3JldHVybmAke3RoaXMuX2hhbmRsZUJhc2VDaGlsZChhKX1eJHt0aGlzLl9oYW5kbGVFeHBvbmVudENoaWxkKG8pfWB9X2hhbmRsZUJhc2VDaGlsZChlKXtjb25zdCB0PWUuY2hpbGRyZW4scj0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKS5jb252ZXJ0KCk7cmV0dXJuIHQubGVuZ3RoPD0xP3I6KG5ldyBhLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcElmTW9yZVRoYW5PbmVDaGFyKHIpfV9oYW5kbGVFeHBvbmVudENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX19fSwyMzUwOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1UYWJsZT12b2lkIDA7Y29uc3QgYT1yKDQyNzkpO3QuTVRhYmxlPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZSx0aGlzLl9hZGRGbGFnUmVjdXJzaXZlSWZOYW1lKHRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4sXCJtdGFibGVcIixcImlubmVyVGFibGVcIil9Y29udmVydCgpe2NvbnN0IGU9dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXFxcXFxcXFxcXG5cIik7cmV0dXJuIHRoaXMuX2hhc0ZsYWcoXCJpbm5lclRhYmxlXCIpP3RoaXMuX3dyYXAoZSk6ZX1fd3JhcChlKXtyZXR1cm5gXFxcXGJlZ2lue21hdHJpeH0ke2V9XFxcXGVuZHttYXRyaXh9YH1fYWRkRmxhZ1JlY3Vyc2l2ZUlmTmFtZShlLHQscil7ZS5mb3JFYWNoKChlPT57ZS5uYW1lPT09dCYmKGUuYXR0cmlidXRlc1tyXT1yKSx0aGlzLl9hZGRGbGFnUmVjdXJzaXZlSWZOYW1lKGUuY2hpbGRyZW4sdCxyKX0pKX1faGFzRmxhZyhlKXtyZXR1cm4hIXRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlc1tlXX19fSwzOTUxOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1UZXh0PXZvaWQgMDtjb25zdCBhPXIoNzAzNyk7dC5NVGV4dD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e2F0dHJpYnV0ZXM6ZSx2YWx1ZTp0fT10aGlzLl9tYXRobWxFbGVtZW50O3JldHVyblsuLi50XS5tYXAoKGU9Pi9eW2EtekEtWjAtOV0kLy50ZXN0KGUpfHxcIiBcIj09PWU/e3ZhbHVlOmUsaXNBbHBoYW51bWVyaWM6ITB9Ont2YWx1ZTplLGlzQWxwaGFudW1lcmljOiExfSkpLnJlZHVjZSgoKGUsdCk9PntpZih0LmlzQWxwaGFudW1lcmljKXtjb25zdCByPWVbZS5sZW5ndGgtMV07aWYociYmci5pc0FscGhhbnVtZXJpYylyZXR1cm4gci52YWx1ZSs9dC52YWx1ZSxlfXJldHVyblsuLi5lLHRdfSksW10pLm1hcCgodD0+dC5pc0FscGhhbnVtZXJpYz9uZXcgbihlLm1hdGh2YXJpYW50KS5hcHBseSh0LnZhbHVlKTpuZXcgYS5NSSh7bmFtZTpcIm1pXCIsYXR0cmlidXRlczp7fSxjaGlsZHJlbjpbXSx2YWx1ZTp0LnZhbHVlfSkuY29udmVydCgpKSkuam9pbihcIlwiKX19O2NsYXNzIG57Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aHZhcmlhbnQ9ZXx8XCJub3JtYWxcIn1hcHBseShlKXtyZXR1cm4gdGhpcy5fY29tbWFuZHMucmVkdWNlKCgodCxyLGEpPT4wPT09YT9gJHtyfXske2V9fWA6YCR7cn17JHt0fX1gKSxcIlwiKX1nZXQgX2NvbW1hbmRzKCl7c3dpdGNoKHRoaXMuX21hdGh2YXJpYW50KXtjYXNlXCJib2xkXCI6cmV0dXJuW1wiXFxcXHRleHRiZlwiXTtjYXNlXCJpdGFsaWNcIjpyZXR1cm5bXCJcXFxcdGV4dGl0XCJdO2Nhc2VcImJvbGQtaXRhbGljXCI6cmV0dXJuW1wiXFxcXHRleHRpdFwiLFwiXFxcXHRleHRiZlwiXTtjYXNlXCJkb3VibGUtc3RydWNrXCI6cmV0dXJuW1wiXFxcXG1hdGhiYlwiXTtjYXNlXCJtb25vc3BhY2VcIjpyZXR1cm5bXCJcXFxcbWF0aHR0XCJdO2Nhc2VcImJvbGQtZnJha3R1clwiOmNhc2VcImZyYWt0dXJcIjpyZXR1cm5bXCJcXFxcbWF0aGZyYWtcIl07ZGVmYXVsdDpyZXR1cm5bXCJcXFxcdGV4dFwiXX19fX0sMTU4NjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVHI9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0Lk1Ucj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe3JldHVybiB0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiAmIFwiKX19fSwxMjIyOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1VbmRlcm92ZXI9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NVW5kZXJvdmVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigzIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMyxyKTtyZXR1cm5gJHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzBdKS5jb252ZXJ0KCl9X3skeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMV0pLmNvbnZlcnQoKX19XnskeygwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMl0pLmNvbnZlcnQoKX19YH19fSw5MTY1OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Wb2lkPXZvaWQgMCx0LlZvaWQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5cIlwifX19LDU0NDM6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdHx8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSl9OmZ1bmN0aW9uKGUsdCl7ZS5kZWZhdWx0PXR9KSxvPXRoaXMmJnRoaXMuX19pbXBvcnRTdGFyfHxmdW5jdGlvbihlKXtpZihlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIHQ9e307aWYobnVsbCE9ZSlmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIiE9PXImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpJiZhKHQsZSxyKTtyZXR1cm4gbih0LGUpLHR9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyPXZvaWQgMDtjb25zdCBpPW8ocig2OTU5KSkscz1yKDI2OTcpO3QuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhNTEVsZW1lbnQ9bnVsbCE9ZT9lOm5ldyBzLlZvaWRNYXRoTUxFbGVtZW50fXRvTGF0ZXhDb252ZXJ0ZXIoKXtjb25zdHtuYW1lOmV9PXRoaXMuX21hdGhNTEVsZW1lbnQ7cmV0dXJuIG5ldyhsW2VdfHxpLkdlbmVyaWNTcGFjaW5nV3JhcHBlcikodGhpcy5fbWF0aE1MRWxlbWVudCl9fTtjb25zdCBsPXttYXRoOmkuTWF0aCxtaTppLk1JLG1vOmkuTU8sbW46aS5NTixtc3FydDppLk1TcXJ0LG1mZW5jZWQ6aS5NRmVuY2VkLG1mcmFjOmkuTUZyYWMsbXJvb3Q6aS5NUm9vdCxtYWN0aW9uOmkuTUFjdGlvbixtZW5jbG9zZTppLk1FbmNsb3NlLG1lcnJvcjppLk1FcnJvcixtcGhhbnRvbTppLk1QaGFudG9tLG1zdXA6aS5NU3VwLG1zdWI6aS5NU3ViLG1zdWJzdXA6aS5NU3Vic3VwLG1tdWx0aXNjcmlwdHM6aS5NTXVsdGlzY3JpcHRzLG10ZXh0OmkuTVRleHQsbXVuZGVyb3ZlcjppLk1VbmRlcm92ZXIsbXRhYmxlOmkuTVRhYmxlLG10cjppLk1Ucixtb3ZlcjppLkdlbmVyaWNVbmRlck92ZXIsbXVuZGVyOmkuR2VuZXJpY1VuZGVyT3Zlcixtcm93OmkuR2VuZXJpY1NwYWNpbmdXcmFwcGVyLG1wYWRkZWQ6aS5HZW5lcmljU3BhY2luZ1dyYXBwZXIsdm9pZDppLlZvaWR9fSw1MjQzOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5FcnJvckhhbmRsZXI9dm9pZCAwLHQuRXJyb3JIYW5kbGVyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fZXJyb3JzPVtdLHRoaXMuZXJyb3JMb2NhdG9yPXt9fWZpeEVycm9yKGUsdCl7cmV0dXJuIHRoaXMuX2lzTWlzc2luZ0F0dHJpYnV0ZVZhbHVlRXJyb3IodCk/KHRoaXMuX2Vycm9ycy5wdXNoKHQpLHRoaXMuX2ZpeE1pc3NpbmdBdHRyaWJ1dGUodCxlKSk6ZX1pc1RoZXJlQW55RXJyb3JzKCl7cmV0dXJuIHRoaXMuX2Vycm9ycy5sZW5ndGg+MH1jbGVhbkVycm9ycygpe3RoaXMuX2Vycm9ycz1bXX1fZml4TWlzc2luZ0F0dHJpYnV0ZShlLHQpe2NvbnN0IHI9ZS5zcGxpdCgnXCInKVsxXTtpZihyKXJldHVybiB0LnJlcGxhY2UodGhpcy5fbWF0Y2hNaXNzaW5nVmFsdWVGb3JBdHRyaWJ1dGUociksXCJcIik7Zm9yKDt0aGlzLl9tYXRoR2VuZXJpY01pc3NpbmdWYWx1ZSgpLmV4ZWModCk7KXQ9dC5yZXBsYWNlKHRoaXMuX21hdGhHZW5lcmljTWlzc2luZ1ZhbHVlKCksXCIkMSQzXCIpO3JldHVybiB0fV9tYXRjaE1pc3NpbmdWYWx1ZUZvckF0dHJpYnV0ZShlKXtyZXR1cm4gbmV3IFJlZ0V4cChgKCR7ZX09KD8hKFwifCcpKSl8KCR7ZX0oPyEoXCJ8JykpKWAsXCJnbVwiKX1fbWF0aEdlbmVyaWNNaXNzaW5nVmFsdWUoKXtyZXR1cm4vKFxcPC4qICkoXFx3Kz0oPyFcXFwifFxcJykpKC4qXFw+KS9nbX1faXNNaXNzaW5nQXR0cmlidXRlVmFsdWVFcnJvcihlKXtyZXR1cm4hIWUuaW5jbHVkZXMoXCJhdHRyaWJ1dGVcIikmJiEhZS5pbmNsdWRlcyhcIm1pc3NlZFwiKXx8ZS5pbmNsdWRlcyhcImF0dHJpYnV0ZSB2YWx1ZSBtaXNzZWRcIil9fX0sOTIwODpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpO3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtuJiYhKFwiZ2V0XCJpbiBuPyF0Ll9fZXNNb2R1bGU6bi53cml0YWJsZXx8bi5jb25maWd1cmFibGUpfHwobj17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLG4pfTpmdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKSxlW2FdPXRbcl19KSxuPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiBlKVwiZGVmYXVsdFwiPT09cnx8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscil8fGEodCxlLHIpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuKHIoOTU0OCksdCksbihyKDUyNDMpLHQpLG4ocigxMTAxKSx0KX0sMTEwMTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRWxlbWVudHNUb01hdGhNTEFkYXB0ZXI9dm9pZCAwLHQuRWxlbWVudHNUb01hdGhNTEFkYXB0ZXI9Y2xhc3N7Y29udmVydChlKXtyZXR1cm4gZS5maWx0ZXIoKGU9PnZvaWQgMCE9PWUudGFnTmFtZSkpLm1hcCgoZT0+dGhpcy5fY29udmVydEVsZW1lbnQoZSkpKX1fY29udmVydEVsZW1lbnQoZSl7cmV0dXJue25hbWU6ZS50YWdOYW1lLGF0dHJpYnV0ZXM6dGhpcy5fY29udmVydEVsZW1lbnRBdHRyaWJ1dGVzKGUuYXR0cmlidXRlcyksdmFsdWU6dGhpcy5faGFzRWxlbWVudENoaWxkKGUpP1wiXCI6ZS50ZXh0Q29udGVudHx8XCJcIixjaGlsZHJlbjp0aGlzLl9oYXNFbGVtZW50Q2hpbGQoZSk/dGhpcy5jb252ZXJ0KEFycmF5LmZyb20oZS5jaGlsZE5vZGVzKSk6W119fV9jb252ZXJ0RWxlbWVudEF0dHJpYnV0ZXMoZSl7cmV0dXJuIEFycmF5LmZyb20oZSkucmVkdWNlKCgoZSx0KT0+T2JqZWN0LmFzc2lnbih7W3Qubm9kZU5hbWVdOnQubm9kZVZhbHVlPT09dC5ub2RlTmFtZT9cIlwiOnQubm9kZVZhbHVlfSxlKSkse30pfV9oYXNFbGVtZW50Q2hpbGQoZSl7Y29uc3QgdD1lLmNoaWxkTm9kZXM7cmV0dXJuISF0JiYwIT09dC5sZW5ndGgmJnRoaXMuX2lzVGhlcmVBbnlOb1RleHROb2RlKHQpfV9pc1RoZXJlQW55Tm9UZXh0Tm9kZShlKXtyZXR1cm4gQXJyYXkuZnJvbShlKS5zb21lKChlPT5cIiN0ZXh0XCIhPT1lLm5vZGVOYW1lKSl9fX0sOTU0ODpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9dGhpcyYmdGhpcy5fX2ltcG9ydERlZmF1bHR8fGZ1bmN0aW9uKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5YbWxUb01hdGhNTEFkYXB0ZXI9dm9pZCAwO2NvbnN0IG49YShyKDg5NzgpKTt0LlhtbFRvTWF0aE1MQWRhcHRlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX3htbD1cIlwiLHRoaXMuX2VsZW1lbnRzQ29udmVydG9yPWUsdGhpcy5fZXJyb3JIYW5kbGVyPXQsdGhpcy5feG1sRE9NPW5ldyBuLmRlZmF1bHQuRE9NUGFyc2VyKHtsb2NhdG9yOnRoaXMuX2Vycm9ySGFuZGxlci5lcnJvckxvY2F0b3IsZXJyb3JIYW5kbGVyOnRoaXMuX2ZpeEVycm9yLmJpbmQodGhpcyl9KX1jb252ZXJ0KGUpe3JldHVybiB0aGlzLl94bWw9dGhpcy5fcmVtb3ZlTGluZUJyZWFrcyhlKSx0aGlzLl94bWw9dGhpcy5fcmVtb3ZlTXNXb3JkUHJlZml4ZXModGhpcy5feG1sKSx0aGlzLl9lbGVtZW50c0NvbnZlcnRvci5jb252ZXJ0KHRoaXMuX21hdGhNTEVsZW1lbnRzKX1fZml4RXJyb3IoZSl7dGhpcy5feG1sPXRoaXMuX2Vycm9ySGFuZGxlci5maXhFcnJvcih0aGlzLl94bWwsZSl9X3JlbW92ZUxpbmVCcmVha3MoZSl7cmV0dXJuIGUucmVwbGFjZSgvXFxufFxcclxcbnxcXHIvZyxcIlwiKX1fcmVtb3ZlTXNXb3JkUHJlZml4ZXMoZSl7cmV0dXJuIGUucmVwbGFjZSgvbW1sOi9nLFwiXCIpfWdldCBfbWF0aE1MRWxlbWVudHMoKXtsZXQgZT10aGlzLl94bWxET00ucGFyc2VGcm9tU3RyaW5nKHRoaXMuX3htbCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtYXRoXCIpO3JldHVybiB0aGlzLl9lcnJvckhhbmRsZXIuaXNUaGVyZUFueUVycm9ycygpJiYodGhpcy5fZXJyb3JIYW5kbGVyLmNsZWFuRXJyb3JzKCksZT10aGlzLl94bWxET00ucGFyc2VGcm9tU3RyaW5nKHRoaXMuX3htbCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJtYXRoXCIpKSxBcnJheS5mcm9tKGUpfX19LDc5NDE6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDg1ODUpLHQpfSw4NTg1OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm1ha2VUb01hdGhFbGVtZW50c0NvbnZlcnRlcj12b2lkIDA7Y29uc3QgYT1yKDkyMDgpO3QubWFrZVRvTWF0aEVsZW1lbnRzQ29udmVydGVyPSgpPT57Y29uc3QgZT1uZXcgYS5FbGVtZW50c1RvTWF0aE1MQWRhcHRlcix0PW5ldyBhLkVycm9ySGFuZGxlcjtyZXR1cm4gbmV3IGEuWG1sVG9NYXRoTUxBZGFwdGVyKGUsdCl9fSw4NjcyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocigzNzk4KSx0KX0sMzc5ODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NYXRoTUxUb0xhVGVYPXZvaWQgMDtjb25zdCBhPXIoNTQ0Myksbj1yKDc5NDEpO3QuTWF0aE1MVG9MYVRlWD1jbGFzc3tzdGF0aWMgY29udmVydChlKXtyZXR1cm4oMCxuLm1ha2VUb01hdGhFbGVtZW50c0NvbnZlcnRlcikoKS5jb252ZXJ0KGUpLm1hcCgoZT0+bmV3IGEuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyKGUpLnRvTGF0ZXhDb252ZXJ0ZXIoKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiXCIpLnRyaW0oKX19fSwyOTY1OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoT3BlcmF0b3JzQnlDaGFyPXZvaWQgMCx0LmFsbE1hdGhPcGVyYXRvcnNCeUNoYXI9e186XCJcXFxcdW5kZXJsaW5lXCIsXCImI3gyM0UxO1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzRTA7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyM0RGO1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzREU7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyM0REO1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzREM7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyM0I1O1wiOlwiXFxcXHVuZGVyYnJhY2VcIixcIiYjeDIzQjQ7XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCImI3gyMERDO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjBEQjtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIwNjQ7XCI6XCJcIixcIiYjeDIwNTc7XCI6XCInJycnXCIsXCImI3gyMDNFO1wiOlwiXFxcXGJhclwiLFwiJiN4MjAzNztcIjpcImBgYFwiLFwiJiN4MjAzNjtcIjpcImBgXCIsXCImI3gyMDM1O1wiOlwiYFwiLFwiJiN4MjAzNDtcIjpcIicnJ1wiLFwiJiN4MjAzMztcIjpcIicnXCIsXCImI3gyMDFGO1wiOlwiYGBcIixcIiYjeDIwMUU7XCI6XCIsLFwiLFwiJiN4MjAxQjtcIjpcImBcIixcIiYjeDIwMUE7XCI6XCIsXCIsXCImI3gzMDI7XCI6XCJcXFxcaGF0XCIsXCImI3gyRjc7XCI6XCJcXFxcc2ltXCIsXCImI3gyREQ7XCI6XCJcXFxcc2ltXCIsXCImI3gyREM7XCI6XCJcXFxcc2ltXCIsXCImI3gyREE7XCI6XCJcXFxcY2lyY1wiLFwiJiN4MkQ5O1wiOlwiXFxcXGNkb3RcIixcIiYjeDJEODtcIjpcIlwiLFwiJiN4MkNEO1wiOlwiXFxcXF9cIixcIiYjeDJDQjtcIjpcIsuLXCIsXCImI3gyQ0E7XCI6XCLLilwiLFwiJiN4MkM5O1wiOlwiy4lcIixcIiYjeDJDNztcIjpcIlwiLFwiJiN4MkM2O1wiOlwiXFxcXGhhdFwiLFwiJiN4QkE7XCI6XCJvXCIsXCImI3hCOTtcIjpcIjFcIixcIiYjeEI4O1wiOlwiwrhcIixcIiYjeEI0O1wiOlwiwrRcIixcIiYjeEIzO1wiOlwiM1wiLFwiJiN4QjI7XCI6XCIyXCIsXCImI3hCMDtcIjpcIlxcXFxjaXJjXCIsXCImI3hBRjtcIjpcIlxcXFxiYXJcIixcIiYjeEFBO1wiOlwiYVwiLFwiJiN4QTg7XCI6XCJcXFxcY2RvdFxcXFxjZG90XCIsXCJ+XCI6XCJcXFxcc2ltXCIsXCJgXCI6XCJgXCIsXCJeXCI6XCJcXFxcaGF0XCIsXCItLVwiOlwiLS1cIixcIisrXCI6XCIrK1wiLFwiJmFtcDtcIjpcIlxcXFwmXCIsXCImI3gyMDYxO1wiOlwiXCIsXCImI3gyMjFDO1wiOlwiXFxcXHNxcnRbNF17fVwiLFwiJiN4MjIxQjtcIjpcIlxcXFxzcXJ0WzNde31cIixcIiYjeDIyMUE7XCI6XCJcXFxcc3FydHt9XCIsXCImI3gyMTQ2O1wiOlwiZFwiLFwiJiN4MjE0NTtcIjpcIlxcXFxtYXRoYmJ7RH1cIixcIj9cIjpcIj9cIixcIkBcIjpcIkBcIixcIi8vXCI6XCIvL1wiLFwiISFcIjpcIiEhXCIsXCIhXCI6XCIhXCIsXCImI3gyNjZGO1wiOlwiXFxcXCNcIixcIiYjeDI2NkU7XCI6XCJcIixcIiYjeDI2NkQ7XCI6XCJcIixcIiYjeDIwMzI7XCI6XCInXCIsXCImbHQ7PlwiOlwiPD5cIixcIioqXCI6XCJcXFxcc3RhclxcXFxzdGFyXCIsXCImI3gyMjA3O1wiOlwiXFxcXG5hYmxhXCIsXCImI3gyMjAyO1wiOlwiXFxcXHBhcnRpYWxcIixcIiYjeDIyOTk7XCI6XCJcXFxcYmlnb2RvdFwiLFwiJiN4QUM7XCI6XCJcXFxcbmVnXCIsXCImI3gyMjIyO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDIyMjE7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4MjIyMDtcIjpcIlxcXFxhbmdsZVwiLFwiJiN4Rjc7XCI6XCJcXFxcZGl2XCIsXCIvXCI6XCIvXCIsXCImI3gyMjE2O1wiOlwiXFxcXGJhY2tzbGFzaFwiLFwiXFxcXFwiOlwiXFxcXGJhY2tzbGFzaFwiLFwiJVwiOlwiXFxcXCVcIixcIiYjeDIyOTc7XCI6XCJcXFxcYmlnb3RpbWVzXCIsXCImI3hCNztcIjpcIlxcXFxjZG90XCIsXCImI3gyQTNGO1wiOlwiXFxcXGNvcHJvZFwiLFwiJiN4MkEyRjtcIjpcIlxcXFx0aW1lc1wiLFwiJiN4MjJDNTtcIjpcIlxcXFxjZG90XCIsXCImI3gyMkExO1wiOlwiXFxcXGJveGRvdFwiLFwiJiN4MjJBMDtcIjpcIlxcXFxib3h0aW1lc1wiLFwiJiN4MjA2MjtcIjpcIlwiLFwiJiN4MjA0MztcIjpcIi1cIixcIiYjeDIwMjI7XCI6XCJcXFxcY2RvdFwiLFwiJiN4RDc7XCI6XCJcXFxcdGltZXNcIixcIi5cIjpcIi5cIixcIipcIjpcIlxcXFxzdGFyXCIsXCImI3gyMjJBO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjIyOTtcIjpcIlxcXFxjYXBcIixcIiYjeDIyMTA7XCI6XCJcXFxcY29wcm9kXCIsXCImI3gyMjBGO1wiOlwiXFxcXHByb2RcIixcIiYjeDIyNDA7XCI6XCJcIixcIiYjeDJBRkY7XCI6XCJcIixcIiYjeDJBRkM7XCI6XCJcXFxcbWlkXFxcXG1pZFxcXFxtaWRcIixcIiYjeDJBMDk7XCI6XCJcXFxcdGltZXNcIixcIiYjeDJBMDg7XCI6XCJcIixcIiYjeDJBMDc7XCI6XCJcIixcIiYjeDJBMDY7XCI6XCJcXFxcc3FjdXBcIixcIiYjeDJBMDU7XCI6XCJcXFxcc3FjYXBcIixcIiYjeDJBMDI7XCI6XCJcXFxcb3RpbWVzXCIsXCImI3gyQTAwO1wiOlwiXFxcXG9kb3RcIixcIiYjeDIyQzI7XCI6XCJcXFxcY2FwXCIsXCImI3gyMkMxO1wiOlwiXFxcXHZlZVwiLFwiJiN4MjJDMDtcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MkEwNDtcIjpcIlxcXFx1cGx1c1wiLFwiJiN4MkEwMztcIjpcIlxcXFxjdXBcIixcIiYjeDIyQzM7XCI6XCJcXFxcY3VwXCIsXCImI3gyQTFDO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaW50fVwiLFwiJiN4MkExQjtcIjpcIlxcXFxvdmVybGluZXtcXFxcaW50fVwiLFwiJiN4MkExQTtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTk7XCI6XCJcXFxcaW50XCIsXCImI3gyQTE4O1wiOlwiXFxcXGludFwiLFwiJiN4MkExNztcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTY7XCI6XCJcXFxcb2ludFwiLFwiJiN4MkExNTtcIjpcIlxcXFxvaW50XCIsXCImI3gyQTE0O1wiOlwiXFxcXGludFwiLFwiJiN4MkExMztcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTI7XCI6XCJcXFxcaW50XCIsXCImI3gyQTExO1wiOlwiXFxcXGludFwiLFwiJiN4MkExMDtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMEY7XCI6XCJcXFxcYmNhbmNlbHtcXFxcaW50fVwiLFwiJiN4MkEwRTtcIjpcIlwiLFwiJiN4MkEwRDtcIjpcIlxcXFxoY2FuY2Vse1xcXFxpbnR9XCIsXCImI3gyQTBDO1wiOlwiXFxcXGlpaWludFwiLFwiJiN4MjIzMztcIjpcIlxcXFxvaW50XCIsXCImI3gyMjMyO1wiOlwiXFxcXG9pbnRcIixcIiYjeDIyMzE7XCI6XCJcXFxcaW50XCIsXCImI3gyMjMwO1wiOlwiXFxcXG9paW50XCIsXCImI3gyMjJGO1wiOlwiXFxcXG9paW50XCIsXCImI3gyMjJFO1wiOlwiXFxcXG9pbnRcIixcIiYjeDIyMkI7XCI6XCJcXFxcaW50XCIsXCImI3gyQTAxO1wiOlwiXFxcXG9wbHVzXCIsXCImI3gyMjk4O1wiOlwiXFxcXG9zbGFzaFwiLFwiJiN4MjI5NjtcIjpcIlxcXFxvbWludXNcIixcIiYjeDIyOTU7XCI6XCJcXFxcb3BsdXNcIixcIiYjeDIyMkQ7XCI6XCJcXFxcaWlpbnRcIixcIiYjeDIyMkM7XCI6XCJcXFxcaWludFwiLFwiJiN4MkEwQjtcIjpcIlwiLFwiJiN4MkEwQTtcIjpcIlwiLFwiJiN4MjIxMTtcIjpcIlxcXFxzdW1cIixcIiYjeDIyOUY7XCI6XCJcXFxcYm94bWludXNcIixcIiYjeDIyOUU7XCI6XCJcXFxcYm94cGx1c1wiLFwiJiN4MjIxNDtcIjpcIlxcXFxkb3R7K31cIixcIiYjeDIyMTM7XCI6XCIrLVwiLFwiJiN4MjIxMjtcIjpcIi1cIixcIiYjeEIxO1wiOlwiXFxcXHBtXCIsXCItXCI6XCItXCIsXCIrXCI6XCIrXCIsXCImI3gyQjQ2O1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCImI3gyQjQ1O1wiOlwiXFxcXExsZWZ0YXJyb3dcIixcIiYjeDI5RjQ7XCI6XCI6XFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5RUY7XCI6XCJcIixcIiYjeDI5REY7XCI6XCJcXFxcYnVsbGV0LVxcXFxidWxsZXRcIixcIiYjeDI5OUY7XCI6XCJcXFxcYW5nbGVcIixcIiYjeDI5OUU7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4Mjk5RDtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCImI3gyOTlDO1wiOlwiXFxcXHBlcnBcIixcIiYjeDI5OUI7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4Mjk5QTtcIjpcIlwiLFwiJiN4Mjk5OTtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4Mjk3RjtcIjpcIlwiLFwiJiN4Mjk3RTtcIjpcIlwiLFwiJiN4Mjk3RDtcIjpcIlxcXFxwcmVjXCIsXCImI3gyOTdDO1wiOlwiXFxcXHN1Y2NcIixcIiYjeDI5N0I7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHJpZ2h0YXJyb3d9e1xcXFxzdXBzZXR9XCIsXCImI3gyOTdBO1wiOlwiXCIsXCImI3gyOTc5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vic2V0fVwiLFwiJiN4Mjk3ODtcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317Pn1cIixcIiYjeDI5Nzc7XCI6XCJcIixcIiYjeDI5NzY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGxlZnRhcnJvd317PH1cIixcIiYjeDI5NzU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHJpZ2h0YXJyb3d9XCIsXCImI3gyOTc0O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3MztcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcbGVmdGFycm93fVwiLFwiJiN4Mjk3MjtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3MTtcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3MDtcIjpcIlwiLFwiJiN4Mjk2RjtcIjpcIlwiLFwiJiN4Mjk2RTtcIjpcIlwiLFwiJiN4Mjk2RDtcIjpcIlxcXFxvdmVybGluZXtcXFxccmlnaHRoYXJwb29uZG93bn1cIixcIiYjeDI5NkM7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxyaWdodGhhcnBvb251cH1cIixcIiYjeDI5NkI7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxlZnRoYXJwb29uZG93bn1cIixcIiYjeDI5NkE7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsZWZ0aGFycG9vbnVwfVwiLFwiJiN4Mjk2OTtcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2ODtcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2NztcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2NjtcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4Mjk2NTtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDI5NjQ7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4Mjk2MztcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyOTYyO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4Mjk2MTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NjA7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1RjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTVFO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1RDtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NUM7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1QjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTVBO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1OTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NTg7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1NztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTU2O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1NTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5NTQ7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4Mjk1MztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTUyO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4Mjk1MTtcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk1MDtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0RjtcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk0RTtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0RDtcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk0QztcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwiJiN4Mjk0QjtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0QTtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0OTtcIjpcIlwiLFwiJiN4Mjk0ODtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4Mjk0NztcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiJiN4Mjk0NjtcIjpcIlwiLFwiJiN4Mjk0NTtcIjpcIlwiLFwiJiN4Mjk0NDtcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIiYjeDI5NDM7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCImI3gyOTQyO1wiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwiJiN4Mjk0MTtcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCImI3gyOTQwO1wiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwiJiN4MjkzRjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTNFO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkzRDtcIjpcIlwiLFwiJiN4MjkzQztcIjpcIlwiLFwiJiN4MjkzQjtcIjpcIlwiLFwiJiN4MjkzQTtcIjpcIlwiLFwiJiN4MjkzOTtcIjpcIlwiLFwiJiN4MjkzODtcIjpcIlwiLFwiJiN4MjkzNztcIjpcIlxcXFxSc2hcIixcIiYjeDI5MzY7XCI6XCJcXFxcTHNoXCIsXCImI3gyOTM1O1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjkzNDtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyOTMzO1wiOlwiXFxcXGxlYWRzdG9cIixcIiYjeDI5MzI7XCI6XCJcIixcIiYjeDI5MzE7XCI6XCJcIixcIiYjeDI5MzA7XCI6XCJcIixcIiYjeDI5MkY7XCI6XCJcIixcIiYjeDI5MkU7XCI6XCJcIixcIiYjeDI5MkQ7XCI6XCJcIixcIiYjeDI5MkM7XCI6XCJcXFxcdGltZXNcIixcIiYjeDI5MkI7XCI6XCJcXFxcdGltZXNcIixcIiYjeDI5MkE7XCI6XCJcIixcIiYjeDI5Mjk7XCI6XCJcIixcIiYjeDI5Mjg7XCI6XCJcIixcIiYjeDI5Mjc7XCI6XCJcIixcIiYjeDI5MjY7XCI6XCJcIixcIiYjeDI5MjU7XCI6XCJcIixcIiYjeDI5MjQ7XCI6XCJcIixcIiYjeDI5MjM7XCI6XCJcIixcIiYjeDI5MjI7XCI6XCJcIixcIiYjeDI5MjE7XCI6XCJcIixcIiYjeDI5MjA7XCI6XCJcXFxcbWFwc3RvXFxcXGNkb3RcIixcIiYjeDI5MUY7XCI6XCJcXFxcY2RvdFxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MUU7XCI6XCJcXFxccmlnaHRhcnJvd1xcXFxjZG90XCIsXCImI3gyOTFEO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkxQztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTFCO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkxQTtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE5O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkxODtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE3O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTY7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxNTtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE0O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTM7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTEyO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5MTE7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxMDtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTBGO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MEU7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyOTBEO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MEM7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyOTBCO1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjkwQTtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyOTA5O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5MDg7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTA3O1wiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIiYjeDI5MDY7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyOTA1O1wiOlwiXFxcXG1hcHN0b1wiLFwiJiN4MjkwNDtcIjpcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5MDM7XCI6XCJcXFxcblJpZ2h0YXJyb3dcIixcIiYjeDI5MDI7XCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwiJiN4MjkwMTtcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIiYjeDI5MDA7XCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCImI3gyN0ZGO1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjdGRTtcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyN0ZEO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjdGQztcIjpcIlxcXFxtYXBzdG9cIixcIiYjeDI3RkI7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyN0ZBO1wiOlwiXFxcXExvbmdsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjdGOTtcIjpcIlxcXFxMb25ncmlnaHRhcnJvd1wiLFwiJiN4MjdGODtcIjpcIlxcXFxMb25nbGVmdGFycm93XCIsXCImI3gyN0Y3O1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCImI3gyN0Y2O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI3RjU7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyN0YxO1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjdGMDtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMkI4O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRkY7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDIxRkU7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjFGRDtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDIxRkM7XCI6XCJcXFxcbmxlZnRyaWdodGFycm93XCIsXCImI3gyMUZCO1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCImI3gyMUZBO1wiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIiYjeDIxRjk7XCI6XCJcXFxcbmxlZnRyaWdodGFycm93XCIsXCImI3gyMUY4O1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCImI3gyMUY3O1wiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIiYjeDIxRjY7XCI6XCJcXFxcUnJpZ2h0YXJyb3dcIixcIiYjeDIxRjU7XCI6XCJcIixcIiYjeDIxRjQ7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjFGMztcIjpcIlxcXFxVcGRvd25hcnJvd1wiLFwiJiN4MjFGMjtcIjpcIlxcXFxzZWFycm93XCIsXCImI3gyMUYxO1wiOlwiXFxcXG53YXJyb3dcIixcIiYjeDIxRjA7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyMUVGO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUU7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFRDtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUVDO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUI7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFQTtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUU5O1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjFFODtcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyMUU3O1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRTY7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyMUU1O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRTQ7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMUUzO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFFMjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMUUxO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDIxRTA7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMURGO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFERTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMUREO1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjFEQztcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDIxREI7XCI6XCJcXFxcUnJpZ2h0YXJyb3dcIixcIiYjeDIxREE7XCI6XCJcXFxcTGxlZnRhcnJvd1wiLFwiJiN4MjFEOTtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMUQ4O1wiOlwiXFxcXHNlYXJyb3dcIixcIiYjeDIxRDc7XCI6XCJcXFxcbmVhcnJvd1wiLFwiJiN4MjFENjtcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMUQ1O1wiOlwiXFxcXFVwZG93bmFycm93XCIsXCImI3gyMUQ0O1wiOlwiXFxcXExlZnRyaWdodGFycm93XCIsXCImI3gyMUQzO1wiOlwiXFxcXERvd25hcnJvd1wiLFwiJiN4MjFEMjtcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyMUQxO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRDA7XCI6XCJcXFxcTGVmdGFycm93XCIsXCImI3gyMUNGO1wiOlwiXFxcXG5SaWdodGFycm93XCIsXCImI3gyMUNFO1wiOlwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFDRDtcIjpcIlxcXFxuTGVmdGFycm93XCIsXCImI3gyMUNDO1wiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCImI3gyMUNCO1wiOlwiXFxcXGxlZnRyaWdodGhhcnBvb25zXCIsXCImI3gyMUNBO1wiOlwiXFxcXGRvd25kb3duYXJyb3dzXCIsXCImI3gyMUM5O1wiOlwiXFxcXHJpZ2h0cmlnaHRhcnJvd3NcIixcIiYjeDIxQzg7XCI6XCJcXFxcdXB1cGFycm93c1wiLFwiJiN4MjFDNztcIjpcIlxcXFxsZWZ0bGVmdGFycm93c1wiLFwiJiN4MjFDNjtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIixcIiYjeDIxQzU7XCI6XCJcIixcIiYjeDIxQzQ7XCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCImI3gyMUMzO1wiOlwiXFxcXGRvd25oYXJwb29ubGVmdFwiLFwiJiN4MjFDMjtcIjpcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIsXCImI3gyMUMxO1wiOlwiXFxcXHJpZ2h0aGFycG9vbmRvd25cIixcIiYjeDIxQzA7XCI6XCJcXFxccmlnaHRoYXJwb29udXBcIixcIiYjeDIxQkY7XCI6XCJcXFxcdXBoYXJwb29ubGVmdFwiLFwiJiN4MjFCRTtcIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwiJiN4MjFCRDtcIjpcIlxcXFxsZWZ0aGFycG9vbmRvd25cIixcIiYjeDIxQkM7XCI6XCJcXFxcbGVmdGhhcnBvb251cFwiLFwiJiN4MjFCQjtcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCImI3gyMUJBO1wiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwiJiN4MjFCOTtcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIixcIiYjeDIxQjg7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG53YXJyb3d9XCIsXCImI3gyMUI3O1wiOlwiXFxcXGN1cnZlYXJyb3dyaWdodFwiLFwiJiN4MjFCNjtcIjpcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLFwiJiN4MjFCNTtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMUI0O1wiOlwiXFxcXHNlYXJyb3dcIixcIiYjeDIxQjM7XCI6XCJcXFxcUnNoXCIsXCImI3gyMUIyO1wiOlwiXFxcXExzaFwiLFwiJiN4MjFCMTtcIjpcIlxcXFxSc2hcIixcIiYjeDIxQjA7XCI6XCJcXFxcTHNoXCIsXCImI3gyMUFGO1wiOlwiXFxcXHN3YXJyb3dcIixcIiYjeDIxQUU7XCI6XCJcIixcIiYjeDIxQUQ7XCI6XCJcXFxcbGVmdHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjFBQztcIjpcIlxcXFxsb29wYXJyb3dyaWdodFwiLFwiJiN4MjFBQjtcIjpcIlxcXFxsb29wYXJyb3dsZWZ0XCIsXCImI3gyMUFBO1wiOlwiXFxcXGhvb2tyaWdodGFycm93XCIsXCImI3gyMUE5O1wiOlwiXFxcXGhvb2tsZWZ0YXJyb3dcIixcIiYjeDIxQTg7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx1cGRvd25hcnJvd31cIixcIiYjeDIxQTc7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyMUE2O1wiOlwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsXCImI3gyMUE1O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDIxQTQ7XCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwiJiN4MjFBMztcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwiJiN4MjFBMjtcIjpcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsXCImI3gyMUExO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFBMDtcIjpcIlxcXFx0d29oZWFkcmlnaHRhcnJvd1wiLFwiJiN4MjE5RjtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMTlFO1wiOlwiXFxcXHR3b2hlYWRsZWZ0YXJyb3dcIixcIiYjeDIxOUQ7XCI6XCJcXFxcbmVhcnJvd1wiLFwiJiN4MjE5QztcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMTlCO1wiOlwiXCIsXCImI3gyMTlBO1wiOlwiXCIsXCImI3gyMTk5O1wiOlwiXFxcXHN3YXJyb3dcIixcIiYjeDIxOTg7XCI6XCJcXFxcc2VhcnJvd1wiLFwiJiN4MjE5NztcIjpcIlxcXFxuZWFycm93XCIsXCImI3gyMTk2O1wiOlwiXFxcXG53YXJyb3dcIixcIiYjeDIxOTU7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDIxOTQ7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDIxOTM7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyMTkyO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxOTE7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjE5MDtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcInx8fFwiOlwiXFxcXGxlZnR8fHxcXFxccmlnaHQuXCIsXCJ8fFwiOlwiXFxcXGxlZnR8fFxcXFxyaWdodC5cIixcInxcIjpcIlxcXFxsZWZ0fFxcXFxyaWdodC5cIixcIiYjeDJBRkU7XCI6XCJcIixcIiYjeDJBRkQ7XCI6XCIvL1wiLFwiJiN4MkFGQjtcIjpcIi8vL1wiLFwiJiN4MkFGQTtcIjpcIlwiLFwiJiN4MkFGOTtcIjpcIlwiLFwiJiN4MkFGODtcIjpcIlwiLFwiJiN4MkFGNztcIjpcIlwiLFwiJiN4MkFGNjtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4MkFGNTtcIjpcIlwiLFwiJiN4MkFGNDtcIjpcIlwiLFwiJiN4MkFGMztcIjpcIlwiLFwiJiN4MkFGMjtcIjpcIlxcXFxucGFyYWxsZWxcIixcIiYjeDJBRjE7XCI6XCJcIixcIiYjeDJBRjA7XCI6XCJcIixcIiYjeDJBRUY7XCI6XCJcIixcIiYjeDJBRUU7XCI6XCJcXFxcYmNhbmNlbHtcXFxcbWlkfVwiLFwiJiN4MkFFRDtcIjpcIlwiLFwiJiN4MkFFQztcIjpcIlwiLFwiJiN4MkFFQjtcIjpcIlwiLFwiJiN4MkFFQTtcIjpcIlwiLFwiJiN4MkFFOTtcIjpcIlwiLFwiJiN4MkFFODtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHBlcnB9XCIsXCImI3gyQUU3O1wiOlwiXFxcXG92ZXJsaW5le1xcXFx0b3B9XCIsXCImI3gyQUU2O1wiOlwiXCIsXCImI3gyQUU1O1wiOlwiXCIsXCImI3gyQUU0O1wiOlwiXCIsXCImI3gyQUUzO1wiOlwiXCIsXCImI3gyQUUyO1wiOlwiXCIsXCImI3gyQUUxO1wiOlwiXCIsXCImI3gyQUUwO1wiOlwiXFxcXHBlcnBcIixcIiYjeDJBREY7XCI6XCJcXFxcdG9wXCIsXCImI3gyQURFO1wiOlwiXFxcXGRhc2h2XCIsXCImI3gyQUREOyYjeDMzODtcIjpcIlwiLFwiJiN4MkFERDtcIjpcIlwiLFwiJiN4MkFEQjtcIjpcIlxcXFxwaXRjaGZvcmtcIixcIiYjeDJBREE7XCI6XCJcIixcIiYjeDJBRDk7XCI6XCJcIixcIiYjeDJBRDg7XCI6XCJcIixcIiYjeDJBRDc7XCI6XCJcIixcIiYjeDJBRDY7XCI6XCJcIixcIiYjeDJBRDU7XCI6XCJcIixcIiYjeDJBRDQ7XCI6XCJcIixcIiYjeDJBRDM7XCI6XCJcIixcIiYjeDJBRDI7XCI6XCJcIixcIiYjeDJBRDE7XCI6XCJcIixcIiYjeDJBRDA7XCI6XCJcIixcIiYjeDJBQ0Y7XCI6XCJcIixcIiYjeDJBQ0U7XCI6XCJcIixcIiYjeDJBQ0Q7XCI6XCJcIixcIiYjeDJBQ0M7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5lcX17XFxcXHN1cHNldH1cIixcIiYjeDJBQ0I7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5lcX17XFxcXHN1YnNldH1cIixcIiYjeDJBQ0E7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1cHNldH1cIixcIiYjeDJBQzk7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1YnNldH1cIixcIiYjeDJBQzg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHN1cHNldH1cIixcIiYjeDJBQzc7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHN1YnNldH1cIixcIiYjeDJBQzY7XCI6XCJcXFxcc3Vwc2V0ZXFxXCIsXCImI3gyQUM1O1wiOlwiXFxcXHN1YnNldGVxcVwiLFwiJiN4MkFDNDtcIjpcIlxcXFxkb3R7XFxcXHN1cHNldGVxfVwiLFwiJiN4MkFDMztcIjpcIlxcXFxkb3R7XFxcXHN1YnNldGVxfVwiLFwiJiN4MkFDMjtcIjpcIlxcXFx1bmRlcnNldHtcXFxcdGltZXN9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUMxO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFx0aW1lc317XFxcXHN1YnNldH1cIixcIiYjeDJBQzA7XCI6XCJcXFxcdW5kZXJzZXR7K317XFxcXHN1cHNldH1cIixcIiYjeDJBQkY7XCI6XCJcXFxcdW5kZXJzZXR7K317XFxcXHN1YnNldH1cIixcIiYjeDJBQkU7XCI6XCJcIixcIiYjeDJBQkQ7XCI6XCJcIixcIiYjeDJBQkM7XCI6XCJcXFxcZ2cgXCIsXCImI3gyQUJCO1wiOlwiXFxcXGxsXCIsXCImI3gyQUJBO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19e1xcXFxzdWNjfVwiLFwiJiN4MkFCOTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXtcXFxccHJlY31cIixcIiYjeDJBQjg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1Y2N9XCIsXCImI3gyQUI3O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxwcmVjfVwiLFwiJiN4MkFCNjtcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vsez19fXtcXFxcc3VjY31cIixcIiYjeDJBQjU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHByZWN9XCIsXCImI3gyQUI0O1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxzdWNjfVwiLFwiJiN4MkFCMztcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxccHJlY31cIixcIiYjeDJBQjI7XCI6XCJcIixcIiYjeDJBQjE7XCI6XCJcIixcIiYjeDJBQUU7XCI6XCJcIixcIiYjeDJBQUQ7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwiJiN4MkFBQztcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGhjYW5jZWx7Pn19XCIsXCImI3gyQUFCO1wiOlwiXFxcXGhjYW5jZWx7Pn1cIixcIiYjeDJBQUE7XCI6XCJcXFxcaGNhbmNlbHs8fVwiLFwiJiN4MkFBOTtcIjpcIlwiLFwiJiN4MkFBODtcIjpcIlwiLFwiJiN4MkFBNztcIjpcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIsXCImI3gyQUE2O1wiOlwiXFxcXHZhcnRyaWFuZ2xlbGVmdFwiLFwiJiN4MkFBNTtcIjpcIj48XCIsXCImI3gyQUE0O1wiOlwiPjxcIixcIiYjeDJBQTM7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsbH1cIixcIiYjeDJBQTI7JiN4MzM4O1wiOlwiXFxcXGNhbmNlbHtcXFxcZ2d9XCIsXCImI3gyQUEyO1wiOlwiXFxcXGdnXCIsXCImI3gyQUExOyYjeDMzODtcIjpcIlxcXFxjYW5jZWx7XFxcXGxsfVwiLFwiJiN4MkFBMTtcIjpcIlxcXFxsbFwiLFwiJiN4MkFBMDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxnZXFxfVwiLFwiJiN4MkE5RjtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxsZXFxfVwiLFwiJiN4MkE5RTtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ez59XCIsXCImI3gyQTlEO1wiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17PH1cIixcIiYjeDJBOUM7XCI6XCJcIixcIiYjeDJBOUI7XCI6XCJcIixcIiYjeDJBOUE7XCI6XCJcXFxcb3ZlcnNldHs9fXs+fVwiLFwiJiN4MkE5OTtcIjpcIlxcXFxvdmVyc2V0ez19ezx9XCIsXCImI3gyQTk4O1wiOlwiXCIsXCImI3gyQTk3O1wiOlwiXCIsXCImI3gyQTk2O1wiOlwiXCIsXCImI3gyQTk1O1wiOlwiXCIsXCImI3gyQTk0O1wiOlwiXCIsXCImI3gyQTkzO1wiOlwiXCIsXCImI3gyQTkyO1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxndHJsZXNzfVwiLFwiJiN4MkE5MTtcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcbGVzc2d0cn1cIixcIiYjeDJBOTA7XCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGd0cnNpbX1cIixcIiYjeDJBOEY7XCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlc3NzaW19XCIsXCImI3gyQThFO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW1lcX17Pn1cIixcIiYjeDJBOEQ7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbWVxfXs8fVwiLFwiJiN4MkE4QztcIjpcIlxcXFxndHJlcXFsZXNzXCIsXCImI3gyQThCO1wiOlwiXFxcXGxlc3NlcXFndHJcIixcIiYjeDJBOEE7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17Pn1cIixcIiYjeDJBODk7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIiYjeDJBODY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17Pn1cIixcIiYjeDJBODU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIiYjeDJBODQ7XCI6XCJcIixcIiYjeDJBODM7XCI6XCJcIixcIiYjeDJBODI7XCI6XCJcIixcIiYjeDJBODE7XCI6XCJcIixcIiYjeDJBODA7XCI6XCJcIixcIiYjeDJBN0Y7XCI6XCJcIixcIiYjeDJBN0U7JiN4MzM4O1wiOlwiXFxcXGJjYW5jZWx7XFxcXGdlcX1cIixcIiYjeDJBN0U7XCI6XCJcXFxcZ2VxXCIsXCImI3gyQTdEOyYjeDMzODtcIjpcIlxcXFxiY2FuY2Vse1xcXFxsZXF9XCIsXCImI3gyQTdEO1wiOlwiXFxcXGxlcVwiLFwiJiN4MkE3QztcIjpcIlwiLFwiJiN4MkE3QjtcIjpcIlwiLFwiJiN4MkE3QTtcIjpcIlwiLFwiJiN4MkE3OTtcIjpcIlwiLFwiJiN4MkE3ODtcIjpcIlxcXFxvdmVyc2V0e1xcXFxkb3RzfXtcXFxcZXF1aXZ9XCIsXCImI3gyQTc3O1wiOlwiXCIsXCImI3gyQTc2O1wiOlwiPT09XCIsXCImI3gyQTc1O1wiOlwiPT1cIixcIiYjeDJBNzQ7XCI6XCI6Oj1cIixcIiYjeDJBNzM7XCI6XCJcIixcIiYjeDJBNzI7XCI6XCJcXFxcdW5kZXJzZXR7PX17K31cIixcIiYjeDJBNzE7XCI6XCJcXFxcb3ZlcnNldHs9fXsrfVwiLFwiJiN4MkE3MDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxhcHByb3h9ez19XCIsXCImI3gyQTZGO1wiOlwiXFxcXG92ZXJzZXR7XFxcXHdlZGdlfXs9fVwiLFwiJiN4MkE2RTtcIjpcIlxcXFxvdmVyc2V0eyp9ez19XCIsXCImI3gyQTZEO1wiOlwiXFxcXGRvdHtcXFxcYXBwcm94fVwiLFwiJiN4MkE2QztcIjpcIlwiLFwiJiN4MkE2QjtcIjpcIlwiLFwiJiN4MkE2QTtcIjpcIlxcXFxkb3R7XFxcXHNpbX1cIixcIiYjeDJBNjk7XCI6XCJcIixcIiYjeDJBNjg7XCI6XCJcIixcIiYjeDJBNjc7XCI6XCJcXFxcZG90e1xcXFxlcXVpdn1cIixcIiYjeDJBNjY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNkb3R9ez19XCIsXCImI3gyQTY1O1wiOlwiXCIsXCImI3gyQTY0O1wiOlwiXCIsXCImI3gyQTYzO1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFx2ZWV9XCIsXCImI3gyQTYyO1wiOlwiXFxcXG92ZXJzZXR7PX17XFxcXHZlZX1cIixcIiYjeDJBNjE7XCI6XCJ1bCh2dilcIixcIiYjeDJBNjA7XCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHdlZGdlfVwiLFwiJiN4MkE1RjtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHdlZGdlfVwiLFwiJiN4MkE1RTtcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIiYjeDJBNUQ7XCI6XCJcXFxcaGNhbmNlbHtcXFxcdmVlfVwiLFwiJiN4MkE1QztcIjpcIlxcXFxoY2FuY2Vse1xcXFx3ZWRnZX1cIixcIiYjeDJBNUI7XCI6XCJcIixcIiYjeDJBNUE7XCI6XCJcIixcIiYjeDJBNTk7XCI6XCJcIixcIiYjeDJBNTg7XCI6XCJcXFxcdmVlXCIsXCImI3gyQTU3O1wiOlwiXFxcXHdlZGdlXCIsXCImI3gyQTU2O1wiOlwiXCIsXCImI3gyQTU1O1wiOlwiXCIsXCImI3gyQTU0O1wiOlwiXCIsXCImI3gyQTUzO1wiOlwiXCIsXCImI3gyQTUyO1wiOlwiXFxcXGRvdHtcXFxcdmVlfVwiLFwiJiN4MkE1MTtcIjpcIlxcXFxkb3R7XFxcXHdlZGdlfVwiLFwiJiN4MkE1MDtcIjpcIlwiLFwiJiN4MkE0RjtcIjpcIlwiLFwiJiN4MkE0RTtcIjpcIlwiLFwiJiN4MkE0RDtcIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwiJiN4MkE0QztcIjpcIlxcXFxvdmVybGluZXtcXFxcY3VwfVwiLFwiJiN4MkE0QjtcIjpcIlwiLFwiJiN4MkE0QTtcIjpcIlwiLFwiJiN4MkE0OTtcIjpcIlwiLFwiJiN4MkE0ODtcIjpcIlwiLFwiJiN4MkE0NztcIjpcIlwiLFwiJiN4MkE0NjtcIjpcIlwiLFwiJiN4MkE0NTtcIjpcIlwiLFwiJiN4MkE0NDtcIjpcIlwiLFwiJiN4MkE0MztcIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwiJiN4MkE0MjtcIjpcIlxcXFxvdmVybGluZXtcXFxcY3VwfVwiLFwiJiN4MkE0MTtcIjpcIlwiLFwiJiN4MkE0MDtcIjpcIlwiLFwiJiN4MkEzRTtcIjpcIlwiLFwiJiN4MkEzRDtcIjpcIlxcXFxsbGNvcm5lclwiLFwiJiN4MkEzQztcIjpcIlxcXFxscmNvcm5lclwiLFwiJiN4MkEzQjtcIjpcIlwiLFwiJiN4MkEzQTtcIjpcIlwiLFwiJiN4MkEzOTtcIjpcIlwiLFwiJiN4MkEzODtcIjpcIlwiLFwiJiN4MkEzNztcIjpcIlwiLFwiJiN4MkEzNjtcIjpcIlxcXFxoYXR7XFxcXG90aW1lc31cIixcIiYjeDJBMzU7XCI6XCJcIixcIiYjeDJBMzQ7XCI6XCJcIixcIiYjeDJBMzM7XCI6XCJcIixcIiYjeDJBMzI7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0aW1lc31cIixcIiYjeDJBMzE7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0aW1lc31cIixcIiYjeDJBMzA7XCI6XCJcXFxcZG90e1xcXFx0aW1lc31cIixcIiYjeDJBMkU7XCI6XCJcIixcIiYjeDJBMkQ7XCI6XCJcIixcIiYjeDJBMkM7XCI6XCJcIixcIiYjeDJBMkI7XCI6XCJcIixcIiYjeDJBMkE7XCI6XCJcIixcIiYjeDJBMjk7XCI6XCJcIixcIiYjeDJBMjg7XCI6XCJcIixcIiYjeDJBMjc7XCI6XCJcIixcIiYjeDJBMjY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17K31cIixcIiYjeDJBMjU7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNpcmN9eyt9XCIsXCImI3gyQTI0O1wiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17K31cIixcIiYjeDJBMjM7XCI6XCJcXFxcaGF0eyt9XCIsXCImI3gyQTIyO1wiOlwiXFxcXGRvdHsrfVwiLFwiJiN4MkEyMTtcIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwiJiN4MkEyMDtcIjpcIj4+XCIsXCImI3gyQTFGO1wiOlwiXCIsXCImI3gyQTFFO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MkExRDtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RkY7XCI6XCJcIixcIiYjeDI5RkU7XCI6XCIrXCIsXCImI3gyOUZCO1wiOlwiXFxcXGhjYW5jZWx7fHx8fVwiLFwiJiN4MjlGQTtcIjpcIlxcXFxoY2FuY2Vse3x8fVwiLFwiJiN4MjlGOTtcIjpcIlxcXFxiYWNrc2xhc2hcIixcIiYjeDI5Rjg7XCI6XCIvXCIsXCImI3gyOUY3O1wiOlwiaGNhbmNlbHtcXGJhY2tzbGFzaH1cIixcIiYjeDI5RjY7XCI6XCJcIixcIiYjeDI5RjU7XCI6XCJcXFxcYmFja3NsYXNoXCIsXCImI3gyOUYyO1wiOlwiXFxcXFBoaVwiLFwiJiN4MjlGMTtcIjpcIlwiLFwiJiN4MjlGMDtcIjpcIlwiLFwiJiN4MjlFRTtcIjpcIlwiLFwiJiN4MjlFRDtcIjpcIlwiLFwiJiN4MjlFQztcIjpcIlwiLFwiJiN4MjlFQjtcIjpcIlxcXFxsb3plbmdlXCIsXCImI3gyOUVBO1wiOlwiXCIsXCImI3gyOUU5O1wiOlwiXCIsXCImI3gyOUU4O1wiOlwiXCIsXCImI3gyOUU3O1wiOlwiXFxcXGRkYWdnZXJcIixcIiYjeDI5RTI7XCI6XCJcXFxcc3FjdXBcXFxcc3FjdXBcIixcIiYjeDI5RTE7XCI6XCJcIixcIiYjeDI5RTA7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyOURFO1wiOlwiXCIsXCImI3gyOUREO1wiOlwiXCIsXCImI3gyOURDO1wiOlwiXCIsXCImI3gyOURCO1wiOlwiXFxcXHtcXFxce1wiLFwiJiN4MjlEOTtcIjpcIlxcXFx7XCIsXCImI3gyOUQ4O1wiOlwiXFxcXH1cIixcIiYjeDI5RDc7XCI6XCJcIixcIiYjeDI5RDY7XCI6XCJcIixcIiYjeDI5RDU7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUQ0O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlEMztcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RDI7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUQxO1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlEMDsmI3gzMzg7XCI6XCJ8IFxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjlEMDtcIjpcInwgXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI5Q0Y7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnQgfFwiLFwiJiN4MjlDRjtcIjpcIlxcXFx0cmlhbmdsZWxlZnQgfFwiLFwiJiN4MjlDRTtcIjpcIlwiLFwiJiN4MjlDRDtcIjpcIlxcXFx0cmlhbmdsZVwiLFwiJiN4MjlDQztcIjpcIlwiLFwiJiN4MjlDQjtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHRyaWFuZ2xlfVwiLFwiJiN4MjlDQTtcIjpcIlxcXFxkb3R7XFxcXHRyaWFuZ2xlfVwiLFwiJiN4MjlDOTtcIjpcIlwiLFwiJiN4MjlDODtcIjpcIlxcXFxib3hlZHtcXFxcY2lyY31cIixcIiYjeDI5Qzc7XCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCImI3gyOUM2O1wiOlwiXFxcXGJveGVke1xcXFxyaWdodGFycm93fVwiLFwiJiN4MjlDNTtcIjpcIlxcXFxiY2FuY2Vse1xcXFxzcXVhcmV9XCIsXCImI3gyOUM0O1wiOlwiXFxcXGNhbmNlbHtcXFxcc3F1YXJlfVwiLFwiJiN4MjlDMztcIjpcIlxcXFxvZG90XCIsXCImI3gyOUMyO1wiOlwiXFxcXG9kb3RcIixcIiYjeDI5QkY7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjlCRTtcIjpcIlxcXFxvZG90XCIsXCImI3gyOUJEO1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5QkM7XCI6XCJcXFxcb3BsdXNcIixcIiYjeDI5QkI7XCI6XCJcXFxcb3RpbWVzXCIsXCImI3gyOUJBO1wiOlwiXCIsXCImI3gyOUI5O1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5Qjg7XCI6XCJcXFxcdmFybm90aGluZ1wiLFwiJiN4MjlCNztcIjpcIlxcXFxvbWludXNcIixcIiYjeDI5QjY7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyOUI1O1wiOlwiXFxcXG9taW51c1wiLFwiJiN4MjlCNDtcIjpcIlxcXFx2ZWN7XFxcXHZhcm5vdGhpbmd9XCIsXCImI3gyOUIzO1wiOlwiXFxcXHZlY3tcXFxcdmFybm90aGluZ31cIixcIiYjeDI5QjI7XCI6XCJcXFxcZG90e1xcXFx2YXJub3RoaW5nfVwiLFwiJiN4MjlCMTtcIjpcIlxcXFxvdmVybGluZXtcXFxcdmFybm90aGluZ31cIixcIiYjeDI5QjA7XCI6XCJcXFxcdmFybm90aGluZ1wiLFwiJiN4MjlBRjtcIjpcIlwiLFwiJiN4MjlBRTtcIjpcIlwiLFwiJiN4MjlBRDtcIjpcIlwiLFwiJiN4MjlBQztcIjpcIlwiLFwiJiN4MjlBQjtcIjpcIlwiLFwiJiN4MjlBQTtcIjpcIlwiLFwiJiN4MjlBOTtcIjpcIlwiLFwiJiN4MjlBODtcIjpcIlwiLFwiJiN4MjlBNztcIjpcIlwiLFwiJiN4MjlBNjtcIjpcIlwiLFwiJiN4MjlBNTtcIjpcIlwiLFwiJiN4MjlBNDtcIjpcIlwiLFwiJiN4MjlBMztcIjpcIlwiLFwiJiN4MjlBMjtcIjpcIlwiLFwiJiN4MjlBMTtcIjpcIlxcXFxub3RcXFxcbG9yXCIsXCImI3gyOUEwO1wiOlwiXFxcXGJjYW5jZWx7Pn1cIixcIiYjeDI5ODI7XCI6XCI6XCIsXCImI3gyOTgxO1wiOlwiXFxcXGNpcmNcIixcIiYjeDI3NTg7XCI6XCJ8XCIsXCImI3gyNUIyO1wiOlwiXFxcXGJpZ3RyaWFuZ2xldXBcIixcIiYjeDIyRkY7XCI6XCJcXFxcRXBzaWxvblwiLFwiJiN4MjJGRTtcIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCImI3gyMkZEO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxuaX1cIixcIiYjeDIyRkM7XCI6XCJcXFxcaW5cIixcIiYjeDIyRkI7XCI6XCJcXFxcaW5cIixcIiYjeDIyRkE7XCI6XCJcXFxcaW5cIixcIiYjeDIyRjk7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIiYjeDIyRjg7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIiYjeDIyRjc7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGlufVwiLFwiJiN4MjJGNjtcIjpcIlxcXFxvdmVybGluZXtcXFxcaW59XCIsXCImI3gyMkY1O1wiOlwiXFxcXGRvdHtcXFxcaW59XCIsXCImI3gyMkY0O1wiOlwiXFxcXGluXCIsXCImI3gyMkYzO1wiOlwiXFxcXGluXCIsXCImI3gyMkYyO1wiOlwiXFxcXGluXCIsXCImI3gyMkYwO1wiOlwiXFxcXGRkb3RzXCIsXCImI3gyMkU5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdWNjfVwiLFwiJiN4MjJFODtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxccHJlY31cIixcIiYjeDIyRTc7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5vdFxcXFxzaW19ez59XCIsXCImI3gyMkU2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxub3RcXFxcc2ltfXs8fVwiLFwiJiN4MjJFNTtcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRlcVwiLFwiJiN4MjJFNDtcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRlcVwiLFwiJiN4MjJFMztcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRlcVwiLFwiJiN4MjJFMjtcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRlcVwiLFwiJiN4MjJFMTtcIjpcIlxcXFxuc3VjY1wiLFwiJiN4MjJFMDtcIjpcIlxcXFxucHJlY1wiLFwiJiN4MjJERjtcIjpcIlxcXFxzdWNjXCIsXCImI3gyMkRFO1wiOlwiXFxcXHByZWNcIixcIiYjeDIyREQ7XCI6XCJcXFxcb3ZlcmxpbmV7Pn1cIixcIiYjeDIyREM7XCI6XCJcXFxcb3ZlcmxpbmV7PH1cIixcIiYjeDIyREI7XCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlcX1cIixcIiYjeDIyREE7XCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGdlcX1cIixcIiYjeDIyRDU7XCI6XCJcXFxcI1wiLFwiJiN4MjJEMztcIjpcIlxcXFxjdXBcIixcIiYjeDIyRDI7XCI6XCJcXFxcY2FwXCIsXCImI3gyMkQxO1wiOlwiXFxcXHN1cHNldFwiLFwiJiN4MjJEMDtcIjpcIlxcXFxzdWJzZXRcIixcIiYjeDIyQ0Y7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDIyQ0U7XCI6XCJcXFxcdmVlXCIsXCImI3gyMkNEO1wiOlwiXFxcXHNpbWVxXCIsXCImI3gyMkM4O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjJDNztcIjpcIlxcXFxhc3RcIixcIiYjeDIyQzY7XCI6XCJcXFxcc3RhclwiLFwiJiN4MjJDNDtcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyMkJGO1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyMkJFO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDIyQkQ7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxvcn1cIixcIiYjeDIyQkM7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxhbmR9XCIsXCImI3gyMkJCO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbG9yfVwiLFwiJiN4MjJCQTtcIjpcIlxcXFx0b3BcIixcIiYjeDIyQjk7XCI6XCJcIixcIiYjeDIyQjc7XCI6XCJcXFxcY2lyY1xcXFxtdWx0aW1hcFwiLFwiJiN4MjJCNjtcIjpcIlxcXFxjaXJjXFxcXG11bHRpbWFwXCIsXCImI3gyMkIzO1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyQjI7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyMkIxO1wiOlwiXFxcXHN1Y2NcIixcIiYjeDIyQjA7XCI6XCJcXFxccHJlY1wiLFwiJiN4MjJBQjtcIjpcInxcXFxcbW9kZWxzXCIsXCImI3gyMkFBO1wiOlwifFxcXFxtb2RlbHNcIixcIiYjeDIyQTc7XCI6XCJcXFxcbW9kZWxzXCIsXCImI3gyMkE2O1wiOlwiXFxcXHZkYXNoXCIsXCImI3gyMjlEO1wiOlwiXFxcXG9taW51c1wiLFwiJiN4MjI5QztcIjpcIlxcXFxvbWludXNcIixcIiYjeDIyOUI7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjI5QTtcIjpcIlxcXFxvZG90XCIsXCImI3gyMjk0O1wiOlwiXFxcXHNxY3VwXCIsXCImI3gyMjkzO1wiOlwiXFxcXHNxY2FwXCIsXCImI3gyMjkyO1wiOlwiXFxcXHNxc3Vwc2V0ZXFcIixcIiYjeDIyOTE7XCI6XCJcXFxcc3FzdWJzZXRlcVwiLFwiJiN4MjI5MDsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0XCIsXCImI3gyMjkwO1wiOlwiXFxcXHNxc3Vwc2V0XCIsXCImI3gyMjhGOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRcIixcIiYjeDIyOEY7XCI6XCJcXFxcc3FzdWJzZXRcIixcIiYjeDIyOEU7XCI6XCJcXFxcY3VwXCIsXCImI3gyMjhEO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjI4QztcIjpcIlxcXFxjdXBcIixcIiYjeDIyN0Y7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFxzdWNjc2ltXCIsXCImI3gyMjdGO1wiOlwiXFxcXHN1Y2NzaW1cIixcIiYjeDIyN0U7XCI6XCJcXFxccHJlY3NpbVwiLFwiJiN4MjI3OTtcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwiJiN4MjI3ODtcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwiJiN4MjI3NztcIjpcIlxcXFxvdmVyc2V0ez59ezx9XCIsXCImI3gyMjc2O1wiOlwiXFxcXG92ZXJzZXR7PH17Pn1cIixcIiYjeDIyNzU7XCI6XCJcXFxcbm90XFxcXGdlZ1wiLFwiJiN4MjI3NDtcIjpcIlxcXFxub3RcXFxcbGVxXCIsXCImI3gyMjczO1wiOlwiXFxcXGdlZ1wiLFwiJiN4MjI3MjtcIjpcIlxcXFxsZXFcIixcIiYjeDIyNkM7XCI6XCJcIixcIiYjeDIyNjc7XCI6XCJcXFxcZ2VnXCIsXCImI3gyMjY2OyYjeDMzODtcIjpcIlxcXFxub3RcXFxcbGVxXCIsXCImI3gyMjY2O1wiOlwiXFxcXGxlcVwiLFwiJiN4MjI2MztcIjpcIlxcXFxvdmVyc2V0ez19ez19IFwiLFwiJiN4MjI1RTtcIjpcIlxcXFxvdmVyc2V0e219ez19IFwiLFwiJiN4MjI1RDtcIjpcIlxcXFxvdmVyc2V0e2RlZn17PX1cIixcIiYjeDIyNTg7XCI6XCI9XCIsXCImI3gyMjU2O1wiOlwiPVwiLFwiJiN4MjI1NTtcIjpcIj06XCIsXCImI3gyMjUzO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjUyO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjUxO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjUwO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjRGOyYjeDMzODtcIjpcIlwiLFwiJiN4MjI0RjtcIjpcIlwiLFwiJiN4MjI0RTsmI3gzMzg7XCI6XCJcIixcIiYjeDIyNEU7XCI6XCJcIixcIiYjeDIyNEM7XCI6XCJcXFxcYXBwcm94XCIsXCImI3gyMjRCO1wiOlwiXFxcXGFwcHJveFwiLFwiJiN4MjI0QTtcIjpcIlxcXFxhcHByb3hcIixcIiYjeDIyNDI7JiN4MzM4O1wiOlwiXFxcXG5lcVwiLFwiJiN4MjI0MjtcIjpcIj1cIixcIiYjeDIyM0Y7XCI6XCJcXFxcc2ltXCIsXCImI3gyMjNFO1wiOlwiXFxcXGluZnR5XCIsXCImI3gyMjNEOyYjeDMzMTtcIjpcIlxcXFxzaW1cIixcIiYjeDIyM0Q7XCI6XCJcXFxcc2ltXCIsXCImI3gyMjNCO1wiOlwiXFxcXHNpbVwiLFwiJiN4MjIzQTtcIjpcIjotOlwiLFwiJiN4MjIzOTtcIjpcIi06XCIsXCImI3gyMjM4O1wiOlwiXFxcXGJvdFwiLFwiJiN4MjIzNztcIjpcIjo6XCIsXCImI3gyMjM2O1wiOlwiOlwiLFwiJiN4MjIyMztcIjpcInxcIixcIiYjeDIyMUY7XCI6XCJcXFxcbGxjb3JuZXJcIixcIiYjeDIyMTk7XCI6XCJcXFxcY2RvdFwiLFwiJiN4MjIxODtcIjpcIlxcXFxjaXJjXCIsXCImI3gyMjE3O1wiOlwiKlwiLFwiJiN4MjIxNTtcIjpcIi9cIixcIiYjeDIyMEU7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyMjBEO1wiOlwiXFxcXG5pXCIsXCImI3gyMjBBO1wiOlwiXFxcXGluXCIsXCImI3gyMjA2O1wiOlwiXFxcXERlbHRhXCIsXCImI3gyMDQ0O1wiOlwiL1wiLFwiJiN4MkFCMDsmI3gzMzg7XCI6XCJcXFxcbnN1Y2NlcVwiLFwiJiN4MkFCMDtcIjpcIlxcXFxzdWNjZXFcIixcIiYjeDJBQUY7JiN4MzM4O1wiOlwiXFxcXG5wcmVjZXFcIixcIiYjeDJBQUY7XCI6XCJcXFxccHJlY2VxXCIsXCImI3gyQTg4O1wiOlwiXFxcXG5nZXFzbGFudFwiLFwiJiN4MkE4NztcIjpcIlxcXFxubGVxc2xhbnRcIixcIiYjeDI5RjM7XCI6XCJcXFxcUGhpXCIsXCImI3gyOUU2O1wiOlwiXFxcXG1vZGVsc1wiLFwiJiN4MjlFNTtcIjpcIlxcXFxub3RcXFxcZXF1aXZcIixcIiYjeDI5RTQ7XCI6XCJcXFxcYXBwcm94XFxcXG5lcVwiLFwiJiN4MjlFMztcIjpcIlxcXFxuZXFcIixcIiYjeDI5QzE7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyOUMwO1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjVFNjtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1RDc7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyNUQ2O1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjVDRjtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1Q0U7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Q0Q7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Q0M7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Qzk7XCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIiYjeDI1Qzg7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjVDNztcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyNUM2O1wiOlwiXFxcXGRpYW1vbmRcIixcIiYjeDI1QzU7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUM0O1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDMztcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QzI7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUMxO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDMDtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QkY7XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCImI3gyNUJFO1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwiJiN4MjVCRDtcIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIiYjeDI1QkM7XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCImI3gyNUI5O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI1Qjg7XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjVCNztcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyNUI2O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI1QjU7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI1QjQ7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI1QjM7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI1QjE7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUIwO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBRjtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUU7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUFEO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBQjtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUE7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUExO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBMDtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIyRUQ7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyRUM7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjJFQjtcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjJFQTtcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyMkQ5O1wiOlwiXFxcXGdnZ1wiLFwiJiN4MjJEODtcIjpcIlxcXFxsbGxcIixcIiYjeDIyRDc7XCI6XCIqPlwiLFwiJiN4MjJENjtcIjpcIjwqXCIsXCImI3gyMkQ0O1wiOlwiXFxcXHBpdGNoZm9ya1wiLFwiJiN4MjJDQztcIjpcIlwiLFwiJiN4MjJDQjtcIjpcIlwiLFwiJiN4MjJDQTtcIjpcIlxcXFxydGltZXNcIixcIiYjeDIyQzk7XCI6XCJcXFxcbHRpbWVzXCIsXCImI3gyMkI1O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyQjQ7XCI6XCJcIixcIiYjeDIyQTU7XCI6XCJcXFxcYm90XCIsXCImI3gyMjgxO1wiOlwiXFxcXG5zdWNjXCIsXCImI3gyMjgwO1wiOlwiXFxcXHByZWNlcVwiLFwiJiN4MjI3RDtcIjpcIlxcXFxzdWNjZXFcIixcIiYjeDIyN0M7XCI6XCJcXFxccHJlY2VxXCIsXCImI3gyMjdCO1wiOlwiXFxcXHN1Y2NcIixcIiYjeDIyN0E7XCI6XCJcXFxccHJlY1wiLFwiJiN4MjI3MTtcIjpcIlxcXFxnZXEvXCIsXCImI3gyMjcwO1wiOlwiXFxcXGxlcS9cIixcIiYjeDIyNkQ7XCI6XCJcXFxcbmVxXCIsXCImI3gyMjZCOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcZ2dcIixcIiYjeDIyNkI7XCI6XCJcXFxcZ2dcIixcIiYjeDIyNkE7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFxsbFwiLFwiJiN4MjI2QTtcIjpcIlxcXFxsbFwiLFwiJiN4MjI2OTtcIjpcIlxcXFxuZ2Vxc2xhbnRcIixcIiYjeDIyNjg7XCI6XCJcXFxcbmxlcXNsYW50XCIsXCImI3gyMjYxO1wiOlwiXFxcXGVxdWl2XCIsXCImI3gyMjVGO1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjVDO1wiOlwiXFxcXHRyaWFuZ2xlcVwiLFwiJiN4MjI1QjtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1QTtcIjpcIlxcXFx0cmlhbmdsZXFcIixcIiYjeDIyNTk7XCI6XCJcXFxcdHJpYW5nbGVxXCIsXCImI3gyMjU3O1wiOlwiXFxcXGRvdGVxXCIsXCImI3gyMjU0O1wiOlwiOj1cIixcIiYjeDIyNEQ7XCI6XCJcXFxcYXN5bXBcIixcIiYjeDIyNDc7XCI6XCJcXFxcbmNvbmdcIixcIiYjeDIyNDY7XCI6XCJcXFxcbmNvbmdcIixcIiYjeDIyNDU7XCI6XCJcXFxcY29uZ1wiLFwiJiN4MjI0NDtcIjpcIlxcXFxub3RcXFxcc2ltZXFcIixcIiYjeDIyNDM7XCI6XCJcXFxcc2ltZXFcIixcIiYjeDIyNDE7XCI6XCJcXFxcbm90XFxcXHNpbVwiLFwiJiN4MjIyNjtcIjpcIlxcXFxub3RcXFxccGFyYWxsZWxcIixcIiYjeDIyMjU7XCI6XCJcXFxccGFyYWxsZWxcIixcIiYjeDIyMjQ7XCI6XCJcXFxcbm90fFwiLFwiJiN4MjIxRDtcIjpcIlxcXFxwcm9wdG9cIixcIj09XCI6XCI9PVwiLFwiPVwiOlwiPVwiLFwiOj1cIjpcIjo9XCIsXCIvPVwiOlwiPVwiLFwiLT1cIjpcIi09XCIsXCIrPVwiOlwiKz1cIixcIio9XCI6XCIqPVwiLFwiIT1cIjpcIiE9XCIsXCImI3gyMjYwO1wiOlwiXFxcXG5lcVwiLFwiJiN4MjI2MjtcIjpcIlxcXFxlcXVpdiAvXCIsXCImI3gyMjQ5O1wiOlwiXFxcXGFwcHJveCAvXCIsXCImI3gyMjNDO1wiOlwic2ltXCIsXCImI3gyMjQ4O1wiOlwiXFxcXGFwcHJveFwiLFwiJiN4MjI2RTtcIjpcIjwvXCIsXCImbHQ7XCI6XCI8XCIsXCImI3gyMjZGO1wiOlwiPi9cIixcIj49XCI6XCI+PVwiLFwiPlwiOlwiPlwiLFwiJiN4MjI2NTtcIjpcIlxcXFxnZXFcIixcIiYjeDIyNjQ7XCI6XCJcXFxcbGVxXCIsXCImbHQ7PVwiOlwiPD1cIixcIiYjeDIyOEI7XCI6XCJcXFxcc3Vwc2V0bmVxXCIsXCImI3gyMjhBO1wiOlwiXFxcXHN1YnNldG5lcVwiLFwiJiN4MjI4OTtcIjpcIlxcXFxuc3Vwc2V0ZXFcIixcIiYjeDIyODg7XCI6XCJcXFxcbnN1YnNldGVxXCIsXCImI3gyMjg3O1wiOlwiXFxcXHN1cHNldGVxXCIsXCImI3gyMjg2O1wiOlwiXFxcXHN1YnNldGVxXCIsXCImI3gyMjg1O1wiOlwiXFxcXG5vdFxcXFxzdXBzZXRcIixcIiYjeDIyODQ7XCI6XCJcXFxcbm90XFxcXHN1YnNldFwiLFwiJiN4MjI4MzsmI3gyMEQyO1wiOlwiXFxcXHN1cHNldCB8XCIsXCImI3gyMjgzO1wiOlwiXFxcXHN1cHNldFwiLFwiJiN4MjI4MjsmI3gyMEQyO1wiOlwiXFxcXHN1YnNldCB8XCIsXCImI3gyMjgyO1wiOlwiXFxcXHN1YnNldFwiLFwiJiN4MjIwQztcIjpcIlxcXFxub3RcXFxcaW5cIixcIiYjeDIyMDk7XCI6XCJcXFxcbm90aW5cIixcIiYjeDIyMDg7XCI6XCJcXFxcaW5cIixcIiYjeDIyMDE7XCI6XCJDXCIsXCImI3gyMjA0O1wiOlwiXFxcXG5leGlzdHNcIixcIiYjeDIyMDM7XCI6XCJcXFxcZXhpc3RzXCIsXCImI3gyMjAwO1wiOlwiXFxcXGZvcmFsbFwiLFwiJiN4MjIyNztcIjpcIlxcXFxsYW5kXCIsXCImYW1wOyZhbXA7XCI6XCJcXFxcJlxcXFwmXCIsXCImI3gyMjI4O1wiOlwiXFxcXGxvclwiLFwiJiN4MjJBRjtcIjpcIlxcXFxjYW5jZWx7XFxcXHZEYXNofVwiLFwiJiN4MjJBRTtcIjpcIlxcXFxjYW5jZWx7XFxcXFZkYXNofVwiLFwiJiN4MjJBRDtcIjpcIlxcXFxudkRhc2hcIixcIiYjeDIyQUM7XCI6XCJcXFxcbnZEYXNoXCIsXCImI3gyMkE5O1wiOlwiXFxcXFZkYXNoXCIsXCImI3gyMkE4O1wiOlwiXFxcXHZEYXNoXCIsXCImI3gyMkE0O1wiOlwiXFxcXHRvcFwiLFwiJiN4MjJBMztcIjpcIlxcXFxkYXNodlwiLFwiJiN4MjJBMjtcIjpcIlxcXFx2ZGFzaFwiLFwiJiN4MjIwQjtcIjpcIlxcXFxuaVwiLFwiJiN4MjJGMTtcIjpcIlxcXFxkZG90c1wiLFwiJiN4MjJFRjtcIjpcIlxcXFxoZG90c1wiLFwiJiN4MjJFRTtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4MjAyNjtcIjpcIlxcXFxoZG90c1wiLFwiJiN4M0Y2O1wiOlwiXFxcXG5pXCIsXCI6XCI6XCI6XCIsXCIuLi5cIjpcIlxcXFxjZG90c1wiLFwiLi5cIjpcIi4uXCIsXCItPlwiOlwiLT5cIixcIiYjeDIyMzU7XCI6XCJcXFxcYmVjYXVzZVwiLFwiJiN4MjIzNDtcIjpcIlxcXFx0aGVyZWZvcmUgXCIsXCImI3gyMDYzO1wiOlwiXCIsXCIsXCI6XCIsXCIsXCI7XCI6XCI7XCIsXCImI3gyOUZEO1wiOlwiXFxcXH1cIixcIiYjeDI5RkM7XCI6XCJcXFxce1wiLFwiJiN4Mjk5ODtcIjpcIlxcXFxdXCIsXCImI3gyOTk3O1wiOlwiXFxcXFtcIixcIiYjeDI5OTY7XCI6XCJcXFxcbGxcIixcIiYjeDI5OTU7XCI6XCJcXFxcZ2dcIixcIiYjeDI5OTQ7XCI6XCJcXFxcZ2dcIixcIiYjeDI5OTM7XCI6XCJcXFxcbGxcIixcIiYjeDI5OTI7XCI6XCJcXFxcZ2dcIixcIiYjeDI5OTE7XCI6XCJcXFxcbGxcIixcIiYjeDI5OTA7XCI6XCJcXFxcXVwiLFwiJiN4Mjk4RjtcIjpcIlxcXFxdXCIsXCImI3gyOThFO1wiOlwiXFxcXF1cIixcIiYjeDI5OEQ7XCI6XCJcXFxcW1wiLFwiJiN4Mjk4QztcIjpcIlxcXFxbXCIsXCImI3gyOThCO1wiOlwiXFxcXF1cIixcIiYjeDI5OEE7XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4Mjk4OTtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI5ODg7XCI6XCJ8XFxcXClcIixcIiYjeDI5ODc7XCI6XCJcXFxcKHxcIixcIiYjeDI5ODY7XCI6XCJ8XFxcXClcIixcIiYjeDI5ODU7XCI6XCJcXFxcKFxcXFwoXCIsXCImI3gyOTg0O1wiOlwifFxcXFx9XCIsXCImI3gyOTgzO1wiOlwiXFxcXHt8XCIsXCImI3gyOTgwO1wiOlwiXFxcXHx8XCIsXCImI3gyN0VGO1wiOlwiXFxcXGxlZnQuIFxcXFxyaWdodF1cIixcIiYjeDI3RUU7XCI6XCJcXFxcbGVmdFsgXFxcXHJpZ2h0LlwiLFwiJiN4MjdFRDtcIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXVwiLFwiJiN4MjdFQztcIjpcIlxcXFxsZWZ0W1sgXFxcXHJpZ2h0LlwiLFwiJiN4MjdFQjtcIjpcIlxcXFxnZ1wiLFwiJiN4MjdFQTtcIjpcIlxcXFxsbFwiLFwiJiN4MjdFOTtcIjpcIlxcXFxyYW5nbGVcIixcIiYjeDI3RTg7XCI6XCJcXFxcbGFuZ2xlXCIsXCImI3gyN0U3O1wiOlwiXFxcXGxlZnQuIFxcXFxyaWdodF1dXCIsXCImI3gyN0U2O1wiOlwiXFxcXGxlZnRbWyBcXFxccmlnaHQuXCIsXCImI3gyNzczO1wiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0KVwiLFwiJiN4Mjc3MjtcIjpcIlxcXFxsZWZ0KFxcXFxyaWdodC5cIixcIiYjeDIzMkE7XCI6XCJcXFxccmFuZ2xlXCIsXCImI3gyMzI5O1wiOlwiXFxcXGxhbmdsZVwiLFwiJiN4MjMwQjtcIjpcIlxcXFxyZmxvb3JcIixcIiYjeDIzMEE7XCI6XCJcXFxcbGZsb29yXCIsXCImI3gyMzA5O1wiOlwiXFxcXHJjZWlsXCIsXCImI3gyMzA4O1wiOlwiXFxcXGxjZWlsXCIsXCImI3gyMDE2O1wiOlwiXFxcXHBhcmFsbGVsXCIsXCJ9XCI6XCJcXFxcbGVmdC5cXFxccmlnaHR9XCIsXCJ7XCI6XCJcXFxcbGVmdHtcXFxccmlnaHQuXCIsXCJdXCI6XCJcXFxcbGVmdF1cXFxccmlnaHQuXCIsXCJbXCI6XCJcXFxcbGVmdFtcXFxccmlnaHQuXCIsXCIpXCI6XCJcXFxcbGVmdC5cXFxccmlnaHQpXCIsXCIoXCI6XCJcXFxcbGVmdChcXFxccmlnaHQuXCIsXCImI3gyMDFEO1wiOidcIicsXCImI3gyMDFDO1wiOlwiYGBcIixcIiYjeDIwMTk7XCI6XCInXCIsXCImI3gyMDE4O1wiOlwiYFwiLFwiJUNFJUIxXCI6XCJcXFxcYWxwaGFcIixcIiVDRSVCMlwiOlwiXFxcXGJldGFcIixcIiVDRSVCM1wiOlwiXFxcXGdhbW1hXCIsXCIlQ0UlOTNcIjpcIlxcXFxHYW1tYVwiLFwiJUNFJUI0XCI6XCJcXFxcZGVsdGFcIixcIiVDRSU5NFwiOlwiXFxcXERlbHRhXCIsXCIlQ0YlQjVcIjpcIlxcXFxlcHNpbG9uXCIsXCIlQ0UlQjZcIjpcIlxcXFx6ZXRhXCIsXCIlQ0UlQjdcIjpcIlxcXFxldGFcIixcIiVDRSVCOFwiOlwiXFxcXHRoZXRhXCIsXCIlQ0UlOThcIjpcIlxcXFxUaGV0YVwiLFwiJUNFJUI5XCI6XCJcXFxcaW90YVwiLFwiJUNFJUJBXCI6XCJcXFxca2FwcGFcIixcIiVDRSVCQlwiOlwiXFxcXGxhbWJkYVwiLFwiJUNFJUJDXCI6XCJcXFxcbXVcIixcIiVDRSVCRFwiOlwiXFxcXG51XCIsXCIlQ0UlQkZcIjpcIlxcXFxvbWljcm9uXCIsXCIlQ0YlODBcIjpcIlxcXFxwaVwiLFwiJUNFJUEwXCI6XCJcXFxcUGlcIixcIiVDRiU4MVwiOlwiXFxcXHBob1wiLFwiJUNGJTgzXCI6XCJcXFxcc2lnbWFcIixcIiVDRSVBM1wiOlwiXFxcXFNpZ21hXCIsXCIlQ0YlODRcIjpcIlxcXFx0YXVcIixcIiVDRiU4NVwiOlwiXFxcXHVwc2lsb25cIixcIiVDRSVBNVwiOlwiXFxcXFVwc2lsb25cIixcIiVDRiU5NVwiOlwiXFxcXHBoaVwiLFwiJUNFJUE2XCI6XCJcXFxcUGhpXCIsXCIlQ0YlODdcIjpcIlxcXFxjaGlcIixcIiVDRiU4OFwiOlwiXFxcXHBzaVwiLFwiJUNFJUE4XCI6XCJcXFxcUHNpXCIsXCIlQ0YlODlcIjpcIlxcXFxvbWVnYVwiLFwiJUNFJUE5XCI6XCJcXFxcT21lZ2FcIn19LDkwMzk6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmFsbE1hdGhPcGVyYXRvcnNCeUdseXBoPXZvaWQgMCx0LmFsbE1hdGhPcGVyYXRvcnNCeUdseXBoPXtfOlwiXFxcXHVuZGVybGluZVwiLFwi4o+hXCI6XCJcXFxcdW5kZXJicmFjZVwiLFwi4o+gXCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCLij59cIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCLij55cIjpcIlxcXFxvdmVyYnJhY2VcIixcIuKPnVwiOlwiXFxcXHVuZGVyYnJhY2VcIixcIuKPnFwiOlwiXFxcXG92ZXJicmFjZVwiLFwi4o61XCI6XCJcXFxcdW5kZXJicmFjZVwiLFwi4o60XCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCLig5xcIjpcIlxcXFxzcXVhcmVcIixcIuKDm1wiOlwiXFxcXHNxdWFyZVwiLFwi4oGkXCI6XCJcIixcIuKBl1wiOlwiJycnJ1wiLFwi4oC+XCI6XCJcXFxcb3ZlcmxpbmVcIixcIuKAt1wiOlwiYGBgXCIsXCLigLZcIjpcImBgXCIsXCLigLVcIjpcImBcIixcIuKAtFwiOlwiJycnXCIsXCLigLNcIjpcIicnXCIsXCLigJ9cIjpcImBgXCIsXCLigJ5cIjpcIiwsXCIsXCLigJtcIjpcImBcIixcIuKAmlwiOlwiLFwiLFwiXlwiOlwiXFxcXGhhdFwiLFwiy7dcIjpcIlxcXFxzaW1cIixcIsudXCI6XCJcXFxcc2ltXCIsXCLLnFwiOlwiXFxcXHNpbVwiLFwiy5pcIjpcIlxcXFxjaXJjXCIsXCLLmVwiOlwiXFxcXGNkb3RcIixcIsuYXCI6XCIgXCIsy406XCJcXFxcX1wiLMuLOlwiy4tcIizLijpcIsuKXCIsy4k6XCLLiVwiLMuHOlwiXCIsy4Y6XCJcXFxcaGF0XCIswro6XCJvXCIsXCLCuVwiOlwiMVwiLFwiwrhcIjpcIixcIixcIsK0XCI6XCLCtFwiLFwiwrNcIjpcIjNcIixcIsKyXCI6XCIyXCIsXCLCsFwiOlwiXFxcXGNpcmNcIixcIsKvXCI6XCJcXFxcYmFyXCIswqo6XCJhXCIsXCLihptcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiwqhcIjpcIlxcXFxjZG90XFxcXGNkb3RcIixcIn5cIjpcIlxcXFxzaW1cIixcImBcIjpcImBcIixcIi0tXCI6XCItLVwiLFwiKytcIjpcIisrXCIsXCImXCI6XCJcXFxcJlwiLFwi4oicXCI6XCJcXFxcc3FydFs0XXt9XCIsXCLiiJtcIjpcIlxcXFxzcXJ0WzNde31cIixcIuKImlwiOlwiXFxcXHNxcnR7fVwiLOKFhjpcImRcIizihYU6XCJcXFxcbWF0aGJie0R9XCIsXCI/XCI6XCI/XCIsXCJAXCI6XCJAXCIsXCIvL1wiOlwiLy9cIixcIiEhXCI6XCIhIVwiLFwiIVwiOlwiIVwiLFwi4pmvXCI6XCJcXFxcI1wiLFwi4pmuXCI6XCJcIixcIuKZrVwiOlwiXCIsXCLigLJcIjpcIidcIixcIjw+XCI6XCI8PlwiLFwiKipcIjpcIlxcXFxzdGFyXFxcXHN0YXJcIixcIuKIh1wiOlwiXFxcXG5hYmxhXCIsXCLiiIJcIjpcIlxcXFxwYXJ0aWFsXCIsXCLiiplcIjpcIlxcXFxiaWdvZG90XCIsXCLCrFwiOlwiXFxcXG5lZ1wiLFwi4oiiXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4oihXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4oigXCI6XCJcXFxcYW5nbGVcIixcIsO3XCI6XCJcXFxcZGl2XCIsXCIvXCI6XCIvXCIsXCLiiJZcIjpcIlxcXFxiYWNrc2xhc2hcIixcIlxcXFxcIjpcIlxcXFxiYWNrc2xhc2hcIixcIiVcIjpcIlxcXFwlXCIsXCLiipdcIjpcIlxcXFxiaWdvdGltZXNcIixcIsK3XCI6XCJcXFxcY2RvdFwiLFwi4qi/XCI6XCJcXFxcY29wcm9kXCIsXCLiqK9cIjpcIlxcXFx0aW1lc1wiLFwi4ouFXCI6XCJcXFxcY2RvdFwiLFwi4oqhXCI6XCJcXFxcYm94ZG90XCIsXCLiiqBcIjpcIlxcXFxib3h0aW1lc1wiLFwi4oGiXCI6XCJcIixcIuKBg1wiOlwiLVwiLFwi4oCiXCI6XCJcXFxcY2RvdFwiLFwiLlwiOlwiLlwiLFwiKlwiOlwiXFxcXHN0YXJcIixcIuKIqlwiOlwiXFxcXGN1cFwiLFwi4oipXCI6XCJcXFxcY2FwXCIsXCLiiJBcIjpcIlxcXFxjb3Byb2RcIixcIuKIj1wiOlwiXFxcXHByb2RcIixcIuKJgFwiOlwiXCIsXCLiq79cIjpcIlwiLFwi4qu8XCI6XCJcXFxcbWlkXFxcXG1pZFxcXFxtaWRcIixcIuKoiVwiOlwiXFxcXHRpbWVzXCIsXCLiqIhcIjpcIlwiLFwi4qiHXCI6XCJcIixcIuKohlwiOlwiXFxcXHNxY3VwXCIsXCLiqIVcIjpcIlxcXFxzcWNhcFwiLFwi4qiCXCI6XCJcXFxcb3RpbWVzXCIsXCLiqIBcIjpcIlxcXFxvZG90XCIsXCLii4JcIjpcIlxcXFxjYXBcIixcIuKLgVwiOlwiXFxcXHZlZVwiLFwi4ouAXCI6XCJcXFxcd2VkZ2VcIixcIuKohFwiOlwiXFxcXHVwbHVzXCIsXCLiqINcIjpcIlxcXFxjdXBcIixcIuKLg1wiOlwiXFxcXGN1cFwiLFwi4qicXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbnR9XCIsXCLiqJtcIjpcIlxcXFxvdmVybGluZXtcXFxcaW50fVwiLFwi4qiaXCI6XCJcXFxcaW50XCIsXCLiqJlcIjpcIlxcXFxpbnRcIixcIuKomFwiOlwiXFxcXGludFwiLFwi4qiXXCI6XCJcXFxcaW50XCIsXCLiqJZcIjpcIlxcXFxvaW50XCIsXCLiqJVcIjpcIlxcXFxvaW50XCIsXCLiqJRcIjpcIlxcXFxpbnRcIixcIuKok1wiOlwiXFxcXGludFwiLFwi4qiSXCI6XCJcXFxcaW50XCIsXCLiqJFcIjpcIlxcXFxpbnRcIixcIuKokFwiOlwiXFxcXGludFwiLFwi4qiPXCI6XCJcXFxcYmNhbmNlbHtcXFxcaW50fVwiLFwi4qiOXCI6XCJcIixcIuKojVwiOlwiXFxcXGhjYW5jZWx7XFxcXGludH1cIixcIuKojFwiOlwiXFxcXGlpaWludFwiLFwi4oizXCI6XCJcXFxcb2ludFwiLFwi4oiyXCI6XCJcXFxcb2ludFwiLFwi4oixXCI6XCJcXFxcaW50XCIsXCLiiLBcIjpcIlxcXFxvaWludFwiLFwi4oivXCI6XCJcXFxcb2lpbnRcIixcIuKIrlwiOlwiXFxcXG9pbnRcIixcIuKIq1wiOlwiXFxcXGludFwiLFwi4qiBXCI6XCJcXFxcb3BsdXNcIixcIuKKmFwiOlwiXFxcXG9zbGFzaFwiLFwi4oqWXCI6XCJcXFxcb21pbnVzXCIsXCLiipVcIjpcIlxcXFxvcGx1c1wiLFwi4oitXCI6XCJcXFxcaWlpbnRcIixcIuKIrFwiOlwiXFxcXGlpbnRcIixcIuKoi1wiOlwiXCIsXCLiqIpcIjpcIlwiLFwi4oiRXCI6XCJcXFxcc3VtXCIsXCLiip9cIjpcIlxcXFxib3htaW51c1wiLFwi4oqeXCI6XCJcXFxcYm94cGx1c1wiLFwi4oiUXCI6XCJcXFxcZG90eyt9XCIsXCLiiJNcIjpcIistXCIsXCLiiJJcIjpcIi1cIixcIsKxXCI6XCJcXFxccG1cIixcIi1cIjpcIi1cIixcIitcIjpcIitcIixcIuKthlwiOlwiXFxcXFJyaWdodGFycm93XCIsXCLirYVcIjpcIlxcXFxMbGVmdGFycm93XCIsXCLip7RcIjpcIjpcXFxccmlnaHRhcnJvd1wiLFwi4qevXCI6XCJcIixcIuKnn1wiOlwiXFxcXGJ1bGxldC1cXFxcYnVsbGV0XCIsXCLipp9cIjpcIlxcXFxhbmdsZVwiLFwi4qaeXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qadXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qacXCI6XCJcXFxccGVycFwiLFwi4qabXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qaaXCI6XCJcIixcIuKmmVwiOlwiXFxcXHZkb3RzXCIsXCLipb9cIjpcIlwiLFwi4qW+XCI6XCJcIixcIuKlvVwiOlwiXFxcXHByZWNcIixcIuKlvFwiOlwiXFxcXHN1Y2NcIixcIuKlu1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vwc2V0fVwiLFwi4qW6XCI6XCJcIixcIuKluVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vic2V0fVwiLFwi4qW4XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHJpZ2h0YXJyb3d9ez59XCIsXCLipbdcIjpcIlwiLFwi4qW2XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGxlZnRhcnJvd317PH1cIixcIuKltVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxyaWdodGFycm93fVwiLFwi4qW0XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHJpZ2h0YXJyb3d9XCIsXCLipbNcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcbGVmdGFycm93fVwiLFwi4qWyXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxccmlnaHRhcnJvd31cIixcIuKlsVwiOlwiXFxcXG92ZXJzZXR7PX17XFxcXHJpZ2h0YXJyb3d9XCIsXCLipbBcIjpcIlwiLFwi4qWvXCI6XCJcIixcIuKlrlwiOlwiXCIsXCLipa1cIjpcIlxcXFxvdmVybGluZXtcXFxccmlnaHRoYXJwb29uZG93bn1cIixcIuKlrFwiOlwiXFxcXHVuZGVybGluZXtcXFxccmlnaHRoYXJwb29udXB9XCIsXCLipatcIjpcIlxcXFxvdmVybGluZXtcXFxcbGVmdGhhcnBvb25kb3dufVwiLFwi4qWqXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsZWZ0aGFycG9vbnVwfVwiLFwi4qWpXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKlqFwiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCLipadcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwi4qWmXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKlpVwiOlwiXFxcXERvd25hcnJvd1wiLFwi4qWkXCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4qWjXCI6XCJcXFxcVXBhcnJvd1wiLFwi4qWiXCI6XCJcXFxcTGVmdGFycm93XCIsXCLipaFcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKloFwiOlwiXFxcXHVwYXJyb3dcIixcIuKln1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKlnlwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qWdXCI6XCJcXFxcZG93bmFycm93XCIsXCLipZxcIjpcIlxcXFx1cGFycm93XCIsXCLipZtcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipZpcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKlmVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qWYXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qWXXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qWWXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipZVcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKllFwiOlwiXFxcXHVwYXJyb3dcIixcIuKlk1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKlklwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qWRXCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIuKlkFwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipY9cIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4qWOXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKljVwiOlwiXFxcXHVwZG93bmFycm93XCIsXCLipYxcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4qWLXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKlilwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipYlcIjpcIlwiLFwi4qWIXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKlh1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCLipYZcIjpcIlwiLFwi4qWFXCI6XCJcIixcIuKlhFwiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwi4qWDXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCLipYJcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIuKlgVwiOlwiXFxcXGNpcmNsZWFycm93cmlnaHRcIixcIuKlgFwiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwi4qS/XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qS+XCI6XCJcXFxcbGVmdGFycm93XCIsXCLipL1cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkvFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKku1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkulwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qS5XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLhcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKkt1wiOlwiXFxcXFJzaFwiLFwi4qS2XCI6XCJcXFxcTHNoXCIsXCLipLVcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKktFwiOlwiXFxcXHVwYXJyb3dcIixcIuKks1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkslwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qSxXCI6XCIgXCIsXCLipLBcIjpcIiBcIixcIuKkr1wiOlwiIFwiLFwi4qSuXCI6XCIgXCIsXCLipK1cIjpcIiBcIixcIuKkrFwiOlwiXFxcXHRpbWVzXCIsXCLipKtcIjpcIlxcXFx0aW1lc1wiLFwi4qSqXCI6XCIgXCIsXCLipKlcIjpcIiBcIixcIuKkqFwiOlwiIFwiLFwi4qSnXCI6XCIgXCIsXCLipKZcIjpcIiBcIixcIuKkpVwiOlwiIFwiLFwi4qSkXCI6XCIgXCIsXCLipKNcIjpcIiBcIixcIuKkolwiOlwiIFwiLFwi4qShXCI6XCIgXCIsXCLipKBcIjpcIlxcXFxtYXBzdG9cXFxcY2RvdFwiLFwi4qSfXCI6XCJcXFxcY2RvdFxcXFxsZWZ0YXJyb3dcIixcIuKknlwiOlwiXFxcXHJpZ2h0YXJyb3dcXFxcY2RvdFwiLFwi4qSdXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipJxcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipJtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkmlwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkmVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qSYXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSXXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSWXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSVXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSUXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSTXCI6XCJcXFxcZG93bmFycm93XCIsXCLipJJcIjpcIlxcXFx1cGFycm93XCIsXCLipJFcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipJBcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipI9cIjpcIlxcXFxyaWdodGFycm93XCIsXCLipI5cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkjVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkjFwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qSLXCI6XCJcXFxcRG93bmFycm93XCIsXCLipIpcIjpcIlxcXFxVcGFycm93XCIsXCLipIlcIjpcIlxcXFx1cGFycm93XCIsXCLipIhcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKkh1wiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIuKkhlwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4qSFXCI6XCJcXFxcbWFwc3RvXCIsXCLipIRcIjpcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIixcIuKkg1wiOlwiXFxcXG5SaWdodGFycm93XCIsXCLipIJcIjpcIlxcXFxuTGVmdGFycm93XCIsXCLipIFcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIuKkgFwiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwi4p+/XCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCLin75cIjpcIlxcXFxSaWdodGFycm93XCIsXCLin71cIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKfvFwiOlwiXFxcXG1hcHN0b1wiLFwi4p+7XCI6XCJcXFxcbGVmdGFycm93XCIsXCLin7pcIjpcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIixcIuKfuVwiOlwiXFxcXExvbmdyaWdodGFycm93XCIsXCLin7hcIjpcIlxcXFxMb25nbGVmdGFycm93XCIsXCLin7dcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4p+2XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4p+1XCI6XCJcXFxcbGVmdGFycm93XCIsXCLin7FcIjpcIlxcXFxEb3duYXJyb3dcIixcIuKfsFwiOlwiXFxcXFVwYXJyb3dcIixcIuKKuFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKHv1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLih75cIjpcIlxcXFxyaWdodGFycm93XCIsXCLih71cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHvFwiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwi4oe7XCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIuKHulwiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIuKHuVwiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwi4oe4XCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIuKHt1wiOlwiXFxcXG5sZWZ0YXJyb3dcIixcIuKHtlwiOlwiXFxcXFJyaWdodGFycm93XCIsXCLih7VcIjpcIlwiLFwi4oe0XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oezXCI6XCJcXFxcVXBkb3duYXJyb3dcIixcIuKHslwiOlwiXFxcXHNlYXJyb3dcIixcIuKHsVwiOlwiXFxcXG53YXJyb3dcIixcIuKHsFwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4oevXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oeuXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oetXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oesXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oerXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oeqXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oepXCI6XCJcXFxcRG93bmFycm93XCIsXCLih6hcIjpcIlxcXFxSaWdodGFycm93XCIsXCLih6dcIjpcIlxcXFxVcGFycm93XCIsXCLih6ZcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKHpVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKHpFwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4oejXCI6XCJcXFxcZG93bmFycm93XCIsXCLih6JcIjpcIlxcXFxyaWdodGFycm93XCIsXCLih6FcIjpcIlxcXFx1cGFycm93XCIsXCLih6BcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHn1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oeeXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oedXCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCLih5xcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHm1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCLih5pcIjpcIlxcXFxMbGVmdGFycm93XCIsXCLih5lcIjpcIlxcXFxzd2Fycm93XCIsXCLih5hcIjpcIlxcXFxzZWFycm93XCIsXCLih5dcIjpcIlxcXFxuZWFycm93XCIsXCLih5ZcIjpcIlxcXFxud2Fycm93XCIsXCLih5VcIjpcIlxcXFxVcGRvd25hcnJvd1wiLFwi4oeUXCI6XCJcXFxcTGVmdHJpZ2h0YXJyb3dcIixcIuKHk1wiOlwiXFxcXERvd25hcnJvd1wiLFwi4oeSXCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4oeRXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oeQXCI6XCJcXFxcTGVmdGFycm93XCIsXCLih49cIjpcIlxcXFxuUmlnaHRhcnJvd1wiLFwi4oeOXCI6XCJcXFxcbkxlZnRyaWdodGFycm93XCIsXCLih41cIjpcIlxcXFxuTGVmdGFycm93XCIsXCLih4xcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwi4oeLXCI6XCJcXFxcbGVmdHJpZ2h0aGFycG9vbnNcIixcIuKHilwiOlwiXFxcXGRvd25kb3duYXJyb3dzXCIsXCLih4lcIjpcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIsXCLih4hcIjpcIlxcXFx1cHVwYXJyb3dzXCIsXCLih4dcIjpcIlxcXFxsZWZ0bGVmdGFycm93c1wiLFwi4oeGXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCLih4VcIjpcIlwiLFwi4oeEXCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCLih4NcIjpcIlxcXFxkb3duaGFycG9vbmxlZnRcIixcIuKHglwiOlwiXFxcXGRvd25oYXJwb29ucmlnaHRcIixcIuKHgVwiOlwiXFxcXHJpZ2h0aGFycG9vbmRvd25cIixcIuKHgFwiOlwiXFxcXHJpZ2h0aGFycG9vbnVwXCIsXCLihr9cIjpcIlxcXFx1cGhhcnBvb25sZWZ0XCIsXCLihr5cIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwi4oa9XCI6XCJcXFxcbGVmdGhhcnBvb25kb3duXCIsXCLihrxcIjpcIlxcXFxsZWZ0aGFycG9vbnVwXCIsXCLihrtcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCLihrpcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKGuVwiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwi4oa4XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG53YXJyb3d9XCIsXCLihrdcIjpcIlxcXFxjdXJ2ZWFycm93cmlnaHRcIixcIuKGtlwiOlwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIsXCLihrVcIjpcIlxcXFxzd2Fycm93XCIsXCLihrRcIjpcIlxcXFxzZWFycm93XCIsXCLihrNcIjpcIlxcXFxSc2hcIixcIuKGslwiOlwiXFxcXExzaFwiLFwi4oaxXCI6XCJcXFxcUnNoXCIsXCLihrBcIjpcIlxcXFxMc2hcIixcIuKGr1wiOlwiXFxcXHN3YXJyb3dcIixcIuKGrlwiOlwiXCIsXCLihq1cIjpcIlxcXFxsZWZ0cmlnaHRzcXVpZ2Fycm93XCIsXCLihqxcIjpcIlxcXFxsb29wYXJyb3dyaWdodFwiLFwi4oarXCI6XCJcXFxcbG9vcGFycm93bGVmdFwiLFwi4oaqXCI6XCJcXFxcaG9va3JpZ2h0YXJyb3dcIixcIuKGqVwiOlwiXFxcXGhvb2tsZWZ0YXJyb3dcIixcIuKGqFwiOlwiXFxcXHVuZGVybGluZXtcXFxcdXBkb3duYXJyb3d9XCIsXCLihqdcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKGplwiOlwiXFxcXHJpZ2h0YXJyb3d0YWlsXCIsXCLihqVcIjpcIlxcXFx1cGFycm93XCIsXCLihqRcIjpcIlxcXFxsZWZ0YXJyb3d0YWlsXCIsXCLihqNcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwi4oaiXCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwi4oahXCI6XCJcXFxcZG93bmFycm93XCIsXCLihqBcIjpcIlxcXFx0d29oZWFkcmlnaHRhcnJvd1wiLFwi4oafXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oaeXCI6XCJcXFxcdHdvaGVhZGxlZnRhcnJvd1wiLFwi4oadXCI6XCJcXFxcbmVhcnJvd1wiLFwi4oacXCI6XCJcXFxcbndhcnJvd1wiLFwi4oaaXCI6XCJcIixcIuKGmVwiOlwiXFxcXHN3YXJyb3dcIixcIuKGmFwiOlwiXFxcXHNlYXJyb3dcIixcIuKGl1wiOlwiXFxcXG5lYXJyb3dcIixcIuKGllwiOlwiXFxcXG53YXJyb3dcIixcIuKGlVwiOlwiXFxcXHVwZG93bmFycm93XCIsXCLihpRcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4oaTXCI6XCJcXFxcZG93bmFycm93XCIsXCLihpJcIjpcIlxcXFxyaWdodGFycm93XCIsXCLihpFcIjpcIlxcXFx1cGFycm93XCIsXCLihpBcIjpcIlxcXFxsZWZ0YXJyb3dcIixcInx8fFwiOlwiXFxcXGxlZnR8fHxcXFxccmlnaHQuXCIsXCJ8fFwiOlwiXFxcXGxlZnR8fFxcXFxyaWdodC5cIixcInxcIjpcIlxcXFxtaWRcIixcIuKrvlwiOlwiXCIsXCLiq71cIjpcIi8vXCIsXCLiq7tcIjpcIi8vL1wiLFwi4qu6XCI6XCJcIixcIuKruVwiOlwiXCIsXCLiq7hcIjpcIlwiLFwi4qu3XCI6XCJcIixcIuKrtlwiOlwiXFxcXHZkb3RzXCIsXCLiq7VcIjpcIlwiLFwi4qu0XCI6XCJcIixcIuKrs1wiOlwiXCIsXCLiq7JcIjpcIlxcXFxucGFyYWxsZWxcIixcIuKrsVwiOlwiXCIsXCLiq7BcIjpcIlwiLFwi4quvXCI6XCJcIixcIuKrrlwiOlwiXFxcXGJjYW5jZWx7XFxcXG1pZH1cIixcIuKrrVwiOlwiXCIsXCLiq6xcIjpcIlwiLFwi4qurXCI6XCJcIixcIuKrqlwiOlwiXCIsXCLiq6lcIjpcIlwiLFwi4quoXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxwZXJwfVwiLFwi4qunXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHRvcH1cIixcIuKrplwiOlwiXCIsXCLiq6VcIjpcIlwiLFwi4qukXCI6XCJcIixcIuKro1wiOlwiXCIsXCLiq6JcIjpcIlwiLFwi4quhXCI6XCJcIixcIuKroFwiOlwiXFxcXHBlcnBcIixcIuKrn1wiOlwiXFxcXHRvcFwiLFwi4queXCI6XCJcXFxcZGFzaHZcIixcIuKrncy4XCI6XCJcIixcIuKrnVwiOlwiXCIsXCLiq5tcIjpcIlxcXFxwaXRjaGZvcmtcIixcIuKrmlwiOlwiXCIsXCLiq5lcIjpcIlwiLFwi4quYXCI6XCJcIixcIuKrl1wiOlwiXCIsXCLiq5ZcIjpcIlwiLFwi4quVXCI6XCJcIixcIuKrlFwiOlwiXCIsXCLiq5NcIjpcIlwiLFwi4quSXCI6XCJcIixcIuKrkVwiOlwiXCIsXCLiq5BcIjpcIlwiLFwi4quPXCI6XCJcIixcIuKrjlwiOlwiXCIsXCLiq41cIjpcIlwiLFwi4quMXCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5lcX17XFxcXHN1cHNldH1cIixcIuKri1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdWJzZXR9XCIsXCLiq4pcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxcc3Vwc2V0fVwiLFwi4quJXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1YnNldH1cIixcIuKriFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdXBzZXR9XCIsXCLiq4dcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3Vic2V0fVwiLFwi4quGXCI6XCJcXFxcc3Vwc2V0ZXFxXCIsXCLiq4VcIjpcIlxcXFxzdWJzZXRlcXFcIixcIuKrhFwiOlwiXFxcXGRvdHtcXFxcc3Vwc2V0ZXF9XCIsXCLiq4NcIjpcIlxcXFxkb3R7XFxcXHN1YnNldGVxfVwiLFwi4quCXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHRpbWVzfXtcXFxcc3Vwc2V0fVwiLFwi4quBXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHRpbWVzfXtcXFxcc3Vic2V0fVwiLFwi4quAXCI6XCJcXFxcdW5kZXJzZXR7K317XFxcXHN1cHNldH1cIixcIuKqv1wiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdWJzZXR9XCIsXCLiqr5cIjpcIlwiLFwi4qq9XCI6XCJcIixcIuKqvFwiOlwiXFxcXGdnIFwiLFwi4qq7XCI6XCJcXFxcbGxcIixcIuKqulwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19e1xcXFxzdWNjfVwiLFwi4qq5XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17XFxcXHByZWN9XCIsXCLiqrhcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxcc3VjY31cIixcIuKqt1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxwcmVjfVwiLFwi4qq2XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHN1Y2N9XCIsXCLiqrVcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vsez19fXtcXFxccHJlY31cIixcIuKqtFwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxzdWNjfVwiLFwi4qqzXCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHByZWN9XCIsXCLiqrJcIjpcIlwiLFwi4qqxXCI6XCJcIixcIuKqrlwiOlwiXCIsXCLiqq1cIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGhjYW5jZWx7Pn19XCIsXCLiqqxcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGhjYW5jZWx7Pn19XCIsXCLiqqtcIjpcIlxcXFxoY2FuY2Vsez59XCIsXCLiqqpcIjpcIlxcXFxoY2FuY2Vsezx9XCIsXCLiqqlcIjpcIlwiLFwi4qqoXCI6XCJcIixcIuKqp1wiOlwiXFxcXHZhcnRyaWFuZ2xlcmlnaHRcIixcIuKqplwiOlwiXFxcXHZhcnRyaWFuZ2xlbGVmdFwiLFwi4qqlXCI6XCI+PFwiLFwi4qqkXCI6XCI+PFwiLFwi4qqjXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxsbH1cIixcIuKqosy4XCI6XCJcXFxcY2FuY2Vse1xcXFxnZ31cIixcIuKqolwiOlwiXFxcXGdnXCIsXCLiqqHMuFwiOlwiXFxcXGNhbmNlbHtcXFxcbGx9XCIsXCLiqqFcIjpcIlxcXFxsbFwiLFwi4qqgXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxcZ2VxcX1cIixcIuKqn1wiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17XFxcXGxlcXF9XCIsXCLiqp5cIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ez59XCIsXCLiqp1cIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ezx9XCIsXCLiqpxcIjpcIlwiLFwi4qqbXCI6XCJcIixcIuKqmlwiOlwiXFxcXG92ZXJzZXR7PX17Pn1cIixcIuKqmVwiOlwiXFxcXG92ZXJzZXR7PX17PH1cIixcIuKqmFwiOlwiXCIsXCLiqpdcIjpcIlwiLFwi4qqWXCI6XCJcIixcIuKqlVwiOlwiXCIsXCLiqpRcIjpcIlwiLFwi4qqTXCI6XCJcIixcIuKqklwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxndHJsZXNzfVwiLFwi4qqRXCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXGxlc3NndHJ9XCIsXCLiqpBcIjpcIlxcXFx1bmRlcnNldHs8fXtcXFxcZ3Ryc2ltfVwiLFwi4qqPXCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlc3NzaW19XCIsXCLiqo5cIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltZXF9ez59XCIsXCLiqo1cIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltZXF9ezx9XCIsXCLiqoxcIjpcIlxcXFxndHJlcXFsZXNzXCIsXCLiqotcIjpcIlxcXFxsZXNzZXFxZ3RyXCIsXCLiqopcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXs+fVwiLFwi4qqJXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIuKqhlwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ez59XCIsXCLiqoVcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXs8fVwiLFwi4qqEXCI6XCJcIixcIuKqg1wiOlwiXCIsXCLiqoJcIjpcIlwiLFwi4qqBXCI6XCJcIixcIuKqgFwiOlwiXCIsXCLiqb9cIjpcIlwiLFwi4qm+zLhcIjpcIlxcXFxiY2FuY2Vse1xcXFxnZXF9XCIsXCLiqb5cIjpcIlxcXFxnZXFcIixcIuKpvcy4XCI6XCJcXFxcYmNhbmNlbHtcXFxcbGVxfVwiLFwi4qm9XCI6XCJcXFxcbGVxXCIsXCLiqbxcIjpcIlwiLFwi4qm7XCI6XCJcIixcIuKpulwiOlwiXCIsXCLiqblcIjpcIlwiLFwi4qm4XCI6XCJcXFxcb3ZlcnNldHtcXFxcZG90c317XFxcXGVxdWl2fVwiLFwi4qm3XCI6XCJcIixcIuKptlwiOlwiPT09XCIsXCLiqbVcIjpcIj09XCIsXCLiqbRcIjpcIjo6PVwiLFwi4qmzXCI6XCJcIixcIuKpslwiOlwiXFxcXHVuZGVyc2V0ez19eyt9XCIsXCLiqbFcIjpcIlxcXFxvdmVyc2V0ez19eyt9XCIsXCLiqbBcIjpcIlxcXFxvdmVyc2V0e1xcXFxhcHByb3h9ez19XCIsXCLiqa9cIjpcIlxcXFxvdmVyc2V0e1xcXFx3ZWRnZX17PX1cIixcIuKprlwiOlwiXFxcXG92ZXJzZXR7Kn17PX1cIixcIuKprVwiOlwiXFxcXGRvdHtcXFxcYXBwcm94fVwiLFwi4qmsXCI6XCJcIixcIuKpq1wiOlwiXCIsXCLiqapcIjpcIlxcXFxkb3R7XFxcXHNpbX1cIixcIuKpqVwiOlwiXCIsXCLiqahcIjpcIlwiLFwi4qmnXCI6XCJcXFxcZG90e1xcXFxlcXVpdn1cIixcIuKpplwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjZG90fXs9fVwiLFwi4qmlXCI6XCJcIixcIuKppFwiOlwiXCIsXCLiqaNcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcdmVlfVwiLFwi4qmiXCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxcdmVlfVwiLFwi4qmhXCI6XCJ1bCh2dilcIixcIuKpoFwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIuKpn1wiOlwiXFxcXHVuZGVybGluZXtcXFxcd2VkZ2V9XCIsXCLiqZ5cIjpcIlxcXFxvdmVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIuKpnVwiOlwiXFxcXGhjYW5jZWx7XFxcXHZlZX1cIixcIuKpnFwiOlwiXFxcXGhjYW5jZWx7XFxcXHdlZGdlfVwiLFwi4qmbXCI6XCJcIixcIuKpmlwiOlwiXCIsXCLiqZlcIjpcIlwiLFwi4qmYXCI6XCJcXFxcdmVlXCIsXCLiqZdcIjpcIlxcXFx3ZWRnZVwiLFwi4qmWXCI6XCJcIixcIuKplVwiOlwiXCIsXCLiqZRcIjpcIlwiLFwi4qmTXCI6XCJcIixcIuKpklwiOlwiXFxcXGRvdHtcXFxcdmVlfVwiLFwi4qmRXCI6XCJcXFxcZG90e1xcXFx3ZWRnZX1cIixcIuKpkFwiOlwiXCIsXCLiqY9cIjpcIlwiLFwi4qmOXCI6XCJcIixcIuKpjVwiOlwiXFxcXG92ZXJsaW5le1xcXFxjYXB9XCIsXCLiqYxcIjpcIlxcXFxvdmVybGluZXtcXFxcY3VwfVwiLFwi4qmLXCI6XCJcIixcIuKpilwiOlwiXCIsXCLiqYlcIjpcIlwiLFwi4qmIXCI6XCJcIixcIuKph1wiOlwiXCIsXCLiqYZcIjpcIlwiLFwi4qmFXCI6XCJcIixcIuKphFwiOlwiXCIsXCLiqYNcIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwi4qmCXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIuKpgVwiOlwiXCIsXCLiqYBcIjpcIlwiLFwi4qi+XCI6XCJcIixcIuKovVwiOlwiXFxcXGxsY29ybmVyXCIsXCLiqLxcIjpcIlxcXFxscmNvcm5lclwiLFwi4qi7XCI6XCJcIixcIuKoulwiOlwiXCIsXCLiqLlcIjpcIlwiLFwi4qi4XCI6XCJcIixcIuKot1wiOlwiXCIsXCLiqLZcIjpcIlxcXFxoYXR7XFxcXG90aW1lc31cIixcIuKotVwiOlwiXCIsXCLiqLRcIjpcIlwiLFwi4qizXCI6XCJcIixcIuKoslwiOlwiXFxcXHVuZGVybGluZXtcXFxcdGltZXN9XCIsXCLiqLFcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHRpbWVzfVwiLFwi4qiwXCI6XCJcXFxcZG90e1xcXFx0aW1lc31cIixcIuKorlwiOlwiXFxcXGJpZ29kb3RcIixcIuKorVwiOlwiXFxcXGJpZ29kb3RcIixcIuKorFwiOlwiXCIsXCLiqKtcIjpcIlwiLFwi4qiqXCI6XCJcIixcIuKoqVwiOlwiXCIsXCLiqKhcIjpcIlwiLFwi4qinXCI6XCJcIixcIuKXu1wiOlwiXFxcXEJveFwiLFwi4qimXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17K31cIixcIuKopVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjaXJjfXsrfVwiLFwi4qikXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXsrfVwiLFwi4qijXCI6XCJcXFxcaGF0eyt9XCIsXCLiqKJcIjpcIlxcXFxkb3R7K31cIixcIuKooVwiOlwiXFxcXHVwaGFycG9vbnJpZ2h0XCIsXCLiqKBcIjpcIj4+XCIsXCLiqJ9cIjpcIlwiLFwi4qieXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLiqJ1cIjpcIlxcXFxib3d0aWVcIixcIuKnv1wiOlwiXCIsXCLip75cIjpcIitcIixcIuKnu1wiOlwiXFxcXGhjYW5jZWx7fHx8fVwiLFwi4qe6XCI6XCJcXFxcaGNhbmNlbHt8fH1cIixcIuKnuVwiOlwiXFxcXGJhY2tzbGFzaFwiLFwi4qe4XCI6XCIvXCIsXCLip7dcIjpcImhjYW5jZWx7XFxiYWNrc2xhc2h9XCIsXCLip7ZcIjpcIlwiLFwi4qe1XCI6XCJcXFxcYmFja3NsYXNoXCIsXCLip7JcIjpcIlxcXFxQaGlcIixcIuKnsVwiOlwiXCIsXCLip7BcIjpcIlwiLFwi4qeuXCI6XCJcIixcIuKnrVwiOlwiXCIsXCLip6xcIjpcIlwiLFwi4qerXCI6XCJcXFxcbG96ZW5nZVwiLFwi4qeqXCI6XCJcIixcIuKnqVwiOlwiXCIsXCLip6hcIjpcIlwiLFwi4qenXCI6XCJcXFxcZGRhZ2dlclwiLFwi4qeiXCI6XCJcXFxcc3FjdXBcXFxcc3FjdXBcIixcIuKnoVwiOlwiXCIsXCLip6BcIjpcIlxcXFxzcXVhcmVcIixcIuKnnlwiOlwiXCIsXCLip51cIjpcIlwiLFwi4qecXCI6XCJcIixcIuKnm1wiOlwiXFxcXHtcXFxce1wiLFwi4qeZXCI6XCJcXFxce1wiLFwi4qeYXCI6XCJcXFxcfVwiLFwi4qeXXCI6XCJcIixcIuKnllwiOlwiXCIsXCLip5VcIjpcIlxcXFxib3d0aWVcIixcIuKnlFwiOlwiXFxcXGJvd3RpZVwiLFwi4qeTXCI6XCJcXFxcYm93dGllXCIsXCLip5JcIjpcIlxcXFxib3d0aWVcIixcIuKnkVwiOlwiXFxcXGJvd3RpZVwiLFwi4qeQzLhcIjpcInwgXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLip5BcIjpcInwgXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKnj8y4XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdCB8XCIsXCLip49cIjpcIlxcXFx0cmlhbmdsZWxlZnQgfFwiLFwi4qeOXCI6XCJcIixcIuKnjVwiOlwiXFxcXHRyaWFuZ2xlXCIsXCLip4xcIjpcIlwiLFwi4qeLXCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0cmlhbmdsZX1cIixcIuKnilwiOlwiXFxcXGRvdHtcXFxcdHJpYW5nbGV9XCIsXCLip4lcIjpcIlwiLFwi4qeIXCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCLip4dcIjpcIlxcXFxib3hlZHtcXFxcY2lyY31cIixcIuKnhlwiOlwiXFxcXGJveGVke1xcXFxyaWdodGFycm93fVwiLFwi4qeFXCI6XCJcXFxcYmNhbmNlbHtcXFxcc3F1YXJlfVwiLFwi4qeEXCI6XCJcXFxcY2FuY2Vse1xcXFxzcXVhcmV9XCIsXCLip4NcIjpcIlxcXFxvZG90XCIsXCLip4JcIjpcIlxcXFxvZG90XCIsXCLipr9cIjpcIlxcXFxvZG90XCIsXCLipr5cIjpcIlxcXFxvZG90XCIsXCLipr1cIjpcIlxcXFx2YXJub3RoaW5nXCIsXCLiprxcIjpcIlxcXFxvcGx1c1wiLFwi4qa7XCI6XCJcXFxcb3RpbWVzXCIsXCLiprpcIjpcIlwiLFwi4qa5XCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qa4XCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qa3XCI6XCJcXFxcb21pbnVzXCIsXCLiprZcIjpcIlxcXFxvbWludXNcIixcIuKmtVwiOlwiXFxcXG9taW51c1wiLFwi4qa0XCI6XCJcXFxcdmVje1xcXFx2YXJub3RoaW5nfVwiLFwi4qazXCI6XCJcXFxcdmVje1xcXFx2YXJub3RoaW5nfVwiLFwi4qayXCI6XCJcXFxcZG90e1xcXFx2YXJub3RoaW5nfVwiLFwi4qaxXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHZhcm5vdGhpbmd9XCIsXCLiprBcIjpcIlxcXFx2YXJub3RoaW5nXCIsXCLipq9cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq5cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq1cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqxcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqpcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqlcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqhcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqdcIjpcIlwiLFwi4qamXCI6XCJcIixcIuKmpVwiOlwiXCIsXCLipqRcIjpcIlwiLFwi4qajXCI6XCJcXFxcdWxjb3JuZXJcIixcIuKmolwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmoVwiOlwiXFxcXG5vdFxcXFxsb3JcIixcIuKmoFwiOlwiXFxcXGJjYW5jZWx7Pn1cIixcIuKmglwiOlwiOlwiLFwi4qaBXCI6XCJcXFxcY2RvdFwiLFwi4p2YXCI6XCJcXFxcbWlkXCIsXCLilrJcIjpcIlxcXFxiaWd0cmlhbmdsZXVwXCIsXCLii79cIjpcIlxcXFxFcHNpbG9uXCIsXCLii75cIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCLii71cIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCLii7xcIjpcIlxcXFxpblwiLFwi4ou7XCI6XCJcXFxcaW5cIixcIuKLulwiOlwiXFxcXGluXCIsXCLii7lcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGlufVwiLFwi4ou4XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIuKLt1wiOlwiXFxcXG92ZXJsaW5le1xcXFxpbn1cIixcIuKLtlwiOlwiXFxcXG92ZXJsaW5le1xcXFxpbn1cIixcIuKLtVwiOlwiXFxcXGRvdHtcXFxcaW59XCIsXCLii7RcIjpcIlxcXFxpblwiLFwi4ouzXCI6XCJcXFxcaW5cIixcIuKLslwiOlwiXFxcXGluXCIsXCLii7BcIjpcIlxcXFxkZG90c1wiLFwi1olcIjpcIjpcIixcIuKLqVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdWNjfVwiLFwi4ouoXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHByZWN9XCIsXCLii6dcIjpcIlxcXFx1bmRlcnNldHtcXFxcbm90XFxcXHNpbX17Pn1cIixcIuKLplwiOlwiXFxcXHVuZGVyc2V0e1xcXFxub3RcXFxcc2ltfXs8fVwiLFwi4oulXCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIuKLpFwiOlwiXFxcXG5vdFxcXFxzcXN1YnNldGVxXCIsXCLii6NcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRlcVwiLFwi4ouiXCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0ZXFcIixcIuKLoVwiOlwiXFxcXG5zdWNjXCIsXCLii6BcIjpcIlxcXFxucHJlY1wiLFwi4oufXCI6XCJcXFxcc3VjY1wiLFwi4oueXCI6XCJcXFxccHJlY1wiLFwi4oudXCI6XCJcXFxcb3ZlcmxpbmV7Pn1cIixcIuKLnFwiOlwiXFxcXG92ZXJsaW5lezx9XCIsXCLii5tcIjpcIlxcXFx1bmRlcnNldHs+fXtcXFxcbGVxfVwiLFwi4ouaXCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGdlcX1cIixcIuKLlVwiOlwiXFxcXCNcIixcIuKLk1wiOlwiXFxcXGN1cFwiLFwi4ouSXCI6XCJcXFxcY2FwXCIsXCLii5FcIjpcIlxcXFxzdXBzZXRcIixcIuKLkFwiOlwiXFxcXHN1YnNldFwiLFwi4ouPXCI6XCJcXFxcd2VkZ2VcIixcIuKLjlwiOlwiXFxcXHZlZVwiLFwi4ouNXCI6XCJcXFxcc2ltZXFcIixcIuKLiFwiOlwiXFxcXEpvaW5cIixcIuKLh1wiOlwiXFxcXGFzdFwiLFwi4ouGXCI6XCJcXFxcc3RhclwiLFwi4ouEXCI6XCJcXFxcZGlhbW9uZFwiLFwi4oq/XCI6XCJcXFxcdHJpYW5nbGVcIixcIuKKvlwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKKvVwiOlwiXFxcXG92ZXJsaW5le1xcXFxsb3J9XCIsXCLiirxcIjpcIlxcXFxvdmVybGluZXtcXFxcbGFuZH1cIixcIuKKu1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbG9yfVwiLFwi4oq6XCI6XCJcXFxcdG9wXCIs5ZyfOlwiXFxcXHBtXCIs5Y2BOlwiK1wiLFwi4oq5XCI6XCJcIixcIuKKt1wiOlwiXFxcXGNpcmNcXFxcbXVsdGltYXBcIixcIuKKtlwiOlwiXFxcXGNpcmNcXFxcbXVsdGltYXBcIixcIuKKs1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKKslwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4oqxXCI6XCJcXFxcc3VjY1wiLFwi4oqwXCI6XCJcXFxccHJlY1wiLFwi4oqrXCI6XCJ8XFxcXG1vZGVsc1wiLFwi4oqqXCI6XCJ8XFxcXG1vZGVsc1wiLFwi4oqnXCI6XCJcXFxcbW9kZWxzXCIsXCLiiqZcIjpcIlxcXFx2ZGFzaFwiLFwi4oqdXCI6XCJcXFxcb21pbnVzXCIsXCLiipxcIjpcIlxcXFxvbWludXNcIixcIuKKm1wiOlwiXFxcXG9kb3RcIixcIuKKmlwiOlwiXFxcXG9kb3RcIixcIuKKlFwiOlwiXFxcXHNxY3VwXCIsXCLiipNcIjpcIlxcXFxzcWNhcFwiLFwi4oqSXCI6XCJcXFxcc3FzdXBzZXRlcVwiLFwi4oqRXCI6XCJcXFxcc3FzdWJzZXRlcVwiLFwi4oqQzLhcIjpcIlxcXFxub3RcXFxcc3FzdXBzZXRcIixcIuKKkFwiOlwiXFxcXHNxc3Vwc2V0XCIsXCLiio/MuFwiOlwiXFxcXG5vdFxcXFxzcXN1YnNldFwiLFwi4oqPXCI6XCJcXFxcc3FzdWJzZXRcIixcIuKKjlwiOlwiXFxcXGN1cFwiLFwi4oqNXCI6XCJcXFxcY3VwXCIsXCLiioxcIjpcIlxcXFxjdXBcIixcIuKJv8y4XCI6XCJcXFxcbm90XFxcXHN1Y2NzaW1cIixcIuKJv1wiOlwiXFxcXHN1Y2NzaW1cIixcIuKJvlwiOlwiXFxcXHByZWNzaW1cIixcIuKJuVwiOlwiXFxcXG5vdFxcXFxvdmVyc2V0ez59ezx9XCIsXCLiibhcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwi4om3XCI6XCJcXFxcb3ZlcnNldHs+fXs8fVwiLFwi4om2XCI6XCJcXFxcb3ZlcnNldHs8fXs+fVwiLFwi4om1XCI6XCJcXFxcbm90XFxcXGdlZ1wiLFwi4om0XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwi4omzXCI6XCJcXFxcZ2VnXCIsXCLiibJcIjpcIlxcXFxsZXFcIixcIuKJrFwiOlwiXCIsXCLiiadcIjpcIlxcXFxnZWdcIixcIuKJpsy4XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwi4ommXCI6XCJcXFxcbGVxXCIsXCLiiaNcIjpcIlxcXFxvdmVyc2V0ez19ez19IFwiLFwi4omeXCI6XCJcXFxcb3ZlcnNldHttfXs9fSBcIixcIuKJnVwiOlwiXFxcXG92ZXJzZXR7ZGVmfXs9fVwiLFwi4omYXCI6XCI9XCIsXCLiiZZcIjpcIj1cIixcIuKJlVwiOlwiPTpcIixcIuKJk1wiOlwiXFxcXGRvdGVxXCIsXCLiiZJcIjpcIlxcXFxkb3RlcVwiLFwi4omRXCI6XCJcXFxcZG90ZXFcIixcIuKJkFwiOlwiXFxcXGRvdGVxXCIsXCLiiY/MuFwiOlwiXCIsXCLiiY9cIjpcIlwiLFwi4omOzLhcIjpcIlwiLFwi4omOXCI6XCJcIixcIuKJjFwiOlwiXFxcXGFwcHJveFwiLFwi4omLXCI6XCJcXFxcYXBwcm94XCIsXCLiiYpcIjpcIlxcXFxhcHByb3hcIixcIuKJgsy4XCI6XCJcXFxcbmVxXCIsXCLiiYJcIjpcIj1cIixcIuKIv1wiOlwiXFxcXHNpbVwiLFwi4oi+XCI6XCJcXFxcaW5mdHlcIixcIuKIvcyxXCI6XCJcXFxcc2ltXCIsXCLiiL1cIjpcIlxcXFxzaW1cIixcIuKIu1wiOlwiXFxcXHNpbVwiLFwi4oi6XCI6XCI6LTpcIixcIuKIuVwiOlwiLTpcIixcIuKIuFwiOlwiXFxcXGJvdFwiLFwi4oi3XCI6XCI6OlwiLFwi4oi2XCI6XCI6XCIsXCLiiKNcIjpcIlxcXFxtaWRcIixcIuKIn1wiOlwiXFxcXGxsY29ybmVyXCIsXCLiiJhcIjpcIlxcXFxjaXJjXCIsXCLiiJdcIjpcIipcIixcIuKIlVwiOlwiL1wiLFwi4oiOXCI6XCJcXFxcc3F1YXJlXCIsXCLiiI1cIjpcIlxcXFxuaVwiLFwi4oiKXCI6XCJcXFxcaW5cIixcIuKIhlwiOlwiXFxcXERlbHRhXCIsXCLigYRcIjpcIi9cIixcIuKqsMy4XCI6XCJcXFxcbnN1Y2NlcVwiLFwi4qqwXCI6XCJcXFxcc3VjY2VxXCIsXCLiqq/MuFwiOlwiXFxcXG5wcmVjZXFcIixcIuKqr1wiOlwiXFxcXHByZWNlcVwiLFwi4qqIXCI6XCJcXFxcbmdlcXNsYW50XCIsXCLiqodcIjpcIlxcXFxubGVxc2xhbnRcIixcIuKns1wiOlwiXFxcXFBoaVwiLFwi4qemXCI6XCJcXFxcbW9kZWxzXCIsXCLip6VcIjpcIlxcXFxub3RcXFxcZXF1aXZcIixcIuKnpFwiOlwiXFxcXGFwcHJveFxcXFxuZXFcIixcIuKno1wiOlwiXFxcXG5lcVwiLFwi4qeBXCI6XCJcXFxcY2lyY2xlXCIsXCLip4BcIjpcIlxcXFxjaXJjbGVcIixcIuKXplwiOlwiXFxcXGNpcmNsZVwiLFwi4peXXCI6XCJcXFxcY2lyY2xlXCIsXCLil5ZcIjpcIlxcXFxjaXJjbGVcIixcIuKXj1wiOlwiXFxcXGNpcmNsZVwiLFwi4peOXCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIuKXjVwiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCLil4xcIjpcIlxcXFxjaXJjbGVkY2lyY1wiLFwi4peJXCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIuKXiFwiOlwiXFxcXGRpYW1vbmRcIixcIuKXh1wiOlwiXFxcXGRpYW1vbmRcIixcIuKXhlwiOlwiXFxcXGRpYW1vbmRcIixcIuKXhVwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peEXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLil4NcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKXglwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peBXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLil4BcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKWv1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwi4pa+XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCLilr1cIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIuKWvFwiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwi4pa5XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa4XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa3XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa2XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwi4pa1XCI6XCJcXFxcdHJpYW5nbGVcIixcIuKWtFwiOlwiXFxcXHRyaWFuZ2xlXCIsXCLilrNcIjpcIlxcXFx0cmlhbmdsZVwiLFwi4paxXCI6XCJcXFxcc3F1YXJlXCIsXCLilrBcIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4pavXCI6XCJcXFxcc3F1YXJlXCIsXCLilq5cIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4patXCI6XCJcXFxcc3F1YXJlXCIsXCLilqtcIjpcIlxcXFxzcXVhcmVcIixcIuKWqlwiOlwiXFxcXHNxdWFyZVwiLFwi4pahXCI6XCJcXFxcc3F1YXJlXCIsXCLilqBcIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4outXCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKLrFwiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnRcIixcIuKLq1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLii6pcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0XCIsXCLii5lcIjpcIlxcXFxnZ2dcIixcIuKLmFwiOlwiXFxcXGxsbFwiLFwi4ouXXCI6XCIqPlwiLFwi4ouWXCI6XCI8KlwiLFwi4ouUXCI6XCJcXFxccGl0Y2hmb3JrXCIsXCLii4xcIjpcIlwiLFwi4ouLXCI6XCJcXFxcYm93dGllXCIsXCLii4pcIjpcIlxcXFxsdGltZXNcIixcIuKLiVwiOlwiXFxcXHJ0aW1lc1wiLFwi4oq1XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiXFxcXHRyaWFuZ2xlbGVmdFwiOlwiXCIsXCLiiqVcIjpcIlxcXFxib3RcIixcIuKKgVwiOlwiXFxcXG5zdWNjXCIsXCLiioBcIjpcIlxcXFxwcmVjZXFcIixcIuKJvVwiOlwiXFxcXHN1Y2NlcVwiLFwi4om8XCI6XCJcXFxccHJlY2VxXCIsXCLiibtcIjpcIlxcXFxzdWNjXCIsXCLiibpcIjpcIlxcXFxwcmVjXCIsXCLiibFcIjpcIlxcXFxnZXEvXCIsXCLiibBcIjpcIlxcXFxsZXEvXCIsXCLiia1cIjpcIlxcXFxuZXFcIixcIuKJq8y4XCI6XCJcXFxcbm90XFxcXGdnXCIsXCLiiatcIjpcIlxcXFxnZ1wiLFwi4omqzLhcIjpcIlxcXFxub3RcXFxcbGxcIixcIuKJqlwiOlwiXFxcXGxsXCIsXCLiialcIjpcIlxcXFxuZ2Vxc2xhbnRcIixcIuKJqFwiOlwiXFxcXG5sZXFzbGFudFwiLFwi4omhXCI6XCJcXFxcZXF1aXZcIixcIuKJn1wiOlwiXFxcXGRvdGVxXCIsXCLiiZxcIjpcIlxcXFx0cmlhbmdsZXFcIixcIuKJm1wiOlwiXFxcXGRvdGVxXCIsXCLiiZpcIjpcIlxcXFx0cmlhbmdsZXFcIixcIuKJmVwiOlwiXFxcXHRyaWFuZ2xlcVwiLFwi4omXXCI6XCJcXFxcZG90ZXFcIixcIuKJlFwiOlwiOj1cIixcIuKJjVwiOlwiXFxcXGFzeW1wXCIsXCLiiYdcIjpcIlxcXFxuY29uZ1wiLFwi4omGXCI6XCJcXFxcbmNvbmdcIixcIuKJhVwiOlwiXFxcXGNvbmdcIixcIuKJhFwiOlwiXFxcXG5vdFxcXFxzaW1lcVwiLFwi4omDXCI6XCJcXFxcc2ltZXFcIixcIuKJgVwiOlwiXFxcXG5vdFxcXFxzaW1cIixcIuKIplwiOlwiXFxcXG5vdFxcXFxwYXJhbGxlbFwiLFwi4oilXCI6XCJcXFxccGFyYWxsZWxcIixcIuKIpFwiOlwiXFxcXG5vdHxcIixcIuKInVwiOlwiXFxcXHByb3B0b1wiLFwiPT1cIjpcIj09XCIsXCI9XCI6XCI9XCIsXCI6PVwiOlwiOj1cIixcIi89XCI6XCI9XCIsXCItPVwiOlwiLT1cIixcIis9XCI6XCIrPVwiLFwiKj1cIjpcIio9XCIsXCIhPVwiOlwiIT1cIixcIuKJoFwiOlwiXFxcXG5lcVwiLFwi4omiXCI6XCJcXFxcZXF1aXYgL1wiLFwi4omJXCI6XCJcXFxcYXBwcm94IC9cIixcIuKIvFwiOlwic2ltXCIsXCLiiYhcIjpcIlxcXFxhcHByb3hcIixcIuKJrlwiOlwiPC9cIixcIjxcIjpcIjxcIixcIuKJr1wiOlwiPi9cIixcIj49XCI6XCI+PVwiLFwiPlwiOlwiPlwiLFwi4omlXCI6XCJcXFxcZ2VxXCIsXCLiiaRcIjpcIlxcXFxsZXFcIixcIjw9XCI6XCI8PVwiLFwi4oqLXCI6XCJcXFxcc3Vwc2V0bmVxXCIsXCLiiopcIjpcIlxcXFxzdWJzZXRuZXFcIixcIuKKiVwiOlwiXFxcXG5zdXBzZXRlcVwiLFwi4oqIXCI6XCJcXFxcbnN1YnNldGVxXCIsXCLiiodcIjpcIlxcXFxzdXBzZXRlcVwiLFwi4oqGXCI6XCJcXFxcc3Vic2V0ZXFcIixcIuKKhVwiOlwiXFxcXG5vdFxcXFxzdXBzZXRcIixcIuKKhFwiOlwiXFxcXG5vdFxcXFxzdWJzZXRcIixcIuKKg+KDklwiOlwiXFxcXHN1cHNldCB8XCIsXCLiioNcIjpcIlxcXFxzdXBzZXRcIixcIuKKguKDklwiOlwiXFxcXHN1YnNldCB8XCIsXCLiioJcIjpcIlxcXFxzdWJzZXRcIixcIuKIjFwiOlwiXFxcXG5vdFxcXFxpblwiLFwi4oiJXCI6XCJcXFxcbm90aW5cIixcIuKIiFwiOlwiXFxcXGluXCIsXCLiiIFcIjpcIkNcIixcIuKIhFwiOlwiXFxcXG5leGlzdHNcIixcIuKIg1wiOlwiXFxcXGV4aXN0c1wiLFwi4oiAXCI6XCJcXFxcZm9yYWxsXCIsXCLiiKdcIjpcIlxcXFxsYW5kXCIsXCImJlwiOlwiXFxcXCZcXFxcJlwiLFwi4oioXCI6XCJcXFxcbG9yXCIsXCLiiq9cIjpcIlxcXFxjYW5jZWx7XFxcXHZEYXNofVwiLFwi4oquXCI6XCJcXFxcY2FuY2Vse1xcXFxWZGFzaH1cIixcIuKKrVwiOlwiXFxcXG52RGFzaFwiLFwi4oqsXCI6XCJcXFxcbnZEYXNoXCIsXCLiiqlcIjpcIlxcXFxWZGFzaFwiLFwi4oqoXCI6XCJcXFxcdkRhc2hcIixcIuKKpFwiOlwiXFxcXHRvcFwiLFwi4oqjXCI6XCJcXFxcZGFzaHZcIixcIuKKolwiOlwiXFxcXHZkYXNoXCIsXCLiiItcIjpcIlxcXFxuaVwiLFwi4ouxXCI6XCJcXFxcZGRvdHNcIixcIuKLr1wiOlwiXFxcXGhkb3RzXCIsXCLii65cIjpcIlxcXFx2ZG90c1wiLFwiz7ZcIjpcIlxcXFxuaVwiLFwiOlwiOlwiOlwiLFwiLi4uXCI6XCJcXFxcY2RvdHNcIixcIi4uXCI6XCIuLlwiLFwiLT5cIjpcIi0+XCIsXCLiiLVcIjpcIlxcXFxiZWNhdXNlXCIsXCLiiLRcIjpcIlxcXFx0aGVyZWZvcmUgXCIsXCLigaNcIjpcIlxcXFxsbGJyYWNrZXRcIixcIixcIjpcIixcIixcIjtcIjpcIjtcIixcIuKnvVwiOlwiXFxcXH1cIixcIuKnvFwiOlwiXFxcXHtcIixcIuKmmFwiOlwiXFxcXF1cIixcIuKml1wiOlwiXFxcXFtcIixcIuKmllwiOlwiXFxcXGxsXCIsXCLippVcIjpcIlxcXFxnZ1wiLFwi4qaUXCI6XCJcXFxcZ2dcIixcIuKmk1wiOlwiXFxcXGxsXCIsXCLippJcIjpcIlxcXFxnZ1wiLFwi4qaRXCI6XCJcXFxcbGxcIixcIuKmkFwiOlwiXFxcXF1cIixcIuKmj1wiOlwiXFxcXF1cIixcIuKmjlwiOlwiXFxcXF1cIixcIuKmjVwiOlwiXFxcXFtcIixcIuKmjFwiOlwiXFxcXFtcIixcIuKmi1wiOlwiXFxcXF1cIixcIuKmilwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKmiVwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4qaIXCI6XCJ8XFxcXClcIixcIuKmh1wiOlwiXFxcXCh8XCIsXCLipoZcIjpcInxcXFxcKVwiLFwi4qaFXCI6XCJcXFxcKFxcXFwoXCIsXCLipoRcIjpcInxcXFxcfVwiLFwi4qaDXCI6XCJcXFxce3xcIixcIuKmgFwiOlwiXFxcXHx8XCIsXCLin69cIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXCIsXCLin65cIjpcIlxcXFxsZWZ0WyBcXFxccmlnaHQuXCIsXCLin61cIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXVwiLFwi4p+sXCI6XCJcXFxcbGVmdFtbIFxcXFxyaWdodC5cIixcIuKfq1wiOlwiXFxcXGdnXCIsXCLin6pcIjpcIlxcXFxsbFwiLFwi4p+nXCI6XCJcXFxcKXxcIixcIuKfplwiOlwiXFxcXCh8XCIsXCLinbNcIjpcIlxcXFxsZWZ0LlxcXFxyaWdodClcIixcIuKdslwiOlwiXFxcXGxlZnQoXFxcXHJpZ2h0LlwiLFwi4oyqXCI6XCJcXFxccmFuZ2xlXCIsXCLijKlcIjpcIlxcXFxsYW5nbGVcIixcIuKMi1wiOlwiXFxcXHJmbG9vclwiLFwi4oyKXCI6XCJcXFxcbGZsb29yXCIsXCLijIlcIjpcIlxcXFxyY2VpbFwiLFwi4oyIXCI6XCJcXFxcbGNlaWxcIixcIuKAllwiOlwiXFxcXHBhcmFsbGVsXCIsXCJ9XCI6XCJcXFxcbGVmdC5cXFxccmlnaHR9XCIsXCJ7XCI6XCJcXFxcbGVmdHtcXFxccmlnaHQuXCIsXCJdXCI6XCJcXFxcbGVmdF1cXFxccmlnaHQuXCIsXCJbXCI6XCJcXFxcbGVmdFtcXFxccmlnaHQuXCIsXCIpXCI6XCJcXFxcbGVmdC5cXFxccmlnaHQpXCIsXCIoXCI6XCJcXFxcbGVmdChcXFxccmlnaHQuXCIsXCLigJ1cIjonXFxcXFwiJyxcIuKAnFwiOlwiXFxcXHRleHR7YGB9XCIsXCLigJlcIjpcIidcIixcIuKAmFwiOlwiYFwiLM6xOlwiXFxcXGFscGhhXCIszrI6XCJcXFxcYmV0YVwiLM6zOlwiXFxcXGdhbW1hXCIszpM6XCJcXFxcR2FtbWFcIizOtDpcIlxcXFxkZWx0YVwiLM6UOlwiXFxcXERlbHRhXCIsz7U6XCJcXFxcZXBzaWxvblwiLM62OlwiXFxcXHpldGFcIizOtzpcIlxcXFxldGFcIizOuDpcIlxcXFx0aGV0YVwiLM6YOlwiXFxcXFRoZXRhXCIszrk6XCJcXFxcaW90YVwiLM66OlwiXFxcXGthcHBhXCIszrs6XCJcXFxcbGFtYmRhXCIszr06XCJcXFxcbnVcIizOvzpcIlxcXFxvbWljcm9uXCIsz4A6XCJcXFxccGlcIizOoDpcIlxcXFxQaVwiLM+BOlwiXFxcXHJob1wiLM+DOlwiXFxcXHNpZ21hXCIszqM6XCJcXFxcU2lnbWFcIizPhDpcIlxcXFx0YXVcIizPhTpcIlxcXFx1cHNpbG9uXCIszqU6XCJcXFxcVXBzaWxvblwiLM+VOlwiXFxcXHBoaVwiLM6mOlwiXFxcXFBoaVwiLM+HOlwiXFxcXGNoaVwiLM+IOlwiXFxcXHBzaVwiLM6oOlwiXFxcXFBzaVwiLM+JOlwiXFxcXG9tZWdhXCIszqk6XCJcXFxcT21lZ2FcIizihKY6XCJcXFxcT21lZ2FcIixcIuKIhVwiOlwiXFxcXGVtcHR5c2V0XCIsXCLin7JcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKfs1wiOlwiXFxcXGNpcmNsZWFycm93cmlnaHRcIixcIsOXXCI6XCJcXFxcdGltZXNcIixcIsK9XCI6XCJcXFxcZGZyYWN7MX17Mn1cIizOvDpcIlxcXFxtdVwiLNOoOlwiXFxcXHRoZXRhXCIsXCLinJNcIjpcIlxcXFxjaGVja21hcmtcIixcIuKfqVwiOlwiXFxcXHJhbmdsZVwiLFwi4p+oXCI6XCJcXFxcbGFuZ2xlXCIsXCLCvFwiOlwiXFxcXGRmcmFjezF9ezR9XCIsXCLigKZcIjpcIlxcXFxsZG90c1wiLOKEjzpcIlxcXFxoYmFyXCIs4oScOlwiXFxcXG1hdGhmcmFre1J9XCIs0bI6XCJcXFxcdGhldGFcIizDmDpcIlxcXFxlbXB0eXNldFwiLM+xOlwiXFxcXHZhcnJob1wiLNGEOlwiXFxcXHBoaVwiLOKEhzpcIlxcXFx2YXJlcHNpbG9uXCIsVDpcIlRcIixcIuKImVwiOlwiXFxcXGNkb3RcIizOoTpcIlBcIixcIuKInlwiOlwiXFxcXGluZnR5XCIs4ZCBOlwiXFxcXG5hYmxhXCIsxp46XCJcXFxcZXRhXCIsXCLigbpcIjpcIl57K31cIixcIuKBu1wiOlwiXnstfVwiLFwi4oG8XCI6XCJeez19XCIsXCLigb1cIjpcIl57KH1cIixcIuKBvlwiOlwiXnspfVwiLFwi44CXXCI6XCJcXFxcKXxcIixcIuOAllwiOlwiXFxcXGxhbmdsZVwiLFwizb5cIjpcIjtcIixcIuC1plwiOlwiXFxcXGNpcmNcIixcIuKUtFwiOlwiXFxcXHBlcnBcIixcIuKclVwiOlwiXFxcXHRpbWVzXCIsXCLijrtcIjpcIi1cIixcIsK7XCI6XCJcXFxcZ2dcIixcIuKshlwiOlwiXFxcXHVwYXJyb3dcIixcIuKsh1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qyFXCI6XCJcXFxcbGVmdGFycm93XCIsXCLinqFcIjpcIlxcXFxyaWdodGFycm93XCIsXCLijrxcIjpcIi1cIixcIuKOnFwiOlwiXFxcXG1pZFwiLFwi4o6lXCI6XCJcXFxcbWlkXCIsxKc6XCJcXFxcaGJhclwiLFwi4q6VXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi44O7XCI6XCJcXFxcY2RvdFwiLFwiwqZcIjpcIlxcXFxtaWRcIixcIsKjXCI6XCJcXFxccG91bmRzXCIsXCLCpVwiOlwiXFxcXHllblwiLFwi4pyXXCI6XCJcXFxcdGltZXNcIixcIuKclFwiOlwiXFxcXGNoZWNrbWFya1wiLOKBvzpcIl57bn1cIixcIsKrXCI6XCJcXFxcbGxcIizguYA6XCJcXFxccHJpbWVcIixcIuKAoFwiOlwiXFxcXGRhZ2dlclwiLFwi4pSCXCI6XCJcXFxcbWlkXCIsJDpcIlxcXFwkXCIsXCIjXCI6XCJcXFxcI1wiLFwi4oSDXCI6XCJcXFxcdGV4dHtcXFxcdGV4dGRlZ3JlZSBDfVwiLFwi4oSJXCI6XCJcXFxcdGV4dHtcXFxcdGV4dGRlZ3JlZSBGfVwiLFwi4paIXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKEp1wiOlwiXFxcXG1ob1wiLOKFhzpcIlxcXFx0ZXh0e2V9XCIsybw6XCJyXCIsXCLigKFcIjpcIlxcXFxkZGFnZ2VyXCIs4byxOlwiaVwiLM+SOlwiXFxcXFVwc2lsb25cIizwnZu/OlwiXFxcXGRlbHRhXCIsXCLLs1wiOlwiXFxcXGNkb3RcIizRszpcIlxcXFx0aGV0YVwiLPCdnJk6XCJcXFxccGhpXCIs0J86XCJcXFxccHJvZFwiLNC+Olwib1wiLNGSOlwiXFxcXGhiYXJcIizJhTpcIlxcXFxMYW1iZGFcIixcIuClpFwiOlwiXFxcXG1pZFwiLFwi4oKsXCI6XCJcXFxcZXVyb1wiLOG/oTpcIlxcXFxiYXJ7dX1cIizPhjpcIlxcXFx2YXJwaGlcIizIvDpcImNcIizwnZ6uOlwiXFxcXGVwc2lsb25cIizOpzpcIlxcXFxtYXRoc2Z7WH1cIizigpk6XCJfe259XCJ9fSw4MjQ5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoU3ltYm9sc0J5Q2hhcj12b2lkIDAsdC5hbGxNYXRoU3ltYm9sc0J5Q2hhcj17XCImI3hBMDtcIjpcIlxcXFx0ZXh0cm17IH1cIixcIiYjeDIyMDM7XCI6XCJcXFxcZXhpc3RzXCIsXCImI3gyMjAwO1wiOlwiXFxcXGZvcmFsbFwiLFwiJiN4MjFENDtcIjpcIlxcXFxpZmZcIixcIiYjeDIxRDI7XCI6XCI9PlwiLFwiJiN4QUM7XCI6XCJcXFxcbmVnXCIsXCImI3gyMTI0O1wiOlwiXFxcXG1hdGhiYntafVwiLFwiJiN4MjExRDtcIjpcIlxcXFxtYXRoYmJ7Un1cIixcIiYjeDIxMUE7XCI6XCJcXFxcbWF0aGJie1F9XCIsXCImI3gyMTE1O1wiOlwiXFxcXG1hdGhiYntOfVwiLFwiJiN4MjEwMjtcIjpcIkNDXCIsXCImI3gyNUExO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjJDNDtcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyNUIzO1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyMzIyO1wiOlwiXFxcXGZyb3duXCIsXCImI3gyMjIwO1wiOlwiXFxcXGFuZ2xlXCIsXCImI3gyMkYxO1wiOlwiXFxcXGRkb3RzXCIsXCImI3gyMkVFO1wiOlwiXFxcXHZkb3RzXCIsXCImI3gyMjM1O1wiOlwiXFxcXGJlY2F1c2VcIixcIiYjeDIyMzQ7XCI6XCJcXFxcdGhlcmVmb3JlXCIsXCImI3gyMTM1O1wiOlwiXFxcXGFsZXBoXCIsXCImI3gyMjA1O1wiOlwiXFxcXG9zbGFzaFwiLFwiJiN4QjE7XCI6XCJcXFxccG1cIixcIiYjeDIyMDc7XCI6XCJcXFxcbmFibGFcIixcIiYjeDIyMDI7XCI6XCJcXFxccGFydGlhbFwiLFwiJiN4MjIyRTtcIjpcIlxcXFxvaW50XCIsXCImI3gyMjJCO1wiOlwiXFxcXGludFwiLFwiJiN4MjJDMztcIjpcIlxcXFxjdXBcIixcIiYjeDIyMkE7XCI6XCJcXFxcY3VwXCIsXCImI3gyMkMyO1wiOlwiXFxcXGNhcFwiLFwiJiN4MjIyOTtcIjpcIlxcXFxjYXBcIixcIiYjeDIyQzE7XCI6XCJcXFxcdmVlXCIsXCImI3gyMjI4O1wiOlwiXFxcXHZlZVwiLFwiJiN4MjJDMDtcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MjIyNztcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MjIwRjtcIjpcIlxcXFxwcm9kXCIsXCImI3gyMjExO1wiOlwiXFxcXHN1bVwiLFwiJiN4MjI5OTtcIjpcIlxcXFxiaWdvZG90XCIsXCImI3gyMjk3O1wiOlwiXFxcXGJpZ29wbHVzXCIsXCImI3gyMjk1O1wiOlwibytcIixcIiYjeDIyMTg7XCI6XCJAXCIsXCImI3gyMkM4O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjJDQTtcIjpcIlxcXFxydGltZXNcIixcIiYjeDIyQzk7XCI6XCJcXFxcbHRpbWVzXCIsXCImI3hGNztcIjpcIlxcXFxkaXZcIixcIiYjeEQ3O1wiOlwiXFxcXHRpbWVzXCIsXCJcXFxcXCI6XCJcXFxcYmFja3NsYXNoXCIsXCImI3gyMkM2O1wiOlwiXFxcXHN0YXJcIixcIiYjeDIyMTc7XCI6XCJcXFxcc3RhclwiLFwiJiN4MjJDNTtcIjpcIlxcXFxjZG90XCIsXCImI3gzQTk7XCI6XCJcXFxcT21lZ2FcIixcIiYjeDNDOTtcIjpcIlxcXFxvbWVnYVwiLFwiJiN4M0E4O1wiOlwiXFxcXFBzaVwiLFwiJiN4M0M4O1wiOlwiXFxcXHBzaVwiLFwiJiN4M0M3O1wiOlwiXFxcXGNoaVwiLFwiJiN4M0M2O1wiOlwiXFxcXHZhcnBoaVwiLFwiJiN4M0E2O1wiOlwiXFxcXFBoaVwiLFwiJiN4M0Q1O1wiOlwiXFxcXHBoaVwiLFwiJiN4M0M1O1wiOlwiXFxcXHVwc2lsb25cIixcIiYjeDNDNDtcIjpcIlxcXFx0YXVcIixcIiYjeDNBMztcIjpcIlxcXFxTaWdtYVwiLFwiJiN4M0MzO1wiOlwiXFxcXHNpZ21hXCIsXCImI3gzQzE7XCI6XCJcXFxccmhvXCIsXCImI3gzQTA7XCI6XCJcXFxcUGlcIixcIiYjeDNDMDtcIjpcIlxcXFxwaVwiLFwiJiN4MzlFO1wiOlwiXFxcXFhpXCIsXCImI3gzQkU7XCI6XCJcXFxceGlcIixcIiYjeDNCRDtcIjpcIlxcXFxudVwiLFwiJiN4M0JDO1wiOlwiXFxcXG11XCIsXCImI3gzOUI7XCI6XCJcXFxcTGFtYmRhXCIsXCImI3gzQkI7XCI6XCJcXFxcbGFtYmRhXCIsXCImI3gzQkE7XCI6XCJcXFxca2FwcGFcIixcIiYjeDNCOTtcIjpcIlxcXFxpb3RhXCIsXCImI3gzRDE7XCI6XCJcXFxcdmFydGhldGFcIixcIiYjeDM5ODtcIjpcIlxcXFxUaGV0YVwiLFwiJiN4M0I4O1wiOlwiXFxcXHRoZXRhXCIsXCImI3gzQjc7XCI6XCJcXFxcZXRhXCIsXCImI3gzQjY7XCI6XCJcXFxcemV0YVwiLFwiJiN4MjVCO1wiOlwiXFxcXHZhcmVwc2lsb25cIixcIiYjeDNCNTtcIjpcIlxcXFxlcHNpbG9uXCIsXCImI3gzOTQ7XCI6XCJcXFxcRGVsdGFcIixcIiYjeDNCNDtcIjpcIlxcXFxkZWx0YVwiLFwiJiN4MzkzO1wiOlwiXFxcXEdhbW1hXCIsXCImI3gzQjM7XCI6XCJcXFxcZ2FtbWFcIixcIiYjeDNCMjtcIjpcIlxcXFxiZXRhXCIsXCImI3gzQjE7XCI6XCJcXFxcYWxwaGFcIixcIiYjeDIyMUU7XCI6XCJcXFxcaW5mdHlcIixcIuKArFwiOlwiXFxcXHRleHR7XFxcXHRleHRkaXIgVFJUfVwiLFwi4oCOXCI6XCJcXFxcdGV4dHtcXFxcdGV4dGRpciBMVFJ9XCJ9fSw4MTcxOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoU3ltYm9sc0J5R2x5cGg9dm9pZCAwLHQuYWxsTWF0aFN5bWJvbHNCeUdseXBoPXtcIiBcIjpcIlxcXFx0ZXh0cm17IH1cIixcIuKIg1wiOlwiXFxcXGV4aXN0c1wiLFwi4oiAXCI6XCJcXFxcZm9yYWxsXCIsXCLih5RcIjpcIlxcXFxpZmZcIixcIuKHklwiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIsKsXCI6XCJcXFxcbmVnXCIsXCLilqFcIjpcIlxcXFxzcXVhcmVcIixcIuKLhFwiOlwiXFxcXGRpYW1vbmRcIixcIuKWs1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCLijKJcIjpcIlxcXFxmcm93blwiLFwi4oigXCI6XCJcXFxcYW5nbGVcIixcIuKLsVwiOlwiXFxcXGRkb3RzXCIsXCLii65cIjpcIlxcXFx2ZG90c1wiLFwi4oi1XCI6XCJcXFxcYmVjYXVzZVwiLFwi4oi0XCI6XCJcXFxcdGhlcmVmb3JlXCIs4oS1OlwiXFxcXGFsZXBoXCIsXCLiiIVcIjpcIlxcXFxlbXB0eXNldFwiLFwiwrFcIjpcIlxcXFxwbVwiLFwi4oiHXCI6XCJcXFxcbmFibGFcIixcIuKIglwiOlwiXFxcXHBhcnRpYWxcIixcIuKIrlwiOlwiXFxcXG9pbnRcIixcIuKIq1wiOlwiXFxcXGludFwiLFwi4ouDXCI6XCJcXFxcY3VwXCIsXCLiiKpcIjpcIlxcXFxjdXBcIixcIuKLglwiOlwiXFxcXGNhcFwiLFwi4oipXCI6XCJcXFxcY2FwXCIsXCLii4FcIjpcIlxcXFx2ZWVcIixcIuKIqFwiOlwiXFxcXHZlZVwiLFwi4ouAXCI6XCJcXFxcd2VkZ2VcIixcIuKIp1wiOlwiXFxcXHdlZGdlXCIsXCLiiI9cIjpcIlxcXFxwcm9kXCIsXCLiiJFcIjpcIlxcXFxzdW1cIixcIuKKmVwiOlwiXFxcXGJpZ29kb3RcIixcIuKKl1wiOlwiXFxcXGJpZ29wbHVzXCIsXCLiipVcIjpcIm8rXCIsXCLiiJhcIjpcIkBcIixcIuKLiFwiOlwiXFxcXGJvd3RpZVwiLFwi4ouKXCI6XCJcXFxccnRpbWVzXCIsXCLii4lcIjpcIlxcXFxsdGltZXNcIixcIsO3XCI6XCJcXFxcZGl2XCIsXCLDl1wiOlwiXFxcXHRpbWVzXCIsXCJcXFxcXCI6XCJcXFxcYmFja3NsYXNoXCIsXCLii4ZcIjpcIlxcXFxzdGFyXCIsXCLiiJdcIjpcIlxcXFxzdGFyXCIsXCLii4VcIjpcIlxcXFxjZG90XCIszqk6XCJcXFxcT21lZ2FcIizPiTpcIlxcXFxvbWVnYVwiLM6oOlwiXFxcXFBzaVwiLM+IOlwiXFxcXHBzaVwiLM+HOlwiXFxcXGNoaVwiLM+GOlwiXFxcXHZhcnBoaVwiLM6mOlwiXFxcXFBoaVwiLM+VOlwiXFxcXHBoaVwiLM+FOlwiXFxcXHVwc2lsb25cIizPhDpcIlxcXFx0YXVcIizOozpcIlxcXFxTaWdtYVwiLM+DOlwiXFxcXHNpZ21hXCIsz4E6XCJcXFxccmhvXCIszqA6XCJcXFxcUGlcIizPgDpcIlxcXFxwaVwiLM6eOlwiXFxcXFhpXCIszr46XCJcXFxceGlcIizOvTpcIlxcXFxudVwiLM68OlwiXFxcXG11XCIszps6XCJcXFxcTGFtYmRhXCIszrs6XCJcXFxcbGFtYmRhXCIszro6XCJcXFxca2FwcGFcIizOuTpcIlxcXFxpb3RhXCIsz5E6XCJcXFxcdmFydGhldGFcIizOmDpcIlxcXFxUaGV0YVwiLM64OlwiXFxcXHRoZXRhXCIszrc6XCJcXFxcZXRhXCIszrY6XCJcXFxcemV0YVwiLMmbOlwiXFxcXHZhcmVwc2lsb25cIizOtTpcIlxcXFxlcHNpbG9uXCIszpQ6XCJcXFxcRGVsdGFcIizOtDpcIlxcXFxkZWx0YVwiLM6TOlwiXFxcXEdhbW1hXCIszrM6XCJcXFxcZ2FtbWFcIizOsjpcIlxcXFxiZXRhXCIszrE6XCJcXFxcYWxwaGFcIixcIuKInlwiOlwiXFxcXGluZnR5XCIsz7U6XCJcXFxcZXBzaWxvblwiLMK1OlwiXFxcXG11XCIsXCLCslwiOlwiXnsyfVwiLMSxOlwiXFxcXGltYXRoXCIsXCLiiI5cIjpcIlxcXFxibGFja3NxdWFyZVwiLOC4oTpcIlxcXFxtYXRoYmZ7bX1cIizihKY6XCJcXFxcT21lZ2FcIixcIuKfslwiOlwiXFxcXGNpcmNsZWFycm93bGVmdFwiLFwi4p+zXCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLOCkpDpcIiBcIixcIsKlXCI6XCJcXFxceWVuXCIsXCLigb1cIjpcIl57KH1cIixcIuKBvlwiOlwiXnspfVwiLMOfOlwiXFxcXHNzXCIs0Is6XCJcXFxcaGJhclwiLFwi4qa1XCI6XCJcXFxcb21pbnVzXCIsXCLiir9cIjpcIlxcXFxiaWd0cmlhbmdsZXVwXCIsXCLihpsnXCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIuKAoFwiOlwiXFxcXGRhZ2dlclwiLOC5gDpcIlxcXFxwcmltZVwiLOeZvTpcIiBcIixcIuK/sVwiOlwiIFwiLOKEuDpcIlxcXFx3cFwiLO2TsDpcIiBcIizigb86XCJee259XCIsXCLinJRcIjpcIlxcXFxjaGVja21hcmtcIixcIuKcl1wiOlwiXFxcXHRpbWVzXCIsXCLCvVwiOlwiXFxcXGRmcmFjezF9ezJ9XCIs06g6XCJcXFxcdGhldGFcIixcIuKck1wiOlwiXFxcXGNoZWNrbWFya1wiLFwi4p+pXCI6XCJcXFxccmFuZ2xlXCIsXCLin6hcIjpcIlxcXFxsYW5nbGVcIixcIuKMqVwiOlwiXFxcXGxhbmdsZVwiLFwiwrxcIjpcIlxcXFxkZnJhY3sxfXs0fVwiLFwi4oCmXCI6XCJcXFxcbGRvdHNcIizihI86XCJcXFxcaGJhclwiLOKEnDpcIlxcXFxtYXRoZnJha3tSfVwiLNGyOlwiXFxcXHRoZXRhXCIsw5g6XCJcXFxcZW1wdHlzZXRcIizPsTpcIlxcXFx2YXJyaG9cIizRhDpcIlxcXFxwaGlcIixUOlwiVFwiLFwi4oiZXCI6XCJcXFxcY2RvdFwiLM6hOlwiUFwiLOGQgTpcIlxcXFxuYWJsYVwiLMaeOlwiXFxcXGV0YVwiLMmjOlwiXFxcXGdhbW1hXCIs0Zs6XCJcXFxcaGJhclwiLMaQOlwiXFxcXHZhcmVwc2lsb25cIizihYU6XCJcXFxcX3tEfVwiLPCdnIY6XCJcXFxcbGFtYmRhXCIsXCLjgJdcIjpcIlxcXFxyYW5nbGVcIixcIuOAllwiOlwiXFxcXGxhbmdsZVwiLFwizb5cIjpcIjtcIizwnZGlOlwieFwiLPCdkaY6XCJ5XCIs8J2RpzpcInpcIizwnZGWOlwiaVwiLPCdkZc6XCJqXCIs8J2RmDpcImtcIizwnZGaOlwibVwiLPCdkZI6XCJlXCIs8J2RnzpcInJcIizJszpcIlxcXFxldGFcIizwnZu9OlwiXFxcXGJldGFcIixcIuKNtVwiOlwiXFxcXG9tZWdhXCIs4oSYOlwiXFxcXHdwXCIs8J2cizpcIlxcXFxwaVwiLNCEOlwiXFxcXGVwc2lsb25cIizRlDpcIlxcXFxlcHNpbG9uXCIs8J2cgDpcIlxcXFxlcHNpbG9uXCIs0L86XCJcXFxccGlcIizOnTpcIlxcXFxudVwiLMm1OlwiXFxcXHRoZXRhXCIs8J2ckzpcIlxcXFxwc2lcIizPtDpcIlxcXFx0aGV0YVwiLMm4OlwiXFxcXHBoaVwiLNO2OlwiXFxcXEdhbW1hXCIsya06XCJcXFxcZWxsXCIsyos6XCJcXFxcdXBzaWxvblwiLPCdm586XCJcXFxcdmFycGhpXCIsXCLijaxcIjpcIlxcXFx0aGV0YVwiLNCkOlwiXFxcXFBoaVwiLPCdnJE6XCJcXFxcdmFycGhpXCIs4oWIOlwiaVwiLM6/Olwib1wiLMahOlwib1wiLMaSOlwiZlwiLFwi4o20XCI6XCJcXFxccmhvXCIsXCLwn4e9XCI6XCJ4XCIs8J2RnTpcInBcIizwnZGeOlwicVwiLPCdkaA6XCJzXCIs8J2RoTpcInRcIizwnZGiOlwidVwiLPCdkaM6XCJ2XCIs8J2RpDpcIndcIizwnZGOOlwiYVwiLPCdkY86XCJiXCIs8J2RkDpcImNcIizwnZGROlwiZFwiLPCdkZM6XCJmXCIs8J2RlDpcImdcIizwnZGZOlwibFwiLPCdkZs6XCJuXCIs8J2RnDpcIm9cIizwnZSAOlwid1wiLPCdmp86XCJ2XCIs4bmBOlwibVwiLFwi4LWmXCI6XCJcXFxcY2lyY1wiLFwi4pS0XCI6XCJcXFxccGVycFwiLFwi4pyVXCI6XCJcXFxcdGltZXNcIixcIuKIo1wiOlwiXFxcXG1pZFwiLNWTOlwiXFxcXFBoaVwiLFwi4o6cXCI6XCJcXFxcbWlkXCIsxKc6XCJcXFxcaGJhclwiLOGNiDpcIiBcIixcIuKmqFwiOlwiXFxcXGxsYnJhY2tldFwiLOG6vzpcIlxcXFxoYXR7ZX1cIixcIsKiXCI6XCJcXFxcY2VudFwiLFwi4qS5XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLhcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKkt1wiOlwiXFxcXFJzaFwiLFwi4qS2XCI6XCJcXFxcTHNoXCIsXCLipLVcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKktFwiOlwiXFxcXHVwYXJyb3dcIixcIuKks1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcInxcIjpcIlxcXFxtaWRcIixcIuKOpVwiOlwiXFxcXG1pZFwiLFwi4pmlXCI6XCJcXFxcaGVhcnRzdWl0XCIs0J46XCIwXCIszqU6XCJZXCIs0YU6XCJ4XCIs8J2TjzpcInpcIizwnZOOOlwieVwiLPCdk406XCJ4XCIs0YA6XCJwXCIs0LA6XCJhXCIsXCLCo1wiOlwiXFxcXHBvdW5kc1wiLG06XCJtXCIs8J2atTpcIlxcXFxYaVwiLFwi4pOqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MH1cIixcIuKRoFwiOlwiXFxcXHRleHRjaXJjbGVkezF9XCIsXCLikaFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyfVwiLFwi4pGiXCI6XCJcXFxcdGV4dGNpcmNsZWR7M31cIixcIuKRo1wiOlwiXFxcXHRleHRjaXJjbGVkezR9XCIsXCLikaRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs1fVwiLFwi4pGlXCI6XCJcXFxcdGV4dGNpcmNsZWR7Nn1cIixcIuKRplwiOlwiXFxcXHRleHRjaXJjbGVkezd9XCIsXCLikadcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs4fVwiLFwi4pGoXCI6XCJcXFxcdGV4dGNpcmNsZWR7OX1cIixcIuKRqVwiOlwiXFxcXHRleHRjaXJjbGVkezEwfVwiLFwi4pGqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTF9XCIsXCLikatcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMn1cIixcIuKRrFwiOlwiXFxcXHRleHRjaXJjbGVkezEzfVwiLFwi4pGtXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTR9XCIsXCLika5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNX1cIixcIuKRr1wiOlwiXFxcXHRleHRjaXJjbGVkezE2fVwiLFwi4pGwXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTd9XCIsXCLikbFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOH1cIixcIuKRslwiOlwiXFxcXHRleHRjaXJjbGVkezE5fVwiLFwi4pGzXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjB9XCIsXCLjiZFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMX1cIixcIuOJklwiOlwiXFxcXHRleHRjaXJjbGVkezIyfVwiLFwi44mTXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjN9XCIsXCLjiZRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNH1cIixcIuOJlVwiOlwiXFxcXHRleHRjaXJjbGVkezI1fVwiLFwi44mWXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjZ9XCIsXCLjiZdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyN31cIixcIuOJmFwiOlwiXFxcXHRleHRjaXJjbGVkezI4fVwiLFwi44mZXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjl9XCIsXCLjiZpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMH1cIixcIuOJm1wiOlwiXFxcXHRleHRjaXJjbGVkezMxfVwiLFwi44mcXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzJ9XCIsXCLjiZ1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszM31cIixcIuOJnlwiOlwiXFxcXHRleHRjaXJjbGVkezM0fVwiLFwi44mfXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzV9XCIsXCLjirFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNn1cIixcIuOKslwiOlwiXFxcXHRleHRjaXJjbGVkezM3fVwiLFwi44qzXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzh9XCIsXCLjirRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszOX1cIixcIuOKtVwiOlwiXFxcXHRleHRjaXJjbGVkezQwfVwiLFwi44q2XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDF9XCIsXCLjirdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Mn1cIixcIuOKuFwiOlwiXFxcXHRleHRjaXJjbGVkezQzfVwiLFwi44q5XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDR9XCIsXCLjirpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0NX1cIixcIuOKu1wiOlwiXFxcXHRleHRjaXJjbGVkezQ2fVwiLFwi44q8XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDd9XCIsXCLjir1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OH1cIixcIuOKvlwiOlwiXFxcXHRleHRjaXJjbGVkezQ5fVwiLFwi44q/XCI6XCJcXFxcdGV4dGNpcmNsZWR7NTB9XCIsXCImXCI6XCJcXFxcJlwiLFwi4oCWXCI6XCJcXFxccGFyYWxsZWxcIixcIiVcIjpcIlxcXFwlXCIsXCLigJxcIjpcIlxcXFx0ZXh0e2BgfVwiLCQ6XCJcXFxcJFwiLFwiI1wiOlwiXFxcXCNcIixcIuKEg1wiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgQ31cIixcIuKEiVwiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgRn1cIixcIuKWiFwiOlwiXFxcXGJsYWNrc3F1YXJlXCIsXCLihKdcIjpcIlxcXFxtaG9cIixcIuKMi1wiOlwiXFxcXHJmbG9vclwiLFwi4oyKXCI6XCJcXFxcbGZsb29yXCIsXCLijIlcIjpcIlxcXFxyY2VpbFwiLFwi4oyIXCI6XCJcXFxcbGNlaWxcIizihIc6XCJcXFxcdmFyZXBzaWxvblwiLOKFhzpcIlxcXFx0ZXh0e2V9XCIsybw6XCJyXCIsXCLihptcIjpcIlxcXFxucmlnaHRhcnJvd1wiLMuGOlwiXFxcXGhhdHt9XCIsXCLigL5cIjpcIlxcXFxvdmVybGluZVwiLFwi4oaSXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oChXCI6XCJcXFxcZGRhZ2dlclwiLFwi44O7XCI6XCJcXFxcY2RvdFwiLFwi4paxXCI6XCJcXFxcc3F1YXJlXCIsXCLiiIZcIjpcIlxcXFxEZWx0YVwiLOG8sTpcImlcIixcIuKIoVwiOlwiXFxcXGFuZ2xlXCIsz5I6XCJcXFxcVXBzaWxvblwiLFwi4oaTXCI6XCJcXFxcZG93bmFycm93XCIsXCLihpFcIjpcIlxcXFx1cGFycm93XCIsXCLCu1wiOlwiXFxcXGdnXCIsXCLiiqRcIjpcIlxcXFx0b3BcIixcIuKnuFwiOlwiL1wiLPCdm786XCJcXFxcZGVsdGFcIixcIsuzXCI6XCJcXFxcY2RvdFwiLFwi1olcIjpcIjpcIixcIuKmqlwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmqVwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmq1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmgVwiOlwiXFxcXGNkb3RcIizRszpcIlxcXFx0aGV0YVwiLFwi4qaiXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiwrhcIjpcIixcIixcIuKOu1wiOlwiXFxcXG92ZXJsaW5lXCIsXCLin6ZcIjpcIlxcXFxsbGJyYWNrZXRcIizwnZyZOlwiXFxcXHBoaVwiLNCfOlwiXFxcXHByb2RcIizQvjpcIm9cIixcIuKJiFwiOlwiXFxcXGFwcHJveFwiLFwi4omkXCI6XCJcXFxcbGVxXCIs0ZI6XCJcXFxcaGJhclwiLMmFOlwiXFxcXExhbWJkYVwiLOWcnzpcIlxcXFxwbVwiLFwi4o68XCI6XCItXCIs5Y2BOlwiK1wiLFwi4omgXCI6XCJcXFxcbmVxXCIsXCLihpBcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuClpFwiOlwiXFxcXG1pZFwiLFwi4oKsXCI6XCJcXFxcZXVyb1wiLFwiy5hcIjpcIiBcIizhv6E6XCJcXFxcYmFye3V9XCIsXCLiiKVcIjpcIlxcXFxwYXJhbGxlbFwiLFwi4oaUXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKImlwiOlwiXFxcXHNxcnR7fVwiLMi8OlwiY1wiLPCdnq46XCJcXFxcZXBzaWxvblwiLFwiwrdcIjpcIlxcXFxjZG90XCIsXCLipqxcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq5cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipq1cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLCq1wiOlwiXFxcXGxsXCIszqc6XCJcXFxcbWF0aHNme1h9XCIsXCLilIJcIjpcIlxcXFxtaWRcIixcIuKMqlwiOlwiXFxcXHJhbmdsZVwiLOKCmTpcIl97bn1cIixcIuKWq1wiOlwiXFxcXHNxdWFyZVwiLFwi4pePXCI6XCJcXFxcY2lyY2xlXCIsXCLigJ1cIjonXFxcXFwiJ319LDU0MDY6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDI5NjUpLHQpLG4ocig5MDM5KSx0KSxuKHIoODI0OSksdCksbihyKDgxNzEpLHQpLG4ocig0NzIpLHQpLG4ocig0MzIwKSx0KSxuKHIoNjEyMiksdCl9LDQ3MjooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubGF0ZXhBY2NlbnRzPXZvaWQgMCx0LmxhdGV4QWNjZW50cz1bXCJcXFxcaGF0XCIsXCJcXFxcYmFyXCIsXCJcXFxcdW5kZXJicmFjZVwiLFwiXFxcXG92ZXJicmFjZVwiXX0sNDMyMDooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubWF0aE51bWJlckJ5R2x5cGg9dm9pZCAwLHQubWF0aE51bWJlckJ5R2x5cGg9e1wi4oKAXCI6XCJfezB9XCIsXCLigoFcIjpcIl97MX1cIixcIuKCglwiOlwiX3syfVwiLFwi4oKDXCI6XCJfezN9XCIsXCLigoRcIjpcIl97NH1cIixcIuKChVwiOlwiX3s1fVwiLFwi4oKGXCI6XCJfezZ9XCIsXCLigodcIjpcIl97N31cIixcIuKCiFwiOlwiX3s4fVwiLFwi4oKJXCI6XCJfezl9XCIsXCLigbBcIjpcIl57MH1cIixcIsK5XCI6XCJeezF9XCIsXCLCslwiOlwiXnsyfVwiLFwiwrNcIjpcIl57M31cIixcIuKBtFwiOlwiXns0fVwiLFwi4oG1XCI6XCJeezV9XCIsXCLigbZcIjpcIl57Nn1cIixcIuKBt1wiOlwiXns3fVwiLFwi4oG4XCI6XCJeezh9XCIsXCLigblcIjpcIl57OX1cIizigb86XCJee259XCIs4oKZOlwiX3tufVwiLFwi4pOqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MH1cIixcIuKRoFwiOlwiXFxcXHRleHRjaXJjbGVkezF9XCIsXCLikaFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyfVwiLFwi4pGiXCI6XCJcXFxcdGV4dGNpcmNsZWR7M31cIixcIuKRo1wiOlwiXFxcXHRleHRjaXJjbGVkezR9XCIsXCLikaRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs1fVwiLFwi4pGlXCI6XCJcXFxcdGV4dGNpcmNsZWR7Nn1cIixcIuKRplwiOlwiXFxcXHRleHRjaXJjbGVkezd9XCIsXCLikadcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs4fVwiLFwi4pGoXCI6XCJcXFxcdGV4dGNpcmNsZWR7OX1cIixcIuKRqVwiOlwiXFxcXHRleHRjaXJjbGVkezEwfVwiLFwi4pGqXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTF9XCIsXCLikatcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMn1cIixcIuKRrFwiOlwiXFxcXHRleHRjaXJjbGVkezEzfVwiLFwi4pGtXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTR9XCIsXCLika5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNX1cIixcIuKRr1wiOlwiXFxcXHRleHRjaXJjbGVkezE2fVwiLFwi4pGwXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTd9XCIsXCLikbFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOH1cIixcIuKRslwiOlwiXFxcXHRleHRjaXJjbGVkezE5fVwiLFwi4pGzXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjB9XCIsXCLjiZFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMX1cIixcIuOJklwiOlwiXFxcXHRleHRjaXJjbGVkezIyfVwiLFwi44mTXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjN9XCIsXCLjiZRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNH1cIixcIuOJlVwiOlwiXFxcXHRleHRjaXJjbGVkezI1fVwiLFwi44mWXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjZ9XCIsXCLjiZdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyN31cIixcIuOJmFwiOlwiXFxcXHRleHRjaXJjbGVkezI4fVwiLFwi44mZXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjl9XCIsXCLjiZpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMH1cIixcIuOJm1wiOlwiXFxcXHRleHRjaXJjbGVkezMxfVwiLFwi44mcXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzJ9XCIsXCLjiZ1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszM31cIixcIuOJnlwiOlwiXFxcXHRleHRjaXJjbGVkezM0fVwiLFwi44mfXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzV9XCIsXCLjirFcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNn1cIixcIuOKslwiOlwiXFxcXHRleHRjaXJjbGVkezM3fVwiLFwi44qzXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzh9XCIsXCLjirRcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszOX1cIixcIuOKtVwiOlwiXFxcXHRleHRjaXJjbGVkezQwfVwiLFwi44q2XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDF9XCIsXCLjirdcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Mn1cIixcIuOKuFwiOlwiXFxcXHRleHRjaXJjbGVkezQzfVwiLFwi44q5XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDR9XCIsXCLjirpcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0NX1cIixcIuOKu1wiOlwiXFxcXHRleHRjaXJjbGVkezQ2fVwiLFwi44q8XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDd9XCIsXCLjir1cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OH1cIixcIuOKvlwiOlwiXFxcXHRleHRjaXJjbGVkezQ5fVwiLFwi44q/XCI6XCJcXFxcdGV4dGNpcmNsZWR7NTB9XCIsXCLCvVwiOlwiXFxcXGRmcmFjezF9ezJ9XCIsXCLihZNcIjpcIlxcXFxkZnJhY3sxfXszfVwiLFwi4oWUXCI6XCJcXFxcZGZyYWN7Mn17M31cIixcIsK8XCI6XCJcXFxcZGZyYWN7MX17NH1cIixcIsK+XCI6XCJcXFxcZGZyYWN7M317NH1cIixcIuKFlVwiOlwiXFxcXGRmcmFjezF9ezV9XCIsXCLihZZcIjpcIlxcXFxkZnJhY3syfXs1fVwiLFwi4oWXXCI6XCJcXFxcZGZyYWN7M317NX1cIixcIuKFmFwiOlwiXFxcXGRmcmFjezR9ezV9XCIsXCLihZlcIjpcIlxcXFxkZnJhY3sxfXs2fVwiLFwi4oWaXCI6XCJcXFxcZGZyYWN7NX17Nn1cIixcIuKFkFwiOlwiXFxcXGRmcmFjezF9ezd9XCIsXCLihZtcIjpcIlxcXFxkZnJhY3sxfXs4fVwiLFwi4oWcXCI6XCJcXFxcZGZyYWN7M317OH1cIixcIuKFnVwiOlwiXFxcXGRmcmFjezV9ezh9XCIsXCLihZ5cIjpcIlxcXFxkZnJhY3s3fXs4fVwiLFwi4oWRXCI6XCJcXFxcZGZyYWN7MX17OX1cIixcIuKFklwiOlwiXFxcXGRmcmFjezF9ezEwfVwifX0sNjEyMjooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSGFzaFVURjhUb0x0WENvbnZlcnRlcj12b2lkIDAsdC5IYXNoVVRGOFRvTHRYQ29udmVydGVyPWNsYXNze2NvbnZlcnQoZSl7aWYoZS5tYXRjaCgvW2EtejAtOV0vaSkpcmV0dXJuIGU7Y29uc3QgdD1yW2VdO2lmKHQpe3JldHVybiB0aGlzLmNvbnZlcnRBY2NlbnRDaGFyVG9MdFgodCl8fGV9cmV0dXJuIHRoaXMuY29udmVydFNwZWNpYWxDaGFyVG9MdFgoZSl8fGV9Y29udmVydEFjY2VudENoYXJUb0x0WChlKXtjb25zdHtjaGFyOnQsYWNjZW50OnJ9PWUsbj1hW3JdO3JldHVybiBuP2BcXFxcJHtufXske3R9fWA6bnVsbH1jb252ZXJ0U3BlY2lhbENoYXJUb0x0WChlKXtjb25zdCB0PW5bZV07aWYoIXQpcmV0dXJuIG51bGw7Y29uc3R7bGV0dGVyOnIsZm9udENtZDphfT10O3JldHVybmBcXFxcJHthfXske3J9fWB9fTtjb25zdCByPXvDoTp7Y2hhcjpcImFcIixhY2NlbnQ6XCLCtFwifSzDoDp7Y2hhcjpcImFcIixhY2NlbnQ6XCJgXCJ9LMOiOntjaGFyOlwiYVwiLGFjY2VudDpcIl5cIn0sw6M6e2NoYXI6XCJhXCIsYWNjZW50OlwiflwifSzDpDp7Y2hhcjpcImFcIixhY2NlbnQ6XCLCqFwifSzDpTp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmlwifSzEhTp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmVwifSzEgzp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmFwifSzHjjp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLh1wifSzHnzp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLhlwifSzHuzp7Y2hhcjpcImFcIixhY2NlbnQ6XCLLmVwifSzHoTp7Y2hhcjpcImFcIixhY2NlbnQ6XCItXCJ9LMSBOntjaGFyOlwiYVwiLGFjY2VudDpcIi1cIn0sw6k6e2NoYXI6XCJlXCIsYWNjZW50OlwiwrRcIn0sw6g6e2NoYXI6XCJlXCIsYWNjZW50OlwiYFwifSzDqjp7Y2hhcjpcImVcIixhY2NlbnQ6XCJeXCJ9LMOrOntjaGFyOlwiZVwiLGFjY2VudDpcIsKoXCJ9LMSZOntjaGFyOlwiZVwiLGFjY2VudDpcIsuZXCJ9LMSbOntjaGFyOlwiZVwiLGFjY2VudDpcIsuHXCJ9LMiHOntjaGFyOlwiaVwiLGFjY2VudDpcIl5cIn0s0ZE6e2NoYXI6XCJlXCIsYWNjZW50OlwiwqhcIn0sxJM6e2NoYXI6XCJlXCIsYWNjZW50OlwiLVwifSzDrTp7Y2hhcjpcImlcIixhY2NlbnQ6XCLCtFwifSzDrDp7Y2hhcjpcImlcIixhY2NlbnQ6XCJgXCJ9LMOuOntjaGFyOlwiaVwiLGFjY2VudDpcIl5cIn0sw686e2NoYXI6XCJpXCIsYWNjZW50OlwiwqhcIn0sxK86e2NoYXI6XCJpXCIsYWNjZW50Olwiy5lcIn0sx5A6e2NoYXI6XCJpXCIsYWNjZW50Olwiy4dcIn0syIk6e2NoYXI6XCJpXCIsYWNjZW50OlwiYFwifSzIizp7Y2hhcjpcImlcIixhY2NlbnQ6XCLCqFwifSzEqzp7Y2hhcjpcImlcIixhY2NlbnQ6XCItXCJ9LMOzOntjaGFyOlwib1wiLGFjY2VudDpcIsK0XCJ9LMOyOntjaGFyOlwib1wiLGFjY2VudDpcImBcIn0sw7Q6e2NoYXI6XCJvXCIsYWNjZW50OlwiXlwifSzDtTp7Y2hhcjpcIm9cIixhY2NlbnQ6XCJ+XCJ9LMO2OntjaGFyOlwib1wiLGFjY2VudDpcIsKoXCJ9LMWROntjaGFyOlwib1wiLGFjY2VudDpcIsudXCJ9LMeSOntjaGFyOlwib1wiLGFjY2VudDpcIsuHXCJ9LMiNOntjaGFyOlwib1wiLGFjY2VudDpcImBcIn0syI86e2NoYXI6XCJvXCIsYWNjZW50OlwiwqhcIn0syKs6e2NoYXI6XCJvXCIsYWNjZW50Olwiy5hcIn0syK06e2NoYXI6XCJvXCIsYWNjZW50Olwiy51cIn0syK86e2NoYXI6XCJvXCIsYWNjZW50Olwiy5lcIn0sxY06e2NoYXI6XCJvXCIsYWNjZW50OlwiLVwifSzDujp7Y2hhcjpcInVcIixhY2NlbnQ6XCLCtFwifSzDuTp7Y2hhcjpcInVcIixhY2NlbnQ6XCJgXCJ9LMO7OntjaGFyOlwidVwiLGFjY2VudDpcIl5cIn0sw7w6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sxbE6e2NoYXI6XCJ1XCIsYWNjZW50Olwiy51cIn0sx5Q6e2NoYXI6XCJ1XCIsYWNjZW50Olwiy4dcIn0sx5Y6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sx5g6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sx5o6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sx5w6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0syJU6e2NoYXI6XCJ1XCIsYWNjZW50OlwiYFwifSzIlzp7Y2hhcjpcInVcIixhY2NlbnQ6XCLCqFwifSzFqzp7Y2hhcjpcInVcIixhY2NlbnQ6XCItXCJ9LMO9OntjaGFyOlwieVwiLGFjY2VudDpcIsK0XCJ9LOG7szp7Y2hhcjpcInlcIixhY2NlbnQ6XCJgXCJ9LMW3OntjaGFyOlwieVwiLGFjY2VudDpcIl5cIn0sw786e2NoYXI6XCJ5XCIsYWNjZW50OlwiwqhcIn0syLM6e2NoYXI6XCJ5XCIsYWNjZW50OlwiLVwifSzDgTp7Y2hhcjpcIkFcIixhY2NlbnQ6XCLCtFwifSzDgDp7Y2hhcjpcIkFcIixhY2NlbnQ6XCJgXCJ9LMOCOntjaGFyOlwiQVwiLGFjY2VudDpcIl5cIn0sw4M6e2NoYXI6XCJBXCIsYWNjZW50OlwiflwifSzDhDp7Y2hhcjpcIkFcIixhY2NlbnQ6XCLCqFwifSzDhTp7Y2hhcjpcIkFcIixhY2NlbnQ6XCLLmlwifSzihKs6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5pcIn0syKY6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5lcIn0sxII6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5hcIn0sx406e2NoYXI6XCJBXCIsYWNjZW50Olwiy4dcIn0sx546e2NoYXI6XCJBXCIsYWNjZW50Olwiy51cIn0sx7o6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5pcIn0sx6A6e2NoYXI6XCJBXCIsYWNjZW50OlwiLVwifSzEgDp7Y2hhcjpcIkFcIixhY2NlbnQ6XCItXCJ9LMOJOntjaGFyOlwiRVwiLGFjY2VudDpcIsK0XCJ9LMOIOntjaGFyOlwiRVwiLGFjY2VudDpcImBcIn0sxJY6e2NoYXI6XCJFXCIsYWNjZW50Olwiy5lcIn0sw4o6e2NoYXI6XCJFXCIsYWNjZW50OlwiXlwifSzDizp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLCqFwifSzEmjp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLLh1wifSzIhDp7Y2hhcjpcIkVcIixhY2NlbnQ6XCJgXCJ9LMiGOntjaGFyOlwiRVwiLGFjY2VudDpcIsKoXCJ9LMSSOntjaGFyOlwiRVwiLGFjY2VudDpcIi1cIn0sw406e2NoYXI6XCJJXCIsYWNjZW50OlwiwrRcIn0sw4w6e2NoYXI6XCJJXCIsYWNjZW50OlwiYFwifSzDjjp7Y2hhcjpcIklcIixhY2NlbnQ6XCJeXCJ9LMOPOntjaGFyOlwiSVwiLGFjY2VudDpcIsKoXCJ9LMSsOntjaGFyOlwiSVwiLGFjY2VudDpcIsuYXCJ9LMePOntjaGFyOlwiSVwiLGFjY2VudDpcIsuHXCJ9LMiIOntjaGFyOlwiSVwiLGFjY2VudDpcImBcIn0syIo6e2NoYXI6XCJJXCIsYWNjZW50OlwiwqhcIn0sxKo6e2NoYXI6XCJJXCIsYWNjZW50OlwiLVwifSzDkzp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLCtFwifSzDkjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCJgXCJ9LMOUOntjaGFyOlwiT1wiLGFjY2VudDpcIl5cIn0sw5U6e2NoYXI6XCJPXCIsYWNjZW50OlwiflwifSzDljp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLCqFwifSzFkDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLnVwifSzHkTp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLh1wifSzIjDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCJgXCJ9LMiOOntjaGFyOlwiT1wiLGFjY2VudDpcIsKoXCJ9LMiqOntjaGFyOlwiT1wiLGFjY2VudDpcIsuYXCJ9LMisOntjaGFyOlwiT1wiLGFjY2VudDpcIsudXCJ9LMiuOntjaGFyOlwiT1wiLGFjY2VudDpcIsuZXCJ9LMWMOntjaGFyOlwiT1wiLGFjY2VudDpcIi1cIn0sw5o6e2NoYXI6XCJVXCIsYWNjZW50OlwiwrRcIn0sw5k6e2NoYXI6XCJVXCIsYWNjZW50OlwiYFwifSzDmzp7Y2hhcjpcIlVcIixhY2NlbnQ6XCJeXCJ9LMOcOntjaGFyOlwiVVwiLGFjY2VudDpcIsKoXCJ9LMWwOntjaGFyOlwiVVwiLGFjY2VudDpcIsudXCJ9LMeTOntjaGFyOlwiVVwiLGFjY2VudDpcIsuHXCJ9LMeVOntjaGFyOlwiVVwiLGFjY2VudDpcIsKoXCJ9LMiUOntjaGFyOlwiVVwiLGFjY2VudDpcImBcIn0syJY6e2NoYXI6XCJVXCIsYWNjZW50OlwiwqhcIn0sxao6e2NoYXI6XCJVXCIsYWNjZW50OlwiLVwifSzDnTp7Y2hhcjpcIllcIixhY2NlbnQ6XCLCtFwifSzhu7I6e2NoYXI6XCJZXCIsYWNjZW50OlwiYFwifSzFtjp7Y2hhcjpcIllcIixhY2NlbnQ6XCJeXCJ9LMW4OntjaGFyOlwiWVwiLGFjY2VudDpcIsKoXCJ9LMiyOntjaGFyOlwiWVwiLGFjY2VudDpcIi1cIn0sw7E6e2NoYXI6XCJuXCIsYWNjZW50OlwiflwifSzDkTp7Y2hhcjpcIk5cIixhY2NlbnQ6XCJ+XCJ9LMOnOntjaGFyOlwiY1wiLGFjY2VudDpcIsuZXCJ9LMOHOntjaGFyOlwiQ1wiLGFjY2VudDpcIsuZXCJ9LOG5vTp7Y2hhcjpcInZcIixhY2NlbnQ6XCJ+XCJ9LOG5vDp7Y2hhcjpcIlZcIixhY2NlbnQ6XCJ+XCJ9LMS1OntjaGFyOlwialwiLGFjY2VudDpcIl5cIn0sxLQ6e2NoYXI6XCJKXCIsYWNjZW50OlwiXlwifSzFujp7Y2hhcjpcInpcIixhY2NlbnQ6XCLCtFwifSzFuTp7Y2hhcjpcIlpcIixhY2NlbnQ6XCLCtFwifSzFuzp7Y2hhcjpcIlpcIixhY2NlbnQ6XCJeXCJ9LMW8OntjaGFyOlwielwiLGFjY2VudDpcIl5cIn0sxb06e2NoYXI6XCJaXCIsYWNjZW50Olwiy4dcIn0sxb46e2NoYXI6XCJ6XCIsYWNjZW50Olwiy4dcIn0s4bqROntjaGFyOlwielwiLGFjY2VudDpcIsuGXCJ9fSxhPXtcIsK0XCI6XCJncmF2ZVwiLFwiYFwiOlwiYWN1dGVcIixcIl5cIjpcImhhdFwiLFwiflwiOlwidGlsZGVcIixcIsKoXCI6XCJkZG90XCIsXCLLmlwiOlwibWF0aHJpbmdcIixcIsuYXCI6XCJicmV2ZVwiLMuHOlwiY2hlY2tcIixcIsudXCI6XCJkZG90XCIsXCLLmVwiOlwiZG90XCIsXCItXCI6XCJiYXJcIizLhjpcImhhdFwiLFwiy5xcIjpcInRpbGRlXCJ9LG49e/CdkIA6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkIE6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkII6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkIM6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkIQ6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGJmXCJ9LM6VOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCFOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCGOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCHOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCIOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCJOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCKOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCLOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCMOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCNOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCOOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCPOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCQOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCROntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCSOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCTOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCUOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCVOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCWOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCXOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZ6GOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCYOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCZOntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn45cIjp7bGV0dGVyOlwiMFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+PXCI6e2xldHRlcjpcIjFcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fkFwiOntsZXR0ZXI6XCIyXCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5FcIjp7bGV0dGVyOlwiM1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+SXCI6e2xldHRlcjpcIjRcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fk1wiOntsZXR0ZXI6XCI1XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5RcIjp7bGV0dGVyOlwiNlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+VXCI6e2xldHRlcjpcIjdcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fllwiOntsZXR0ZXI6XCI4XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5dcIjp7bGV0dGVyOlwiOVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QtDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QtTp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Qtjp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Qtzp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QuDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QuTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Qujp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2Quzp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0s8J2QvDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoaXRcIn0szpk6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkL06e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkL46e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkL86e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYA6e2xldHRlcjpcIk1cIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYE6e2xldHRlcjpcIk5cIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYI6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYM6e2xldHRlcjpcIlBcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYQ6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYU6e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYY6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYc6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYg6e2xldHRlcjpcIlVcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYk6e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYo6e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYs6e2xldHRlcjpcIlhcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkYw6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkY06e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdlLg6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlLk6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEgjp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Uuzp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2UvDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2UvTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Uvjp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSNOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWAOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWBOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWCOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWDOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWEOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhiYlwifSzihJU6e2xldHRlcjpcIk5cIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYY6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGJiXCJ9LOKEmTp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSaOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhiYlwifSzihJ06e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYo6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYs6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlYw6e2xldHRlcjpcIlVcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlY06e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlY46e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlY86e2xldHRlcjpcIlhcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlZA6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEpDp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+YXCI6e2xldHRlcjpcIjBcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fmVwiOntsZXR0ZXI6XCIxXCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn5pcIjp7bGV0dGVyOlwiMlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+bXCI6e2xldHRlcjpcIjNcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fnFwiOntsZXR0ZXI6XCI0XCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn51cIjp7bGV0dGVyOlwiNVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+eXCI6e2xldHRlcjpcIjZcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fn1wiOntsZXR0ZXI6XCI3XCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn6BcIjp7bGV0dGVyOlwiOFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+hXCI6e2xldHRlcjpcIjlcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdkpw6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZOQOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSsOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Snjp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkp86e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZOTOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSwOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSxOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2TlTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqI6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGNhbFwifSzihIs6e2xldHRlcjpcIkhcIixmb250Q21kOlwibWF0aGNhbFwifSzihJA6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKlOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Spjp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEkjp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdk5s6e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGNhbFwifSzihLM6e2xldHRlcjpcIk1cIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKpOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Sqjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdk546e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKrOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SrDp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEmzp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdlb06e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGNhbFwifSxcIuKEn1wiOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Srjp7bGV0dGVyOlwiU1wiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkq86e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKwOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SsTp7bGV0dGVyOlwiVlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrI6e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKzOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2StDp7bGV0dGVyOlwiWVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrU6e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZSEOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIU6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oStOntsZXR0ZXI6XCJDXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIc6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UiDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSJOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIo6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oSMOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEkTp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSNOntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlI46e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ujzp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSQOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJE6e2xldHRlcjpcIk5cIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ukjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSTOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJQ6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oScOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJY6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ulzp7bGV0dGVyOlwiVFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSYOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJk6e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Umjp7bGV0dGVyOlwiV1wiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSbOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJw6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGZyYWtcIn0s4oSoOntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlqA6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aHNmXCJ9LM6ROntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZahOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhzZlwifSzOkjp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wojp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wozp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WpDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WpTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wpjp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wpzp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WqDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WqTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0syLc6e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqo6e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aHNmXCJ9LM6aOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZarOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZasOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZatOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZauOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZavOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZawOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZaxOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZayOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZazOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa0OntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa1OntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa2OntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZa3OntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhzZlwifSzOpzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WuDp7bGV0dGVyOlwiWVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WuTp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2aqDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aqTp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aqjp7bGV0dGVyOlwiXFxcXEdhbW1hXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqrOntsZXR0ZXI6XCJcXFxcRGVsdGFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmqw6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmq06e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmq46e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmq86e2xldHRlcjpcIlxcXFxUaGV0YVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2asDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2asTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2asjp7bGV0dGVyOlwiXFxcXExhbWJkYVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aszp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atTp7bGV0dGVyOlwiXFxcXFBpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq2OntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq3OntsZXR0ZXI6XCJcXFxcUGlcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrg6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrk6e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmro6e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrs6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrw6e2xldHRlcjpcIlVcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmr06e2xldHRlcjpcIlxcXFxQaGlcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmr46e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmr86e2xldHRlcjpcIlxcXFxQc2lcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdm4A6e2xldHRlcjpcIlxcXFxPbWVnYVwiLGZvbnRDbWQ6XCJtYXRodHRcIn19fX0sdD17fTtmdW5jdGlvbiByKGEpe3ZhciBuPXRbYV07aWYodm9pZCAwIT09bilyZXR1cm4gbi5leHBvcnRzO3ZhciBvPXRbYV09e2V4cG9ydHM6e319O3JldHVybiBlW2FdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHIpLG8uZXhwb3J0c312YXIgYT17fTtyZXR1cm4oKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT1hO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuTWF0aE1MVG9MYVRlWD12b2lkIDA7dmFyIHQ9cig4NjcyKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIk1hdGhNTFRvTGFUZVhcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdC5NYXRoTUxUb0xhVGVYfX0pfSkoKSxhfSkoKSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVuZGxlLm1pbi5qcy5tYXAiLCJpbXBvcnQgeyBEZWZ1ZGRsZU1ldGFkYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjbGFzcyBNZXRhZGF0YUV4dHJhY3RvciB7XG5cdHN0YXRpYyBleHRyYWN0KGRvYzogRG9jdW1lbnQsIHNjaGVtYU9yZ0RhdGE6IGFueSk6IERlZnVkZGxlTWV0YWRhdGEge1xuXHRcdGxldCBkb21haW4gPSAnJztcblx0XHRsZXQgdXJsID0gJyc7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gVHJ5IHRvIGdldCBVUkwgZnJvbSBkb2N1bWVudCBsb2NhdGlvblxuXHRcdFx0dXJsID0gZG9jLmxvY2F0aW9uPy5ocmVmIHx8ICcnO1xuXHRcdFx0XG5cdFx0XHQvLyBJZiBubyBVUkwgZnJvbSBsb2NhdGlvbiwgdHJ5IG90aGVyIHNvdXJjZXNcblx0XHRcdGlmICghdXJsKSB7XG5cdFx0XHRcdHVybCA9IHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6dXJsXCIpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJ0d2l0dGVyOnVybFwiKSB8fFxuXHRcdFx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAndXJsJykgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ21haW5FbnRpdHlPZlBhZ2UudXJsJykgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ21haW5FbnRpdHkudXJsJykgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ1dlYlNpdGUudXJsJykgfHxcblx0XHRcdFx0XHRkb2MucXVlcnlTZWxlY3RvcignbGlua1tyZWw9XCJjYW5vbmljYWxcIl0nKT8uZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh1cmwpIHtcblx0XHRcdFx0ZG9tYWluID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCAnJyk7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSWYgVVJMIHBhcnNpbmcgZmFpbHMsIHRyeSB0byBnZXQgZnJvbSBiYXNlIHRhZ1xuXHRcdFx0Y29uc3QgYmFzZVRhZyA9IGRvYy5xdWVyeVNlbGVjdG9yKCdiYXNlW2hyZWZdJyk7XG5cdFx0XHRpZiAoYmFzZVRhZykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHVybCA9IGJhc2VUYWcuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG5cdFx0XHRcdFx0ZG9tYWluID0gbmV3IFVSTCh1cmwpLmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCAnJyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBwYXJzZSBiYXNlIFVSTDonLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0aXRsZTogdGhpcy5nZXRUaXRsZShkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0ZGVzY3JpcHRpb246IHRoaXMuZ2V0RGVzY3JpcHRpb24oZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdGRvbWFpbixcblx0XHRcdGZhdmljb246IHRoaXMuZ2V0RmF2aWNvbihkb2MsIHVybCksXG5cdFx0XHRpbWFnZTogdGhpcy5nZXRJbWFnZShkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0cHVibGlzaGVkOiB0aGlzLmdldFB1Ymxpc2hlZChkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0YXV0aG9yOiB0aGlzLmdldEF1dGhvcihkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0c2l0ZTogdGhpcy5nZXRTaXRlKGRvYywgc2NoZW1hT3JnRGF0YSksXG5cdFx0XHRzY2hlbWFPcmdEYXRhLFxuXHRcdFx0d29yZENvdW50OiAwLFxuXHRcdFx0cGFyc2VUaW1lOiAwXG5cdFx0fTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldEF1dGhvcihkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUuYXV0aG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2F1dGhvci5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwiYXV0aG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYnlsXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXV0aG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXV0aG9yTGlzdFwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImNvcHlyaWdodFwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdjb3B5cmlnaHRIb2xkZXIubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOnNpdGVfbmFtZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdwdWJsaXNoZXIubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3NvdXJjZU9yZ2FuaXphdGlvbi5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnaXNQYXJ0T2YubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwidHdpdHRlcjpjcmVhdG9yXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXBwbGljYXRpb24tbmFtZVwiKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0U2l0ZShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3B1Ymxpc2hlci5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6c2l0ZV9uYW1lXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ1dlYlNpdGUubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3NvdXJjZU9yZ2FuaXphdGlvbi5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJjb3B5cmlnaHRcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnY29weXJpZ2h0SG9sZGVyLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdpc1BhcnRPZi5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJhcHBsaWNhdGlvbi1uYW1lXCIpIHx8XG5cdFx0XHR0aGlzLmdldEF1dGhvcihkb2MsIHNjaGVtYU9yZ0RhdGEpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRUaXRsZShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHJhd1RpdGxlID0gKFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJvZzp0aXRsZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInR3aXR0ZXI6dGl0bGVcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnaGVhZGxpbmUnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInRpdGxlXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUudGl0bGVcIikgfHxcblx0XHRcdGRvYy5xdWVyeVNlbGVjdG9yKCd0aXRsZScpPy50ZXh0Q29udGVudD8udHJpbSgpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cblx0XHRyZXR1cm4gdGhpcy5jbGVhblRpdGxlKHJhd1RpdGxlLCB0aGlzLmdldFNpdGUoZG9jLCBzY2hlbWFPcmdEYXRhKSk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBjbGVhblRpdGxlKHRpdGxlOiBzdHJpbmcsIHNpdGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGlmICghdGl0bGUgfHwgIXNpdGVOYW1lKSByZXR1cm4gdGl0bGU7XG5cblx0XHQvLyBSZW1vdmUgc2l0ZSBuYW1lIGlmIGl0IGV4aXN0c1xuXHRcdGNvbnN0IHNpdGVOYW1lRXNjYXBlZCA9IHNpdGVOYW1lLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJyk7XG5cdFx0Y29uc3QgcGF0dGVybnMgPSBbXG5cdFx0XHRgXFxcXHMqW1xcXFx8XFxcXC3igJPigJRdXFxcXHMqJHtzaXRlTmFtZUVzY2FwZWR9XFxcXHMqJGAsIC8vIFRpdGxlIHwgU2l0ZSBOYW1lXG5cdFx0XHRgXlxcXFxzKiR7c2l0ZU5hbWVFc2NhcGVkfVxcXFxzKltcXFxcfFxcXFwt4oCT4oCUXVxcXFxzKmAsIC8vIFNpdGUgTmFtZSB8IFRpdGxlXG5cdFx0XTtcblx0XHRcblx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcblx0XHRcdGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnaScpO1xuXHRcdFx0aWYgKHJlZ2V4LnRlc3QodGl0bGUpKSB7XG5cdFx0XHRcdHRpdGxlID0gdGl0bGUucmVwbGFjZShyZWdleCwgJycpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGl0bGUudHJpbSgpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0RGVzY3JpcHRpb24oZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcImRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOmRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2Rlc2NyaXB0aW9uJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0d2l0dGVyOmRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUuZGVzY3JpcHRpb25cIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldEltYWdlKGRvYzogRG9jdW1lbnQsIHNjaGVtYU9yZ0RhdGE6IGFueSk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6aW1hZ2VcIikgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0d2l0dGVyOmltYWdlXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2ltYWdlLnVybCcpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwic2FpbHRocnUuaW1hZ2UuZnVsbFwiKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0RmF2aWNvbihkb2M6IERvY3VtZW50LCBiYXNlVXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGljb25Gcm9tTWV0YSA9IHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6aW1hZ2U6ZmF2aWNvblwiKTtcblx0XHRpZiAoaWNvbkZyb21NZXRhKSByZXR1cm4gaWNvbkZyb21NZXRhO1xuXG5cdFx0Y29uc3QgaWNvbkxpbmsgPSBkb2MucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPSdpY29uJ11cIik/LmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0aWYgKGljb25MaW5rKSByZXR1cm4gaWNvbkxpbms7XG5cblx0XHRjb25zdCBzaG9ydGN1dExpbmsgPSBkb2MucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPSdzaG9ydGN1dCBpY29uJ11cIik/LmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG5cdFx0aWYgKHNob3J0Y3V0TGluaykgcmV0dXJuIHNob3J0Y3V0TGluaztcblxuXHRcdC8vIE9ubHkgdHJ5IHRvIGNvbnN0cnVjdCBmYXZpY29uIFVSTCBpZiB3ZSBoYXZlIGEgdmFsaWQgYmFzZSBVUkxcblx0XHRpZiAoYmFzZVVybCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIG5ldyBVUkwoXCIvZmF2aWNvbi5pY29cIiwgYmFzZVVybCkuaHJlZjtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gY29uc3RydWN0IGZhdmljb24gVVJMOicsIGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldFB1Ymxpc2hlZChkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2RhdGVQdWJsaXNoZWQnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInB1Ymxpc2hEYXRlXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcImFydGljbGU6cHVibGlzaGVkX3RpbWVcIikgfHxcblx0XHRcdHRoaXMuZ2V0VGltZUVsZW1lbnQoZG9jKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmRhdGVcIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldE1ldGFDb250ZW50KGRvYzogRG9jdW1lbnQsIGF0dHI6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0Y29uc3Qgc2VsZWN0b3IgPSBgbWV0YVske2F0dHJ9XWA7XG5cdFx0Y29uc3QgZWxlbWVudCA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxuXHRcdFx0LmZpbmQoZWwgPT4gZWwuZ2V0QXR0cmlidXRlKGF0dHIpPy50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpKTtcblx0XHRjb25zdCBjb250ZW50ID0gZWxlbWVudCA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKT8udHJpbSgpID8/IFwiXCIgOiBcIlwiO1xuXHRcdHJldHVybiB0aGlzLmRlY29kZUhUTUxFbnRpdGllcyhjb250ZW50LCBkb2MpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0VGltZUVsZW1lbnQoZG9jOiBEb2N1bWVudCk6IHN0cmluZyB7XG5cdFx0Y29uc3Qgc2VsZWN0b3IgPSBgdGltZWA7XG5cdFx0Y29uc3QgZWxlbWVudCA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVswXTtcblx0XHRjb25zdCBjb250ZW50ID0gZWxlbWVudCA/IChlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGV0aW1lXCIpPy50cmltKCkgPz8gZWxlbWVudC50ZXh0Q29udGVudD8udHJpbSgpID8/IFwiXCIpIDogXCJcIjtcblx0XHRyZXR1cm4gdGhpcy5kZWNvZGVIVE1MRW50aXRpZXMoY29udGVudCwgZG9jKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGRlY29kZUhUTUxFbnRpdGllcyh0ZXh0OiBzdHJpbmcsIGRvYzogRG9jdW1lbnQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHRleHRhcmVhID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdFx0dGV4dGFyZWEuaW5uZXJIVE1MID0gdGV4dDtcblx0XHRyZXR1cm4gdGV4dGFyZWEudmFsdWU7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRTY2hlbWFQcm9wZXJ0eShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnksIHByb3BlcnR5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogc3RyaW5nID0gJycpOiBzdHJpbmcge1xuXHRcdGlmICghc2NoZW1hT3JnRGF0YSkgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcblxuXHRcdGNvbnN0IHNlYXJjaFNjaGVtYSA9IChkYXRhOiBhbnksIHByb3BzOiBzdHJpbmdbXSwgZnVsbFBhdGg6IHN0cmluZywgaXNFeGFjdE1hdGNoOiBib29sZWFuID0gdHJ1ZSk6IHN0cmluZ1tdID0+IHtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0cmV0dXJuIHByb3BzLmxlbmd0aCA9PT0gMCA/IFtkYXRhXSA6IFtdO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFByb3AgPSBwcm9wc1swXTtcblx0XHRcdFx0aWYgKC9eXFxbXFxkK1xcXSQvLnRlc3QoY3VycmVudFByb3ApKSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBwYXJzZUludChjdXJyZW50UHJvcC5zbGljZSgxLCAtMSkpO1xuXHRcdFx0XHRcdGlmIChkYXRhW2luZGV4XSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHNlYXJjaFNjaGVtYShkYXRhW2luZGV4XSwgcHJvcHMuc2xpY2UoMSksIGZ1bGxQYXRoLCBpc0V4YWN0TWF0Y2gpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGlmIChwcm9wcy5sZW5ndGggPT09IDAgJiYgZGF0YS5ldmVyeShpdGVtID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGEubWFwKFN0cmluZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBkYXRhLmZsYXRNYXAoaXRlbSA9PiBzZWFyY2hTY2hlbWEoaXRlbSwgcHJvcHMsIGZ1bGxQYXRoLCBpc0V4YWN0TWF0Y2gpKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgW2N1cnJlbnRQcm9wLCAuLi5yZW1haW5pbmdQcm9wc10gPSBwcm9wcztcblx0XHRcdFxuXHRcdFx0aWYgKCFjdXJyZW50UHJvcCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSByZXR1cm4gW2RhdGFdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEubmFtZSkge1xuXHRcdFx0XHRcdHJldHVybiBbZGF0YS5uYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChkYXRhLmhhc093blByb3BlcnR5KGN1cnJlbnRQcm9wKSkge1xuXHRcdFx0XHRyZXR1cm4gc2VhcmNoU2NoZW1hKGRhdGFbY3VycmVudFByb3BdLCByZW1haW5pbmdQcm9wcywgXG5cdFx0XHRcdFx0ZnVsbFBhdGggPyBgJHtmdWxsUGF0aH0uJHtjdXJyZW50UHJvcH1gIDogY3VycmVudFByb3AsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzRXhhY3RNYXRjaCkge1xuXHRcdFx0XHRjb25zdCBuZXN0ZWRSZXN1bHRzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBkYXRhW2tleV0gPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gc2VhcmNoU2NoZW1hKGRhdGFba2V5XSwgcHJvcHMsIFxuXHRcdFx0XHRcdFx0XHRmdWxsUGF0aCA/IGAke2Z1bGxQYXRofS4ke2tleX1gIDoga2V5LCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRuZXN0ZWRSZXN1bHRzLnB1c2goLi4ucmVzdWx0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuZXN0ZWRSZXN1bHRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmVzdGVkUmVzdWx0cztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRsZXQgcmVzdWx0cyA9IHNlYXJjaFNjaGVtYShzY2hlbWFPcmdEYXRhLCBwcm9wZXJ0eS5zcGxpdCgnLicpLCAnJywgdHJ1ZSk7XG5cdFx0XHRpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmVzdWx0cyA9IHNlYXJjaFNjaGVtYShzY2hlbWFPcmdEYXRhLCBwcm9wZXJ0eS5zcGxpdCgnLicpLCAnJywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPiAwID8gcmVzdWx0cy5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKSA6IGRlZmF1bHRWYWx1ZTtcblx0XHRcdHJldHVybiB0aGlzLmRlY29kZUhUTUxFbnRpdGllcyhyZXN1bHQsIGRvYyk7XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIGdldFNjaGVtYVByb3BlcnR5IGZvciAke3Byb3BlcnR5fTpgLCBlcnJvcik7XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdHN0YXRpYyBleHRyYWN0U2NoZW1hT3JnRGF0YShkb2M6IERvY3VtZW50KTogYW55IHtcblx0XHRjb25zdCBzY2hlbWFTY3JpcHRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFt0eXBlPVwiYXBwbGljYXRpb24vbGQranNvblwiXScpO1xuXHRcdGNvbnN0IHNjaGVtYURhdGE6IGFueVtdID0gW107XG5cblx0XHRzY2hlbWFTY3JpcHRzLmZvckVhY2goc2NyaXB0ID0+IHtcblx0XHRcdGxldCBqc29uQ29udGVudCA9IHNjcmlwdC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvbkNvbnRlbnQgPSBqc29uQ29udGVudFxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvfF5cXHMqXFwvXFwvLiokL2dtLCAnJylcblx0XHRcdFx0XHQucmVwbGFjZSgvXlxccyo8IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXFxdXFxdPlxccyokLywgJyQxJylcblx0XHRcdFx0XHQucmVwbGFjZSgvXlxccyooXFwqXFwvfFxcL1xcKilcXHMqfFxccyooXFwqXFwvfFxcL1xcKilcXHMqJC9nLCAnJylcblx0XHRcdFx0XHQudHJpbSgpO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBqc29uRGF0YSA9IEpTT04ucGFyc2UoanNvbkNvbnRlbnQpO1xuXG5cdFx0XHRcdGlmIChqc29uRGF0YVsnQGdyYXBoJ10gJiYgQXJyYXkuaXNBcnJheShqc29uRGF0YVsnQGdyYXBoJ10pKSB7XG5cdFx0XHRcdFx0c2NoZW1hRGF0YS5wdXNoKC4uLmpzb25EYXRhWydAZ3JhcGgnXSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2NoZW1hRGF0YS5wdXNoKGpzb25EYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBzY2hlbWEub3JnIGRhdGE6JywgZXJyb3IpO1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdQcm9ibGVtYXRpYyBKU09OIGNvbnRlbnQ6JywganNvbkNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNjaGVtYURhdGE7XG5cdH1cbn0iLCJpbXBvcnQgeyBNZXRhZGF0YUV4dHJhY3RvciB9IGZyb20gJy4vbWV0YWRhdGEnO1xuaW1wb3J0IHsgRGVmdWRkbGVPcHRpb25zLCBEZWZ1ZGRsZVJlc3BvbnNlLCBEZWZ1ZGRsZU1ldGFkYXRhIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBcblx0SElEREVOX0VMRU1FTlRfU0VMRUNUT1JTLFxuXHRNT0JJTEVfV0lEVEgsXG5cdEJMT0NLX0VMRU1FTlRTLFxuXHRQUkVTRVJWRV9FTEVNRU5UUyxcblx0SU5MSU5FX0VMRU1FTlRTLFxuXHRTVVBQT1JURURfTEFOR1VBR0VTLFxuXHRBTExPV0VEX0FUVFJJQlVURVMsXG5cdEFMTE9XRURfQVRUUklCVVRFU19ERUJVRyxcblx0RVhBQ1RfU0VMRUNUT1JTLFxuXHRQQVJUSUFMX1NFTEVDVE9SUyxcblx0Rk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMsXG5cdEZPT1ROT1RFX0lOTElORV9SRUZFUkVOQ0VTLFxuXHRFTlRSWV9QT0lOVF9FTEVNRU5UUyxcblx0QUxMT1dFRF9FTVBUWV9FTEVNRU5UU1xufSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBtYXRoU3RhbmRhcmRpemF0aW9uUnVsZXMgfSBmcm9tICcuL21hdGgnO1xuXG4vLyBFbGVtZW50IHN0YW5kYXJkaXphdGlvbiBydWxlc1xuLy8gTWFwcyBzZWxlY3RvcnMgdG8gdGhlaXIgdGFyZ2V0IEhUTUwgZWxlbWVudCBuYW1lXG5pbnRlcmZhY2UgU3RhbmRhcmRpemF0aW9uUnVsZSB7XG5cdHNlbGVjdG9yOiBzdHJpbmc7XG5cdGVsZW1lbnQ6IHN0cmluZztcblx0dHJhbnNmb3JtPzogKGVsOiBFbGVtZW50KSA9PiBFbGVtZW50O1xufVxuXG5jb25zdCBFTEVNRU5UX1NUQU5EQVJESVpBVElPTl9SVUxFUzogU3RhbmRhcmRpemF0aW9uUnVsZVtdID0gW1xuXHQvLyBNYXRoIGVsZW1lbnRzXG5cdC4uLm1hdGhTdGFuZGFyZGl6YXRpb25SdWxlcyxcblx0Ly8gQ29kZSBibG9ja3Ncblx0e1xuXHRcdHNlbGVjdG9yOiAncHJlJyxcblx0XHRlbGVtZW50OiAncHJlJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBlbDtcblxuXHRcdFx0Ly8gRnVuY3Rpb24gdG8gZ2V0IGxhbmd1YWdlIGZyb20gY2xhc3Ncblx0XHRcdGNvbnN0IGdldExhbmd1YWdlRnJvbUNsYXNzID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogc3RyaW5nID0+IHtcblx0XHRcdFx0Ly8gQ2hlY2sgZGF0YS1sYW5nIGF0dHJpYnV0ZSBmaXJzdFxuXHRcdFx0XHRjb25zdCBkYXRhTGFuZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWxhbmcnKTtcblx0XHRcdFx0aWYgKGRhdGFMYW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGFMYW5nLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEZWZpbmUgbGFuZ3VhZ2UgcGF0dGVybnNcblx0XHRcdFx0Y29uc3QgbGFuZ3VhZ2VQYXR0ZXJucyA9IFtcblx0XHRcdFx0XHQvXmxhbmd1YWdlLShcXHcrKSQvLCAgICAgICAgICAvLyBsYW5ndWFnZS1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15sYW5nLShcXHcrKSQvLCAgICAgICAgICAgICAgLy8gbGFuZy1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L14oXFx3KyktY29kZSQvLCAgICAgICAgICAgICAgLy8gamF2YXNjcmlwdC1jb2RlXG5cdFx0XHRcdFx0L15jb2RlLShcXHcrKSQvLCAgICAgICAgICAgICAgLy8gY29kZS1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15zeW50YXgtKFxcdyspJC8sICAgICAgICAgICAgLy8gc3ludGF4LWphdmFzY3JpcHRcblx0XHRcdFx0XHQvXmNvZGUtc25pcHBldF9fKFxcdyspJC8sICAgICAvLyBjb2RlLXNuaXBwZXRfX2phdmFzY3JpcHRcblx0XHRcdFx0XHQvXmhpZ2hsaWdodC0oXFx3KykkLywgICAgICAgICAvLyBoaWdobGlnaHQtamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9eKFxcdyspLXNuaXBwZXQkLyAgICAgICAgICAgIC8vIGphdmFzY3JpcHQtc25pcHBldFxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdC8vIFRoZW4gY2hlY2sgdGhlIGNsYXNzIGF0dHJpYnV0ZSBmb3IgcGF0dGVybnNcblx0XHRcdFx0aWYgKGVsZW1lbnQuY2xhc3NOYW1lICYmIHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ3VhZ2VQYXR0ZXJucykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBlbGVtZW50LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpLm1hdGNoKHBhdHRlcm4pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBUaGVuIGNoZWNrIGZvciBzdXBwb3J0ZWQgbGFuZ3VhZ2Vcblx0XHRcdFx0XHRpZiAoU1VQUE9SVEVEX0xBTkdVQUdFUy5oYXMoZWxlbWVudC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtZW50LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZXMgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2xhc3NMaXN0KTtcblx0XHRcdFx0XG5cdFx0XHRcdGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcblx0XHRcdFx0XHQvLyBDaGVjayBwYXR0ZXJucyBmaXJzdFxuXHRcdFx0XHRcdGZvciAoY29uc3QgcGF0dGVybiBvZiBsYW5ndWFnZVBhdHRlcm5zKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGNsYXNzTmFtZS5tYXRjaChwYXR0ZXJuKTtcblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPbmx5IGNoZWNrIGJhcmUgbGFuZ3VhZ2UgbmFtZXMgaWYgbm8gcGF0dGVybnMgd2VyZSBmb3VuZFxuXHRcdFx0XHRmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG5cdFx0XHRcdFx0aWYgKFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKGNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH07XG5cblx0XHRcdC8vIFRyeSB0byBnZXQgdGhlIGxhbmd1YWdlIGZyb20gdGhlIGVsZW1lbnQgYW5kIGl0cyBhbmNlc3RvcnNcblx0XHRcdGxldCBsYW5ndWFnZSA9ICcnO1xuXHRcdFx0bGV0IGN1cnJlbnRFbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwgPSBlbDtcblx0XHRcdFxuXHRcdFx0d2hpbGUgKGN1cnJlbnRFbGVtZW50ICYmICFsYW5ndWFnZSkge1xuXHRcdFx0XHRsYW5ndWFnZSA9IGdldExhbmd1YWdlRnJvbUNsYXNzKGN1cnJlbnRFbGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFsc28gY2hlY2sgZm9yIGNvZGUgZWxlbWVudHMgd2l0aGluIHRoZSBjdXJyZW50IGVsZW1lbnRcblx0XHRcdFx0aWYgKCFsYW5ndWFnZSAmJiBjdXJyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJykpIHtcblx0XHRcdFx0XHRsYW5ndWFnZSA9IGdldExhbmd1YWdlRnJvbUNsYXNzKGN1cnJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvZGUnKSEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZ1bmN0aW9uIHRvIHJlY3Vyc2l2ZWx5IGV4dHJhY3QgdGV4dCBjb250ZW50IHdoaWxlIHByZXNlcnZpbmcgc3RydWN0dXJlXG5cdFx0XHRjb25zdCBleHRyYWN0U3RydWN0dXJlZFRleHQgPSAoZWxlbWVudDogTm9kZSk6IHN0cmluZyA9PiB7XG5cdFx0XHRcdGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtZW50LnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgdGV4dCA9ICcnO1xuXHRcdFx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGxpbmUgYnJlYWtzXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0JSJykge1xuXHRcdFx0XHRcdFx0cmV0dXJuICdcXG4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBIYW5kbGUgY29kZSBlbGVtZW50cyBhbmQgdGhlaXIgY2hpbGRyZW5cblx0XHRcdFx0XHRlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdFx0XHR0ZXh0ICs9IGV4dHJhY3RTdHJ1Y3R1cmVkVGV4dChjaGlsZCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQWRkIG5ld2xpbmUgYWZ0ZXIgZWFjaCBjb2RlIGVsZW1lbnRcblx0XHRcdFx0XHRpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQ09ERScpIHtcblx0XHRcdFx0XHRcdHRleHQgKz0gJ1xcbic7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gRXh0cmFjdCBhbGwgdGV4dCBjb250ZW50XG5cdFx0XHRsZXQgY29kZUNvbnRlbnQgPSBleHRyYWN0U3RydWN0dXJlZFRleHQoZWwpO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgY29udGVudFxuXHRcdFx0Y29kZUNvbnRlbnQgPSBjb2RlQ29udGVudFxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IGV4dHJhIG5ld2xpbmVzIGF0IHRoZSBzdGFydFxuXHRcdFx0XHQucmVwbGFjZSgvXlxcbisvLCAnJylcblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSBleHRyYSBuZXdsaW5lcyBhdCB0aGUgZW5kXG5cdFx0XHRcdC5yZXBsYWNlKC9cXG4rJC8sICcnKVxuXHRcdFx0XHQvLyBSZXBsYWNlIG11bHRpcGxlIGNvbnNlY3V0aXZlIG5ld2xpbmVzIHdpdGggYSBzaW5nbGUgbmV3bGluZVxuXHRcdFx0XHQucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJyk7XG5cblx0XHRcdC8vIENyZWF0ZSBuZXcgcHJlIGVsZW1lbnRcblx0XHRcdGNvbnN0IG5ld1ByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXHRcdFx0XG5cdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlc1xuXHRcdFx0QXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0bmV3UHJlLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQ3JlYXRlIGNvZGUgZWxlbWVudFxuXHRcdFx0Y29uc3QgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcblx0XHRcdGlmIChsYW5ndWFnZSkge1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5nJywgbGFuZ3VhZ2UpO1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcblx0XHRcdH1cblx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBjb2RlQ29udGVudDtcblx0XHRcdFxuXHRcdFx0bmV3UHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuXHRcdFx0cmV0dXJuIG5ld1ByZTtcblx0XHR9XG5cdH0sXG5cdC8vIFNpbXBsaWZ5IGhlYWRpbmdzIGJ5IHJlbW92aW5nIGludGVybmFsIG5hdmlnYXRpb24gZWxlbWVudHNcblx0e1xuXHRcdHNlbGVjdG9yOiAnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicsXG5cdFx0ZWxlbWVudDogJ2tlZXAnLFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHQvLyBJZiBoZWFkaW5nIG9ubHkgY29udGFpbnMgYSBzaW5nbGUgYW5jaG9yIHdpdGggaW50ZXJuYWwgbGlua1xuXHRcdFx0aWYgKGVsLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBcblx0XHRcdFx0ZWwuZmlyc3RFbGVtZW50Q2hpbGQ/LnRhZ05hbWUgPT09ICdBJyAmJlxuXHRcdFx0XHQoZWwuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0QXR0cmlidXRlKCdocmVmJyk/LmluY2x1ZGVzKCcjJykgfHwgXG5cdFx0XHRcdCBlbC5maXJzdEVsZW1lbnRDaGlsZC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKT8uc3RhcnRzV2l0aCgnIycpKSkge1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ3JlYXRlIG5ldyBoZWFkaW5nIG9mIHNhbWUgbGV2ZWxcblx0XHRcdFx0Y29uc3QgbmV3SGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwudGFnTmFtZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlcyBmcm9tIG9yaWdpbmFsIGhlYWRpbmdcblx0XHRcdFx0QXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRcdGlmIChBTExPV0VEX0FUVFJJQlVURVMuaGFzKGF0dHIubmFtZSkpIHtcblx0XHRcdFx0XHRcdG5ld0hlYWRpbmcuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEp1c3QgdXNlIHRoZSB0ZXh0IGNvbnRlbnRcblx0XHRcdFx0bmV3SGVhZGluZy50ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gbmV3SGVhZGluZztcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gSWYgaGVhZGluZyBjb250YWlucyBuYXZpZ2F0aW9uIGJ1dHRvbnMgb3Igb3RoZXIgdXRpbGl0eSBlbGVtZW50c1xuXHRcdFx0Y29uc3QgYnV0dG9ucyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuXHRcdFx0aWYgKGJ1dHRvbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCBuZXdIZWFkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC50YWdOYW1lKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENvcHkgYWxsb3dlZCBhdHRyaWJ1dGVzXG5cdFx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRuZXdIZWFkaW5nLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBKdXN0IHVzZSB0aGUgdGV4dCBjb250ZW50XG5cdFx0XHRcdG5ld0hlYWRpbmcudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ld0hlYWRpbmc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBlbDtcblx0XHR9XG5cdH0sXG5cdC8vIENvbnZlcnQgZGl2cyB3aXRoIHBhcmFncmFwaCByb2xlIHRvIGFjdHVhbCBwYXJhZ3JhcGhzXG5cdHsgXG5cdFx0c2VsZWN0b3I6ICdkaXZbZGF0YS10ZXN0aWRePVwicGFyYWdyYXBoXCJdLCBkaXZbcm9sZT1cInBhcmFncmFwaFwiXScsIFxuXHRcdGVsZW1lbnQ6ICdwJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29weSBpbm5lckhUTUxcblx0XHRcdHAuaW5uZXJIVE1MID0gZWwuaW5uZXJIVE1MO1xuXHRcdFx0XG5cdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlc1xuXHRcdFx0QXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0cC5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBwO1xuXHRcdH1cblx0fSxcblx0Ly8gQ29udmVydCBkaXZzIHdpdGggbGlzdCByb2xlcyB0byBhY3R1YWwgbGlzdHNcblx0eyBcblx0XHRzZWxlY3RvcjogJ2Rpdltyb2xlPVwibGlzdFwiXScsIFxuXHRcdGVsZW1lbnQ6ICd1bCcsXG5cdFx0Ly8gQ3VzdG9tIGhhbmRsZXIgZm9yIGxpc3QgdHlwZSBkZXRlY3Rpb24gYW5kIHRyYW5zZm9ybWF0aW9uXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdC8vIEZpcnN0IGRldGVybWluZSBpZiB0aGlzIGlzIGFuIG9yZGVyZWQgbGlzdFxuXHRcdFx0Y29uc3QgZmlyc3RJdGVtID0gZWwucXVlcnlTZWxlY3RvcignZGl2W3JvbGU9XCJsaXN0aXRlbVwiXSAubGFiZWwnKTtcblx0XHRcdGNvbnN0IGxhYmVsID0gZmlyc3RJdGVtPy50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0Y29uc3QgaXNPcmRlcmVkID0gbGFiZWwubWF0Y2goL15cXGQrXFwpLyk7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSB0aGUgYXBwcm9wcmlhdGUgbGlzdCB0eXBlXG5cdFx0XHRjb25zdCBsaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpc09yZGVyZWQgPyAnb2wnIDogJ3VsJyk7XG5cdFx0XHRcblx0XHRcdC8vIFByb2Nlc3MgZWFjaCBsaXN0IGl0ZW1cblx0XHRcdGNvbnN0IGl0ZW1zID0gZWwucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJsaXN0aXRlbVwiXScpO1xuXHRcdFx0aXRlbXMuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdFx0Y29uc3QgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gaXRlbS5xdWVyeVNlbGVjdG9yKCcuY29udGVudCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKGNvbnRlbnQpIHtcblx0XHRcdFx0XHQvLyBDb252ZXJ0IGFueSBwYXJhZ3JhcGggZGl2cyBpbnNpZGUgY29udGVudFxuXHRcdFx0XHRcdGNvbnN0IHBhcmFncmFwaERpdnMgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdltyb2xlPVwicGFyYWdyYXBoXCJdJyk7XG5cdFx0XHRcdFx0cGFyYWdyYXBoRGl2cy5mb3JFYWNoKGRpdiA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRcdFx0cC5pbm5lckhUTUwgPSBkaXYuaW5uZXJIVE1MO1xuXHRcdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKHApO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIENvbnZlcnQgYW55IG5lc3RlZCBsaXN0cyByZWN1cnNpdmVseVxuXHRcdFx0XHRcdGNvbnN0IG5lc3RlZExpc3RzID0gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cImxpc3RcIl0nKTtcblx0XHRcdFx0XHRuZXN0ZWRMaXN0cy5mb3JFYWNoKG5lc3RlZExpc3QgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgZmlyc3ROZXN0ZWRJdGVtID0gbmVzdGVkTGlzdC5xdWVyeVNlbGVjdG9yKCdkaXZbcm9sZT1cImxpc3RpdGVtXCJdIC5sYWJlbCcpO1xuXHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkTGFiZWwgPSBmaXJzdE5lc3RlZEl0ZW0/LnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHRcdFx0XHRjb25zdCBpc05lc3RlZE9yZGVyZWQgPSBuZXN0ZWRMYWJlbC5tYXRjaCgvXlxcZCtcXCkvKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Y29uc3QgbmV3TmVzdGVkTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXNOZXN0ZWRPcmRlcmVkID8gJ29sJyA6ICd1bCcpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHQvLyBQcm9jZXNzIG5lc3RlZCBpdGVtc1xuXHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkSXRlbXMgPSBuZXN0ZWRMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0nKTtcblx0XHRcdFx0XHRcdG5lc3RlZEl0ZW1zLmZvckVhY2gobmVzdGVkSXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZExpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkQ29udGVudCA9IG5lc3RlZEl0ZW0ucXVlcnlTZWxlY3RvcignLmNvbnRlbnQnKTtcblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdGlmIChuZXN0ZWRDb250ZW50KSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gQ29udmVydCBwYXJhZ3JhcGggZGl2cyBpbiBuZXN0ZWQgaXRlbXNcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBuZXN0ZWRQYXJhZ3JhcGhzID0gbmVzdGVkQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cInBhcmFncmFwaFwiXScpO1xuXHRcdFx0XHRcdFx0XHRcdG5lc3RlZFBhcmFncmFwaHMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0XHRcdFx0XHRcdHAuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChwKTtcblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWRMaS5pbm5lckhUTUwgPSBuZXN0ZWRDb250ZW50LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdFx0bmV3TmVzdGVkTGlzdC5hcHBlbmRDaGlsZChuZXN0ZWRMaSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0bmVzdGVkTGlzdC5yZXBsYWNlV2l0aChuZXdOZXN0ZWRMaXN0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRsaS5pbm5lckhUTUwgPSBjb250ZW50LmlubmVySFRNTDtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0bGlzdC5hcHBlbmRDaGlsZChsaSk7XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXHR9LFxuXHR7IFxuXHRcdHNlbGVjdG9yOiAnZGl2W3JvbGU9XCJsaXN0aXRlbVwiXScsIFxuXHRcdGVsZW1lbnQ6ICdsaScsXG5cdFx0Ly8gQ3VzdG9tIGhhbmRsZXIgZm9yIGxpc3QgaXRlbSBjb250ZW50XG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSBlbC5xdWVyeVNlbGVjdG9yKCcuY29udGVudCcpO1xuXHRcdFx0aWYgKCFjb250ZW50KSByZXR1cm4gZWw7XG5cdFx0XHRcblx0XHRcdC8vIENvbnZlcnQgYW55IHBhcmFncmFwaCBkaXZzIGluc2lkZSBjb250ZW50XG5cdFx0XHRjb25zdCBwYXJhZ3JhcGhEaXZzID0gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cInBhcmFncmFwaFwiXScpO1xuXHRcdFx0cGFyYWdyYXBoRGl2cy5mb3JFYWNoKGRpdiA9PiB7XG5cdFx0XHRcdGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdHAuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDtcblx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKHApO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdH1cblx0fSxcblx0Ly8gQ29kZSBibG9ja3Mgd2l0aCBzeW50YXggaGlnaGxpZ2h0aW5nXG5cdHtcblx0XHRzZWxlY3RvcjogJy53cC1ibG9jay1zeW50YXhoaWdobGlnaHRlci1jb2RlLCAuc3ludGF4aGlnaGxpZ2h0ZXIsIC5oaWdobGlnaHQsIC5oaWdobGlnaHQtc291cmNlLCAud3AtYmxvY2stY29kZSwgcHJlW2NsYXNzKj1cImxhbmd1YWdlLVwiXSwgcHJlW2NsYXNzKj1cImJydXNoOlwiXScsXG5cdFx0ZWxlbWVudDogJ3ByZScsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIENyZWF0ZSBuZXcgcHJlIGVsZW1lbnRcblx0XHRcdGNvbnN0IG5ld1ByZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXHRcdFx0XG5cdFx0XHQvLyBUcnkgdG8gZGV0ZWN0IGxhbmd1YWdlXG5cdFx0XHRsZXQgbGFuZ3VhZ2UgPSAnJztcblx0XHRcdFxuXHRcdFx0Ly8gQ2hlY2sgZm9yIFdvcmRQcmVzcyBzeW50YXggaGlnaGxpZ2h0ZXIgc3BlY2lmaWMgZm9ybWF0XG5cdFx0XHRjb25zdCBzeW50YXhFbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zeW50YXhoaWdobGlnaHRlcicpO1xuXHRcdFx0aWYgKHN5bnRheEVsKSB7XG5cdFx0XHRcdC8vIEdldCBsYW5ndWFnZSBmcm9tIHN5bnRheGhpZ2hsaWdodGVyIGNsYXNzXG5cdFx0XHRcdGNvbnN0IGNsYXNzZXMgPSBBcnJheS5mcm9tKHN5bnRheEVsLmNsYXNzTGlzdCk7XG5cdFx0XHRcdGNvbnN0IGxhbmdDbGFzcyA9IGNsYXNzZXMuZmluZChjID0+ICFbJ3N5bnRheGhpZ2hsaWdodGVyJywgJ25vZ3V0dGVyJ10uaW5jbHVkZXMoYykpO1xuXHRcdFx0XHRpZiAobGFuZ0NsYXNzICYmIFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKGxhbmdDbGFzcy50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0XHRcdGxhbmd1YWdlID0gbGFuZ0NsYXNzLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm8gbGFuZ3VhZ2UgZm91bmQgeWV0LCBjaGVjayBvdGhlciBjb21tb24gcGF0dGVybnNcblx0XHRcdGlmICghbGFuZ3VhZ2UpIHtcblx0XHRcdFx0Y29uc3QgY2xhc3NOYW1lcyA9IEFycmF5LmZyb20oZWwuY2xhc3NMaXN0KTtcblx0XHRcdFx0Y29uc3QgbGFuZ3VhZ2VQYXR0ZXJucyA9IFtcblx0XHRcdFx0XHQvKD86XnxcXHMpKD86bGFuZ3VhZ2V8bGFuZ3xicnVzaHxzeW50YXgpLShcXHcrKSg/Olxcc3wkKS9pLFxuXHRcdFx0XHRcdC8oPzpefFxccykoXFx3KykoPzpcXHN8JCkvaVxuXHRcdFx0XHRdO1xuXG5cdFx0XHRcdGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ3VhZ2VQYXR0ZXJucykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBjbGFzc05hbWUubWF0Y2gocGF0dGVybik7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2ggJiYgbWF0Y2hbMV0gJiYgU1VQUE9SVEVEX0xBTkdVQUdFUy5oYXMobWF0Y2hbMV0udG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRcdFx0bGFuZ3VhZ2UgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxhbmd1YWdlKSBicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBFeHRyYWN0IGNvZGUgY29udGVudCwgaGFuZGxpbmcgdmFyaW91cyBmb3JtYXRzXG5cdFx0XHRsZXQgY29kZUNvbnRlbnQgPSAnJztcblxuXHRcdFx0Ly8gSGFuZGxlIFdvcmRQcmVzcyBzeW50YXggaGlnaGxpZ2h0ZXIgdGFibGUgZm9ybWF0XG5cdFx0XHRjb25zdCBjb2RlQ29udGFpbmVyID0gZWwucXVlcnlTZWxlY3RvcignLnN5bnRheGhpZ2hsaWdodGVyIHRhYmxlIC5jb2RlIC5jb250YWluZXInKTtcblx0XHRcdGlmIChjb2RlQ29udGFpbmVyKSB7XG5cdFx0XHRcdC8vIFByb2Nlc3MgZWFjaCBsaW5lXG5cdFx0XHRcdGNvbnN0IGxpbmVzID0gQXJyYXkuZnJvbShjb2RlQ29udGFpbmVyLmNoaWxkcmVuKTtcblx0XHRcdFx0Y29kZUNvbnRlbnQgPSBsaW5lc1xuXHRcdFx0XHRcdC5tYXAobGluZSA9PiB7XG5cdFx0XHRcdFx0XHQvLyBHZXQgYWxsIGNvZGUgZWxlbWVudHMgaW4gdGhpcyBsaW5lXG5cdFx0XHRcdFx0XHRjb25zdCBjb2RlUGFydHMgPSBBcnJheS5mcm9tKGxpbmUucXVlcnlTZWxlY3RvckFsbCgnY29kZScpKVxuXHRcdFx0XHRcdFx0XHQubWFwKGNvZGUgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdC8vIEdldCB0aGUgdGV4dCBjb250ZW50LCBwcmVzZXJ2aW5nIHNwYWNlc1xuXHRcdFx0XHRcdFx0XHRcdGxldCB0ZXh0ID0gY29kZS50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB0aGlzIGlzIGEgJ3NwYWNlcycgY2xhc3MgZWxlbWVudCwgY29udmVydCB0byBhY3R1YWwgc3BhY2VzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGNvZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdzcGFjZXMnKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dGV4dCA9ICcgJy5yZXBlYXQodGV4dC5sZW5ndGgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdGV4dDtcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0LmpvaW4oJycpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvZGVQYXJ0cyB8fCBsaW5lLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmpvaW4oJ1xcbicpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGFuZGxlIFdvcmRQcmVzcyBzeW50YXggaGlnaGxpZ2h0ZXIgbm9uLXRhYmxlIGZvcm1hdFxuXHRcdFx0XHRjb25zdCBjb2RlTGluZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcuY29kZSAubGluZScpO1xuXHRcdFx0XHRpZiAoY29kZUxpbmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRjb2RlQ29udGVudCA9IEFycmF5LmZyb20oY29kZUxpbmVzKVxuXHRcdFx0XHRcdFx0Lm1hcChsaW5lID0+IHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgY29kZVBhcnRzID0gQXJyYXkuZnJvbShsaW5lLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvZGUnKSlcblx0XHRcdFx0XHRcdFx0XHQubWFwKGNvZGUgPT4gY29kZS50ZXh0Q29udGVudCB8fCAnJylcblx0XHRcdFx0XHRcdFx0XHQuam9pbignJyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBjb2RlUGFydHMgfHwgbGluZS50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQuam9pbignXFxuJyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gcmVndWxhciB0ZXh0IGNvbnRlbnRcblx0XHRcdFx0XHRjb2RlQ29udGVudCA9IGVsLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFuIHVwIHRoZSBjb250ZW50XG5cdFx0XHRjb2RlQ29udGVudCA9IGNvZGVDb250ZW50XG5cdFx0XHRcdC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykgLy8gVHJpbSBzdGFydC9lbmQgd2hpdGVzcGFjZVxuXHRcdFx0XHQucmVwbGFjZSgvXFx0L2csICcgICAgJykgLy8gQ29udmVydCB0YWJzIHRvIHNwYWNlc1xuXHRcdFx0XHQucmVwbGFjZSgvXFxuezMsfS9nLCAnXFxuXFxuJykgLy8gTm9ybWFsaXplIG11bHRpcGxlIG5ld2xpbmVzXG5cdFx0XHRcdC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7IC8vIFJlcGxhY2Ugbm9uLWJyZWFraW5nIHNwYWNlcyB3aXRoIHJlZ3VsYXIgc3BhY2VzXG5cblx0XHRcdC8vIENyZWF0ZSBjb2RlIGVsZW1lbnQgd2l0aCBsYW5ndWFnZSBjbGFzcyBpZiBkZXRlY3RlZFxuXHRcdFx0Y29uc3QgY29kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NvZGUnKTtcblx0XHRcdGlmIChsYW5ndWFnZSkge1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1sYW5nJywgbGFuZ3VhZ2UpO1xuXHRcdFx0XHRjb2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcblx0XHRcdH1cblx0XHRcdGNvZGUudGV4dENvbnRlbnQgPSBjb2RlQ29udGVudDtcblx0XHRcdFxuXHRcdFx0bmV3UHJlLmFwcGVuZENoaWxkKGNvZGUpO1xuXHRcdFx0cmV0dXJuIG5ld1ByZTtcblx0XHR9XG5cdH1cbl07XG5cbmludGVyZmFjZSBGb290bm90ZURhdGEge1xuXHRjb250ZW50OiBFbGVtZW50IHwgc3RyaW5nO1xuXHRvcmlnaW5hbElkOiBzdHJpbmc7XG5cdHJlZnM6IHN0cmluZ1tdO1xufVxuXG5pbnRlcmZhY2UgRm9vdG5vdGVDb2xsZWN0aW9uIHtcblx0W2Zvb3Rub3RlTnVtYmVyOiBudW1iZXJdOiBGb290bm90ZURhdGE7XG59XG5cbmludGVyZmFjZSBDb250ZW50U2NvcmUge1xuXHRzY29yZTogbnVtYmVyO1xuXHRlbGVtZW50OiBFbGVtZW50O1xufVxuXG5pbnRlcmZhY2UgU3R5bGVDaGFuZ2Uge1xuXHRzZWxlY3Rvcjogc3RyaW5nO1xuXHRzdHlsZXM6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIERlZnVkZGxlIHtcblx0cHJpdmF0ZSBkb2M6IERvY3VtZW50O1xuXHRwcml2YXRlIG9wdGlvbnM6IERlZnVkZGxlT3B0aW9ucztcblx0cHJpdmF0ZSBkZWJ1ZzogYm9vbGVhbjtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbmV3IERlZnVkZGxlIGluc3RhbmNlXG5cdCAqIEBwYXJhbSBkb2MgLSBUaGUgZG9jdW1lbnQgdG8gcGFyc2Vcblx0ICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBwYXJzaW5nXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcihkb2M6IERvY3VtZW50LCBvcHRpb25zOiBEZWZ1ZGRsZU9wdGlvbnMgPSB7fSkge1xuXHRcdHRoaXMuZG9jID0gZG9jO1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5kZWJ1ZyA9IG9wdGlvbnMuZGVidWcgfHwgZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2UgdGhlIGRvY3VtZW50IGFuZCBleHRyYWN0IGl0cyBtYWluIGNvbnRlbnRcblx0ICovXG5cdHBhcnNlKCk6IERlZnVkZGxlUmVzcG9uc2Uge1xuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG5cdFx0Ly8gRXh0cmFjdCBtZXRhZGF0YSBmaXJzdCBzaW5jZSB3ZSdsbCBuZWVkIGl0IGluIG11bHRpcGxlIHBsYWNlc1xuXHRcdGNvbnN0IHNjaGVtYU9yZ0RhdGEgPSBNZXRhZGF0YUV4dHJhY3Rvci5leHRyYWN0U2NoZW1hT3JnRGF0YSh0aGlzLmRvYyk7XG5cdFx0Y29uc3QgbWV0YWRhdGEgPSBNZXRhZGF0YUV4dHJhY3Rvci5leHRyYWN0KHRoaXMuZG9jLCBzY2hlbWFPcmdEYXRhKTtcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBFdmFsdWF0ZSBzdHlsZXMgYW5kIHNpemVzIG9uIG9yaWdpbmFsIGRvY3VtZW50XG5cdFx0XHRjb25zdCBtb2JpbGVTdHlsZXMgPSB0aGlzLl9ldmFsdWF0ZU1lZGlhUXVlcmllcyh0aGlzLmRvYyk7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBzbWFsbCBpbWFnZXMgaW4gb3JpZ2luYWwgZG9jdW1lbnQsIGV4Y2x1ZGluZyBsYXp5LWxvYWRlZCBvbmVzXG5cdFx0XHRjb25zdCBzbWFsbEltYWdlcyA9IHRoaXMuZmluZFNtYWxsSW1hZ2VzKHRoaXMuZG9jKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ2xvbmUgZG9jdW1lbnRcblx0XHRcdGNvbnN0IGNsb25lID0gdGhpcy5kb2MuY2xvbmVOb2RlKHRydWUpIGFzIERvY3VtZW50O1xuXHRcdFx0XG5cdFx0XHQvLyBBcHBseSBtb2JpbGUgc3R5bGUgdG8gY2xvbmVcblx0XHRcdHRoaXMuYXBwbHlNb2JpbGVTdHlsZXMoY2xvbmUsIG1vYmlsZVN0eWxlcyk7XG5cblx0XHRcdC8vIEZpbmQgbWFpbiBjb250ZW50XG5cdFx0XHRjb25zdCBtYWluQ29udGVudCA9IHRoaXMuZmluZE1haW5Db250ZW50KGNsb25lKTtcblx0XHRcdGlmICghbWFpbkNvbnRlbnQpIHtcblx0XHRcdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbnRlbnQ6IHRoaXMuZG9jLmJvZHkuaW5uZXJIVE1MLFxuXHRcdFx0XHRcdC4uLm1ldGFkYXRhLFxuXHRcdFx0XHRcdHdvcmRDb3VudDogdGhpcy5jb3VudFdvcmRzKHRoaXMuZG9jLmJvZHkuaW5uZXJIVE1MKSxcblx0XHRcdFx0XHRwYXJzZVRpbWU6IE1hdGgucm91bmQoZW5kVGltZSAtIHN0YXJ0VGltZSlcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIHNtYWxsIGltYWdlcyBpZGVudGlmaWVkIGZyb20gb3JpZ2luYWwgZG9jdW1lbnRcblx0XHRcdHRoaXMucmVtb3ZlU21hbGxJbWFnZXMoY2xvbmUsIHNtYWxsSW1hZ2VzKTtcblx0XHRcdFxuXHRcdFx0Ly8gUGVyZm9ybSBvdGhlciBkZXN0cnVjdGl2ZSBvcGVyYXRpb25zIG9uIHRoZSBjbG9uZVxuXHRcdFx0dGhpcy5yZW1vdmVIaWRkZW5FbGVtZW50cyhjbG9uZSk7XG5cdFx0XHR0aGlzLnJlbW92ZUNsdXR0ZXIoY2xvbmUpO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgbWFpbiBjb250ZW50XG5cdFx0XHR0aGlzLmNsZWFuQ29udGVudChtYWluQ29udGVudCwgbWV0YWRhdGEpO1xuXG5cdFx0XHRjb25zdCBjb250ZW50ID0gbWFpbkNvbnRlbnQgPyBtYWluQ29udGVudC5vdXRlckhUTUwgOiB0aGlzLmRvYy5ib2R5LmlubmVySFRNTDtcblx0XHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29udGVudCxcblx0XHRcdFx0Li4ubWV0YWRhdGEsXG5cdFx0XHRcdHdvcmRDb3VudDogdGhpcy5jb3VudFdvcmRzKGNvbnRlbnQpLFxuXHRcdFx0XHRwYXJzZVRpbWU6IE1hdGgucm91bmQoZW5kVGltZSAtIHN0YXJ0VGltZSlcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0RlZnVkZGxlJywgJ0Vycm9yIHByb2Nlc3NpbmcgZG9jdW1lbnQ6JywgZXJyb3IpO1xuXHRcdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29udGVudDogdGhpcy5kb2MuYm9keS5pbm5lckhUTUwsXG5cdFx0XHRcdC4uLm1ldGFkYXRhLFxuXHRcdFx0XHR3b3JkQ291bnQ6IHRoaXMuY291bnRXb3Jkcyh0aGlzLmRvYy5ib2R5LmlubmVySFRNTCksXG5cdFx0XHRcdHBhcnNlVGltZTogTWF0aC5yb3VuZChlbmRUaW1lIC0gc3RhcnRUaW1lKVxuXHRcdFx0fTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGNvdW50V29yZHMoY29udGVudDogc3RyaW5nKTogbnVtYmVyIHtcblx0XHQvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgZGl2IHRvIHBhcnNlIEhUTUwgY29udGVudFxuXHRcdGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHR0ZW1wRGl2LmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cblx0XHQvLyBHZXQgdGV4dCBjb250ZW50LCByZW1vdmluZyBleHRyYSB3aGl0ZXNwYWNlXG5cdFx0Y29uc3QgdGV4dCA9IHRlbXBEaXYudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0Y29uc3Qgd29yZHMgPSB0ZXh0XG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXFxzKy9nLCAnICcpIC8vIFJlcGxhY2UgbXVsdGlwbGUgc3BhY2VzIHdpdGggc2luZ2xlIHNwYWNlXG5cdFx0XHQuc3BsaXQoJyAnKVxuXHRcdFx0LmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID4gMCk7IC8vIEZpbHRlciBvdXQgZW1wdHkgc3RyaW5nc1xuXG5cdFx0cmV0dXJuIHdvcmRzLmxlbmd0aDtcblx0fVxuXG5cdC8vIE1ha2UgYWxsIG90aGVyIG1ldGhvZHMgcHJpdmF0ZSBieSByZW1vdmluZyB0aGUgc3RhdGljIGtleXdvcmQgYW5kIHVzaW5nIHByaXZhdGVcblx0cHJpdmF0ZSBfbG9nKC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdEZWZ1ZGRsZTonLCAuLi5hcmdzKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIF9ldmFsdWF0ZU1lZGlhUXVlcmllcyhkb2M6IERvY3VtZW50KTogU3R5bGVDaGFuZ2VbXSB7XG5cdFx0Y29uc3QgbW9iaWxlU3R5bGVzOiBTdHlsZUNoYW5nZVtdID0gW107XG5cdFx0Y29uc3QgbWF4V2lkdGhSZWdleCA9IC9tYXgtd2lkdGhbXjpdKjpcXHMqKFxcZCspLztcblxuXHRcdHRyeSB7XG5cdFx0XHQvLyBHZXQgYWxsIHN0eWxlcywgaW5jbHVkaW5nIGlubGluZSBzdHlsZXNcblx0XHRcdGNvbnN0IHNoZWV0cyA9IEFycmF5LmZyb20oZG9jLnN0eWxlU2hlZXRzKS5maWx0ZXIoc2hlZXQgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIEFjY2VzcyBydWxlcyBvbmNlIHRvIGNoZWNrIHZhbGlkaXR5XG5cdFx0XHRcdFx0c2hlZXQuY3NzUnVsZXM7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHQvLyBFeHBlY3RlZCBlcnJvciBmb3IgY3Jvc3Mtb3JpZ2luIHN0eWxlc2hlZXRzXG5cdFx0XHRcdFx0aWYgKGUgaW5zdGFuY2VvZiBET01FeGNlcHRpb24gJiYgZS5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdC8vIFByb2Nlc3MgYWxsIHNoZWV0cyBpbiBhIHNpbmdsZSBwYXNzXG5cdFx0XHRjb25zdCBtZWRpYVJ1bGVzID0gc2hlZXRzLmZsYXRNYXAoc2hlZXQgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiBBcnJheS5mcm9tKHNoZWV0LmNzc1J1bGVzKVxuXHRcdFx0XHRcdFx0LmZpbHRlcigocnVsZSk6IHJ1bGUgaXMgQ1NTTWVkaWFSdWxlID0+IFxuXHRcdFx0XHRcdFx0XHRydWxlIGluc3RhbmNlb2YgQ1NTTWVkaWFSdWxlICYmXG5cdFx0XHRcdFx0XHRcdHJ1bGUuY29uZGl0aW9uVGV4dC5pbmNsdWRlcygnbWF4LXdpZHRoJylcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdEZWZ1ZGRsZTogRmFpbGVkIHRvIHByb2Nlc3Mgc3R5bGVzaGVldDonLCBlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gUHJvY2VzcyBhbGwgbWVkaWEgcnVsZXMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdFx0bWVkaWFSdWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuXHRcdFx0XHRjb25zdCBtYXRjaCA9IHJ1bGUuY29uZGl0aW9uVGV4dC5tYXRjaChtYXhXaWR0aFJlZ2V4KTtcblx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0Y29uc3QgbWF4V2lkdGggPSBwYXJzZUludChtYXRjaFsxXSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKE1PQklMRV9XSURUSCA8PSBtYXhXaWR0aCkge1xuXHRcdFx0XHRcdFx0Ly8gQmF0Y2ggcHJvY2VzcyBhbGwgc3R5bGUgcnVsZXNcblx0XHRcdFx0XHRcdGNvbnN0IHN0eWxlUnVsZXMgPSBBcnJheS5mcm9tKHJ1bGUuY3NzUnVsZXMpXG5cdFx0XHRcdFx0XHRcdC5maWx0ZXIoKHIpOiByIGlzIENTU1N0eWxlUnVsZSA9PiByIGluc3RhbmNlb2YgQ1NTU3R5bGVSdWxlKTtcblxuXHRcdFx0XHRcdFx0c3R5bGVSdWxlcy5mb3JFYWNoKGNzc1J1bGUgPT4ge1xuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdG1vYmlsZVN0eWxlcy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdG9yOiBjc3NSdWxlLnNlbGVjdG9yVGV4dCxcblx0XHRcdFx0XHRcdFx0XHRcdHN0eWxlczogY3NzUnVsZS5zdHlsZS5jc3NUZXh0XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCdEZWZ1ZGRsZTogRmFpbGVkIHRvIHByb2Nlc3MgQ1NTIHJ1bGU6JywgZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoJ0RlZnVkZGxlOiBFcnJvciBldmFsdWF0aW5nIG1lZGlhIHF1ZXJpZXM6JywgZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1vYmlsZVN0eWxlcztcblx0fVxuXG5cdHByaXZhdGUgYXBwbHlNb2JpbGVTdHlsZXMoZG9jOiBEb2N1bWVudCwgbW9iaWxlU3R5bGVzOiBTdHlsZUNoYW5nZVtdKSB7XG5cdFx0bGV0IGFwcGxpZWRDb3VudCA9IDA7XG5cblx0XHRtb2JpbGVTdHlsZXMuZm9yRWFjaCgoe3NlbGVjdG9yLCBzdHlsZXN9KSA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCBlbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblx0XHRcdFx0ZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdFx0XHRlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBcblx0XHRcdFx0XHRcdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJykgKyBzdHlsZXNcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGFwcGxpZWRDb3VudCsrO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignRGVmdWRkbGUnLCAnRXJyb3IgYXBwbHlpbmcgc3R5bGVzIGZvciBzZWxlY3RvcjonLCBzZWxlY3RvciwgZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlSGlkZGVuRWxlbWVudHMoZG9jOiBEb2N1bWVudCkge1xuXHRcdGxldCBjb3VudCA9IDA7XG5cdFx0Y29uc3QgZWxlbWVudHNUb1JlbW92ZSA9IG5ldyBTZXQ8RWxlbWVudD4oKTtcblxuXHRcdC8vIEZpcnN0IHBhc3M6IEdldCBhbGwgZWxlbWVudHMgbWF0Y2hpbmcgaGlkZGVuIHNlbGVjdG9yc1xuXHRcdGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoSElEREVOX0VMRU1FTlRfU0VMRUNUT1JTKTtcblx0XHRoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsZW1lbnRzVG9SZW1vdmUuYWRkKGVsKSk7XG5cdFx0Y291bnQgKz0gaGlkZGVuRWxlbWVudHMubGVuZ3RoO1xuXG5cdFx0Ly8gU2Vjb25kIHBhc3M6IFVzZSBUcmVlV2Fsa2VyIGZvciBlZmZpY2llbnQgdHJhdmVyc2FsXG5cdFx0Y29uc3QgdHJlZVdhbGtlciA9IGRvYy5jcmVhdGVUcmVlV2Fsa2VyKFxuXHRcdFx0ZG9jLmJvZHksXG5cdFx0XHROb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcblx0XHRcdHtcblx0XHRcdFx0YWNjZXB0Tm9kZTogKG5vZGU6IEVsZW1lbnQpID0+IHtcblx0XHRcdFx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgbWFya2VkIGZvciByZW1vdmFsXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnRzVG9SZW1vdmUuaGFzKG5vZGUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfUkVKRUNUO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdC8vIEJhdGNoIHN0eWxlIGNvbXB1dGF0aW9uc1xuXHRcdGNvbnN0IGVsZW1lbnRzOiBFbGVtZW50W10gPSBbXTtcblx0XHRsZXQgY3VycmVudE5vZGU6IEVsZW1lbnQgfCBudWxsO1xuXHRcdHdoaWxlIChjdXJyZW50Tm9kZSA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSBhcyBFbGVtZW50KSB7XG5cdFx0XHRlbGVtZW50cy5wdXNoKGN1cnJlbnROb2RlKTtcblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHN0eWxlcyBpbiBiYXRjaGVzIHRvIG1pbmltaXplIGxheW91dCB0aHJhc2hpbmdcblx0XHRjb25zdCBCQVRDSF9TSVpFID0gMTAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IEJBVENIX1NJWkUpIHtcblx0XHRcdGNvbnN0IGJhdGNoID0gZWxlbWVudHMuc2xpY2UoaSwgaSArIEJBVENIX1NJWkUpO1xuXHRcdFx0XG5cdFx0XHQvLyBSZWFkIHBoYXNlIC0gZ2F0aGVyIGFsbCBjb21wdXRlZFN0eWxlc1xuXHRcdFx0Y29uc3Qgc3R5bGVzID0gYmF0Y2gubWFwKGVsID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKSk7XG5cdFx0XHRcblx0XHRcdC8vIFdyaXRlIHBoYXNlIC0gbWFyayBlbGVtZW50cyBmb3IgcmVtb3ZhbFxuXHRcdFx0YmF0Y2guZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcblx0XHRcdFx0Y29uc3QgY29tcHV0ZWRTdHlsZSA9IHN0eWxlc1tpbmRleF07XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fFxuXHRcdFx0XHRcdGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHxcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlLm9wYWNpdHkgPT09ICcwJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRlbGVtZW50c1RvUmVtb3ZlLmFkZChlbGVtZW50KTtcblx0XHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBGaW5hbCBwYXNzOiBCYXRjaCByZW1vdmUgYWxsIGhpZGRlbiBlbGVtZW50c1xuXHRcdGVsZW1lbnRzVG9SZW1vdmUuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG5cblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgaGlkZGVuIGVsZW1lbnRzOicsIGNvdW50KTtcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlQ2x1dHRlcihkb2M6IERvY3VtZW50KSB7XG5cdFx0Y29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0bGV0IGV4YWN0U2VsZWN0b3JDb3VudCA9IDA7XG5cdFx0bGV0IHBhcnRpYWxTZWxlY3RvckNvdW50ID0gMDtcblxuXHRcdC8vIFRyYWNrIGFsbCBlbGVtZW50cyB0byBiZSByZW1vdmVkXG5cdFx0Y29uc3QgZWxlbWVudHNUb1JlbW92ZSA9IG5ldyBTZXQ8RWxlbWVudD4oKTtcblxuXHRcdC8vIEZpcnN0IGNvbGxlY3QgZWxlbWVudHMgbWF0Y2hpbmcgZXhhY3Qgc2VsZWN0b3JzXG5cdFx0Y29uc3QgZXhhY3RFbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKEVYQUNUX1NFTEVDVE9SUy5qb2luKCcsJykpO1xuXHRcdGV4YWN0RWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRpZiAoZWw/LnBhcmVudE5vZGUpIHtcblx0XHRcdFx0ZWxlbWVudHNUb1JlbW92ZS5hZGQoZWwpO1xuXHRcdFx0XHRleGFjdFNlbGVjdG9yQ291bnQrKztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIFByZS1jb21waWxlIHJlZ2V4ZXMgYW5kIGNvbWJpbmUgaW50byBhIHNpbmdsZSByZWdleCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG5cdFx0Y29uc3QgY29tYmluZWRQYXR0ZXJuID0gUEFSVElBTF9TRUxFQ1RPUlMuam9pbignfCcpO1xuXHRcdGNvbnN0IHBhcnRpYWxSZWdleCA9IG5ldyBSZWdFeHAoY29tYmluZWRQYXR0ZXJuLCAnaScpO1xuXG5cdFx0Ly8gQ3JlYXRlIGFuIGVmZmljaWVudCBhdHRyaWJ1dGUgc2VsZWN0b3IgZm9yIGVsZW1lbnRzIHdlIGNhcmUgYWJvdXRcblx0XHRjb25zdCBhdHRyaWJ1dGVTZWxlY3RvciA9ICdbY2xhc3NdLFtpZF0sW2RhdGEtdGVzdGlkXSxbZGF0YS1xYV0sW2RhdGEtY3ldJztcblx0XHRjb25zdCBhbGxFbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKGF0dHJpYnV0ZVNlbGVjdG9yKTtcblxuXHRcdC8vIFByb2Nlc3MgZWxlbWVudHMgZm9yIHBhcnRpYWwgbWF0Y2hlc1xuXHRcdGFsbEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0Ly8gU2tpcCBpZiBhbHJlYWR5IG1hcmtlZCBmb3IgcmVtb3ZhbFxuXHRcdFx0aWYgKGVsZW1lbnRzVG9SZW1vdmUuaGFzKGVsKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEdldCBhbGwgcmVsZXZhbnQgYXR0cmlidXRlcyBhbmQgY29tYmluZSBpbnRvIGEgc2luZ2xlIHN0cmluZ1xuXHRcdFx0Y29uc3QgYXR0cnMgPSBbXG5cdFx0XHRcdGVsLmNsYXNzTmFtZSAmJiB0eXBlb2YgZWwuY2xhc3NOYW1lID09PSAnc3RyaW5nJyA/IGVsLmNsYXNzTmFtZSA6ICcnLFxuXHRcdFx0XHRlbC5pZCB8fCAnJyxcblx0XHRcdFx0ZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRlc3RpZCcpIHx8ICcnLFxuXHRcdFx0XHRlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcWEnKSB8fCAnJyxcblx0XHRcdFx0ZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWN5JykgfHwgJydcblx0XHRcdF0uam9pbignICcpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdC8vIFNraXAgaWYgbm8gYXR0cmlidXRlcyB0byBjaGVja1xuXHRcdFx0aWYgKCFhdHRycy50cmltKCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3IgcGFydGlhbCBtYXRjaCB1c2luZyBzaW5nbGUgcmVnZXggdGVzdFxuXHRcdFx0aWYgKHBhcnRpYWxSZWdleC50ZXN0KGF0dHJzKSkge1xuXHRcdFx0XHRlbGVtZW50c1RvUmVtb3ZlLmFkZChlbCk7XG5cdFx0XHRcdHBhcnRpYWxTZWxlY3RvckNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBSZW1vdmUgYWxsIGNvbGxlY3RlZCBlbGVtZW50cyBpbiBhIHNpbmdsZSBwYXNzXG5cdFx0ZWxlbWVudHNUb1JlbW92ZS5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcblxuXHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgY2x1dHRlciBlbGVtZW50czonLCB7XG5cdFx0XHRleGFjdFNlbGVjdG9yczogZXhhY3RTZWxlY3RvckNvdW50LFxuXHRcdFx0cGFydGlhbFNlbGVjdG9yczogcGFydGlhbFNlbGVjdG9yQ291bnQsXG5cdFx0XHR0b3RhbDogZWxlbWVudHNUb1JlbW92ZS5zaXplLFxuXHRcdFx0cHJvY2Vzc2luZ1RpbWU6IGAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zYFxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBmbGF0dGVuRGl2cyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdC8vIFByb2Nlc3MgaW4gYmF0Y2hlcyB0byBtYWludGFpbiBwZXJmb3JtYW5jZVxuXHRcdGxldCBrZWVwUHJvY2Vzc2luZyA9IHRydWU7XG5cblx0XHRjb25zdCBzaG91bGRQcmVzZXJ2ZUVsZW1lbnQgPSAoZWw6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcblx0XHRcdGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnQgc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0aWYgKFBSRVNFUlZFX0VMRU1FTlRTLmhhcyh0YWdOYW1lKSkgcmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBzZW1hbnRpYyByb2xlc1xuXHRcdFx0Y29uc3Qgcm9sZSA9IGVsLmdldEF0dHJpYnV0ZSgncm9sZScpO1xuXHRcdFx0aWYgKHJvbGUgJiYgWydhcnRpY2xlJywgJ21haW4nLCAnbmF2aWdhdGlvbicsICdiYW5uZXInLCAnY29udGVudGluZm8nXS5pbmNsdWRlcyhyb2xlKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHNlbWFudGljIGNsYXNzZXNcblx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKGNsYXNzTmFtZS5tYXRjaCgvKD86YXJ0aWNsZXxtYWlufGNvbnRlbnR8Zm9vdG5vdGV8cmVmZXJlbmNlfGJpYmxpb2dyYXBoeSkvKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgaWYgZGl2IGNvbnRhaW5zIG1peGVkIGNvbnRlbnQgdHlwZXMgdGhhdCBzaG91bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRpZiAodGFnTmFtZSA9PT0gJ2RpdicpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKTtcblx0XHRcdFx0Y29uc3QgaGFzUHJlc2VydmVkRWxlbWVudHMgPSBjaGlsZHJlbi5zb21lKGNoaWxkID0+IFxuXHRcdFx0XHRcdFBSRVNFUlZFX0VMRU1FTlRTLmhhcyhjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHx8XG5cdFx0XHRcdFx0Y2hpbGQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdhcnRpY2xlJyB8fFxuXHRcdFx0XHRcdGNoaWxkLmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdhcnRpY2xlJylcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKGhhc1ByZXNlcnZlZEVsZW1lbnRzKSByZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHRjb25zdCBpc1dyYXBwZXJEaXYgPSAoZGl2OiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHQvLyBDaGVjayBpZiBpdCdzIGp1c3QgZW1wdHkgc3BhY2Vcblx0XHRcdGlmICghZGl2LnRleHRDb250ZW50Py50cmltKCkpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdCBvbmx5IGNvbnRhaW5zIG90aGVyIGRpdnMgb3IgYmxvY2sgZWxlbWVudHNcblx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGlmIGFsbCBjaGlsZHJlbiBhcmUgYmxvY2sgZWxlbWVudHNcblx0XHRcdGNvbnN0IGFsbEJsb2NrRWxlbWVudHMgPSBjaGlsZHJlbi5ldmVyeShjaGlsZCA9PiB7XG5cdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0cmV0dXJuIHRhZyA9PT0gJ2RpdicgfHwgdGFnID09PSAncCcgfHwgdGFnID09PSAnaDEnIHx8IHRhZyA9PT0gJ2gyJyB8fCBcblx0XHRcdFx0XHQgICB0YWcgPT09ICdoMycgfHwgdGFnID09PSAnaDQnIHx8IHRhZyA9PT0gJ2g1JyB8fCB0YWcgPT09ICdoNicgfHxcblx0XHRcdFx0XHQgICB0YWcgPT09ICd1bCcgfHwgdGFnID09PSAnb2wnIHx8IHRhZyA9PT0gJ3ByZScgfHwgdGFnID09PSAnYmxvY2txdW90ZScgfHxcblx0XHRcdFx0XHQgICB0YWcgPT09ICdmaWd1cmUnO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoYWxsQmxvY2tFbGVtZW50cykgcmV0dXJuIHRydWU7XG5cblx0XHRcdC8vIENoZWNrIGZvciBjb21tb24gd3JhcHBlciBwYXR0ZXJuc1xuXHRcdFx0Y29uc3QgY2xhc3NOYW1lID0gZGl2LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y29uc3QgaXNXcmFwcGVyID0gLyg/OndyYXBwZXJ8Y29udGFpbmVyfGxheW91dHxyb3d8Y29sfGdyaWR8ZmxleHxvdXRlcnxpbm5lcnxjb250ZW50LWFyZWEpL2kudGVzdChjbGFzc05hbWUpO1xuXHRcdFx0aWYgKGlzV3JhcHBlcikgcmV0dXJuIHRydWU7XG5cblx0XHRcdC8vIENoZWNrIGlmIGl0IGhhcyBleGNlc3NpdmUgd2hpdGVzcGFjZSBvciBlbXB0eSB0ZXh0IG5vZGVzXG5cdFx0XHRjb25zdCB0ZXh0Tm9kZXMgPSBBcnJheS5mcm9tKGRpdi5jaGlsZE5vZGVzKS5maWx0ZXIobm9kZSA9PiBcblx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgbm9kZS50ZXh0Q29udGVudD8udHJpbSgpXG5cdFx0XHQpO1xuXHRcdFx0aWYgKHRleHROb2Rlcy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdCdzIGEgZGl2IHRoYXQgb25seSBjb250YWlucyBibG9jayBlbGVtZW50c1xuXHRcdFx0Y29uc3QgaGFzT25seUJsb2NrRWxlbWVudHMgPSBjaGlsZHJlbi5sZW5ndGggPiAwICYmICFjaGlsZHJlbi5zb21lKGNoaWxkID0+IHtcblx0XHRcdFx0Y29uc3QgdGFnID0gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRyZXR1cm4gSU5MSU5FX0VMRU1FTlRTLmhhcyh0YWcpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoaGFzT25seUJsb2NrRWxlbWVudHMpIHJldHVybiB0cnVlO1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8vIEZ1bmN0aW9uIHRvIHByb2Nlc3MgYSBzaW5nbGUgZGl2XG5cdFx0Y29uc3QgcHJvY2Vzc0RpdiA9IChkaXY6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcblx0XHRcdC8vIFNraXAgcHJvY2Vzc2luZyBpZiBkaXYgaGFzIGJlZW4gcmVtb3ZlZCBvciBzaG91bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRpZiAoIWRpdi5pc0Nvbm5lY3RlZCB8fCBzaG91bGRQcmVzZXJ2ZUVsZW1lbnQoZGl2KSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBDYXNlIDE6IEVtcHR5IGRpdiBvciBkaXYgd2l0aCBvbmx5IHdoaXRlc3BhY2Vcblx0XHRcdGlmICghZGl2Lmhhc0NoaWxkTm9kZXMoKSB8fCAhZGl2LnRleHRDb250ZW50Py50cmltKCkpIHtcblx0XHRcdFx0ZGl2LnJlbW92ZSgpO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSAyOiBUb3AtbGV2ZWwgZGl2IC0gYmUgbW9yZSBhZ2dyZXNzaXZlXG5cdFx0XHRpZiAoZGl2LnBhcmVudEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGRpdi5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IGhhc09ubHlCbG9ja0VsZW1lbnRzID0gY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhY2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgdGFnID0gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdHJldHVybiBJTkxJTkVfRUxFTUVOVFMuaGFzKHRhZyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChoYXNPbmx5QmxvY2tFbGVtZW50cykge1xuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSAzOiBXcmFwcGVyIGRpdiAtIG1lcmdlIHVwIGFnZ3Jlc3NpdmVseVxuXHRcdFx0aWYgKGlzV3JhcHBlckRpdihkaXYpKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZTogaWYgZGl2IG9ubHkgY29udGFpbnMgYmxvY2sgZWxlbWVudHMsIG1lcmdlIHRoZW0gdXBcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGRpdi5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IG9ubHlCbG9ja0VsZW1lbnRzID0gIWNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRyZXR1cm4gSU5MSU5FX0VMRU1FTlRTLmhhcyh0YWcpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChvbmx5QmxvY2tFbGVtZW50cykge1xuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgaGFuZGxlIGFzIG5vcm1hbCB3cmFwcGVyXG5cdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHR3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgNDogRGl2IG9ubHkgY29udGFpbnMgdGV4dCBjb250ZW50IC0gY29udmVydCB0byBwYXJhZ3JhcGhcblx0XHRcdGlmICghZGl2LmNoaWxkcmVuLmxlbmd0aCAmJiBkaXYudGV4dENvbnRlbnQ/LnRyaW0oKSkge1xuXHRcdFx0XHRjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRwLnRleHRDb250ZW50ID0gZGl2LnRleHRDb250ZW50O1xuXHRcdFx0XHRkaXYucmVwbGFjZVdpdGgocCk7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXNlIDU6IERpdiBoYXMgc2luZ2xlIGNoaWxkXG5cdFx0XHRpZiAoZGl2LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRjb25zdCBjaGlsZCA9IGRpdi5maXJzdEVsZW1lbnRDaGlsZCE7XG5cdFx0XHRcdGNvbnN0IGNoaWxkVGFnID0gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gRG9uJ3QgdW53cmFwIGlmIGNoaWxkIGlzIGlubGluZSBvciBzaG91bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdGlmICghSU5MSU5FX0VMRU1FTlRTLmhhcyhjaGlsZFRhZykgJiYgIXNob3VsZFByZXNlcnZlRWxlbWVudChjaGlsZCkpIHtcblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoY2hpbGQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSA2OiBEZWVwbHkgbmVzdGVkIGRpdiAtIG1lcmdlIHVwXG5cdFx0XHRsZXQgbmVzdGluZ0RlcHRoID0gMDtcblx0XHRcdGxldCBwYXJlbnQgPSBkaXYucGFyZW50RWxlbWVudDtcblx0XHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdFx0aWYgKHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnKSB7XG5cdFx0XHRcdFx0bmVzdGluZ0RlcHRoKys7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXN0aW5nRGVwdGggPiAwKSB7IC8vIENoYW5nZWQgZnJvbSA+IDEgdG8gPiAwIHRvIGJlIG1vcmUgYWdncmVzc2l2ZVxuXHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG5cdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChmcmFnbWVudCk7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHRcdC8vIEZpcnN0IHBhc3M6IFByb2Nlc3MgdG9wLWxldmVsIGRpdnNcblx0XHRjb25zdCBwcm9jZXNzVG9wTGV2ZWxEaXZzID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgdG9wRGl2cyA9IEFycmF5LmZyb20oZWxlbWVudC5jaGlsZHJlbikuZmlsdGVyKFxuXHRcdFx0XHRlbCA9PiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnXG5cdFx0XHQpO1xuXHRcdFx0XG5cdFx0XHRsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblx0XHRcdHRvcERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRpZiAocHJvY2Vzc0RpdihkaXYpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBtb2RpZmllZDtcblx0XHR9O1xuXG5cdFx0Ly8gU2Vjb25kIHBhc3M6IFByb2Nlc3MgcmVtYWluaW5nIGRpdnMgZnJvbSBkZWVwZXN0IHRvIHNoYWxsb3dlc3Rcblx0XHRjb25zdCBwcm9jZXNzUmVtYWluaW5nRGl2cyA9ICgpID0+IHtcblx0XHRcdGNvbnN0IGFsbERpdnMgPSBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RpdicpKVxuXHRcdFx0XHQuc29ydCgoYSwgYikgPT4ge1xuXHRcdFx0XHRcdC8vIENvdW50IG5lc3RpbmcgZGVwdGhcblx0XHRcdFx0XHRjb25zdCBnZXREZXB0aCA9IChlbDogRWxlbWVudCk6IG51bWJlciA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgZGVwdGggPSAwO1xuXHRcdFx0XHRcdFx0bGV0IHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2JykgZGVwdGgrKztcblx0XHRcdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGVwdGg7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZXR1cm4gZ2V0RGVwdGgoYikgLSBnZXREZXB0aChhKTsgLy8gUHJvY2VzcyBkZWVwZXN0IGZpcnN0XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblx0XHRcdGFsbERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRpZiAocHJvY2Vzc0RpdihkaXYpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBtb2RpZmllZDtcblx0XHR9O1xuXG5cdFx0Ly8gRmluYWwgY2xlYW51cCBwYXNzIC0gYWdncmVzc2l2ZWx5IGZsYXR0ZW4gcmVtYWluaW5nIGRpdnNcblx0XHRjb25zdCBmaW5hbENsZWFudXAgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCByZW1haW5pbmdEaXZzID0gQXJyYXkuZnJvbShlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKSk7XG5cdFx0XHRsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblx0XHRcdFxuXHRcdFx0cmVtYWluaW5nRGl2cy5mb3JFYWNoKGRpdiA9PiB7XG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiBvbmx5IGNvbnRhaW5zIHBhcmFncmFwaHNcblx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGRpdi5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IG9ubHlQYXJhZ3JhcGhzID0gY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncCcpO1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKG9ubHlQYXJhZ3JhcGhzIHx8ICghc2hvdWxkUHJlc2VydmVFbGVtZW50KGRpdikgJiYgaXNXcmFwcGVyRGl2KGRpdikpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFx0d2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG5cdFx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChmcmFnbWVudCk7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0XHRtb2RpZmllZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIG1vZGlmaWVkO1xuXHRcdH07XG5cblx0XHQvLyBFeGVjdXRlIGFsbCBwYXNzZXMgdW50aWwgbm8gbW9yZSBjaGFuZ2VzXG5cdFx0ZG8ge1xuXHRcdFx0XHRrZWVwUHJvY2Vzc2luZyA9IGZhbHNlO1xuXHRcdFx0XHRpZiAocHJvY2Vzc1RvcExldmVsRGl2cygpKSBrZWVwUHJvY2Vzc2luZyA9IHRydWU7XG5cdFx0XHRcdGlmIChwcm9jZXNzUmVtYWluaW5nRGl2cygpKSBrZWVwUHJvY2Vzc2luZyA9IHRydWU7XG5cdFx0XHRcdGlmIChmaW5hbENsZWFudXAoKSkga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0fSB3aGlsZSAoa2VlcFByb2Nlc3NpbmcpO1xuXG5cdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHRoaXMuX2xvZygnRmxhdHRlbmVkIGRpdnM6Jywge1xuXHRcdFx0Y291bnQ6IHByb2Nlc3NlZENvdW50LFxuXHRcdFx0cHJvY2Vzc2luZ1RpbWU6IGAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zYFxuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBjbGVhbkNvbnRlbnQoZWxlbWVudDogRWxlbWVudCwgbWV0YWRhdGE6IERlZnVkZGxlTWV0YWRhdGEpIHtcblx0XHQvLyBSZW1vdmUgSFRNTCBjb21tZW50c1xuXHRcdHRoaXMucmVtb3ZlSHRtbENvbW1lbnRzKGVsZW1lbnQpO1xuXHRcdFxuXHRcdC8vIEhhbmRsZSBIMSBlbGVtZW50cyAtIHJlbW92ZSBmaXJzdCBvbmUgYW5kIGNvbnZlcnQgb3RoZXJzIHRvIEgyXG5cdFx0dGhpcy5oYW5kbGVIZWFkaW5ncyhlbGVtZW50LCBtZXRhZGF0YS50aXRsZSk7XG5cdFx0XG5cdFx0Ly8gU3RhbmRhcmRpemUgZm9vdG5vdGVzIGFuZCBjaXRhdGlvbnNcblx0XHR0aGlzLnN0YW5kYXJkaXplRm9vdG5vdGVzKGVsZW1lbnQpO1xuXG5cdFx0Ly8gSGFuZGxlIGxhenktbG9hZGVkIGltYWdlc1xuXHRcdHRoaXMuaGFuZGxlTGF6eUltYWdlcyhlbGVtZW50KTtcblxuXHRcdC8vIENvbnZlcnQgZW1iZWRkZWQgY29udGVudCB0byBzdGFuZGFyZCBmb3JtYXRzXG5cdFx0dGhpcy5zdGFuZGFyZGl6ZUVsZW1lbnRzKGVsZW1lbnQpO1xuXG5cdFx0Ly8gU2tpcCBkaXYgZmxhdHRlbmluZyBpbiBkZWJ1ZyBtb2RlXG5cdFx0aWYgKCF0aGlzLmRlYnVnKSB7XG5cdFx0XHQvLyBGaXJzdCBwYXNzIG9mIGRpdiBmbGF0dGVuaW5nXG5cdFx0XHR0aGlzLmZsYXR0ZW5EaXZzKGVsZW1lbnQpO1xuXHRcdFx0XG5cdFx0XHQvLyBTdHJpcCB1bndhbnRlZCBhdHRyaWJ1dGVzXG5cdFx0XHR0aGlzLnN0cmlwVW53YW50ZWRBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXG5cdFx0XHQvLyBSZW1vdmUgZW1wdHkgZWxlbWVudHNcblx0XHRcdHRoaXMucmVtb3ZlRW1wdHlFbGVtZW50cyhlbGVtZW50KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIHRyYWlsaW5nIGhlYWRpbmdzXG5cdFx0XHR0aGlzLnJlbW92ZVRyYWlsaW5nSGVhZGluZ3MoZWxlbWVudCk7XG5cblx0XHRcdC8vIEZpbmFsIHBhc3Mgb2YgZGl2IGZsYXR0ZW5pbmcgYWZ0ZXIgY2xlYW51cCBvcGVyYXRpb25zXG5cdFx0XHR0aGlzLmZsYXR0ZW5EaXZzKGVsZW1lbnQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBJbiBkZWJ1ZyBtb2RlLCBzdGlsbCBkbyBiYXNpYyBjbGVhbnVwIGJ1dCBwcmVzZXJ2ZSBzdHJ1Y3R1cmVcblx0XHRcdHRoaXMuc3RyaXBVbndhbnRlZEF0dHJpYnV0ZXMoZWxlbWVudCk7XG5cdFx0XHR0aGlzLnJlbW92ZUVtcHR5RWxlbWVudHMoZWxlbWVudCk7XG5cdFx0XHR0aGlzLnJlbW92ZVRyYWlsaW5nSGVhZGluZ3MoZWxlbWVudCk7XG5cdFx0XHR0aGlzLl9sb2coJ0RlYnVnIG1vZGU6IFNraXBwaW5nIGRpdiBmbGF0dGVuaW5nIHRvIHByZXNlcnZlIHN0cnVjdHVyZScpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlVHJhaWxpbmdIZWFkaW5ncyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHJlbW92ZWRDb3VudCA9IDA7XG5cblx0XHRjb25zdCBoYXNDb250ZW50QWZ0ZXIgPSAoZWw6IEVsZW1lbnQpOiBib29sZWFuID0+IHtcblx0XHRcdC8vIENoZWNrIGlmIHRoZXJlJ3MgYW55IG1lYW5pbmdmdWwgY29udGVudCBhZnRlciB0aGlzIGVsZW1lbnRcblx0XHRcdGxldCBuZXh0Q29udGVudCA9ICcnO1xuXHRcdFx0bGV0IHNpYmxpbmcgPSBlbC5uZXh0U2libGluZztcblxuXHRcdFx0Ly8gRmlyc3QgY2hlY2sgZGlyZWN0IHNpYmxpbmdzXG5cdFx0XHR3aGlsZSAoc2libGluZykge1xuXHRcdFx0XHRpZiAoc2libGluZy5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdFx0XHRuZXh0Q29udGVudCArPSBzaWJsaW5nLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNpYmxpbmcubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG5cdFx0XHRcdFx0Ly8gSWYgd2UgZmluZCBhbiBlbGVtZW50IHNpYmxpbmcsIGNoZWNrIGl0cyBjb250ZW50XG5cdFx0XHRcdFx0bmV4dENvbnRlbnQgKz0gKHNpYmxpbmcgYXMgRWxlbWVudCkudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2libGluZyA9IHNpYmxpbmcubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdlIGZvdW5kIG1lYW5pbmdmdWwgY29udGVudCBhdCB0aGlzIGxldmVsLCByZXR1cm4gdHJ1ZVxuXHRcdFx0aWYgKG5leHRDb250ZW50LnRyaW0oKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgbm8gY29udGVudCBmb3VuZCBhdCB0aGlzIGxldmVsIGFuZCB3ZSBoYXZlIGEgcGFyZW50LFxuXHRcdFx0Ly8gY2hlY2sgZm9yIGNvbnRlbnQgYWZ0ZXIgdGhlIHBhcmVudFxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZWwucGFyZW50RWxlbWVudDtcblx0XHRcdGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBlbGVtZW50KSB7XG5cdFx0XHRcdHJldHVybiBoYXNDb250ZW50QWZ0ZXIocGFyZW50KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBQcm9jZXNzIGFsbCBoZWFkaW5ncyBmcm9tIGJvdHRvbSB0byB0b3Bcblx0XHRjb25zdCBoZWFkaW5ncyA9IEFycmF5LmZyb20oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdoMSwgaDIsIGgzLCBoNCwgaDUsIGg2JykpXG5cdFx0XHQucmV2ZXJzZSgpO1xuXG5cdFx0aGVhZGluZ3MuZm9yRWFjaChoZWFkaW5nID0+IHtcblx0XHRcdGlmICghaGFzQ29udGVudEFmdGVyKGhlYWRpbmcpKSB7XG5cdFx0XHRcdGhlYWRpbmcucmVtb3ZlKCk7XG5cdFx0XHRcdHJlbW92ZWRDb3VudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gU3RvcCBwcm9jZXNzaW5nIG9uY2Ugd2UgZmluZCBhIGhlYWRpbmcgd2l0aCBjb250ZW50IGFmdGVyIGl0XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChyZW1vdmVkQ291bnQgPiAwKSB7XG5cdFx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgdHJhaWxpbmcgaGVhZGluZ3M6JywgcmVtb3ZlZENvdW50KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIGhhbmRsZUhlYWRpbmdzKGVsZW1lbnQ6IEVsZW1lbnQsIHRpdGxlOiBzdHJpbmcpIHtcblx0XHRjb25zdCBoMXMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMScpO1xuXG5cdFx0QXJyYXkuZnJvbShoMXMpLmZvckVhY2goaDEgPT4ge1xuXHRcdFx0Y29uc3QgaDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuXHRcdFx0aDIuaW5uZXJIVE1MID0gaDEuaW5uZXJIVE1MO1xuXHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXNcblx0XHRcdEFycmF5LmZyb20oaDEuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdGgyLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGgxLnBhcmVudE5vZGU/LnJlcGxhY2VDaGlsZChoMiwgaDEpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIGZpcnN0IEgyIGlmIGl0IG1hdGNoZXMgdGl0bGVcblx0XHRjb25zdCBoMnMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoMicpO1xuXHRcdGlmIChoMnMubGVuZ3RoID4gMCkge1xuXHRcdFx0Y29uc3QgZmlyc3RIMiA9IGgyc1swXTtcblx0XHRcdGNvbnN0IGZpcnN0SDJUZXh0ID0gZmlyc3RIMi50ZXh0Q29udGVudD8udHJpbSgpLnRvTG93ZXJDYXNlKCkgfHwgJyc7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkVGl0bGUgPSB0aXRsZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblx0XHRcdGlmIChub3JtYWxpemVkVGl0bGUgJiYgbm9ybWFsaXplZFRpdGxlID09PSBmaXJzdEgyVGV4dCkge1xuXHRcdFx0XHRmaXJzdEgyLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlSHRtbENvbW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRjb25zdCBjb21tZW50czogQ29tbWVudFtdID0gW107XG5cdFx0Y29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHROb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCxcblx0XHRcdG51bGxcblx0XHQpO1xuXG5cdFx0bGV0IG5vZGU7XG5cdFx0d2hpbGUgKG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKSkge1xuXHRcdFx0Y29tbWVudHMucHVzaChub2RlIGFzIENvbW1lbnQpO1xuXHRcdH1cblxuXHRcdGNvbW1lbnRzLmZvckVhY2goY29tbWVudCA9PiB7XG5cdFx0XHRjb21tZW50LnJlbW92ZSgpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIEhUTUwgY29tbWVudHM6JywgY29tbWVudHMubGVuZ3RoKTtcblx0fVxuXG5cdHByaXZhdGUgc3RyaXBVbndhbnRlZEF0dHJpYnV0ZXMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCBhdHRyaWJ1dGVDb3VudCA9IDA7XG5cblx0XHRjb25zdCBwcm9jZXNzRWxlbWVudCA9IChlbDogRWxlbWVudCkgPT4ge1xuXHRcdFx0Ly8gU2tpcCBTVkcgZWxlbWVudHMgLSBwcmVzZXJ2ZSBhbGwgdGhlaXIgYXR0cmlidXRlc1xuXHRcdFx0aWYgKGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKGVsLmF0dHJpYnV0ZXMpO1xuXHRcdFx0XG5cdFx0XHRhdHRyaWJ1dGVzLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdGNvbnN0IGF0dHJOYW1lID0gYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdC8vIEluIGRlYnVnIG1vZGUsIGFsbG93IGRlYnVnIGF0dHJpYnV0ZXMgYW5kIGRhdGEtIGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRpZiAoIUFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ck5hbWUpICYmIFxuXHRcdFx0XHRcdFx0IUFMTE9XRURfQVRUUklCVVRFU19ERUJVRy5oYXMoYXR0ck5hbWUpICYmIFxuXHRcdFx0XHRcdFx0IWF0dHJOYW1lLnN0YXJ0c1dpdGgoJ2RhdGEtJykpIHtcblx0XHRcdFx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuXHRcdFx0XHRcdFx0YXR0cmlidXRlQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSW4gbm9ybWFsIG1vZGUsIG9ubHkgYWxsb3cgc3RhbmRhcmQgYXR0cmlidXRlc1xuXHRcdFx0XHRcdGlmICghQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyTmFtZSkpIHtcblx0XHRcdFx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5hbWUpO1xuXHRcdFx0XHRcdFx0YXR0cmlidXRlQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRwcm9jZXNzRWxlbWVudChlbGVtZW50KTtcblx0XHRlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKS5mb3JFYWNoKHByb2Nlc3NFbGVtZW50KTtcblxuXHRcdHRoaXMuX2xvZygnU3RyaXBwZWQgYXR0cmlidXRlczonLCBhdHRyaWJ1dGVDb3VudCk7XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUVtcHR5RWxlbWVudHMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCByZW1vdmVkQ291bnQgPSAwO1xuXHRcdGxldCBpdGVyYXRpb25zID0gMDtcblx0XHRsZXQga2VlcFJlbW92aW5nID0gdHJ1ZTtcblxuXHRcdHdoaWxlIChrZWVwUmVtb3ZpbmcpIHtcblx0XHRcdGl0ZXJhdGlvbnMrKztcblx0XHRcdGtlZXBSZW1vdmluZyA9IGZhbHNlO1xuXHRcdFx0Ly8gR2V0IGFsbCBlbGVtZW50cyB3aXRob3V0IGNoaWxkcmVuLCB3b3JraW5nIGZyb20gZGVlcGVzdCBmaXJzdFxuXHRcdFx0Y29uc3QgZW1wdHlFbGVtZW50cyA9IEFycmF5LmZyb20oZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpKS5maWx0ZXIoZWwgPT4ge1xuXHRcdFx0XHRpZiAoQUxMT1dFRF9FTVBUWV9FTEVNRU5UUy5oYXMoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZWxlbWVudCBoYXMgb25seSB3aGl0ZXNwYWNlIG9yICZuYnNwO1xuXHRcdFx0XHRjb25zdCB0ZXh0Q29udGVudCA9IGVsLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHRjb25zdCBoYXNPbmx5V2hpdGVzcGFjZSA9IHRleHRDb250ZW50LnRyaW0oKS5sZW5ndGggPT09IDA7XG5cdFx0XHRcdGNvbnN0IGhhc05ic3AgPSB0ZXh0Q29udGVudC5pbmNsdWRlcygnXFx1MDBBMCcpOyAvLyBVbmljb2RlIG5vbi1icmVha2luZyBzcGFjZVxuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ2hlY2sgaWYgZWxlbWVudCBoYXMgbm8gbWVhbmluZ2Z1bCBjaGlsZHJlblxuXHRcdFx0XHRjb25zdCBoYXNOb0NoaWxkcmVuID0gIWVsLmhhc0NoaWxkTm9kZXMoKSB8fCBcblx0XHRcdFx0XHQoQXJyYXkuZnJvbShlbC5jaGlsZE5vZGVzKS5ldmVyeShub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBub2RlVGV4dCA9IG5vZGUudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBub2RlVGV4dC50cmltKCkubGVuZ3RoID09PSAwICYmICFub2RlVGV4dC5pbmNsdWRlcygnXFx1MDBBMCcpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH0pKTtcblxuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2U6IENoZWNrIGZvciBkaXZzIHRoYXQgb25seSBjb250YWluIHNwYW5zIHdpdGggY29tbWFzXG5cdFx0XHRcdGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKTtcblx0XHRcdFx0XHRjb25zdCBoYXNPbmx5Q29tbWFTcGFucyA9IGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3NwYW4nKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRjb25zdCBjb250ZW50ID0gY2hpbGQudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdFx0XHRcdHJldHVybiBjb250ZW50ID09PSAnLCcgfHwgY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJyAnO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmIChoYXNPbmx5Q29tbWFTcGFucykgcmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gaGFzT25seVdoaXRlc3BhY2UgJiYgIWhhc05ic3AgJiYgaGFzTm9DaGlsZHJlbjtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoZW1wdHlFbGVtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGVtcHR5RWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRcdFx0ZWwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0cmVtb3ZlZENvdW50Kys7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRrZWVwUmVtb3ZpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2xvZygnUmVtb3ZlZCBlbXB0eSBlbGVtZW50czonLCB7XG5cdFx0XHRjb3VudDogcmVtb3ZlZENvdW50LFxuXHRcdFx0aXRlcmF0aW9uc1xuXHRcdH0pO1xuXHR9XG5cblx0cHJpdmF0ZSBjcmVhdGVGb290bm90ZUl0ZW0oXG5cdFx0Zm9vdG5vdGVOdW1iZXI6IG51bWJlcixcblx0XHRjb250ZW50OiBzdHJpbmcgfCBFbGVtZW50LFxuXHRcdHJlZnM6IHN0cmluZ1tdXG5cdCk6IEhUTUxMSUVsZW1lbnQge1xuXHRcdGNvbnN0IG5ld0l0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuXHRcdG5ld0l0ZW0uY2xhc3NOYW1lID0gJ2Zvb3Rub3RlJztcblx0XHRuZXdJdGVtLmlkID0gYGZuOiR7Zm9vdG5vdGVOdW1iZXJ9YDtcblxuXHRcdC8vIEhhbmRsZSBjb250ZW50XG5cdFx0aWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuXHRcdFx0Y29uc3QgcGFyYWdyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0cGFyYWdyYXBoLmlubmVySFRNTCA9IGNvbnRlbnQ7XG5cdFx0XHRuZXdJdGVtLmFwcGVuZENoaWxkKHBhcmFncmFwaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEdldCBhbGwgcGFyYWdyYXBocyBmcm9tIHRoZSBjb250ZW50XG5cdFx0XHRjb25zdCBwYXJhZ3JhcGhzID0gQXJyYXkuZnJvbShjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3AnKSk7XG5cdFx0XHRpZiAocGFyYWdyYXBocy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0Ly8gSWYgbm8gcGFyYWdyYXBocywgd3JhcCBjb250ZW50IGluIGEgcGFyYWdyYXBoXG5cdFx0XHRcdGNvbnN0IHBhcmFncmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0cGFyYWdyYXBoLmlubmVySFRNTCA9IGNvbnRlbnQuaW5uZXJIVE1MO1xuXHRcdFx0XHRuZXdJdGVtLmFwcGVuZENoaWxkKHBhcmFncmFwaCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBDb3B5IGV4aXN0aW5nIHBhcmFncmFwaHNcblx0XHRcdFx0cGFyYWdyYXBocy5mb3JFYWNoKHAgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IG5ld1AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdFx0bmV3UC5pbm5lckhUTUwgPSBwLmlubmVySFRNTDtcblx0XHRcdFx0XHRuZXdJdGVtLmFwcGVuZENoaWxkKG5ld1ApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgYmFja2xpbmsocykgdG8gdGhlIGxhc3QgcGFyYWdyYXBoXG5cdFx0Y29uc3QgbGFzdFBhcmFncmFwaCA9IG5ld0l0ZW0ucXVlcnlTZWxlY3RvcigncDpsYXN0LW9mLXR5cGUnKSB8fCBuZXdJdGVtO1xuXHRcdHJlZnMuZm9yRWFjaCgocmVmSWQsIGluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBiYWNrbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblx0XHRcdGJhY2tsaW5rLmhyZWYgPSBgIyR7cmVmSWR9YDtcblx0XHRcdGJhY2tsaW5rLnRpdGxlID0gJ3JldHVybiB0byBhcnRpY2xlJztcblx0XHRcdGJhY2tsaW5rLmNsYXNzTmFtZSA9ICdmb290bm90ZS1iYWNrcmVmJztcblx0XHRcdGJhY2tsaW5rLmlubmVySFRNTCA9ICfihqknO1xuXHRcdFx0aWYgKGluZGV4IDwgcmVmcy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdGJhY2tsaW5rLmlubmVySFRNTCArPSAnICc7XG5cdFx0XHR9XG5cdFx0XHRsYXN0UGFyYWdyYXBoLmFwcGVuZENoaWxkKGJhY2tsaW5rKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBuZXdJdGVtO1xuXHR9XG5cblx0cHJpdmF0ZSBjb2xsZWN0Rm9vdG5vdGVzKGVsZW1lbnQ6IEVsZW1lbnQpOiBGb290bm90ZUNvbGxlY3Rpb24ge1xuXHRcdGNvbnN0IGZvb3Rub3RlczogRm9vdG5vdGVDb2xsZWN0aW9uID0ge307XG5cdFx0bGV0IGZvb3Rub3RlQ291bnQgPSAxO1xuXHRcdGNvbnN0IHByb2Nlc3NlZElkcyA9IG5ldyBTZXQ8c3RyaW5nPigpOyAvLyBUcmFjayBwcm9jZXNzZWQgSURzXG5cblx0XHQvLyBDb2xsZWN0IGFsbCBmb290bm90ZXMgYW5kIHRoZWlyIElEcyBmcm9tIGZvb3Rub3RlIGxpc3RzXG5cdFx0Y29uc3QgZm9vdG5vdGVMaXN0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChGT09UTk9URV9MSVNUX1NFTEVDVE9SUyk7XG5cdFx0Zm9vdG5vdGVMaXN0cy5mb3JFYWNoKGxpc3QgPT4ge1xuXHRcdFx0Ly8gU3Vic3RhY2sgaGFzIGluZGl2aWR1YWwgZm9vdG5vdGUgZGl2cyB3aXRoIG5vIHBhcmVudFxuXHRcdFx0aWYgKGxpc3QubWF0Y2hlcygnZGl2LmZvb3Rub3RlW2RhdGEtY29tcG9uZW50LW5hbWU9XCJGb290bm90ZVRvRE9NXCJdJykpIHtcblx0XHRcdFx0Y29uc3QgYW5jaG9yID0gbGlzdC5xdWVyeVNlbGVjdG9yKCdhLmZvb3Rub3RlLW51bWJlcicpO1xuXHRcdFx0XHRjb25zdCBjb250ZW50ID0gbGlzdC5xdWVyeVNlbGVjdG9yKCcuZm9vdG5vdGUtY29udGVudCcpO1xuXHRcdFx0XHRpZiAoYW5jaG9yICYmIGNvbnRlbnQpIHtcblx0XHRcdFx0XHRjb25zdCBpZCA9IGFuY2hvci5pZC5yZXBsYWNlKCdmb290bm90ZS0nLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoaWQgJiYgIXByb2Nlc3NlZElkcy5oYXMoaWQpKSB7XG5cdFx0XHRcdFx0XHRmb290bm90ZXNbZm9vdG5vdGVDb3VudF0gPSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRlbnQ6IGNvbnRlbnQsXG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsSWQ6IGlkLFxuXHRcdFx0XHRcdFx0XHRyZWZzOiBbXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHByb2Nlc3NlZElkcy5hZGQoaWQpO1xuXHRcdFx0XHRcdFx0Zm9vdG5vdGVDb3VudCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbW1vbiBmb3JtYXQgdXNpbmcgT0wvVUwgYW5kIExJIGVsZW1lbnRzXG5cdFx0XHRjb25zdCBpdGVtcyA9IGxpc3QucXVlcnlTZWxlY3RvckFsbCgnbGksIGRpdltyb2xlPVwibGlzdGl0ZW1cIl0nKTtcblx0XHRcdGl0ZW1zLmZvckVhY2gobGkgPT4ge1xuXHRcdFx0XHRsZXQgaWQgPSAnJztcblx0XHRcdFx0bGV0IGNvbnRlbnQ6IEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuXHRcdFx0XHQvLyBIYW5kbGUgY2l0YXRpb25zIHdpdGggLmNpdGF0aW9ucyBjbGFzc1xuXHRcdFx0XHRjb25zdCBjaXRhdGlvbnNEaXYgPSBsaS5xdWVyeVNlbGVjdG9yKCcuY2l0YXRpb25zJyk7XG5cdFx0XHRcdGlmIChjaXRhdGlvbnNEaXY/LmlkPy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3InKSkge1xuXHRcdFx0XHRcdGlkID0gY2l0YXRpb25zRGl2LmlkLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0Ly8gTG9vayBmb3IgY2l0YXRpb24gY29udGVudCB3aXRoaW4gdGhlIGNpdGF0aW9ucyBkaXZcblx0XHRcdFx0XHRjb25zdCBjaXRhdGlvbkNvbnRlbnQgPSBjaXRhdGlvbnNEaXYucXVlcnlTZWxlY3RvcignLmNpdGF0aW9uLWNvbnRlbnQnKTtcblx0XHRcdFx0XHRpZiAoY2l0YXRpb25Db250ZW50KSB7XG5cdFx0XHRcdFx0XHRjb250ZW50ID0gY2l0YXRpb25Db250ZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBFeHRyYWN0IElEIGZyb20gdmFyaW91cyBmb3JtYXRzXG5cdFx0XHRcdFx0aWYgKGxpLmlkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnYmliLmJpYicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmlkLnJlcGxhY2UoJ2JpYi5iaWInLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGxpLmlkLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnZm46JykpIHtcblx0XHRcdFx0XHRcdGlkID0gbGkuaWQucmVwbGFjZSgnZm46JywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsaS5pZC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2ZuJykpIHtcblx0XHRcdFx0XHRcdGlkID0gbGkuaWQucmVwbGFjZSgnZm4nLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHQvLyBOYXR1cmUuY29tXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsaS5oYXNBdHRyaWJ1dGUoJ2RhdGEtY291bnRlcicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3VudGVyJyk/LnJlcGxhY2UoL1xcLiQvLCAnJyk/LnRvTG93ZXJDYXNlKCkgfHwgJyc7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gbGkuaWQuc3BsaXQoJy8nKS5wb3AoKT8ubWF0Y2goL2NpdGVfbm90ZS0oLispLyk7XG5cdFx0XHRcdFx0XHRpZCA9IG1hdGNoID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6IGxpLmlkLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRlbnQgPSBsaTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpZCAmJiAhcHJvY2Vzc2VkSWRzLmhhcyhpZCkpIHtcblx0XHRcdFx0XHRmb290bm90ZXNbZm9vdG5vdGVDb3VudF0gPSB7XG5cdFx0XHRcdFx0XHRjb250ZW50OiBjb250ZW50IHx8IGxpLFxuXHRcdFx0XHRcdFx0b3JpZ2luYWxJZDogaWQsXG5cdFx0XHRcdFx0XHRyZWZzOiBbXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cHJvY2Vzc2VkSWRzLmFkZChpZCk7XG5cdFx0XHRcdFx0Zm9vdG5vdGVDb3VudCsrO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBmb290bm90ZXM7XG5cdH1cblxuXHRwcml2YXRlIGZpbmRPdXRlckZvb3Rub3RlQ29udGFpbmVyKGVsOiBFbGVtZW50KTogRWxlbWVudCB7XG5cdFx0bGV0IGN1cnJlbnQ6IEVsZW1lbnQgfCBudWxsID0gZWw7XG5cdFx0bGV0IHBhcmVudDogRWxlbWVudCB8IG51bGwgPSBlbC5wYXJlbnRFbGVtZW50O1xuXHRcdFxuXHRcdC8vIEtlZXAgZ29pbmcgdXAgdW50aWwgd2UgZmluZCBhbiBlbGVtZW50IHRoYXQncyBub3QgYSBzcGFuIG9yIHN1cFxuXHRcdHdoaWxlIChwYXJlbnQgJiYgKFxuXHRcdFx0cGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3NwYW4nIHx8IFxuXHRcdFx0cGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1cCdcblx0XHQpKSB7XG5cdFx0XHRjdXJyZW50ID0gcGFyZW50O1xuXHRcdFx0cGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBjdXJyZW50O1xuXHR9XG5cblx0Ly8gRXZlcnkgZm9vdG5vdGUgcmVmZXJlbmNlIHNob3VsZCBiZSBhIHN1cCBlbGVtZW50IHdpdGggYW4gYW5jaG9yIGluc2lkZVxuXHQvLyBlLmcuIDxzdXAgaWQ9XCJmbnJlZjoxXCI+PGEgaHJlZj1cIiNmbjoxXCI+MTwvYT48L3N1cD5cblx0cHJpdmF0ZSBjcmVhdGVGb290bm90ZVJlZmVyZW5jZShmb290bm90ZU51bWJlcjogc3RyaW5nLCByZWZJZDogc3RyaW5nKTogSFRNTEVsZW1lbnQge1xuXHRcdGNvbnN0IHN1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N1cCcpO1xuXHRcdHN1cC5pZCA9IHJlZklkO1xuXHRcdGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0bGluay5ocmVmID0gYCNmbjoke2Zvb3Rub3RlTnVtYmVyfWA7XG5cdFx0bGluay50ZXh0Q29udGVudCA9IGZvb3Rub3RlTnVtYmVyO1xuXHRcdHN1cC5hcHBlbmRDaGlsZChsaW5rKTtcblx0XHRyZXR1cm4gc3VwO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFuZGFyZGl6ZUZvb3Rub3RlcyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0Y29uc3QgZm9vdG5vdGVzID0gdGhpcy5jb2xsZWN0Rm9vdG5vdGVzKGVsZW1lbnQpO1xuXG5cdFx0Ly8gU3RhbmRhcmRpemUgaW5saW5lIGZvb3Rub3RlcyB1c2luZyB0aGUgY29sbGVjdGVkIElEc1xuXHRcdGNvbnN0IGZvb3Rub3RlSW5saW5lUmVmZXJlbmNlcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChGT09UTk9URV9JTkxJTkVfUkVGRVJFTkNFUyk7XG5cdFx0XG5cdFx0Ly8gR3JvdXAgcmVmZXJlbmNlcyBieSB0aGVpciBwYXJlbnQgc3VwIGVsZW1lbnRcblx0XHRjb25zdCBzdXBHcm91cHMgPSBuZXcgTWFwPEVsZW1lbnQsIEVsZW1lbnRbXT4oKTtcblx0XHRcblx0XHRmb290bm90ZUlubGluZVJlZmVyZW5jZXMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuO1xuXG5cdFx0XHRsZXQgZm9vdG5vdGVJZCA9ICcnO1xuXHRcdFx0bGV0IGZvb3Rub3RlQ29udGVudCA9ICcnO1xuXG5cdFx0XHQvLyBFeHRyYWN0IGZvb3Rub3RlIElEIGJhc2VkIG9uIGVsZW1lbnQgdHlwZVxuXHRcdFx0Ly8gTmF0dXJlLmNvbVxuXHRcdFx0aWYgKGVsLm1hdGNoZXMoJ2FbaWRePVwicmVmLWxpbmtcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdC8vIFNjaWVuY2Uub3JnXG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2Fbcm9sZT1cImRvYy1iaWJsaW9yZWZcIl0nKSkge1xuXHRcdFx0XHRjb25zdCB4bWxSaWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEteG1sLXJpZCcpO1xuXHRcdFx0XHRpZiAoeG1sUmlkKSB7XG5cdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IHhtbFJpZDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zdCBocmVmID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cdFx0XHRcdFx0aWYgKGhyZWY/LnN0YXJ0c1dpdGgoJyNjb3JlLVInKSkge1xuXHRcdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IGhyZWYucmVwbGFjZSgnI2NvcmUtJywgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0Ly8gU3Vic3RhY2tcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnYS5mb290bm90ZS1hbmNob3IsIHNwYW4uZm9vdG5vdGUtaG92ZXJjYXJkLXRhcmdldCBhJykpIHtcblx0XHRcdFx0Y29uc3QgaWQgPSBlbC5pZD8ucmVwbGFjZSgnZm9vdG5vdGUtYW5jaG9yLScsICcnKSB8fCAnJztcblx0XHRcdFx0aWYgKGlkKSB7XG5cdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdC8vIEFyeGl2XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2NpdGUubHR4X2NpdGUnKSkge1xuXHRcdFx0XHRjb25zdCBsaW5rID0gZWwucXVlcnlTZWxlY3RvcignYScpO1xuXHRcdFx0XHRpZiAobGluaykge1xuXHRcdFx0XHRcdGNvbnN0IGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRcdGlmIChocmVmKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGhyZWYuc3BsaXQoJy8nKS5wb3AoKT8ubWF0Y2goL2JpYlxcLmJpYihcXGQrKS8pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdzdXAucmVmZXJlbmNlJykpIHtcblx0XHRcdFx0Y29uc3QgbGlua3MgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdhJyk7XG5cdFx0XHRcdEFycmF5LmZyb20obGlua3MpLmZvckVhY2gobGluayA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cdFx0XHRcdFx0aWYgKGhyZWYpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gaHJlZi5zcGxpdCgnLycpLnBvcCgpPy5tYXRjaCgvKD86Y2l0ZV9ub3RlfGNpdGVfcmVmKS0oLispLyk7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0Zm9vdG5vdGVJZCA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3VwW2lkXj1cImZucmVmOlwiXScpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5pZC5yZXBsYWNlKCdmbnJlZjonLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3VwW2lkXj1cImZuclwiXScpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5pZC5yZXBsYWNlKCdmbnInLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3Bhbi5mb290bm90ZS1yZWZlcmVuY2UnKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWZvb3Rub3RlLWlkJykgfHwgJyc7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3NwYW4uZm9vdG5vdGUtbGluaycpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZm9vdG5vdGUtaWQnKSB8fCAnJztcblx0XHRcdFx0Zm9vdG5vdGVDb250ZW50ID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWZvb3Rub3RlLWNvbnRlbnQnKSB8fCAnJztcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnYS5jaXRhdGlvbicpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRmb290bm90ZUNvbnRlbnQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSB8fCAnJztcblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnYVtpZF49XCJmbnJlZlwiXScpKSB7XG5cdFx0XHRcdGZvb3Rub3RlSWQgPSBlbC5pZC5yZXBsYWNlKCdmbnJlZicsICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gT3RoZXIgY2l0YXRpb24gdHlwZXNcblx0XHRcdFx0Y29uc3QgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRpZiAoaHJlZikge1xuXHRcdFx0XHRcdGNvbnN0IGlkID0gaHJlZi5yZXBsYWNlKC9eWyNdLywgJycpO1xuXHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChmb290bm90ZUlkKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIGZvb3Rub3RlIG51bWJlciBieSBtYXRjaGluZyB0aGUgb3JpZ2luYWwgSURcblx0XHRcdFx0Y29uc3QgZm9vdG5vdGVFbnRyeSA9IE9iamVjdC5lbnRyaWVzKGZvb3Rub3RlcykuZmluZChcblx0XHRcdFx0XHQoW18sIGRhdGFdKSA9PiBkYXRhLm9yaWdpbmFsSWQgPT09IGZvb3Rub3RlSWQudG9Mb3dlckNhc2UoKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChmb290bm90ZUVudHJ5KSB7XG5cdFx0XHRcdFx0Y29uc3QgW2Zvb3Rub3RlTnVtYmVyLCBmb290bm90ZURhdGFdID0gZm9vdG5vdGVFbnRyeTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBDcmVhdGUgZm9vdG5vdGUgcmVmZXJlbmNlIElEXG5cdFx0XHRcdFx0Y29uc3QgcmVmSWQgPSBmb290bm90ZURhdGEucmVmcy5sZW5ndGggPiAwID8gXG5cdFx0XHRcdFx0XHRgZm5yZWY6JHtmb290bm90ZU51bWJlcn0tJHtmb290bm90ZURhdGEucmVmcy5sZW5ndGggKyAxfWAgOiBcblx0XHRcdFx0XHRcdGBmbnJlZjoke2Zvb3Rub3RlTnVtYmVyfWA7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Zm9vdG5vdGVEYXRhLnJlZnMucHVzaChyZWZJZCk7XG5cblx0XHRcdFx0XHQvLyBGaW5kIHRoZSBvdXRlcm1vc3QgY29udGFpbmVyIChzcGFuIG9yIHN1cClcblx0XHRcdFx0XHRjb25zdCBjb250YWluZXIgPSB0aGlzLmZpbmRPdXRlckZvb3Rub3RlQ29udGFpbmVyKGVsKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBJZiBjb250YWluZXIgaXMgYSBzdXAsIGdyb3VwIHJlZmVyZW5jZXNcblx0XHRcdFx0XHRpZiAoY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1cCcpIHtcblx0XHRcdFx0XHRcdGlmICghc3VwR3JvdXBzLmhhcyhjb250YWluZXIpKSB7XG5cdFx0XHRcdFx0XHRcdHN1cEdyb3Vwcy5zZXQoY29udGFpbmVyLCBbXSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb25zdCBncm91cCA9IHN1cEdyb3Vwcy5nZXQoY29udGFpbmVyKSE7XG5cdFx0XHRcdFx0XHRncm91cC5wdXNoKHRoaXMuY3JlYXRlRm9vdG5vdGVSZWZlcmVuY2UoZm9vdG5vdGVOdW1iZXIsIHJlZklkKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFJlcGxhY2UgdGhlIGNvbnRhaW5lciBkaXJlY3RseVxuXHRcdFx0XHRcdFx0Y29udGFpbmVyLnJlcGxhY2VXaXRoKHRoaXMuY3JlYXRlRm9vdG5vdGVSZWZlcmVuY2UoZm9vdG5vdGVOdW1iZXIsIHJlZklkKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBIYW5kbGUgZ3JvdXBlZCByZWZlcmVuY2VzXG5cdFx0c3VwR3JvdXBzLmZvckVhY2goKHJlZmVyZW5jZXMsIGNvbnRhaW5lcikgPT4ge1xuXHRcdFx0aWYgKHJlZmVyZW5jZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvLyBDcmVhdGUgYSBkb2N1bWVudCBmcmFnbWVudCB0byBob2xkIGFsbCB0aGUgcmVmZXJlbmNlc1xuXHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFkZCBlYWNoIHJlZmVyZW5jZSBhcyBpdHMgb3duIHN1cCBlbGVtZW50XG5cdFx0XHRcdHJlZmVyZW5jZXMuZm9yRWFjaCgocmVmLCBpbmRleCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmsgPSByZWYucXVlcnlTZWxlY3RvcignYScpO1xuXHRcdFx0XHRcdGlmIChsaW5rKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdXAnKTtcblx0XHRcdFx0XHRcdHN1cC5pZCA9IHJlZi5pZDtcblx0XHRcdFx0XHRcdHN1cC5hcHBlbmRDaGlsZChsaW5rLmNsb25lTm9kZSh0cnVlKSk7XG5cdFx0XHRcdFx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZChzdXApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRjb250YWluZXIucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gQ3JlYXRlIHRoZSBzdGFuZGFyZGl6ZWQgZm9vdG5vdGUgbGlzdFxuXHRcdGNvbnN0IG5ld0xpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb290bm90ZXMnKTtcblx0XHRuZXdMaXN0LmNsYXNzTmFtZSA9ICdmb290bm90ZXMnO1xuXHRcdGNvbnN0IG9yZGVyZWRMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb2wnKTtcblxuXHRcdC8vIENyZWF0ZSBmb290bm90ZSBpdGVtcyBpbiBvcmRlclxuXHRcdE9iamVjdC5lbnRyaWVzKGZvb3Rub3RlcykuZm9yRWFjaCgoW251bWJlciwgZGF0YV0pID0+IHtcblx0XHRcdGNvbnN0IG5ld0l0ZW0gPSB0aGlzLmNyZWF0ZUZvb3Rub3RlSXRlbShcblx0XHRcdFx0cGFyc2VJbnQobnVtYmVyKSxcblx0XHRcdFx0ZGF0YS5jb250ZW50LFxuXHRcdFx0XHRkYXRhLnJlZnNcblx0XHRcdCk7XG5cdFx0XHRvcmRlcmVkTGlzdC5hcHBlbmRDaGlsZChuZXdJdGVtKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlbW92ZSBvcmlnaW5hbCBmb290bm90ZSBsaXN0c1xuXHRcdGNvbnN0IGZvb3Rub3RlTGlzdHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMpO1xuXHRcdGZvb3Rub3RlTGlzdHMuZm9yRWFjaChsaXN0ID0+IGxpc3QucmVtb3ZlKCkpO1xuXG5cdFx0Ly8gSWYgd2UgaGF2ZSBhbnkgZm9vdG5vdGVzLCBhZGQgdGhlIG5ldyBsaXN0IHRvIHRoZSBkb2N1bWVudFxuXHRcdGlmIChvcmRlcmVkTGlzdC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0XHRuZXdMaXN0LmFwcGVuZENoaWxkKG9yZGVyZWRMaXN0KTtcblx0XHRcdGVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3TGlzdCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBoYW5kbGVMYXp5SW1hZ2VzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgcHJvY2Vzc2VkQ291bnQgPSAwO1xuXHRcdGNvbnN0IGxhenlJbWFnZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZ1tkYXRhLXNyY10sIGltZ1tkYXRhLXNyY3NldF0nKTtcblxuXHRcdGxhenlJbWFnZXMuZm9yRWFjaChpbWcgPT4ge1xuXHRcdFx0aWYgKCEoaW1nIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHJldHVybjtcblxuXHRcdFx0Ly8gSGFuZGxlIGRhdGEtc3JjXG5cdFx0XHRjb25zdCBkYXRhU3JjID0gaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblx0XHRcdGlmIChkYXRhU3JjICYmICFpbWcuc3JjKSB7XG5cdFx0XHRcdGltZy5zcmMgPSBkYXRhU3JjO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgZGF0YS1zcmNzZXRcblx0XHRcdGNvbnN0IGRhdGFTcmNzZXQgPSBpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdFx0aWYgKGRhdGFTcmNzZXQgJiYgIWltZy5zcmNzZXQpIHtcblx0XHRcdFx0aW1nLnNyY3NldCA9IGRhdGFTcmNzZXQ7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBsYXp5IGxvYWRpbmcgcmVsYXRlZCBjbGFzc2VzIGFuZCBhdHRyaWJ1dGVzXG5cdFx0XHRpbWcuY2xhc3NMaXN0LnJlbW92ZSgnbGF6eScsICdsYXp5bG9hZCcpO1xuXHRcdFx0aW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sbC1zdGF0dXMnKTtcblx0XHRcdGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG5cdFx0XHRpbWcucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdQcm9jZXNzZWQgbGF6eSBpbWFnZXM6JywgcHJvY2Vzc2VkQ291bnQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGFuZGFyZGl6ZUVsZW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgcHJvY2Vzc2VkQ291bnQgPSAwO1xuXG5cdFx0Ly8gQ29udmVydCBlbGVtZW50cyBiYXNlZCBvbiBzdGFuZGFyZGl6YXRpb24gcnVsZXNcblx0XHRFTEVNRU5UX1NUQU5EQVJESVpBVElPTl9SVUxFUy5mb3JFYWNoKHJ1bGUgPT4ge1xuXHRcdFx0Y29uc3QgZWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocnVsZS5zZWxlY3Rvcik7XG5cdFx0XHRlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcblx0XHRcdFx0aWYgKHJ1bGUudHJhbnNmb3JtKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlcmUncyBhIHRyYW5zZm9ybSBmdW5jdGlvbiwgdXNlIGl0IHRvIGNyZWF0ZSB0aGUgbmV3IGVsZW1lbnRcblx0XHRcdFx0XHRjb25zdCB0cmFuc2Zvcm1lZCA9IHJ1bGUudHJhbnNmb3JtKGVsKTtcblx0XHRcdFx0XHRlbC5yZXBsYWNlV2l0aCh0cmFuc2Zvcm1lZCk7XG5cdFx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHQvLyBDb252ZXJ0IGxpdGUteW91dHViZSBlbGVtZW50c1xuXHRcdGNvbnN0IGxpdGVZb3V0dWJlRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpdGUteW91dHViZScpO1xuXHRcdGxpdGVZb3V0dWJlRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRjb25zdCB2aWRlb0lkID0gZWwuZ2V0QXR0cmlidXRlKCd2aWRlb2lkJyk7XG5cdFx0XHRpZiAoIXZpZGVvSWQpIHJldHVybjtcblxuXHRcdFx0Y29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUud2lkdGggPSAnNTYwJztcblx0XHRcdGlmcmFtZS5oZWlnaHQgPSAnMzE1Jztcblx0XHRcdGlmcmFtZS5zcmMgPSBgaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvJHt2aWRlb0lkfWA7XG5cdFx0XHRpZnJhbWUudGl0bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3ZpZGVvdGl0bGUnKSB8fCAnWW91VHViZSB2aWRlbyBwbGF5ZXInO1xuXHRcdFx0aWZyYW1lLmZyYW1lQm9yZGVyID0gJzAnO1xuXHRcdFx0aWZyYW1lLmFsbG93ID0gJ2FjY2VsZXJvbWV0ZXI7IGF1dG9wbGF5OyBjbGlwYm9hcmQtd3JpdGU7IGVuY3J5cHRlZC1tZWRpYTsgZ3lyb3Njb3BlOyBwaWN0dXJlLWluLXBpY3R1cmU7IHdlYi1zaGFyZSc7XG5cdFx0XHRpZnJhbWUuc2V0QXR0cmlidXRlKCdhbGxvd2Z1bGxzY3JlZW4nLCAnJyk7XG5cblx0XHRcdGVsLnJlcGxhY2VXaXRoKGlmcmFtZSk7XG5cdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdDb252ZXJ0ZWQgZW1iZWRkZWQgZWxlbWVudHM6JywgcHJvY2Vzc2VkQ291bnQpO1xuXHR9XG5cblx0Ly8gRmluZCBzbWFsbCBJTUcgYW5kIFNWRyBlbGVtZW50c1xuXHRwcml2YXRlIGZpbmRTbWFsbEltYWdlcyhkb2M6IERvY3VtZW50KTogU2V0PHN0cmluZz4ge1xuXHRcdGNvbnN0IE1JTl9ESU1FTlNJT04gPSAzMztcblx0XHRjb25zdCBzbWFsbEltYWdlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXHRcdGNvbnN0IHRyYW5zZm9ybVJlZ2V4ID0gL3NjYWxlXFwoKFtcXGQuXSspXFwpLztcblx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRsZXQgcHJvY2Vzc2VkQ291bnQgPSAwO1xuXG5cdFx0Ly8gMS4gUmVhZCBwaGFzZSAtIEdhdGhlciBhbGwgZWxlbWVudHMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdGNvbnN0IGVsZW1lbnRzID0gW1xuXHRcdFx0Li4uQXJyYXkuZnJvbShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpKSxcblx0XHRcdC4uLkFycmF5LmZyb20oZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdmcnKSlcblx0XHRdLmZpbHRlcihlbGVtZW50ID0+IHtcblx0XHRcdC8vIFNraXAgbGF6eS1sb2FkZWQgaW1hZ2VzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXRcblx0XHRcdC8vIGFuZCBtYXRoIGltYWdlcyB3aGljaCBtYXkgYmUgc21hbGxcblx0XHRcdGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuXHRcdFx0XHRjb25zdCBpZ25vcmVkSW1hZ2UgPSBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbGF6eScpIHx8IFxuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXp5bG9hZCcpIHx8XG5cdFx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2xhdGV4JykgfHxcblx0XHRcdFx0XHRlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGVjb2RpbmcnKSB8fFxuXHRcdFx0XHRcdGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXNyYycpIHx8XG5cdFx0XHRcdFx0ZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc3Jjc2V0Jyk7XG5cdFx0XHRcdHJldHVybiAhaWdub3JlZEltYWdlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cblx0XHRpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm4gc21hbGxJbWFnZXM7XG5cdFx0fVxuXG5cdFx0Ly8gMi4gQmF0Y2ggcHJvY2VzcyAtIENvbGxlY3QgYWxsIG1lYXN1cmVtZW50cyBpbiBvbmUgZ29cblx0XHRjb25zdCBtZWFzdXJlbWVudHMgPSBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiAoe1xuXHRcdFx0ZWxlbWVudCxcblx0XHRcdC8vIFN0YXRpYyBhdHRyaWJ1dGVzIChubyByZWZsb3cpXG5cdFx0XHRuYXR1cmFsV2lkdGg6IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID8gZWxlbWVudC5uYXR1cmFsV2lkdGggOiAwLFxuXHRcdFx0bmF0dXJhbEhlaWdodDogZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgPyBlbGVtZW50Lm5hdHVyYWxIZWlnaHQgOiAwLFxuXHRcdFx0YXR0cldpZHRoOiBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCAnMCcpLFxuXHRcdFx0YXR0ckhlaWdodDogcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8ICcwJylcblx0XHR9KSk7XG5cblx0XHQvLyAzLiBCYXRjaCBjb21wdXRlIHN0eWxlcyAtIFByb2Nlc3MgaW4gY2h1bmtzIHRvIGF2b2lkIGxvbmcgdGFza3Ncblx0XHRjb25zdCBCQVRDSF9TSVpFID0gNTA7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBtZWFzdXJlbWVudHMubGVuZ3RoOyBpICs9IEJBVENIX1NJWkUpIHtcblx0XHRcdGNvbnN0IGJhdGNoID0gbWVhc3VyZW1lbnRzLnNsaWNlKGksIGkgKyBCQVRDSF9TSVpFKTtcblx0XHRcdFxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gUmVhZCBwaGFzZSAtIGNvbXB1dGUgYWxsIHN0eWxlcyBhdCBvbmNlXG5cdFx0XHRcdGNvbnN0IHN0eWxlcyA9IGJhdGNoLm1hcCgoeyBlbGVtZW50IH0pID0+IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKTtcblx0XHRcdFx0Y29uc3QgcmVjdHMgPSBiYXRjaC5tYXAoKHsgZWxlbWVudCB9KSA9PiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIFByb2Nlc3MgcGhhc2UgLSBubyBET00gb3BlcmF0aW9uc1xuXHRcdFx0XHRiYXRjaC5mb3JFYWNoKChtZWFzdXJlbWVudCwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3R5bGUgPSBzdHlsZXNbaW5kZXhdO1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVjdCA9IHJlY3RzW2luZGV4XTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRyYW5zZm9ybSBzY2FsZSBpbiB0aGUgc2FtZSBiYXRjaFxuXHRcdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtO1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2NhbGUgPSB0cmFuc2Zvcm0gPyBcblx0XHRcdFx0XHRcdFx0cGFyc2VGbG9hdCh0cmFuc2Zvcm0ubWF0Y2godHJhbnNmb3JtUmVnZXgpPy5bMV0gfHwgJzEnKSA6IDE7XG5cblx0XHRcdFx0XHRcdC8vIENhbGN1bGF0ZSBlZmZlY3RpdmUgZGltZW5zaW9uc1xuXHRcdFx0XHRcdFx0Y29uc3Qgd2lkdGhzID0gW1xuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5uYXR1cmFsV2lkdGgsXG5cdFx0XHRcdFx0XHRcdG1lYXN1cmVtZW50LmF0dHJXaWR0aCxcblx0XHRcdFx0XHRcdFx0cGFyc2VJbnQoc3R5bGUud2lkdGgpIHx8IDAsXG5cdFx0XHRcdFx0XHRcdHJlY3Qud2lkdGggKiBzY2FsZVxuXHRcdFx0XHRcdFx0XS5maWx0ZXIoZGltID0+IHR5cGVvZiBkaW0gPT09ICdudW1iZXInICYmIGRpbSA+IDApO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBoZWlnaHRzID0gW1xuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5uYXR1cmFsSGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5hdHRySGVpZ2h0LFxuXHRcdFx0XHRcdFx0XHRwYXJzZUludChzdHlsZS5oZWlnaHQpIHx8IDAsXG5cdFx0XHRcdFx0XHRcdHJlY3QuaGVpZ2h0ICogc2NhbGVcblx0XHRcdFx0XHRcdF0uZmlsdGVyKGRpbSA9PiB0eXBlb2YgZGltID09PSAnbnVtYmVyJyAmJiBkaW0gPiAwKTtcblxuXHRcdFx0XHRcdFx0Ly8gRGVjaXNpb24gcGhhc2UgLSBubyBET00gb3BlcmF0aW9uc1xuXHRcdFx0XHRcdFx0aWYgKHdpZHRocy5sZW5ndGggPiAwICYmIGhlaWdodHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlZmZlY3RpdmVXaWR0aCA9IE1hdGgubWluKC4uLndpZHRocyk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVmZmVjdGl2ZUhlaWdodCA9IE1hdGgubWluKC4uLmhlaWdodHMpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChlZmZlY3RpdmVXaWR0aCA8IE1JTl9ESU1FTlNJT04gfHwgZWZmZWN0aXZlSGVpZ2h0IDwgTUlOX0RJTUVOU0lPTikge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGlkZW50aWZpZXIgPSB0aGlzLmdldEVsZW1lbnRJZGVudGlmaWVyKG1lYXN1cmVtZW50LmVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpZGVudGlmaWVyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzbWFsbEltYWdlcy5hZGQoaWRlbnRpZmllcik7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIGVsZW1lbnQgZGltZW5zaW9uczonLCBlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIGJhdGNoOicsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdHRoaXMuX2xvZygnRm91bmQgc21hbGwgZWxlbWVudHM6Jywge1xuXHRcdFx0Y291bnQ6IHByb2Nlc3NlZENvdW50LFxuXHRcdFx0dG90YWxFbGVtZW50czogZWxlbWVudHMubGVuZ3RoLFxuXHRcdFx0cHJvY2Vzc2luZ1RpbWU6IGAkeyhlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0ZpeGVkKDIpfW1zYFxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHNtYWxsSW1hZ2VzO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVTbWFsbEltYWdlcyhkb2M6IERvY3VtZW50LCBzbWFsbEltYWdlczogU2V0PHN0cmluZz4pIHtcblx0XHRsZXQgcmVtb3ZlZENvdW50ID0gMDtcblxuXHRcdFsnaW1nJywgJ3N2ZyddLmZvckVhY2godGFnID0+IHtcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XG5cdFx0XHRBcnJheS5mcm9tKGVsZW1lbnRzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRjb25zdCBpZGVudGlmaWVyID0gdGhpcy5nZXRFbGVtZW50SWRlbnRpZmllcihlbGVtZW50KTtcblx0XHRcdFx0aWYgKGlkZW50aWZpZXIgJiYgc21hbGxJbWFnZXMuaGFzKGlkZW50aWZpZXIpKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdFx0XHRyZW1vdmVkQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgc21hbGwgZWxlbWVudHM6JywgcmVtb3ZlZENvdW50KTtcblx0fVxuXG5cdHByaXZhdGUgZ2V0RWxlbWVudElkZW50aWZpZXIoZWxlbWVudDogRWxlbWVudCk6IHN0cmluZyB8IG51bGwge1xuXHRcdC8vIFRyeSB0byBjcmVhdGUgYSB1bmlxdWUgaWRlbnRpZmllciB1c2luZyB2YXJpb3VzIGF0dHJpYnV0ZXNcblx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdC8vIEZvciBsYXp5LWxvYWRlZCBpbWFnZXMsIHVzZSBkYXRhLXNyYyBhcyBpZGVudGlmaWVyIGlmIGF2YWlsYWJsZVxuXHRcdFx0Y29uc3QgZGF0YVNyYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXHRcdFx0aWYgKGRhdGFTcmMpIHJldHVybiBgc3JjOiR7ZGF0YVNyY31gO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBzcmMgPSBlbGVtZW50LnNyYyB8fCAnJztcblx0XHRcdGNvbnN0IHNyY3NldCA9IGVsZW1lbnQuc3Jjc2V0IHx8ICcnO1xuXHRcdFx0Y29uc3QgZGF0YVNyY3NldCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdFx0XG5cdFx0XHRpZiAoc3JjKSByZXR1cm4gYHNyYzoke3NyY31gO1xuXHRcdFx0aWYgKHNyY3NldCkgcmV0dXJuIGBzcmNzZXQ6JHtzcmNzZXR9YDtcblx0XHRcdGlmIChkYXRhU3Jjc2V0KSByZXR1cm4gYHNyY3NldDoke2RhdGFTcmNzZXR9YDtcblx0XHR9XG5cblx0XHRjb25zdCBpZCA9IGVsZW1lbnQuaWQgfHwgJyc7XG5cdFx0Y29uc3QgY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgfHwgJyc7XG5cdFx0Y29uc3Qgdmlld0JveCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ID8gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSB8fCAnJyA6ICcnO1xuXHRcdFxuXHRcdGlmIChpZCkgcmV0dXJuIGBpZDoke2lkfWA7XG5cdFx0aWYgKHZpZXdCb3gpIHJldHVybiBgdmlld0JveDoke3ZpZXdCb3h9YDtcblx0XHRpZiAoY2xhc3NOYW1lKSByZXR1cm4gYGNsYXNzOiR7Y2xhc3NOYW1lfWA7XG5cdFx0XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRwcml2YXRlIGZpbmRNYWluQ29udGVudChkb2M6IERvY3VtZW50KTogRWxlbWVudCB8IG51bGwge1xuXG5cdFx0Ly8gRmluZCBhbGwgcG90ZW50aWFsIGNvbnRlbnQgY29udGFpbmVyc1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXM6IHsgZWxlbWVudDogRWxlbWVudDsgc2NvcmU6IG51bWJlciB9W10gPSBbXTtcblxuXHRcdEVOVFJZX1BPSU5UX0VMRU1FTlRTLmZvckVhY2goKHNlbGVjdG9yLCBpbmRleCkgPT4ge1xuXHRcdFx0Y29uc3QgZWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHRlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0XHQvLyBCYXNlIHNjb3JlIGZyb20gc2VsZWN0b3IgcHJpb3JpdHkgKGVhcmxpZXIgPSBoaWdoZXIpXG5cdFx0XHRcdGxldCBzY29yZSA9IChFTlRSWV9QT0lOVF9FTEVNRU5UUy5sZW5ndGggLSBpbmRleCkgKiAxMDtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIEFkZCBzY29yZSBiYXNlZCBvbiBjb250ZW50IGFuYWx5c2lzXG5cdFx0XHRcdHNjb3JlICs9IHRoaXMuc2NvcmVFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y2FuZGlkYXRlcy5wdXNoKHsgZWxlbWVudCwgc2NvcmUgfSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdGlmIChjYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIHNjb3JpbmcgYmxvY2sgZWxlbWVudHNcblx0XHRcdC8vIEN1cnJlbnRseSA8Ym9keT4gZWxlbWVudCBpcyB1c2VkIGFzIHRoZSBmYWxsYmFjaywgc28gdGhpcyBpcyBub3QgdXNlZFxuXHRcdFx0cmV0dXJuIHRoaXMuZmluZENvbnRlbnRCeVNjb3JpbmcoZG9jKTtcblx0XHR9XG5cblx0XHQvLyBTb3J0IGJ5IHNjb3JlIGRlc2NlbmRpbmdcblx0XHRjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcblx0XHRcblx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0dGhpcy5fbG9nKCdDb250ZW50IGNhbmRpZGF0ZXM6JywgY2FuZGlkYXRlcy5tYXAoYyA9PiAoe1xuXHRcdFx0XHRlbGVtZW50OiBjLmVsZW1lbnQudGFnTmFtZSxcblx0XHRcdFx0c2VsZWN0b3I6IHRoaXMuZ2V0RWxlbWVudFNlbGVjdG9yKGMuZWxlbWVudCksXG5cdFx0XHRcdHNjb3JlOiBjLnNjb3JlXG5cdFx0XHR9KSkpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjYW5kaWRhdGVzWzBdLmVsZW1lbnQ7XG5cdH1cblxuXHRwcml2YXRlIGZpbmRDb250ZW50QnlTY29yaW5nKGRvYzogRG9jdW1lbnQpOiBFbGVtZW50IHwgbnVsbCB7XG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9IHRoaXMuc2NvcmVFbGVtZW50cyhkb2MpO1xuXHRcdHJldHVybiBjYW5kaWRhdGVzLmxlbmd0aCA+IDAgPyBjYW5kaWRhdGVzWzBdLmVsZW1lbnQgOiBudWxsO1xuXHR9XG5cblx0cHJpdmF0ZSBnZXRFbGVtZW50U2VsZWN0b3IoZWxlbWVudDogRWxlbWVudCk6IHN0cmluZyB7XG5cdFx0Y29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XG5cdFx0bGV0IGN1cnJlbnQ6IEVsZW1lbnQgfCBudWxsID0gZWxlbWVudDtcblx0XHRcblx0XHR3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSB0aGlzLmRvYy5kb2N1bWVudEVsZW1lbnQpIHtcblx0XHRcdGxldCBzZWxlY3RvciA9IGN1cnJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0aWYgKGN1cnJlbnQuaWQpIHtcblx0XHRcdFx0c2VsZWN0b3IgKz0gJyMnICsgY3VycmVudC5pZDtcblx0XHRcdH0gZWxzZSBpZiAoY3VycmVudC5jbGFzc05hbWUgJiYgdHlwZW9mIGN1cnJlbnQuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRzZWxlY3RvciArPSAnLicgKyBjdXJyZW50LmNsYXNzTmFtZS50cmltKCkuc3BsaXQoL1xccysvKS5qb2luKCcuJyk7XG5cdFx0XHR9XG5cdFx0XHRwYXJ0cy51bnNoaWZ0KHNlbGVjdG9yKTtcblx0XHRcdGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCcgPiAnKTtcblx0fVxuXG5cdHByaXZhdGUgc2NvcmVFbGVtZW50cyhkb2M6IERvY3VtZW50KTogQ29udGVudFNjb3JlW10ge1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXM6IENvbnRlbnRTY29yZVtdID0gW107XG5cblx0XHRCTE9DS19FTEVNRU5UUy5mb3JFYWNoKCh0YWc6IHN0cmluZykgPT4ge1xuXHRcdFx0QXJyYXkuZnJvbShkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKSkuZm9yRWFjaCgoZWxlbWVudDogRWxlbWVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCBzY29yZSA9IHRoaXMuc2NvcmVFbGVtZW50KGVsZW1lbnQpO1xuXHRcdFx0XHRpZiAoc2NvcmUgPiAwKSB7XG5cdFx0XHRcdFx0Y2FuZGlkYXRlcy5wdXNoKHsgc2NvcmUsIGVsZW1lbnQgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNhbmRpZGF0ZXMuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuXHR9XG5cblx0cHJpdmF0ZSBzY29yZUVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IG51bWJlciB7XG5cdFx0bGV0IHNjb3JlID0gMDtcblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIGVsZW1lbnQgcHJvcGVydGllc1xuXHRcdGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICYmIHR5cGVvZiBlbGVtZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBcblx0XHRcdGVsZW1lbnQuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcblx0XHRjb25zdCBpZCA9IGVsZW1lbnQuaWQgPyBlbGVtZW50LmlkLnRvTG93ZXJDYXNlKCkgOiAnJztcblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIGNvbnRlbnRcblx0XHRjb25zdCB0ZXh0ID0gZWxlbWVudC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQoL1xccysvKS5sZW5ndGg7XG5cdFx0c2NvcmUgKz0gTWF0aC5taW4oTWF0aC5mbG9vcih3b3JkcyAvIDEwMCksIDMpO1xuXG5cdFx0Ly8gU2NvcmUgYmFzZWQgb24gbGluayBkZW5zaXR5XG5cdFx0Y29uc3QgbGlua3MgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJyk7XG5cdFx0Y29uc3QgbGlua1RleHQgPSBBcnJheS5mcm9tKGxpbmtzKS5yZWR1Y2UoKGFjYywgbGluaykgPT4gYWNjICsgKGxpbmsudGV4dENvbnRlbnQ/Lmxlbmd0aCB8fCAwKSwgMCk7XG5cdFx0Y29uc3QgbGlua0RlbnNpdHkgPSB0ZXh0Lmxlbmd0aCA/IGxpbmtUZXh0IC8gdGV4dC5sZW5ndGggOiAwO1xuXHRcdGlmIChsaW5rRGVuc2l0eSA+IDAuNSkge1xuXHRcdFx0c2NvcmUgLT0gMTA7XG5cdFx0fVxuXG5cdFx0Ly8gU2NvcmUgYmFzZWQgb24gcHJlc2VuY2Ugb2YgbWVhbmluZ2Z1bCBlbGVtZW50c1xuXHRcdGNvbnN0IHBhcmFncmFwaHMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwJykubGVuZ3RoO1xuXHRcdHNjb3JlICs9IHBhcmFncmFwaHM7XG5cblx0XHRjb25zdCBpbWFnZXMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKS5sZW5ndGg7XG5cdFx0c2NvcmUgKz0gTWF0aC5taW4oaW1hZ2VzICogMywgOSk7XG5cblx0XHRyZXR1cm4gc2NvcmU7XG5cdH1cbn0gIiwiLy8gRW50cnkgcG9pbnQgZWxlbWVudHNcbi8vIFRoZXNlIGFyZSB0aGUgZWxlbWVudHMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZmluZCB0aGUgbWFpbiBjb250ZW50XG5leHBvcnQgY29uc3QgRU5UUllfUE9JTlRfRUxFTUVOVFMgPSBbXG5cdCdhcnRpY2xlJyxcblx0J1tyb2xlPVwiYXJ0aWNsZVwiXScsXG5cdCcucG9zdC1jb250ZW50Jyxcblx0Jy5hcnRpY2xlLWNvbnRlbnQnLFxuXHQnI2FydGljbGUtY29udGVudCcsXG5cdCcuY29udGVudC1hcnRpY2xlJyxcblx0J21haW4nLFxuXHQnW3JvbGU9XCJtYWluXCJdJyxcblx0J2JvZHknIC8vIGVuc3VyZXMgdGhlcmUgaXMgYWx3YXlzIGEgbWF0Y2hcbl07XG5cbmV4cG9ydCBjb25zdCBNT0JJTEVfV0lEVEggPSA2MDA7XG5leHBvcnQgY29uc3QgQkxPQ0tfRUxFTUVOVFMgPSBbJ2RpdicsICdzZWN0aW9uJywgJ2FydGljbGUnLCAnbWFpbiddO1xuXG4vLyBFbGVtZW50cyB0aGF0IHNob3VsZCBub3QgYmUgdW53cmFwcGVkXG5leHBvcnQgY29uc3QgUFJFU0VSVkVfRUxFTUVOVFMgPSBuZXcgU2V0KFtcblx0J3ByZScsICdjb2RlJywgJ3RhYmxlJywgJ3RoZWFkJywgJ3Rib2R5JywgJ3RyJywgJ3RkJywgJ3RoJyxcblx0J3VsJywgJ29sJywgJ2xpJywgJ2RsJywgJ2R0JywgJ2RkJyxcblx0J2ZpZ3VyZScsICdmaWdjYXB0aW9uJywgJ3BpY3R1cmUnLFxuXHQnZGV0YWlscycsICdzdW1tYXJ5Jyxcblx0J2Jsb2NrcXVvdGUnLFxuXHQnZm9ybScsICdmaWVsZHNldCdcbl0pO1xuXG4vLyBJbmxpbmUgZWxlbWVudHMgdGhhdCBzaG91bGQgbm90IGJlIHVud3JhcHBlZFxuZXhwb3J0IGNvbnN0IElOTElORV9FTEVNRU5UUyA9IG5ldyBTZXQoW1xuXHQnYScsICdzcGFuJywgJ3N0cm9uZycsICdlbScsICdpJywgJ2InLCAndScsICdjb2RlJywgJ2JyJywgJ3NtYWxsJyxcblx0J3N1YicsICdzdXAnLCAnbWFyaycsICdkZWwnLCAnaW5zJywgJ3EnLCAnYWJicicsICdjaXRlJywgJ3RpbWUnXG5dKTtcblxuLy8gSGlkZGVuIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWRcbmV4cG9ydCBjb25zdCBISURERU5fRUxFTUVOVF9TRUxFQ1RPUlMgPSBbXG5cdCdbaGlkZGVuXScsXG4vL1x0J1thcmlhLWhpZGRlbj1cInRydWVcIl0nLCBuZWVkZWQgZm9yIG1hdGggZm9ybXVsYXNcbi8vXHQnW3N0eWxlKj1cImRpc3BsYXk6IG5vbmVcIl0nLCBuZWVkZWQgZm9yIGZvciBtYXRoIGZvcm11bGFzXG4vL1x0J1tzdHlsZSo9XCJkaXNwbGF5Om5vbmVcIl0nLFxuXHQnW3N0eWxlKj1cInZpc2liaWxpdHk6IGhpZGRlblwiXScsXG5cdCdbc3R5bGUqPVwidmlzaWJpbGl0eTpoaWRkZW5cIl0nLFxuXHQnLmhpZGRlbicsXG5cdCcuaW52aXNpYmxlJ1xuXS5qb2luKCcsJyk7XG5cbi8vIFNlbGVjdG9ycyB0byBiZSByZW1vdmVkXG5leHBvcnQgY29uc3QgRVhBQ1RfU0VMRUNUT1JTID0gW1xuXHQvLyBzY3JpcHRzLCBzdHlsZXNcblx0J25vc2NyaXB0Jyxcblx0J3NjcmlwdDpub3QoW3R5cGVePVwibWF0aC9cIl0pJyxcblx0J3N0eWxlJyxcblxuXHQvLyBhZHNcblx0Jy5hZDpub3QoW2NsYXNzKj1cImdyYWRpZW50XCJdKScsXG5cdCdbY2xhc3NePVwiYWQtXCIgaV0nLFxuXHQnW2NsYXNzJD1cIi1hZFwiIGldJyxcblx0J1tpZF49XCJhZC1cIiBpXScsXG5cdCdbaWQkPVwiLWFkXCIgaV0nLFxuXHQnW3JvbGU9XCJiYW5uZXJcIiBpXScsXG5cdCcucHJvbW8nLFxuXHQnLlByb21vJyxcblx0JyNiYXJyaWVyLXBhZ2UnLCAvLyBmdC5jb21cblxuXHQvLyBjb21tZW50c1xuXHQnW2lkPVwiY29tbWVudHNcIiBpXScsXG5cblx0Ly8gaGVhZGVyLCBuYXZcblx0J2hlYWRlcicsXG5cdCcuaGVhZGVyJyxcblx0JyNoZWFkZXInLFxuXHQnbmF2Jyxcblx0Jy5uYXZpZ2F0aW9uJyxcblx0JyNuYXZpZ2F0aW9uJyxcblx0J1tyb2xlPVwibmF2aWdhdGlvblwiIGldJyxcblx0J1tyb2xlPVwiZGlhbG9nXCIgaV0nLFxuXHQnW3JvbGUqPVwiY29tcGxlbWVudGFyeVwiIGldJyxcblx0J1tjbGFzcyo9XCJwYWdpbmF0aW9uXCIgaV0nLFxuXHQnLm1lbnUnLFxuXHQnI21lbnUnLFxuXHQnI3NpdGVTdWInLFxuXG5cdC8vIG1ldGFkYXRhXG5cdCcuYXV0aG9yJyxcblx0Jy5BdXRob3InLFxuXHQnLmNvbnRyaWJ1dG9yJyxcblx0Jy5kYXRlJyxcblx0Jy5tZXRhJyxcblx0Jy50YWdzJyxcblx0Jy50b2MnLFxuXHQnLlRvYycsXG5cdCcjdG9jJyxcblx0JyN0aXRsZScsXG5cdCcjVGl0bGUnLFxuXHQnW2hyZWYqPVwiL2NhdGVnb3J5XCJdJyxcblx0J1tocmVmKj1cIi9jYXRlZ29yaWVzXCJdJyxcblx0J1tocmVmKj1cIi90YWcvXCJdJyxcblx0J1tocmVmKj1cIi90YWdzL1wiXScsXG5cdCdbaHJlZio9XCIvdG9waWNzXCJdJyxcblx0J1tocmVmKj1cImF1dGhvclwiXScsXG5cdCdbaHJlZj1cIiNzaXRlLWNvbnRlbnRcIl0nLFxuXHQnW3NyYyo9XCJhdXRob3JcIl0nLFxuXG5cdC8vIGZvb3RlclxuXHQnZm9vdGVyJyxcblxuXHQvLyBpbnB1dHMsIGZvcm1zLCBlbGVtZW50c1xuXHQnYXNpZGUnLFxuXHQnYnV0dG9uJyxcblx0XHQvLyAnW3JvbGU9XCJidXR0b25cIl0nLCBNZWRpdW0gaW1hZ2VzXG5cdCdjYW52YXMnLFxuXHQnZGlhbG9nJyxcblx0J2ZpZWxkc2V0Jyxcblx0J2Zvcm0nLFxuXHQnaW5wdXQ6bm90KFt0eXBlPVwiY2hlY2tib3hcIl0pJyxcblx0J2xhYmVsJyxcblx0J2xpbmsnLFxuXHQnb3B0aW9uJyxcblx0J3NlbGVjdCcsXG5cdCd0ZXh0YXJlYScsXG5cdCd0aW1lJyxcblxuXHQvLyBpZnJhbWVzXG5cdCdpbnN0YXJlYWQtcGxheWVyJyxcblx0J2lmcmFtZTpub3QoW3NyYyo9XCJ5b3V0dWJlXCJdKTpub3QoW3NyYyo9XCJ5b3V0dS5iZVwiXSk6bm90KFtzcmMqPVwidmltZW9cIl0pOm5vdChbc3JjKj1cInR3aXR0ZXJcIl0pJyxcblxuXHQvLyBsb2dvc1xuXHQnW2NsYXNzPVwibG9nb1wiIGldJyxcblx0JyNsb2dvJyxcblx0JyNMb2dvJyxcblxuXHQvLyBuZXdzbGV0dGVyXG5cdCcjbmV3c2xldHRlcicsXG5cdCcjTmV3c2xldHRlcicsXG5cblx0Ly8gaGlkZGVuIGZvciBwcmludFxuXHQnLm5vcHJpbnQnLFxuXHQnW2RhdGEtbGluay1uYW1lKj1cInNraXBcIiBpXScsXG5cdCdbZGF0YS1wcmludC1sYXlvdXQ9XCJoaWRlXCIgaV0nLFxuXHQnW2RhdGEtYmxvY2s9XCJkb25vdHByaW50XCIgaV0nLFxuXG5cdC8vIGZvb3Rub3RlcywgY2l0YXRpb25zXG5cdCdbY2xhc3MqPVwiY2xpY2thYmxlLWljb25cIiBpXScsXG5cdCdsaSBzcGFuW2NsYXNzKj1cImx0eF90YWdcIiBpXVtjbGFzcyo9XCJsdHhfdGFnX2l0ZW1cIiBpXScsXG5cdCdhW2hyZWZePVwiI1wiXVtjbGFzcyo9XCJhbmNob3JcIiBpXScsXG5cdCdhW2hyZWZePVwiI1wiXVtjbGFzcyo9XCJyZWZcIiBpXScsXG5cblx0Ly8gbGluayBsaXN0c1xuXHQnW2RhdGEtY29udGFpbmVyKj1cIm1vc3Qtdmlld2VkXCIgaV0nLFxuXG5cdC8vIHNpZGViYXJcblx0Jy5zaWRlYmFyJyxcblx0Jy5TaWRlYmFyJyxcblx0JyNzaWRlYmFyJyxcblx0JyNTaWRlYmFyJyxcblx0JyNzaXRlc3ViJyxcblx0XG5cdC8vIG90aGVyXG5cdCcjcHJpbWFyeWF1ZGlvJywgLy8gTlBSXG5cdCcjTllUX0FCT1ZFX01BSU5fQ09OVEVOVF9SRUdJT04nLFxuXHQnW2RhdGEtdGVzdGlkPVwicGhvdG92aWV3ZXItY2hpbGRyZW4tZmlndXJlXCJdID4gc3BhbicsIC8vIE5ldyBZb3JrIFRpbWVzXG5cdCd0YWJsZS5pbmZvYm94Jyxcblx0Jy5wZW5jcmFmdDpub3QoLnBjLWRpc3BsYXktY29udGVudHMpJywgLy8gU3Vic3RhY2tcblx0J1tkYXRhLW9wdGltaXplbHk9XCJyZWxhdGVkLWFydGljbGVzLXNlY3Rpb25cIiBpXScgLy8gVGhlIEVjb25vbWlzdFxuXTtcblxuLy8gUmVtb3ZhbCBwYXR0ZXJucyB0ZXN0ZWQgYWdhaW5zdCBhdHRyaWJ1dGVzOiBjbGFzcywgaWQsIGRhdGEtdGVzdGlkLCBhbmQgZGF0YS1xYVxuLy8gQ2FzZSBpbnNlbnNpdGl2ZSwgcGFydGlhbCBtYXRjaGVzIGFsbG93ZWRcbmV4cG9ydCBjb25zdCBQQVJUSUFMX1NFTEVDVE9SUyA9IFtcblx0J2FjY2Vzcy13YWxsJyxcblx0J2FjdGl2aXR5cHViJyxcblx0J2FjdGlvbmNhbGwnLFxuXHQnYXBwZW5kaXgnLFxuXHQnYXZhdGFyJyxcblx0J2FkdmVydCcsXG5cdCctYWQtJyxcblx0J19hZF8nLFxuXHQnYWxsdGVybXMnLFxuXHQnYWxlcnQtYm94Jyxcblx0J2Fyb3VuZC10aGUtd2ViJyxcblx0J2FydGljbGUtYm90dG9tLXNlY3Rpb24nLFxuXHQnYXJ0aWNsZV9fY29weScsXG5cdCdhcnRpY2xlX2RhdGUnLFxuXHQnYXJ0aWNsZS1lbmQgJyxcblx0J2FydGljbGVfaGVhZGVyJyxcblx0J2FydGljbGVfX2hlYWRlcicsXG5cdCdhcnRpY2xlX19pbmZvJyxcblx0J2FydGljbGUtaW5mbycsXG5cdCdhcnRpY2xlX19tZXRhJyxcblx0J2FydGljbGUtc3ViamVjdCcsXG5cdCdhcnRpY2xlX3N1YmplY3QnLFxuXHQnYXJ0aWNsZS1zbmlwcGV0Jyxcblx0J2FydGljbGUtc2VwYXJhdG9yJyxcblx0J2FydGljbGUtLXNoYXJlJyxcblx0J2FydGljbGUtLXRvcGljcycsXG5cdCdhcnRpY2xldGFncycsXG5cdCdhcnRpY2xlLXRhZ3MnLFxuXHQnYXJ0aWNsZV90YWdzJyxcblx0J2FydGljbGUtdGl0bGUnLFxuXHQnYXJ0aWNsZV90aXRsZScsXG5cdCdhcnRpY2xldG9waWNzJyxcblx0J2FydGljbGUtdG9waWNzJyxcblx0J2FydGljbGUtdHlwZScsXG5cdCdhcnRpY2xlLS1sZWRlJywgLy8gVGhlIFZlcmdlXG5cdCdhcnRpY2xld2VsbCcsXG5cdCdhc3NvY2lhdGVkLXBlb3BsZScsXG5cdCdhdWRpby1jYXJkJyxcbi8vXHQnYXV0aG9yJywgR3dlcm5cblx0J2F1dGhvcmVkLWJ5Jyxcblx0J2F1dGhvci1ib3gnLFxuXHQnYXV0aG9yLW5hbWUnLFxuXHQnYXV0aG9yLWJpbycsXG5cdCdhdXRob3ItbWluaS1iaW8nLFxuXHQnYmFjay10by10b3AnLFxuXHQnYmFja2xpbmtzLXNlY3Rpb24nLFxuXHQnYmFubmVyJyxcblx0J2Jpby1ibG9jaycsXG5cdCdibG9nLXBhZ2VyJyxcblx0J2Jvb2ttYXJrLScsXG5cdCctYm9va21hcmsnLFxuXHQnYm90dG9tLW9mLWFydGljbGUnLFxuXHQnYnJhbmQtYmFyJyxcblx0J2JyZWFkY3J1bWInLFxuXHQnYnV0dG9uLXdyYXBwZXInLFxuXHQnYnRuLScsXG5cdCctYnRuJyxcblx0J2J5bGluZScsXG5cdCdjYXB0Y2hhJyxcblx0J2NhcmQtdGV4dCcsXG5cdCdjYXJkLW1lZGlhJyxcblx0J2NhdF9oZWFkZXInLFxuXHQnY2F0bGlua3MnLFxuXHQnY2hhcHRlci1saXN0JywgLy8gVGhlIEVjb25vbWlzdFxuXHQnY29sbGVjdGlvbnMnLFxuXHQnY29tbWVudHMnLFxuLy9cdCctY29tbWVudCcsIFN5bnRheCBoaWdobGlnaHRpbmdcblx0J2NvbW1lbnRib3gnLFxuXHQnY29tbWVudC1jb3VudCcsXG5cdCdjb21tZW50LWNvbnRlbnQnLFxuXHQnY29tbWVudC1mb3JtJyxcblx0J2NvbW1lbnQtbnVtYmVyJyxcblx0J2NvbW1lbnQtcmVzcG9uZCcsXG5cdCdjb21tZW50LXRocmVhZCcsXG5cdCdjb21wbGVtZW50YXJ5Jyxcblx0J2NvbnNlbnQnLFxuXHQnY29udGVudC1jYXJkJywgLy8gVGhlIFZlcmdlXG5cdCdjb250ZW50LXRvcGljcycsXG5cdCdjb250ZW50cHJvbW8nLFxuXHQnY29udGV4dC13aWRnZXQnLCAvLyBSZXV0ZXJzXG5cdCdjb3JlLWNvbGxhdGVyYWwnLFxuXHQnX2N0YScsXG5cdCctY3RhJyxcblx0J2N0YS0nLFxuXHQnY3RhXycsXG5cdCdjdXJyZW50LWlzc3VlJywgLy8gVGhlIE5hdGlvblxuXHQnY3VzdG9tLWxpc3QtbnVtYmVyJyxcblx0J2RhdGVsaW5lJyxcblx0J2RhdGVoZWFkZXInLFxuXHQnZGF0ZS1oZWFkZXInLFxuXHQnZGF0ZV9oZWFkZXItJyxcbi8vXHQnZGlhbG9nJyxcblx0J2Rpc2NsYWltZXInLFxuXHQnZGlzY2xvc3VyZScsXG5cdCdkaXNjdXNzaW9uJyxcblx0J2Rpc2N1c3NfJyxcblx0J2Rpc3F1cycsXG5cdCdkb25hdGUnLFxuXHQnZHJvcGRvd24nLCAvLyBBcnMgVGVjaG5pY2Fcblx0J2VsZXR0ZXJzJyxcblx0J2VtYWlsc2lnbnVwJyxcblx0J2VuZ2FnZW1lbnQtd2lkZ2V0Jyxcblx0J2VudHJ5LWF1dGhvci1pbmZvJyxcblx0J2VudHJ5LWNhdGVnb3JpZXMnLFxuXHQnZW50cnktZGF0ZScsXG5cdCdlbnRyeS1tZXRhJyxcblx0J2VudHJ5LXRpdGxlJyxcblx0J2VudHJ5LXV0aWxpdHknLFxuXHQnZXllYnJvdycsXG5cdCdleHBhbmQtcmVkdWNlJyxcblx0J2V4dGVybmFsbGlua2VtYmVkd3JhcHBlcicsIC8vIFRoZSBOZXcgWW9ya2VyXG5cdCdleHRyYS1zZXJ2aWNlcycsXG5cdCdleHRyYS10aXRsZScsXG5cdCdmYWNlYm9vaycsXG5cdCdmYXZvcml0ZScsXG5cdCdmZWVkYmFjaycsXG5cdCdmZWVkLWxpbmtzJyxcblx0J2ZpZWxkLXNpdGUtc2VjdGlvbnMnLFxuXHQnZml4ZWQnLFxuXHQnZmxvYXRpbmctdmlkJyxcblx0J2ZvbGxvdycsXG5cdCdmb290ZXInLFxuXHQnZm9vdG5vdGUtYmFjaycsXG5cdCdmb290bm90ZWJhY2snLFxuXHQnZm9yLXlvdScsXG5cdCdmcm9udG1hdHRlcicsXG5cdCdmdXJ0aGVyLXJlYWRpbmcnLFxuXHQnZ2lzdC1tZXRhJyxcbi8vXHQnZ2xvYmFsJyxcblx0J2dvb2dsZScsXG5cdCdnb29nLScsXG5cdCdncmFwaC12aWV3Jyxcblx0J2hlYWRlci1sb2dvJyxcblx0J2hlYWRlci1wYXR0ZXJuJywgLy8gVGhlIFZlcmdlXG5cdCdoZXJvLWxpc3QnLFxuXHQnaGlkZS1mb3ItcHJpbnQnLFxuXHQnaGlkZS1wcmludCcsXG5cdCdoaWRlLXdoZW4tbm8tc2NyaXB0Jyxcblx0J2hpZGRlbi1zaWRlbm90ZScsXG5cdCdpbnRlcmx1ZGUnLFxuXHQnaW50ZXJhY3Rpb24nLFxuXHQnanVtcGxpbmsnLFxuXHQnanVtcC10by0nLFxuLy9cdCdrZXl3b3JkJywgLy8gdXNlZCBpbiBzeW50YXggaGlnaGxpZ2h0aW5nXG5cdCdraWNrZXInLFxuXHQnbGFic3RhYicsIC8vIEFyeGl2XG5cdCctbGFiZWxzJyxcblx0J2xhbmd1YWdlLW5hbWUnLFxuXHQnbGF0ZXN0LWNvbnRlbnQnLFxuXHQnLWxlZGVzLScsIC8vIFRoZSBWZXJnZVxuXHQnLWxpY2Vuc2UnLFxuXHQnbGluay1ib3gnLFxuXHQnbGlua3MtZ3JpZCcsIC8vIEJCQ1xuXHQnbGlua3MtdGl0bGUnLCAvLyBCQkNcblx0J2xpc3RpbmctZHluYW1pYy10ZXJtcycsIC8vIEJvc3RvbiBSZXZpZXdcblx0J2xpc3QtdGFncycsXG5cdCdsb2FkaW5nJyxcblx0J2xvYS1pbmZvJyxcblx0J2xvZ29fY29udGFpbmVyJyxcblx0J2x0eF9yb2xlX3JlZm51bScsIC8vIEFyeGl2XG5cdCdsdHhfdGFnX2JpYml0ZW0nLFxuXHQnbHR4X2Vycm9yJyxcblx0J21hcmtldGluZycsXG5cdCdtZWRpYS1pbnF1aXJ5Jyxcblx0J21lbnUtJyxcblx0J21ldGEtJyxcblx0J21ldGFkYXRhJyxcblx0J21pZ2h0LWxpa2UnLFxuXHQnX21vZGFsJyxcblx0Jy1tb2RhbCcsXG5cdCdtb3JlLScsXG5cdCdtb3JlbmV3cycsXG5cdCdtb3Jlc3RvcmllcycsXG5cdCdtb3ZlLWhlbHBlcicsXG5cdCdtdy1lZGl0c2VjdGlvbicsXG5cdCdtdy1jaXRlLWJhY2tsaW5rJyxcblx0J213LWluZGljYXRvcnMnLFxuXHQnbXctanVtcC1saW5rJyxcblx0J25hdi0nLFxuXHQnbmF2XycsXG5cdCduYXZiYXInLFxuLy9cdCduYXZpZ2F0aW9uJyxcblx0J25leHQtJyxcblx0J25ld3Mtc3RvcnktdGl0bGUnLFxuLy9cdCduZXdzbGV0dGVyJywgdXNlZCBvbiBTdWJzdGFja1xuXHQnbmV3c2xldHRlcl8nLFxuXHQnbmV3c2xldHRlci1zaWdudXAnLFxuXHQnbmV3c2xldHRlcnNpZ251cCcsXG5cdCduZXdzbGV0dGVyd2lkZ2V0Jyxcblx0J25ld3NsZXR0ZXJ3cmFwcGVyJyxcblx0J25vdC1mb3VuZCcsXG5cdCdub21vYmlsZScsXG5cdCdub3ByaW50Jyxcblx0J29yaWdpbmFsbHktcHVibGlzaGVkJywgLy8gTWVyY3VyeSBOZXdzXG5cdCdvdXRsaW5lLXZpZXcnLFxuXHQnb3ZlcmxheScsXG5cdCdwYWdlLXRpdGxlJyxcblx0Jy1wYXJ0bmVycycsXG5cdCdwbGVhJyxcblx0J3BvcHVsYXInLFxuLy9cdCdwb3B1cCcsIEd3ZXJuXG5cdCdwb3AtdXAnLFxuXHQncG9wb3ZlcicsXG5cdCdwb3N0LWJvdHRvbScsXG5cdCdwb3N0X19jYXRlZ29yeScsXG5cdCdwb3N0Y29tbWVudCcsXG5cdCdwb3N0ZGF0ZScsXG5cdCdwb3N0LWF1dGhvcicsXG5cdCdwb3N0LWRhdGUnLFxuXHQncG9zdF9kYXRlJyxcblx0J3Bvc3QtZmVlZHMnLFxuXHQncG9zdGluZm8nLFxuXHQncG9zdC1pbmZvJyxcblx0J3Bvc3RfaW5mbycsXG5cdCdwb3N0LWlubGluZS1kYXRlJyxcblx0J3Bvc3QtbGlua3MnLFxuXHQncG9zdC1tZXRhJyxcblx0J3Bvc3RtZXRhJyxcblx0J3Bvc3RzbmlwcGV0Jyxcblx0J3Bvc3Rfc25pcHBldCcsXG5cdCdwb3N0LXNuaXBwZXQnLFxuXHQncG9zdHRpdGxlJyxcblx0J3Bvc3QtdGl0bGUnLFxuXHQncG9zdF90aXRsZScsXG5cdCdwb3N0dGF4Jyxcblx0J3Bvc3QtdGF4Jyxcblx0J3Bvc3RfdGF4Jyxcblx0J3Bvc3R0YWcnLFxuXHQncG9zdF90YWcnLFxuXHQncG9zdC10YWcnLFxuLy9cdCdwcmV2aWV3JywgdXNlZCBvbiBPYnNpZGlhbiBQdWJsaXNoXG5cdCdwcmV2bmV4dCcsXG5cdCdwcmV2aW91c25leHQnLFxuXHQncHJlc3MtaW5xdWlyaWVzJyxcblx0J3ByaW50LW5vbmUnLFxuXHQncHJpbnQtaGVhZGVyJyxcblx0J3Byb2ZpbGUnLFxuLy9cdCdwcm9tbycsXG5cdCdwcm9tby1ib3gnLFxuXHQncHViZGF0ZScsXG5cdCdwdWJfZGF0ZScsXG5cdCdwdWItZGF0ZScsXG5cdCdwdWJsaWNhdGlvbi1kYXRlJyxcblx0J3B1YmxpY2F0aW9uTmFtZScsIC8vIE1lZGl1bVxuXHQncXItY29kZScsXG5cdCdxcl9jb2RlJyxcblx0J19yYWlsJyxcblx0J3JlYWRtb3JlJyxcblx0J3JlYWQtbmV4dCcsXG5cdCdyZWFkX25leHQnLFxuXHQncmVhZF90aW1lJyxcblx0J3JlYWQtdGltZScsXG5cdCdyZWFkaW5nX3RpbWUnLFxuXHQncmVhZGluZy10aW1lJyxcblx0J3JlYWRpbmctbGlzdCcsXG5cdCdyZWNlbnRwb3N0Jyxcblx0J3JlY2VudF9wb3N0Jyxcblx0J3JlY2VudC1wb3N0Jyxcblx0J3JlY29tbWVuZCcsXG5cdCdyZWRpcmVjdGVkZnJvbScsXG5cdCdyZWNpcmMnLFxuXHQncmVnaXN0ZXInLFxuXHQncmVsYXRlZCcsXG5cdCdyZWxldmFudCcsXG5cdCdyZXZlcnNlZm9vdG5vdGUnLFxuXHQnc2NyZWVuLXJlYWRlci10ZXh0Jyxcbi8vXHQnc2hhcmUnLFxuLy9cdCctc2hhcmUnLCBzY2l0ZWNoZGFpbHkuY29tXG5cdCdzaGFyZS1ib3gnLFxuXHQnc2hhcmVkYWRkeScsXG5cdCdzaGFyZS1pY29ucycsXG5cdCdzaGFyZWxpbmtzJyxcblx0J3NoYXJlLXNlY3Rpb24nLFxuXHQnc2lkZWJhcnRpdGxlJyxcblx0J3NpZGViYXJfJyxcblx0J3NpZGViYXItY29udGVudCcsXG5cdCdzaW1pbGFyLScsXG5cdCdzaW1pbGFyXycsXG5cdCdzaW1pbGFycy0nLFxuXHQnc2lkZWl0ZW1zJyxcblx0J3NpZGUtYm94Jyxcblx0J3NpdGUtaW5kZXgnLFxuXHQnc2l0ZS1oZWFkZXInLFxuXHQnc2l0ZS1sb2dvJyxcblx0J3NpdGUtbmFtZScsXG4vL1x0J3NraXAtJyxcbi8vXHQnc2tpcC1saW5rJywgVGVjaENydW5jaFxuXHQnX3NraXAtbGluaycsXG5cdCdzbHVnLXdyYXAnLFxuXHQnc29jaWFsJyxcblx0J3NwZWVjaGlmeS1pZ25vcmUnLFxuXHQnc3BvbnNvcicsXG5cdCdzcHJpbmdlcmNpdGF0aW9uJyxcbi8vXHQnLXN0YXRzJyxcblx0J19zdGF0cycsXG5cdCdzdGlja3knLFxuXHQnc3RvcnlyZWFkdGltZScsIC8vIE1lZGl1bVxuXHQnc3RvcnlwdWJsaXNoZGF0ZScsIC8vIE1lZGl1bVxuXHQnc3ViamVjdC1sYWJlbCcsXG5cdCdzdWJzY3JpYmUnLFxuXHQnX3RhZ3MnLFxuXHQndGFnc19faXRlbScsXG5cdCd0YWdfbGlzdCcsXG5cdCd0YXhvbm9teScsXG5cdCd0YWJsZS1vZi1jb250ZW50cycsXG5cdCd0YWJzLScsXG4vL1x0J3RlYXNlcicsIE5hdHVyZVxuXHQndGVybWluYWx0b3V0Jyxcblx0J3RpbWUtcnVicmljJyxcblx0J3RpbWVzdGFtcCcsXG5cdCd0aXBfb2ZmJyxcblx0J3RpcHRvdXQnLFxuXHQnLXRvdXQtJyxcblx0Jy10b2MnLFxuXHQndG9nZ2xlLWNhcHRpb24nLFxuXHQndG9waWMtbGlzdCcsXG5cdCd0b29sYmFyJyxcblx0J3Rvb2x0aXAnLFxuXHQndG9wLXdyYXBwZXInLFxuXHQndHJlZS1pdGVtJyxcblx0J3RyZW5kaW5nJyxcblx0J3RydXN0LWZlYXQnLFxuXHQndHJ1c3QtYmFkZ2UnLFxuXHQndHdpdHRlcicsXG5cdCd2aXN1YWxseS1oaWRkZW4nLFxuXHQnd2VsY29tZWJveCdcbi8vXHQnd2lkZ2V0LSdcbl07XG5cbi8vIFNlbGVjdG9ycyBmb3IgZm9vdG5vdGVzIGFuZCBjaXRhdGlvbnNcbmV4cG9ydCBjb25zdCBGT09UTk9URV9JTkxJTkVfUkVGRVJFTkNFUyA9IFtcblx0J3N1cC5yZWZlcmVuY2UnLFxuXHQnY2l0ZS5sdHhfY2l0ZScsXG5cdCdzdXBbaWRePVwiZm5yXCJdJyxcblx0J3N1cFtpZF49XCJmbnJlZjpcIl0nLFxuXHQnc3Bhbi5mb290bm90ZS1saW5rJyxcblx0J2EuY2l0YXRpb24nLFxuXHQnYVtpZF49XCJyZWYtbGlua1wiXScsXG5cdCdhW2hyZWZePVwiI2ZuXCJdJyxcblx0J2FbaHJlZl49XCIjY2l0ZVwiXScsXG5cdCdhW2hyZWZePVwiI3JlZmVyZW5jZVwiXScsXG5cdCdhW2hyZWZePVwiI2Zvb3Rub3RlXCJdJyxcblx0J2FbaHJlZl49XCIjclwiXScsIC8vIENvbW1vbiBpbiBhY2FkZW1pYyBwYXBlcnNcblx0J2FbaHJlZl49XCIjYlwiXScsIC8vIENvbW1vbiBmb3IgYmlibGlvZ3JhcGh5IHJlZmVyZW5jZXNcblx0J2FbaHJlZio9XCJjaXRlX25vdGVcIl0nLFxuXHQnYVtocmVmKj1cImNpdGVfcmVmXCJdJyxcblx0J2EuZm9vdG5vdGUtYW5jaG9yJywgLy8gU3Vic3RhY2tcblx0J3NwYW4uZm9vdG5vdGUtaG92ZXJjYXJkLXRhcmdldCBhJywgLy8gU3Vic3RhY2tcblx0J2Fbcm9sZT1cImRvYy1iaWJsaW9yZWZcIl0nLCAvLyBTY2llbmNlLm9yZ1xuXHQnYVtpZF49XCJmbnJlZlwiXScsXG5cdCdhW2lkXj1cInJlZi1saW5rXCJdJywgLy8gTmF0dXJlLmNvbVxuXS5qb2luKCcsJyk7XG5cbmV4cG9ydCBjb25zdCBGT09UTk9URV9MSVNUX1NFTEVDVE9SUyA9IFtcblx0J2Rpdi5mb290bm90ZSBvbCcsXG5cdCdkaXYuZm9vdG5vdGVzIG9sJyxcblx0J2Rpdltyb2xlPVwiZG9jLWVuZG5vdGVzXCJdJyxcblx0J2Rpdltyb2xlPVwiZG9jLWZvb3Rub3Rlc1wiXScsXG5cdCdvbC5mb290bm90ZXMtbGlzdCcsXG5cdCdvbC5mb290bm90ZXMnLFxuXHQnb2wucmVmZXJlbmNlcycsXG5cdCdvbFtjbGFzcyo9XCJhcnRpY2xlLXJlZmVyZW5jZXNcIl0nLFxuXHQnc2VjdGlvbi5mb290bm90ZXMgb2wnLFxuXHQnc2VjdGlvbltyb2xlPVwiZG9jLWVuZG5vdGVzXCJdJyxcblx0J3NlY3Rpb25bcm9sZT1cImRvYy1mb290bm90ZXNcIl0nLFxuXHQnc2VjdGlvbltyb2xlPVwiZG9jLWJpYmxpb2dyYXBoeVwiXScsXG5cdCd1bC5mb290bm90ZXMtbGlzdCcsXG5cdCd1bC5sdHhfYmlibGlzdCcsXG5cdCdkaXYuZm9vdG5vdGVbZGF0YS1jb21wb25lbnQtbmFtZT1cIkZvb3Rub3RlVG9ET01cIl0nIC8vIFN1YnN0YWNrXG5dLmpvaW4oJywnKTtcblxuLy8gRWxlbWVudHMgdGhhdCBhcmUgYWxsb3dlZCB0byBiZSBlbXB0eVxuLy8gVGhlc2UgYXJlIG5vdCByZW1vdmVkIGV2ZW4gaWYgdGhleSBoYXZlIG5vIGNvbnRlbnRcbmV4cG9ydCBjb25zdCBBTExPV0VEX0VNUFRZX0VMRU1FTlRTID0gbmV3IFNldChbXG5cdCdhcmVhJyxcblx0J2F1ZGlvJyxcblx0J2Jhc2UnLFxuXHQnYnInLFxuXHQnY2lyY2xlJyxcblx0J2NvbCcsXG5cdCdkZWZzJyxcblx0J2VsbGlwc2UnLFxuXHQnZW1iZWQnLFxuXHQnZmlndXJlJyxcblx0J2cnLFxuXHQnaHInLFxuXHQnaWZyYW1lJyxcblx0J2ltZycsXG5cdCdpbnB1dCcsXG5cdCdsaW5lJyxcblx0J2xpbmsnLFxuXHQnbWFzaycsXG5cdCdtZXRhJyxcblx0J29iamVjdCcsXG5cdCdwYXJhbScsXG5cdCdwYXRoJyxcblx0J3BhdHRlcm4nLFxuXHQncGljdHVyZScsXG5cdCdwb2x5Z29uJyxcblx0J3BvbHlsaW5lJyxcblx0J3JlY3QnLFxuXHQnc291cmNlJyxcblx0J3N0b3AnLFxuXHQnc3ZnJyxcblx0J3RkJyxcblx0J3RoJyxcblx0J3RyYWNrJyxcblx0J3VzZScsXG5cdCd2aWRlbycsXG5cdCd3YnInXG5dKTtcblxuLy8gQXR0cmlidXRlcyB0byBrZWVwXG5leHBvcnQgY29uc3QgQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbXG5cdCdhbHQnLFxuXHQnYWxsb3cnLFxuXHQnYWxsb3dmdWxsc2NyZWVuJyxcblx0J2FyaWEtbGFiZWwnLFxuXHQnY2hlY2tlZCcsXG5cdCdjb2xzcGFuJyxcblx0J2NvbnRyb2xzJyxcblx0J2RhdGEtbGF0ZXgnLFxuXHQnZGF0YS1zcmMnLFxuXHQnZGF0YS1zcmNzZXQnLFxuXHQnZGF0YS1sYW5nJyxcblx0J2RpcicsXG5cdCdkaXNwbGF5Jyxcblx0J2ZyYW1lYm9yZGVyJyxcblx0J2hlYWRlcnMnLFxuXHQnaGVpZ2h0Jyxcblx0J2hyZWYnLFxuXHQnbGFuZycsXG5cdCdyb2xlJyxcblx0J3Jvd3NwYW4nLFxuXHQnc3JjJyxcblx0J3NyY3NldCcsXG5cdCd0aXRsZScsXG5cdCd0eXBlJyxcblx0J3dpZHRoJyxcblxuXHQvLyBNYXRoTUwgYXR0cmlidXRlc1xuXHQnYWNjZW50Jyxcblx0J2FjY2VudHVuZGVyJyxcblx0J2FsaWduJyxcblx0J2NvbHVtbmFsaWduJyxcblx0J2NvbHVtbmxpbmVzJyxcblx0J2NvbHVtbnNwYWNpbmcnLFxuXHQnY29sdW1uc3BhbicsXG5cdCdkYXRhLW1qeC10ZXhjbGFzcycsXG5cdCdkZXB0aCcsXG5cdCdkaXNwbGF5c3R5bGUnLFxuXHQnZmVuY2UnLFxuXHQnZnJhbWUnLFxuXHQnZnJhbWVzcGFjaW5nJyxcblx0J2xpbmV0aGlja25lc3MnLFxuXHQnbHNwYWNlJyxcblx0J21hdGhzaXplJyxcblx0J21hdGh2YXJpYW50Jyxcblx0J21heHNpemUnLFxuXHQnbWluc2l6ZScsXG5cdCdtb3ZhYmxlbGltaXRzJyxcblx0J25vdGF0aW9uJyxcblx0J3Jvd2FsaWduJyxcblx0J3Jvd2xpbmVzJyxcblx0J3Jvd3NwYWNpbmcnLFxuXHQncm93c3BhbicsXG5cdCdyc3BhY2UnLFxuXHQnc2NyaXB0bGV2ZWwnLFxuXHQnc2VwYXJhdG9yJyxcblx0J3N0cmV0Y2h5Jyxcblx0J3N5bW1ldHJpYycsXG5cdCd2b2Zmc2V0Jyxcblx0J3htbG5zJ1xuXSk7XG5leHBvcnQgY29uc3QgQUxMT1dFRF9BVFRSSUJVVEVTX0RFQlVHID0gbmV3IFNldChbXG5cdCdjbGFzcycsXG5cdCdpZCcsXG5dKTtcblxuLy8gU3VwcG9ydGVkIGxhbmd1YWdlcyBmb3IgY29kZSBibG9ja3NcbmV4cG9ydCBjb25zdCBTVVBQT1JURURfTEFOR1VBR0VTID0gbmV3IFNldChbXG5cdC8vIE1hcmt1cCAmIFdlYlxuXHQnbWFya3VwJywgJ2h0bWwnLCAneG1sJywgJ3N2ZycsICdtYXRobWwnLCAnc3NtbCcsICdhdG9tJywgJ3JzcycsXG5cdCdqYXZhc2NyaXB0JywgJ2pzJywgJ2pzeCcsICd0eXBlc2NyaXB0JywgJ3RzJywgJ3RzeCcsXG5cdCd3ZWJhc3NlbWJseScsICd3YXNtJyxcblx0XG5cdC8vIENvbW1vbiBQcm9ncmFtbWluZyBMYW5ndWFnZXNcblx0J3B5dGhvbicsXG5cdCdqYXZhJyxcblx0J2NzaGFycCcsICdjcycsICdkb3RuZXQnLCAnYXNwbmV0Jyxcblx0J2NwcCcsICdjKysnLCAnYycsICdvYmpjJyxcblx0J3J1YnknLCAncmInLFxuXHQncGhwJyxcblx0J2dvbGFuZycsXG5cdCdydXN0Jyxcblx0J3N3aWZ0Jyxcblx0J2tvdGxpbicsXG5cdCdzY2FsYScsXG5cdCdkYXJ0Jyxcblx0XG5cdC8vIFNoZWxsICYgU2NyaXB0aW5nXG5cdCdiYXNoJywgJ3NoZWxsJywgJ3NoJyxcblx0J3Bvd2Vyc2hlbGwnLFxuXHQnYmF0Y2gnLFxuXHRcblx0Ly8gRGF0YSAmIENvbmZpZ1xuXHQnanNvbicsICdqc29ucCcsXG5cdCd5YW1sJywgJ3ltbCcsXG5cdCd0b21sJyxcblx0J2RvY2tlcmZpbGUnLFxuXHQnZ2l0aWdub3JlJyxcblx0XG5cdC8vIFF1ZXJ5IExhbmd1YWdlc1xuXHQnc3FsJywgJ215c3FsJywgJ3Bvc3RncmVzcWwnLFxuXHQnZ3JhcGhxbCcsXG5cdCdtb25nb2RiJyxcblx0J3NwYXJxbCcsXG5cdFxuXHQvLyBNYXJrdXAgJiBEb2N1bWVudGF0aW9uXG5cdCdtYXJrZG93bicsICdtZCcsXG5cdCdsYXRleCcsICd0ZXgnLFxuXHQnYXNjaWlkb2MnLCAnYWRvYycsXG5cdCdqc2RvYycsXG5cdFxuXHQvLyBGdW5jdGlvbmFsIExhbmd1YWdlc1xuXHQnaGFza2VsbCcsICdocycsXG5cdCdlbG0nLFxuXHQnZWxpeGlyJyxcblx0J2VybGFuZycsXG5cdCdvY2FtbCcsXG5cdCdmc2hhcnAnLFxuXHQnc2NoZW1lJyxcblx0J2xpc3AnLCAnZWxpc3AnLFxuXHQnY2xvanVyZScsXG5cdFxuXHQvLyBPdGhlciBMYW5ndWFnZXNcblx0J21hdGxhYicsXG5cdCdmb3J0cmFuJyxcblx0J2NvYm9sJyxcblx0J3Bhc2NhbCcsXG5cdCdwZXJsJyxcblx0J2x1YScsXG5cdCdqdWxpYScsXG5cdCdncm9vdnknLFxuXHQnY3J5c3RhbCcsXG5cdCduaW0nLFxuXHQnemlnJyxcblx0XG5cdC8vIERvbWFpbiBTcGVjaWZpY1xuXHQncmVnZXgnLFxuXHQnZ3JhZGxlJyxcblx0J2NtYWtlJyxcblx0J21ha2VmaWxlJyxcblx0J25peCcsXG5cdCd0ZXJyYWZvcm0nLFxuXHQnc29saWRpdHknLFxuXHQnZ2xzbCcsXG5cdCdobHNsJyxcblx0XG5cdC8vIEFzc2VtYmx5XG5cdCduYXNtJyxcblx0J21hc20nLFxuXHQnYXJtYXNtJyxcblx0XG5cdC8vIEdhbWUgRGV2ZWxvcG1lbnRcblx0J2dkc2NyaXB0Jyxcblx0J3VucmVhbHNjcmlwdCcsXG5cdFxuXHQvLyBPdGhlcnNcblx0J2FiYXAnLFxuXHQnYWN0aW9uc2NyaXB0Jyxcblx0J2FkYScsXG5cdCdhZ2RhJyxcblx0J2FudGxyNCcsXG5cdCdhcHBsZXNjcmlwdCcsXG5cdCdhcmR1aW5vJyxcblx0J2NvZmZlZXNjcmlwdCcsXG5cdCdkamFuZ28nLFxuXHQnZXJsYW5nJyxcblx0J2ZvcnRyYW4nLFxuXHQnaGF4ZScsXG5cdCdpZHJpcycsXG5cdCdrb3RsaW4nLFxuXHQnbGl2ZXNjcmlwdCcsXG5cdCdtYXRsYWInLFxuXHQnbmdpbngnLFxuXHQncGFzY2FsJyxcblx0J3Byb2xvZycsXG5cdCdwdXBwZXQnLFxuXHQnc2NhbGEnLFxuXHQnc2NoZW1lJyxcblx0J3RjbCcsXG5cdCd2ZXJpbG9nJyxcblx0J3ZoZGwnXG5dKTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIFBhcnNlRXJyb3IgY2xhc3MsIHdoaWNoIGlzIHRoZSBtYWluIGVycm9yIHRocm93biBieSBUZW1tbFxuICogZnVuY3Rpb25zIHdoZW4gc29tZXRoaW5nIGhhcyBnb25lIHdyb25nLiBUaGlzIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggaW50ZXJuYWxcbiAqIGVycm9ycyBmcm9tIGVycm9ycyBpbiB0aGUgZXhwcmVzc2lvbiB0aGF0IHRoZSB1c2VyIHByb3ZpZGVkLlxuICpcbiAqIElmIHBvc3NpYmxlLCBhIGNhbGxlciBzaG91bGQgcHJvdmlkZSBhIFRva2VuIG9yIFBhcnNlTm9kZSB3aXRoIGluZm9ybWF0aW9uXG4gKiBhYm91dCB3aGVyZSBpbiB0aGUgc291cmNlIHN0cmluZyB0aGUgcHJvYmxlbSBvY2N1cnJlZC5cbiAqL1xuY2xhc3MgUGFyc2VFcnJvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIG1lc3NhZ2UsIC8vIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgdG9rZW4gLy8gQW4gb2JqZWN0IHByb3ZpZGluZyBwb3NpdGlvbiBpbmZvcm1hdGlvblxuICApIHtcbiAgICBsZXQgZXJyb3IgPSBcIiBcIiArIG1lc3NhZ2U7XG4gICAgbGV0IHN0YXJ0O1xuXG4gICAgY29uc3QgbG9jID0gdG9rZW4gJiYgdG9rZW4ubG9jO1xuICAgIGlmIChsb2MgJiYgbG9jLnN0YXJ0IDw9IGxvYy5lbmQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgdGhlIGlucHV0IGFuZCBhIHBvc2l0aW9uLCBtYWtlIHRoZSBlcnJvciBhIGJpdCBmYW5jaWVyXG5cbiAgICAgIC8vIEdldCB0aGUgaW5wdXRcbiAgICAgIGNvbnN0IGlucHV0ID0gbG9jLmxleGVyLmlucHV0O1xuXG4gICAgICAvLyBQcmVwZW5kIHNvbWUgaW5mb3JtYXRpb25cbiAgICAgIHN0YXJ0ID0gbG9jLnN0YXJ0O1xuICAgICAgY29uc3QgZW5kID0gbG9jLmVuZDtcbiAgICAgIGlmIChzdGFydCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGVycm9yICs9IFwiIGF0IGVuZCBvZiBpbnB1dDogXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciArPSBcIiBhdCBwb3NpdGlvbiBcIiArIChzdGFydCArIDEpICsgXCI6IFxcblwiO1xuICAgICAgfVxuXG4gICAgICAvLyBVbmRlcmxpbmUgdG9rZW4gaW4gcXVlc3Rpb24gdXNpbmcgY29tYmluaW5nIHVuZGVyc2NvcmVzXG4gICAgICBjb25zdCB1bmRlcmxpbmVkID0gaW5wdXQuc2xpY2Uoc3RhcnQsIGVuZCkucmVwbGFjZSgvW15dL2csIFwiJCZcXHUwMzMyXCIpO1xuXG4gICAgICAvLyBFeHRyYWN0IHNvbWUgY29udGV4dCBmcm9tIHRoZSBpbnB1dCBhbmQgYWRkIGl0IHRvIHRoZSBlcnJvclxuICAgICAgbGV0IGxlZnQ7XG4gICAgICBpZiAoc3RhcnQgPiAxNSkge1xuICAgICAgICBsZWZ0ID0gXCLigKZcIiArIGlucHV0LnNsaWNlKHN0YXJ0IC0gMTUsIHN0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBpbnB1dC5zbGljZSgwLCBzdGFydCk7XG4gICAgICB9XG4gICAgICBsZXQgcmlnaHQ7XG4gICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQsIGVuZCArIDE1KSArIFwi4oCmXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCk7XG4gICAgICB9XG4gICAgICBlcnJvciArPSBsZWZ0ICsgdW5kZXJsaW5lZCArIHJpZ2h0O1xuICAgIH1cblxuICAgIC8vIFNvbWUgaGFja2VyeSB0byBtYWtlIFBhcnNlRXJyb3IgYSBwcm90b3R5cGUgb2YgRXJyb3JcbiAgICAvLyBTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODQ2MDc1M1xuICAgIGNvbnN0IHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICAgIHNlbGYuX19wcm90b19fID0gUGFyc2VFcnJvci5wcm90b3R5cGU7XG4gICAgc2VsZi5wb3NpdGlvbiA9IHN0YXJ0O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG59XG5cblBhcnNlRXJyb3IucHJvdG90eXBlLl9fcHJvdG9fXyA9IEVycm9yLnByb3RvdHlwZTtcblxuLy9cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGUgYSBkZWZhdWx0IHZhbHVlIGlmIGEgc2V0dGluZyBpcyB1bmRlZmluZWRcbiAqL1xuY29uc3QgZGVmbHQgPSBmdW5jdGlvbihzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHtcbiAgcmV0dXJuIHNldHRpbmcgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRJZlVuZGVmaW5lZCA6IHNldHRpbmc7XG59O1xuXG4vLyBoeXBoZW5hdGUgYW5kIGVzY2FwZSBhZGFwdGVkIGZyb20gRmFjZWJvb2sncyBSZWFjdCB1bmRlciBBcGFjaGUgMiBsaWNlbnNlXG5cbmNvbnN0IHVwcGVyY2FzZSA9IC8oW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHVwcGVyY2FzZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbmNvbnN0IEVTQ0FQRV9MT09LVVAgPSB7XG4gIFwiJlwiOiBcIiZhbXA7XCIsXG4gIFwiPlwiOiBcIiZndDtcIixcbiAgXCI8XCI6IFwiJmx0O1wiLFxuICAnXCInOiBcIiZxdW90O1wiLFxuICBcIidcIjogXCImI3gyNztcIlxufTtcblxuY29uc3QgRVNDQVBFX1JFR0VYID0gL1smPjxcIiddL2c7XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh0ZXh0KSB7XG4gIHJldHVybiBTdHJpbmcodGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIChtYXRjaCkgPT4gRVNDQVBFX0xPT0tVUFttYXRjaF0pO1xufVxuXG4vKipcbiAqIFNvbWV0aW1lcyB3ZSB3YW50IHRvIHB1bGwgb3V0IHRoZSBpbm5lcm1vc3QgZWxlbWVudCBvZiBhIGdyb3VwLiBJbiBtb3N0XG4gKiBjYXNlcywgdGhpcyB3aWxsIGp1c3QgYmUgdGhlIGdyb3VwIGl0c2VsZiwgYnV0IHdoZW4gb3JkZ3JvdXBzIGFuZCBjb2xvcnMgaGF2ZVxuICogYSBzaW5nbGUgZWxlbWVudCwgd2Ugd2FudCB0byBwdWxsIHRoYXQgb3V0LlxuICovXG5jb25zdCBnZXRCYXNlRWxlbSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gIGlmIChncm91cC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICBpZiAoZ3JvdXAuYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC5ib2R5WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcImNvbG9yXCIpIHtcbiAgICBpZiAoZ3JvdXAuYm9keS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC5ib2R5WzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcImZvbnRcIikge1xuICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC5ib2R5KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbn07XG5cbi8qKlxuICogVGVYYm9vayBhbGdvcml0aG1zIG9mdGVuIHJlZmVyZW5jZSBcImNoYXJhY3RlciBib3hlc1wiLCB3aGljaCBhcmUgc2ltcGx5IGdyb3Vwc1xuICogd2l0aCBhIHNpbmdsZSBjaGFyYWN0ZXIgaW4gdGhlbS4gVG8gZGVjaWRlIGlmIHNvbWV0aGluZyBpcyBhIGNoYXJhY3RlciBib3gsXG4gKiB3ZSBmaW5kIGl0cyBpbm5lcm1vc3QgZ3JvdXAsIGFuZCBzZWUgaWYgaXQgaXMgYSBzaW5nbGUgY2hhcmFjdGVyLlxuICovXG5jb25zdCBpc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gIGNvbnN0IGJhc2VFbGVtID0gZ2V0QmFzZUVsZW0oZ3JvdXApO1xuXG4gIC8vIFRoZXNlIGFyZSBhbGwgdGhlIHR5cGVzIG9mIGdyb3VwcyB3aGljaCBob2xkIHNpbmdsZSBjaGFyYWN0ZXJzXG4gIHJldHVybiBiYXNlRWxlbS50eXBlID09PSBcIm1hdGhvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcInRleHRvcmRcIiB8fCBiYXNlRWxlbS50eXBlID09PSBcImF0b21cIlxufTtcblxuY29uc3QgYXNzZXJ0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5vbi1udWxsLCBidXQgZ290IFwiICsgU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHByb3RvY29sIG9mIGEgVVJMLCBvciBcIl9yZWxhdGl2ZVwiIGlmIHRoZSBVUkwgZG9lcyBub3Qgc3BlY2lmeSBhXG4gKiBwcm90b2NvbCAoYW5kIHRodXMgaXMgcmVsYXRpdmUpLCBvciBgbnVsbGAgaWYgVVJMIGhhcyBpbnZhbGlkIHByb3RvY29sXG4gKiAoc28gc2hvdWxkIGJlIG91dHJpZ2h0IHJlamVjdGVkKS5cbiAqL1xuY29uc3QgcHJvdG9jb2xGcm9tVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gIC8vIENoZWNrIGZvciBwb3NzaWJsZSBsZWFkaW5nIHByb3RvY29sLlxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nIHN0cmlwcyBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgLy8gKFxceDAwKSBvciBDMCBjb250cm9sIChcXHgwMC1cXHgxRikgY2hhcmFjdGVycy5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgY29uc3QgcHJvdG9jb2wgPSAvXltcXHgwMC1cXHgyMF0qKFteXFxcXC8jP10qPykoOnwmIzAqNTh8JiN4MCozYXwmY29sb24pL2kuZXhlYyh1cmwpO1xuICBpZiAoIXByb3RvY29sKSB7XG4gICAgcmV0dXJuIFwiX3JlbGF0aXZlXCI7XG4gIH1cbiAgLy8gUmVqZWN0IHdlaXJkIGNvbG9uc1xuICBpZiAocHJvdG9jb2xbMl0gIT09IFwiOlwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gUmVqZWN0IGludmFsaWQgY2hhcmFjdGVycyBpbiBzY2hlbWUgYWNjb3JkaW5nIHRvXG4gIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTMuMVxuICBpZiAoIS9eW2EtekEtWl1bYS16QS1aMC05K1xcLS5dKiQvLnRlc3QocHJvdG9jb2xbMV0pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gTG93ZXJjYXNlIHRoZSBwcm90b2NvbFxuICByZXR1cm4gcHJvdG9jb2xbMV0udG9Mb3dlckNhc2UoKTtcbn07XG5cbi8qKlxuICogUm91bmQgYG5gIHRvIDQgZGVjaW1hbCBwbGFjZXMsIG9yIHRvIHRoZSBuZWFyZXN0IDEvMTAsMDAwdGggZW0uIFRoZSBUZVhib29rXG4gKiBnaXZlcyBhbiBhY2NlcHRhYmxlIHJvdW5kaW5nIGVycm9yIG9mIDEwMHNwICh3aGljaCB3b3VsZCBiZSB0aGUgbmVhcmVzdFxuICogMS82NTUxLjZlbSB3aXRoIG91ciBwdFBlckVtID0gMTApOlxuICogaHR0cDovL3d3dy5jdGV4Lm9yZy9kb2N1bWVudHMvc2hyZWRkZXIvc3JjL3RleGJvb2sucGRmI3BhZ2U9NjlcbiAqL1xuY29uc3Qgcm91bmQgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiArbi50b0ZpeGVkKDQpO1xufTtcblxudmFyIHV0aWxzID0ge1xuICBkZWZsdCxcbiAgZXNjYXBlLFxuICBoeXBoZW5hdGUsXG4gIGdldEJhc2VFbGVtLFxuICBpc0NoYXJhY3RlckJveCxcbiAgcHJvdG9jb2xGcm9tVXJsLFxuICByb3VuZFxufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbW9kdWxlIGZvciBzdG9yaW5nIHNldHRpbmdzIHBhc3NlZCBpbnRvIFRlbW1sLiBJdCBjb3JyZWN0bHkgaGFuZGxlc1xuICogZGVmYXVsdCBzZXR0aW5ncy5cbiAqL1xuXG5cbi8qKlxuICogVGhlIG1haW4gU2V0dGluZ3Mgb2JqZWN0XG4gKi9cbmNsYXNzIFNldHRpbmdzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8vIGFsbG93IG51bGwgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSB1dGlscy5kZWZsdChvcHRpb25zLmRpc3BsYXlNb2RlLCBmYWxzZSk7ICAgIC8vIGJvb2xlYW5cbiAgICB0aGlzLmFubm90YXRlID0gdXRpbHMuZGVmbHQob3B0aW9ucy5hbm5vdGF0ZSwgZmFsc2UpOyAgICAgICAgICAgLy8gYm9vbGVhblxuICAgIHRoaXMubGVxbm8gPSB1dGlscy5kZWZsdChvcHRpb25zLmxlcW5vLCBmYWxzZSk7ICAgICAgICAgICAgICAgIC8vIGJvb2xlYW5cbiAgICB0aGlzLnRocm93T25FcnJvciA9IHV0aWxzLmRlZmx0KG9wdGlvbnMudGhyb3dPbkVycm9yLCBmYWxzZSk7ICAvLyBib29sZWFuXG4gICAgdGhpcy5lcnJvckNvbG9yID0gdXRpbHMuZGVmbHQob3B0aW9ucy5lcnJvckNvbG9yLCBcIiNiMjIyMjJcIik7ICAvLyBzdHJpbmdcbiAgICB0aGlzLm1hY3JvcyA9IG9wdGlvbnMubWFjcm9zIHx8IHt9O1xuICAgIHRoaXMud3JhcCA9IHV0aWxzLmRlZmx0KG9wdGlvbnMud3JhcCwgXCJ0ZXhcIik7ICAgICAgICAgICAgICAgICAgICAvLyBcInRleFwiIHwgXCI9XCJcbiAgICB0aGlzLnhtbCA9IHV0aWxzLmRlZmx0KG9wdGlvbnMueG1sLCBmYWxzZSk7ICAgICAgICAgICAgICAgICAgICAgLy8gYm9vbGVhblxuICAgIHRoaXMuY29sb3JJc1RleHRDb2xvciA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuY29sb3JJc1RleHRDb2xvciwgZmFsc2UpOyAgLy8gYm9vZWxlYW5cbiAgICB0aGlzLnN0cmljdCA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuc3RyaWN0LCBmYWxzZSk7ICAgIC8vIGJvb2xlYW5cbiAgICB0aGlzLnRydXN0ID0gdXRpbHMuZGVmbHQob3B0aW9ucy50cnVzdCwgZmFsc2UpOyAgLy8gdHJ1c3QgY29udGV4dC4gU2VlIGh0bWwuanMuXG4gICAgdGhpcy5tYXhTaXplID0gKG9wdGlvbnMubWF4U2l6ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/IFtJbmZpbml0eSwgSW5maW5pdHldXG4gICAgICA6IEFycmF5LmlzQXJyYXkob3B0aW9ucy5tYXhTaXplKVxuICAgICAgPyBvcHRpb25zLm1heFNpemVcbiAgICAgIDogW0luZmluaXR5LCBJbmZpbml0eV1cbiAgICApO1xuICAgIHRoaXMubWF4RXhwYW5kID0gTWF0aC5tYXgoMCwgdXRpbHMuZGVmbHQob3B0aW9ucy5tYXhFeHBhbmQsIDEwMDApKTsgLy8gbnVtYmVyXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0byB0ZXN0IHBvdGVudGlhbGx5IGRhbmdlcm91cyBpbnB1dCwgYW5kIHJldHVyblxuICAgKiBgdHJ1ZWAgKHRydXN0ZWQpIG9yIGBmYWxzZWAgKHVudHJ1c3RlZCkuICBUaGUgc29sZSBhcmd1bWVudCBgY29udGV4dGBcbiAgICogc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGBjb21tYW5kYCBmaWVsZCBzcGVjaWZ5aW5nIHRoZSByZWxldmFudCBMYVRlWFxuICAgKiBjb21tYW5kIChhcyBhIHN0cmluZyBzdGFydGluZyB3aXRoIGBcXGApLCBhbmQgYW55IG90aGVyIGFyZ3VtZW50cywgZXRjLlxuICAgKiBJZiBgY29udGV4dGAgaGFzIGEgYHVybGAgZmllbGQsIGEgYHByb3RvY29sYCBmaWVsZCB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICogZ2V0IGFkZGVkIGJ5IHRoaXMgZnVuY3Rpb24gKGNoYW5naW5nIHRoZSBzcGVjaWZpZWQgb2JqZWN0KS5cbiAgICovXG4gIGlzVHJ1c3RlZChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQudXJsICYmICFjb250ZXh0LnByb3RvY29sKSB7XG4gICAgICBjb25zdCBwcm90b2NvbCA9IHV0aWxzLnByb3RvY29sRnJvbVVybChjb250ZXh0LnVybCk7XG4gICAgICBpZiAocHJvdG9jb2wgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGNvbnRleHQucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICB9XG4gICAgY29uc3QgdHJ1c3QgPSB0eXBlb2YgdGhpcy50cnVzdCA9PT0gXCJmdW5jdGlvblwiID8gdGhpcy50cnVzdChjb250ZXh0KSA6IHRoaXMudHJ1c3Q7XG4gICAgcmV0dXJuIEJvb2xlYW4odHJ1c3QpO1xuICB9XG59XG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZnVuY3Rpb25zLlxuICogYGZ1bmN0aW9ucy5qc2AganVzdCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkuXG4gKi9cbmNvbnN0IF9mdW5jdGlvbnMgPSB7fTtcblxuLyoqXG4gKiBBbGwgTWF0aE1MIGJ1aWxkZXJzLiBTaG91bGQgYmUgb25seSB1c2VkIGluIHRoZSBgZGVmaW5lKmAgYW5kIHRoZSBgYnVpbGQqTUxgXG4gKiBmdW5jdGlvbnMuXG4gKi9cbmNvbnN0IF9tYXRobWxHcm91cEJ1aWxkZXJzID0ge307XG5cbmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZSxcbiAgbmFtZXMsXG4gIHByb3BzLFxuICBoYW5kbGVyLFxuICBtYXRobWxCdWlsZGVyXG59KSB7XG4gIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBmdW5jdGlvbnNcbiAgY29uc3QgZGF0YSA9IHtcbiAgICB0eXBlLFxuICAgIG51bUFyZ3M6IHByb3BzLm51bUFyZ3MsXG4gICAgYXJnVHlwZXM6IHByb3BzLmFyZ1R5cGVzLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiAhIXByb3BzLmFsbG93ZWRJbkFyZ3VtZW50LFxuICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICBhbGxvd2VkSW5NYXRoOiBwcm9wcy5hbGxvd2VkSW5NYXRoID09PSB1bmRlZmluZWQgPyB0cnVlIDogcHJvcHMuYWxsb3dlZEluTWF0aCxcbiAgICBudW1PcHRpb25hbEFyZ3M6IHByb3BzLm51bU9wdGlvbmFsQXJncyB8fCAwLFxuICAgIGluZml4OiAhIXByb3BzLmluZml4LFxuICAgIHByaW1pdGl2ZTogISFwcm9wcy5wcmltaXRpdmUsXG4gICAgaGFuZGxlcjogaGFuZGxlclxuICB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgX2Z1bmN0aW9uc1tuYW1lc1tpXV0gPSBkYXRhO1xuICB9XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKG1hdGhtbEJ1aWxkZXIpIHtcbiAgICAgIF9tYXRobWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gbWF0aG1sQnVpbGRlcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgdGhpcyB0byByZWdpc3RlciBvbmx5IHRoZSBNYXRoTUwgYnVpbGRlciBmb3IgYSBmdW5jdGlvbihlLmcuXG4gKiBpZiB0aGUgZnVuY3Rpb24ncyBQYXJzZU5vZGUgaXMgZ2VuZXJhdGVkIGluIFBhcnNlci5qcyByYXRoZXIgdGhhbiB2aWEgYVxuICogc3RhbmQtYWxvbmUgaGFuZGxlciBwcm92aWRlZCB0byBgZGVmaW5lRnVuY3Rpb25gKS5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7IHR5cGUsIG1hdGhtbEJ1aWxkZXIgfSkge1xuICBkZWZpbmVGdW5jdGlvbih7XG4gICAgdHlwZSxcbiAgICBuYW1lczogW10sXG4gICAgcHJvcHM6IHsgbnVtQXJnczogMCB9LFxuICAgIGhhbmRsZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgYmUgY2FsbGVkLlwiKVxuICAgIH0sXG4gICAgbWF0aG1sQnVpbGRlclxuICB9KTtcbn1cblxuY29uc3Qgbm9ybWFsaXplQXJndW1lbnQgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIgJiYgYXJnLmJvZHkubGVuZ3RoID09PSAxID8gYXJnLmJvZHlbMF0gOiBhcmdcbn07XG5cbi8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkTWF0aE1MIGZ1bmN0aW9uIGV4cGVjdHMgYVxuLy8gbGlzdCBvZiBlbGVtZW50cywgd2Ugbm9ybWFsaXplIGZvciBkaWZmZXJlbnQga2luZHMgb2YgYXJndW1lbnRzXG5jb25zdCBvcmRhcmd1bWVudCA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIiA/IGFyZy5ib2R5IDogW2FyZ11cbn07XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBkb2N1bWVudCBmcmFnbWVudCwgd2hpY2ggY29udGFpbnMgZWxlbWVudHMsIGJ1dCB3aGVuXG4gKiBwbGFjZWQgaW50byB0aGUgRE9NIGRvZXNuJ3QgaGF2ZSBhbnkgcmVwcmVzZW50YXRpb24gaXRzZWxmLiBJdCBvbmx5IGNvbnRhaW5zXG4gKiBjaGlsZHJlbiBhbmQgZG9lc24ndCBoYXZlIGFueSBET00gbm9kZSBwcm9wZXJ0aWVzLlxuICovXG5jbGFzcyBEb2N1bWVudEZyYWdtZW50IHtcbiAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdGhpcy5jbGFzc2VzID0gW107XG4gICAgdGhpcy5zdHlsZSA9IHt9O1xuICB9XG5cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3Nlcy5pbmNsdWRlcyhjbGFzc05hbWUpO1xuICB9XG5cbiAgLyoqIENvbnZlcnQgdGhlIGZyYWdtZW50IGludG8gYSBub2RlLiAqL1xuICB0b05vZGUoKSB7XG4gICAgY29uc3QgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIC8qKiBDb252ZXJ0IHRoZSBmcmFnbWVudCBpbnRvIEhUTUwgbWFya3VwLiAqL1xuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gXCJcIjtcblxuICAgIC8vIFNpbXBseSBjb25jYXRlbmF0ZSB0aGUgbWFya3VwIGZvciB0aGUgY2hpbGRyZW4gdG9nZXRoZXIuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dC4gQXBwbGllcyB0b1xuICAgKiBNYXRoRG9tTm9kZSdzIG9ubHkuXG4gICAqL1xuICB0b1RleHQoKSB7XG4gICAgLy8gVG8gYXZvaWQgdGhpcywgd2Ugd291bGQgc3ViY2xhc3MgZG9jdW1lbnRGcmFnbWVudCBzZXBhcmF0ZWx5IGZvclxuICAgIC8vIE1hdGhNTCwgYnV0IHBvbHlmaWxscyBmb3Igc3ViY2xhc3NpbmcgaXMgZXhwZW5zaXZlIHBlciBQUiAxNDY5LlxuICAgIGNvbnN0IHRvVGV4dCA9IChjaGlsZCkgPT4gY2hpbGQudG9UZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKHRvVGV4dCkuam9pbihcIlwiKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZXNlIG9iamVjdHMgc3RvcmUgdGhlIGRhdGEgYWJvdXQgdGhlIERPTSBub2RlcyB3ZSBjcmVhdGUsIGFzIHdlbGwgYXMgc29tZVxuICogZXh0cmEgZGF0YS4gVGhleSBjYW4gdGhlbiBiZSB0cmFuc2Zvcm1lZCBpbnRvIHJlYWwgRE9NIG5vZGVzIHdpdGggdGhlXG4gKiBgdG9Ob2RlYCBmdW5jdGlvbiBvciBIVE1MIG1hcmt1cCB1c2luZyBgdG9NYXJrdXBgLiBUaGV5IGFyZSB1c2VmdWwgZm9yIGJvdGhcbiAqIHN0b3JpbmcgZXh0cmEgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMsIGFzIHdlbGwgYXMgcHJvdmlkaW5nIGEgd2F5IHRvIGVhc2lseVxuICogd29yayB3aXRoIHRoZSBET00uXG4gKlxuICogU2ltaWxhciBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBNYXRoTUwgbm9kZXMgZXhpc3QgaW4gbWF0aE1MVHJlZS5qcy5cbiAqXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYW4gSFRNTCBjbGFzc05hbWUgYmFzZWQgb24gYSBsaXN0IG9mIGNsYXNzZXMuIEluIGFkZGl0aW9uIHRvIGpvaW5pbmdcbiAqIHdpdGggc3BhY2VzLCB3ZSBhbHNvIHJlbW92ZSBlbXB0eSBjbGFzc2VzLlxuICovXG5jb25zdCBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uKGNsYXNzZXMpIHtcbiAgcmV0dXJuIGNsYXNzZXMuZmlsdGVyKChjbHMpID0+IGNscykuam9pbihcIiBcIik7XG59O1xuXG5jb25zdCBpbml0Tm9kZSA9IGZ1bmN0aW9uKGNsYXNzZXMsIHN0eWxlKSB7XG4gIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICB0aGlzLnN0eWxlID0gc3R5bGUgfHwge307XG59O1xuXG4vKipcbiAqIENvbnZlcnQgaW50byBhbiBIVE1MIG5vZGVcbiAqL1xuY29uc3QgdG9Ob2RlID0gZnVuY3Rpb24odGFnTmFtZSkge1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICAvLyBBcHBseSB0aGUgY2xhc3NcbiAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuXG4gIC8vIEFwcGx5IGlubGluZSBzdHlsZXNcbiAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGx5IGF0dHJpYnV0ZXNcbiAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyICkpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogQ29udmVydCBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZ1xuICovXG5jb25zdCB0b01hcmt1cCA9IGZ1bmN0aW9uKHRhZ05hbWUpIHtcbiAgbGV0IG1hcmt1cCA9IGA8JHt0YWdOYW1lfWA7XG5cbiAgLy8gQWRkIHRoZSBjbGFzc1xuICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgIG1hcmt1cCArPSBgIGNsYXNzPVwiJHt1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSl9XCJgO1xuICB9XG5cbiAgbGV0IHN0eWxlcyA9IFwiXCI7XG5cbiAgLy8gQWRkIHRoZSBzdHlsZXMsIGFmdGVyIGh5cGhlbmF0aW9uXG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgc3R5bGVzICs9IGAke3V0aWxzLmh5cGhlbmF0ZShzdHlsZSl9OiR7dGhpcy5zdHlsZVtzdHlsZV19O2A7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0eWxlcykge1xuICAgIG1hcmt1cCArPSBgIHN0eWxlPVwiJHtzdHlsZXN9XCJgO1xuICB9XG5cbiAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG4gIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0ciApKSB7XG4gICAgICBtYXJrdXAgKz0gYCAke2F0dHJ9PVwiJHt1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKX1cImA7XG4gICAgfVxuICB9XG5cbiAgbWFya3VwICs9IFwiPlwiO1xuXG4gIC8vIEFkZCB0aGUgbWFya3VwIG9mIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBtYXJrdXBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgfVxuXG4gIG1hcmt1cCArPSBgPC8ke3RhZ05hbWV9PmA7XG5cbiAgcmV0dXJuIG1hcmt1cDtcbn07XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBzcGFuIG5vZGUsIHdpdGggYSBjbGFzc05hbWUsIGEgbGlzdCBvZiBjaGlsZHJlbiwgYW5kXG4gKiBhbiBpbmxpbmUgc3R5bGUuXG4gKlxuICovXG5jbGFzcyBTcGFuIHtcbiAgY29uc3RydWN0b3IoY2xhc3NlcywgY2hpbGRyZW4sIHN0eWxlKSB7XG4gICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBzdHlsZSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICB9XG5cbiAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlO1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIHJldHVybiB0b05vZGUuY2FsbCh0aGlzLCBcInNwYW5cIik7XG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICByZXR1cm4gdG9NYXJrdXAuY2FsbCh0aGlzLCBcInNwYW5cIik7XG4gIH1cbn1cblxubGV0IFRleHROb2RlJDEgPSBjbGFzcyBUZXh0Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KTtcbiAgfVxuICB0b01hcmt1cCgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXNjYXBlKHRoaXMudGV4dCk7XG4gIH1cbn07XG5cbi8vIENyZWF0ZSBhbiA8YSBocmVmPVwi4oCmXCI+IG5vZGUuXG5jbGFzcyBBbmNob3JOb2RlIHtcbiAgY29uc3RydWN0b3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4pIHtcbiAgICB0aGlzLmhyZWYgPSBocmVmO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICB9XG5cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdGhpcy5ocmVmKTtcbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgbGV0IG1hcmt1cCA9IGA8YSBocmVmPScke3V0aWxzLmVzY2FwZSh0aGlzLmhyZWYpfSdgO1xuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbWFya3VwICs9IGAgY2xhc3M9XCIke3V0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKX1cImA7XG4gICAgfVxuICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuICAgIG1hcmt1cCArPSBcIjwvYT5cIjtcbiAgICByZXR1cm4gbWFya3VwXG4gIH1cbn1cblxuLypcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGFuIGltYWdlIGVtYmVkICg8aW1nPikgZWxlbWVudC5cbiAqL1xuY2xhc3MgSW1nIHtcbiAgY29uc3RydWN0b3Ioc3JjLCBhbHQsIHN0eWxlKSB7XG4gICAgdGhpcy5hbHQgPSBhbHQ7XG4gICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgdGhpcy5jbGFzc2VzID0gW1wibW9yZFwiXTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgbm9kZS5zcmMgPSB0aGlzLnNyYztcbiAgICBub2RlLmFsdCA9IHRoaXMuYWx0O1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJtb3JkXCI7XG5cbiAgICAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgICAgbm9kZS5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIGxldCBtYXJrdXAgPSBgPGltZyBzcmM9JyR7dGhpcy5zcmN9JyBhbHQ9JyR7dGhpcy5hbHR9J2A7XG5cbiAgICAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cbiAgICBsZXQgc3R5bGVzID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgICBzdHlsZXMgKz0gYCR7dXRpbHMuaHlwaGVuYXRlKHN0eWxlKX06JHt0aGlzLnN0eWxlW3N0eWxlXX07YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbWFya3VwICs9IGAgc3R5bGU9XCIke3V0aWxzLmVzY2FwZShzdHlsZXMpfVwiYDtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI+XCI7XG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxufVxuXG4vL1xuLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIGRhdGEgYWJvdXQgTWF0aE1MIG5vZGVzLlxuICogVGhlIGB0b05vZGVgIGFuZCBgdG9NYXJrdXBgIGZ1bmN0aW9ucyAgY3JlYXRlIG5hbWVzcGFjZWQgRE9NIG5vZGVzIGFuZFxuICogSFRNTCB0ZXh0IG1hcmt1cCByZXNwZWN0aXZlbHkuXG4gKi9cblxuXG5mdW5jdGlvbiBuZXdEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7XG59XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBnZW5lcmFsIHB1cnBvc2UgTWF0aE1MIG5vZGUgb2YgYW55IHR5cGUsXG4gKiBmb3IgZXhhbXBsZSwgYFwibW9cImAgb3IgYFwibXNwYWNlXCJgLCBjb3JyZXNwb25kaW5nIHRvIGA8bW8+YCBhbmRcbiAqIGA8bXNwYWNlPmAgdGFncykuXG4gKi9cbmNsYXNzIE1hdGhOb2RlIHtcbiAgY29uc3RydWN0b3IodHlwZSwgY2hpbGRyZW4sIGNsYXNzZXMsIHN0eWxlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGUgfHwge307ICAgLy8gVXNlZCBmb3IgPG1zdHlsZT4gZWxlbWVudHNcbiAgICB0aGlzLmxhYmVsID0gXCJcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLiBNYXRoTUwgZGVwZW5kcyBvbiBhdHRyaWJ1dGVzIHRvIGNvbnZleSBhXG4gICAqIHNlbWFudGljIGNvbnRlbnQsIHNvIHRoaXMgaXMgdXNlZCBoZWF2aWx5LlxuICAgKi9cbiAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS5cbiAgICovXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgfVxuXG4gIHNldExhYmVsKHZhbHVlKSB7XG4gICAgdGhpcy5sYWJlbCA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICAgKi9cbiAgdG9Ob2RlKCkge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsIHRoaXMudHlwZSk7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBpbmxpbmUgc3R5bGVzXG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgICAgbm9kZS5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZy5cbiAgICovXG4gIHRvTWFya3VwKCkge1xuICAgIGxldCBtYXJrdXAgPSBcIjxcIiArIHRoaXMudHlwZTtcblxuICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgJz1cIic7XG4gICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgbWFya3VwICs9ICdcIic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXJrdXAgKz0gYCBjbGFzcz1cIiR7dXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpfVwiYDtcbiAgICB9XG5cbiAgICBsZXQgc3R5bGVzID0gXCJcIjtcblxuICAgIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICAgIHN0eWxlcyArPSBgJHt1dGlscy5oeXBoZW5hdGUoc3R5bGUpfToke3RoaXMuc3R5bGVbc3R5bGVdfTtgO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgIG1hcmt1cCArPSBgIHN0eWxlPVwiJHtzdHlsZXN9XCJgO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG5cbiAgICBtYXJrdXAgKz0gXCI8L1wiICsgdGhpcy50eXBlICsgXCI+XCI7XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQsIGJ1dCBlc2NhcGVkLlxuICAgKi9cbiAgdG9UZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLnRvVGV4dCgpKS5qb2luKFwiXCIpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBwaWVjZSBvZiB0ZXh0LlxuICovXG5jbGFzcyBUZXh0Tm9kZSB7XG4gIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIERPTSB0ZXh0IG5vZGUuXG4gICAqL1xuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGVzY2FwZWQgSFRNTCBtYXJrdXBcbiAgICogKHJlcHJlc2VudGluZyB0aGUgdGV4dCBpdHNlbGYpLlxuICAgKi9cbiAgdG9NYXJrdXAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRvVGV4dCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gYSBzdHJpbmdcbiAgICogKHJlcHJlc2VudGluZyB0aGUgdGV4dCBpdHNlbGYpLlxuICAgKi9cbiAgdG9UZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cbn1cblxuLy8gRG8gbm90IG1ha2UgYW4gPG1yb3c+IHRoZSBvbmx5IGNoaWxkIG9mIGEgPG1zdHlsZT4uXG4vLyBBbiA8bXN0eWxlPiBhY3RzIGFzIGl0cyBvd24gaW1wbGljaXQgPG1yb3c+LlxuY29uc3Qgd3JhcFdpdGhNc3R5bGUgPSBleHByZXNzaW9uID0+IHtcbiAgbGV0IG5vZGU7XG4gIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSAmJiBleHByZXNzaW9uWzBdLnR5cGUgPT09IFwibXJvd1wiKSB7XG4gICAgbm9kZSA9IGV4cHJlc3Npb24ucG9wKCk7XG4gICAgbm9kZS50eXBlID0gXCJtc3R5bGVcIjtcbiAgfSBlbHNlIHtcbiAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibXN0eWxlXCIsIGV4cHJlc3Npb24pO1xuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG52YXIgbWF0aE1MVHJlZSA9IHtcbiAgTWF0aE5vZGUsXG4gIFRleHROb2RlLFxuICBuZXdEb2N1bWVudEZyYWdtZW50XG59O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBwcm92aWRlcyBzdXBwb3J0IGZvciBidWlsZGluZyBob3Jpem9udGFsIHN0cmV0Y2h5IGVsZW1lbnRzLlxuICovXG5cblxuLy8gVE9ETzogUmVtb3ZlIHdoZW4gQ2hyb21pdW0gc3RyZXRjaGVzIFxcd2lkZXRpbGRlICYgXFx3aWRlaGF0XG5jb25zdCBlc3RpbWF0ZWRXaWR0aCA9IG5vZGUgPT4ge1xuICBsZXQgd2lkdGggPSAwO1xuICBpZiAobm9kZS5ib2R5KSB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuYm9keSkge1xuICAgICAgd2lkdGggKz0gZXN0aW1hdGVkV2lkdGgoaXRlbSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgIHdpZHRoICs9IGVzdGltYXRlZFdpZHRoKG5vZGUuYmFzZSk7XG4gICAgaWYgKG5vZGUuc3ViKSB7IHdpZHRoICs9IDAuNyAqIGVzdGltYXRlZFdpZHRoKG5vZGUuc3ViKTsgfVxuICAgIGlmIChub2RlLnN1cCkgeyB3aWR0aCArPSAwLjcgKiBlc3RpbWF0ZWRXaWR0aChub2RlLnN1cCk7IH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8IG5vZGUudHlwZSA9PT0gXCJ0ZXh0b3JkXCIpIHtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIG5vZGUudGV4dC5zcGxpdCgnJykpIHtcbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGNoLmNvZGVQb2ludEF0KDApO1xuICAgICAgaWYgKCgweDYwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4N0IpIHx8ICgweDAzQjAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgzQ0EpKSB7XG4gICAgICAgIHdpZHRoICs9IDAuNTY7IC8vIGxvd2VyIGNhc2UgbGF0aW4gb3IgZ3JlZWsuIFVzZSBhZHZhbmNlIHdpZHRoIG9mIGxldHRlciBuXG4gICAgICB9IGVsc2UgaWYgKDB4MkYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgzQSkge1xuICAgICAgICB3aWR0aCArPSAwLjUwOyAvLyBudW1lcmFscy5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoICs9IDAuOTI7IC8vIGFkdmFuY2Ugd2lkdGggb2YgbGV0dGVyIE1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggKz0gMS4wO1xuICB9XG4gIHJldHVybiB3aWR0aFxufTtcblxuY29uc3Qgc3RyZXRjaHlDb2RlUG9pbnQgPSB7XG4gIHdpZGVoYXQ6IFwiXlwiLFxuICB3aWRlY2hlY2s6IFwiy4dcIixcbiAgd2lkZXRpbGRlOiBcIn5cIixcbiAgd2lkZXBhcmVuOiBcIuKPnFwiLCAvLyBcXHUyM2RjXG4gIHV0aWxkZTogXCJ+XCIsXG4gIG92ZXJsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICB1bmRlcmxlZnRhcnJvdzogXCJcXHUyMTkwXCIsXG4gIHhsZWZ0YXJyb3c6IFwiXFx1MjE5MFwiLFxuICBvdmVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHVuZGVycmlnaHRhcnJvdzogXCJcXHUyMTkyXCIsXG4gIHhyaWdodGFycm93OiBcIlxcdTIxOTJcIixcbiAgdW5kZXJicmFjZTogXCJcXHUyM2RmXCIsXG4gIG92ZXJicmFjZTogXCJcXHUyM2RlXCIsXG4gIG92ZXJncm91cDogXCJcXHUyM2UwXCIsXG4gIG92ZXJwYXJlbjogXCLij5xcIixcbiAgdW5kZXJncm91cDogXCJcXHUyM2UxXCIsXG4gIHVuZGVycGFyZW46IFwiXFx1MjNkZFwiLFxuICBvdmVybGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjE5NFwiLFxuICB1bmRlcmxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgeGxlZnRyaWdodGFycm93OiBcIlxcdTIxOTRcIixcbiAgT3ZlcnJpZ2h0YXJyb3c6IFwiXFx1MjFkMlwiLFxuICB4UmlnaHRhcnJvdzogXCJcXHUyMWQyXCIsXG4gIG92ZXJsZWZ0aGFycG9vbjogXCJcXHUyMWJjXCIsXG4gIHhsZWZ0aGFycG9vbnVwOiBcIlxcdTIxYmNcIixcbiAgb3ZlcnJpZ2h0aGFycG9vbjogXCJcXHUyMWMwXCIsXG4gIHhyaWdodGhhcnBvb251cDogXCJcXHUyMWMwXCIsXG4gIHhMZWZ0YXJyb3c6IFwiXFx1MjFkMFwiLFxuICB4TGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjFkNFwiLFxuICB4aG9va2xlZnRhcnJvdzogXCJcXHUyMWE5XCIsXG4gIHhob29rcmlnaHRhcnJvdzogXCJcXHUyMWFhXCIsXG4gIHhtYXBzdG86IFwiXFx1MjFhNlwiLFxuICB4cmlnaHRoYXJwb29uZG93bjogXCJcXHUyMWMxXCIsXG4gIHhsZWZ0aGFycG9vbmRvd246IFwiXFx1MjFiZFwiLFxuICB4dHdvaGVhZGxlZnRhcnJvdzogXCJcXHUyMTllXCIsXG4gIHh0d29oZWFkcmlnaHRhcnJvdzogXCJcXHUyMWEwXCIsXG4gIHhsb25nZXF1YWw6IFwiPVwiLFxuICB4cmlnaHRsZWZ0YXJyb3dzOiBcIlxcdTIxYzRcIixcbiAgeWllbGRzOiBcIlxcdTIxOTJcIixcbiAgeWllbGRzTGVmdDogXCJcXHUyMTkwXCIsXG4gIG1lc29tZXJpc206IFwiXFx1MjE5NFwiLFxuICBsb25ncmlnaHRoYXJwb29udXA6IFwiXFx1MjFjMFwiLFxuICBsb25nbGVmdGhhcnBvb25kb3duOiBcIlxcdTIxYmRcIixcbiAgZXFyaWdodGhhcnBvb251cDogXCJcXHUyMWMwXCIsXG4gIGVxbGVmdGhhcnBvb25kb3duOiBcIlxcdTIxYmRcIixcbiAgXCJcXFxcY2RyaWdodGFycm93XCI6IFwiXFx1MjE5MlwiLFxuICBcIlxcXFxjZGxlZnRhcnJvd1wiOiBcIlxcdTIxOTBcIixcbiAgXCJcXFxcY2Rsb25nZXF1YWxcIjogXCI9XCJcbn07XG5cbmNvbnN0IG1hdGhNTG5vZGUgPSBmdW5jdGlvbihsYWJlbCkge1xuICBjb25zdCBjaGlsZCA9IG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKHN0cmV0Y2h5Q29kZVBvaW50W2xhYmVsLnNsaWNlKDEpXSk7XG4gIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtjaGlsZF0pO1xuICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmNvbnN0IGNyb29rZWRXaWRlcyA9IFtcIlxcXFx3aWRldGlsZGVcIiwgXCJcXFxcd2lkZWhhdFwiLCBcIlxcXFx3aWRlY2hlY2tcIiwgXCJcXFxcdXRpbGRlXCJdO1xuXG4vLyBUT0RPOiBSZW1vdmUgd2hlbiBDaHJvbWl1bSBzdHJldGNoZXMgXFx3aWRldGlsZGUgJiBcXHdpZGVoYXRcbmNvbnN0IGFjY2VudE5vZGUgPSAoZ3JvdXApID0+IHtcbiAgY29uc3QgbW8gPSBtYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgaWYgKGNyb29rZWRXaWRlcy5pbmNsdWRlcyhncm91cC5sYWJlbCkpIHtcbiAgICBjb25zdCB3aWR0aCA9IGVzdGltYXRlZFdpZHRoKGdyb3VwLmJhc2UpO1xuICAgIGlmICgxIDwgd2lkdGggJiYgd2lkdGggPCAxLjYpIHtcbiAgICAgIG1vLmNsYXNzZXMucHVzaChcInRtbC1jcm9va2VkLTJcIik7XG4gICAgfSBlbHNlIGlmICgxLjYgPD0gd2lkdGggJiYgd2lkdGggPCAyLjUpIHtcbiAgICAgIG1vLmNsYXNzZXMucHVzaChcInRtbC1jcm9va2VkLTNcIik7XG4gICAgfSBlbHNlIGlmICgyLjUgPD0gd2lkdGgpIHtcbiAgICAgIG1vLmNsYXNzZXMucHVzaChcInRtbC1jcm9va2VkLTRcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb1xufTtcblxudmFyIHN0cmV0Y2h5ID0ge1xuICBtYXRoTUxub2RlLFxuICBhY2NlbnROb2RlXG59O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBob2xkcyBhIGxpc3Qgb2YgYWxsIG5vLWFyZ3VtZW50IGZ1bmN0aW9ucyBhbmQgc2luZ2xlLWNoYXJhY3RlclxuICogc3ltYm9scyAobGlrZSAnYScgb3IgJzsnKS5cbiAqXG4gKiBGb3IgZWFjaCBvZiB0aGUgc3ltYm9scywgdGhlcmUgYXJlIHR3byBwcm9wZXJ0aWVzIHRoZXkgY2FuIGhhdmU6XG4gKiAtIGdyb3VwIChyZXF1aXJlZCk6IHRoZSBQYXJzZU5vZGUgZ3JvdXAgdHlwZSB0aGUgc3ltYm9sIHNob3VsZCBoYXZlIChpLmUuXG4gICAgIFwidGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgZXRjKS5cbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuXG4vLyBTb21lIG9mIHRoZXNlIGhhdmUgYSBcIi10b2tlblwiIHN1ZmZpeCBzaW5jZSB0aGVzZSBhcmUgYWxzbyB1c2VkIGFzIGBQYXJzZU5vZGVgXG4vLyB0eXBlcyBmb3IgcmF3IHRleHQgdG9rZW5zLCBhbmQgd2Ugd2FudCB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBoaWdoZXItbGV2ZWxcbi8vIGBQYXJzZU5vZGVgIHR5cGVzLiBUaGVzZSBgUGFyc2VOb2RlYHMgYXJlIGNvbnN0cnVjdGVkIHdpdGhpbiBgUGFyc2VyYCBieVxuLy8gbG9va2luZyB1cCB0aGUgYHN5bWJvbHNgIG1hcC5cbmNvbnN0IEFUT01TID0ge1xuICBiaW46IDEsXG4gIGNsb3NlOiAxLFxuICBpbm5lcjogMSxcbiAgb3BlbjogMSxcbiAgcHVuY3Q6IDEsXG4gIHJlbDogMVxufTtcbmNvbnN0IE5PTl9BVE9NUyA9IHtcbiAgXCJhY2NlbnQtdG9rZW5cIjogMSxcbiAgbWF0aG9yZDogMSxcbiAgXCJvcC10b2tlblwiOiAxLFxuICBzcGFjaW5nOiAxLFxuICB0ZXh0b3JkOiAxXG59O1xuXG5jb25zdCBzeW1ib2xzID0ge1xuICBtYXRoOiB7fSxcbiAgdGV4dDoge31cbn07XG5cbi8qKiBgYWNjZXB0VW5pY29kZUNoYXIgPSB0cnVlYCBpcyBvbmx5IGFwcGxpY2FibGUgaWYgYHJlcGxhY2VgIGlzIHNldC4gKi9cbmZ1bmN0aW9uIGRlZmluZVN5bWJvbChtb2RlLCBncm91cCwgcmVwbGFjZSwgbmFtZSwgYWNjZXB0VW5pY29kZUNoYXIpIHtcbiAgc3ltYm9sc1ttb2RlXVtuYW1lXSA9IHsgZ3JvdXAsIHJlcGxhY2UgfTtcblxuICBpZiAoYWNjZXB0VW5pY29kZUNoYXIgJiYgcmVwbGFjZSkge1xuICAgIHN5bWJvbHNbbW9kZV1bcmVwbGFjZV0gPSBzeW1ib2xzW21vZGVdW25hbWVdO1xuICB9XG59XG5cbi8vIFNvbWUgYWJicmV2aWF0aW9ucyBmb3IgY29tbW9ubHkgdXNlZCBzdHJpbmdzLlxuLy8gVGhpcyBoZWxwcyBtaW5pZnkgdGhlIGNvZGUsIGFuZCBhbHNvIHNwb3R0aW5nIHR5cG9zIHVzaW5nIGpzaGludC5cblxuLy8gbW9kZXM6XG5jb25zdCBtYXRoID0gXCJtYXRoXCI7XG5jb25zdCB0ZXh0ID0gXCJ0ZXh0XCI7XG5cbi8vIGdyb3VwczpcbmNvbnN0IGFjY2VudCA9IFwiYWNjZW50LXRva2VuXCI7XG5jb25zdCBiaW4gPSBcImJpblwiO1xuY29uc3QgY2xvc2UgPSBcImNsb3NlXCI7XG5jb25zdCBpbm5lciA9IFwiaW5uZXJcIjtcbmNvbnN0IG1hdGhvcmQgPSBcIm1hdGhvcmRcIjtcbmNvbnN0IG9wID0gXCJvcC10b2tlblwiO1xuY29uc3Qgb3BlbiA9IFwib3BlblwiO1xuY29uc3QgcHVuY3QgPSBcInB1bmN0XCI7XG5jb25zdCByZWwgPSBcInJlbFwiO1xuY29uc3Qgc3BhY2luZyA9IFwic3BhY2luZ1wiO1xuY29uc3QgdGV4dG9yZCA9IFwidGV4dG9yZFwiO1xuXG4vLyBOb3cgY29tZXMgdGhlIHN5bWJvbCB0YWJsZVxuXG4vLyBSZWxhdGlvbiBTeW1ib2xzXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjFcIiwgXCJcXFxcZXF1aXZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyN2FcIiwgXCJcXFxccHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3YlwiLCBcIlxcXFxzdWNjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjNjXCIsIFwiXFxcXHNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdjMlwiLCBcIlxcXFxwZXJwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWFmXCIsIFwiXFxcXHByZWNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiMFwiLCBcIlxcXFxzdWNjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDNcIiwgXCJcXFxcc2ltZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNGNcIiwgXCJcXFxcYmFja2NvbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcInxcIiwgXCJcXFxcbWlkXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjZhXCIsIFwiXFxcXGxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjZiXCIsIFwiXFxcXGdnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjRkXCIsIFwiXFxcXGFzeW1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjkxXCIsIFwiXFxcXHNxc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOTJcIiwgXCJcXFxcc3FzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxmcm93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxuaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwY1wiLCBcIlxcXFxub3RuaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIxZFwiLCBcIlxcXFxwcm9wdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYTJcIiwgXCJcXFxcdmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYTNcIiwgXCJcXFxcZGFzaHZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcb3duc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1OFwiLCBcIlxcXFxhcmNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1OVwiLCBcIlxcXFx3ZWRnZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNWFcIiwgXCJcXFxcdmVlZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNWJcIiwgXCJcXFxcc3RhcmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjVkXCIsIFwiXFxcXGVxZGVmXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjVlXCIsIFwiXFxcXG1lYXNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1ZlwiLCBcIlxcXFxxdWVzdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbi8vIHVuaWNvZGVtYXRoXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhNzVcIiwgXCJcXFxcZXFlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE3NlwiLCBcIlxcXFxlcWVxZXFcIiwgdHJ1ZSk7XG4vLyBtYXRodG9vbHMuc3R5XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMzdcIiwgXCJcXFxcZGJsY29sb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTRcIiwgXCJcXFxcY29sb25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTVcIiwgXCJcXFxcZXFxY29sb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMzlcIiwgXCJcXFxcZXFjb2xvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MkE3NFwiLCBcIlxcXFxDb2xvbmVxcVwiLCB0cnVlKTtcblxuLy8gUHVuY3R1YXRpb25cbmRlZmluZVN5bWJvbChtYXRoLCBwdW5jdCwgXCJcXHUwMDJlXCIsIFwiXFxcXGxkb3RwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHB1bmN0LCBcIlxcdTAwYjdcIiwgXCJcXFxcY2RvdHBcIik7XG5cbi8vIE1pc2MgU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIiwgdHJ1ZSk7XG4vLyDiiIcgaXMgYWN0dWFsbHkgYSB1bmFyeSBvcGVyYXRvciwgbm90IGJpbmFyeS4gQnV0IHRoaXMgd29ya3MuXG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMDdcIiwgXCJcXFxcbmFibGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjZkXCIsIFwiXFxcXGZsYXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTEzXCIsIFwiXFxcXGVsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NmVcIiwgXCJcXFxcbmF0dXJhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIuKEq1wiLCBcIlxcXFxBbmdzdHJvbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIuKEq1wiLCBcIlxcXFxBbmdzdHJvbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjNcIiwgXCJcXFxcY2x1YnN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjY3XCIsIFwiXFxcXHZhcmNsdWJzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2NlwiLCBcIlxcXFx2YXJkaWFtb25kc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMWNcIiwgXCJcXFxcUmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjYxXCIsIFwiXFxcXGhlYXJ0c3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjVcIiwgXCJcXFxcdmFyaGVhcnRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2NFwiLCBcIlxcXFx2YXJzcGFkZXN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjQwXCIsIFwiXFxcXGZlbWFsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NDJcIiwgXCJcXFxcbWFsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYTdcIiwgXCJcXFxcU1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYTdcIiwgXCJcXFxcU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYjZcIiwgXCJcXFxcUFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYjZcIiwgXCJcXFxcUFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTI2M2FcIiwgXCJcXFxcc21pbGV5XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjYzYVwiLCBcIlxcXFxzbWlsZXlcIiwgdHJ1ZSk7XG5cbi8vIE1hdGggYW5kIFRleHRcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcZGFnXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFxkYWdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXHRleHRkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXGRkYWdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDIxXCIsIFwiXFxcXHRleHRkYWdnZXJkYmxcIik7XG5cbi8vIExhcmdlIERlbGltaXRlcnNcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyM2IxXCIsIFwiXFxcXHJtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyM2IwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjdlZlwiLCBcIlxcXFxyZ3JvdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyN2VlXCIsIFwiXFxcXGxncm91cFwiLCB0cnVlKTtcblxuLy8gQmluYXJ5IE9wZXJhdG9yc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjEzXCIsIFwiXFxcXG1wXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk2XCIsIFwiXFxcXG9taW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI4ZVwiLCBcIlxcXFx1cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5M1wiLCBcIlxcXFxzcWNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxN1wiLCBcIlxcXFxhc3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTRcIiwgXCJcXFxcc3FjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1ZWZcIiwgXCJcXFxcYmlnY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxOVwiLCBcIlxcXFxidWxsZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI0MFwiLCBcIlxcXFx3clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MmEzZlwiLCBcIlxcXFxhbWFsZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MDAyNlwiLCBcIlxcXFxBbmRcIik7IC8vIGZyb20gYW1zbWF0aFxuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQUZEXCIsIFwiXFxcXHNzbGFzaFwiLCB0cnVlKTsgLy8gZnJvbSBzdG1hcnlyZFxuXG4vLyBBcnJvdyBTeW1ib2xzXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkMFwiLCBcIlxcXFxMZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZjhcIiwgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkMlwiLCBcIlxcXFxSaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2Y5XCIsIFwiXFxcXExvbmdyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2Y3XCIsIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkNFwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmYVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYTRcIiwgXCJcXFxcbWFwc2Zyb21cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYTZcIiwgXCJcXFxcbWFwc3RvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2ZjXCIsIFwiXFxcXGxvbmdtYXBzdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhOVwiLCBcIlxcXFxob29rbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWFhXCIsIFwiXFxcXGhvb2tyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYmNcIiwgXCJcXFxcbGVmdGhhcnBvb251cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjMFwiLCBcIlxcXFxyaWdodGhhcnBvb251cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJkXCIsIFwiXFxcXGxlZnRoYXJwb29uZG93blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjMVwiLCBcIlxcXFxyaWdodGhhcnBvb25kb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2NcIiwgXCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyMWFmXCIsIFwiXFxcXGxpZ2h0bmluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTIyMEVcIiwgXCJcXFxcUUVEXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjAzMFwiLCBcIlxcXFxwZXJtaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDMwXCIsIFwiXFxcXHBlcm1pbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTI2MDlcIiwgXCJcXFxcYXN0cm9zdW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyNjNjXCIsIFwiXFxcXHN1blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTI2M2VcIiwgXCJcXFxcbGVmdG1vb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyNjNkXCIsIFwiXFxcXHJpZ2h0bW9vblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTIyOTVcIiwgXCJcXFxcRWFydGhcIik7XG5cbi8vIEFNUyBOZWdhdGVkIEJpbmFyeSBSZWxhdGlvbnNcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2ZVwiLCBcIlxcXFxubGVzc1wiLCB0cnVlKTtcbi8vIFN5bWJvbCBuYW1lcyBwcmVjZWVkZWQgYnkgXCJAXCIgZWFjaCBoYXZlIGEgY29ycmVzcG9uZGluZyBtYWNyby5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4N1wiLCBcIlxcXFxsbmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY4XCIsIFwiXFxcXGxuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY4XFx1ZmUwMFwiLCBcIlxcXFxsdmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZTZcIiwgXCJcXFxcbG5zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhODlcIiwgXCJcXFxcbG5hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODBcIiwgXCJcXFxcbnByZWNcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMmUwIHRvIFxcbnByZWNjdXJseWVxLiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmUwXCIsIFwiXFxcXG5wcmVjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZThcIiwgXCJcXFxccHJlY25zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjlcIiwgXCJcXFxccHJlY25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDFcIiwgXCJcXFxcbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxubWlkXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjI0XCIsIFwiXFxcXG5zaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhY1wiLCBcIlxcXFxudmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWRcIiwgXCJcXFxcbnZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmVhXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZWNcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg0XCIsIFwiXFxcXG5zdWJzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODVcIiwgXCJcXFxcbnN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4YVwiLCBcIlxcXFxzdWJzZXRuZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOGFcXHVmZTAwXCIsIFwiXFxcXHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjYlwiLCBcIlxcXFxzdWJzZXRuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWNiXFx1ZmUwMFwiLCBcIlxcXFx2YXJzdWJzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjZmXCIsIFwiXFxcXG5ndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2OVwiLCBcIlxcXFxnbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2OVxcdWZlMDBcIiwgXCJcXFxcZ3ZlcnRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmU3XCIsIFwiXFxcXGduc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYThhXCIsIFwiXFxcXGduYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjgxXCIsIFwiXFxcXG5zdWNjXCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjJlMSB0byBcXG5zdWNjY3VybHllcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlMVwiLCBcIlxcXFxuc3VjY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWJhXCIsIFwiXFxcXHN1Y2NuYXBwcm94XCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjI0NiB0byBcXHNpbW5lcXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDZcIiwgXCJcXFxcbmNvbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjZcIiwgXCJcXFxcbnBhcmFsbGVsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjI2XCIsIFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmFmXCIsIFwiXFxcXG5WRGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlYlwiLCBcIlxcXFxudHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlZFwiLCBcIlxcXFxudHJpYW5nbGVyaWdodGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjhiXCIsIFwiXFxcXHN1cHNldG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4YlwiLCBcIlxcXFx2YXJzdXBzZXRuZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhY2NcIiwgXCJcXFxcc3Vwc2V0bmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjY1xcdWZlMDBcIiwgXCJcXFxcdmFyc3Vwc2V0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhZVwiLCBcIlxcXFxuVmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjVcIiwgXCJcXFxccHJlY25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYjZcIiwgXCJcXFxcc3VjY25lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYjRcIiwgXCJcXFxcdW5saGRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYjVcIiwgXCJcXFxcdW5yaGRcIik7XG5cbi8vIEFNUyBOZWdhdGVkIEFycm93c1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTlhXCIsIFwiXFxcXG5sZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOWJcIiwgXCJcXFxcbnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2RcIiwgXCJcXFxcbkxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjZlwiLCBcIlxcXFxuUmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhZVwiLCBcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2VcIiwgXCJcXFxcbkxlZnRyaWdodGFycm93XCIsIHRydWUpO1xuXG4vLyBBTVMgTWlzY1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWJkXCIsIFwiXFxcXHRyaWFuZ2xlZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI0YzhcIiwgXCJcXFxcY2lyY2xlZFNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGFlXCIsIFwiXFxcXGNpcmNsZWRSXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYWVcIiwgXCJcXFxcdGV4dHJlZ2lzdGVyZWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjIxXCIsIFwiXFxcXG1lYXN1cmVkYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjA0XCIsIFwiXFxcXG5leGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTI3XCIsIFwiXFxcXG1ob1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMzJcIiwgXCJcXFxcRmludlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxNDFcIiwgXCJcXFxcR2FtZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzVcIiwgXCJcXFxcYmFja3ByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzNlwiLCBcIlxcXFxiYWNrZHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzN1wiLCBcIlxcXFxiYWNrdHJwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1YjJcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1YmNcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWEwXCIsIFwiXFxcXGJsYWNrc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjllYlwiLCBcIlxcXFxibGFja2xvemVuZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjA1XCIsIFwiXFxcXGJpZ3N0YXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjIyXCIsIFwiXFxcXHNwaGVyaWNhbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwMVwiLCBcIlxcXFxjb21wbGVtZW50XCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgVStGMCB0byBcXG1hdGhldGguIFdlIG1hcCB0byBBTVMgZnVuY3Rpb24gXFxldGhcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXFxcZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBmMFwiLCBcIlxcdTAwZjBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1NzJcIiwgXCJcXFxcZGlhZ2Rvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWExXCIsIFwiXFxcXHNxdWFyZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjVjYVwiLCBcIlxcXFxEaWFtb25kXCIpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgVStBNSB0byBcXG1hdGh5ZW4uIFdlIG1hcCB0byBBTVMgZnVuY3Rpb24gXFx5ZW5cbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjcxN1wiLCBcIlxcXFxiYWxsb3R4XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjcxN1wiLCBcIlxcXFxiYWxsb3R4XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAyMlwiLCBcIlxcXFx0ZXh0YnVsbGV0XCIpO1xuXG4vLyBBTVMgSGVicmV3XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTM2XCIsIFwiXFxcXGJldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTM4XCIsIFwiXFxcXGRhbGV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMzdcIiwgXCJcXFxcZ2ltZWxcIiwgdHJ1ZSk7XG5cbi8vIEFNUyBHcmVla1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDNkZFwiLCBcIlxcXFxkaWdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDNmMFwiLCBcIlxcXFx2YXJrYXBwYVwiKTtcblxuLy8gQU1TIERlbGltaXRlcnNcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTIzMUNcIiwgXCJcXFxcdWxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjMxRFwiLCBcIlxcXFx1cmNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTIzMUVcIiwgXCJcXFxcbGxjb3JuZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjMxRlwiLCBcIlxcXFxscmNvcm5lclwiLCB0cnVlKTtcblxuLy8gQU1TIEJpbmFyeSBSZWxhdGlvbnNcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTdkXCIsIFwiXFxcXGxlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTk1XCIsIFwiXFxcXGVxc2xhbnRsZXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhODVcIiwgXCJcXFxcbGVzc2FwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0YVwiLCBcIlxcXFxhcHByb3hlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJkNlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3NlwiLCBcIlxcXFxsZXNzZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmRhXCIsIFwiXFxcXGxlc3NlcWd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4YlwiLCBcIlxcXFxsZXNzZXFxZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjUxXCIsIFwiXFxcXGRvdGVxZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1MlwiLCBcIlxcXFxmYWxsaW5nZG90c2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjNkXCIsIFwiXFxcXGJhY2tzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyY2RcIiwgXCJcXFxcYmFja3NpbWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWM1XCIsIFwiXFxcXHN1YnNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkMFwiLCBcIlxcXFxTdWJzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOGZcIiwgXCJcXFxcc3FzdWJzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyN2NcIiwgXCJcXFxccHJlY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZGVcIiwgXCJcXFxcY3VybHllcXByZWNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyN2VcIiwgXCJcXFxccHJlY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiN1wiLCBcIlxcXFxwcmVjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmIyXCIsIFwiXFxcXHZhcnRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFx2RGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhYlwiLCBcIlxcXFxWRGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhYVwiLCBcIlxcXFxWdmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxzbWFsbGZyb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjRmXCIsIFwiXFxcXGJ1bXBlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0ZVwiLCBcIlxcXFxCdW1wZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjdcIiwgXCJcXFxcZ2VxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE3ZVwiLCBcIlxcXFxnZXFzbGFudFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjczXCIsIFwiXFxcXGd0cnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4NlwiLCBcIlxcXFxndHJhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3N1wiLCBcIlxcXFxndHJsZXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmRiXCIsIFwiXFxcXGd0cmVxbGVzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4Y1wiLCBcIlxcXFxndHJlcXFsZXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU2XCIsIFwiXFxcXGVxY2lyY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNWNcIiwgXCJcXFxcdHJpYW5nbGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjNjXCIsIFwiXFxcXHRoaWNrc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWM2XCIsIFwiXFxcXHN1cHNldGVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkMVwiLCBcIlxcXFxTdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyN2RcIiwgXCJcXFxcc3VjY2N1cmx5ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZGZcIiwgXCJcXFxcY3VybHllcXN1Y2NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyN2ZcIiwgXCJcXFxcc3VjY3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiOFwiLCBcIlxcXFxzdWNjYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmE5XCIsIFwiXFxcXFZkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjIzXCIsIFwiXFxcXHNob3J0bWlkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNmNcIiwgXCJcXFxcYmV0d2VlblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkNFwiLCBcIlxcXFxwaXRjaGZvcmtcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyNWMwXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVsZWZ0XCIpO1xuLy8gdW5pY29kZS1tYXRoIHNheXMgdGhhdCBcXHRoZXJlZm9yZSBpcyBhIG1hdGhvcmQgYXRvbS5cbi8vIFdlIGtlcHQgdGhlIGFtc3N5bWIgYXRvbSB0eXBlLCB3aGljaCBpcyByZWwuXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMzRcIiwgXCJcXFxcdGhlcmVmb3JlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjBkXCIsIFwiXFxcXGJhY2tlcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyNWI2XCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVyaWdodFwiKTtcbi8vIHVuaWNvZGUtbWF0aCBzYXlzIHRoYXQgXFxiZWNhdXNlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzNVwiLCBcIlxcXFxiZWNhdXNlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmQ4XCIsIFwiXFxcXGxsbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkOVwiLCBcIlxcXFxnZ2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiMlwiLCBcIlxcXFxsaGRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYjNcIiwgXCJcXFxccmhkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQyXCIsIFwiXFxcXGVxc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjUxXCIsIFwiXFxcXERvdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyOTdkXCIsIFwiXFxcXHN0cmljdGlmXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyOTdjXCIsIFwiXFxcXHN0cmljdGZpXCIsIHRydWUpO1xuXG4vLyBBTVMgQmluYXJ5IE9wZXJhdG9yc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE0XCIsIFwiXFxcXGRvdHBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc21hbGxzZXRtaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJkMlwiLCBcIlxcXFxDYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDNcIiwgXCJcXFxcQ3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyYTVlXCIsIFwiXFxcXGRvdWJsZWJhcndlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjlmXCIsIFwiXFxcXGJveG1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjllXCIsIFwiXFxcXGJveHBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzRcIiwgXCJcXFxcYm94c2xhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzdcIiwgXCJcXFxcZGl2aWRlb250aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjOVwiLCBcIlxcXFxsdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyY2FcIiwgXCJcXFxccnRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmNiXCIsIFwiXFxcXGxlZnR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmNjXCIsIFwiXFxcXHJpZ2h0dGhyZWV0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjZlwiLCBcIlxcXFxjdXJseXdlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmNlXCIsIFwiXFxcXGN1cmx5dmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjlkXCIsIFwiXFxcXGNpcmNsZWRkYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjliXCIsIFwiXFxcXGNpcmNsZWRhc3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYmFcIiwgXCJcXFxcaW50ZXJjYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcZG91YmxlY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXGRvdWJsZWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJhMFwiLCBcIlxcXFxib3h0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjOFwiLCBcIlxcXFxib3d0aWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzhcIiwgXCJcXFxcSm9pblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdkNVwiLCBcIlxcXFxsZWZ0b3V0ZXJqb2luXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN2Q2XCIsIFwiXFxcXHJpZ2h0b3V0ZXJqb2luXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN2Q3XCIsIFwiXFxcXGZ1bGxvdXRlcmpvaW5cIiwgdHJ1ZSk7XG5cbi8vIHN0aXggQmluYXJ5IE9wZXJhdG9yc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjM4XCIsIFwiXFxcXGRvdG1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0QxXCIsIFwiXFxcXHdlZGdlZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0M3XCIsIFwiXFxcXHZlZWRvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE2MlwiLCBcIlxcXFxkb3VibGViYXJ2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNjNcIiwgXCJcXFxcdmVlZG91YmxlYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTVGXCIsIFwiXFxcXHdlZGdlYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTYwXCIsIFwiXFxcXHdlZGdlZG91YmxlYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTU0XCIsIFwiXFxcXFZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE1M1wiLCBcIlxcXFxXZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0M1wiLCBcIlxcXFxiYXJjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDJcIiwgXCJcXFxcYmFyY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQ4XCIsIFwiXFxcXGNhcGJhcmN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0MFwiLCBcIlxcXFxjYXBkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDdcIiwgXCJcXFxcY2Fwb3ZlcmN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0NlwiLCBcIlxcXFxjdXBvdmVyY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTREXCIsIFwiXFxcXGNsb3NlZHZhcmNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0Q1wiLCBcIlxcXFxjbG9zZWR2YXJjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMkFcIiwgXCJcXFxcbWludXNkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMkJcIiwgXCJcXFxcbWludXNmZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEyQ1wiLCBcIlxcXFxtaW51c3Jkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMkJCXCIsIFwiXFxcXFhvclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJCQ1wiLCBcIlxcXFxOYW5kXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMkJEXCIsIFwiXFxcXE5vclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJCRFwiLCBcIlxcXFxiYXJ2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBRjRcIiwgXCJcXFxcaW50ZXJsZWF2ZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlFMlwiLCBcIlxcXFxzaHVmZmxlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQUY2XCIsIFwiXFxcXHRocmVlZG90Y29sb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5ODJcIiwgXCJcXFxcdHlwZWNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjNFXCIsIFwiXFxcXGludmxhenlzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTRCXCIsIFwiXFxcXHR3b2NhcHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNEFcIiwgXCJcXFxcdHdvY3Vwc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0RVwiLCBcIlxcXFxTcWNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0RlwiLCBcIlxcXFxTcWN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE1NlwiLCBcIlxcXFx2ZWVvbnZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE1NVwiLCBcIlxcXFx3ZWRnZW9ud2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5RDdcIiwgXCJcXFxcYmxhY2tob3VyZ2xhc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzZcIiwgXCJcXFxcYm94YXN0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUM4XCIsIFwiXFxcXGJveGJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDN1wiLCBcIlxcXFxib3hjaXJjbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOUNcIiwgXCJcXFxcY2lyY2xlZGVxdWFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUI3XCIsIFwiXFxcXGNpcmNsZWRwYXJhbGxlbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlCNlwiLCBcIlxcXFxjaXJjbGVkdmVydFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlCNVwiLCBcIlxcXFxjaXJjbGVoYmFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0UxXCIsIFwiXFxcXGNvbmNhdmVkaWFtb25kXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0UyXCIsIFwiXFxcXGNvbmNhdmVkaWFtb25kdGlja2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RTNcIiwgXCJcXFxcY29uY2F2ZWRpYW1vbmR0aWNrcmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQzRcIiwgXCJcXFxcZGlhbW9uZFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlENlwiLCBcIlxcXFxob3VyZ2xhc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RTBcIiwgXCJcXFxcbG96ZW5nZW1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMzNEXCIsIFwiXFxcXG9iYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QjhcIiwgXCJcXFxcb2JzbGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzOFwiLCBcIlxcXFxvZGl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUMxXCIsIFwiXFxcXG9ncmVhdGVydGhhblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDMFwiLCBcIlxcXFxvbGVzc3RoYW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QjlcIiwgXCJcXFxcb3BlcnBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMzdcIiwgXCJcXFxcT3RpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTM2XCIsIFwiXFxcXG90aW1lc2hhdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJDNlwiLCBcIlxcXFxzdGFyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNUIzXCIsIFwiXFxcXHRyaWFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTNBXCIsIFwiXFxcXHRyaWFuZ2xlbWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMzlcIiwgXCJcXFxcdHJpYW5nbGVwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTNCXCIsIFwiXFxcXHRyaWFuZ2xldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RTRcIiwgXCJcXFxcd2hpdGVzcXVhcmV0aWNrbGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFNVwiLCBcIlxcXFx3aGl0ZXNxdWFyZXRpY2tyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzM1wiLCBcIlxcXFxzbWFzaHRpbWVzXCIsIHRydWUpO1xuXG4vLyBBTVMgQXJyb3dzXG4vLyBOb3RlOiB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWUyIHRvIHRoZWlyIG93biBmdW5jdGlvbiBcXHJpZ2h0ZGFzaGFycm93LlxuLy8gV2UnbGwgbWFwIGl0IHRvIEFNUyBmdW5jdGlvbiBcXGRhc2hyaWdodGFycm93LiBJdCBwcm9kdWNlcyB0aGUgc2FtZSBhdG9tLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWUyXCIsIFwiXFxcXGRhc2hyaWdodGFycm93XCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFlMCB0byBcXGxlZnRkYXNoYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZTBcIiwgXCJcXFxcZGFzaGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjNlwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZGFcIiwgXCJcXFxcTGxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5ZVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWEyXCIsIFwiXFxcXGxlZnRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYWJcIiwgXCJcXFxcbG9vcGFycm93bGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjYlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiNlwiLCBcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxYmEgdG8gXFxhY3dvcGVuY2lyY2xlYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWIwXCIsIFwiXFxcXExzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjOFwiLCBcIlxcXFx1cHVwYXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzNcIiwgXCJcXFxcZG93bmhhcnBvb25sZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmI2XCIsIFwiXFxcXG9yaWdvZlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiN1wiLCBcIlxcXFxpbWFnZW9mXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmI4XCIsIFwiXFxcXG11bHRpbWFwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWFkXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzlcIiwgXCJcXFxccmlnaHRyaWdodGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjNFwiLCBcIlxcXFxyaWdodGxlZnRhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYTNcIiwgXCJcXFxccmlnaHRhcnJvd3RhaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYWNcIiwgXCJcXFxcbG9vcGFycm93cmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYiB0byBcXGN3b3BlbmNpcmNsZWFycm93LiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJiXCIsIFwiXFxcXGNpcmNsZWFycm93cmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYjFcIiwgXCJcXFxcUnNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNhXCIsIFwiXFxcXGRvd25kb3duYXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWJlXCIsIFwiXFxcXHVwaGFycG9vbnJpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWMyXCIsIFwiXFxcXGRvd25oYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWRkXCIsIFwiXFxcXGxlYWRzdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZGJcIiwgXCJcXFxcUnJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxccmVzdHJpY3Rpb25cIik7XG5cbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiJFwiLCBcIlxcXFx0ZXh0ZG9sbGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiwqJcIiwgXCJcXFxcY2VudFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIsKiXCIsIFwiXFxcXGNlbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCIlXCIsIFwiXFxcXCVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCIlXCIsIFwiXFxcXCVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXF9cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXF9cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJfXCIsIFwiXFxcXHRleHR1bmRlcnNjb3JlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjQyM1wiLCBcIlxcXFx0ZXh0dmlzaWJsZXNwYWNlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIyMFwiLCBcIlxcXFxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMWVcIiwgXCJcXFxcaW5mdHlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzM1wiLCBcIlxcXFxkcHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDM0XCIsIFwiXFxcXHRycHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDU3XCIsIFwiXFxcXHFwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1YjNcIiwgXCJcXFxcdHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzkxXCIsIFwiXFxcXEFscGhhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5MlwiLCBcIlxcXFxCZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5M1wiLCBcIlxcXFxHYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTRcIiwgXCJcXFxcRGVsdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk1XCIsIFwiXFxcXEVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk2XCIsIFwiXFxcXFpldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk3XCIsIFwiXFxcXEV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOThcIiwgXCJcXFxcVGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzk5XCIsIFwiXFxcXElvdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzlhXCIsIFwiXFxcXEthcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5YlwiLCBcIlxcXFxMYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzljXCIsIFwiXFxcXE11XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5ZFwiLCBcIlxcXFxOdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWVcIiwgXCJcXFxcWGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzlmXCIsIFwiXFxcXE9taWNyb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2EwXCIsIFwiXFxcXFBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhMVwiLCBcIlxcXFxSaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2EzXCIsIFwiXFxcXFNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhNFwiLCBcIlxcXFxUYXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2E1XCIsIFwiXFxcXFVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2E2XCIsIFwiXFxcXFBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTdcIiwgXCJcXFxcQ2hpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhOFwiLCBcIlxcXFxQc2lcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2E5XCIsIFwiXFxcXE9tZWdhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5MVwiLCBcIlxcXFxBbHBoYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTJcIiwgXCJcXFxcQmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5NVwiLCBcIlxcXFxFcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5NlwiLCBcIlxcXFxaZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5N1wiLCBcIlxcXFxFdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzk4XCIsIFwiXFxcXFRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5OVwiLCBcIlxcXFxJb3RhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5YVwiLCBcIlxcXFxLYXBwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5Y1wiLCBcIlxcXFxNdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWRcIiwgXCJcXFxcTnVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzllXCIsIFwiXFxcXFhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5ZlwiLCBcIlxcXFxPbWljcm9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhMFwiLCBcIlxcXFxQaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTFcIiwgXCJcXFxcUmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhM1wiLCBcIlxcXFxTaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTRcIiwgXCJcXFxcVGF1XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E3XCIsIFwiXFxcXENoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYThcIiwgXCJcXFxcUHNpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhOVwiLCBcIlxcXFxPbWVnYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTAwYWNcIiwgXCJcXFxcbmVnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MDBhY1wiLCBcIlxcXFxsbm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjJhNFwiLCBcIlxcXFx0b3BcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMmE1XCIsIFwiXFxcXGJvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDVcIiwgXCJcXFxcZW1wdHlzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMzAwXCIsIFwiXFxcXHZhcm5vdGhpbmdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2IxXCIsIFwiXFxcXGFscGhhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiMlwiLCBcIlxcXFxiZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiM1wiLCBcIlxcXFxnYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjRcIiwgXCJcXFxcZGVsdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Y1XCIsIFwiXFxcXGVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I2XCIsIFwiXFxcXHpldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I3XCIsIFwiXFxcXGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjhcIiwgXCJcXFxcdGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I5XCIsIFwiXFxcXGlvdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2JhXCIsIFwiXFxcXGthcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiYlwiLCBcIlxcXFxsYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2JjXCIsIFwiXFxcXG11XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiZFwiLCBcIlxcXFxudVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmVcIiwgXCJcXFxceGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2JmXCIsIFwiXFxcXG9taWNyb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2MwXCIsIFwiXFxcXHBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjMVwiLCBcIlxcXFxyaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2MzXCIsIFwiXFxcXHNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjNFwiLCBcIlxcXFx0YXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2M1XCIsIFwiXFxcXHVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Q1XCIsIFwiXFxcXHBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzdcIiwgXCJcXFxcY2hpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjOFwiLCBcIlxcXFxwc2lcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2M5XCIsIFwiXFxcXG9tZWdhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiNVwiLCBcIlxcXFx2YXJlcHNpbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkMVwiLCBcIlxcXFx2YXJ0aGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDZcIiwgXCJcXFxcdmFycGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2YxXCIsIFwiXFxcXHZhcnJob1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzJcIiwgXCJcXFxcdmFyc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2M2XCIsIFwiXFxcXHZhcnBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDhcIiwgXCJcXFxcQ29wcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Q5XCIsIFwiXFxcXGNvcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkOVwiLCBcIlxcXFx2YXJjb3BwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZGVcIiwgXCJcXFxcS29wcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2RmXCIsIFwiXFxcXGtvcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNlMFwiLCBcIlxcXFxTYW1waVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZTFcIiwgXCJcXFxcc2FtcGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2RhXCIsIFwiXFxcXFN0aWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZGJcIiwgXCJcXFxcc3RpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MmFlYlwiLCBcIlxcXFxCb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTdcIiwgXCJcXHUyMjE3XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCIrXCIsIFwiK1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxN1wiLCBcIipcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIwNDRcIiwgXCIvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMDQ0XCIsIFwiXFx1MjA0NFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxMlwiLCBcIi1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxOFwiLCBcIlxcXFxjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUwMGY3XCIsIFwiXFxcXGRpdlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MDBiMVwiLCBcIlxcXFxwbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MDBkN1wiLCBcIlxcXFx0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyOVwiLCBcIlxcXFxjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMmFcIiwgXCJcXFxcY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE2XCIsIFwiXFxcXHNldG1pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjI3XCIsIFwiXFxcXGxhbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcbG9yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjI3XCIsIFwiXFxcXHdlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjI4XCIsIFwiXFxcXHZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI3ZTZcIiwgXCJcXFxcbGxicmFja2V0XCIsIHRydWUpOyAvLyBzdG1hcnlyZC9zZW1hbnRpYyBwYWNrYWdlc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI3ZTdcIiwgXCJcXFxccnJicmFja2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjdlOFwiLCBcIlxcXFxsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyN2VhXCIsIFwiXFxcXGxBbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI5ODlcIiwgXCJcXFxcbGxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcInxcIiwgXCJcXFxcbHZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyMDE2XCIsIFwiXFxcXGxWZXJ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiIVwiLCBcIlxcXFxvY1wiKTsgLy8gY21sbCBwYWNrYWdlXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCI/XCIsIFwiXFxcXHduXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjE5M1wiLCBcIlxcXFxzaHBvc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxOTVcIiwgXCJcXFxcc2hpZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTkxXCIsIFwiXFxcXHNobmVnXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIj9cIiwgXCI/XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIiFcIiwgXCIhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIuKAvFwiLCBcIuKAvFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyN2U5XCIsIFwiXFxcXHJhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyN2ViXCIsIFwiXFxcXHJBbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyOThhXCIsIFwiXFxcXHJyYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwifFwiLCBcIlxcXFxydmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyMDE2XCIsIFwiXFxcXHJWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1Mjk4M1wiLCBcIlxcXFxsQnJhY2VcIiwgdHJ1ZSk7IC8vIHN0bWFyeXJkL3NlbWFudGljIHBhY2thZ2VzXG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1Mjk4NFwiLCBcIlxcXFxyQnJhY2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIj1cIiwgXCJcXFxcZXF1YWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIjpcIiwgXCI6XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXGFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0NVwiLCBcIlxcXFxjb25nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY1XCIsIFwiXFxcXGdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxnZXRzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCI+XCIsIFwiXFxcXGd0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjA4XCIsIFwiXFxcXGluXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjA5XCIsIFwiXFxcXG5vdGluXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHVlMDIwXCIsIFwiXFxcXEBub3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODJcIiwgXCJcXFxcc3Vic2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjgzXCIsIFwiXFxcXHN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4NlwiLCBcIlxcXFxzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4N1wiLCBcIlxcXFxzdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4OFwiLCBcIlxcXFxuc3Vic2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4OVwiLCBcIlxcXFxuc3Vwc2V0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODlcIiwgXCJcXFxcbnN1cHNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhOFwiLCBcIlxcXFxtb2RlbHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY0XCIsIFwiXFxcXGxlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiPFwiLCBcIlxcXFxsdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcxXCIsIFwiXFxcXG5nZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzBcIiwgXCJcXFxcbmxlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzBcIiwgXCJcXFxcbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWViXCIsIFwiXFxcXFBlcnBcIiwgdHJ1ZSk7IC8vY21sbCBwYWNrYWdlXG5kZWZpbmVTeW1ib2wobWF0aCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXHNwYWNlXCIpO1xuLy8gUmVmOiBMYVRlWCBTb3VyY2UgMmU6IFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFxub2JyZWFrc3BhY2V9eyVcbmRlZmluZVN5bWJvbChtYXRoLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcbm9icmVha3NwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFwgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIiBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXHNwYWNlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxub2JyZWFrc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgc3BhY2luZywgbnVsbCwgXCJcXFxcbm9icmVha1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBzcGFjaW5nLCBudWxsLCBcIlxcXFxhbGxvd2JyZWFrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHB1bmN0LCBcIixcIiwgXCIsXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHB1bmN0LCBcIjpcIiwgXCI6XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHB1bmN0LCBcIjtcIiwgXCI7XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmJjXCIsIFwiXFxcXGJhcndlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmJiXCIsIFwiXFxcXHZlZWJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5OVwiLCBcIlxcXFxvZG90XCIsIHRydWUpO1xuLy8gRmlyZWZveCB0dXJucyDiipUgaW50byBhbiBlbW9qaS4gU28gYXBwZW5kIFxcdUZFMEUuIERlZmluZSBVbmljb2RlIGNoYXJhY3RlciBpbiBtYWNyb3MsIG5vdCBoZXJlLlxuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk1XFx1RkUwRVwiLCBcIlxcXFxvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5N1wiLCBcIlxcXFxvdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjAyXCIsIFwiXFxcXHBhcnRpYWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOThcIiwgXCJcXFxcb3NsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjlhXCIsIFwiXFxcXGNpcmNsZWRjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmExXCIsIFwiXFxcXGJveGRvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjViM1wiLCBcIlxcXFxiaWd0cmlhbmdsZXVwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNWJkXCIsIFwiXFxcXGJpZ3RyaWFuZ2xlZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjAyMFwiLCBcIlxcXFxkYWdnZXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYzRcIiwgXCJcXFxcZGlhbW9uZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjVjM1wiLCBcIlxcXFx0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1YjlcIiwgXCJcXFxcdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIntcIiwgXCJcXFxce1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIntcIiwgXCJcXFxce1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIntcIiwgXCJcXFxcdGV4dGJyYWNlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJ9XCIsIFwiXFxcXH1cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ9XCIsIFwiXFxcXH1cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ9XCIsIFwiXFxcXHRleHRicmFjZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwie1wiLCBcIlxcXFxsYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwifVwiLCBcIlxcXFxyYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCIoXCIsIFwiXFxcXGxwYXJlblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCIpXCIsIFwiXFxcXHJwYXJlblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIuKmh1wiLCBcIlxcXFxsbHBhcmVudGhlc2lzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIuKmiFwiLCBcIlxcXFxycnBhcmVudGhlc2lzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiPFwiLCBcIlxcXFx0ZXh0bGVzc1wiLCB0cnVlKTsgLy8gaW4gVDEgZm9udGVuY1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiPlwiLCBcIlxcXFx0ZXh0Z3JlYXRlclwiLCB0cnVlKTsgLy8gaW4gVDEgZm9udGVuY1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjMwYVwiLCBcIlxcXFxsZmxvb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjMwYlwiLCBcIlxcXFxyZmxvb3JcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyMzA4XCIsIFwiXFxcXGxjZWlsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzMDlcIiwgXCJcXFxccmNlaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXFxcXCIsIFwiXFxcXGJhY2tzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcInxcIiwgXCJ8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwifFwiLCBcIlxcXFx2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwifFwiLCBcIlxcXFx0ZXh0YmFyXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDE2XCIsIFwiXFxcXHxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDE2XCIsIFwiXFxcXFZlcnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE2XCIsIFwiXFxcXHRleHRiYXJkYmxcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ+XCIsIFwiXFxcXHRleHRhc2NpaXRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFx0ZXh0YmFja3NsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXlwiLCBcIlxcXFx0ZXh0YXNjaWljaXJjdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTFcIiwgXCJcXFxcdXBhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkMVwiLCBcIlxcXFxVcGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkzXCIsIFwiXFxcXGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkM1wiLCBcIlxcXFxEb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTVcIiwgXCJcXFxcdXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZDVcIiwgXCJcXFxcVXBkb3duYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIxMFwiLCBcIlxcXFxjb3Byb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjJjMVwiLCBcIlxcXFxiaWd2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjJjMFwiLCBcIlxcXFxiaWd3ZWRnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA0XCIsIFwiXFxcXGJpZ3VwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDRcIiwgXCJcXFxcYmlnY3VwcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTAzXCIsIFwiXFxcXGJpZ2N1cGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA3XCIsIFwiXFxcXGJpZ2RvdWJsZXZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA4XCIsIFwiXFxcXGJpZ2RvdWJsZXdlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyYzJcIiwgXCJcXFxcYmlnY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyYzNcIiwgXCJcXFxcYmlnY3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcaW50b3BcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyY1wiLCBcIlxcXFxpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmRcIiwgXCJcXFxcaWlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIwZlwiLCBcIlxcXFxwcm9kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMTFcIiwgXCJcXFxcc3VtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDJcIiwgXCJcXFxcYmlnb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDFcIiwgXCJcXFxcYmlnb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwMFwiLCBcIlxcXFxiaWdvZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDlcIiwgXCJcXFxcYmlndGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyZVwiLCBcIlxcXFxvaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmZcIiwgXCJcXFxcb2lpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIzMFwiLCBcIlxcXFxvaWlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIzMVwiLCBcIlxcXFxpbnRjbG9ja3dpc2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIzMlwiLCBcIlxcXFx2YXJvaW50Y2xvY2t3aXNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMGNcIiwgXCJcXFxcaWlpaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMGRcIiwgXCJcXFxcaW50YmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMGVcIiwgXCJcXFxcaW50QmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMGZcIiwgXCJcXFxcZmludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTEyXCIsIFwiXFxcXHJwcG9saW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMTNcIiwgXCJcXFxcc2Nwb2xpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExNVwiLCBcIlxcXFxwb2ludGludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTE2XCIsIFwiXFxcXHNxaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMTdcIiwgXCJcXFxcaW50bGFyaGtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExOFwiLCBcIlxcXFxpbnR4XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMTlcIiwgXCJcXFxcaW50Y2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMWFcIiwgXCJcXFxcaW50Y3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDVcIiwgXCJcXFxcYmlnc3FjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwNlwiLCBcIlxcXFxiaWdzcWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJiXCIsIFwiXFxcXHNtYWxsaW50XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcdGV4dGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbWF0aGVsbGlwc2lzXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxsZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBpbm5lciwgXCJcXHUyMmYwXCIsIFwiXFxcXGlkZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBpbm5lciwgXCJcXHUyMmVmXCIsIFwiXFxcXEBjZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBpbm5lciwgXCJcXHUyMmYxXCIsIFwiXFxcXGRkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2YXJ2ZG90c1wiKTsgLy8gXFx2ZG90cyBpcyBhIG1hY3JvXG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMmVlXCIsIFwiXFxcXHZhcnZkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmNhXCIsIFwiXFxcXGFjdXRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMDYwXCIsIFwiXFxcXGdyYXZlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMGE4XCIsIFwiXFxcXGRkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTIwMjZcIiwgXCJcXFxcZGRkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTIwMjZcXHUwMDJlXCIsIFwiXFxcXGRkZGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDA3ZVwiLCBcIlxcXFx0aWxkZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MjAzZVwiLCBcIlxcXFxiYXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZDhcIiwgXCJcXFxcYnJldmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyYzdcIiwgXCJcXFxcY2hlY2tcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwNWVcIiwgXCJcXFxcaGF0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUyMTkyXCIsIFwiXFxcXHZlY1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkOVwiLCBcIlxcXFxkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZGFcIiwgXCJcXFxcbWF0aHJpbmdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMTMxXCIsIFwiXFxcXGltYXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDIzN1wiLCBcIlxcXFxqbWF0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAxMzFcIiwgXCJcXHUwMTMxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDIzN1wiLCBcIlxcdTAyMzdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMTMxXCIsIFwiXFxcXGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMjM3XCIsIFwiXFxcXGpcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGRmXCIsIFwiXFxcXHNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBlNlwiLCBcIlxcXFxhZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAxNTNcIiwgXCJcXFxcb2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGY4XCIsIFwiXFxcXG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMGY4XCIsIFwiXFxcXG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGM2XCIsIFwiXFxcXEFFXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDE1MlwiLCBcIlxcXFxPRVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwZDhcIiwgXCJcXFxcT1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAwZDhcIiwgXCJcXFxcT1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJjYVwiLCBcIlxcXFwnXCIpOyAvLyBhY3V0ZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmNiXCIsIFwiXFxcXGBcIik7IC8vIGdyYXZlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyYzZcIiwgXCJcXFxcXlwiKTsgLy8gY2lyY3VtZmxleFxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmRjXCIsIFwiXFxcXH5cIik7IC8vIHRpbGRlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyYzlcIiwgXCJcXFxcPVwiKTsgLy8gbWFjcm9uXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyZDhcIiwgXCJcXFxcdVwiKTsgLy8gYnJldmVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJkOVwiLCBcIlxcXFwuXCIpOyAvLyBkb3QgYWJvdmVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDBiOFwiLCBcIlxcXFxjXCIpOyAvLyBjZWRpbGxhXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyZGFcIiwgXCJcXFxcclwiKTsgLy8gcmluZyBhYm92ZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXHZcIik7IC8vIGNhcm9uXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAwYThcIiwgJ1xcXFxcIicpOyAvLyBkaWFlcmVzaXNcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJkZFwiLCBcIlxcXFxIXCIpOyAvLyBkb3VibGUgYWN1dGVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjYVwiLCBcIlxcXFwnXCIpOyAvLyBhY3V0ZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmNiXCIsIFwiXFxcXGBcIik7IC8vIGdyYXZlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyYzZcIiwgXCJcXFxcXlwiKTsgLy8gY2lyY3VtZmxleFxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmRjXCIsIFwiXFxcXH5cIik7IC8vIHRpbGRlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyYzlcIiwgXCJcXFxcPVwiKTsgLy8gbWFjcm9uXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZDhcIiwgXCJcXFxcdVwiKTsgLy8gYnJldmVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkOVwiLCBcIlxcXFwuXCIpOyAvLyBkb3QgYWJvdmVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDBiOFwiLCBcIlxcXFxjXCIpOyAvLyBjZWRpbGxhXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZGFcIiwgXCJcXFxcclwiKTsgLy8gcmluZyBhYm92ZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmM3XCIsIFwiXFxcXHZcIik7IC8vIGNhcm9uXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwYThcIiwgJ1xcXFxcIicpOyAvLyBkaWFlcmVzaXNcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkZFwiLCBcIlxcXFxIXCIpOyAvLyBkb3VibGUgYWN1dGVcblxuLy8gVGhlc2UgbGlnYXR1cmVzIGFyZSBkZXRlY3RlZCBhbmQgY3JlYXRlZCBpbiBQYXJzZXIuanMncyBgZm9ybUxpZ2F0dXJlc2AuXG5jb25zdCBsaWdhdHVyZXMgPSB7XG4gIFwiLS1cIjogdHJ1ZSxcbiAgXCItLS1cIjogdHJ1ZSxcbiAgXCJgYFwiOiB0cnVlLFxuICBcIicnXCI6IHRydWVcbn07XG5cbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCItLVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTNcIiwgXCJcXFxcdGV4dGVuZGFzaFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTRcIiwgXCItLS1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiXFxcXHRleHRlbWRhc2hcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE4XCIsIFwiYFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJcXFxcdGV4dHF1b3RlbGVmdFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTlcIiwgXCInXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxOVwiLCBcIlxcXFx0ZXh0cXVvdGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJgYFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJcXFxcdGV4dHF1b3RlZGJsbGVmdFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCInJ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCJcXFxcdGV4dHF1b3RlZGJscmlnaHRcIik7XG4vLyAgXFxkZWdyZWUgZnJvbSBnZW5zeW1iIHBhY2thZ2VcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIik7XG4vLyBcXHRleHRkZWdyZWUgZnJvbSBpbnB1dGVuYyBwYWNrYWdlXG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXHRleHRkZWdyZWVcIiwgdHJ1ZSk7XG4vLyBUT0RPOiBJbiBMYVRlWCwgXFxwb3VuZHMgY2FuIGdlbmVyYXRlIGEgZGlmZmVyZW50IGNoYXJhY3RlciBpbiB0ZXh0IGFuZCBtYXRoXG4vLyBtb2RlLCBidXQgYW1vbmcgb3VyIGZvbnRzLCBvbmx5IE1haW4tUmVndWxhciBkZWZpbmVzIHRoaXMgY2hhcmFjdGVyIFwiMTYzXCIuXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHBvdW5kc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxcbWF0aHN0ZXJsaW5nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxwb3VuZHNcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHRleHRzdGVybGluZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI3MjBcIiwgXCJcXFxcbWFsdGVzZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTI3MjBcIiwgXCJcXFxcbWFsdGVzZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwYWNcIiwgXCJcXFxcZXVyb1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwYWNcIiwgXCJcXFxcZXVyb1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwYWNcIiwgXCJcXFxcdGV4dGV1cm9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMGE5XCIsIFwiXFxcXGNvcHlyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYTlcIiwgXCJcXFxcdGV4dGNvcHlyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIzMDBcIiwgXCJcXFxcZGlhbWV0ZXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMzAwXCIsIFwiXFxcXGRpYW1ldGVyXCIpO1xuXG4vLyBJdGFsaWMgR3JlZWtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm6RcIiwgXCJcXFxcdmFyR2FtbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZulXCIsIFwiXFxcXHZhckRlbHRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2bqVwiLCBcIlxcXFx2YXJUaGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm6xcIiwgXCJcXFxcdmFyTGFtYmRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2br1wiLCBcIlxcXFx2YXJYaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7FcIiwgXCJcXFxcdmFyUGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZu0XCIsIFwiXFxcXHZhclNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2btlwiLCBcIlxcXFx2YXJVcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2bt1wiLCBcIlxcXFx2YXJQaGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZu5XCIsIFwiXFxcXHZhclBzaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7pcIiwgXCJcXFxcdmFyT21lZ2FcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZukXCIsIFwiXFxcXHZhckdhbW1hXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bpVwiLCBcIlxcXFx2YXJEZWx0YVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm6lcIiwgXCJcXFxcdmFyVGhldGFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZusXCIsIFwiXFxcXHZhckxhbWJkYVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm69cIiwgXCJcXFxcdmFyWGlcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZuxXCIsIFwiXFxcXHZhclBpXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2btFwiLCBcIlxcXFx2YXJTaWdtYVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7ZcIiwgXCJcXFxcdmFyVXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7dcIiwgXCJcXFxcdmFyUGhpXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2buVwiLCBcIlxcXFx2YXJQc2lcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZu6XCIsIFwiXFxcXHZhck9tZWdhXCIpO1xuXG5cbi8vIFRoZXJlIGFyZSBsb3RzIG9mIHN5bWJvbHMgd2hpY2ggYXJlIHRoZSBzYW1lLCBzbyB3ZSBhZGQgdGhlbSBpbiBhZnRlcndhcmRzLlxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiBtYXRoIG1vZGVcbmNvbnN0IG1hdGhUZXh0U3ltYm9scyA9ICcwMTIzNDU2Nzg5L0AuXCInO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRoVGV4dFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSBtYXRoVGV4dFN5bWJvbHMuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGVcbmNvbnN0IHRleHRTeW1ib2xzID0gJzAxMjM0NTY3ODkhQCooKS09K1wiOzo/Ly4sJztcbmZvciAobGV0IGkgPSAwOyBpIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSB0ZXh0U3ltYm9scy5jaGFyQXQoaSk7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG4vLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIHRleHQgbW9kZSwgYW5kIG1hdGhvcmRzIGluIG1hdGggbW9kZVxuY29uc3QgbGV0dGVycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBsZXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gbGV0dGVycy5jaGFyQXQoaSk7XG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBjaCwgY2gpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gU29tZSBtb3JlIGxldHRlcnMgaW4gVW5pY29kZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUuXG5jb25zdCBuYXJyb3cgPSBcIsOHw5DDnsOnw77ihILihI3ihJXihJnihJrihJ3ihKTihI7ihI/ihIrihIvihIzihJDihJHihJLihJPihJjihJvihJzihKzihLDihLHihLPihK3ihKhcIjtcbmZvciAobGV0IGkgPSAwOyBpIDwgbmFycm93Lmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGNoID0gbmFycm93LmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIGNoLCBjaCk7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG4vLyBUaGUgbmV4dCBsb29wIGxvYWRzIHdpZGUgKHN1cnJvZ2F0ZSBwYWlyKSBjaGFyYWN0ZXJzLlxuLy8gV2Ugc3VwcG9ydCBzb21lIGxldHRlcnMgaW4gdGhlIFVuaWNvZGUgcmFuZ2UgVSsxRDQwMCB0byBVKzFEN0ZGLFxuLy8gTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzLlxubGV0IHdpZGVDaGFyID0gXCJcIjtcbmZvciAobGV0IGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICAvLyBUaGUgaGV4IG51bWJlcnMgaW4gdGhlIG5leHQgbGluZSBhcmUgYSBzdXJyb2dhdGUgcGFpci5cbiAgLy8gMHhEODM1IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBmb3IgYWxsIGxldHRlcnMgaW4gdGhlIHJhbmdlIHdlIHN1cHBvcnQuXG4gIC8vIDB4REMwMCBpcyB0aGUgbG93IHN1cnJvZ2F0ZSBmb3IgYm9sZCBBLlxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRjMDAgKyBpKTsgLy8gQS1aIGEteiBib2xkXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRjMzQgKyBpKTsgLy8gQS1aIGEteiBpdGFsaWNcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGM2OCArIGkpOyAvLyBBLVogYS16IGJvbGQgaXRhbGljXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRkMDQgKyBpKTsgLy8gQS1aIGEteiBGcmFjdHVyXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRkYTAgKyBpKTsgLy8gQS1aIGEteiBzYW5zLXNlcmlmXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRkZDQgKyBpKTsgLy8gQS1aIGEteiBzYW5zIGJvbGRcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGUwOCArIGkpOyAvLyBBLVogYS16IHNhbnMgaXRhbGljXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRlNzAgKyBpKTsgLy8gQS1aIGEteiBtb25vc3BhY2VcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGQzOCArIGkpOyAvLyBBLVogYS16IGRvdWJsZSBzdHJ1Y2tcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIGNvbnN0IGNoID0gbGV0dGVycy5jaGFyQXQoaSk7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGM5YyArIGkpOyAvLyBBLVogYS16IGNhbGxpZ3JhcGhpY1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgY2gsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIGNoLCB3aWRlQ2hhcik7XG59XG5cbi8vIE5leHQsIHNvbWUgd2lkZSBjaGFyYWN0ZXIgbnVtZXJhbHNcbmZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRmY2UgKyBpKTsgLy8gMC05IGJvbGRcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGZlMiArIGkpOyAvLyAwLTkgc2FucyBzZXJpZlxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZmVjICsgaSk7IC8vIDAtOSBib2xkIHNhbnNcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGZmNiArIGkpOyAvLyAwLTkgbW9ub3NwYWNlXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbn1cblxuLypcbiAqIE5laXRoZXIgRmlyZWZveCBub3IgQ2hyb21lIHN1cHBvcnQgaGFyZCBsaW5lIGJyZWFrcyBvciBzb2Z0IGxpbmUgYnJlYWtzLlxuICogKERlc3BpdGUgaHR0cHM6Ly93d3cudzMub3JnL01hdGgvZHJhZnQtc3BlYy9tYXRobWwuaHRtbCNjaGFwdGVyM19wcmVzbS5sYmF0dHJzKVxuICogU28gVGVtbWwgaGFzIHdvcmstYXJvdW5kcyBmb3IgYm90aCBoYXJkIGFuZCBzb2Z0IGJyZWFrcy5cbiAqIFRoZSB3b3JrLWFyb3VuZHMgc2FkbHkgZG8gbm90IHdvcmsgc2ltdWx0YW5lb3VzbHkuIEFueSB0b3AtbGV2ZWwgaGFyZFxuICogYnJlYWsgbWFrZXMgc29mdCBsaW5lIGJyZWFrcyBpbXBvc3NpYmxlLlxuICpcbiAqIEhhcmQgYnJlYWtzIGFyZSBzaW11bGF0ZWQgYnkgY3JlYXRpbmcgYSA8bXRhYmxlPiBhbmQgcHV0dGluZyBlYWNoIGxpbmUgaW4gaXRzIG93biA8bXRyPi5cbiAqXG4gKiBUbyBjcmVhdGUgc29mdCBsaW5lIGJyZWFrcywgVGVtbWwgYXZvaWRzIHVzaW5nIHRoZSA8c2VtYW50aWNzPiBhbmQgPGFubm90YXRpb24+IHRhZ3MuXG4gKiBUaGVuIHRoZSB0b3AgbGV2ZWwgb2YgYSA8bWF0aD4gZWxlbWVudCBjYW4gYmUgb2NjdXBpZWQgYnkgPG1yb3c+IGVsZW1lbnRzLCBhbmQgdGhlIGJyb3dzZXJcbiAqIHdpbGwgYnJlYWsgYWZ0ZXIgYSA8bXJvdz4gaWYgdGhlIGV4cHJlc3Npb24gZXh0ZW5kcyBiZXlvbmQgdGhlIGNvbnRhaW5lciBsaW1pdC5cbiAqXG4gKiBUaGUgZGVmYXVsdCBpcyBmb3Igc29mdCBsaW5lIGJyZWFrcyBhZnRlciBlYWNoIHRvcC1sZXZlbCBiaW5hcnkgb3JcbiAqIHJlbGF0aW9uYWwgb3BlcmF0b3IsIHBlciBUZVhib29rIHAuIDE3My4gU28gd2UgZ2F0aGVyIHRoZSBleHByZXNzaW9uIGludG8gPG1yb3c+cyBzbyB0aGF0XG4gKiBlYWNoIDxtcm93PiBlbmRzIGluIGEgYmluYXJ5IG9yIHJlbGF0aW9uYWwgb3BlcmF0b3IuXG4gKlxuICogQW4gb3B0aW9uIGlzIGZvciBzb2Z0IGxpbmUgYnJlYWtzIGJlZm9yZSBhbiBcIj1cIiBzaWduLiBUaGF0IGNoYW5nZXMgdGhlIDxtcm93PnMuXG4gKlxuICogU29mdCBsaW5lIGJyZWFrcyB3aWxsIG5vdCB3b3JrIGluIENocm9taXVtIGFuZCBTYWZhcmksIG9ubHkgRmlyZWZveC5cbiAqXG4gKiBIb3BlZnVsbHkgYnJvd3NlcnMgd2lsbCBzb21lZGF5IGRvIHRoZWlyIG93biBsaW5lYnJlYWtpbmcgYW5kIHdlIHdpbGwgYmUgYWJsZSB0byBkZWxldGVcbiAqIG11Y2ggb2YgdGhpcyBtb2R1bGUuXG4gKi9cblxuY29uc3Qgb3BlbkRlbGltcyA9IFwiKFt74oyK4oyI4p+o4p+u4o6w4p+m4qaDXCI7XG5jb25zdCBjbG9zZURlbGltcyA9IFwiKV194oyL4oyJ4p+p4p+v4o6x4p+m4qaEXCI7XG5cbmZ1bmN0aW9uIHNldExpbmVCcmVha3MoZXhwcmVzc2lvbiwgd3JhcE1vZGUsIGlzRGlzcGxheU1vZGUpIHtcbiAgY29uc3QgbXRycyA9IFtdO1xuICBsZXQgbXJvd3MgPSBbXTtcbiAgbGV0IGJsb2NrID0gW107XG4gIGxldCBudW1Ub3BMZXZlbEVxdWFscyA9IDA7XG4gIGxldCBpID0gMDtcbiAgbGV0IGxldmVsID0gMDtcbiAgd2hpbGUgKGkgPCBleHByZXNzaW9uLmxlbmd0aCkge1xuICAgIHdoaWxlIChleHByZXNzaW9uW2ldIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgZXhwcmVzc2lvbi5zcGxpY2UoaSwgMSwgLi4uZXhwcmVzc2lvbltpXS5jaGlsZHJlbik7IC8vIEV4cGFuZCB0aGUgZnJhZ21lbnQuXG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBleHByZXNzaW9uW2ldO1xuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmxpbmVicmVhayAmJlxuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxpbmVicmVhayA9PT0gXCJuZXdsaW5lXCIpIHtcbiAgICAgIC8vIEEgaGFyZCBsaW5lIGJyZWFrLiBDcmVhdGUgYSA8bXRyPiBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICBpZiAoYmxvY2subGVuZ3RoID4gMCkge1xuICAgICAgICBtcm93cy5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBibG9jaykpO1xuICAgICAgfVxuICAgICAgbXJvd3MucHVzaChub2RlKTtcbiAgICAgIGJsb2NrID0gW107XG4gICAgICBjb25zdCBtdGQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBtcm93cyk7XG4gICAgICBtdGQuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICBtdHJzLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgW210ZF0pKTtcbiAgICAgIG1yb3dzID0gW107XG4gICAgICBpICs9IDE7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBibG9jay5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgJiYgbm9kZS50eXBlID09PSBcIm1vXCIgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlLmF0dHJpYnV0ZXMsIFwibW92YWJsZWxpbWl0c1wiKSkge1xuICAgICAgY29uc3QgY2ggPSBub2RlLmNoaWxkcmVuWzBdLnRleHQ7XG4gICAgICBpZiAob3BlbkRlbGltcy5pbmRleE9mKGNoKSA+IC0xKSB7XG4gICAgICAgIGxldmVsICs9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNsb3NlRGVsaW1zLmluZGV4T2YoY2gpID4gLTEpIHtcbiAgICAgICAgbGV2ZWwgLT0gMTtcbiAgICAgIH0gZWxzZSBpZiAobGV2ZWwgPT09IDAgJiYgd3JhcE1vZGUgPT09IFwiPVwiICYmIGNoID09PSBcIj1cIikge1xuICAgICAgICBudW1Ub3BMZXZlbEVxdWFscyArPSAxO1xuICAgICAgICBpZiAobnVtVG9wTGV2ZWxFcXVhbHMgPiAxKSB7XG4gICAgICAgICAgYmxvY2sucG9wKCk7XG4gICAgICAgICAgLy8gU3RhcnQgYSBuZXcgYmxvY2suIChJbnNlcnQgYSBzb2Z0IGxpbmVicmVhay4pXG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBibG9jayk7XG4gICAgICAgICAgbXJvd3MucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBibG9jayA9IFtub2RlXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsZXZlbCA9PT0gMCAmJiB3cmFwTW9kZSA9PT0gXCJ0ZXhcIiAmJiBjaCAhPT0gXCLiiIdcIikge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZm9sbG93aW5nIG5vZGUgaXMgYSBcXG5vYnJlYWsgdGV4dCBub2RlLCBlLmcuIFwiflwiXCJcbiAgICAgICAgY29uc3QgbmV4dCA9IGkgPCBleHByZXNzaW9uLmxlbmd0aCAtIDEgPyBleHByZXNzaW9uW2kgKyAxXSA6IG51bGw7XG4gICAgICAgIGxldCBnbHVlSXNGcmVlT2ZOb2JyZWFrID0gdHJ1ZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICEoXG4gICAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgICBuZXh0LnR5cGUgPT09IFwibXRleHRcIiAmJlxuICAgICAgICAgICAgbmV4dC5hdHRyaWJ1dGVzLmxpbmVicmVhayAmJlxuICAgICAgICAgICAgbmV4dC5hdHRyaWJ1dGVzLmxpbmVicmVhayA9PT0gXCJub2JyZWFrXCJcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFdlIG1heSBuZWVkIHRvIHN0YXJ0IGEgbmV3IGJsb2NrLlxuICAgICAgICAgIC8vIEZpcnN0LCBwdXQgYW55IHBvc3Qtb3BlcmF0b3IgZ2x1ZSBvbiBzYW1lIGxpbmUgYXMgb3BlcmF0b3IuXG4gICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgbmQgPSBleHByZXNzaW9uW2pdO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBuZC50eXBlICYmXG4gICAgICAgICAgICAgIG5kLnR5cGUgPT09IFwibXNwYWNlXCIgJiZcbiAgICAgICAgICAgICAgIShuZC5hdHRyaWJ1dGVzLmxpbmVicmVhayAmJiBuZC5hdHRyaWJ1dGVzLmxpbmVicmVhayA9PT0gXCJuZXdsaW5lXCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgYmxvY2sucHVzaChuZCk7XG4gICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG5kLmF0dHJpYnV0ZXMgJiZcbiAgICAgICAgICAgICAgICBuZC5hdHRyaWJ1dGVzLmxpbmVicmVhayAmJlxuICAgICAgICAgICAgICAgIG5kLmF0dHJpYnV0ZXMubGluZWJyZWFrID09PSBcIm5vYnJlYWtcIlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBnbHVlSXNGcmVlT2ZOb2JyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2x1ZUlzRnJlZU9mTm9icmVhaykge1xuICAgICAgICAgIC8vIFN0YXJ0IGEgbmV3IGJsb2NrLiAoSW5zZXJ0IGEgc29mdCBsaW5lYnJlYWsuKVxuICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYmxvY2spO1xuICAgICAgICAgIG1yb3dzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgYmxvY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpICs9IDE7XG4gIH1cbiAgaWYgKGJsb2NrLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBlbGVtZW50ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJsb2NrKTtcbiAgICBtcm93cy5wdXNoKGVsZW1lbnQpO1xuICB9XG4gIGlmIChtdHJzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBtdGQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBtcm93cyk7XG4gICAgbXRkLnN0eWxlLnRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgIGNvbnN0IG10ciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFttdGRdKTtcbiAgICBtdHJzLnB1c2gobXRyKTtcbiAgICBjb25zdCBtdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCBtdHJzKTtcbiAgICBpZiAoIWlzRGlzcGxheU1vZGUpIHtcbiAgICAgIG10YWJsZS5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5hbGlnblwiLCBcImxlZnRcIik7XG4gICAgICBtdGFibGUuc2V0QXR0cmlidXRlKFwicm93c3BhY2luZ1wiLCBcIjBlbVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG10YWJsZVxuICB9XG4gIHJldHVybiBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQobXJvd3MpO1xufVxuXG4vKipcbiAqIFRoaXMgZmlsZSBjb252ZXJ0cyBhIHBhcnNlIHRyZWUgaW50byBhIGNvcnJlc3BvbmRpbmcgTWF0aE1MIHRyZWUuIFRoZSBtYWluXG4gKiBlbnRyeSBwb2ludCBpcyB0aGUgYGJ1aWxkTWF0aE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlIGZyb20gdGhlXG4gKiBwYXJzZXIuXG4gKi9cblxuXG4vKipcbiAqIFRha2VzIGEgc3ltYm9sIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgTWF0aE1MIHRleHQgbm9kZSBhZnRlciBwZXJmb3JtaW5nXG4gKiBvcHRpb25hbCByZXBsYWNlbWVudCBmcm9tIHN5bWJvbHMuanMuXG4gKi9cbmNvbnN0IG1ha2VUZXh0ID0gZnVuY3Rpb24odGV4dCwgbW9kZSwgc3R5bGUpIHtcbiAgaWYgKFxuICAgIHN5bWJvbHNbbW9kZV1bdGV4dF0gJiZcbiAgICBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UgJiZcbiAgICB0ZXh0LmNoYXJDb2RlQXQoMCkgIT09IDB4ZDgzNSAmJlxuICAgICEoXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGlnYXR1cmVzLCB0ZXh0KSAmJlxuICAgICAgc3R5bGUgJiZcbiAgICAgICgoc3R5bGUuZm9udEZhbWlseSAmJiBzdHlsZS5mb250RmFtaWx5LnNsaWNlKDQsIDYpID09PSBcInR0XCIpIHx8XG4gICAgICAgIChzdHlsZS5mb250ICYmIHN0eWxlLmZvbnQuc2xpY2UoNCwgNikgPT09IFwidHRcIikpXG4gICAgKVxuICApIHtcbiAgICB0ZXh0ID0gc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleHQpO1xufTtcblxuY29uc3QgY29weUNoYXIgPSAobmV3Um93LCBjaGlsZCkgPT4ge1xuICBpZiAobmV3Um93LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgbmV3Um93LmNoaWxkcmVuW25ld1Jvdy5jaGlsZHJlbi5sZW5ndGggLSAxXS50eXBlICE9PSBcIm10ZXh0XCIpIHtcbiAgICBjb25zdCBtdGV4dCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgXCJtdGV4dFwiLFxuICAgICAgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKGNoaWxkLmNoaWxkcmVuWzBdLnRleHQpXVxuICAgICk7XG4gICAgbmV3Um93LmNoaWxkcmVuLnB1c2gobXRleHQpO1xuICB9IGVsc2Uge1xuICAgIG5ld1Jvdy5jaGlsZHJlbltuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uY2hpbGRyZW5bMF0udGV4dCArPSBjaGlsZC5jaGlsZHJlblswXS50ZXh0O1xuICB9XG59O1xuXG5jb25zdCBjb25zb2xpZGF0ZVRleHQgPSBtcm93ID0+IHtcbiAgLy8gSWYgcG9zc2libGUsIGNvbnNvbGlkYXRlIGFkamFjZW50IDxtdGV4dD4gZWxlbWVudHMgaW50byBhIHNpbmdsZSBlbGVtZW50LlxuICBpZiAobXJvdy50eXBlICE9PSBcIm1yb3dcIiAmJiBtcm93LnR5cGUgIT09IFwibXN0eWxlXCIpIHsgcmV0dXJuIG1yb3cgfVxuICBpZiAobXJvdy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHsgcmV0dXJuIG1yb3cgfSAvLyBlbXB0eSBncm91cCwgZS5nLiwgXFx0ZXh0e31cbiAgY29uc3QgbmV3Um93ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1yb3cuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IG1yb3cuY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLnR5cGUgPT09IFwibXRleHRcIiAmJiBPYmplY3Qua2V5cyhjaGlsZC5hdHRyaWJ1dGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvcHlDaGFyKG5ld1JvdywgY2hpbGQpO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudHlwZSA9PT0gXCJtcm93XCIpIHtcbiAgICAgIC8vIFdlJ2xsIGFsc28gY2hlY2sgdGhlIGNoaWxkcmVuIG9mIGFuIG1yb3cuIE9uZSBsZXZlbCBvbmx5LiBObyByZWN1cnNpb24uXG4gICAgICBsZXQgY2FuQ29uc29saWRhdGUgPSB0cnVlO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBncmFuZENoaWxkID0gY2hpbGQuY2hpbGRyZW5bal07XG4gICAgICAgIGlmIChncmFuZENoaWxkLnR5cGUgIT09IFwibXRleHRcIiB8fCBPYmplY3Qua2V5cyhjaGlsZC5hdHRyaWJ1dGVzKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjYW5Db25zb2xpZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYW5Db25zb2xpZGF0ZSkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgZ3JhbmRDaGlsZCA9IGNoaWxkLmNoaWxkcmVuW2pdO1xuICAgICAgICAgIGNvcHlDaGFyKG5ld1JvdywgZ3JhbmRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1Jvdy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Um93LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1Jvdy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChuZXdSb3cuY2hpbGRyZW5baV0udHlwZSA9PT0gXCJtdGV4dFwiKSB7XG4gICAgICBjb25zdCBtdGV4dCA9IG5ld1Jvdy5jaGlsZHJlbltpXTtcbiAgICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgcmVuZGVyIGEgc3BhY2UgYXQgZWl0aGVyIGVuZCBvZiBhbiA8bXRleHQ+IHN0cmluZy5cbiAgICAgIC8vIFRvIGdldCBwcm9wZXIgcmVuZGVyaW5nLCB3ZSByZXBsYWNlIGxlYWRpbmcgb3IgdHJhaWxpbmcgc3BhY2VzIHdpdGggbm8tYnJlYWsgc3BhY2VzLlxuICAgICAgaWYgKG10ZXh0LmNoaWxkcmVuWzBdLnRleHQuY2hhckF0KDApID09PSBcIiBcIikge1xuICAgICAgICBtdGV4dC5jaGlsZHJlblswXS50ZXh0ID0gXCJcXHUwMGEwXCIgKyBtdGV4dC5jaGlsZHJlblswXS50ZXh0LnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgY29uc3QgTCA9IG10ZXh0LmNoaWxkcmVuWzBdLnRleHQubGVuZ3RoO1xuICAgICAgaWYgKEwgPiAwICYmIG10ZXh0LmNoaWxkcmVuWzBdLnRleHQuY2hhckF0KEwgLSAxKSA9PT0gXCIgXCIpIHtcbiAgICAgICAgbXRleHQuY2hpbGRyZW5bMF0udGV4dCA9IG10ZXh0LmNoaWxkcmVuWzBdLnRleHQuc2xpY2UoMCwgLTEpICsgXCJcXHUwMGEwXCI7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtcm93LmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIG10ZXh0LmF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3Um93LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBuZXdSb3cuY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJtdGV4dFwiKSB7XG4gICAgcmV0dXJuIG5ld1Jvdy5jaGlsZHJlblswXTsgLy8gQSBjb25zb2xpZGF0ZWQgPG10ZXh0PlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXdSb3dcbiAgfVxufTtcblxuLyoqXG4gKiBXcmFwIHRoZSBnaXZlbiBhcnJheSBvZiBub2RlcyBpbiBhbiA8bXJvdz4gbm9kZSBpZiBuZWVkZWQsIGkuZS4sXG4gKiB1bmxlc3MgdGhlIGFycmF5IGhhcyBsZW5ndGggMS4gIEFsd2F5cyByZXR1cm5zIGEgc2luZ2xlIG5vZGUuXG4gKi9cbmNvbnN0IG1ha2VSb3cgPSBmdW5jdGlvbihib2R5LCBzZW1pc2ltcGxlID0gZmFsc2UpIHtcbiAgaWYgKGJvZHkubGVuZ3RoID09PSAxICYmICEoYm9keVswXSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpKSB7XG4gICAgcmV0dXJuIGJvZHlbMF07XG4gIH0gZWxzZSBpZiAoIXNlbWlzaW1wbGUpIHtcbiAgICAvLyBTdXBwcmVzcyBzcGFjaW5nIG9uIDxtbz4gbm9kZXMgYXQgYm90aCBlbmRzIG9mIHRoZSByb3cuXG4gICAgaWYgKGJvZHlbMF0gaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBib2R5WzBdLnR5cGUgPT09IFwibW9cIiAmJiAhYm9keVswXS5hdHRyaWJ1dGVzLmZlbmNlKSB7XG4gICAgICBib2R5WzBdLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgIGJvZHlbMF0uYXR0cmlidXRlcy5yc3BhY2UgPSBcIjBlbVwiO1xuICAgIH1cbiAgICBjb25zdCBlbmQgPSBib2R5Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGJvZHlbZW5kXSBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGJvZHlbZW5kXS50eXBlID09PSBcIm1vXCIgJiYgIWJvZHlbZW5kXS5hdHRyaWJ1dGVzLmZlbmNlKSB7XG4gICAgICBib2R5W2VuZF0uYXR0cmlidXRlcy5sc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgYm9keVtlbmRdLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwZW1cIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBib2R5KTtcbn07XG5cbi8qKlxuICogQ2hlY2sgZm9yIDxtaT4uPC9taT4gd2hpY2ggaXMgaG93IGEgZG90IHJlbmRlcnMgaW4gTWF0aE1MLFxuICogb3IgPG1vIHNlcGFyYXRvcj1cInRydWVcIiBsc3BhY2U9XCIwZW1cIiByc3BhY2U9XCIwZW1cIj4sPC9tbz5cbiAqIHdoaWNoIGlzIGhvdyBhIGJyYWNlZCBjb21tYSB7LH0gcmVuZGVycyBpbiBNYXRoTUxcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJQdW5jdHVhdGlvbihncm91cCkge1xuICBpZiAoIWdyb3VwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGdyb3VwLnR5cGUgPT09ICdtaScgJiYgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgY2hpbGQgPSBncm91cC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBjaGlsZC50ZXh0ID09PSAnLidcbiAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIm10ZXh0XCIgJiYgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgY2hpbGQgPSBncm91cC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gY2hpbGQgaW5zdGFuY2VvZiBUZXh0Tm9kZSAmJiBjaGlsZC50ZXh0ID09PSAnXFx1MjAwOCcgLy8gcHVuY3R1YXRpb24gc3BhY2VcbiAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSAnbW8nICYmIGdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgIGdyb3VwLmdldEF0dHJpYnV0ZSgnc2VwYXJhdG9yJykgPT09ICd0cnVlJyAmJlxuICAgIGdyb3VwLmdldEF0dHJpYnV0ZSgnbHNwYWNlJykgPT09ICcwZW0nICYmXG4gICAgZ3JvdXAuZ2V0QXR0cmlidXRlKCdyc3BhY2UnKSA9PT0gJzBlbScpIHtcbiAgICBjb25zdCBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlICYmIGNoaWxkLnRleHQgPT09ICcsJ1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5jb25zdCBpc0NvbW1hID0gKGV4cHJlc3Npb24sIGkpID0+IHtcbiAgY29uc3Qgbm9kZSA9IGV4cHJlc3Npb25baV07XG4gIGNvbnN0IGZvbGxvd2luZ05vZGUgPSBleHByZXNzaW9uW2kgKyAxXTtcbiAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIG5vZGUudGV4dCA9PT0gXCIsXCIpICYmXG4gICAgLy8gRG9uJ3QgY29uc29saWRhdGUgaWYgdGhlcmUgaXMgYSBzcGFjZSBhZnRlciB0aGUgY29tbWEuXG4gICAgbm9kZS5sb2MgJiYgZm9sbG93aW5nTm9kZS5sb2MgJiYgbm9kZS5sb2MuZW5kID09PSBmb2xsb3dpbmdOb2RlLmxvYy5zdGFydFxufTtcblxuY29uc3QgaXNSZWwgPSBpdGVtID0+IHtcbiAgcmV0dXJuIChpdGVtLnR5cGUgPT09IFwiYXRvbVwiICYmIGl0ZW0uZmFtaWx5ID09PSBcInJlbFwiKSB8fFxuICAgICAgKGl0ZW0udHlwZSA9PT0gXCJtY2xhc3NcIiAmJiBpdGVtLm1jbGFzcyA9PT0gXCJtcmVsXCIpXG59O1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBub2RlcywgYnVpbGRzIHRoZW0sIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0aGUgZ2VuZXJhdGVkXG4gKiBNYXRoTUwgbm9kZXMuICBBbHNvIGRvIGEgY291cGxlIGNob3JlcyBhbG9uZyB0aGUgd2F5OlxuICogKDEpIFN1cHByZXNzIHNwYWNpbmcgd2hlbiBhbiBhdXRob3Igd3JhcHMgYW4gb3BlcmF0b3Igdy9icmFjZXMsIGFzIGluIHs9fS5cbiAqICgyKSBTdXBwcmVzcyBzcGFjaW5nIGJldHdlZW4gdHdvIGFkamFjZW50IHJlbGF0aW9ucy5cbiAqL1xuY29uc3QgYnVpbGRFeHByZXNzaW9uID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgc3R5bGUsIHNlbWlzaW1wbGUgPSBmYWxzZSkge1xuICBpZiAoIXNlbWlzaW1wbGUgJiYgZXhwcmVzc2lvbi5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBncm91cCA9IGJ1aWxkR3JvdXAkMShleHByZXNzaW9uWzBdLCBzdHlsZSk7XG4gICAgaWYgKGdyb3VwIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgZ3JvdXAudHlwZSA9PT0gXCJtb1wiKSB7XG4gICAgICAvLyBXaGVuIFRlWCB3cml0ZXJzIHdhbnQgdG8gc3VwcHJlc3Mgc3BhY2luZyBvbiBhbiBvcGVyYXRvcixcbiAgICAgIC8vIHRoZXkgb2Z0ZW4gcHV0IHRoZSBvcGVyYXRvciBieSBpdHNlbGYgaW5zaWRlIGJyYWNlcy5cbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjBlbVwiKTtcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjBlbVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtncm91cF07XG4gIH1cblxuICBjb25zdCBncm91cHMgPSBbXTtcbiAgY29uc3QgZ3JvdXBBcnJheSA9IFtdO1xuICBsZXQgbGFzdEdyb3VwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICBncm91cEFycmF5LnB1c2goYnVpbGRHcm91cCQxKGV4cHJlc3Npb25baV0sIHN0eWxlKSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBncm91cCA9IGdyb3VwQXJyYXlbaV07XG5cbiAgICAvLyBTdXBwcmVzcyBzcGFjaW5nIGJldHdlZW4gYWRqYWNlbnQgcmVsYXRpb25zXG4gICAgaWYgKGkgPCBleHByZXNzaW9uLmxlbmd0aCAtIDEgJiYgaXNSZWwoZXhwcmVzc2lvbltpXSkgJiYgaXNSZWwoZXhwcmVzc2lvbltpICsgMV0pKSB7XG4gICAgICBncm91cC5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwZW1cIik7XG4gICAgfVxuICAgIGlmIChpID4gMCAmJiBpc1JlbChleHByZXNzaW9uW2ldKSAmJiBpc1JlbChleHByZXNzaW9uW2kgLSAxXSkpIHtcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjBlbVwiKTtcbiAgICB9XG5cbiAgICAvLyBDb25jYXRlbmF0ZSBudW1iZXJzXG4gICAgaWYgKGdyb3VwLnR5cGUgPT09ICdtbicgJiYgbGFzdEdyb3VwICYmIGxhc3RHcm91cC50eXBlID09PSAnbW4nKSB7XG4gICAgICAvLyBDb25jYXRlbmF0ZSA8bW4+Li4uPC9tbj4gZm9sbG93ZWQgYnkgPG1pPi48L21pPlxuICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uZ3JvdXAuY2hpbGRyZW4pO1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyUHVuY3R1YXRpb24oZ3JvdXApICYmIGxhc3RHcm91cCAmJiBsYXN0R3JvdXAudHlwZSA9PT0gJ21uJykge1xuICAgICAgLy8gQ29uY2F0ZW5hdGUgPG1uPi4uLjwvbW4+IGZvbGxvd2VkIGJ5IDxtaT4uPC9taT5cbiAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLmdyb3VwLmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChsYXN0R3JvdXAgJiYgbGFzdEdyb3VwLnR5cGUgPT09IFwibW5cIiAmJiBpIDwgZ3JvdXBBcnJheS5sZW5ndGggLSAxICYmXG4gICAgICBncm91cEFycmF5W2kgKyAxXS50eXBlID09PSBcIm1uXCIgJiYgaXNDb21tYShleHByZXNzaW9uLCBpKSkge1xuICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uZ3JvdXAuY2hpbGRyZW4pO1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09ICdtbicgJiYgaXNOdW1iZXJQdW5jdHVhdGlvbihsYXN0R3JvdXApKSB7XG4gICAgICAvLyBDb25jYXRlbmF0ZSA8bWk+LjwvbWk+IGZvbGxvd2VkIGJ5IDxtbj4uLi48L21uPlxuICAgICAgZ3JvdXAuY2hpbGRyZW4gPSBbLi4ubGFzdEdyb3VwLmNoaWxkcmVuLCAuLi5ncm91cC5jaGlsZHJlbl07XG4gICAgICBncm91cHMucG9wKCk7XG4gICAgfSBlbHNlIGlmICgoZ3JvdXAudHlwZSA9PT0gJ21zdXAnIHx8IGdyb3VwLnR5cGUgPT09ICdtc3ViJykgJiZcbiAgICAgICAgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID49IDEgJiYgbGFzdEdyb3VwICYmXG4gICAgICAgIChsYXN0R3JvdXAudHlwZSA9PT0gJ21uJyB8fCBpc051bWJlclB1bmN0dWF0aW9uKGxhc3RHcm91cCkpKSB7XG4gICAgICAvLyBQdXQgcHJlY2VkaW5nIDxtbj4uLi48L21uPiBvciA8bWk+LjwvbWk+IGluc2lkZSBiYXNlIG9mXG4gICAgICAvLyA8bXN1cD48bW4+Li4uYmFzZS4uLjwvbW4+Li4uZXhwb25lbnQuLi48L21zdXA+IChvciA8bXN1Yj4pXG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgICBpZiAoYmFzZSBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGJhc2UudHlwZSA9PT0gJ21uJyAmJiBsYXN0R3JvdXApIHtcbiAgICAgICAgYmFzZS5jaGlsZHJlbiA9IFsuLi5sYXN0R3JvdXAuY2hpbGRyZW4sIC4uLmJhc2UuY2hpbGRyZW5dO1xuICAgICAgICBncm91cHMucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICBsYXN0R3JvdXAgPSBncm91cDtcbiAgfVxuICByZXR1cm4gZ3JvdXBzXG59O1xuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gYnVpbGRFeHByZXNzaW9uLCBidXQgd3JhcHMgdGhlIGVsZW1lbnRzIGluIGFuIDxtcm93PlxuICogaWYgdGhlcmUncyBtb3JlIHRoYW4gb25lLiAgUmV0dXJucyBhIHNpbmdsZSBub2RlIGluc3RlYWQgb2YgYW4gYXJyYXkuXG4gKi9cbmNvbnN0IGJ1aWxkRXhwcmVzc2lvblJvdyA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHN0eWxlLCBzZW1pc2ltcGxlID0gZmFsc2UpIHtcbiAgcmV0dXJuIG1ha2VSb3coYnVpbGRFeHByZXNzaW9uKGV4cHJlc3Npb24sIHN0eWxlLCBzZW1pc2ltcGxlKSwgc2VtaXNpbXBsZSk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgZ3JvdXAgZnJvbSB0aGUgcGFyc2VyIGFuZCBjYWxscyB0aGUgYXBwcm9wcmlhdGUgZ3JvdXBCdWlsZGVycyBmdW5jdGlvblxuICogb24gaXQgdG8gcHJvZHVjZSBhIE1hdGhNTCBub2RlLlxuICovXG5jb25zdCBidWlsZEdyb3VwJDEgPSBmdW5jdGlvbihncm91cCwgc3R5bGUpIHtcbiAgaWYgKCFncm91cCkge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIik7XG4gIH1cblxuICBpZiAoX21hdGhtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0pIHtcbiAgICAvLyBDYWxsIHRoZSBncm91cEJ1aWxkZXJzIGZ1bmN0aW9uXG4gICAgY29uc3QgcmVzdWx0ID0gX21hdGhtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0oZ3JvdXAsIHN0eWxlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgfVxufTtcblxuY29uc3QgZ2x1ZSQxID0gXyA9PiB7XG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbXSwgW10sIHsgcGFkZGluZzogXCIwXCIsIHdpZHRoOiBcIjUwJVwiIH0pXG59O1xuXG5jb25zdCBsYWJlbENvbnRhaW5lcnMgPSBbXCJtcm93XCIsIFwibXRkXCIsIFwibXRhYmxlXCIsIFwibXRyXCJdO1xuY29uc3QgZ2V0TGFiZWwgPSBwYXJlbnQgPT4ge1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgcGFyZW50LmNoaWxkcmVuKSB7XG4gICAgaWYgKG5vZGUudHlwZSAmJiBsYWJlbENvbnRhaW5lcnMuaW5jbHVkZXMobm9kZS50eXBlKSkge1xuICAgICAgaWYgKG5vZGUuY2xhc3NlcyAmJiBub2RlLmNsYXNzZXNbMF0gPT09IFwidG1sLWxhYmVsXCIpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBub2RlLmxhYmVsO1xuICAgICAgICByZXR1cm4gbGFiZWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZ2V0TGFiZWwobm9kZSk7XG4gICAgICAgIGlmIChsYWJlbCkgeyByZXR1cm4gbGFiZWwgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW5vZGUudHlwZSkge1xuICAgICAgY29uc3QgbGFiZWwgPSBnZXRMYWJlbChub2RlKTtcbiAgICAgIGlmIChsYWJlbCkgeyByZXR1cm4gbGFiZWwgfVxuICAgIH1cbiAgfVxufTtcblxuY29uc3QgdGFnZ2VkRXhwcmVzc2lvbiA9IChleHByZXNzaW9uLCB0YWcsIHN0eWxlLCBsZXFubykgPT4ge1xuICB0YWcgPSBidWlsZEV4cHJlc3Npb25Sb3codGFnWzBdLmJvZHksIHN0eWxlKTtcbiAgdGFnID0gY29uc29saWRhdGVUZXh0KHRhZyk7XG4gIHRhZy5jbGFzc2VzLnB1c2goXCJ0bWwtdGFnXCIpO1xuXG4gIGNvbnN0IGxhYmVsID0gZ2V0TGFiZWwoZXhwcmVzc2lvbik7IC8vIGZyb20gYSBcXGxhYmVse30gZnVuY3Rpb24uXG4gIGV4cHJlc3Npb24gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbZXhwcmVzc2lvbl0pO1xuICBjb25zdCByb3dBcnJheSA9IFtnbHVlJDEoKSwgZXhwcmVzc2lvbiwgZ2x1ZSQxKCldO1xuICByb3dBcnJheVtsZXFubyA/IDAgOiAyXS5jbGFzc2VzLnB1c2gobGVxbm8gPyBcInRtbC1sZWZ0XCIgOiBcInRtbC1yaWdodFwiKTtcbiAgcm93QXJyYXlbbGVxbm8gPyAwIDogMl0uY2hpbGRyZW4ucHVzaCh0YWcpO1xuICBjb25zdCBtdHIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCByb3dBcnJheSwgW1widG1sLXRhZ2VxblwiXSk7XG4gIGlmIChsYWJlbCkgeyBtdHIuc2V0QXR0cmlidXRlKFwiaWRcIiwgbGFiZWwpOyB9XG4gIGNvbnN0IHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgW210cl0pO1xuICB0YWJsZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gdGFibGVcbn07XG5cbi8qKlxuICogVGFrZXMgYSBmdWxsIHBhcnNlIHRyZWUgYW5kIHNldHRpbmdzIGFuZCBidWlsZHMgYSBNYXRoTUwgcmVwcmVzZW50YXRpb24gb2ZcbiAqIGl0LlxuICovXG5mdW5jdGlvbiBidWlsZE1hdGhNTCh0cmVlLCB0ZXhFeHByZXNzaW9uLCBzdHlsZSwgc2V0dGluZ3MpIHtcbiAgLy8gU3RyaXAgb2ZmIG91dGVyIHRhZyB3cmFwcGVyIGZvciBwcm9jZXNzaW5nIGJlbG93LlxuICBsZXQgdGFnID0gbnVsbDtcbiAgaWYgKHRyZWUubGVuZ3RoID09PSAxICYmIHRyZWVbMF0udHlwZSA9PT0gXCJ0YWdcIikge1xuICAgIHRhZyA9IHRyZWVbMF0udGFnO1xuICAgIHRyZWUgPSB0cmVlWzBdLmJvZHk7XG4gIH1cblxuICBjb25zdCBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIHN0eWxlKTtcblxuICBpZiAoZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgZXhwcmVzc2lvblswXSBpbnN0YW5jZW9mIEFuY2hvck5vZGUpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvblswXVxuICB9XG5cbiAgY29uc3Qgd3JhcCA9IChzZXR0aW5ncy5kaXNwbGF5TW9kZSB8fCBzZXR0aW5ncy5hbm5vdGF0ZSkgPyBcIm5vbmVcIiA6IHNldHRpbmdzLndyYXA7XG5cbiAgY29uc3QgbjEgPSBleHByZXNzaW9uLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBleHByZXNzaW9uWzBdO1xuICBsZXQgd3JhcHBlciA9IGV4cHJlc3Npb24ubGVuZ3RoID09PSAxICYmIHRhZyA9PT0gbnVsbCAmJiAobjEgaW5zdGFuY2VvZiBNYXRoTm9kZSlcbiAgICAgID8gZXhwcmVzc2lvblswXVxuICAgICAgOiBzZXRMaW5lQnJlYWtzKGV4cHJlc3Npb24sIHdyYXAsIHNldHRpbmdzLmRpc3BsYXlNb2RlKTtcblxuICBpZiAodGFnKSB7XG4gICAgd3JhcHBlciA9IHRhZ2dlZEV4cHJlc3Npb24od3JhcHBlciwgdGFnLCBzdHlsZSwgc2V0dGluZ3MubGVxbm8pO1xuICB9XG5cbiAgaWYgKHNldHRpbmdzLmFubm90YXRlKSB7XG4gICAgLy8gQnVpbGQgYSBUZVggYW5ub3RhdGlvbiBvZiB0aGUgc291cmNlXG4gICAgY29uc3QgYW5ub3RhdGlvbiA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgXCJhbm5vdGF0aW9uXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSh0ZXhFeHByZXNzaW9uKV0pO1xuICAgIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcbiAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGggPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1hdGhcIiwgW3dyYXBwZXJdKTtcblxuICBpZiAoc2V0dGluZ3MueG1sKSB7XG4gICAgbWF0aC5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIik7XG4gIH1cbiAgaWYgKHdyYXBwZXIuc3R5bGUud2lkdGgpIHtcbiAgICBtYXRoLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gIH1cbiAgaWYgKHNldHRpbmdzLmRpc3BsYXlNb2RlKSB7XG4gICAgbWF0aC5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XG4gICAgbWF0aC5zdHlsZS5kaXNwbGF5ID0gXCJibG9jayBtYXRoXCI7IC8vIG5lY2Vzc2FyeSBpbiBDaHJvbWl1bS5cbiAgICAvLyBGaXJlZm94IGFuZCBTYWZhcmkgZG8gbm90IHJlY29nbml6ZSBkaXNwbGF5OiBcImJsb2NrIG1hdGhcIi5cbiAgICAvLyBTZXQgYSBjbGFzcyBzbyB0aGF0IHRoZSBDU1MgZmlsZSBjYW4gc2V0IGRpc3BsYXk6IGJsb2NrLlxuICAgIG1hdGguY2xhc3NlcyA9IFtcInRtbC1kaXNwbGF5XCJdO1xuICB9XG4gIHJldHVybiBtYXRoO1xufVxuXG5jb25zdCBzbWFsbHMgPSBcImFjZWfEsci3bW5vcHFyc3V2d3h5es6xzrPOtc63zrnOus68zr3Ov8+Az4HPgs+Dz4TPhc+Hz4nPlfCdkJrwnZCc8J2QnvCdkKDwnZCm8J2Qp/CdkKjwnZCp8J2QqvCdkKvwnZCs8J2QrvCdkK/wnZCw8J2QsfCdkLLwnZCzXCI7XG5jb25zdCB0YWxscyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpiZGZoa2x0zpHOks6TzpTOlc6WzpfOmM6ZzprOm86czp3Ons6fzqDOoc6jzqTOpc6mzqfOqM6pzrLOtM67zrbPhs64z4hcIlxuICAgICAgICAgICAgICsgXCLwnZCA8J2QgfCdkILwnZCD8J2QhPCdkIXwnZCG8J2Qh/CdkIjwnZCJ8J2QivCdkIvwnZCM8J2QjfCdkI7wnZCP8J2QkPCdkJHwnZCS8J2Qk/CdkJTwnZCV8J2QlvCdkJfwnZCY8J2QmfCdkJvwnZCd8J2Qn/CdkKHwnZCk8J2QpfCdkK1cIjtcbmNvbnN0IGxvbmdTbWFsbHMgPSBuZXcgU2V0KFtcIlxcXFxhbHBoYVwiLCBcIlxcXFxnYW1tYVwiLCBcIlxcXFxkZWx0YVwiLCBcIlxcXFxlcHNpbG9uXCIsIFwiXFxcXGV0YVwiLCBcIlxcXFxpb3RhXCIsXG4gIFwiXFxcXGthcHBhXCIsIFwiXFxcXG11XCIsIFwiXFxcXG51XCIsIFwiXFxcXHBpXCIsIFwiXFxcXHJob1wiLCBcIlxcXFxzaWdtYVwiLCBcIlxcXFx0YXVcIiwgXCJcXFxcdXBzaWxvblwiLCBcIlxcXFxjaGlcIiwgXCJcXFxccHNpXCIsXG4gIFwiXFxcXG9tZWdhXCIsIFwiXFxcXGltYXRoXCIsIFwiXFxcXGptYXRoXCJdKTtcbmNvbnN0IGxvbmdUYWxscyA9IG5ldyBTZXQoW1wiXFxcXEdhbW1hXCIsIFwiXFxcXERlbHRhXCIsIFwiXFxcXFNpZ21hXCIsIFwiXFxcXE9tZWdhXCIsIFwiXFxcXGJldGFcIiwgXCJcXFxcZGVsdGFcIixcbiAgXCJcXFxcbGFtYmRhXCIsIFwiXFxcXHRoZXRhXCIsIFwiXFxcXHBzaVwiXSk7XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkYSA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgY29uc3QgYWNjZW50Tm9kZSA9IGdyb3VwLmlzU3RyZXRjaHlcbiAgICA/IHN0cmV0Y2h5LmFjY2VudE5vZGUoZ3JvdXApXG4gICAgOiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5sYWJlbCwgZ3JvdXAubW9kZSldKTtcblxuICBpZiAoZ3JvdXAubGFiZWwgPT09IFwiXFxcXHZlY1wiKSB7XG4gICAgYWNjZW50Tm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlKDAuNzUpIHRyYW5zbGF0ZSgxMCUsIDMwJSlcIjtcbiAgfSBlbHNlIHtcbiAgICBhY2NlbnROb2RlLnN0eWxlLm1hdGhTdHlsZSA9IFwibm9ybWFsXCI7XG4gICAgYWNjZW50Tm9kZS5zdHlsZS5tYXRoRGVwdGggPSBcIjBcIjtcbiAgICBpZiAobmVlZFdlYmtpdFNoaWZ0Lmhhcyhncm91cC5sYWJlbCkgJiYgIHV0aWxzLmlzQ2hhcmFjdGVyQm94KGdyb3VwLmJhc2UpKSB7XG4gICAgICBsZXQgc2hpZnQgPSBcIlwiO1xuICAgICAgY29uc3QgY2ggPSBncm91cC5iYXNlLnRleHQ7XG4gICAgICBpZiAoc21hbGxzLmluZGV4T2YoY2gpID4gLTEgfHwgbG9uZ1NtYWxscy5oYXMoY2gpKSB7IHNoaWZ0ID0gXCJ0bWwteHNoaWZ0XCI7IH1cbiAgICAgIGlmICh0YWxscy5pbmRleE9mKGNoKSA+IC0xICB8fCBsb25nVGFsbHMuaGFzKGNoKSkgIHsgc2hpZnQgPSBcInRtbC1jYXBzaGlmdFwiOyB9XG4gICAgICBpZiAoc2hpZnQpIHsgYWNjZW50Tm9kZS5jbGFzc2VzLnB1c2goc2hpZnQpOyB9XG4gICAgfVxuICB9XG4gIGlmICghZ3JvdXAuaXNTdHJldGNoeSkge1xuICAgIGFjY2VudE5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJmYWxzZVwiKTtcbiAgfVxuXG4gIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgoZ3JvdXAubGFiZWwgPT09IFwiXFxcXGNcIiA/IFwibXVuZGVyXCIgOiBcIm1vdmVyXCIpLFxuICAgIFtidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgc3R5bGUpLCBhY2NlbnROb2RlXVxuICApO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxuY29uc3Qgbm9uU3RyZXRjaHlBY2NlbnRzID0gbmV3IFNldChbXG4gIFwiXFxcXGFjdXRlXCIsXG4gIFwiXFxcXGdyYXZlXCIsXG4gIFwiXFxcXGRkb3RcIixcbiAgXCJcXFxcZGRkb3RcIixcbiAgXCJcXFxcZGRkZG90XCIsXG4gIFwiXFxcXHRpbGRlXCIsXG4gIFwiXFxcXGJhclwiLFxuICBcIlxcXFxicmV2ZVwiLFxuICBcIlxcXFxjaGVja1wiLFxuICBcIlxcXFxoYXRcIixcbiAgXCJcXFxcdmVjXCIsXG4gIFwiXFxcXGRvdFwiLFxuICBcIlxcXFxtYXRocmluZ1wiXG5dKTtcblxuY29uc3QgbmVlZFdlYmtpdFNoaWZ0ID0gbmV3IFNldChbXG4gIFwiXFxcXGFjdXRlXCIsXG4gIFwiXFxcXGJhclwiLFxuICBcIlxcXFxicmV2ZVwiLFxuICBcIlxcXFxjaGVja1wiLFxuICBcIlxcXFxkb3RcIixcbiAgXCJcXFxcZGRvdFwiLFxuICBcIlxcXFxncmF2ZVwiLFxuICBcIlxcXFxoYXRcIixcbiAgXCJcXFxcbWF0aHJpbmdcIixcbiAgXCJcXFxcJ1wiLCBcIlxcXFxeXCIsIFwiXFxcXH5cIiwgXCJcXFxcPVwiLCBcIlxcXFx1XCIsIFwiXFxcXC5cIiwgJ1xcXFxcIicsIFwiXFxcXHJcIiwgXCJcXFxcSFwiLCBcIlxcXFx2XCJcbl0pO1xuXG5jb25zdCBjb21iaW5pbmdDaGFyID0ge1xuICBcIlxcXFxgXCI6IFwiXFx1MDMwMFwiLFxuICBcIlxcXFwnXCI6IFwiXFx1MDMwMVwiLFxuICBcIlxcXFxeXCI6IFwiXFx1MDMwMlwiLFxuICBcIlxcXFx+XCI6IFwiXFx1MDMwM1wiLFxuICBcIlxcXFw9XCI6IFwiXFx1MDMwNFwiLFxuICBcIlxcXFx1XCI6IFwiXFx1MDMwNlwiLFxuICBcIlxcXFwuXCI6IFwiXFx1MDMwN1wiLFxuICAnXFxcXFwiJzogXCJcXHUwMzA4XCIsXG4gIFwiXFxcXHJcIjogXCJcXHUwMzBBXCIsXG4gIFwiXFxcXEhcIjogXCJcXHUwMzBCXCIsXG4gIFwiXFxcXHZcIjogXCJcXHUwMzBDXCJcbn07XG5cbi8vIEFjY2VudHNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJhY2NlbnRcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxhY3V0ZVwiLFxuICAgIFwiXFxcXGdyYXZlXCIsXG4gICAgXCJcXFxcZGRvdFwiLFxuICAgIFwiXFxcXGRkZG90XCIsXG4gICAgXCJcXFxcZGRkZG90XCIsXG4gICAgXCJcXFxcdGlsZGVcIixcbiAgICBcIlxcXFxiYXJcIixcbiAgICBcIlxcXFxicmV2ZVwiLFxuICAgIFwiXFxcXGNoZWNrXCIsXG4gICAgXCJcXFxcaGF0XCIsXG4gICAgXCJcXFxcdmVjXCIsXG4gICAgXCJcXFxcZG90XCIsXG4gICAgXCJcXFxcbWF0aHJpbmdcIixcbiAgICBcIlxcXFxvdmVycGFyZW5cIixcbiAgICBcIlxcXFx3aWRlY2hlY2tcIixcbiAgICBcIlxcXFx3aWRlaGF0XCIsXG4gICAgXCJcXFxcd2lkZXBhcmVuXCIsXG4gICAgXCJcXFxcd2lkZXRpbGRlXCIsXG4gICAgXCJcXFxcb3ZlcnJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFxvdmVybGVmdGFycm93XCIsXG4gICAgXCJcXFxcT3ZlcnJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFxvdmVybGVmdHJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFxvdmVyZ3JvdXBcIixcbiAgICBcIlxcXFxvdmVybGVmdGhhcnBvb25cIixcbiAgICBcIlxcXFxvdmVycmlnaHRoYXJwb29uXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYmFzZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuXG4gICAgY29uc3QgaXNTdHJldGNoeSA9ICFub25TdHJldGNoeUFjY2VudHMuaGFzKGNvbnRleHQuZnVuY05hbWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWNjZW50XCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICBpc1N0cmV0Y2h5OiBpc1N0cmV0Y2h5LFxuICAgICAgYmFzZTogYmFzZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkYVxufSk7XG5cbi8vIFRleHQtbW9kZSBhY2NlbnRzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcJ1wiLCBcIlxcXFxgXCIsIFwiXFxcXF5cIiwgXCJcXFxcflwiLCBcIlxcXFw9XCIsIFwiXFxcXGNcIiwgXCJcXFxcdVwiLCBcIlxcXFwuXCIsICdcXFxcXCInLCBcIlxcXFxyXCIsIFwiXFxcXEhcIiwgXCJcXFxcdlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYmFzZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgIGNvbnN0IG1vZGUgPSBjb250ZXh0LnBhcnNlci5tb2RlO1xuXG4gICAgaWYgKG1vZGUgPT09IFwibWF0aFwiICYmIGNvbnRleHQucGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgLy8gTGFUZVggb25seSB3cml0ZXMgYSB3YXJuaW5nLiBJdCBkb2Vzbid0IHN0b3AuIFdlJ2xsIGlzc3VlIHRoZSBzYW1lIHdhcm5pbmcuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5sb2coYFRlbW1sIHBhcnNlIGVycm9yOiBDb21tYW5kICR7Y29udGV4dC5mdW5jTmFtZX0gaXMgaW52YWxpZCBpbiBtYXRoIG1vZGUuYCk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGUgPT09IFwidGV4dFwiICYmIGJhc2UudGV4dCAmJiBiYXNlLnRleHQubGVuZ3RoID09PSAxXG4gICAgICAgICYmIGNvbnRleHQuZnVuY05hbWUgaW4gY29tYmluaW5nQ2hhciAgJiYgc21hbGxzLmluZGV4T2YoYmFzZS50ZXh0KSA+IC0xKSB7XG4gICAgICAvLyBSZXR1cm4gYSBjb21iaW5pbmcgYWNjZW50IGNoYXJhY3RlclxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBiYXNlLnRleHQgKyBjb21iaW5pbmdDaGFyW2NvbnRleHQuZnVuY05hbWVdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJ1aWxkIHVwIHRoZSBhY2NlbnRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiYWNjZW50XCIsXG4gICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgIGxhYmVsOiBjb250ZXh0LmZ1bmNOYW1lLFxuICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSxcbiAgICAgICAgYmFzZTogYmFzZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciRhXG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFVuZGVyXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcdW5kZXJsZWZ0YXJyb3dcIixcbiAgICBcIlxcXFx1bmRlcnJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx1bmRlcmxlZnRyaWdodGFycm93XCIsXG4gICAgXCJcXFxcdW5kZXJncm91cFwiLFxuICAgIFwiXFxcXHVuZGVycGFyZW5cIixcbiAgICBcIlxcXFx1dGlsZGVcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYmFzZSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYWNjZW50VW5kZXJcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYmFzZTogYmFzZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBhY2NlbnROb2RlID0gc3RyZXRjaHkuYWNjZW50Tm9kZShncm91cCk7XG4gICAgYWNjZW50Tm9kZS5zdHlsZVtcIm1hdGgtZGVwdGhcIl0gPSAwO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbXG4gICAgICBidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgc3R5bGUpLFxuICAgICAgYWNjZW50Tm9kZVxuICAgIF0pO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgZG9lcyBjb252ZXJzaW9uIGJldHdlZW4gdW5pdHMuICBJbiBwYXJ0aWN1bGFyLCBpdCBwcm92aWRlc1xuICogY2FsY3VsYXRlU2l6ZSB0byBjb252ZXJ0IG90aGVyIHVuaXRzIGludG8gQ1NTIHVuaXRzLlxuICovXG5cblxuY29uc3QgcHRQZXJVbml0ID0ge1xuICAvLyBDb252ZXJ0IHRvIENTUyAoUG9zdHNjaXB0KSBwb2ludHMsIG5vdCBUZVggcG9pbnRzXG4gIC8vIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0xhVGVYL0xlbmd0aHMgYW5kXG4gIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvODI2M1xuICBwdDogODAwIC8gODAzLCAvLyBjb252ZXJ0IFRlWCBwb2ludCB0byBDU1MgKFBvc3RzY3JpcHQpIHBvaW50XG4gIHBjOiAoMTIgKiA4MDApIC8gODAzLCAvLyBwaWNhXG4gIGRkOiAoKDEyMzggLyAxMTU3KSAqIDgwMCkgLyA4MDMsIC8vIGRpZG90XG4gIGNjOiAoKDE0ODU2IC8gMTE1NykgKiA4MDApIC8gODAzLCAvLyBjaWNlcm8gKDEyIGRpZG90KVxuICBuZDogKCg2ODUgLyA2NDIpICogODAwKSAvIDgwMywgLy8gbmV3IGRpZG90XG4gIG5jOiAoKDEzNzAgLyAxMDcpICogODAwKSAvIDgwMywgLy8gbmV3IGNpY2VybyAoMTIgbmV3IGRpZG90KVxuICBzcDogKCgxIC8gNjU1MzYpICogODAwKSAvIDgwMywgLy8gc2NhbGVkIHBvaW50IChUZVgncyBpbnRlcm5hbCBzbWFsbGVzdCB1bml0KVxuICBtbTogKDI1LjQgLyA3MiksXG4gIGNtOiAoMi41NCAvIDcyKSxcbiAgaW46ICgxIC8gNzIpLFxuICBweDogKDk2IC8gNzIpXG59O1xuXG4vKipcbiAqIERldGVybWluZSB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgdW5pdCAoZWl0aGVyIGEgc3RyaW5nIGRlZmluaW5nIHRoZSB1bml0XG4gKiBvciBhIFwic2l6ZVwiIHBhcnNlIG5vZGUgY29udGFpbmluZyBhIHVuaXQgZmllbGQpIGlzIHZhbGlkLlxuICovXG5jb25zdCB2YWxpZFVuaXRzID0gW1xuICBcImVtXCIsXG4gIFwiZXhcIixcbiAgXCJtdVwiLFxuICBcInB0XCIsXG4gIFwibW1cIixcbiAgXCJjbVwiLFxuICBcImluXCIsXG4gIFwicHhcIixcbiAgXCJicFwiLFxuICBcInBjXCIsXG4gIFwiZGRcIixcbiAgXCJjY1wiLFxuICBcIm5kXCIsXG4gIFwibmNcIixcbiAgXCJzcFwiXG5dO1xuXG5jb25zdCB2YWxpZFVuaXQgPSBmdW5jdGlvbih1bml0KSB7XG4gIGlmICh0eXBlb2YgdW5pdCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHVuaXQgPSB1bml0LnVuaXQ7XG4gIH1cbiAgcmV0dXJuIHZhbGlkVW5pdHMuaW5kZXhPZih1bml0KSA+IC0xXG59O1xuXG5jb25zdCBlbVNjYWxlID0gc3R5bGVMZXZlbCA9PiB7XG4gIGNvbnN0IHNjcmlwdExldmVsID0gTWF0aC5tYXgoc3R5bGVMZXZlbCAtIDEsIDApO1xuICByZXR1cm4gWzEsIDAuNywgMC41XVtzY3JpcHRMZXZlbF1cbn07XG5cbi8qXG4gKiBDb252ZXJ0IGEgXCJzaXplXCIgcGFyc2Ugbm9kZSAod2l0aCBudW1lcmljIFwibnVtYmVyXCIgYW5kIHN0cmluZyBcInVuaXRcIiBmaWVsZHMsXG4gKiBhcyBwYXJzZWQgYnkgZnVuY3Rpb25zLmpzIGFyZ1R5cGUgXCJzaXplXCIpIGludG8gYSBDU1MgdmFsdWUuXG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVNpemUgPSBmdW5jdGlvbihzaXplVmFsdWUsIHN0eWxlKSB7XG4gIGxldCBudW1iZXIgPSBzaXplVmFsdWUubnVtYmVyO1xuICBpZiAoc3R5bGUubWF4U2l6ZVswXSA8IDAgJiYgbnVtYmVyID4gMCkge1xuICAgIHJldHVybiB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH1cbiAgfVxuICBjb25zdCB1bml0ID0gc2l6ZVZhbHVlLnVuaXQ7XG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgXCJtbVwiOlxuICAgIGNhc2UgXCJjbVwiOlxuICAgIGNhc2UgXCJpblwiOlxuICAgIGNhc2UgXCJweFwiOiB7XG4gICAgICBjb25zdCBudW1JbkNzc1B0cyA9IG51bWJlciAqIHB0UGVyVW5pdFt1bml0XTtcbiAgICAgIGlmIChudW1JbkNzc1B0cyA+IHN0eWxlLm1heFNpemVbMV0pIHtcbiAgICAgICAgcmV0dXJuIHsgbnVtYmVyOiBzdHlsZS5tYXhTaXplWzFdLCB1bml0OiBcInB0XCIgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbnVtYmVyLCB1bml0IH07IC8vIGFic29sdXRlIENTUyB1bml0cy5cbiAgICB9XG4gICAgY2FzZSBcImVtXCI6XG4gICAgY2FzZSBcImV4XCI6IHtcbiAgICAgIC8vIEluIFRlWCwgZW0gYW5kIGV4IGRvIG5vdCBjaGFuZ2Ugc2l6ZSBpbiBcXHNjcmlwdHN0eWxlLlxuICAgICAgaWYgKHVuaXQgPT09IFwiZXhcIikgeyBudW1iZXIgKj0gMC40MzE7IH1cbiAgICAgIG51bWJlciA9IE1hdGgubWluKG51bWJlciAvIGVtU2NhbGUoc3R5bGUubGV2ZWwpLCBzdHlsZS5tYXhTaXplWzBdKTtcbiAgICAgIHJldHVybiB7IG51bWJlcjogdXRpbHMucm91bmQobnVtYmVyKSwgdW5pdDogXCJlbVwiIH07XG4gICAgfVxuICAgIGNhc2UgXCJicFwiOiB7XG4gICAgICBpZiAobnVtYmVyID4gc3R5bGUubWF4U2l6ZVsxXSkgeyBudW1iZXIgPSBzdHlsZS5tYXhTaXplWzFdOyB9XG4gICAgICByZXR1cm4geyBudW1iZXIsIHVuaXQ6IFwicHRcIiB9OyAvLyBUZVggYnAgaXMgYSBDU1MgcHQuICgxLzcyIGluY2gpLlxuICAgIH1cbiAgICBjYXNlIFwicHRcIjpcbiAgICBjYXNlIFwicGNcIjpcbiAgICBjYXNlIFwiZGRcIjpcbiAgICBjYXNlIFwiY2NcIjpcbiAgICBjYXNlIFwibmRcIjpcbiAgICBjYXNlIFwibmNcIjpcbiAgICBjYXNlIFwic3BcIjoge1xuICAgICAgbnVtYmVyID0gTWF0aC5taW4obnVtYmVyICogcHRQZXJVbml0W3VuaXRdLCBzdHlsZS5tYXhTaXplWzFdKTtcbiAgICAgIHJldHVybiB7IG51bWJlcjogdXRpbHMucm91bmQobnVtYmVyKSwgdW5pdDogXCJwdFwiIH1cbiAgICB9XG4gICAgY2FzZSBcIm11XCI6IHtcbiAgICAgIG51bWJlciA9IE1hdGgubWluKG51bWJlciAvIDE4LCBzdHlsZS5tYXhTaXplWzBdKTtcbiAgICAgIHJldHVybiB7IG51bWJlcjogdXRpbHMucm91bmQobnVtYmVyKSwgdW5pdDogXCJlbVwiIH1cbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyB1bml0ICsgXCInXCIpXG4gIH1cbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcblxuY29uc3QgcGFkZGluZyQxID0gd2lkdGggPT4ge1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggKyBcImVtXCIpO1xuICByZXR1cm4gbm9kZVxufTtcblxuY29uc3QgcGFkZGVkTm9kZSA9IChncm91cCwgbHNwYWNlID0gMC4zLCByc3BhY2UgPSAwLCBtdXN0U21hc2ggPSBmYWxzZSkgPT4ge1xuICBpZiAoZ3JvdXAgPT0gbnVsbCAmJiByc3BhY2UgPT09IDApIHsgcmV0dXJuIHBhZGRpbmckMShsc3BhY2UpIH1cbiAgY29uc3Qgcm93ID0gZ3JvdXAgPyBbZ3JvdXBdIDogW107XG4gIGlmIChsc3BhY2UgIT09IDApICAgeyByb3cudW5zaGlmdChwYWRkaW5nJDEobHNwYWNlKSk7IH1cbiAgaWYgKHJzcGFjZSA+IDApIHsgcm93LnB1c2gocGFkZGluZyQxKHJzcGFjZSkpOyB9XG4gIGlmIChtdXN0U21hc2gpIHtcbiAgICAvLyBVc2VkIGZvciB0aGUgYm90dG9tIGFycm93IGluIGEge0NEfSBlbnZpcm9ubWVudFxuICAgIGNvbnN0IG1wYWRkZWQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgcm93KTtcbiAgICBtcGFkZGVkLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBcIik7XG4gICAgcmV0dXJuIG1wYWRkZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIHJvdylcbiAgfVxufTtcblxuY29uc3QgbGFiZWxTaXplID0gKHNpemUsIHNjcmlwdExldmVsKSA9PiAgTnVtYmVyKHNpemUpIC8gZW1TY2FsZShzY3JpcHRMZXZlbCk7XG5cbmNvbnN0IG11bmRlcm92ZXJOb2RlID0gKGZOYW1lLCBib2R5LCBiZWxvdywgc3R5bGUpID0+IHtcbiAgY29uc3QgYXJyb3dOb2RlID0gc3RyZXRjaHkubWF0aE1Mbm9kZShmTmFtZSk7XG4gIC8vIElzIHRoaXMgdGhlIHNob3J0IHBhcnQgb2YgYSBtaGNoZW0gZXF1aWxpYnJpdW0gYXJyb3c/XG4gIGNvbnN0IGlzRXEgPSBmTmFtZS5zbGljZSgxLCAzKSA9PT0gXCJlcVwiO1xuICBjb25zdCBtaW5XaWR0aCA9IGZOYW1lLmNoYXJBdCgxKSA9PT0gXCJ4XCJcbiAgICA/IFwiMS43NVwiICAvLyBtYXRodG9vbHMgZXh0ZW5zaWJsZSBhcnJvd3MgYXJlIOKJpSAxLjc1ZW0gbG9uZ1xuICAgIDogZk5hbWUuc2xpY2UoMiwgNCkgPT09IFwiY2RcIlxuICAgID8gXCIzLjBcIiAgLy8gY2QgcGFja2FnZSBhcnJvd3NcbiAgICA6IGlzRXFcbiAgICA/IFwiMS4wXCIgIC8vIFRoZSBzaG9ydGVyIGhhcnBvb24gb2YgYSBtaGNoZW0gZXF1aWxpYnJpdW0gYXJyb3dcbiAgICA6IFwiMi4wXCI7IC8vIG90aGVyIG1oY2hlbSBhcnJvd3NcbiAgLy8gVE9ETzogV2hlbiBGaXJlZm94IHN1cHBvcnRzIG1pbnNpemUsIHVzZSB0aGUgbmV4dCBsaW5lLlxuICAvL2Fycm93Tm9kZS5zZXRBdHRyaWJ1dGUoXCJtaW5zaXplXCIsIFN0cmluZyhtaW5XaWR0aCkgKyBcImVtXCIpXG4gIGFycm93Tm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwXCIpO1xuICBhcnJvd05vZGUuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIChpc0VxID8gXCIwLjVlbVwiIDogXCIwXCIpKTtcblxuICAvLyA8bXVuZGVyb3Zlcj4gdXBwZXIgYW5kIGxvd2VyIGxhYmVscyBhcmUgc2V0IHRvIHNjcmlwdGxldmVsIGJ5IE1hdGhNTFxuICAvLyBTbyB3ZSBoYXZlIHRvIGFkanVzdCBvdXIgbGFiZWwgZGltZW5zaW9ucyBhY2NvcmRpbmdseS5cbiAgY29uc3QgbGFiZWxTdHlsZSA9IHN0eWxlLndpdGhMZXZlbChzdHlsZS5sZXZlbCA8IDIgPyAyIDogMyk7XG4gIGNvbnN0IG1pbkFycm93V2lkdGggPSBsYWJlbFNpemUobWluV2lkdGgsIGxhYmVsU3R5bGUubGV2ZWwpO1xuICAvLyBUaGUgZHVtbXlOb2RlIHdpbGwgYmUgaW5zaWRlIGEgPG1vdmVyPiBpbnNpZGUgYSA8bW92ZXI+XG4gIC8vIFNvIGl0IHdpbGwgYmUgYXQgc2NyaXB0bGV2ZWwgM1xuICBjb25zdCBkdW1teVdpZHRoID0gbGFiZWxTaXplKG1pbldpZHRoLCAzKTtcbiAgY29uc3QgZW1wdHlMYWJlbCA9IHBhZGRlZE5vZGUobnVsbCwgbWluQXJyb3dXaWR0aC50b0ZpeGVkKDQpLCAwKTtcbiAgY29uc3QgZHVtbXlOb2RlID0gcGFkZGVkTm9kZShudWxsLCBkdW1teVdpZHRoLnRvRml4ZWQoNCksIDApO1xuICAvLyBUaGUgYXJyb3cgaXMgYSBsaXR0bGUgbG9uZ2VyIHRoYW4gdGhlIGxhYmVsLiBTZXQgYSBzcGFjZXIgbGVuZ3RoLlxuICBjb25zdCBzcGFjZSA9IGxhYmVsU2l6ZSgoaXNFcSA/IDAgOiAwLjMpLCBsYWJlbFN0eWxlLmxldmVsKS50b0ZpeGVkKDQpO1xuICBsZXQgdXBwZXJOb2RlO1xuICBsZXQgbG93ZXJOb2RlO1xuXG4gIGNvbnN0IGdvdFVwcGVyID0gKGJvZHkgJiYgYm9keS5ib2R5ICYmXG4gICAgLy8gXFxocGhhbnRvbSAgICAgICAgdmlzaWJsZSBjb250ZW50XG4gICAgKGJvZHkuYm9keS5ib2R5IHx8IGJvZHkuYm9keS5sZW5ndGggPiAwKSk7XG4gIGlmIChnb3RVcHBlcikge1xuICAgIGxldCBsYWJlbCA9ICBidWlsZEdyb3VwJDEoYm9keSwgbGFiZWxTdHlsZSk7XG4gICAgY29uc3QgbXVzdFNtYXNoID0gKGZOYW1lID09PSBcIlxcXFxcXFxcY2RyaWdodGFycm93XCIgfHwgZk5hbWUgPT09IFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiKTtcbiAgICBsYWJlbCA9IHBhZGRlZE5vZGUobGFiZWwsIHNwYWNlLCBzcGFjZSwgbXVzdFNtYXNoKTtcbiAgICAvLyBTaW5jZSBGaXJlZm94IGRvZXMgbm90IHN1cHBvcnQgbWluc2l6ZSwgc3RhY2sgYSBpbnZpc2libGUgbm9kZVxuICAgIC8vIG9uIHRvcCBvZiB0aGUgbGFiZWwuIEl0cyB3aWR0aCB3aWxsIHNlcnZlIGFzIGEgbWluLXdpZHRoLlxuICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoaXMgYWZ0ZXIgRmlyZWZveCBzdXBwb3J0cyBtaW5zaXplLlxuICAgIHVwcGVyTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW92ZXJcIiwgW2xhYmVsLCBkdW1teU5vZGVdKTtcbiAgfVxuICBjb25zdCBnb3RMb3dlciA9IChiZWxvdyAmJiBiZWxvdy5ib2R5ICYmXG4gICAgKGJlbG93LmJvZHkuYm9keSB8fCBiZWxvdy5ib2R5Lmxlbmd0aCA+IDApKTtcbiAgaWYgKGdvdExvd2VyKSB7XG4gICAgbGV0IGxhYmVsID0gIGJ1aWxkR3JvdXAkMShiZWxvdywgbGFiZWxTdHlsZSk7XG4gICAgbGFiZWwgPSBwYWRkZWROb2RlKGxhYmVsLCBzcGFjZSwgc3BhY2UpO1xuICAgIGxvd2VyTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFtsYWJlbCwgZHVtbXlOb2RlXSk7XG4gIH1cblxuICBsZXQgbm9kZTtcbiAgaWYgKCFnb3RVcHBlciAmJiAhZ290TG93ZXIpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYXJyb3dOb2RlLCBlbXB0eUxhYmVsXSk7XG4gIH0gZWxzZSBpZiAoZ290VXBwZXIgJiYgZ290TG93ZXIpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJvdmVyXCIsIFthcnJvd05vZGUsIGxvd2VyTm9kZSwgdXBwZXJOb2RlXSk7XG4gIH0gZWxzZSBpZiAoZ290VXBwZXIpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbYXJyb3dOb2RlLCB1cHBlck5vZGVdKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2Fycm93Tm9kZSwgbG93ZXJOb2RlXSk7XG4gIH1cbiAgaWYgKG1pbldpZHRoID09PSBcIjMuMFwiKSB7IG5vZGUuc3R5bGUuaGVpZ2h0ID0gXCIxZW1cIjsgfSAvLyBDRCBlbnZpcm9ubWVudFxuICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcImZhbHNlXCIpOyAvLyBOZWNlc3NhcnkgZm9yIE1TIFdvcmRcbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIFN0cmV0Y2h5IGFycm93cyB3aXRoIGFuIG9wdGlvbmFsIGFyZ3VtZW50XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwieEFycm93XCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxceGxlZnRhcnJvd1wiLFxuICAgIFwiXFxcXHhyaWdodGFycm93XCIsXG4gICAgXCJcXFxceExlZnRhcnJvd1wiLFxuICAgIFwiXFxcXHhSaWdodGFycm93XCIsXG4gICAgXCJcXFxceGxlZnRyaWdodGFycm93XCIsXG4gICAgXCJcXFxceExlZnRyaWdodGFycm93XCIsXG4gICAgXCJcXFxceGhvb2tsZWZ0YXJyb3dcIixcbiAgICBcIlxcXFx4aG9va3JpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx4bWFwc3RvXCIsXG4gICAgXCJcXFxceHJpZ2h0aGFycG9vbmRvd25cIixcbiAgICBcIlxcXFx4cmlnaHRoYXJwb29udXBcIixcbiAgICBcIlxcXFx4bGVmdGhhcnBvb25kb3duXCIsXG4gICAgXCJcXFxceGxlZnRoYXJwb29udXBcIixcbiAgICBcIlxcXFx4bG9uZ2VxdWFsXCIsXG4gICAgXCJcXFxceHR3b2hlYWRyaWdodGFycm93XCIsXG4gICAgXCJcXFxceHR3b2hlYWRsZWZ0YXJyb3dcIixcbiAgICAvLyBUaGUgbmV4dCA1IGZ1bmN0aW9ucyBhcmUgaGVyZSBvbmx5IHRvIHN1cHBvcnQgbWhjaGVtXG4gICAgXCJcXFxceWllbGRzXCIsXG4gICAgXCJcXFxceWllbGRzTGVmdFwiLFxuICAgIFwiXFxcXG1lc29tZXJpc21cIixcbiAgICBcIlxcXFxsb25ncmlnaHRoYXJwb29udXBcIixcbiAgICBcIlxcXFxsb25nbGVmdGhhcnBvb25kb3duXCIsXG4gICAgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgb25seSB0byBzdXBwb3J0IHRoZSB7Q0R9IGVudmlyb25tZW50LlxuICAgIFwiXFxcXFxcXFxjZHJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFxcXFxcY2RsZWZ0YXJyb3dcIixcbiAgICBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ4QXJyb3dcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmFtZTogZnVuY05hbWUsXG4gICAgICBib2R5OiBhcmdzWzBdLFxuICAgICAgYmVsb3c6IG9wdEFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIEJ1aWxkIHRoZSBhcnJvdyBhbmQgaXRzIGxhYmVscy5cbiAgICBjb25zdCBub2RlID0gbXVuZGVyb3Zlck5vZGUoZ3JvdXAubmFtZSwgZ3JvdXAuYm9keSwgZ3JvdXAuYmVsb3csIHN0eWxlKTtcbiAgICAvLyBDcmVhdGUgb3BlcmF0b3Igc3BhY2luZyBmb3IgYSByZWxhdGlvbi5cbiAgICBjb25zdCByb3cgPSBbbm9kZV07XG4gICAgcm93LnVuc2hpZnQocGFkZGluZyQxKDAuMjc3OCkpO1xuICAgIHJvdy5wdXNoKHBhZGRpbmckMSgwLjI3NzgpKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIHJvdylcbiAgfVxufSk7XG5cbmNvbnN0IGFycm93Q29tcG9uZW50ID0ge1xuICBcIlxcXFx4dG9mcm9tXCI6IFtcIlxcXFx4cmlnaHRhcnJvd1wiLCBcIlxcXFx4bGVmdGFycm93XCJdLFxuICBcIlxcXFx4bGVmdHJpZ2h0aGFycG9vbnNcIjogW1wiXFxcXHhsZWZ0aGFycG9vbnVwXCIsIFwiXFxcXHhyaWdodGhhcnBvb25kb3duXCJdLFxuICBcIlxcXFx4cmlnaHRsZWZ0aGFycG9vbnNcIjogW1wiXFxcXHhyaWdodGhhcnBvb251cFwiLCBcIlxcXFx4bGVmdGhhcnBvb25kb3duXCJdLFxuICBcIlxcXFx5aWVsZHNMZWZ0UmlnaHRcIjogW1wiXFxcXHlpZWxkc1wiLCBcIlxcXFx5aWVsZHNMZWZ0XCJdLFxuICAvLyBUaGUgbmV4dCB0aHJlZSBhbGwgZ2V0IHRoZSBzYW1lIGhhcnBvb24gZ2x5cGhzLiBPbmx5IHRoZSBsZW5ndGhzIGFuZCBwYWRkaW5ncyBkaWZmZXIuXG4gIFwiXFxcXGVxdWlsaWJyaXVtXCI6IFtcIlxcXFxsb25ncmlnaHRoYXJwb29udXBcIiwgXCJcXFxcbG9uZ2xlZnRoYXJwb29uZG93blwiXSxcbiAgXCJcXFxcZXF1aWxpYnJpdW1SaWdodFwiOiBbXCJcXFxcbG9uZ3JpZ2h0aGFycG9vbnVwXCIsIFwiXFxcXGVxbGVmdGhhcnBvb25kb3duXCJdLFxuICBcIlxcXFxlcXVpbGlicml1bUxlZnRcIjogW1wiXFxcXGVxcmlnaHRoYXJwb29udXBcIiwgXCJcXFxcbG9uZ2xlZnRoYXJwb29uZG93blwiXVxufTtcblxuLy8gQnJvd3NlcnMgYXJlIG5vdCBnb29kIGF0IHN0cmV0Y2hpbmcgYSBnbHlwaCB0aGF0IGNvbnRhaW5zIGEgcGFpciBvZiBzdGFja2VkIGFycm93cyBzdWNoIGFzIOKHhC5cbi8vIFNvIHdlIHN0YWNrIGEgcGFpciBvZiBzaW5nbGUgYXJyb3dzLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInN0YWNrZWRBcnJvd1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXHh0b2Zyb21cIiwgICAgICAgICAgICAgIC8vIGV4cGZlaWxcbiAgICBcIlxcXFx4bGVmdHJpZ2h0aGFycG9vbnNcIiwgICAvLyBtYXRodG9vbHNcbiAgICBcIlxcXFx4cmlnaHRsZWZ0aGFycG9vbnNcIiwgICAvLyBtYXRodG9vbHNcbiAgICBcIlxcXFx5aWVsZHNMZWZ0UmlnaHRcIiwgICAgICAvLyBtaGNoZW1cbiAgICBcIlxcXFxlcXVpbGlicml1bVwiLCAgICAgICAgICAvLyBtaGNoZW1cbiAgICBcIlxcXFxlcXVpbGlicml1bVJpZ2h0XCIsXG4gICAgXCJcXFxcZXF1aWxpYnJpdW1MZWZ0XCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3QgbG93ZXJBcnJvd0JvZHkgPSBhcmdzWzBdXG4gICAgICA/IHtcbiAgICAgICAgdHlwZTogXCJocGhhbnRvbVwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgYm9keTogYXJnc1swXVxuICAgICAgfVxuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHVwcGVyQXJyb3dCZWxvdyA9IG9wdEFyZ3NbMF1cbiAgICAgID8ge1xuICAgICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBib2R5OiBvcHRBcmdzWzBdXG4gICAgICB9XG4gICAgICA6IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RhY2tlZEFycm93XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lLFxuICAgICAgYm9keTogYXJnc1swXSxcbiAgICAgIHVwcGVyQXJyb3dCZWxvdyxcbiAgICAgIGxvd2VyQXJyb3dCb2R5LFxuICAgICAgYmVsb3c6IG9wdEFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IHRvcExhYmVsID0gYXJyb3dDb21wb25lbnRbZ3JvdXAubmFtZV1bMF07XG4gICAgY29uc3QgYm90TGFiZWwgPSBhcnJvd0NvbXBvbmVudFtncm91cC5uYW1lXVsxXTtcbiAgICBjb25zdCB0b3BBcnJvdyA9IG11bmRlcm92ZXJOb2RlKHRvcExhYmVsLCBncm91cC5ib2R5LCBncm91cC51cHBlckFycm93QmVsb3csIHN0eWxlKTtcbiAgICBjb25zdCBib3RBcnJvdyA9IG11bmRlcm92ZXJOb2RlKGJvdExhYmVsLCBncm91cC5sb3dlckFycm93Qm9keSwgZ3JvdXAuYmVsb3csIHN0eWxlKTtcbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGNvbnN0IHJhaXNlTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbdG9wQXJyb3ddKTtcbiAgICByYWlzZU5vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBcIjAuM2VtXCIpO1xuICAgIHJhaXNlTm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIrMC4zZW1cIik7XG4gICAgcmFpc2VOb2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiLTAuM2VtXCIpO1xuICAgIC8vIE9uZSBvZiB0aGUgYXJyb3dzIGlzIGdpdmVuIH56ZXJvIHdpZHRoLiBzbyB0aGUgb3RoZXIgaGFzIHRoZSBzYW1lIGhvcnpvbnRhbCBhbGlnbm1lbnQuXG4gICAgaWYgKGdyb3VwLm5hbWUgPT09IFwiXFxcXGVxdWlsaWJyaXVtTGVmdFwiKSB7XG4gICAgICBjb25zdCBib3ROb2RlID0gIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYm90QXJyb3ddKTtcbiAgICAgIGJvdE5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjVlbVwiKTtcbiAgICAgIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtcGFkZGVkXCIsXG4gICAgICAgIFtwYWRkaW5nJDEoMC4yNzc4KSwgYm90Tm9kZSwgcmFpc2VOb2RlLCBwYWRkaW5nJDEoMC4yNzc4KV1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhaXNlTm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAoZ3JvdXAubmFtZSA9PT0gXCJcXFxcZXF1aWxpYnJpdW1SaWdodFwiID8gXCIwLjVlbVwiIDogXCIwXCIpKTtcbiAgICAgIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtcGFkZGVkXCIsXG4gICAgICAgIFtwYWRkaW5nJDEoMC4yNzc4KSwgcmFpc2VOb2RlLCBib3RBcnJvdywgcGFkZGluZyQxKDAuMjc3OCldXG4gICAgICApO1xuICAgIH1cblxuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBcIi0wLjE4ZW1cIik7XG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCItMC4xOGVtXCIpO1xuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIrMC4xOGVtXCIpO1xuICAgIHJldHVybiB3cmFwcGVyXG4gIH1cbn0pO1xuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGVudmlyb25tZW50cy5cbiAqIGBlbnZpcm9ubWVudHMuanNgIGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeSB2aWEgYGVudmlyb25tZW50cy5qc2AuXG4gKi9cbmNvbnN0IF9lbnZpcm9ubWVudHMgPSB7fTtcblxuZnVuY3Rpb24gZGVmaW5lRW52aXJvbm1lbnQoeyB0eXBlLCBuYW1lcywgcHJvcHMsIGhhbmRsZXIsIG1hdGhtbEJ1aWxkZXIgfSkge1xuICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgZW52aXJvbm1lbnRzLlxuICBjb25zdCBkYXRhID0ge1xuICAgIHR5cGUsXG4gICAgbnVtQXJnczogcHJvcHMubnVtQXJncyB8fCAwLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlLFxuICAgIG51bU9wdGlvbmFsQXJnczogMCxcbiAgICBoYW5kbGVyXG4gIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICBfZW52aXJvbm1lbnRzW25hbWVzW2ldXSA9IGRhdGE7XG4gIH1cbiAgaWYgKG1hdGhtbEJ1aWxkZXIpIHtcbiAgICBfbWF0aG1sR3JvdXBCdWlsZGVyc1t0eXBlXSA9IG1hdGhtbEJ1aWxkZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIG5vZGUgaXMgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIHJldHVybnMgaXQgd2l0aCBzdHJpY3RlclxuICogdHlwaW5nLiBUaHJvd3MgaWYgdGhlIG5vZGUncyB0eXBlIGRvZXMgbm90IG1hdGNoLlxuICovXG5mdW5jdGlvbiBhc3NlcnROb2RlVHlwZShub2RlLCB0eXBlKSB7XG4gIGlmICghbm9kZSB8fCBub2RlLnR5cGUgIT09IHR5cGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgbm9kZSBvZiB0eXBlICR7dHlwZX0sIGJ1dCBnb3QgYCArXG4gICAgICAgIChub2RlID8gYG5vZGUgb2YgdHlwZSAke25vZGUudHlwZX1gIDogU3RyaW5nKG5vZGUpKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbm9kZSBtb3JlIHN0cmljdGx5IHR5cGVkIGlmZiBpdCBpcyBvZiB0aGUgZ2l2ZW4gdHlwZS4gT3RoZXJ3aXNlLFxuICogcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBhc3NlcnRTeW1ib2xOb2RlVHlwZShub2RlKSB7XG4gIGNvbnN0IHR5cGVkTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSk7XG4gIGlmICghdHlwZWROb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIG5vZGUgb2Ygc3ltYm9sIGdyb3VwIHR5cGUsIGJ1dCBnb3QgYCArXG4gICAgICAgIChub2RlID8gYG5vZGUgb2YgdHlwZSAke25vZGUudHlwZX1gIDogU3RyaW5nKG5vZGUpKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHR5cGVkTm9kZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlIG1vcmUgc3RyaWN0bHkgdHlwZWQgaWZmIGl0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLiBPdGhlcndpc2UsXG4gKiByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU3ltYm9sTm9kZVR5cGUobm9kZSkge1xuICBpZiAobm9kZSAmJiAobm9kZS50eXBlID09PSBcImF0b21cIiB8fFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE5PTl9BVE9NUywgbm9kZS50eXBlKSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgY2RBcnJvd0Z1bmN0aW9uTmFtZSA9IHtcbiAgXCI+XCI6IFwiXFxcXFxcXFxjZHJpZ2h0YXJyb3dcIixcbiAgXCI8XCI6IFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiLFxuICBcIj1cIjogXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCIsXG4gIEE6IFwiXFxcXHVwYXJyb3dcIixcbiAgVjogXCJcXFxcZG93bmFycm93XCIsXG4gIFwifFwiOiBcIlxcXFxWZXJ0XCIsXG4gIFwiLlwiOiBcIm5vIGFycm93XCJcbn07XG5cbmNvbnN0IG5ld0NlbGwgPSAoKSA9PiB7XG4gIC8vIENyZWF0ZSBhbiBlbXB0eSBjZWxsLCB0byBiZSBmaWxsZWQgYmVsb3cgd2l0aCBwYXJzZSBub2Rlcy5cbiAgcmV0dXJuIHsgdHlwZTogXCJzdHlsaW5nXCIsIGJvZHk6IFtdLCBtb2RlOiBcIm1hdGhcIiwgc2NyaXB0TGV2ZWw6IFwiZGlzcGxheVwiIH07XG59O1xuXG5jb25zdCBpc1N0YXJ0T2ZBcnJvdyA9IChub2RlKSA9PiB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwidGV4dG9yZFwiICYmIG5vZGUudGV4dCA9PT0gXCJAXCI7XG59O1xuXG5jb25zdCBpc0xhYmVsRW5kID0gKG5vZGUsIGVuZENoYXIpID0+IHtcbiAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8IG5vZGUudHlwZSA9PT0gXCJhdG9tXCIpICYmIG5vZGUudGV4dCA9PT0gZW5kQ2hhcjtcbn07XG5cbmZ1bmN0aW9uIGNkQXJyb3coYXJyb3dDaGFyLCBsYWJlbHMsIHBhcnNlcikge1xuICAvLyBSZXR1cm4gYSBwYXJzZSB0cmVlIG9mIGFuIGFycm93IGFuZCBpdHMgbGFiZWxzLlxuICAvLyBUaGlzIGFjdHMgaW4gYSB3YXkgc2ltaWxhciB0byBhIG1hY3JvIGV4cGFuc2lvbi5cbiAgY29uc3QgZnVuY05hbWUgPSBjZEFycm93RnVuY3Rpb25OYW1lW2Fycm93Q2hhcl07XG4gIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICBjYXNlIFwiXFxcXFxcXFxjZHJpZ2h0YXJyb3dcIjpcbiAgICBjYXNlIFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiOlxuICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtsYWJlbHNbMF1dLCBbbGFiZWxzWzFdXSk7XG4gICAgY2FzZSBcIlxcXFx1cGFycm93XCI6XG4gICAgY2FzZSBcIlxcXFxkb3duYXJyb3dcIjoge1xuICAgICAgY29uc3QgbGVmdExhYmVsID0gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2RsZWZ0XCIsIFtsYWJlbHNbMF1dLCBbXSk7XG4gICAgICBjb25zdCBiYXJlQXJyb3cgPSB7XG4gICAgICAgIHR5cGU6IFwiYXRvbVwiLFxuICAgICAgICB0ZXh0OiBmdW5jTmFtZSxcbiAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgIGZhbWlseTogXCJyZWxcIlxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNpemVkQXJyb3cgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXEJpZ1wiLCBbYmFyZUFycm93XSwgW10pO1xuICAgICAgY29uc3QgcmlnaHRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkcmlnaHRcIiwgW2xhYmVsc1sxXV0sIFtdKTtcbiAgICAgIGNvbnN0IGFycm93R3JvdXAgPSB7XG4gICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgbW9kZTogXCJtYXRoXCIsXG4gICAgICAgIGJvZHk6IFtsZWZ0TGFiZWwsIHNpemVkQXJyb3csIHJpZ2h0TGFiZWxdLFxuICAgICAgICBzZW1pc2ltcGxlOiB0cnVlXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkcGFyZW50XCIsIFthcnJvd0dyb3VwXSwgW10pO1xuICAgIH1cbiAgICBjYXNlIFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiOlxuICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCIsIFtdLCBbXSk7XG4gICAgY2FzZSBcIlxcXFxWZXJ0XCI6IHtcbiAgICAgIGNvbnN0IGFycm93ID0geyB0eXBlOiBcInRleHRvcmRcIiwgdGV4dDogXCJcXFxcVmVydFwiLCBtb2RlOiBcIm1hdGhcIiB9O1xuICAgICAgcmV0dXJuIHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcQmlnXCIsIFthcnJvd10sIFtdKTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGV4dG9yZFwiLCB0ZXh0OiBcIiBcIiwgbW9kZTogXCJtYXRoXCIgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNEKHBhcnNlcikge1xuICAvLyBHZXQgdGhlIGFycmF5J3MgcGFyc2Ugbm9kZXMgd2l0aCBcXFxcIHRlbXBvcmFyaWx5IG1hcHBlZCB0byBcXGNyLlxuICBjb25zdCBwYXJzZWRSb3dzID0gW107XG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY3JcIiwgXCJcXFxcXFxcXFxcXFxyZWxheFwiKTtcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gR2V0IHRoZSBwYXJzZSBub2RlcyBmb3IgdGhlIG5leHQgcm93LlxuICAgIHBhcnNlZFJvd3MucHVzaChwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBcIlxcXFxcXFxcXCIpKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gICAgaWYgKG5leHQgPT09IFwiJlwiIHx8IG5leHQgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXGVuZFwiKSB7XG4gICAgICBpZiAocGFyc2VkUm93c1twYXJzZWRSb3dzLmxlbmd0aCAtIDFdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBwYXJzZWRSb3dzLnBvcCgpOyAvLyBmaW5hbCByb3cgZW5kZWQgaW4gXFxcXFxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgXFxcXFxcXFwgb3IgXFxcXGNyIG9yIFxcXFxlbmRcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgfVxuICB9XG5cbiAgbGV0IHJvdyA9IFtdO1xuICBjb25zdCBib2R5ID0gW3Jvd107XG5cbiAgLy8gTG9vcCB0aHJ1IHRoZSBwYXJzZSBub2Rlcy4gQ29sbGVjdCB0aGVtIGludG8gY2VsbHMgYW5kIGFycm93cy5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWRSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gU3RhcnQgYSBuZXcgcm93LlxuICAgIGNvbnN0IHJvd05vZGVzID0gcGFyc2VkUm93c1tpXTtcbiAgICAvLyBDcmVhdGUgdGhlIGZpcnN0IGNlbGwuXG4gICAgbGV0IGNlbGwgPSBuZXdDZWxsKCk7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvd05vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoIWlzU3RhcnRPZkFycm93KHJvd05vZGVzW2pdKSkge1xuICAgICAgICAvLyBJZiBhIHBhcnNlTm9kZSBpcyBub3QgYW4gYXJyb3csIGl0IGdvZXMgaW50byBhIGNlbGwuXG4gICAgICAgIGNlbGwuYm9keS5wdXNoKHJvd05vZGVzW2pdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFBhcnNlIG5vZGUgaiBpcyBhbiBcIkBcIiwgdGhlIHN0YXJ0IG9mIGFuIGFycm93LlxuICAgICAgICAvLyBCZWZvcmUgc3RhcnRpbmcgb24gdGhlIGFycm93LCBwdXNoIHRoZSBjZWxsIGludG8gYHJvd2AuXG4gICAgICAgIHJvdy5wdXNoKGNlbGwpO1xuXG4gICAgICAgIC8vIE5vdyBjb2xsZWN0IHBhcnNlTm9kZXMgaW50byBhbiBhcnJvdy5cbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBhZnRlciBcIkBcIiBkZWZpbmVzIHRoZSBhcnJvdyB0eXBlLlxuICAgICAgICBqICs9IDE7XG4gICAgICAgIGNvbnN0IGFycm93Q2hhciA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKHJvd05vZGVzW2pdKS50ZXh0O1xuXG4gICAgICAgIC8vIENyZWF0ZSB0d28gZW1wdHkgbGFiZWwgbm9kZXMuIFdlIG1heSBvciBtYXkgbm90IHVzZSB0aGVtLlxuICAgICAgICBjb25zdCBsYWJlbHMgPSBuZXcgQXJyYXkoMik7XG4gICAgICAgIGxhYmVsc1swXSA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiBcIm1hdGhcIiwgYm9keTogW10gfTtcbiAgICAgICAgbGFiZWxzWzFdID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IFwibWF0aFwiLCBib2R5OiBbXSB9O1xuXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGFycm93LlxuICAgICAgICBpZiAoXCI9fC5cIi5pbmRleE9mKGFycm93Q2hhcikgPiAtMSkgOyBlbHNlIGlmIChcIjw+QVZcIi5pbmRleE9mKGFycm93Q2hhcikgPiAtMSkge1xuICAgICAgICAgIC8vIEZvdXIgYXJyb3dzLCBgQD4+PmAsIGBAPDw8YCwgYEBBQUFgLCBhbmQgYEBWVlZgLCBlYWNoIHRha2VcbiAgICAgICAgICAvLyB0d28gb3B0aW9uYWwgbGFiZWxzLiBFLmcuIHRoZSByaWdodC1wb2ludCBhcnJvdyBzeW50YXggaXNcbiAgICAgICAgICAvLyByZWFsbHk6ICBAPntvcHRpb25hbCBsYWJlbH0+e29wdGlvbmFsIGxhYmVsfT5cbiAgICAgICAgICAvLyBDb2xsZWN0IHBhcnNlTm9kZXMgaW50byBsYWJlbHMuXG4gICAgICAgICAgZm9yIChsZXQgbGFiZWxOdW0gPSAwOyBsYWJlbE51bSA8IDI7IGxhYmVsTnVtKyspIHtcbiAgICAgICAgICAgIGxldCBpbkxhYmVsID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IHJvd05vZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIGlmIChpc0xhYmVsRW5kKHJvd05vZGVzW2tdLCBhcnJvd0NoYXIpKSB7XG4gICAgICAgICAgICAgICAgaW5MYWJlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGogPSBrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc1N0YXJ0T2ZBcnJvdyhyb3dOb2Rlc1trXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgIFwiTWlzc2luZyBhIFwiICsgYXJyb3dDaGFyICsgXCIgY2hhcmFjdGVyIHRvIGNvbXBsZXRlIGEgQ0QgYXJyb3cuXCIsXG4gICAgICAgICAgICAgICAgICByb3dOb2Rlc1trXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsYWJlbHNbbGFiZWxOdW1dLmJvZHkucHVzaChyb3dOb2Rlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5MYWJlbCkge1xuICAgICAgICAgICAgICAvLyBpc0xhYmVsRW5kIG5ldmVyIHJldHVybmVkIGEgdHJ1ZS5cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJNaXNzaW5nIGEgXCIgKyBhcnJvd0NoYXIgKyBcIiBjaGFyYWN0ZXIgdG8gY29tcGxldGUgYSBDRCBhcnJvdy5cIixcbiAgICAgICAgICAgICAgICByb3dOb2Rlc1tqXVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRXhwZWN0ZWQgb25lIG9mIFwiPD5BVj18LlwiIGFmdGVyIEAuYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3cgam9pbiB0aGUgYXJyb3cgdG8gaXRzIGxhYmVscy5cbiAgICAgICAgY29uc3QgYXJyb3cgPSBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpO1xuXG4gICAgICAgIC8vIFdyYXAgdGhlIGFycm93IGluIGEgc3R5bGluZyBub2RlXG4gICAgICAgIHJvdy5wdXNoKGFycm93KTtcbiAgICAgICAgLy8gSW4gQ0QncyBzeW50YXgsIGNlbGxzIGFyZSBpbXBsaWNpdC4gVGhhdCBpcywgZXZlcnl0aGluZyB0aGF0XG4gICAgICAgIC8vIGlzIG5vdCBhbiBhcnJvdyBnZXRzIGNvbGxlY3RlZCBpbnRvIGEgY2VsbC4gU28gY3JlYXRlIGFuIGVtcHR5XG4gICAgICAgIC8vIGNlbGwgbm93LiBJdCB3aWxsIGNvbGxlY3QgdXBjb21pbmcgcGFyc2VOb2Rlcy5cbiAgICAgICAgY2VsbCA9IG5ld0NlbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgJSAyID09PSAwKSB7XG4gICAgICAvLyBFdmVuLW51bWJlcmVkIHJvd3MgY29uc2lzdCBvZjogY2VsbCwgYXJyb3csIGNlbGwsIGFycm93LCAuLi4gY2VsbFxuICAgICAgLy8gVGhlIGxhc3QgY2VsbCBpcyBub3QgeWV0IHB1c2hlZCBpbnRvIGByb3dgLCBzbzpcbiAgICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPZGQtbnVtYmVyZWQgcm93cyBjb25zaXN0IG9mOiB2ZXJ0IGFycm93LCBlbXB0eSBjZWxsLCAuLi4gdmVydCBhcnJvd1xuICAgICAgLy8gUmVtb3ZlIHRoZSBlbXB0eSBjZWxsIHRoYXQgd2FzIHBsYWNlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGByb3dgLlxuICAgICAgcm93LnNoaWZ0KCk7XG4gICAgfVxuICAgIHJvdyA9IFtdO1xuICAgIGJvZHkucHVzaChyb3cpO1xuICB9XG4gIGJvZHkucG9wKCk7XG5cbiAgLy8gRW5kIHJvdyBncm91cFxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gIC8vIEVuZCBhcnJheSBncm91cCBkZWZpbmluZyBcXFxcXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBib2R5LFxuICAgIHRhZ3M6IG51bGwsXG4gICAgbGFiZWxzOiBuZXcgQXJyYXkoYm9keS5sZW5ndGggKyAxKS5maWxsKFwiXCIpLFxuICAgIGVudkNsYXNzZXM6IFtcImpvdFwiLCBcImNkXCJdLFxuICAgIGNvbHM6IFtdLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogbmV3IEFycmF5KGJvZHkubGVuZ3RoICsgMSkuZmlsbChbXSlcbiAgfTtcbn1cblxuLy8gVGhlIGZ1bmN0aW9ucyBiZWxvdyBhcmUgbm90IGF2YWlsYWJsZSBmb3IgZ2VuZXJhbCB1c2UuXG4vLyBUaGV5IGFyZSBoZXJlIG9ubHkgZm9yIGludGVybmFsIHVzZSBieSB0aGUge0NEfSBlbnZpcm9ubWVudCBpbiBwbGFjaW5nIGxhYmVsc1xuLy8gbmV4dCB0byB2ZXJ0aWNhbCBhcnJvd3MuXG5cbi8vIFdlIGRvbid0IG5lZWQgYW55IHN1Y2ggZnVuY3Rpb25zIGZvciBob3Jpem9udGFsIGFycm93cyBiZWNhdXNlIHdlIGNhbiByZXVzZVxuLy8gdGhlIGZ1bmN0aW9uYWxpdHkgdGhhdCBhbHJlYWR5IGV4aXN0cyBmb3IgZXh0ZW5zaWJsZSBhcnJvd3MuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjZGxhYmVsXCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXGNkbGVmdFwiLCBcIlxcXFxcXFxcY2RyaWdodFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjZGxhYmVsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHNpZGU6IGZ1bmNOYW1lLnNsaWNlKDQpLFxuICAgICAgbGFiZWw6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGlmIChncm91cC5sYWJlbC5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBzdHlsZSkgIC8vIGVtcHR5IGxhYmVsXG4gICAgfVxuICAgIC8vIEFidXNlIGFuIDxtdGFibGU+IHRvIGNyZWF0ZSB2ZXJ0aWNhbGx5IGNlbnRlcmVkIGNvbnRlbnQuXG4gICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGRcIiwgW2J1aWxkR3JvdXAkMShncm91cC5sYWJlbCwgc3R5bGUpXSk7XG4gICAgbXRkLnN0eWxlLnBhZGRpbmcgPSBcIjBcIjtcbiAgICBjb25zdCBtdHIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbbXRkXSk7XG4gICAgY29uc3QgbXRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgW210cl0pO1xuICAgIGNvbnN0IGxhYmVsID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFttdGFibGVdKTtcbiAgICAvLyBTZXQgdGhlIGxhYmVsIHdpZHRoIHRvIHplcm8gc28gdGhhdCB0aGUgYXJyb3cgd2lsbCBiZSBjZW50ZXJlZCB1bmRlciB0aGUgY29ybmVyIGNlbGwuXG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwXCIpO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcImZhbHNlXCIpO1xuICAgIGxhYmVsLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMVwiKTtcbiAgICBpZiAoZ3JvdXAuc2lkZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIGxhYmVsLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgIGxhYmVsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJmbGV4LWVuZFwiO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY2RsYWJlbHBhcmVudFwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxjZHBhcmVudFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNkbGFiZWxwYXJlbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZnJhZ21lbnQ6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2J1aWxkR3JvdXAkMShncm91cC5mcmFnbWVudCwgc3R5bGUpXSk7XG4gIH1cbn0pO1xuXG5jb25zdCBvcmRHcm91cCA9IChib2R5KSA9PiB7XG4gIHJldHVybiB7XG4gICAgXCJ0eXBlXCI6IFwib3JkZ3JvdXBcIixcbiAgICBcIm1vZGVcIjogXCJtYXRoXCIsXG4gICAgXCJib2R5XCI6IGJvZHksXG4gICAgXCJzZW1pc2ltcGxlXCI6IHRydWVcbiAgfVxufTtcblxuY29uc3QgcGhhbnRvbSA9IChib2R5LCB0eXBlKSA9PiB7XG4gIHJldHVybiB7XG4gICAgXCJ0eXBlXCI6IHR5cGUsXG4gICAgXCJtb2RlXCI6IFwibWF0aFwiLFxuICAgIFwiYm9keVwiOiBvcmRHcm91cChib2R5KVxuICB9XG59O1xuXG4vKlxuICogQSBoZWxwZXIgZm9yIFxcYm9yZGVybWF0cml4LlxuICogcGFyc2VBcnJheSgpIGhhcyBwYXJzZWQgdGhlIHRva2VucyBhcyBpZiB0aGUgZW52aXJvbm1lbnRcbiAqIHdhcyBcXGJlZ2lue21hdHJpeH0uIFRoYXQgcGFyc2UgdHJlZSBpcyB0aGlzIGZ1bmN0aW9u4oCZcyBpbnB1dC5cbiAqIEhlcmUsIHdlIHJlYXJyYW5nZSB0aGUgcGFyc2UgdHJlZSB0byBnZXQgb25lIHRoYXQgd2lsbFxuICogcmVzdWx0IGluIFRlWCBcXGJvcmRlcm1hdHJpeC5cbiAqIFRoZSBmaW5hbCByZXN1bHQgaW5jbHVkZXMgYSB7cG1hdHJpeH0sIHdoaWNoIGlzIHRoZSBib3R0b21cbiAqIGhhbGYgb2YgYSA8bW92ZXI+IGVsZW1lbnQuIFRoZSB0b3Agb2YgdGhlIDxtb3Zlcj4gY29udGFpbnNcbiAqIHRoZSBcXGJvcmRlcm1hdHJpeCBoZWFkaW5ncy4gVGhlIHRvcCBzZWN0aW9uIGFsc28gY29udGFpbnMgdGhlXG4gKiBjb250ZW50cyBvZiB0aGUgYm90dG9tIHtwbWF0cml4fS4gVGhvc2UgZWxlbWVudHMgYXJlIGhpZGRlbiB2aWFcbiAqIFxcaHBoYW50b20sIGJ1dCB0aGV5IGVuc3VyZSB0aGF0IGNvbHVtbiB3aWR0aHMgYXJlIHRoZSBzYW1lIHRvcCBhbmRcbiAqIGJvdHRvbS5cbiAqXG4gKiBXZSBhbHNvIGNyZWF0ZSBhIGxlZnQge21hdHJpeH0gd2l0aCBhIHNpbmdsZSBjb2x1bW4gdGhhdCBjb250YWluc1xuICogZWxlbWVudHMgc2hpZnRlZCBvdXQgb2YgdGhlIG1hdHJpeC4gVGhlIGxlZnQge21hdHJpeH0gYWxzb1xuICogY29udGFpbnMgXFx2cGhhbnRvbSBjb3BpZXMgb2YgdGhlIG90aGVyIHtwbWF0cml4fSBlbGVtZW50cy5cbiAqIEFzIGJlZm9yZSwgdGhpcyBlbnN1cmVzIGNvbnNpc3RlbnQgcm93IGhlaWdodHMgb2YgbGVmdCBhbmQgbWFpbi5cbiAqL1xuXG5jb25zdCBib3JkZXJtYXRyaXhQYXJzZVRyZWUgPSAobWF0cml4LCBkZWxpbWl0ZXJzKSA9PiB7XG4gIGNvbnN0IGJvZHkgPSBtYXRyaXguYm9keTtcbiAgYm9keVswXS5zaGlmdCgpOyAvLyBkaXNwb3NlIG9mIHRvcCBsZWZ0IGNlbGxcblxuICAvLyBDcmVhdGUgYW4gYXJyYXkgZm9yIHRoZSBsZWZ0IGNvbHVtblxuICBjb25zdCBsZWZ0Q29sdW1uQm9keSA9IG5ldyBBcnJheShib2R5Lmxlbmd0aCAtIDEpLmZpbGwoKS5tYXAoKCkgPT4gW10pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBUaGUgdmlzaWJsZSBwYXJ0IG9mIHRoZSBjZWxsXG4gICAgbGVmdENvbHVtbkJvZHlbaSAtIDFdLnB1c2goYm9keVtpXS5zaGlmdCgpKTtcbiAgICAvLyBBIHZwaGFudG9tIHdpdGggY29udGVudHMgZnJvbSB0aGUgcG1hdHJpeCwgdG8gc2V0IG1pbmltdW0gY2VsbCBoZWlnaHRcbiAgICBjb25zdCBwaGFudG9tQm9keSA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYm9keVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgcGhhbnRvbUJvZHkucHVzaChzdHJ1Y3R1cmVkQ2xvbmUoYm9keVtpXVtqXSkpO1xuICAgIH1cbiAgICBsZWZ0Q29sdW1uQm9keVtpIC0gMV0ucHVzaChwaGFudG9tKHBoYW50b21Cb2R5LCBcInZwaGFudG9tXCIpKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbiBhcnJheSBmb3IgdGhlIHRvcCByb3dcbiAgY29uc3QgdG9wUm93Qm9keSA9IG5ldyBBcnJheShib2R5Lmxlbmd0aCkuZmlsbCgpLm1hcCgoKSA9PiBbXSk7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgYm9keVswXS5sZW5ndGg7IGorKykge1xuICAgIHRvcFJvd0JvZHlbMF0ucHVzaChzdHJ1Y3R1cmVkQ2xvbmUoYm9keVswXVtqXSkpO1xuICB9XG4gIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHBtYXRyaXgsIGJ1dCBzcXVhc2hlZCB2aWEgXFxocGhhbnRvbVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJvZHlbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHRvcFJvd0JvZHlbaV0ucHVzaChwaGFudG9tKHN0cnVjdHVyZWRDbG9uZShib2R5W2ldW2pdKS5ib2R5LCBcImhwaGFudG9tXCIpKTtcbiAgICB9XG4gIH1cblxuICAvLyBTcXVhc2ggdGhlIHRvcCByb3cgb2YgdGhlIG1haW4ge3BtYXRyaXh9XG4gIGZvciAobGV0IGogPSAwOyBqIDwgYm9keVswXS5sZW5ndGg7IGorKykge1xuICAgIGJvZHlbMF1bal0gPSBwaGFudG9tKHN0cnVjdHVyZWRDbG9uZShib2R5WzBdW2pdKS5ib2R5LCBcImhwaGFudG9tXCIpO1xuICB9XG5cbiAgLy8gTm93IHdyYXAgdGhlIGFycmF5cyBpbiB0aGUgcHJvcGVyIHBhcnNlIG5vZGVzLlxuXG4gIGNvbnN0IGxlZnRDb2x1bW4gPSB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGJvZHk6IGxlZnRDb2x1bW5Cb2R5LFxuICAgIGNvbHM6IFt7IHR5cGU6IFwiYWxpZ25cIiwgYWxpZ246IFwiY1wiIH1dLFxuICAgIHJvd0dhcHM6IG5ldyBBcnJheShsZWZ0Q29sdW1uQm9keS5sZW5ndGggLSAxKS5maWxsKG51bGwpLFxuICAgIGhMaW5lc0JlZm9yZVJvdzogbmV3IEFycmF5KGxlZnRDb2x1bW5Cb2R5Lmxlbmd0aCArIDEpLmZpbGwoKS5tYXAoKCkgPT4gW10pLFxuICAgIGVudkNsYXNzZXM6IFtdLFxuICAgIHNjcmlwdExldmVsOiBcInRleHRcIixcbiAgICBhcnJheXN0cmV0Y2g6IDEsXG4gICAgbGFiZWxzOiBuZXcgQXJyYXkobGVmdENvbHVtbkJvZHkubGVuZ3RoKS5maWxsKFwiXCIpLFxuICAgIGFycmF5Y29sc2VwOiB7IFwibnVtYmVyXCI6IDAuMDQsIHVuaXQ6IFwiZW1cIiB9XG4gIH07XG5cbiAgY29uc3QgdG9wUm93ID0ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBib2R5OiB0b3BSb3dCb2R5LFxuICAgIGNvbHM6IG5ldyBBcnJheSh0b3BSb3dCb2R5Lmxlbmd0aCkuZmlsbCh7IHR5cGU6IFwiYWxpZ25cIiwgYWxpZ246IFwiY1wiIH0pLFxuICAgIHJvd0dhcHM6IG5ldyBBcnJheSh0b3BSb3dCb2R5Lmxlbmd0aCAtIDEpLmZpbGwobnVsbCksXG4gICAgaExpbmVzQmVmb3JlUm93OiBuZXcgQXJyYXkodG9wUm93Qm9keS5sZW5ndGggKyAxKS5maWxsKCkubWFwKCgpID0+IFtdKSxcbiAgICBlbnZDbGFzc2VzOiBbXSxcbiAgICBzY3JpcHRMZXZlbDogXCJ0ZXh0XCIsXG4gICAgYXJyYXlzdHJldGNoOiAxLFxuICAgIGxhYmVsczogbmV3IEFycmF5KHRvcFJvd0JvZHkubGVuZ3RoKS5maWxsKFwiXCIpLFxuICAgIGFycmF5Y29sc2VwOiBudWxsXG4gIH07XG5cbiAgY29uc3QgdG9wV3JhcHBlciA9IHtcbiAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBzY3JpcHRMZXZlbDogXCJ0ZXh0XCIsIC8vIE11c3Qgc2V0IHRoaXMgZXhwbGljaXRseS5cbiAgICBib2R5OiBbdG9wUm93XSAgICAgICAvLyBEZWZhdWx0IGxldmVsIGlzIFwic2NyaXB0XCIuXG4gIH07XG5cbiAgY29uc3QgY29udGFpbmVyID0ge1xuICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgYm9keTogW21hdHJpeF0sXG4gICAgbGVmdDogZGVsaW1pdGVycyA/IGRlbGltaXRlcnNbMF0gOiBcIihcIixcbiAgICByaWdodDogZGVsaW1pdGVycyA/IGRlbGltaXRlcnNbMV0gOiBcIilcIixcbiAgICByaWdodENvbG9yOiB1bmRlZmluZWRcbiAgfTtcblxuICBjb25zdCBiYXNlID0ge1xuICAgIHR5cGU6IFwib3BcIiwgICAvLyBUaGUgYmFzZSBvZiBhIFRlWCBcXG92ZXJzZXRcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBsaW1pdHM6IHRydWUsXG4gICAgYWx3YXlzSGFuZGxlU3VwU3ViOiB0cnVlLFxuICAgIHBhcmVudElzU3VwU3ViOiB0cnVlLFxuICAgIHN5bWJvbDogZmFsc2UsXG4gICAgc3RhY2s6IHRydWUsXG4gICAgc3VwcHJlc3NCYXNlU2hpZnQ6IHRydWUsXG4gICAgYm9keTogW2NvbnRhaW5lcl1cbiAgfTtcblxuICBjb25zdCBtb3ZlciA9IHtcbiAgICB0eXBlOiBcInN1cHN1YlwiLCAgLy8gV2UncmUgdXNpbmcgdGhlIE1hdGhNTCBlcXVpdmFsZW50XG4gICAgbW9kZTogXCJtYXRoXCIsICAgIC8vIG9mIFRlWCBcXG92ZXJzZXQuXG4gICAgYmFzZTogYmFzZSwgICAgICAvLyBUaGF0IGtlZXBzIHRoZSB7cG1hdHJpeH0gYWxpZ25lZCB3aXRoXG4gICAgc3VwOiB0b3BXcmFwcGVyLCAvLyB0aGUgbWF0aCBjZW50ZXJsaW5lLlxuICAgIHN1YjogbnVsbFxuICB9O1xuXG4gIHJldHVybiBvcmRHcm91cChbbGVmdENvbHVtbiwgbW92ZXJdKVxufTtcblxuLyoqXG4gKiBMZXhpbmcgb3IgcGFyc2luZyBwb3NpdGlvbmFsIGluZm9ybWF0aW9uIGZvciBlcnJvciByZXBvcnRpbmcuXG4gKiBUaGlzIG9iamVjdCBpcyBpbW11dGFibGUuXG4gKi9cbmNsYXNzIFNvdXJjZUxvY2F0aW9uIHtcbiAgY29uc3RydWN0b3IobGV4ZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLmxleGVyID0gbGV4ZXI7IC8vIExleGVyIGhvbGRpbmcgdGhlIGlucHV0IHN0cmluZy5cbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7IC8vIFN0YXJ0IG9mZnNldCwgemVyby1iYXNlZCBpbmNsdXNpdmUuXG4gICAgdGhpcy5lbmQgPSBlbmQ7ICAgICAvLyBFbmQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGV4Y2x1c2l2ZS5cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZXMgdHdvIGBTb3VyY2VMb2NhdGlvbmBzIGZyb20gbG9jYXRpb24gcHJvdmlkZXJzLCBnaXZlbiB0aGV5IGFyZVxuICAgKiBwcm92aWRlZCBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLlxuICAgKiAtIFJldHVybnMgdGhlIGZpcnN0IG9uZSdzIGxvY2F0aW9uIGlmIG9ubHkgdGhlIGZpcnN0IGlzIHByb3ZpZGVkLlxuICAgKiAtIFJldHVybnMgYSBtZXJnZWQgcmFuZ2Ugb2YgdGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBpZiBib3RoIGFyZSBwcm92aWRlZFxuICAgKiAgIGFuZCB0aGVpciBsZXhlcnMgbWF0Y2guXG4gICAqIC0gT3RoZXJ3aXNlLCByZXR1cm5zIG51bGwuXG4gICAqL1xuICBzdGF0aWMgcmFuZ2UoZmlyc3QsIHNlY29uZCkge1xuICAgIGlmICghc2Vjb25kKSB7XG4gICAgICByZXR1cm4gZmlyc3QgJiYgZmlyc3QubG9jO1xuICAgIH0gZWxzZSBpZiAoIWZpcnN0IHx8ICFmaXJzdC5sb2MgfHwgIXNlY29uZC5sb2MgfHwgZmlyc3QubG9jLmxleGVyICE9PSBzZWNvbmQubG9jLmxleGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBTb3VyY2VMb2NhdGlvbihmaXJzdC5sb2MubGV4ZXIsIGZpcnN0LmxvYy5zdGFydCwgc2Vjb25kLmxvYy5lbmQpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEludGVyZmFjZSByZXF1aXJlZCB0byBicmVhayBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gVG9rZW4sIExleGVyLCBhbmRcbiAqIFBhcnNlRXJyb3IuXG4gKi9cblxuLyoqXG4gKiBUaGUgcmVzdWx0aW5nIHRva2VuIHJldHVybmVkIGZyb20gYGxleGAuXG4gKlxuICogSXQgY29uc2lzdHMgb2YgdGhlIHRva2VuIHRleHQgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGlzIGVzc2VudGlhbGx5IGEgcmFuZ2UgaW4gYW4gaW5wdXQgc3RyaW5nLFxuICogYnV0IGluc3RlYWQgb2YgcmVmZXJlbmNpbmcgdGhlIGJhcmUgaW5wdXQgc3RyaW5nLCB3ZSByZWZlciB0byB0aGUgbGV4ZXIuXG4gKiBUaGF0IHdheSBpdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggZXh0cmEgbWV0YWRhdGEgdG8gdGhlIGlucHV0IHN0cmluZyxcbiAqIGxpa2UgZm9yIGV4YW1wbGUgYSBmaWxlIG5hbWUgb3Igc2ltaWxhci5cbiAqXG4gKiBUaGUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgb3B0aW9uYWwsIHNvIGl0IGlzIE9LIHRvIGNvbnN0cnVjdCBzeW50aGV0aWNcbiAqIHRva2VucyBpZiBhcHByb3ByaWF0ZS4gTm90IHByb3ZpZGluZyBhdmFpbGFibGUgcG9zaXRpb24gaW5mb3JtYXRpb24gbWF5XG4gKiBsZWFkIHRvIGRlZ3JhZGVkIGVycm9yIHJlcG9ydGluZywgdGhvdWdoLlxuICovXG5jbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHRleHQsIC8vIHRoZSB0ZXh0IG9mIHRoaXMgdG9rZW5cbiAgICBsb2NcbiAgKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLmxvYyA9IGxvYztcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIHBhaXIgb2YgdG9rZW5zICh0aGlzIGFuZCBlbmRUb2tlbiksIGNvbXB1dGUgYSBgVG9rZW5gIGVuY29tcGFzc2luZ1xuICAgKiB0aGUgd2hvbGUgaW5wdXQgcmFuZ2UgZW5jbG9zZWQgYnkgdGhlc2UgdHdvLlxuICAgKi9cbiAgcmFuZ2UoXG4gICAgZW5kVG9rZW4sIC8vIGxhc3QgdG9rZW4gb2YgdGhlIHJhbmdlLCBpbmNsdXNpdmVcbiAgICB0ZXh0IC8vIHRoZSB0ZXh0IG9mIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCB0b2tlblxuICApIHtcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIFNvdXJjZUxvY2F0aW9uLnJhbmdlKHRoaXMsIGVuZFRva2VuKSk7XG4gIH1cbn1cblxuLy8gSW4gVGVYLCB0aGVyZSBhcmUgYWN0dWFsbHkgdGhyZWUgc2V0cyBvZiBkaW1lbnNpb25zLCBvbmUgZm9yIGVhY2ggb2Zcbi8vIHRleHRzdHlsZSwgc2NyaXB0c3R5bGUsIGFuZCBzY3JpcHRzY3JpcHRzdHlsZS4gIFRoZXNlIGFyZVxuLy8gcHJvdmlkZWQgaW4gdGhlIHRoZSBhcnJheXMgYmVsb3csIGluIHRoYXQgb3JkZXIuXG4vL1xuXG4vLyBNYXRoIHN0eWxlIGlzIG5vdCBxdWl0ZSB0aGUgc2FtZSB0aGluZyBhcyBzY3JpcHQgbGV2ZWwuXG5jb25zdCBTdHlsZUxldmVsID0ge1xuICBESVNQTEFZOiAwLFxuICBURVhUOiAxLFxuICBTQ1JJUFQ6IDIsXG4gIFNDUklQVFNDUklQVDogM1xufTtcblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBnbG9iYWwvYnVpbHQtaW4gbWFjcm9zLlxuICogYG1hY3Jvcy5qc2AgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5IHZpYSBgbWFjcm9zLmpzYC5cbiAqL1xuY29uc3QgX21hY3JvcyA9IHt9O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIG1pZ2h0IG9uZSBkYXkgYWNjZXB0IGFuIGFkZGl0aW9uYWwgYXJndW1lbnQgYW5kIGRvIG1vcmUgdGhpbmdzLlxuZnVuY3Rpb24gZGVmaW5lTWFjcm8obmFtZSwgYm9keSkge1xuICBfbWFjcm9zW25hbWVdID0gYm9keTtcbn1cblxuLyoqXG4gKiBQcmVkZWZpbmVkIG1hY3JvcyBmb3IgVGVtbWwuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBzb21lIGNvbW1hbmRzIGluIHRlcm1zIG9mIG90aGVycy5cbiAqL1xuXG5jb25zdCBtYWNyb3MgPSBfbWFjcm9zO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYWNybyB0b29sc1xuXG5kZWZpbmVNYWNybyhcIlxcXFxub2V4cGFuZFwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIC8vIFRoZSBleHBhbnNpb24gaXMgdGhlIHRva2VuIGl0c2VsZjsgYnV0IHRoYXQgdG9rZW4gaXMgaW50ZXJwcmV0ZWRcbiAgLy8gYXMgaWYgaXRzIG1lYW5pbmcgd2VyZSDigJhcXHJlbGF44oCZIGlmIGl0IGlzIGEgY29udHJvbCBzZXF1ZW5jZSB0aGF0XG4gIC8vIHdvdWxkIG9yZGluYXJpbHkgYmUgZXhwYW5kZWQgYnkgVGVY4oCZcyBleHBhbnNpb24gcnVsZXMuXG4gIGNvbnN0IHQgPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIGlmIChjb250ZXh0LmlzRXhwYW5kYWJsZSh0LnRleHQpKSB7XG4gICAgdC5ub2V4cGFuZCA9IHRydWU7XG4gICAgdC50cmVhdEFzUmVsYXggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7IHRva2VuczogW3RdLCBudW1BcmdzOiAwIH07XG59KTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcZXhwYW5kYWZ0ZXJcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICAvLyBUZVggZmlyc3QgcmVhZHMgdGhlIHRva2VuIHRoYXQgY29tZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgXFxleHBhbmRhZnRlcixcbiAgLy8gd2l0aG91dCBleHBhbmRpbmcgaXQ7IGxldOKAmXMgY2FsbCB0aGlzIHRva2VuIHQuIFRoZW4gVGVYIHJlYWRzIHRoZVxuICAvLyB0b2tlbiB0aGF0IGNvbWVzIGFmdGVyIHQgKGFuZCBwb3NzaWJseSBtb3JlIHRva2VucywgaWYgdGhhdCB0b2tlblxuICAvLyBoYXMgYW4gYXJndW1lbnQpLCByZXBsYWNpbmcgaXQgYnkgaXRzIGV4cGFuc2lvbi4gRmluYWxseSBUZVggcHV0c1xuICAvLyB0IGJhY2sgaW4gZnJvbnQgb2YgdGhhdCBleHBhbnNpb24uXG4gIGNvbnN0IHQgPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIGNvbnRleHQuZXhwYW5kT25jZSh0cnVlKTsgLy8gZXhwYW5kIG9ubHkgYW4gZXhwYW5kYWJsZSB0b2tlblxuICByZXR1cm4geyB0b2tlbnM6IFt0XSwgbnVtQXJnczogMCB9O1xufSk7XG5cbi8vIExhVGVYJ3MgXFxAZmlyc3RvZnR3b3sjMX17IzJ9IGV4cGFuZHMgdG8gIzEsIHNraXBwaW5nICMyXG4vLyBUZVggc291cmNlOiBcXGxvbmdcXGRlZlxcQGZpcnN0b2Z0d28jMSMyeyMxfVxuZGVmaW5lTWFjcm8oXCJcXFxcQGZpcnN0b2Z0d29cIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcbiAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzBdLCBudW1BcmdzOiAwIH07XG59KTtcblxuLy8gTGFUZVgncyBcXEBzZWNvbmRvZnR3b3sjMX17IzJ9IGV4cGFuZHMgdG8gIzIsIHNraXBwaW5nICMxXG4vLyBUZVggc291cmNlOiBcXGxvbmdcXGRlZlxcQHNlY29uZG9mdHdvIzEjMnsjMn1cbmRlZmluZU1hY3JvKFwiXFxcXEBzZWNvbmRvZnR3b1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMV0sIG51bUFyZ3M6IDAgfTtcbn0pO1xuXG4vLyBMYVRlWCdzIFxcQGlmbmV4dGNoYXJ7IzF9eyMyfXsjM30gbG9va3MgYWhlYWQgdG8gdGhlIG5leHQgKHVuZXhwYW5kZWQpXG4vLyBzeW1ib2wgdGhhdCBpc24ndCBhIHNwYWNlLCBjb25zdW1pbmcgYW55IHNwYWNlcyBidXQgbm90IGNvbnN1bWluZyB0aGVcbi8vIGZpcnN0IG5vbnNwYWNlIGNoYXJhY3Rlci4gIElmIHRoYXQgbm9uc3BhY2UgY2hhcmFjdGVyIG1hdGNoZXMgIzEsIHRoZW5cbi8vIHRoZSBtYWNybyBleHBhbmRzIHRvICMyOyBvdGhlcndpc2UsIGl0IGV4cGFuZHMgdG8gIzMuXG5kZWZpbmVNYWNybyhcIlxcXFxAaWZuZXh0Y2hhclwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDMpOyAvLyBzeW1ib2wsIGlmLCBlbHNlXG4gIGNvbnRleHQuY29uc3VtZVNwYWNlcygpO1xuICBjb25zdCBuZXh0VG9rZW4gPSBjb250ZXh0LmZ1dHVyZSgpO1xuICBpZiAoYXJnc1swXS5sZW5ndGggPT09IDEgJiYgYXJnc1swXVswXS50ZXh0ID09PSBuZXh0VG9rZW4udGV4dCkge1xuICAgIHJldHVybiB7IHRva2VuczogYXJnc1sxXSwgbnVtQXJnczogMCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHRva2VuczogYXJnc1syXSwgbnVtQXJnczogMCB9O1xuICB9XG59KTtcblxuLy8gTGFUZVgncyBcXEBpZnN0YXJ7IzF9eyMyfSBsb29rcyBhaGVhZCB0byB0aGUgbmV4dCAodW5leHBhbmRlZCkgc3ltYm9sLlxuLy8gSWYgaXQgaXMgYCpgLCB0aGVuIGl0IGNvbnN1bWVzIHRoZSBzeW1ib2wsIGFuZCB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMTtcbi8vIG90aGVyd2lzZSwgdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzIgKHdpdGhvdXQgY29uc3VtaW5nIHRoZSBzeW1ib2wpLlxuLy8gVGVYIHNvdXJjZTogXFxkZWZcXEBpZnN0YXIjMXtcXEBpZm5leHRjaGFyICp7XFxAZmlyc3RvZnR3b3sjMX19fVxuZGVmaW5lTWFjcm8oXCJcXFxcQGlmc3RhclwiLCBcIlxcXFxAaWZuZXh0Y2hhciAqe1xcXFxAZmlyc3RvZnR3b3sjMX19XCIpO1xuXG4vLyBMYVRlWCdzIFxcVGV4dE9yTWF0aHsjMX17IzJ9IGV4cGFuZHMgdG8gIzEgaW4gdGV4dCBtb2RlLCAjMiBpbiBtYXRoIG1vZGVcbmRlZmluZU1hY3JvKFwiXFxcXFRleHRPck1hdGhcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTtcbiAgaWYgKGNvbnRleHQubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMF0sIG51bUFyZ3M6IDAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMV0sIG51bUFyZ3M6IDAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IHN0cmluZ0Zyb21BcmcgPSBhcmcgPT4ge1xuICAvLyBSZXZlcnNlIHRoZSBvcmRlciBvZiB0aGUgYXJnIGFuZCByZXR1cm4gYSBzdHJpbmcuXG4gIGxldCBzdHIgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gYXJnLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgc3RyICs9IGFyZ1tpXS50ZXh0O1xuICB9XG4gIHJldHVybiBzdHJcbn07XG5cbi8vIExvb2t1cCB0YWJsZSBmb3IgcGFyc2luZyBudW1iZXJzIGluIGJhc2UgOCB0aHJvdWdoIDE2XG5jb25zdCBkaWdpdFRvTnVtYmVyID0ge1xuICAwOiAwLFxuICAxOiAxLFxuICAyOiAyLFxuICAzOiAzLFxuICA0OiA0LFxuICA1OiA1LFxuICA2OiA2LFxuICA3OiA3LFxuICA4OiA4LFxuICA5OiA5LFxuICBhOiAxMCxcbiAgQTogMTAsXG4gIGI6IDExLFxuICBCOiAxMSxcbiAgYzogMTIsXG4gIEM6IDEyLFxuICBkOiAxMyxcbiAgRDogMTMsXG4gIGU6IDE0LFxuICBFOiAxNCxcbiAgZjogMTUsXG4gIEY6IDE1XG59O1xuXG5jb25zdCBuZXh0Q2hhck51bWJlciA9IGNvbnRleHQgPT4ge1xuICBjb25zdCBudW1TdHIgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG4gIGlmIChudW1TdHIgPT09IFwiRU9GXCIpIHsgcmV0dXJuIFtudWxsLCBcIlwiXSB9XG4gIHJldHVybiBbZGlnaXRUb051bWJlcltudW1TdHIuY2hhckF0KDApXSwgbnVtU3RyXVxufTtcblxuY29uc3QgYXBwZW5kQ2hhck51bWJlcnMgPSAobnVtYmVyLCBudW1TdHIsIGJhc2UpID0+IHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW1TdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaWdpdCA9IGRpZ2l0VG9OdW1iZXJbbnVtU3RyLmNoYXJBdChpKV07XG4gICAgbnVtYmVyICo9IGJhc2U7XG4gICAgbnVtYmVyICs9IGRpZ2l0O1xuICB9XG4gIHJldHVybiBudW1iZXJcbn07XG5cbi8vIFRlWCBcXGNoYXIgbWFrZXMgYSBsaXRlcmFsIGNoYXJhY3RlciAoY2F0Y29kZSAxMikgdXNpbmcgdGhlIGZvbGxvd2luZyBmb3Jtczpcbi8vIChzZWUgVGhlIFRlWEJvb2ssIHAuIDQzKVxuLy8gICBcXGNoYXIxMjMgIC0tIGRlY2ltYWxcbi8vICAgXFxjaGFyJzEyMyAtLSBvY3RhbFxuLy8gICBcXGNoYXJcIjEyMyAtLSBoZXhcbi8vICAgXFxjaGFyYHggICAtLSBjaGFyYWN0ZXIgdGhhdCBjYW4gYmUgd3JpdHRlbiAoaS5lLiBpc24ndCBhY3RpdmUpXG4vLyAgIFxcY2hhcmBcXHggIC0tIGNoYXJhY3RlciB0aGF0IGNhbm5vdCBiZSB3cml0dGVuIChlLmcuICUpXG4vLyBUaGVzZSBhbGwgcmVmZXIgdG8gY2hhcmFjdGVycyBmcm9tIHRoZSBmb250LCBzbyB3ZSB0dXJuIHRoZW0gaW50byBzcGVjaWFsXG4vLyBjYWxscyB0byBhIGZ1bmN0aW9uIFxcQGNoYXIgZGVhbHQgd2l0aCBpbiB0aGUgUGFyc2VyLlxuZGVmaW5lTWFjcm8oXCJcXFxcY2hhclwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGxldCB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgbGV0IGJhc2U7XG4gIGxldCBudW1iZXIgPSBcIlwiO1xuICBpZiAodG9rZW4udGV4dCA9PT0gXCInXCIpIHtcbiAgICBiYXNlID0gODtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSAnXCInKSB7XG4gICAgYmFzZSA9IDE2O1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09IFwiYFwiKSB7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gICAgaWYgKHRva2VuLnRleHRbMF0gPT09IFwiXFxcXFwiKSB7XG4gICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50ZXh0ID09PSBcIkVPRlwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFxjaGFyYCBtaXNzaW5nIGFyZ3VtZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJhc2UgPSAxMDtcbiAgfVxuICBpZiAoYmFzZSkge1xuICAgIC8vIFBhcnNlIGEgbnVtYmVyIGluIHRoZSBnaXZlbiBiYXNlLCBzdGFydGluZyB3aXRoIGZpcnN0IGB0b2tlbmAuXG4gICAgbGV0IG51bVN0ciA9IHRva2VuLnRleHQ7XG4gICAgbnVtYmVyID0gZGlnaXRUb051bWJlcltudW1TdHIuY2hhckF0KDApXTtcbiAgICBpZiAobnVtYmVyID09IG51bGwgfHwgbnVtYmVyID49IGJhc2UpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIGJhc2UtJHtiYXNlfSBkaWdpdCAke3Rva2VuLnRleHR9YCk7XG4gICAgfVxuICAgIG51bWJlciA9IGFwcGVuZENoYXJOdW1iZXJzKG51bWJlciwgbnVtU3RyLCBiYXNlKTtcbiAgICBsZXQgZGlnaXQ7XG4gICAgW2RpZ2l0LCBudW1TdHJdID0gbmV4dENoYXJOdW1iZXIoY29udGV4dCk7XG4gICAgd2hpbGUgKGRpZ2l0ICE9IG51bGwgJiYgZGlnaXQgPCBiYXNlKSB7XG4gICAgICBudW1iZXIgKj0gYmFzZTtcbiAgICAgIG51bWJlciArPSBkaWdpdDtcbiAgICAgIG51bWJlciA9IGFwcGVuZENoYXJOdW1iZXJzKG51bWJlciwgbnVtU3RyLCBiYXNlKTtcbiAgICAgIGNvbnRleHQucG9wVG9rZW4oKTtcbiAgICAgIFtkaWdpdCwgbnVtU3RyXSA9IG5leHRDaGFyTnVtYmVyKGNvbnRleHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYFxcXFxAY2hhcnske251bWJlcn19YDtcbn0pO1xuXG5mdW5jdGlvbiByZWNyZWF0ZUFyZ1N0cihjb250ZXh0KSB7XG4gIC8vIFJlY3JlYXRlIHRoZSBtYWNybydzIG9yaWdpbmFsIGFyZ3VtZW50IHN0cmluZyBmcm9tIHRoZSBhcnJheSBvZiBwYXJzZSB0b2tlbnMuXG4gIGNvbnN0IHRva2VucyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF07XG4gIGxldCBzdHIgPSBcIlwiO1xuICBsZXQgZXhwZWN0ZWRMb2MgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmxvYy5zdGFydDtcbiAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGFjdHVhbExvYyA9IHRva2Vuc1tpXS5sb2Muc3RhcnQ7XG4gICAgaWYgKGFjdHVhbExvYyA+IGV4cGVjdGVkTG9jKSB7XG4gICAgICAvLyBjb250ZXh0LmNvbnN1bWVBcmdzIGhhcyBlYXRlbiBhIHNwYWNlLlxuICAgICAgc3RyICs9IFwiIFwiO1xuICAgICAgZXhwZWN0ZWRMb2MgPSBhY3R1YWxMb2M7XG4gICAgfVxuICAgIHN0ciArPSB0b2tlbnNbaV0udGV4dDtcbiAgICBleHBlY3RlZExvYyArPSB0b2tlbnNbaV0udGV4dC5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG4vLyBUaGUgTGF0aW4gTW9kZXJuIGZvbnQgcmVuZGVycyA8bWk+4oiaPC9taT4gYXQgdGhlIHdyb25nIHZlcnRpY2FsIGFsaWdubWVudC5cbi8vIFRoaXMgbWFjcm8gcHJvdmlkZXMgYSBiZXR0ZXIgcmVuZGVyaW5nLlxuZGVmaW5lTWFjcm8oXCJcXFxcc3VyZFwiLCAnXFxcXHNxcnR7XFxcXHZwaGFudG9te3x9fScpO1xuXG4vLyBTZWUgY29tbWVudCBmb3IgXFxvcGx1cyBpbiBzeW1ib2xzLmpzLlxuZGVmaW5lTWFjcm8oXCJcXHUyMjk1XCIsIFwiXFxcXG9wbHVzXCIpO1xuXG4vLyBTaW5jZSBUZW1tbCBoYXMgbm8gXFxwYXIsIGlnbm9yZSBcXGxvbmcuXG5kZWZpbmVNYWNybyhcIlxcXFxsb25nXCIsIFwiXCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBHcm91cGluZ1xuLy8gXFxsZXRcXGJncm91cD17IFxcbGV0XFxlZ3JvdXA9fVxuZGVmaW5lTWFjcm8oXCJcXFxcYmdyb3VwXCIsIFwie1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVncm91cFwiLCBcIn1cIik7XG5cbi8vIFN5bWJvbHMgZnJvbSBsYXRleC5sdHg6XG4vLyBcXGRlZn57XFxub2JyZWFrc3BhY2V7fX1cbi8vIFxcZGVmXFxscXtgfVxuLy8gXFxkZWZcXHJxeyd9XG4vLyBcXGRlZiBcXGFhIHtcXHIgYX1cbmRlZmluZU1hY3JvKFwiflwiLCBcIlxcXFxub2JyZWFrc3BhY2VcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxscVwiLCBcImBcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxycVwiLCBcIidcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhYVwiLCBcIlxcXFxyIGFcIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXEJiYmtcIiwgXCJcXFxcQmJie2t9XCIpO1xuXG4vLyBcXG1hdGhzdHJ1dCBmcm9tIHRoZSBUZVhib29rLCBwIDM2MFxuZGVmaW5lTWFjcm8oXCJcXFxcbWF0aHN0cnV0XCIsIFwiXFxcXHZwaGFudG9teyh9XCIpO1xuXG4vLyBcXHVuZGVyYmFyIGZyb20gVGVYYm9vayBwIDM1M1xuZGVmaW5lTWFjcm8oXCJcXFxcdW5kZXJiYXJcIiwgXCJcXFxcdW5kZXJsaW5le1xcXFx0ZXh0eyMxfX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIExhVGVYXzLOtVxuXG4vLyBcXHZkb3Rze1xcdmJveHtcXGJhc2VsaW5lc2tpcDRcXHBAICBcXGxpbmVza2lwbGltaXRcXHpAXG4vLyBcXGtlcm42XFxwQFxcaGJveHsufVxcaGJveHsufVxcaGJveHsufX19XG4vLyBXZSdsbCBjYWxsIFxcdmFydmRvdHMsIHdoaWNoIGdldHMgYSBnbHlwaCBmcm9tIHN5bWJvbHMuanMuXG4vLyBUaGUgemVyby13aWR0aCBydWxlIGdldHMgdXMgYW4gZXF1aXZhbGVudCB0byB0aGUgdmVydGljYWwgNnB0IGtlcm4uXG5kZWZpbmVNYWNybyhcIlxcXFx2ZG90c1wiLCBcIntcXFxcdmFydmRvdHNcXFxccnVsZXswcHR9ezE1cHR9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFx1MjJlZVwiLCBcIlxcXFx2ZG90c1wiKTtcblxuLy8ge2FycmF5fSBlbnZpcm9ubWVudCBnYXBzXG5kZWZpbmVNYWNybyhcIlxcXFxhcnJheXN0cmV0Y2hcIiwgXCIxXCIpOyAgICAgLy8gbGluZSBzcGFjaW5nIGZhY3RvciB0aW1lcyAxMnB0XG5kZWZpbmVNYWNybyhcIlxcXFxhcnJheWNvbHNlcFwiLCBcIjZwdFwiKTsgICAgLy8gaGFsZiB0aGUgd2lkdGggc2VwYXJhdGluZyBjb2x1bW5zXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGFtc21hdGguc3R5XG4vLyBodHRwOi8vbWlycm9ycy5jb25jZXJ0cGFzcy5jb20vdGV4LWFyY2hpdmUvbWFjcm9zL2xhdGV4L3JlcXVpcmVkL2Ftc21hdGgvYW1zbWF0aC5wZGZcblxuLy9cXG5ld2NvbW1hbmR7XFxzdWJzdGFja31bMV17XFxzdWJhcnJheXtjfSMxXFxlbmRzdWJhcnJheX1cbmRlZmluZU1hY3JvKFwiXFxcXHN1YnN0YWNrXCIsIFwiXFxcXGJlZ2lue3N1YmFycmF5fXtjfSMxXFxcXGVuZHtzdWJhcnJheX1cIik7XG5cbi8vIFxcZGVmXFxpZmZ7XFxET1RTQlxcO1xcTG9uZ2xlZnRyaWdodGFycm93XFw7fVxuLy8gXFxkZWZcXGltcGxpZXN7XFxET1RTQlxcO1xcTG9uZ3JpZ2h0YXJyb3dcXDt9XG4vLyBcXGRlZlxcaW1wbGllZGJ5e1xcRE9UU0JcXDtcXExvbmdsZWZ0YXJyb3dcXDt9XG5kZWZpbmVNYWNybyhcIlxcXFxpZmZcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25nbGVmdHJpZ2h0YXJyb3dcXFxcO1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltcGxpZXNcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25ncmlnaHRhcnJvd1xcXFw7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1wbGllZGJ5XCIsIFwiXFxcXERPVFNCXFxcXDtcXFxcTG9uZ2xlZnRhcnJvd1xcXFw7XCIpO1xuXG4vLyBBTVNNYXRoJ3MgYXV0b21hdGljIFxcZG90cywgYmFzZWQgb24gXFxtZG90c0BAIG1hY3JvLlxuY29uc3QgZG90c0J5VG9rZW4gPSB7XG4gIFwiLFwiOiBcIlxcXFxkb3RzY1wiLFxuICBcIlxcXFxub3RcIjogXCJcXFxcZG90c2JcIixcbiAgLy8gXFxrZXliaW5AIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgXCIrXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiPVwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIjxcIjogXCJcXFxcZG90c2JcIixcbiAgXCI+XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiLVwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIipcIjogXCJcXFxcZG90c2JcIixcbiAgXCI6XCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNCOlxuICBcIlxcXFxET1RTQlwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxjb3Byb2RcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlndmVlXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3dlZGdlXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ3VwbHVzXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ2NhcFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdjdXBcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxccHJvZFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxzdW1cIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnb3RpbWVzXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ29wbHVzXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ29kb3RcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnc3FjYXBcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnc3FjdXBcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlndGltZXNcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcQW5kXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGxvbmdyaWdodGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXExvbmdyaWdodGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGxvbmdsZWZ0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxsb25nbGVmdHJpZ2h0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcTG9uZ2xlZnRyaWdodGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXG1hcHN0b1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxsb25nbWFwc3RvXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGhvb2tyaWdodGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGRvdGVxXCI6IFwiXFxcXGRvdHNiXCIsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXG1hdGhiaW46XG4gIFwiXFxcXG1hdGhiaW5cIjogXCJcXFxcZG90c2JcIixcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcbWF0aHJlbDpcbiAgXCJcXFxcbWF0aHJlbFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxyZWxiYXJcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcUmVsYmFyXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXHhyaWdodGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXHhsZWZ0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcRE9UU0k6XG4gIFwiXFxcXERPVFNJXCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXGludFwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxvaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXGlpbnRcIjogXCJcXFxcZG90c2lcIixcbiAgXCJcXFxcaWlpbnRcIjogXCJcXFxcZG90c2lcIixcbiAgXCJcXFxcaWlpaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXGlkb3RzaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcXERPVFNYOlxuICBcIlxcXFxET1RTWFwiOiBcIlxcXFxkb3RzeFwiXG59O1xuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgLy8gVE9ETzogSWYgdXNlZCBpbiB0ZXh0IG1vZGUsIHNob3VsZCBleHBhbmQgdG8gXFx0ZXh0ZWxsaXBzaXMuXG4gIC8vIEhvd2V2ZXIsIGluIFRlbW1sLCBcXHRleHRlbGxpcHNpcyBhbmQgXFxsZG90cyBiZWhhdmUgdGhlIHNhbWVcbiAgLy8gKGluIHRleHQgbW9kZSksIGFuZCBpdCdzIHVubGlrZWx5IHdlJ2Qgc2VlIGFueSBvZiB0aGUgbWF0aCBjb21tYW5kc1xuICAvLyB0aGF0IGFmZmVjdCB0aGUgYmVoYXZpb3Igb2YgXFxkb3RzIHdoZW4gaW4gdGV4dCBtb2RlLiAgU28gZmluZSBmb3Igbm93XG4gIC8vICh1bnRpbCB3ZSBzdXBwb3J0IFxcaWZtbW9kZSAuLi4gXFxlbHNlIC4uLiBcXGZpKS5cbiAgbGV0IHRoZWRvdHMgPSBcIlxcXFxkb3Rzb1wiO1xuICBjb25zdCBuZXh0ID0gY29udGV4dC5leHBhbmRBZnRlckZ1dHVyZSgpLnRleHQ7XG4gIGlmIChuZXh0IGluIGRvdHNCeVRva2VuKSB7XG4gICAgdGhlZG90cyA9IGRvdHNCeVRva2VuW25leHRdO1xuICB9IGVsc2UgaWYgKG5leHQuc2xpY2UoMCwgNCkgPT09IFwiXFxcXG5vdFwiKSB7XG4gICAgdGhlZG90cyA9IFwiXFxcXGRvdHNiXCI7XG4gIH0gZWxzZSBpZiAobmV4dCBpbiBzeW1ib2xzLm1hdGgpIHtcbiAgICBpZiAoW1wiYmluXCIsIFwicmVsXCJdLmluY2x1ZGVzKHN5bWJvbHMubWF0aFtuZXh0XS5ncm91cCkpIHtcbiAgICAgIHRoZWRvdHMgPSBcIlxcXFxkb3RzYlwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhlZG90cztcbn0pO1xuXG5jb25zdCBzcGFjZUFmdGVyRG90cyA9IHtcbiAgLy8gXFxyaWdodGRlbGltQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gIFwiKVwiOiB0cnVlLFxuICBcIl1cIjogdHJ1ZSxcbiAgXCJcXFxccmJyYWNrXCI6IHRydWUsXG4gIFwiXFxcXH1cIjogdHJ1ZSxcbiAgXCJcXFxccmJyYWNlXCI6IHRydWUsXG4gIFwiXFxcXHJhbmdsZVwiOiB0cnVlLFxuICBcIlxcXFxyY2VpbFwiOiB0cnVlLFxuICBcIlxcXFxyZmxvb3JcIjogdHJ1ZSxcbiAgXCJcXFxccmdyb3VwXCI6IHRydWUsXG4gIFwiXFxcXHJtb3VzdGFjaGVcIjogdHJ1ZSxcbiAgXCJcXFxccmlnaHRcIjogdHJ1ZSxcbiAgXCJcXFxcYmlnclwiOiB0cnVlLFxuICBcIlxcXFxiaWdnclwiOiB0cnVlLFxuICBcIlxcXFxCaWdyXCI6IHRydWUsXG4gIFwiXFxcXEJpZ2dyXCI6IHRydWUsXG4gIC8vIFxcZXh0cmFAIGFsc28gdGVzdHMgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICQ6IHRydWUsXG4gIC8vIFxcZXh0cmFwQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6XG4gIFwiO1wiOiB0cnVlLFxuICBcIi5cIjogdHJ1ZSxcbiAgXCIsXCI6IHRydWVcbn07XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNvXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgbmV4dCA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1wiO1xuICB9XG59KTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2NcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuICAvLyBcXGRvdHNjIHVzZXMgXFxleHRyYUAgYnV0IG5vdCBcXGV4dHJhcEAsIGluc3RlYWQgc3BlY2lhbGx5IGNoZWNraW5nIGZvclxuICAvLyAnOycgYW5kICcuJywgYnV0IGRvZXNuJ3QgY2hlY2sgZm9yICcsJy5cbiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMgJiYgbmV4dCAhPT0gXCIsXCIpIHtcbiAgICByZXR1cm4gXCJcXFxcbGRvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1wiO1xuICB9XG59KTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcY2RvdHNcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cykge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcXFxcLFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlxcXFxAY2RvdHNcIjtcbiAgfVxufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNiXCIsIFwiXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZG90c21cIiwgXCJcXFxcY2RvdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzaVwiLCBcIlxcXFwhXFxcXGNkb3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaWRvdHNpbnRcIiwgXCJcXFxcZG90c2lcIik7XG4vLyBhbXNtYXRoIGRvZXNuJ3QgYWN0dWFsbHkgZGVmaW5lIFxcZG90c3gsIGJ1dCBcXGRvdHMgZm9sbG93ZWQgYnkgYSBtYWNyb1xuLy8gc3RhcnRpbmcgd2l0aCBcXERPVFNYIGltcGxpZXMgXFxkb3RzbywgYW5kIHRoZW4gXFxleHRyYUAgZGV0ZWN0cyB0aGlzIGNhc2Vcbi8vIGFuZCBmb3JjZXMgdGhlIGFkZGVkIGBcXCxgLlxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c3hcIiwgXCJcXFxcbGRvdHNcXFxcLFwiKTtcblxuLy8gXFxsZXRcXERPVFNJXFxyZWxheFxuLy8gXFxsZXRcXERPVFNCXFxyZWxheFxuLy8gXFxsZXRcXERPVFNYXFxyZWxheFxuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU0lcIiwgXCJcXFxccmVsYXhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxET1RTQlwiLCBcIlxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNYXCIsIFwiXFxcXHJlbGF4XCIpO1xuXG4vLyBTcGFjaW5nLCBiYXNlZCBvbiBhbXNtYXRoLnN0eSdzIG92ZXJyaWRlIG9mIExhVGVYIGRlZmF1bHRzXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5ke1xcdG1zcGFjZX1bM117JVxuLy8gICBcXGlmbW1vZGVcXG1za2lwIzEjMlxcZWxzZVxca2VybiMxIzNcXGZpXFxyZWxheH1cbmRlZmluZU1hY3JvKFwiXFxcXHRtc3BhY2VcIiwgXCJcXFxcVGV4dE9yTWF0aHtcXFxca2VybiMxIzN9e1xcXFxtc2tpcCMxIzJ9XFxcXHJlbGF4XCIpO1xuLy8gXFxyZW5ld2NvbW1hbmR7XFwsfXtcXHRtc3BhY2UrXFx0aGlubXVza2lwey4xNjY3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlubXVza2lwXG5kZWZpbmVNYWNybyhcIlxcXFwsXCIsIFwie1xcXFx0bXNwYWNlK3szbXV9ey4xNjY3ZW19fVwiKTtcbi8vIFxcbGV0XFx0aGluc3BhY2VcXCxcbmRlZmluZU1hY3JvKFwiXFxcXHRoaW5zcGFjZVwiLCBcIlxcXFwsXCIpO1xuLy8gXFxkZWZcXD57XFxtc2tpcFxcbWVkbXVza2lwfVxuLy8gXFxyZW5ld2NvbW1hbmR7XFw6fXtcXHRtc3BhY2UrXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBcXD4gYW5kIG1hdGggbW9kZSBvZiBcXDogc2hvdWxkIHVzZSBcXG1lZG11c2tpcCA9IDRtdSBwbHVzIDJtdSBtaW51cyA0bXVcbmRlZmluZU1hY3JvKFwiXFxcXD5cIiwgXCJcXFxcbXNraXB7NG11fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXDpcIiwgXCJ7XFxcXHRtc3BhY2UrezRtdX17LjIyMjJlbX19XCIpO1xuLy8gXFxsZXRcXG1lZHNwYWNlXFw6XG5kZWZpbmVNYWNybyhcIlxcXFxtZWRzcGFjZVwiLCBcIlxcXFw6XCIpO1xuLy8gXFxyZW5ld2NvbW1hbmR7XFw7fXtcXHRtc3BhY2UrXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXAgPSA1bXUgcGx1cyA1bXVcbmRlZmluZU1hY3JvKFwiXFxcXDtcIiwgXCJ7XFxcXHRtc3BhY2UrezVtdX17LjI3NzdlbX19XCIpO1xuLy8gXFxsZXRcXHRoaWNrc3BhY2VcXDtcbmRlZmluZU1hY3JvKFwiXFxcXHRoaWNrc3BhY2VcIiwgXCJcXFxcO1wiKTtcbi8vIFxccmVuZXdjb21tYW5ke1xcIX17XFx0bXNwYWNlLVxcdGhpbm11c2tpcHsuMTY2N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpbm11c2tpcFxuZGVmaW5lTWFjcm8oXCJcXFxcIVwiLCBcIntcXFxcdG1zcGFjZS17M211fXsuMTY2N2VtfX1cIik7XG4vLyBcXGxldFxcbmVndGhpbnNwYWNlXFwhXG5kZWZpbmVNYWNybyhcIlxcXFxuZWd0aGluc3BhY2VcIiwgXCJcXFxcIVwiKTtcbi8vIFxcbmV3Y29tbWFuZHtcXG5lZ21lZHNwYWNlfXtcXHRtc3BhY2UtXFxtZWRtdXNraXB7LjIyMjJlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXG1lZG11c2tpcFxuZGVmaW5lTWFjcm8oXCJcXFxcbmVnbWVkc3BhY2VcIiwgXCJ7XFxcXHRtc3BhY2UtezRtdX17LjIyMjJlbX19XCIpO1xuLy8gXFxuZXdjb21tYW5ke1xcbmVndGhpY2tzcGFjZX17XFx0bXNwYWNlLVxcdGhpY2ttdXNraXB7LjI3NzdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaWNrbXVza2lwXG5kZWZpbmVNYWNybyhcIlxcXFxuZWd0aGlja3NwYWNlXCIsIFwie1xcXFx0bXNwYWNlLXs1bXV9ey4yNzdlbX19XCIpO1xuLy8gXFxkZWZcXGVuc3BhY2V7XFxrZXJuLjVlbSB9XG5kZWZpbmVNYWNybyhcIlxcXFxlbnNwYWNlXCIsIFwiXFxcXGtlcm4uNWVtIFwiKTtcbi8vIFxcZGVmXFxlbnNraXB7XFxoc2tpcC41ZW1cXHJlbGF4fVxuZGVmaW5lTWFjcm8oXCJcXFxcZW5za2lwXCIsIFwiXFxcXGhza2lwLjVlbVxcXFxyZWxheFwiKTtcbi8vIFxcZGVmXFxxdWFke1xcaHNraXAxZW1cXHJlbGF4fVxuZGVmaW5lTWFjcm8oXCJcXFxccXVhZFwiLCBcIlxcXFxoc2tpcDFlbVxcXFxyZWxheFwiKTtcbi8vIFxcZGVmXFxxcXVhZHtcXGhza2lwMmVtXFxyZWxheH1cbmRlZmluZU1hY3JvKFwiXFxcXHFxdWFkXCIsIFwiXFxcXGhza2lwMmVtXFxcXHJlbGF4XCIpO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxBQVwiLCBcIlxcXFxUZXh0T3JNYXRoe1xcXFxBbmdzdHJvbX17XFxcXG1hdGhyaW5ne0F9fVxcXFxyZWxheFwiKTtcblxuLy8gXFx0YWdAaW5AZGlzcGxheSBmb3JtIG9mIFxcdGFnXG5kZWZpbmVNYWNybyhcIlxcXFx0YWdcIiwgXCJcXFxcQGlmc3RhclxcXFx0YWdAbGl0ZXJhbFxcXFx0YWdAcGFyZW5cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0YWdAcGFyZW5cIiwgXCJcXFxcdGFnQGxpdGVyYWx7KHsjMX0pfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRhZ0BsaXRlcmFsXCIsIChjb250ZXh0KSA9PiB7XG4gIGlmIChjb250ZXh0Lm1hY3Jvcy5nZXQoXCJcXFxcZGZAdGFnXCIpKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJNdWx0aXBsZSBcXFxcdGFnXCIpO1xuICB9XG4gIHJldHVybiBcIlxcXFxnZGVmXFxcXGRmQHRhZ3tcXFxcdGV4dHsjMX19XCI7XG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vdGFnXCIsIFwiXFxcXG5vbnVtYmVyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbm9udW1iZXJcIiwgXCJcXFxcZ2RlZlxcXFxAZXFuc3d7MH1cIik7XG5cbi8vIFxccmVuZXdjb21tYW5ke1xcYm1vZH17XFxub25zY3JpcHRcXG1za2lwLVxcbWVkbXVza2lwXFxta2VybjVtdVxcbWF0aGJpblxuLy8gICB7XFxvcGVyYXRvckBmb250IG1vZH1cXHBlbmFsdHk5MDBcbi8vICAgXFxta2VybjVtdVxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcH1cbi8vIFxcbmV3Y29tbWFuZHtcXHBvZH1bMV17XFxhbGxvd2JyZWFrXG4vLyAgIFxcaWZAZGlzcGxheVxcbWtlcm4xOG11XFxlbHNlXFxta2VybjhtdVxcZmkoIzEpfVxuLy8gXFxyZW5ld2NvbW1hbmR7XFxwbW9kfVsxXXtcXHBvZHt7XFxvcGVyYXRvckBmb250IG1vZH1cXG1rZXJuNm11IzF9fVxuLy8gXFxuZXdjb21tYW5ke1xcbW9kfVsxXXtcXGFsbG93YnJlYWtcXGlmQGRpc3BsYXlcXG1rZXJuMThtdVxuLy8gICBcXGVsc2VcXG1rZXJuMTJtdVxcZml7XFxvcGVyYXRvckBmb250IG1vZH1cXCxcXCwjMX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcbWVkbXVza2lwID0gNG11IHBsdXMgMm11IG1pbnVzIDRtdVxuZGVmaW5lTWFjcm8oXCJcXFxcYm1vZFwiLCBcIlxcXFxtYXRoYmlue1xcXFx0ZXh0e21vZH19XCIpO1xuZGVmaW5lTWFjcm8oXG4gIFwiXFxcXHBvZFwiLFxuICBcIlxcXFxhbGxvd2JyZWFrXCIgKyBcIlxcXFxtYXRoY2hvaWNle1xcXFxta2VybjE4bXV9e1xcXFxta2VybjhtdX17XFxcXG1rZXJuOG11fXtcXFxcbWtlcm44bXV9KCMxKVwiXG4pO1xuZGVmaW5lTWFjcm8oXCJcXFxccG1vZFwiLCBcIlxcXFxwb2R7e1xcXFxybSBtb2R9XFxcXG1rZXJuNm11IzF9XCIpO1xuZGVmaW5lTWFjcm8oXG4gIFwiXFxcXG1vZFwiLFxuICBcIlxcXFxhbGxvd2JyZWFrXCIgK1xuICAgIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuMThtdX17XFxcXG1rZXJuMTJtdX17XFxcXG1rZXJuMTJtdX17XFxcXG1rZXJuMTJtdX1cIiArXG4gICAgXCJ7XFxcXHJtIG1vZH1cXFxcLFxcXFwsIzFcIlxuKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTGFUZVggc291cmNlMmVcblxuLy8gXFxleHBhbmRhZnRlclxcbGV0XFxleHBhbmRhZnRlclxcQG5vcm1hbGNyXG4vLyAgICAgXFxjc25hbWVcXGV4cGFuZGFmdGVyXFxAZ29iYmxlXFxzdHJpbmdcXFxcIFxcZW5kY3NuYW1lXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXFxuZXdsaW5le1xcQG5vcm1hbGNyXFxyZWxheH1cbmRlZmluZU1hY3JvKFwiXFxcXG5ld2xpbmVcIiwgXCJcXFxcXFxcXFxcXFxyZWxheFwiKTtcblxuLy8gXFxkZWZcXFRlWHtUXFxrZXJuLS4xNjY3ZW1cXGxvd2VyLjVleFxcaGJveHtFfVxca2Vybi0uMTI1ZW1YXFxAfVxuLy8gVE9ETzogRG9lc24ndCBub3JtYWxseSB3b3JrIGluIG1hdGggbW9kZSBiZWNhdXNlIFxcQCBmYWlscy5cbmRlZmluZU1hY3JvKFwiXFxcXFRlWFwiLCBcIlxcXFx0ZXh0cm17VH1cXFxca2Vybi0uMTY2N2VtXFxcXHJhaXNlYm94ey0uNWV4fXtFfVxcXFxrZXJuLS4xMjVlbVxcXFx0ZXh0cm17WH1cIik7XG5cbmRlZmluZU1hY3JvKFxuICBcIlxcXFxMYVRlWFwiLFxuICAgIFwiXFxcXHRleHRybXtMfVxcXFxrZXJuLS4zNWVtXFxcXHJhaXNlYm94ezAuMmVtfXtcXFxcc2NyaXB0c3R5bGUgQX1cXFxca2Vybi0uMTVlbVxcXFxUZVhcIlxuKTtcblxuZGVmaW5lTWFjcm8oXG4gIFwiXFxcXFRlbW1sXCIsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIFwiXFxcXHRleHRybXtUfVxcXFxrZXJuLTAuMmVtXFxcXGxvd2VyezAuMmVtfXtcXFxcdGV4dHJte0V9fVxcXFxrZXJuLTAuMDhlbXtcXFxcdGV4dHJte019XFxcXGtlcm4tMC4wOGVtXFxcXHJhaXNlezAuMmVtfVxcXFx0ZXh0cm17TX1cXFxca2Vybi0wLjA4ZW1cXFxcdGV4dHJte0x9fVwiXG4pO1xuXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXFxoc3BhY2V7XFxAaWZzdGFyXFxAaHNwYWNlclxcQGhzcGFjZX1cbi8vIFxcZGVmXFxAaHNwYWNlIzF7XFxoc2tpcCAgIzFcXHJlbGF4fVxuLy8gXFxkZWZcXEBoc3BhY2VyIzF7XFx2cnVsZSBcXEB3aWR0aFxcekBcXG5vYnJlYWtcbi8vICAgICAgICAgICAgICAgICBcXGhza2lwICMxXFxoc2tpcCBcXHpAc2tpcH1cbmRlZmluZU1hY3JvKFwiXFxcXGhzcGFjZVwiLCBcIlxcXFxAaWZzdGFyXFxcXEBoc3BhY2VyXFxcXEBoc3BhY2VcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxAaHNwYWNlXCIsIFwiXFxcXGhza2lwICMxXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQGhzcGFjZXJcIiwgXCJcXFxccnVsZXswcHR9ezBwdH1cXFxcaHNraXAgIzFcXFxccmVsYXhcIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uXCIsIGBcXFxcbWF0aHB1bmN0e1xcXFxjaGFyXCIzYX1gKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gbWF0aHRvb2xzLnN0eVxuXG5kZWZpbmVNYWNybyhcIlxcXFxwcmVzY3JpcHRcIiwgXCJcXFxccHJlc0BjcmlwdHtfeyMxfV57IzJ9fXt9eyMzfVwiKTtcblxuLy9cXHByb3ZpZGVjb21tYW5kXFxvcmRpbmFyeWNvbG9uezp9XG5kZWZpbmVNYWNybyhcIlxcXFxvcmRpbmFyeWNvbG9uXCIsIGBcXFxcY2hhclwiM2FgKTtcbi8vIFJhaXNlIHRvIGNlbnRlciBvbiB0aGUgbWF0aCBheGlzLCBhcyBjbG9zZWx5IGFzIHBvc3NpYmxlLlxuZGVmaW5lTWFjcm8oXCJcXFxcdmNlbnRjb2xvblwiLCBcIlxcXFxtYXRocmVse1xcXFxyYWlzZWJveHswLjAzNWVtfXtcXFxcb3JkaW5hcnljb2xvbn19XCIpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uZXF7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcVwiLCAnXFxcXG1hdGhyZWx7XFxcXHJhaXNlYm94ezAuMDM1ZW19e1xcXFxvcmRpbmFyeWNvbG9ufVxcXFxjaGFyXCIyMjEyfScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uZXF7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcbWF0aHJlbHstfX1cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uZXFcIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIyMjM3XFxcXGNoYXJcIjIyMTJ9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcRXFxY29sb257PVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcZGJsY29sb259XG5kZWZpbmVNYWNybyhcIlxcXFxFcXFjb2xvblwiLCAnXFxcXG1hdGhyZWx7XFxcXGNoYXJcIjNkXFxcXGNoYXJcIjIyMzd9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcRXFjb2xvbntcXG1hdGhyZWx7LX1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufVxuZGVmaW5lTWFjcm8oXCJcXFxcRXFjb2xvblwiLCAnXFxcXG1hdGhyZWx7XFxcXGNoYXJcIjIyMTJcXFxcY2hhclwiMjIzN30nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbmFwcHJveHtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGFwcHJveH1cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uYXBwcm94XCIsICdcXFxcbWF0aHJlbHtcXFxccmFpc2Vib3h7MC4wMzVlbX17XFxcXG9yZGluYXJ5Y29sb259XFxcXGNoYXJcIjIyNDh9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25hcHByb3h7XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuZGVmaW5lTWFjcm8oXCJcXFxcQ29sb25hcHByb3hcIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIyMjM3XFxcXGNoYXJcIjIyNDh9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25zaW17XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbnNpbVwiLCAnXFxcXG1hdGhyZWx7XFxcXHJhaXNlYm94ezAuMDM1ZW19e1xcXFxvcmRpbmFyeWNvbG9ufVxcXFxjaGFyXCIyMjNjfScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXENvbG9uc2lte1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHNpbX1cbmRlZmluZU1hY3JvKFwiXFxcXENvbG9uc2ltXCIsICdcXFxcbWF0aHJlbHtcXFxccmFpc2Vib3h7MC4wMzVlbX17XFxcXG9yZGluYXJ5Y29sb259XFxcXGNoYXJcIjIyM2N9Jyk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbG9uZXF1YWxzLnN0eVxuXG4vLyBBbHRlcm5hdGUgbmFtZXMgZm9yIG1hdGh0b29scydzIG1hY3JvczpcbmRlZmluZU1hY3JvKFwiXFxcXHJhdGlvXCIsIFwiXFxcXHZjZW50Y29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uXCIsIFwiXFxcXGRibGNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25lcXVhbHNcIiwgXCJcXFxcY29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uZXF1YWxzXCIsIFwiXFxcXENvbG9uZXFxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXF1YWxzY29sb25cIiwgXCJcXFxcZXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvbmNvbG9uXCIsIFwiXFxcXEVxcWNvbG9uXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25taW51c1wiLCBcIlxcXFxjb2xvbmVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbm1pbnVzXCIsIFwiXFxcXENvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uXCIsIFwiXFxcXGVxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtaW51c2NvbG9uY29sb25cIiwgXCJcXFxcRXFjb2xvblwiKTtcbi8vIFxcY29sb25hcHByb3ggbmFtZSBpcyBzYW1lIGluIG1hdGh0b29scyBhbmQgY29sb25lcXVhbHMuXG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9uYXBwcm94XCIsIFwiXFxcXENvbG9uYXBwcm94XCIpO1xuLy8gXFxjb2xvbnNpbSBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25zaW1cIiwgXCJcXFxcQ29sb25zaW1cIik7XG5cbi8vIFByZXNlbnQgaW4gbmV3dHhtYXRoLCBweGZvbnRzIGFuZCB0eGZvbnRzXG5kZWZpbmVNYWNybyhcIlxcXFxub3RuaVwiLCBcIlxcXFxtYXRocmVse1xcXFxjaGFyYFxcdTIyMEN9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGltc3VwXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7bGltXFxcXCxzdXB9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGltaW5mXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7bGltXFxcXCxpbmZ9XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBGcm9tIGFtc29wbi5zdHlcbmRlZmluZU1hY3JvKFwiXFxcXGluamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2lualxcXFwsbGltfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHByb2psaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntwcm9qXFxcXCxsaW19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFybGltc3VwXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXG92ZXJsaW5le1xcXFx0ZXh0e2xpbX19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmxpbWluZlwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe1xcXFx1bmRlcmxpbmV7XFxcXHRleHR7bGltfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyaW5qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVycmlnaHRhcnJvd3tcXFxcdGV4dHtsaW19fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJwcm9qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVybGVmdGFycm93e1xcXFx0ZXh0e2xpbX19fVwiKTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcY2VudGVyZG90XCIsIFwie1xcXFxtZWRzcGFjZVxcXFxydWxlezAuMTY3ZW19ezAuMTg5ZW19XFxcXG1lZHNwYWNlfVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gc3RhdG1hdGguc3R5XG4vLyBodHRwczovL2N0YW4ubWF0aC5pbGxpbm9pcy5lZHUvbWFjcm9zL2xhdGV4L2NvbnRyaWIvc3RhdG1hdGgvc3RhdG1hdGgucGRmXG5cbmRlZmluZU1hY3JvKFwiXFxcXGFyZ21pblwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2FyZ1xcXFwsbWlufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFyZ21heFwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe2FyZ1xcXFwsbWF4fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBsaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntwbGltfVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTW5TeW1ib2wuc3R5XG5cbmRlZmluZU1hY3JvKFwiXFxcXGxlZnRtb2RlbHNcIiwgXCJcXFxcbWF0aG9we1xcXFxyZWZsZWN0Ym94eyRcXFxcbW9kZWxzJH19XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBicmFrZXQuc3R5XG4vLyBodHRwOi8vY3Rhbi5tYXRoLndhc2hpbmd0b24uZWR1L3RleC1hcmNoaXZlL21hY3Jvcy9sYXRleC9jb250cmliL2JyYWtldC9icmFrZXQucGRmXG5cbmRlZmluZU1hY3JvKFwiXFxcXGJyYVwiLCBcIlxcXFxtYXRoaW5uZXJ7XFxcXGxhbmdsZXsjMX18fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGtldFwiLCBcIlxcXFxtYXRoaW5uZXJ7fHsjMX1cXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJyYWtldFwiLCBcIlxcXFxtYXRoaW5uZXJ7XFxcXGxhbmdsZXsjMX1cXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEJyYVwiLCBcIlxcXFxsZWZ0XFxcXGxhbmdsZSMxXFxcXHJpZ2h0fFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEtldFwiLCBcIlxcXFxsZWZ0fCMxXFxcXHJpZ2h0XFxcXHJhbmdsZVwiKTtcbi8vIEEgaGVscGVyIGZvciBcXEJyYWtldCBhbmQgXFxTZXRcbmNvbnN0IHJlcGxhY2VWZXJ0ID0gKGFyZ1N0ciwgbWF0Y2gpID0+IHtcbiAgY29uc3QgY2ggPSBtYXRjaFswXSA9PT0gXCJ8XCIgPyBcIlxcXFx2ZXJ0XCIgOiBcIlxcXFxWZXJ0XCI7XG4gIGNvbnN0IHJlcGxhY2VTdHIgPSBgfVxcXFwsXFxcXG1pZGRsZSR7Y2h9XFxcXCx7YDtcbiAgcmV0dXJuIGFyZ1N0ci5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyByZXBsYWNlU3RyICsgYXJnU3RyLnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKVxufTtcbmRlZmluZU1hY3JvKFwiXFxcXEJyYWtldFwiLCAgZnVuY3Rpb24oY29udGV4dCkge1xuICBsZXQgYXJnU3RyID0gcmVjcmVhdGVBcmdTdHIoY29udGV4dCk7XG4gIGNvbnN0IHJlZ0V4ID0gL1xcfFxcfHxcXHx8XFxcXFxcfC9nO1xuICBsZXQgbWF0Y2g7XG4gIHdoaWxlICgobWF0Y2ggPSByZWdFeC5leGVjKGFyZ1N0cikpICE9PSBudWxsKSB7XG4gICAgYXJnU3RyID0gcmVwbGFjZVZlcnQoYXJnU3RyLCBtYXRjaCk7XG4gIH1cbiAgcmV0dXJuIFwiXFxcXGxlZnRcXFxcbGFuZ2xle1wiICsgYXJnU3RyICsgXCJ9XFxcXHJpZ2h0XFxcXHJhbmdsZVwiXG59KTtcbmRlZmluZU1hY3JvKFwiXFxcXFNldFwiLCAgZnVuY3Rpb24oY29udGV4dCkge1xuICBsZXQgYXJnU3RyID0gcmVjcmVhdGVBcmdTdHIoY29udGV4dCk7XG4gIGNvbnN0IG1hdGNoID0gL1xcfFxcfHxcXHx8XFxcXFxcfC8uZXhlYyhhcmdTdHIpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBhcmdTdHIgPSByZXBsYWNlVmVydChhcmdTdHIsIG1hdGNoKTtcbiAgfVxuICByZXR1cm4gXCJcXFxcbGVmdFxcXFx7XFxcXDp7XCIgKyBhcmdTdHIgKyBcIn1cXFxcOlxcXFxyaWdodFxcXFx9XCJcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2V0XCIsICBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ1N0ciA9IHJlY3JlYXRlQXJnU3RyKGNvbnRleHQpO1xuICByZXR1cm4gXCJcXFxce3tcIiArIGFyZ1N0ci5yZXBsYWNlKC9cXHwvLCBcIn1cXFxcbWlke1wiKSArIFwifVxcXFx9XCJcbn0pO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBhY3R1YXJpYWxhbmdsZS5kdHhcbmRlZmluZU1hY3JvKFwiXFxcXGFuZ2xuXCIsIFwie1xcXFxhbmdsIG59XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBkZXJpdmF0aXZlLnN0eVxuZGVmaW5lTWFjcm8oXCJcXFxcb2R2XCIsIFwiXFxcXEBpZnN0YXJcXFxcb2R2QG5leHRcXFxcb2R2QG51bWVyYXRvclwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9kdkBudW1lcmF0b3JcIiwgXCJcXFxcZnJhY3tcXFxcbWF0aHJte2R9IzF9e1xcXFxtYXRocm17ZH0jMn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxvZHZAbmV4dFwiLCBcIlxcXFxmcmFje1xcXFxtYXRocm17ZH19e1xcXFxtYXRocm17ZH0jMn0jMVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBkdlwiLCBcIlxcXFxAaWZzdGFyXFxcXHBkdkBuZXh0XFxcXHBkdkBudW1lcmF0b3JcIik7XG5cbmNvbnN0IHBkdkhlbHBlciA9IGFyZ3MgPT4ge1xuICBjb25zdCBudW1lcmF0b3IgPSBhcmdzWzBdWzBdLnRleHQ7XG4gIGNvbnN0IGRlbm9tcyA9IHN0cmluZ0Zyb21BcmcoYXJnc1sxXSkuc3BsaXQoXCIsXCIpO1xuICBjb25zdCBwb3dlciA9IFN0cmluZyhkZW5vbXMubGVuZ3RoKTtcbiAgY29uc3QgbnVtT3AgPSBwb3dlciA9PT0gXCIxXCIgPyBcIlxcXFxwYXJ0aWFsXCIgOiBgXFxcXHBhcnRpYWxeJHtwb3dlcn1gO1xuICBsZXQgZGVub21pbmF0b3IgPSBcIlwiO1xuICBkZW5vbXMubWFwKGUgPT4geyBkZW5vbWluYXRvciArPSBcIlxcXFxwYXJ0aWFsIFwiICsgZS50cmltKCkgKyAgXCJcXFxcLFwiO30pO1xuICByZXR1cm4gW251bWVyYXRvciwgbnVtT3AsICBkZW5vbWluYXRvci5yZXBsYWNlKC9cXFxcLCQvLCBcIlwiKV1cbn07XG5kZWZpbmVNYWNybyhcIlxcXFxwZHZAbnVtZXJhdG9yXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgW251bWVyYXRvciwgbnVtT3AsIGRlbm9taW5hdG9yXSA9IHBkdkhlbHBlcihjb250ZXh0LmNvbnN1bWVBcmdzKDIpKTtcbiAgcmV0dXJuIGBcXFxcZnJhY3ske251bU9wfSAke251bWVyYXRvcn19eyR7ZGVub21pbmF0b3J9fWBcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxccGR2QG5leHRcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBbbnVtZXJhdG9yLCBudW1PcCwgZGVub21pbmF0b3JdID0gcGR2SGVscGVyKGNvbnRleHQuY29uc3VtZUFyZ3MoMikpO1xuICByZXR1cm4gYFxcXFxmcmFjeyR7bnVtT3B9fXske2Rlbm9taW5hdG9yfX0gJHtudW1lcmF0b3J9YFxufSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHVwZ3JlZWsuZHR4XG5kZWZpbmVNYWNybyhcIlxcXFx1cGFscGhhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxhbHBoYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGJldGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGJldGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBnYW1tYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcZ2FtbWF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBkZWx0YVwiLCBcIlxcXFx1cEBncmVla3tcXFxcZGVsdGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBlcHNpbG9uXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxlcHNpbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwemV0YVwiLCBcIlxcXFx1cEBncmVla3tcXFxcemV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGV0YVwiLCBcIlxcXFx1cEBncmVla3tcXFxcZXRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwdGhldGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHRoZXRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwaW90YVwiLCBcIlxcXFx1cEBncmVla3tcXFxcaW90YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGthcHBhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxrYXBwYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGxhbWJkYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcbGFtYmRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwbXVcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXG11fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwbnVcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXG51fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVweGlcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHhpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwb21pY3JvblwiLCBcIlxcXFx1cEBncmVla3tcXFxcb21pY3Jvbn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHBpXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxwaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGFscGhhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxhbHBoYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHJob1wiLCBcIlxcXFx1cEBncmVla3tcXFxccmhvfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwc2lnbWFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHNpZ21hfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwdGF1XCIsIFwiXFxcXHVwQGdyZWVre1xcXFx0YXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXB1cHNpbG9uXCIsIFwiXFxcXHVwQGdyZWVre1xcXFx1cHNpbG9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwcGhpXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxwaGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBjaGlcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGNoaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHBzaVwiLCBcIlxcXFx1cEBncmVla3tcXFxccHNpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwb21lZ2FcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXG9tZWdhfVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY21sbCBwYWNrYWdlXG5kZWZpbmVNYWNybyhcIlxcXFxpbnZhbXBcIiwgJ1xcXFxtYXRoYmlue1xcXFxjaGFyXCIyMTRifScpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGFyclwiLCAnXFxcXG1hdGhiaW57XFxcXGNoYXJcIjIxNGJ9Jyk7XG5kZWZpbmVNYWNybyhcIlxcXFx3aXRoXCIsICdcXFxcbWF0aGJpbntcXFxcY2hhclwiMjZ9Jyk7XG5kZWZpbmVNYWNybyhcIlxcXFxtdWx0aW1hcGludlwiLCAnXFxcXG1hdGhyZWx7XFxcXGNoYXJcIjI3ZGN9Jyk7XG5kZWZpbmVNYWNybyhcIlxcXFxtdWx0aW1hcGJvdGhcIiwgJ1xcXFxtYXRocmVse1xcXFxjaGFyXCIyOWRmfScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2NvaFwiLCAne1xcXFxta2VybjVtdVxcXFxjaGFyXCIyMzIyXFxcXG1rZXJuNW11fScpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2luY29oXCIsICd7XFxcXG1rZXJuNW11XFxcXGNoYXJcIjIzMjNcXFxcbWtlcm41bXV9Jyk7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2hcIiwgYHtcXFxcbWtlcm41bXVcXFxccnVsZXt9ezAuN2VtfVxcXFxtYXRocmxhcHtcXFxcc21hc2h7XFxcXHJhaXNlMm11e1xcXFxjaGFyXCIyMzIyfX19XG57XFxcXHNtYXNoe1xcXFxsb3dlcjRtdXtcXFxcY2hhclwiMjMyM319fVxcXFxta2VybjVtdX1gKTtcbmRlZmluZU1hY3JvKFwiXFxcXGluY29oXCIsIGB7XFxcXG1rZXJuNW11XFxcXHJ1bGV7fXswLjdlbX1cXFxcbWF0aHJsYXB7XFxcXHNtYXNoe1xcXFxyYWlzZTJtdXtcXFxcY2hhclwiMjMyM319fVxue1xcXFxzbWFzaHtcXFxcbG93ZXI0bXV7XFxcXGNoYXJcIjIzMjJ9fX1cXFxcbWtlcm41bXV9YCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY2hlbXN0eWxlIHBhY2thZ2VcbmRlZmluZU1hY3JvKFwiXFxcXHN0YW5kYXJkc3RhdGVcIiwgXCJcXFxcdGV4dHtcXFxcdGlueVxcXFxjaGFyYOKmtX1cIik7XG5cbu+7vy8qIGVzbGludC1kaXNhYmxlICovXG4vKiAtKi0gTW9kZTogSmF2YVNjcmlwdDsgaW5kZW50LXRhYnMtbW9kZTpuaWw7IGpzLWluZGVudC1sZXZlbDogMiAtKi0gKi9cbi8qIHZpbTogc2V0IHRzPTIgZXQgc3c9MiB0dz04MDogKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiAgVGVtbWwgbWhjaGVtLmpzXG4gKlxuICogIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGEgVGVtbWwgdmVyc2lvbiBvZiBtaGNoZW0gdmVyc2lvbiAzLjMuMC5cbiAqICBJdCBpcyBhZGFwdGVkIGZyb20gTWF0aEpheC9leHRlbnNpb25zL1RlWC9taGNoZW0uanNcbiAqICBJdCBkaWZmZXJzIGZyb20gdGhlIE1hdGhKYXggdmVyc2lvbiBhcyBmb2xsb3dzOlxuICogICAgMS4gVGhlIGludGVyZmFjZSBpcyBjaGFuZ2VkIHNvIHRoYXQgaXQgY2FuIGJlIGNhbGxlZCBmcm9tIFRlbW1sLCBub3QgTWF0aEpheC5cbiAqICAgIDIuIFxccmxhcCBhbmQgXFxsbGFwIGFyZSByZXBsYWNlZCB3aXRoIFxcbWF0aHJsYXAgYW5kIFxcbWF0aGxsYXAuXG4gKiAgICAzLiBUaGUgcmVhY3Rpb24gYXJyb3cgY29kZSBpcyBzaW1wbGlmaWVkLiBBbGwgcmVhY3Rpb24gYXJyb3dzIGFyZSByZW5kZXJlZFxuICogICAgICAgdXNpbmcgVGVtbWwgZXh0ZW5zaWJsZSBhcnJvd3MgaW5zdGVhZCBvZiBidWlsZGluZyBub24tZXh0ZW5zaWJsZSBhcnJvd3MuXG4gKiAgICA0LiBUaGUgfmJvbmQgZm9ybXMgYXJlIGNvbXBvc2VkIGVudGlyZWx5IG9mIFxccnVsZSBlbGVtZW50cy5cbiAqICAgIDUuIFR3byBkYXNoZXMgaW4gX2dldEJvbmQgYXJlIHdyYXBwZWQgaW4gYnJhY2VzIHRvIHN1cHByZXNzIHNwYWNpbmcuIGkuZS4sIHstfVxuICogICAgNi4gVGhlIGVsZWN0cm9uIGRvdCB1c2VzIFxcdGV4dGJ1bGxldCBpbnN0ZWFkIG9mIFxcYnVsbGV0LlxuICogICAgNy4gXFxzbWFzaFtUXSBoYXMgYmVlbiByZW1vdmVkLiAoV2ViS2l0IGhpZGVzIGFueXRoaW5nIGluc2lkZSBcXHNtYXNoe+KApn0pXG4gKlxuICogICAgVGhpcyBjb2RlLCBhcyBvdGhlciBUZW1tbCBjb2RlLCBpcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBcbiAqIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKlxuICogIE1hdGhKYXgvZXh0ZW5zaW9ucy9UZVgvbWhjaGVtLmpzXG4gKlxuICogIEltcGxlbWVudHMgdGhlIFxcY2UgY29tbWFuZCBmb3IgaGFuZGxpbmcgY2hlbWljYWwgZm9ybXVsYXNcbiAqICBmcm9tIHRoZSBtaGNoZW0gTGFUZVggcGFja2FnZS5cbiAqXG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogIENvcHlyaWdodCAoYykgMjAxMS0yMDE1IFRoZSBNYXRoSmF4IENvbnNvcnRpdW1cbiAqICBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxOCBNYXJ0aW4gSGVuc2VsXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8vXG4vLyBDb2RpbmcgU3R5bGVcbi8vICAgLSB1c2UgJycgZm9yIGlkZW50aWZpZXJzIHRoYXQgY2FuIGJ5IG1pbmlmaWVkL3VnbGlmaWVkXG4vLyAgIC0gdXNlIFwiXCIgZm9yIHN0cmluZ3MgdGhhdCBuZWVkIHRvIHN0YXkgdW50b3VjaGVkXG5cbi8vIHZlcnNpb246IFwiMy4zLjBcIiBmb3IgTWF0aEpheCBhbmQgVGVtbWxcblxuXG4vLyBBZGQgXFxjZSwgXFxwdSwgYW5kIFxcdHJpcGxlRGFzaCB0byB0aGUgVGVtbWwgbWFjcm9zLlxuXG5kZWZpbmVNYWNybyhcIlxcXFxjZVwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIHJldHVybiBjaGVtUGFyc2UoY29udGV4dC5jb25zdW1lQXJncygxKVswXSwgXCJjZVwiKVxufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXHB1XCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIGNoZW1QYXJzZShjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdLCBcInB1XCIpO1xufSk7XG5cbi8vIE1hdGggZm9udHMgZG8gbm90IGluY2x1ZGUgZ2x5cGhzIGZvciB0aGUgfiBmb3JtIG9mIGJvbmRzLiBTbyB3ZSdsbCBzZW5kIHBhdGggZ2VvbWV0cnlcbi8vIFNvIHdlJ2xsIGNvbXBvc2UgY2hhcmFjdGVycyBidWlsdCBmcm9tIFxccnVsZSBlbGVtZW50cy5cbmRlZmluZU1hY3JvKFwiXFxcXHVuaURhc2hcIiwgYHtcXFxccnVsZXswLjY3MmVtfXswLjA2ZW19fWApXG5kZWZpbmVNYWNybyhcIlxcXFx0cmlEYXNoXCIsIGB7XFxcXHJ1bGV7MC4xNWVtfXswLjA2ZW19XFxcXGtlcm4ybXVcXFxccnVsZXswLjE1ZW19ezAuMDZlbX1cXFxca2VybjJtdVxcXFxydWxlezAuMTVlbX17MC4wNmVtfX1gKVxuZGVmaW5lTWFjcm8oXCJcXFxcdHJpcGxlRGFzaFwiLCBgXFxcXGtlcm4wLjA3NWVtXFxcXHJhaXNlMC4yNWVte1xcXFx0cmlEYXNofVxcXFxrZXJuMC4wNzVlbWApXG5kZWZpbmVNYWNybyhcIlxcXFx0cmlwbGVEYXNoT3ZlckxpbmVcIiwgYFxcXFxrZXJuMC4wNzVlbVxcXFxtYXRocmxhcHtcXFxccmFpc2UwLjEyNWVte1xcXFx1bmlEYXNofX1cXFxccmFpc2UwLjM0ZW17XFxcXHRyaURhc2h9XFxcXGtlcm4wLjA3NWVtYClcbmRlZmluZU1hY3JvKFwiXFxcXHRyaXBsZURhc2hPdmVyRG91YmxlTGluZVwiLCBgXFxcXGtlcm4wLjA3NWVtXFxcXG1hdGhybGFwe1xcXFxtYXRocmxhcHtcXFxccmFpc2UwLjQ4ZW17XFxcXHRyaURhc2h9fVxcXFxyYWlzZTAuMjdlbXtcXFxcdW5pRGFzaH19e1xcXFxyYWlzZTAuMDVlbXtcXFxcdW5pRGFzaH19XFxcXGtlcm4wLjA3NWVtYClcbmRlZmluZU1hY3JvKFwiXFxcXHRyaXBsZURhc2hCZXR3ZWVuRG91YmxlTGluZVwiLCBgXFxcXGtlcm4wLjA3NWVtXFxcXG1hdGhybGFwe1xcXFxtYXRocmxhcHtcXFxccmFpc2UwLjQ4ZW17XFxcXHVuaURhc2h9fVxcXFxyYWlzZTAuMjdlbXtcXFxcdHJpRGFzaH19e1xcXFxyYWlzZTAuMDVlbXtcXFxcdW5pRGFzaH19XFxcXGtlcm4wLjA3NWVtYClcblxuICAvL1xuICAvLyAgVGhpcyBpcyB0aGUgbWFpbiBmdW5jdGlvbiBmb3IgaGFuZGluZyB0aGUgXFxjZSBhbmQgXFxwdSBjb21tYW5kcy5cbiAgLy8gIEl0IHRha2VzIHRoZSBhcmd1bWVudCB0byBcXGNlIG9yIFxccHUgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgVGVYIHN0cmluZy5cbiAgLy9cblxuICB2YXIgY2hlbVBhcnNlID0gZnVuY3Rpb24gKHRva2Vucywgc3RhdGVNYWNoaW5lKSB7XG4gICAgLy8gUmVjcmVhdGUgdGhlIGFyZ3VtZW50IHN0cmluZyBmcm9tIFRlbW1sJ3MgYXJyYXkgb2YgdG9rZW5zLlxuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBleHBlY3RlZExvYyA9IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS5sb2Muc3RhcnRcbiAgICBmb3IgKHZhciBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZih0b2tlbnNbaV0ubG9jLnN0YXJ0ID4gZXhwZWN0ZWRMb2MpIHtcbiAgICAgICAgLy8gY29udGV4dC5jb25zdW1lQXJncyBoYXMgZWF0ZW4gYSBzcGFjZS5cbiAgICAgICAgc3RyICs9IFwiIFwiO1xuICAgICAgICBleHBlY3RlZExvYyA9IHRva2Vuc1tpXS5sb2Muc3RhcnQ7XG4gICAgICB9XG4gICAgICBzdHIgKz0gdG9rZW5zW2ldLnRleHQ7XG4gICAgICBleHBlY3RlZExvYyArPSB0b2tlbnNbaV0udGV4dC5sZW5ndGg7XG4gICAgfVxuICAgIC8vIENhbGwgdGhlIG1oY2hlbSBjb3JlIHBhcnNlci5cbiAgICB2YXIgdGV4ID0gdGV4aWZ5LmdvKG1oY2hlbVBhcnNlci5nbyhzdHIsIHN0YXRlTWFjaGluZSkpO1xuICAgIHJldHVybiB0ZXg7XG4gIH07XG5cbiAgLy9cbiAgLy8gQ29yZSBwYXJzZXIgZm9yIG1oY2hlbSBzeW50YXggIChyZWN1cnNpdmUpXG4gIC8vXG4gIC8qKiBAdHlwZSB7TWhjaGVtUGFyc2VyfSAqL1xuICB2YXIgbWhjaGVtUGFyc2VyID0ge1xuICAgIC8vXG4gICAgLy8gUGFyc2VzIG1jaGVtIFxcY2Ugc3ludGF4XG4gICAgLy9cbiAgICAvLyBDYWxsIGxpa2VcbiAgICAvLyAgIGdvKFwiSDJPXCIpO1xuICAgIC8vXG4gICAgZ286IGZ1bmN0aW9uIChpbnB1dCwgc3RhdGVNYWNoaW5lKSB7XG4gICAgICBpZiAoIWlucHV0KSB7IHJldHVybiBbXTsgfVxuICAgICAgaWYgKHN0YXRlTWFjaGluZSA9PT0gdW5kZWZpbmVkKSB7IHN0YXRlTWFjaGluZSA9ICdjZSc7IH1cbiAgICAgIHZhciBzdGF0ZSA9ICcwJztcblxuICAgICAgLy9cbiAgICAgIC8vIFN0cmluZyBidWZmZXJzIGZvciBwYXJzaW5nOlxuICAgICAgLy9cbiAgICAgIC8vIGJ1ZmZlci5hID09IGFtb3VudFxuICAgICAgLy8gYnVmZmVyLm8gPT0gZWxlbWVudFxuICAgICAgLy8gYnVmZmVyLmIgPT0gbGVmdC1zaWRlIHN1cGVyc2NyaXB0XG4gICAgICAvLyBidWZmZXIucCA9PSBsZWZ0LXNpZGUgc3Vic2NyaXB0XG4gICAgICAvLyBidWZmZXIucSA9PSByaWdodC1zaWRlIHN1YnNjcmlwdFxuICAgICAgLy8gYnVmZmVyLmQgPT0gcmlnaHQtc2lkZSBzdXBlcnNjcmlwdFxuICAgICAgLy9cbiAgICAgIC8vIGJ1ZmZlci5yID09IGFycm93XG4gICAgICAvLyBidWZmZXIucmR0ID09IGFycm93LCBzY3JpcHQgYWJvdmUsIHR5cGVcbiAgICAgIC8vIGJ1ZmZlci5yZCA9PSBhcnJvdywgc2NyaXB0IGFib3ZlLCBjb250ZW50XG4gICAgICAvLyBidWZmZXIucnF0ID09IGFycm93LCBzY3JpcHQgYmVsb3csIHR5cGVcbiAgICAgIC8vIGJ1ZmZlci5ycSA9PSBhcnJvdywgc2NyaXB0IGJlbG93LCBjb250ZW50XG4gICAgICAvL1xuICAgICAgLy8gYnVmZmVyLnRleHRfXG4gICAgICAvLyBidWZmZXIucm1cbiAgICAgIC8vIGV0Yy5cbiAgICAgIC8vXG4gICAgICAvLyBidWZmZXIucGFyZW50aGVzaXNMZXZlbCA9PSBpbnQsIHN0YXJ0aW5nIGF0IDBcbiAgICAgIC8vIGJ1ZmZlci5zYiA9PSBib29sLCBzcGFjZSBiZWZvcmVcbiAgICAgIC8vIGJ1ZmZlci5iZWdpbnNXaXRoQm9uZCA9PSBib29sXG4gICAgICAvL1xuICAgICAgLy8gVGhlc2UgbGV0dGVycyBhcmUgYWxzbyB1c2VkIGFzIHN0YXRlIG5hbWVzLlxuICAgICAgLy9cbiAgICAgIC8vIE90aGVyIHN0YXRlczpcbiAgICAgIC8vIDAgPT0gYmVnaW4gb2YgbWFpbiBwYXJ0IChhcnJvdy9vcGVyYXRvciB1bmxpa2VseSlcbiAgICAgIC8vIDEgPT0gbmV4dCBlbnRpdHlcbiAgICAgIC8vIDIgPT0gbmV4dCBlbnRpdHkgKGFycm93L29wZXJhdG9yIHVubGlrZWx5KVxuICAgICAgLy8gMyA9PSBuZXh0IGF0b21cbiAgICAgIC8vIGMgPT0gbWFjcm9cbiAgICAgIC8vXG4gICAgICAvKiogQHR5cGUge0J1ZmZlcn0gKi9cbiAgICAgIHZhciBidWZmZXIgPSB7fTtcbiAgICAgIGJ1ZmZlclsncGFyZW50aGVzaXNMZXZlbCddID0gMDtcblxuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9cXG4vZywgXCIgXCIpO1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXFx1MjIxMlxcdTIwMTNcXHUyMDE0XFx1MjAxMF0vZywgXCItXCIpO1xuICAgICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXFx1MjAyNl0vZywgXCIuLi5cIik7XG5cbiAgICAgIC8vXG4gICAgICAvLyBMb29rcyB0aHJvdWdoIG1oY2hlbVBhcnNlci50cmFuc2l0aW9ucywgdG8gZXhlY3V0ZSBhIG1hdGNoaW5nIGFjdGlvblxuICAgICAgLy8gKHJlY3Vyc2l2ZSlcbiAgICAgIC8vXG4gICAgICB2YXIgbGFzdElucHV0O1xuICAgICAgdmFyIHdhdGNoZG9nID0gMTA7XG4gICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKGxhc3RJbnB1dCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICB3YXRjaGRvZyA9IDEwO1xuICAgICAgICAgIGxhc3RJbnB1dCA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhdGNoZG9nLS07XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gRmluZCBhY3Rpb25zIGluIHRyYW5zaXRpb24gdGFibGVcbiAgICAgICAgLy9cbiAgICAgICAgdmFyIG1hY2hpbmUgPSBtaGNoZW1QYXJzZXIuc3RhdGVNYWNoaW5lc1tzdGF0ZU1hY2hpbmVdO1xuICAgICAgICB2YXIgdCA9IG1hY2hpbmUudHJhbnNpdGlvbnNbc3RhdGVdIHx8IG1hY2hpbmUudHJhbnNpdGlvbnNbJyonXTtcbiAgICAgICAgaXRlcmF0ZVRyYW5zaXRpb25zOlxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXyh0W2ldLnBhdHRlcm4sIGlucHV0KTtcbiAgICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgYWN0aW9uc1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhciB0YXNrID0gdFtpXS50YXNrO1xuICAgICAgICAgICAgZm9yICh2YXIgaUE9MDsgaUE8dGFzay5hY3Rpb25fLmxlbmd0aDsgaUErKykge1xuICAgICAgICAgICAgICB2YXIgbztcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gRmluZCBhbmQgZXhlY3V0ZSBhY3Rpb25cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgaWYgKG1hY2hpbmUuYWN0aW9uc1t0YXNrLmFjdGlvbl9baUFdLnR5cGVfXSkge1xuICAgICAgICAgICAgICAgIG8gPSBtYWNoaW5lLmFjdGlvbnNbdGFzay5hY3Rpb25fW2lBXS50eXBlX10oYnVmZmVyLCBtYXRjaGVzLm1hdGNoXywgdGFzay5hY3Rpb25fW2lBXS5vcHRpb24pO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1oY2hlbVBhcnNlci5hY3Rpb25zW3Rhc2suYWN0aW9uX1tpQV0udHlwZV9dKSB7XG4gICAgICAgICAgICAgICAgbyA9IG1oY2hlbVBhcnNlci5hY3Rpb25zW3Rhc2suYWN0aW9uX1tpQV0udHlwZV9dKGJ1ZmZlciwgbWF0Y2hlcy5tYXRjaF8sIHRhc2suYWN0aW9uX1tpQV0ub3B0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdBXCIsIFwibWhjaGVtIGJ1ZyBBLiBQbGVhc2UgcmVwb3J0LiAoXCIgKyB0YXNrLmFjdGlvbl9baUFdLnR5cGVfICsgXCIpXCJdOyAgLy8gVHJ5aW5nIHRvIHVzZSBub24tZXhpc3RpbmcgYWN0aW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gQWRkIG91dHB1dFxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkob3V0cHV0LCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTZXQgbmV4dCBzdGF0ZSxcbiAgICAgICAgICAgIC8vIFNob3J0ZW4gaW5wdXQsXG4gICAgICAgICAgICAvLyBDb250aW51ZSB3aXRoIG5leHQgY2hhcmFjdGVyXG4gICAgICAgICAgICAvLyAgICg9IGFwcGx5IG9ubHkgb25lIHRyYW5zaXRpb24gcGVyIHBvc2l0aW9uKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHN0YXRlID0gdGFzay5uZXh0U3RhdGUgfHwgc3RhdGU7XG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpZiAoIXRhc2sucmV2aXNpdCkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gbWF0Y2hlcy5yZW1haW5kZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCF0YXNrLnRvQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICBicmVhayBpdGVyYXRlVHJhbnNpdGlvbnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcFxuICAgICAgICAvL1xuICAgICAgICBpZiAod2F0Y2hkb2cgPD0gMCkge1xuICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1VcIiwgXCJtaGNoZW0gYnVnIFUuIFBsZWFzZSByZXBvcnQuXCJdOyAgLy8gVW5leHBlY3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29uY2F0QXJyYXk6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgIGZvciAodmFyIGlCPTA7IGlCPGIubGVuZ3RoOyBpQisrKSB7XG4gICAgICAgICAgICBhLnB1c2goYltpQl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhLnB1c2goYik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcGF0dGVybnM6IHtcbiAgICAgIC8vXG4gICAgICAvLyBNYXRjaGluZyBwYXR0ZXJuc1xuICAgICAgLy8gZWl0aGVyIHJlZ2V4cHMgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm4gbnVsbCBvciB7bWF0Y2hfOlwiYVwiLCByZW1haW5kZXI6XCJiY1wifVxuICAgICAgLy9cbiAgICAgIHBhdHRlcm5zOiB7XG4gICAgICAgIC8vIHByb3BlcnR5IG5hbWVzIG11c3Qgbm90IGxvb2sgbGlrZSBpbnRlZ2VycyAoXCIyXCIpIGZvciBjb3JyZWN0IHByb3BlcnR5IHRyYXZlcnNhbCBvcmRlciwgbGF0ZXIgb25cbiAgICAgICAgJ2VtcHR5JzogL14kLyxcbiAgICAgICAgJ2Vsc2UnOiAvXi4vLFxuICAgICAgICAnZWxzZTInOiAvXi4vLFxuICAgICAgICAnc3BhY2UnOiAvXlxccy8sXG4gICAgICAgICdzcGFjZSBBJzogL15cXHMoPz1bQS1aXFxcXCRdKS8sXG4gICAgICAgICdzcGFjZSQnOiAvXlxccyQvLFxuICAgICAgICAnYS16JzogL15bYS16XS8sXG4gICAgICAgICd4JzogL154LyxcbiAgICAgICAgJ3gkJzogL154JC8sXG4gICAgICAgICdpJCc6IC9eaSQvLFxuICAgICAgICAnbGV0dGVycyc6IC9eKD86W2EtekEtWlxcdTAzQjEtXFx1MDNDOVxcdTAzOTEtXFx1MDNBOT9AXXwoPzpcXFxcKD86YWxwaGF8YmV0YXxnYW1tYXxkZWx0YXxlcHNpbG9ufHpldGF8ZXRhfHRoZXRhfGlvdGF8a2FwcGF8bGFtYmRhfG11fG51fHhpfG9taWNyb258cGl8cmhvfHNpZ21hfHRhdXx1cHNpbG9ufHBoaXxjaGl8cHNpfG9tZWdhfEdhbW1hfERlbHRhfFRoZXRhfExhbWJkYXxYaXxQaXxTaWdtYXxVcHNpbG9ufFBoaXxQc2l8T21lZ2EpKD86XFxzK3xcXHtcXH18KD8hW2EtekEtWl0pKSkpKy8sXG4gICAgICAgICdcXFxcZ3JlZWsnOiAvXlxcXFwoPzphbHBoYXxiZXRhfGdhbW1hfGRlbHRhfGVwc2lsb258emV0YXxldGF8dGhldGF8aW90YXxrYXBwYXxsYW1iZGF8bXV8bnV8eGl8b21pY3JvbnxwaXxyaG98c2lnbWF8dGF1fHVwc2lsb258cGhpfGNoaXxwc2l8b21lZ2F8R2FtbWF8RGVsdGF8VGhldGF8TGFtYmRhfFhpfFBpfFNpZ21hfFVwc2lsb258UGhpfFBzaXxPbWVnYSkoPzpcXHMrfFxce1xcfXwoPyFbYS16QS1aXSkpLyxcbiAgICAgICAgJ29uZSBsb3dlcmNhc2UgbGF0aW4gbGV0dGVyICQnOiAvXig/OihbYS16XSkoPzokfFteYS16QS1aXSkpJC8sXG4gICAgICAgICckb25lIGxvd2VyY2FzZSBsYXRpbiBsZXR0ZXIkICQnOiAvXlxcJCg/OihbYS16XSkoPzokfFteYS16QS1aXSkpXFwkJC8sXG4gICAgICAgICdvbmUgbG93ZXJjYXNlIGdyZWVrIGxldHRlciAkJzogL14oPzpcXCQ/W1xcdTAzQjEtXFx1MDNDOV1cXCQ/fFxcJD9cXFxcKD86YWxwaGF8YmV0YXxnYW1tYXxkZWx0YXxlcHNpbG9ufHpldGF8ZXRhfHRoZXRhfGlvdGF8a2FwcGF8bGFtYmRhfG11fG51fHhpfG9taWNyb258cGl8cmhvfHNpZ21hfHRhdXx1cHNpbG9ufHBoaXxjaGl8cHNpfG9tZWdhKVxccypcXCQ/KSg/Olxccyt8XFx7XFx9fCg/IVthLXpBLVpdKSkkLyxcbiAgICAgICAgJ2RpZ2l0cyc6IC9eWzAtOV0rLyxcbiAgICAgICAgJy05Liw5JzogL15bK1xcLV0/KD86WzAtOV0rKD86WywuXVswLTldKyk/fFswLTldKig/OlxcLlswLTldKykpLyxcbiAgICAgICAgJy05Liw5IG5vIG1pc3NpbmcgMCc6IC9eWytcXC1dP1swLTldKyg/OlsuLF1bMC05XSspPy8sXG4gICAgICAgICcoLSkoOS4sOSkoZSkoOTkpJzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXihcXCtcXC18XFwrXFwvXFwtfFxcK3xcXC18XFxcXHBtXFxzPyk/KFswLTldKyg/OlssLl1bMC05XSspP3xbMC05XSooPzpcXC5bMC05XSspKT8oXFwoKD86WzAtOV0rKD86WywuXVswLTldKyk/fFswLTldKig/OlxcLlswLTldKykpXFwpKT8oPzooW2VFXXxcXHMqKFxcKnx4fFxcXFx0aW1lc3xcXHUwMEQ3KVxccyoxMFxcXikoWytcXC1dP1swLTldK3xcXHtbK1xcLV0/WzAtOV0rXFx9KSk/Lyk7XG4gICAgICAgICAgaWYgKG0gJiYgbVswXSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtLnNwbGljZSgxKSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobVswXS5sZW5ndGgpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAnKC0pKDkpXigtOSknOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKFxcK1xcLXxcXCtcXC9cXC18XFwrfFxcLXxcXFxccG1cXHM/KT8oWzAtOV0rKD86WywuXVswLTldKyk/fFswLTldKig/OlxcLlswLTldKyk/KVxcXihbK1xcLV0/WzAtOV0rfFxce1srXFwtXT9bMC05XStcXH0pLyk7XG4gICAgICAgICAgaWYgKG0gJiYgbVswXSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtLnNwbGljZSgxKSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobVswXS5sZW5ndGgpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAnc3RhdGUgb2YgYWdncmVnYXRpb24gJCc6IGZ1bmN0aW9uIChpbnB1dCkgeyAgLy8gLi4uIG9yIGNyeXN0YWwgc3lzdGVtXG4gICAgICAgICAgdmFyIGEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIC9eXFwoW2Etel17MSwzfSg/PVtcXCksXSkvLCBcIilcIiwgXCJcIik7ICAvLyAoYXEpLCAoYXEsJFxcaW5mdHkkKSwgKGFxLCBzYXQpXG4gICAgICAgICAgaWYgKGEgICYmICBhLnJlbWFpbmRlci5tYXRjaCgvXigkfFtcXHMsO1xcKVxcXVxcfV0pLykpIHsgcmV0dXJuIGE7IH0gIC8vICBBTkQgZW5kIG9mICdwaHJhc2UnXG4gICAgICAgICAgdmFyIG0gPSBpbnB1dC5tYXRjaCgvXig/OlxcKCg/OlxcXFxjYVxccz8pP1xcJFthbW90aGNdXFwkXFwpKS8pOyAgLy8gT1IgY3J5c3RhbCBzeXN0ZW0gKCRvJCkgKFxcY2EkYyQpXG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbVswXSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobVswXS5sZW5ndGgpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAnX3soc3RhdGUgb2YgYWdncmVnYXRpb24pfSQnOiAvXl9cXHsoXFwoW2Etel17MSwzfVxcKSlcXH0vLFxuICAgICAgICAne1soJzogL14oPzpcXFxcXFx7fFxcW3xcXCgpLyxcbiAgICAgICAgJyldfSc6IC9eKD86XFwpfFxcXXxcXFxcXFx9KS8sXG4gICAgICAgICcsICc6IC9eWyw7XVxccyovLFxuICAgICAgICAnLCc6IC9eWyw7XS8sXG4gICAgICAgICcuJzogL15bLl0vLFxuICAgICAgICAnLiAnOiAvXihbLlxcdTIyQzVcXHUwMEI3XFx1MjAyMl0pXFxzKi8sXG4gICAgICAgICcuLi4nOiAvXlxcLlxcLlxcLig/PSR8W14uXSkvLFxuICAgICAgICAnKiAnOiAvXihbKl0pXFxzKi8sXG4gICAgICAgICdeeyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl57XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ14oJC4uLiQpJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXlwiLCBcIiRcIiwgXCIkXCIsIFwiXCIpOyB9LFxuICAgICAgICAnXmEnOiAvXlxcXihbMC05XSt8W15cXFxcX10pLyxcbiAgICAgICAgJ15cXFxceHt9e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJeXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiLCBcIlwiLCBcIntcIiwgXCJ9XCIsIFwiXCIsIHRydWUpOyB9LFxuICAgICAgICAnXlxcXFx4e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJeXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ15cXFxceCc6IC9eXFxeKFxcXFxbYS16QS1aXSspXFxzKi8sXG4gICAgICAgICdeKC0xKSc6IC9eXFxeKC0/XFxkKykvLFxuICAgICAgICAnXFwnJzogL14nLyxcbiAgICAgICAgJ197KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiX3tcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXygkLi4uJCknOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJfXCIsIFwiJFwiLCBcIiRcIiwgXCJcIik7IH0sXG4gICAgICAgICdfOSc6IC9eXyhbK1xcLV0/WzAtOV0rfFteXFxcXF0pLyxcbiAgICAgICAgJ19cXFxceHt9e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJfXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiLCBcIlwiLCBcIntcIiwgXCJ9XCIsIFwiXCIsIHRydWUpOyB9LFxuICAgICAgICAnX1xcXFx4e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJfXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ19cXFxceCc6IC9eXyhcXFxcW2EtekEtWl0rKVxccyovLFxuICAgICAgICAnXl8nOiAvXig/OlxcXig/PV8pfFxcXyg/PVxcXil8W1xcXl9dJCkvLFxuICAgICAgICAne30nOiAvXlxce1xcfS8sXG4gICAgICAgICd7Li4ufSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCBcIntcIiwgXCJ9XCIsIFwiXCIpOyB9LFxuICAgICAgICAneyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnJC4uLiQnOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgXCIkXCIsIFwiJFwiLCBcIlwiKTsgfSxcbiAgICAgICAgJyR7KC4uLil9JCc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIiR7XCIsIFwiXCIsIFwiXCIsIFwifSRcIik7IH0sXG4gICAgICAgICckKC4uLikkJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiJFwiLCBcIlwiLCBcIlwiLCBcIiRcIik7IH0sXG4gICAgICAgICc9PD4nOiAvXls9PD5dLyxcbiAgICAgICAgJyMnOiAvXlsjXFx1MjI2MV0vLFxuICAgICAgICAnKyc6IC9eXFwrLyxcbiAgICAgICAgJy0kJzogL14tKD89W1xcc199LDtcXF0vXXwkfFxcKFthLXpdK1xcKSkvLCAgLy8gLXNwYWNlIC0sIC07IC1dIC0vIC0kIC1zdGF0ZS1vZi1hZ2dyZWdhdGlvblxuICAgICAgICAnLTknOiAvXi0oPz1bMC05XSkvLFxuICAgICAgICAnLSBvcmJpdGFsIG92ZXJsYXAnOiAvXi0oPz0oPzpbc3BkXXxzcCkoPzokfFtcXHMsO1xcKVxcXVxcfV0pKS8sXG4gICAgICAgICctJzogL14tLyxcbiAgICAgICAgJ3BtLW9wZXJhdG9yJzogL14oPzpcXFxccG18XFwkXFxcXHBtXFwkfFxcKy18XFwrXFwvLSkvLFxuICAgICAgICAnb3BlcmF0b3InOiAvXig/OlxcK3woPzpbXFwtPTw+XXw8PHw+PnxcXFxcYXBwcm94fFxcJFxcXFxhcHByb3hcXCQpKD89XFxzfCR8LT9bMC05XSkpLyxcbiAgICAgICAgJ2Fycm93VXBEb3duJzogL14oPzp2fFxcKHZcXCl8XFxefFxcKFxcXlxcKSkoPz0kfFtcXHMsO1xcKVxcXVxcfV0pLyxcbiAgICAgICAgJ1xcXFxib25keyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxib25ke1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICctPic6IC9eKD86PC0+fDwtLT58LT58PC18PD0+Pnw8PD0+fDw9PnxbXFx1MjE5MlxcdTI3RjZcXHUyMUNDXSkvLFxuICAgICAgICAnQ01UJzogL15bQ01UXSg/PVxcWykvLFxuICAgICAgICAnWyguLi4pXSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIltcIiwgXCJcIiwgXCJcIiwgXCJdXCIpOyB9LFxuICAgICAgICAnMXN0LWxldmVsIGVzY2FwZSc6IC9eKCZ8XFxcXFxcXFx8XFxcXGhsaW5lKVxccyovLFxuICAgICAgICAnXFxcXCwnOiAvXig/OlxcXFxbLFxcIDs6XSkvLCAgLy8gXFxcXHggLSBidXQgb3V0cHV0IG5vIHNwYWNlIGJlZm9yZVxuICAgICAgICAnXFxcXHh7fXt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiLCBcIlwiLCBcIntcIiwgXCJ9XCIsIFwiXCIsIHRydWUpOyB9LFxuICAgICAgICAnXFxcXHh7fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCAvXlxcXFxbYS16QS1aXStcXHsvLCBcIn1cIiwgXCJcIik7IH0sXG4gICAgICAgICdcXFxcY2EnOiAvXlxcXFxjYSg/Olxccyt8KD8hW2EtekEtWl0pKS8sXG4gICAgICAgICdcXFxceCc6IC9eKD86XFxcXFthLXpBLVpdK1xccyp8XFxcXFtfJnt9JV0pLyxcbiAgICAgICAgJ29yYml0YWwnOiAvXig/OlswLTldezEsMn1bc3BkZmdoXXxbMC05XXswLDJ9c3ApKD89JHxbXmEtekEtWl0pLywgIC8vIG9ubHkgdGhvc2Ugd2l0aCBudW1iZXJzIGluIGZyb250LCBiZWNhdXNlIHRoZSBvdGhlcnMgd2lsbCBiZSBmb3JtYXR0ZWQgY29ycmVjdGx5IGFueXdheVxuICAgICAgICAnb3RoZXJzJzogL15bXFwvfnxdLyxcbiAgICAgICAgJ1xcXFxmcmFjeyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxmcmFje1wiLCBcIlwiLCBcIlwiLCBcIn1cIiwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFxvdmVyc2V0eyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxvdmVyc2V0e1wiLCBcIlwiLCBcIlwiLCBcIn1cIiwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFx1bmRlcnNldHsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcdW5kZXJzZXR7XCIsIFwiXCIsIFwiXCIsIFwifVwiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXHVuZGVyYnJhY2V7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXHVuZGVyYnJhY2V7XCIsIFwiXCIsIFwiXCIsIFwifV9cIiwgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX0wJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNvbG9ye1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9eyguLi4pfTEnOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcY29sb3J7XCIsIFwiXCIsIFwiXCIsIFwifVwiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXGNvbG9yKC4uLil7KC4uLil9Mic6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxjb2xvclwiLCBcIlxcXFxcIiwgXCJcIiwgL14oPz1cXHspLywgXCJ7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcY2V7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ294aWRhdGlvbiQnOiAvXig/OlsrLV1bSVZYXSt8XFxcXHBtXFxzKjB8XFwkXFxcXHBtXFwkXFxzKjApJC8sXG4gICAgICAgICdkLW94aWRhdGlvbiQnOiAvXig/OlsrLV0/XFxzP1tJVlhdK3xcXFxccG1cXHMqMHxcXCRcXFxccG1cXCRcXHMqMCkkLywgIC8vIDAgY291bGQgYmUgb3hpZGF0aW9uIG9yIGNoYXJnZVxuICAgICAgICAncm9tYW4gbnVtZXJhbCc6IC9eW0lWWF0rLyxcbiAgICAgICAgJzEvMiQnOiAvXlsrXFwtXT8oPzpbMC05XSt8XFwkW2Etel1cXCR8W2Etel0pXFwvWzAtOV0rKD86XFwkW2Etel1cXCR8W2Etel0pPyQvLFxuICAgICAgICAnYW1vdW50JzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICAgIC8vIGUuZy4gMiwgMC41LCAxLzIsIC0yLCBuLzIsICs7ICAkYSQgY291bGQgYmUgYWRkZWQgbGF0ZXIgaW4gcGFyc2luZ1xuICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goL14oPzooPzooPzpcXChbK1xcLV0/WzAtOV0rXFwvWzAtOV0rXFwpfFsrXFwtXT8oPzpbMC05XSt8XFwkW2Etel1cXCR8W2Etel0pXFwvWzAtOV0rfFsrXFwtXT9bMC05XStbLixdWzAtOV0rfFsrXFwtXT9cXC5bMC05XSt8WytcXC1dP1swLTldKykoPzpbYS16XSg/PVxccypbQS1aXSkpPyl8WytcXC1dP1thLXpdKD89XFxzKltBLVpdKXxcXCsoPyFcXHMpKS8pO1xuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtYXRjaFswXSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgXCIkXCIsIFwiJFwiLCBcIlwiKTtcbiAgICAgICAgICBpZiAoYSkgeyAgLy8gZS5nLiAkMm4tMSQsICQtJFxuICAgICAgICAgICAgbWF0Y2ggPSBhLm1hdGNoXy5tYXRjaCgvXlxcJCg/OlxcKD9bK1xcLV0/KD86WzAtOV0qW2Etel0/WytcXC1dKT9bMC05XSpbYS16XSg/OlsrXFwtXVswLTldKlthLXpdPyk/XFwpP3xcXCt8LSlcXCQkLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtYXRjaFswXSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgJ2Ftb3VudDInOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIHRoaXNbJ2Ftb3VudCddKGlucHV0KTsgfSxcbiAgICAgICAgJyhLViBsZXR0ZXJzKSwnOiAvXig/OltBLVpdW2Etel17MCwyfXxpKSg/PSwpLyxcbiAgICAgICAgJ2Zvcm11bGEkJzogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9eXFwoW2Etel0rXFwpJC8pKSB7IHJldHVybiBudWxsOyB9ICAvLyBzdGF0ZSBvZiBhZ2dyZWdhdGlvbiA9IG5vIGZvcm11bGFcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvXig/OlthLXpdfCg/OlswLTlcXCBcXCtcXC1cXCxcXC5cXChcXCldK1thLXpdKStbMC05XFwgXFwrXFwtXFwsXFwuXFwoXFwpXSp8KD86W2Etel1bMC05XFwgXFwrXFwtXFwsXFwuXFwoXFwpXSspK1thLXpdPykkLyk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1hdGNoWzBdLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAndXByaWdodEVudGl0aWVzJzogL14oPzpwSHxwT0h8cEN8cEt8aVByfGlCdSkoPz0kfFteYS16QS1aXSkvLFxuICAgICAgICAnLyc6IC9eXFxzKihcXC8pXFxzKi8sXG4gICAgICAgICcvLyc6IC9eXFxzKihcXC9cXC8pXFxzKi8sXG4gICAgICAgICcqJzogL15cXHMqWyouXVxccyovXG4gICAgICB9LFxuICAgICAgZmluZE9ic2VydmVHcm91cHM6IGZ1bmN0aW9uIChpbnB1dCwgYmVnRXhjbCwgYmVnSW5jbCwgZW5kSW5jbCwgZW5kRXhjbCwgYmVnMkV4Y2wsIGJlZzJJbmNsLCBlbmQySW5jbCwgZW5kMkV4Y2wsIGNvbWJpbmUpIHtcbiAgICAgICAgLyoqIEB0eXBlIHt7KGlucHV0OiBzdHJpbmcsIHBhdHRlcm46IHN0cmluZyB8IFJlZ0V4cCk6IHN0cmluZyB8IHN0cmluZ1tdIHwgbnVsbDt9fSAqL1xuICAgICAgICB2YXIgX21hdGNoID0gZnVuY3Rpb24gKGlucHV0LCBwYXR0ZXJuKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuaW5kZXhPZihwYXR0ZXJuKSAhPT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKHBhdHRlcm4pO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEB0eXBlIHt7KGlucHV0OiBzdHJpbmcsIGk6IG51bWJlciwgZW5kQ2hhcnM6IHN0cmluZyB8IFJlZ0V4cCk6IHtlbmRNYXRjaEJlZ2luOiBudW1iZXIsIGVuZE1hdGNoRW5kOiBudW1iZXJ9IHwgbnVsbDt9fSAqL1xuICAgICAgICB2YXIgX2ZpbmRPYnNlcnZlR3JvdXBzID0gZnVuY3Rpb24gKGlucHV0LCBpLCBlbmRDaGFycykge1xuICAgICAgICAgIHZhciBicmFjZXMgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGlucHV0LmNoYXJBdChpKTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IF9tYXRjaChpbnB1dC5zdWJzdHIoaSksIGVuZENoYXJzKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAgJiYgIGJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4geyBlbmRNYXRjaEJlZ2luOiBpLCBlbmRNYXRjaEVuZDogaSArIG1hdGNoLmxlbmd0aCB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhID09PSBcIntcIikge1xuICAgICAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgaWYgKGJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IFtcIkV4dHJhQ2xvc2VNaXNzaW5nT3BlblwiLCBcIkV4dHJhIGNsb3NlIGJyYWNlIG9yIG1pc3Npbmcgb3BlbiBicmFjZVwiXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmFjZXMtLTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnJhY2VzID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbWF0Y2ggPSBfbWF0Y2goaW5wdXQsIGJlZ0V4Y2wpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIobWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgbWF0Y2ggPSBfbWF0Y2goaW5wdXQsIGJlZ0luY2wpO1xuICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIGUgPSBfZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIG1hdGNoLmxlbmd0aCwgZW5kSW5jbCB8fCBlbmRFeGNsKTtcbiAgICAgICAgaWYgKGUgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgdmFyIG1hdGNoMSA9IGlucHV0LnN1YnN0cmluZygwLCAoZW5kSW5jbCA/IGUuZW5kTWF0Y2hFbmQgOiBlLmVuZE1hdGNoQmVnaW4pKTtcbiAgICAgICAgaWYgKCEoYmVnMkV4Y2wgfHwgYmVnMkluY2wpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoXzogbWF0Y2gxLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIoZS5lbmRNYXRjaEVuZClcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBncm91cDIgPSB0aGlzLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LnN1YnN0cihlLmVuZE1hdGNoRW5kKSwgYmVnMkV4Y2wsIGJlZzJJbmNsLCBlbmQySW5jbCwgZW5kMkV4Y2wpO1xuICAgICAgICAgIGlmIChncm91cDIgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgICAgICAgIHZhciBtYXRjaFJldCA9IFttYXRjaDEsIGdyb3VwMi5tYXRjaF9dO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXRjaF86IChjb21iaW5lID8gbWF0Y2hSZXQuam9pbihcIlwiKSA6IG1hdGNoUmV0KSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogZ3JvdXAyLnJlbWFpbmRlclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vXG4gICAgICAvLyBNYXRjaGluZyBmdW5jdGlvblxuICAgICAgLy8gZS5nLiBtYXRjaChcImFcIiwgaW5wdXQpIHdpbGwgbG9vayBmb3IgdGhlIHJlZ2V4cCBjYWxsZWQgXCJhXCIgYW5kIHNlZSBpZiBpdCBtYXRjaGVzXG4gICAgICAvLyByZXR1cm5zIG51bGwgb3Ige21hdGNoXzpcImFcIiwgcmVtYWluZGVyOlwiYmNcIn1cbiAgICAgIC8vXG4gICAgICBtYXRjaF86IGZ1bmN0aW9uIChtLCBpbnB1dCkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5wYXR0ZXJuc1ttXTtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1BcIiwgXCJtaGNoZW0gYnVnIFAuIFBsZWFzZSByZXBvcnQuIChcIiArIG0gKyBcIilcIl07ICAvLyBUcnlpbmcgdG8gdXNlIG5vbi1leGlzdGluZyBwYXR0ZXJuXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMucGF0dGVybnNbbV0oaW5wdXQpOyAgLy8gY2Fubm90IHVzZSBjYWNoZWQgdmFyIHBhdHRlcm4gaGVyZSwgYmVjYXVzZSBzb21lIHBhdHRlcm4gZnVuY3Rpb25zIG5lZWQgdGhpcz09PW1oY2hlbVBhcnNlclxuICAgICAgICB9IGVsc2UgeyAgLy8gUmVnRXhwXG4gICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgbW07XG4gICAgICAgICAgICBpZiAobWF0Y2hbMl0pIHtcbiAgICAgICAgICAgICAgbW0gPSBbIG1hdGNoWzFdLCBtYXRjaFsyXSBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICBtbSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW0gPSBtYXRjaFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbW0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy9cbiAgICAvLyBHZW5lcmljIHN0YXRlIG1hY2hpbmUgYWN0aW9uc1xuICAgIC8vXG4gICAgYWN0aW9uczoge1xuICAgICAgJ2E9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuYSA9IChidWZmZXIuYSB8fCBcIlwiKSArIG07IH0sXG4gICAgICAnYj0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5iID0gKGJ1ZmZlci5iIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdwPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnAgPSAoYnVmZmVyLnAgfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ289JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIubyA9IChidWZmZXIubyB8fCBcIlwiKSArIG07IH0sXG4gICAgICAncT0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5xID0gKGJ1ZmZlci5xIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdkPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLmQgPSAoYnVmZmVyLmQgfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ3JtPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJtID0gKGJ1ZmZlci5ybSB8fCBcIlwiKSArIG07IH0sXG4gICAgICAndGV4dD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci50ZXh0XyA9IChidWZmZXIudGV4dF8gfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ2luc2VydCc6IGZ1bmN0aW9uIChidWZmZXIsIG0sIGEpIHsgcmV0dXJuIHsgdHlwZV86IGEgfTsgfSxcbiAgICAgICdpbnNlcnQrcDEnOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBhKSB7IHJldHVybiB7IHR5cGVfOiBhLCBwMTogbSB9OyB9LFxuICAgICAgJ2luc2VydCtwMStwMic6IGZ1bmN0aW9uIChidWZmZXIsIG0sIGEpIHsgcmV0dXJuIHsgdHlwZV86IGEsIHAxOiBtWzBdLCBwMjogbVsxXSB9OyB9LFxuICAgICAgJ2NvcHknOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiBtOyB9LFxuICAgICAgJ3JtJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4geyB0eXBlXzogJ3JtJywgcDE6IG0gfHwgXCJcIn07IH0sXG4gICAgICAndGV4dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtLCAndGV4dCcpOyB9LFxuICAgICAgJ3t0ZXh0fSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgdmFyIHJldCA9IFsgXCJ7XCIgXTtcbiAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmdvKG0sICd0ZXh0JykpO1xuICAgICAgICByZXQucHVzaChcIn1cIik7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9LFxuICAgICAgJ3RleC1tYXRoJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLmdvKG0sICd0ZXgtbWF0aCcpOyB9LFxuICAgICAgJ3RleC1tYXRoIHRpZ2h0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLmdvKG0sICd0ZXgtbWF0aCB0aWdodCcpOyB9LFxuICAgICAgJ2JvbmQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBrKSB7IHJldHVybiB7IHR5cGVfOiAnYm9uZCcsIGtpbmRfOiBrIHx8IG0gfTsgfSxcbiAgICAgICdjb2xvcjAtb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4geyB0eXBlXzogJ2NvbG9yMCcsIGNvbG9yOiBtWzBdIH07IH0sXG4gICAgICAnY2UnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiBtaGNoZW1QYXJzZXIuZ28obSk7IH0sXG4gICAgICAnMS8yJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgIGlmIChtLm1hdGNoKC9eWytcXC1dLykpIHtcbiAgICAgICAgICByZXQucHVzaChtLnN1YnN0cigwLCAxKSk7XG4gICAgICAgICAgbSA9IG0uc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gbS5tYXRjaCgvXihbMC05XSt8XFwkW2Etel1cXCR8W2Etel0pXFwvKFswLTldKykoXFwkW2Etel1cXCR8W2Etel0pPyQvKTtcbiAgICAgICAgblsxXSA9IG5bMV0ucmVwbGFjZSgvXFwkL2csIFwiXCIpO1xuICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnZnJhYycsIHAxOiBuWzFdLCBwMjogblsyXSB9KTtcbiAgICAgICAgaWYgKG5bM10pIHtcbiAgICAgICAgICBuWzNdID0gblszXS5yZXBsYWNlKC9cXCQvZywgXCJcIik7XG4gICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ3RleC1tYXRoJywgcDE6IG5bM10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICAnOSw5JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLmdvKG0sICc5LDknKTsgfVxuICAgIH0sXG4gICAgLy9cbiAgICAvLyBjcmVhdGVUcmFuc2l0aW9uc1xuICAgIC8vIGNvbnZlcnQgIHsgJ2xldHRlcic6IHsgJ3N0YXRlJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0gfSAgdG8gIHsgJ3N0YXRlJyA9PiBbIHsgcGF0dGVybjogJ2xldHRlcicsIHRhc2s6IHsgYWN0aW9uXzogW3t0eXBlXzogJ291dHB1dCd9XSB9IH0gXSB9XG4gICAgLy8gd2l0aCBleHBhbnNpb24gb2YgJ2F8YicgdG8gJ2EnIGFuZCAnYicgKGF0IDIgcGxhY2VzKVxuICAgIC8vXG4gICAgY3JlYXRlVHJhbnNpdGlvbnM6IGZ1bmN0aW9uIChvKSB7XG4gICAgICB2YXIgcGF0dGVybiwgc3RhdGU7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ1tdfSAqL1xuICAgICAgdmFyIHN0YXRlQXJyYXk7XG4gICAgICB2YXIgaTtcbiAgICAgIC8vXG4gICAgICAvLyAxLiBDb2xsZWN0IGFsbCBzdGF0ZXNcbiAgICAgIC8vXG4gICAgICAvKiogQHR5cGUge1RyYW5zaXRpb25zfSAqL1xuICAgICAgdmFyIHRyYW5zaXRpb25zID0ge307XG4gICAgICBmb3IgKHBhdHRlcm4gaW4gbykge1xuICAgICAgICBmb3IgKHN0YXRlIGluIG9bcGF0dGVybl0pIHtcbiAgICAgICAgICBzdGF0ZUFycmF5ID0gc3RhdGUuc3BsaXQoXCJ8XCIpO1xuICAgICAgICAgIG9bcGF0dGVybl1bc3RhdGVdLnN0YXRlQXJyYXkgPSBzdGF0ZUFycmF5O1xuICAgICAgICAgIGZvciAoaT0wOyBpPHN0YXRlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25zW3N0YXRlQXJyYXlbaV1dID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL1xuICAgICAgLy8gMi4gRmlsbCBzdGF0ZXNcbiAgICAgIC8vXG4gICAgICBmb3IgKHBhdHRlcm4gaW4gbykge1xuICAgICAgICBmb3IgKHN0YXRlIGluIG9bcGF0dGVybl0pIHtcbiAgICAgICAgICBzdGF0ZUFycmF5ID0gb1twYXR0ZXJuXVtzdGF0ZV0uc3RhdGVBcnJheSB8fCBbXTtcbiAgICAgICAgICBmb3IgKGk9MDsgaTxzdGF0ZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMmEuIE5vcm1hbGl6ZSBhY3Rpb25zIGludG8gYXJyYXk6ICAndGV4dD0nID09PiBbe3R5cGVfOid0ZXh0PSd9XVxuICAgICAgICAgICAgLy8gKE5vdGUgdG8gbXlzZWxmOiBSZXNvbHZpbmcgdGhlIGZ1bmN0aW9uIGhlcmUgd291bGQgYmUgcHJvYmxlbWF0aWMuIEl0IHdvdWxkIG5lZWQgLmJpbmQgKGZvciAqdGhpcyopIGFuZCBjdXJyeWluZyAoZm9yICpvcHRpb24qKS4pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgICAgICAgICB2YXIgcCA9IG9bcGF0dGVybl1bc3RhdGVdO1xuICAgICAgICAgICAgaWYgKHAuYWN0aW9uXykge1xuICAgICAgICAgICAgICBwLmFjdGlvbl8gPSBbXS5jb25jYXQocC5hY3Rpb25fKTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaz0wOyBrPHAuYWN0aW9uXy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcC5hY3Rpb25fW2tdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICBwLmFjdGlvbl9ba10gPSB7IHR5cGVfOiBwLmFjdGlvbl9ba10gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAuYWN0aW9uXyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIDIuYiBNdWx0aS1pbnNlcnRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB2YXIgcGF0dGVybkFycmF5ID0gcGF0dGVybi5zcGxpdChcInxcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8cGF0dGVybkFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZUFycmF5W2ldID09PSAnKicpIHsgIC8vIGluc2VydCBpbnRvIGFsbFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHQgaW4gdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zW3RdLnB1c2goeyBwYXR0ZXJuOiBwYXR0ZXJuQXJyYXlbal0sIHRhc2s6IHAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zW3N0YXRlQXJyYXlbaV1dLnB1c2goeyBwYXR0ZXJuOiBwYXR0ZXJuQXJyYXlbal0sIHRhc2s6IHAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2l0aW9ucztcbiAgICB9LFxuICAgIHN0YXRlTWFjaGluZXM6IHt9XG4gIH07XG5cbiAgLy9cbiAgLy8gRGVmaW5pdGlvbiBvZiBzdGF0ZSBtYWNoaW5lc1xuICAvL1xuICBtaGNoZW1QYXJzZXIuc3RhdGVNYWNoaW5lcyA9IHtcbiAgICAvL1xuICAgIC8vIFxcY2Ugc3RhdGUgbWFjaGluZXNcbiAgICAvL1xuICAgIC8vI3JlZ2lvbiBjZVxuICAgICdjZSc6IHsgIC8vIG1haW4gcGFyc2VyXG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0sXG4gICAgICAgICdlbHNlJzogIHtcbiAgICAgICAgICAnMHwxfDInOiB7IGFjdGlvbl86ICdiZWdpbnNXaXRoQm9uZD1mYWxzZScsIHJldmlzaXQ6IHRydWUsIHRvQ29udGludWU6IHRydWUgfSB9LFxuICAgICAgICAnb3hpZGF0aW9uJCc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ294aWRhdGlvbi1vdXRwdXQnIH0gfSxcbiAgICAgICAgJ0NNVCc6IHtcbiAgICAgICAgICAncic6IHsgYWN0aW9uXzogJ3JkdD0nLCBuZXh0U3RhdGU6ICdydCcgfSxcbiAgICAgICAgICAncmQnOiB7IGFjdGlvbl86ICdycXQ9JywgbmV4dFN0YXRlOiAncmR0JyB9IH0sXG4gICAgICAgICdhcnJvd1VwRG93bic6IHtcbiAgICAgICAgICAnMHwxfDJ8YXMnOiB7IGFjdGlvbl86IFsgJ3NiPWZhbHNlJywgJ291dHB1dCcsICdvcGVyYXRvcicgXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAndXByaWdodEVudGl0aWVzJzoge1xuICAgICAgICAgICcwfDF8Mic6IHsgYWN0aW9uXzogWyAnbz0nLCAnb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICdvcmJpdGFsJzoge1xuICAgICAgICAgICcwfDF8MnwzJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICctPic6IHtcbiAgICAgICAgICAnMHwxfDJ8Myc6IHsgYWN0aW9uXzogJ3I9JywgbmV4dFN0YXRlOiAncicgfSxcbiAgICAgICAgICAnYXxhcyc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3I9JyBdLCBuZXh0U3RhdGU6ICdyJyB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAncj0nIF0sIG5leHRTdGF0ZTogJ3InIH0gfSxcbiAgICAgICAgJysnOiB7XG4gICAgICAgICAgJ28nOiB7IGFjdGlvbl86ICdkPSBrdicsICBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICdkfEQnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJ3EnOiB7IGFjdGlvbl86ICdkPScsICBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAncWR8cUQnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2Q9JyBdLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICczJzogeyBhY3Rpb25fOiBbICdzYj1mYWxzZScsICdvdXRwdXQnLCAnb3BlcmF0b3InIF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ2Ftb3VudCc6IHtcbiAgICAgICAgICAnMHwyJzogeyBhY3Rpb25fOiAnYT0nLCBuZXh0U3RhdGU6ICdhJyB9IH0sXG4gICAgICAgICdwbS1vcGVyYXRvcic6IHtcbiAgICAgICAgICAnMHwxfDJ8YXxhcyc6IHsgYWN0aW9uXzogWyAnc2I9ZmFsc2UnLCAnb3V0cHV0JywgeyB0eXBlXzogJ29wZXJhdG9yJywgb3B0aW9uOiAnXFxcXHBtJyB9IF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ29wZXJhdG9yJzoge1xuICAgICAgICAgICcwfDF8MnxhfGFzJzogeyBhY3Rpb25fOiBbICdzYj1mYWxzZScsICdvdXRwdXQnLCAnb3BlcmF0b3InIF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJy0kJzoge1xuICAgICAgICAgICdvfHEnOiB7IGFjdGlvbl86IFsgJ2NoYXJnZSBvciBib25kJywgJ291dHB1dCcgXSwgIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdkJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICdEJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiAnZD0nLCAgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ3FkJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAncUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJy05Jzoge1xuICAgICAgICAgICczfG8nOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdoeXBoZW4nIH0gXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnLSBvcmJpdGFsIG92ZXJsYXAnOiB7XG4gICAgICAgICAgJ28nOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdoeXBoZW4nIH0gXSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnZCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2h5cGhlbicgfSBdLCBuZXh0U3RhdGU6ICcyJyB9IH0sXG4gICAgICAgICctJzoge1xuICAgICAgICAgICcwfDF8Mic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sICdiZWdpbnNXaXRoQm9uZD10cnVlJywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAnMyc6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gfSxcbiAgICAgICAgICAnYSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2h5cGhlbicgfSBdLCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICdhcyc6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgJ2InOiB7IGFjdGlvbl86ICdiPScgfSxcbiAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogeyB0eXBlXzogJy0gYWZ0ZXIgby9kJywgb3B0aW9uOiBmYWxzZSB9LCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnLSBhZnRlciBvL2QnLCBvcHRpb246IGZhbHNlIH0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJ2R8cWR8ZHEnOiB7IGFjdGlvbl86IHsgdHlwZV86ICctIGFmdGVyIG8vZCcsIG9wdGlvbjogdHJ1ZSB9LCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICdEfHFEfHAnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ2Ftb3VudDInOiB7XG4gICAgICAgICAgJzF8Myc6IHsgYWN0aW9uXzogJ2E9JywgbmV4dFN0YXRlOiAnYScgfSB9LFxuICAgICAgICAnbGV0dGVycyc6IHtcbiAgICAgICAgICAnMHwxfDJ8M3xhfGFzfGJ8cHxicHxvJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICdxfGRxJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdvPSddLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICdkfER8cWR8cUQnOiB7IGFjdGlvbl86ICdvIGFmdGVyIGQnLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICdkaWdpdHMnOiB7XG4gICAgICAgICAgJ28nOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ3EnIH0sXG4gICAgICAgICAgJ2R8RCc6IHsgYWN0aW9uXzogJ3E9JywgbmV4dFN0YXRlOiAnZHEnIH0sXG4gICAgICAgICAgJ3EnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdvPScgXSwgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAnYSc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnc3BhY2UgQSc6IHtcbiAgICAgICAgICAnYnxwfGJwJzoge30gfSxcbiAgICAgICAgJ3NwYWNlJzoge1xuICAgICAgICAgICdhJzogeyBuZXh0U3RhdGU6ICdhcycgfSxcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ3NiPWZhbHNlJyB9LFxuICAgICAgICAgICcxfDInOiB7IGFjdGlvbl86ICdzYj10cnVlJyB9LFxuICAgICAgICAgICdyfHJ0fHJkfHJkdHxyZHEnOiB7IGFjdGlvbl86ICdvdXRwdXQnLCBuZXh0U3RhdGU6ICcwJyB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnc2I9dHJ1ZScgXSwgbmV4dFN0YXRlOiAnMSd9IH0sXG4gICAgICAgICcxc3QtbGV2ZWwgZXNjYXBlJzoge1xuICAgICAgICAgICcxfDInOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdpbnNlcnQrcDEnLCBvcHRpb246ICcxc3QtbGV2ZWwgZXNjYXBlJyB9IF0gfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCtwMScsIG9wdGlvbjogJzFzdC1sZXZlbCBlc2NhcGUnIH0gXSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnWyguLi4pXSc6IHtcbiAgICAgICAgICAncnxydCc6IHsgYWN0aW9uXzogJ3JkPScsIG5leHRTdGF0ZTogJ3JkJyB9LFxuICAgICAgICAgICdyZHxyZHQnOiB7IGFjdGlvbl86ICdycT0nLCBuZXh0U3RhdGU6ICdyZHEnIH0gfSxcbiAgICAgICAgJy4uLic6IHtcbiAgICAgICAgICAnb3xkfER8ZHF8cWR8cUQnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi4uLlwiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sIHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdlbGxpcHNpcycgfSBdLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICcuIHwqICc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2FkZGl0aW9uIGNvbXBvdW5kJyB9IF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uICQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbicgXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAne1soJzoge1xuICAgICAgICAgICdhfGFzfG8nOiB7IGFjdGlvbl86IFsgJ289JywgJ291dHB1dCcsICdwYXJlbnRoZXNpc0xldmVsKysnIF0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJzB8MXwyfDMnOiB7IGFjdGlvbl86IFsgJ289JywgJ291dHB1dCcsICdwYXJlbnRoZXNpc0xldmVsKysnIF0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdvPScsICdvdXRwdXQnLCAncGFyZW50aGVzaXNMZXZlbCsrJyBdLCBuZXh0U3RhdGU6ICcyJyB9IH0sXG4gICAgICAgICcpXX0nOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YnxwfGJwfG8nOiB7IGFjdGlvbl86IFsgJ289JywgJ3BhcmVudGhlc2lzTGV2ZWwtLScgXSwgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAnYXxhc3xkfER8cXxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ289JywgJ3BhcmVudGhlc2lzTGV2ZWwtLScgXSwgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnLCAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdjb21tYScgXSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnXl8nOiB7ICAvLyBeIGFuZCBfIHdpdGhvdXQgYSBzZW5zaWJsZSBhcmd1bWVudFxuICAgICAgICAgICcqJzogeyB9IH0sXG4gICAgICAgICdeeyguLi4pfXxeKCQuLi4kKSc6IHtcbiAgICAgICAgICAnMHwxfDJ8YXMnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2InIH0sXG4gICAgICAgICAgJ3AnOiB7IGFjdGlvbl86ICdiPScsIG5leHRTdGF0ZTogJ2JwJyB9LFxuICAgICAgICAgICczfG8nOiB7IGFjdGlvbl86ICdkPSBrdicsIG5leHRTdGF0ZTogJ0QnIH0sXG4gICAgICAgICAgJ3EnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ3FEJyB9LFxuICAgICAgICAgICdkfER8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdkPScgXSwgbmV4dFN0YXRlOiAnRCcgfSB9LFxuICAgICAgICAnXmF8XlxcXFx4e317fXxeXFxcXHh7fXxeXFxcXHh8XFwnJzoge1xuICAgICAgICAgICcwfDF8Mnxhcyc6IHsgYWN0aW9uXzogJ2I9JywgbmV4dFN0YXRlOiAnYicgfSxcbiAgICAgICAgICAncCc6IHsgYWN0aW9uXzogJ2I9JywgbmV4dFN0YXRlOiAnYnAnIH0sXG4gICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogJ2Q9IGt2JywgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ2R8cWR8RHxxRCc6IHsgYWN0aW9uXzogJ2Q9JyB9LFxuICAgICAgICAgICdkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2Q9JyBdLCBuZXh0U3RhdGU6ICdkJyB9IH0sXG4gICAgICAgICdfeyhzdGF0ZSBvZiBhZ2dyZWdhdGlvbil9JCc6IHtcbiAgICAgICAgICAnZHxEfHF8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdxPScgXSwgbmV4dFN0YXRlOiAncScgfSB9LFxuICAgICAgICAnX3soLi4uKX18XygkLi4uJCl8Xzl8X1xcXFx4e317fXxfXFxcXHh7fXxfXFxcXHgnOiB7XG4gICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiAncD0nLCBuZXh0U3RhdGU6ICdwJyB9LFxuICAgICAgICAgICdiJzogeyBhY3Rpb25fOiAncD0nLCBuZXh0U3RhdGU6ICdicCcgfSxcbiAgICAgICAgICAnM3xvJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdxJyB9LFxuICAgICAgICAgICdkfEQnOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ2RxJyB9LFxuICAgICAgICAgICdxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAncT0nIF0sIG5leHRTdGF0ZTogJ3EnIH0gfSxcbiAgICAgICAgJz08Pic6IHtcbiAgICAgICAgICAnMHwxfDJ8M3xhfGFzfG98cXxkfER8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnYm9uZCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnIyc6IHtcbiAgICAgICAgICAnMHwxfDJ8M3xhfGFzfG8nOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCIjXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICd7fSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAney4uLn0nOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xifHB8YnAnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgJ298ZHxEfHF8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdvPScgXSwgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnJC4uLiQnOiB7XG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86ICdhPScgfSwgIC8vIDIkbiRcbiAgICAgICAgICAnMHwxfDJ8M3xhc3xifHB8YnB8byc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfSwgIC8vIG5vdCAnYW1vdW50J1xuICAgICAgICAgICdhc3xvJzogeyBhY3Rpb25fOiAnbz0nIH0sXG4gICAgICAgICAgJ3F8ZHxEfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nIF0sIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJ1xcXFxib25keyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdib25kJyBdLCBuZXh0U3RhdGU6IFwiM1wiIH0gfSxcbiAgICAgICAgJ1xcXFxmcmFjeyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sICdmcmFjLW91dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXG92ZXJzZXR7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ292ZXJzZXQtb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdcXFxcdW5kZXJzZXR7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ3VuZGVyc2V0LW91dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXHVuZGVyYnJhY2V7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ3VuZGVyYnJhY2Utb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9eyguLi4pfTF8XFxcXGNvbG9yKC4uLil7KC4uLil9Mic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdjb2xvci1vdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX0wJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ2NvbG9yMC1vdXRwdXQnIF0gfSB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdjZScgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXCwnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMSB9LCAnY29weScgXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnXFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJzB8MXwyfDN8YXxhc3xifHB8YnB8b3xjMCc6IHsgYWN0aW9uXzogWyAnbz0nLCAnb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbJ291dHB1dCcsICdvPScsICdvdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ290aGVycyc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sICdjb3B5JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAnYSc6IHsgYWN0aW9uXzogJ2EgdG8gbycsIG5leHRTdGF0ZTogJ28nLCByZXZpc2l0OiB0cnVlIH0sXG4gICAgICAgICAgJ2FzJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnc2I9dHJ1ZScgXSwgbmV4dFN0YXRlOiAnMScsIHJldmlzaXQ6IHRydWUgfSxcbiAgICAgICAgICAncnxydHxyZHxyZHR8cmRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnIF0sIG5leHRTdGF0ZTogJzAnLCByZXZpc2l0OiB0cnVlIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdjb3B5JyBdLCBuZXh0U3RhdGU6ICczJyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnbyBhZnRlciBkJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYgKChidWZmZXIuZCB8fCBcIlwiKS5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgdmFyIHRtcCA9IGJ1ZmZlci5kO1xuICAgICAgICAgICAgYnVmZmVyLmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXQgPSB0aGlzWydvdXRwdXQnXShidWZmZXIpO1xuICAgICAgICAgICAgYnVmZmVyLmIgPSB0bXA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXNbJ291dHB1dCddKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1oY2hlbVBhcnNlci5hY3Rpb25zWydvPSddKGJ1ZmZlciwgbSk7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ2Q9IGt2JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIGJ1ZmZlci5kID0gbTtcbiAgICAgICAgICBidWZmZXIuZFR5cGUgPSAna3YnO1xuICAgICAgICB9LFxuICAgICAgICAnY2hhcmdlIG9yIGJvbmQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlclsnYmVnaW5zV2l0aEJvbmQnXSkge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIHRoaXNbJ291dHB1dCddKGJ1ZmZlcikpO1xuICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmFjdGlvbnNbJ2JvbmQnXShidWZmZXIsIG0sIFwiLVwiKSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIuZCA9IG07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnLSBhZnRlciBvL2QnOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBpc0FmdGVyRCkge1xuICAgICAgICAgIHZhciBjMSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ29yYml0YWwnLCBidWZmZXIubyB8fCBcIlwiKTtcbiAgICAgICAgICB2YXIgYzIgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdvbmUgbG93ZXJjYXNlIGdyZWVrIGxldHRlciAkJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgdmFyIGMzID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnb25lIGxvd2VyY2FzZSBsYXRpbiBsZXR0ZXIgJCcsIGJ1ZmZlci5vIHx8IFwiXCIpO1xuICAgICAgICAgIHZhciBjNCA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJyRvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciQgJCcsIGJ1ZmZlci5vIHx8IFwiXCIpO1xuICAgICAgICAgIHZhciBoeXBoZW5Gb2xsb3dzID0gIG09PT1cIi1cIiAmJiAoIGMxICYmIGMxLnJlbWFpbmRlcj09PVwiXCIgIHx8ICBjMiAgfHwgIGMzICB8fCAgYzQgKTtcbiAgICAgICAgICBpZiAoaHlwaGVuRm9sbG93cyAmJiAhYnVmZmVyLmEgJiYgIWJ1ZmZlci5iICYmICFidWZmZXIucCAmJiAhYnVmZmVyLmQgJiYgIWJ1ZmZlci5xICYmICFjMSAmJiBjMykge1xuICAgICAgICAgICAgYnVmZmVyLm8gPSAnJCcgKyBidWZmZXIubyArICckJztcbiAgICAgICAgICB9XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgaWYgKGh5cGhlbkZvbGxvd3MpIHtcbiAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIHRoaXNbJ291dHB1dCddKGJ1ZmZlcikpO1xuICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2h5cGhlbicgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMxID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnZGlnaXRzJywgYnVmZmVyLmQgfHwgXCJcIik7XG4gICAgICAgICAgICBpZiAoaXNBZnRlckQgJiYgYzEgJiYgYzEucmVtYWluZGVyPT09JycpIHtcbiAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmFjdGlvbnNbJ2Q9J10oYnVmZmVyLCBtKSk7XG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIHRoaXNbJ291dHB1dCddKGJ1ZmZlcikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgdGhpc1snb3V0cHV0J10oYnVmZmVyKSk7XG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5hY3Rpb25zWydib25kJ10oYnVmZmVyLCBtLCBcIi1cIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnYSB0byBvJzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlci5vID0gYnVmZmVyLmE7XG4gICAgICAgICAgYnVmZmVyLmEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0sXG4gICAgICAgICdzYj10cnVlJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXIuc2IgPSB0cnVlOyB9LFxuICAgICAgICAnc2I9ZmFsc2UnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlci5zYiA9IGZhbHNlOyB9LFxuICAgICAgICAnYmVnaW5zV2l0aEJvbmQ9dHJ1ZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyWydiZWdpbnNXaXRoQm9uZCddID0gdHJ1ZTsgfSxcbiAgICAgICAgJ2JlZ2luc1dpdGhCb25kPWZhbHNlJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXJbJ2JlZ2luc1dpdGhCb25kJ10gPSBmYWxzZTsgfSxcbiAgICAgICAgJ3BhcmVudGhlc2lzTGV2ZWwrKyc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyWydwYXJlbnRoZXNpc0xldmVsJ10rKzsgfSxcbiAgICAgICAgJ3BhcmVudGhlc2lzTGV2ZWwtLSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyWydwYXJlbnRoZXNpc0xldmVsJ10tLTsgfSxcbiAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnc3RhdGUgb2YgYWdncmVnYXRpb24nLCBwMTogbWhjaGVtUGFyc2VyLmdvKG0sICdvJykgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbW1hJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHZhciBhID0gbS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbiAgICAgICAgICB2YXIgd2l0aFNwYWNlID0gKGEgIT09IG0pO1xuICAgICAgICAgIGlmICh3aXRoU3BhY2UgICYmICBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb21tYSBlbnVtZXJhdGlvbiBMJywgcDE6IGEgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb21tYSBlbnVtZXJhdGlvbiBNJywgcDE6IGEgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtLCBlbnRpdHlGb2xsb3dzKSB7XG4gICAgICAgICAgLy8gZW50aXR5Rm9sbG93czpcbiAgICAgICAgICAvLyAgIHVuZGVmaW5lZCA9IGlmIHdlIGhhdmUgbm90aGluZyBlbHNlIHRvIG91dHB1dCwgYWxzbyBpZ25vcmUgdGhlIGp1c3QgcmVhZCBzcGFjZSAoYnVmZmVyLnNiKVxuICAgICAgICAgIC8vICAgMSA9IGFuIGVudGl0eSBmb2xsb3dzLCBuZXZlciBvbWl0IHRoZSBzcGFjZSBpZiB0aGVyZSB3YXMgb25lIGp1c3QgcmVhZCBiZWZvcmUgKGNhbiBvbmx5IGFwcGx5IHRvIHN0YXRlIDEpXG4gICAgICAgICAgLy8gICAyID0gMSArIHRoZSBlbnRpdHkgY2FuIGhhdmUgYW4gYW1vdW50LCBzbyBvdXRwdXQgYVxcLCBpbnN0ZWFkIG9mIGNvbnZlcnRpbmcgaXQgdG8gbyAoY2FuIG9ubHkgYXBwbHkgdG8gc3RhdGVzIGF8YXMpXG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXQgfCBQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIGlmICghYnVmZmVyLnIpIHtcbiAgICAgICAgICAgIHJldCA9IFtdO1xuICAgICAgICAgICAgaWYgKCFidWZmZXIuYSAmJiAhYnVmZmVyLmIgJiYgIWJ1ZmZlci5wICYmICFidWZmZXIubyAmJiAhYnVmZmVyLnEgJiYgIWJ1ZmZlci5kICYmICFlbnRpdHlGb2xsb3dzKSB7XG4gICAgICAgICAgICAgIC8vcmV0ID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoYnVmZmVyLnNiKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ2VudGl0eVNraXAnIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghYnVmZmVyLm8gJiYgIWJ1ZmZlci5xICYmICFidWZmZXIuZCAmJiAhYnVmZmVyLmIgJiYgIWJ1ZmZlci5wICYmIGVudGl0eUZvbGxvd3MhPT0yKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLm8gPSBidWZmZXIuYTtcbiAgICAgICAgICAgICAgICBidWZmZXIuYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghYnVmZmVyLm8gJiYgIWJ1ZmZlci5xICYmICFidWZmZXIuZCAmJiAoYnVmZmVyLmIgfHwgYnVmZmVyLnApKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLm8gPSBidWZmZXIuYTtcbiAgICAgICAgICAgICAgICBidWZmZXIuZCA9IGJ1ZmZlci5iO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5xID0gYnVmZmVyLnA7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmEgPSBidWZmZXIuYiA9IGJ1ZmZlci5wID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChidWZmZXIubyAmJiBidWZmZXIuZFR5cGU9PT0na3YnICYmIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ2Qtb3hpZGF0aW9uJCcsIGJ1ZmZlci5kIHx8IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICBidWZmZXIuZFR5cGUgPSAnb3hpZGF0aW9uJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5vICYmIGJ1ZmZlci5kVHlwZT09PSdrdicgJiYgIWJ1ZmZlci5xKSB7XG4gICAgICAgICAgICAgICAgICBidWZmZXIuZFR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlXzogJ2NoZW1maXZlJyxcbiAgICAgICAgICAgICAgICBhOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLmEsICdhJyksXG4gICAgICAgICAgICAgICAgYjogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5iLCAnYmQnKSxcbiAgICAgICAgICAgICAgICBwOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnAsICdwcScpLFxuICAgICAgICAgICAgICAgIG86IG1oY2hlbVBhcnNlci5nbyhidWZmZXIubywgJ28nKSxcbiAgICAgICAgICAgICAgICBxOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnEsICdwcScpLFxuICAgICAgICAgICAgICAgIGQ6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIuZCwgKGJ1ZmZlci5kVHlwZSA9PT0gJ294aWRhdGlvbicgPyAnb3hpZGF0aW9uJyA6ICdiZCcpKSxcbiAgICAgICAgICAgICAgICBkVHlwZTogYnVmZmVyLmRUeXBlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7ICAvLyByXG4gICAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgICAgdmFyIHJkO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5yZHQgPT09ICdNJykge1xuICAgICAgICAgICAgICByZCA9IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucmQsICd0ZXgtbWF0aCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIucmR0ID09PSAnVCcpIHtcbiAgICAgICAgICAgICAgcmQgPSBbIHsgdHlwZV86ICd0ZXh0JywgcDE6IGJ1ZmZlci5yZCB8fCBcIlwiIH0gXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJkID0gbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgICAgdmFyIHJxO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5ycXQgPT09ICdNJykge1xuICAgICAgICAgICAgICBycSA9IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucnEsICd0ZXgtbWF0aCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChidWZmZXIucnF0ID09PSAnVCcpIHtcbiAgICAgICAgICAgICAgcnEgPSBbIHsgdHlwZV86ICd0ZXh0JywgcDE6IGJ1ZmZlci5ycSB8fCBcIlwifSBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnEgPSBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnJxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldCA9IHtcbiAgICAgICAgICAgICAgdHlwZV86ICdhcnJvdycsXG4gICAgICAgICAgICAgIHI6IGJ1ZmZlci5yLFxuICAgICAgICAgICAgICByZDogcmQsXG4gICAgICAgICAgICAgIHJxOiBycVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChwICE9PSAncGFyZW50aGVzaXNMZXZlbCcgICYmICBwICE9PSAnYmVnaW5zV2l0aEJvbmQnKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBidWZmZXJbcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdveGlkYXRpb24tb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHZhciByZXQgPSBbIFwie1wiIF07XG4gICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmdvKG0sICdveGlkYXRpb24nKSk7XG4gICAgICAgICAgcmV0LnB1c2goXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdmcmFjLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2ZyYWMtY2UnLCBwMTogbWhjaGVtUGFyc2VyLmdvKG1bMF0pLCBwMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0pIH07XG4gICAgICAgIH0sXG4gICAgICAgICdvdmVyc2V0LW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ292ZXJzZXQnLCBwMTogbWhjaGVtUGFyc2VyLmdvKG1bMF0pLCBwMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0pIH07XG4gICAgICAgIH0sXG4gICAgICAgICd1bmRlcnNldC1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICd1bmRlcnNldCcsIHAxOiBtaGNoZW1QYXJzZXIuZ28obVswXSksIHAyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3VuZGVyYnJhY2Utb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAndW5kZXJicmFjZScsIHAxOiBtaGNoZW1QYXJzZXIuZ28obVswXSksIHAyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbG9yLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2NvbG9yJywgY29sb3IxOiBtWzBdLCBjb2xvcjI6IG1oY2hlbVBhcnNlci5nbyhtWzFdKSB9O1xuICAgICAgICB9LFxuICAgICAgICAncj0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5yID0gbTsgfSxcbiAgICAgICAgJ3JkdD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5yZHQgPSBtOyB9LFxuICAgICAgICAncmQ9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucmQgPSBtOyB9LFxuICAgICAgICAncnF0PSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJxdCA9IG07IH0sXG4gICAgICAgICdycT0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5ycSA9IG07IH0sXG4gICAgICAgICdvcGVyYXRvcic6IGZ1bmN0aW9uIChidWZmZXIsIG0sIHAxKSB7IHJldHVybiB7IHR5cGVfOiAnb3BlcmF0b3InLCBraW5kXzogKHAxIHx8IG0pIH07IH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdhJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHt9IH0sXG4gICAgICAgICcxLzIkJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnMS8yJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICcxJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICckKC4uLikkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGggdGlnaHQnLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICcsJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnY29tbWFEZWNpbWFsJyB9IH0gfSxcbiAgICAgICAgJ2Vsc2UyJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHt9XG4gICAgfSxcbiAgICAnbyc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAnMS8yJCc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJzEvMicgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnMScsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnbGV0dGVycyc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JtJyB9IH0sXG4gICAgICAgICdcXFxcY2EnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdjaXJjYScgfSB9IH0sXG4gICAgICAgICdcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfSxcbiAgICAgICAgJyR7KC4uLil9JHwkKC4uLikkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ3soLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd7dGV4dH0nIH0gfSxcbiAgICAgICAgJ2Vsc2UyJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHt9XG4gICAgfSxcbiAgICAndGV4dCc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSxcbiAgICAgICAgJ3suLi59Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4dD0nIH0gfSxcbiAgICAgICAgJyR7KC4uLil9JHwkKC4uLikkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ1xcXFxncmVlayc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3JtJyBdIH0gfSxcbiAgICAgICAgJ1xcXFwsfFxcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY29weScgXSB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4dD0nIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci50ZXh0Xykge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXR9ICovXG4gICAgICAgICAgICB2YXIgcmV0ID0geyB0eXBlXzogJ3RleHQnLCBwMTogYnVmZmVyLnRleHRfIH07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3BxJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHt9IH0sXG4gICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbiAkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnc3RhdGUgb2YgYWdncmVnYXRpb24nIH0gfSxcbiAgICAgICAgJ2kkJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICchZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnKEtWIGxldHRlcnMpLCc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ3JtJywgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnZm9ybXVsYSQnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJ2YnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJzEvMiQnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICcxLzInIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJyFmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICd7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4dCcgfSB9LFxuICAgICAgICAnYS16Jzoge1xuICAgICAgICAgICdmJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ2xldHRlcnMnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybScgfSB9LFxuICAgICAgICAnLTkuLDknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICc5LDknICB9IH0sXG4gICAgICAgICcsJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0K3AxJywgb3B0aW9uOiAnY29tbWEgZW51bWVyYXRpb24gUycgfSB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9eyguLi4pfTF8XFxcXGNvbG9yKC4uLil7KC4uLil9Mic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvbG9yLW91dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfTAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvcjAtb3V0cHV0JyB9IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY2UnIH0gfSxcbiAgICAgICAgJ1xcXFwsfFxcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9LFxuICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnc3RhdGUgb2YgYWdncmVnYXRpb24nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbiBzdWJzY3JpcHQnLCBwMTogbWhjaGVtUGFyc2VyLmdvKG0sICdvJykgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvbG9yLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2NvbG9yJywgY29sb3IxOiBtWzBdLCBjb2xvcjI6IG1oY2hlbVBhcnNlci5nbyhtWzFdLCAncHEnKSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnYmQnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJ3gkJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICchZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnZm9ybXVsYSQnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJ2YnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJyFmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICctOS4sOSBubyBtaXNzaW5nIDAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICc5LDknIH0gfSxcbiAgICAgICAgJy4nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdlbGVjdHJvbiBkb3QnIH0gfSB9LFxuICAgICAgICAnYS16Jzoge1xuICAgICAgICAgICdmJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ3gnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdLViB4JyB9IH0gfSxcbiAgICAgICAgJ2xldHRlcnMnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybScgfSB9LFxuICAgICAgICAnXFwnJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAncHJpbWUnIH0gfSB9LFxuICAgICAgICAnJHsoLi4uKX0kfCQoLi4uKSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAneyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleHQnIH0gfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX17KC4uLil9MXxcXFxcY29sb3IoLi4uKXsoLi4uKX0yJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29sb3Itb3V0cHV0JyB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9MCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvbG9yMC1vdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjZScgfSB9LFxuICAgICAgICAnXFxcXCx8XFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH0sXG4gICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdjb2xvci1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdjb2xvcicsIGNvbG9yMTogbVswXSwgY29sb3IyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSwgJ2JkJykgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ294aWRhdGlvbic6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAncm9tYW4gbnVtZXJhbCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JvbWFuLW51bWVyYWwnIH0gfSxcbiAgICAgICAgJyR7KC4uLil9JHwkKC4uLikkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAncm9tYW4tbnVtZXJhbCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIHsgdHlwZV86ICdyb21hbiBudW1lcmFsJywgcDE6IG0gfHwgXCJcIiB9OyB9XG4gICAgICB9XG4gICAgfSxcbiAgICAndGV4LW1hdGgnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY2UnIF0gfSB9LFxuICAgICAgICAney4uLn18XFxcXCx8XFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvPScgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ289JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIGlmIChidWZmZXIubykge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXR9ICovXG4gICAgICAgICAgICB2YXIgcmV0ID0geyB0eXBlXzogJ3RleC1tYXRoJywgcDE6IGJ1ZmZlci5vIH07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3RleC1tYXRoIHRpZ2h0Jzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2NlJyBdIH0gfSxcbiAgICAgICAgJ3suLi59fFxcXFwsfFxcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnbz0nIH0gfSxcbiAgICAgICAgJy18Kyc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RpZ2h0IG9wZXJhdG9yJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnbz0nIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICd0aWdodCBvcGVyYXRvcic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLm8gPSAoYnVmZmVyLm8gfHwgXCJcIikgKyBcIntcIittK1wifVwiOyB9LFxuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIGlmIChidWZmZXIubykge1xuICAgICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXR9ICovXG4gICAgICAgICAgICB2YXIgcmV0ID0geyB0eXBlXzogJ3RleC1tYXRoJywgcDE6IGJ1ZmZlci5vIH07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJzksOSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAnLCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvbW1hJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ2NvbW1hJzogZnVuY3Rpb24gKCkgeyByZXR1cm4geyB0eXBlXzogJ2NvbW1hRGVjaW1hbCcgfTsgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8jZW5kcmVnaW9uXG4gICAgLy9cbiAgICAvLyBcXHB1IHN0YXRlIG1hY2hpbmVzXG4gICAgLy9cbiAgICAvLyNyZWdpb24gcHVcbiAgICAncHUnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0sXG4gICAgICAgICdzcGFjZSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdzcGFjZScgXSB9IH0sXG4gICAgICAgICd7Wyh8KV19Jzoge1xuICAgICAgICAgICcwfGEnOiB7IGFjdGlvbl86ICdjb3B5JyB9IH0sXG4gICAgICAgICcoLSkoOSleKC05KSc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ251bWJlcl4nLCBuZXh0U3RhdGU6ICdhJyB9IH0sXG4gICAgICAgICcoLSkoOS4sOSkoZSkoOTkpJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnZW51bWJlcicsIG5leHRTdGF0ZTogJ2EnIH0gfSxcbiAgICAgICAgJ3NwYWNlJzoge1xuICAgICAgICAgICcwfGEnOiB7fSB9LFxuICAgICAgICAncG0tb3BlcmF0b3InOiB7XG4gICAgICAgICAgJzB8YSc6IHsgYWN0aW9uXzogeyB0eXBlXzogJ29wZXJhdG9yJywgb3B0aW9uOiAnXFxcXHBtJyB9LCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdvcGVyYXRvcic6IHtcbiAgICAgICAgICAnMHxhJzogeyBhY3Rpb25fOiAnY29weScsIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJy8vJzoge1xuICAgICAgICAgICdkJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICcvJyB9IH0sXG4gICAgICAgICcvJzoge1xuICAgICAgICAgICdkJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICcvJyB9IH0sXG4gICAgICAgICd7Li4ufXxlbHNlJzoge1xuICAgICAgICAgICcwfGQnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJ2EnOiB7IGFjdGlvbl86IFsgJ3NwYWNlJywgJ2Q9JyBdLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICcvfHEnOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ3EnIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdlbnVtYmVyJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgIGlmIChtWzBdID09PSBcIistXCIgIHx8ICBtWzBdID09PSBcIisvLVwiKSB7XG4gICAgICAgICAgICByZXQucHVzaChcIlxcXFxwbSBcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChtWzBdKSB7XG4gICAgICAgICAgICByZXQucHVzaChtWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1bMV0pIHtcbiAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtWzFdLCAncHUtOSw5JykpO1xuICAgICAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgaWYgKG1bMl0ubWF0Y2goL1ssLl0vKSkge1xuICAgICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIG1oY2hlbVBhcnNlci5nbyhtWzJdLCAncHUtOSw5JykpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKG1bMl0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtWzNdID0gbVs0XSB8fCBtWzNdO1xuICAgICAgICAgICAgaWYgKG1bM10pIHtcbiAgICAgICAgICAgICAgbVszXSA9IG1bM10udHJpbSgpO1xuICAgICAgICAgICAgICBpZiAobVszXSA9PT0gXCJlXCIgIHx8ICBtWzNdLnN1YnN0cigwLCAxKSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnY2RvdCcgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJ3RpbWVzJyB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobVszXSkge1xuICAgICAgICAgICAgcmV0LnB1c2goXCIxMF57XCIrbVs1XStcIn1cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdudW1iZXJeJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgIGlmIChtWzBdID09PSBcIistXCIgIHx8ICBtWzBdID09PSBcIisvLVwiKSB7XG4gICAgICAgICAgICByZXQucHVzaChcIlxcXFxwbSBcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChtWzBdKSB7XG4gICAgICAgICAgICByZXQucHVzaChtWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmdvKG1bMV0sICdwdS05LDknKSk7XG4gICAgICAgICAgcmV0LnB1c2goXCJee1wiK21bMl0rXCJ9XCIpO1xuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdvcGVyYXRvcic6IGZ1bmN0aW9uIChidWZmZXIsIG0sIHAxKSB7IHJldHVybiB7IHR5cGVfOiAnb3BlcmF0b3InLCBraW5kXzogKHAxIHx8IG0pIH07IH0sXG4gICAgICAgICdzcGFjZSc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICdwdS1zcGFjZS0xJyB9OyB9LFxuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0IHwgUGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICB2YXIgbWQgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCd7KC4uLil9JywgYnVmZmVyLmQgfHwgXCJcIik7XG4gICAgICAgICAgaWYgKG1kICAmJiAgbWQucmVtYWluZGVyID09PSAnJykgeyBidWZmZXIuZCA9IG1kLm1hdGNoXzsgfVxuICAgICAgICAgIHZhciBtcSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ3soLi4uKX0nLCBidWZmZXIucSB8fCBcIlwiKTtcbiAgICAgICAgICBpZiAobXEgICYmICBtcS5yZW1haW5kZXIgPT09ICcnKSB7IGJ1ZmZlci5xID0gbXEubWF0Y2hfOyB9XG4gICAgICAgICAgaWYgKGJ1ZmZlci5kKSB7XG4gICAgICAgICAgICBidWZmZXIuZCA9IGJ1ZmZlci5kLnJlcGxhY2UoL1xcdTAwQjBDfFxcXm9DfFxcXntvfUMvZywgXCJ7fV57XFxcXGNpcmN9Q1wiKTtcbiAgICAgICAgICAgIGJ1ZmZlci5kID0gYnVmZmVyLmQucmVwbGFjZSgvXFx1MDBCMEZ8XFxeb0Z8XFxee299Ri9nLCBcInt9XntcXFxcY2lyY31GXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYnVmZmVyLnEpIHsgIC8vIGZyYWN0aW9uXG4gICAgICAgICAgICBidWZmZXIucSA9IGJ1ZmZlci5xLnJlcGxhY2UoL1xcdTAwQjBDfFxcXm9DfFxcXntvfUMvZywgXCJ7fV57XFxcXGNpcmN9Q1wiKTtcbiAgICAgICAgICAgIGJ1ZmZlci5xID0gYnVmZmVyLnEucmVwbGFjZSgvXFx1MDBCMEZ8XFxeb0Z8XFxee299Ri9nLCBcInt9XntcXFxcY2lyY31GXCIpO1xuICAgICAgICAgICAgdmFyIGI1ID0ge1xuICAgICAgICAgICAgICBkOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLmQsICdwdScpLFxuICAgICAgICAgICAgICBxOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnEsICdwdScpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5vID09PSAnLy8nKSB7XG4gICAgICAgICAgICAgIHJldCA9IHsgdHlwZV86ICdwdS1mcmFjJywgcDE6IGI1LmQsIHAyOiBiNS5xIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXQgPSBiNS5kO1xuICAgICAgICAgICAgICBpZiAoYjUuZC5sZW5ndGggPiAxICB8fCAgYjUucS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJyAvICcgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJy8nIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShyZXQsIGI1LnEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7ICAvLyBubyBmcmFjdGlvblxuICAgICAgICAgICAgcmV0ID0gbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5kLCAncHUtMicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3B1LTInOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0sXG4gICAgICAgICcqJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY2RvdCcgXSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnXFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdybT0nIH0gfSxcbiAgICAgICAgJ3NwYWNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnc3BhY2UnIF0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ157KC4uLil9fF4oLTEpJzoge1xuICAgICAgICAgICcxJzogeyBhY3Rpb25fOiAnXigtMSknIH0gfSxcbiAgICAgICAgJy05Liw5Jzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAncm09JywgbmV4dFN0YXRlOiAnMCcgfSxcbiAgICAgICAgICAnMSc6IHsgYWN0aW9uXzogJ14oLTEpJywgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAney4uLn18ZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JtPScsIG5leHRTdGF0ZTogJzEnIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdjZG90JzogZnVuY3Rpb24gKCkgeyByZXR1cm4geyB0eXBlXzogJ3RpZ2h0IGNkb3QnIH07IH0sXG4gICAgICAgICdeKC0xKSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJtICs9IFwiXntcIittK1wifVwiOyB9LFxuICAgICAgICAnc3BhY2UnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAncHUtc3BhY2UtMicgfTsgfSxcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dCB8IFBhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBpZiAoYnVmZmVyLnJtKSB7XG4gICAgICAgICAgICB2YXIgbXJtID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygneyguLi4pfScsIGJ1ZmZlci5ybSB8fCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChtcm0gICYmICBtcm0ucmVtYWluZGVyID09PSAnJykge1xuICAgICAgICAgICAgICByZXQgPSBtaGNoZW1QYXJzZXIuZ28obXJtLm1hdGNoXywgJ3B1Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXQgPSB7IHR5cGVfOiAncm0nLCBwMTogYnVmZmVyLnJtIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAncHUtOSw5Jzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJ291dHB1dC0wJyB9LFxuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiAnb3V0cHV0LW8nIH0gfSxcbiAgICAgICAgJywnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86IFsgJ291dHB1dC0wJywgJ2NvbW1hJyBdLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICcuJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiBbICdvdXRwdXQtMCcsICdjb3B5JyBdLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4dD0nIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdjb21tYSc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICdjb21tYURlY2ltYWwnIH07IH0sXG4gICAgICAgICdvdXRwdXQtMCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBidWZmZXIudGV4dF8gPSBidWZmZXIudGV4dF8gfHwgXCJcIjtcbiAgICAgICAgICBpZiAoYnVmZmVyLnRleHRfLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIHZhciBhID0gYnVmZmVyLnRleHRfLmxlbmd0aCAlIDM7XG4gICAgICAgICAgICBpZiAoYSA9PT0gMCkgeyBhID0gMzsgfVxuICAgICAgICAgICAgZm9yICh2YXIgaT1idWZmZXIudGV4dF8ubGVuZ3RoLTM7IGk+MDsgaS09Mykge1xuICAgICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKGksIDMpKTtcbiAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJzEwMDAgc2VwYXJhdG9yJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xy5zdWJzdHIoMCwgYSkpO1xuICAgICAgICAgICAgcmV0LnJldmVyc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdvdXRwdXQtbyc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBidWZmZXIudGV4dF8gPSBidWZmZXIudGV4dF8gfHwgXCJcIjtcbiAgICAgICAgICBpZiAoYnVmZmVyLnRleHRfLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIHZhciBhID0gYnVmZmVyLnRleHRfLmxlbmd0aCAtIDM7XG4gICAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8YTsgaSs9Mykge1xuICAgICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8uc3Vic3RyKGksIDMpKTtcbiAgICAgICAgICAgICAgcmV0LnB1c2goeyB0eXBlXzogJzEwMDAgc2VwYXJhdG9yJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xy5zdWJzdHIoaSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyNlbmRyZWdpb25cbiAgfTtcblxuICAvL1xuICAvLyB0ZXhpZnk6IFRha2UgTWhjaGVtUGFyc2VyIG91dHB1dCBhbmQgY29udmVydCBpdCB0byBUZVhcbiAgLy9cbiAgLyoqIEB0eXBlIHtUZXhpZnl9ICovXG4gIHZhciB0ZXhpZnkgPSB7XG4gICAgZ286IGZ1bmN0aW9uIChpbnB1dCwgaXNJbm5lcikgeyAgLy8gKHJlY3Vyc2l2ZSwgbWF4IDQgbGV2ZWxzKVxuICAgICAgaWYgKCFpbnB1dCkgeyByZXR1cm4gXCJcIjsgfVxuICAgICAgdmFyIHJlcyA9IFwiXCI7XG4gICAgICB2YXIgY2VlID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpPTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRpID0gaW5wdXRbaV07XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmVzICs9IGlucHV0aTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgKz0gdGV4aWZ5Ll9nbzIoaW5wdXRpKTtcbiAgICAgICAgICBpZiAoaW5wdXRpLnR5cGVfID09PSAnMXN0LWxldmVsIGVzY2FwZScpIHsgY2VlID0gdHJ1ZTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzSW5uZXIgJiYgIWNlZSAmJiByZXMpIHtcbiAgICAgICAgcmVzID0gXCJ7XCIgKyByZXMgKyBcIn1cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBfZ29Jbm5lcjogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICBpZiAoIWlucHV0KSB7IHJldHVybiBpbnB1dDsgfVxuICAgICAgcmV0dXJuIHRleGlmeS5nbyhpbnB1dCwgdHJ1ZSk7XG4gICAgfSxcbiAgICBfZ28yOiBmdW5jdGlvbiAoYnVmKSB7XG4gICAgICAvKiogQHR5cGUge3VuZGVmaW5lZCB8IHN0cmluZ30gKi9cbiAgICAgIHZhciByZXM7XG4gICAgICBzd2l0Y2ggKGJ1Zi50eXBlXykge1xuICAgICAgICBjYXNlICdjaGVtZml2ZSc6XG4gICAgICAgICAgcmVzID0gXCJcIjtcbiAgICAgICAgICB2YXIgYjUgPSB7XG4gICAgICAgICAgICBhOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLmEpLFxuICAgICAgICAgICAgYjogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5iKSxcbiAgICAgICAgICAgIHA6IHRleGlmeS5fZ29Jbm5lcihidWYucCksXG4gICAgICAgICAgICBvOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLm8pLFxuICAgICAgICAgICAgcTogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5xKSxcbiAgICAgICAgICAgIGQ6IHRleGlmeS5fZ29Jbm5lcihidWYuZClcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gYVxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKGI1LmEpIHtcbiAgICAgICAgICAgIGlmIChiNS5hLm1hdGNoKC9eWytcXC1dLykpIHsgYjUuYSA9IFwie1wiK2I1LmErXCJ9XCI7IH1cbiAgICAgICAgICAgIHJlcyArPSBiNS5hICsgXCJcXFxcLFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIGIgYW5kIHBcbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChiNS5iIHx8IGI1LnApIHtcbiAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICByZXMgKz0gXCJee1xcXFxocGhhbnRvbXtcIisoYjUuYnx8XCJcIikrXCJ9fV97XFxcXGhwaGFudG9te1wiKyhiNS5wfHxcIlwiKStcIn19XCI7XG4gICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgLy8gSW4gdGhlIG5leHQgdHdvIGxpbmVzLCBJJ3ZlIHJlbW92ZWQgXFxzbWFzaFt0XSAocm9uKVxuICAgICAgICAgICAgLy8gVE9ETzogUmV2ZXJ0IFxcc21hc2hbdF0gd2hlbiBXZWJLaXQgcHJvcGVybHkgcmVuZGVycyA8bXBhZGRlZD4gdy9oZWlnaHQ9XCIwXCJcbiAgICAgICAgICAgIC8vcmVzICs9IFwiXntcXFxcc21hc2hbdF17XFxcXHZwaGFudG9tezJ9fVxcXFxtYXRobGxhcHtcIisoYjUuYnx8XCJcIikrXCJ9fVwiO1xuICAgICAgICAgICAgcmVzICs9IFwiXntcXFxcdnBoYW50b217Mn1cXFxcbWF0aGxsYXB7XCIrKGI1LmJ8fFwiXCIpK1wifX1cIjtcbiAgICAgICAgICAgIC8vcmVzICs9IFwiX3tcXFxcdnBoYW50b217Mn1cXFxcbWF0aGxsYXB7XFxcXHNtYXNoW3Rde1wiKyhiNS5wfHxcIlwiKStcIn19fVwiO1xuICAgICAgICAgICAgcmVzICs9IFwiX3tcXFxcdnBoYW50b217Mn1cXFxcbWF0aGxsYXB7XCIrKGI1LnB8fFwiXCIpK1wifX1cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBvXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoYjUubykge1xuICAgICAgICAgICAgaWYgKGI1Lm8ubWF0Y2goL15bK1xcLV0vKSkgeyBiNS5vID0gXCJ7XCIrYjUubytcIn1cIjsgfVxuICAgICAgICAgICAgcmVzICs9IGI1Lm87XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gcSBhbmQgZFxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKGJ1Zi5kVHlwZSA9PT0gJ2t2Jykge1xuICAgICAgICAgICAgaWYgKGI1LmQgfHwgYjUucSkge1xuICAgICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGI1LmQpIHtcbiAgICAgICAgICAgICAgcmVzICs9IFwiXntcIitiNS5kK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGI1LnEpIHtcbiAgICAgICAgICAgICAgLy8gSW4gdGhlIG5leHQgbGluZSwgSSd2ZSByZW1vdmVkIFxcc21hc2hbdF0gKHJvbilcbiAgICAgICAgICAgICAgLy8gVE9ETzogUmV2ZXJ0IFxcc21hc2hbdF0gd2hlbiBXZWJLaXQgcHJvcGVybHkgcmVuZGVycyA8bXBhZGRlZD4gdy9oZWlnaHQ9XCIwXCJcbiAgICAgICAgICAgICAgLy9yZXMgKz0gXCJfe1xcXFxzbWFzaFt0XXtcIitiNS5xK1wifX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwiX3tcIitiNS5xK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoYnVmLmRUeXBlID09PSAnb3hpZGF0aW9uJykge1xuICAgICAgICAgICAgaWYgKGI1LmQpIHtcbiAgICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwiXntcIitiNS5kK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGI1LnEpIHtcbiAgICAgICAgICAgICAgLy8gQSBGaXJlZm94IGJ1ZyBhZGRzIGEgYm9ndXMgZGVwdGggdG8gPG1waGFudG9tPiwgc28gd2UgY2hhbmdlIFxcdnBoYW50b217WH0gdG8ge31cbiAgICAgICAgICAgICAgLy8gVE9ETzogUmVpbnN0YXRlIFxcdnBoYW50b217WH0gd2hlbiB0aGUgRmlyZWZveCBidWcgaXMgZml4ZWQuXG4vLyAgICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwie3t9fVwiO1xuICAgICAgICAgICAgICAvLyBJbiB0aGUgbmV4dCBsaW5lLCBJJ3ZlIHJlbW92ZWQgXFxzbWFzaFt0XSAocm9uKVxuICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZlcnQgXFxzbWFzaFt0XSB3aGVuIFdlYktpdCBwcm9wZXJseSByZW5kZXJzIDxtcGFkZGVkPiB3L2hlaWdodD1cIjBcIlxuICAgICAgICAgICAgICAvL3JlcyArPSBcIl97XFxcXHNtYXNoW3Rde1wiK2I1LnErXCJ9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJfe1wiK2I1LnErXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChiNS5xKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IFJlaW5zdGF0ZSBcXHZwaGFudG9te1h9IHdoZW4gdGhlIEZpcmVmb3ggYnVnIGlzIGZpeGVkLlxuLy8gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcInt7fX1cIjtcbiAgICAgICAgICAgICAgLy8gSW4gdGhlIG5leHQgbGluZSwgSSd2ZSByZW1vdmVkIFxcc21hc2hbdF0gKHJvbilcbiAgICAgICAgICAgICAgLy8gVE9ETzogUmV2ZXJ0IFxcc21hc2hbdF0gd2hlbiBXZWJLaXQgcHJvcGVybHkgcmVuZGVycyA8bXBhZGRlZD4gdy9oZWlnaHQ9XCIwXCJcbiAgICAgICAgICAgICAgLy9yZXMgKz0gXCJfe1xcXFxzbWFzaFt0XXtcIitiNS5xK1wifX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwiX3tcIitiNS5xK1wifVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGI1LmQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogUmVpbnN0YXRlIFxcdnBoYW50b217WH0gd2hlbiB0aGUgRmlyZWZveCBidWcgaXMgZml4ZWQuXG4vLyAgICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwie3t9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJee1wiK2I1LmQrXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdybSc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWF0aHJte1wiK2J1Zi5wMStcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgaWYgKGJ1Zi5wMS5tYXRjaCgvW1xcXl9dLykpIHtcbiAgICAgICAgICAgIGJ1Zi5wMSA9IGJ1Zi5wMS5yZXBsYWNlKFwiIFwiLCBcIn5cIikucmVwbGFjZShcIi1cIiwgXCJcXFxcdGV4dHstfVwiKTtcbiAgICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhybXtcIitidWYucDErXCJ9XCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IFwiXFxcXHRleHR7XCIrYnVmLnAxK1wifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncm9tYW4gbnVtZXJhbCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWF0aHJte1wiK2J1Zi5wMStcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3RhdGUgb2YgYWdncmVnYXRpb24nOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1za2lwMm11IFwiK3RleGlmeS5fZ29Jbm5lcihidWYucDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbiBzdWJzY3JpcHQnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1za2lwMW11IFwiK3RleGlmeS5fZ29Jbm5lcihidWYucDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib25kJzpcbiAgICAgICAgICByZXMgPSB0ZXhpZnkuX2dldEJvbmQoYnVmLmtpbmRfKTtcbiAgICAgICAgICBpZiAoIXJlcykge1xuICAgICAgICAgICAgdGhyb3cgW1wiTWhjaGVtRXJyb3JCb25kXCIsIFwibWhjaGVtIEVycm9yLiBVbmtub3duIGJvbmQgdHlwZSAoXCIgKyBidWYua2luZF8gKyBcIilcIl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmcmFjJzpcbiAgICAgICAgICB2YXIgYyA9IFwiXFxcXGZyYWN7XCIgKyBidWYucDEgKyBcIn17XCIgKyBidWYucDIgKyBcIn1cIjtcbiAgICAgICAgICByZXMgPSBcIlxcXFxtYXRoY2hvaWNle1xcXFx0ZXh0c3R5bGVcIitjK1wifXtcIitjK1wifXtcIitjK1wifXtcIitjK1wifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwdS1mcmFjJzpcbiAgICAgICAgICB2YXIgZCA9IFwiXFxcXGZyYWN7XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKSArIFwifXtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDIpICsgXCJ9XCI7XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWF0aGNob2ljZXtcXFxcdGV4dHN0eWxlXCIrZCtcIn17XCIrZCtcIn17XCIrZCtcIn17XCIrZCtcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGV4LW1hdGgnOlxuICAgICAgICAgIHJlcyA9IGJ1Zi5wMSArIFwiIFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmcmFjLWNlJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxmcmFje1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvdmVyc2V0JzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxvdmVyc2V0e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn17XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd1bmRlcnNldCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcdW5kZXJzZXR7XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKSArIFwifXtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDIpICsgXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VuZGVyYnJhY2UnOlxuICAgICAgICAgIHJlcyA9ICBcIlxcXFx1bmRlcmJyYWNle1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSkgKyBcIn1fe1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgIHJlcyA9IFwie1xcXFxjb2xvcntcIiArIGJ1Zi5jb2xvcjEgKyBcIn17XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLmNvbG9yMikgKyBcIn19XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbG9yMCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcY29sb3J7XCIgKyBidWYuY29sb3IgKyBcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYXJyb3cnOlxuICAgICAgICAgIHZhciBiNiA9IHtcbiAgICAgICAgICAgIHJkOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLnJkKSxcbiAgICAgICAgICAgIHJxOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLnJxKVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGFycm93ID0gdGV4aWZ5Ll9nZXRBcnJvdyhidWYucik7XG4gICAgICAgICAgaWYgKGI2LnJxKSB7IGFycm93ICs9IFwiW3tcXFxccm0gXCIgKyBiNi5ycSArIFwifV1cIjsgfVxuICAgICAgICAgIGlmIChiNi5yZCkge1xuICAgICAgICAgICAgYXJyb3cgKz0gXCJ7XFxcXHJtIFwiICsgYjYucmQgKyBcIn1cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyb3cgKz0gXCJ7fVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXMgPSBhcnJvdztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3BlcmF0b3InOlxuICAgICAgICAgIHJlcyA9IHRleGlmeS5fZ2V0T3BlcmF0b3IoYnVmLmtpbmRfKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMXN0LWxldmVsIGVzY2FwZSc6XG4gICAgICAgICAgcmVzID0gYnVmLnAxK1wiIFwiOyAgLy8gJiwgXFxcXFxcXFwsIFxcXFxobGluXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICByZXMgPSBcIiBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZW50aXR5U2tpcCc6XG4gICAgICAgICAgcmVzID0gXCJ+XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3B1LXNwYWNlLTEnOlxuICAgICAgICAgIHJlcyA9IFwiflwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwdS1zcGFjZS0yJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjNtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnMTAwMCBzZXBhcmF0b3InOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1rZXJuMm11IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb21tYURlY2ltYWwnOlxuICAgICAgICAgIHJlcyA9IFwieyx9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY29tbWEgZW51bWVyYXRpb24gTCc6XG4gICAgICAgICAgcmVzID0gXCJ7XCIrYnVmLnAxK1wifVxcXFxta2VybjZtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29tbWEgZW51bWVyYXRpb24gTSc6XG4gICAgICAgICAgcmVzID0gXCJ7XCIrYnVmLnAxK1wifVxcXFxta2VybjNtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29tbWEgZW51bWVyYXRpb24gUyc6XG4gICAgICAgICAgcmVzID0gXCJ7XCIrYnVmLnAxK1wifVxcXFxta2VybjFtdSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHlwaGVuJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFx0ZXh0ey19XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FkZGl0aW9uIGNvbXBvdW5kJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFwse1xcXFxjZG90fVxcXFwsXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VsZWN0cm9uIGRvdCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWtlcm4xbXUgXFxcXHRleHR7XFxcXHRleHRidWxsZXR9XFxcXG1rZXJuMW11IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdLViB4JzpcbiAgICAgICAgICByZXMgPSBcIntcXFxcdGltZXN9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ByaW1lJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxwcmltZSBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2RvdCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcY2RvdCBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGlnaHQgY2RvdCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWtlcm4xbXV7XFxcXGNkb3R9XFxcXG1rZXJuMW11IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aW1lcyc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcdGltZXMgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NpcmNhJzpcbiAgICAgICAgICByZXMgPSBcIntcXFxcc2ltfVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICByZXMgPSBcInVwYXJyb3dcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgcmVzID0gXCJkb3duYXJyb3dcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZWxsaXBzaXMnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXGxkb3RzIFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcvJzpcbiAgICAgICAgICByZXMgPSBcIi9cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnIC8gJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFwsL1xcXFwsXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXNzZXJ0TmV2ZXIoYnVmKTtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdUXCIsIFwibWhjaGVtIGJ1ZyBULiBQbGVhc2UgcmVwb3J0LlwiXTsgIC8vIE1pc3NpbmcgdGV4aWZ5IHJ1bGUgb3IgdW5rbm93biBNaGNoZW1QYXJzZXIgb3V0cHV0XG4gICAgICB9XG4gICAgICBhc3NlcnRTdHJpbmcocmVzKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBfZ2V0QXJyb3c6IGZ1bmN0aW9uIChhKSB7XG4gICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgY2FzZSBcIi0+XCI6IHJldHVybiBcIlxcXFx5aWVsZHNcIjtcbiAgICAgICAgY2FzZSBcIlxcdTIxOTJcIjogcmV0dXJuIFwiXFxcXHlpZWxkc1wiO1xuICAgICAgICBjYXNlIFwiXFx1MjdGNlwiOiByZXR1cm4gXCJcXFxceWllbGRzXCI7XG4gICAgICAgIGNhc2UgXCI8LVwiOiByZXR1cm4gXCJcXFxceWllbGRzTGVmdFwiO1xuICAgICAgICBjYXNlIFwiPC0+XCI6IHJldHVybiBcIlxcXFxtZXNvbWVyaXNtXCI7XG4gICAgICAgIGNhc2UgXCI8LS0+XCI6IHJldHVybiBcIlxcXFx5aWVsZHNMZWZ0UmlnaHRcIjtcbiAgICAgICAgY2FzZSBcIjw9PlwiOiByZXR1cm4gXCJcXFxcZXF1aWxpYnJpdW1cIjtcbiAgICAgICAgY2FzZSBcIlxcdTIxQ0NcIjogcmV0dXJuIFwiXFxcXGVxdWlsaWJyaXVtXCI7XG4gICAgICAgIGNhc2UgXCI8PT4+XCI6IHJldHVybiBcIlxcXFxlcXVpbGlicml1bVJpZ2h0XCI7XG4gICAgICAgIGNhc2UgXCI8PD0+XCI6IHJldHVybiBcIlxcXFxlcXVpbGlicml1bUxlZnRcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhc3NlcnROZXZlcihhKTtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdUXCIsIFwibWhjaGVtIGJ1ZyBULiBQbGVhc2UgcmVwb3J0LlwiXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRCb25kOiBmdW5jdGlvbiAoYSkge1xuICAgICAgc3dpdGNoIChhKSB7XG4gICAgICAgIGNhc2UgXCItXCI6IHJldHVybiBcInstfVwiO1xuICAgICAgICBjYXNlIFwiMVwiOiByZXR1cm4gXCJ7LX1cIjtcbiAgICAgICAgY2FzZSBcIj1cIjogcmV0dXJuIFwiez19XCI7XG4gICAgICAgIGNhc2UgXCIyXCI6IHJldHVybiBcIns9fVwiO1xuICAgICAgICBjYXNlIFwiI1wiOiByZXR1cm4gXCJ7XFxcXGVxdWl2fVwiO1xuICAgICAgICBjYXNlIFwiM1wiOiByZXR1cm4gXCJ7XFxcXGVxdWl2fVwiO1xuICAgICAgICBjYXNlIFwiflwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2h9XCI7XG4gICAgICAgIGNhc2UgXCJ+LVwiOiByZXR1cm4gXCJ7XFxcXHRyaXBsZURhc2hPdmVyTGluZX1cIjtcbiAgICAgICAgY2FzZSBcIn49XCI6IHJldHVybiBcIntcXFxcdHJpcGxlRGFzaE92ZXJEb3VibGVMaW5lfVwiO1xuICAgICAgICBjYXNlIFwifi0tXCI6IHJldHVybiBcIntcXFxcdHJpcGxlRGFzaE92ZXJEb3VibGVMaW5lfVwiO1xuICAgICAgICBjYXNlIFwiLX4tXCI6IHJldHVybiBcIntcXFxcdHJpcGxlRGFzaEJldHdlZW5Eb3VibGVMaW5lfVwiO1xuICAgICAgICBjYXNlIFwiLi4uXCI6IHJldHVybiBcInt7XFxcXGNkb3R9e1xcXFxjZG90fXtcXFxcY2RvdH19XCI7XG4gICAgICAgIGNhc2UgXCIuLi4uXCI6IHJldHVybiBcInt7XFxcXGNkb3R9e1xcXFxjZG90fXtcXFxcY2RvdH17XFxcXGNkb3R9fVwiO1xuICAgICAgICBjYXNlIFwiLT5cIjogcmV0dXJuIFwie1xcXFxyaWdodGFycm93fVwiO1xuICAgICAgICBjYXNlIFwiPC1cIjogcmV0dXJuIFwie1xcXFxsZWZ0YXJyb3d9XCI7XG4gICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiBcIns8fVwiO1xuICAgICAgICBjYXNlIFwiPlwiOiByZXR1cm4gXCJ7Pn1cIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhc3NlcnROZXZlcihhKTtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdUXCIsIFwibWhjaGVtIGJ1ZyBULiBQbGVhc2UgcmVwb3J0LlwiXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRPcGVyYXRvcjogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIFwiK1wiOiByZXR1cm4gXCIge30re30gXCI7XG4gICAgICAgIGNhc2UgXCItXCI6IHJldHVybiBcIiB7fS17fSBcIjtcbiAgICAgICAgY2FzZSBcIj1cIjogcmV0dXJuIFwiIHt9PXt9IFwiO1xuICAgICAgICBjYXNlIFwiPFwiOiByZXR1cm4gXCIge308e30gXCI7XG4gICAgICAgIGNhc2UgXCI+XCI6IHJldHVybiBcIiB7fT57fSBcIjtcbiAgICAgICAgY2FzZSBcIjw8XCI6IHJldHVybiBcIiB7fVxcXFxsbHt9IFwiO1xuICAgICAgICBjYXNlIFwiPj5cIjogcmV0dXJuIFwiIHt9XFxcXGdne30gXCI7XG4gICAgICAgIGNhc2UgXCJcXFxccG1cIjogcmV0dXJuIFwiIHt9XFxcXHBte30gXCI7XG4gICAgICAgIGNhc2UgXCJcXFxcYXBwcm94XCI6IHJldHVybiBcIiB7fVxcXFxhcHByb3h7fSBcIjtcbiAgICAgICAgY2FzZSBcIiRcXFxcYXBwcm94JFwiOiByZXR1cm4gXCIge31cXFxcYXBwcm94e30gXCI7XG4gICAgICAgIGNhc2UgXCJ2XCI6IHJldHVybiBcIiBcXFxcZG93bmFycm93e30gXCI7XG4gICAgICAgIGNhc2UgXCIodilcIjogcmV0dXJuIFwiIFxcXFxkb3duYXJyb3d7fSBcIjtcbiAgICAgICAgY2FzZSBcIl5cIjogcmV0dXJuIFwiIFxcXFx1cGFycm93e30gXCI7XG4gICAgICAgIGNhc2UgXCIoXilcIjogcmV0dXJuIFwiIFxcXFx1cGFycm93e30gXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXNzZXJ0TmV2ZXIoYSk7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVFwiLCBcIm1oY2hlbSBidWcgVC4gUGxlYXNlIHJlcG9ydC5cIl07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vXG4gIC8vIEhlbHBlcnMgZm9yIGNvZGUgYW5hbHlzaXNcbiAgLy8gV2lsbCBzaG93IHR5cGUgZXJyb3IgYXQgY2FsbGluZyBwb3NpdGlvblxuICAvL1xuICAvKiogQHBhcmFtIHtudW1iZXJ9IGEgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoYSkge31cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBhICovXG4gIGZ1bmN0aW9uIGFzc2VydFN0cmluZyhhKSB7fVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB0ZXh2Yy5zdHlcblxuLy8gVGhlIHRleHZjIHBhY2thZ2UgY29udGFpbnMgbWFjcm9zIGF2YWlsYWJsZSBpbiBtZWRpYXdpa2kgcGFnZXMuXG4vLyBXZSBvbWl0IHRoZSBmdW5jdGlvbnMgZGVwcmVjYXRlZCBhdFxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVscDpEaXNwbGF5aW5nX2FfZm9ybXVsYSNEZXByZWNhdGVkX3N5bnRheFxuXG4vLyBXZSBhbHNvIG9taXQgdGV4dmMncyBcXE8sIHdoaWNoIGNvbmZsaWN0cyB3aXRoIFxcdGV4dHtcXE99XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRhcnJcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZEFyclwiLCBcIlxcXFxEb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxEYXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxhbmdcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFuZ1wiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1YXJyXCIsIFwiXFxcXHVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1QXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxVYXJyXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxOXCIsIFwiXFxcXG1hdGhiYntOfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJcIiwgXCJcXFxcbWF0aGJie1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcWlwiLCBcIlxcXFxtYXRoYmJ7Wn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWxlZnN5bVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGJ1bGxcIiwgXCJcXFxcYnVsbGV0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY2x1YnNcIiwgXCJcXFxcY2x1YnN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbnVtc1wiLCBcIlxcXFxtYXRoYmJ7Q31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxDb21wbGV4XCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhZ2dlclwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGlhbW9uZHNcIiwgXCJcXFxcZGlhbW9uZHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlbXB0eVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4aXN0XCIsIFwiXFxcXGV4aXN0c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxoQXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcSGFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhlYXJ0c1wiLCBcIlxcXFxoZWFydHN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbWFnZVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGluZmluXCIsIFwiXFxcXGluZnR5XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaXNpblwiLCBcIlxcXFxpblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxhcnJcIiwgXCJcXFxcbGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbEFyclwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxMYXJyXCIsIFwiXFxcXExlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxyYXJyXCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHJBcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxMcmFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5hdG51bXNcIiwgXCJcXFxcbWF0aGJie059XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGx1c21uXCIsIFwiXFxcXHBtXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFyclwiLCBcIlxcXFxyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcckFyclwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUmFyclwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVhbFwiLCBcIlxcXFxSZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJlYWxzXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFJlYWxzXCIsIFwiXFxcXG1hdGhiYntSfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNkb3RcIiwgXCJcXFxcY2RvdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNlY3RcIiwgXCJcXFxcU1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHNwYWRlc1wiLCBcIlxcXFxzcGFkZXN1aXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJcIiwgXCJcXFxcc3Vic2V0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3ViZVwiLCBcIlxcXFxzdWJzZXRlcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1cGVcIiwgXCJcXFxcc3Vwc2V0ZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0aGV0YXN5bVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHdlaWVycFwiLCBcIlxcXFx3cFwiKTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiAgcGh5c2ljcy5qc1xuICpcbiAqICBJbXBsZW1lbnRzIHRoZSBQaHlzaWNzIFBhY2thZ2UgZm9yIExhVGVYIGlucHV0LlxuICpcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgVGhlIG9yaWdpbmFsIHZlcnNpb24gb2YgdGhpcyBmaWxlIGlzIGxpY2Vuc2VkIGFzIGZvbGxvd3M6XG4gKiAgQ29weXJpZ2h0IChjKSAyMDE1LTIwMTYgS29sZW4gQ2hldW5nIDxodHRwczovL2dpdGh1Yi5jb20vaWNrYy9NYXRoSmF4LXRoaXJkLXBhcnR5LWV4dGVuc2lvbnM+LlxuICpcbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogIFRoaXMgZmlsZSBoYXMgYmVlbiByZXZpc2VkIGZyb20gdGhlIG9yaWdpbmFsIGluIHRoZSBmb2xsb3dpbmcgd2F5czpcbiAqICAxLiBUaGUgaW50ZXJmYWNlIGlzIGNoYW5nZWQgc28gdGhhdCBpdCBjYW4gYmUgY2FsbGVkIGZyb20gVGVtbWwsIG5vdCBNYXRoSmF4LlxuICogIDIuIFxcUmUgYW5kIFxcSW0gYXJlIG5vdCB1c2VkLCB0byBhdm9pZCBjb25mbGljdCB3aXRoIGV4aXN0aW5nIExhVGVYIGxldHRlcnMuXG4gKlxuICogIFRoaXMgcmV2aXNpb24gb2YgdGhlIGZpbGUgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogIGh0dHBzOi8vbWl0LWxpY2Vuc2Uub3JnL1xuICovXG5kZWZpbmVNYWNybyhcIlxcXFxxdWFudGl0eVwiLCBcIntcXFxcbGVmdFxcXFx7ICMxIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHF0eVwiLCBcIntcXFxcbGVmdFxcXFx7ICMxIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBxdHlcIiwgXCJ7XFxcXGxlZnQoICMxIFxcXFxyaWdodCl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnF0eVwiLCBcIntcXFxcbGVmdFsgIzEgXFxcXHJpZ2h0XX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2cXR5XCIsIFwie1xcXFxsZWZ0XFxcXHZlcnQgIzEgXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQnF0eVwiLCBcIntcXFxcbGVmdFxcXFx7ICMxIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFic29sdXRldmFsdWVcIiwgXCJ7XFxcXGxlZnRcXFxcdmVydCAjMSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhYnNcIiwgXCJ7XFxcXGxlZnRcXFxcdmVydCAjMSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxub3JtXCIsIFwie1xcXFxsZWZ0XFxcXFZlcnQgIzEgXFxcXHJpZ2h0XFxcXFZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXZhbHVhdGVkXCIsIFwie1xcXFxsZWZ0LiMxIFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV2YWxcIiwgXCJ7XFxcXGxlZnQuIzEgXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb3JkZXJcIiwgXCJ7XFxcXG1hdGhjYWx7T30gXFxcXGxlZnQoICMxIFxcXFxyaWdodCl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29tbXV0YXRvclwiLCBcIntcXFxcbGVmdFsgIzEgLCAjMiBcXFxccmlnaHRdfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbW1cIiwgXCJ7XFxcXGxlZnRbICMxICwgIzIgXFxcXHJpZ2h0XX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbnRpY29tbXV0YXRvclwiLCBcIntcXFxcbGVmdFxcXFx7ICMxICwgIzIgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWNvbW1cIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSAsICMyIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBvaXNzb25icmFja2V0XCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgLCAjMiBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwYlwiLCBcIntcXFxcbGVmdFxcXFx7ICMxICwgIzIgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmVjdG9yYm9sZFwiLCBcIntcXFxcYm9sZHN5bWJvbHsgIzEgfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YlwiLCBcIntcXFxcYm9sZHN5bWJvbHsgIzEgfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2ZWN0b3JhcnJvd1wiLCBcIntcXFxcdmVje1xcXFxib2xkc3ltYm9seyAjMSB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YVwiLCBcIntcXFxcdmVje1xcXFxib2xkc3ltYm9seyAjMSB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2ZWN0b3J1bml0XCIsIFwie3tcXFxcYm9sZHN5bWJvbHtcXFxcaGF0eyAjMSB9fX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdnVcIiwgXCJ7e1xcXFxib2xkc3ltYm9se1xcXFxoYXR7ICMxIH19fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3Rwcm9kdWN0XCIsIFwiXFxcXG1hdGhiaW57XFxcXGJvbGRzeW1ib2xcXFxcY2RvdH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2ZG90XCIsIFwie1xcXFxib2xkc3ltYm9sXFxcXGNkb3R9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY3Jvc3Nwcm9kdWN0XCIsIFwiXFxcXG1hdGhiaW57XFxcXGJvbGRzeW1ib2xcXFxcdGltZXN9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY3Jvc3NcIiwgXCJcXFxcbWF0aGJpbntcXFxcYm9sZHN5bWJvbFxcXFx0aW1lc31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjcFwiLCBcIlxcXFxtYXRoYmlue1xcXFxib2xkc3ltYm9sXFxcXHRpbWVzfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYWRpZW50XCIsIFwie1xcXFxib2xkc3ltYm9sXFxcXG5hYmxhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGdyYWRcIiwgXCJ7XFxcXGJvbGRzeW1ib2xcXFxcbmFibGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGl2ZXJnZW5jZVwiLCBcIntcXFxcZ3JhZFxcXFx2ZG90fVwiKTtcbi8vZGVmaW5lTWFjcm8oXCJcXFxcZGl2XCIsIFwie1xcXFxncmFkXFxcXHZkb3R9XCIpOyBOb3QgaW5jbHVkZWQgaW4gVGVtbWwuIENvbmZsaWN0cyB3L0xhVGVYIFxcZGl2XG5kZWZpbmVNYWNybyhcIlxcXFxjdXJsXCIsIFwie1xcXFxncmFkXFxcXGNyb3NzfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxhcGxhY2lhblwiLCBcIlxcXFxuYWJsYV4yXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdHJcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXt0cn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcVHJcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtUcn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmFua1wiLCBcIntcXFxcb3BlcmF0b3JuYW1le3Jhbmt9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVyZlwiLCBcIntcXFxcb3BlcmF0b3JuYW1le2VyZn19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUmVzXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7UmVzfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwcmluY2lwYWx2YWx1ZVwiLCBcIntcXFxcbWF0aGNhbHtQfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwdlwiLCBcIntcXFxcbWF0aGNhbHtQfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxQVlwiLCBcIntcXFxcb3BlcmF0b3JuYW1le1AuVi59fVwiKTtcbi8vIFRlbW1sIGRvZXMgbm90IHVzZSB0aGUgbmV4dCB0d28gbGluZXMuIFRoZXkgY29uZmxpY3Qgd2l0aCBMYVRlWCBsZXR0ZXJzLlxuLy9kZWZpbmVNYWNybyhcIlxcXFxSZVwiLCBcIntcXFxcb3BlcmF0b3JuYW1le1JlfSBcXFxcbGVmdFxcXFx7ICMxIFxcXFxyaWdodFxcXFx9fVwiKTtcbi8vZGVmaW5lTWFjcm8oXCJcXFxcSW1cIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtJbX0gXFxcXGxlZnRcXFxceyAjMSBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxcXRleHRcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHsgIzEgfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFxXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7ICMxIH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxY29tbWFcIiwgXCJ7XFxcXHRleHR7LH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxY1wiLCBcIntcXFxcdGV4dHssfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFjY1wiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2MuYy59XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWlmXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7aWZ9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXRoZW5cIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHt0aGVufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFlbHNlXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7ZWxzZX1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxb3RoZXJ3aXNlXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7b3RoZXJ3aXNlfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHF1bmxlc3NcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHt1bmxlc3N9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWdpdmVuXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7Z2l2ZW59XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXVzaW5nXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7dXNpbmd9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWFzc3VtZVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2Fzc3VtZX1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxc2luY2VcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtzaW5jZX1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxbGV0XCIsIFwie1xcXFxxdWFkXFxcXHRleHR7bGV0fVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFmb3JcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtmb3J9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWFsbFwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2FsbH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxZXZlblwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2V2ZW59XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccW9kZFwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e29kZH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxaW50ZWdlclwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2ludGVnZXJ9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWFuZFwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2FuZH1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxb3JcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtvcn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxYXNcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHthc31cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxaW5cIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtpbn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkaWZmZXJlbnRpYWxcIiwgXCJ7XFxcXHRleHR7ZH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGRcIiwgXCJ7XFxcXHRleHR7ZH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZGVyaXZhdGl2ZVwiLCBcIntcXFxcZnJhY3tcXFxcdGV4dHtkfXsgIzEgfX17XFxcXHRleHR7ZH17ICMyIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGR2XCIsIFwie1xcXFxmcmFje1xcXFx0ZXh0e2R9eyAjMSB9fXtcXFxcdGV4dHtkfXsgIzIgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGFydGlhbGRlcml2YXRpdmVcIiwgXCJ7XFxcXGZyYWN7XFxcXHBhcnRpYWx7ICMxIH19e1xcXFxwYXJ0aWFseyAjMiB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJpYXRpb25cIiwgXCJ7XFxcXGRlbHRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhclwiLCBcIntcXFxcZGVsdGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZnVuY3Rpb25hbGRlcml2YXRpdmVcIiwgXCJ7XFxcXGZyYWN7XFxcXGRlbHRheyAjMSB9fXtcXFxcZGVsdGF7ICMyIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGZkdlwiLCBcIntcXFxcZnJhY3tcXFxcZGVsdGF7ICMxIH19e1xcXFxkZWx0YXsgIzIgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW5uZXJwcm9kdWN0XCIsIFwie1xcXFxsZWZ0XFxcXGxhbmdsZSB7IzF9IFxcXFxtaWQgeyAjMn0gXFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxvdXRlcnByb2R1Y3RcIixcbiAgXCJ7XFxcXGxlZnRcXFxcdmVydCB7ICMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZVxcXFxsZWZ0XFxcXGxhbmdsZSB7ICMyfSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkeWFkXCIsXG4gIFwie1xcXFxsZWZ0XFxcXHZlcnQgeyAjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGVcXFxcbGVmdFxcXFxsYW5nbGUgeyAjMn0gXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2V0YnJhXCIsXG4gIFwie1xcXFxsZWZ0XFxcXHZlcnQgeyAjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGVcXFxcbGVmdFxcXFxsYW5nbGUgeyAjMn0gXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb3BcIixcbiAgXCJ7XFxcXGxlZnRcXFxcdmVydCB7ICMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZVxcXFxsZWZ0XFxcXGxhbmdsZSB7ICMyfSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxleHBlY3RhdGlvbnZhbHVlXCIsIFwie1xcXFxsZWZ0XFxcXGxhbmdsZSB7IzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4cHZhbFwiLCBcIntcXFxcbGVmdFxcXFxsYW5nbGUgeyMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxldlwiLCBcIntcXFxcbGVmdFxcXFxsYW5nbGUgeyMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxtYXRyaXhlbGVtZW50XCIsXG4gIFwie1xcXFxsZWZ0XFxcXGxhbmdsZXsgIzEgfVxcXFxyaWdodFxcXFx2ZXJ0eyAjMiB9XFxcXGxlZnRcXFxcdmVydHsjM31cXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hdHJpeGVsXCIsXG4gIFwie1xcXFxsZWZ0XFxcXGxhbmdsZXsgIzEgfVxcXFxyaWdodFxcXFx2ZXJ0eyAjMiB9XFxcXGxlZnRcXFxcdmVydHsjM31cXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1lbFwiLFxuICBcIntcXFxcbGVmdFxcXFxsYW5nbGV7ICMxIH1cXFxccmlnaHRcXFxcdmVydHsgIzIgfVxcXFxsZWZ0XFxcXHZlcnR7IzN9XFxcXHJpZ2h0XFxcXHJhbmdsZX1cIik7XG5cbi8vIEhlbHBlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGdldEhMaW5lcyhwYXJzZXIpIHtcbiAgLy8gUmV0dXJuIGFuIGFycmF5LiBUaGUgYXJyYXkgbGVuZ3RoID0gbnVtYmVyIG9mIGhsaW5lcy5cbiAgLy8gRWFjaCBlbGVtZW50IGluIHRoZSBhcnJheSB0ZWxscyBpZiB0aGUgbGluZSBpcyBkYXNoZWQuXG4gIGNvbnN0IGhsaW5lSW5mbyA9IFtdO1xuICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICBsZXQgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgaWYgKG54dCA9PT0gXCJcXFxccmVsYXhcIikge1xuICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICBueHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICB9XG4gIHdoaWxlIChueHQgPT09IFwiXFxcXGhsaW5lXCIgfHwgbnh0ID09PSBcIlxcXFxoZGFzaGxpbmVcIikge1xuICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgaGxpbmVJbmZvLnB1c2gobnh0ID09PSBcIlxcXFxoZGFzaGxpbmVcIik7XG4gICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICBueHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICB9XG4gIHJldHVybiBobGluZUluZm87XG59XG5cbmNvbnN0IHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gIGNvbnN0IHNldHRpbmdzID0gY29udGV4dC5wYXJzZXIuc2V0dGluZ3M7XG4gIGlmICghc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgeyR7Y29udGV4dC5lbnZOYW1lfX0gY2FuIGJlIHVzZWQgb25seSBpbiBkaXNwbGF5IG1vZGUuYCk7XG4gIH1cbn07XG5cbmNvbnN0IHNpemVSZWdFeCQxID0gLyhbLStdPykgKihcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspICooW2Etel17Mn0pLztcbmNvbnN0IGFycmF5R2FwcyA9IG1hY3JvcyA9PiB7XG4gIGxldCBhcnJheXN0cmV0Y2ggPSBtYWNyb3MuZ2V0KFwiXFxcXGFycmF5c3RyZXRjaFwiKTtcbiAgaWYgKHR5cGVvZiBhcnJheXN0cmV0Y2ggIT09IFwic3RyaW5nXCIpIHtcbiAgICBhcnJheXN0cmV0Y2ggPSBzdHJpbmdGcm9tQXJnKGFycmF5c3RyZXRjaC50b2tlbnMpO1xuICB9XG4gIGFycmF5c3RyZXRjaCA9IGlzTmFOKGFycmF5c3RyZXRjaCkgPyBudWxsIDogTnVtYmVyKGFycmF5c3RyZXRjaCk7XG4gIGxldCBhcnJheWNvbHNlcFN0ciA9IG1hY3Jvcy5nZXQoXCJcXFxcYXJyYXljb2xzZXBcIik7XG4gIGlmICh0eXBlb2YgYXJyYXljb2xzZXBTdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICBhcnJheWNvbHNlcFN0ciA9IHN0cmluZ0Zyb21BcmcoYXJyYXljb2xzZXBTdHIudG9rZW5zKTtcbiAgfVxuICBjb25zdCBtYXRjaCA9IHNpemVSZWdFeCQxLmV4ZWMoYXJyYXljb2xzZXBTdHIpO1xuICBjb25zdCBhcnJheWNvbHNlcCA9IG1hdGNoXG4gICAgPyB7IG51bWJlcjogKyhtYXRjaFsxXSArIG1hdGNoWzJdKSwgdW5pdDogbWF0Y2hbM10gfVxuICAgIDogbnVsbDtcbiAgcmV0dXJuIFthcnJheXN0cmV0Y2gsIGFycmF5Y29sc2VwXVxufTtcblxuY29uc3QgY2hlY2tDZWxsRm9yTGFiZWxzID0gY2VsbCA9PiB7XG4gIC8vIENoZWNrIGlmIHRoZSBhdXRob3Igd3JvdGUgYSBcXHRhZ3t9IGluc2lkZSB0aGlzIGNlbGwuXG4gIGxldCByb3dMYWJlbCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjZWxsW2ldLnR5cGUgPT09IFwibGFiZWxcIikge1xuICAgICAgaWYgKHJvd0xhYmVsKSB7IHRocm93IG5ldyBQYXJzZUVycm9yKChcIk11bHRpcGxlIFxcXFxsYWJlbHMgaW4gb25lIHJvd1wiKSkgfVxuICAgICAgcm93TGFiZWwgPSBjZWxsW2ldLnN0cmluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvd0xhYmVsXG59O1xuXG4vLyBhdXRvVGFnIChhbiBhcmd1bWVudCB0byBwYXJzZUFycmF5KSBjYW4gYmUgb25lIG9mIHRocmVlIHZhbHVlczpcbi8vICogdW5kZWZpbmVkOiBSZWd1bGFyIChub3QtdG9wLWxldmVsKSBhcnJheTsgbm8gdGFncyBvbiBlYWNoIHJvd1xuLy8gKiB0cnVlOiBBdXRvbWF0aWMgZXF1YXRpb24gbnVtYmVyaW5nLCBvdmVycmlkYWJsZSBieSBcXHRhZ1xuLy8gKiBmYWxzZTogVGFncyBhbGxvd2VkIG9uIGVhY2ggcm93LCBidXQgbm8gYXV0b21hdGljIG51bWJlcmluZ1xuLy8gVGhpcyBmdW5jdGlvbiAqZG9lc24ndCogd29yayB3aXRoIHRoZSBcInNwbGl0XCIgZW52aXJvbm1lbnQgbmFtZS5cbmZ1bmN0aW9uIGdldEF1dG9UYWcobmFtZSkge1xuICBpZiAobmFtZS5pbmRleE9mKFwiZWRcIikgPT09IC0xKSB7XG4gICAgcmV0dXJuIG5hbWUuaW5kZXhPZihcIipcIikgPT09IC0xO1xuICB9XG4gIC8vIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUGFyc2UgdGhlIGJvZHkgb2YgdGhlIGVudmlyb25tZW50LCB3aXRoIHJvd3MgZGVsaW1pdGVkIGJ5IFxcXFwgYW5kXG4gKiBjb2x1bW5zIGRlbGltaXRlZCBieSAmLCBhbmQgY3JlYXRlIGEgbmVzdGVkIGxpc3QgaW4gcm93LW1ham9yIG9yZGVyXG4gKiB3aXRoIG9uZSBncm91cCBwZXIgY2VsbC4gIElmIGdpdmVuIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHNjcmlwdExldmVsXG4gKiAoXCJ0ZXh0XCIsIFwiZGlzcGxheVwiLCBldGMuKSwgdGhlbiBlYWNoIGNlbGwgaXMgY2FzdCBpbnRvIHRoYXQgc2NyaXB0TGV2ZWwuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJyYXkoXG4gIHBhcnNlcixcbiAge1xuICAgIGNvbHMsIC8vIFt7IHR5cGU6IHN0cmluZyAsIGFsaWduOiBsfGN8cnxudWxsIH1dXG4gICAgZW52Q2xhc3NlcywgLy8gYWxpZ24oZWR8YXR8ZWRhdCkgfCBhcnJheSB8IGNhc2VzIHwgY2QgfCBzbWFsbCB8IG11bHRsaW5lXG4gICAgYXV0b1RhZywgICAgICAgIC8vIGJvb2xlYW5cbiAgICBzaW5nbGVSb3csICAgICAgLy8gYm9vbGVhblxuICAgIGVtcHR5U2luZ2xlUm93LCAvLyBib29sZWFuXG4gICAgbWF4TnVtQ29scywgICAgIC8vIG51bWJlclxuICAgIGxlcW5vLCAgICAgICAgICAvLyBib29sZWFuXG4gICAgYXJyYXlzdHJldGNoLCAgIC8vIG51bWJlciAgfCBudWxsXG4gICAgYXJyYXljb2xzZXAgICAgIC8vIHNpemUgdmFsdWUgfCBudWxsXG59LFxuICBzY3JpcHRMZXZlbFxuKSB7XG4gIGNvbnN0IGVuZFRva2VuID0gZW52Q2xhc3NlcyAmJiBlbnZDbGFzc2VzLmluY2x1ZGVzKFwiYm9yZGVybWF0cml4XCIpID8gXCJ9XCIgOiBcIlxcXFxlbmRcIjtcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gIGlmICghc2luZ2xlUm93KSB7XG4gICAgLy8gXFxjciBpcyBlcXVpdmFsZW50IHRvIFxcXFwgd2l0aG91dCB0aGUgb3B0aW9uYWwgc2l6ZSBhcmd1bWVudCAoc2VlIGJlbG93KVxuICAgIC8vIFRPRE86IHByb3ZpZGUgaGVscGZ1bCBlcnJvciB3aGVuIFxcY3IgaXMgdXNlZCBvdXRzaWRlIGFycmF5IGVudmlyb25tZW50XG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNyXCIsIFwiXFxcXFxcXFxcXFxccmVsYXhcIik7XG4gIH1cblxuICAvLyBTdGFydCBncm91cCBmb3IgZmlyc3QgY2VsbFxuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcblxuICBsZXQgcm93ID0gW107XG4gIGNvbnN0IGJvZHkgPSBbcm93XTtcbiAgY29uc3Qgcm93R2FwcyA9IFtdO1xuICBjb25zdCBsYWJlbHMgPSBbXTtcblxuICBjb25zdCBoTGluZXNCZWZvcmVSb3cgPSBbXTtcblxuICBjb25zdCB0YWdzID0gKGF1dG9UYWcgIT0gbnVsbCA/IFtdIDogdW5kZWZpbmVkKTtcblxuICAvLyBhbXNtYXRoIHVzZXMgXFxnbG9iYWxcXEBlcW5zd3RydWUgYW5kIFxcZ2xvYmFsXFxAZXFuc3dmYWxzZSB0byByZXByZXNlbnRcbiAgLy8gd2hldGhlciB0aGlzIHJvdyBzaG91bGQgaGF2ZSBhbiBlcXVhdGlvbiBudW1iZXIuICBTaW11bGF0ZSB0aGlzIHdpdGhcbiAgLy8gYSBcXEBlcW5zdyBtYWNybyBzZXQgdG8gMSBvciAwLlxuICBmdW5jdGlvbiBiZWdpblJvdygpIHtcbiAgICBpZiAoYXV0b1RhZykge1xuICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXEBlcW5zd1wiLCBcIjFcIiwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVuZFJvdygpIHtcbiAgICBpZiAodGFncykge1xuICAgICAgaWYgKHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICAgICAgdGFncy5wdXNoKHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKFwiXFxcXGRmQHRhZ1wiKV0pKTtcbiAgICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGRmQHRhZ1wiLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFncy5wdXNoKEJvb2xlYW4oYXV0b1RhZykgJiZcbiAgICAgICAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxAZXFuc3dcIikgPT09IFwiMVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYmVnaW5Sb3coKTtcblxuICAvLyBUZXN0IGZvciBcXGhsaW5lIGF0IHRoZSB0b3Agb2YgdGhlIGFycmF5LlxuICBoTGluZXNCZWZvcmVSb3cucHVzaChnZXRITGluZXMocGFyc2VyKSk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBQYXJzZSBlYWNoIGNlbGwgaW4gaXRzIG93biBncm91cCAobmFtZXNwYWNlKVxuICAgIGxldCBjZWxsID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgc2luZ2xlUm93ID8gXCJcXFxcZW5kXCIgOiBcIlxcXFxcXFxcXCIpO1xuICAgIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcblxuICAgIGNlbGwgPSB7XG4gICAgICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGNlbGwsXG4gICAgICBzZW1pc2ltcGxlOiB0cnVlXG4gICAgfTtcbiAgICByb3cucHVzaChjZWxsKTtcbiAgICBjb25zdCBuZXh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgICBpZiAobmV4dCA9PT0gXCImXCIpIHtcbiAgICAgIGlmIChtYXhOdW1Db2xzICYmIHJvdy5sZW5ndGggPT09IG1heE51bUNvbHMpIHtcbiAgICAgICAgaWYgKGVudkNsYXNzZXMuaW5jbHVkZXMoXCJhcnJheVwiKSkge1xuICAgICAgICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRvbyBmZXcgY29sdW1ucyBcIiArIFwic3BlY2lmaWVkIGluIHRoZSB7YXJyYXl9IGNvbHVtbiBhcmd1bWVudC5cIixcbiAgICAgICAgICAgICAgcGFyc2VyLm5leHRUb2tlbilcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobWF4TnVtQ29scyA9PT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVGhlIHNwbGl0IGVudmlyb25tZW50IGFjY2VwdHMgbm8gbW9yZSB0aGFuIHR3byBjb2x1bW5zXCIsXG4gICAgICAgICAgICBwYXJzZXIubmV4dFRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRoZSBlcXVhdGlvbiBlbnZpcm9ubWVudCBhY2NlcHRzIG9ubHkgb25lIGNvbHVtblwiLFxuICAgICAgICAgICAgcGFyc2VyLm5leHRUb2tlbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IGVuZFRva2VuKSB7XG4gICAgICBlbmRSb3coKTtcbiAgICAgIC8vIEFycmF5cyB0ZXJtaW5hdGUgbmV3bGluZXMgd2l0aCBgXFxjcmNyYCB3aGljaCBjb25zdW1lcyBhIGBcXGNyYCBpZlxuICAgICAgLy8gdGhlIGxhc3QgbGluZSBpcyBlbXB0eS4gIEhvd2V2ZXIsIEFNUyBlbnZpcm9ubWVudHMga2VlcCB0aGVcbiAgICAgIC8vIGVtcHR5IHJvdyBpZiBpdCdzIHRoZSBvbmx5IG9uZS5cbiAgICAgIC8vIE5PVEU6IEN1cnJlbnRseSwgYGNlbGxgIGlzIHRoZSBsYXN0IGl0ZW0gYWRkZWQgaW50byBgcm93YC5cbiAgICAgIGlmIChyb3cubGVuZ3RoID09PSAxICYmIGNlbGwuYm9keS5sZW5ndGggPT09IDAgJiYgKGJvZHkubGVuZ3RoID4gMSB8fCAhZW1wdHlTaW5nbGVSb3cpKSB7XG4gICAgICAgIGJvZHkucG9wKCk7XG4gICAgICB9XG4gICAgICBsYWJlbHMucHVzaChjaGVja0NlbGxGb3JMYWJlbHMoY2VsbC5ib2R5KSk7XG4gICAgICBpZiAoaExpbmVzQmVmb3JlUm93Lmxlbmd0aCA8IGJvZHkubGVuZ3RoICsgMSkge1xuICAgICAgICBoTGluZXNCZWZvcmVSb3cucHVzaChbXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IFwiXFxcXFxcXFxcIikge1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgIGxldCBzaXplO1xuICAgICAgLy8gXFxkZWZcXExldEB7XFxsZXRcXFxcXFxtYXRoQGNyfVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3J7Li4uXFxtYXRoQGNyQH1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQHtcXG5ld0BpZm5leHRjaGFyW1xcbWF0aEBjckBAe1xcbWF0aEBjckBAW1xcekBdfX1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQEBbIzFdey4uLlxcbWF0aEBjckBAQC4uLn1cbiAgICAgIC8vIFxcZGVmXFxtYXRoQGNyQEBAe1xcY3J9XG4gICAgICBpZiAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSBcIiBcIikge1xuICAgICAgICBzaXplID0gcGFyc2VyLnBhcnNlU2l6ZUdyb3VwKHRydWUpO1xuICAgICAgfVxuICAgICAgcm93R2Fwcy5wdXNoKHNpemUgPyBzaXplLnZhbHVlIDogbnVsbCk7XG4gICAgICBlbmRSb3coKTtcblxuICAgICAgbGFiZWxzLnB1c2goY2hlY2tDZWxsRm9yTGFiZWxzKGNlbGwuYm9keSkpO1xuXG4gICAgICAvLyBjaGVjayBmb3IgXFxobGluZShzKSBmb2xsb3dpbmcgdGhlIHJvdyBzZXBhcmF0b3JcbiAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTtcblxuICAgICAgcm93ID0gW107XG4gICAgICBib2R5LnB1c2gocm93KTtcbiAgICAgIGJlZ2luUm93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgJiBvciBcXFxcXFxcXCBvciBcXFxcY3Igb3IgXCIgKyBlbmRUb2tlbiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5kIGNlbGwgZ3JvdXBcbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAvLyBFbmQgYXJyYXkgZ3JvdXAgZGVmaW5pbmcgXFxjclxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgYm9keSxcbiAgICBjb2xzLFxuICAgIHJvd0dhcHMsXG4gICAgaExpbmVzQmVmb3JlUm93LFxuICAgIGVudkNsYXNzZXMsXG4gICAgYXV0b1RhZyxcbiAgICBzY3JpcHRMZXZlbCxcbiAgICB0YWdzLFxuICAgIGxhYmVscyxcbiAgICBsZXFubyxcbiAgICBhcnJheXN0cmV0Y2gsXG4gICAgYXJyYXljb2xzZXBcbiAgfTtcbn1cblxuLy8gRGVjaWRlcyBvbiBhIHNjcmlwdExldmVsIGZvciBjZWxscyBpbiBhbiBhcnJheSBhY2NvcmRpbmcgdG8gd2hldGhlciB0aGUgZ2l2ZW5cbi8vIGVudmlyb25tZW50IG5hbWUgc3RhcnRzIHdpdGggdGhlIGxldHRlciAnZCcuXG5mdW5jdGlvbiBkQ2VsbFN0eWxlKGVudk5hbWUpIHtcbiAgcmV0dXJuIGVudk5hbWUuc2xpY2UoMCwgMSkgPT09IFwiZFwiID8gXCJkaXNwbGF5XCIgOiBcInRleHRcIlxufVxuXG5jb25zdCBhbGlnbk1hcCA9IHtcbiAgYzogXCJjZW50ZXIgXCIsXG4gIGw6IFwibGVmdCBcIixcbiAgcjogXCJyaWdodCBcIlxufTtcblxuY29uc3QgZ2x1ZSA9IGdyb3VwID0+IHtcbiAgY29uc3QgZ2x1ZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbXSk7XG4gIGdsdWVOb2RlLnN0eWxlID0geyBwYWRkaW5nOiBcIjBcIiwgd2lkdGg6IFwiNTAlXCIgfTtcbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJtdWx0bGluZVwiKSkge1xuICAgIGdsdWVOb2RlLnN0eWxlLndpZHRoID0gXCI3LjUlXCI7XG4gIH1cbiAgcmV0dXJuIGdsdWVOb2RlXG59O1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJDkgPSBmdW5jdGlvbihncm91cCwgc3R5bGUpIHtcbiAgY29uc3QgdGJsID0gW107XG4gIGNvbnN0IG51bVJvd3MgPSBncm91cC5ib2R5Lmxlbmd0aDtcbiAgY29uc3QgaGxpbmVzID0gZ3JvdXAuaExpbmVzQmVmb3JlUm93O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUm93czsgaSsrKSB7XG4gICAgY29uc3QgcncgPSBncm91cC5ib2R5W2ldO1xuICAgIGNvbnN0IHJvdyA9IFtdO1xuICAgIGNvbnN0IGNlbGxMZXZlbCA9IGdyb3VwLnNjcmlwdExldmVsID09PSBcInRleHRcIlxuICAgICAgPyBTdHlsZUxldmVsLlRFWFRcbiAgICAgIDogZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwic2NyaXB0XCJcbiAgICAgID8gU3R5bGVMZXZlbC5TQ1JJUFRcbiAgICAgIDogU3R5bGVMZXZlbC5ESVNQTEFZO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBydy5sZW5ndGg7IGorKykge1xuICAgICAgY29uc3QgbXRkID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXRkXCIsXG4gICAgICAgIFtidWlsZEdyb3VwJDEocndbal0sIHN0eWxlLndpdGhMZXZlbChjZWxsTGV2ZWwpKV1cbiAgICAgICk7XG5cbiAgICAgIGlmIChncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwibXVsdGxpbmVcIikpIHtcbiAgICAgICAgY29uc3QgYWxpZ24gPSBpID09PSAwID8gXCJsZWZ0XCIgOiBpID09PSBudW1Sb3dzIC0gMSA/IFwicmlnaHRcIiA6IFwiY2VudGVyXCI7XG4gICAgICAgIG10ZC5zZXRBdHRyaWJ1dGUoXCJjb2x1bW5hbGlnblwiLCBhbGlnbik7XG4gICAgICAgIGlmIChhbGlnbiAhPT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgIG10ZC5jbGFzc2VzLnB1c2goXCJ0bWwtXCIgKyBhbGlnbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJvdy5wdXNoKG10ZCk7XG4gICAgfVxuICAgIGNvbnN0IG51bUNvbHVtbnMgPSBncm91cC5ib2R5WzBdLmxlbmd0aDtcbiAgICAvLyBGaWxsIG91dCBhIHNob3J0IHJvdyB3aXRoIGVtcHR5IDxtdGQ+IGVsZW1lbnRzLlxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbnVtQ29sdW1ucyAtIHJ3Lmxlbmd0aDsgaysrKSB7XG4gICAgICByb3cucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbXSwgc3R5bGUpKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmF1dG9UYWcpIHtcbiAgICAgIGNvbnN0IHRhZyA9IGdyb3VwLnRhZ3NbaV07XG4gICAgICBsZXQgdGFnRWxlbWVudDtcbiAgICAgIGlmICh0YWcgPT09IHRydWUpIHsgIC8vIGF1dG9tYXRpYyBudW1iZXJpbmdcbiAgICAgICAgdGFnRWxlbWVudCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW25ldyBTcGFuKFtcInRtbC1lcW5cIl0pXSk7XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gXFxub251bWJlci9cXG5vdGFnIG9yIHN0YXJyZWQgZW52aXJvbm1lbnRcbiAgICAgICAgdGFnRWxlbWVudCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW10sIFtdKTtcbiAgICAgIH0gZWxzZSB7ICAvLyBtYW51YWwgXFx0YWdcbiAgICAgICAgdGFnRWxlbWVudCA9IGJ1aWxkRXhwcmVzc2lvblJvdyh0YWdbMF0uYm9keSwgc3R5bGUud2l0aExldmVsKGNlbGxMZXZlbCksIHRydWUpO1xuICAgICAgICB0YWdFbGVtZW50ID0gY29uc29saWRhdGVUZXh0KHRhZ0VsZW1lbnQpO1xuICAgICAgICB0YWdFbGVtZW50LmNsYXNzZXMgPSBbXCJ0bWwtdGFnXCJdO1xuICAgICAgfVxuICAgICAgaWYgKHRhZ0VsZW1lbnQpIHtcbiAgICAgICAgcm93LnVuc2hpZnQoZ2x1ZShncm91cCkpO1xuICAgICAgICByb3cucHVzaChnbHVlKGdyb3VwKSk7XG4gICAgICAgIGlmIChncm91cC5sZXFubykge1xuICAgICAgICAgIHJvd1swXS5jaGlsZHJlbi5wdXNoKHRhZ0VsZW1lbnQpO1xuICAgICAgICAgIHJvd1swXS5jbGFzc2VzLnB1c2goXCJ0bWwtbGVmdFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3dbcm93Lmxlbmd0aCAtIDFdLmNoaWxkcmVuLnB1c2godGFnRWxlbWVudCk7XG4gICAgICAgICAgcm93W3Jvdy5sZW5ndGggLSAxXS5jbGFzc2VzLnB1c2goXCJ0bWwtcmlnaHRcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbXRyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgcm93LCBbXSk7XG4gICAgY29uc3QgbGFiZWwgPSBncm91cC5sYWJlbHMuc2hpZnQoKTtcbiAgICBpZiAobGFiZWwgJiYgZ3JvdXAudGFncyAmJiBncm91cC50YWdzW2ldKSB7XG4gICAgICBtdHIuc2V0QXR0cmlidXRlKFwiaWRcIiwgbGFiZWwpO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZ3JvdXAudGFnc1tpXSkpIHsgbXRyLmNsYXNzZXMucHVzaChcInRtbC10YWdlcW5cIik7IH1cbiAgICB9XG5cbiAgICAvLyBXcml0ZSBob3Jpem9udGFsIHJ1bGVzXG4gICAgaWYgKGkgPT09IDAgJiYgaGxpbmVzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChobGluZXNbMF0ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG10ci5jaGlsZHJlbi5mb3JFYWNoKGNlbGwgPT4geyBjZWxsLnN0eWxlLmJvcmRlclRvcCA9IFwiMC4xNWVtIGRvdWJsZVwiOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG10ci5jaGlsZHJlbi5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgIGNlbGwuc3R5bGUuYm9yZGVyVG9wID0gaGxpbmVzWzBdWzBdID8gXCIwLjA2ZW0gZGFzaGVkXCIgOiBcIjAuMDZlbSBzb2xpZFwiO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhsaW5lc1tpICsgMV0ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGhsaW5lc1tpICsgMV0ubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIG10ci5jaGlsZHJlbi5mb3JFYWNoKGNlbGwgPT4geyBjZWxsLnN0eWxlLmJvcmRlckJvdHRvbSA9IFwiMC4xNWVtIGRvdWJsZVwiOyB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG10ci5jaGlsZHJlbi5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgICAgIGNlbGwuc3R5bGUuYm9yZGVyQm90dG9tID0gaGxpbmVzW2kgKyAxXVswXSA/IFwiMC4wNmVtIGRhc2hlZFwiIDogXCIwLjA2ZW0gc29saWRcIjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIFxcaHBoYW50b20gXFxmcm9tIFxcYm9yZGVybWF0cml4XG4gICAgbGV0IG11c3RTcXVhc2hSb3cgPSB0cnVlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbXRyLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG10ci5jaGlsZHJlbltqXS5jaGlsZHJlblswXTtcbiAgICAgIGlmICghKGNoaWxkICYmIGNoaWxkLnR5cGUgPT09IFwibXBhZGRlZFwiICYmIGNoaWxkLmF0dHJpYnV0ZXMuaGVpZ2h0ID09PSBcIjBweFwiKSkge1xuICAgICAgICBtdXN0U3F1YXNoUm93ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtdXN0U3F1YXNoUm93KSB7XG4gICAgICAvLyBBbGwgdGhlIGNlbGwgY29udGVudHMgYXJlIFxcaHBoYW50b20uIFNxdWFzaCB0aGUgcGFkZGluZy5cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbXRyLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG10ci5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XG4gICAgICAgIG10ci5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nQm90dG9tID0gXCIwXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGJsLnB1c2gobXRyKTtcbiAgfVxuXG4gIGlmIChncm91cC5hcnJheXN0cmV0Y2ggJiYgZ3JvdXAuYXJyYXlzdHJldGNoICE9PSAxKSB7XG4gICAgLy8gSW4gTGFUZVgsIFxcYXJyYXlzdHJldGNoIGlzIGEgZmFjdG9yIGFwcGxpZWQgdG8gYSAxMnB0IHN0cnV0IGhlaWdodC5cbiAgICAvLyBJdCBkZWZpbmVzIGEgYmFzZWxpbmUgdG8gYmFzZWxpbmUgZGlzdGFuY2UuXG4gICAgLy8gSGVyZSwgd2UgZG8gYW4gYXBwcm94aW1hdGlvbiBvZiB0aGF0IGFwcHJvYWNoLlxuICAgIGNvbnN0IHBhZCA9IFN0cmluZygxLjQgKiBncm91cC5hcnJheXN0cmV0Y2ggLSAwLjgpICsgXCJleFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGJsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRibFtpXS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICB0YmxbaV0uY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ1RvcCA9IHBhZDtcbiAgICAgICAgdGJsW2ldLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBwYWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHNpZGVQYWRkaW5nO1xuICBsZXQgc2lkZVBhZFVuaXQ7XG4gIGlmIChncm91cC5lbnZDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICBzaWRlUGFkZGluZyA9IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJhYnV0XCIpXG4gICAgICA/IFwiMFwiXG4gICAgICA6IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJjYXNlc1wiKVxuICAgICAgPyBcIjBcIlxuICAgICAgOiBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwic21hbGxcIilcbiAgICAgID8gXCIwLjEzODlcIlxuICAgICAgOiBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiY2RcIilcbiAgICAgID8gXCIwLjI1XCJcbiAgICAgIDogXCIwLjRcIjsgLy8gZGVmYXVsdCBzaWRlIHBhZGRpbmdcbiAgICBzaWRlUGFkVW5pdCA9IFwiZW1cIjtcbiAgfVxuICBpZiAoZ3JvdXAuYXJyYXljb2xzZXApIHtcbiAgICBjb25zdCBhcnJheVNpZGVQYWQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmFycmF5Y29sc2VwLCBzdHlsZSk7XG4gICAgc2lkZVBhZGRpbmcgPSBhcnJheVNpZGVQYWQubnVtYmVyLnRvRml4ZWQoNCk7XG4gICAgc2lkZVBhZFVuaXQgPSBhcnJheVNpZGVQYWQudW5pdDtcbiAgfVxuICBpZiAoc2lkZVBhZGRpbmcpIHtcbiAgICBjb25zdCBudW1Db2xzID0gdGJsLmxlbmd0aCA9PT0gMCA/IDAgOiB0YmxbMF0uY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgY29uc3Qgc2lkZVBhZCA9IChqLCBoYW5kKSA9PiB7XG4gICAgICBpZiAoaiA9PT0gMCAmJiBoYW5kID09PSAwKSB7IHJldHVybiBcIjBcIiB9XG4gICAgICBpZiAoaiA9PT0gbnVtQ29scyAtIDEgJiYgaGFuZCA9PT0gMSkgeyByZXR1cm4gXCIwXCIgfVxuICAgICAgaWYgKGdyb3VwLmVudkNsYXNzZXNbMF0gIT09IFwiYWxpZ25cIikgeyByZXR1cm4gc2lkZVBhZGRpbmcgfVxuICAgICAgaWYgKGhhbmQgPT09IDEpIHsgcmV0dXJuIFwiMFwiIH1cbiAgICAgIGlmIChncm91cC5hdXRvVGFnKSB7XG4gICAgICAgIHJldHVybiAoaiAlIDIpID8gXCIxXCIgOiBcIjBcIlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChqICUgMikgPyBcIjBcIiA6IFwiMVwiXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNpZGUgcGFkZGluZ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGJsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRibFtpXS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICB0YmxbaV0uY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtzaWRlUGFkKGosIDApfSR7c2lkZVBhZFVuaXR9YDtcbiAgICAgICAgdGJsW2ldLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3NpZGVQYWQoaiwgMSl9JHtzaWRlUGFkVW5pdH1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBTZXQgemVybyBwYWRkaW5nIG9uIHNpZGUgb2YgdGhlIG1hdHJpeFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGJsLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0YmxbaV0uY2hpbGRyZW5bMF0uc3R5bGUucGFkZGluZ0xlZnQgPSBcIjBlbVwiO1xuICAgICAgaWYgKHRibFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IHRibFswXS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdGJsW2ldLmNoaWxkcmVuW3RibFtpXS5jaGlsZHJlbi5sZW5ndGggLSAxXS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBcIjBlbVwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChncm91cC5lbnZDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBKdXN0aWZpY2F0aW9uXG4gICAgY29uc3QgYWxpZ24gPSBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiYWxpZ25cIikgfHwgZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImFsaWduYXRcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YmwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IHRibFtpXTtcbiAgICAgIGlmIChhbGlnbikge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIC8vIENocm9taXVtIGRvZXMgbm90IHJlY29nbml6ZSB0ZXh0LWFsaWduOiBsZWZ0LiBVc2UgLXdlYmtpdC1cbiAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgLXdlYmtpdC0gd2hlbiBDaHJvbWl1bSBubyBsb25nZXIgbmVlZHMgaXQuXG4gICAgICAgICAgcm93LmNoaWxkcmVuW2pdLmNsYXNzZXMgPSBbXCJ0bWwtXCIgKyAoaiAlIDIgPyBcImxlZnRcIiA6IFwicmlnaHRcIildO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cC5hdXRvVGFnKSB7XG4gICAgICAgICAgY29uc3QgayA9IGdyb3VwLmxlcW5vID8gMCA6IHJvdy5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICAgIHJvdy5jaGlsZHJlbltrXS5jbGFzc2VzID0gW1widG1sLVwiICsgKGdyb3VwLmxlcW5vID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJvdy5jaGlsZHJlbi5sZW5ndGggPiAxICYmIGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJjYXNlc1wiKSkge1xuICAgICAgICByb3cuY2hpbGRyZW5bMV0uc3R5bGUucGFkZGluZ0xlZnQgPSBcIjFlbVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImNhc2VzXCIpIHx8IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJzdWJhcnJheVwiKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2Ygcm93LmNoaWxkcmVuKSB7XG4gICAgICAgICAgY2VsbC5jbGFzc2VzLnB1c2goXCJ0bWwtbGVmdFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIHRibCk7XG4gIGlmIChncm91cC5lbnZDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBUb3AgJiBib3R0b20gcGFkZGluZ1xuICAgIGlmIChncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiam90XCIpKSB7XG4gICAgICB0YWJsZS5jbGFzc2VzLnB1c2goXCJ0bWwtam90XCIpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcInNtYWxsXCIpKSB7XG4gICAgICB0YWJsZS5jbGFzc2VzLnB1c2goXCJ0bWwtc21hbGxcIik7XG4gICAgfVxuICB9XG4gIGlmIChncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJkaXNwbGF5XCIpIHsgdGFibGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFwidHJ1ZVwiKTsgfVxuXG4gIGlmIChncm91cC5hdXRvVGFnIHx8IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJtdWx0bGluZVwiKSkge1xuICAgIHRhYmxlLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gIH1cblxuICAvLyBDb2x1bW4gc2VwYXJhdG9yIGxpbmVzIGFuZCBjb2x1bW4gYWxpZ25tZW50XG4gIGxldCBhbGlnbiA9IFwiXCI7XG5cbiAgaWYgKGdyb3VwLmNvbHMgJiYgZ3JvdXAuY29scy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY29scyA9IGdyb3VwLmNvbHM7XG4gICAgbGV0IHByZXZUeXBlV2FzQWxpZ24gPSBmYWxzZTtcbiAgICBsZXQgaVN0YXJ0ID0gMDtcbiAgICBsZXQgaUVuZCA9IGNvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGNvbHNbaVN0YXJ0XS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBpU3RhcnQgKz0gMTtcbiAgICB9XG4gICAgd2hpbGUgKGNvbHNbaUVuZCAtIDFdLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgIGlFbmQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoY29sc1swXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBjb25zdCBzZXAgPSBjb2xzWzFdLnR5cGUgPT09IFwic2VwYXJhdG9yXCJcbiAgICAgICAgPyBcIjAuMTVlbSBkb3VibGVcIlxuICAgICAgICA6IGNvbHNbMF0uc2VwYXJhdG9yID09PSBcInxcIlxuICAgICAgICA/IFwiMC4wNmVtIHNvbGlkIFwiXG4gICAgICAgIDogXCIwLjA2ZW0gZGFzaGVkIFwiO1xuICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcm93LmNoaWxkcmVuWzBdLnN0eWxlLmJvcmRlckxlZnQgPSBzZXA7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpQ29sID0gZ3JvdXAuYXV0b1RhZyA/IDAgOiAtMTtcbiAgICBmb3IgKGxldCBpID0gaVN0YXJ0OyBpIDwgaUVuZDsgaSsrKSB7XG4gICAgICBpZiAoY29sc1tpXS50eXBlID09PSBcImFsaWduXCIpIHtcbiAgICAgICAgY29uc3QgY29sQWxpZ24gPSBhbGlnbk1hcFtjb2xzW2ldLmFsaWduXTtcbiAgICAgICAgYWxpZ24gKz0gY29sQWxpZ247XG4gICAgICAgIGlDb2wgKz0gMTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoY29sQWxpZ24udHJpbSgpICE9PSBcImNlbnRlclwiICYmIGlDb2wgPCByb3cuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByb3cuY2hpbGRyZW5baUNvbF0uY2xhc3NlcyA9IFtcInRtbC1cIiArIGNvbEFsaWduLnRyaW0oKV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjb2xzW2ldLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgICAgLy8gTWF0aE1MIGFjY2VwdHMgb25seSBzaW5nbGUgbGluZXMgYmV0d2VlbiBjZWxscy5cbiAgICAgICAgLy8gU28gd2UgcmVhZCBvbmx5IHRoZSBmaXJzdCBvZiBjb25zZWN1dGl2ZSBzZXBhcmF0b3JzLlxuICAgICAgICBpZiAocHJldlR5cGVXYXNBbGlnbikge1xuICAgICAgICAgIGNvbnN0IHNlcCA9IGNvbHNbaSArIDFdLnR5cGUgPT09IFwic2VwYXJhdG9yXCJcbiAgICAgICAgICAgID8gXCIwLjE1ZW0gZG91YmxlXCJcbiAgICAgICAgICAgIDogY29sc1tpXS5zZXBhcmF0b3IgPT09IFwifFwiXG4gICAgICAgICAgICA/IFwiMC4wNmVtIHNvbGlkXCJcbiAgICAgICAgICAgIDogXCIwLjA2ZW0gZGFzaGVkXCI7XG4gICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgdGFibGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChpQ29sIDwgcm93LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICByb3cuY2hpbGRyZW5baUNvbF0uc3R5bGUuYm9yZGVyUmlnaHQgPSBzZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbHNbY29scy5sZW5ndGggLSAxXS50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICBjb25zdCBzZXAgPSBjb2xzW2NvbHMubGVuZ3RoIC0gMl0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIlxuICAgICAgICA/IFwiMC4xNWVtIGRvdWJsZVwiXG4gICAgICAgIDogY29sc1tjb2xzLmxlbmd0aCAtIDFdLnNlcGFyYXRvciA9PT0gXCJ8XCJcbiAgICAgICAgPyBcIjAuMDZlbSBzb2xpZFwiXG4gICAgICAgIDogXCIwLjA2ZW0gZGFzaGVkXCI7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZS5jaGlsZHJlbikge1xuICAgICAgICByb3cuY2hpbGRyZW5bcm93LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN0eWxlLmJvcmRlclJpZ2h0ID0gc2VwO1xuICAgICAgICByb3cuY2hpbGRyZW5bcm93LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMC40ZW1cIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGdyb3VwLmF1dG9UYWcpIHtcbiAgICAgLy8gYWxsb3cgZm9yIGdsdWUgY2VsbHMgb24gZWFjaCBzaWRlXG4gICAgYWxpZ24gPSBcImxlZnQgXCIgKyAoYWxpZ24ubGVuZ3RoID4gMCA/IGFsaWduIDogXCJjZW50ZXIgXCIpICsgXCJyaWdodCBcIjtcbiAgfVxuICBpZiAoYWxpZ24pIHtcbiAgICAvLyBGaXJlZm94IHJlYWRzIHRoaXMgYXR0cmlidXRlLCBub3QgdGhlIC13ZWJraXQtbGVmdHxyaWdodCB3cml0dGVuIGFib3ZlLlxuICAgIC8vIFRPRE86IFdoZW4gQ2hyb21lIG5vIGxvbmdlciBuZWVkcyBcIi13ZWJraXQtXCIsIHVzZSBDU1MgYW5kIGRlbGV0ZSB0aGUgbmV4dCBsaW5lLlxuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbmFsaWduXCIsIGFsaWduLnRyaW0oKSk7XG4gIH1cblxuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcInNtYWxsXCIpKSB7XG4gICAgLy8gQSBzbWFsbCBhcnJheS4gV3JhcCBpbiBzY3JpcHRzdHlsZS5cbiAgICB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIFt0YWJsZV0pO1xuICAgIHRhYmxlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMVwiKTtcbiAgfVxuXG4gIHJldHVybiB0YWJsZVxufTtcblxuLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFsaWduLCBhbGlnbiosIGFsaWduZWQsIGFsaWduYXQsIGFsaWduYXQqLCBhbGlnbmVkYXQsIHNwbGl0LlxuY29uc3QgYWxpZ25lZEhhbmRsZXIgPSBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gIGlmIChjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcImVkXCIpID09PSAtMSkge1xuICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICB9XG4gIGNvbnN0IGlzU3BsaXQgPSBjb250ZXh0LmVudk5hbWUgPT09IFwic3BsaXRcIjtcbiAgY29uc3QgY29scyA9IFtdO1xuICBjb25zdCByZXMgPSBwYXJzZUFycmF5KFxuICAgIGNvbnRleHQucGFyc2VyLFxuICAgIHtcbiAgICAgIGNvbHMsXG4gICAgICBlbXB0eVNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIGF1dG9UYWc6IGlzU3BsaXQgPyB1bmRlZmluZWQgOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgICBlbnZDbGFzc2VzOiBbXCJhYnV0XCIsIFwiam90XCJdLCAvLyBzZXQgcm93IHNwYWNpbmcgJiBwcm92aXNpb25hbCBjb2x1bW4gc3BhY2luZ1xuICAgICAgbWF4TnVtQ29sczogY29udGV4dC5lbnZOYW1lID09PSBcInNwbGl0XCIgPyAyIDogdW5kZWZpbmVkLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfSxcbiAgICBcImRpc3BsYXlcIlxuICApO1xuXG4gIC8vIERldGVybWluaW5nIG51bWJlciBvZiBjb2x1bW5zLlxuICAvLyAxLiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ2l2ZW4sIHdlIHVzZSBpdCBhcyBhIG51bWJlciBvZiBjb2x1bW5zLFxuICAvLyAgICBhbmQgbWFrZXMgc3VyZSB0aGF0IGVhY2ggcm93IGRvZXNuJ3QgZXhjZWVkIHRoYXQgbnVtYmVyLlxuICAvLyAyLiBPdGhlcndpc2UsIGp1c3QgY291bnQgbnVtYmVyIG9mIGNvbHVtbnMgPSBtYXhpbXVtIG51bWJlclxuICAvLyAgICBvZiBjZWxscyBpbiBlYWNoIHJvdyAoXCJhbGlnbmVkXCIgbW9kZSAtLSBpc0FsaWduZWQgd2lsbCBiZSB0cnVlKS5cbiAgLy9cbiAgLy8gQXQgdGhlIHNhbWUgdGltZSwgcHJlcGVuZCBlbXB0eSBncm91cCB7fSBhdCBiZWdpbm5pbmcgb2YgZXZlcnkgc2Vjb25kXG4gIC8vIGNlbGwgaW4gZWFjaCByb3cgKHN0YXJ0aW5nIHdpdGggc2Vjb25kIGNlbGwpIHNvIHRoYXQgb3BlcmF0b3JzIGJlY29tZVxuICAvLyBiaW5hcnkuICBUaGlzIGJlaGF2aW9yIGlzIGltcGxlbWVudGVkIGluIGFtc21hdGgncyBcXHN0YXJ0QGFsaWduZWQuXG4gIGxldCBudW1NYXRocztcbiAgbGV0IG51bUNvbHMgPSAwO1xuICBjb25zdCBpc0FsaWduZWRBdCA9IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiYXRcIikgPiAtMTtcbiAgaWYgKGFyZ3NbMF0gJiYgaXNBbGlnbmVkQXQpIHtcbiAgICAvLyBhbGlnbmF0IGVudmlyb25tZW50IHRha2VzIGFuIGFyZ3VtZW50IHcvIG51bWJlciBvZiBjb2x1bW5zXG4gICAgbGV0IGFyZzAgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJnc1swXS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0ZXh0b3JkID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXS5ib2R5W2ldLCBcInRleHRvcmRcIik7XG4gICAgICBhcmcwICs9IHRleHRvcmQudGV4dDtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGFyZzApKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRoZSBhbGlnbmF0IGVudmlyb21lbnQgcmVxdWlyZXMgYSBudW1lcmljIGZpcnN0IGFyZ3VtZW50LlwiKVxuICAgIH1cbiAgICBudW1NYXRocyA9IE51bWJlcihhcmcwKTtcbiAgICBudW1Db2xzID0gbnVtTWF0aHMgKiAyO1xuICB9XG4gIHJlcy5ib2R5LmZvckVhY2goZnVuY3Rpb24ocm93KSB7XG4gICAgaWYgKGlzQWxpZ25lZEF0KSB7XG4gICAgICAvLyBDYXNlIDFcbiAgICAgIGNvbnN0IGN1ck1hdGhzID0gcm93Lmxlbmd0aCAvIDI7XG4gICAgICBpZiAobnVtTWF0aHMgPCBjdXJNYXRocykge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICBcIlRvbyBtYW55IG1hdGggaW4gYSByb3c6IFwiICsgYGV4cGVjdGVkICR7bnVtTWF0aHN9LCBidXQgZ290ICR7Y3VyTWF0aHN9YCxcbiAgICAgICAgICByb3dbMF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAvLyBDYXNlIDJcbiAgICAgIG51bUNvbHMgPSByb3cubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gQWRqdXN0aW5nIGFsaWdubWVudC5cbiAgLy8gSW4gYWxpZ25lZCBtb2RlLCB3ZSBhZGQgb25lIFxccXF1YWQgYmV0d2VlbiBjb2x1bW5zO1xuICAvLyBvdGhlcndpc2Ugd2UgYWRkIG5vdGhpbmcuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29sczsgKytpKSB7XG4gICAgbGV0IGFsaWduID0gXCJyXCI7XG4gICAgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICBhbGlnbiA9IFwibFwiO1xuICAgIH1cbiAgICBjb2xzW2ldID0ge1xuICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgYWxpZ246IGFsaWduXG4gICAgfTtcbiAgfVxuICBpZiAoY29udGV4dC5lbnZOYW1lID09PSBcInNwbGl0XCIpIDsgZWxzZSBpZiAoaXNBbGlnbmVkQXQpIHtcbiAgICByZXMuZW52Q2xhc3Nlcy5wdXNoKFwiYWxpZ25hdFwiKTsgLy8gU2V0cyBqdXN0aWZpY2F0aW9uXG4gIH0gZWxzZSB7XG4gICAgcmVzLmVudkNsYXNzZXNbMF0gPSBcImFsaWduXCI7IC8vIFNldHMgY29sdW1uIHNwYWNpbmcgJiBqdXN0aWZpY2F0aW9uXG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cbi8vIEFycmF5cyBhcmUgcGFydCBvZiBMYVRlWCwgZGVmaW5lZCBpbiBsdHRhYi5kdHggc28gaXRzIGRvY3VtZW50YXRpb25cbi8vIGlzIHBhcnQgb2YgdGhlIHNvdXJjZTJlLnBkZiBmaWxlIG9mIExhVGVYMmUgc291cmNlIGRvY3VtZW50YXRpb24uXG4vLyB7ZGFycmF5fSBpcyBhbiB7YXJyYXl9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG5jY21hdGguc3R5LlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJhcnJheVwiLCBcImRhcnJheVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIC8vIFNpbmNlIG5vIHR5cGVzIGFyZSBzcGVjaWZpZWQgYWJvdmUsIHRoZSB0d28gcG9zc2liaWxpdGllcyBhcmVcbiAgICAvLyAtIFRoZSBhcmd1bWVudCBpcyB3cmFwcGVkIGluIHt9IG9yIFtdLCBpbiB3aGljaCBjYXNlIFBhcnNlcidzXG4gICAgLy8gICBwYXJzZUdyb3VwKCkgcmV0dXJucyBhbiBcIm9yZGdyb3VwXCIgd3JhcHBpbmcgc29tZSBzeW1ib2wgbm9kZS5cbiAgICAvLyAtIFRoZSBhcmd1bWVudCBpcyBhIGJhcmUgc3ltYm9sIG5vZGUuXG4gICAgY29uc3Qgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7XG4gICAgY29uc3QgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKS5ib2R5O1xuICAgIGNvbnN0IGNvbHMgPSBjb2xhbGlnbi5tYXAoZnVuY3Rpb24obmRlKSB7XG4gICAgICBjb25zdCBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTtcbiAgICAgIGNvbnN0IGNhID0gbm9kZS50ZXh0O1xuICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjYSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcGFyYXRvclwiLFxuICAgICAgICAgIHNlcGFyYXRvcjogXCJ8XCJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwiOlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJzZXBhcmF0b3JcIixcbiAgICAgICAgICBzZXBhcmF0b3I6IFwiOlwiXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVua25vd24gY29sdW1uIGFsaWdubWVudDogXCIgKyBjYSwgbmRlKTtcbiAgICB9KTtcbiAgICBjb25zdCBbYXJyYXlzdHJldGNoLCBhcnJheWNvbHNlcF0gPSBhcnJheUdhcHMoY29udGV4dC5wYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgY29scyxcbiAgICAgIGVudkNsYXNzZXM6IFtcImFycmF5XCJdLFxuICAgICAgbWF4TnVtQ29sczogY29scy5sZW5ndGgsXG4gICAgICBhcnJheXN0cmV0Y2gsXG4gICAgICBhcnJheWNvbHNlcFxuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgZENlbGxTdHlsZShjb250ZXh0LmVudk5hbWUpKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gVGhlIG1hdHJpeCBlbnZpcm9ubWVudHMgb2YgYW1zbWF0aCBidWlsZCBvbiB0aGUgYXJyYXkgZW52aXJvbm1lbnRcbi8vIG9mIExhVGVYLCB3aGljaCBpcyBkaXNjdXNzZWQgYWJvdmUuXG4vLyBUaGUgbWF0aHRvb2xzIHBhY2thZ2UgYWRkcyBzdGFycmVkIHZlcnNpb25zIG9mIHRoZSBzYW1lIGVudmlyb25tZW50cy5cbi8vIFRoZXNlIGhhdmUgYW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gY2hvb3NlIGxlZnR8Y2VudGVyfHJpZ2h0IGp1c3RpZmljYXRpb24uXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcbiAgICBcIm1hdHJpeFwiLFxuICAgIFwicG1hdHJpeFwiLFxuICAgIFwiYm1hdHJpeFwiLFxuICAgIFwiQm1hdHJpeFwiLFxuICAgIFwidm1hdHJpeFwiLFxuICAgIFwiVm1hdHJpeFwiLFxuICAgIFwibWF0cml4KlwiLFxuICAgIFwicG1hdHJpeCpcIixcbiAgICBcImJtYXRyaXgqXCIsXG4gICAgXCJCbWF0cml4KlwiLFxuICAgIFwidm1hdHJpeCpcIixcbiAgICBcIlZtYXRyaXgqXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IGRlbGltaXRlcnMgPSB7XG4gICAgICBtYXRyaXg6IG51bGwsXG4gICAgICBwbWF0cml4OiBbXCIoXCIsIFwiKVwiXSxcbiAgICAgIGJtYXRyaXg6IFtcIltcIiwgXCJdXCJdLFxuICAgICAgQm1hdHJpeDogW1wiXFxcXHtcIiwgXCJcXFxcfVwiXSxcbiAgICAgIHZtYXRyaXg6IFtcInxcIiwgXCJ8XCJdLFxuICAgICAgVm1hdHJpeDogW1wiXFxcXFZlcnRcIiwgXCJcXFxcVmVydFwiXVxuICAgIH1bY29udGV4dC5lbnZOYW1lLnJlcGxhY2UoXCIqXCIsIFwiXCIpXTtcbiAgICAvLyBcXGhza2lwIC1cXGFycmF5Y29sc2VwIGluIGFtc21hdGhcbiAgICBsZXQgY29sQWxpZ24gPSBcImNcIjtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgZW52Q2xhc3NlczogW10sXG4gICAgICBjb2xzOiBbXVxuICAgIH07XG4gICAgaWYgKGNvbnRleHQuZW52TmFtZS5jaGFyQXQoY29udGV4dC5lbnZOYW1lLmxlbmd0aCAtIDEpID09PSBcIipcIikge1xuICAgICAgLy8gSXQncyBvbmUgb2YgdGhlIG1hdGh0b29scyBzdGFycmVkIGZ1bmN0aW9ucy5cbiAgICAgIC8vIFBhcnNlIHRoZSBvcHRpb25hbCBhbGlnbm1lbnQgYXJndW1lbnQuXG4gICAgICBjb25zdCBwYXJzZXIgPSBjb250ZXh0LnBhcnNlcjtcbiAgICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgICBpZiAocGFyc2VyLmZldGNoKCkudGV4dCA9PT0gXCJbXCIpIHtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgICAgY29sQWxpZ24gPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICAgICAgICBpZiAoXCJsY3JcIi5pbmRleE9mKGNvbEFsaWduKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGwgb3IgYyBvciByXCIsIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgICAgIHBhcnNlci5leHBlY3QoXCJdXCIpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXlsb2FkLmNvbHMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgXCJ0ZXh0XCIpO1xuICAgIHJlcy5jb2xzID0gbmV3IEFycmF5KHJlcy5ib2R5WzBdLmxlbmd0aCkuZmlsbCh7IHR5cGU6IFwiYWxpZ25cIiwgYWxpZ246IGNvbEFsaWduIH0pO1xuICAgIGNvbnN0IFthcnJheXN0cmV0Y2gsIGFycmF5Y29sc2VwXSA9IGFycmF5R2Fwcyhjb250ZXh0LnBhcnNlci5ndWxsZXQubWFjcm9zKTtcbiAgICByZXMuYXJyYXlzdHJldGNoID0gYXJyYXlzdHJldGNoO1xuICAgIGlmIChhcnJheWNvbHNlcCAmJiAhKGFycmF5Y29sc2VwID09PSA2ICYmIGFycmF5Y29sc2VwID09PSBcInB0XCIpKSB7XG4gICAgICByZXMuYXJyYXljb2xzZXAgPSBhcnJheWNvbHNlcDtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGltaXRlcnNcbiAgICAgID8ge1xuICAgICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgICAgIGJvZHk6IFtyZXNdLFxuICAgICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICByaWdodDogZGVsaW1pdGVyc1sxXSxcbiAgICAgICAgcmlnaHRDb2xvcjogdW5kZWZpbmVkIC8vIFxccmlnaHQgdW5pbmZsdWVuY2VkIGJ5IFxcY29sb3IgaW4gYXJyYXlcbiAgICAgIH1cbiAgICAgIDogcmVzO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImJvcmRlcm1hdHJpeFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7IGNvbHM6IFtdLCBlbnZDbGFzc2VzOiBbXCJib3JkZXJtYXRyaXhcIl0gfTtcbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBcInRleHRcIik7XG4gICAgcmVzLmNvbHMgPSBuZXcgQXJyYXkocmVzLmJvZHlbMF0ubGVuZ3RoKS5maWxsKHsgdHlwZTogXCJhbGlnblwiLCBhbGlnbjogXCJjXCIgfSk7XG4gICAgcmVzLmVudkNsYXNzZXMgPSBbXTtcbiAgICByZXMuYXJyYXlzdHJldGNoID0gMTtcbiAgICBpZiAoY29udGV4dC5lbnZOYW1lID09PSBcIm1hdHJpeFwiKSB7IHJldHVybiByZXN9XG4gICAgcmV0dXJuIGJvcmRlcm1hdHJpeFBhcnNlVHJlZShyZXMsIGNvbnRleHQuZGVsaW1pdGVycylcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJzbWFsbG1hdHJpeFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7IHR5cGU6IFwic21hbGxcIiB9O1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIFwic2NyaXB0XCIpO1xuICAgIHJlcy5lbnZDbGFzc2VzID0gW1wic21hbGxcIl07XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJzdWJhcnJheVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIC8vIFBhcnNpbmcgb2Yge3N1YmFycmF5fSBpcyBzaW1pbGFyIHRvIHthcnJheX1cbiAgICBjb25zdCBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICBjb25zdCBjb2xhbGlnbiA9IHN5bU5vZGUgPyBbYXJnc1swXV0gOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcIm9yZGdyb3VwXCIpLmJvZHk7XG4gICAgY29uc3QgY29scyA9IGNvbGFsaWduLm1hcChmdW5jdGlvbihuZGUpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhc3NlcnRTeW1ib2xOb2RlVHlwZShuZGUpO1xuICAgICAgY29uc3QgY2EgPSBub2RlLnRleHQ7XG4gICAgICAvLyB7c3ViYXJyYXl9IG9ubHkgcmVjb2duaXplcyBcImxcIiAmIFwiY1wiXG4gICAgICBpZiAoXCJsY1wiLmluZGV4T2YoY2EpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuICAgIGlmIChjb2xzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwie3N1YmFycmF5fSBjYW4gY29udGFpbiBvbmx5IG9uZSBjb2x1bW5cIik7XG4gICAgfVxuICAgIGxldCByZXMgPSB7XG4gICAgICBjb2xzLFxuICAgICAgZW52Q2xhc3NlczogW1wic21hbGxcIl1cbiAgICB9O1xuICAgIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJzY3JpcHRcIik7XG4gICAgaWYgKHJlcy5ib2R5Lmxlbmd0aCA+IDAgJiYgcmVzLmJvZHlbMF0ubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gQSBjYXNlcyBlbnZpcm9ubWVudCAoaW4gYW1zbWF0aC5zdHkpIGlzIGFsbW9zdCBlcXVpdmFsZW50IHRvXG4vLyBcXGRlZlxuLy8gXFxsZWZ0XFx7XFxiZWdpbnthcnJheX17QHt9bEB7XFxxdWFkfWxAe319IOKApiBcXGVuZHthcnJheX1cXHJpZ2h0LlxuLy8ge2RjYXNlc30gaXMgYSB7Y2FzZXN9IGVudmlyb25tZW50IHdoZXJlIGNlbGxzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUsXG4vLyBhcyBkZWZpbmVkIGluIG1hdGh0b29scy5zdHkuXG4vLyB7cmNhc2VzfSBpcyBhbm90aGVyIG1hdGh0b29scyBlbnZpcm9ubWVudC4gSXQncyBicmFjZSBpcyBvbiB0aGUgcmlnaHQgc2lkZS5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiY2FzZXNcIiwgXCJkY2FzZXNcIiwgXCJyY2FzZXNcIiwgXCJkcmNhc2VzXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIGNvbHM6IFtdLFxuICAgICAgZW52Q2xhc3NlczogW1wiY2FzZXNcIl1cbiAgICB9O1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICBtb2RlOiBjb250ZXh0Lm1vZGUsXG4gICAgICBib2R5OiBbcmVzXSxcbiAgICAgIGxlZnQ6IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiclwiKSA+IC0xID8gXCIuXCIgOiBcIlxcXFx7XCIsXG4gICAgICByaWdodDogY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJyXCIpID4gLTEgPyBcIlxcXFx9XCIgOiBcIi5cIixcbiAgICAgIHJpZ2h0Q29sb3I6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIEluIHRoZSBhbGlnbiBlbnZpcm9ubWVudCwgb25lIHVzZXMgYW1wZXJzYW5kcywgJiwgdG8gc3BlY2lmeSBudW1iZXIgb2Zcbi8vIGNvbHVtbnMgaW4gZWFjaCByb3csIGFuZCB0byBsb2NhdGUgc3BhY2luZyBiZXR3ZWVuIGVhY2ggY29sdW1uLlxuLy8gYWxpZ24gZ2V0cyBhdXRvbWF0aWMgbnVtYmVyaW5nLiBhbGlnbiogYW5kIGFsaWduZWQgZG8gbm90LlxuLy8gVGhlIGFsaWduZWRhdCBlbnZpcm9ubWVudCBjYW4gYmUgdXNlZCBpbiBtYXRoIG1vZGUuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImFsaWduXCIsIFwiYWxpZ24qXCIsIFwiYWxpZ25lZFwiLCBcInNwbGl0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogYWxpZ25lZEhhbmRsZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIGFsaWduYXQgZW52aXJvbm1lbnQgaXMgbGlrZSBhbiBhbGlnbiBlbnZpcm9ubWVudCwgYnV0IG9uZSBtdXN0IGV4cGxpY2l0bHlcbi8vIHNwZWNpZnkgbWF4aW11bSBudW1iZXIgb2YgY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIGNhbiBhZGp1c3Qgd2hlcmUgc3BhY2luZyBvY2N1cnMuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImFsaWduYXRcIiwgXCJhbGlnbmF0KlwiLCBcImFsaWduZWRhdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBBIGdhdGhlcmVkIGVudmlyb25tZW50IGlzIGxpa2UgYW4gYXJyYXkgZW52aXJvbm1lbnQgd2l0aCBvbmUgY2VudGVyZWRcbi8vIGNvbHVtbiwgYnV0IHdoZXJlIHJvd3MgYXJlIGNvbnNpZGVyZWQgbGluZXMgc28gZ2V0IFxcam90IGxpbmUgc3BhY2luZ1xuLy8gYW5kIGNvbnRlbnRzIGFyZSBzZXQgaW4gXFxkaXNwbGF5c3R5bGUuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImdhdGhlcmVkXCIsIFwiZ2F0aGVyXCIsIFwiZ2F0aGVyKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LmVudk5hbWUgIT09IFwiZ2F0aGVyZWRcIikge1xuICAgICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGNvbHM6IFtdLFxuICAgICAgZW52Q2xhc3NlczogW1wiYWJ1dFwiLCBcImpvdFwiXSxcbiAgICAgIGF1dG9UYWc6IGdldEF1dG9UYWcoY29udGV4dC5lbnZOYW1lKSxcbiAgICAgIGVtcHR5U2luZ2xlUm93OiB0cnVlLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiZXF1YXRpb25cIiwgXCJlcXVhdGlvbipcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBhdXRvVGFnOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksXG4gICAgICBlbXB0eVNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIHNpbmdsZVJvdzogdHJ1ZSxcbiAgICAgIG1heE51bUNvbHM6IDEsXG4gICAgICBlbnZDbGFzc2VzOiBbXCJhbGlnblwiXSxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJkaXNwbGF5XCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcIm11bHRsaW5lXCIsIFwibXVsdGxpbmUqXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgYXV0b1RhZzogY29udGV4dC5lbnZOYW1lID09PSBcIm11bHRsaW5lXCIsXG4gICAgICBtYXhOdW1Db2xzOiAxLFxuICAgICAgZW52Q2xhc3NlczogW1wiam90XCIsIFwibXVsdGxpbmVcIl0sXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJDRFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIHJldHVybiBwYXJzZUNEKGNvbnRleHQucGFyc2VyKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gQ2F0Y2ggXFxobGluZSBvdXRzaWRlIGFycmF5IGVudmlyb25tZW50XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dFwiLCAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgaXMuXG4gIG5hbWVzOiBbXCJcXFxcaGxpbmVcIiwgXCJcXFxcaGRhc2hsaW5lXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCwgYXJncykge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGAke2NvbnRleHQuZnVuY05hbWV9IHZhbGlkIG9ubHkgd2l0aGluIGFycmF5IGVudmlyb25tZW50YCk7XG4gIH1cbn0pO1xuXG5jb25zdCBlbnZpcm9ubWVudHMgPSBfZW52aXJvbm1lbnRzO1xuXG4vLyBcXGJvcmRlcm1hdHJpeCAgZnJvbSBUZVhib29rIHBwIDE3NyAmIDM2MVxuLy8gT3B0aW9uYWwgYXJndW1lbnQgZnJvbSBIZXJiZXJ0IFZvw58sIE1hdGggbW9kZSwgcCAyMFxuLy8gUmVmOiBodHRwczovL3R1Zy5jdGFuLm9yZy9vYnNvbGV0ZS9pbmZvL21hdGgvdm9zcy9tYXRobW9kZS9NYXRobW9kZS5wZGZcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImJvcmRlcm1hdHJpeFwiLFxuICBuYW1lczogW1wiXFxcXGJvcmRlcm1hdHJpeFwiLCBcIlxcXFxtYXRyaXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzLCBvcHRBcmdzKSA9PiB7XG4gICAgLy8gRmluZCBvdXQgaWYgdGhlIGF1dGhvciBoYXMgZGVmaW5lZCBjdXN0b20gZGVsaW1pdGVyc1xuICAgIGxldCBkZWxpbWl0ZXJzID0gW1wiKFwiLCBcIilcIl07XG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxib3JkZXJtYXRyaXhcIiAmJiBvcHRBcmdzWzBdICYmIG9wdEFyZ3NbMF0uYm9keSkge1xuICAgICAgY29uc3QgYm9keSA9IG9wdEFyZ3NbMF0uYm9keTtcbiAgICAgIGlmIChib2R5Lmxlbmd0aCA9PT0gMiAmJiBib2R5WzBdLnR5cGUgPT09IFwiYXRvbVwiICYmIGJvZHlbMV0udHlwZSA9PT0gXCJhdG9tXCIpIHtcbiAgICAgICAgaWYgKGJvZHlbMF0uZmFtaWx5ID09PSBcIm9wZW5cIiAmJiBib2R5WzFdLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAgICAgZGVsaW1pdGVycyA9IFtib2R5WzBdLnRleHQsIGJvZHlbMV0udGV4dF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc3VtZSB0aGUgb3BlbmluZyBicmFjZVxuICAgIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gICAgcGFyc2VyLmNvbnN1bWUoKTtcblxuICAgIC8vIFBhc3MgY29udHJvbCB0byB0aGUgZW52aXJvbm1lbnQgaGFuZGxlciBpbiBhcnJheS5qcy5cbiAgICBjb25zdCBlbnYgPSBlbnZpcm9ubWVudHNbXCJib3JkZXJtYXRyaXhcIl07XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZW52TmFtZTogZnVuY05hbWUuc2xpY2UoMSksXG4gICAgICBkZWxpbWl0ZXJzLFxuICAgICAgcGFyc2VyXG4gICAgfTtcbiAgICBjb25zdCByZXN1bHQgPSBlbnYuaGFuZGxlcihjb250ZXh0KTtcbiAgICBwYXJzZXIuZXhwZWN0KFwifVwiLCB0cnVlKTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn0pO1xuXG4vLyBcXEBjaGFyIGlzIGFuIGludGVybmFsIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBncm91cGVkIGRlY2ltYWwgYXJndW1lbnQgbGlrZVxuLy8gezEyM30gYW5kIGNvbnZlcnRzIGludG8gc3ltYm9sIHdpdGggY29kZSAxMjMuICBJdCBpcyB1c2VkIGJ5IHRoZSAqbWFjcm8qXG4vLyBcXGNoYXIgZGVmaW5lZCBpbiBtYWNyb3MuanMuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwidGV4dG9yZFwiLFxuICBuYW1lczogW1wiXFxcXEBjaGFyXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCB0b2tlbiB9LCBhcmdzKSB7XG4gICAgY29uc3QgYXJnID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJvcmRncm91cFwiKTtcbiAgICBjb25zdCBncm91cCA9IGFyZy5ib2R5O1xuICAgIGxldCBudW1iZXIgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhc3NlcnROb2RlVHlwZShncm91cFtpXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgbnVtYmVyICs9IG5vZGUudGV4dDtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IHBhcnNlSW50KG51bWJlcik7XG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgXFxcXEBjaGFyIGhhcyBub24tbnVtZXJpYyBhcmd1bWVudCAke251bWJlcn1gLCB0b2tlbilcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICB0ZXh0OiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIEhlbHBlcnNcbmNvbnN0IGh0bWxSZWdFeCA9IC9eKCNbYS1mMC05XXszfXwjP1thLWYwLTldezZ9KSQvaTtcbmNvbnN0IGh0bWxPck5hbWVSZWdFeCA9IC9eKCNbYS1mMC05XXszfXwjP1thLWYwLTldezZ9fFthLXpdKykkL2k7XG5jb25zdCBSR0JyZWdFeCA9IC9eICpcXGR7MSwzfSAqKD86LCAqXFxkezEsM30gKil7Mn0kLztcbmNvbnN0IHJnYlJlZ0V4ID0gL14gKlsxMF0oPzpcXC5cXGQqKT8gKig/OiwgKlsxMF0oPzpcXC5cXGQqKT8gKil7Mn0kLztcbmNvbnN0IHhjb2xvckh0bWxSZWdFeCA9IC9eW2EtZjAtOV17Nn0kL2k7XG5jb25zdCB0b0hleCA9IG51bSA9PiB7XG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoMTYpO1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMSkgeyBzdHIgPSBcIjBcIiArIHN0cjsgfVxuICByZXR1cm4gc3RyXG59O1xuXG4vLyBDb2xvcnMgZnJvbSBUYWJsZXMgNC4xIGFuZCA0LjIgb2YgdGhlIHhjb2xvciBwYWNrYWdlLlxuLy8gVGFibGUgNC4xIChsb3dlciBjYXNlKSBSR0IgdmFsdWVzIGFyZSB0YWtlbiBmcm9tIGNocm9tYSBhbmQgeGNvbG9yLmR0eC5cbi8vIFRhYmxlIDQuMiAoQ2FwaXRhbGl6emVkKSB2YWx1ZXMgd2VyZSBzYW1wbGVkLCBiZWNhdXNlIENocm9tYSBjb250YWlucyBhIHVucmVsaWFibGVcbi8vIGNvbnZlcnNpb24gZnJvbSBjbXlrIHRvIFJHQi4gU2VlIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvNTM3Mjc0LlxuY29uc3QgeGNvbG9ycyA9IEpTT04ucGFyc2UoYHtcbiAgXCJBcHJpY290XCI6IFwiI2ZmYjQ4NFwiLFxuICBcIkFxdWFtYXJpbmVcIjogXCIjMDhiNGJjXCIsXG4gIFwiQml0dGVyc3dlZXRcIjogXCIjYzg0YzE0XCIsXG4gIFwiYmx1ZVwiOiBcIiMwMDAwRkZcIixcbiAgXCJCbHVlXCI6IFwiIzMwMzQ5NFwiLFxuICBcIkJsdWVHcmVlblwiOiBcIiMwOGI0YmNcIixcbiAgXCJCbHVlVmlvbGV0XCI6IFwiIzUwM2M5NFwiLFxuICBcIkJyaWNrUmVkXCI6IFwiI2I4MzQxY1wiLFxuICBcImJyb3duXCI6IFwiI0JGODA0MFwiLFxuICBcIkJyb3duXCI6IFwiIzgwMjQwNFwiLFxuICBcIkJ1cm50T3JhbmdlXCI6IFwiI2Y4OTQxY1wiLFxuICBcIkNhZGV0Qmx1ZVwiOiBcIiM3ODc0OWNcIixcbiAgXCJDYXJuYXRpb25QaW5rXCI6IFwiI2Y4ODRiNFwiLFxuICBcIkNlcnVsZWFuXCI6IFwiIzA4YTRlNFwiLFxuICBcIkNvcm5mbG93ZXJCbHVlXCI6IFwiIzQwYWNlNFwiLFxuICBcImN5YW5cIjogXCIjMDBGRkZGXCIsXG4gIFwiQ3lhblwiOiBcIiMwOGFjZWNcIixcbiAgXCJEYW5kZWxpb25cIjogXCIjZmZiYzQ0XCIsXG4gIFwiZGFya2dyYXlcIjogXCIjNDA0MDQwXCIsXG4gIFwiRGFya09yY2hpZFwiOiBcIiNhODU0OGNcIixcbiAgXCJFbWVyYWxkXCI6IFwiIzA4YWM5Y1wiLFxuICBcIkZvcmVzdEdyZWVuXCI6IFwiIzA4OWM1NFwiLFxuICBcIkZ1Y2hzaWFcIjogXCIjOTAzNDhjXCIsXG4gIFwiR29sZGVucm9kXCI6IFwiI2ZmZGM0NFwiLFxuICBcImdyYXlcIjogXCIjODA4MDgwXCIsXG4gIFwiR3JheVwiOiBcIiM5ODk0OWNcIixcbiAgXCJncmVlblwiOiBcIiMwMEZGMDBcIixcbiAgXCJHcmVlblwiOiBcIiMwOGE0NGNcIixcbiAgXCJHcmVlblllbGxvd1wiOiBcIiNlMGU0NzRcIixcbiAgXCJKdW5nbGVHcmVlblwiOiBcIiMwOGFjOWNcIixcbiAgXCJMYXZlbmRlclwiOiBcIiNmODljYzRcIixcbiAgXCJsaWdodGdyYXlcIjogXCIjYzBjMGMwXCIsXG4gIFwibGltZVwiOiBcIiNCRkZGMDBcIixcbiAgXCJMaW1lR3JlZW5cIjogXCIjOTBjNDNjXCIsXG4gIFwibWFnZW50YVwiOiBcIiNGRjAwRkZcIixcbiAgXCJNYWdlbnRhXCI6IFwiI2YwMDQ4Y1wiLFxuICBcIk1haG9nYW55XCI6IFwiI2IwMzQxY1wiLFxuICBcIk1hcm9vblwiOiBcIiNiMDM0MzRcIixcbiAgXCJNZWxvblwiOiBcIiNmODljN2NcIixcbiAgXCJNaWRuaWdodEJsdWVcIjogXCIjMDg2NDk0XCIsXG4gIFwiTXVsYmVycnlcIjogXCIjYjAzYzk0XCIsXG4gIFwiTmF2eUJsdWVcIjogXCIjMDg2Y2JjXCIsXG4gIFwib2xpdmVcIjogXCIjN0Y3RjAwXCIsXG4gIFwiT2xpdmVHcmVlblwiOiBcIiM0MDdjMzRcIixcbiAgXCJvcmFuZ2VcIjogXCIjRkY4MDAwXCIsXG4gIFwiT3JhbmdlXCI6IFwiI2Y4ODQzY1wiLFxuICBcIk9yYW5nZVJlZFwiOiBcIiNmMDE0NWNcIixcbiAgXCJPcmNoaWRcIjogXCIjYjA3NGFjXCIsXG4gIFwiUGVhY2hcIjogXCIjZjg5NDVjXCIsXG4gIFwiUGVyaXdpbmtsZVwiOiBcIiM4MDc0YmNcIixcbiAgXCJQaW5lR3JlZW5cIjogXCIjMDg4Yzc0XCIsXG4gIFwicGlua1wiOiBcIiNmZjdmN2ZcIixcbiAgXCJQbHVtXCI6IFwiIzk4MjQ4Y1wiLFxuICBcIlByb2Nlc3NCbHVlXCI6IFwiIzA4YjRlY1wiLFxuICBcInB1cnBsZVwiOiBcIiNCRjAwNDBcIixcbiAgXCJQdXJwbGVcIjogXCIjYTA0NDljXCIsXG4gIFwiUmF3U2llbm5hXCI6IFwiIzk4M2MwNFwiLFxuICBcInJlZFwiOiBcIiNmZjAwMDBcIixcbiAgXCJSZWRcIjogXCIjZjAxYzI0XCIsXG4gIFwiUmVkT3JhbmdlXCI6IFwiI2Y4NjQzNFwiLFxuICBcIlJlZFZpb2xldFwiOiBcIiNhMDI0NmNcIixcbiAgXCJSaG9kYW1pbmVcIjogXCIjZjA1NDljXCIsXG4gIFwiUm95YWxsdWVcIjogXCIjMDg3NGJjXCIsXG4gIFwiUm95YWxQdXJwbGVcIjogXCIjNjgzYzljXCIsXG4gIFwiUnViaW5lUmVkXCI6IFwiI2YwMDQ3Y1wiLFxuICBcIlNhbG1vblwiOiBcIiNmODk0OGNcIixcbiAgXCJTZWFHcmVlblwiOiBcIiMzMGJjOWNcIixcbiAgXCJTZXBpYVwiOiBcIiM3MDE0MDRcIixcbiAgXCJTa3lCbHVlXCI6IFwiIzQ4YzRkY1wiLFxuICBcIlNwcmluZ0dyZWVuXCI6IFwiI2M4ZGM2NFwiLFxuICBcIlRhblwiOiBcIiNlMDljNzRcIixcbiAgXCJ0ZWFsXCI6IFwiIzAwN0Y3RlwiLFxuICBcIlRlYWxCbHVlXCI6IFwiIzA4YWNiNFwiLFxuICBcIlRoaXN0bGVcIjogXCIjZDg4NGI0XCIsXG4gIFwiVHVycXVvaXNlXCI6IFwiIzA4YjRjY1wiLFxuICBcInZpb2xldFwiOiBcIiM4MDAwODBcIixcbiAgXCJWaW9sZXRcIjogXCIjNjA0NDljXCIsXG4gIFwiVmlvbGV0UmVkXCI6IFwiI2YwNTRhNFwiLFxuICBcIldpbGRTdHJhd2JlcnJ5XCI6IFwiI2YwMjQ2Y1wiLFxuICBcInllbGxvd1wiOiBcIiNGRkZGMDBcIixcbiAgXCJZZWxsb3dcIjogXCIjZmZmNDA0XCIsXG4gIFwiWWVsbG93R3JlZW5cIjogXCIjOThjYzZjXCIsXG4gIFwiWWVsbG93T3JhbmdlXCI6IFwiI2ZmYTQxY1wiXG59YCk7XG5cbmNvbnN0IGNvbG9yRnJvbVNwZWMgPSAobW9kZWwsIHNwZWMpID0+IHtcbiAgbGV0IGNvbG9yID0gXCJcIjtcbiAgaWYgKG1vZGVsID09PSBcIkhUTUxcIikge1xuICAgIGlmICghaHRtbFJlZ0V4LnRlc3Qoc3BlYykpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBIVE1MIGlucHV0LlwiKVxuICAgIH1cbiAgICBjb2xvciA9IHNwZWM7XG4gIH0gZWxzZSBpZiAobW9kZWwgPT09IFwiUkdCXCIpIHtcbiAgICBpZiAoIVJHQnJlZ0V4LnRlc3Qoc3BlYykpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBSR0IgaW5wdXQuXCIpXG4gICAgfVxuICAgIHNwZWMuc3BsaXQoXCIsXCIpLm1hcChlID0+IHsgY29sb3IgKz0gdG9IZXgoTnVtYmVyKGUudHJpbSgpKSk7IH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICghcmdiUmVnRXgudGVzdChzcGVjKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHJiZyBpbnB1dC5cIilcbiAgICB9XG4gICAgc3BlYy5zcGxpdChcIixcIikubWFwKGUgPT4ge1xuICAgICAgY29uc3QgbnVtID0gTnVtYmVyKGUudHJpbSgpKTtcbiAgICAgIGlmIChudW0gPiAxKSB7IHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ29sb3IgcmdiIGlucHV0IG11c3QgYmUgPCAxLlwiKSB9XG4gICAgICBjb2xvciArPSB0b0hleChOdW1iZXIoKG51bSAqIDI1NSkudG9GaXhlZCgwKSkpO1xuICAgIH0pO1xuICB9XG4gIGlmIChjb2xvci5jaGFyQXQoMCkgIT09IFwiI1wiKSB7IGNvbG9yID0gXCIjXCIgKyBjb2xvcjsgfVxuICByZXR1cm4gY29sb3Jcbn07XG5cbmNvbnN0IHZhbGlkYXRlQ29sb3IgPSAoY29sb3IsIG1hY3JvcywgdG9rZW4pID0+IHtcbiAgY29uc3QgbWFjcm9OYW1lID0gYFxcXFxcXFxcY29sb3JAJHtjb2xvcn1gOyAvLyBmcm9tIFxcZGVmaW5lQ29sb3IuXG4gIGNvbnN0IG1hdGNoID0gaHRtbE9yTmFtZVJlZ0V4LmV4ZWMoY29sb3IpO1xuICBpZiAoIW1hdGNoKSB7IHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBjb2xvcjogJ1wiICsgY29sb3IgKyBcIidcIiwgdG9rZW4pIH1cbiAgLy8gV2UgYWxsb3cgYSA2LWRpZ2l0IEhUTUwgY29sb3Igc3BlYyB3aXRob3V0IGEgbGVhZGluZyBcIiNcIi5cbiAgLy8gVGhpcyBmb2xsb3dzIHRoZSB4Y29sb3IgcGFja2FnZSdzIEhUTUwgY29sb3IgbW9kZWwuXG4gIC8vIFByZWRlZmluZWQgY29sb3IgbmFtZXMgYXJlIGFsbCBtaXNzZWQgYnkgdGhpcyBSZWdFeCBwYXR0ZXJuLlxuICBpZiAoeGNvbG9ySHRtbFJlZ0V4LnRlc3QoY29sb3IpKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgY29sb3JcbiAgfSBlbHNlIGlmIChjb2xvci5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgcmV0dXJuIGNvbG9yXG4gIH0gZWxzZSBpZiAobWFjcm9zLmhhcyhtYWNyb05hbWUpKSB7XG4gICAgY29sb3IgPSBtYWNyb3MuZ2V0KG1hY3JvTmFtZSkudG9rZW5zWzBdLnRleHQ7XG4gIH0gZWxzZSBpZiAoeGNvbG9yc1tjb2xvcl0pIHtcbiAgICBjb2xvciA9IHhjb2xvcnNbY29sb3JdO1xuICB9XG4gIHJldHVybiBjb2xvclxufTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ4ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAvLyBJbiBMYVRlWCwgY29sb3IgaXMgbm90IHN1cHBvc2VkIHRvIGNoYW5nZSB0aGUgc3BhY2luZyBvZiBhbnkgbm9kZS5cbiAgLy8gU28gaW5zdGVhZCBvZiB3cmFwcGluZyB0aGUgZ3JvdXAgaW4gYW4gPG1zdHlsZT4sIHdlIGFwcGx5XG4gIC8vIHRoZSBjb2xvciBpbmRpdmlkdWFsbHkgdG8gZWFjaCBub2RlIGFuZCByZXR1cm4gYSBkb2N1bWVudCBmcmFnbWVudC5cbiAgbGV0IGV4cHIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUud2l0aENvbG9yKGdyb3VwLmNvbG9yKSk7XG4gIGV4cHIgPSBleHByLm1hcChlID0+IHtcbiAgICBlLnN0eWxlLmNvbG9yID0gZ3JvdXAuY29sb3I7XG4gICAgcmV0dXJuIGVcbiAgfSk7XG4gIHJldHVybiBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoZXhwcilcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjb2xvclwiLFxuICBuYW1lczogW1wiXFxcXHRleHRjb2xvclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJyYXdcIiwgXCJvcmlnaW5hbFwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCB0b2tlbiB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBsZXQgY29sb3IgPSBcIlwiO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3Qgc3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICAgIGNvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgc3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gdmFsaWRhdGVDb2xvcihhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmcsIHBhcnNlci5ndWxsZXQubWFjcm9zLCB0b2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbG9yLFxuICAgICAgaXNUZXh0Q29sb3I6IHRydWUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ4XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNvbG9yXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwicmF3XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGJyZWFrT25Ub2tlblRleHQsIHRva2VuIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBtb2RlbCA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGxldCBjb2xvciA9IFwiXCI7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBjb25zdCBzcGVjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgICAgY29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBzcGVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSB2YWxpZGF0ZUNvbG9yKGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZywgcGFyc2VyLmd1bGxldC5tYWNyb3MsIHRva2VuKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHkgdGhhdCBzaG91bGQgYmUgY29sb3JlZC5cbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0LCB0cnVlKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbG9yLFxuICAgICAgaXNUZXh0Q29sb3I6IGZhbHNlLFxuICAgICAgYm9keVxuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ4XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNvbG9yXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGVmaW5lY29sb3JcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMyxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJyYXdcIiwgXCJyYXdcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBuYW1lID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGlmICghL15bQS1aYS16XSskLy50ZXN0KG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNvbG9yIG5hbWUgbXVzdCBiZSBsYXRpbiBsZXR0ZXJzLlwiLCB0b2tlbilcbiAgICB9XG4gICAgY29uc3QgbW9kZWwgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgaWYgKCFbXCJIVE1MXCIsIFwiUkdCXCIsIFwicmdiXCJdLmluY2x1ZGVzKG1vZGVsKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDb2xvciBtb2RlbCBtdXN0IGJlIEhUTUwsIFJHQiwgb3IgcmdiLlwiLCB0b2tlbilcbiAgICB9XG4gICAgY29uc3Qgc3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMl0sIFwicmF3XCIpLnN0cmluZztcbiAgICBjb25zdCBjb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIHNwZWMpO1xuICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChgXFxcXFxcXFxjb2xvckAke25hbWV9YCwgeyB0b2tlbnM6IFt7IHRleHQ6IGNvbG9yIH1dLCBudW1BcmdzOiAwIH0pO1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJuYWxcIiwgbW9kZTogcGFyc2VyLm1vZGUgfVxuICB9XG4gIC8vIE5vIG1hdGhtbEJ1aWxkZXIuIFRoZSBwb2ludCBvZiBcXGRlZmluZWNvbG9yIGlzIHRvIHNldCBhIG1hY3JvLlxufSk7XG5cbi8vIFJvdyBicmVha3Mgd2l0aGluIHRhYnVsYXIgZW52aXJvbm1lbnRzLCBhbmQgbGluZSBicmVha3MgYXQgdG9wIGxldmVsXG5cblxuLy8gXFxEZWNsYXJlUm9idXN0Q29tbWFuZFxcXFx7Li4uXFxAeG5ld2xpbmV9XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY3JcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcblxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBzaXplID0gcGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ID09PSBcIltcIiA/IHBhcnNlci5wYXJzZVNpemVHcm91cCh0cnVlKSA6IG51bGw7XG4gICAgY29uc3QgbmV3TGluZSA9ICFwYXJzZXIuc2V0dGluZ3MuZGlzcGxheU1vZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmV3TGluZSxcbiAgICAgIHNpemU6IHNpemUgJiYgYXNzZXJ0Tm9kZVR5cGUoc2l6ZSwgXCJzaXplXCIpLnZhbHVlXG4gICAgfVxuICB9LFxuXG4gIC8vIFRoZSBmb2xsb3dpbmcgYnVpbGRlciBpcyBjYWxsZWQgb25seSBhdCB0aGUgdG9wIGxldmVsLFxuICAvLyBub3Qgd2l0aGluIHRhYnVsYXIvYXJyYXkgZW52aXJvbm1lbnRzLlxuXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgLy8gTWF0aE1MIDMuMCBjYWxscyBmb3IgbmV3bGluZSB0byBvY2N1ciBpbiBhbiA8bW8+IG9yIGFuIDxtc3BhY2U+LlxuICAgIC8vIFJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL01hdGhNTDMvY2hhcHRlcjMuaHRtbCNwcmVzbS5saW5lYnJlYWtpbmdcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiKTtcbiAgICBpZiAoZ3JvdXAubmV3TGluZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5lYnJlYWtcIiwgXCJuZXdsaW5lXCIpO1xuICAgICAgaWYgKGdyb3VwLnNpemUpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2l6ZSwgc3R5bGUpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBzaXplLm51bWJlciArIHNpemUudW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG5jb25zdCBnbG9iYWxNYXAgPSB7XG4gIFwiXFxcXGdsb2JhbFwiOiBcIlxcXFxnbG9iYWxcIixcbiAgXCJcXFxcbG9uZ1wiOiBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiLFxuICBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiOiBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiLFxuICBcIlxcXFxkZWZcIjogXCJcXFxcZ2RlZlwiLFxuICBcIlxcXFxnZGVmXCI6IFwiXFxcXGdkZWZcIixcbiAgXCJcXFxcZWRlZlwiOiBcIlxcXFx4ZGVmXCIsXG4gIFwiXFxcXHhkZWZcIjogXCJcXFxceGRlZlwiLFxuICBcIlxcXFxsZXRcIjogXCJcXFxcXFxcXGdsb2JhbGxldFwiLFxuICBcIlxcXFxmdXR1cmVsZXRcIjogXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiXG59O1xuXG5jb25zdCBjaGVja0NvbnRyb2xTZXF1ZW5jZSA9ICh0b2spID0+IHtcbiAgY29uc3QgbmFtZSA9IHRvay50ZXh0O1xuICBpZiAoL14oPzpbXFxcXHt9JCYjXl9dfEVPRikkLy50ZXN0KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIGNvbnRyb2wgc2VxdWVuY2VcIiwgdG9rKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn07XG5cbmNvbnN0IGdldFJIUyA9IChwYXJzZXIpID0+IHtcbiAgbGV0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgaWYgKHRvay50ZXh0ID09PSBcIj1cIikge1xuICAgIC8vIGNvbnN1bWUgb3B0aW9uYWwgZXF1YWxzXG4gICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGlmICh0b2sudGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgIC8vIGNvbnN1bWUgb25lIG9wdGlvbmFsIHNwYWNlXG4gICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2s7XG59O1xuXG5jb25zdCBsZXRDb21tYW5kID0gKHBhcnNlciwgbmFtZSwgdG9rLCBnbG9iYWwpID0+IHtcbiAgbGV0IG1hY3JvID0gcGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KHRvay50ZXh0KTtcbiAgaWYgKG1hY3JvID09IG51bGwpIHtcbiAgICAvLyBkb24ndCBleHBhbmQgaXQgbGF0ZXIgZXZlbiBpZiBhIG1hY3JvIHdpdGggdGhlIHNhbWUgbmFtZSBpcyBkZWZpbmVkXG4gICAgLy8gZS5nLiwgXFxsZXRcXGZvbz1cXGZyYWMgXFxkZWZcXGZyYWN7XFxyZWxheH0gXFxmcmFjMTJcbiAgICB0b2subm9leHBhbmQgPSB0cnVlO1xuICAgIG1hY3JvID0ge1xuICAgICAgdG9rZW5zOiBbdG9rXSxcbiAgICAgIG51bUFyZ3M6IDAsXG4gICAgICAvLyByZXByb2R1Y2UgdGhlIHNhbWUgYmVoYXZpb3IgaW4gZXhwYW5zaW9uXG4gICAgICB1bmV4cGFuZGFibGU6ICFwYXJzZXIuZ3VsbGV0LmlzRXhwYW5kYWJsZSh0b2sudGV4dClcbiAgICB9O1xuICB9XG4gIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChuYW1lLCBtYWNybywgZ2xvYmFsKTtcbn07XG5cbi8vIDxhc3NpZ25tZW50PiAtPiA8bm9uLW1hY3JvIGFzc2lnbm1lbnQ+fDxtYWNybyBhc3NpZ25tZW50PlxuLy8gPG5vbi1tYWNybyBhc3NpZ25tZW50PiAtPiA8c2ltcGxlIGFzc2lnbm1lbnQ+fFxcZ2xvYmFsPG5vbi1tYWNybyBhc3NpZ25tZW50PlxuLy8gPG1hY3JvIGFzc2lnbm1lbnQ+IC0+IDxkZWZpbml0aW9uPnw8cHJlZml4PjxtYWNybyBhc3NpZ25tZW50PlxuLy8gPHByZWZpeD4gLT4gXFxnbG9iYWx8XFxsb25nfFxcb3V0ZXJcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGdsb2JhbFwiLFxuICAgIFwiXFxcXGxvbmdcIixcbiAgICBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICBjb25zdCB0b2tlbiA9IHBhcnNlci5mZXRjaCgpO1xuICAgIGlmIChnbG9iYWxNYXBbdG9rZW4udGV4dF0pIHtcbiAgICAgIC8vIFRlbW1sIGRvZXNuJ3QgaGF2ZSBcXHBhciwgc28gaWdub3JlIFxcbG9uZ1xuICAgICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxnbG9iYWxcIiB8fCBmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGdsb2JhbGxvbmdcIikge1xuICAgICAgICB0b2tlbi50ZXh0ID0gZ2xvYmFsTWFwW3Rva2VuLnRleHRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwiaW50ZXJuYWxcIik7XG4gICAgfVxuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIG1hY3JvIHByZWZpeGAsIHRva2VuKTtcbiAgfVxufSk7XG5cbi8vIEJhc2ljIHN1cHBvcnQgZm9yIG1hY3JvIGRlZmluaXRpb25zOiBcXGRlZiwgXFxnZGVmLCBcXGVkZWYsIFxceGRlZlxuLy8gPGRlZmluaXRpb24+IC0+IDxkZWY+PGNvbnRyb2wgc2VxdWVuY2U+PGRlZmluaXRpb24gdGV4dD5cbi8vIDxkZWY+IC0+IFxcZGVmfFxcZ2RlZnxcXGVkZWZ8XFx4ZGVmXG4vLyA8ZGVmaW5pdGlvbiB0ZXh0PiAtPiA8cGFyYW1ldGVyIHRleHQ+PGxlZnQgYnJhY2U+PGJhbGFuY2VkIHRleHQ+PHJpZ2h0IGJyYWNlPlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGVmXCIsIFwiXFxcXGdkZWZcIiwgXCJcXFxcZWRlZlwiLCBcIlxcXFx4ZGVmXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGxldCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgY29uc3QgbmFtZSA9IHRvay50ZXh0O1xuICAgIGlmICgvXig/OltcXFxce30kJiNeX118RU9GKSQvLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgYSBjb250cm9sIHNlcXVlbmNlXCIsIHRvayk7XG4gICAgfVxuXG4gICAgbGV0IG51bUFyZ3MgPSAwO1xuICAgIGxldCBpbnNlcnQ7XG4gICAgY29uc3QgZGVsaW1pdGVycyA9IFtbXV07XG4gICAgLy8gPHBhcmFtZXRlciB0ZXh0PiBjb250YWlucyBubyBicmFjZXNcbiAgICB3aGlsZSAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSBcIntcIikge1xuICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAvLyBJZiB0aGUgdmVyeSBsYXN0IGNoYXJhY3RlciBvZiB0aGUgPHBhcmFtZXRlciB0ZXh0PiBpcyAjLCBzbyB0aGF0XG4gICAgICAgIC8vIHRoaXMgIyBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB7LCBUZVggd2lsbCBiZWhhdmUgYXMgaWYgdGhlIHtcbiAgICAgICAgLy8gaGFkIGJlZW4gaW5zZXJ0ZWQgYXQgdGhlIHJpZ2h0IGVuZCBvZiBib3RoIHRoZSBwYXJhbWV0ZXIgdGV4dFxuICAgICAgICAvLyBhbmQgdGhlIHJlcGxhY2VtZW50IHRleHQuXG4gICAgICAgIGlmIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgPT09IFwie1wiKSB7XG4gICAgICAgICAgaW5zZXJ0ID0gcGFyc2VyLmd1bGxldC5mdXR1cmUoKTtcbiAgICAgICAgICBkZWxpbWl0ZXJzW251bUFyZ3NdLnB1c2goXCJ7XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQSBwYXJhbWV0ZXIsIHRoZSBmaXJzdCBhcHBlYXJhbmNlIG9mICMgbXVzdCBiZSBmb2xsb3dlZCBieSAxLFxuICAgICAgICAvLyB0aGUgbmV4dCBieSAyLCBhbmQgc28gb247IHVwIHRvIG5pbmUgI+KAmXMgYXJlIGFsbG93ZWRcbiAgICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgICAgICBpZiAoIS9eWzEtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIGFyZ3VtZW50IG51bWJlciBcIiR7dG9rLnRleHR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VJbnQodG9rLnRleHQpICE9PSBudW1BcmdzICsgMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBBcmd1bWVudCBudW1iZXIgXCIke3Rvay50ZXh0fVwiIG91dCBvZiBvcmRlcmApO1xuICAgICAgICB9XG4gICAgICAgIG51bUFyZ3MrKztcbiAgICAgICAgZGVsaW1pdGVycy5wdXNoKFtdKTtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIG1hY3JvIGRlZmluaXRpb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxpbWl0ZXJzW251bUFyZ3NdLnB1c2godG9rLnRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXBsYWNlbWVudCB0ZXh0LCBlbmNsb3NlZCBpbiAneycgYW5kICd9JyBhbmQgcHJvcGVybHkgbmVzdGVkXG4gICAgbGV0IHsgdG9rZW5zIH0gPSBwYXJzZXIuZ3VsbGV0LmNvbnN1bWVBcmcoKTtcbiAgICBpZiAoaW5zZXJ0KSB7XG4gICAgICB0b2tlbnMudW5zaGlmdChpbnNlcnQpO1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcZWRlZlwiIHx8IGZ1bmNOYW1lID09PSBcIlxcXFx4ZGVmXCIpIHtcbiAgICAgIHRva2VucyA9IHBhcnNlci5ndWxsZXQuZXhwYW5kVG9rZW5zKHRva2Vucyk7XG4gICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IHBhcnNlci5ndWxsZXQuc2V0dGluZ3MubWF4RXhwYW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVG9vIG1hbnkgZXhwYW5zaW9ucyBpbiBhbiBcIiArIGZ1bmNOYW1lKTtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5yZXZlcnNlKCk7IC8vIHRvIGZpdCBpbiB3aXRoIHN0YWNrIG9yZGVyXG4gICAgfVxuICAgIC8vIEZpbmFsIGFyZyBpcyB0aGUgZXhwYW5zaW9uIG9mIHRoZSBtYWNyb1xuICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcbiAgICAgIG5hbWUsXG4gICAgICB7IHRva2VucywgbnVtQXJncywgZGVsaW1pdGVycyB9LFxuICAgICAgZnVuY05hbWUgPT09IGdsb2JhbE1hcFtmdW5jTmFtZV1cbiAgICApO1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJuYWxcIiwgbW9kZTogcGFyc2VyLm1vZGUgfTtcbiAgfVxufSk7XG5cbi8vIDxzaW1wbGUgYXNzaWdubWVudD4gLT4gPGxldCBhc3NpZ25tZW50PlxuLy8gPGxldCBhc3NpZ25tZW50PiAtPiBcXGZ1dHVyZWxldDxjb250cm9sIHNlcXVlbmNlPjx0b2tlbj48dG9rZW4+XG4vLyAgICAgfCBcXGxldDxjb250cm9sIHNlcXVlbmNlPjxlcXVhbHM+PG9uZSBvcHRpb25hbCBzcGFjZT48dG9rZW4+XG4vLyA8ZXF1YWxzPiAtPiA8b3B0aW9uYWwgc3BhY2VzPnw8b3B0aW9uYWwgc3BhY2VzPj1cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGxldFwiLFxuICAgIFwiXFxcXFxcXFxnbG9iYWxsZXRcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBjb25zdCBuYW1lID0gY2hlY2tDb250cm9sU2VxdWVuY2UocGFyc2VyLmd1bGxldC5wb3BUb2tlbigpKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmNvbnN1bWVTcGFjZXMoKTtcbiAgICBjb25zdCB0b2sgPSBnZXRSSFMocGFyc2VyKTtcbiAgICBsZXRDb21tYW5kKHBhcnNlciwgbmFtZSwgdG9rLCBmdW5jTmFtZSA9PT0gXCJcXFxcXFxcXGdsb2JhbGxldFwiKTtcbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG4gIH1cbn0pO1xuXG4vLyByZWY6IGh0dHBzOi8vd3d3LnR1Zy5vcmcvVFVHYm9hdC90YjA5LTMvdGIyMmJlY2h0b2xzaGVpbS5wZGZcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGZ1dHVyZWxldFwiLFxuICAgIFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBjb25zdCBuYW1lID0gY2hlY2tDb250cm9sU2VxdWVuY2UocGFyc2VyLmd1bGxldC5wb3BUb2tlbigpKTtcbiAgICBjb25zdCBtaWRkbGUgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgY29uc3QgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGxldENvbW1hbmQocGFyc2VyLCBuYW1lLCB0b2ssIGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCIpO1xuICAgIHBhcnNlci5ndWxsZXQucHVzaFRva2VuKHRvayk7XG4gICAgcGFyc2VyLmd1bGxldC5wdXNoVG9rZW4obWlkZGxlKTtcbiAgICByZXR1cm4geyB0eXBlOiBcImludGVybmFsXCIsIG1vZGU6IHBhcnNlci5tb2RlIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxuZXdjb21tYW5kXCIsIFwiXFxcXHJlbmV3Y29tbWFuZFwiLCBcIlxcXFxwcm92aWRlY29tbWFuZFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBsZXQgbmFtZSA9IFwiXCI7XG4gICAgY29uc3QgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIGlmICh0b2sudGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgIG5hbWUgPSBjaGVja0NvbnRyb2xTZXF1ZW5jZShwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCkpO1xuICAgICAgcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gY2hlY2tDb250cm9sU2VxdWVuY2UodG9rKTtcbiAgICB9XG5cbiAgICBjb25zdCBleGlzdHMgPSBwYXJzZXIuZ3VsbGV0LmlzRGVmaW5lZChuYW1lKTtcbiAgICBpZiAoZXhpc3RzICYmIGZ1bmNOYW1lID09PSBcIlxcXFxuZXdjb21tYW5kXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBgXFxcXG5ld2NvbW1hbmR7JHtuYW1lfX0gYXR0ZW1wdGluZyB0byByZWRlZmluZSAke25hbWV9OyB1c2UgXFxcXHJlbmV3Y29tbWFuZGBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghZXhpc3RzICYmIGZ1bmNOYW1lID09PSBcIlxcXFxyZW5ld2NvbW1hbmRcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIGBcXFxccmVuZXdjb21tYW5keyR7bmFtZX19IHdoZW4gY29tbWFuZCAke25hbWV9IGRvZXMgbm90IHlldCBleGlzdDsgdXNlIFxcXFxuZXdjb21tYW5kYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgbnVtQXJncyA9IDA7XG4gICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCA9PT0gXCJbXCIpIHtcbiAgICAgIGxldCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgICBpZiAoIS9eWzAtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzOiBcIiR7dG9rLnRleHR9XCJgKTtcbiAgICAgIH1cbiAgICAgIG51bUFyZ3MgPSBwYXJzZUludCh0b2sudGV4dCk7XG4gICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgICBpZiAodG9rLnRleHQgIT09IFwiXVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIGFyZ3VtZW50IFwiJHt0b2sudGV4dH1cImApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlcGxhY2VtZW50IHRleHQsIGVuY2xvc2VkIGluICd7JyBhbmQgJ30nIGFuZCBwcm9wZXJseSBuZXN0ZWRcbiAgICBjb25zdCB7IHRva2VucyB9ID0gcGFyc2VyLmd1bGxldC5jb25zdW1lQXJnKCk7XG5cbiAgICBpZiAoIShmdW5jTmFtZSA9PT0gXCJcXFxccHJvdmlkZWNvbW1hbmRcIiAmJiBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5oYXMobmFtZSkpKSB7XG4gICAgICAvLyBJZ25vcmUgXFxwcm92aWRlY29tbWFuZFxuICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFxuICAgICAgICBuYW1lLFxuICAgICAgICB7IHRva2VucywgbnVtQXJncyB9XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJuYWxcIiwgbW9kZTogcGFyc2VyLm1vZGUgfTtcblxuICB9XG59KTtcblxuLy8gRXh0cmEgZGF0YSBuZWVkZWQgZm9yIHRoZSBkZWxpbWl0ZXIgaGFuZGxlciBkb3duIGJlbG93XG5jb25zdCBkZWxpbWl0ZXJTaXplcyA9IHtcbiAgXCJcXFxcYmlnbFwiOiB7IG1jbGFzczogXCJtb3BlblwiLCBzaXplOiAxIH0sXG4gIFwiXFxcXEJpZ2xcIjogeyBtY2xhc3M6IFwibW9wZW5cIiwgc2l6ZTogMiB9LFxuICBcIlxcXFxiaWdnbFwiOiB7IG1jbGFzczogXCJtb3BlblwiLCBzaXplOiAzIH0sXG4gIFwiXFxcXEJpZ2dsXCI6IHsgbWNsYXNzOiBcIm1vcGVuXCIsIHNpemU6IDQgfSxcbiAgXCJcXFxcYmlnclwiOiB7IG1jbGFzczogXCJtY2xvc2VcIiwgc2l6ZTogMSB9LFxuICBcIlxcXFxCaWdyXCI6IHsgbWNsYXNzOiBcIm1jbG9zZVwiLCBzaXplOiAyIH0sXG4gIFwiXFxcXGJpZ2dyXCI6IHsgbWNsYXNzOiBcIm1jbG9zZVwiLCBzaXplOiAzIH0sXG4gIFwiXFxcXEJpZ2dyXCI6IHsgbWNsYXNzOiBcIm1jbG9zZVwiLCBzaXplOiA0IH0sXG4gIFwiXFxcXGJpZ21cIjogeyBtY2xhc3M6IFwibXJlbFwiLCBzaXplOiAxIH0sXG4gIFwiXFxcXEJpZ21cIjogeyBtY2xhc3M6IFwibXJlbFwiLCBzaXplOiAyIH0sXG4gIFwiXFxcXGJpZ2dtXCI6IHsgbWNsYXNzOiBcIm1yZWxcIiwgc2l6ZTogMyB9LFxuICBcIlxcXFxCaWdnbVwiOiB7IG1jbGFzczogXCJtcmVsXCIsIHNpemU6IDQgfSxcbiAgXCJcXFxcYmlnXCI6IHsgbWNsYXNzOiBcIm1vcmRcIiwgc2l6ZTogMSB9LFxuICBcIlxcXFxCaWdcIjogeyBtY2xhc3M6IFwibW9yZFwiLCBzaXplOiAyIH0sXG4gIFwiXFxcXGJpZ2dcIjogeyBtY2xhc3M6IFwibW9yZFwiLCBzaXplOiAzIH0sXG4gIFwiXFxcXEJpZ2dcIjogeyBtY2xhc3M6IFwibW9yZFwiLCBzaXplOiA0IH1cbn07XG5cbmNvbnN0IGRlbGltaXRlcnMgPSBbXG4gIFwiKFwiLFxuICBcIlxcXFxscGFyZW5cIixcbiAgXCIpXCIsXG4gIFwiXFxcXHJwYXJlblwiLFxuICBcIltcIixcbiAgXCJcXFxcbGJyYWNrXCIsXG4gIFwiXVwiLFxuICBcIlxcXFxyYnJhY2tcIixcbiAgXCJcXFxce1wiLFxuICBcIlxcXFxsYnJhY2VcIixcbiAgXCJcXFxcfVwiLFxuICBcIlxcXFxyYnJhY2VcIixcbiAgXCLipodcIixcbiAgXCJcXFxcbGxwYXJlbnRoZXNpc1wiLFxuICBcIuKmiFwiLFxuICBcIlxcXFxycnBhcmVudGhlc2lzXCIsXG4gIFwiXFxcXGxmbG9vclwiLFxuICBcIlxcXFxyZmxvb3JcIixcbiAgXCJcXHUyMzBhXCIsXG4gIFwiXFx1MjMwYlwiLFxuICBcIlxcXFxsY2VpbFwiLFxuICBcIlxcXFxyY2VpbFwiLFxuICBcIlxcdTIzMDhcIixcbiAgXCJcXHUyMzA5XCIsXG4gIFwiPFwiLFxuICBcIj5cIixcbiAgXCJcXFxcbGFuZ2xlXCIsXG4gIFwiXFx1MjdlOFwiLFxuICBcIlxcXFxyYW5nbGVcIixcbiAgXCJcXHUyN2U5XCIsXG4gIFwiXFxcXGxBbmdsZVwiLFxuICBcIlxcdTI3ZWFcIixcbiAgXCJcXFxcckFuZ2xlXCIsXG4gIFwiXFx1MjdlYlwiLFxuICBcIlxcXFxsbGFuZ2xlXCIsXG4gIFwi4qaJXCIsXG4gIFwiXFxcXHJyYW5nbGVcIixcbiAgXCLipopcIixcbiAgXCJcXFxcbHRcIixcbiAgXCJcXFxcZ3RcIixcbiAgXCJcXFxcbHZlcnRcIixcbiAgXCJcXFxccnZlcnRcIixcbiAgXCJcXFxcbFZlcnRcIixcbiAgXCJcXFxcclZlcnRcIixcbiAgXCJcXFxcbGdyb3VwXCIsXG4gIFwiXFxcXHJncm91cFwiLFxuICBcIlxcdTI3ZWVcIixcbiAgXCJcXHUyN2VmXCIsXG4gIFwiXFxcXGxtb3VzdGFjaGVcIixcbiAgXCJcXFxccm1vdXN0YWNoZVwiLFxuICBcIlxcdTIzYjBcIixcbiAgXCJcXHUyM2IxXCIsXG4gIFwiXFxcXGxsYnJhY2tldFwiLFxuICBcIlxcXFxycmJyYWNrZXRcIixcbiAgXCJcXHUyN2U2XCIsXG4gIFwiXFx1MjdlNlwiLFxuICBcIlxcXFxsQnJhY2VcIixcbiAgXCJcXFxcckJyYWNlXCIsXG4gIFwiXFx1Mjk4M1wiLFxuICBcIlxcdTI5ODRcIixcbiAgXCIvXCIsXG4gIFwiXFxcXGJhY2tzbGFzaFwiLFxuICBcInxcIixcbiAgXCJcXFxcdmVydFwiLFxuICBcIlxcXFx8XCIsXG4gIFwiXFxcXFZlcnRcIixcbiAgXCJcXHUyMDE2XCIsXG4gIFwiXFxcXHVwYXJyb3dcIixcbiAgXCJcXFxcVXBhcnJvd1wiLFxuICBcIlxcXFxkb3duYXJyb3dcIixcbiAgXCJcXFxcRG93bmFycm93XCIsXG4gIFwiXFxcXHVwZG93bmFycm93XCIsXG4gIFwiXFxcXFVwZG93bmFycm93XCIsXG4gIFwiLlwiXG5dO1xuXG4vLyBFeHBvcnQgaXNEZWxpbWl0ZXIgZm9yIGJlbmVmaXQgb2YgcGFyc2VyLlxuY29uc3QgZGVscyA9IFtcIn1cIiwgXCJcXFxcbGVmdFwiLCBcIlxcXFxtaWRkbGVcIiwgXCJcXFxccmlnaHRcIl07XG5jb25zdCBpc0RlbGltaXRlciA9IHN0ciA9PiBzdHIubGVuZ3RoID4gMCAmJlxuICAoZGVsaW1pdGVycy5pbmNsdWRlcyhzdHIpIHx8IGRlbGltaXRlclNpemVzW3N0cl0gfHwgZGVscy5pbmNsdWRlcyhzdHIpKTtcblxuLy8gTWV0cmljcyBvZiB0aGUgZGlmZmVyZW50IHNpemVzLiBGb3VuZCBieSBsb29raW5nIGF0IFRlWCdzIG91dHB1dCBvZlxuLy8gJFxcYmlnbHwgLy8gXFxCaWdsfCBcXGJpZ2dsfCBcXEJpZ2dsfCBcXHNob3dsaXN0cyRcbi8vIFVzZWQgdG8gY3JlYXRlIHN0YWNrZWQgZGVsaW1pdGVycyBvZiBhcHByb3ByaWF0ZSBzaXplcyBpbiBtYWtlU2l6ZWREZWxpbS5cbmNvbnN0IHNpemVUb01heEhlaWdodCA9IFswLCAxLjIsIDEuOCwgMi40LCAzLjBdO1xuXG4vLyBEZWxpbWl0ZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBjaGVja0RlbGltaXRlcihkZWxpbSwgY29udGV4dCkge1xuICBjb25zdCBzeW1EZWxpbSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoZGVsaW0pO1xuICBpZiAoc3ltRGVsaW0gJiYgZGVsaW1pdGVycy5pbmNsdWRlcyhzeW1EZWxpbS50ZXh0KSkge1xuICAgIC8vIElmIGEgY2hhcmFjdGVyIGlzIG5vdCBpbiB0aGUgTWF0aE1MIG9wZXJhdG9yIGRpY3Rpb25hcnksIGl0IHdpbGwgbm90IHN0cmV0Y2guXG4gICAgLy8gUmVwbGFjZSBzdWNoIGNoYXJhY3RlcnMgdy9jaGFyYWN0ZXJzIHRoYXQgd2lsbCBzdHJldGNoLlxuICAgIGlmIChbXCI8XCIsIFwiXFxcXGx0XCJdLmluY2x1ZGVzKHN5bURlbGltLnRleHQpKSB7IHN5bURlbGltLnRleHQgPSBcIuKfqFwiOyB9XG4gICAgaWYgKFtcIj5cIiwgXCJcXFxcZ3RcIl0uaW5jbHVkZXMoc3ltRGVsaW0udGV4dCkpIHsgc3ltRGVsaW0udGV4dCA9IFwi4p+pXCI7IH1cbiAgICByZXR1cm4gc3ltRGVsaW07XG4gIH0gZWxzZSBpZiAoc3ltRGVsaW0pIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBkZWxpbWl0ZXIgJyR7c3ltRGVsaW0udGV4dH0nIGFmdGVyICcke2NvbnRleHQuZnVuY05hbWV9J2AsIGRlbGltKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBkZWxpbWl0ZXIgdHlwZSAnJHtkZWxpbS50eXBlfSdgLCBkZWxpbSk7XG4gIH1cbn1cblxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgIFxcXG5jb25zdCBuZWVkRXhwbGljaXRTdHJldGNoID0gW1wiXFx1MDAyRlwiLCBcIlxcdTAwNUNcIiwgXCJcXFxcYmFja3NsYXNoXCIsIFwiXFxcXHZlcnRcIiwgXCJ8XCJdO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZGVsaW1zaXppbmdcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxiaWdsXCIsXG4gICAgXCJcXFxcQmlnbFwiLFxuICAgIFwiXFxcXGJpZ2dsXCIsXG4gICAgXCJcXFxcQmlnZ2xcIixcbiAgICBcIlxcXFxiaWdyXCIsXG4gICAgXCJcXFxcQmlnclwiLFxuICAgIFwiXFxcXGJpZ2dyXCIsXG4gICAgXCJcXFxcQmlnZ3JcIixcbiAgICBcIlxcXFxiaWdtXCIsXG4gICAgXCJcXFxcQmlnbVwiLFxuICAgIFwiXFxcXGJpZ2dtXCIsXG4gICAgXCJcXFxcQmlnZ21cIixcbiAgICBcIlxcXFxiaWdcIixcbiAgICBcIlxcXFxCaWdcIixcbiAgICBcIlxcXFxiaWdnXCIsXG4gICAgXCJcXFxcQmlnZ1wiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicHJpbWl0aXZlXCJdXG4gIH0sXG4gIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgc2l6ZTogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0uc2l6ZSxcbiAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgZGVsaW06IGRlbGltLnRleHRcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXApID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLmRlbGltID09PSBcIi5cIikgeyBncm91cC5kZWxpbSA9IFwiXCI7IH1cbiAgICBjaGlsZHJlbi5wdXNoKG1ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKSk7XG5cbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1vcGVuXCIgfHwgZ3JvdXAubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAvLyBPbmx5IHNvbWUgb2YgdGhlIGRlbGltc2l6aW5nIGZ1bmN0aW9ucyBhY3QgYXMgZmVuY2VzLCBhbmQgdGhleVxuICAgICAgLy8gcmV0dXJuIFwibW9wZW5cIiBvciBcIm1jbG9zZVwiIG1jbGFzcy5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFeHBsaWNpdGx5IGRpc2FibGUgZmVuY2luZyBpZiBpdCdzIG5vdCBhIGZlbmNlLCB0byBvdmVycmlkZSB0aGVcbiAgICAgIC8vIGRlZmF1bHRzLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cbiAgICBpZiAobmVlZEV4cGxpY2l0U3RyZXRjaC5pbmNsdWRlcyhncm91cC5kZWxpbSkgfHwgZ3JvdXAuZGVsaW0uaW5kZXhPZihcImFycm93XCIpID4gLTEpIHtcbiAgICAgIC8vIFdlIGhhdmUgdG8gZXhwbGljaXRseSBzZXQgc3RyZXRjaHkgdG8gdHJ1ZS5cbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInN5bW1ldHJpY1wiLCBcInRydWVcIik7IC8vIE5lZWRlZCBmb3IgdGFsbCBhcnJvd3MgaW4gRmlyZWZveC5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1pbnNpemVcIiwgc2l6ZVRvTWF4SGVpZ2h0W2dyb3VwLnNpemVdICsgXCJlbVwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1heHNpemVcIiwgc2l6ZVRvTWF4SGVpZ2h0W2dyb3VwLnNpemVdICsgXCJlbVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGFzc2VydFBhcnNlZChncm91cCkge1xuICBpZiAoIWdyb3VwLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWc6IFRoZSBsZWZ0cmlnaHQgUGFyc2VOb2RlIHdhc24ndCBmdWxseSBwYXJzZWQuXCIpO1xuICB9XG59XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsZWZ0cmlnaHQtcmlnaHRcIixcbiAgbmFtZXM6IFtcIlxcXFxyaWdodFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHQtcmlnaHRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBkZWxpbTogY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCkudGV4dFxuICAgIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gIG5hbWVzOiBbXCJcXFxcbGVmdFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuXG4gICAgY29uc3QgcGFyc2VyID0gY29udGV4dC5wYXJzZXI7XG4gICAgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG4gICAgKytwYXJzZXIubGVmdHJpZ2h0RGVwdGg7XG4gICAgLy8gcGFyc2VFeHByZXNzaW9uIHN0b3BzIGJlZm9yZSAnXFxcXHJpZ2h0JyBvciBgXFxcXG1pZGRsZWBcbiAgICBsZXQgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG51bGwsIHRydWUpO1xuICAgIGxldCBuZXh0VG9rZW4gPSBwYXJzZXIuZmV0Y2goKTtcbiAgICB3aGlsZSAobmV4dFRva2VuLnRleHQgPT09IFwiXFxcXG1pZGRsZVwiKSB7XG4gICAgICAvLyBgXFxtaWRkbGVgLCBmcm9tIHRoZSDOtS1UZVggcGFja2FnZSwgZW5kcyBvbmUgZ3JvdXAgYW5kIHN0YXJ0cyBhbm90aGVyIGdyb3VwLlxuICAgICAgLy8gV2UgaGFkIHRvIHBhcnNlIHRoaXMgZXhwcmVzc2lvbiB3aXRoIGBicmVha09uTWlkZGxlYCBlbmFibGVkIGluIG9yZGVyXG4gICAgICAvLyB0byBnZXQgVGVYLWNvbXBsaWFudCBwYXJzaW5nIG9mIFxcb3Zlci5cbiAgICAgIC8vIEJ1dCB3ZSBkbyBub3Qgd2FudCwgYXQgdGhpcyBwb2ludCwgdG8gZW5kIG9uIFxcbWlkZGxlLCBzbyBjb250aW51ZVxuICAgICAgLy8gdG8gcGFyc2UgdW50aWwgd2UgZmV0Y2ggYSBgXFxyaWdodGAuXG4gICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgY29uc3QgbWlkZGxlID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgICAgIGlmICghc3ltYm9scy5tYXRoW21pZGRsZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgZGVsaW1pdGVyICcke21pZGRsZX0nIGFmdGVyICdcXFxcbWlkZGxlJ2ApO1xuICAgICAgfVxuICAgICAgY2hlY2tEZWxpbWl0ZXIoeyB0eXBlOiBcImF0b21cIiwgbW9kZTogXCJtYXRoXCIsIHRleHQ6IG1pZGRsZSB9LCB7IGZ1bmNOYW1lOiBcIlxcXFxtaWRkbGVcIiB9KTtcbiAgICAgIGJvZHkucHVzaCh7IHR5cGU6IFwibWlkZGxlXCIsIG1vZGU6IFwibWF0aFwiLCBkZWxpbTogbWlkZGxlIH0pO1xuICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgIGJvZHkgPSBib2R5LmNvbmNhdChwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBudWxsLCB0cnVlKSk7XG4gICAgICBuZXh0VG9rZW4gPSBwYXJzZXIuZmV0Y2goKTtcbiAgICB9XG4gICAgLS1wYXJzZXIubGVmdHJpZ2h0RGVwdGg7XG4gICAgLy8gQ2hlY2sgdGhlIG5leHQgdG9rZW5cbiAgICBwYXJzZXIuZXhwZWN0KFwiXFxcXHJpZ2h0XCIsIGZhbHNlKTtcbiAgICBjb25zdCByaWdodCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwibGVmdHJpZ2h0LXJpZ2h0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgbGVmdDogZGVsaW0udGV4dCxcbiAgICAgIHJpZ2h0OiByaWdodC5kZWxpbVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBhc3NlcnRQYXJzZWQoZ3JvdXApO1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlKTtcblxuICAgIGlmIChncm91cC5sZWZ0ID09PSBcIi5cIikgeyBncm91cC5sZWZ0ID0gXCJcIjsgfVxuICAgIGNvbnN0IGxlZnROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAubGVmdCwgZ3JvdXAubW9kZSldKTtcbiAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBcInByZWZpeFwiKTtcbiAgICBpZiAoZ3JvdXAubGVmdCA9PT0gXCIvXCIgfHwgZ3JvdXAubGVmdCA9PT0gXCJcXHUwMDVDXCIgfHwgZ3JvdXAubGVmdC5pbmRleE9mKFwiYXJyb3dcIikgPiAtMSkge1xuICAgICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBpbm5lci51bnNoaWZ0KGxlZnROb2RlKTtcblxuICAgIGlmIChncm91cC5yaWdodCA9PT0gXCIuXCIpIHsgZ3JvdXAucmlnaHQgPSBcIlwiOyB9XG4gICAgY29uc3QgcmlnaHROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAucmlnaHQsIGdyb3VwLm1vZGUpXSk7XG4gICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBcInBvc3RmaXhcIik7XG4gICAgaWYgKGdyb3VwLnJpZ2h0ID09PSBcIlxcdTIyMTZcIiB8fCBncm91cC5yaWdodC5pbmRleE9mKFwiYXJyb3dcIikgPiAtMSkge1xuICAgICAgcmlnaHROb2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBncm91cC5ib2R5W2dyb3VwLmJvZHkubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdEVsZW1lbnQudHlwZSA9PT0gXCJjb2xvclwiICYmICFsYXN0RWxlbWVudC5pc1RleHRDb2xvcikge1xuICAgICAgICAvLyBcXGNvbG9yIGlzIGEgc3dpdGNoLiBJZiB0aGUgbGFzdCBlbGVtZW50IGlzIG9mIHR5cGUgXCJjb2xvclwiIHRoZW5cbiAgICAgICAgLy8gdGhlIHVzZXIgc2V0IHRoZSBcXGNvbG9yIHN3aXRjaCBhbmQgbGVmdCBpdCBvbi5cbiAgICAgICAgLy8gQSBcXHJpZ2h0IGRlbGltaXRlciB0dXJucyB0aGUgc3dpdGNoIG9mZiwgYnV0IHRoZSBkZWxpbWl0ZXIgaXRzZWxmIGdldHMgdGhlIGNvbG9yLlxuICAgICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwibWF0aGNvbG9yXCIsIGxhc3RFbGVtZW50LmNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaW5uZXIucHVzaChyaWdodE5vZGUpO1xuXG4gICAgcmV0dXJuIG1ha2VSb3coaW5uZXIpO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1pZGRsZVwiLFxuICBuYW1lczogW1wiXFxcXG1pZGRsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIGlmICghY29udGV4dC5wYXJzZXIubGVmdHJpZ2h0RGVwdGgpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXG1pZGRsZSB3aXRob3V0IHByZWNlZGluZyBcXFxcbGVmdFwiLCBkZWxpbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWlkZGxlXCIsXG4gICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLFxuICAgICAgZGVsaW06IGRlbGltLnRleHRcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgdGV4dE5vZGUgPSBtYWtlVGV4dChncm91cC5kZWxpbSwgZ3JvdXAubW9kZSk7XG4gICAgY29uc3QgbWlkZGxlTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW3RleHROb2RlXSk7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgaWYgKGdyb3VwLmRlbGltLmluZGV4T2YoXCJhcnJvd1wiKSA+IC0xKSB7XG4gICAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcbiAgICB9XG4gICAgLy8gVGhlIG5leHQgbGluZSBpcyBub3Qgc2VtYW50aWNhbGx5IGNvcnJlY3QsIGJ1dFxuICAgIC8vIENocm9taXVtIGZhaWxzIHRvIHN0cmV0Y2ggaWYgaXQgaXMgbm90IHRoZXJlLlxuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBcInByZWZpeFwiKTtcbiAgICAvLyBNYXRoTUwgZ2l2ZXMgNS8xOGVtIHNwYWNpbmcgdG8gZWFjaCA8bW8+IGVsZW1lbnQuXG4gICAgLy8gXFxtaWRkbGUgc2hvdWxkIGdldCBkZWxpbWl0ZXIgc3BhY2luZyBpbnN0ZWFkLlxuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMC4wNWVtXCIpO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMC4wNWVtXCIpO1xuICAgIHJldHVybiBtaWRkbGVOb2RlO1xuICB9XG59KTtcblxuY29uc3QgcGFkZGluZyA9IF8gPT4ge1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIzcHRcIik7XG4gIHJldHVybiBub2RlXG59O1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJDcgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGxldCBub2RlO1xuICBpZiAoZ3JvdXAubGFiZWwuaW5kZXhPZihcImNvbG9yYm94XCIpID4gLTEgfHwgZ3JvdXAubGFiZWwgPT09IFwiXFxcXGJveGVkXCIpIHtcbiAgICAvLyBNYXRoTUwgY29yZSBkb2VzIG5vdCBzdXBwb3J0ICt3aWR0aCBhdHRyaWJ1dGUgaW4gPG1wYWRkZWQ+LlxuICAgIC8vIEZpcmVmb3ggZG9lcyBub3QgcmVsaWFibHkgYWRkIHNpZGUgcGFkZGluZy5cbiAgICAvLyBJbnNlcnQgPG1zcGFjZT5cbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtcbiAgICAgIHBhZGRpbmcoKSxcbiAgICAgIGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSksXG4gICAgICBwYWRkaW5nKClcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtZW5jbG9zZVwiLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIHN0eWxlKV0pO1xuICB9XG4gIHN3aXRjaCAoZ3JvdXAubGFiZWwpIHtcbiAgICBjYXNlIFwiXFxcXG92ZXJsaW5lXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwidG9wXCIpOyAvLyBmb3IgRmlyZWZveCAmIFdlYktpdFxuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJ0bWwtb3ZlcmxpbmVcIik7ICAgIC8vIGZvciBDaHJvbWl1bVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXHVuZGVybGluZVwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImJvdHRvbVwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLXVuZGVybGluZVwiKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJ1cGRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1widG1sLWNhbmNlbFwiLCBcInVwc3RyaWtlXCJdKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcYmNhbmNlbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImRvd25kaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInRtbC1jYW5jZWxcIiwgXCJkb3duc3RyaWtlXCJdKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcc291dFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImhvcml6b250YWxzdHJpa2VcIik7XG4gICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJ0bWwtY2FuY2VsXCIsIFwic291dFwiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXHhjYW5jZWxcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJ1cGRpYWdvbmFsc3RyaWtlIGRvd25kaWFnb25hbHN0cmlrZVwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLXhjYW5jZWxcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcbG9uZ2RpdlwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImxvbmdkaXZcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcImxvbmdkaXYtdG9wXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1wibG9uZ2Rpdi1hcmNcIl0pKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxwaGFzZVwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInBoYXNvcmFuZ2xlXCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJwaGFzb3ItYm90dG9tXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1wicGhhc29yLWFuZ2xlXCJdKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcdGV4dGNpcmNsZWRcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJjaXJjbGVcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcImNpcmNsZS1wYWRcIik7XG4gICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJ0ZXh0Y2lyY2xlXCJdKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcYW5nbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImFjdHVhcmlhbFwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwiYWN0dWFyaWFsXCIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGJveGVkXCI6XG4gICAgICAvLyBcXG5ld2NvbW1hbmR7XFxib3hlZH1bMV17XFxmYm94e1xcbUB0aCRcXGRpc3BsYXlzdHlsZSMxJH19IGZyb20gYW1zbWF0aC5zdHlcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJib3hcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC1ib3hcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMFwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxmYm94XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYm94XCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJ0bWwtZmJveFwiKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxmY29sb3Jib3hcIjpcbiAgICBjYXNlIFwiXFxcXGNvbG9yYm94XCI6IHtcbiAgICAgIC8vIDxtZW5jbG9zZT4gZG9lc24ndCBoYXZlIGEgZ29vZCBub3RhdGlvbiBvcHRpb24gZm9yIFxcY29sb3Jib3guXG4gICAgICAvLyBTbyB1c2UgPG1wYWRkZWQ+IGluc3RlYWQuIFNldCBzb21lIGF0dHJpYnV0ZXMgdGhhdCBjb21lXG4gICAgICAvLyBpbmNsdWRlZCB3aXRoIDxtZW5jbG9zZT4uXG4gICAgICAvL2NvbnN0IGZib3hzZXAgPSAzOyAvLyAzIHB0IGZyb20gTGFUZVggc291cmNlMmVcbiAgICAgIC8vbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgYCskezIgKiBmYm94c2VwfXB0YClcbiAgICAgIC8vbm9kZS5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIGAke2Zib3hzZXB9cHRgKVxuICAgICAgY29uc3Qgc3R5bGUgPSB7IHBhZGRpbmc6IFwiM3B0IDAgM3B0IDBcIiB9O1xuXG4gICAgICBpZiAoZ3JvdXAubGFiZWwgPT09IFwiXFxcXGZjb2xvcmJveFwiKSB7XG4gICAgICAgIHN0eWxlLmJvcmRlciA9IFwiMC4wNjY3ZW0gc29saWQgXCIgKyBTdHJpbmcoZ3JvdXAuYm9yZGVyQ29sb3IpO1xuICAgICAgfVxuICAgICAgbm9kZS5zdHlsZSA9IHN0eWxlO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgaWYgKGdyb3VwLmJhY2tncm91bmRDb2xvcikge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aGJhY2tncm91bmRcIiwgZ3JvdXAuYmFja2dyb3VuZENvbG9yKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcY29sb3Jib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwicmF3XCIsIFwidGV4dFwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBsZXQgY29sb3IgPSBcIlwiO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3Qgc3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICAgIGNvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgc3BlYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbG9yID0gdmFsaWRhdGVDb2xvcihhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmcsIHBhcnNlci5ndWxsZXQubWFjcm9zKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkN1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcZmNvbG9yYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInJhd1wiLCBcInJhd1wiLCBcInRleHRcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0QXJnc1swXSAmJiBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgbGV0IGJvcmRlckNvbG9yID0gXCJcIjtcbiAgICBsZXQgYmFja2dyb3VuZENvbG9yO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY29uc3QgYm9yZGVyU3BlYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICAgIGNvbnN0IGJhY2tncm91bmRTcGVjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgICAgYm9yZGVyQ29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBib3JkZXJTcGVjKTtcbiAgICAgIGJhY2tncm91bmRDb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIGJhY2tncm91bmRTcGVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9yZGVyQ29sb3IgPSB2YWxpZGF0ZUNvbG9yKGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZywgcGFyc2VyLmd1bGxldC5tYWNyb3MpO1xuICAgICAgYmFja2dyb3VuZENvbG9yID0gdmFsaWRhdGVDb2xvcihhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcInJhd1wiKS5zdHJpbmcsIHBhcnNlci5ndWxsZXQubWFjcm9zKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMl07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJDb2xvcixcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGZib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IFwiXFxcXGZib3hcIixcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxhbmdsXCIsIFwiXFxcXGNhbmNlbFwiLCBcIlxcXFxiY2FuY2VsXCIsIFwiXFxcXHhjYW5jZWxcIiwgXCJcXFxcc291dFwiLCBcIlxcXFxvdmVybGluZVwiLFxuICAgIFwiXFxcXGJveGVkXCIsIFwiXFxcXGxvbmdkaXZcIiwgXCJcXFxccGhhc2VcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFx1bmRlcmxpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcdGV4dGNpcmNsZWRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuXG4vLyBFbnZpcm9ubWVudCBkZWxpbWl0ZXJzLiBIVE1ML01hdGhNTCByZW5kZXJpbmcgaXMgZGVmaW5lZCBpbiB0aGUgY29ycmVzcG9uZGluZ1xuLy8gZGVmaW5lRW52aXJvbm1lbnQgZGVmaW5pdGlvbnMuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW52aXJvbm1lbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxiZWdpblwiLCBcIlxcXFxlbmRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgbmFtZUdyb3VwID0gYXJnc1swXTtcbiAgICBpZiAobmFtZUdyb3VwLnR5cGUgIT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGVudmlyb25tZW50IG5hbWVcIiwgbmFtZUdyb3VwKTtcbiAgICB9XG4gICAgbGV0IGVudk5hbWUgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZUdyb3VwLmJvZHkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGVudk5hbWUgKz0gYXNzZXJ0Tm9kZVR5cGUobmFtZUdyb3VwLmJvZHlbaV0sIFwidGV4dG9yZFwiKS50ZXh0O1xuICAgIH1cblxuICAgIGlmIChmdW5jTmFtZSA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgLy8gYmVnaW4uLi5lbmQgaXMgc2ltaWxhciB0byBsZWZ0Li4ucmlnaHRcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVudmlyb25tZW50cywgZW52TmFtZSApKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTm8gc3VjaCBlbnZpcm9ubWVudDogXCIgKyBlbnZOYW1lLCBuYW1lR3JvdXApO1xuICAgICAgfVxuICAgICAgLy8gQnVpbGQgdGhlIGVudmlyb25tZW50IG9iamVjdC4gQXJndW1lbnRzIGFuZCBvdGhlciBpbmZvcm1hdGlvbiB3aWxsXG4gICAgICAvLyBiZSBtYWRlIGF2YWlsYWJsZSB0byB0aGUgYmVnaW4gYW5kIGVuZCBtZXRob2RzIHVzaW5nIHByb3BlcnRpZXMuXG4gICAgICBjb25zdCBlbnYgPSBlbnZpcm9ubWVudHNbZW52TmFtZV07XG4gICAgICBjb25zdCB7IGFyZ3MsIG9wdEFyZ3MgfSA9IHBhcnNlci5wYXJzZUFyZ3VtZW50cyhcIlxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn1cIiwgZW52KTtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBlbnZOYW1lLFxuICAgICAgICBwYXJzZXJcbiAgICAgIH07XG4gICAgICBjb25zdCByZXN1bHQgPSBlbnYuaGFuZGxlcihjb250ZXh0LCBhcmdzLCBvcHRBcmdzKTtcbiAgICAgIHBhcnNlci5leHBlY3QoXCJcXFxcZW5kXCIsIGZhbHNlKTtcbiAgICAgIGNvbnN0IGVuZE5hbWVUb2tlbiA9IHBhcnNlci5uZXh0VG9rZW47XG4gICAgICBjb25zdCBlbmQgPSBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCBcImVudmlyb25tZW50XCIpO1xuICAgICAgaWYgKGVuZC5uYW1lICE9PSBlbnZOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgIGBNaXNtYXRjaDogXFxcXGJlZ2lueyR7ZW52TmFtZX19IG1hdGNoZWQgYnkgXFxcXGVuZHske2VuZC5uYW1lfX1gLFxuICAgICAgICAgIGVuZE5hbWVUb2tlblxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbnZpcm9ubWVudFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuYW1lOiBlbnZOYW1lLFxuICAgICAgbmFtZUdyb3VwXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbnZUYWdcIixcbiAgbmFtZXM6IFtcIlxcXFxlbnZAdGFnXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW52VGFnXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIik7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibm9UYWdcIixcbiAgbmFtZXM6IFtcIlxcXFxlbnZAbm90YWdcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJub1RhZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIik7XG4gIH1cbn0pO1xuXG5jb25zdCBpc0xvbmdWYXJpYWJsZU5hbWUgPSAoZ3JvdXAsIGZvbnQpID0+IHtcbiAgaWYgKGZvbnQgIT09IFwibWF0aHJtXCIgfHwgZ3JvdXAuYm9keS50eXBlICE9PSBcIm9yZGdyb3VwXCIgfHwgZ3JvdXAuYm9keS5ib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChncm91cC5ib2R5LmJvZHlbMF0udHlwZSAhPT0gXCJtYXRob3JkXCIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBncm91cC5ib2R5LmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJzZU5vZGVUeXBlID0gZ3JvdXAuYm9keS5ib2R5W2ldLnR5cGU7XG4gICAgaWYgKCEocGFyc2VOb2RlVHlwZSA9PT0gIFwibWF0aG9yZFwiIHx8XG4gICAgKHBhcnNlTm9kZVR5cGUgPT09ICBcInRleHRvcmRcIiAmJiAhaXNOYU4oZ3JvdXAuYm9keS5ib2R5W2ldLnRleHQpKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ2ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBjb25zdCBmb250ID0gZ3JvdXAuZm9udDtcbiAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS53aXRoRm9udChmb250KTtcbiAgY29uc3QgbWF0aEdyb3VwID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG5ld1N0eWxlKTtcblxuICBpZiAobWF0aEdyb3VwLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbWF0aEdyb3VwIH0gLy8gZW1wdHkgZ3JvdXAsIGUuZy4sIFxcbWF0aHJte31cbiAgaWYgKGZvbnQgPT09IFwiYm9sZHN5bWJvbFwiICYmIFtcIm1vXCIsIFwibXBhZGRlZFwiLCBcIm1yb3dcIl0uaW5jbHVkZXMobWF0aEdyb3VwLnR5cGUpKSB7XG4gICAgbWF0aEdyb3VwLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICByZXR1cm4gbWF0aEdyb3VwXG4gIH1cbiAgLy8gQ2hlY2sgaWYgaXQgaXMgcG9zc2libGUgdG8gY29uc29saWRhdGUgZWxlbWVudHMgaW50byBhIHNpbmdsZSA8bWk+IGVsZW1lbnQuXG4gIGlmIChpc0xvbmdWYXJpYWJsZU5hbWUoZ3JvdXAsIGZvbnQpKSB7XG4gICAgLy8gVGhpcyBpcyBhIFxcbWF0aHJte+KApn0gZ3JvdXAuIEl0IGdldHMgc3BlY2lhbCB0cmVhdG1lbnQgYmVjYXVzZSBzeW1ib2xzT3JkLmpzXG4gICAgLy8gd3JhcHMgPG1pPiBlbGVtZW50cyB3aXRoIDxtcm93PnMgdG8gd29yayBhcm91bmQgYSBGaXJlZm94IGJ1Zy5cbiAgICBjb25zdCBtaSA9IG1hdGhHcm91cC5jaGlsZHJlblswXS5jaGlsZHJlblswXTtcbiAgICBkZWxldGUgbWkuYXR0cmlidXRlcy5tYXRodmFyaWFudDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1hdGhHcm91cC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWkuY2hpbGRyZW5bMF0udGV4dCArPSBtYXRoR3JvdXAuY2hpbGRyZW5baV0udHlwZSA9PT0gXCJtblwiXG4gICAgICAgID8gbWF0aEdyb3VwLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdLnRleHRcbiAgICAgICAgOiBtYXRoR3JvdXAuY2hpbGRyZW5baV0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0udGV4dDtcbiAgICB9XG4gICAgLy8gV3JhcCBpbiBhIDxtcm93PiB0byBwcmV2ZW50IHRoZSBzYW1lIEZpcmVmb3ggYnVnLlxuICAgIGNvbnN0IGJvZ3VzID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTIwMGJcIikpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2JvZ3VzLCBtaV0pXG4gIH1cbiAgbGV0IGNhbkNvbnNvbGlkYXRlID0gbWF0aEdyb3VwLmNoaWxkcmVuWzBdLnR5cGUgPT09IFwibW9cIjtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRoR3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWF0aEdyb3VwLmNoaWxkcmVuW2ldLnR5cGUgPT09IFwibW9cIiAmJiBmb250ID09PSBcImJvbGRzeW1ib2xcIikge1xuICAgICAgbWF0aEdyb3VwLmNoaWxkcmVuW2ldLnN0eWxlLmZvbnRXZWlnaHQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgaWYgKG1hdGhHcm91cC5jaGlsZHJlbltpXS50eXBlICE9PSBcIm1pXCIpIHsgY2FuQ29uc29saWRhdGUgPSBmYWxzZTsgfVxuICAgIGNvbnN0IGxvY2FsVmFyaWFudCA9IG1hdGhHcm91cC5jaGlsZHJlbltpXS5hdHRyaWJ1dGVzICYmXG4gICAgICBtYXRoR3JvdXAuY2hpbGRyZW5baV0uYXR0cmlidXRlcy5tYXRodmFyaWFudCB8fCBcIlwiO1xuICAgIGlmIChsb2NhbFZhcmlhbnQgIT09IFwibm9ybWFsXCIpIHsgY2FuQ29uc29saWRhdGUgPSBmYWxzZTsgfVxuICB9XG4gIGlmICghY2FuQ29uc29saWRhdGUpIHsgcmV0dXJuIG1hdGhHcm91cCB9XG4gIC8vIENvbnNvbGlkYXRlIHRoZSA8bWk+IGVsZW1lbnRzLlxuICBjb25zdCBtaSA9IG1hdGhHcm91cC5jaGlsZHJlblswXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBtYXRoR3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBtaS5jaGlsZHJlbi5wdXNoKG1hdGhHcm91cC5jaGlsZHJlbltpXS5jaGlsZHJlblswXSk7XG4gIH1cbiAgaWYgKG1pLmF0dHJpYnV0ZXMubWF0aHZhcmlhbnQgJiYgbWkuYXR0cmlidXRlcy5tYXRodmFyaWFudCA9PT0gXCJub3JtYWxcIikge1xuICAgIC8vIFdvcmthcm91bmQgZm9yIGEgRmlyZWZveCBidWcgdGhhdCByZW5kZXJzIHNwdXJpb3VzIHNwYWNlIGFyb3VuZFxuICAgIC8vIGEgPG1pIG1hdGh2YXJpYW50PVwibm9ybWFsXCI+XG4gICAgLy8gUmVmOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5MDk3XG4gICAgLy8gV2UgaW5zZXJ0IGEgdGV4dCBub2RlIHRoYXQgY29udGFpbnMgYSB6ZXJvLXdpZHRoIHNwYWNlIGFuZCB3cmFwIGluIGFuIG1yb3cuXG4gICAgLy8gVE9ETzogR2V0IHJpZCBvZiB0aGlzIDxtaT4gd29ya2Fyb3VuZCB3aGVuIHRoZSBGaXJlZm94IGJ1ZyBpcyBmaXhlZC5cbiAgICBjb25zdCBib2d1cyA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDBiXCIpKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtib2d1cywgbWldKVxuICB9XG4gIHJldHVybiBtaVxufTtcblxuY29uc3QgZm9udEFsaWFzZXMgPSB7XG4gIFwiXFxcXEJiYlwiOiBcIlxcXFxtYXRoYmJcIixcbiAgXCJcXFxcYm9sZFwiOiBcIlxcXFxtYXRoYmZcIixcbiAgXCJcXFxcZnJha1wiOiBcIlxcXFxtYXRoZnJha1wiLFxuICBcIlxcXFxibVwiOiBcIlxcXFxib2xkc3ltYm9sXCJcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJmb250XCIsXG4gIG5hbWVzOiBbXG4gICAgLy8gc3R5bGVzXG4gICAgXCJcXFxcbWF0aHJtXCIsXG4gICAgXCJcXFxcbWF0aGl0XCIsXG4gICAgXCJcXFxcbWF0aGJmXCIsXG4gICAgXCJcXFxcbWF0aG5vcm1hbFwiLFxuICAgIFwiXFxcXHVwQGdyZWVrXCIsXG4gICAgXCJcXFxcYm9sZHN5bWJvbFwiLFxuXG4gICAgLy8gZmFtaWxpZXNcbiAgICBcIlxcXFxtYXRoYmJcIixcbiAgICBcIlxcXFxtYXRoY2FsXCIsXG4gICAgXCJcXFxcbWF0aGZyYWtcIixcbiAgICBcIlxcXFxtYXRoc2NyXCIsXG4gICAgXCJcXFxcbWF0aHNmXCIsXG4gICAgXCJcXFxcbWF0aHNmaXRcIixcbiAgICBcIlxcXFxtYXRodHRcIixcblxuICAgIC8vIGFsaWFzZXNcbiAgICBcIlxcXFxCYmJcIixcbiAgICBcIlxcXFxibVwiLFxuICAgIFwiXFxcXGJvbGRcIixcbiAgICBcIlxcXFxmcmFrXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcbiAgICBsZXQgZnVuYyA9IGZ1bmNOYW1lO1xuICAgIGlmIChmdW5jIGluIGZvbnRBbGlhc2VzKSB7XG4gICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZm9udDogZnVuYy5zbGljZSgxKSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDZcbn0pO1xuXG4vLyBPbGQgZm9udCBjaGFuZ2luZyBmdW5jdGlvbnNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJmb250XCIsXG4gIG5hbWVzOiBbXCJcXFxccm1cIiwgXCJcXFxcc2ZcIiwgXCJcXFxcdHRcIiwgXCJcXFxcYmZcIiwgXCJcXFxcaXRcIiwgXCJcXFxcY2FsXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lLCBicmVha09uVG9rZW5UZXh0IH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCB7IG1vZGUgfSA9IHBhcnNlcjtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0LCB0cnVlKTtcbiAgICBjb25zdCBmb250U3R5bGUgPSBgbWF0aCR7ZnVuY05hbWUuc2xpY2UoMSl9YDtcblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBmb250OiBmb250U3R5bGUsXG4gICAgICBib2R5OiB7XG4gICAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGJvZHlcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDZcbn0pO1xuXG5jb25zdCBzdHlsQXJyYXkgPSBbXCJkaXNwbGF5XCIsIFwidGV4dFwiLCBcInNjcmlwdFwiLCBcInNjcmlwdHNjcmlwdFwiXTtcbmNvbnN0IHNjcmlwdExldmVsID0geyBhdXRvOiAtMSwgZGlzcGxheTogMCwgdGV4dDogMCwgc2NyaXB0OiAxLCBzY3JpcHRzY3JpcHQ6IDIgfTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQ1ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAvLyBUcmFjayB0aGUgc2NyaXB0TGV2ZWwgb2YgdGhlIG51bWVyYXRvciBhbmQgZGVub21pbmF0b3IuXG4gIC8vIFdlIG1heSBuZWVkIHRoYXQgaW5mbyBmb3IgXFxtYXRoY2hvaWNlIG9yIGZvciBhZGp1c3RpbmcgZW0gZGltZW5zaW9ucy5cbiAgY29uc3QgY2hpbGRPcHRpb25zID0gZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwiYXV0b1wiXG4gICAgPyBzdHlsZS5pbmNyZW1lbnRMZXZlbCgpXG4gICAgOiBncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJkaXNwbGF5XCJcbiAgICA/IHN0eWxlLndpdGhMZXZlbChTdHlsZUxldmVsLlRFWFQpXG4gICAgOiBncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJ0ZXh0XCJcbiAgICA/IHN0eWxlLndpdGhMZXZlbChTdHlsZUxldmVsLlNDUklQVClcbiAgICA6IHN0eWxlLndpdGhMZXZlbChTdHlsZUxldmVsLlNDUklQVFNDUklQVCk7XG5cbiAgLy8gQ2hyb21pdW0gKHdyb25nbHkpIGNvbnRpbnVlcyB0byBzaHJpbmsgZnJhY3Rpb25zIGJleW9uZCBzY3JpcHRzY3JpcHRsZXZlbC5cbiAgLy8gU28gd2UgY2hlY2sgZm9yIGxldmVscyB0aGF0IENocm9taXVtIHNocmlua3MgdG9vIHNtYWxsLlxuICAvLyBJZiBuZWNlc3NhcnksIHNldCBhbiBleHBsaWNpdCBmcmFjdGlvbiBkZXB0aC5cbiAgY29uc3QgbnVtZXIgPSBidWlsZEdyb3VwJDEoZ3JvdXAubnVtZXIsIGNoaWxkT3B0aW9ucyk7XG4gIGNvbnN0IGRlbm9tID0gYnVpbGRHcm91cCQxKGdyb3VwLmRlbm9tLCBjaGlsZE9wdGlvbnMpO1xuICBpZiAoc3R5bGUubGV2ZWwgPT09IDMpIHtcbiAgICBudW1lci5zdHlsZS5tYXRoRGVwdGggPSBcIjJcIjtcbiAgICBudW1lci5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjJcIik7XG4gICAgZGVub20uc3R5bGUubWF0aERlcHRoID0gXCIyXCI7XG4gICAgZGVub20uc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIyXCIpO1xuICB9XG5cbiAgbGV0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1mcmFjXCIsIFtudW1lciwgZGVub21dKTtcblxuICBpZiAoIWdyb3VwLmhhc0JhckxpbmUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmV0aGlja25lc3NcIiwgXCIwcHhcIik7XG4gIH0gZWxzZSBpZiAoZ3JvdXAuYmFyU2l6ZSkge1xuICAgIGNvbnN0IHJ1bGVXaWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuYmFyU2l6ZSwgc3R5bGUpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZXRoaWNrbmVzc1wiLCBydWxlV2lkdGgubnVtYmVyICsgcnVsZVdpZHRoLnVuaXQpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmxlZnREZWxpbSAhPSBudWxsIHx8IGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkge1xuICAgIGNvbnN0IHdpdGhEZWxpbXMgPSBbXTtcblxuICAgIGlmIChncm91cC5sZWZ0RGVsaW0gIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGVmdE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbXG4gICAgICAgIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKGdyb3VwLmxlZnREZWxpbS5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSlcbiAgICAgIF0pO1xuICAgICAgbGVmdE9wLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApO1xuICAgIH1cblxuICAgIHdpdGhEZWxpbXMucHVzaChub2RlKTtcblxuICAgIGlmIChncm91cC5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJpZ2h0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtcbiAgICAgICAgbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAucmlnaHREZWxpbS5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSlcbiAgICAgIF0pO1xuICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgICB3aXRoRGVsaW1zLnB1c2gocmlnaHRPcCk7XG4gICAgfVxuXG4gICAgbm9kZSA9IG1ha2VSb3cod2l0aERlbGltcyk7XG4gIH1cblxuICBpZiAoZ3JvdXAuc2NyaXB0TGV2ZWwgIT09IFwiYXV0b1wiKSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIFtub2RlXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgU3RyaW5nKGdyb3VwLnNjcmlwdExldmVsID09PSBcImRpc3BsYXlcIikpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgc2NyaXB0TGV2ZWxbZ3JvdXAuc2NyaXB0TGV2ZWxdKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxkZnJhY1wiLFxuICAgIFwiXFxcXGZyYWNcIixcbiAgICBcIlxcXFx0ZnJhY1wiLFxuICAgIFwiXFxcXGRiaW5vbVwiLFxuICAgIFwiXFxcXGJpbm9tXCIsXG4gICAgXCJcXFxcdGJpbm9tXCIsXG4gICAgXCJcXFxcXFxcXGF0b3BmcmFjXCIsIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICAgIFwiXFxcXFxcXFxicmFjZWZyYWNcIixcbiAgICBcIlxcXFxcXFxcYnJhY2tmcmFjXCIgLy8gZGl0dG9cbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IG51bWVyID0gYXJnc1swXTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbMV07XG4gICAgbGV0IGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICBsZXQgbGVmdERlbGltID0gbnVsbDtcbiAgICBsZXQgcmlnaHREZWxpbSA9IG51bGw7XG4gICAgbGV0IHNjcmlwdExldmVsID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxcXFxcYXRvcGZyYWNcIjpcbiAgICAgICAgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcZGJpbm9tXCI6XG4gICAgICBjYXNlIFwiXFxcXGJpbm9tXCI6XG4gICAgICBjYXNlIFwiXFxcXHRiaW5vbVwiOlxuICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiKVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcXFxcXGJyYWNlZnJhY1wiOlxuICAgICAgICBsZWZ0RGVsaW0gPSBcIlxcXFx7XCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIlxcXFx9XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI6XG4gICAgICAgIGxlZnREZWxpbSA9IFwiW1wiO1xuICAgICAgICByaWdodERlbGltID0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGRmcmFjXCI6XG4gICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICBzY3JpcHRMZXZlbCA9IFwiZGlzcGxheVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgIHNjcmlwdExldmVsID0gXCJ0ZXh0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29udGludWVkOiBmYWxzZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgbGVmdERlbGltLFxuICAgICAgcmlnaHREZWxpbSxcbiAgICAgIHNjcmlwdExldmVsLFxuICAgICAgYmFyU2l6ZTogbnVsbFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcY2ZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbMF07XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzFdO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb250aW51ZWQ6IHRydWUsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgaGFzQmFyTGluZTogdHJ1ZSxcbiAgICAgIGxlZnREZWxpbTogbnVsbCxcbiAgICAgIHJpZ2h0RGVsaW06IG51bGwsXG4gICAgICBzY3JpcHRMZXZlbDogXCJkaXNwbGF5XCIsXG4gICAgICBiYXJTaXplOiBudWxsXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9ucyAtLSB0aGVzZSBhcmUgbm90IHJlbmRlcmVkIGRpcmVjdGx5LCBidXQgcmVwbGFjZWRcbi8vIGltbWVkaWF0ZWx5IGJ5IG9uZSBvZiB0aGUgdmFyaWFudHMgYWJvdmUuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5maXhcIixcbiAgbmFtZXM6IFtcIlxcXFxvdmVyXCIsIFwiXFxcXGNob29zZVwiLCBcIlxcXFxhdG9wXCIsIFwiXFxcXGJyYWNlXCIsIFwiXFxcXGJyYWNrXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgaW5maXg6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0pIHtcbiAgICBsZXQgcmVwbGFjZVdpdGg7XG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxvdmVyXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcZnJhY1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcYmlub21cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGF0b3BcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYXRvcGZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGJyYWNlXCI6XG4gICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcXFxcXGJyYWNlZnJhY1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcYnJhY2tcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2tmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGluZml4IGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW5maXhcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgcmVwbGFjZVdpdGgsXG4gICAgICB0b2tlblxuICAgIH07XG4gIH1cbn0pO1xuXG5jb25zdCBkZWxpbUZyb21WYWx1ZSA9IGZ1bmN0aW9uKGRlbGltU3RyaW5nKSB7XG4gIGxldCBkZWxpbSA9IG51bGw7XG4gIGlmIChkZWxpbVN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgZGVsaW0gPSBkZWxpbVN0cmluZztcbiAgICBkZWxpbSA9IGRlbGltID09PSBcIi5cIiA/IG51bGwgOiBkZWxpbTtcbiAgfVxuICByZXR1cm4gZGVsaW07XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXGdlbmZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogNixcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wibWF0aFwiLCBcIm1hdGhcIiwgXCJzaXplXCIsIFwidGV4dFwiLCBcIm1hdGhcIiwgXCJtYXRoXCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIGNvbnN0IG51bWVyID0gYXJnc1s0XTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbNV07XG5cbiAgICAvLyBMb29rIGludG8gdGhlIHBhcnNlIG5vZGVzIHRvIGdldCB0aGUgZGVzaXJlZCBkZWxpbWl0ZXJzLlxuICAgIGNvbnN0IGxlZnROb2RlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgY29uc3QgbGVmdERlbGltID0gbGVmdE5vZGUudHlwZSA9PT0gXCJhdG9tXCIgJiYgbGVmdE5vZGUuZmFtaWx5ID09PSBcIm9wZW5cIlxuICAgICAgPyBkZWxpbUZyb21WYWx1ZShsZWZ0Tm9kZS50ZXh0KVxuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHJpZ2h0Tm9kZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMV0pO1xuICAgIGNvbnN0IHJpZ2h0RGVsaW0gPVxuICAgICAgcmlnaHROb2RlLnR5cGUgPT09IFwiYXRvbVwiICYmIHJpZ2h0Tm9kZS5mYW1pbHkgPT09IFwiY2xvc2VcIlxuICAgICAgICA/IGRlbGltRnJvbVZhbHVlKHJpZ2h0Tm9kZS50ZXh0KVxuICAgICAgICA6IG51bGw7XG5cbiAgICBjb25zdCBiYXJOb2RlID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1syXSwgXCJzaXplXCIpO1xuICAgIGxldCBoYXNCYXJMaW5lO1xuICAgIGxldCBiYXJTaXplID0gbnVsbDtcbiAgICBpZiAoYmFyTm9kZS5pc0JsYW5rKSB7XG4gICAgICAvLyBcXGdlbmZyYWMgYWN0cyBkaWZmZXJlbnRseSB0aGFuIFxcYWJvdmUuXG4gICAgICAvLyBcXGdlbmZyYWMgdHJlYXRzIGFuIGVtcHR5IHNpemUgZ3JvdXAgYXMgYSBzaWduYWwgdG8gdXNlIGFcbiAgICAgIC8vIHN0YW5kYXJkIGJhciBzaXplLiBcXGFib3ZlIHdvdWxkIHNlZSBzaXplID0gMCBhbmQgb21pdCB0aGUgYmFyLlxuICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhclNpemUgPSBiYXJOb2RlLnZhbHVlO1xuICAgICAgaGFzQmFyTGluZSA9IGJhclNpemUubnVtYmVyID4gMDtcbiAgICB9XG5cbiAgICAvLyBGaW5kIG91dCBpZiB3ZSB3YW50IGRpc3BsYXlzdHlsZSwgdGV4dHN0eWxlLCBldGMuXG4gICAgbGV0IHNjcmlwdExldmVsID0gXCJhdXRvXCI7XG4gICAgbGV0IHN0eWwgPSBhcmdzWzNdO1xuICAgIGlmIChzdHlsLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgaWYgKHN0eWwuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHRleHRPcmQgPSBhc3NlcnROb2RlVHlwZShzdHlsLmJvZHlbMF0sIFwidGV4dG9yZFwiKTtcbiAgICAgICAgc2NyaXB0TGV2ZWwgPSBzdHlsQXJyYXlbTnVtYmVyKHRleHRPcmQudGV4dCldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bCwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgc2NyaXB0TGV2ZWwgPSBzdHlsQXJyYXlbTnVtYmVyKHN0eWwudGV4dCldO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImdlbmZyYWNcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGNvbnRpbnVlZDogZmFsc2UsXG4gICAgICBoYXNCYXJMaW5lLFxuICAgICAgYmFyU2l6ZSxcbiAgICAgIGxlZnREZWxpbSxcbiAgICAgIHJpZ2h0RGVsaW0sXG4gICAgICBzY3JpcHRMZXZlbFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNVxufSk7XG5cbi8vIFxcYWJvdmUgaXMgYW4gaW5maXggZnJhY3Rpb24gdGhhdCBhbHNvIGRlZmluZXMgYSBmcmFjdGlvbiBiYXIgc2l6ZS5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmZpeFwiLFxuICBuYW1lczogW1wiXFxcXGFib3ZlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIl0sXG4gICAgaW5maXg6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aDogXCJcXFxcXFxcXGFib3ZlZnJhY1wiLFxuICAgICAgYmFyU2l6ZTogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlLFxuICAgICAgdG9rZW5cbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcYWJvdmVmcmFjXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDMsXG4gICAgYXJnVHlwZXM6IFtcIm1hdGhcIiwgXCJzaXplXCIsIFwibWF0aFwiXVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBudW1lciA9IGFyZ3NbMF07XG4gICAgY29uc3QgYmFyU2l6ZSA9IGFzc2VydChhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcImluZml4XCIpLmJhclNpemUpO1xuICAgIGNvbnN0IGRlbm9tID0gYXJnc1syXTtcblxuICAgIGNvbnN0IGhhc0JhckxpbmUgPSBiYXJTaXplLm51bWJlciA+IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgY29udGludWVkOiBmYWxzZSxcbiAgICAgIGhhc0JhckxpbmUsXG4gICAgICBiYXJTaXplLFxuICAgICAgbGVmdERlbGltOiBudWxsLFxuICAgICAgcmlnaHREZWxpbTogbnVsbCxcbiAgICAgIHNjcmlwdExldmVsOiBcImF1dG9cIlxuICAgIH07XG4gIH0sXG5cbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTtcblxuLy8gXFxoYm94IGlzIHByb3ZpZGVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggTGFUZVggZnVuY3Rpb25zIHRoYXQgYWN0IG9uIGEgYm94LlxuLy8gVGhpcyBmdW5jdGlvbiBieSBpdHNlbGYgZG9lc24ndCBkbyBhbnl0aGluZyBidXQgc2V0IHNjcmlwdGxldmVsIHRvIFxcdGV4dHN0eWxlXG4vLyBhbmQgcHJldmVudCBhIHNvZnQgbGluZSBicmVhay5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhib3hcIixcbiAgbmFtZXM6IFtcIlxcXFxoYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcImhib3hcIl0sXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGJveFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChhcmdzWzBdKVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS53aXRoTGV2ZWwoU3R5bGVMZXZlbC5URVhUKTtcbiAgICBjb25zdCBtcm93ID0gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG5ld1N0eWxlKTtcbiAgICByZXR1cm4gY29uc29saWRhdGVUZXh0KG1yb3cpXG4gIH1cbn0pO1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJDQgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGFjY2VudE5vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTtcbiAgYWNjZW50Tm9kZS5zdHlsZVtcIm1hdGgtZGVwdGhcIl0gPSAwO1xuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoZ3JvdXAuaXNPdmVyID8gXCJtb3ZlclwiIDogXCJtdW5kZXJcIiwgW1xuICAgIGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBzdHlsZSksXG4gICAgYWNjZW50Tm9kZVxuICBdKTtcbn07XG5cbi8vIEhvcml6b250YWwgc3RyZXRjaHkgYnJhY2VzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaG9yaXpCcmFjZVwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJicmFjZVwiLCBcIlxcXFx1bmRlcmJyYWNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhvcml6QnJhY2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgaXNPdmVyOiAvXlxcXFxvdmVyLy50ZXN0KGZ1bmNOYW1lKSxcbiAgICAgIGJhc2U6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDRcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHJlZlwiLFxuICBuYW1lczogW1wiXFxcXGhyZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1widXJsXCIsIFwib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIHRva2VuIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICBjb25zdCBocmVmID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKFxuICAgICAgIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgICBjb21tYW5kOiBcIlxcXFxocmVmXCIsXG4gICAgICAgIHVybDogaHJlZlxuICAgICAgfSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBGdW5jdGlvbiBcIlxcXFxocmVmXCIgaXMgbm90IHRydXN0ZWRgLCB0b2tlbilcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGhyZWYsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBtYXRoID0gbmV3IE1hdGhOb2RlKFwibWF0aFwiLCBbYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIHN0eWxlKV0pO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBuZXcgQW5jaG9yTm9kZShncm91cC5ocmVmLCBbXSwgW21hdGhdKTtcbiAgICByZXR1cm4gYW5jaG9yTm9kZVxuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFx1cmxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCB0b2tlbiB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgaHJlZiA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmIChcbiAgICAgICFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHtcbiAgICAgICAgY29tbWFuZDogXCJcXFxcdXJsXCIsXG4gICAgICAgIHVybDogaHJlZlxuICAgICAgfSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBGdW5jdGlvbiBcIlxcXFx1cmxcIiBpcyBub3QgdHJ1c3RlZGAsIHRva2VuKVxuICAgIH1cblxuICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBocmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYyA9IGhyZWZbaV07XG4gICAgICBpZiAoYyA9PT0gXCJ+XCIpIHtcbiAgICAgICAgYyA9IFwiXFxcXHRleHRhc2NpaXRpbGRlXCI7XG4gICAgICB9XG4gICAgICBjaGFycy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICB0ZXh0OiBjXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBcIlxcXFx0ZXh0dHRcIixcbiAgICAgIGJvZHk6IGNoYXJzXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGhyZWYsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHRtbFwiLFxuICBuYW1lczogW1wiXFxcXGNsYXNzXCIsIFwiXFxcXGlkXCIsIFwiXFxcXHN0eWxlXCIsIFwiXFxcXGRhdGFcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwib3JpZ2luYWxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG5cbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEZ1bmN0aW9uIFwiJHtmdW5jTmFtZX1cIiBpcyBkaXNhYmxlZCBpbiBzdHJpY3QgbW9kZWAsIHRva2VuKVxuICAgIH1cblxuICAgIGxldCB0cnVzdENvbnRleHQ7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgICAgY2FzZSBcIlxcXFxjbGFzc1wiOlxuICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxjbGFzc1wiLFxuICAgICAgICAgIGNsYXNzOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcaWRcIjpcbiAgICAgICAgYXR0cmlidXRlcy5pZCA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcaWRcIixcbiAgICAgICAgICBpZDogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXHN0eWxlXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXHN0eWxlXCIsXG4gICAgICAgICAgc3R5bGU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxkYXRhXCI6IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHZhbHVlLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5VmFsID0gZGF0YVtpXS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgaWYgKGtleVZhbC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXJyb3IgcGFyc2luZyBrZXktdmFsdWUgZm9yIFxcXFxkYXRhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyaWJ1dGVzW1wiZGF0YS1cIiArIGtleVZhbFswXS50cmltKCldID0ga2V5VmFsWzFdLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxkYXRhXCIsXG4gICAgICAgICAgYXR0cmlidXRlc1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBodG1sIGNvbW1hbmRcIik7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHRydXN0Q29udGV4dCkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBGdW5jdGlvbiBcIiR7ZnVuY05hbWV9XCIgaXMgbm90IHRydXN0ZWRgLCB0b2tlbilcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHRtbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhdHRyaWJ1dGVzLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9ICBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgc3R5bGUpO1xuXG4gICAgY29uc3QgY2xhc3NlcyA9IFtdO1xuICAgIGlmIChncm91cC5hdHRyaWJ1dGVzLmNsYXNzKSB7XG4gICAgICBjbGFzc2VzLnB1c2goLi4uZ3JvdXAuYXR0cmlidXRlcy5jbGFzcy50cmltKCkuc3BsaXQoL1xccysvKSk7XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NlcyA9IGNsYXNzZXM7XG5cbiAgICBmb3IgKGNvbnN0IGF0dHIgaW4gZ3JvdXAuYXR0cmlidXRlcykge1xuICAgICAgaWYgKGF0dHIgIT09IFwiY2xhc3NcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZ3JvdXAuYXR0cmlidXRlcywgYXR0cikpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgZ3JvdXAuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0pO1xuXG5jb25zdCBzaXplRGF0YSA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoL15bLStdPyAqKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspJC8udGVzdChzdHIpKSB7XG4gICAgLy8gc3RyIGlzIGEgbnVtYmVyIHdpdGggbm8gdW5pdCBzcGVjaWZpZWQuXG4gICAgLy8gZGVmYXVsdCB1bml0IGlzIGJwLCBwZXIgZ3JhcGhpeCBwYWNrYWdlLlxuICAgIHJldHVybiB7IG51bWJlcjogK3N0ciwgdW5pdDogXCJicFwiIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXRjaCA9IC8oWy0rXT8pICooXFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSAqKFthLXpdezJ9KS8uZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyBzdHIgKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljc1wiKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG51bWJlcjogKyhtYXRjaFsxXSArIG1hdGNoWzJdKSwgLy8gc2lnbiArIG1hZ25pdHVkZSwgY2FzdCB0byBudW1iZXJcbiAgICAgIHVuaXQ6IG1hdGNoWzNdXG4gICAgfTtcbiAgICBpZiAoIXZhbGlkVW5pdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIGRhdGEudW5pdCArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICBuYW1lczogW1wiXFxcXGluY2x1ZGVncmFwaGljc1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwidXJsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgdG9rZW4gfSwgYXJncywgb3B0QXJncykgPT4ge1xuICAgIGxldCB3aWR0aCA9IHsgbnVtYmVyOiAwLCB1bml0OiBcImVtXCIgfTtcbiAgICBsZXQgaGVpZ2h0ID0geyBudW1iZXI6IDAuOSwgdW5pdDogXCJlbVwiIH07ICAvLyBzb3J0YSBjaGFyYWN0ZXIgc2l6ZWQuXG4gICAgbGV0IHRvdGFsaGVpZ2h0ID0geyBudW1iZXI6IDAsIHVuaXQ6IFwiZW1cIiB9O1xuICAgIGxldCBhbHQgPSBcIlwiO1xuXG4gICAgaWYgKG9wdEFyZ3NbMF0pIHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZVN0ciA9IGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcblxuICAgICAgLy8gUGFyc2VyLmpzIGRvZXMgbm90IHBhcnNlIGtleS92YWx1ZSBwYWlycy4gV2UgZ2V0IGEgc3RyaW5nLlxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZVN0ci5zcGxpdChcIixcIik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5VmFsID0gYXR0cmlidXRlc1tpXS5zcGxpdChcIj1cIik7XG4gICAgICAgIGlmIChrZXlWYWwubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgY29uc3Qgc3RyID0ga2V5VmFsWzFdLnRyaW0oKTtcbiAgICAgICAgICBzd2l0Y2ggKGtleVZhbFswXS50cmltKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJhbHRcIjpcbiAgICAgICAgICAgICAgYWx0ID0gc3RyO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICAgIHdpZHRoID0gc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgXCJoZWlnaHRcIjpcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgXCJ0b3RhbGhlaWdodFwiOlxuICAgICAgICAgICAgICB0b3RhbGhlaWdodCA9IHNpemVEYXRhKHN0cik7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQga2V5OiAnXCIgKyBrZXlWYWxbMF0gKyBcIicgaW4gXFxcXGluY2x1ZGVncmFwaGljcy5cIilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzcmMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoYWx0ID09PSBcIlwiKSB7XG4gICAgICAvLyBObyBhbHQgZ2l2ZW4uIFVzZSB0aGUgZmlsZSBuYW1lLiBTdHJpcCBhd2F5IHRoZSBwYXRoLlxuICAgICAgYWx0ID0gc3JjO1xuICAgICAgYWx0ID0gYWx0LnJlcGxhY2UoL14uKltcXFxcL10vLCBcIlwiKTtcbiAgICAgIGFsdCA9IGFsdC5zdWJzdHJpbmcoMCwgYWx0Lmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgICBjb21tYW5kOiBcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIixcbiAgICAgICAgdXJsOiBzcmNcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCIgaXMgbm90IHRydXN0ZWRgLCB0b2tlbilcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmNsdWRlZ3JhcGhpY3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYWx0OiBhbHQsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHRvdGFsaGVpZ2h0OiB0b3RhbGhlaWdodCxcbiAgICAgIHNyYzogc3JjXG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIHN0eWxlKTtcbiAgICBjb25zdCBkZXB0aCA9IHsgbnVtYmVyOiAwLCB1bml0OiBcImVtXCIgfTtcblxuICAgIGlmIChncm91cC50b3RhbGhlaWdodC5udW1iZXIgPiAwKSB7XG4gICAgICBpZiAoZ3JvdXAudG90YWxoZWlnaHQudW5pdCA9PT0gaGVpZ2h0LnVuaXQgJiZcbiAgICAgICAgZ3JvdXAudG90YWxoZWlnaHQubnVtYmVyID4gaGVpZ2h0Lm51bWJlcikge1xuICAgICAgICBkZXB0aC5udW1iZXIgPSBncm91cC50b3RhbGhlaWdodC5udW1iZXIgLSBoZWlnaHQubnVtYmVyO1xuICAgICAgICBkZXB0aC51bml0ID0gaGVpZ2h0LnVuaXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBpZiAoZ3JvdXAud2lkdGgubnVtYmVyID4gMCkge1xuICAgICAgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBzdHlsZSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3JhcGhpY1N0eWxlID0geyBoZWlnaHQ6IGhlaWdodC5udW1iZXIgKyBkZXB0aC5udW1iZXIgKyBcImVtXCIgfTtcbiAgICBpZiAod2lkdGgubnVtYmVyID4gMCkge1xuICAgICAgZ3JhcGhpY1N0eWxlLndpZHRoID0gd2lkdGgubnVtYmVyICsgd2lkdGgudW5pdDtcbiAgICB9XG4gICAgaWYgKGRlcHRoLm51bWJlciA+IDApIHtcbiAgICAgIGdyYXBoaWNTdHlsZS52ZXJ0aWNhbEFsaWduID0gLWRlcHRoLm51bWJlciArIGRlcHRoLnVuaXQ7XG4gICAgfVxuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBJbWcoZ3JvdXAuc3JjLCBncm91cC5hbHQsIGdyYXBoaWNTdHlsZSk7XG4gICAgbm9kZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgbm9kZS5kZXB0aCA9IGRlcHRoO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtub2RlXSlcbiAgfVxufSk7XG5cbi8vIEhvcml6b250YWwgc3BhY2luZyBjb21tYW5kc1xuXG5cbi8vIFRPRE86IFxcaHNraXAgYW5kIFxcbXNraXAgc2hvdWxkIHN1cHBvcnQgcGx1cyBhbmQgbWludXMgaW4gbGVuZ3Roc1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwia2VyblwiLFxuICBuYW1lczogW1wiXFxcXGtlcm5cIiwgXCJcXFxcbWtlcm5cIiwgXCJcXFxcaHNraXBcIiwgXCJcXFxcbXNraXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBwcmltaXRpdmU6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykge1xuICAgIGNvbnN0IHNpemUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIik7XG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgIGNvbnN0IG1hdGhGdW5jdGlvbiA9IGZ1bmNOYW1lWzFdID09PSBcIm1cIjsgLy8gXFxta2VybiwgXFxtc2tpcFxuICAgICAgY29uc3QgbXVVbml0ID0gc2l6ZS52YWx1ZS51bml0ID09PSBcIm11XCI7XG4gICAgICBpZiAobWF0aEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICghbXVVbml0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYExhVGVYJ3MgJHtmdW5jTmFtZX0gc3VwcG9ydHMgb25seSBtdSB1bml0cywgYCArXG4gICAgICAgICAgICBgbm90ICR7c2l6ZS52YWx1ZS51bml0fSB1bml0c2AsIHRva2VuKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZXIubW9kZSAhPT0gXCJtYXRoXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgTGFUZVgncyAke2Z1bmNOYW1lfSB3b3JrcyBvbmx5IGluIG1hdGggbW9kZWAsIHRva2VuKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAhbWF0aEZ1bmN0aW9uXG4gICAgICAgIGlmIChtdVVuaXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgTGFUZVgncyAke2Z1bmNOYW1lfSBkb2Vzbid0IHN1cHBvcnQgbXUgdW5pdHNgLCB0b2tlbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJrZXJuXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGRpbWVuc2lvbjogc2l6ZS52YWx1ZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgZGltZW5zaW9uID0gY2FsY3VsYXRlU2l6ZShncm91cC5kaW1lbnNpb24sIHN0eWxlKTtcbiAgICBjb25zdCBjaCA9IGRpbWVuc2lvbi51bml0ID09PSBcImVtXCIgPyBzcGFjZUNoYXJhY3RlcihkaW1lbnNpb24ubnVtYmVyKSA6IFwiXCI7XG4gICAgaWYgKGdyb3VwLm1vZGUgPT09IFwidGV4dFwiICYmIGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKGNoKTtcbiAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtjaGFyYWN0ZXJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBkaW1lbnNpb24ubnVtYmVyICsgZGltZW5zaW9uLnVuaXQpO1xuICAgICAgaWYgKGRpbWVuc2lvbi5udW1iZXIgPCAwKSB7XG4gICAgICAgIG5vZGUuc3R5bGUubWFyZ2luTGVmdCA9IGRpbWVuc2lvbi5udW1iZXIgKyBkaW1lbnNpb24udW5pdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxufSk7XG5cbmNvbnN0IHNwYWNlQ2hhcmFjdGVyID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgaWYgKHdpZHRoID49IDAuMDU1NTUgJiYgd2lkdGggPD0gMC4wNTU1Nikge1xuICAgIHJldHVybiBcIlxcdTIwMGFcIjsgLy8gJlZlcnlUaGluU3BhY2U7XG4gIH0gZWxzZSBpZiAod2lkdGggPj0gMC4xNjY2ICYmIHdpZHRoIDw9IDAuMTY2Nykge1xuICAgIHJldHVybiBcIlxcdTIwMDlcIjsgLy8gJlRoaW5TcGFjZTtcbiAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjIyMjIgJiYgd2lkdGggPD0gMC4yMjIzKSB7XG4gICAgcmV0dXJuIFwiXFx1MjAwNVwiOyAvLyAmTWVkaXVtU3BhY2U7XG4gIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yNzc3ICYmIHdpZHRoIDw9IDAuMjc3OCkge1xuICAgIHJldHVybiBcIlxcdTIwMDVcXHUyMDBhXCI7IC8vICZUaGlja1NwYWNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59O1xuXG4vLyBMaW1pdCB2YWxpZCBjaGFyYWN0ZXJzIHRvIGEgc21hbGwgc2V0LCBmb3Igc2FmZXR5LlxuY29uc3QgaW52YWxpZElkUmVnRXggPSAvW15BLVphLXpfMC05LV0vZztcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxhYmVsXCIsXG4gIG5hbWVzOiBbXCJcXFxcbGFiZWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicmF3XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxhYmVsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHN0cmluZzogYXJnc1swXS5zdHJpbmcucmVwbGFjZShpbnZhbGlkSWRSZWdFeCwgXCJcIilcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIFJldHVybiBhIG5vLXdpZHRoLCBuby1pbmsgZWxlbWVudCB3aXRoIGFuIEhUTUwgaWQuXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1widG1sLWxhYmVsXCJdKTtcbiAgICBpZiAoZ3JvdXAuc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgIG5vZGUuc2V0TGFiZWwoZ3JvdXAuc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbi8vIEhvcml6b250YWwgb3ZlcmxhcCBmdW5jdGlvbnNcblxuY29uc3QgdGV4dE1vZGVMYXAgPSBbXCJcXFxcY2xhcFwiLCBcIlxcXFxsbGFwXCIsIFwiXFxcXHJsYXBcIl07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsYXBcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRobGxhcFwiLCBcIlxcXFxtYXRocmxhcFwiLCBcIlxcXFxtYXRoY2xhcFwiLCBcIlxcXFxjbGFwXCIsIFwiXFxcXGxsYXBcIiwgXCJcXFxccmxhcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykgPT4ge1xuICAgIGlmICh0ZXh0TW9kZUxhcC5pbmNsdWRlcyhmdW5jTmFtZSkpIHtcbiAgICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0ICYmIHBhcnNlci5tb2RlICE9PSBcInRleHRcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgeyR7ZnVuY05hbWV9fSBjYW4gYmUgdXNlZCBvbmx5IGluIHRleHQgbW9kZS5cbiBUcnkgXFxcXG1hdGgke2Z1bmNOYW1lLnNsaWNlKDEpfWAsIHRva2VuKVxuICAgICAgfVxuICAgICAgZnVuY05hbWUgPSBmdW5jTmFtZS5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuY05hbWUgPSBmdW5jTmFtZS5zbGljZSg1KTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGFwXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGFsaWdubWVudDogZnVuY05hbWUsXG4gICAgICBib2R5XG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgLy8gbWF0aGxsYXAsIG1hdGhybGFwLCBtYXRoY2xhcFxuICAgIGxldCBzdHJ1dDtcbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ID09PSBcImxsYXBcIikge1xuICAgICAgLy8gV2UgbmVlZCBhbiBpbnZpc2libGUgc3RydXQgd2l0aCB0aGUgc2FtZSBkZXB0aCBhcyB0aGUgZ3JvdXAuXG4gICAgICAvLyBXZSBjYW4ndCBqdXN0IHJlYWQgdGhlIGRlcHRoLCBzbyB3ZSB1c2UgXFx2cGhhbnRvbSBtZXRob2RzLlxuICAgICAgY29uc3QgcGhhbnRvbUlubmVyID0gYnVpbGRFeHByZXNzaW9uKG9yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBzdHlsZSk7XG4gICAgICBjb25zdCBwaGFudG9tID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBwaGFudG9tSW5uZXIpO1xuICAgICAgc3RydXQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICAgIHN0cnV0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGlubmVyID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIHN0eWxlKTtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ID09PSBcImxsYXBcIikge1xuICAgICAgaW5uZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBpbm5lci5zdHlsZS5yaWdodCA9IFwiMFwiO1xuICAgICAgaW5uZXIuc3R5bGUuYm90dG9tID0gYDBgOyAvLyBJZiB3ZSBjb3VsZCBoYXZlIHJlYWQgdGhlIGluayBkZXB0aCwgaXQgd291bGQgZ28gaGVyZS5cbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3N0cnV0LCBpbm5lcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtpbm5lcl0pO1xuICAgIH1cblxuICAgIGlmIChncm91cC5hbGlnbm1lbnQgPT09IFwicmxhcFwiKSB7XG4gICAgICBpZiAoZ3JvdXAuYm9keS5ib2R5Lmxlbmd0aCA+IDAgJiYgZ3JvdXAuYm9keS5ib2R5WzBdLnR5cGUgPT09IFwiZ2VuZnJhY1wiKSB7XG4gICAgICAgIC8vIEluIEZpcmVmb3gsIGEgPG1wYWRkZWQ+IHNxdWFzaGVzIHRoZSAzLzE4ZW0gcGFkZGluZyBvZiBhIGNoaWxkIFxcZnJhYy4gUHV0IGl0IGJhY2suXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMC4xNjY2N2VtXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiID8gXCItMVwiIDogXCItMC41XCI7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBvZmZzZXQgKyBcIndpZHRoXCIpO1xuICAgICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJsbGFwXCIpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICBub2RlLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gXCJjZW50ZXJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gU3dpdGNoaW5nIGZyb20gdGV4dCBtb2RlIGJhY2sgdG8gbWF0aCBtb2RlXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgbmFtZXM6IFtcIlxcXFwoXCIsIFwiJFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcih7IGZ1bmNOYW1lLCBwYXJzZXIgfSwgYXJncykge1xuICAgIGNvbnN0IG91dGVyTW9kZSA9IHBhcnNlci5tb2RlO1xuICAgIHBhcnNlci5zd2l0Y2hNb2RlKFwibWF0aFwiKTtcbiAgICBjb25zdCBjbG9zZSA9IGZ1bmNOYW1lID09PSBcIlxcXFwoXCIgPyBcIlxcXFwpXCIgOiBcIiRcIjtcbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgY2xvc2UpO1xuICAgIHBhcnNlci5leHBlY3QoY2xvc2UpO1xuICAgIHBhcnNlci5zd2l0Y2hNb2RlKG91dGVyTW9kZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBDaGVjayBmb3IgZXh0cmEgY2xvc2luZyBtYXRoIGRlbGltaXRlcnNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0XCIsIC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhpcyBpcy5cbiAgbmFtZXM6IFtcIlxcXFwpXCIsIFwiXFxcXF1cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCwgdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgTWlzbWF0Y2hlZCAke2NvbnRleHQuZnVuY05hbWV9YCwgdG9rZW4pO1xuICB9XG59KTtcblxuY29uc3QgY2hvb3NlU3R5bGUgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIHN3aXRjaCAoc3R5bGUubGV2ZWwpIHtcbiAgICBjYXNlIFN0eWxlTGV2ZWwuRElTUExBWTogICAgICAgLy8gMFxuICAgICAgcmV0dXJuIGdyb3VwLmRpc3BsYXk7XG4gICAgY2FzZSBTdHlsZUxldmVsLlRFWFQ6ICAgICAgICAgIC8vIDFcbiAgICAgIHJldHVybiBncm91cC50ZXh0O1xuICAgIGNhc2UgU3R5bGVMZXZlbC5TQ1JJUFQ6ICAgICAgICAvLyAyXG4gICAgICByZXR1cm4gZ3JvdXAuc2NyaXB0O1xuICAgIGNhc2UgU3R5bGVMZXZlbC5TQ1JJUFRTQ1JJUFQ6ICAvLyAzXG4gICAgICByZXR1cm4gZ3JvdXAuc2NyaXB0c2NyaXB0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ3JvdXAudGV4dDtcbiAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1hdGhjaG9pY2VcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRoY2hvaWNlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDQsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciB9LCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWF0aGNob2ljZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkaXNwbGF5OiBvcmRhcmd1bWVudChhcmdzWzBdKSxcbiAgICAgIHRleHQ6IG9yZGFyZ3VtZW50KGFyZ3NbMV0pLFxuICAgICAgc2NyaXB0OiBvcmRhcmd1bWVudChhcmdzWzJdKSxcbiAgICAgIHNjcmlwdHNjcmlwdDogb3JkYXJndW1lbnQoYXJnc1szXSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGNob29zZVN0eWxlKGdyb3VwLCBzdHlsZSk7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhib2R5LCBzdHlsZSk7XG4gIH1cbn0pO1xuXG5jb25zdCB0ZXh0QXRvbVR5cGVzID0gW1widGV4dFwiLCBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIFwiYXRvbVwiXTtcblxuZnVuY3Rpb24gbWF0aG1sQnVpbGRlciQzKGdyb3VwLCBzdHlsZSkge1xuICBsZXQgbm9kZTtcbiAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUpO1xuXG4gIGlmIChncm91cC5tY2xhc3MgPT09IFwibWlubmVyXCIpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIGlubmVyKTtcbiAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibW9yZFwiKSB7XG4gICAgaWYgKGdyb3VwLmlzQ2hhcmFjdGVyQm94IHx8IGlubmVyWzBdLnR5cGUgPT09IFwibWF0aG9yZFwiKSB7XG4gICAgICBub2RlID0gaW5uZXJbMF07XG4gICAgICBub2RlLnR5cGUgPSBcIm1pXCI7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50ZXh0ICYmIG5vZGUuY2hpbGRyZW5bMF0udGV4dCA9PT0gXCLiiIdcIikge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwibm9ybWFsXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtaVwiLCBpbm5lcik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgaW5uZXIpO1xuICAgIGlmIChncm91cC5tdXN0UHJvbW90ZSkge1xuICAgICAgbm9kZSA9IGlubmVyWzBdO1xuICAgICAgbm9kZS50eXBlID0gXCJtb1wiO1xuICAgICAgaWYgKGdyb3VwLmlzQ2hhcmFjdGVyQm94ICYmIGdyb3VwLmJvZHlbMF0udGV4dCAmJiAvW0EtWmEtel0vLnRlc3QoZ3JvdXAuYm9keVswXS50ZXh0KSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwiaXRhbGljXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcbiAgICB9XG5cbiAgICAvLyBTZXQgc3BhY2luZyBiYXNlZCBvbiB3aGF0IGlzIHRoZSBtb3N0IGxpa2VseSBhZGphY2VudCBhdG9tIHR5cGUuXG4gICAgLy8gU2VlIFRlWGJvb2sgcDE3MC5cbiAgICBjb25zdCBkb1NwYWNpbmcgPSBzdHlsZS5sZXZlbCA8IDI7IC8vIE9wZXJhdG9yIHNwYWNpbmcgaXMgemVybyBpbnNpZGUgYSAoc3VifHN1cGVyKXNjcmlwdC5cbiAgICBpZiAobm9kZS50eXBlID09PSBcIm1yb3dcIikge1xuICAgICAgaWYgKGRvU3BhY2luZyApIHtcbiAgICAgICAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtYmluXCIpIHtcbiAgICAgICAgICAvLyBtZWRpdW0gc3BhY2VcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnVuc2hpZnQocGFkZGluZyQxKDAuMjIyMikpO1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChwYWRkaW5nJDEoMC4yMjIyKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1yZWxcIikge1xuICAgICAgICAgIC8vIHRoaWNrc3BhY2VcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnVuc2hpZnQocGFkZGluZyQxKDAuMjc3OCkpO1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChwYWRkaW5nJDEoMC4yNzc4KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1wdW5jdFwiKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHBhZGRpbmckMSgwLjE2NjcpKTtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibWlubmVyXCIpIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnVuc2hpZnQocGFkZGluZyQxKDAuMDU1NikpOyAgLy8gMSBtdSBpcyB0aGUgbW9zdCBsaWtlbHkgb3B0aW9uXG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHBhZGRpbmckMSgwLjA1NTYpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1iaW5cIikge1xuICAgICAgICAvLyBtZWRpdW0gc3BhY2VcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IChkb1NwYWNpbmcgPyBcIjAuMjIyMmVtXCIgOiBcIjBcIik7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSAoZG9TcGFjaW5nID8gXCIwLjIyMjJlbVwiIDogXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibXJlbFwiKSB7XG4gICAgICAgIC8vIHRoaWNrc3BhY2VcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IChkb1NwYWNpbmcgPyBcIjAuMjc3OGVtXCIgOiBcIjBcIik7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSAoZG9TcGFjaW5nID8gXCIwLjI3NzhlbVwiIDogXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibXB1bmN0XCIpIHtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSAoZG9TcGFjaW5nID8gXCIwLjE2NjdlbVwiIDogXCIwXCIpO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibW9wZW5cIiB8fCBncm91cC5tY2xhc3MgPT09IFwibWNsb3NlXCIpIHtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibWlubmVyXCIgJiYgZG9TcGFjaW5nKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjAuMDU1NmVtXCI7IC8vIDEgbXUgaXMgdGhlIG1vc3QgbGlrZWx5IG9wdGlvblxuICAgICAgICBub2RlLmF0dHJpYnV0ZXMud2lkdGggPSBcIiswLjExMTFlbVwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikpIHtcbiAgICAgIGRlbGV0ZSBub2RlLmF0dHJpYnV0ZXMuc3RyZXRjaHk7XG4gICAgICBkZWxldGUgbm9kZS5hdHRyaWJ1dGVzLmZvcm07XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vLyBNYXRoIGNsYXNzIGNvbW1hbmRzIGV4Y2VwdCBcXG1hdGhvcFxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXG1hdGhvcmRcIixcbiAgICBcIlxcXFxtYXRoYmluXCIsXG4gICAgXCJcXFxcbWF0aHJlbFwiLFxuICAgIFwiXFxcXG1hdGhvcGVuXCIsXG4gICAgXCJcXFxcbWF0aGNsb3NlXCIsXG4gICAgXCJcXFxcbWF0aHB1bmN0XCIsXG4gICAgXCJcXFxcbWF0aGlubmVyXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgY29uc3QgaXNDaGFyYWN0ZXJCb3ggPSB1dGlscy5pc0NoYXJhY3RlckJveChib2R5KTtcbiAgICAvLyBXZSBzaG91bGQgbm90IHdyYXAgYSA8bW8+IGFyb3VuZCBhIDxtaT4gb3IgPG1vcmQ+LiBUaGF0IHdvdWxkIGJlIGludmFsaWQgTWF0aE1MLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgaW5zdGVhZCBwcm9tb3RlIHRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBib2R5IHRvIHRoZSBwYXJlbnQuXG4gICAgbGV0IG11c3RQcm9tb3RlID0gdHJ1ZTtcbiAgICBjb25zdCBtb3JkID0geyB0eXBlOiBcIm1hdGhvcmRcIiwgdGV4dDogXCJcIiwgbW9kZTogcGFyc2VyLm1vZGUgfTtcbiAgICBjb25zdCBhcnIgPSAoYm9keS5ib2R5KSA/IGJvZHkuYm9keSA6IFtib2R5XTtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcnIpIHtcbiAgICAgIGlmICh0ZXh0QXRvbVR5cGVzLmluY2x1ZGVzKGFyZy50eXBlKSkge1xuICAgICAgICBpZiAoc3ltYm9sc1twYXJzZXIubW9kZV1bYXJnLnRleHRdKSB7XG4gICAgICAgICAgbW9yZC50ZXh0ICs9IHN5bWJvbHNbcGFyc2VyLm1vZGVdW2FyZy50ZXh0XS5yZXBsYWNlO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZy50ZXh0KSB7XG4gICAgICAgICAgbW9yZC50ZXh0ICs9IGFyZy50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKGFyZy5ib2R5KSB7XG4gICAgICAgICAgYXJnLmJvZHkubWFwKGUgPT4geyBtb3JkLnRleHQgKz0gZS50ZXh0OyB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVzdFByb21vdGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG11c3RQcm9tb3RlICYmIGZ1bmNOYW1lID09PSBcIlxcXFxtYXRob3JkXCIgJiYgbW9yZC50eXBlID09PSBcIm1hdGhvcmRcIlxuICAgICAgICAgICAgICAgICAgICAmJiBtb3JkLnRleHQubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIG1vcmRcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIG1jbGFzczogXCJtXCIgKyBmdW5jTmFtZS5zbGljZSg1KSxcbiAgICAgICAgYm9keTogb3JkYXJndW1lbnQobXVzdFByb21vdGUgPyBtb3JkIDogYm9keSksXG4gICAgICAgIGlzQ2hhcmFjdGVyQm94LFxuICAgICAgICBtdXN0UHJvbW90ZVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkM1xufSk7XG5cbmNvbnN0IGJpbnJlbENsYXNzID0gKGFyZykgPT4ge1xuICAvLyBcXGJpbnJlbEAgc3BhY2luZyB2YXJpZXMgd2l0aCAoYmlufHJlbHxvcmQpIG9mIHRoZSBhdG9tIGluIHRoZSBhcmd1bWVudC5cbiAgLy8gKGJ5IHJlbmRlcmluZyBzZXBhcmF0ZWx5IGFuZCB3aXRoIHt9cyBiZWZvcmUgYW5kIGFmdGVyLCBhbmQgbWVhc3VyaW5nXG4gIC8vIHRoZSBjaGFuZ2UgaW4gc3BhY2luZykuICBXZSdsbCBkbyByb3VnaGx5IHRoZSBzYW1lIGJ5IGRldGVjdGluZyB0aGVcbiAgLy8gYXRvbSB0eXBlIGRpcmVjdGx5LlxuICBjb25zdCBhdG9tID0gYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIiAmJiBhcmcuYm9keS5sZW5ndGggPyBhcmcuYm9keVswXSA6IGFyZztcbiAgaWYgKGF0b20udHlwZSA9PT0gXCJhdG9tXCIgJiYgKGF0b20uZmFtaWx5ID09PSBcImJpblwiIHx8IGF0b20uZmFtaWx5ID09PSBcInJlbFwiKSkge1xuICAgIHJldHVybiBcIm1cIiArIGF0b20uZmFtaWx5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIm1vcmRcIjtcbiAgfVxufTtcblxuLy8gXFxAYmlucmVse3h9e3l9IHJlbmRlcnMgbGlrZSB5IGJ1dCBhcyBtYmluL21yZWwvbW9yZCBpZiB4IGlzIG1iaW4vbXJlbC9tb3JkLlxuLy8gVGhpcyBpcyBlcXVpdmFsZW50IHRvIFxcYmlucmVsQHt4fVxcYmlucmVsQEB7eX0gaW4gQU1TVGVYLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXEBiaW5yZWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtY2xhc3NcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbWNsYXNzOiBiaW5yZWxDbGFzcyhhcmdzWzBdKSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMV0pLFxuICAgICAgaXNDaGFyYWN0ZXJCb3g6IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGFyZ3NbMV0pXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIEJ1aWxkIGEgcmVsYXRpb24gb3Igc3RhY2tlZCBvcCBieSBwbGFjaW5nIG9uZSBzeW1ib2wgb24gdG9wIG9mIGFub3RoZXJcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtY2xhc3NcIixcbiAgbmFtZXM6IFtcIlxcXFxzdGFja3JlbFwiLCBcIlxcXFxvdmVyc2V0XCIsIFwiXFxcXHVuZGVyc2V0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDJcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJhc2VBcmcgPSBhcmdzWzFdO1xuICAgIGNvbnN0IHNoaWZ0ZWRBcmcgPSBhcmdzWzBdO1xuXG4gICAgY29uc3QgYmFzZU9wID0ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogYmFzZUFyZy5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgc3VwcHJlc3NCYXNlU2hpZnQ6IGZ1bmNOYW1lICE9PSBcIlxcXFxzdGFja3JlbFwiLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYmFzZUFyZylcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICBtb2RlOiBzaGlmdGVkQXJnLm1vZGUsXG4gICAgICBiYXNlOiBiYXNlT3AsXG4gICAgICBzdXA6IGZ1bmNOYW1lID09PSBcIlxcXFx1bmRlcnNldFwiID8gbnVsbCA6IHNoaWZ0ZWRBcmcsXG4gICAgICBzdWI6IGZ1bmNOYW1lID09PSBcIlxcXFx1bmRlcnNldFwiID8gc2hpZnRlZEFyZyA6IG51bGxcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDNcbn0pO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb25cbmNvbnN0IGJ1aWxkR3JvdXAgPSAoZWwsIHN0eWxlLCBub25lTm9kZSkgPT4ge1xuICBpZiAoIWVsKSB7IHJldHVybiBub25lTm9kZSB9XG4gIGNvbnN0IG5vZGUgPSBidWlsZEdyb3VwJDEoZWwsIHN0eWxlKTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJtcm93XCIgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHsgcmV0dXJuIG5vbmVOb2RlIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJtdWx0aXNjcmlwdFwiLFxuICBuYW1lczogW1wiXFxcXHNpZGVzZXRcIiwgXCJcXFxccHJlc0BjcmlwdFwiXSwgLy8gU2VlIG1hY3Jvcy5qcyBmb3IgXFxwcmVzY3JpcHRcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSB7XG4gICAgaWYgKGFyZ3NbMl0uYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGZ1bmNOYW1lICsgYGNhbm5vdCBwYXJzZSBhbiBlbXB0eSBiYXNlLmApXG4gICAgfVxuICAgIGNvbnN0IGJhc2UgPSBhcmdzWzJdLmJvZHlbMF07XG4gICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QgJiYgZnVuY05hbWUgPT09IFwiXFxcXHNpZGVzZXRcIiAmJiAhYmFzZS5zeW1ib2wpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBUaGUgYmFzZSBvZiBcXFxcc2lkZXNldCBtdXN0IGJlIGEgYmlnIG9wZXJhdG9yLiBUcnkgXFxcXHByZXNjcmlwdC5gKVxuICAgIH1cblxuICAgIGlmICgoYXJnc1swXS5ib2R5Lmxlbmd0aCA+IDAgJiYgYXJnc1swXS5ib2R5WzBdLnR5cGUgIT09IFwic3Vwc3ViXCIpIHx8XG4gICAgICAgIChhcmdzWzFdLmJvZHkubGVuZ3RoID4gMCAmJiBhcmdzWzFdLmJvZHlbMF0udHlwZSAhPT0gXCJzdXBzdWJcIikpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXHNpZGVzZXQgY2FuIHBhcnNlIG9ubHkgc3Vic2NyaXB0cyBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3VwZXJzY3JpcHRzIGluIGl0cyBmaXJzdCB0d28gYXJndW1lbnRzXCIsIHRva2VuKVxuICAgIH1cblxuICAgIC8vIFRoZSBwcmVzY3JpcHRzIGFuZCBwb3N0c2NyaXB0cyBjb21lIHdyYXBwZWQgaW4gYSBzdXBzdWIuXG4gICAgY29uc3QgcHJlc2NyaXB0cyA9IGFyZ3NbMF0uYm9keS5sZW5ndGggPiAwID8gYXJnc1swXS5ib2R5WzBdIDogbnVsbDtcbiAgICBjb25zdCBwb3N0c2NyaXB0cyA9IGFyZ3NbMV0uYm9keS5sZW5ndGggPiAwID8gYXJnc1sxXS5ib2R5WzBdIDogbnVsbDtcblxuICAgIGlmICghcHJlc2NyaXB0cyAmJiAhcG9zdHNjcmlwdHMpIHtcbiAgICAgIHJldHVybiBiYXNlXG4gICAgfSBlbHNlIGlmICghcHJlc2NyaXB0cykge1xuICAgICAgLy8gSXQncyBub3QgYSBtdWx0aS1zY3JpcHQuIEdldCBhIFxcdGV4dHN0eWxlIHN1cHN1Yi5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiLFxuICAgICAgICBib2R5OiBbe1xuICAgICAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgICAgYmFzZSxcbiAgICAgICAgICBzdXA6IHBvc3RzY3JpcHRzLnN1cCxcbiAgICAgICAgICBzdWI6IHBvc3RzY3JpcHRzLnN1YlxuICAgICAgICB9XVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm11bHRpc2NyaXB0XCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBpc1NpZGVzZXQ6IGZ1bmNOYW1lID09PSBcIlxcXFxzaWRlc2V0XCIsXG4gICAgICAgIHByZXNjcmlwdHMsXG4gICAgICAgIHBvc3RzY3JpcHRzLFxuICAgICAgICBiYXNlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IGJhc2UgPSAgYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UsIHN0eWxlKTtcblxuICAgIGNvbnN0IHByZXNjcmlwdHNOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcHJlc2NyaXB0c1wiKTtcbiAgICBjb25zdCBub25lTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibm9uZVwiKTtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXTtcblxuICAgIGNvbnN0IHByZVN1YiA9IGJ1aWxkR3JvdXAoZ3JvdXAucHJlc2NyaXB0cy5zdWIsIHN0eWxlLCBub25lTm9kZSk7XG4gICAgY29uc3QgcHJlU3VwID0gYnVpbGRHcm91cChncm91cC5wcmVzY3JpcHRzLnN1cCwgc3R5bGUsIG5vbmVOb2RlKTtcbiAgICBpZiAoZ3JvdXAuaXNTaWRlc2V0KSB7XG4gICAgICAvLyBUaGlzIHNlZW1zIHNpbGx5LCBidXQgTGFUZVggZG9lcyB0aGlzLiBGaXJlZm94IGlnbm9yZXMgaXQsIHdoaWNoIGRvZXMgbm90IG1ha2UgbWUgc2FkLlxuICAgICAgcHJlU3ViLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwidGV4dC1hbGlnbjogbGVmdDtcIik7XG4gICAgICBwcmVTdXAuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ0ZXh0LWFsaWduOiBsZWZ0O1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAucG9zdHNjcmlwdHMpIHtcbiAgICAgIGNvbnN0IHBvc3RTdWIgPSBidWlsZEdyb3VwKGdyb3VwLnBvc3RzY3JpcHRzLnN1Yiwgc3R5bGUsIG5vbmVOb2RlKTtcbiAgICAgIGNvbnN0IHBvc3RTdXAgPSBidWlsZEdyb3VwKGdyb3VwLnBvc3RzY3JpcHRzLnN1cCwgc3R5bGUsIG5vbmVOb2RlKTtcbiAgICAgIGNoaWxkcmVuID0gW2Jhc2UsIHBvc3RTdWIsIHBvc3RTdXAsIHByZXNjcmlwdHNOb2RlLCBwcmVTdWIsIHByZVN1cF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuID0gW2Jhc2UsIHByZXNjcmlwdHNOb2RlLCBwcmVTdWIsIHByZVN1cF07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW11bHRpc2NyaXB0c1wiLCBjaGlsZHJlbik7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibm90XCIsXG4gIG5hbWVzOiBbXCJcXFxcbm90XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIGNvbnN0IGlzQ2hhcmFjdGVyQm94ID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYXJnc1swXSk7XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKGlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICBib2R5ID0gb3JkYXJndW1lbnQoYXJnc1swXSk7XG4gICAgICBpZiAoYm9keVswXS50ZXh0LmNoYXJBdCgwKSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgYm9keVswXS50ZXh0ID0gc3ltYm9scy5tYXRoW2JvZHlbMF0udGV4dF0ucmVwbGFjZTtcbiAgICAgIH1cbiAgICAgIC8vIFxcdTAzMzggaXMgdGhlIFVuaWNvZGUgQ29tYmluaW5nIExvbmcgU29saWR1cyBPdmVybGF5XG4gICAgICBib2R5WzBdLnRleHQgPSBib2R5WzBdLnRleHQuc2xpY2UoMCwgMSkgKyBcIlxcdTAzMzhcIiArIGJvZHlbMF0udGV4dC5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2hlbiB0aGUgYXJndW1lbnQgaXMgbm90IGEgY2hhcmFjdGVyIGJveCwgVGVYIGRvZXMgYW4gYXdrd2FyZCwgcG9vcmx5IHBsYWNlZCBvdmVybGF5LlxuICAgICAgLy8gV2UnbGwgZG8gdGhlIHNhbWUuXG4gICAgICBjb25zdCBub3ROb2RlID0geyB0eXBlOiBcInRleHRvcmRcIiwgbW9kZTogXCJtYXRoXCIsIHRleHQ6IFwiXFx1MDMzOFwiIH07XG4gICAgICBjb25zdCBrZXJuTm9kZSA9IHsgdHlwZTogXCJrZXJuXCIsIG1vZGU6IFwibWF0aFwiLCBkaW1lbnNpb246IHsgbnVtYmVyOiAtMC42LCB1bml0OiBcImVtXCIgfSB9O1xuICAgICAgYm9keSA9IFtub3ROb2RlLCBrZXJuTm9kZSwgYXJnc1swXV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm5vdFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgaXNDaGFyYWN0ZXJCb3hcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGlmIChncm91cC5pc0NoYXJhY3RlckJveCkge1xuICAgICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUsIHRydWUpO1xuICAgICAgcmV0dXJuIGlubmVyWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgc3R5bGUpXG4gICAgfVxuICB9XG59KTtcblxuLy8gTGltaXRzLCBzeW1ib2xzXG5cbi8vIFNvbWUgaGVscGVyc1xuXG5jb25zdCBvcmRBdG9tVHlwZXMgPSBbXCJ0ZXh0b3JkXCIsIFwibWF0aG9yZFwiLCBcImF0b21cIl07XG5cbi8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG5jb25zdCBub1N1Y2Nlc3NvciA9IFtcIlxcXFxzbWFsbGludFwiXTtcblxuLy8gTWF0aCBvcGVyYXRvcnMgKGUuZy4gXFxzaW4pIG5lZWQgYSBzcGFjZSBiZXR3ZWVuIHRoZXNlIHR5cGVzIGFuZCB0aGVtc2VsdmVzOlxuY29uc3Qgb3JkVHlwZXMgPSBbXCJ0ZXh0b3JkXCIsIFwibWF0aG9yZFwiLCBcIm9yZGdyb3VwXCIsIFwiY2xvc2VcIiwgXCJsZWZ0cmlnaHRcIiwgXCJmb250XCJdO1xuXG4vLyBOT1RFOiBVbmxpa2UgbW9zdCBgYnVpbGRlcnNgcywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seSBcIm9wXCIsIGJ1dCBhbHNvXG4vLyBcInN1cHN1YlwiIHNpbmNlIHNvbWUgb2YgdGhlbSAobGlrZSBcXGludCkgY2FuIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG5cbmNvbnN0IHNldFNwYWNpbmcgPSBub2RlID0+IHtcbiAgLy8gVGhlIHVzZXIgd3JvdGUgYSBcXG1hdGhvcHvigKZ9IGZ1bmN0aW9uLiBDaGFuZ2Ugc3BhY2luZyBmcm9tIGRlZmF1bHQgdG8gT1Agc3BhY2luZy5cbiAgLy8gVGhlIG1vc3QgbGlrZWx5IHNwYWNpbmcgZm9yIGFuIE9QIGlzIGEgdGhpbiBzcGFjZSBwZXIgVGVYYm9vayBwMTcwLlxuICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwLjE2NjdlbVwiO1xuICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwLjE2NjdlbVwiO1xufTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciQyID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBsZXQgbm9kZTtcblxuICBpZiAoZ3JvdXAuc3ltYm9sKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bWJvbC4gSnVzdCBhZGQgdGhlIHN5bWJvbC5cbiAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLm5hbWUsIGdyb3VwLm1vZGUpXSk7XG4gICAgaWYgKG5vU3VjY2Vzc29yLmluY2x1ZGVzKGdyb3VwLm5hbWUpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxhcmdlb3BcIiwgXCJmYWxzZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtb3ZhYmxlbGltaXRzXCIsIFwiZmFsc2VcIik7XG4gICAgfVxuICAgIGlmIChncm91cC5mcm9tTWF0aE9wKSB7IHNldFNwYWNpbmcobm9kZSk7IH1cbiAgfSBlbHNlIGlmIChncm91cC5ib2R5KSB7XG4gICAgLy8gVGhpcyBpcyBhbiBvcGVyYXRvciB3aXRoIGNoaWxkcmVuLiBBZGQgdGhlbS5cbiAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibW9cIiwgYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlKSk7XG4gICAgaWYgKGdyb3VwLmZyb21NYXRoT3ApIHsgc2V0U3BhY2luZyhub2RlKTsgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBBZGQgYWxsIG9mIHRoZSBjaGFyYWN0ZXJzIGZyb20gdGhlIG9wZXJhdG9yJ3MgbmFtZS5cbiAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibWlcIiwgW25ldyBUZXh0Tm9kZShncm91cC5uYW1lLnNsaWNlKDEpKV0pO1xuXG4gICAgaWYgKCFncm91cC5wYXJlbnRJc1N1cFN1Yikge1xuICAgICAgLy8gQXBwZW5kIGFuIGludmlzaWJsZSA8bW8+JkFwcGx5RnVuY3Rpb247PC9tbz4uXG4gICAgICAvLyByZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMtTWF0aE1ML2NoYXAzXzIuaHRtbCNzZWMzLjIuNFxuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuICAgICAgY29uc3Qgcm93ID0gW25vZGUsIG9wZXJhdG9yXTtcbiAgICAgIC8vIFNldCBzcGFjaW5nXG4gICAgICBpZiAoZ3JvdXAubmVlZHNMZWFkaW5nU3BhY2UpIHtcbiAgICAgICAgY29uc3QgbGVhZCA9IG5ldyBNYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgICAgbGVhZC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgICByb3cudW5zaGlmdChsZWFkKTtcbiAgICAgIH1cbiAgICAgIGlmICghZ3JvdXAuaXNGb2xsb3dlZEJ5RGVsaW1pdGVyKSB7XG4gICAgICAgIGNvbnN0IHRyYWlsID0gbmV3IE1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgICB0cmFpbC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgICByb3cucHVzaCh0cmFpbCk7XG4gICAgICB9XG4gICAgICBub2RlID0gbmV3IE1hdGhOb2RlKFwibXJvd1wiLCByb3cpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuY29uc3Qgc2luZ2xlQ2hhckJpZ09wcyA9IHtcbiAgXCJcXHUyMjBGXCI6IFwiXFxcXHByb2RcIixcbiAgXCJcXHUyMjEwXCI6IFwiXFxcXGNvcHJvZFwiLFxuICBcIlxcdTIyMTFcIjogXCJcXFxcc3VtXCIsXG4gIFwiXFx1MjJjMFwiOiBcIlxcXFxiaWd3ZWRnZVwiLFxuICBcIlxcdTIyYzFcIjogXCJcXFxcYmlndmVlXCIsXG4gIFwiXFx1MjJjMlwiOiBcIlxcXFxiaWdjYXBcIixcbiAgXCJcXHUyMmMzXCI6IFwiXFxcXGJpZ2N1cFwiLFxuICBcIlxcdTJhMDBcIjogXCJcXFxcYmlnb2RvdFwiLFxuICBcIlxcdTJhMDFcIjogXCJcXFxcYmlnb3BsdXNcIixcbiAgXCJcXHUyYTAyXCI6IFwiXFxcXGJpZ290aW1lc1wiLFxuICBcIlxcdTJhMDRcIjogXCJcXFxcYmlndXBsdXNcIixcbiAgXCJcXHUyYTA1XCI6IFwiXFxcXGJpZ3NxY2FwXCIsXG4gIFwiXFx1MmEwNlwiOiBcIlxcXFxiaWdzcWN1cFwiLFxuICBcIlxcdTJhMDNcIjogXCJcXFxcYmlnY3VwZG90XCIsXG4gIFwiXFx1MmEwN1wiOiBcIlxcXFxiaWdkb3VibGV2ZWVcIixcbiAgXCJcXHUyYTA4XCI6IFwiXFxcXGJpZ2RvdWJsZXdlZGdlXCIsXG4gIFwiXFx1MmEwOVwiOiBcIlxcXFxiaWd0aW1lc1wiXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxjb3Byb2RcIixcbiAgICBcIlxcXFxiaWd2ZWVcIixcbiAgICBcIlxcXFxiaWd3ZWRnZVwiLFxuICAgIFwiXFxcXGJpZ3VwbHVzXCIsXG4gICAgXCJcXFxcYmlnY3VwcGx1c1wiLFxuICAgIFwiXFxcXGJpZ2N1cGRvdFwiLFxuICAgIFwiXFxcXGJpZ2NhcFwiLFxuICAgIFwiXFxcXGJpZ2N1cFwiLFxuICAgIFwiXFxcXGJpZ2RvdWJsZXZlZVwiLFxuICAgIFwiXFxcXGJpZ2RvdWJsZXdlZGdlXCIsXG4gICAgXCJcXFxcaW50b3BcIixcbiAgICBcIlxcXFxwcm9kXCIsXG4gICAgXCJcXFxcc3VtXCIsXG4gICAgXCJcXFxcYmlnb3RpbWVzXCIsXG4gICAgXCJcXFxcYmlnb3BsdXNcIixcbiAgICBcIlxcXFxiaWdvZG90XCIsXG4gICAgXCJcXFxcYmlnc3FjYXBcIixcbiAgICBcIlxcXFxiaWdzcWN1cFwiLFxuICAgIFwiXFxcXGJpZ3RpbWVzXCIsXG4gICAgXCJcXFxcc21hbGxpbnRcIixcbiAgICBcIlxcdTIyMEZcIixcbiAgICBcIlxcdTIyMTBcIixcbiAgICBcIlxcdTIyMTFcIixcbiAgICBcIlxcdTIyYzBcIixcbiAgICBcIlxcdTIyYzFcIixcbiAgICBcIlxcdTIyYzJcIixcbiAgICBcIlxcdTIyYzNcIixcbiAgICBcIlxcdTJhMDBcIixcbiAgICBcIlxcdTJhMDFcIixcbiAgICBcIlxcdTJhMDJcIixcbiAgICBcIlxcdTJhMDRcIixcbiAgICBcIlxcdTJhMDZcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgbGV0IGZOYW1lID0gZnVuY05hbWU7XG4gICAgaWYgKGZOYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZk5hbWUgPSBzaW5nbGVDaGFyQmlnT3BzW2ZOYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiB0cnVlLFxuICAgICAgc3RhY2s6IGZhbHNlLCAvLyBUaGlzIGlzIHRydWUgZm9yIFxcc3RhY2tyZWx7fSwgbm90IGhlcmUuXG4gICAgICBuYW1lOiBmTmFtZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMlxufSk7XG5cbi8vIE5vdGU6IGNhbGxpbmcgZGVmaW5lRnVuY3Rpb24gd2l0aCBhIHR5cGUgdGhhdCdzIGFscmVhZHkgYmVlbiBkZWZpbmVkIG9ubHlcbi8vIHdvcmtzIGJlY2F1c2UgdGhlIHNhbWUgbWF0aG1sQnVpbGRlciBpcyBiZWluZyB1c2VkLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWF0aG9wXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgLy8gSXQgd291bGQgYmUgY29udmllbmllbnQgdG8ganVzdCB3cmFwIGEgPG1vPiBhcm91bmQgdGhlIGFyZ3VtZW50LlxuICAgIC8vIEJ1dCBpZiB0aGUgYXJndW1lbnQgaXMgYSA8bWk+IG9yIDxtb3JkPiwgdGhhdCB3b3VsZCBiZSBpbnZhbGlkIE1hdGhNTC5cbiAgICAvLyBJbiB0aGF0IGNhc2UsIHdlIGluc3RlYWQgcHJvbW90ZSB0aGUgdGV4dCBjb250ZW50cyBvZiB0aGUgYm9keSB0byB0aGUgcGFyZW50LlxuICAgIGNvbnN0IGFyciA9IChib2R5LmJvZHkpID8gYm9keS5ib2R5IDogW2JvZHldO1xuICAgIGNvbnN0IGlzU3ltYm9sID0gYXJyLmxlbmd0aCA9PT0gMSAmJiBvcmRBdG9tVHlwZXMuaW5jbHVkZXMoYXJyWzBdLnR5cGUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogaXNTeW1ib2wsXG4gICAgICBmcm9tTWF0aE9wOiB0cnVlLFxuICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgbmFtZTogaXNTeW1ib2wgPyBhcnJbMF0udGV4dCA6IG51bGwsXG4gICAgICBib2R5OiBpc1N5bWJvbCA/IG51bGwgOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMlxufSk7XG5cbi8vIFRoZXJlIGFyZSAyIGZsYWdzIGZvciBvcGVyYXRvcnM7IHdoZXRoZXIgdGhleSBwcm9kdWNlIGxpbWl0cyBpblxuLy8gZGlzcGxheXN0eWxlLCBhbmQgd2hldGhlciB0aGV5IGFyZSBzeW1ib2xzIGFuZCBzaG91bGQgZ3JvdyBpblxuLy8gZGlzcGxheXN0eWxlLiBUaGVzZSBmb3VyIGdyb3VwcyBjb3ZlciB0aGUgZm91ciBwb3NzaWJsZSBjaG9pY2VzLlxuXG5jb25zdCBzaW5nbGVDaGFySW50ZWdyYWxzID0ge1xuICBcIlxcdTIyMmJcIjogXCJcXFxcaW50XCIsXG4gIFwiXFx1MjIyY1wiOiBcIlxcXFxpaW50XCIsXG4gIFwiXFx1MjIyZFwiOiBcIlxcXFxpaWludFwiLFxuICBcIlxcdTIyMmVcIjogXCJcXFxcb2ludFwiLFxuICBcIlxcdTIyMmZcIjogXCJcXFxcb2lpbnRcIixcbiAgXCJcXHUyMjMwXCI6IFwiXFxcXG9paWludFwiLFxuICBcIlxcdTIyMzFcIjogXCJcXFxcaW50Y2xvY2t3aXNlXCIsXG4gIFwiXFx1MjIzMlwiOiBcIlxcXFx2YXJvaW50Y2xvY2t3aXNlXCIsXG4gIFwiXFx1MmEwY1wiOiBcIlxcXFxpaWlpbnRcIixcbiAgXCJcXHUyYTBkXCI6IFwiXFxcXGludGJhclwiLFxuICBcIlxcdTJhMGVcIjogXCJcXFxcaW50QmFyXCIsXG4gIFwiXFx1MmEwZlwiOiBcIlxcXFxmaW50XCIsXG4gIFwiXFx1MmExMlwiOiBcIlxcXFxycHBvbGludFwiLFxuICBcIlxcdTJhMTNcIjogXCJcXFxcc2Nwb2xpbnRcIixcbiAgXCJcXHUyYTE1XCI6IFwiXFxcXHBvaW50aW50XCIsXG4gIFwiXFx1MmExNlwiOiBcIlxcXFxzcWludFwiLFxuICBcIlxcdTJhMTdcIjogXCJcXFxcaW50bGFyaGtcIixcbiAgXCJcXHUyYTE4XCI6IFwiXFxcXGludHhcIixcbiAgXCJcXHUyYTE5XCI6IFwiXFxcXGludGNhcFwiLFxuICBcIlxcdTJhMWFcIjogXCJcXFxcaW50Y3VwXCJcbn07XG5cbi8vIE5vIGxpbWl0cywgbm90IHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGFyY3NpblwiLFxuICAgIFwiXFxcXGFyY2Nvc1wiLFxuICAgIFwiXFxcXGFyY3RhblwiLFxuICAgIFwiXFxcXGFyY3RnXCIsXG4gICAgXCJcXFxcYXJjY3RnXCIsXG4gICAgXCJcXFxcYXJnXCIsXG4gICAgXCJcXFxcY2hcIixcbiAgICBcIlxcXFxjb3NcIixcbiAgICBcIlxcXFxjb3NlY1wiLFxuICAgIFwiXFxcXGNvc2hcIixcbiAgICBcIlxcXFxjb3RcIixcbiAgICBcIlxcXFxjb3RnXCIsXG4gICAgXCJcXFxcY290aFwiLFxuICAgIFwiXFxcXGNzY1wiLFxuICAgIFwiXFxcXGN0Z1wiLFxuICAgIFwiXFxcXGN0aFwiLFxuICAgIFwiXFxcXGRlZ1wiLFxuICAgIFwiXFxcXGRpbVwiLFxuICAgIFwiXFxcXGV4cFwiLFxuICAgIFwiXFxcXGhvbVwiLFxuICAgIFwiXFxcXGtlclwiLFxuICAgIFwiXFxcXGxnXCIsXG4gICAgXCJcXFxcbG5cIixcbiAgICBcIlxcXFxsb2dcIixcbiAgICBcIlxcXFxzZWNcIixcbiAgICBcIlxcXFxzaW5cIixcbiAgICBcIlxcXFxzaW5oXCIsXG4gICAgXCJcXFxcc2hcIixcbiAgICBcIlxcXFxzZ25cIixcbiAgICBcIlxcXFx0YW5cIixcbiAgICBcIlxcXFx0YW5oXCIsXG4gICAgXCJcXFxcdGdcIixcbiAgICBcIlxcXFx0aFwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgY29uc3QgcHJldkF0b21UeXBlID0gcGFyc2VyLnByZXZBdG9tVHlwZTtcbiAgICBjb25zdCBuZXh0ID0gcGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyOiBpc0RlbGltaXRlcihuZXh0KSxcbiAgICAgIG5lZWRzTGVhZGluZ1NwYWNlOiBwcmV2QXRvbVR5cGUubGVuZ3RoID4gMCAmJiBvcmRUeXBlcy5pbmNsdWRlcyhwcmV2QXRvbVR5cGUpLFxuICAgICAgbmFtZTogZnVuY05hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBMaW1pdHMsIG5vdCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbWF4XCIsIFwiXFxcXG1pblwiLCBcIlxcXFxQclwiLCBcIlxcXFxzdXBcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgY29uc3QgcHJldkF0b21UeXBlID0gcGFyc2VyLnByZXZBdG9tVHlwZTtcbiAgICBjb25zdCBuZXh0ID0gcGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxpbWl0czogdHJ1ZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBzdGFjazogZmFsc2UsXG4gICAgICBpc0ZvbGxvd2VkQnlEZWxpbWl0ZXI6IGlzRGVsaW1pdGVyKG5leHQpLFxuICAgICAgbmVlZHNMZWFkaW5nU3BhY2U6IHByZXZBdG9tVHlwZS5sZW5ndGggPiAwICYmIG9yZFR5cGVzLmluY2x1ZGVzKHByZXZBdG9tVHlwZSksXG4gICAgICBuYW1lOiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMlxufSk7XG5cbi8vIE5vIGxpbWl0cywgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcaW50XCIsXG4gICAgXCJcXFxcaWludFwiLFxuICAgIFwiXFxcXGlpaW50XCIsXG4gICAgXCJcXFxcaWlpaW50XCIsXG4gICAgXCJcXFxcb2ludFwiLFxuICAgIFwiXFxcXG9paW50XCIsXG4gICAgXCJcXFxcb2lpaW50XCIsXG4gICAgXCJcXFxcaW50Y2xvY2t3aXNlXCIsXG4gICAgXCJcXFxcdmFyb2ludGNsb2Nrd2lzZVwiLFxuICAgIFwiXFxcXGludGJhclwiLFxuICAgIFwiXFxcXGludEJhclwiLFxuICAgIFwiXFxcXGZpbnRcIixcbiAgICBcIlxcXFxycHBvbGludFwiLFxuICAgIFwiXFxcXHNjcG9saW50XCIsXG4gICAgXCJcXFxccG9pbnRpbnRcIixcbiAgICBcIlxcXFxzcWludFwiLFxuICAgIFwiXFxcXGludGxhcmhrXCIsXG4gICAgXCJcXFxcaW50eFwiLFxuICAgIFwiXFxcXGludGNhcFwiLFxuICAgIFwiXFxcXGludGN1cFwiLFxuICAgIFwiXFx1MjIyYlwiLFxuICAgIFwiXFx1MjIyY1wiLFxuICAgIFwiXFx1MjIyZFwiLFxuICAgIFwiXFx1MjIyZVwiLFxuICAgIFwiXFx1MjIyZlwiLFxuICAgIFwiXFx1MjIzMFwiLFxuICAgIFwiXFx1MjIzMVwiLFxuICAgIFwiXFx1MjIzMlwiLFxuICAgIFwiXFx1MmEwY1wiLFxuICAgIFwiXFx1MmEwZFwiLFxuICAgIFwiXFx1MmEwZVwiLFxuICAgIFwiXFx1MmEwZlwiLFxuICAgIFwiXFx1MmExMlwiLFxuICAgIFwiXFx1MmExM1wiLFxuICAgIFwiXFx1MmExNVwiLFxuICAgIFwiXFx1MmExNlwiLFxuICAgIFwiXFx1MmExN1wiLFxuICAgIFwiXFx1MmExOFwiLFxuICAgIFwiXFx1MmExOVwiLFxuICAgIFwiXFx1MmExYVwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgbGV0IGZOYW1lID0gZnVuY05hbWU7XG4gICAgaWYgKGZOYW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZk5hbWUgPSBzaW5nbGVDaGFySW50ZWdyYWxzW2ZOYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIG5hbWU6IGZOYW1lXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQyXG59KTtcblxuLy8gTk9URTogVW5saWtlIG1vc3QgYnVpbGRlcnMsIHRoaXMgb25lIGhhbmRsZXMgbm90IG9ubHlcbi8vIFwib3BlcmF0b3JuYW1lXCIsIGJ1dCBhbHNvICBcInN1cHN1YlwiIHNpbmNlIFxcb3BlcmF0b3JuYW1lKiBjYW5cbi8vIGFmZmVjdCBzdXBlci9zdWJzY3JpcHRpbmcuXG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkMSA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgbGV0IGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUud2l0aEZvbnQoXCJtYXRocm1cIikpO1xuXG4gIC8vIElzIGV4cHJlc3Npb24gYSBzdHJpbmcgb3IgaGFzIGl0IHNvbWV0aGluZyBsaWtlIGEgZnJhY3Rpb24/XG4gIGxldCBpc0FsbFN0cmluZyA9IHRydWU7IC8vIGRlZmF1bHRcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG5vZGUgPSBleHByZXNzaW9uW2ldO1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5NYXRoTm9kZSkge1xuICAgICAgaWYgKChub2RlLnR5cGUgPT09IFwibXJvd1wiIHx8IG5vZGUudHlwZSA9PT0gXCJtcGFkZGVkXCIpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgbm9kZS5jaGlsZHJlblswXSBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuTWF0aE5vZGUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICBjYXNlIFwibWlcIjpcbiAgICAgICAgY2FzZSBcIm1uXCI6XG4gICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICBjYXNlIFwibXRleHRcIjpcbiAgICAgICAgICBicmVhazsgLy8gRG8gbm90aGluZyB5ZXQuXG4gICAgICAgIGNhc2UgXCJtc3BhY2VcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobm9kZS5hdHRyaWJ1dGVzLndpZHRoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gbm9kZS5hdHRyaWJ1dGVzLndpZHRoLnJlcGxhY2UoXCJlbVwiLCBcIlwiKTtcbiAgICAgICAgICAgICAgY29uc3QgY2ggPSBzcGFjZUNoYXJhY3RlcihOdW1iZXIod2lkdGgpKTtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uW2ldID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoY2gpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcIm1vXCI6IHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5UZXh0Tm9kZSkge1xuICAgICAgICAgICAgY2hpbGQudGV4dCA9IGNoaWxkLnRleHQucmVwbGFjZSgvXFx1MjIxMi8sIFwiLVwiKS5yZXBsYWNlKC9cXHUyMjE3LywgXCIqXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXNBbGxTdHJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNBbGxTdHJpbmcpIHtcbiAgICAvLyBXcml0ZSBhIHNpbmdsZSBUZXh0Tm9kZSBpbnN0ZWFkIG9mIG11bHRpcGxlIG5lc3RlZCB0YWdzLlxuICAgIGNvbnN0IHdvcmQgPSBleHByZXNzaW9uLm1hcCgobm9kZSkgPT4gbm9kZS50b1RleHQoKSkuam9pbihcIlwiKTtcbiAgICBleHByZXNzaW9uID0gW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHdvcmQpXTtcbiAgfSBlbHNlIGlmIChcbiAgICBleHByZXNzaW9uLmxlbmd0aCA9PT0gMVxuICAgICYmIFtcIm1vdmVyXCIsIFwibXVuZGVyXCJdLmluY2x1ZGVzKGV4cHJlc3Npb25bMF0udHlwZSkgJiZcbiAgICAoZXhwcmVzc2lvblswXS5jaGlsZHJlblswXS50eXBlID09PSBcIm1pXCIgfHwgZXhwcmVzc2lvblswXS5jaGlsZHJlblswXS50eXBlID09PSBcIm10ZXh0XCIpXG4gICkge1xuICAgIGV4cHJlc3Npb25bMF0uY2hpbGRyZW5bMF0udHlwZSA9IFwibWlcIjtcbiAgICBpZiAoZ3JvdXAucGFyZW50SXNTdXBTdWIpIHtcbiAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgZXhwcmVzc2lvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG4gICAgICByZXR1cm4gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KFtleHByZXNzaW9uWzBdLCBvcGVyYXRvcl0pXG4gICAgfVxuICB9XG5cbiAgbGV0IHdyYXBwZXI7XG4gIGlmIChpc0FsbFN0cmluZykge1xuICAgIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIGV4cHJlc3Npb24pO1xuICAgIGlmIChleHByZXNzaW9uWzBdLnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwibm9ybWFsXCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGV4cHJlc3Npb24pO1xuICB9XG5cbiAgaWYgKCFncm91cC5wYXJlbnRJc1N1cFN1Yikge1xuICAgIC8vIEFwcGVuZCBhbiA8bW8+JkFwcGx5RnVuY3Rpb247PC9tbz4uXG4gICAgLy8gcmVmOiBodHRwczovL3d3dy53My5vcmcvVFIvUkVDLU1hdGhNTC9jaGFwM18yLmh0bWwjc2VjMy4yLjRcbiAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcbiAgICBjb25zdCBmcmFnbWVudCA9IFt3cmFwcGVyLCBvcGVyYXRvcl07XG4gICAgaWYgKGdyb3VwLm5lZWRzTGVhZGluZ1NwYWNlKSB7XG4gICAgICAvLyBMYVRlWCBnaXZlcyBvcGVyYXRvciBzcGFjaW5nLCBidXQgYSA8bWk+IGdldHMgb3JkIHNwYWNpbmcuXG4gICAgICAvLyBTbyBhZGQgYSBsZWFkaW5nIHNwYWNlLlxuICAgICAgY29uc3Qgc3BhY2UgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgIHNwYWNlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4xNjY3ZW1cIik7IC8vIHRoaW4gc3BhY2UuXG4gICAgICBmcmFnbWVudC51bnNoaWZ0KHNwYWNlKTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5pc0ZvbGxvd2VkQnlEZWxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IHRyYWlsID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICB0cmFpbC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgZnJhZ21lbnQucHVzaCh0cmFpbCk7XG4gICAgfVxuICAgIHJldHVybiBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoZnJhZ21lbnQpXG4gIH1cblxuICByZXR1cm4gd3JhcHBlclxufTtcblxuLy8gXFxvcGVyYXRvcm5hbWVcbi8vIGFtc29wbi5kdHg6IFxcbWF0aG9weyMxXFxrZXJuXFx6QFxcb3BlcmF0b3JAZm9udCMzfVxcbmV3bWNvZGVzQFxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wZXJhdG9ybmFtZVwiLFxuICBuYW1lczogW1wiXFxcXG9wZXJhdG9ybmFtZUBcIiwgXCJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIGNvbnN0IHByZXZBdG9tVHlwZSA9IHBhcnNlci5wcmV2QXRvbVR5cGU7XG4gICAgY29uc3QgbmV4dCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcGVyYXRvcm5hbWVcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSksXG4gICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IChmdW5jTmFtZSA9PT0gXCJcXFxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1wiKSxcbiAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBpc0ZvbGxvd2VkQnlEZWxpbWl0ZXI6IGlzRGVsaW1pdGVyKG5leHQpLFxuICAgICAgbmVlZHNMZWFkaW5nU3BhY2U6IHByZXZBdG9tVHlwZS5sZW5ndGggPiAwICYmIG9yZFR5cGVzLmluY2x1ZGVzKHByZXZBdG9tVHlwZSlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDFcbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxvcGVyYXRvcm5hbWVcIixcbiAgXCJcXFxcQGlmc3RhclxcXFxvcGVyYXRvcm5hbWV3aXRobGltaXRzXFxcXG9wZXJhdG9ybmFtZUBcIik7XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcIm9yZGdyb3VwXCIsXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBzdHlsZSwgZ3JvdXAuc2VtaXNpbXBsZSk7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXHBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImhwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxcaHBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgc3R5bGUpO1xuICAgIGNvbnN0IHBoYW50b20gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwcHhcIik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2cGhhbnRvbVwiLFxuICBuYW1lczogW1wiXFxcXHZwaGFudG9tXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInZwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24ob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIHN0eWxlKTtcbiAgICBjb25zdCBwaGFudG9tID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcGhhbnRvbV0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vLyBJbiBMYVRlWCwgXFxwbWIgaXMgYSBzaW11bGF0aW9uIG9mIGJvbGQgZm9udC5cbi8vIFRoZSB2ZXJzaW9uIG9mIFxccG1iIGluIGFtYnN5LnN0eSB3b3JrcyBieSB0eXBlc2V0dGluZyB0aHJlZSBjb3BpZXMgb2YgdGhlIGFyZ3VtZW50XG4vLyB3aXRoIHNtYWxsIG9mZnNldHMuIFdlIHVzZSBDU1MgZm9udC13ZWlnaHQ6Ym9sZC5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInBtYlwiLFxuICBuYW1lczogW1wiXFxcXHBtYlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicG1iXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pXG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlKTtcbiAgICAvLyBXcmFwIHdpdGggYW4gPG1zdHlsZT4gZWxlbWVudC5cbiAgICBjb25zdCBub2RlID0gd3JhcFdpdGhNc3R5bGUoaW5uZXIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJmb250LXdlaWdodDpib2xkXCIpO1xuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG4vLyBcXHJhaXNlLCBcXGxvd2VyLCBhbmQgXFxyYWlzZWJveFxuXG5jb25zdCBtYXRobWxCdWlsZGVyID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlLndpdGhMZXZlbChTdHlsZUxldmVsLlRFWFQpO1xuICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgbmV3U3R5bGUpXSk7XG4gIGNvbnN0IGR5ID0gY2FsY3VsYXRlU2l6ZShncm91cC5keSwgc3R5bGUpO1xuICBub2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgZHkubnVtYmVyICsgZHkudW5pdCk7XG4gIC8vIEFkZCBwYWRkaW5nLCB3aGljaCBhY3RzIHRvIGluY3JlYXNlIGhlaWdodCBpbiBDaHJvbWl1bS5cbiAgLy8gVE9ETzogRmlndXJlIG91dCBzb21lIHdheSB0byBjaGFuZ2UgaGVpZ2h0IGluIEZpcmVmb3ggdy9vIGJyZWFraW5nIENocm9taXVtLlxuICBpZiAoZHkubnVtYmVyID4gMCkge1xuICAgIG5vZGUuc3R5bGUucGFkZGluZyA9IGR5Lm51bWJlciArIGR5LnVuaXQgKyBcIiAwIDAgMFwiO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuc3R5bGUucGFkZGluZyA9IFwiMCAwIFwiICsgTWF0aC5hYnMoZHkubnVtYmVyKSArIGR5LnVuaXQgKyBcIiAwXCI7XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJyYWlzZVwiLFxuICBuYW1lczogW1wiXFxcXHJhaXNlXCIsIFwiXFxcXGxvd2VyXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIiwgXCJwcmltaXRpdmVcIl0sXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBhbW91bnQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWU7XG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxsb3dlclwiKSB7IGFtb3VudC5udW1iZXIgKj0gLTE7IH1cbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyYWlzZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkeTogYW1vdW50LFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXJcbn0pO1xuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJyYWlzZVwiLFxuICBuYW1lczogW1wiXFxcXHJhaXNlYm94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYXJnVHlwZXM6IFtcInNpemVcIiwgXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGFtb3VudCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKS52YWx1ZTtcbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyYWlzZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBkeTogYW1vdW50LFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXJcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxccmVmXCIsIFwiXFxcXGVxcmVmXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicmVmXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZ1bmNOYW1lLFxuICAgICAgc3RyaW5nOiBhcmdzWzBdLnN0cmluZy5yZXBsYWNlKGludmFsaWRJZFJlZ0V4LCBcIlwiKVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgLy8gQ3JlYXRlIGFuIGVtcHR5IDxhPiBub2RlLiBTZXQgYSBjbGFzcyBhbmQgYW4gaHJlZiBhdHRyaWJ1dGUuXG4gICAgLy8gVGhlIHBvc3QtcHJvY2Vzc29yIHdpbGwgcG9wdWxhdGUgd2l0aCB0aGUgdGFyZ2V0J3MgdGFnIG9yIGVxdWF0aW9uIG51bWJlci5cbiAgICBjb25zdCBjbGFzc2VzID0gZ3JvdXAuZnVuY05hbWUgPT09IFwiXFxcXHJlZlwiID8gW1widG1sLXJlZlwiXSA6IFtcInRtbC1yZWZcIiwgXCJ0bWwtZXFyZWZcIl07XG4gICAgcmV0dXJuIG5ldyBBbmNob3JOb2RlKFwiI1wiICsgZ3JvdXAuc3RyaW5nLCBjbGFzc2VzLCBudWxsKVxuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJlZmxlY3RcIixcbiAgbmFtZXM6IFtcIlxcXFxyZWZsZWN0Ym94XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcImhib3hcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyZWZsZWN0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IG5vZGUgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpO1xuICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZVgoLTEpXCI7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXHJlbGF4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGVcbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJ1bGVcIixcbiAgbmFtZXM6IFtcIlxcXFxydWxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IHNoaWZ0ID0gb3B0QXJnc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcbiAgICBjb25zdCBoZWlnaHQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzFdLCBcInNpemVcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBzaGlmdDogc2hpZnQgJiYgYXNzZXJ0Tm9kZVR5cGUoc2hpZnQsIFwic2l6ZVwiKS52YWx1ZSxcbiAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgIGhlaWdodDogaGVpZ2h0LnZhbHVlXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIHN0eWxlKTtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgc3R5bGUpO1xuICAgIGNvbnN0IHNoaWZ0ID0gZ3JvdXAuc2hpZnRcbiAgICAgID8gY2FsY3VsYXRlU2l6ZShncm91cC5zaGlmdCwgc3R5bGUpXG4gICAgICA6IHsgbnVtYmVyOiAwLCB1bml0OiBcImVtXCIgfTtcbiAgICBjb25zdCBjb2xvciA9IChzdHlsZS5jb2xvciAmJiBzdHlsZS5nZXRDb2xvcigpKSB8fCBcImJsYWNrXCI7XG5cbiAgICBjb25zdCBydWxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgaWYgKHdpZHRoLm51bWJlciA+IDAgJiYgaGVpZ2h0Lm51bWJlciA+IDApIHtcbiAgICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwibWF0aGJhY2tncm91bmRcIiwgY29sb3IpO1xuICAgIH1cbiAgICBydWxlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoLm51bWJlciArIHdpZHRoLnVuaXQpO1xuICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodC5udW1iZXIgKyBoZWlnaHQudW5pdCk7XG4gICAgaWYgKHNoaWZ0Lm51bWJlciA9PT0gMCkgeyByZXR1cm4gcnVsZSB9XG5cbiAgICBjb25zdCB3cmFwcGVyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtydWxlXSk7XG4gICAgaWYgKHNoaWZ0Lm51bWJlciA+PSAwKSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIitcIiArIHNoaWZ0Lm51bWJlciArIHNoaWZ0LnVuaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBzaGlmdC5udW1iZXIgKyBzaGlmdC51bml0KTtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIrXCIgKyAtc2hpZnQubnVtYmVyICsgc2hpZnQudW5pdCk7XG4gICAgfVxuICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBzaGlmdC5udW1iZXIgKyBzaGlmdC51bml0KTtcbiAgICByZXR1cm4gd3JhcHBlcjtcbiAgfVxufSk7XG5cbi8vIFRoZSBzaXplIG1hcHBpbmdzIGFyZSB0YWtlbiBmcm9tIFRlWCB3aXRoIFxcbm9ybWFsc2l6ZT0xMHB0LlxuLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmFjayBzY3JpcHQgbGV2ZWwuIE1hdGhNTCBkb2VzIHRoYXQuXG5jb25zdCBzaXplTWFwID0ge1xuICBcIlxcXFx0aW55XCI6IDAuNSxcbiAgXCJcXFxcc2l4cHRzaXplXCI6IDAuNixcbiAgXCJcXFxcVGlueVwiOiAwLjYsXG4gIFwiXFxcXHNjcmlwdHNpemVcIjogMC43LFxuICBcIlxcXFxmb290bm90ZXNpemVcIjogMC44LFxuICBcIlxcXFxzbWFsbFwiOiAwLjksXG4gIFwiXFxcXG5vcm1hbHNpemVcIjogMS4wLFxuICBcIlxcXFxsYXJnZVwiOiAxLjIsXG4gIFwiXFxcXExhcmdlXCI6IDEuNDQsXG4gIFwiXFxcXExBUkdFXCI6IDEuNzI4LFxuICBcIlxcXFxodWdlXCI6IDIuMDc0LFxuICBcIlxcXFxIdWdlXCI6IDIuNDg4XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic2l6aW5nXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcdGlueVwiLFxuICAgIFwiXFxcXHNpeHB0c2l6ZVwiLFxuICAgIFwiXFxcXFRpbnlcIixcbiAgICBcIlxcXFxzY3JpcHRzaXplXCIsXG4gICAgXCJcXFxcZm9vdG5vdGVzaXplXCIsXG4gICAgXCJcXFxcc21hbGxcIixcbiAgICBcIlxcXFxub3JtYWxzaXplXCIsXG4gICAgXCJcXFxcbGFyZ2VcIixcbiAgICBcIlxcXFxMYXJnZVwiLFxuICAgIFwiXFxcXExBUkdFXCIsXG4gICAgXCJcXFxcaHVnZVwiLFxuICAgIFwiXFxcXEh1Z2VcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBicmVha09uVG9rZW5UZXh0LCBmdW5jTmFtZSwgcGFyc2VyIH0sIGFyZ3MpID0+IHtcbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCAmJiBwYXJzZXIubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhgVGVtbWwgc3RyaWN0LW1vZGUgd2FybmluZzogQ29tbWFuZCAke2Z1bmNOYW1lfSBpcyBpbnZhbGlkIGluIG1hdGggbW9kZS5gKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGJyZWFrT25Ub2tlblRleHQsIHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNpemluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmdW5jTmFtZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS53aXRoRm9udFNpemUoc2l6ZU1hcFtncm91cC5mdW5jTmFtZV0pO1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld1N0eWxlKTtcbiAgICAvLyBXcmFwIHdpdGggYW4gPG1zdHlsZT4gZWxlbWVudC5cbiAgICBjb25zdCBub2RlID0gd3JhcFdpdGhNc3R5bGUoaW5uZXIpO1xuICAgIGNvbnN0IGZhY3RvciA9IChzaXplTWFwW2dyb3VwLmZ1bmNOYW1lXSAvIHN0eWxlLmZvbnRTaXplKS50b0ZpeGVkKDQpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHNpemVcIiwgZmFjdG9yICsgXCJlbVwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8vIHNtYXNoLCB3aXRoIG9wdGlvbmFsIFt0Yl0sIGFzIGluIEFNU1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic21hc2hcIixcbiAgbmFtZXM6IFtcIlxcXFxzbWFzaFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciB9LCBhcmdzLCBvcHRBcmdzKSA9PiB7XG4gICAgbGV0IHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgbGV0IHNtYXNoRGVwdGggPSBmYWxzZTtcbiAgICBjb25zdCB0YkFyZyA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJvcmRncm91cFwiKTtcbiAgICBpZiAodGJBcmcpIHtcbiAgICAgIC8vIE9wdGlvbmFsIFt0Yl0gYXJndW1lbnQgaXMgZW5nYWdlZC5cbiAgICAgIC8vIHJlZjogYW1zbWF0aDogXFxyZW5ld2NvbW1hbmR7XFxzbWFzaH1bMV1bdGJdeyVcbiAgICAgIC8vICAgICAgICAgICAgICAgZGVmXFxtYkB0e1xcaHR9XFxkZWZcXG1iQGJ7XFxkcH1cXGRlZlxcbWJAdGJ7XFxodFxcekBcXHpAXFxkcH0lXG4gICAgICBsZXQgbGV0dGVyID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGJBcmcuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGJBcmcuYm9keVtpXTtcbiAgICAgICAgLy8gVE9ETzogV3JpdGUgYW4gQXNzZXJ0U3ltYm9sTm9kZVxuICAgICAgICBsZXR0ZXIgPSBub2RlLnRleHQ7XG4gICAgICAgIGlmIChsZXR0ZXIgPT09IFwidFwiKSB7XG4gICAgICAgICAgc21hc2hIZWlnaHQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCJiXCIpIHtcbiAgICAgICAgICBzbWFzaERlcHRoID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IGZhbHNlO1xuICAgICAgICAgIHNtYXNoRGVwdGggPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICBzbWFzaERlcHRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzbWFzaFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgc21hc2hIZWlnaHQsXG4gICAgICBzbWFzaERlcHRoXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSldKTtcblxuICAgIGlmIChncm91cC5zbWFzaEhlaWdodCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIwcHhcIik7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnNtYXNoRGVwdGgpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCIwcHhcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3FydFwiLFxuICBuYW1lczogW1wiXFxcXHNxcnRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3QgaW5kZXggPSBvcHRBcmdzWzBdO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNxcnRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keSxcbiAgICAgIGluZGV4XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCB7IGJvZHksIGluZGV4IH0gPSBncm91cDtcbiAgICByZXR1cm4gaW5kZXhcbiAgICAgID8gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm9vdFwiLCBbXG4gICAgICAgIGJ1aWxkR3JvdXAkMShib2R5LCBzdHlsZSksXG4gICAgICAgIGJ1aWxkR3JvdXAkMShpbmRleCwgc3R5bGUuaW5jcmVtZW50TGV2ZWwoKSlcbiAgICAgIF0pXG4gICAgOiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcXJ0XCIsIFtidWlsZEdyb3VwJDEoYm9keSwgc3R5bGUpXSk7XG4gIH1cbn0pO1xuXG5jb25zdCBzdHlsZU1hcCA9IHtcbiAgZGlzcGxheTogMCxcbiAgdGV4dDogMSxcbiAgc2NyaXB0OiAyLFxuICBzY3JpcHRzY3JpcHQ6IDNcbn07XG5cbmNvbnN0IHN0eWxlQXR0cmlidXRlcyA9IHtcbiAgZGlzcGxheTogW1wiMFwiLCBcInRydWVcIl0sXG4gIHRleHQ6IFtcIjBcIiwgXCJmYWxzZVwiXSxcbiAgc2NyaXB0OiBbXCIxXCIsIFwiZmFsc2VcIl0sXG4gIHNjcmlwdHNjcmlwdDogW1wiMlwiLCBcImZhbHNlXCJdXG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3R5bGluZ1wiLFxuICBuYW1lczogW1wiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c2NyaXB0c3R5bGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgYnJlYWtPblRva2VuVGV4dCwgZnVuY05hbWUsIHBhcnNlciB9LCBhcmdzKSB7XG4gICAgLy8gcGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG4gICAgY29uc3QgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCwgdHJ1ZSk7XG5cbiAgICBjb25zdCBzY3JpcHRMZXZlbCA9IGZ1bmNOYW1lLnNsaWNlKDEsIGZ1bmNOYW1lLmxlbmd0aCAtIDUpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0eWxpbmdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgLy8gRmlndXJlIG91dCB3aGF0IHNjcmlwdExldmVsIHRvIHVzZSBieSBwdWxsaW5nIG91dCB0aGUgc2NyaXB0TGV2ZWwgZnJvbVxuICAgICAgLy8gdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgIHNjcmlwdExldmVsLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHNjcmlwdExldmVsIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aExldmVsKHN0eWxlTWFwW2dyb3VwLnNjcmlwdExldmVsXSk7XG4gICAgLy8gVGhlIHN0eWxlIGFyZ3VtZW50IGluIHRoZSBuZXh0IGxpbmUgZG9lcyBOT1QgZGlyZWN0bHkgc2V0IGEgTWF0aE1MIHNjcmlwdCBsZXZlbC5cbiAgICAvLyBJdCBqdXN0IHRyYWNrcyB0aGUgc3R5bGUgbGV2ZWwsIGluIGNhc2Ugd2UgbmVlZCB0byBrbm93IGl0IGZvciBzdXBzdWIgb3IgbWF0aGNob2ljZS5cbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBuZXdTdHlsZSk7XG4gICAgLy8gV3JhcCB3aXRoIGFuIDxtc3R5bGU+IGVsZW1lbnQuXG4gICAgY29uc3Qgbm9kZSA9IHdyYXBXaXRoTXN0eWxlKGlubmVyKTtcblxuICAgIGNvbnN0IGF0dHIgPSBzdHlsZUF0dHJpYnV0ZXNbZ3JvdXAuc2NyaXB0TGV2ZWxdO1xuXG4gICAgLy8gSGVyZSBpcyB3aGVyZSB3ZSBzZXQgdGhlIE1hdGhNTCBzY3JpcHQgbGV2ZWwuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBhdHRyWzBdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBhdHRyWzFdKTtcblxuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLyoqXG4gKiBTb21ldGltZXMsIGdyb3VwcyBwZXJmb3JtIHNwZWNpYWwgcnVsZXMgd2hlbiB0aGV5IGhhdmUgc3VwZXJzY3JpcHRzIG9yXG4gKiBzdWJzY3JpcHRzIGF0dGFjaGVkIHRvIHRoZW0uIFRoaXMgZnVuY3Rpb24gbGV0cyB0aGUgYHN1cHN1YmAgZ3JvdXAga25vdyB0aGF0XG4gKiBTb21ldGltZXMsIGdyb3VwcyBwZXJmb3JtIHNwZWNpYWwgcnVsZXMgd2hlbiB0aGV5IGhhdmUgc3VwZXJzY3JpcHRzIG9yXG4gKiBpdHMgaW5uZXIgZWxlbWVudCBzaG91bGQgaGFuZGxlIHRoZSBzdXBlcnNjcmlwdHMgYW5kIHN1YnNjcmlwdHMgaW5zdGVhZCBvZlxuICogaGFuZGxpbmcgdGhlbSBpdHNlbGYuXG4gKi9cblxuLy8gSGVscGVyc1xuY29uc3Qgc3ltYm9sUmVnRXggPSAvXm0ob3Zlcnx1bmRlcnx1bmRlcm92ZXIpJC87XG5cbi8vIFN1cGVyIHNjcmlwdHMgYW5kIHN1YnNjcmlwdHMsIHdob3NlIHByZWNpc2UgcGxhY2VtZW50IGNhbiBkZXBlbmQgb24gb3RoZXJcbi8vIGZ1bmN0aW9ucyB0aGF0IHByZWNlZGUgdGhlbS5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInN1cHN1YlwiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIElzIHRoZSBpbm5lciBncm91cCBhIHJlbGV2YW50IGhvcml6b250YWwgYnJhY2U/XG4gICAgbGV0IGlzQnJhY2UgPSBmYWxzZTtcbiAgICBsZXQgaXNPdmVyO1xuICAgIGxldCBpc1N1cDtcbiAgICBsZXQgYXBwZW5kQXBwbHlGdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBhcHBlbmRTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBuZWVkc0xlYWRpbmdTcGFjZSA9IGZhbHNlO1xuXG4gICAgaWYgKGdyb3VwLmJhc2UgJiYgZ3JvdXAuYmFzZS50eXBlID09PSBcImhvcml6QnJhY2VcIikge1xuICAgICAgaXNTdXAgPSAhIWdyb3VwLnN1cDtcbiAgICAgIGlmIChpc1N1cCA9PT0gZ3JvdXAuYmFzZS5pc092ZXIpIHtcbiAgICAgICAgaXNCcmFjZSA9IHRydWU7XG4gICAgICAgIGlzT3ZlciA9IGdyb3VwLmJhc2UuaXNPdmVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChncm91cC5iYXNlICYmICFncm91cC5iYXNlLnN0YWNrICYmXG4gICAgICAoZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wXCIgfHwgZ3JvdXAuYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSkge1xuICAgICAgZ3JvdXAuYmFzZS5wYXJlbnRJc1N1cFN1YiA9IHRydWU7XG4gICAgICBhcHBlbmRBcHBseUZ1bmN0aW9uID0gIWdyb3VwLmJhc2Uuc3ltYm9sO1xuICAgICAgYXBwZW5kU3BhY2UgPSBhcHBlbmRBcHBseUZ1bmN0aW9uICYmICFncm91cC5pc0ZvbGxvd2VkQnlEZWxpbWl0ZXI7XG4gICAgICBuZWVkc0xlYWRpbmdTcGFjZSA9IGdyb3VwLmJhc2UubmVlZHNMZWFkaW5nU3BhY2U7XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBncm91cC5iYXNlICYmIGdyb3VwLmJhc2Uuc3RhY2tcbiAgICAgID8gW2J1aWxkR3JvdXAkMShncm91cC5iYXNlLmJvZHlbMF0sIHN0eWxlKV1cbiAgICAgIDogW2J1aWxkR3JvdXAkMShncm91cC5iYXNlLCBzdHlsZSldO1xuXG4gICAgLy8gTm90ZSByZWdhcmRpbmcgc2NyaXB0c3R5bGUgbGV2ZWwuXG4gICAgLy8gKFN1YnxzdXBlcilzY3JpcHRzIHNob3VsZCBub3Qgc2hyaW5rIGJleW9uZCBNYXRoTUwgc2NyaXB0bGV2ZWwgMiBha2EgXFxzY3JpcHRzY3JpcHRzdHlsZVxuICAgIC8vIFJlZjogaHR0cHM6Ly93M2MuZ2l0aHViLmlvL21hdGhtbC1jb3JlLyN0aGUtZGlzcGxheXN0eWxlLWFuZC1zY3JpcHRsZXZlbC1hdHRyaWJ1dGVzXG4gICAgLy8gKEJUVywgTWF0aE1MIHNjcmlwdGxldmVsIDIgaXMgZXF1YWwgdG8gVGVtbWwgbGV2ZWwgMy4pXG4gICAgLy8gQnV0IENocm9taXVtIGNvbnRpbnVlcyB0byBzaHJpbmsgdGhlIChzdWJ8c3VwZXIpc2NyaXB0cy4gU28gd2UgZXhwbGljaXRseSBzZXQgc2NyaXB0bGV2ZWwgMi5cblxuICAgIGNvbnN0IGNoaWxkU3R5bGUgPSBzdHlsZS5pblN1Yk9yU3VwKCk7XG4gICAgaWYgKGdyb3VwLnN1Yikge1xuICAgICAgY29uc3Qgc3ViID0gYnVpbGRHcm91cCQxKGdyb3VwLnN1YiwgY2hpbGRTdHlsZSk7XG4gICAgICBpZiAoc3R5bGUubGV2ZWwgPT09IDMpIHsgc3ViLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMlwiKTsgfVxuICAgICAgY2hpbGRyZW4ucHVzaChzdWIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5zdXApIHtcbiAgICAgIGNvbnN0IHN1cCA9IGJ1aWxkR3JvdXAkMShncm91cC5zdXAsIGNoaWxkU3R5bGUpO1xuICAgICAgaWYgKHN0eWxlLmxldmVsID09PSAzKSB7IHN1cC5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjJcIik7IH1cbiAgICAgIGNvbnN0IHRlc3ROb2RlID0gc3VwLnR5cGUgPT09IFwibXJvd1wiID8gc3VwLmNoaWxkcmVuWzBdIDogc3VwO1xuICAgICAgaWYgKCh0ZXN0Tm9kZSAmJiB0ZXN0Tm9kZS50eXBlID09PSBcIm1vXCIgJiYgdGVzdE5vZGUuY2xhc3Nlcy5pbmNsdWRlcyhcInRtbC1wcmltZVwiKSlcbiAgICAgICAgJiYgZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnRleHQgJiYgXCJmRlwiLmluZGV4T2YoZ3JvdXAuYmFzZS50ZXh0KSA+IC0xKSB7XG4gICAgICAgIC8vIENocm9taXVtIGRvZXMgbm90IGFkZHJlc3MgaXRhbGljIGNvcnJlY3Rpb24gb24gcHJpbWUuICBQcmV2ZW50IGbigLIgZnJvbSBvdmVybGFwcGluZy5cbiAgICAgICAgdGVzdE5vZGUuY2xhc3Nlcy5wdXNoKFwicHJpbWUtcGFkXCIpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucHVzaChzdXApO1xuICAgIH1cblxuICAgIGxldCBub2RlVHlwZTtcbiAgICBpZiAoaXNCcmFjZSkge1xuICAgICAgbm9kZVR5cGUgPSBpc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiO1xuICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1Yikge1xuICAgICAgY29uc3QgYmFzZSA9IGdyb3VwLmJhc2U7XG4gICAgICBpZiAoXG4gICAgICAgIGJhc2UgJiZcbiAgICAgICAgYmFzZS50eXBlID09PSBcIm9wXCIgJiZcbiAgICAgICAgYmFzZS5saW1pdHMgJiZcbiAgICAgICAgKHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkgfHwgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1vdmVyXCI7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBiYXNlICYmXG4gICAgICAgIGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJlxuICAgICAgICBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJlxuICAgICAgICAoYmFzZS5saW1pdHMgfHwgc3R5bGUubGV2ZWwgPT09IFN0eWxlTGV2ZWwuRElTUExBWSlcbiAgICAgICkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3VwXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAuc3VwKSB7XG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuYmFzZTtcbiAgICAgIGlmIChcbiAgICAgICAgYmFzZSAmJlxuICAgICAgICBiYXNlLnR5cGUgPT09IFwib3BcIiAmJlxuICAgICAgICBiYXNlLmxpbWl0cyAmJlxuICAgICAgICAoc3R5bGUubGV2ZWwgPT09IFN0eWxlTGV2ZWwuRElTUExBWSB8fCBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YilcbiAgICAgICkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyXCI7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBiYXNlICYmXG4gICAgICAgIGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJlxuICAgICAgICBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJlxuICAgICAgICAoYmFzZS5saW1pdHMgfHwgc3R5bGUubGV2ZWwgPT09IFN0eWxlTGV2ZWwuRElTUExBWSlcbiAgICAgICkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuYmFzZTtcbiAgICAgIGlmIChiYXNlICYmICgoYmFzZS50eXBlID09PSBcIm9wXCIgJiYgYmFzZS5saW1pdHMpIHx8IGJhc2UudHlwZSA9PT0gXCJtdWx0aXNjcmlwdFwiKSAmJlxuICAgICAgICAoc3R5bGUubGV2ZWwgPT09IFN0eWxlTGV2ZWwuRElTUExBWSB8fCBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YilcbiAgICAgICkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyb3ZlclwiO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgYmFzZSAmJlxuICAgICAgICBiYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIgJiZcbiAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiZcbiAgICAgICAgKHN0eWxlLmxldmVsID09PSBTdHlsZUxldmVsLkRJU1BMQVkgfHwgYmFzZS5saW1pdHMpXG4gICAgICApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm11bmRlcm92ZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3Vic3VwXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShub2RlVHlwZSwgY2hpbGRyZW4pO1xuICAgIGlmIChhcHBlbmRBcHBseUZ1bmN0aW9uKSB7XG4gICAgICAvLyBBcHBlbmQgYW4gPG1vPiZBcHBseUZ1bmN0aW9uOzwvbW8+LlxuICAgICAgLy8gcmVmOiBodHRwczovL3d3dy53My5vcmcvVFIvUkVDLU1hdGhNTC9jaGFwM18yLmh0bWwjc2VjMy4yLjRcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuICAgICAgaWYgKG5lZWRzTGVhZGluZ1NwYWNlKSB7XG4gICAgICAgIGNvbnN0IHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIHNwYWNlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4xNjY3ZW1cIik7IC8vIHRoaW4gc3BhY2UuXG4gICAgICAgIG5vZGUgPSBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoW3NwYWNlLCBub2RlLCBvcGVyYXRvcl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChbbm9kZSwgb3BlcmF0b3JdKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcHBlbmRTcGFjZSkge1xuICAgICAgICBjb25zdCBzcGFjZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgICBzcGFjZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuMTY2N2VtXCIpOyAvLyB0aGluIHNwYWNlLlxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goc3BhY2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3ltYm9sUmVnRXgudGVzdChub2RlVHlwZSkpIHtcbiAgICAgIC8vIFdyYXAgaW4gYSA8bXJvdz4uIE90aGVyd2lzZSBGaXJlZm94IHN0cmV0Y2h5IHBhcmVucyB3aWxsIG5vdCBzdHJldGNoIHRvIGluY2x1ZGUgbGltaXRzLlxuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbbm9kZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG4vLyBPcGVyYXRvciBQYXJzZU5vZGVzIGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gc3ltYm9sIEdyb3VwcyBpbiBzcmMvc3ltYm9scy5qcy5cblxuY29uc3Qgc2hvcnQgPSBbXCJcXFxcc2hvcnRtaWRcIiwgXCJcXFxcbnNob3J0bWlkXCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIixcbiAgXCJcXFxcbnNob3J0cGFyYWxsZWxcIiwgXCJcXFxcc21hbGxzZXRtaW51c1wiXTtcblxuY29uc3QgYXJyb3dzID0gW1wiXFxcXFJzaFwiLCBcIlxcXFxMc2hcIiwgXCJcXFxccmVzdHJpY3Rpb25cIl07XG5cbmNvbnN0IGlzQXJyb3cgPSBzdHIgPT4ge1xuICBpZiAoc3RyLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHN0ci5jb2RlUG9pbnRBdCgwKTtcbiAgICByZXR1cm4gKDB4MjE4ZiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDIyMDApXG4gIH1cbiAgcmV0dXJuIHN0ci5pbmRleE9mKFwiYXJyb3dcIikgPiAtMSB8fCBzdHIuaW5kZXhPZihcImhhcnBvb25cIikgPiAtMSB8fCBhcnJvd3MuaW5jbHVkZXMoc3RyKVxufTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwiYXRvbVwiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlKV0pO1xuICAgIGlmIChncm91cC5mYW1pbHkgPT09IFwicHVuY3RcIikge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzZXBhcmF0b3JcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcIm9wZW5cIiB8fCBncm91cC5mYW1pbHkgPT09IFwiY2xvc2VcIikge1xuICAgICAgLy8gRGVsaW1zIGJ1aWx0IGhlcmUgc2hvdWxkIG5vdCBzdHJldGNoIHZlcnRpY2FsbHkuXG4gICAgICAvLyBTZWUgZGVsaW1zaXppbmcuanMgZm9yIHN0cmV0Y2h5IGRlbGltcy5cbiAgICAgIGlmIChncm91cC5mYW1pbHkgPT09IFwib3BlblwiKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBcInByZWZpeFwiKTtcbiAgICAgICAgLy8gU2V0IGFuIGV4cGxpY2l0IGF0dHJpYnV0ZSBmb3Igc3RyZXRjaC4gT3RoZXJ3aXNlIEZpcmVmb3ggbWF5IGRvIGl0IHdyb25nLlxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZm9ybVwiLCBcInBvc3RmaXhcIik7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJmYWxzZVwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLnRleHQgPT09IFwiXFxcXG1pZFwiKSB7XG4gICAgICAvLyBGaXJlZm94IG1lc3NlcyB1cCB0aGlzIHNwYWNpbmcgaWYgYXQgdGhlIGVuZCBvZiBhbiA8bXJvdz4uIFNlZSBpdCBleHBsaWNpdGx5LlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjIyZW1cIik7IC8vIG1lZGl1bSBzcGFjZVxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwLjIyZW1cIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwicmVsXCIgJiYgaXNBcnJvdyhncm91cC50ZXh0KSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgIH0gZWxzZSBpZiAoc2hvcnQuaW5jbHVkZXMoZ3JvdXAudGV4dCkpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHNpemVcIiwgXCI3MCVcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC50ZXh0ID09PSBcIjpcIikge1xuICAgICAgLy8gXCI6XCIgaXMgbm90IGluIHRoZSBNYXRoTUwgb3BlcmF0b3IgZGljdGlvbmFyeS4gR2l2ZSBpdCBCSU4gc3BhY2luZy5cbiAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjAuMjIyMmVtXCI7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gXCIwLjIyMjJlbVwiO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAubmVlZHNTcGFjaW5nKSB7XG4gICAgICAvLyBGaXggYSBNYXRoTUwgYnVnIHRoYXQgb2NjdXJzIHdoZW4gYSA8bW8+IGlzIGJldHdlZW4gdHdvIDxtdGV4dD4gZWxlbWVudHMuXG4gICAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcImJpblwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW3BhZGRpbmckMSgwLjIyMiksIG5vZGUsIHBhZGRpbmckMSgwLjIyMildKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUkVMIHNwYWNpbmdcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbcGFkZGluZyQxKDAuMjc3OCksIG5vZGUsIHBhZGRpbmckMSgwLjI3NzgpXSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIE1hcHMgVGVYIGZvbnQgY29tbWFuZHMgdG8gXCJtYXRodmFyaWFudFwiIGF0dHJpYnV0ZSBpbiBidWlsZE1hdGhNTC5qc1xuICovXG5jb25zdCBmb250TWFwID0ge1xuICAvLyBzdHlsZXNcbiAgbWF0aGJmOiBcImJvbGRcIixcbiAgbWF0aHJtOiBcIm5vcm1hbFwiLFxuICB0ZXh0aXQ6IFwiaXRhbGljXCIsXG4gIG1hdGhpdDogXCJpdGFsaWNcIixcbiAgbWF0aG5vcm1hbDogXCJpdGFsaWNcIixcblxuICAvLyBmYW1pbGllc1xuICBtYXRoYmI6IFwiZG91YmxlLXN0cnVja1wiLFxuICBtYXRoY2FsOiBcInNjcmlwdFwiLFxuICBtYXRoZnJhazogXCJmcmFrdHVyXCIsXG4gIG1hdGhzY3I6IFwic2NyaXB0XCIsXG4gIG1hdGhzZjogXCJzYW5zLXNlcmlmXCIsXG4gIG1hdGh0dDogXCJtb25vc3BhY2VcIlxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXRoIHZhcmlhbnQgYXMgYSBzdHJpbmcgb3IgbnVsbCBpZiBub25lIGlzIHJlcXVpcmVkLlxuICovXG5jb25zdCBnZXRWYXJpYW50ID0gZnVuY3Rpb24oZ3JvdXAsIHN0eWxlKSB7XG4gIC8vIEhhbmRsZSBmb250IHNwZWNpZmllcnMgYXMgYmVzdCB3ZSBjYW4uXG4gIC8vIENocm9taXVtIGRvZXMgbm90IHN1cHBvcnQgdGhlIE1hdGhNTCBtYXRodmFyaWFudCBhdHRyaWJ1dGUuXG4gIC8vIFNvIHdlJ2xsIHVzZSBVbmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaW5zdGVhZC5cbiAgLy8gQnV0IGZpcnN0LCBkZXRlcm1pbmUgdGhlIG1hdGggdmFyaWFudC5cblxuICAvLyBEZWFsIHdpdGggdGhlIFxcdGV4dGl0LCBcXHRleHRiZiwgZXRjLiwgZnVuY3Rpb25zLlxuICBpZiAoc3R5bGUuZm9udEZhbWlseSA9PT0gXCJ0ZXh0dHRcIikge1xuICAgIHJldHVybiBcIm1vbm9zcGFjZVwiXG4gIH0gZWxzZSBpZiAoc3R5bGUuZm9udEZhbWlseSA9PT0gXCJ0ZXh0c2NcIikge1xuICAgIHJldHVybiBcIm5vcm1hbFwiOyAvLyBoYW5kbGVkIHZpYSBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uIGluIHN5bWJvbHNPcmQuanMuXG4gIH0gZWxzZSBpZiAoc3R5bGUuZm9udEZhbWlseSA9PT0gXCJ0ZXh0c2ZcIikge1xuICAgIGlmIChzdHlsZS5mb250U2hhcGUgPT09IFwidGV4dGl0XCIgJiYgc3R5bGUuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiXG4gICAgfSBlbHNlIGlmIChzdHlsZS5mb250U2hhcGUgPT09IFwidGV4dGl0XCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtaXRhbGljXCJcbiAgICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtYm9sZFwiXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWZcIlxuICAgIH1cbiAgfSBlbHNlIGlmIChzdHlsZS5mb250U2hhcGUgPT09IFwidGV4dGl0XCIgJiYgc3R5bGUuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgIHJldHVybiBcImJvbGQtaXRhbGljXCJcbiAgfSBlbHNlIGlmIChzdHlsZS5mb250U2hhcGUgPT09IFwidGV4dGl0XCIpIHtcbiAgICByZXR1cm4gXCJpdGFsaWNcIlxuICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRXZWlnaHQgPT09IFwidGV4dGJmXCIpIHtcbiAgICByZXR1cm4gXCJib2xkXCJcbiAgfVxuXG4gIC8vIERlYWwgd2l0aCB0aGUgXFxtYXRoaXQsIG1hdGhiZiwgZXRjLCBmdW5jdGlvbnMuXG4gIGNvbnN0IGZvbnQgPSBzdHlsZS5mb250O1xuICBpZiAoIWZvbnQgfHwgZm9udCA9PT0gXCJtYXRobm9ybWFsXCIpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgbW9kZSA9IGdyb3VwLm1vZGU7XG4gIHN3aXRjaCAoZm9udCkge1xuICAgIGNhc2UgXCJtYXRoaXRcIjpcbiAgICAgIHJldHVybiBcIml0YWxpY1wiXG4gICAgY2FzZSBcIm1hdGhybVwiOiB7XG4gICAgICBjb25zdCBjb2RlUG9pbnQgPSBncm91cC50ZXh0LmNvZGVQb2ludEF0KDApO1xuICAgICAgLy8gTGFUZVggXFxtYXRocm0gcmV0dXJucyBpdGFsaWMgZm9yIEdyZWVrIGNoYXJhY3RlcnMuXG4gICAgICByZXR1cm4gICgweDAzYWIgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgwM2NmKSA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiXG4gICAgfVxuICAgIGNhc2UgXCJncmVla0l0YWxpY1wiOlxuICAgICAgcmV0dXJuIFwiaXRhbGljXCJcbiAgICBjYXNlIFwidXBAZ3JlZWtcIjpcbiAgICAgIHJldHVybiBcIm5vcm1hbFwiXG4gICAgY2FzZSBcImJvbGRzeW1ib2xcIjpcbiAgICBjYXNlIFwibWF0aGJvbGRzeW1ib2xcIjpcbiAgICAgIHJldHVybiBcImJvbGQtaXRhbGljXCJcbiAgICBjYXNlIFwibWF0aGJmXCI6XG4gICAgICByZXR1cm4gXCJib2xkXCJcbiAgICBjYXNlIFwibWF0aGJiXCI6XG4gICAgICByZXR1cm4gXCJkb3VibGUtc3RydWNrXCJcbiAgICBjYXNlIFwibWF0aGZyYWtcIjpcbiAgICAgIHJldHVybiBcImZyYWt0dXJcIlxuICAgIGNhc2UgXCJtYXRoc2NyXCI6XG4gICAgY2FzZSBcIm1hdGhjYWxcIjpcbiAgICAgIHJldHVybiBcInNjcmlwdFwiXG4gICAgY2FzZSBcIm1hdGhzZlwiOlxuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiXG4gICAgY2FzZSBcIm1hdGhzZml0XCI6XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWl0YWxpY1wiXG4gICAgY2FzZSBcIm1hdGh0dFwiOlxuICAgICAgcmV0dXJuIFwibW9ub3NwYWNlXCJcbiAgfVxuXG4gIGxldCB0ZXh0ID0gZ3JvdXAudGV4dDtcbiAgaWYgKHN5bWJvbHNbbW9kZV1bdGV4dF0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlKSB7XG4gICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZm9udE1hcCwgZm9udCkgPyBmb250TWFwW2ZvbnRdIDogbnVsbFxufTtcblxuLy8gQ2hyb21pdW0gZG9lcyBub3Qgc3VwcG9ydCB0aGUgTWF0aE1MIGBtYXRodmFyaWFudGAgYXR0cmlidXRlLlxuLy8gSW5zdGVhZCwgd2UgcmVwbGFjZSBBU0NJSSBjaGFyYWN0ZXJzIHdpdGggVW5pY29kZSBjaGFyYWN0ZXJzIHRoYXRcbi8vIGFyZSBkZWZpbmVkIGluIHRoZSBmb250IGFzIGJvbGQsIGl0YWxpYywgZG91YmxlLXN0cnVjaywgZXRjLlxuLy8gVGhpcyBtb2R1bGUgaWRlbnRpZmllcyB0aG9zZSBVbmljb2RlIGNvZGUgcG9pbnRzLlxuXG4vLyBGaXJzdCwgYSBmZXcgaGVscGVycy5cbmNvbnN0IHNjcmlwdCA9IE9iamVjdC5mcmVlemUoe1xuICBCOiAweDIwRUEsIC8vIE9mZnNldCBmcm9tIEFTQ0lJIEIgdG8gVW5pY29kZSBzY3JpcHQgQlxuICBFOiAweDIwRUIsXG4gIEY6IDB4MjBFQixcbiAgSDogMHgyMEMzLFxuICBJOiAweDIwQzcsXG4gIEw6IDB4MjBDNixcbiAgTTogMHgyMEU2LFxuICBSOiAweDIwQzksXG4gIGU6IDB4MjBDQSxcbiAgZzogMHgyMEEzLFxuICBvOiAweDIwQzVcbn0pO1xuXG5jb25zdCBmcmFrID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEM6IDB4MjBFQSxcbiAgSDogMHgyMEM0LFxuICBJOiAweDIwQzgsXG4gIFI6IDB4MjBDQSxcbiAgWjogMHgyMENFXG59KTtcblxuY29uc3QgYmJiID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEM6IDB4MjBCRiwgLy8gYmxhY2tib2FyZCBib2xkXG4gIEg6IDB4MjBDNSxcbiAgTjogMHgyMEM3LFxuICBQOiAweDIwQzksXG4gIFE6IDB4MjBDOSxcbiAgUjogMHgyMENCLFxuICBaOiAweDIwQ0Fcbn0pO1xuXG5jb25zdCBib2xkID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFwiXFx1MDNmNVwiOiAweDFEMkU3LCAvLyBsdW5hdGUgZXBzaWxvblxuICBcIlxcdTAzZDFcIjogMHgxRDMwQywgLy8gdmFydGhldGFcbiAgXCJcXHUwM2YwXCI6IDB4MUQyRUUsIC8vIHZhcmthcHBhXG4gIFwiXFx1MDNjNlwiOiAweDFEMzE5LCAvLyB2YXJwaGlcbiAgXCJcXHUwM2YxXCI6IDB4MUQyRUYsIC8vIHZhcnJob1xuICBcIlxcdTAzZDZcIjogMHgxRDMwQiAgLy8gdmFycGlcbn0pO1xuXG5jb25zdCBib2xkSXRhbGljID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFwiXFx1MDNmNVwiOiAweDFEMzVCLCAvLyBsdW5hdGUgZXBzaWxvblxuICBcIlxcdTAzZDFcIjogMHgxRDM4MCwgLy8gdmFydGhldGFcbiAgXCJcXHUwM2YwXCI6IDB4MUQzNjIsIC8vIHZhcmthcHBhXG4gIFwiXFx1MDNjNlwiOiAweDFEMzhELCAvLyB2YXJwaGlcbiAgXCJcXHUwM2YxXCI6IDB4MUQzNjMsIC8vIHZhcnJob1xuICBcIlxcdTAzZDZcIjogMHgxRDM3RiAgLy8gdmFycGlcbn0pO1xuXG5jb25zdCBib2xkc2YgPSBPYmplY3QuZnJlZXplKHtcbiAgXCJcXHUwM2Y1XCI6IDB4MUQzOTUsIC8vIGx1bmF0ZSBlcHNpbG9uXG4gIFwiXFx1MDNkMVwiOiAweDFEM0JBLCAvLyB2YXJ0aGV0YVxuICBcIlxcdTAzZjBcIjogMHgxRDM5QywgLy8gdmFya2FwcGFcbiAgXCJcXHUwM2M2XCI6IDB4MUQzQzcsIC8vIHZhcnBoaVxuICBcIlxcdTAzZjFcIjogMHgxRDM5RCwgLy8gdmFycmhvXG4gIFwiXFx1MDNkNlwiOiAweDFEM0I5ICAvLyB2YXJwaVxufSk7XG5cbmNvbnN0IGJpc2YgPSBPYmplY3QuZnJlZXplKHtcbiAgXCJcXHUwM2Y1XCI6IDB4MUQzQ0YsIC8vIGx1bmF0ZSBlcHNpbG9uXG4gIFwiXFx1MDNkMVwiOiAweDFEM0Y0LCAvLyB2YXJ0aGV0YVxuICBcIlxcdTAzZjBcIjogMHgxRDNENiwgLy8gdmFya2FwcGFcbiAgXCJcXHUwM2M2XCI6IDB4MUQ0MDEsIC8vIHZhcnBoaVxuICBcIlxcdTAzZjFcIjogMHgxRDNENywgLy8gdmFycmhvXG4gIFwiXFx1MDNkNlwiOiAweDFEM0YzICAvLyB2YXJwaVxufSk7XG5cbi8vIENvZGUgcG9pbnQgb2Zmc2V0cyBiZWxvdyBhcmUgZGVyaXZlZCBmcm9tIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL2NoYXJ0cy9QREYvVTFENDAwLnBkZlxuY29uc3Qgb2Zmc2V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHVwcGVyQ2FzZUxhdGluOiB7IC8vIEEtWlxuICAgIFwibm9ybWFsXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkXCI6IGNoID0+ICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzQkYgfSxcbiAgICBcIml0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDNGMyB9LFxuICAgIFwiYm9sZC1pdGFsaWNcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAweDFENDI3IH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIHNjcmlwdFtjaF0gfHwgMHgxRDQ1QiB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAweDFENDhGIH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIGZyYWtbY2hdIHx8IDB4MUQ0QzMgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMHgxRDUyQiB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiBiYmJbY2hdIHx8IDB4MUQ0RjcgfSxcbiAgICBcInNhbnMtc2VyaWZcIjogY2ggPT4gICAgICAgICAgICAgeyByZXR1cm4gMHgxRDU1RiB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkXCI6IGNoID0+ICAgICAgICB7IHJldHVybiAweDFENTkzIH0sXG4gICAgXCJzYW5zLXNlcmlmLWl0YWxpY1wiOiBjaCA9PiAgICAgIHsgcmV0dXJuIDB4MUQ1QzcgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjogY2ggPT4geyByZXR1cm4gMHgxRDYzQyB9LFxuICAgIFwibW9ub3NwYWNlXCI6IGNoID0+ICAgICAgICAgICAgICB7IHJldHVybiAweDFENjJGIH1cbiAgfSxcbiAgbG93ZXJDYXNlTGF0aW46IHsgLy8gYS16XG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDNCOSB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiBjaCA9PT0gXCJoXCIgPyAweDIwQTYgOiAweDFEM0VEIH0sXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ0MjEgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gc2NyaXB0W2NoXSB8fCAweDFENDU1IH0sXG4gICAgXCJzY3JpcHQtYm9sZFwiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ0ODkgfSxcbiAgICBcImZyYWt0dXJcIjogY2ggPT4gICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDRCRCB9LFxuICAgIFwiZnJha3R1ci1ib2xkXCI6IGNoID0+ICAgICAgICAgICB7IHJldHVybiAweDFENTI1IH0sXG4gICAgXCJkb3VibGUtc3RydWNrXCI6IGNoID0+ICAgICAgICAgIHsgcmV0dXJuIDB4MUQ0RjEgfSxcbiAgICBcInNhbnMtc2VyaWZcIjogY2ggPT4gICAgICAgICAgICAgeyByZXR1cm4gMHgxRDU1OSB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkXCI6IGNoID0+ICAgICAgICB7IHJldHVybiAweDFENThEIH0sXG4gICAgXCJzYW5zLXNlcmlmLWl0YWxpY1wiOiBjaCA9PiAgICAgIHsgcmV0dXJuIDB4MUQ1QzEgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjogY2ggPT4geyByZXR1cm4gMHgxRDVGNSB9LFxuICAgIFwibW9ub3NwYWNlXCI6IGNoID0+ICAgICAgICAgICAgICB7IHJldHVybiAweDFENjI5IH1cbiAgfSxcbiAgdXBwZXJDYXNlR3JlZWs6IHsgLy8gQS3OqVxuICAgIFwibm9ybWFsXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkXCI6IGNoID0+ICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzMTcgfSxcbiAgICBcIml0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDM1MSB9LFxuICAgIC8vIFxcYm9sZHN5bWJvbCBhY3R1YWxseSByZXR1cm5zIHVwcmlnaHQgYm9sZCBmb3IgdXBwZXJDYXNlR3JlZWtcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMHgxRDMxNyB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzY3JpcHQtYm9sZFwiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXJcIjogY2ggPT4gICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1ci1ib2xkXCI6IGNoID0+ICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJkb3VibGUtc3RydWNrXCI6IGNoID0+ICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICAvLyBVbmljb2RlIGhhcyBubyBjb2RlIHBvaW50cyBmb3IgcmVndWxhci13ZWlnaHQgc2FuLXNlcmlmIEdyZWVrLiBVc2UgYm9sZC5cbiAgICBcInNhbnMtc2VyaWZcIjogY2ggPT4gICAgICAgICAgICAgeyByZXR1cm4gMHgxRDNDNSB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkXCI6IGNoID0+ICAgICAgICB7IHJldHVybiAweDFEM0M1IH0sXG4gICAgXCJzYW5zLXNlcmlmLWl0YWxpY1wiOiBjaCA9PiAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjogY2ggPT4geyByZXR1cm4gMHgxRDNGRiB9LFxuICAgIFwibW9ub3NwYWNlXCI6IGNoID0+ICAgICAgICAgICAgICB7IHJldHVybiAwIH1cbiAgfSxcbiAgbG93ZXJDYXNlR3JlZWs6IHsgLy8gzrEtz4lcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEMzExIH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzNEIgfSxcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gY2ggPT09IFwiXFx1MDNkNVwiID8gMHgxRDM3RSA6IDB4MUQzODUgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgLy8gVW5pY29kZSBoYXMgbm8gY29kZSBwb2ludHMgZm9yIHJlZ3VsYXItd2VpZ2h0IHNhbi1zZXJpZiBHcmVlay4gVXNlIGJvbGQuXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzQkYgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gMHgxRDNCRiB9LFxuICAgIFwic2Fucy1zZXJpZi1pdGFsaWNcIjogY2ggPT4gICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6IGNoID0+IHsgcmV0dXJuIDB4MUQzRjkgfSxcbiAgICBcIm1vbm9zcGFjZVwiOiBjaCA9PiAgICAgICAgICAgICAgeyByZXR1cm4gMCB9XG4gIH0sXG4gIHZhckdyZWVrOiB7IC8vIFxcdmFyR2FtbWEsIGV0Y1xuICAgIFwibm9ybWFsXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkXCI6IGNoID0+ICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuICBib2xkW2NoXSB8fCAtNTEgfSxcbiAgICBcIml0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZC1pdGFsaWNcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiBib2xkSXRhbGljW2NoXSB8fCAweDNBIH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2Fucy1zZXJpZlwiOiBjaCA9PiAgICAgICAgICAgICB7IHJldHVybiBib2xkc2ZbY2hdIHx8IDB4NzQgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZFwiOiBjaCA9PiAgICAgICAgeyByZXR1cm4gYm9sZHNmW2NoXSB8fCAweDc0IH0sXG4gICAgXCJzYW5zLXNlcmlmLWl0YWxpY1wiOiBjaCA9PiAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjogY2ggPT4geyByZXR1cm4gYmlzZltjaF0gfHwgMHhBRSB9LFxuICAgIFwibW9ub3NwYWNlXCI6IGNoID0+ICAgICAgICAgICAgICB7IHJldHVybiAwIH1cbiAgfSxcbiAgbnVtZXJhbDogeyAvLyAwLTlcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFENzlFIH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzY3JpcHQtYm9sZFwiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXJcIjogY2ggPT4gICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1ci1ib2xkXCI6IGNoID0+ICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJkb3VibGUtc3RydWNrXCI6IGNoID0+ICAgICAgICAgIHsgcmV0dXJuIDB4MUQ3QTggfSxcbiAgICBcInNhbnMtc2VyaWZcIjogY2ggPT4gICAgICAgICAgICAgeyByZXR1cm4gMHgxRDdCMiB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkXCI6IGNoID0+ICAgICAgICB7IHJldHVybiAweDFEN0JDIH0sXG4gICAgXCJzYW5zLXNlcmlmLWl0YWxpY1wiOiBjaCA9PiAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjogY2ggPT4geyByZXR1cm4gMCB9LFxuICAgIFwibW9ub3NwYWNlXCI6IGNoID0+ICAgICAgICAgICAgICB7IHJldHVybiAweDFEN0M2IH1cbiAgfVxufSk7XG5cbmNvbnN0IHZhcmlhbnRDaGFyID0gKGNoLCB2YXJpYW50KSA9PiB7XG4gIGNvbnN0IGNvZGVQb2ludCA9IGNoLmNvZGVQb2ludEF0KDApO1xuICBjb25zdCBibG9jayA9IDB4NDAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHg1YlxuICAgID8gXCJ1cHBlckNhc2VMYXRpblwiXG4gICAgOiAweDYwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4N2JcbiAgICA/IFwibG93ZXJDYXNlTGF0aW5cIlxuICAgIDogKDB4MzkwICA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDNBQSlcbiAgICA/IFwidXBwZXJDYXNlR3JlZWtcIlxuICAgIDogMHgzQjAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgzQ0EgfHwgY2ggPT09IFwiXFx1MDNkNVwiXG4gICAgPyBcImxvd2VyQ2FzZUdyZWVrXCJcbiAgICA6IDB4MUQ2RTEgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHgxRDZGQyAgfHwgYm9sZFtjaF1cbiAgICA/IFwidmFyR3JlZWtcIlxuICAgIDogKDB4MkYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgIDB4M0EpXG4gICAgPyBcIm51bWVyYWxcIlxuICAgIDogXCJvdGhlclwiO1xuICByZXR1cm4gYmxvY2sgPT09IFwib3RoZXJcIlxuICAgID8gY2hcbiAgICA6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCArIG9mZnNldFtibG9ja11bdmFyaWFudF0oY2gpKVxufTtcblxuY29uc3Qgc21hbGxDYXBzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGE6IFwi4bSAXCIsXG4gIGI6IFwiyplcIixcbiAgYzogXCLhtIRcIixcbiAgZDogXCLhtIVcIixcbiAgZTogXCLhtIdcIixcbiAgZjogXCLqnLBcIixcbiAgZzogXCLJolwiLFxuICBoOiBcIsqcXCIsXG4gIGk6IFwiyapcIixcbiAgajogXCLhtIpcIixcbiAgazogXCLhtItcIixcbiAgbDogXCLKn1wiLFxuICBtOiBcIuG0jVwiLFxuICBuOiBcIsm0XCIsXG4gIG86IFwi4bSPXCIsXG4gIHA6IFwi4bSYXCIsXG4gIHE6IFwix6tcIixcbiAgcjogXCLKgFwiLFxuICBzOiBcInNcIixcbiAgdDogXCLhtJtcIixcbiAgdTogXCLhtJxcIixcbiAgdjogXCLhtKBcIixcbiAgdzogXCLhtKFcIixcbiAgeDogXCJ4XCIsXG4gIHk6IFwiyo9cIixcbiAgejogXCLhtKJcIlxufSk7XG5cbi8vIFwibWF0aG9yZFwiIGFuZCBcInRleHRvcmRcIiBQYXJzZU5vZGVzIGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gc3ltYm9sIEdyb3VwcyBpblxuLy8gc3JjL3N5bWJvbHMuanMuXG5cbmNvbnN0IG51bWJlclJlZ0V4ID0gL15cXGQoPzpbXFxkLC5dKlxcZCk/JC87XG5jb25zdCBsYXRpblJlZ0V4ID0gL1tBLUJhLXpdLztcbmNvbnN0IHByaW1lcyA9IG5ldyBTZXQoW1wiXFxcXHByaW1lXCIsIFwiXFxcXGRwcmltZVwiLCBcIlxcXFx0cnByaW1lXCIsIFwiXFxcXHFwcmltZVwiLFxuICBcIlxcXFxiYWNrcHJpbWVcIiwgXCJcXFxcYmFja2RwcmltZVwiLCBcIlxcXFxiYWNrdHJwcmltZVwiXSk7XG5cbmNvbnN0IGl0YWxpY051bWJlciA9ICh0ZXh0LCB2YXJpYW50LCB0YWcpID0+IHtcbiAgY29uc3QgbW4gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSh0YWcsIFt0ZXh0XSk7XG4gIGNvbnN0IHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBbbW5dKTtcbiAgd3JhcHBlci5zdHlsZVtcImZvbnQtc3R5bGVcIl0gPSBcIml0YWxpY1wiO1xuICB3cmFwcGVyLnN0eWxlW1wiZm9udC1mYW1pbHlcIl0gPSBcIkNhbWJyaWEsICdUaW1lcyBOZXcgUm9tYW4nLCBzZXJpZlwiO1xuICBpZiAodmFyaWFudCA9PT0gXCJib2xkLWl0YWxpY1wiKSB7IHdyYXBwZXIuc3R5bGVbXCJmb250LXdlaWdodFwiXSA9IFwiYm9sZFwiOyB9XG4gIHJldHVybiB3cmFwcGVyXG59O1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJtYXRob3JkXCIsXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgdGV4dCA9IG1ha2VUZXh0KGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIHN0eWxlKTtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSB0ZXh0LnRleHQuY29kZVBvaW50QXQoMCk7XG4gICAgLy8gVGVzdCBmb3IgdXBwZXItY2FzZSBHcmVla1xuICAgIGNvbnN0IGRlZmF1bHRWYXJpYW50ID0gKDB4MDM5MCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDAzYWEpID8gXCJub3JtYWxcIiA6IFwiaXRhbGljXCI7XG4gICAgY29uc3QgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIHN0eWxlKSB8fCBkZWZhdWx0VmFyaWFudDtcbiAgICBpZiAodmFyaWFudCA9PT0gXCJzY3JpcHRcIikge1xuICAgICAgdGV4dC50ZXh0ID0gdmFyaWFudENoYXIodGV4dC50ZXh0LCB2YXJpYW50KTtcbiAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSwgW3N0eWxlLmZvbnRdKVxuICAgIH0gZWxzZSBpZiAodmFyaWFudCAhPT0gXCJpdGFsaWNcIikge1xuICAgICAgdGV4dC50ZXh0ID0gdmFyaWFudENoYXIodGV4dC50ZXh0LCB2YXJpYW50KTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSk7XG4gICAgLy8gVE9ETzogSGFuZGxlIFUrMUQ0OUMgLSBVKzFENENGIHBlciBodHRwczovL3d3dy51bmljb2RlLm9yZy9jaGFydHMvUERGL1UxRDQwMC5wZGZcbiAgICBpZiAodmFyaWFudCA9PT0gXCJub3JtYWxcIikge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIm5vcm1hbFwiKTtcbiAgICAgIGlmICh0ZXh0LnRleHQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEEgRmlyZWZveCBidWcgd2lsbCBhcHBseSBzcGFjaW5nIGhlcmUsIGJ1dCB0aGVyZSBzaG91bGQgYmUgbm9uZS4gRml4IGl0LlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtub2RlXSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMFwiKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwidGV4dG9yZFwiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGxldCBjaCA9IGdyb3VwLnRleHQ7XG4gICAgY29uc3QgY29kZVBvaW50ID0gY2guY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKHN0eWxlLmZvbnRGYW1pbHkgPT09IFwidGV4dHNjXCIpIHtcbiAgICAgIC8vIENvbnZlcnQgc21hbGwgbGF0aW4gbGV0dGVycyB0byBzbWFsbCBjYXBzLlxuICAgICAgaWYgKDk2IDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDEyMykge1xuICAgICAgICBjaCA9IHNtYWxsQ2Fwc1tjaF07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBtYWtlVGV4dChjaCwgZ3JvdXAubW9kZSwgc3R5bGUpO1xuICAgIGNvbnN0IHZhcmlhbnQgPSBnZXRWYXJpYW50KGdyb3VwLCBzdHlsZSkgfHwgXCJub3JtYWxcIjtcblxuICAgIGxldCBub2RlO1xuICAgIGlmIChudW1iZXJSZWdFeC50ZXN0KGdyb3VwLnRleHQpKSB7XG4gICAgICBjb25zdCB0YWcgPSBncm91cC5tb2RlID09PSBcInRleHRcIiA/IFwibXRleHRcIiA6IFwibW5cIjtcbiAgICAgIGlmICh2YXJpYW50ID09PSBcIml0YWxpY1wiIHx8IHZhcmlhbnQgPT09IFwiYm9sZC1pdGFsaWNcIikge1xuICAgICAgICByZXR1cm4gaXRhbGljTnVtYmVyKHRleHQsIHZhcmlhbnQsIHRhZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YXJpYW50ICE9PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgdGV4dC50ZXh0ID0gdGV4dC50ZXh0LnNwbGl0KFwiXCIpLm1hcChjID0+IHZhcmlhbnRDaGFyKGMsIHZhcmlhbnQpKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSh0YWcsIFt0ZXh0XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgaWYgKHZhcmlhbnQgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgdGV4dC50ZXh0ID0gdmFyaWFudENoYXIodGV4dC50ZXh0LCB2YXJpYW50KTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFt0ZXh0XSk7XG4gICAgfSBlbHNlIGlmIChwcmltZXMuaGFzKGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbdGV4dF0pO1xuICAgICAgLy8gVE9ETzogSWYvd2hlbiBDaHJvbWl1bSB1c2VzIHNzdHkgdmFyaWFudCBmb3IgcHJpbWUsIHJlbW92ZSB0aGUgbmV4dCBsaW5lLlxuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJ0bWwtcHJpbWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9yaWdUZXh0ID0gdGV4dC50ZXh0O1xuICAgICAgaWYgKHZhcmlhbnQgIT09IFwiaXRhbGljXCIpIHtcbiAgICAgICAgdGV4dC50ZXh0ID0gdmFyaWFudENoYXIodGV4dC50ZXh0LCB2YXJpYW50KTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSk7XG4gICAgICBpZiAodGV4dC50ZXh0ID09PSBvcmlnVGV4dCAmJiBsYXRpblJlZ0V4LnRlc3Qob3JpZ1RleHQpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJpdGFsaWNcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG4vLyBBIG1hcCBvZiBDU1MtYmFzZWQgc3BhY2luZyBmdW5jdGlvbnMgdG8gdGhlaXIgQ1NTIGNsYXNzLlxuY29uc3QgY3NzU3BhY2UgPSB7XG4gIFwiXFxcXG5vYnJlYWtcIjogXCJub2JyZWFrXCIsXG4gIFwiXFxcXGFsbG93YnJlYWtcIjogXCJhbGxvd2JyZWFrXCJcbn07XG5cbi8vIEEgbG9va3VwIHRhYmxlIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc3BhY2luZyBmdW5jdGlvbi9zeW1ib2wgc2hvdWxkIGJlXG4vLyB0cmVhdGVkIGxpa2UgYSByZWd1bGFyIHNwYWNlIGNoYXJhY3Rlci4gIElmIGEgc3ltYm9sIG9yIGNvbW1hbmQgaXMgYSBrZXlcbi8vIGluIHRoaXMgdGFibGUsIHRoZW4gaXQgc2hvdWxkIGJlIGEgcmVndWxhciBzcGFjZSBjaGFyYWN0ZXIuICBGdXJ0aGVybW9yZSxcbi8vIHRoZSBhc3NvY2lhdGVkIHZhbHVlIG1heSBoYXZlIGEgYGNsYXNzTmFtZWAgc3BlY2lmeWluZyBhbiBleHRyYSBDU1MgY2xhc3Ncbi8vIHRvIGFkZCB0byB0aGUgY3JlYXRlZCBgc3BhbmAuXG5jb25zdCByZWd1bGFyU3BhY2UgPSB7XG4gIFwiIFwiOiB7fSxcbiAgXCJcXFxcIFwiOiB7fSxcbiAgXCJ+XCI6IHtcbiAgICBjbGFzc05hbWU6IFwibm9icmVha1wiXG4gIH0sXG4gIFwiXFxcXHNwYWNlXCI6IHt9LFxuICBcIlxcXFxub2JyZWFrc3BhY2VcIjoge1xuICAgIGNsYXNzTmFtZTogXCJub2JyZWFrXCJcbiAgfVxufTtcblxuLy8gUGFyc2VOb2RlPFwic3BhY2luZ1wiPiBjcmVhdGVkIGluIFBhcnNlci5qcyBmcm9tIHRoZSBcInNwYWNpbmdcIiBzeW1ib2wgR3JvdXBzIGluXG4vLyBzcmMvc3ltYm9scy5qcy5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInNwYWNpbmdcIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBsZXQgbm9kZTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVndWxhclNwYWNlLCBncm91cC50ZXh0KSkge1xuICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCByZW5kZXIgYSBzcGFjZSBpbiBhIDxtdGV4dD4gPC9tdGV4dD4uIFNvIHdyaXRlIGEgbm8tYnJlYWsgc3BhY2UuXG4gICAgICAvLyBUT0RPOiBJZiBGaXJlZm94IGZpeGVzIHRoYXQgYnVnLCB1bmNvbW1lbnQgdGhlIG5leHQgbGluZSBhbmQgd3JpdGUgY2ggaW50byB0aGUgbm9kZS5cbiAgICAgIC8vY29uc3QgY2ggPSAocmVndWxhclNwYWNlW2dyb3VwLnRleHRdLmNsYXNzTmFtZSA9PT0gXCJub2JyZWFrXCIpID8gXCJcXHUwMGEwXCIgOiBcIiBcIlxuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MDBhMFwiKV0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNzc1NwYWNlLCBncm91cC50ZXh0KSkge1xuICAgICAgLy8gTWF0aE1MIDMuMCBjYWxscyBmb3Igbm9icmVhayB0byBvY2N1ciBpbiBhbiA8bW8+LCBub3QgYW4gPG10ZXh0PlxuICAgICAgLy8gUmVmOiBodHRwczovL3d3dy53My5vcmcvTWF0aC9kcmFmdC1zcGVjL21hdGhtbC5odG1sI2NoYXB0ZXIzX3ByZXNtLmxiYXR0cnNcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIpO1xuICAgICAgaWYgKGdyb3VwLnRleHQgPT09IFwiXFxcXG5vYnJlYWtcIikge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmVicmVha1wiLCBcIm5vYnJlYWtcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBVbmtub3duIHR5cGUgb2Ygc3BhY2UgXCIke2dyb3VwLnRleHR9XCJgKVxuICAgIH1cblxuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJ0YWdcIlxufSk7XG5cbi8vIEZvciBhIFxcdGFnLCB0aGUgd29yayB1c3VhbGx5IGRvbmUgaW4gYSBtYXRobWxCdWlsZGVyIGlzIGluc3RlYWQgZG9uZSBpbiBidWlsZE1hdGhNTC5qcy5cbi8vIFRoYXQgd2F5LCBhIFxcdGFnIGNhbiBiZSBwdWxsZWQgb3V0IG9mIHRoZSBwYXJzZSB0cmVlIGFuZCB3cmFwcGVkIGFyb3VuZCB0aGUgb3V0ZXIgbm9kZS5cblxuLy8gTm9uLW1hdGh5IHRleHQsIHBvc3NpYmx5IGluIGEgZm9udFxuY29uc3QgdGV4dEZvbnRGYW1pbGllcyA9IHtcbiAgXCJcXFxcdGV4dFwiOiB1bmRlZmluZWQsXG4gIFwiXFxcXHRleHRybVwiOiBcInRleHRybVwiLFxuICBcIlxcXFx0ZXh0c2ZcIjogXCJ0ZXh0c2ZcIixcbiAgXCJcXFxcdGV4dHR0XCI6IFwidGV4dHR0XCIsXG4gIFwiXFxcXHRleHRub3JtYWxcIjogXCJ0ZXh0cm1cIixcbiAgXCJcXFxcdGV4dHNjXCI6IFwidGV4dHNjXCIgICAgICAvLyBzbWFsbCBjYXBzXG59O1xuXG5jb25zdCB0ZXh0Rm9udFdlaWdodHMgPSB7XG4gIFwiXFxcXHRleHRiZlwiOiBcInRleHRiZlwiLFxuICBcIlxcXFx0ZXh0bWRcIjogXCJ0ZXh0bWRcIlxufTtcblxuY29uc3QgdGV4dEZvbnRTaGFwZXMgPSB7XG4gIFwiXFxcXHRleHRpdFwiOiBcInRleHRpdFwiLFxuICBcIlxcXFx0ZXh0dXBcIjogXCJ0ZXh0dXBcIlxufTtcblxuY29uc3Qgc3R5bGVXaXRoRm9udCA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgY29uc3QgZm9udCA9IGdyb3VwLmZvbnQ7XG4gIC8vIENoZWNrcyBpZiB0aGUgYXJndW1lbnQgaXMgYSBmb250IGZhbWlseSBvciBhIGZvbnQgc3R5bGUuXG4gIGlmICghZm9udCkge1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSBlbHNlIGlmICh0ZXh0Rm9udEZhbWlsaWVzW2ZvbnRdKSB7XG4gICAgcmV0dXJuIHN0eWxlLndpdGhUZXh0Rm9udEZhbWlseSh0ZXh0Rm9udEZhbWlsaWVzW2ZvbnRdKTtcbiAgfSBlbHNlIGlmICh0ZXh0Rm9udFdlaWdodHNbZm9udF0pIHtcbiAgICByZXR1cm4gc3R5bGUud2l0aFRleHRGb250V2VpZ2h0KHRleHRGb250V2VpZ2h0c1tmb250XSk7XG4gIH0gZWxzZSBpZiAoZm9udCA9PT0gXCJcXFxcZW1waFwiKSB7XG4gICAgcmV0dXJuIHN0eWxlLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIlxuICAgICAgPyBzdHlsZS53aXRoVGV4dEZvbnRTaGFwZShcInRleHR1cFwiKVxuICAgICAgOiBzdHlsZS53aXRoVGV4dEZvbnRTaGFwZShcInRleHRpdFwiKVxuICB9XG4gIHJldHVybiBzdHlsZS53aXRoVGV4dEZvbnRTaGFwZSh0ZXh0Rm9udFNoYXBlc1tmb250XSlcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0XCIsXG4gIG5hbWVzOiBbXG4gICAgLy8gRm9udCBmYW1pbGllc1xuICAgIFwiXFxcXHRleHRcIixcbiAgICBcIlxcXFx0ZXh0cm1cIixcbiAgICBcIlxcXFx0ZXh0c2ZcIixcbiAgICBcIlxcXFx0ZXh0dHRcIixcbiAgICBcIlxcXFx0ZXh0bm9ybWFsXCIsXG4gICAgXCJcXFxcdGV4dHNjXCIsXG4gICAgLy8gRm9udCB3ZWlnaHRzXG4gICAgXCJcXFxcdGV4dGJmXCIsXG4gICAgXCJcXFxcdGV4dG1kXCIsXG4gICAgLy8gRm9udCBTaGFwZXNcbiAgICBcIlxcXFx0ZXh0aXRcIixcbiAgICBcIlxcXFx0ZXh0dXBcIixcbiAgICBcIlxcXFxlbXBoXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSksXG4gICAgICBmb250OiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZVdpdGhGb250KGdyb3VwLCBzdHlsZSk7XG4gICAgY29uc3QgbXJvdyA9IGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBuZXdTdHlsZSk7XG4gICAgcmV0dXJuIGNvbnNvbGlkYXRlVGV4dChtcm93KVxuICB9XG59KTtcblxuLy8gXFx2Y2VudGVyOiAgVmVydGljYWxseSBjZW50ZXIgdGhlIGFyZ3VtZW50IGdyb3VwIG9uIHRoZSBtYXRoIGF4aXMuXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2Y2VudGVyXCIsXG4gIG5hbWVzOiBbXCJcXFxcdmNlbnRlclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJvcmlnaW5hbFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ2Y2VudGVyXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF1cbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIC8vIFVzZSBhIG1hdGggdGFibGUgdG8gY3JlYXRlIHZlcnRpY2FsbHkgY2VudGVyZWQgY29udGVudC5cbiAgICBjb25zdCBtdGQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIHN0eWxlKV0pO1xuICAgIG10ZC5zdHlsZS5wYWRkaW5nID0gXCIwXCI7XG4gICAgY29uc3QgbXRyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgW210ZF0pO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCBbbXRyXSlcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ2ZXJiXCIsXG4gIG5hbWVzOiBbXCJcXFxcdmVyYlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgLy8gXFx2ZXJiIGFuZCBcXHZlcmIqIGFyZSBkZWFsdCB3aXRoIGRpcmVjdGx5IGluIFBhcnNlci5qcy5cbiAgICAvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXQncyBiZWNhdXNlIG9mIGEgZmFpbHVyZSB0byBtYXRjaCB0aGUgdHdvIGRlbGltaXRlcnNcbiAgICAvLyBpbiB0aGUgcmVnZXggaW4gTGV4ZXIuanMuICBMYVRlWCByYWlzZXMgdGhlIGZvbGxvd2luZyBlcnJvciB3aGVuIFxcdmVyYiBpc1xuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIGxpbmUgKG9yIGZpbGUpLlxuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXHZlcmIgZW5kZWQgYnkgZW5kIG9mIGxpbmUgaW5zdGVhZCBvZiBtYXRjaGluZyBkZWxpbWl0ZXJcIik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKG1ha2VWZXJiKGdyb3VwKSk7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW3RleHRdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwibW9ub3NwYWNlXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB2ZXJiIGdyb3VwIGludG8gYm9keSBzdHJpbmcuXG4gKlxuICogXFx2ZXJiKiByZXBsYWNlcyBlYWNoIHNwYWNlIHdpdGggYW4gb3BlbiBib3ggXFx1MjQyM1xuICogXFx2ZXJiIHJlcGxhY2VzIGVhY2ggc3BhY2Ugd2l0aCBhIG5vLWJyZWFrIHNwYWNlIFxceEEwXG4gKi9cbmNvbnN0IG1ha2VWZXJiID0gKGdyb3VwKSA9PiBncm91cC5ib2R5LnJlcGxhY2UoLyAvZywgZ3JvdXAuc3RhciA/IFwiXFx1MjQyM1wiIDogXCJcXHhBMFwiKTtcblxuLyoqIEluY2x1ZGUgdGhpcyB0byBlbnN1cmUgdGhhdCBhbGwgZnVuY3Rpb25zIGFyZSBkZWZpbmVkLiAqL1xuXG5jb25zdCBmdW5jdGlvbnMgPSBfZnVuY3Rpb25zO1xuXG4vKipcbiAqIFRoZSBMZXhlciBjbGFzcyBoYW5kbGVzIHRva2VuaXppbmcgdGhlIGlucHV0IGluIHZhcmlvdXMgd2F5cy4gU2luY2Ugb3VyXG4gKiBwYXJzZXIgZXhwZWN0cyB1cyB0byBiZSBhYmxlIHRvIGJhY2t0cmFjaywgdGhlIGxleGVyIGFsbG93cyBsZXhpbmcgZnJvbSBhbnlcbiAqIGdpdmVuIHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIEl0cyBtYWluIGV4cG9zZWQgZnVuY3Rpb24gaXMgdGhlIGBsZXhgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBvc2l0aW9uIHRvXG4gKiBsZXggZnJvbSBhbmQgYSB0eXBlIG9mIHRva2VuIHRvIGxleC4gSXQgZGVmZXJzIHRvIHRoZSBhcHByb3ByaWF0ZSBgX2lubmVyTGV4YFxuICogZnVuY3Rpb24uXG4gKlxuICogVGhlIHZhcmlvdXMgYF9pbm5lckxleGAgZnVuY3Rpb25zIHBlcmZvcm0gdGhlIGFjdHVhbCBsZXhpbmcgb2YgZGlmZmVyZW50XG4gKiBraW5kcy5cbiAqL1xuXG5cbi8qIFRoZSBmb2xsb3dpbmcgdG9rZW5SZWdleFxuICogLSBtYXRjaGVzIHR5cGljYWwgd2hpdGVzcGFjZSAoYnV0IG5vdCBOQlNQIGV0Yy4pIHVzaW5nIGl0cyBmaXJzdCB0d28gZ3JvdXBzXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGhjaGVzIG51bWVyYWxzXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVycyB0aGVuIHdoaXRlc3BhY2VcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBhbnkgQk1QIGNoYXJhY3RlclxuICogQ2FwdHVyaW5nIGdyb3VwczpcbiAqICAgWzFdIHJlZ3VsYXIgd2hpdGVzcGFjZVxuICogICBbMl0gYmFja3NsYXNoIGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2VcbiAqICAgWzNdIGFueXRoaW5nIGVsc2UsIHdoaWNoIG1heSBpbmNsdWRlOlxuICogICAgIFs0XSBsZWZ0IGNoYXJhY3RlciBvZiBcXHZlcmIqXG4gKiAgICAgWzVdIGxlZnQgY2hhcmFjdGVyIG9mIFxcdmVyYlxuICogICAgIFs2XSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgd29yZCwgZXhjbHVkaW5nIGFueSB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gKiBKdXN0IGJlY2F1c2UgdGhlIExleGVyIG1hdGNoZXMgc29tZXRoaW5nIGRvZXNuJ3QgbWVhbiBpdCdzIHZhbGlkIGlucHV0OlxuICogSWYgdGhlcmUgaXMgbm8gbWF0Y2hpbmcgZnVuY3Rpb24gb3Igc3ltYm9sIGRlZmluaXRpb24sIHRoZSBQYXJzZXIgd2lsbFxuICogc3RpbGwgcmVqZWN0IHRoZSBpbnB1dC5cbiAqL1xuY29uc3Qgc3BhY2VSZWdleFN0cmluZyA9IFwiWyBcXHJcXG5cXHRdXCI7XG5jb25zdCBjb250cm9sV29yZFJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXFthLXpBLVpAXStcIjtcbmNvbnN0IGNvbnRyb2xTeW1ib2xSZWdleFN0cmluZyA9IFwiXFxcXFxcXFxbXlxcdUQ4MDAtXFx1REZGRl1cIjtcbmNvbnN0IGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nID0gYCgke2NvbnRyb2xXb3JkUmVnZXhTdHJpbmd9KSR7c3BhY2VSZWdleFN0cmluZ30qYDtcbmNvbnN0IGNvbnRyb2xTcGFjZVJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXChcXG58WyBcXHJcXHRdK1xcbj8pWyBcXHJcXHRdKlwiO1xuY29uc3QgY29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nID0gXCJbXFx1MDMwMC1cXHUwMzZmXVwiO1xuY29uc3QgY29tYmluaW5nRGlhY3JpdGljYWxNYXJrc0VuZFJlZ2V4ID0gbmV3IFJlZ0V4cChgJHtjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmd9KyRgKTtcbmNvbnN0IHRva2VuUmVnZXhTdHJpbmcgPVxuICBgKCR7c3BhY2VSZWdleFN0cmluZ30rKXxgICsgLy8gd2hpdGVzcGFjZVxuICBgJHtjb250cm9sU3BhY2VSZWdleFN0cmluZ318YCArICAvLyB3aGl0ZXNwYWNlXG4gIFwiKFshLVxcXFxbXFxcXF0tXFx1MjAyN1xcdTIwMkEtXFx1RDdGRlxcdUY5MDAtXFx1RkZGRl1cIiArIC8vIHNpbmdsZSBjb2RlcG9pbnRcbiAgYCR7Y29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nfSpgICsgLy8gLi4ucGx1cyBhY2NlbnRzXG4gIFwifFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl1cIiArIC8vIHN1cnJvZ2F0ZSBwYWlyXG4gIGAke2NvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZ30qYCArIC8vIC4uLnBsdXMgYWNjZW50c1xuICBcInxcXFxcXFxcXHZlcmJcXFxcKihbXl0pLio/XFxcXDRcIiArIC8vIFxcdmVyYipcbiAgXCJ8XFxcXFxcXFx2ZXJiKFteKmEtekEtWl0pLio/XFxcXDVcIiArIC8vIFxcdmVyYiB1bnN0YXJyZWRcbiAgYHwke2NvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nfWAgKyAvLyBcXG1hY3JvTmFtZSArIHNwYWNlc1xuICBgfCR7Y29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nfSlgOyAvLyBcXFxcLCBcXCcsIGV0Yy5cblxuLyoqIE1haW4gTGV4ZXIgY2xhc3MgKi9cbmNsYXNzIExleGVyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgLy8gU2VwYXJhdGUgYWNjZW50cyBmcm9tIGNoYXJhY3RlcnNcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMudG9rZW5SZWdleCA9IG5ldyBSZWdFeHAodG9rZW5SZWdleFN0cmluZywgJ2cnKTtcbiAgICAvLyBDYXRlZ29yeSBjb2Rlcy4gVGhlIGxleGVyIG9ubHkgc3VwcG9ydHMgY29tbWVudCBjaGFyYWN0ZXJzICgxNCkgZm9yIG5vdy5cbiAgICAvLyBNYWNyb0V4cGFuZGVyIGFkZGl0aW9uYWxseSBkaXN0aW5ndWlzaGVzIGFjdGl2ZSAoMTMpLlxuICAgIHRoaXMuY2F0Y29kZXMgPSB7XG4gICAgICBcIiVcIjogMTQsIC8vIGNvbW1lbnQgY2hhcmFjdGVyXG4gICAgICBcIn5cIjogMTMgIC8vIGFjdGl2ZSBjaGFyYWN0ZXJcbiAgICB9O1xuICB9XG5cbiAgc2V0Q2F0Y29kZShjaGFyLCBjb2RlKSB7XG4gICAgdGhpcy5jYXRjb2Rlc1tjaGFyXSA9IGNvZGU7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBsZXhlcyBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGxleCgpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgY29uc3QgcG9zID0gdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleDtcbiAgICBpZiAocG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBuZXcgVG9rZW4oXCJFT0ZcIiwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zKSk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gdGhpcy50b2tlblJlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5pbmRleCAhPT0gcG9zKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgYFVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAnJHtpbnB1dFtwb3NdfSdgLFxuICAgICAgICBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zICsgMSkpXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gbWF0Y2hbNl0gfHwgbWF0Y2hbM10gfHwgKG1hdGNoWzJdID8gXCJcXFxcIFwiIDogXCIgXCIpO1xuXG4gICAgaWYgKHRoaXMuY2F0Y29kZXNbdGV4dF0gPT09IDE0KSB7XG4gICAgICAvLyBjb21tZW50IGNoYXJhY3RlclxuICAgICAgY29uc3QgbmxJbmRleCA9IGlucHV0LmluZGV4T2YoXCJcXG5cIiwgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCk7XG4gICAgICBpZiAobmxJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCA9IGlucHV0Lmxlbmd0aDsgLy8gRU9GXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiJSBjb21tZW50IGhhcyBubyB0ZXJtaW5hdGluZyBuZXdsaW5lOyBMYVRlWCB3b3VsZCBcIiArXG4gICAgICAgICAgICAgIFwiZmFpbCBiZWNhdXNlIG9mIGNvbW1lbnRpbmcgdGhlIGVuZCBvZiBtYXRoIG1vZGVcIilcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleCA9IG5sSW5kZXggKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubGV4KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGBOYW1lc3BhY2VgIHJlZmVycyB0byBhIHNwYWNlIG9mIG5hbWVhYmxlIHRoaW5ncyBsaWtlIG1hY3JvcyBvciBsZW5ndGhzLFxuICogd2hpY2ggY2FuIGJlIGBzZXRgIGVpdGhlciBnbG9iYWxseSBvciBsb2NhbCB0byBhIG5lc3RlZCBncm91cCwgdXNpbmcgYW5cbiAqIHVuZG8gc3RhY2sgc2ltaWxhciB0byBob3cgVGVYIGltcGxlbWVudHMgdGhpcyBmdW5jdGlvbmFsaXR5LlxuICogUGVyZm9ybWFuY2Utd2lzZSwgYGdldGAgYW5kIGxvY2FsIGBzZXRgIHRha2UgY29uc3RhbnQgdGltZSwgd2hpbGUgZ2xvYmFsXG4gKiBgc2V0YCB0YWtlcyB0aW1lIHByb3BvcnRpb25hbCB0byB0aGUgZGVwdGggb2YgZ3JvdXAgbmVzdGluZy5cbiAqL1xuXG5cbmNsYXNzIE5hbWVzcGFjZSB7XG4gIC8qKlxuICAgKiBCb3RoIGFyZ3VtZW50cyBhcmUgb3B0aW9uYWwuICBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYW4gb2JqZWN0IG9mXG4gICAqIGJ1aWx0LWluIG1hcHBpbmdzIHdoaWNoIG5ldmVyIGNoYW5nZS4gIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gICAqIG9mIGluaXRpYWwgKGdsb2JhbC1sZXZlbCkgbWFwcGluZ3MsIHdoaWNoIHdpbGwgY29uc3RhbnRseSBjaGFuZ2VcbiAgICogYWNjb3JkaW5nIHRvIGFueSBnbG9iYWwvdG9wLWxldmVsIGBzZXRgcyBkb25lLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYnVpbHRpbnMgPSB7fSwgZ2xvYmFsTWFjcm9zID0ge30pIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBnbG9iYWxNYWNyb3M7XG4gICAgdGhpcy5idWlsdGlucyA9IGJ1aWx0aW5zO1xuICAgIHRoaXMudW5kZWZTdGFjayA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IG5lc3RlZCBncm91cCwgYWZmZWN0aW5nIGZ1dHVyZSBsb2NhbCBgc2V0YHMuXG4gICAqL1xuICBiZWdpbkdyb3VwKCkge1xuICAgIHRoaXMudW5kZWZTdGFjay5wdXNoKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBuZXN0ZWQgZ3JvdXAsIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZSBncm91cCBiZWdhbi5cbiAgICovXG4gIGVuZEdyb3VwKCkge1xuICAgIGlmICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgXCJVbmJhbGFuY2VkIG5hbWVzcGFjZSBkZXN0cnVjdGlvbjogYXR0ZW1wdCBcIiArXG4gICAgICAgICAgXCJ0byBwb3AgZ2xvYmFsIG5hbWVzcGFjZTsgcGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHVuZGVmcyA9IHRoaXMudW5kZWZTdGFjay5wb3AoKTtcbiAgICBmb3IgKGNvbnN0IHVuZGVmIGluIHVuZGVmcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1bmRlZnMsIHVuZGVmICkpIHtcbiAgICAgICAgaWYgKHVuZGVmc1t1bmRlZl0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRbdW5kZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VycmVudFt1bmRlZl0gPSB1bmRlZnNbdW5kZWZdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCB3aGV0aGVyIGBuYW1lYCBoYXMgYSBkZWZpbml0aW9uLiAgRXF1aXZhbGVudCB0b1xuICAgKiBgZ2V0KG5hbWUpICE9IG51bGxgLlxuICAgKi9cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY3VycmVudCwgbmFtZSApIHx8XG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYnVpbHRpbnMsIG5hbWUgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyB2YWx1ZS5cbiAgICpcbiAgICogTm90ZTogRG8gbm90IHVzZSBgaWYgKG5hbWVzcGFjZS5nZXQoLi4uKSlgIHRvIGRldGVjdCB3aGV0aGVyIGEgbWFjcm9cbiAgICogaXMgZGVmaW5lZCwgYXMgdGhlIGRlZmluaXRpb24gbWF5IGJlIHRoZSBlbXB0eSBzdHJpbmcgd2hpY2ggZXZhbHVhdGVzXG4gICAqIHRvIGBmYWxzZWAgaW4gSmF2YVNjcmlwdC4gIFVzZSBgaWYgKG5hbWVzcGFjZS5nZXQoLi4uKSAhPSBudWxsKWAgb3JcbiAgICogYGlmIChuYW1lc3BhY2UuaGFzKC4uLikpYC5cbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1cnJlbnQsIG5hbWUgKSkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuYnVpbHRpbnNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIG5hbWUsIGFuZCBvcHRpb25hbGx5IHNldCBpdCBnbG9iYWxseSB0b28uXG4gICAqIExvY2FsIHNldCgpIHNldHMgdGhlIGN1cnJlbnQgdmFsdWUgYW5kICh3aGVuIGFwcHJvcHJpYXRlKSBhZGRzIGFuIHVuZG9cbiAgICogb3BlcmF0aW9uIHRvIHRoZSB1bmRvIHN0YWNrLiAgR2xvYmFsIHNldCgpIG1heSBjaGFuZ2UgdGhlIHVuZG9cbiAgICogb3BlcmF0aW9uIGF0IGV2ZXJ5IGxldmVsLCBzbyB0YWtlcyB0aW1lIGxpbmVhciBpbiB0aGVpciBudW1iZXIuXG4gICAqL1xuICBzZXQobmFtZSwgdmFsdWUsIGdsb2JhbCA9IGZhbHNlKSB7XG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgLy8gR2xvYmFsIHNldCBpcyBlcXVpdmFsZW50IHRvIHNldHRpbmcgaW4gYWxsIGdyb3Vwcy4gIFNpbXVsYXRlIHRoaXNcbiAgICAgIC8vIGJ5IGRlc3Ryb3lpbmcgYW55IHVuZG9zIGN1cnJlbnRseSBzY2hlZHVsZWQgZm9yIHRoaXMgbmFtZSxcbiAgICAgIC8vIGFuZCBhZGRpbmcgYW4gdW5kbyB3aXRoIHRoZSAqbmV3KiB2YWx1ZSAoaW4gY2FzZSBpdCBsYXRlciBnZXRzXG4gICAgICAvLyBsb2NhbGx5IHJlc2V0IHdpdGhpbiB0aGlzIGVudmlyb25tZW50KS5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy51bmRlZlN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVuZGVmU3RhY2tbaV1bbmFtZV07XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51bmRlZlN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVbmRvIHRoaXMgc2V0IGF0IGVuZCBvZiB0aGlzIGdyb3VwIChwb3NzaWJseSB0byBgdW5kZWZpbmVkYCksXG4gICAgICAvLyB1bmxlc3MgYW4gdW5kbyBpcyBhbHJlYWR5IGluIHBsYWNlLCBpbiB3aGljaCBjYXNlIHRoYXQgb2xkZXJcbiAgICAgIC8vIHZhbHVlIGlzIHRoZSBjb3JyZWN0IG9uZS5cbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudW5kZWZTdGFja1t0aGlzLnVuZGVmU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAodG9wICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodG9wLCBuYW1lICkpIHtcbiAgICAgICAgdG9wW25hbWVdID0gdGhpcy5jdXJyZW50W25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRbbmFtZV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyB0aGUg4oCcZ3VsbGV04oCdIHdoZXJlIG1hY3JvcyBhcmUgZXhwYW5kZWRcbiAqIHVudGlsIG9ubHkgbm9uLW1hY3JvIHRva2VucyByZW1haW4uXG4gKi9cblxuXG4vLyBMaXN0IG9mIGNvbW1hbmRzIHRoYXQgYWN0IGxpa2UgbWFjcm9zIGJ1dCBhcmVuJ3QgZGVmaW5lZCBhcyBhIG1hY3JvLFxuLy8gZnVuY3Rpb24sIG9yIHN5bWJvbC4gIFVzZWQgaW4gYGlzRGVmaW5lZGAuXG5jb25zdCBpbXBsaWNpdENvbW1hbmRzID0ge1xuICBcIl5cIjogdHJ1ZSwgLy8gUGFyc2VyLmpzXG4gIF86IHRydWUsIC8vIFBhcnNlci5qc1xuICBcIlxcXFxsaW1pdHNcIjogdHJ1ZSwgLy8gUGFyc2VyLmpzXG4gIFwiXFxcXG5vbGltaXRzXCI6IHRydWUgLy8gUGFyc2VyLmpzXG59O1xuXG5jbGFzcyBNYWNyb0V4cGFuZGVyIHtcbiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzLCBtb2RlKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuZXhwYW5zaW9uQ291bnQgPSAwO1xuICAgIHRoaXMuZmVlZChpbnB1dCk7XG4gICAgLy8gTWFrZSBuZXcgZ2xvYmFsIG5hbWVzcGFjZVxuICAgIHRoaXMubWFjcm9zID0gbmV3IE5hbWVzcGFjZShtYWNyb3MsIHNldHRpbmdzLm1hY3Jvcyk7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLnN0YWNrID0gW107IC8vIGNvbnRhaW5zIHRva2VucyBpbiBSRVZFUlNFIG9yZGVyXG4gIH1cblxuICAvKipcbiAgICogRmVlZCBhIG5ldyBpbnB1dCBzdHJpbmcgdG8gdGhlIHNhbWUgTWFjcm9FeHBhbmRlclxuICAgKiAod2l0aCBleGlzdGluZyBtYWNyb3MgZXRjLikuXG4gICAqL1xuICBmZWVkKGlucHV0KSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcihpbnB1dCwgdGhpcy5zZXR0aW5ncyk7XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoZXMgYmV0d2VlbiBcInRleHRcIiBhbmQgXCJtYXRoXCIgbW9kZXMuXG4gICAqL1xuICBzd2l0Y2hNb2RlKG5ld01vZGUpIHtcbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLlxuICAgKi9cbiAgYmVnaW5Hcm91cCgpIHtcbiAgICB0aGlzLm1hY3Jvcy5iZWdpbkdyb3VwKCk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIGN1cnJlbnQgZ3JvdXAgbmVzdGluZyB3aXRoaW4gYWxsIG5hbWVzcGFjZXMuXG4gICAqL1xuICBlbmRHcm91cCgpIHtcbiAgICB0aGlzLm1hY3Jvcy5lbmRHcm91cCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRvcG1vc3QgdG9rZW4gb24gdGhlIHN0YWNrLCB3aXRob3V0IGV4cGFuZGluZyBpdC5cbiAgICogU2ltaWxhciBpbiBiZWhhdmlvciB0byBUZVgncyBgXFxmdXR1cmVsZXRgLlxuICAgKi9cbiAgZnV0dXJlKCkge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5wdXNoVG9rZW4odGhpcy5sZXhlci5sZXgoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW5kIHJldHVybiB0aGUgbmV4dCB1bmV4cGFuZGVkIHRva2VuLlxuICAgKi9cbiAgcG9wVG9rZW4oKSB7XG4gICAgdGhpcy5mdXR1cmUoKTsgLy8gZW5zdXJlIG5vbi1lbXB0eSBzdGFja1xuICAgIHJldHVybiB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIGdpdmVuIHRva2VuIHRvIHRoZSB0b2tlbiBzdGFjay4gIEluIHBhcnRpY3VsYXIsIHRoaXMgZ2V0IGJlIHVzZWRcbiAgICogdG8gcHV0IGJhY2sgYSB0b2tlbiByZXR1cm5lZCBmcm9tIG9uZSBvZiB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgICovXG4gIHB1c2hUb2tlbih0b2tlbikge1xuICAgIHRoaXMuc3RhY2sucHVzaCh0b2tlbik7XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIGFuIGFycmF5IG9mIHRva2VucyB0byB0aGUgdG9rZW4gc3RhY2suXG4gICAqL1xuICBwdXNoVG9rZW5zKHRva2Vucykge1xuICAgIHRoaXMuc3RhY2sucHVzaCguLi50b2tlbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYW4gbWFjcm8gYXJndW1lbnQgd2l0aG91dCBleHBhbmRpbmcgdG9rZW5zIGFuZCBhcHBlbmQgdGhlIGFycmF5IG9mXG4gICAqIHRva2VucyB0byB0aGUgdG9rZW4gc3RhY2suIFVzZXMgVG9rZW4gYXMgYSBjb250YWluZXIgZm9yIHRoZSByZXN1bHQuXG4gICAqL1xuICBzY2FuQXJndW1lbnQoaXNPcHRpb25hbCkge1xuICAgIGxldCBzdGFydDtcbiAgICBsZXQgZW5kO1xuICAgIGxldCB0b2tlbnM7XG4gICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBcXEBpZm5leHRjaGFyIGdvYmJsZXMgYW55IHNwYWNlIGZvbGxvd2luZyBpdFxuICAgICAgaWYgKHRoaXMuZnV0dXJlKCkudGV4dCAhPT0gXCJbXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzdGFydCA9IHRoaXMucG9wVG9rZW4oKTsgLy8gZG9uJ3QgaW5jbHVkZSBbIGluIHRva2Vuc1xuICAgICAgKHsgdG9rZW5zLCBlbmQgfSA9IHRoaXMuY29uc3VtZUFyZyhbXCJdXCJdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh7IHRva2Vucywgc3RhcnQsIGVuZCB9ID0gdGhpcy5jb25zdW1lQXJnKCkpO1xuICAgIH1cblxuICAgIC8vIGluZGljYXRlIHRoZSBlbmQgb2YgYW4gYXJndW1lbnRcbiAgICB0aGlzLnB1c2hUb2tlbihuZXcgVG9rZW4oXCJFT0ZcIiwgZW5kLmxvYykpO1xuXG4gICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgcmV0dXJuIHN0YXJ0LnJhbmdlKGVuZCwgXCJcIik7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZSBhbGwgZm9sbG93aW5nIHNwYWNlIHRva2Vucywgd2l0aG91dCBleHBhbnNpb24uXG4gICAqL1xuICBjb25zdW1lU3BhY2VzKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5mdXR1cmUoKTtcbiAgICAgIGlmICh0b2tlbi50ZXh0ID09PSBcIiBcIikge1xuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWUgYW4gYXJndW1lbnQgZnJvbSB0aGUgdG9rZW4gc3RyZWFtLCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgYXJyYXlcbiAgICogb2YgdG9rZW5zIGFuZCBzdGFydC9lbmQgdG9rZW4uXG4gICAqL1xuICBjb25zdW1lQXJnKGRlbGltcykge1xuICAgIC8vIFRoZSBhcmd1bWVudCBmb3IgYSBkZWxpbWl0ZWQgcGFyYW1ldGVyIGlzIHRoZSBzaG9ydGVzdCAocG9zc2libHlcbiAgICAvLyBlbXB0eSkgc2VxdWVuY2Ugb2YgdG9rZW5zIHdpdGggcHJvcGVybHkgbmVzdGVkIHsuLi59IGdyb3VwcyB0aGF0IGlzXG4gICAgLy8gZm9sbG93ZWQgLi4uIGJ5IHRoaXMgcGFydGljdWxhciBsaXN0IG9mIG5vbi1wYXJhbWV0ZXIgdG9rZW5zLlxuICAgIC8vIFRoZSBhcmd1bWVudCBmb3IgYW4gdW5kZWxpbWl0ZWQgcGFyYW1ldGVyIGlzIHRoZSBuZXh0IG5vbmJsYW5rXG4gICAgLy8gdG9rZW4sIHVubGVzcyB0aGF0IHRva2VuIGlzIOKAmHvigJksIHdoZW4gdGhlIGFyZ3VtZW50IHdpbGwgYmUgdGhlXG4gICAgLy8gZW50aXJlIHsuLi59IGdyb3VwIHRoYXQgZm9sbG93cy5cbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBjb25zdCBpc0RlbGltaXRlZCA9IGRlbGltcyAmJiBkZWxpbXMubGVuZ3RoID4gMDtcbiAgICBpZiAoIWlzRGVsaW1pdGVkKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGJldHdlZW4gYXJndW1lbnRzLiAgQXMgdGhlIFRlWGJvb2sgc2F5czpcbiAgICAgIC8vIFwiQWZ0ZXIgeW91IGhhdmUgc2FpZCDigJhcXGRlZlxccm93IzEjMnsuLi594oCZLCB5b3UgYXJlIGFsbG93ZWQgdG9cbiAgICAgIC8vICBwdXQgc3BhY2VzIGJldHdlZW4gdGhlIGFyZ3VtZW50cyAoZS5nLiwg4oCYXFxyb3cgeCBu4oCZKSwgYmVjYXVzZVxuICAgICAgLy8gIFRlWCBkb2VzbuKAmXQgdXNlIHNpbmdsZSBzcGFjZXMgYXMgdW5kZWxpbWl0ZWQgYXJndW1lbnRzLlwiXG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLmZ1dHVyZSgpO1xuICAgIGxldCB0b2s7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICBsZXQgbWF0Y2ggPSAwO1xuICAgIGRvIHtcbiAgICAgIHRvayA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICAgIHRva2Vucy5wdXNoKHRvayk7XG4gICAgICBpZiAodG9rLnRleHQgPT09IFwie1wiKSB7XG4gICAgICAgICsrZGVwdGg7XG4gICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSBcIn1cIikge1xuICAgICAgICAtLWRlcHRoO1xuICAgICAgICBpZiAoZGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHRyYSB9XCIsIHRvayk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBhIG1hY3JvIGFyZ3VtZW50XCIgK1xuICAgICAgICAgICAgXCIsIGV4cGVjdGVkICdcIiArXG4gICAgICAgICAgICAoZGVsaW1zICYmIGlzRGVsaW1pdGVkID8gZGVsaW1zW21hdGNoXSA6IFwifVwiKSArXG4gICAgICAgICAgICBcIidcIixcbiAgICAgICAgICB0b2tcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWxpbXMgJiYgaXNEZWxpbWl0ZWQpIHtcbiAgICAgICAgaWYgKChkZXB0aCA9PT0gMCB8fCAoZGVwdGggPT09IDEgJiYgZGVsaW1zW21hdGNoXSA9PT0gXCJ7XCIpKSAmJiB0b2sudGV4dCA9PT0gZGVsaW1zW21hdGNoXSkge1xuICAgICAgICAgICsrbWF0Y2g7XG4gICAgICAgICAgaWYgKG1hdGNoID09PSBkZWxpbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBpbmNsdWRlIGRlbGltcyBpbiB0b2tlbnNcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoLW1hdGNoLCBtYXRjaCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2ggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAoZGVwdGggIT09IDAgfHwgaXNEZWxpbWl0ZWQpO1xuICAgIC8vIElmIHRoZSBhcmd1bWVudCBmb3VuZCAuLi4gaGFzIHRoZSBmb3JtIOKAmHs8bmVzdGVkIHRva2Vucz594oCZLFxuICAgIC8vIC4uLiB0aGUgb3V0ZXJtb3N0IGJyYWNlcyBlbmNsb3NpbmcgdGhlIGFyZ3VtZW50IGFyZSByZW1vdmVkXG4gICAgaWYgKHN0YXJ0LnRleHQgPT09IFwie1wiICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udGV4dCA9PT0gXCJ9XCIpIHtcbiAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgIHRva2Vucy5zaGlmdCgpO1xuICAgIH1cbiAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayBvcmRlclxuICAgIHJldHVybiB7IHRva2Vucywgc3RhcnQsIGVuZDogdG9rIH07XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiAoZGVsaW1pdGVkKSBhcmd1bWVudHMgZnJvbSB0aGUgdG9rZW5cbiAgICogc3RyZWFtIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheSBvZiBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdW1lQXJncyhudW1BcmdzLCBkZWxpbWl0ZXJzKSB7XG4gICAgaWYgKGRlbGltaXRlcnMpIHtcbiAgICAgIGlmIChkZWxpbWl0ZXJzLmxlbmd0aCAhPT0gbnVtQXJncyArIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUaGUgbGVuZ3RoIG9mIGRlbGltaXRlcnMgZG9lc24ndCBtYXRjaCB0aGUgbnVtYmVyIG9mIGFyZ3MhXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsaW1zID0gZGVsaW1pdGVyc1swXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRvayA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICAgICAgaWYgKGRlbGltc1tpXSAhPT0gdG9rLnRleHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVzZSBvZiB0aGUgbWFjcm8gZG9lc24ndCBtYXRjaCBpdHMgZGVmaW5pdGlvblwiLCB0b2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQXJnczsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2godGhpcy5jb25zdW1lQXJnKGRlbGltaXRlcnMgJiYgZGVsaW1pdGVyc1tpICsgMV0pLnRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgbmV4dCB0b2tlbiBvbmx5IG9uY2UgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIElmIHRoZSB0b2tlbiBpcyBleHBhbmRlZCwgdGhlIHJlc3VsdGluZyB0b2tlbnMgd2lsbCBiZSBwdXNoZWQgb250b1xuICAgKiB0aGUgc3RhY2sgaW4gcmV2ZXJzZSBvcmRlciwgYW5kIHRoZSBudW1iZXIgb2Ygc3VjaCB0b2tlbnMgd2lsbCBiZVxuICAgKiByZXR1cm5lZC4gIFRoaXMgbnVtYmVyIG1pZ2h0IGJlIHplcm8gb3IgcG9zaXRpdmUuXG4gICAqXG4gICAqIElmIG5vdCwgdGhlIHJldHVybiB2YWx1ZSBpcyBgZmFsc2VgLCBhbmQgdGhlIG5leHQgdG9rZW4gcmVtYWlucyBhdCB0aGVcbiAgICogdG9wIG9mIHRoZSBzdGFjay5cbiAgICpcbiAgICogSW4gZWl0aGVyIGNhc2UsIHRoZSBuZXh0IHRva2VuIHdpbGwgYmUgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2ssXG4gICAqIG9yIHRoZSBzdGFjayB3aWxsIGJlIGVtcHR5IChpbiBjYXNlIG9mIGVtcHR5IGV4cGFuc2lvblxuICAgKiBhbmQgbm8gb3RoZXIgdG9rZW5zKS5cbiAgICpcbiAgICogVXNlZCB0byBpbXBsZW1lbnQgYGV4cGFuZEFmdGVyRnV0dXJlYCBhbmQgYGV4cGFuZE5leHRUb2tlbmAuXG4gICAqXG4gICAqIElmIGV4cGFuZGFibGVPbmx5LCBvbmx5IGV4cGFuZGFibGUgdG9rZW5zIGFyZSBleHBhbmRlZCBhbmRcbiAgICogYW4gdW5kZWZpbmVkIGNvbnRyb2wgc2VxdWVuY2UgcmVzdWx0cyBpbiBhbiBlcnJvci5cbiAgICovXG4gIGV4cGFuZE9uY2UoZXhwYW5kYWJsZU9ubHkpIHtcbiAgICBjb25zdCB0b3BUb2tlbiA9IHRoaXMucG9wVG9rZW4oKTtcbiAgICBjb25zdCBuYW1lID0gdG9wVG9rZW4udGV4dDtcbiAgICBjb25zdCBleHBhbnNpb24gPSAhdG9wVG9rZW4ubm9leHBhbmQgPyB0aGlzLl9nZXRFeHBhbnNpb24obmFtZSkgOiBudWxsO1xuICAgIGlmIChleHBhbnNpb24gPT0gbnVsbCB8fCAoZXhwYW5kYWJsZU9ubHkgJiYgZXhwYW5zaW9uLnVuZXhwYW5kYWJsZSkpIHtcbiAgICAgIGlmIChleHBhbmRhYmxlT25seSAmJiBleHBhbnNpb24gPT0gbnVsbCAmJiBuYW1lWzBdID09PSBcIlxcXFxcIiAmJiAhdGhpcy5pc0RlZmluZWQobmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZTogXCIgKyBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaFRva2VuKHRvcFRva2VuKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5leHBhbnNpb25Db3VudCsrO1xuICAgIGlmICh0aGlzLmV4cGFuc2lvbkNvdW50ID4gdGhpcy5zZXR0aW5ncy5tYXhFeHBhbmQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBcIlRvbyBtYW55IGV4cGFuc2lvbnM6IGluZmluaXRlIGxvb3Agb3IgXCIgKyBcIm5lZWQgdG8gaW5jcmVhc2UgbWF4RXhwYW5kIHNldHRpbmdcIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHRva2VucyA9IGV4cGFuc2lvbi50b2tlbnM7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuY29uc3VtZUFyZ3MoZXhwYW5zaW9uLm51bUFyZ3MsIGV4cGFuc2lvbi5kZWxpbWl0ZXJzKTtcbiAgICBpZiAoZXhwYW5zaW9uLm51bUFyZ3MpIHtcbiAgICAgIC8vIHBhc3RlIGFyZ3VtZW50cyBpbiBwbGFjZSBvZiB0aGUgcGxhY2Vob2xkZXJzXG4gICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoKTsgLy8gbWFrZSBhIHNoYWxsb3cgY29weVxuICAgICAgZm9yIChsZXQgaSA9IHRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBsZXQgdG9rID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW5jb21wbGV0ZSBwbGFjZWhvbGRlciBhdCBlbmQgb2YgbWFjcm8gYm9keVwiLCB0b2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2sgPSB0b2tlbnNbLS1pXTsgLy8gbmV4dCB0b2tlbiBvbiBzdGFja1xuICAgICAgICAgIGlmICh0b2sudGV4dCA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIC8vICMjIOKGkiAjXG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgKyAxLCAxKTsgLy8gZHJvcCBmaXJzdCAjXG4gICAgICAgICAgfSBlbHNlIGlmICgvXlsxLTldJC8udGVzdCh0b2sudGV4dCkpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdpdGggdGhlIGluZGljYXRlZCBhcmd1bWVudFxuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAyLCAuLi5hcmdzWyt0b2sudGV4dCAtIDFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJOb3QgYSB2YWxpZCBhcmd1bWVudCBudW1iZXJcIiwgdG9rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29uY2F0ZW5hdGUgZXhwYW5zaW9uIG9udG8gdG9wIG9mIHN0YWNrLlxuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHJldHVybiB0b2tlbnMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cGFuZCB0aGUgbmV4dCB0b2tlbiBvbmx5IG9uY2UgKGlmIHBvc3NpYmxlKSwgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nXG4gICAqIHRvcCB0b2tlbiBvbiB0aGUgc3RhY2sgKHdpdGhvdXQgcmVtb3ZpbmcgYW55dGhpbmcgZnJvbSB0aGUgc3RhY2spLlxuICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcXGV4cGFuZGFmdGVyXFxmdXR1cmVsZXRgLlxuICAgKiBFcXVpdmFsZW50IHRvIGV4cGFuZE9uY2UoKSBmb2xsb3dlZCBieSBmdXR1cmUoKS5cbiAgICovXG4gIGV4cGFuZEFmdGVyRnV0dXJlKCkge1xuICAgIHRoaXMuZXhwYW5kT25jZSgpO1xuICAgIHJldHVybiB0aGlzLmZ1dHVyZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGV4cGFuZCBmaXJzdCB0b2tlbiwgdGhlbiByZXR1cm4gZmlyc3Qgbm9uLWV4cGFuZGFibGUgdG9rZW4uXG4gICAqL1xuICBleHBhbmROZXh0VG9rZW4oKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuZXhwYW5kT25jZSgpID09PSBmYWxzZSkgeyAvLyBmdWxseSBleHBhbmRlZFxuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgIC8vIFRoZSB0b2tlbiBhZnRlciBcXG5vZXhwYW5kIGlzIGludGVycHJldGVkIGFzIGlmIGl0cyBtZWFuaW5nIHdlcmUg4oCYXFxyZWxheOKAmVxuICAgICAgICBpZiAodG9rZW4udHJlYXRBc1JlbGF4KSB7XG4gICAgICAgICAgdG9rZW4udGV4dCA9IFwiXFxcXHJlbGF4XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBwYXRod2F5IGlzIGltcG9zc2libGUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIG1hY3JvIG5hbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGxpc3Qgb2ZcbiAgICogdG9rZW5zLCBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLlxuICAgKi9cbiAgZXhwYW5kTWFjcm8obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hY3Jvcy5oYXMobmFtZSkgPyB0aGlzLmV4cGFuZFRva2VucyhbbmV3IFRva2VuKG5hbWUpXSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiB0b2tlbiBzdHJlYW0gYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGxpc3Qgb2ZcbiAgICogdG9rZW5zLiAgTm90ZSB0aGF0IHRoZSBpbnB1dCB0b2tlbnMgYXJlIGluIHJldmVyc2Ugb3JkZXIsIGJ1dCB0aGVcbiAgICogb3V0cHV0IHRva2VucyBhcmUgaW4gZm9yd2FyZCBvcmRlci5cbiAgICovXG4gIGV4cGFuZFRva2Vucyh0b2tlbnMpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBjb25zdCBvbGRTdGFja0xlbmd0aCA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IG9sZFN0YWNrTGVuZ3RoKSB7XG4gICAgICAvLyBFeHBhbmQgb25seSBleHBhbmRhYmxlIHRva2Vuc1xuICAgICAgaWYgKHRoaXMuZXhwYW5kT25jZSh0cnVlKSA9PT0gZmFsc2UpIHsgIC8vIGZ1bGx5IGV4cGFuZGVkXG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKHRva2VuLnRyZWF0QXNSZWxheCkge1xuICAgICAgICAgIC8vIHRoZSBleHBhbnNpb24gb2YgXFxub2V4cGFuZCBpcyB0aGUgdG9rZW4gaXRzZWxmXG4gICAgICAgICAgdG9rZW4ubm9leHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICB0b2tlbi50cmVhdEFzUmVsYXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiBtYWNybyBuYW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIHN0cmluZyxcbiAgICogb3IgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggbWFjcm8gaXMgZGVmaW5lZC5cbiAgICovXG4gIGV4cGFuZE1hY3JvQXNUZXh0KG5hbWUpIHtcbiAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmV4cGFuZE1hY3JvKG5hbWUpO1xuICAgIGlmICh0b2tlbnMpIHtcbiAgICAgIHJldHVybiB0b2tlbnMubWFwKCh0b2tlbikgPT4gdG9rZW4udGV4dCkuam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXhwYW5kZWQgbWFjcm8gYXMgYSByZXZlcnNlZCBhcnJheSBvZiB0b2tlbnMgYW5kIGEgbWFjcm9cbiAgICogYXJndW1lbnQgY291bnQuICBPciByZXR1cm5zIGBudWxsYCBpZiBubyBzdWNoIG1hY3JvLlxuICAgKi9cbiAgX2dldEV4cGFuc2lvbihuYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMubWFjcm9zLmdldChuYW1lKTtcbiAgICBpZiAoZGVmaW5pdGlvbiA9PSBudWxsKSB7XG4gICAgICAvLyBtYWlubHkgY2hlY2tpbmcgZm9yIHVuZGVmaW5lZCBoZXJlXG4gICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLy8gSWYgYSBzaW5nbGUgY2hhcmFjdGVyIGhhcyBhbiBhc3NvY2lhdGVkIGNhdGNvZGUgb3RoZXIgdGhhbiAxM1xuICAgIC8vIChhY3RpdmUgY2hhcmFjdGVyKSwgdGhlbiBkb24ndCBleHBhbmQgaXQuXG4gICAgaWYgKG5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjYXRjb2RlID0gdGhpcy5sZXhlci5jYXRjb2Rlc1tuYW1lXTtcbiAgICAgIGlmIChjYXRjb2RlICE9IG51bGwgJiYgY2F0Y29kZSAhPT0gMTMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cGFuc2lvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBkZWZpbml0aW9uKHRoaXMpIDogZGVmaW5pdGlvbjtcbiAgICBpZiAodHlwZW9mIGV4cGFuc2lvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbGV0IG51bUFyZ3MgPSAwO1xuICAgICAgaWYgKGV4cGFuc2lvbi5pbmRleE9mKFwiI1wiKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSBleHBhbnNpb24ucmVwbGFjZSgvIyMvZywgXCJcIik7XG4gICAgICAgIHdoaWxlIChzdHJpcHBlZC5pbmRleE9mKFwiI1wiICsgKG51bUFyZ3MgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgKytudW1BcmdzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBib2R5TGV4ZXIgPSBuZXcgTGV4ZXIoZXhwYW5zaW9uLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgbGV0IHRvayA9IGJvZHlMZXhlci5sZXgoKTtcbiAgICAgIHdoaWxlICh0b2sudGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgICB0b2tlbnMucHVzaCh0b2spO1xuICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICB9XG4gICAgICB0b2tlbnMucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcbiAgICAgIGNvbnN0IGV4cGFuZGVkID0geyB0b2tlbnMsIG51bUFyZ3MgfTtcbiAgICAgIHJldHVybiBleHBhbmRlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwYW5zaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBjdXJyZW50bHkgXCJkZWZpbmVkXCIgKGhhcyBzb21lXG4gICAqIGZ1bmN0aW9uYWxpdHkpLCBtZWFuaW5nIHRoYXQgaXQncyBhIG1hY3JvIChpbiB0aGUgY3VycmVudCBncm91cCksXG4gICAqIGEgZnVuY3Rpb24sIGEgc3ltYm9sLCBvciBvbmUgb2YgdGhlIHNwZWNpYWwgY29tbWFuZHMgbGlzdGVkIGluXG4gICAqIGBpbXBsaWNpdENvbW1hbmRzYC5cbiAgICovXG4gIGlzRGVmaW5lZChuYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubWFjcm9zLmhhcyhuYW1lKSB8fFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZ1bmN0aW9ucywgbmFtZSApIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3ltYm9scy5tYXRoLCBuYW1lICkgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzeW1ib2xzLnRleHQsIG5hbWUgKSB8fFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGltcGxpY2l0Q29tbWFuZHMsIG5hbWUgKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tYW5kIGlzIGV4cGFuZGFibGUuXG4gICAqL1xuICBpc0V4cGFuZGFibGUobmFtZSkge1xuICAgIGNvbnN0IG1hY3JvID0gdGhpcy5tYWNyb3MuZ2V0KG5hbWUpO1xuICAgIHJldHVybiBtYWNybyAhPSBudWxsXG4gICAgICA/IHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWFjcm8gPT09IFwiZnVuY3Rpb25cIiB8fCAhbWFjcm8udW5leHBhbmRhYmxlXG4gICAgICA6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmdW5jdGlvbnMsIG5hbWUgKSAmJiAhZnVuY3Rpb25zW25hbWVdLnByaW1pdGl2ZTtcbiAgfVxufVxuXG4vLyBIZWxwZXJzIGZvciBQYXJzZXIuanMgaGFuZGxpbmcgb2YgVW5pY29kZSAoc3VifHN1cGVyKXNjcmlwdCBjaGFyYWN0ZXJzLlxuXG5jb25zdCB1bmljb2RlU3ViUmVnRXggPSAvXlvigorigovigozigo3igo7igoDigoHigoLigoPigoTigoXigobigofigojigonigpDigpHigpXhtaLisbzigpbigpfigpjigpnigpLigprhtaPigpvigpzhtaThtaXigpPhtabhtafhtajhtanhtapdLztcblxuY29uc3QgdVN1YnNBbmRTdXBzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICfigoonOiAnKycsXG4gICfigosnOiAnLScsXG4gICfigownOiAnPScsXG4gICfigo0nOiAnKCcsXG4gICfigo4nOiAnKScsXG4gICfigoAnOiAnMCcsXG4gICfigoEnOiAnMScsXG4gICfigoInOiAnMicsXG4gICfigoMnOiAnMycsXG4gICfigoQnOiAnNCcsXG4gICfigoUnOiAnNScsXG4gICfigoYnOiAnNicsXG4gICfigocnOiAnNycsXG4gICfigognOiAnOCcsXG4gICfigoknOiAnOScsXG4gICdcXHUyMDkwJzogJ2EnLFxuICAnXFx1MjA5MSc6ICdlJyxcbiAgJ1xcdTIwOTUnOiAnaCcsXG4gICdcXHUxRDYyJzogJ2knLFxuICAnXFx1MkM3Qyc6ICdqJyxcbiAgJ1xcdTIwOTYnOiAnaycsXG4gICdcXHUyMDk3JzogJ2wnLFxuICAnXFx1MjA5OCc6ICdtJyxcbiAgJ1xcdTIwOTknOiAnbicsXG4gICdcXHUyMDkyJzogJ28nLFxuICAnXFx1MjA5QSc6ICdwJyxcbiAgJ1xcdTFENjMnOiAncicsXG4gICdcXHUyMDlCJzogJ3MnLFxuICAnXFx1MjA5Qyc6ICd0JyxcbiAgJ1xcdTFENjQnOiAndScsXG4gICdcXHUxRDY1JzogJ3YnLFxuICAnXFx1MjA5Myc6ICd4JyxcbiAgJ1xcdTFENjYnOiAnzrInLFxuICAnXFx1MUQ2Nyc6ICfOsycsXG4gICdcXHUxRDY4JzogJ8+BJyxcbiAgJ1xcdTFENjknOiAnXFx1MDNkNScsXG4gICdcXHUxRDZBJzogJ8+HJyxcbiAgJ+KBuic6ICcrJyxcbiAgJ+KBuyc6ICctJyxcbiAgJ+KBvCc6ICc9JyxcbiAgJ+KBvSc6ICcoJyxcbiAgJ+KBvic6ICcpJyxcbiAgJ+KBsCc6ICcwJyxcbiAgJ8K5JzogJzEnLFxuICAnwrInOiAnMicsXG4gICfCsyc6ICczJyxcbiAgJ+KBtCc6ICc0JyxcbiAgJ+KBtSc6ICc1JyxcbiAgJ+KBtic6ICc2JyxcbiAgJ+KBtyc6ICc3JyxcbiAgJ+KBuCc6ICc4JyxcbiAgJ+KBuSc6ICc5JyxcbiAgJ1xcdTFEMkMnOiAnQScsXG4gICdcXHUxRDJFJzogJ0InLFxuICAnXFx1MUQzMCc6ICdEJyxcbiAgJ1xcdTFEMzEnOiAnRScsXG4gICdcXHUxRDMzJzogJ0cnLFxuICAnXFx1MUQzNCc6ICdIJyxcbiAgJ1xcdTFEMzUnOiAnSScsXG4gICdcXHUxRDM2JzogJ0onLFxuICAnXFx1MUQzNyc6ICdLJyxcbiAgJ1xcdTFEMzgnOiAnTCcsXG4gICdcXHUxRDM5JzogJ00nLFxuICAnXFx1MUQzQSc6ICdOJyxcbiAgJ1xcdTFEM0MnOiAnTycsXG4gICdcXHUxRDNFJzogJ1AnLFxuICAnXFx1MUQzRic6ICdSJyxcbiAgJ1xcdTFENDAnOiAnVCcsXG4gICdcXHUxRDQxJzogJ1UnLFxuICAnXFx1MkM3RCc6ICdWJyxcbiAgJ1xcdTFENDInOiAnVycsXG4gICdcXHUxRDQzJzogJ2EnLFxuICAnXFx1MUQ0Nyc6ICdiJyxcbiAgJ1xcdTFEOUMnOiAnYycsXG4gICdcXHUxRDQ4JzogJ2QnLFxuICAnXFx1MUQ0OSc6ICdlJyxcbiAgJ1xcdTFEQTAnOiAnZicsXG4gICdcXHUxRDREJzogJ2cnLFxuICAnXFx1MDJCMCc6ICdoJyxcbiAgJ1xcdTIwNzEnOiAnaScsXG4gICdcXHUwMkIyJzogJ2onLFxuICAnXFx1MUQ0Ric6ICdrJyxcbiAgJ1xcdTAyRTEnOiAnbCcsXG4gICdcXHUxRDUwJzogJ20nLFxuICAnXFx1MjA3Ric6ICduJyxcbiAgJ1xcdTFENTInOiAnbycsXG4gICdcXHUxRDU2JzogJ3AnLFxuICAnXFx1MDJCMyc6ICdyJyxcbiAgJ1xcdTAyRTInOiAncycsXG4gICdcXHUxRDU3JzogJ3QnLFxuICAnXFx1MUQ1OCc6ICd1JyxcbiAgJ1xcdTFENUInOiAndicsXG4gICdcXHUwMkI3JzogJ3cnLFxuICAnXFx1MDJFMyc6ICd4JyxcbiAgJ1xcdTAyQjgnOiAneScsXG4gICdcXHUxREJCJzogJ3onLFxuICAnXFx1MUQ1RCc6ICfOsicsXG4gICdcXHUxRDVFJzogJ86zJyxcbiAgJ1xcdTFENUYnOiAnzrQnLFxuICAnXFx1MUQ2MCc6ICdcXHUwM2Q1JyxcbiAgJ1xcdTFENjEnOiAnz4cnLFxuICAnXFx1MURCRic6ICfOuCdcbn0pO1xuXG4vLyBVc2VkIGZvciBVbmljb2RlIGlucHV0IG9mIGNhbGxpZ3JhcGhpYyBhbmQgc2NyaXB0IGxldHRlcnNcbmNvbnN0IGFzY2lpRnJvbVNjcmlwdCA9IE9iamVjdC5mcmVlemUoe1xuICBcIlxcdWQ4MzVcXHVkYzljXCI6IFwiQVwiLFxuICBcIlxcdTIxMmNcIjogXCJCXCIsXG4gIFwiXFx1ZDgzNVxcdWRjOWVcIjogXCJDXCIsXG4gIFwiXFx1ZDgzNVxcdWRjOWZcIjogXCJEXCIsXG4gIFwiXFx1MjEzMFwiOiBcIkVcIixcbiAgXCJcXHUyMTMxXCI6IFwiRlwiLFxuICBcIlxcdWQ4MzVcXHVkY2EyXCI6IFwiR1wiLFxuICBcIlxcdTIxMEJcIjogXCJIXCIsXG4gIFwiXFx1MjExMFwiOiBcIklcIixcbiAgXCJcXHVkODM1XFx1ZGNhNVwiOiBcIkpcIixcbiAgXCJcXHVkODM1XFx1ZGNhNlwiOiBcIktcIixcbiAgXCJcXHUyMTEyXCI6IFwiTFwiLFxuICBcIlxcdTIxMzNcIjogXCJNXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYTlcIjogXCJOXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYWFcIjogXCJPXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYWJcIjogXCJQXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYWNcIjogXCJRXCIsXG4gIFwiXFx1MjExQlwiOiBcIlJcIixcbiAgXCJcXHVkODM1XFx1ZGNhZVwiOiBcIlNcIixcbiAgXCJcXHVkODM1XFx1ZGNhZlwiOiBcIlRcIixcbiAgXCJcXHVkODM1XFx1ZGNiMFwiOiBcIlVcIixcbiAgXCJcXHVkODM1XFx1ZGNiMVwiOiBcIlZcIixcbiAgXCJcXHVkODM1XFx1ZGNiMlwiOiBcIldcIixcbiAgXCJcXHVkODM1XFx1ZGNiM1wiOiBcIlhcIixcbiAgXCJcXHVkODM1XFx1ZGNiNFwiOiBcIllcIixcbiAgXCJcXHVkODM1XFx1ZGNiNVwiOiBcIlpcIlxufSk7XG5cbi8vIE1hcHBpbmcgb2YgVW5pY29kZSBhY2NlbnQgY2hhcmFjdGVycyB0byB0aGVpciBMYVRlWCBlcXVpdmFsZW50IGluIHRleHQgYW5kXG4vLyBtYXRoIG1vZGUgKHdoZW4gdGhleSBleGlzdCkuXG52YXIgdW5pY29kZUFjY2VudHMgPSB7XG4gIFwiXFx1MDMwMVwiOiB7IHRleHQ6IFwiXFxcXCdcIiwgbWF0aDogXCJcXFxcYWN1dGVcIiB9LFxuICBcIlxcdTAzMDBcIjogeyB0ZXh0OiBcIlxcXFxgXCIsIG1hdGg6IFwiXFxcXGdyYXZlXCIgfSxcbiAgXCJcXHUwMzA4XCI6IHsgdGV4dDogJ1xcXFxcIicsIG1hdGg6IFwiXFxcXGRkb3RcIiB9LFxuICBcIlxcdTAzMDNcIjogeyB0ZXh0OiBcIlxcXFx+XCIsIG1hdGg6IFwiXFxcXHRpbGRlXCIgfSxcbiAgXCJcXHUwMzA0XCI6IHsgdGV4dDogXCJcXFxcPVwiLCBtYXRoOiBcIlxcXFxiYXJcIiB9LFxuICBcIlxcdTAzMDZcIjogeyB0ZXh0OiBcIlxcXFx1XCIsIG1hdGg6IFwiXFxcXGJyZXZlXCIgfSxcbiAgXCJcXHUwMzBjXCI6IHsgdGV4dDogXCJcXFxcdlwiLCBtYXRoOiBcIlxcXFxjaGVja1wiIH0sXG4gIFwiXFx1MDMwMlwiOiB7IHRleHQ6IFwiXFxcXF5cIiwgbWF0aDogXCJcXFxcaGF0XCIgfSxcbiAgXCJcXHUwMzA3XCI6IHsgdGV4dDogXCJcXFxcLlwiLCBtYXRoOiBcIlxcXFxkb3RcIiB9LFxuICBcIlxcdTAzMGFcIjogeyB0ZXh0OiBcIlxcXFxyXCIsIG1hdGg6IFwiXFxcXG1hdGhyaW5nXCIgfSxcbiAgXCJcXHUwMzBiXCI6IHsgdGV4dDogXCJcXFxcSFwiIH0sXG4gICdcXHUwMzI3JzogeyB0ZXh0OiAnXFxcXGMnIH1cbn07XG5cbnZhciB1bmljb2RlU3ltYm9scyA9IHtcbiAgXCLDoVwiOiBcImHMgVwiLFxuICBcIsOgXCI6IFwiYcyAXCIsXG4gIFwiw6RcIjogXCJhzIhcIixcbiAgXCLHn1wiOiBcImHMiMyEXCIsXG4gIFwiw6NcIjogXCJhzINcIixcbiAgXCLEgVwiOiBcImHMhFwiLFxuICBcIsSDXCI6IFwiYcyGXCIsXG4gIFwi4bqvXCI6IFwiYcyGzIFcIixcbiAgXCLhurFcIjogXCJhzIbMgFwiLFxuICBcIuG6tVwiOiBcImHMhsyDXCIsXG4gIFwix45cIjogXCJhzIxcIixcbiAgXCLDolwiOiBcImHMglwiLFxuICBcIuG6pVwiOiBcImHMgsyBXCIsXG4gIFwi4bqnXCI6IFwiYcyCzIBcIixcbiAgXCLhuqtcIjogXCJhzILMg1wiLFxuICBcIsinXCI6IFwiYcyHXCIsXG4gIFwix6FcIjogXCJhzIfMhFwiLFxuICBcIsOlXCI6IFwiYcyKXCIsXG4gIFwix7tcIjogXCJhzIrMgVwiLFxuICBcIuG4g1wiOiBcImLMh1wiLFxuICBcIsSHXCI6IFwiY8yBXCIsXG4gIFwixI1cIjogXCJjzIxcIixcbiAgXCLEiVwiOiBcImPMglwiLFxuICBcIsSLXCI6IFwiY8yHXCIsXG4gIFwixI9cIjogXCJkzIxcIixcbiAgXCLhuItcIjogXCJkzIdcIixcbiAgXCLDqVwiOiBcImXMgVwiLFxuICBcIsOoXCI6IFwiZcyAXCIsXG4gIFwiw6tcIjogXCJlzIhcIixcbiAgXCLhur1cIjogXCJlzINcIixcbiAgXCLEk1wiOiBcImXMhFwiLFxuICBcIuG4l1wiOiBcImXMhMyBXCIsXG4gIFwi4biVXCI6IFwiZcyEzIBcIixcbiAgXCLElVwiOiBcImXMhlwiLFxuICBcIsSbXCI6IFwiZcyMXCIsXG4gIFwiw6pcIjogXCJlzIJcIixcbiAgXCLhur9cIjogXCJlzILMgVwiLFxuICBcIuG7gVwiOiBcImXMgsyAXCIsXG4gIFwi4buFXCI6IFwiZcyCzINcIixcbiAgXCLEl1wiOiBcImXMh1wiLFxuICBcIuG4n1wiOiBcImbMh1wiLFxuICBcIse1XCI6IFwiZ8yBXCIsXG4gIFwi4bihXCI6IFwiZ8yEXCIsXG4gIFwixJ9cIjogXCJnzIZcIixcbiAgXCLHp1wiOiBcImfMjFwiLFxuICBcIsSdXCI6IFwiZ8yCXCIsXG4gIFwixKFcIjogXCJnzIdcIixcbiAgXCLhuKdcIjogXCJozIhcIixcbiAgXCLIn1wiOiBcImjMjFwiLFxuICBcIsSlXCI6IFwiaMyCXCIsXG4gIFwi4bijXCI6IFwiaMyHXCIsXG4gIFwiw61cIjogXCJpzIFcIixcbiAgXCLDrFwiOiBcImnMgFwiLFxuICBcIsOvXCI6IFwiacyIXCIsXG4gIFwi4bivXCI6IFwiacyIzIFcIixcbiAgXCLEqVwiOiBcImnMg1wiLFxuICBcIsSrXCI6IFwiacyEXCIsXG4gIFwixK1cIjogXCJpzIZcIixcbiAgXCLHkFwiOiBcImnMjFwiLFxuICBcIsOuXCI6IFwiacyCXCIsXG4gIFwix7BcIjogXCJqzIxcIixcbiAgXCLEtVwiOiBcImrMglwiLFxuICBcIuG4sVwiOiBcImvMgVwiLFxuICBcIsepXCI6IFwia8yMXCIsXG4gIFwixLpcIjogXCJszIFcIixcbiAgXCLEvlwiOiBcImzMjFwiLFxuICBcIuG4v1wiOiBcIm3MgVwiLFxuICBcIuG5gVwiOiBcIm3Mh1wiLFxuICBcIsWEXCI6IFwibsyBXCIsXG4gIFwix7lcIjogXCJuzIBcIixcbiAgXCLDsVwiOiBcIm7Mg1wiLFxuICBcIsWIXCI6IFwibsyMXCIsXG4gIFwi4bmFXCI6IFwibsyHXCIsXG4gIFwiw7NcIjogXCJvzIFcIixcbiAgXCLDslwiOiBcIm/MgFwiLFxuICBcIsO2XCI6IFwib8yIXCIsXG4gIFwiyKtcIjogXCJvzIjMhFwiLFxuICBcIsO1XCI6IFwib8yDXCIsXG4gIFwi4bmNXCI6IFwib8yDzIFcIixcbiAgXCLhuY9cIjogXCJvzIPMiFwiLFxuICBcIsitXCI6IFwib8yDzIRcIixcbiAgXCLFjVwiOiBcIm/MhFwiLFxuICBcIuG5k1wiOiBcIm/MhMyBXCIsXG4gIFwi4bmRXCI6IFwib8yEzIBcIixcbiAgXCLFj1wiOiBcIm/MhlwiLFxuICBcIseSXCI6IFwib8yMXCIsXG4gIFwiw7RcIjogXCJvzIJcIixcbiAgXCLhu5FcIjogXCJvzILMgVwiLFxuICBcIuG7k1wiOiBcIm/MgsyAXCIsXG4gIFwi4buXXCI6IFwib8yCzINcIixcbiAgXCLIr1wiOiBcIm/Mh1wiLFxuICBcIsixXCI6IFwib8yHzIRcIixcbiAgXCLFkVwiOiBcIm/Mi1wiLFxuICBcIuG5lVwiOiBcInDMgVwiLFxuICBcIuG5l1wiOiBcInDMh1wiLFxuICBcIsWVXCI6IFwicsyBXCIsXG4gIFwixZlcIjogXCJyzIxcIixcbiAgXCLhuZlcIjogXCJyzIdcIixcbiAgXCLFm1wiOiBcInPMgVwiLFxuICBcIuG5pVwiOiBcInPMgcyHXCIsXG4gIFwixaFcIjogXCJzzIxcIixcbiAgXCLhuadcIjogXCJzzIzMh1wiLFxuICBcIsWdXCI6IFwic8yCXCIsXG4gIFwi4bmhXCI6IFwic8yHXCIsXG4gIFwi4bqXXCI6IFwidMyIXCIsXG4gIFwixaVcIjogXCJ0zIxcIixcbiAgXCLhuatcIjogXCJ0zIdcIixcbiAgXCLDulwiOiBcInXMgVwiLFxuICBcIsO5XCI6IFwidcyAXCIsXG4gIFwiw7xcIjogXCJ1zIhcIixcbiAgXCLHmFwiOiBcInXMiMyBXCIsXG4gIFwix5xcIjogXCJ1zIjMgFwiLFxuICBcIseWXCI6IFwidcyIzIRcIixcbiAgXCLHmlwiOiBcInXMiMyMXCIsXG4gIFwixalcIjogXCJ1zINcIixcbiAgXCLhublcIjogXCJ1zIPMgVwiLFxuICBcIsWrXCI6IFwidcyEXCIsXG4gIFwi4bm7XCI6IFwidcyEzIhcIixcbiAgXCLFrVwiOiBcInXMhlwiLFxuICBcIseUXCI6IFwidcyMXCIsXG4gIFwiw7tcIjogXCJ1zIJcIixcbiAgXCLFr1wiOiBcInXMilwiLFxuICBcIsWxXCI6IFwidcyLXCIsXG4gIFwi4bm9XCI6IFwidsyDXCIsXG4gIFwi4bqDXCI6IFwid8yBXCIsXG4gIFwi4bqBXCI6IFwid8yAXCIsXG4gIFwi4bqFXCI6IFwid8yIXCIsXG4gIFwixbVcIjogXCJ3zIJcIixcbiAgXCLhuodcIjogXCJ3zIdcIixcbiAgXCLhuphcIjogXCJ3zIpcIixcbiAgXCLhuo1cIjogXCJ4zIhcIixcbiAgXCLhuotcIjogXCJ4zIdcIixcbiAgXCLDvVwiOiBcInnMgVwiLFxuICBcIuG7s1wiOiBcInnMgFwiLFxuICBcIsO/XCI6IFwiecyIXCIsXG4gIFwi4bu5XCI6IFwiecyDXCIsXG4gIFwiyLNcIjogXCJ5zIRcIixcbiAgXCLFt1wiOiBcInnMglwiLFxuICBcIuG6j1wiOiBcInnMh1wiLFxuICBcIuG6mVwiOiBcInnMilwiLFxuICBcIsW6XCI6IFwiesyBXCIsXG4gIFwixb5cIjogXCJ6zIxcIixcbiAgXCLhupFcIjogXCJ6zIJcIixcbiAgXCLFvFwiOiBcInrMh1wiLFxuICBcIsOBXCI6IFwiQcyBXCIsXG4gIFwiw4BcIjogXCJBzIBcIixcbiAgXCLDhFwiOiBcIkHMiFwiLFxuICBcIseeXCI6IFwiQcyIzIRcIixcbiAgXCLDg1wiOiBcIkHMg1wiLFxuICBcIsSAXCI6IFwiQcyEXCIsXG4gIFwixIJcIjogXCJBzIZcIixcbiAgXCLhuq5cIjogXCJBzIbMgVwiLFxuICBcIuG6sFwiOiBcIkHMhsyAXCIsXG4gIFwi4bq0XCI6IFwiQcyGzINcIixcbiAgXCLHjVwiOiBcIkHMjFwiLFxuICBcIsOCXCI6IFwiQcyCXCIsXG4gIFwi4bqkXCI6IFwiQcyCzIFcIixcbiAgXCLhuqZcIjogXCJBzILMgFwiLFxuICBcIuG6qlwiOiBcIkHMgsyDXCIsXG4gIFwiyKZcIjogXCJBzIdcIixcbiAgXCLHoFwiOiBcIkHMh8yEXCIsXG4gIFwiw4VcIjogXCJBzIpcIixcbiAgXCLHulwiOiBcIkHMisyBXCIsXG4gIFwi4biCXCI6IFwiQsyHXCIsXG4gIFwixIZcIjogXCJDzIFcIixcbiAgXCLEjFwiOiBcIkPMjFwiLFxuICBcIsSIXCI6IFwiQ8yCXCIsXG4gIFwixIpcIjogXCJDzIdcIixcbiAgXCLEjlwiOiBcIkTMjFwiLFxuICBcIuG4ilwiOiBcIkTMh1wiLFxuICBcIsOJXCI6IFwiRcyBXCIsXG4gIFwiw4hcIjogXCJFzIBcIixcbiAgXCLDi1wiOiBcIkXMiFwiLFxuICBcIuG6vFwiOiBcIkXMg1wiLFxuICBcIsSSXCI6IFwiRcyEXCIsXG4gIFwi4biWXCI6IFwiRcyEzIFcIixcbiAgXCLhuJRcIjogXCJFzITMgFwiLFxuICBcIsSUXCI6IFwiRcyGXCIsXG4gIFwixJpcIjogXCJFzIxcIixcbiAgXCLDilwiOiBcIkXMglwiLFxuICBcIuG6vlwiOiBcIkXMgsyBXCIsXG4gIFwi4buAXCI6IFwiRcyCzIBcIixcbiAgXCLhu4RcIjogXCJFzILMg1wiLFxuICBcIsSWXCI6IFwiRcyHXCIsXG4gIFwi4bieXCI6IFwiRsyHXCIsXG4gIFwix7RcIjogXCJHzIFcIixcbiAgXCLhuKBcIjogXCJHzIRcIixcbiAgXCLEnlwiOiBcIkfMhlwiLFxuICBcIsemXCI6IFwiR8yMXCIsXG4gIFwixJxcIjogXCJHzIJcIixcbiAgXCLEoFwiOiBcIkfMh1wiLFxuICBcIuG4plwiOiBcIkjMiFwiLFxuICBcIsieXCI6IFwiSMyMXCIsXG4gIFwixKRcIjogXCJIzIJcIixcbiAgXCLhuKJcIjogXCJIzIdcIixcbiAgXCLDjVwiOiBcIknMgVwiLFxuICBcIsOMXCI6IFwiScyAXCIsXG4gIFwiw49cIjogXCJJzIhcIixcbiAgXCLhuK5cIjogXCJJzIjMgVwiLFxuICBcIsSoXCI6IFwiScyDXCIsXG4gIFwixKpcIjogXCJJzIRcIixcbiAgXCLErFwiOiBcIknMhlwiLFxuICBcIsePXCI6IFwiScyMXCIsXG4gIFwiw45cIjogXCJJzIJcIixcbiAgXCLEsFwiOiBcIknMh1wiLFxuICBcIsS0XCI6IFwiSsyCXCIsXG4gIFwi4biwXCI6IFwiS8yBXCIsXG4gIFwix6hcIjogXCJLzIxcIixcbiAgXCLEuVwiOiBcIkzMgVwiLFxuICBcIsS9XCI6IFwiTMyMXCIsXG4gIFwi4bi+XCI6IFwiTcyBXCIsXG4gIFwi4bmAXCI6IFwiTcyHXCIsXG4gIFwixYNcIjogXCJOzIFcIixcbiAgXCLHuFwiOiBcIk7MgFwiLFxuICBcIsORXCI6IFwiTsyDXCIsXG4gIFwixYdcIjogXCJOzIxcIixcbiAgXCLhuYRcIjogXCJOzIdcIixcbiAgXCLDk1wiOiBcIk/MgVwiLFxuICBcIsOSXCI6IFwiT8yAXCIsXG4gIFwiw5ZcIjogXCJPzIhcIixcbiAgXCLIqlwiOiBcIk/MiMyEXCIsXG4gIFwiw5VcIjogXCJPzINcIixcbiAgXCLhuYxcIjogXCJPzIPMgVwiLFxuICBcIuG5jlwiOiBcIk/Mg8yIXCIsXG4gIFwiyKxcIjogXCJPzIPMhFwiLFxuICBcIsWMXCI6IFwiT8yEXCIsXG4gIFwi4bmSXCI6IFwiT8yEzIFcIixcbiAgXCLhuZBcIjogXCJPzITMgFwiLFxuICBcIsWOXCI6IFwiT8yGXCIsXG4gIFwix5FcIjogXCJPzIxcIixcbiAgXCLDlFwiOiBcIk/MglwiLFxuICBcIuG7kFwiOiBcIk/MgsyBXCIsXG4gIFwi4buSXCI6IFwiT8yCzIBcIixcbiAgXCLhu5ZcIjogXCJPzILMg1wiLFxuICBcIsiuXCI6IFwiT8yHXCIsXG4gIFwiyLBcIjogXCJPzIfMhFwiLFxuICBcIsWQXCI6IFwiT8yLXCIsXG4gIFwi4bmUXCI6IFwiUMyBXCIsXG4gIFwi4bmWXCI6IFwiUMyHXCIsXG4gIFwixZRcIjogXCJSzIFcIixcbiAgXCLFmFwiOiBcIlLMjFwiLFxuICBcIuG5mFwiOiBcIlLMh1wiLFxuICBcIsWaXCI6IFwiU8yBXCIsXG4gIFwi4bmkXCI6IFwiU8yBzIdcIixcbiAgXCLFoFwiOiBcIlPMjFwiLFxuICBcIuG5plwiOiBcIlPMjMyHXCIsXG4gIFwixZxcIjogXCJTzIJcIixcbiAgXCLhuaBcIjogXCJTzIdcIixcbiAgXCLFpFwiOiBcIlTMjFwiLFxuICBcIuG5qlwiOiBcIlTMh1wiLFxuICBcIsOaXCI6IFwiVcyBXCIsXG4gIFwiw5lcIjogXCJVzIBcIixcbiAgXCLDnFwiOiBcIlXMiFwiLFxuICBcIseXXCI6IFwiVcyIzIFcIixcbiAgXCLHm1wiOiBcIlXMiMyAXCIsXG4gIFwix5VcIjogXCJVzIjMhFwiLFxuICBcIseZXCI6IFwiVcyIzIxcIixcbiAgXCLFqFwiOiBcIlXMg1wiLFxuICBcIuG5uFwiOiBcIlXMg8yBXCIsXG4gIFwixapcIjogXCJVzIRcIixcbiAgXCLhubpcIjogXCJVzITMiFwiLFxuICBcIsWsXCI6IFwiVcyGXCIsXG4gIFwix5NcIjogXCJVzIxcIixcbiAgXCLDm1wiOiBcIlXMglwiLFxuICBcIsWuXCI6IFwiVcyKXCIsXG4gIFwixbBcIjogXCJVzItcIixcbiAgXCLhubxcIjogXCJWzINcIixcbiAgXCLhuoJcIjogXCJXzIFcIixcbiAgXCLhuoBcIjogXCJXzIBcIixcbiAgXCLhuoRcIjogXCJXzIhcIixcbiAgXCLFtFwiOiBcIlfMglwiLFxuICBcIuG6hlwiOiBcIlfMh1wiLFxuICBcIuG6jFwiOiBcIljMiFwiLFxuICBcIuG6ilwiOiBcIljMh1wiLFxuICBcIsOdXCI6IFwiWcyBXCIsXG4gIFwi4buyXCI6IFwiWcyAXCIsXG4gIFwixbhcIjogXCJZzIhcIixcbiAgXCLhu7hcIjogXCJZzINcIixcbiAgXCLIslwiOiBcIlnMhFwiLFxuICBcIsW2XCI6IFwiWcyCXCIsXG4gIFwi4bqOXCI6IFwiWcyHXCIsXG4gIFwixblcIjogXCJazIFcIixcbiAgXCLFvVwiOiBcIlrMjFwiLFxuICBcIuG6kFwiOiBcIlrMglwiLFxuICBcIsW7XCI6IFwiWsyHXCIsXG4gIFwizqxcIjogXCLOscyBXCIsXG4gIFwi4b2wXCI6IFwizrHMgFwiLFxuICBcIuG+sVwiOiBcIs6xzIRcIixcbiAgXCLhvrBcIjogXCLOscyGXCIsXG4gIFwizq1cIjogXCLOtcyBXCIsXG4gIFwi4b2yXCI6IFwizrXMgFwiLFxuICBcIs6uXCI6IFwizrfMgVwiLFxuICBcIuG9tFwiOiBcIs63zIBcIixcbiAgXCLOr1wiOiBcIs65zIFcIixcbiAgXCLhvbZcIjogXCLOucyAXCIsXG4gIFwiz4pcIjogXCLOucyIXCIsXG4gIFwizpBcIjogXCLOucyIzIFcIixcbiAgXCLhv5JcIjogXCLOucyIzIBcIixcbiAgXCLhv5FcIjogXCLOucyEXCIsXG4gIFwi4b+QXCI6IFwizrnMhlwiLFxuICBcIs+MXCI6IFwizr/MgVwiLFxuICBcIuG9uFwiOiBcIs6/zIBcIixcbiAgXCLPjVwiOiBcIs+FzIFcIixcbiAgXCLhvbpcIjogXCLPhcyAXCIsXG4gIFwiz4tcIjogXCLPhcyIXCIsXG4gIFwizrBcIjogXCLPhcyIzIFcIixcbiAgXCLhv6JcIjogXCLPhcyIzIBcIixcbiAgXCLhv6FcIjogXCLPhcyEXCIsXG4gIFwi4b+gXCI6IFwiz4XMhlwiLFxuICBcIs+OXCI6IFwiz4nMgVwiLFxuICBcIuG9vFwiOiBcIs+JzIBcIixcbiAgXCLOjlwiOiBcIs6lzIFcIixcbiAgXCLhv6pcIjogXCLOpcyAXCIsXG4gIFwizqtcIjogXCLOpcyIXCIsXG4gIFwi4b+pXCI6IFwizqXMhFwiLFxuICBcIuG/qFwiOiBcIs6lzIZcIixcbiAgXCLOj1wiOiBcIs6pzIFcIixcbiAgXCLhv7pcIjogXCLOqcyAXCJcbn07XG5cbi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xuXG5jb25zdCBiaW5MZWZ0Q2FuY2VsbGVycyA9IFtcImJpblwiLCBcIm9wXCIsIFwib3BlblwiLCBcInB1bmN0XCIsIFwicmVsXCJdO1xuY29uc3Qgc2l6ZVJlZ0V4ID0gLyhbLStdPykgKihcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspICooW2Etel17Mn0pLztcbmNvbnN0IHRleHRSZWdFeCA9IC9eICpcXFxcdGV4dC87XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBwYXJzZXIgdXNlZCB0byBwYXJzZSBvdXQgYSBUZVggZXhwcmVzc2lvbiBmcm9tIHRoZVxuICogaW5wdXQuIFNpbmNlIFRlWCBpc24ndCBjb250ZXh0LWZyZWUsIHN0YW5kYXJkIHBhcnNlcnMgZG9uJ3Qgd29yayBwYXJ0aWN1bGFybHlcbiAqIHdlbGwuXG4gKlxuICogVGhlIHN0cmF0ZWd5IG9mIHRoaXMgcGFyc2VyIGlzIGFzIHN1Y2g6XG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zICh0aGUgYC5wYXJzZS4uLmAgb25lcykgdGFrZSBhIHBvc2l0aW9uIGluIHRoZSBjdXJyZW50XG4gKiBwYXJzZSBzdHJpbmcgdG8gcGFyc2UgdG9rZW5zIGZyb20uIFRoZSBsZXhlciAoZm91bmQgaW4gTGV4ZXIuanMsIHN0b3JlZCBhdFxuICogdGhpcy5ndWxsZXQubGV4ZXIpIGFsc28gc3VwcG9ydHMgcHVsbGluZyBvdXQgdG9rZW5zIGF0IGFyYml0cmFyeSBwbGFjZXMuIFdoZW5cbiAqIGluZGl2aWR1YWwgdG9rZW5zIGFyZSBuZWVkZWQgYXQgYSBwb3NpdGlvbiwgdGhlIGxleGVyIGlzIGNhbGxlZCB0byBwdWxsIG91dCBhXG4gKiB0b2tlbiwgd2hpY2ggaXMgdGhlbiB1c2VkLlxuICpcbiAqIFRoZSBwYXJzZXIgaGFzIGEgcHJvcGVydHkgY2FsbGVkIFwibW9kZVwiIGluZGljYXRpbmcgdGhlIG1vZGUgdGhhdFxuICogdGhlIHBhcnNlciBpcyBjdXJyZW50bHkgaW4uIEN1cnJlbnRseSBpdCBoYXMgdG8gYmUgb25lIG9mIFwibWF0aFwiIG9yXG4gKiBcInRleHRcIiwgd2hpY2ggZGVub3RlcyB3aGV0aGVyIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIGEgbWF0aC15XG4gKiBvbmUgb3IgYSB0ZXh0LXkgb25lIChlLmcuIGluc2lkZSBcXHRleHQpLiBDdXJyZW50bHksIHRoaXMgc2VydmVzIHRvXG4gKiBsaW1pdCB0aGUgZnVuY3Rpb25zIHdoaWNoIGNhbiBiZSB1c2VkIGluIHRleHQgbW9kZS5cbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgdGhlbiByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSB1c2VmdWwgZGF0YSB0aGF0XG4gKiB3YXMgcGFyc2VkIGF0IGl0cyBnaXZlbiBwb2ludCwgYW5kIGEgbmV3IHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHBhcnNlZFxuICogZGF0YS4gVGhlIG1haW4gZnVuY3Rpb25zIGNhbiBjYWxsIGVhY2ggb3RoZXIgYW5kIGNvbnRpbnVlIHRoZSBwYXJzaW5nIGJ5XG4gKiB1c2luZyB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYXMgYSBuZXcgc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogVGhlcmUgYXJlIGFsc28gZXh0cmEgYC5oYW5kbGUuLi5gIGZ1bmN0aW9ucywgd2hpY2ggcHVsbCBvdXQgc29tZSByZXVzZWRcbiAqIGZ1bmN0aW9uYWxpdHkgaW50byBzZWxmLWNvbnRhaW5lZCBmdW5jdGlvbnMuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyByZXR1cm4gUGFyc2VOb2Rlcy5cbiAqL1xuXG5jbGFzcyBQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MsIGlzUHJlYW1ibGUgPSBmYWxzZSkge1xuICAgIC8vIFN0YXJ0IGluIG1hdGggbW9kZVxuICAgIHRoaXMubW9kZSA9IFwibWF0aFwiO1xuICAgIC8vIENyZWF0ZSBhIG5ldyBtYWNybyBleHBhbmRlciAoZ3VsbGV0KSBhbmQgKGluZGlyZWN0bHkgdmlhIHRoYXQpIGFsc28gYVxuICAgIC8vIG5ldyBsZXhlciAobW91dGgpIGZvciB0aGlzIHBhcnNlciAoc3RvbWFjaCwgaW4gdGhlIGxhbmd1YWdlIG9mIFRlWClcbiAgICB0aGlzLmd1bGxldCA9IG5ldyBNYWNyb0V4cGFuZGVyKGlucHV0LCBzZXR0aW5ncywgdGhpcy5tb2RlKTtcbiAgICAvLyBTdG9yZSB0aGUgc2V0dGluZ3MgZm9yIHVzZSBpbiBwYXJzaW5nXG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIC8vIEFyZSB3ZSBkZWZpbmluZyBhIHByZWFtYmxlP1xuICAgIHRoaXMuaXNQcmVhbWJsZSA9IGlzUHJlYW1ibGU7XG4gICAgLy8gQ291bnQgbGVmdHJpZ2h0IGRlcHRoIChmb3IgXFxtaWRkbGUgZXJyb3JzKVxuICAgIHRoaXMubGVmdHJpZ2h0RGVwdGggPSAwO1xuICAgIHRoaXMucHJldkF0b21UeXBlID0gXCJcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICAgKiBhcHByb3ByaWF0ZSBlcnJvciBvdGhlcndpc2UuXG4gICAqL1xuICBleHBlY3QodGV4dCwgY29uc3VtZSA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5mZXRjaCgpLnRleHQgIT09IHRleHQpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBFeHBlY3RlZCAnJHt0ZXh0fScsIGdvdCAnJHt0aGlzLmZldGNoKCkudGV4dH0nYCwgdGhpcy5mZXRjaCgpKTtcbiAgICB9XG4gICAgaWYgKGNvbnN1bWUpIHtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkcyB0aGUgY3VycmVudCBsb29rYWhlYWQgdG9rZW4sIGNvbnNpZGVyaW5nIGl0IGNvbnN1bWVkLlxuICAgKi9cbiAgY29uc3VtZSgpIHtcbiAgICB0aGlzLm5leHRUb2tlbiA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IGxvb2thaGVhZCB0b2tlbiwgb3IgaWYgdGhlcmUgaXNuJ3Qgb25lIChhdCB0aGVcbiAgICogYmVnaW5uaW5nLCBvciBpZiB0aGUgcHJldmlvdXMgbG9va2FoZWFkIHRva2VuIHdhcyBjb25zdW1lKClkKSxcbiAgICogZmV0Y2ggdGhlIG5leHQgdG9rZW4gYXMgdGhlIG5ldyBsb29rYWhlYWQgdG9rZW4gYW5kIHJldHVybiBpdC5cbiAgICovXG4gIGZldGNoKCkge1xuICAgIGlmICh0aGlzLm5leHRUb2tlbiA9PSBudWxsKSB7XG4gICAgICB0aGlzLm5leHRUb2tlbiA9IHRoaXMuZ3VsbGV0LmV4cGFuZE5leHRUb2tlbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW47XG4gIH1cblxuICAvKipcbiAgICogU3dpdGNoZXMgYmV0d2VlbiBcInRleHRcIiBhbmQgXCJtYXRoXCIgbW9kZXMuXG4gICAqL1xuICBzd2l0Y2hNb2RlKG5ld01vZGUpIHtcbiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlO1xuICAgIHRoaXMuZ3VsbGV0LnN3aXRjaE1vZGUobmV3TW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBwYXJzaW5nIGZ1bmN0aW9uLCB3aGljaCBwYXJzZXMgYW4gZW50aXJlIGlucHV0LlxuICAgKi9cbiAgcGFyc2UoKSB7XG4gICAgLy8gQ3JlYXRlIGEgZ3JvdXAgbmFtZXNwYWNlIGZvciBldmVyeSAkLi4uJCwgJCQuLi4kJCwgXFxbLi4uXFxdLilcbiAgICAvLyBBIFxcZGVmIGlzIHRoZW4gdmFsaWQgb25seSB3aXRoaW4gdGhhdCBwYWlyIG9mIGRlbGltaXRlcnMuXG4gICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuY29sb3JJc1RleHRDb2xvcikge1xuICAgICAgLy8gVXNlIG9sZCBcXGNvbG9yIGJlaGF2aW9yIChzYW1lIGFzIExhVGVYJ3MgXFx0ZXh0Y29sb3IpIGlmIHJlcXVlc3RlZC5cbiAgICAgIC8vIFdlIGRvIHRoaXMgd2l0aGluIHRoZSBncm91cCBmb3IgdGhlIG1hdGggZXhwcmVzc2lvbiwgc28gaXQgZG9lc24ndFxuICAgICAgLy8gcG9sbHV0ZSBzZXR0aW5ncy5tYWNyb3MuXG4gICAgICB0aGlzLmd1bGxldC5tYWNyb3Muc2V0KFwiXFxcXGNvbG9yXCIsIFwiXFxcXHRleHRjb2xvclwiKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGlucHV0XG4gICAgY29uc3QgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7XG5cbiAgICAvLyBJZiB3ZSBzdWNjZWVkZWQsIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIEVPRiBhdCB0aGUgZW5kXG4gICAgdGhpcy5leHBlY3QoXCJFT0ZcIik7XG5cbiAgICBpZiAodGhpcy5pc1ByZWFtYmxlKSB7XG4gICAgICBjb25zdCBtYWNyb3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5ndWxsZXQubWFjcm9zLmN1cnJlbnQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBtYWNyb3Nba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgICAgcmV0dXJuIG1hY3Jvc1xuICAgIH1cblxuICAgIC8vIFRoZSBvbmx5IGxvY2FsIG1hY3JvIHRoYXQgd2Ugd2FudCB0byBzYXZlIGlzIGZyb20gXFx0YWcuXG4gICAgY29uc3QgdGFnID0gdGhpcy5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIik7XG5cbiAgICAvLyBFbmQgdGhlIGdyb3VwIG5hbWVzcGFjZSBmb3IgdGhlIGV4cHJlc3Npb25cbiAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuXG4gICAgaWYgKHRhZykgeyB0aGlzLmd1bGxldC5tYWNyb3MuY3VycmVudFtcIlxcXFxkZkB0YWdcIl0gPSB0YWc7IH1cblxuICAgIHJldHVybiBwYXJzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZW5kT2ZFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiBbXCJ9XCIsIFwiXFxcXGVuZGdyb3VwXCIsIFwiXFxcXGVuZFwiLCBcIlxcXFxyaWdodFwiLCBcIlxcXFxlbmR0b2dnbGVcIiwgXCImXCJdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IHBhcnNlIGEgc2VwYXJhdGUgc2VxdWVuY2Ugb2YgdG9rZW5zIGFzIGEgc2VwYXJhdGUgam9iLlxuICAgKiBUb2tlbnMgc2hvdWxkIGJlIHNwZWNpZmllZCBpbiByZXZlcnNlIG9yZGVyLCBhcyBpbiBhIE1hY3JvRGVmaW5pdGlvbi5cbiAgICovXG4gIHN1YnBhcnNlKHRva2Vucykge1xuICAgIC8vIFNhdmUgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgY3VycmVudCBqb2IuXG4gICAgY29uc3Qgb2xkVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB0aGlzLmNvbnN1bWUoKTtcblxuICAgIC8vIFJ1biB0aGUgbmV3IGpvYiwgdGVybWluYXRpbmcgaXQgd2l0aCBhbiBleGNlc3MgJ30nXG4gICAgdGhpcy5ndWxsZXQucHVzaFRva2VuKG5ldyBUb2tlbihcIn1cIikpO1xuICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICBjb25zdCBwYXJzZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICB0aGlzLmV4cGVjdChcIn1cIik7XG5cbiAgICAvLyBSZXN0b3JlIHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIGN1cnJlbnQgam9iLlxuICAgIHRoaXMubmV4dFRva2VuID0gb2xkVG9rZW47XG5cbiAgICByZXR1cm4gcGFyc2U7XG4gIH1cblxuLyoqXG4gICAqIFBhcnNlcyBhbiBcImV4cHJlc3Npb25cIiwgd2hpY2ggaXMgYSBsaXN0IG9mIGF0b21zLlxuICAgKlxuICAgKiBgYnJlYWtPbkluZml4YDogU2hvdWxkIHRoZSBwYXJzaW5nIHN0b3Agd2hlbiB3ZSBoaXQgaW5maXggbm9kZXM/IFRoaXNcbiAgICogICAgICAgICAgICAgICAgIGhhcHBlbnMgd2hlbiBmdW5jdGlvbnMgaGF2ZSBoaWdoZXIgcHJlY2VkZW5jZSBoYW4gaW5maXhcbiAgICogICAgICAgICAgICAgICAgIG5vZGVzIGluIGltcGxpY2l0IHBhcnNlcy5cbiAgICpcbiAgICogYGJyZWFrT25Ub2tlblRleHRgOiBUaGUgdGV4dCBvZiB0aGUgdG9rZW4gdGhhdCB0aGUgZXhwcmVzc2lvbiBzaG91bGQgZW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgd2l0aCwgb3IgYG51bGxgIGlmIHNvbWV0aGluZyBlbHNlIHNob3VsZCBlbmQgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogYGJyZWFrT25NaWRkbGVgOiBcXGNvbG9yLCBcXG92ZXIsIGFuZCBvbGQgc3R5bGluZyBmdW5jdGlvbnMgd29yayBvbiBhbiBpbXBsaWNpdCBncm91cC5cbiAgICogICAgICAgICAgICAgICAgICBUaGVzZSBncm91cHMgZW5kIGp1c3QgYmVmb3JlIHRoZSB1c3VhbCB0b2tlbnMsIGJ1dCB0aGV5IGFsc29cbiAgICogICAgICAgICAgICAgICAgICBlbmQganVzdCBiZWZvcmUgYFxcbWlkZGxlYC5cbiAgICovXG4gIHBhcnNlRXhwcmVzc2lvbihicmVha09uSW5maXgsIGJyZWFrT25Ub2tlblRleHQsIGJyZWFrT25NaWRkbGUpIHtcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgdGhpcy5wcmV2QXRvbVR5cGUgPSBcIlwiO1xuICAgIC8vIEtlZXAgYWRkaW5nIGF0b21zIHRvIHRoZSBib2R5IHVudGlsIHdlIGNhbid0IHBhcnNlIGFueSBtb3JlIGF0b21zIChlaXRoZXJcbiAgICAvLyB3ZSByZWFjaGVkIHRoZSBlbmQsIGEgfSwgb3IgYSBcXHJpZ2h0KVxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZ25vcmUgc3BhY2VzIGluIG1hdGggbW9kZVxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXggPSB0aGlzLmZldGNoKCk7XG4gICAgICBpZiAoUGFyc2VyLmVuZE9mRXhwcmVzc2lvbi5pbmRleE9mKGxleC50ZXh0KSAhPT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoYnJlYWtPblRva2VuVGV4dCAmJiBsZXgudGV4dCA9PT0gYnJlYWtPblRva2VuVGV4dCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChicmVha09uTWlkZGxlICYmIGxleC50ZXh0ID09PSBcIlxcXFxtaWRkbGVcIikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGJyZWFrT25JbmZpeCAmJiBmdW5jdGlvbnNbbGV4LnRleHRdICYmIGZ1bmN0aW9uc1tsZXgudGV4dF0uaW5maXgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBhdG9tID0gdGhpcy5wYXJzZUF0b20oYnJlYWtPblRva2VuVGV4dCk7XG4gICAgICBpZiAoIWF0b20pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKGF0b20udHlwZSA9PT0gXCJpbnRlcm5hbFwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYm9keS5wdXNoKGF0b20pO1xuICAgICAgLy8gS2VlcCBhIHJlY29yZCBvZiB0aGUgYXRvbSB0eXBlLCBzbyB0aGF0IG9wLmpzIGNhbiBzZXQgY29ycmVjdCBzcGFjaW5nLlxuICAgICAgdGhpcy5wcmV2QXRvbVR5cGUgPSBhdG9tLnR5cGUgPT09IFwiYXRvbVwiID8gYXRvbS5mYW1pbHkgOiBhdG9tLnR5cGU7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICB0aGlzLmZvcm1MaWdhdHVyZXMoYm9keSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhbmRsZUluZml4Tm9kZXMoYm9keSk7XG4gIH1cblxuICAvKipcbiAgICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gICAqIGFzIFxcZnJhYy5cbiAgICpcbiAgICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICAgKiB0aGVuIHRoZSBleHByZXNzaW9uIGlzIGFtYmlndW91cy4gIFRoaXMgY2FuIGJlIHJlc29sdmVkIGJ5IGFkZGluZyB7fS5cbiAgICovXG4gIGhhbmRsZUluZml4Tm9kZXMoYm9keSkge1xuICAgIGxldCBvdmVySW5kZXggPSAtMTtcbiAgICBsZXQgZnVuY05hbWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChib2R5W2ldLnR5cGUgPT09IFwiaW5maXhcIikge1xuICAgICAgICBpZiAob3ZlckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwib25seSBvbmUgaW5maXggb3BlcmF0b3IgcGVyIGdyb3VwXCIsIGJvZHlbaV0udG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIG92ZXJJbmRleCA9IGk7XG4gICAgICAgIGZ1bmNOYW1lID0gYm9keVtpXS5yZXBsYWNlV2l0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3ZlckluZGV4ICE9PSAtMSAmJiBmdW5jTmFtZSkge1xuICAgICAgbGV0IG51bWVyTm9kZTtcbiAgICAgIGxldCBkZW5vbU5vZGU7XG5cbiAgICAgIGNvbnN0IG51bWVyQm9keSA9IGJvZHkuc2xpY2UoMCwgb3ZlckluZGV4KTtcbiAgICAgIGNvbnN0IGRlbm9tQm9keSA9IGJvZHkuc2xpY2Uob3ZlckluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChudW1lckJvZHkubGVuZ3RoID09PSAxICYmIG51bWVyQm9keVswXS50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgbnVtZXJOb2RlID0gbnVtZXJCb2R5WzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtZXJOb2RlID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IHRoaXMubW9kZSwgYm9keTogbnVtZXJCb2R5IH07XG4gICAgICB9XG5cbiAgICAgIGlmIChkZW5vbUJvZHkubGVuZ3RoID09PSAxICYmIGRlbm9tQm9keVswXS50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgZGVub21Ob2RlID0gZGVub21Cb2R5WzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVub21Ob2RlID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IHRoaXMubW9kZSwgYm9keTogZGVub21Cb2R5IH07XG4gICAgICB9XG5cbiAgICAgIGxldCBub2RlO1xuICAgICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcYWJvdmVmcmFjXCIpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbnVtZXJOb2RlLCBib2R5W292ZXJJbmRleF0sIGRlbm9tTm9kZV0sIFtdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW251bWVyTm9kZSwgZGVub21Ob2RlXSwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBhIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCB3aXRoIG5pY2UgZXJyb3JzLlxuICAgKi9cbiAgaGFuZGxlU3VwU3Vic2NyaXB0KFxuICAgIG5hbWUgLy8gRm9yIGVycm9yIHJlcG9ydGluZy5cbiAgKSB7XG4gICAgY29uc3Qgc3ltYm9sVG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgY29uc3Qgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsgLy8gaWdub3JlIHNwYWNlcyBiZWZvcmUgc3VwL3N1YnNjcmlwdCBhcmd1bWVudFxuICAgIGNvbnN0IGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUpO1xuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBncm91cCBhZnRlciAnXCIgKyBzeW1ib2wgKyBcIidcIiwgc3ltYm9sVG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dHVhbCBpbnB1dCBvZiBhbiB1bnN1cHBvcnRlZCBjb21tYW5kIGludG8gYSB0ZXh0IG5vZGVcbiAgICogY29udGFpbmVkIHdpdGhpbiBhIGNvbG9yIG5vZGUgd2hvc2UgY29sb3IgaXMgZGV0ZXJtaW5lZCBieSBlcnJvckNvbG9yXG4gICAqL1xuICBmb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0KSB7XG4gICAgY29uc3QgdGV4dG9yZEFycmF5ID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRleHRvcmRBcnJheS5wdXNoKHsgdHlwZTogXCJ0ZXh0b3JkXCIsIG1vZGU6IFwidGV4dFwiLCB0ZXh0OiB0ZXh0W2ldIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHROb2RlID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBib2R5OiB0ZXh0b3JkQXJyYXlcbiAgICB9O1xuXG4gICAgY29uc3QgY29sb3JOb2RlID0ge1xuICAgICAgdHlwZTogXCJjb2xvclwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgY29sb3I6IHRoaXMuc2V0dGluZ3MuZXJyb3JDb2xvcixcbiAgICAgIGJvZHk6IFt0ZXh0Tm9kZV1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGNvbG9yTm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCB3aXRoIG9wdGlvbmFsIHN1cGVyL3N1YnNjcmlwdHMuXG4gICAqL1xuICBwYXJzZUF0b20oYnJlYWtPblRva2VuVGV4dCkge1xuICAgIC8vIFRoZSBib2R5IG9mIGFuIGF0b20gaXMgYW4gaW1wbGljaXQgZ3JvdXAsIHNvIHRoYXQgdGhpbmdzIGxpa2VcbiAgICAvLyBcXGxlZnQoeFxccmlnaHQpXjIgd29yayBjb3JyZWN0bHkuXG4gICAgY29uc3QgYmFzZSA9IHRoaXMucGFyc2VHcm91cChcImF0b21cIiwgYnJlYWtPblRva2VuVGV4dCk7XG5cbiAgICAvLyBJbiB0ZXh0IG1vZGUsIHdlIGRvbid0IGhhdmUgc3VwZXJzY3JpcHRzIG9yIHN1YnNjcmlwdHNcbiAgICBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGJhc2UgbWF5IGJlIGVtcHR5IChpLmUuIG51bGwpIGF0IHRoaXMgcG9pbnQuXG5cbiAgICBsZXQgc3VwZXJzY3JpcHQ7XG4gICAgbGV0IHN1YnNjcmlwdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gR3VhcmFudGVlZCBpbiBtYXRoIG1vZGUsIHNvIGVhdCBhbnkgc3BhY2VzIGZpcnN0LlxuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7XG5cbiAgICAgIC8vIExleCB0aGUgZmlyc3QgdG9rZW5cbiAgICAgIGNvbnN0IGxleCA9IHRoaXMuZmV0Y2goKTtcblxuICAgICAgaWYgKGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIiB8fCBsZXgudGV4dCA9PT0gXCJcXFxcbm9saW1pdHNcIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBsaW1pdCBjb250cm9sXG4gICAgICAgIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcFwiKSB7XG4gICAgICAgICAgY29uc3QgbGltaXRzID0gbGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiO1xuICAgICAgICAgIGJhc2UubGltaXRzID0gbGltaXRzO1xuICAgICAgICAgIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIikge1xuICAgICAgICAgIGlmIChiYXNlLmFsd2F5c0hhbmRsZVN1cFN1Yikge1xuICAgICAgICAgICAgYmFzZS5saW1pdHMgPSBsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiTGltaXQgY29udHJvbHMgbXVzdCBmb2xsb3cgYSBtYXRoIG9wZXJhdG9yXCIsIGxleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl5cIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBzdXBlcnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyc2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdXBlcnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiX1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1YnNjcmlwdCBzdGFydFxuICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3Vic2NyaXB0XCIsIGxleCk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaXB0ID0gdGhpcy5oYW5kbGVTdXBTdWJzY3JpcHQoXCJzdWJzY3JpcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIidcIikge1xuICAgICAgICAvLyBXZSBnb3QgYSBwcmltZVxuICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByaW1lID0geyB0eXBlOiBcInRleHRvcmRcIiwgbW9kZTogdGhpcy5tb2RlLCB0ZXh0OiBcIlxcXFxwcmltZVwiIH07XG5cbiAgICAgICAgLy8gTWFueSBwcmltZXMgY2FuIGJlIGdyb3VwZWQgdG9nZXRoZXIsIHNvIHdlIGhhbmRsZSB0aGlzIGhlcmVcbiAgICAgICAgY29uc3QgcHJpbWVzID0gW3ByaW1lXTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIC8vIEtlZXAgbGV4aW5nIHRva2VucyB1bnRpbCB3ZSBnZXQgc29tZXRoaW5nIHRoYXQncyBub3QgYSBwcmltZVxuICAgICAgICB3aGlsZSAodGhpcy5mZXRjaCgpLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgLy8gRm9yIGVhY2ggb25lLCBhZGQgYW5vdGhlciBwcmltZSB0byB0aGUgbGlzdFxuICAgICAgICAgIHByaW1lcy5wdXNoKHByaW1lKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgc3VwZXJzY3JpcHQgZm9sbG93aW5nIHRoZSBwcmltZXMsIGNvbWJpbmUgdGhhdFxuICAgICAgICAvLyBzdXBlcnNjcmlwdCBpbiB3aXRoIHRoZSBwcmltZXMuXG4gICAgICAgIGlmICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICBwcmltZXMucHVzaCh0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQdXQgZXZlcnl0aGluZyBpbnRvIGFuIG9yZGdyb3VwIGFzIHRoZSBzdXBlcnNjcmlwdFxuICAgICAgICBzdXBlcnNjcmlwdCA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiB0aGlzLm1vZGUsIGJvZHk6IHByaW1lcyB9O1xuICAgICAgfSBlbHNlIGlmICh1U3Vic0FuZFN1cHNbbGV4LnRleHRdKSB7XG4gICAgICAgIC8vIEEgVW5pY29kZSBzdWJzY3JpcHQgb3Igc3VwZXJzY3JpcHQgY2hhcmFjdGVyLlxuICAgICAgICAvLyBXZSB0cmVhdCB0aGVzZSBzaW1pbGFybHkgdG8gdGhlIHVuaWNvZGUtbWF0aCBwYWNrYWdlLlxuICAgICAgICAvLyBTbyB3ZSByZW5kZXIgYSBzdHJpbmcgb2YgVW5pY29kZSAoc3VifHN1cGVyKXNjcmlwdHMgdGhlXG4gICAgICAgIC8vIHNhbWUgYXMgYSAoc3VifHN1cGVyKXNjcmlwdCBvZiByZWd1bGFyIGNoYXJhY3RlcnMuXG4gICAgICAgIGNvbnN0IGlzU3ViID0gdW5pY29kZVN1YlJlZ0V4LnRlc3QobGV4LnRleHQpO1xuICAgICAgICBjb25zdCBzdWJzdXBUb2tlbnMgPSBbXTtcbiAgICAgICAgc3Vic3VwVG9rZW5zLnB1c2gobmV3IFRva2VuKHVTdWJzQW5kU3Vwc1tsZXgudGV4dF0pKTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIC8vIENvbnRpbnVlIGZldGNoaW5nIHRva2VucyB0byBmaWxsIG91dCB0aGUgZ3JvdXAuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmZldGNoKCkudGV4dDtcbiAgICAgICAgICBpZiAoISh1U3Vic0FuZFN1cHNbdG9rZW5dKSkgeyBicmVhayB9XG4gICAgICAgICAgaWYgKHVuaWNvZGVTdWJSZWdFeC50ZXN0KHRva2VuKSAhPT0gaXNTdWIpIHsgYnJlYWsgfVxuICAgICAgICAgIHN1YnN1cFRva2Vucy51bnNoaWZ0KG5ldyBUb2tlbih1U3Vic0FuZFN1cHNbdG9rZW5dKSk7XG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IGNyZWF0ZSBhIChzdWJ8c3VwZXIpc2NyaXB0LlxuICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5zdWJwYXJzZShzdWJzdXBUb2tlbnMpO1xuICAgICAgICBpZiAoaXNTdWIpIHtcbiAgICAgICAgICBzdWJzY3JpcHQgPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogXCJtYXRoXCIsIGJvZHkgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdXBlcnNjcmlwdCA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiBcIm1hdGhcIiwgYm9keSB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBpdCB3YXNuJ3QgXiwgXywgYSBVbmljb2RlIChzdWJ8c3VwZXIpc2NyaXB0LCBvciAnLCBzdG9wIHBhcnNpbmcgc3VwZXIvc3Vic2NyaXB0c1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3VwZXJzY3JpcHQgfHwgc3Vic2NyaXB0KSB7XG4gICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09IFwibXVsdGlzY3JpcHRcIiAmJiAhYmFzZS5wb3N0c2NyaXB0cykge1xuICAgICAgICAvLyBiYXNlIGlzIHRoZSByZXN1bHQgb2YgYSBcXHByZXNjcmlwdCBmdW5jdGlvbi5cbiAgICAgICAgLy8gV3JpdGUgdGhlIHN1Yi0gJiBzdXBlcnNjcmlwdHMgaW50byB0aGUgbXVsdGlzY3JpcHQgZWxlbWVudC5cbiAgICAgICAgYmFzZS5wb3N0c2NyaXB0cyA9IHsgc3VwOiBzdXBlcnNjcmlwdCwgc3ViOiBzdWJzY3JpcHQgfTtcbiAgICAgICAgcmV0dXJuIGJhc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGdvdCBlaXRoZXIgYSBzdXBlcnNjcmlwdCBvciBzdWJzY3JpcHQsIGNyZWF0ZSBhIHN1cHN1YlxuICAgICAgICBjb25zdCBpc0ZvbGxvd2VkQnlEZWxpbWl0ZXIgPSAoIWJhc2UgfHwgYmFzZS50eXBlICE9PSBcIm9wXCIgJiYgYmFzZS50eXBlICE9PSBcIm9wZXJhdG9ybmFtZVwiKVxuICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgOiBpc0RlbGltaXRlcih0aGlzLm5leHRUb2tlbi50ZXh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInN1cHN1YlwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBiYXNlOiBiYXNlLFxuICAgICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgICAgc3ViOiBzdWJzY3JpcHQsXG4gICAgICAgICAgaXNGb2xsb3dlZEJ5RGVsaW1pdGVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIHJldHVybiB0aGUgb3JpZ2luYWwgYm9keVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gICAqL1xuICBwYXJzZUZ1bmN0aW9uKFxuICAgIGJyZWFrT25Ub2tlblRleHQsXG4gICAgbmFtZSAvLyBGb3IgZGV0ZXJtaW5pbmcgaXRzIGNvbnRleHRcbiAgKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgY29uc3QgZnVuYyA9IHRva2VuLnRleHQ7XG4gICAgY29uc3QgZnVuY0RhdGEgPSBmdW5jdGlvbnNbZnVuY107XG4gICAgaWYgKCFmdW5jRGF0YSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBjb25zdW1lIGNvbW1hbmQgdG9rZW5cblxuICAgIGlmIChuYW1lICYmIG5hbWUgIT09IFwiYXRvbVwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5Bcmd1bWVudCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIFwiR290IGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgd2l0aCBubyBhcmd1bWVudHNcIiArIChuYW1lID8gXCIgYXMgXCIgKyBuYW1lIDogXCJcIiksXG4gICAgICAgIHRva2VuXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDYW4ndCB1c2UgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyBpbiB0ZXh0IG1vZGVcIiwgdG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIiAmJiBmdW5jRGF0YS5hbGxvd2VkSW5NYXRoID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDYW4ndCB1c2UgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyBpbiBtYXRoIG1vZGVcIiwgdG9rZW4pO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZBdG9tVHlwZSA9IHRoaXMucHJldkF0b21UeXBlO1xuICAgIGNvbnN0IHsgYXJncywgb3B0QXJncyB9ID0gdGhpcy5wYXJzZUFyZ3VtZW50cyhmdW5jLCBmdW5jRGF0YSk7XG4gICAgdGhpcy5wcmV2QXRvbVR5cGUgPSBwcmV2QXRvbVR5cGU7XG4gICAgcmV0dXJuIHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIG9wdEFyZ3MsIHRva2VuLCBicmVha09uVG9rZW5UZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICAgKi9cbiAgY2FsbEZ1bmN0aW9uKG5hbWUsIGFyZ3MsIG9wdEFyZ3MsIHRva2VuLCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGZ1bmNOYW1lOiBuYW1lLFxuICAgICAgcGFyc2VyOiB0aGlzLFxuICAgICAgdG9rZW4sXG4gICAgICBicmVha09uVG9rZW5UZXh0XG4gICAgfTtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb25zW25hbWVdO1xuICAgIGlmIChmdW5jICYmIGZ1bmMuaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGZ1bmMuaGFuZGxlcihjb250ZXh0LCBhcmdzLCBvcHRBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYE5vIGZ1bmN0aW9uIGhhbmRsZXIgZm9yICR7bmFtZX1gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBhcmd1bWVudHMgb2YgYSBmdW5jdGlvbiBvciBlbnZpcm9ubWVudFxuICAgKi9cbiAgcGFyc2VBcmd1bWVudHMoXG4gICAgZnVuYywgLy8gU2hvdWxkIGxvb2sgbGlrZSBcIlxcbmFtZVwiIG9yIFwiXFxiZWdpbntuYW1lfVwiLlxuICAgIGZ1bmNEYXRhXG4gICkge1xuICAgIGNvbnN0IHRvdGFsQXJncyA9IGZ1bmNEYXRhLm51bUFyZ3MgKyBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3M7XG4gICAgaWYgKHRvdGFsQXJncyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHsgYXJnczogW10sIG9wdEFyZ3M6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGNvbnN0IG9wdEFyZ3MgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxBcmdzOyBpKyspIHtcbiAgICAgIGxldCBhcmdUeXBlID0gZnVuY0RhdGEuYXJnVHlwZXMgJiYgZnVuY0RhdGEuYXJnVHlwZXNbaV07XG4gICAgICBjb25zdCBpc09wdGlvbmFsID0gaSA8IGZ1bmNEYXRhLm51bU9wdGlvbmFsQXJncztcblxuICAgICAgaWYgKFxuICAgICAgICAoZnVuY0RhdGEucHJpbWl0aXZlICYmIGFyZ1R5cGUgPT0gbnVsbCkgfHxcbiAgICAgICAgLy8gXFxzcXJ0IGV4cGFuZHMgaW50byBwcmltaXRpdmUgaWYgb3B0aW9uYWwgYXJndW1lbnQgZG9lc24ndCBleGlzdFxuICAgICAgICAoZnVuY0RhdGEudHlwZSA9PT0gXCJzcXJ0XCIgJiYgaSA9PT0gMSAmJiBvcHRBcmdzWzBdID09IG51bGwpXG4gICAgICApIHtcbiAgICAgICAgYXJnVHlwZSA9IFwicHJpbWl0aXZlXCI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZyA9IHRoaXMucGFyc2VHcm91cE9mVHlwZShgYXJndW1lbnQgdG8gJyR7ZnVuY30nYCwgYXJnVHlwZSwgaXNPcHRpb25hbCk7XG4gICAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgICBvcHRBcmdzLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnICE9IG51bGwpIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzaG91bGQgYmUgdW5yZWFjaGFibGVcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJOdWxsIGFyZ3VtZW50LCBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWdcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgYXJncywgb3B0QXJncyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwIHdoZW4gdGhlIG1vZGUgaXMgY2hhbmdpbmcuXG4gICAqL1xuICBwYXJzZUdyb3VwT2ZUeXBlKG5hbWUsIHR5cGUsIG9wdGlvbmFsKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNpemVHcm91cChvcHRpb25hbCk7XG4gICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVXJsR3JvdXAob3B0aW9uYWwpO1xuICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgdHlwZSk7XG4gICAgICBjYXNlIFwiaGJveFwiOiB7XG4gICAgICAgIC8vIGhib3ggYXJndW1lbnQgdHlwZSB3cmFwcyB0aGUgYXJndW1lbnQgaW4gdGhlIGVxdWl2YWxlbnQgb2ZcbiAgICAgICAgLy8gXFxoYm94LCB3aGljaCBpcyBsaWtlIFxcdGV4dCBidXQgc3dpdGNoaW5nIHRvIFxcdGV4dHN0eWxlIHNpemUuXG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIFwidGV4dFwiKTtcbiAgICAgICAgcmV0dXJuIGdyb3VwICE9IG51bGxcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgICAgICAgbW9kZTogZ3JvdXAubW9kZSxcbiAgICAgICAgICAgIGJvZHk6IFtncm91cF0sXG4gICAgICAgICAgICBzY3JpcHRMZXZlbDogXCJ0ZXh0XCIgLy8gc2ltdWxhdGUgXFx0ZXh0c3R5bGVcbiAgICAgICAgICB9XG4gICAgICAgICAgOiBudWxsO1xuICAgICAgfVxuICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwicmF3XCIsIG9wdGlvbmFsKTtcbiAgICAgICAgcmV0dXJuIHRva2VuICE9IG51bGxcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6IFwicmF3XCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIHN0cmluZzogdG9rZW4udGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9XG4gICAgICBjYXNlIFwicHJpbWl0aXZlXCI6IHtcbiAgICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJBIHByaW1pdGl2ZSBhcmd1bWVudCBjYW5ub3QgYmUgb3B0aW9uYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAobmFtZSk7XG4gICAgICAgIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBncm91cCBhcyBcIiArIG5hbWUsIHRoaXMuZmV0Y2goKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9yaWdpbmFsXCI6XG4gICAgICBjYXNlIG51bGw6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5rbm93biBncm91cCB0eXBlIGFzIFwiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzY2FyZCBhbnkgc3BhY2UgdG9rZW5zLCBmZXRjaGluZyB0aGUgbmV4dCBub24tc3BhY2UgdG9rZW4uXG4gICAqL1xuICBjb25zdW1lU3BhY2VzKCkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMuZmV0Y2goKS50ZXh0O1xuICAgICAgLy8gXFx1ZmUwZSBpcyB0aGUgVW5pY29kZSB2YXJpYXRpb24gc2VsZWN0b3IgdG8gc3VwcmVzcyBlbW9qaS4gSWdub3JlIGl0LlxuICAgICAgaWYgKGNoID09PSBcIiBcIiB8fCBjaCA9PT0gXCJcXHUwMGEwXCIgfHwgY2ggPT09IFwiXFx1ZmUwZVwiKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAsIGVzc2VudGlhbGx5IHJldHVybmluZyB0aGUgc3RyaW5nIGZvcm1lZCBieSB0aGVcbiAgICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHBhcnNlU3RyaW5nR3JvdXAoXG4gICAgbW9kZU5hbWUsIC8vIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAgb3B0aW9uYWxcbiAgKSB7XG4gICAgY29uc3QgYXJnVG9rZW4gPSB0aGlzLmd1bGxldC5zY2FuQXJndW1lbnQob3B0aW9uYWwpO1xuICAgIGlmIChhcmdUb2tlbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgbGV0IG5leHRUb2tlbjtcbiAgICB3aGlsZSAoKG5leHRUb2tlbiA9IHRoaXMuZmV0Y2goKSkudGV4dCAhPT0gXCJFT0ZcIikge1xuICAgICAgc3RyICs9IG5leHRUb2tlbi50ZXh0O1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuICAgIHRoaXMuY29uc3VtZSgpOyAvLyBjb25zdW1lIHRoZSBlbmQgb2YgdGhlIGFyZ3VtZW50XG4gICAgYXJnVG9rZW4udGV4dCA9IHN0cjtcbiAgICByZXR1cm4gYXJnVG9rZW47XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgcmVnZXgtZGVsaW1pdGVkIGdyb3VwOiB0aGUgbGFyZ2VzdCBzZXF1ZW5jZSBvZiB0b2tlbnNcbiAgICogd2hvc2UgY29uY2F0ZW5hdGVkIHN0cmluZ3MgbWF0Y2ggYHJlZ2V4YC4gUmV0dXJucyB0aGUgc3RyaW5nXG4gICAqIGZvcm1lZCBieSB0aGUgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIHBhcnNlUmVnZXhHcm91cChcbiAgICByZWdleCxcbiAgICBtb2RlTmFtZSAvLyBVc2VkIHRvIGRlc2NyaWJlIHRoZSBtb2RlIGluIGVycm9yIG1lc3NhZ2VzLlxuICApIHtcbiAgICBjb25zdCBmaXJzdFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgIGxldCBsYXN0VG9rZW4gPSBmaXJzdFRva2VuO1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGxldCBuZXh0VG9rZW47XG4gICAgd2hpbGUgKChuZXh0VG9rZW4gPSB0aGlzLmZldGNoKCkpLnRleHQgIT09IFwiRU9GXCIgJiYgcmVnZXgudGVzdChzdHIgKyBuZXh0VG9rZW4udGV4dCkpIHtcbiAgICAgIGxhc3RUb2tlbiA9IG5leHRUb2tlbjtcbiAgICAgIHN0ciArPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgXCIgKyBtb2RlTmFtZSArIFwiOiAnXCIgKyBmaXJzdFRva2VuLnRleHQgKyBcIidcIiwgZmlyc3RUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBzaXplIHNwZWNpZmljYXRpb24sIGNvbnNpc3Rpbmcgb2YgbWFnbml0dWRlIGFuZCB1bml0LlxuICAgKi9cbiAgcGFyc2VTaXplR3JvdXAob3B0aW9uYWwpIHtcbiAgICBsZXQgcmVzO1xuICAgIGxldCBpc0JsYW5rID0gZmFsc2U7XG4gICAgLy8gZG9uJ3QgZXhwYW5kIGJlZm9yZSBwYXJzZVN0cmluZ0dyb3VwXG4gICAgdGhpcy5ndWxsZXQuY29uc3VtZVNwYWNlcygpO1xuICAgIGlmICghb3B0aW9uYWwgJiYgdGhpcy5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gXCJ7XCIpIHtcbiAgICAgIHJlcyA9IHRoaXMucGFyc2VSZWdleEdyb3VwKC9eWy0rXT8gKig/OiR8XFxkK3xcXGQrXFwuXFxkKnxcXC5cXGQqKSAqW2Etel17MCwyfSAqJC8sIFwic2l6ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwic2l6ZVwiLCBvcHRpb25hbCk7XG4gICAgfVxuICAgIGlmICghcmVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25hbCAmJiByZXMudGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIEJlY2F1c2Ugd2UndmUgdGVzdGVkIGZvciB3aGF0IGlzICFvcHRpb25hbCwgdGhpcyBibG9jayB3b24ndFxuICAgICAgLy8gYWZmZWN0IFxca2VybiwgXFxoc3BhY2UsIGV0Yy4gSXQgd2lsbCBjYXB0dXJlIHRoZSBtYW5kYXRvcnkgYXJndW1lbnRzXG4gICAgICAvLyB0byBcXGdlbmZyYWMgYW5kIFxcYWJvdmUuXG4gICAgICByZXMudGV4dCA9IFwiMHB0XCI7IC8vIEVuYWJsZSBcXGFib3Zle31cbiAgICAgIGlzQmxhbmsgPSB0cnVlOyAvLyBUaGlzIGlzIGhlcmUgc3BlY2lmaWNhbGx5IGZvciBcXGdlbmZyYWNcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBzaXplUmVnRXguZXhlYyhyZXMudGV4dCk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHNpemU6ICdcIiArIHJlcy50ZXh0ICsgXCInXCIsIHJlcyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyXG4gICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG4gICAgaWYgKCF2YWxpZFVuaXQoZGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic2l6ZVwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICBpc0JsYW5rXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gVVJMLCBjaGVja2luZyBlc2NhcGVkIGxldHRlcnMgYW5kIGFsbG93ZWQgcHJvdG9jb2xzLFxuICAgKiBhbmQgc2V0dGluZyB0aGUgY2F0Y29kZSBvZiAlIGFzIGFuIGFjdGl2ZSBjaGFyYWN0ZXIgKGFzIGluIFxcaHlwZXJyZWYpLlxuICAgKi9cbiAgcGFyc2VVcmxHcm91cChvcHRpb25hbCkge1xuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCIlXCIsIDEzKTsgLy8gYWN0aXZlIGNoYXJhY3RlclxuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCJ+XCIsIDEyKTsgLy8gb3RoZXIgY2hhcmFjdGVyXG4gICAgY29uc3QgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwidXJsXCIsIG9wdGlvbmFsKTtcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiJVwiLCAxNCk7IC8vIGNvbW1lbnQgY2hhcmFjdGVyXG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIn5cIiwgMTMpOyAvLyBhY3RpdmUgY2hhcmFjdGVyXG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaHlwZXJyZWYgcGFja2FnZSBhbGxvd3MgYmFja3NsYXNoZXMgYWxvbmUgaW4gaHJlZiwgYnV0IGRvZXNuJ3RcbiAgICAvLyBnZW5lcmF0ZSB2YWxpZCBsaW5rcyBpbiBzdWNoIGNhc2VzOyB3ZSBpbnRlcnByZXQgdGhpcyBhc1xuICAgIC8vIFwidW5kZWZpbmVkXCIgYmVoYXZpb3VyLCBhbmQga2VlcCB0aGVtIGFzLWlzLiBTb21lIGJyb3dzZXIgd2lsbFxuICAgIC8vIHJlcGxhY2UgYmFja3NsYXNoZXMgd2l0aCBmb3J3YXJkIHNsYXNoZXMuXG4gICAgbGV0IHVybCA9IHJlcy50ZXh0LnJlcGxhY2UoL1xcXFwoWyMkJSZ+X157fV0pL2csIFwiJDFcIik7XG4gICAgdXJsID0gcmVzLnRleHQucmVwbGFjZSgve1xcdTIwNDR9L2csIFwiL1wiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ1cmxcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIHVybFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGFyZ3VtZW50IHdpdGggdGhlIG1vZGUgc3BlY2lmaWVkLlxuICAgKi9cbiAgcGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCBtb2RlKSB7XG4gICAgY29uc3QgYXJnVG9rZW4gPSB0aGlzLmd1bGxldC5zY2FuQXJndW1lbnQob3B0aW9uYWwpO1xuICAgIGlmIChhcmdUb2tlbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIGlmIChtb2RlKSB7XG4gICAgICAvLyBTd2l0Y2ggdG8gc3BlY2lmaWVkIG1vZGVcbiAgICAgIHRoaXMuc3dpdGNoTW9kZShtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBcIkVPRlwiKTtcbiAgICAvLyBUT0RPOiBmaW5kIGFuIGFsdGVybmF0aXZlIHdheSB0byBkZW5vdGUgdGhlIGVuZFxuICAgIHRoaXMuZXhwZWN0KFwiRU9GXCIpOyAvLyBleHBlY3QgdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRcbiAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGxvYzogYXJnVG9rZW4ubG9jLFxuICAgICAgYm9keTogZXhwcmVzc2lvblxuICAgIH07XG5cbiAgICBpZiAobW9kZSkge1xuICAgICAgLy8gU3dpdGNoIG1vZGUgYmFja1xuICAgICAgdGhpcy5zd2l0Y2hNb2RlKG91dGVyTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIG9yZGluYXJ5IGdyb3VwLCB3aGljaCBpcyBlaXRoZXIgYSBzaW5nbGUgbnVjbGV1cyAobGlrZSBcInhcIilcbiAgICogb3IgYW4gZXhwcmVzc2lvbiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKSBvciBhbiBpbXBsaWNpdCBncm91cCwgYSBncm91cFxuICAgKiB0aGF0IHN0YXJ0cyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0XG4gICAqIGdyb3VwIGVuZHMsIG9yIGF0IEVPRi5cbiAgICovXG4gIHBhcnNlR3JvdXAoXG4gICAgbmFtZSwgLy8gRm9yIGVycm9yIHJlcG9ydGluZy5cbiAgICBicmVha09uVG9rZW5UZXh0XG4gICkge1xuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgY29uc3QgdGV4dCA9IGZpcnN0VG9rZW4udGV4dDtcblxuICAgIGxldCByZXN1bHQ7XG4gICAgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2Ugb3IgXFxiZWdpbmdyb3VwXG4gICAgaWYgKHRleHQgPT09IFwie1wiIHx8IHRleHQgPT09IFwiXFxcXGJlZ2luZ3JvdXBcIiB8fCB0ZXh0ID09PSBcIlxcXFx0b2dnbGVcIikge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICBjb25zdCBncm91cEVuZCA9IHRleHQgPT09IFwie1wiXG4gICAgICAgID8gXCJ9XCJcbiAgICAgICAgOiB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCJcbiAgICAgICAgPyBcIlxcXFxlbmRncm91cFwiXG4gICAgICAgIDogXCJcXFxcZW5kdG9nZ2xlXCI7XG5cbiAgICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICAgIC8vIElmIHdlIGdldCBhIGJyYWNlLCBwYXJzZSBhbiBleHByZXNzaW9uXG4gICAgICBjb25zdCBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGdyb3VwRW5kKTtcbiAgICAgIGNvbnN0IGxhc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICAgIHRoaXMuZXhwZWN0KGdyb3VwRW5kKTsgLy8gQ2hlY2sgdGhhdCB3ZSBnb3QgYSBtYXRjaGluZyBjbG9zaW5nIGJyYWNlXG4gICAgICB0aGlzLmd1bGxldC5lbmRHcm91cCgpO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiAobGFzdFRva2VuLnRleHQgPT09IFwiXFxcXGVuZHRvZ2dsZVwiID8gXCJ0b2dnbGVcIiA6IFwib3JkZ3JvdXBcIiksXG4gICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShmaXJzdFRva2VuLCBsYXN0VG9rZW4pLFxuICAgICAgICBib2R5OiBleHByZXNzaW9uLFxuICAgICAgICAvLyBBIGdyb3VwIGZvcm1lZCBieSBcXGJlZ2luZ3JvdXAuLi5cXGVuZGdyb3VwIGlzIGEgc2VtaS1zaW1wbGUgZ3JvdXBcbiAgICAgICAgLy8gd2hpY2ggZG9lc24ndCBhZmZlY3Qgc3BhY2luZyBpbiBtYXRoIG1vZGUsIGkuZS4sIGlzIHRyYW5zcGFyZW50LlxuICAgICAgICAvLyBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkzMC9cbiAgICAgICAgc2VtaXNpbXBsZTogdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiIHx8IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUgZXhpc3RzIGEgZnVuY3Rpb24gd2l0aCB0aGlzIG5hbWUsIHBhcnNlIHRoZSBmdW5jdGlvbi5cbiAgICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYSBudWNsZXVzXG4gICAgICByZXN1bHQgPSB0aGlzLnBhcnNlRnVuY3Rpb24oYnJlYWtPblRva2VuVGV4dCwgbmFtZSkgfHwgdGhpcy5wYXJzZVN5bWJvbCgpO1xuICAgICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIHRleHRbMF0gPT09IFwiXFxcXFwiICYmXG4gICAgICAgICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbXBsaWNpdENvbW1hbmRzLCB0ZXh0ICkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0KTtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRm9ybSBsaWdhdHVyZS1saWtlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJzIGZvciB0ZXh0IG1vZGUuXG4gICAqIFRoaXMgaW5jbHVkZXMgaW5wdXRzIGxpa2UgXCItLVwiLCBcIi0tLVwiLCBcImBgXCIgYW5kIFwiJydcIi5cbiAgICogVGhlIHJlc3VsdCB3aWxsIHNpbXBseSByZXBsYWNlIG11bHRpcGxlIHRleHRvcmQgbm9kZXMgd2l0aCBhIHNpbmdsZVxuICAgKiBjaGFyYWN0ZXIgaW4gZWFjaCB2YWx1ZSBieSBhIHNpbmdsZSB0ZXh0b3JkIG5vZGUgaGF2aW5nIG11bHRpcGxlXG4gICAqIGNoYXJhY3RlcnMgaW4gaXRzIHZhbHVlLiAgVGhlIHJlcHJlc2VudGF0aW9uIGlzIHN0aWxsIEFTQ0lJIHNvdXJjZS5cbiAgICogVGhlIGdyb3VwIHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UuXG4gICAqL1xuICBmb3JtTGlnYXR1cmVzKGdyb3VwKSB7XG4gICAgbGV0IG4gPSBncm91cC5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBhID0gZ3JvdXBbaV07XG4gICAgICBjb25zdCB2ID0gYS50ZXh0O1xuICAgICAgaWYgKHYgPT09IFwiLVwiICYmIGdyb3VwW2kgKyAxXS50ZXh0ID09PSBcIi1cIikge1xuICAgICAgICBpZiAoaSArIDEgPCBuICYmIGdyb3VwW2kgKyAyXS50ZXh0ID09PSBcIi1cIikge1xuICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAzLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMl0pLFxuICAgICAgICAgICAgdGV4dDogXCItLS1cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4gLT0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDFdKSxcbiAgICAgICAgICAgIHRleHQ6IFwiLS1cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCh2ID09PSBcIidcIiB8fCB2ID09PSBcImBcIikgJiYgZ3JvdXBbaSArIDFdLnRleHQgPT09IHYpIHtcbiAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDIsIHtcbiAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAxXSksXG4gICAgICAgICAgdGV4dDogdiArIHZcbiAgICAgICAgfSk7XG4gICAgICAgIG4gLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSBzaW5nbGUgc3ltYm9sIG91dCBvZiB0aGUgc3RyaW5nLiBIZXJlLCB3ZSBoYW5kbGUgc2luZ2xlIGNoYXJhY3RlclxuICAgKiBzeW1ib2xzIGFuZCBzcGVjaWFsIGZ1bmN0aW9ucyBsaWtlIFxcdmVyYi5cbiAgICovXG4gIHBhcnNlU3ltYm9sKCkge1xuICAgIGNvbnN0IG51Y2xldXMgPSB0aGlzLmZldGNoKCk7XG4gICAgbGV0IHRleHQgPSBudWNsZXVzLnRleHQ7XG5cbiAgICBpZiAoL15cXFxcdmVyYlteYS16QS1aXS8udGVzdCh0ZXh0KSkge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICBsZXQgYXJnID0gdGV4dC5zbGljZSg1KTtcbiAgICAgIGNvbnN0IHN0YXIgPSBhcmcuY2hhckF0KDApID09PSBcIipcIjtcbiAgICAgIGlmIChzdGFyKSB7XG4gICAgICAgIGFyZyA9IGFyZy5zbGljZSgxKTtcbiAgICAgIH1cbiAgICAgIC8vIExleGVyJ3MgdG9rZW5SZWdleCBpcyBjb25zdHJ1Y3RlZCB0byBhbHdheXMgaGF2ZSBtYXRjaGluZ1xuICAgICAgLy8gZmlyc3QvbGFzdCBjaGFyYWN0ZXJzLlxuICAgICAgaWYgKGFyZy5sZW5ndGggPCAyIHx8IGFyZy5jaGFyQXQoMCkgIT09IGFyZy5zbGljZSgtMSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFxcXFx2ZXJiIGFzc2VydGlvbiBmYWlsZWQgLS1cbiAgICAgICAgICAgICAgICAgICAgcGxlYXNlIHJlcG9ydCB3aGF0IGlucHV0IGNhdXNlZCB0aGlzIGJ1Z2ApO1xuICAgICAgfVxuICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTsgLy8gcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IGNoYXJcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidmVyYlwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgYm9keTogYXJnLFxuICAgICAgICBzdGFyXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBzaG91bGQgaGF2ZSBhIHN5bWJvbCwgcG9zc2libHkgd2l0aCBhY2NlbnRzLlxuICAgIC8vIEZpcnN0IGV4cGFuZCBhbnkgYWNjZW50ZWQgYmFzZSBzeW1ib2wgYWNjb3JkaW5nIHRvIHVuaWNvZGVTeW1ib2xzLlxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodW5pY29kZVN5bWJvbHMsIHRleHRbMF0pICYmXG4gICAgICB0aGlzLm1vZGUgPT09IFwibWF0aFwiICYmICFzeW1ib2xzW3RoaXMubW9kZV1bdGV4dFswXV0pIHtcbiAgICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgbm90IHN0cmljdCAoWGVUZVgtY29tcGF0aWJsZSkgaW4gbWF0aCBtb2RlLlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0ICYmIHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEFjY2VudGVkIFVuaWNvZGUgdGV4dCBjaGFyYWN0ZXIgXCIke3RleHRbMF19XCIgdXNlZCBpbiBgICsgYG1hdGggbW9kZWAsXG4gICAgICAgICAgbnVjbGV1c1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGV4dCA9IHVuaWNvZGVTeW1ib2xzW3RleHRbMF1dICsgdGV4dC5zbGljZSgxKTtcbiAgICB9XG4gICAgLy8gU3RyaXAgb2ZmIGFueSBjb21iaW5pbmcgY2hhcmFjdGVyc1xuICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tb2RlID09PSBcIm1hdGhcIlxuICAgICAgPyBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtzRW5kUmVnZXguZXhlYyh0ZXh0KVxuICAgICAgOiBudWxsO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgIGlmICh0ZXh0ID09PSBcImlcIikge1xuICAgICAgICB0ZXh0ID0gXCJcXHUwMTMxXCI7IC8vIGRvdGxlc3MgaSwgaW4gbWF0aCBhbmQgdGV4dCBtb2RlXG4gICAgICB9IGVsc2UgaWYgKHRleHQgPT09IFwialwiKSB7XG4gICAgICAgIHRleHQgPSBcIlxcdTAyMzdcIjsgLy8gZG90bGVzcyBqLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVjb2duaXplIGJhc2Ugc3ltYm9sXG4gICAgbGV0IHN5bWJvbDtcbiAgICBpZiAoc3ltYm9sc1t0aGlzLm1vZGVdW3RleHRdKSB7XG4gICAgICBsZXQgZ3JvdXAgPSBzeW1ib2xzW3RoaXMubW9kZV1bdGV4dF0uZ3JvdXA7XG4gICAgICBpZiAoZ3JvdXAgPT09IFwiYmluXCIgJiYgYmluTGVmdENhbmNlbGxlcnMuaW5jbHVkZXModGhpcy5wcmV2QXRvbVR5cGUpKSB7XG4gICAgICAgIC8vIENoYW5nZSBmcm9tIGEgYmluYXJ5IG9wZXJhdG9yIHRvIGEgdW5hcnkgKHByZWZpeCkgb3BlcmF0b3JcbiAgICAgICAgZ3JvdXAgPSBcIm9wZW5cIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvYyA9IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpO1xuICAgICAgbGV0IHM7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEFUT01TLCBncm91cCApKSB7XG4gICAgICAgIGNvbnN0IGZhbWlseSA9IGdyb3VwO1xuICAgICAgICBzID0ge1xuICAgICAgICAgIHR5cGU6IFwiYXRvbVwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBmYW1pbHksXG4gICAgICAgICAgbG9jLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKChmYW1pbHkgPT09IFwicmVsXCIgfHwgZmFtaWx5ID09PSBcImJpblwiKSAmJiB0aGlzLnByZXZBdG9tVHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICBpZiAodGV4dFJlZ0V4LnRlc3QobG9jLmxleGVyLmlucHV0LnNsaWNlKGxvYy5lbmQpKSkge1xuICAgICAgICAgICAgcy5uZWVkc1NwYWNpbmcgPSB0cnVlOyAgLy8gRml4IGEgTWF0aE1MIGJ1Zy5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhc2NpaUZyb21TY3JpcHRbdGV4dF0pIHtcbiAgICAgICAgICAvLyBVbmljb2RlIDE0IGRpc2FtYmlndWF0ZXMgY2hhbmNlcnkgZnJvbSByb3VuZGhhbmQuXG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL2NoYXJ0cy9QREYvVTFENDAwLnBkZlxuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAgIGNvbnN0IG5leHRDb2RlID0gdGhpcy5mZXRjaCgpLnRleHQuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAvLyBtYXRoY2FsIGlzIFRlbW1sIGRlZmF1bHQuIFVzZSBtYXRoc2NyaXB0IGlmIGNhbGxlZCBmb3IuXG4gICAgICAgICAgY29uc3QgZm9udCA9IG5leHRDb2RlID09PSAweGZlMDEgPyBcIm1hdGhzY3JcIiA6IFwibWF0aGNhbFwiO1xuICAgICAgICAgIGlmIChuZXh0Q29kZSA9PT0gMHhmZTAwIHx8IG5leHRDb2RlID09PSAweGZlMDEpIHsgdGhpcy5jb25zdW1lKCk7IH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJmb250XCIsXG4gICAgICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgICAgIGZvbnQsXG4gICAgICAgICAgICBib2R5OiB7IHR5cGU6IFwibWF0aG9yZFwiLCBtb2RlOiBcIm1hdGhcIiwgbG9jLCB0ZXh0OiBhc2NpaUZyb21TY3JpcHRbdGV4dF0gfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IG9yZCBjaGFyYWN0ZXIuIE5vIGRpc2FtYmlndWF0aW9uIG5lY2Vzc2FyeS5cbiAgICAgICAgcyA9IHtcbiAgICAgICAgICB0eXBlOiBncm91cCxcbiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgICAgbG9jLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHN5bWJvbCA9IHM7XG4gICAgfSBlbHNlIGlmICh0ZXh0LmNoYXJDb2RlQXQoMCkgPj0gMHg4MCB8fCBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtzRW5kUmVnZXguZXhlYyh0ZXh0KSkge1xuICAgICAgLy8gbm8gc3ltYm9sIGZvciBlLmcuIF5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnN0cmljdCAmJiB0aGlzLm1vZGUgPT09IFwibWF0aFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBVbmljb2RlIHRleHQgY2hhcmFjdGVyIFwiJHt0ZXh0WzBdfVwiIHVzZWQgaW4gbWF0aCBtb2RlYCwgbnVjbGV1cylcbiAgICAgIH1cbiAgICAgIC8vIEFsbCBub25tYXRoZW1hdGljYWwgVW5pY29kZSBjaGFyYWN0ZXJzIGFyZSByZW5kZXJlZCBhcyBpZiB0aGV5XG4gICAgICAvLyBhcmUgaW4gdGV4dCBtb2RlICh3cmFwcGVkIGluIFxcdGV4dCkgYmVjYXVzZSB0aGF0J3Mgd2hhdCBpdFxuICAgICAgLy8gdGFrZXMgdG8gcmVuZGVyIHRoZW0gaW4gTGFUZVguXG4gICAgICBzeW1ib2wgPSB7XG4gICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShudWNsZXVzKSxcbiAgICAgICAgdGV4dFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIEVPRiwgXiwgXywgeywgfSwgZXRjLlxuICAgIH1cbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAvLyBUcmFuc2Zvcm0gY29tYmluaW5nIGNoYXJhY3RlcnMgaW50byBhY2NlbnRzXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFjY2VudCA9IG1hdGNoWzBdW2ldO1xuICAgICAgICBpZiAoIXVuaWNvZGVBY2NlbnRzW2FjY2VudF0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgVW5rbm93biBhY2NlbnQgJyAke2FjY2VudH0nYCwgbnVjbGV1cyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tbWFuZCA9IHVuaWNvZGVBY2NlbnRzW2FjY2VudF1bdGhpcy5tb2RlXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pY29kZUFjY2VudHNbYWNjZW50XS50ZXh0O1xuICAgICAgICBpZiAoIWNvbW1hbmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgQWNjZW50ICR7YWNjZW50fSB1bnN1cHBvcnRlZCBpbiAke3RoaXMubW9kZX0gbW9kZWAsIG51Y2xldXMpO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbCA9IHtcbiAgICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpLFxuICAgICAgICAgIGxhYmVsOiBjb21tYW5kLFxuICAgICAgICAgIGlzU3RyZXRjaHk6IGZhbHNlLFxuICAgICAgICAgIGJhc2U6IHN5bWJvbFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3ltYm9sO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGV4cHJlc3Npb24gdXNpbmcgYSBQYXJzZXIsIHRoZW4gcmV0dXJucyB0aGUgcGFyc2VkIHJlc3VsdC5cbiAqL1xuY29uc3QgcGFyc2VUcmVlID0gZnVuY3Rpb24odG9QYXJzZSwgc2V0dGluZ3MpIHtcbiAgaWYgKCEodHlwZW9mIHRvUGFyc2UgPT09IFwic3RyaW5nXCIgfHwgdG9QYXJzZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVtbWwgY2FuIG9ubHkgcGFyc2Ugc3RyaW5nIHR5cGVkIGV4cHJlc3Npb25cIilcbiAgfVxuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHRvUGFyc2UsIHNldHRpbmdzKTtcbiAgLy8gQmxhbmsgb3V0IGFueSBcXGRmQHRhZyB0byBhdm9pZCBzcHVyaW91cyBcIkR1cGxpY2F0ZSBcXHRhZ1wiIGVycm9yc1xuICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFtcIlxcXFxkZkB0YWdcIl07XG5cbiAgbGV0IHRyZWUgPSBwYXJzZXIucGFyc2UoKTtcblxuICAvLyBMYVRlWCBpZ25vcmVzIGEgXFx0YWcgcGxhY2VkIG91dHNpZGUgYW4gQU1TIGVudmlyb25tZW50LlxuICBpZiAoISh0cmVlLmxlbmd0aCA+IDAgJiYgIHRyZWVbMF0udHlwZSAmJiB0cmVlWzBdLnR5cGUgPT09IFwiYXJyYXlcIiAmJiB0cmVlWzBdLmFkZEVxbk51bSkpIHtcbiAgICAvLyBJZiB0aGUgaW5wdXQgdXNlZCBcXHRhZywgaXQgd2lsbCBzZXQgdGhlIFxcZGZAdGFnIG1hY3JvIHRvIHRoZSB0YWcuXG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBzZXBhcmF0ZWx5IHBhcnNlIHRoZSB0YWcgYW5kIHdyYXAgdGhlIHRyZWUuXG4gICAgaWYgKHBhcnNlci5ndWxsZXQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICAgIGlmICghc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcdGFnIHdvcmtzIG9ubHkgaW4gZGlzcGxheSBtb2RlXCIpXG4gICAgICB9XG4gICAgICBwYXJzZXIuZ3VsbGV0LmZlZWQoXCJcXFxcZGZAdGFnXCIpO1xuICAgICAgdHJlZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwidGFnXCIsXG4gICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgYm9keTogdHJlZSxcbiAgICAgICAgICB0YWc6IHBhcnNlci5wYXJzZSgpXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRyZWVcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzdHlsZSB0aGF0IHRoZSBtYXRobWxCdWlsZGVyIGNhcnJpZXNcbiAqIGFyb3VuZCB3aXRoIGl0LiBEYXRhIGlzIGhlbGQgaW4gYW4gYFN0eWxlYCBvYmplY3QsIGFuZCB3aGVuXG4gKiByZWN1cnNpbmcsIGEgbmV3IGBTdHlsZWAgb2JqZWN0IGNhbiBiZSBjcmVhdGVkIHdpdGggdGhlIGAud2l0aCpgIGZ1bmN0aW9ucy5cbiAqL1xuXG5jb25zdCBzdWJPclN1cExldmVsID0gWzIsIDIsIDMsIDNdO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gU3R5bGUgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBjdXJyZW50IHN0eWxlLmxldmVsLCBjb2xvciwgYW5kIGZvbnQuXG4gKlxuICogU3R5bGUgb2JqZWN0cyBzaG91bGQgbm90IGJlIG1vZGlmaWVkLiBUbyBjcmVhdGUgYSBuZXcgU3R5bGUgd2l0aFxuICogZGlmZmVyZW50IHByb3BlcnRpZXMsIGNhbGwgYSBgLndpdGgqYCBtZXRob2QuXG4gKi9cbmNsYXNzIFN0eWxlIHtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIC8vIFN0eWxlLmxldmVsIGNhbiBiZSAwIHwgMSB8IDIgfCAzLCB3aGljaCBjb3JyZXNwb25kIHRvXG4gICAgLy8gICAgICAgZGlzcGxheXN0eWxlLCB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBhbmQgc2NyaXB0c2NyaXB0c3R5bGUuXG4gICAgLy8gc3R5bGUubGV2ZWwgdXN1YWxseSBkb2VzIG5vdCBkaXJlY3RseSBzZXQgTWF0aE1MJ3Mgc2NyaXB0IGxldmVsLiBNYXRoTUwgZG9lcyB0aGF0IGl0c2VsZi5cbiAgICAvLyBIb3dldmVyLCBDaHJvbWl1bSBkb2VzIG5vdCBzdG9wIHNocmlua2luZyBhZnRlciBzY3JpcHRzY3JpcHRzdHlsZSwgc28gd2UgZG8gZXhwbGljaXRseVxuICAgIC8vIHNldCBhIHNjcmlwdGxldmVsIGF0dHJpYnV0ZSBpbiB0aG9zZSBjb25kaXRpb25zLlxuICAgIC8vIFdlIGFsc28gdXNlIHN0eWxlLmxldmVsIHRvIHRyYWNrIG1hdGggc3R5bGUgc28gdGhhdCB3ZSBjYW4gZ2V0IHRoZSBjb3JyZWN0XG4gICAgLy8gc2NyaXB0bGV2ZWwgd2hlbiBuZWVkZWQgaW4gc3Vwc3ViLmpzLCBtYXRoY2hvaWNlLmpzLCBvciBmb3IgZGltZW5zaW9ucyBpbiBlbS5cbiAgICB0aGlzLmxldmVsID0gZGF0YS5sZXZlbDtcbiAgICB0aGlzLmNvbG9yID0gZGF0YS5jb2xvcjsgIC8vIHN0cmluZyB8IHZvaWRcbiAgICAvLyBBIGZvbnQgZmFtaWx5IGFwcGxpZXMgdG8gYSBncm91cCBvZiBmb250cyAoaS5lLiBTYW5zU2VyaWYpLCB3aGlsZSBhIGZvbnRcbiAgICAvLyByZXByZXNlbnRzIGEgc3BlY2lmaWMgZm9udCAoaS5lLiBTYW5zU2VyaWYgQm9sZCkuXG4gICAgLy8gU2VlOiBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjIzNTAvZGlmZmVyZW5jZS1iZXR3ZWVuLXRleHRybS1hbmQtbWF0aHJtXG4gICAgdGhpcy5mb250ID0gZGF0YS5mb250IHx8IFwiXCI7ICAgICAgICAgICAgICAgIC8vIHN0cmluZ1xuICAgIHRoaXMuZm9udEZhbWlseSA9IGRhdGEuZm9udEZhbWlseSB8fCBcIlwiOyAgICAvLyBzdHJpbmdcbiAgICB0aGlzLmZvbnRTaXplID0gZGF0YS5mb250U2l6ZSB8fCAxLjA7ICAgICAgIC8vIG51bWJlclxuICAgIHRoaXMuZm9udFdlaWdodCA9IGRhdGEuZm9udFdlaWdodCB8fCBcIlwiO1xuICAgIHRoaXMuZm9udFNoYXBlID0gZGF0YS5mb250U2hhcGUgfHwgXCJcIjtcbiAgICB0aGlzLm1heFNpemUgPSBkYXRhLm1heFNpemU7ICAgICAgICAgICAgICAgIC8vIFtudW1iZXIsIG51bWJlcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgXCJ0aGlzXCIuICBQcm9wZXJ0aWVzXG4gICAqIGZyb20gXCJleHRlbnNpb25cIiB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IHN0eWxlIG9iamVjdC5cbiAgICovXG4gIGV4dGVuZChleHRlbnNpb24pIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbGV2ZWw6IHRoaXMubGV2ZWwsXG4gICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplOiB0aGlzLmZvbnRTaXplLFxuICAgICAgZm9udFdlaWdodDogdGhpcy5mb250V2VpZ2h0LFxuICAgICAgZm9udFNoYXBlOiB0aGlzLmZvbnRTaGFwZSxcbiAgICAgIG1heFNpemU6IHRoaXMubWF4U2l6ZVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBleHRlbnNpb24pIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXh0ZW5zaW9uLCBrZXkpKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IGV4dGVuc2lvbltrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3R5bGUoZGF0YSk7XG4gIH1cblxuICB3aXRoTGV2ZWwobikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBsZXZlbDogblxuICAgIH0pO1xuICB9XG5cbiAgaW5jcmVtZW50TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGxldmVsOiBNYXRoLm1pbih0aGlzLmxldmVsICsgMSwgMylcbiAgICB9KTtcbiAgfVxuXG4gIGluU3ViT3JTdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGxldmVsOiBzdWJPclN1cExldmVsW3RoaXMubGV2ZWxdXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc3R5bGUgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICAgKi9cbiAgd2l0aENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3R5bGUgb2JqZWN0IHdpdGggdGhlIGdpdmVuIG1hdGggZm9udCBvciBvbGQgdGV4dCBmb250LlxuICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgKi9cbiAgd2l0aEZvbnQoZm9udCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHN0eWxlIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZW4gZm9udEZhbWlseS5cbiAgICovXG4gIHdpdGhUZXh0Rm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRGYW1pbHksXG4gICAgICBmb250OiBcIlwiXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCBzaXplXG4gICAqL1xuICB3aXRoRm9udFNpemUobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRTaXplOiBudW1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBmb250IHdlaWdodFxuICAgKi9cbiAgd2l0aFRleHRGb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFdlaWdodCxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBmb250IHdlaWdodFxuICAgKi9cbiAgd2l0aFRleHRGb250U2hhcGUoZm9udFNoYXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRTaGFwZSxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgc3R5bGUgb2JqZWN0XG4gICAqL1xuICBnZXRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvcjtcbiAgfVxufVxuXG4vKiBUZW1tbCBQb3N0IFByb2Nlc3NcbiAqIFBvcHVsYXRlIHRoZSB0ZXh0IGNvbnRlbnRzIG9mIGVhY2ggXFxyZWYgJiBcXGVxcmVmXG4gKlxuICogQXMgd2l0aCBvdGhlciBUZW1tbCBjb2RlLCB0aGlzIGZpbGUgaXMgcmVsZWFzZWQgdW5kZXIgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cHM6Ly9taXQtbGljZW5zZS5vcmcvXG4gKi9cblxuY29uc3QgdmVyc2lvbiA9IFwiMC4xMS4wMlwiO1xuXG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhibG9jaykge1xuICBjb25zdCBsYWJlbE1hcCA9IHt9O1xuICBsZXQgaSA9IDA7XG5cbiAgLy8gR2V0IGEgY29sbGVjdGlvbiBvZiB0aGUgcGFyZW50cyBvZiBlYWNoIFxcdGFnICYgYXV0by1udW1iZXJlZCBlcXVhdGlvblxuICBjb25zdCBhbXNFcW5zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndG1sLWVxbicpO1xuICBmb3IgKGxldCBwYXJlbnQgb2YgYW1zRXFucykge1xuICAgIC8vIEFNUyBhdXRvbWF0aWNhbGx5IG51bWJlcmVkIGVxdWF0aW9uLlxuICAgIC8vIEFzc2lnbiBhbiBpZC5cbiAgICBpICs9IDE7XG4gICAgcGFyZW50LnNldEF0dHJpYnV0ZShcImlkXCIsIFwidG1sLWVxbi1cIiArIFN0cmluZyhpKSk7XG4gICAgLy8gTm8gbmVlZCB0byB3cml0ZSBhIG51bWJlciBpbnRvIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGVsZW1lbnQuXG4gICAgLy8gQSBDU1MgY291bnRlciBoYXMgZG9uZSB0aGF0IGV2ZW4gaWYgdGhpcyBwb3N0UHJvY2VzcygpIGZ1bmN0aW9uIGlzIG5vdCB1c2VkLlxuXG4gICAgLy8gRmluZCBhbnkgXFxsYWJlbCB0aGF0IHJlZmVycyB0byBhbiBBTVMgYXV0b21hdGljIGVxbiBudW1iZXIuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChwYXJlbnQudGFnTmFtZSA9PT0gXCJtdGFibGVcIikgeyBicmVhayB9XG4gICAgICBjb25zdCBsYWJlbHMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRtbC1sYWJlbFwiKTtcbiAgICAgIGlmIChsYWJlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBpZCA9IHBhcmVudC5hdHRyaWJ1dGVzLmlkLnZhbHVlO1xuICAgICAgICBsYWJlbE1hcFtpZF0gPSBTdHJpbmcoaSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIFxcbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCBcXHRhZ1xuICBjb25zdCB0YWdnZWRFcW5zID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndG1sLXRhZ2VxbicpO1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiB0YWdnZWRFcW5zKSB7XG4gICAgY29uc3QgbGFiZWxzID0gcGFyZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0bWwtbGFiZWxcIik7XG4gICAgaWYgKGxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0YWdzID0gcGFyZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0bWwtdGFnXCIpO1xuICAgICAgaWYgKHRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBpZCA9IHBhcmVudC5hdHRyaWJ1dGVzLmlkLnZhbHVlO1xuICAgICAgICBsYWJlbE1hcFtpZF0gPSB0YWdzWzBdLnRleHRDb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBvcHVsYXRlIFxccmVmICYgXFxlcXJlZiB0ZXh0IGNvbnRlbnRcbiAgY29uc3QgcmVmcyA9IGJsb2NrLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0bWwtcmVmXCIpO1xuICBbLi4ucmVmc10uZm9yRWFjaChyZWYgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSByZWYuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcbiAgICBsZXQgc3RyID0gbGFiZWxNYXBbYXR0ci5zbGljZSgxKV07XG4gICAgaWYgKHJlZi5jbGFzc05hbWUuaW5kZXhPZihcInRtbC1lcXJlZlwiKSA9PT0gLTEpIHtcbiAgICAgIC8vIFxccmVmLiBPbWl0IHBhcmVucy5cbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eXFwoLywgXCJcIik7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFwpJC8sIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBcXGVxcmVmLiBJbmNsdWRlIHBhcmVuc1xuICAgICAgaWYgKHN0ci5jaGFyQXQoMCkgIT09IFwiKFwiKSB7IHN0ciA9IFwiKFwiICsgc3RyOyB9XG4gICAgICBpZiAoc3RyLnNsaWNlKC0xKSAhPT0gXCIpXCIpIHsgc3RyID0gIHN0ciArIFwiKVwiOyB9XG4gICAgfVxuICAgIGNvbnN0IG10ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCBcIm10ZXh0XCIpO1xuICAgIG10ZXh0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cikpO1xuICAgIGNvbnN0IG1hdGggPSAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCBcIm1hdGhcIik7XG4gICAgbWF0aC5hcHBlbmRDaGlsZChtdGV4dCk7XG4gICAgcmVmLnRleHRDb250ZW50ID0gJyc7XG4gICAgcmVmLmFwcGVuZENoaWxkKG1hdGgpO1xuICB9KTtcbn1cblxuY29uc3QgZmluZEVuZE9mTWF0aCA9IGZ1bmN0aW9uKGRlbGltaXRlciwgdGV4dCwgc3RhcnRJbmRleCkge1xuICAvLyBBZGFwdGVkIGZyb21cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0toYW4vcGVyc2V1cy9ibG9iL21hc3Rlci9zcmMvcGVyc2V1cy1tYXJrZG93bi5qc3hcbiAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcbiAgbGV0IGJyYWNlTGV2ZWwgPSAwO1xuXG4gIGNvbnN0IGRlbGltTGVuZ3RoID0gZGVsaW1pdGVyLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIGNvbnN0IGNoYXJhY3RlciA9IHRleHRbaW5kZXhdO1xuXG4gICAgaWYgKGJyYWNlTGV2ZWwgPD0gMCAmJiB0ZXh0LnNsaWNlKGluZGV4LCBpbmRleCArIGRlbGltTGVuZ3RoKSA9PT0gZGVsaW1pdGVyKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICBpbmRleCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBcIntcIikge1xuICAgICAgYnJhY2VMZXZlbCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSBcIn1cIikge1xuICAgICAgYnJhY2VMZXZlbC0tO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gLTE7XG59O1xuXG5jb25zdCBlc2NhcGVSZWdleCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpO1xufTtcblxuY29uc3QgYW1zUmVnZXggPSAvXlxcXFwoPzpiZWdpbnwoPzplcSk/cmVmKXsvO1xuXG5jb25zdCBzcGxpdEF0RGVsaW1pdGVycyA9IGZ1bmN0aW9uKHRleHQsIGRlbGltaXRlcnMpIHtcbiAgbGV0IGluZGV4O1xuICBjb25zdCBkYXRhID0gW107XG5cbiAgY29uc3QgcmVnZXhMZWZ0ID0gbmV3IFJlZ0V4cChcbiAgICBcIihcIiArIGRlbGltaXRlcnMubWFwKCh4KSA9PiBlc2NhcGVSZWdleCh4LmxlZnQpKS5qb2luKFwifFwiKSArIFwiKVwiXG4gICk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpbmRleCA9IHRleHQuc2VhcmNoKHJlZ2V4TGVmdCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICBkYXRhOiB0ZXh0LnNsaWNlKDAsIGluZGV4KVxuICAgICAgfSk7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZShpbmRleCk7IC8vIG5vdyB0ZXh0IHN0YXJ0cyB3aXRoIGRlbGltaXRlclxuICAgIH1cbiAgICAvLyAuLi4gc28gdGhpcyBhbHdheXMgc3VjY2VlZHM6XG4gICAgY29uc3QgaSA9IGRlbGltaXRlcnMuZmluZEluZGV4KChkZWxpbSkgPT4gdGV4dC5zdGFydHNXaXRoKGRlbGltLmxlZnQpKTtcbiAgICBpbmRleCA9IGZpbmRFbmRPZk1hdGgoZGVsaW1pdGVyc1tpXS5yaWdodCwgdGV4dCwgZGVsaW1pdGVyc1tpXS5sZWZ0Lmxlbmd0aCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHJhd0RhdGEgPSB0ZXh0LnNsaWNlKDAsIGluZGV4ICsgZGVsaW1pdGVyc1tpXS5yaWdodC5sZW5ndGgpO1xuICAgIGNvbnN0IG1hdGggPSBhbXNSZWdleC50ZXN0KHJhd0RhdGEpXG4gICAgICA/IHJhd0RhdGFcbiAgICAgIDogdGV4dC5zbGljZShkZWxpbWl0ZXJzW2ldLmxlZnQubGVuZ3RoLCBpbmRleCk7XG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIHR5cGU6IFwibWF0aFwiLFxuICAgICAgZGF0YTogbWF0aCxcbiAgICAgIHJhd0RhdGEsXG4gICAgICBkaXNwbGF5OiBkZWxpbWl0ZXJzW2ldLmRpc3BsYXlcbiAgICB9KTtcbiAgICB0ZXh0ID0gdGV4dC5zbGljZShpbmRleCArIGRlbGltaXRlcnNbaV0ucmlnaHQubGVuZ3RoKTtcbiAgfVxuXG4gIGlmICh0ZXh0ICE9PSBcIlwiKSB7XG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgZGF0YTogdGV4dFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5jb25zdCBkZWZhdWx0RGVsaW1pdGVycyA9IFtcbiAgeyBsZWZ0OiBcIiQkXCIsIHJpZ2h0OiBcIiQkXCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFwoXCIsIHJpZ2h0OiBcIlxcXFwpXCIsIGRpc3BsYXk6IGZhbHNlIH0sXG4gIC8vIExhVGVYIHVzZXMgJOKApiQsIGJ1dCBpdCBydWlucyB0aGUgZGlzcGxheSBvZiBub3JtYWwgYCRgIGluIHRleHQ6XG4gIC8vIHtsZWZ0OiBcIiRcIiwgcmlnaHQ6IFwiJFwiLCBkaXNwbGF5OiBmYWxzZX0sXG4gIC8vICQgbXVzdCBjb21lIGFmdGVyICQkXG5cbiAgLy8gUmVuZGVyIEFNUyBlbnZpcm9ubWVudHMgZXZlbiBpZiBvdXRzaWRlICQk4oCmJCQgZGVsaW1pdGVycy5cbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntlcXVhdGlvbn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtlcXVhdGlvbn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2VxdWF0aW9uKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtlcXVhdGlvbip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWduKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbmF0fVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWduYXR9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbmF0Kn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbmF0Kn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2dhdGhlcn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtnYXRoZXJ9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntnYXRoZXIqfVwiLCByaWdodDogXCJcXFxcZW5ke2dhdGhlcip9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntDRH1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtDRH1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICAvLyBEaXR0byBcXHJlZiAmIFxcZXFyZWZcbiAgeyBsZWZ0OiBcIlxcXFxyZWZ7XCIsIHJpZ2h0OiBcIn1cIiwgZGlzcGxheTogZmFsc2UgfSxcbiAgeyBsZWZ0OiBcIlxcXFxlcXJlZntcIiwgcmlnaHQ6IFwifVwiLCBkaXNwbGF5OiBmYWxzZSB9LFxuXG4gIHsgbGVmdDogXCJcXFxcW1wiLCByaWdodDogXCJcXFxcXVwiLCBkaXNwbGF5OiB0cnVlIH1cbl07XG5cbmNvbnN0IGZpcnN0RHJhZnREZWxpbWl0ZXJzID0ge1xuICBcIiRcIjogW1xuICAgICAgICAgeyBsZWZ0OiBcIiQkXCIsIHJpZ2h0OiBcIiQkXCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgICAgICAgIHsgbGVmdDogXCIkYFwiLCByaWdodDogXCJgJFwiLCBkaXNwbGF5OiBmYWxzZSB9LFxuICAgICAgICAgeyBsZWZ0OiBcIiRcIiwgcmlnaHQ6IFwiJFwiLCBkaXNwbGF5OiBmYWxzZSB9XG4gIF0sXG4gIFwiKFwiOiBbXG4gICAgeyBsZWZ0OiBcIlxcXFxbXCIsIHJpZ2h0OiBcIlxcXFxdXCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgICB7IGxlZnQ6IFwiXFxcXChcIiwgcmlnaHQ6IFwiXFxcXClcIiwgZGlzcGxheTogZmFsc2UgfVxuICBdXG59O1xuXG5jb25zdCBhbXNEZWxpbWl0ZXJzID0gW1xuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2VxdWF0aW9ufVwiLCByaWdodDogXCJcXFxcZW5ke2VxdWF0aW9ufVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57ZXF1YXRpb24qfVwiLCByaWdodDogXCJcXFxcZW5ke2VxdWF0aW9uKn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWdufVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWdufVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ24qfVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWduKn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWduYXR9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ25hdH1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWduYXQqfVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWduYXQqfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Z2F0aGVyfVwiLCByaWdodDogXCJcXFxcZW5ke2dhdGhlcn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2dhdGhlcip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Z2F0aGVyKn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue0NEfVwiLCByaWdodDogXCJcXFxcZW5ke0NEfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxccmVme1wiLCByaWdodDogXCJ9XCIsIGRpc3BsYXk6IGZhbHNlIH0sXG4gIHsgbGVmdDogXCJcXFxcZXFyZWZ7XCIsIHJpZ2h0OiBcIn1cIiwgZGlzcGxheTogZmFsc2UgfVxuXTtcblxuY29uc3QgZGVsaW1pdGVyc0Zyb21LZXkgPSBrZXkgPT4ge1xuICBpZiAoa2V5ID09PSBcIiRcIiB8fCBrZXkgPT09IFwiKFwiKSB7XG4gICAgcmV0dXJuIGZpcnN0RHJhZnREZWxpbWl0ZXJzW2tleV07XG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcIiQrXCIgfHwga2V5ID09PSBcIigrXCIpIHtcbiAgICBjb25zdCBmaXJzdERyYWZ0ID0gZmlyc3REcmFmdERlbGltaXRlcnNba2V5LnNsaWNlKDAsIDEpXTtcbiAgICByZXR1cm4gZmlyc3REcmFmdC5jb25jYXQoYW1zRGVsaW1pdGVycylcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwiYW1zXCIpIHtcbiAgICByZXR1cm4gYW1zRGVsaW1pdGVyc1xuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJhbGxcIikge1xuICAgIHJldHVybiAoZmlyc3REcmFmdERlbGltaXRlcnNbXCIoXCJdKS5jb25jYXQoZmlyc3REcmFmdERlbGltaXRlcnNbXCIkXCJdKS5jb25jYXQoYW1zRGVsaW1pdGVycylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVmYXVsdERlbGltaXRlcnNcbiAgfVxufTtcblxuLyogTm90ZTogb3B0aW9uc0NvcHkgaXMgbXV0YXRlZCBieSB0aGlzIG1ldGhvZC4gSWYgaXQgaXMgZXZlciBleHBvc2VkIGluIHRoZVxuICogQVBJLCB3ZSBzaG91bGQgY29weSBpdCBiZWZvcmUgbXV0YXRpbmcuXG4gKi9cbmNvbnN0IHJlbmRlck1hdGhJblRleHQgPSBmdW5jdGlvbih0ZXh0LCBvcHRpb25zQ29weSkge1xuICBjb25zdCBkYXRhID0gc3BsaXRBdERlbGltaXRlcnModGV4dCwgb3B0aW9uc0NvcHkuZGVsaW1pdGVycyk7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gZm9ybXVsYSBpbiB0aGUgdGV4dC5cbiAgICAvLyBMZXQncyByZXR1cm4gbnVsbCB3aGljaCBtZWFucyB0aGVyZSBpcyBubyBuZWVkIHRvIHJlcGxhY2VcbiAgICAvLyB0aGUgY3VycmVudCB0ZXh0IG5vZGUgd2l0aCBhIG5ldyBvbmUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZGF0YVtpXS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YVtpXS5kYXRhKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIGxldCBtYXRoID0gZGF0YVtpXS5kYXRhO1xuICAgICAgLy8gT3ZlcnJpZGUgYW55IGRpc3BsYXkgbW9kZSBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncyB3aXRoIHRoYXRcbiAgICAgIC8vIGRlZmluZWQgYnkgdGhlIHRleHQgaXRzZWxmXG4gICAgICBvcHRpb25zQ29weS5kaXNwbGF5TW9kZSA9IGRhdGFbaV0uZGlzcGxheTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChvcHRpb25zQ29weS5wcmVQcm9jZXNzKSB7XG4gICAgICAgICAgbWF0aCA9IG9wdGlvbnNDb3B5LnByZVByb2Nlc3MobWF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW1wb3J0aW5nIHJlbmRlcigpIGZyb20gdGVtbWwuanMgd291bGQgYmUgYSBjaXJjdWxhciBkZXBlbmRlbmN5LlxuICAgICAgICAvLyBTbyBjYWxsIHRoZSBnbG9iYWwgdmVyc2lvbi5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgIHRlbW1sLnJlbmRlcihtYXRoLCBzcGFuLCBvcHRpb25zQ29weSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBQYXJzZUVycm9yKSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9uc0NvcHkuZXJyb3JDYWxsYmFjayhcbiAgICAgICAgICBcIlRlbW1sIGF1dG8tcmVuZGVyOiBGYWlsZWQgdG8gcGFyc2UgYFwiICsgZGF0YVtpXS5kYXRhICsgXCJgIHdpdGggXCIsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhW2ldLnJhd0RhdGEpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnJhZ21lbnQ7XG59O1xuXG5jb25zdCByZW5kZXJFbGVtID0gZnVuY3Rpb24oZWxlbSwgb3B0aW9uc0NvcHkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBlbGVtLmNoaWxkTm9kZXNbaV07XG4gICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgLy8gVGV4dCBub2RlXG4gICAgICBjb25zdCBmcmFnID0gcmVuZGVyTWF0aEluVGV4dChjaGlsZE5vZGUudGV4dENvbnRlbnQsIG9wdGlvbnNDb3B5KTtcbiAgICAgIGlmIChmcmFnKSB7XG4gICAgICAgIGkgKz0gZnJhZy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGVsZW0ucmVwbGFjZUNoaWxkKGZyYWcsIGNoaWxkTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgIC8vIEVsZW1lbnQgbm9kZVxuICAgICAgY29uc3QgY2xhc3NOYW1lID0gXCIgXCIgKyBjaGlsZE5vZGUuY2xhc3NOYW1lICsgXCIgXCI7XG4gICAgICBjb25zdCBzaG91bGRSZW5kZXIgPVxuICAgICAgICBvcHRpb25zQ29weS5pZ25vcmVkVGFncy5pbmRleE9mKGNoaWxkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEgJiZcbiAgICAgICAgb3B0aW9uc0NvcHkuaWdub3JlZENsYXNzZXMuZXZlcnkoKHgpID0+IGNsYXNzTmFtZS5pbmRleE9mKFwiIFwiICsgeCArIFwiIFwiKSA9PT0gLTEpO1xuXG4gICAgICBpZiAoc2hvdWxkUmVuZGVyKSB7XG4gICAgICAgIHJlbmRlckVsZW0oY2hpbGROb2RlLCBvcHRpb25zQ29weSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgaXQncyBzb21ldGhpbmcgZWxzZSwgYW5kIGlnbm9yZSBpdC5cbiAgfVxufTtcblxuY29uc3QgcmVuZGVyTWF0aEluRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW0sIG9wdGlvbnMpIHtcbiAgaWYgKCFlbGVtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBwcm92aWRlZCB0byByZW5kZXJcIik7XG4gIH1cblxuICBjb25zdCBvcHRpb25zQ29weSA9IHt9O1xuXG4gIC8vIE9iamVjdC5hc3NpZ24ob3B0aW9uc0NvcHksIG9wdGlvbilcbiAgZm9yIChjb25zdCBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgb3B0aW9uc0NvcHlbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9uc0NvcHkuZmVuY2VzKSB7XG4gICAgb3B0aW9uc0NvcHkuZGVsaW1pdGVycyA9IGRlbGltaXRlcnNGcm9tS2V5KG9wdGlvbnNDb3B5LmZlbmNlcyk7XG4gIH0gZWxzZSB7XG4gICAgb3B0aW9uc0NvcHkuZGVsaW1pdGVycyA9IG9wdGlvbnNDb3B5LmRlbGltaXRlcnMgfHwgZGVmYXVsdERlbGltaXRlcnM7XG4gIH1cbiAgb3B0aW9uc0NvcHkuaWdub3JlZFRhZ3MgPSBvcHRpb25zQ29weS5pZ25vcmVkVGFncyB8fCBbXG4gICAgXCJzY3JpcHRcIixcbiAgICBcIm5vc2NyaXB0XCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwidGV4dGFyZWFcIixcbiAgICBcInByZVwiLFxuICAgIFwiY29kZVwiLFxuICAgIFwib3B0aW9uXCJcbiAgXTtcbiAgb3B0aW9uc0NvcHkuaWdub3JlZENsYXNzZXMgPSBvcHRpb25zQ29weS5pZ25vcmVkQ2xhc3NlcyB8fCBbXTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgb3B0aW9uc0NvcHkuZXJyb3JDYWxsYmFjayA9IG9wdGlvbnNDb3B5LmVycm9yQ2FsbGJhY2sgfHwgY29uc29sZS5lcnJvcjtcblxuICAvLyBFbmFibGUgc2hhcmluZyBvZiBnbG9iYWwgbWFjcm9zIGRlZmluZWQgdmlhIGBcXGdkZWZgIGJldHdlZW4gZGlmZmVyZW50XG4gIC8vIG1hdGggZWxlbWVudHMgd2l0aGluIGEgc2luZ2xlIGNhbGwgdG8gYHJlbmRlck1hdGhJbkVsZW1lbnRgLlxuICBvcHRpb25zQ29weS5tYWNyb3MgPSBvcHRpb25zQ29weS5tYWNyb3MgfHwge307XG5cbiAgcmVuZGVyRWxlbShlbGVtLCBvcHRpb25zQ29weSk7XG4gIHBvc3RQcm9jZXNzKGVsZW0pO1xufTtcblxuLyogZXNsaW50IG5vLWNvbnNvbGU6MCAqL1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGVudHJ5IHBvaW50IGZvciBUZW1tbC4gSGVyZSwgd2UgZXhwb3NlIGZ1bmN0aW9ucyBmb3JcbiAqIHJlbmRlcmluZyBleHByZXNzaW9ucyBlaXRoZXIgdG8gRE9NIG5vZGVzIG9yIHRvIG1hcmt1cCBzdHJpbmdzLlxuICpcbiAqIFdlIGFsc28gZXhwb3NlIHRoZSBQYXJzZUVycm9yIGNsYXNzIHRvIGNoZWNrIGlmIGVycm9ycyB0aHJvd24gZnJvbSBUZW1tbCBhcmVcbiAqIGVycm9ycyBpbiB0aGUgZXhwcmVzc2lvbiwgb3IgZXJyb3JzIGluIGphdmFzY3JpcHQgaGFuZGxpbmcuXG4gKi9cblxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5yZW5kZXJ9XG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHBsYWNlIHRoYXQgZXhwcmVzc2lvbiBpbiB0aGUgRE9NIG5vZGVcbiAqIGdpdmVuLlxuICovXG5sZXQgcmVuZGVyID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgYmFzZU5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICBiYXNlTm9kZS50ZXh0Q29udGVudCA9IFwiXCI7XG4gIGNvbnN0IGFscmVhZHlJbk1hdGhFbGVtZW50ID0gYmFzZU5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcIm1hdGhcIjtcbiAgaWYgKGFscmVhZHlJbk1hdGhFbGVtZW50KSB7IG9wdGlvbnMud3JhcCA9IFwibm9uZVwiOyB9XG4gIGNvbnN0IG1hdGggPSByZW5kZXJUb01hdGhNTFRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucyk7XG4gIGlmIChhbHJlYWR5SW5NYXRoRWxlbWVudCkge1xuICAgIC8vIFRoZSA8bWF0aD4gZWxlbWVudCBhbHJlYWR5IGV4aXN0cy4gUG9wdWxhdGUgaXQuXG4gICAgYmFzZU5vZGUudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgIG1hdGguY2hpbGRyZW4uZm9yRWFjaChlID0+IHsgYmFzZU5vZGUuYXBwZW5kQ2hpbGQoZS50b05vZGUoKSk7IH0pO1xuICB9IGVsc2UgaWYgKG1hdGguY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgIGJhc2VOb2RlLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICBtYXRoLmNoaWxkcmVuLmZvckVhY2goZSA9PiB7IGJhc2VOb2RlLmFwcGVuZENoaWxkKGUudG9Ob2RlKCkpOyB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNlTm9kZS5hcHBlbmRDaGlsZChtYXRoLnRvTm9kZSgpKTtcbiAgfVxufTtcblxuLy8gVGVtbWwncyBzdHlsZXMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBxdWlya3MgbW9kZS4gUHJpbnQgb3V0IGFuIGVycm9yLCBhbmRcbi8vIGRpc2FibGUgcmVuZGVyaW5nLlxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBpZiAoZG9jdW1lbnQuY29tcGF0TW9kZSAhPT0gXCJDU1MxQ29tcGF0XCIpIHtcbiAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIldhcm5pbmc6IFRlbW1sIGRvZXNuJ3Qgd29yayBpbiBxdWlya3MgbW9kZS4gTWFrZSBzdXJlIHlvdXIgXCIgK1xuICAgICAgICAgIFwid2Vic2l0ZSBoYXMgYSBzdWl0YWJsZSBkb2N0eXBlLlwiXG4gICAgICApO1xuXG4gICAgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRlbW1sIGRvZXNuJ3Qgd29yayBpbiBxdWlya3MgbW9kZS5cIik7XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5yZW5kZXJUb1N0cmluZ31cbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcmV0dXJuIHRoZSBtYXJrdXAgZm9yIHRoYXQuXG4gKi9cbmNvbnN0IHJlbmRlclRvU3RyaW5nID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBtYXJrdXAgPSByZW5kZXJUb01hdGhNTFRyZWUoZXhwcmVzc2lvbiwgb3B0aW9ucykudG9NYXJrdXAoKTtcbiAgcmV0dXJuIG1hcmt1cDtcbn07XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90ZW1tbCcpLmdlbmVyYXRlUGFyc2VUcmVlfVxuICogUGFyc2UgYW4gZXhwcmVzc2lvbiBhbmQgcmV0dXJuIHRoZSBwYXJzZSB0cmVlLlxuICovXG5jb25zdCBnZW5lcmF0ZVBhcnNlVHJlZSA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG4gIHJldHVybiBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykuZGVmaW5lUHJlYW1ibGV9XG4gKiBUYWtlIGFuIGV4cHJlc3Npb24gd2hpY2ggY29udGFpbnMgYSBwcmVhbWJsZS5cbiAqIFBhcnNlIGl0IGFuZCByZXR1cm4gdGhlIG1hY3Jvcy5cbiAqL1xuY29uc3QgZGVmaW5lUHJlYW1ibGUgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuICBzZXR0aW5ncy5tYWNyb3MgPSB7fTtcbiAgaWYgKCEodHlwZW9mIGV4cHJlc3Npb24gPT09IFwic3RyaW5nXCIgfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVtbWwgY2FuIG9ubHkgcGFyc2Ugc3RyaW5nIHR5cGVkIGV4cHJlc3Npb25cIilcbiAgfVxuICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGV4cHJlc3Npb24sIHNldHRpbmdzLCB0cnVlKTtcbiAgLy8gQmxhbmsgb3V0IGFueSBcXGRmQHRhZyB0byBhdm9pZCBzcHVyaW91cyBcIkR1cGxpY2F0ZSBcXHRhZ1wiIGVycm9yc1xuICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFtcIlxcXFxkZkB0YWdcIl07XG4gIGNvbnN0IG1hY3JvcyA9IHBhcnNlci5wYXJzZSgpO1xuICByZXR1cm4gbWFjcm9zXG59O1xuXG4vKipcbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBhIFRlbW1sIFBhcnNlRXJyb3IsXG4gKiByZW5kZXJzIHRoZSBpbnZhbGlkIExhVGVYIGFzIGEgc3BhbiB3aXRoIGhvdmVyIHRpdGxlIGdpdmluZyB0aGUgVGVtbWxcbiAqIGVycm9yIG1lc3NhZ2UuICBPdGhlcndpc2UsIHNpbXBseSB0aHJvd3MgdGhlIGVycm9yLlxuICovXG5jb25zdCByZW5kZXJFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRocm93T25FcnJvciB8fCAhKGVycm9yIGluc3RhbmNlb2YgUGFyc2VFcnJvcikpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBjb25zdCBub2RlID0gbmV3IFNwYW4oW1widGVtbWwtZXJyb3JcIl0sIFtuZXcgVGV4dE5vZGUkMShleHByZXNzaW9uICsgXCJcXG5cXG5cIiArIGVycm9yLnRvU3RyaW5nKCkpXSk7XG4gIG5vZGUuc3R5bGUuY29sb3IgPSBvcHRpb25zLmVycm9yQ29sb3I7XG4gIG5vZGUuc3R5bGUud2hpdGVTcGFjZSA9IFwicHJlLWxpbmVcIjtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5yZW5kZXJUb01hdGhNTFRyZWV9XG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgdGhlIFRlbW1sIGJ1aWxkIHRyZWUuIFRoaXMgaXMgdXNlZCBmb3IgYWR2YW5jZWRcbiAqIHVzZSBjYXNlcyAobGlrZSByZW5kZXJpbmcgdG8gY3VzdG9tIG91dHB1dCkuXG4gKi9cbmNvbnN0IHJlbmRlclRvTWF0aE1MVHJlZSA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG4gIHRyeSB7XG4gICAgY29uc3QgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgY29uc3Qgc3R5bGUgPSBuZXcgU3R5bGUoe1xuICAgICAgbGV2ZWw6IHNldHRpbmdzLmRpc3BsYXlNb2RlID8gU3R5bGVMZXZlbC5ESVNQTEFZIDogU3R5bGVMZXZlbC5URVhULFxuICAgICAgbWF4U2l6ZTogc2V0dGluZ3MubWF4U2l6ZVxuICAgIH0pO1xuICAgIHJldHVybiBidWlsZE1hdGhNTCh0cmVlLCBleHByZXNzaW9uLCBzdHlsZSwgc2V0dGluZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICB9XG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi90ZW1tbCcpLmRlZmF1bHR9ICovXG52YXIgdGVtbWwkMSA9IHtcbiAgLyoqXG4gICAqIEN1cnJlbnQgVGVtbWwgdmVyc2lvblxuICAgKi9cbiAgdmVyc2lvbjogdmVyc2lvbixcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gTWF0aE1MLCBhbmQgYWRkc1xuICAgKiBpdCBhcyBhIGNoaWxkIHRvIHRoZSBzcGVjaWZpZWQgRE9NIG5vZGUuXG4gICAqL1xuICByZW5kZXIsXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIE1hdGhNTCBzdHJpbmcsXG4gICAqIGZvciBzZW5kaW5nIHRvIHRoZSBjbGllbnQuXG4gICAqL1xuICByZW5kZXJUb1N0cmluZyxcbiAgLyoqXG4gICAqIEZpbmRzIGFsbCB0aGUgbWF0aCBkZWxpbWl0ZXJzIGluIGEgZ2l2ZW4gZWxlbWVudCBvZiBhIHJ1bm5pbmcgSFRNTCBkb2N1bWVudFxuICAgKiBhbmQgY29udmVydHMgdGhlIGNvbnRlbnRzIG9mIGVhY2ggaW5zdGFuY2UgaW50byBhIDxtYXRoPiBlbGVtZW50LlxuICAgKi9cbiAgcmVuZGVyTWF0aEluRWxlbWVudCxcbiAgLyoqXG4gICAqIFBvc3QtcHJvY2VzcyBhbiBlbnRpcmUgSFRNTCBibG9jay5cbiAgICogV3JpdGVzIEFNUyBhdXRvLW51bWJlcnMgYW5kIGltcGxlbWVudHMgXFxyZWZ7fS5cbiAgICogVHlwY2FsbHkgY2FsbGVkIG9uY2UsIGFmdGVyIGEgbG9vcCBoYXMgcmVuZGVyZWQgbWFueSBpbmRpdmlkdWFsIHNwYW5zLlxuICAgKi9cbiAgcG9zdFByb2Nlc3MsXG4gIC8qKlxuICAgKiBUZW1tbCBlcnJvciwgdXN1YWxseSBkdXJpbmcgcGFyc2luZy5cbiAgICovXG4gIFBhcnNlRXJyb3IsXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2V0IG9mIG1hY3JvcyB3aXRoIGRvY3VtZW50LXdpZGUgc2NvcGUuXG4gICAqL1xuICBkZWZpbmVQcmVhbWJsZSxcbiAgLyoqXG4gICAqIFBhcnNlcyB0aGUgZ2l2ZW4gTGFUZVggaW50byBUZW1tbCdzIGludGVybmFsIHBhcnNlIHRyZWUgc3RydWN0dXJlLFxuICAgKiB3aXRob3V0IHJlbmRlcmluZyB0byBIVE1MIG9yIE1hdGhNTC5cbiAgICpcbiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS5cbiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5XG4gICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAqL1xuICBfX3BhcnNlOiBnZW5lcmF0ZVBhcnNlVHJlZSxcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYSBNYXRoTUwgaW50ZXJuYWwgRE9NIHRyZWVcbiAgICogcmVwcmVzZW50YXRpb24sIHdpdGhvdXQgZmxhdHRlbmluZyB0aGF0IHJlcHJlc2VudGF0aW9uIHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcmVuZGVyVG9NYXRoTUxUcmVlOiByZW5kZXJUb01hdGhNTFRyZWUsXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IHN5bWJvbCB0byBidWlsdGluIHN5bWJvbHMgdGFibGVcbiAgICovXG4gIF9fZGVmaW5lU3ltYm9sOiBkZWZpbmVTeW1ib2wsXG4gIC8qKlxuICAgKiBhZGRzIGEgbmV3IG1hY3JvIHRvIGJ1aWx0aW4gbWFjcm8gbGlzdFxuICAgKi9cbiAgX19kZWZpbmVNYWNybzogZGVmaW5lTWFjcm9cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtbWwkMTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJleHBvcnQgeyBEZWZ1ZGRsZSB9IGZyb20gJy4vZGVmdWRkbGUnO1xuZXhwb3J0IHR5cGUgeyBEZWZ1ZGRsZU9wdGlvbnMsIERlZnVkZGxlUmVzcG9uc2UsIERlZnVkZGxlTWV0YWRhdGEgfSBmcm9tICcuL3R5cGVzJzsgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9