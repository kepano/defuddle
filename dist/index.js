(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Defuddle"] = factory();
	else
		root["Defuddle"] = factory();
})(typeof self !== "undefined" ? self : this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 315:
/*!*********************!*\
  !*** ./src/math.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mathStandardizationRules = exports.createStandardMathElement = exports.isBlockMath = exports.getLatexFromElement = exports.getMathMLFromElement = void 0;
const mathml_to_latex_1 = __webpack_require__(/*! mathml-to-latex */ 354);
const temml = __importStar(__webpack_require__(/*! temml */ 914));
const getMathMLFromElement = (el) => {
    console.log('getMathMLFromElement input:', el.outerHTML);
    // 1. Direct MathML content
    if (el.tagName.toLowerCase() === 'math') {
        const isBlock = el.getAttribute('display') === 'block';
        console.log('Direct MathML - isBlock:', isBlock);
        return {
            mathml: el.outerHTML,
            latex: el.getAttribute('alttext') || null,
            isBlock
        };
    }
    // 2. MathML in data-mathml attribute
    const mathmlStr = el.getAttribute('data-mathml');
    if (mathmlStr) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathmlStr;
        const mathElement = tempDiv.querySelector('math');
        if (mathElement) {
            const isBlock = mathElement.getAttribute('display') === 'block';
            console.log('data-mathml - isBlock:', isBlock);
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 3. MathJax assistive MathML
    const assistiveMmlContainer = el.querySelector('.MJX_Assistive_MathML, mjx-assistive-mml');
    console.log('Found assistiveMmlContainer:', assistiveMmlContainer === null || assistiveMmlContainer === void 0 ? void 0 : assistiveMmlContainer.outerHTML);
    if (assistiveMmlContainer) {
        const mathElement = assistiveMmlContainer.querySelector('math');
        console.log('Found mathElement:', mathElement === null || mathElement === void 0 ? void 0 : mathElement.outerHTML);
        if (mathElement) {
            // Check both the math element and container for display mode
            const mathDisplayAttr = mathElement.getAttribute('display');
            const containerDisplayAttr = assistiveMmlContainer.getAttribute('display');
            console.log('Math display attribute:', mathDisplayAttr);
            console.log('Container display attribute:', containerDisplayAttr);
            const isBlock = mathDisplayAttr === 'block' || containerDisplayAttr === 'block';
            console.log('Final isBlock determination:', isBlock);
            return {
                mathml: mathElement.outerHTML,
                latex: mathElement.getAttribute('alttext') || null,
                isBlock
            };
        }
    }
    // 4. KaTeX MathML
    const katexMathml = el.querySelector('.katex-mathml math');
    if (katexMathml) {
        console.log('KaTeX MathML found');
        return {
            mathml: katexMathml.outerHTML,
            latex: null, // We'll get LaTeX separately for KaTeX
            isBlock: false // We'll determine this from container
        };
    }
    console.log('No MathML found');
    return null;
};
exports.getMathMLFromElement = getMathMLFromElement;
const getLatexFromElement = (el) => {
    var _a, _b;
    // 1. Direct data-latex attribute
    const dataLatex = el.getAttribute('data-latex');
    if (dataLatex) {
        return dataLatex;
    }
    // 2. WordPress LaTeX images
    if (el instanceof HTMLImageElement && el.classList.contains('latex')) {
        // Try alt text first as it's cleaner
        const altLatex = el.getAttribute('alt');
        if (altLatex) {
            return altLatex;
        }
        // Fallback to extracting from URL
        const src = el.getAttribute('src');
        if (src) {
            const match = src.match(/latex\.php\?latex=([^&]+)/);
            if (match) {
                return decodeURIComponent(match[1])
                    .replace(/\+/g, ' ') // Replace + with spaces
                    .replace(/%5C/g, '\\'); // Fix escaped backslashes
            }
        }
    }
    // 3. LaTeX in annotation
    const annotation = el.querySelector('annotation[encoding="application/x-tex"]');
    if (annotation === null || annotation === void 0 ? void 0 : annotation.textContent) {
        return annotation.textContent.trim();
    }
    // 4. KaTeX specific formats
    if (el.matches('.katex')) {
        // Try katex-mathml annotation first
        const katexAnnotation = el.querySelector('.katex-mathml annotation[encoding="application/x-tex"]');
        if (katexAnnotation === null || katexAnnotation === void 0 ? void 0 : katexAnnotation.textContent) {
            return katexAnnotation.textContent.trim();
        }
    }
    // 5. MathJax specific formats
    if (el.matches('script[type="math/tex"]')) {
        return ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || null;
    }
    // 6. Try to convert MathML to LaTeX as last resort
    const mathml = (0, exports.getMathMLFromElement)(el);
    if (mathml === null || mathml === void 0 ? void 0 : mathml.mathml) {
        try {
            return mathml_to_latex_1.MathMLToLaTeX.convert(mathml.mathml);
        }
        catch (error) {
            console.error('Error converting MathML to LaTeX:', error);
            return null;
        }
    }
    // 7. Fallback to alt text or text content
    return el.getAttribute('alt') || ((_b = el.textContent) === null || _b === void 0 ? void 0 : _b.trim()) || null;
};
exports.getLatexFromElement = getLatexFromElement;
const isBlockMath = (el) => {
    console.log('isBlockMath checking element:', el.outerHTML);
    // 1. Check explicit display attribute
    const displayAttr = el.getAttribute('display');
    console.log('display attribute:', displayAttr);
    if (displayAttr === 'block') {
        return true;
    }
    // 2. Check common class names
    const classNames = el.className.toLowerCase();
    console.log('class names:', classNames);
    if (classNames.includes('display') || classNames.includes('block')) {
        return true;
    }
    // 3. Check container classes
    const container = el.closest('.katex-display, .MathJax_Display, [data-display="block"]');
    console.log('container found:', container === null || container === void 0 ? void 0 : container.outerHTML);
    if (container) {
        return true;
    }
    // 4. Check if preceded by block element
    const prevElement = el.previousElementSibling;
    console.log('previous element:', prevElement === null || prevElement === void 0 ? void 0 : prevElement.outerHTML);
    if ((prevElement === null || prevElement === void 0 ? void 0 : prevElement.tagName.toLowerCase()) === 'p') {
        return true;
    }
    // 5. Check specific formats
    if (el.matches('.mwe-math-fallback-image-display')) {
        return true;
    }
    // 6. Check KaTeX display mode
    if (el.matches('.katex')) {
        // KaTeX elements are inline by default
        // Only block if explicitly marked as display
        return el.closest('.katex-display') !== null;
    }
    // 7. Check MathJax v3 display attribute
    if (el.hasAttribute('display')) {
        console.log('Found display attribute:', el.getAttribute('display'));
        return el.getAttribute('display') === 'true';
    }
    // 8. Check parent container display attribute
    const parentContainer = el.closest('[display]');
    if (parentContainer) {
        console.log('Parent container display:', parentContainer.getAttribute('display'));
        return parentContainer.getAttribute('display') === 'true';
    }
    return false;
};
exports.isBlockMath = isBlockMath;
const createStandardMathElement = (mathData, latex, isBlock) => {
    console.log('createStandardMathElement inputs:', {
        mathData,
        latex,
        isBlock
    });
    const newMath = document.createElement('math');
    // Set display mode
    newMath.setAttribute('display', isBlock ? 'block' : 'inline');
    // Set LaTeX if available
    if (latex) {
        newMath.setAttribute('data-latex', latex);
    }
    // First try to use existing MathML content
    if (mathData === null || mathData === void 0 ? void 0 : mathData.mathml) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = mathData.mathml;
        const mathContent = tempDiv.querySelector('math');
        if (mathContent) {
            newMath.innerHTML = mathContent.innerHTML;
        }
    }
    // If no MathML content but we have LaTeX, convert using Temml
    else if (latex) {
        try {
            console.log('Converting LaTeX to MathML:', latex);
            // Convert LaTeX to MathML using Temml
            const mathml = temml.renderToString(latex, {
                displayMode: isBlock,
                throwOnError: false
            });
            console.log('Temml conversion result:', mathml);
            if (typeof mathml === 'string') {
                // Extract the inner content of the math element
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = mathml;
                const mathContent = tempDiv.querySelector('math');
                if (mathContent) {
                    // Copy attributes except display mode
                    Array.from(mathContent.attributes).forEach(attr => {
                        if (attr.name !== 'display') {
                            newMath.setAttribute(attr.name, attr.value);
                        }
                    });
                    newMath.innerHTML = mathContent.innerHTML;
                }
                else {
                    // Use the entire output as fallback
                    newMath.innerHTML = mathml;
                }
            }
            else {
                newMath.textContent = latex;
            }
        }
        catch (error) {
            console.error('Error converting LaTeX to MathML:', error);
            newMath.textContent = latex;
        }
    }
    console.log('Created math element:', newMath.outerHTML);
    return newMath;
};
exports.createStandardMathElement = createStandardMathElement;
// Math element standardization rules
exports.mathStandardizationRules = [
    {
        // WordPress LaTeX images
        selector: 'img.latex[src*="latex.php"]',
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLImageElement))
                return el;
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // WordPress LaTeX images are inline by default
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element without MathML
            return (0, exports.createStandardMathElement)(null, latex, isBlock);
        }
    },
    {
        // MathJax elements (v2 and v3)
        selector: [
            'span.MathJax',
            'mjx-container',
            'script[type="math/tex"]',
            'script[type="math/tex; mode=display"]',
            '.MathJax_Preview + script[type="math/tex"]',
            '.MathJax_Display',
            '.MathJax_SVG',
            '.MathJax_MathML'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el) || el.matches('script[type="math/tex; mode=display"]');
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    },
    {
        // MediaWiki math elements
        selector: [
            '.mwe-math-element',
            '.mwe-math-fallback-image-inline',
            '.mwe-math-fallback-image-display',
            '.mwe-math-mathml-inline',
            '.mwe-math-mathml-display',
            'math[xmlns="http://www.w3.org/1998/Math/MathML"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    },
    {
        // KaTeX elements
        selector: [
            '.katex',
            '.katex-display',
            '.katex-mathml',
            '.katex-html',
            '[data-katex]',
            'script[type="math/katex"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    },
    {
        // Generic math elements and other formats
        selector: [
            'math',
            '[data-math]',
            '[data-latex]',
            '[data-tex]',
            'script[type^="math/"]',
            'annotation[encoding="application/x-tex"]'
        ].join(','),
        element: 'math',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Get MathML content
            const mathData = (0, exports.getMathMLFromElement)(el);
            // Get LaTeX formula
            const latex = (0, exports.getLatexFromElement)(el);
            // Determine display mode
            const isBlock = (0, exports.isBlockMath)(el);
            // Create standardized math element
            return (0, exports.createStandardMathElement)(mathData, latex, isBlock);
        }
    }
];


/***/ }),

/***/ 354:
/*!*********************************************************!*\
  !*** ./node_modules/mathml-to-latex/dist/bundle.min.js ***!
  \*********************************************************/
/***/ (function(module) {

!function(e,t){ true?module.exports=t():0}(this,(()=>(()=>{var e={4582:(e,t)=>{"use strict";function r(e,t){return void 0===t&&(t=Object),t&&"function"==typeof t.freeze?t.freeze(e):e}var a=r({HTML:"text/html",isHTML:function(e){return e===a.HTML},XML_APPLICATION:"application/xml",XML_TEXT:"text/xml",XML_XHTML_APPLICATION:"application/xhtml+xml",XML_SVG_IMAGE:"image/svg+xml"}),n=r({HTML:"http://www.w3.org/1999/xhtml",isHTML:function(e){return e===n.HTML},SVG:"http://www.w3.org/2000/svg",XML:"http://www.w3.org/XML/1998/namespace",XMLNS:"http://www.w3.org/2000/xmlns/"});t.assign=function(e,t){if(null===e||"object"!=typeof e)throw new TypeError("target is not an object");for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e},t.find=function(e,t,r){if(void 0===r&&(r=Array.prototype),e&&"function"==typeof r.find)return r.find.call(e,t);for(var a=0;a<e.length;a++)if(Object.prototype.hasOwnProperty.call(e,a)){var n=e[a];if(t.call(void 0,n,a,e))return n}},t.freeze=r,t.MIME_TYPE=a,t.NAMESPACE=n},5752:(e,t,r)=>{var a=r(4582),n=r(4722),o=r(6559),i=r(4466),s=n.DOMImplementation,l=a.NAMESPACE,c=i.ParseError,u=i.XMLReader;function h(e){return e.replace(/\r[\n\u0085]/g,"\n").replace(/[\r\u0085\u2028]/g,"\n")}function d(e){this.options=e||{locator:{}}}function m(){this.cdata=!1}function p(e,t){t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber}function f(e){if(e)return"\n@"+(e.systemId||"")+"#[line:"+e.lineNumber+",col:"+e.columnNumber+"]"}function x(e,t,r){return"string"==typeof e?e.substr(t,r):e.length>=t+r||t?new java.lang.String(e,t,r)+"":e}function g(e,t){e.currentElement?e.currentElement.appendChild(t):e.doc.appendChild(t)}d.prototype.parseFromString=function(e,t){var r=this.options,a=new u,n=r.domBuilder||new m,i=r.errorHandler,s=r.locator,c=r.xmlns||{},d=/\/x?html?$/.test(t),p=d?o.HTML_ENTITIES:o.XML_ENTITIES;s&&n.setDocumentLocator(s),a.errorHandler=function(e,t,r){if(!e){if(t instanceof m)return t;e=t}var a={},n=e instanceof Function;function o(t){var o=e[t];!o&&n&&(o=2==e.length?function(r){e(t,r)}:e),a[t]=o&&function(e){o("[xmldom "+t+"]\t"+e+f(r))}||function(){}}return r=r||{},o("warning"),o("error"),o("fatalError"),a}(i,n,s),a.domBuilder=r.domBuilder||n,d&&(c[""]=l.HTML),c.xml=c.xml||l.XML;var x=r.normalizeLineEndings||h;return e&&"string"==typeof e?a.parse(x(e),c,p):a.errorHandler.error("invalid doc source"),n.doc},m.prototype={startDocument:function(){this.doc=(new s).createDocument(null,null,null),this.locator&&(this.doc.documentURI=this.locator.systemId)},startElement:function(e,t,r,a){var n=this.doc,o=n.createElementNS(e,r||t),i=a.length;g(this,o),this.currentElement=o,this.locator&&p(this.locator,o);for(var s=0;s<i;s++){e=a.getURI(s);var l=a.getValue(s),c=(r=a.getQName(s),n.createAttributeNS(e,r));this.locator&&p(a.getLocator(s),c),c.value=c.nodeValue=l,o.setAttributeNode(c)}},endElement:function(e,t,r){var a=this.currentElement;a.tagName,this.currentElement=a.parentNode},startPrefixMapping:function(e,t){},endPrefixMapping:function(e){},processingInstruction:function(e,t){var r=this.doc.createProcessingInstruction(e,t);this.locator&&p(this.locator,r),g(this,r)},ignorableWhitespace:function(e,t,r){},characters:function(e,t,r){if(e=x.apply(this,arguments)){if(this.cdata)var a=this.doc.createCDATASection(e);else a=this.doc.createTextNode(e);this.currentElement?this.currentElement.appendChild(a):/^\s*$/.test(e)&&this.doc.appendChild(a),this.locator&&p(this.locator,a)}},skippedEntity:function(e){},endDocument:function(){this.doc.normalize()},setDocumentLocator:function(e){(this.locator=e)&&(e.lineNumber=0)},comment:function(e,t,r){e=x.apply(this,arguments);var a=this.doc.createComment(e);this.locator&&p(this.locator,a),g(this,a)},startCDATA:function(){this.cdata=!0},endCDATA:function(){this.cdata=!1},startDTD:function(e,t,r){var a=this.doc.implementation;if(a&&a.createDocumentType){var n=a.createDocumentType(e,t,r);this.locator&&p(this.locator,n),g(this,n),this.doc.doctype=n}},warning:function(e){console.warn("[xmldom warning]\t"+e,f(this.locator))},error:function(e){console.error("[xmldom error]\t"+e,f(this.locator))},fatalError:function(e){throw new c(e,this.locator)}},"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,(function(e){m.prototype[e]=function(){return null}})),t.DOMParser=d},4722:(e,t,r)=>{var a=r(4582),n=a.find,o=a.NAMESPACE;function i(e){return""!==e}function s(e,t){return e.hasOwnProperty(t)||(e[t]=!0),e}function l(e){if(!e)return[];var t=function(e){return e?e.split(/[\t\n\f\r ]+/).filter(i):[]}(e);return Object.keys(t.reduce(s,{}))}function c(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function u(e,t){var r=e.prototype;if(!(r instanceof t)){function a(){}a.prototype=t.prototype,c(r,a=new a),e.prototype=r=a}r.constructor!=e&&("function"!=typeof e&&console.error("unknown Class:"+e),r.constructor=e)}var h={},d=h.ELEMENT_NODE=1,m=h.ATTRIBUTE_NODE=2,p=h.TEXT_NODE=3,f=h.CDATA_SECTION_NODE=4,x=h.ENTITY_REFERENCE_NODE=5,g=h.ENTITY_NODE=6,w=h.PROCESSING_INSTRUCTION_NODE=7,b=h.COMMENT_NODE=8,v=h.DOCUMENT_NODE=9,C=h.DOCUMENT_TYPE_NODE=10,A=h.DOCUMENT_FRAGMENT_NODE=11,E=h.NOTATION_NODE=12,_={},y={},q=(_.INDEX_SIZE_ERR=(y[1]="Index size error",1),_.DOMSTRING_SIZE_ERR=(y[2]="DOMString size error",2),_.HIERARCHY_REQUEST_ERR=(y[3]="Hierarchy request error",3)),D=(_.WRONG_DOCUMENT_ERR=(y[4]="Wrong document",4),_.INVALID_CHARACTER_ERR=(y[5]="Invalid character",5),_.NO_DATA_ALLOWED_ERR=(y[6]="No data allowed",6),_.NO_MODIFICATION_ALLOWED_ERR=(y[7]="No modification allowed",7),_.NOT_FOUND_ERR=(y[8]="Not found",8)),M=(_.NOT_SUPPORTED_ERR=(y[9]="Not supported",9),_.INUSE_ATTRIBUTE_ERR=(y[10]="Attribute in use",10));function T(e,t){if(t instanceof Error)var r=t;else r=this,Error.call(this,y[e]),this.message=y[e],Error.captureStackTrace&&Error.captureStackTrace(this,T);return r.code=e,t&&(this.message=this.message+": "+t),r}function N(){}function O(e,t){this._node=e,this._refresh=t,L(this)}function L(e){var t=e._node._inc||e._node.ownerDocument._inc;if(e._inc!==t){var r=e._refresh(e._node);if(we(e,"length",r.length),!e.$$length||r.length<e.$$length)for(var a=r.length;a in e;a++)Object.prototype.hasOwnProperty.call(e,a)&&delete e[a];c(r,e),e._inc=t}}function B(){}function S(e,t){for(var r=e.length;r--;)if(e[r]===t)return r}function F(e,t,r,a){if(a?t[S(t,a)]=r:t[t.length++]=r,e){r.ownerElement=e;var n=e.ownerDocument;n&&(a&&V(n,e,a),function(e,t,r){e&&e._inc++,r.namespaceURI===o.XMLNS&&(t._nsMap[r.prefix?r.localName:""]=r.value)}(n,e,r))}}function P(e,t,r){var a=S(t,r);if(!(a>=0))throw new T(D,new Error(e.tagName+"@"+r));for(var n=t.length-1;a<n;)t[a]=t[++a];if(t.length=n,e){var o=e.ownerDocument;o&&(V(o,e,r),r.ownerElement=null)}}function k(){}function R(){}function I(e){return("<"==e?"&lt;":">"==e&&"&gt;")||"&"==e&&"&amp;"||'"'==e&&"&quot;"||"&#"+e.charCodeAt()+";"}function U(e,t){if(t(e))return!0;if(e=e.firstChild)do{if(U(e,t))return!0}while(e=e.nextSibling)}function j(){this.ownerDocument=this}function V(e,t,r,a){e&&e._inc++,r.namespaceURI===o.XMLNS&&delete t._nsMap[r.prefix?r.localName:""]}function G(e,t,r){if(e&&e._inc){e._inc++;var a=t.childNodes;if(r)a[a.length++]=r;else{for(var n=t.firstChild,o=0;n;)a[o++]=n,n=n.nextSibling;a.length=o,delete a[a.length]}}}function $(e,t){var r=t.previousSibling,a=t.nextSibling;return r?r.nextSibling=a:e.firstChild=a,a?a.previousSibling=r:e.lastChild=r,t.parentNode=null,t.previousSibling=null,t.nextSibling=null,G(e.ownerDocument,e),t}function X(e){return e&&e.nodeType===R.DOCUMENT_TYPE_NODE}function H(e){return e&&e.nodeType===R.ELEMENT_NODE}function W(e){return e&&e.nodeType===R.TEXT_NODE}function z(e,t){var r=e.childNodes||[];if(n(r,H)||X(t))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function Y(e,t){var r=e.childNodes||[];if(n(r,(function(e){return H(e)&&e!==t})))return!1;var a=n(r,X);return!(t&&a&&r.indexOf(a)>r.indexOf(t))}function J(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!z(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!z(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,X))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element");if(!r&&s)throw new T(q,"Doctype can not be appended since element is present")}}function Z(e,t,r){var a=e.childNodes||[],o=t.childNodes||[];if(t.nodeType===R.DOCUMENT_FRAGMENT_NODE){var i=o.filter(H);if(i.length>1||n(o,W))throw new T(q,"More than one element or text in fragment");if(1===i.length&&!Y(e,r))throw new T(q,"Element in fragment can not be inserted before doctype")}if(H(t)&&!Y(e,r))throw new T(q,"Only one element can be added and only after doctype");if(X(t)){if(n(a,(function(e){return X(e)&&e!==r})))throw new T(q,"Only one doctype is allowed");var s=n(a,H);if(r&&a.indexOf(s)<a.indexOf(r))throw new T(q,"Doctype can only be inserted before an element")}}function Q(e,t,r,a){(function(e,t,r){if(!function(e){return e&&(e.nodeType===R.DOCUMENT_NODE||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.ELEMENT_NODE)}(e))throw new T(q,"Unexpected parent node type "+e.nodeType);if(r&&r.parentNode!==e)throw new T(D,"child not in parent");if(!function(e){return e&&(H(e)||W(e)||X(e)||e.nodeType===R.DOCUMENT_FRAGMENT_NODE||e.nodeType===R.COMMENT_NODE||e.nodeType===R.PROCESSING_INSTRUCTION_NODE)}(t)||X(t)&&e.nodeType!==R.DOCUMENT_NODE)throw new T(q,"Unexpected node type "+t.nodeType+" for parent node type "+e.nodeType)})(e,t,r),e.nodeType===R.DOCUMENT_NODE&&(a||J)(e,t,r);var n=t.parentNode;if(n&&n.removeChild(t),t.nodeType===A){var o=t.firstChild;if(null==o)return t;var i=t.lastChild}else o=i=t;var s=r?r.previousSibling:e.lastChild;o.previousSibling=s,i.nextSibling=r,s?s.nextSibling=o:e.firstChild=o,null==r?e.lastChild=i:r.previousSibling=i;do{o.parentNode=e}while(o!==i&&(o=o.nextSibling));return G(e.ownerDocument||e,e),t.nodeType==A&&(t.firstChild=t.lastChild=null),t}function K(){this._nsMap={}}function ee(){}function te(){}function re(){}function ae(){}function ne(){}function oe(){}function ie(){}function se(){}function le(){}function ce(){}function ue(){}function he(){}function de(e,t){var r=[],a=9==this.nodeType&&this.documentElement||this,n=a.prefix,o=a.namespaceURI;if(o&&null==n&&null==(n=a.lookupPrefix(o)))var i=[{namespace:o,prefix:null}];return fe(this,r,e,t,i),r.join("")}function me(e,t,r){var a=e.prefix||"",n=e.namespaceURI;if(!n)return!1;if("xml"===a&&n===o.XML||n===o.XMLNS)return!1;for(var i=r.length;i--;){var s=r[i];if(s.prefix===a)return s.namespace!==n}return!0}function pe(e,t,r){e.push(" ",t,'="',r.replace(/[<>&"\t\n\r]/g,I),'"')}function fe(e,t,r,a,n){if(n||(n=[]),a){if(!(e=a(e)))return;if("string"==typeof e)return void t.push(e)}switch(e.nodeType){case d:var i=e.attributes,s=i.length,l=e.firstChild,c=e.tagName,u=c;if(!(r=o.isHTML(e.namespaceURI)||r)&&!e.prefix&&e.namespaceURI){for(var h,g=0;g<i.length;g++)if("xmlns"===i.item(g).name){h=i.item(g).value;break}if(!h)for(var E=n.length-1;E>=0;E--)if(""===(_=n[E]).prefix&&_.namespace===e.namespaceURI){h=_.namespace;break}if(h!==e.namespaceURI)for(E=n.length-1;E>=0;E--){var _;if((_=n[E]).namespace===e.namespaceURI){_.prefix&&(u=_.prefix+":"+c);break}}}t.push("<",u);for(var y=0;y<s;y++)"xmlns"==(q=i.item(y)).prefix?n.push({prefix:q.localName,namespace:q.value}):"xmlns"==q.nodeName&&n.push({prefix:"",namespace:q.value});for(y=0;y<s;y++){var q,D,M;me(q=i.item(y),0,n)&&(pe(t,(D=q.prefix||"")?"xmlns:"+D:"xmlns",M=q.namespaceURI),n.push({prefix:D,namespace:M})),fe(q,t,r,a,n)}if(c===u&&me(e,0,n)&&(pe(t,(D=e.prefix||"")?"xmlns:"+D:"xmlns",M=e.namespaceURI),n.push({prefix:D,namespace:M})),l||r&&!/^(?:meta|link|img|br|hr|input)$/i.test(c)){if(t.push(">"),r&&/^script$/i.test(c))for(;l;)l.data?t.push(l.data):fe(l,t,r,a,n.slice()),l=l.nextSibling;else for(;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;t.push("</",u,">")}else t.push("/>");return;case v:case A:for(l=e.firstChild;l;)fe(l,t,r,a,n.slice()),l=l.nextSibling;return;case m:return pe(t,e.name,e.value);case p:return t.push(e.data.replace(/[<&>]/g,I));case f:return t.push("<![CDATA[",e.data,"]]>");case b:return t.push("\x3c!--",e.data,"--\x3e");case C:var T=e.publicId,N=e.systemId;if(t.push("<!DOCTYPE ",e.name),T)t.push(" PUBLIC ",T),N&&"."!=N&&t.push(" ",N),t.push(">");else if(N&&"."!=N)t.push(" SYSTEM ",N,">");else{var O=e.internalSubset;O&&t.push(" [",O,"]"),t.push(">")}return;case w:return t.push("<?",e.target," ",e.data,"?>");case x:return t.push("&",e.nodeName,";");default:t.push("??",e.nodeName)}}function xe(e,t,r){var a;switch(t.nodeType){case d:(a=t.cloneNode(!1)).ownerDocument=e;case A:break;case m:r=!0}if(a||(a=t.cloneNode(!1)),a.ownerDocument=e,a.parentNode=null,r)for(var n=t.firstChild;n;)a.appendChild(xe(e,n,r)),n=n.nextSibling;return a}function ge(e,t,r){var a=new t.constructor;for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var o=t[n];"object"!=typeof o&&o!=a[n]&&(a[n]=o)}switch(t.childNodes&&(a.childNodes=new N),a.ownerDocument=e,a.nodeType){case d:var i=t.attributes,s=a.attributes=new B,l=i.length;s._ownerElement=a;for(var c=0;c<l;c++)a.setAttributeNode(ge(e,i.item(c),!0));break;case m:r=!0}if(r)for(var u=t.firstChild;u;)a.appendChild(ge(e,u,r)),u=u.nextSibling;return a}function we(e,t,r){e[t]=r}_.INVALID_STATE_ERR=(y[11]="Invalid state",11),_.SYNTAX_ERR=(y[12]="Syntax error",12),_.INVALID_MODIFICATION_ERR=(y[13]="Invalid modification",13),_.NAMESPACE_ERR=(y[14]="Invalid namespace",14),_.INVALID_ACCESS_ERR=(y[15]="Invalid access",15),T.prototype=Error.prototype,c(_,T),N.prototype={length:0,item:function(e){return e>=0&&e<this.length?this[e]:null},toString:function(e,t){for(var r=[],a=0;a<this.length;a++)fe(this[a],r,e,t);return r.join("")},filter:function(e){return Array.prototype.filter.call(this,e)},indexOf:function(e){return Array.prototype.indexOf.call(this,e)}},O.prototype.item=function(e){return L(this),this[e]||null},u(O,N),B.prototype={length:0,item:N.prototype.item,getNamedItem:function(e){for(var t=this.length;t--;){var r=this[t];if(r.nodeName==e)return r}},setNamedItem:function(e){var t=e.ownerElement;if(t&&t!=this._ownerElement)throw new T(M);var r=this.getNamedItem(e.nodeName);return F(this._ownerElement,this,e,r),r},setNamedItemNS:function(e){var t,r=e.ownerElement;if(r&&r!=this._ownerElement)throw new T(M);return t=this.getNamedItemNS(e.namespaceURI,e.localName),F(this._ownerElement,this,e,t),t},removeNamedItem:function(e){var t=this.getNamedItem(e);return P(this._ownerElement,this,t),t},removeNamedItemNS:function(e,t){var r=this.getNamedItemNS(e,t);return P(this._ownerElement,this,r),r},getNamedItemNS:function(e,t){for(var r=this.length;r--;){var a=this[r];if(a.localName==t&&a.namespaceURI==e)return a}return null}},k.prototype={hasFeature:function(e,t){return!0},createDocument:function(e,t,r){var a=new j;if(a.implementation=this,a.childNodes=new N,a.doctype=r||null,r&&a.appendChild(r),t){var n=a.createElementNS(e,t);a.appendChild(n)}return a},createDocumentType:function(e,t,r){var a=new oe;return a.name=e,a.nodeName=e,a.publicId=t||"",a.systemId=r||"",a}},R.prototype={firstChild:null,lastChild:null,previousSibling:null,nextSibling:null,attributes:null,parentNode:null,childNodes:null,ownerDocument:null,nodeValue:null,namespaceURI:null,prefix:null,localName:null,insertBefore:function(e,t){return Q(this,e,t)},replaceChild:function(e,t){Q(this,e,t,Z),t&&this.removeChild(t)},removeChild:function(e){return $(this,e)},appendChild:function(e){return this.insertBefore(e,null)},hasChildNodes:function(){return null!=this.firstChild},cloneNode:function(e){return ge(this.ownerDocument||this,this,e)},normalize:function(){for(var e=this.firstChild;e;){var t=e.nextSibling;t&&t.nodeType==p&&e.nodeType==p?(this.removeChild(t),e.appendData(t.data)):(e.normalize(),e=t)}},isSupported:function(e,t){return this.ownerDocument.implementation.hasFeature(e,t)},hasAttributes:function(){return this.attributes.length>0},lookupPrefix:function(e){for(var t=this;t;){var r=t._nsMap;if(r)for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a)&&r[a]===e)return a;t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},lookupNamespaceURI:function(e){for(var t=this;t;){var r=t._nsMap;if(r&&Object.prototype.hasOwnProperty.call(r,e))return r[e];t=t.nodeType==m?t.ownerDocument:t.parentNode}return null},isDefaultNamespace:function(e){return null==this.lookupPrefix(e)}},c(h,R),c(h,R.prototype),j.prototype={nodeName:"#document",nodeType:v,doctype:null,documentElement:null,_inc:1,insertBefore:function(e,t){if(e.nodeType==A){for(var r=e.firstChild;r;){var a=r.nextSibling;this.insertBefore(r,t),r=a}return e}return Q(this,e,t),e.ownerDocument=this,null===this.documentElement&&e.nodeType===d&&(this.documentElement=e),e},removeChild:function(e){return this.documentElement==e&&(this.documentElement=null),$(this,e)},replaceChild:function(e,t){Q(this,e,t,Z),e.ownerDocument=this,t&&this.removeChild(t),H(e)&&(this.documentElement=e)},importNode:function(e,t){return xe(this,e,t)},getElementById:function(e){var t=null;return U(this.documentElement,(function(r){if(r.nodeType==d&&r.getAttribute("id")==e)return t=r,!0})),t},getElementsByClassName:function(e){var t=l(e);return new O(this,(function(r){var a=[];return t.length>0&&U(r.documentElement,(function(n){if(n!==r&&n.nodeType===d){var o=n.getAttribute("class");if(o){var i=e===o;if(!i){var s=l(o);i=t.every((c=s,function(e){return c&&-1!==c.indexOf(e)}))}i&&a.push(n)}}var c})),a}))},createElement:function(e){var t=new K;return t.ownerDocument=this,t.nodeName=e,t.tagName=e,t.localName=e,t.childNodes=new N,(t.attributes=new B)._ownerElement=t,t},createDocumentFragment:function(){var e=new ce;return e.ownerDocument=this,e.childNodes=new N,e},createTextNode:function(e){var t=new re;return t.ownerDocument=this,t.appendData(e),t},createComment:function(e){var t=new ae;return t.ownerDocument=this,t.appendData(e),t},createCDATASection:function(e){var t=new ne;return t.ownerDocument=this,t.appendData(e),t},createProcessingInstruction:function(e,t){var r=new ue;return r.ownerDocument=this,r.tagName=r.nodeName=r.target=e,r.nodeValue=r.data=t,r},createAttribute:function(e){var t=new ee;return t.ownerDocument=this,t.name=e,t.nodeName=e,t.localName=e,t.specified=!0,t},createEntityReference:function(e){var t=new le;return t.ownerDocument=this,t.nodeName=e,t},createElementNS:function(e,t){var r=new K,a=t.split(":"),n=r.attributes=new B;return r.childNodes=new N,r.ownerDocument=this,r.nodeName=t,r.tagName=t,r.namespaceURI=e,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,n._ownerElement=r,r},createAttributeNS:function(e,t){var r=new ee,a=t.split(":");return r.ownerDocument=this,r.nodeName=t,r.name=t,r.namespaceURI=e,r.specified=!0,2==a.length?(r.prefix=a[0],r.localName=a[1]):r.localName=t,r}},u(j,R),K.prototype={nodeType:d,hasAttribute:function(e){return null!=this.getAttributeNode(e)},getAttribute:function(e){var t=this.getAttributeNode(e);return t&&t.value||""},getAttributeNode:function(e){return this.attributes.getNamedItem(e)},setAttribute:function(e,t){var r=this.ownerDocument.createAttribute(e);r.value=r.nodeValue=""+t,this.setAttributeNode(r)},removeAttribute:function(e){var t=this.getAttributeNode(e);t&&this.removeAttributeNode(t)},appendChild:function(e){return e.nodeType===A?this.insertBefore(e,null):function(e,t){return t.parentNode&&t.parentNode.removeChild(t),t.parentNode=e,t.previousSibling=e.lastChild,t.nextSibling=null,t.previousSibling?t.previousSibling.nextSibling=t:e.firstChild=t,e.lastChild=t,G(e.ownerDocument,e,t),t}(this,e)},setAttributeNode:function(e){return this.attributes.setNamedItem(e)},setAttributeNodeNS:function(e){return this.attributes.setNamedItemNS(e)},removeAttributeNode:function(e){return this.attributes.removeNamedItem(e.nodeName)},removeAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);r&&this.removeAttributeNode(r)},hasAttributeNS:function(e,t){return null!=this.getAttributeNodeNS(e,t)},getAttributeNS:function(e,t){var r=this.getAttributeNodeNS(e,t);return r&&r.value||""},setAttributeNS:function(e,t,r){var a=this.ownerDocument.createAttributeNS(e,t);a.value=a.nodeValue=""+r,this.setAttributeNode(a)},getAttributeNodeNS:function(e,t){return this.attributes.getNamedItemNS(e,t)},getElementsByTagName:function(e){return new O(this,(function(t){var r=[];return U(t,(function(a){a===t||a.nodeType!=d||"*"!==e&&a.tagName!=e||r.push(a)})),r}))},getElementsByTagNameNS:function(e,t){return new O(this,(function(r){var a=[];return U(r,(function(n){n===r||n.nodeType!==d||"*"!==e&&n.namespaceURI!==e||"*"!==t&&n.localName!=t||a.push(n)})),a}))}},j.prototype.getElementsByTagName=K.prototype.getElementsByTagName,j.prototype.getElementsByTagNameNS=K.prototype.getElementsByTagNameNS,u(K,R),ee.prototype.nodeType=m,u(ee,R),te.prototype={data:"",substringData:function(e,t){return this.data.substring(e,e+t)},appendData:function(e){e=this.data+e,this.nodeValue=this.data=e,this.length=e.length},insertData:function(e,t){this.replaceData(e,0,t)},appendChild:function(e){throw new Error(y[q])},deleteData:function(e,t){this.replaceData(e,t,"")},replaceData:function(e,t,r){r=this.data.substring(0,e)+r+this.data.substring(e+t),this.nodeValue=this.data=r,this.length=r.length}},u(te,R),re.prototype={nodeName:"#text",nodeType:p,splitText:function(e){var t=this.data,r=t.substring(e);t=t.substring(0,e),this.data=this.nodeValue=t,this.length=t.length;var a=this.ownerDocument.createTextNode(r);return this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling),a}},u(re,te),ae.prototype={nodeName:"#comment",nodeType:b},u(ae,te),ne.prototype={nodeName:"#cdata-section",nodeType:f},u(ne,te),oe.prototype.nodeType=C,u(oe,R),ie.prototype.nodeType=E,u(ie,R),se.prototype.nodeType=g,u(se,R),le.prototype.nodeType=x,u(le,R),ce.prototype.nodeName="#document-fragment",ce.prototype.nodeType=A,u(ce,R),ue.prototype.nodeType=w,u(ue,R),he.prototype.serializeToString=function(e,t,r){return de.call(e,t,r)},R.prototype.toString=de;try{if(Object.defineProperty){function be(e){switch(e.nodeType){case d:case A:var t=[];for(e=e.firstChild;e;)7!==e.nodeType&&8!==e.nodeType&&t.push(be(e)),e=e.nextSibling;return t.join("");default:return e.nodeValue}}Object.defineProperty(O.prototype,"length",{get:function(){return L(this),this.$$length}}),Object.defineProperty(R.prototype,"textContent",{get:function(){return be(this)},set:function(e){switch(this.nodeType){case d:case A:for(;this.firstChild;)this.removeChild(this.firstChild);(e||String(e))&&this.appendChild(this.ownerDocument.createTextNode(e));break;default:this.data=e,this.value=e,this.nodeValue=e}}}),we=function(e,t,r){e["$$"+t]=r}}}catch(ve){}t.DocumentType=oe,t.DOMException=T,t.DOMImplementation=k,t.Element=K,t.Node=R,t.NodeList=N,t.XMLSerializer=he},6559:(e,t,r)=>{"use strict";var a=r(4582).freeze;t.XML_ENTITIES=a({amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}),t.HTML_ENTITIES=a({Aacute:"Á",aacute:"á",Abreve:"Ă",abreve:"ă",ac:"∾",acd:"∿",acE:"∾̳",Acirc:"Â",acirc:"â",acute:"´",Acy:"А",acy:"а",AElig:"Æ",aelig:"æ",af:"⁡",Afr:"𝔄",afr:"𝔞",Agrave:"À",agrave:"à",alefsym:"ℵ",aleph:"ℵ",Alpha:"Α",alpha:"α",Amacr:"Ā",amacr:"ā",amalg:"⨿",AMP:"&",amp:"&",And:"⩓",and:"∧",andand:"⩕",andd:"⩜",andslope:"⩘",andv:"⩚",ang:"∠",ange:"⦤",angle:"∠",angmsd:"∡",angmsdaa:"⦨",angmsdab:"⦩",angmsdac:"⦪",angmsdad:"⦫",angmsdae:"⦬",angmsdaf:"⦭",angmsdag:"⦮",angmsdah:"⦯",angrt:"∟",angrtvb:"⊾",angrtvbd:"⦝",angsph:"∢",angst:"Å",angzarr:"⍼",Aogon:"Ą",aogon:"ą",Aopf:"𝔸",aopf:"𝕒",ap:"≈",apacir:"⩯",apE:"⩰",ape:"≊",apid:"≋",apos:"'",ApplyFunction:"⁡",approx:"≈",approxeq:"≊",Aring:"Å",aring:"å",Ascr:"𝒜",ascr:"𝒶",Assign:"≔",ast:"*",asymp:"≈",asympeq:"≍",Atilde:"Ã",atilde:"ã",Auml:"Ä",auml:"ä",awconint:"∳",awint:"⨑",backcong:"≌",backepsilon:"϶",backprime:"‵",backsim:"∽",backsimeq:"⋍",Backslash:"∖",Barv:"⫧",barvee:"⊽",Barwed:"⌆",barwed:"⌅",barwedge:"⌅",bbrk:"⎵",bbrktbrk:"⎶",bcong:"≌",Bcy:"Б",bcy:"б",bdquo:"„",becaus:"∵",Because:"∵",because:"∵",bemptyv:"⦰",bepsi:"϶",bernou:"ℬ",Bernoullis:"ℬ",Beta:"Β",beta:"β",beth:"ℶ",between:"≬",Bfr:"𝔅",bfr:"𝔟",bigcap:"⋂",bigcirc:"◯",bigcup:"⋃",bigodot:"⨀",bigoplus:"⨁",bigotimes:"⨂",bigsqcup:"⨆",bigstar:"★",bigtriangledown:"▽",bigtriangleup:"△",biguplus:"⨄",bigvee:"⋁",bigwedge:"⋀",bkarow:"⤍",blacklozenge:"⧫",blacksquare:"▪",blacktriangle:"▴",blacktriangledown:"▾",blacktriangleleft:"◂",blacktriangleright:"▸",blank:"␣",blk12:"▒",blk14:"░",blk34:"▓",block:"█",bne:"=⃥",bnequiv:"≡⃥",bNot:"⫭",bnot:"⌐",Bopf:"𝔹",bopf:"𝕓",bot:"⊥",bottom:"⊥",bowtie:"⋈",boxbox:"⧉",boxDL:"╗",boxDl:"╖",boxdL:"╕",boxdl:"┐",boxDR:"╔",boxDr:"╓",boxdR:"╒",boxdr:"┌",boxH:"═",boxh:"─",boxHD:"╦",boxHd:"╤",boxhD:"╥",boxhd:"┬",boxHU:"╩",boxHu:"╧",boxhU:"╨",boxhu:"┴",boxminus:"⊟",boxplus:"⊞",boxtimes:"⊠",boxUL:"╝",boxUl:"╜",boxuL:"╛",boxul:"┘",boxUR:"╚",boxUr:"╙",boxuR:"╘",boxur:"└",boxV:"║",boxv:"│",boxVH:"╬",boxVh:"╫",boxvH:"╪",boxvh:"┼",boxVL:"╣",boxVl:"╢",boxvL:"╡",boxvl:"┤",boxVR:"╠",boxVr:"╟",boxvR:"╞",boxvr:"├",bprime:"‵",Breve:"˘",breve:"˘",brvbar:"¦",Bscr:"ℬ",bscr:"𝒷",bsemi:"⁏",bsim:"∽",bsime:"⋍",bsol:"\\",bsolb:"⧅",bsolhsub:"⟈",bull:"•",bullet:"•",bump:"≎",bumpE:"⪮",bumpe:"≏",Bumpeq:"≎",bumpeq:"≏",Cacute:"Ć",cacute:"ć",Cap:"⋒",cap:"∩",capand:"⩄",capbrcup:"⩉",capcap:"⩋",capcup:"⩇",capdot:"⩀",CapitalDifferentialD:"ⅅ",caps:"∩︀",caret:"⁁",caron:"ˇ",Cayleys:"ℭ",ccaps:"⩍",Ccaron:"Č",ccaron:"č",Ccedil:"Ç",ccedil:"ç",Ccirc:"Ĉ",ccirc:"ĉ",Cconint:"∰",ccups:"⩌",ccupssm:"⩐",Cdot:"Ċ",cdot:"ċ",cedil:"¸",Cedilla:"¸",cemptyv:"⦲",cent:"¢",CenterDot:"·",centerdot:"·",Cfr:"ℭ",cfr:"𝔠",CHcy:"Ч",chcy:"ч",check:"✓",checkmark:"✓",Chi:"Χ",chi:"χ",cir:"○",circ:"ˆ",circeq:"≗",circlearrowleft:"↺",circlearrowright:"↻",circledast:"⊛",circledcirc:"⊚",circleddash:"⊝",CircleDot:"⊙",circledR:"®",circledS:"Ⓢ",CircleMinus:"⊖",CirclePlus:"⊕",CircleTimes:"⊗",cirE:"⧃",cire:"≗",cirfnint:"⨐",cirmid:"⫯",cirscir:"⧂",ClockwiseContourIntegral:"∲",CloseCurlyDoubleQuote:"”",CloseCurlyQuote:"’",clubs:"♣",clubsuit:"♣",Colon:"∷",colon:":",Colone:"⩴",colone:"≔",coloneq:"≔",comma:",",commat:"@",comp:"∁",compfn:"∘",complement:"∁",complexes:"ℂ",cong:"≅",congdot:"⩭",Congruent:"≡",Conint:"∯",conint:"∮",ContourIntegral:"∮",Copf:"ℂ",copf:"𝕔",coprod:"∐",Coproduct:"∐",COPY:"©",copy:"©",copysr:"℗",CounterClockwiseContourIntegral:"∳",crarr:"↵",Cross:"⨯",cross:"✗",Cscr:"𝒞",cscr:"𝒸",csub:"⫏",csube:"⫑",csup:"⫐",csupe:"⫒",ctdot:"⋯",cudarrl:"⤸",cudarrr:"⤵",cuepr:"⋞",cuesc:"⋟",cularr:"↶",cularrp:"⤽",Cup:"⋓",cup:"∪",cupbrcap:"⩈",CupCap:"≍",cupcap:"⩆",cupcup:"⩊",cupdot:"⊍",cupor:"⩅",cups:"∪︀",curarr:"↷",curarrm:"⤼",curlyeqprec:"⋞",curlyeqsucc:"⋟",curlyvee:"⋎",curlywedge:"⋏",curren:"¤",curvearrowleft:"↶",curvearrowright:"↷",cuvee:"⋎",cuwed:"⋏",cwconint:"∲",cwint:"∱",cylcty:"⌭",Dagger:"‡",dagger:"†",daleth:"ℸ",Darr:"↡",dArr:"⇓",darr:"↓",dash:"‐",Dashv:"⫤",dashv:"⊣",dbkarow:"⤏",dblac:"˝",Dcaron:"Ď",dcaron:"ď",Dcy:"Д",dcy:"д",DD:"ⅅ",dd:"ⅆ",ddagger:"‡",ddarr:"⇊",DDotrahd:"⤑",ddotseq:"⩷",deg:"°",Del:"∇",Delta:"Δ",delta:"δ",demptyv:"⦱",dfisht:"⥿",Dfr:"𝔇",dfr:"𝔡",dHar:"⥥",dharl:"⇃",dharr:"⇂",DiacriticalAcute:"´",DiacriticalDot:"˙",DiacriticalDoubleAcute:"˝",DiacriticalGrave:"`",DiacriticalTilde:"˜",diam:"⋄",Diamond:"⋄",diamond:"⋄",diamondsuit:"♦",diams:"♦",die:"¨",DifferentialD:"ⅆ",digamma:"ϝ",disin:"⋲",div:"÷",divide:"÷",divideontimes:"⋇",divonx:"⋇",DJcy:"Ђ",djcy:"ђ",dlcorn:"⌞",dlcrop:"⌍",dollar:"$",Dopf:"𝔻",dopf:"𝕕",Dot:"¨",dot:"˙",DotDot:"⃜",doteq:"≐",doteqdot:"≑",DotEqual:"≐",dotminus:"∸",dotplus:"∔",dotsquare:"⊡",doublebarwedge:"⌆",DoubleContourIntegral:"∯",DoubleDot:"¨",DoubleDownArrow:"⇓",DoubleLeftArrow:"⇐",DoubleLeftRightArrow:"⇔",DoubleLeftTee:"⫤",DoubleLongLeftArrow:"⟸",DoubleLongLeftRightArrow:"⟺",DoubleLongRightArrow:"⟹",DoubleRightArrow:"⇒",DoubleRightTee:"⊨",DoubleUpArrow:"⇑",DoubleUpDownArrow:"⇕",DoubleVerticalBar:"∥",DownArrow:"↓",Downarrow:"⇓",downarrow:"↓",DownArrowBar:"⤓",DownArrowUpArrow:"⇵",DownBreve:"̑",downdownarrows:"⇊",downharpoonleft:"⇃",downharpoonright:"⇂",DownLeftRightVector:"⥐",DownLeftTeeVector:"⥞",DownLeftVector:"↽",DownLeftVectorBar:"⥖",DownRightTeeVector:"⥟",DownRightVector:"⇁",DownRightVectorBar:"⥗",DownTee:"⊤",DownTeeArrow:"↧",drbkarow:"⤐",drcorn:"⌟",drcrop:"⌌",Dscr:"𝒟",dscr:"𝒹",DScy:"Ѕ",dscy:"ѕ",dsol:"⧶",Dstrok:"Đ",dstrok:"đ",dtdot:"⋱",dtri:"▿",dtrif:"▾",duarr:"⇵",duhar:"⥯",dwangle:"⦦",DZcy:"Џ",dzcy:"џ",dzigrarr:"⟿",Eacute:"É",eacute:"é",easter:"⩮",Ecaron:"Ě",ecaron:"ě",ecir:"≖",Ecirc:"Ê",ecirc:"ê",ecolon:"≕",Ecy:"Э",ecy:"э",eDDot:"⩷",Edot:"Ė",eDot:"≑",edot:"ė",ee:"ⅇ",efDot:"≒",Efr:"𝔈",efr:"𝔢",eg:"⪚",Egrave:"È",egrave:"è",egs:"⪖",egsdot:"⪘",el:"⪙",Element:"∈",elinters:"⏧",ell:"ℓ",els:"⪕",elsdot:"⪗",Emacr:"Ē",emacr:"ē",empty:"∅",emptyset:"∅",EmptySmallSquare:"◻",emptyv:"∅",EmptyVerySmallSquare:"▫",emsp:" ",emsp13:" ",emsp14:" ",ENG:"Ŋ",eng:"ŋ",ensp:" ",Eogon:"Ę",eogon:"ę",Eopf:"𝔼",eopf:"𝕖",epar:"⋕",eparsl:"⧣",eplus:"⩱",epsi:"ε",Epsilon:"Ε",epsilon:"ε",epsiv:"ϵ",eqcirc:"≖",eqcolon:"≕",eqsim:"≂",eqslantgtr:"⪖",eqslantless:"⪕",Equal:"⩵",equals:"=",EqualTilde:"≂",equest:"≟",Equilibrium:"⇌",equiv:"≡",equivDD:"⩸",eqvparsl:"⧥",erarr:"⥱",erDot:"≓",Escr:"ℰ",escr:"ℯ",esdot:"≐",Esim:"⩳",esim:"≂",Eta:"Η",eta:"η",ETH:"Ð",eth:"ð",Euml:"Ë",euml:"ë",euro:"€",excl:"!",exist:"∃",Exists:"∃",expectation:"ℰ",ExponentialE:"ⅇ",exponentiale:"ⅇ",fallingdotseq:"≒",Fcy:"Ф",fcy:"ф",female:"♀",ffilig:"ﬃ",fflig:"ﬀ",ffllig:"ﬄ",Ffr:"𝔉",ffr:"𝔣",filig:"ﬁ",FilledSmallSquare:"◼",FilledVerySmallSquare:"▪",fjlig:"fj",flat:"♭",fllig:"ﬂ",fltns:"▱",fnof:"ƒ",Fopf:"𝔽",fopf:"𝕗",ForAll:"∀",forall:"∀",fork:"⋔",forkv:"⫙",Fouriertrf:"ℱ",fpartint:"⨍",frac12:"½",frac13:"⅓",frac14:"¼",frac15:"⅕",frac16:"⅙",frac18:"⅛",frac23:"⅔",frac25:"⅖",frac34:"¾",frac35:"⅗",frac38:"⅜",frac45:"⅘",frac56:"⅚",frac58:"⅝",frac78:"⅞",frasl:"⁄",frown:"⌢",Fscr:"ℱ",fscr:"𝒻",gacute:"ǵ",Gamma:"Γ",gamma:"γ",Gammad:"Ϝ",gammad:"ϝ",gap:"⪆",Gbreve:"Ğ",gbreve:"ğ",Gcedil:"Ģ",Gcirc:"Ĝ",gcirc:"ĝ",Gcy:"Г",gcy:"г",Gdot:"Ġ",gdot:"ġ",gE:"≧",ge:"≥",gEl:"⪌",gel:"⋛",geq:"≥",geqq:"≧",geqslant:"⩾",ges:"⩾",gescc:"⪩",gesdot:"⪀",gesdoto:"⪂",gesdotol:"⪄",gesl:"⋛︀",gesles:"⪔",Gfr:"𝔊",gfr:"𝔤",Gg:"⋙",gg:"≫",ggg:"⋙",gimel:"ℷ",GJcy:"Ѓ",gjcy:"ѓ",gl:"≷",gla:"⪥",glE:"⪒",glj:"⪤",gnap:"⪊",gnapprox:"⪊",gnE:"≩",gne:"⪈",gneq:"⪈",gneqq:"≩",gnsim:"⋧",Gopf:"𝔾",gopf:"𝕘",grave:"`",GreaterEqual:"≥",GreaterEqualLess:"⋛",GreaterFullEqual:"≧",GreaterGreater:"⪢",GreaterLess:"≷",GreaterSlantEqual:"⩾",GreaterTilde:"≳",Gscr:"𝒢",gscr:"ℊ",gsim:"≳",gsime:"⪎",gsiml:"⪐",Gt:"≫",GT:">",gt:">",gtcc:"⪧",gtcir:"⩺",gtdot:"⋗",gtlPar:"⦕",gtquest:"⩼",gtrapprox:"⪆",gtrarr:"⥸",gtrdot:"⋗",gtreqless:"⋛",gtreqqless:"⪌",gtrless:"≷",gtrsim:"≳",gvertneqq:"≩︀",gvnE:"≩︀",Hacek:"ˇ",hairsp:" ",half:"½",hamilt:"ℋ",HARDcy:"Ъ",hardcy:"ъ",hArr:"⇔",harr:"↔",harrcir:"⥈",harrw:"↭",Hat:"^",hbar:"ℏ",Hcirc:"Ĥ",hcirc:"ĥ",hearts:"♥",heartsuit:"♥",hellip:"…",hercon:"⊹",Hfr:"ℌ",hfr:"𝔥",HilbertSpace:"ℋ",hksearow:"⤥",hkswarow:"⤦",hoarr:"⇿",homtht:"∻",hookleftarrow:"↩",hookrightarrow:"↪",Hopf:"ℍ",hopf:"𝕙",horbar:"―",HorizontalLine:"─",Hscr:"ℋ",hscr:"𝒽",hslash:"ℏ",Hstrok:"Ħ",hstrok:"ħ",HumpDownHump:"≎",HumpEqual:"≏",hybull:"⁃",hyphen:"‐",Iacute:"Í",iacute:"í",ic:"⁣",Icirc:"Î",icirc:"î",Icy:"И",icy:"и",Idot:"İ",IEcy:"Е",iecy:"е",iexcl:"¡",iff:"⇔",Ifr:"ℑ",ifr:"𝔦",Igrave:"Ì",igrave:"ì",ii:"ⅈ",iiiint:"⨌",iiint:"∭",iinfin:"⧜",iiota:"℩",IJlig:"Ĳ",ijlig:"ĳ",Im:"ℑ",Imacr:"Ī",imacr:"ī",image:"ℑ",ImaginaryI:"ⅈ",imagline:"ℐ",imagpart:"ℑ",imath:"ı",imof:"⊷",imped:"Ƶ",Implies:"⇒",in:"∈",incare:"℅",infin:"∞",infintie:"⧝",inodot:"ı",Int:"∬",int:"∫",intcal:"⊺",integers:"ℤ",Integral:"∫",intercal:"⊺",Intersection:"⋂",intlarhk:"⨗",intprod:"⨼",InvisibleComma:"⁣",InvisibleTimes:"⁢",IOcy:"Ё",iocy:"ё",Iogon:"Į",iogon:"į",Iopf:"𝕀",iopf:"𝕚",Iota:"Ι",iota:"ι",iprod:"⨼",iquest:"¿",Iscr:"ℐ",iscr:"𝒾",isin:"∈",isindot:"⋵",isinE:"⋹",isins:"⋴",isinsv:"⋳",isinv:"∈",it:"⁢",Itilde:"Ĩ",itilde:"ĩ",Iukcy:"І",iukcy:"і",Iuml:"Ï",iuml:"ï",Jcirc:"Ĵ",jcirc:"ĵ",Jcy:"Й",jcy:"й",Jfr:"𝔍",jfr:"𝔧",jmath:"ȷ",Jopf:"𝕁",jopf:"𝕛",Jscr:"𝒥",jscr:"𝒿",Jsercy:"Ј",jsercy:"ј",Jukcy:"Є",jukcy:"є",Kappa:"Κ",kappa:"κ",kappav:"ϰ",Kcedil:"Ķ",kcedil:"ķ",Kcy:"К",kcy:"к",Kfr:"𝔎",kfr:"𝔨",kgreen:"ĸ",KHcy:"Х",khcy:"х",KJcy:"Ќ",kjcy:"ќ",Kopf:"𝕂",kopf:"𝕜",Kscr:"𝒦",kscr:"𝓀",lAarr:"⇚",Lacute:"Ĺ",lacute:"ĺ",laemptyv:"⦴",lagran:"ℒ",Lambda:"Λ",lambda:"λ",Lang:"⟪",lang:"⟨",langd:"⦑",langle:"⟨",lap:"⪅",Laplacetrf:"ℒ",laquo:"«",Larr:"↞",lArr:"⇐",larr:"←",larrb:"⇤",larrbfs:"⤟",larrfs:"⤝",larrhk:"↩",larrlp:"↫",larrpl:"⤹",larrsim:"⥳",larrtl:"↢",lat:"⪫",lAtail:"⤛",latail:"⤙",late:"⪭",lates:"⪭︀",lBarr:"⤎",lbarr:"⤌",lbbrk:"❲",lbrace:"{",lbrack:"[",lbrke:"⦋",lbrksld:"⦏",lbrkslu:"⦍",Lcaron:"Ľ",lcaron:"ľ",Lcedil:"Ļ",lcedil:"ļ",lceil:"⌈",lcub:"{",Lcy:"Л",lcy:"л",ldca:"⤶",ldquo:"“",ldquor:"„",ldrdhar:"⥧",ldrushar:"⥋",ldsh:"↲",lE:"≦",le:"≤",LeftAngleBracket:"⟨",LeftArrow:"←",Leftarrow:"⇐",leftarrow:"←",LeftArrowBar:"⇤",LeftArrowRightArrow:"⇆",leftarrowtail:"↢",LeftCeiling:"⌈",LeftDoubleBracket:"⟦",LeftDownTeeVector:"⥡",LeftDownVector:"⇃",LeftDownVectorBar:"⥙",LeftFloor:"⌊",leftharpoondown:"↽",leftharpoonup:"↼",leftleftarrows:"⇇",LeftRightArrow:"↔",Leftrightarrow:"⇔",leftrightarrow:"↔",leftrightarrows:"⇆",leftrightharpoons:"⇋",leftrightsquigarrow:"↭",LeftRightVector:"⥎",LeftTee:"⊣",LeftTeeArrow:"↤",LeftTeeVector:"⥚",leftthreetimes:"⋋",LeftTriangle:"⊲",LeftTriangleBar:"⧏",LeftTriangleEqual:"⊴",LeftUpDownVector:"⥑",LeftUpTeeVector:"⥠",LeftUpVector:"↿",LeftUpVectorBar:"⥘",LeftVector:"↼",LeftVectorBar:"⥒",lEg:"⪋",leg:"⋚",leq:"≤",leqq:"≦",leqslant:"⩽",les:"⩽",lescc:"⪨",lesdot:"⩿",lesdoto:"⪁",lesdotor:"⪃",lesg:"⋚︀",lesges:"⪓",lessapprox:"⪅",lessdot:"⋖",lesseqgtr:"⋚",lesseqqgtr:"⪋",LessEqualGreater:"⋚",LessFullEqual:"≦",LessGreater:"≶",lessgtr:"≶",LessLess:"⪡",lesssim:"≲",LessSlantEqual:"⩽",LessTilde:"≲",lfisht:"⥼",lfloor:"⌊",Lfr:"𝔏",lfr:"𝔩",lg:"≶",lgE:"⪑",lHar:"⥢",lhard:"↽",lharu:"↼",lharul:"⥪",lhblk:"▄",LJcy:"Љ",ljcy:"љ",Ll:"⋘",ll:"≪",llarr:"⇇",llcorner:"⌞",Lleftarrow:"⇚",llhard:"⥫",lltri:"◺",Lmidot:"Ŀ",lmidot:"ŀ",lmoust:"⎰",lmoustache:"⎰",lnap:"⪉",lnapprox:"⪉",lnE:"≨",lne:"⪇",lneq:"⪇",lneqq:"≨",lnsim:"⋦",loang:"⟬",loarr:"⇽",lobrk:"⟦",LongLeftArrow:"⟵",Longleftarrow:"⟸",longleftarrow:"⟵",LongLeftRightArrow:"⟷",Longleftrightarrow:"⟺",longleftrightarrow:"⟷",longmapsto:"⟼",LongRightArrow:"⟶",Longrightarrow:"⟹",longrightarrow:"⟶",looparrowleft:"↫",looparrowright:"↬",lopar:"⦅",Lopf:"𝕃",lopf:"𝕝",loplus:"⨭",lotimes:"⨴",lowast:"∗",lowbar:"_",LowerLeftArrow:"↙",LowerRightArrow:"↘",loz:"◊",lozenge:"◊",lozf:"⧫",lpar:"(",lparlt:"⦓",lrarr:"⇆",lrcorner:"⌟",lrhar:"⇋",lrhard:"⥭",lrm:"‎",lrtri:"⊿",lsaquo:"‹",Lscr:"ℒ",lscr:"𝓁",Lsh:"↰",lsh:"↰",lsim:"≲",lsime:"⪍",lsimg:"⪏",lsqb:"[",lsquo:"‘",lsquor:"‚",Lstrok:"Ł",lstrok:"ł",Lt:"≪",LT:"<",lt:"<",ltcc:"⪦",ltcir:"⩹",ltdot:"⋖",lthree:"⋋",ltimes:"⋉",ltlarr:"⥶",ltquest:"⩻",ltri:"◃",ltrie:"⊴",ltrif:"◂",ltrPar:"⦖",lurdshar:"⥊",luruhar:"⥦",lvertneqq:"≨︀",lvnE:"≨︀",macr:"¯",male:"♂",malt:"✠",maltese:"✠",Map:"⤅",map:"↦",mapsto:"↦",mapstodown:"↧",mapstoleft:"↤",mapstoup:"↥",marker:"▮",mcomma:"⨩",Mcy:"М",mcy:"м",mdash:"—",mDDot:"∺",measuredangle:"∡",MediumSpace:" ",Mellintrf:"ℳ",Mfr:"𝔐",mfr:"𝔪",mho:"℧",micro:"µ",mid:"∣",midast:"*",midcir:"⫰",middot:"·",minus:"−",minusb:"⊟",minusd:"∸",minusdu:"⨪",MinusPlus:"∓",mlcp:"⫛",mldr:"…",mnplus:"∓",models:"⊧",Mopf:"𝕄",mopf:"𝕞",mp:"∓",Mscr:"ℳ",mscr:"𝓂",mstpos:"∾",Mu:"Μ",mu:"μ",multimap:"⊸",mumap:"⊸",nabla:"∇",Nacute:"Ń",nacute:"ń",nang:"∠⃒",nap:"≉",napE:"⩰̸",napid:"≋̸",napos:"ŉ",napprox:"≉",natur:"♮",natural:"♮",naturals:"ℕ",nbsp:" ",nbump:"≎̸",nbumpe:"≏̸",ncap:"⩃",Ncaron:"Ň",ncaron:"ň",Ncedil:"Ņ",ncedil:"ņ",ncong:"≇",ncongdot:"⩭̸",ncup:"⩂",Ncy:"Н",ncy:"н",ndash:"–",ne:"≠",nearhk:"⤤",neArr:"⇗",nearr:"↗",nearrow:"↗",nedot:"≐̸",NegativeMediumSpace:"​",NegativeThickSpace:"​",NegativeThinSpace:"​",NegativeVeryThinSpace:"​",nequiv:"≢",nesear:"⤨",nesim:"≂̸",NestedGreaterGreater:"≫",NestedLessLess:"≪",NewLine:"\n",nexist:"∄",nexists:"∄",Nfr:"𝔑",nfr:"𝔫",ngE:"≧̸",nge:"≱",ngeq:"≱",ngeqq:"≧̸",ngeqslant:"⩾̸",nges:"⩾̸",nGg:"⋙̸",ngsim:"≵",nGt:"≫⃒",ngt:"≯",ngtr:"≯",nGtv:"≫̸",nhArr:"⇎",nharr:"↮",nhpar:"⫲",ni:"∋",nis:"⋼",nisd:"⋺",niv:"∋",NJcy:"Њ",njcy:"њ",nlArr:"⇍",nlarr:"↚",nldr:"‥",nlE:"≦̸",nle:"≰",nLeftarrow:"⇍",nleftarrow:"↚",nLeftrightarrow:"⇎",nleftrightarrow:"↮",nleq:"≰",nleqq:"≦̸",nleqslant:"⩽̸",nles:"⩽̸",nless:"≮",nLl:"⋘̸",nlsim:"≴",nLt:"≪⃒",nlt:"≮",nltri:"⋪",nltrie:"⋬",nLtv:"≪̸",nmid:"∤",NoBreak:"⁠",NonBreakingSpace:" ",Nopf:"ℕ",nopf:"𝕟",Not:"⫬",not:"¬",NotCongruent:"≢",NotCupCap:"≭",NotDoubleVerticalBar:"∦",NotElement:"∉",NotEqual:"≠",NotEqualTilde:"≂̸",NotExists:"∄",NotGreater:"≯",NotGreaterEqual:"≱",NotGreaterFullEqual:"≧̸",NotGreaterGreater:"≫̸",NotGreaterLess:"≹",NotGreaterSlantEqual:"⩾̸",NotGreaterTilde:"≵",NotHumpDownHump:"≎̸",NotHumpEqual:"≏̸",notin:"∉",notindot:"⋵̸",notinE:"⋹̸",notinva:"∉",notinvb:"⋷",notinvc:"⋶",NotLeftTriangle:"⋪",NotLeftTriangleBar:"⧏̸",NotLeftTriangleEqual:"⋬",NotLess:"≮",NotLessEqual:"≰",NotLessGreater:"≸",NotLessLess:"≪̸",NotLessSlantEqual:"⩽̸",NotLessTilde:"≴",NotNestedGreaterGreater:"⪢̸",NotNestedLessLess:"⪡̸",notni:"∌",notniva:"∌",notnivb:"⋾",notnivc:"⋽",NotPrecedes:"⊀",NotPrecedesEqual:"⪯̸",NotPrecedesSlantEqual:"⋠",NotReverseElement:"∌",NotRightTriangle:"⋫",NotRightTriangleBar:"⧐̸",NotRightTriangleEqual:"⋭",NotSquareSubset:"⊏̸",NotSquareSubsetEqual:"⋢",NotSquareSuperset:"⊐̸",NotSquareSupersetEqual:"⋣",NotSubset:"⊂⃒",NotSubsetEqual:"⊈",NotSucceeds:"⊁",NotSucceedsEqual:"⪰̸",NotSucceedsSlantEqual:"⋡",NotSucceedsTilde:"≿̸",NotSuperset:"⊃⃒",NotSupersetEqual:"⊉",NotTilde:"≁",NotTildeEqual:"≄",NotTildeFullEqual:"≇",NotTildeTilde:"≉",NotVerticalBar:"∤",npar:"∦",nparallel:"∦",nparsl:"⫽⃥",npart:"∂̸",npolint:"⨔",npr:"⊀",nprcue:"⋠",npre:"⪯̸",nprec:"⊀",npreceq:"⪯̸",nrArr:"⇏",nrarr:"↛",nrarrc:"⤳̸",nrarrw:"↝̸",nRightarrow:"⇏",nrightarrow:"↛",nrtri:"⋫",nrtrie:"⋭",nsc:"⊁",nsccue:"⋡",nsce:"⪰̸",Nscr:"𝒩",nscr:"𝓃",nshortmid:"∤",nshortparallel:"∦",nsim:"≁",nsime:"≄",nsimeq:"≄",nsmid:"∤",nspar:"∦",nsqsube:"⋢",nsqsupe:"⋣",nsub:"⊄",nsubE:"⫅̸",nsube:"⊈",nsubset:"⊂⃒",nsubseteq:"⊈",nsubseteqq:"⫅̸",nsucc:"⊁",nsucceq:"⪰̸",nsup:"⊅",nsupE:"⫆̸",nsupe:"⊉",nsupset:"⊃⃒",nsupseteq:"⊉",nsupseteqq:"⫆̸",ntgl:"≹",Ntilde:"Ñ",ntilde:"ñ",ntlg:"≸",ntriangleleft:"⋪",ntrianglelefteq:"⋬",ntriangleright:"⋫",ntrianglerighteq:"⋭",Nu:"Ν",nu:"ν",num:"#",numero:"№",numsp:" ",nvap:"≍⃒",nVDash:"⊯",nVdash:"⊮",nvDash:"⊭",nvdash:"⊬",nvge:"≥⃒",nvgt:">⃒",nvHarr:"⤄",nvinfin:"⧞",nvlArr:"⤂",nvle:"≤⃒",nvlt:"<⃒",nvltrie:"⊴⃒",nvrArr:"⤃",nvrtrie:"⊵⃒",nvsim:"∼⃒",nwarhk:"⤣",nwArr:"⇖",nwarr:"↖",nwarrow:"↖",nwnear:"⤧",Oacute:"Ó",oacute:"ó",oast:"⊛",ocir:"⊚",Ocirc:"Ô",ocirc:"ô",Ocy:"О",ocy:"о",odash:"⊝",Odblac:"Ő",odblac:"ő",odiv:"⨸",odot:"⊙",odsold:"⦼",OElig:"Œ",oelig:"œ",ofcir:"⦿",Ofr:"𝔒",ofr:"𝔬",ogon:"˛",Ograve:"Ò",ograve:"ò",ogt:"⧁",ohbar:"⦵",ohm:"Ω",oint:"∮",olarr:"↺",olcir:"⦾",olcross:"⦻",oline:"‾",olt:"⧀",Omacr:"Ō",omacr:"ō",Omega:"Ω",omega:"ω",Omicron:"Ο",omicron:"ο",omid:"⦶",ominus:"⊖",Oopf:"𝕆",oopf:"𝕠",opar:"⦷",OpenCurlyDoubleQuote:"“",OpenCurlyQuote:"‘",operp:"⦹",oplus:"⊕",Or:"⩔",or:"∨",orarr:"↻",ord:"⩝",order:"ℴ",orderof:"ℴ",ordf:"ª",ordm:"º",origof:"⊶",oror:"⩖",orslope:"⩗",orv:"⩛",oS:"Ⓢ",Oscr:"𝒪",oscr:"ℴ",Oslash:"Ø",oslash:"ø",osol:"⊘",Otilde:"Õ",otilde:"õ",Otimes:"⨷",otimes:"⊗",otimesas:"⨶",Ouml:"Ö",ouml:"ö",ovbar:"⌽",OverBar:"‾",OverBrace:"⏞",OverBracket:"⎴",OverParenthesis:"⏜",par:"∥",para:"¶",parallel:"∥",parsim:"⫳",parsl:"⫽",part:"∂",PartialD:"∂",Pcy:"П",pcy:"п",percnt:"%",period:".",permil:"‰",perp:"⊥",pertenk:"‱",Pfr:"𝔓",pfr:"𝔭",Phi:"Φ",phi:"φ",phiv:"ϕ",phmmat:"ℳ",phone:"☎",Pi:"Π",pi:"π",pitchfork:"⋔",piv:"ϖ",planck:"ℏ",planckh:"ℎ",plankv:"ℏ",plus:"+",plusacir:"⨣",plusb:"⊞",pluscir:"⨢",plusdo:"∔",plusdu:"⨥",pluse:"⩲",PlusMinus:"±",plusmn:"±",plussim:"⨦",plustwo:"⨧",pm:"±",Poincareplane:"ℌ",pointint:"⨕",Popf:"ℙ",popf:"𝕡",pound:"£",Pr:"⪻",pr:"≺",prap:"⪷",prcue:"≼",prE:"⪳",pre:"⪯",prec:"≺",precapprox:"⪷",preccurlyeq:"≼",Precedes:"≺",PrecedesEqual:"⪯",PrecedesSlantEqual:"≼",PrecedesTilde:"≾",preceq:"⪯",precnapprox:"⪹",precneqq:"⪵",precnsim:"⋨",precsim:"≾",Prime:"″",prime:"′",primes:"ℙ",prnap:"⪹",prnE:"⪵",prnsim:"⋨",prod:"∏",Product:"∏",profalar:"⌮",profline:"⌒",profsurf:"⌓",prop:"∝",Proportion:"∷",Proportional:"∝",propto:"∝",prsim:"≾",prurel:"⊰",Pscr:"𝒫",pscr:"𝓅",Psi:"Ψ",psi:"ψ",puncsp:" ",Qfr:"𝔔",qfr:"𝔮",qint:"⨌",Qopf:"ℚ",qopf:"𝕢",qprime:"⁗",Qscr:"𝒬",qscr:"𝓆",quaternions:"ℍ",quatint:"⨖",quest:"?",questeq:"≟",QUOT:'"',quot:'"',rAarr:"⇛",race:"∽̱",Racute:"Ŕ",racute:"ŕ",radic:"√",raemptyv:"⦳",Rang:"⟫",rang:"⟩",rangd:"⦒",range:"⦥",rangle:"⟩",raquo:"»",Rarr:"↠",rArr:"⇒",rarr:"→",rarrap:"⥵",rarrb:"⇥",rarrbfs:"⤠",rarrc:"⤳",rarrfs:"⤞",rarrhk:"↪",rarrlp:"↬",rarrpl:"⥅",rarrsim:"⥴",Rarrtl:"⤖",rarrtl:"↣",rarrw:"↝",rAtail:"⤜",ratail:"⤚",ratio:"∶",rationals:"ℚ",RBarr:"⤐",rBarr:"⤏",rbarr:"⤍",rbbrk:"❳",rbrace:"}",rbrack:"]",rbrke:"⦌",rbrksld:"⦎",rbrkslu:"⦐",Rcaron:"Ř",rcaron:"ř",Rcedil:"Ŗ",rcedil:"ŗ",rceil:"⌉",rcub:"}",Rcy:"Р",rcy:"р",rdca:"⤷",rdldhar:"⥩",rdquo:"”",rdquor:"”",rdsh:"↳",Re:"ℜ",real:"ℜ",realine:"ℛ",realpart:"ℜ",reals:"ℝ",rect:"▭",REG:"®",reg:"®",ReverseElement:"∋",ReverseEquilibrium:"⇋",ReverseUpEquilibrium:"⥯",rfisht:"⥽",rfloor:"⌋",Rfr:"ℜ",rfr:"𝔯",rHar:"⥤",rhard:"⇁",rharu:"⇀",rharul:"⥬",Rho:"Ρ",rho:"ρ",rhov:"ϱ",RightAngleBracket:"⟩",RightArrow:"→",Rightarrow:"⇒",rightarrow:"→",RightArrowBar:"⇥",RightArrowLeftArrow:"⇄",rightarrowtail:"↣",RightCeiling:"⌉",RightDoubleBracket:"⟧",RightDownTeeVector:"⥝",RightDownVector:"⇂",RightDownVectorBar:"⥕",RightFloor:"⌋",rightharpoondown:"⇁",rightharpoonup:"⇀",rightleftarrows:"⇄",rightleftharpoons:"⇌",rightrightarrows:"⇉",rightsquigarrow:"↝",RightTee:"⊢",RightTeeArrow:"↦",RightTeeVector:"⥛",rightthreetimes:"⋌",RightTriangle:"⊳",RightTriangleBar:"⧐",RightTriangleEqual:"⊵",RightUpDownVector:"⥏",RightUpTeeVector:"⥜",RightUpVector:"↾",RightUpVectorBar:"⥔",RightVector:"⇀",RightVectorBar:"⥓",ring:"˚",risingdotseq:"≓",rlarr:"⇄",rlhar:"⇌",rlm:"‏",rmoust:"⎱",rmoustache:"⎱",rnmid:"⫮",roang:"⟭",roarr:"⇾",robrk:"⟧",ropar:"⦆",Ropf:"ℝ",ropf:"𝕣",roplus:"⨮",rotimes:"⨵",RoundImplies:"⥰",rpar:")",rpargt:"⦔",rppolint:"⨒",rrarr:"⇉",Rrightarrow:"⇛",rsaquo:"›",Rscr:"ℛ",rscr:"𝓇",Rsh:"↱",rsh:"↱",rsqb:"]",rsquo:"’",rsquor:"’",rthree:"⋌",rtimes:"⋊",rtri:"▹",rtrie:"⊵",rtrif:"▸",rtriltri:"⧎",RuleDelayed:"⧴",ruluhar:"⥨",rx:"℞",Sacute:"Ś",sacute:"ś",sbquo:"‚",Sc:"⪼",sc:"≻",scap:"⪸",Scaron:"Š",scaron:"š",sccue:"≽",scE:"⪴",sce:"⪰",Scedil:"Ş",scedil:"ş",Scirc:"Ŝ",scirc:"ŝ",scnap:"⪺",scnE:"⪶",scnsim:"⋩",scpolint:"⨓",scsim:"≿",Scy:"С",scy:"с",sdot:"⋅",sdotb:"⊡",sdote:"⩦",searhk:"⤥",seArr:"⇘",searr:"↘",searrow:"↘",sect:"§",semi:";",seswar:"⤩",setminus:"∖",setmn:"∖",sext:"✶",Sfr:"𝔖",sfr:"𝔰",sfrown:"⌢",sharp:"♯",SHCHcy:"Щ",shchcy:"щ",SHcy:"Ш",shcy:"ш",ShortDownArrow:"↓",ShortLeftArrow:"←",shortmid:"∣",shortparallel:"∥",ShortRightArrow:"→",ShortUpArrow:"↑",shy:"­",Sigma:"Σ",sigma:"σ",sigmaf:"ς",sigmav:"ς",sim:"∼",simdot:"⩪",sime:"≃",simeq:"≃",simg:"⪞",simgE:"⪠",siml:"⪝",simlE:"⪟",simne:"≆",simplus:"⨤",simrarr:"⥲",slarr:"←",SmallCircle:"∘",smallsetminus:"∖",smashp:"⨳",smeparsl:"⧤",smid:"∣",smile:"⌣",smt:"⪪",smte:"⪬",smtes:"⪬︀",SOFTcy:"Ь",softcy:"ь",sol:"/",solb:"⧄",solbar:"⌿",Sopf:"𝕊",sopf:"𝕤",spades:"♠",spadesuit:"♠",spar:"∥",sqcap:"⊓",sqcaps:"⊓︀",sqcup:"⊔",sqcups:"⊔︀",Sqrt:"√",sqsub:"⊏",sqsube:"⊑",sqsubset:"⊏",sqsubseteq:"⊑",sqsup:"⊐",sqsupe:"⊒",sqsupset:"⊐",sqsupseteq:"⊒",squ:"□",Square:"□",square:"□",SquareIntersection:"⊓",SquareSubset:"⊏",SquareSubsetEqual:"⊑",SquareSuperset:"⊐",SquareSupersetEqual:"⊒",SquareUnion:"⊔",squarf:"▪",squf:"▪",srarr:"→",Sscr:"𝒮",sscr:"𝓈",ssetmn:"∖",ssmile:"⌣",sstarf:"⋆",Star:"⋆",star:"☆",starf:"★",straightepsilon:"ϵ",straightphi:"ϕ",strns:"¯",Sub:"⋐",sub:"⊂",subdot:"⪽",subE:"⫅",sube:"⊆",subedot:"⫃",submult:"⫁",subnE:"⫋",subne:"⊊",subplus:"⪿",subrarr:"⥹",Subset:"⋐",subset:"⊂",subseteq:"⊆",subseteqq:"⫅",SubsetEqual:"⊆",subsetneq:"⊊",subsetneqq:"⫋",subsim:"⫇",subsub:"⫕",subsup:"⫓",succ:"≻",succapprox:"⪸",succcurlyeq:"≽",Succeeds:"≻",SucceedsEqual:"⪰",SucceedsSlantEqual:"≽",SucceedsTilde:"≿",succeq:"⪰",succnapprox:"⪺",succneqq:"⪶",succnsim:"⋩",succsim:"≿",SuchThat:"∋",Sum:"∑",sum:"∑",sung:"♪",Sup:"⋑",sup:"⊃",sup1:"¹",sup2:"²",sup3:"³",supdot:"⪾",supdsub:"⫘",supE:"⫆",supe:"⊇",supedot:"⫄",Superset:"⊃",SupersetEqual:"⊇",suphsol:"⟉",suphsub:"⫗",suplarr:"⥻",supmult:"⫂",supnE:"⫌",supne:"⊋",supplus:"⫀",Supset:"⋑",supset:"⊃",supseteq:"⊇",supseteqq:"⫆",supsetneq:"⊋",supsetneqq:"⫌",supsim:"⫈",supsub:"⫔",supsup:"⫖",swarhk:"⤦",swArr:"⇙",swarr:"↙",swarrow:"↙",swnwar:"⤪",szlig:"ß",Tab:"\t",target:"⌖",Tau:"Τ",tau:"τ",tbrk:"⎴",Tcaron:"Ť",tcaron:"ť",Tcedil:"Ţ",tcedil:"ţ",Tcy:"Т",tcy:"т",tdot:"⃛",telrec:"⌕",Tfr:"𝔗",tfr:"𝔱",there4:"∴",Therefore:"∴",therefore:"∴",Theta:"Θ",theta:"θ",thetasym:"ϑ",thetav:"ϑ",thickapprox:"≈",thicksim:"∼",ThickSpace:"  ",thinsp:" ",ThinSpace:" ",thkap:"≈",thksim:"∼",THORN:"Þ",thorn:"þ",Tilde:"∼",tilde:"˜",TildeEqual:"≃",TildeFullEqual:"≅",TildeTilde:"≈",times:"×",timesb:"⊠",timesbar:"⨱",timesd:"⨰",tint:"∭",toea:"⤨",top:"⊤",topbot:"⌶",topcir:"⫱",Topf:"𝕋",topf:"𝕥",topfork:"⫚",tosa:"⤩",tprime:"‴",TRADE:"™",trade:"™",triangle:"▵",triangledown:"▿",triangleleft:"◃",trianglelefteq:"⊴",triangleq:"≜",triangleright:"▹",trianglerighteq:"⊵",tridot:"◬",trie:"≜",triminus:"⨺",TripleDot:"⃛",triplus:"⨹",trisb:"⧍",tritime:"⨻",trpezium:"⏢",Tscr:"𝒯",tscr:"𝓉",TScy:"Ц",tscy:"ц",TSHcy:"Ћ",tshcy:"ћ",Tstrok:"Ŧ",tstrok:"ŧ",twixt:"≬",twoheadleftarrow:"↞",twoheadrightarrow:"↠",Uacute:"Ú",uacute:"ú",Uarr:"↟",uArr:"⇑",uarr:"↑",Uarrocir:"⥉",Ubrcy:"Ў",ubrcy:"ў",Ubreve:"Ŭ",ubreve:"ŭ",Ucirc:"Û",ucirc:"û",Ucy:"У",ucy:"у",udarr:"⇅",Udblac:"Ű",udblac:"ű",udhar:"⥮",ufisht:"⥾",Ufr:"𝔘",ufr:"𝔲",Ugrave:"Ù",ugrave:"ù",uHar:"⥣",uharl:"↿",uharr:"↾",uhblk:"▀",ulcorn:"⌜",ulcorner:"⌜",ulcrop:"⌏",ultri:"◸",Umacr:"Ū",umacr:"ū",uml:"¨",UnderBar:"_",UnderBrace:"⏟",UnderBracket:"⎵",UnderParenthesis:"⏝",Union:"⋃",UnionPlus:"⊎",Uogon:"Ų",uogon:"ų",Uopf:"𝕌",uopf:"𝕦",UpArrow:"↑",Uparrow:"⇑",uparrow:"↑",UpArrowBar:"⤒",UpArrowDownArrow:"⇅",UpDownArrow:"↕",Updownarrow:"⇕",updownarrow:"↕",UpEquilibrium:"⥮",upharpoonleft:"↿",upharpoonright:"↾",uplus:"⊎",UpperLeftArrow:"↖",UpperRightArrow:"↗",Upsi:"ϒ",upsi:"υ",upsih:"ϒ",Upsilon:"Υ",upsilon:"υ",UpTee:"⊥",UpTeeArrow:"↥",upuparrows:"⇈",urcorn:"⌝",urcorner:"⌝",urcrop:"⌎",Uring:"Ů",uring:"ů",urtri:"◹",Uscr:"𝒰",uscr:"𝓊",utdot:"⋰",Utilde:"Ũ",utilde:"ũ",utri:"▵",utrif:"▴",uuarr:"⇈",Uuml:"Ü",uuml:"ü",uwangle:"⦧",vangrt:"⦜",varepsilon:"ϵ",varkappa:"ϰ",varnothing:"∅",varphi:"ϕ",varpi:"ϖ",varpropto:"∝",vArr:"⇕",varr:"↕",varrho:"ϱ",varsigma:"ς",varsubsetneq:"⊊︀",varsubsetneqq:"⫋︀",varsupsetneq:"⊋︀",varsupsetneqq:"⫌︀",vartheta:"ϑ",vartriangleleft:"⊲",vartriangleright:"⊳",Vbar:"⫫",vBar:"⫨",vBarv:"⫩",Vcy:"В",vcy:"в",VDash:"⊫",Vdash:"⊩",vDash:"⊨",vdash:"⊢",Vdashl:"⫦",Vee:"⋁",vee:"∨",veebar:"⊻",veeeq:"≚",vellip:"⋮",Verbar:"‖",verbar:"|",Vert:"‖",vert:"|",VerticalBar:"∣",VerticalLine:"|",VerticalSeparator:"❘",VerticalTilde:"≀",VeryThinSpace:" ",Vfr:"𝔙",vfr:"𝔳",vltri:"⊲",vnsub:"⊂⃒",vnsup:"⊃⃒",Vopf:"𝕍",vopf:"𝕧",vprop:"∝",vrtri:"⊳",Vscr:"𝒱",vscr:"𝓋",vsubnE:"⫋︀",vsubne:"⊊︀",vsupnE:"⫌︀",vsupne:"⊋︀",Vvdash:"⊪",vzigzag:"⦚",Wcirc:"Ŵ",wcirc:"ŵ",wedbar:"⩟",Wedge:"⋀",wedge:"∧",wedgeq:"≙",weierp:"℘",Wfr:"𝔚",wfr:"𝔴",Wopf:"𝕎",wopf:"𝕨",wp:"℘",wr:"≀",wreath:"≀",Wscr:"𝒲",wscr:"𝓌",xcap:"⋂",xcirc:"◯",xcup:"⋃",xdtri:"▽",Xfr:"𝔛",xfr:"𝔵",xhArr:"⟺",xharr:"⟷",Xi:"Ξ",xi:"ξ",xlArr:"⟸",xlarr:"⟵",xmap:"⟼",xnis:"⋻",xodot:"⨀",Xopf:"𝕏",xopf:"𝕩",xoplus:"⨁",xotime:"⨂",xrArr:"⟹",xrarr:"⟶",Xscr:"𝒳",xscr:"𝓍",xsqcup:"⨆",xuplus:"⨄",xutri:"△",xvee:"⋁",xwedge:"⋀",Yacute:"Ý",yacute:"ý",YAcy:"Я",yacy:"я",Ycirc:"Ŷ",ycirc:"ŷ",Ycy:"Ы",ycy:"ы",yen:"¥",Yfr:"𝔜",yfr:"𝔶",YIcy:"Ї",yicy:"ї",Yopf:"𝕐",yopf:"𝕪",Yscr:"𝒴",yscr:"𝓎",YUcy:"Ю",yucy:"ю",Yuml:"Ÿ",yuml:"ÿ",Zacute:"Ź",zacute:"ź",Zcaron:"Ž",zcaron:"ž",Zcy:"З",zcy:"з",Zdot:"Ż",zdot:"ż",zeetrf:"ℨ",ZeroWidthSpace:"​",Zeta:"Ζ",zeta:"ζ",Zfr:"ℨ",zfr:"𝔷",ZHcy:"Ж",zhcy:"ж",zigrarr:"⇝",Zopf:"ℤ",zopf:"𝕫",Zscr:"𝒵",zscr:"𝓏",zwj:"‍",zwnj:"‌"}),t.entityMap=t.HTML_ENTITIES},8978:(e,t,r)=>{var a=r(4722);t.DOMImplementation=a.DOMImplementation,t.XMLSerializer=a.XMLSerializer,t.DOMParser=r(5752).DOMParser},4466:(e,t,r)=>{var a=r(4582).NAMESPACE,n=/[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,o=new RegExp("[\\-\\.0-9"+n.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"),i=new RegExp("^"+n.source+o.source+"*(?::"+n.source+o.source+"*)?$");function s(e,t){this.message=e,this.locator=t,Error.captureStackTrace&&Error.captureStackTrace(this,s)}function l(){}function c(e,t){return t.lineNumber=e.lineNumber,t.columnNumber=e.columnNumber,t}function u(e,t,r,n,o,i){function s(e,t,a){r.attributeNames.hasOwnProperty(e)&&i.fatalError("Attribute "+e+" redefined"),r.addValue(e,t.replace(/[\t\n\r]/g," ").replace(/&#?\w+;/g,o),a)}for(var l,c=++t,u=0;;){var h=e.charAt(c);switch(h){case"=":if(1===u)l=e.slice(t,c),u=3;else{if(2!==u)throw new Error("attribute equal must after attrName");u=3}break;case"'":case'"':if(3===u||1===u){if(1===u&&(i.warning('attribute value must after "="'),l=e.slice(t,c)),t=c+1,!((c=e.indexOf(h,t))>0))throw new Error("attribute value no end '"+h+"' match");s(l,d=e.slice(t,c),t-1),u=5}else{if(4!=u)throw new Error('attribute value must after "="');s(l,d=e.slice(t,c),t),i.warning('attribute "'+l+'" missed start quot('+h+")!!"),t=c+1,u=5}break;case"/":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:u=7,r.closed=!0;case 4:case 1:break;case 2:r.closed=!0;break;default:throw new Error("attribute invalid close char('/')")}break;case"":return i.error("unexpected end of input"),0==u&&r.setTagName(e.slice(t,c)),c;case">":switch(u){case 0:r.setTagName(e.slice(t,c));case 5:case 6:case 7:break;case 4:case 1:"/"===(d=e.slice(t,c)).slice(-1)&&(r.closed=!0,d=d.slice(0,-1));case 2:2===u&&(d=l),4==u?(i.warning('attribute "'+d+'" missed quot(")!'),s(l,d,t)):(a.isHTML(n[""])&&d.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+d+'" missed value!! "'+d+'" instead!!'),s(d,d,t));break;case 3:throw new Error("attribute value missed!!")}return c;case"":h=" ";default:if(h<=" ")switch(u){case 0:r.setTagName(e.slice(t,c)),u=6;break;case 1:l=e.slice(t,c),u=2;break;case 4:var d=e.slice(t,c);i.warning('attribute "'+d+'" missed quot(")!!'),s(l,d,t);case 5:u=6}else switch(u){case 2:r.tagName,a.isHTML(n[""])&&l.match(/^(?:disabled|checked|selected)$/i)||i.warning('attribute "'+l+'" missed value!! "'+l+'" instead2!!'),s(l,l,t),t=c,u=1;break;case 5:i.warning('attribute space is required"'+l+'"!!');case 6:u=1,t=c;break;case 3:u=4,t=c;break;case 7:throw new Error("elements closed character '/' and '>' must be connected to")}}c++}}function h(e,t,r){for(var n=e.tagName,o=null,i=e.length;i--;){var s=e[i],l=s.qName,c=s.value;if((m=l.indexOf(":"))>0)var u=s.prefix=l.slice(0,m),h=l.slice(m+1),d="xmlns"===u&&h;else h=l,u=null,d="xmlns"===l&&"";s.localName=h,!1!==d&&(null==o&&(o={},p(r,r={})),r[d]=o[d]=c,s.uri=a.XMLNS,t.startPrefixMapping(d,c))}for(i=e.length;i--;)(u=(s=e[i]).prefix)&&("xml"===u&&(s.uri=a.XML),"xmlns"!==u&&(s.uri=r[u||""]));var m;(m=n.indexOf(":"))>0?(u=e.prefix=n.slice(0,m),h=e.localName=n.slice(m+1)):(u=null,h=e.localName=n);var f=e.uri=r[u||""];if(t.startElement(f,h,n,e),!e.closed)return e.currentNSMap=r,e.localNSMap=o,!0;if(t.endElement(f,h,n),o)for(u in o)Object.prototype.hasOwnProperty.call(o,u)&&t.endPrefixMapping(u)}function d(e,t,r,a,n){if(/^(?:script|textarea)$/i.test(r)){var o=e.indexOf("</"+r+">",t),i=e.substring(t+1,o);if(/[&<]/.test(i))return/^script$/i.test(r)?(n.characters(i,0,i.length),o):(i=i.replace(/&#?\w+;/g,a),n.characters(i,0,i.length),o)}return t+1}function m(e,t,r,a){var n=a[r];return null==n&&((n=e.lastIndexOf("</"+r+">"))<t&&(n=e.lastIndexOf("</"+r)),a[r]=n),n<t}function p(e,t){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])}function f(e,t,r,a){if("-"===e.charAt(t+2))return"-"===e.charAt(t+3)?(n=e.indexOf("--\x3e",t+4))>t?(r.comment(e,t+4,n-t-4),n+3):(a.error("Unclosed comment"),-1):-1;if("CDATA["==e.substr(t+3,6)){var n=e.indexOf("]]>",t+9);return r.startCDATA(),r.characters(e,t+9,n-t-9),r.endCDATA(),n+3}var o=function(e,t){var r,a=[],n=/'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;for(n.lastIndex=t,n.exec(e);r=n.exec(e);)if(a.push(r),r[1])return a}(e,t),i=o.length;if(i>1&&/!doctype/i.test(o[0][0])){var s=o[1][0],l=!1,c=!1;i>3&&(/^public$/i.test(o[2][0])?(l=o[3][0],c=i>4&&o[4][0]):/^system$/i.test(o[2][0])&&(c=o[3][0]));var u=o[i-1];return r.startDTD(s,l,c),r.endDTD(),u.index+u[0].length}return-1}function x(e,t,r){var a=e.indexOf("?>",t);if(a){var n=e.substring(t,a).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);return n?(n[0].length,r.processingInstruction(n[1],n[2]),a+2):-1}return-1}function g(){this.attributeNames={}}s.prototype=new Error,s.prototype.name=s.name,l.prototype={parse:function(e,t,r){var n=this.domBuilder;n.startDocument(),p(t,t={}),function(e,t,r,n,o){function i(e){var t=e.slice(1,-1);return Object.hasOwnProperty.call(r,t)?r[t]:"#"===t.charAt(0)?function(e){if(e>65535){var t=55296+((e-=65536)>>10),r=56320+(1023&e);return String.fromCharCode(t,r)}return String.fromCharCode(e)}(parseInt(t.substr(1).replace("x","0x"))):(o.error("entity not found:"+e),e)}function l(t){if(t>_){var r=e.substring(_,t).replace(/&#?\w+;/g,i);C&&p(_),n.characters(r,0,t-_),_=t}}function p(t,r){for(;t>=b&&(r=v.exec(e));)w=r.index,b=w+r[0].length,C.lineNumber++;C.columnNumber=t-w+1}for(var w=0,b=0,v=/.*(?:\r\n?|\n)|.*$/g,C=n.locator,A=[{currentNSMap:t}],E={},_=0;;){try{var y=e.indexOf("<",_);if(y<0){if(!e.substr(_).match(/^\s*$/)){var q=n.doc,D=q.createTextNode(e.substr(_));q.appendChild(D),n.currentElement=D}return}switch(y>_&&l(y),e.charAt(y+1)){case"/":var M=e.indexOf(">",y+3),T=e.substring(y+2,M).replace(/[ \t\n\r]+$/g,""),N=A.pop();M<0?(T=e.substring(y+2).replace(/[\s<].*/,""),o.error("end tag name: "+T+" is not complete:"+N.tagName),M=y+1+T.length):T.match(/\s</)&&(T=T.replace(/[\s<].*/,""),o.error("end tag name: "+T+" maybe not complete"),M=y+1+T.length);var O=N.localNSMap,L=N.tagName==T;if(L||N.tagName&&N.tagName.toLowerCase()==T.toLowerCase()){if(n.endElement(N.uri,N.localName,T),O)for(var B in O)Object.prototype.hasOwnProperty.call(O,B)&&n.endPrefixMapping(B);L||o.fatalError("end tag name: "+T+" is not match the current start tagName:"+N.tagName)}else A.push(N);M++;break;case"?":C&&p(y),M=x(e,y,n);break;case"!":C&&p(y),M=f(e,y,n,o);break;default:C&&p(y);var S=new g,F=A[A.length-1].currentNSMap,P=(M=u(e,y,S,F,i,o),S.length);if(!S.closed&&m(e,M,S.tagName,E)&&(S.closed=!0,r.nbsp||o.warning("unclosed xml attribute")),C&&P){for(var k=c(C,{}),R=0;R<P;R++){var I=S[R];p(I.offset),I.locator=c(C,{})}n.locator=k,h(S,n,F)&&A.push(S),n.locator=C}else h(S,n,F)&&A.push(S);a.isHTML(S.uri)&&!S.closed?M=d(e,M,S.tagName,i,n):M++}}catch(e){if(e instanceof s)throw e;o.error("element parse error: "+e),M=-1}M>_?_=M:l(Math.max(y,_)+1)}}(e,t,r,n,this.errorHandler),n.endDocument()}},g.prototype={setTagName:function(e){if(!i.test(e))throw new Error("invalid tagName:"+e);this.tagName=e},addValue:function(e,t,r){if(!i.test(e))throw new Error("invalid attribute:"+e);this.attributeNames[e]=this.length,this[this.length++]={qName:e,value:t,offset:r}},length:0,getLocalName:function(e){return this[e].localName},getLocator:function(e){return this[e].locator},getQName:function(e){return this[e].qName},getURI:function(e){return this[e].uri},getValue:function(e){return this[e].value}},t.XMLReader=l,t.ParseError=s},8917:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;var a=r(6200);Object.defineProperty(t,"InvalidNumberOfChildrenError",{enumerable:!0,get:function(){return a.InvalidNumberOfChildrenError}})},6200:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidNumberOfChildrenError=void 0;class r extends Error{constructor(e,t,r,a="exactly"){super(`${e} tag must have ${a} ${t} children. It's actually ${r}`),this.name="InvalidNumberOfChildrenError"}}t.InvalidNumberOfChildrenError=r},4279:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(828),t),n(r(5975),t),n(r(799),t),n(r(2424),t)},5975:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JoinWithManySeparators=void 0;class r{constructor(e){this._separators=e}static join(e,t){return new r(t)._join(e)}_join(e){return e.reduce(((e,t,r,a)=>e+t+(r===a.length-1?"":this._get(r))),"")}_get(e){return this._separators[e]?this._separators[e]:this._separators.length>0?this._separators[this._separators.length-1]:","}}t.JoinWithManySeparators=r},799:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathMLElementToLaTeXConverter=void 0;const a=r(5443);t.mathMLElementToLaTeXConverter=e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter()},2424:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.normalizeWhiteSpaces=void 0,t.normalizeWhiteSpaces=e=>e.replace(/\s+/g," ")},7192:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BracketWrapper=void 0;const a=r(1855);t.BracketWrapper=class{constructor(){this._open="{",this._close="}"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},5025:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=void 0;const a=r(1855);t.GenericWrapper=class{constructor(e,t){this._open="\\left"+e,this._close="\\right"+t}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}}},828:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericWrapper=t.ParenthesisWrapper=t.BracketWrapper=void 0;var a=r(7192);Object.defineProperty(t,"BracketWrapper",{enumerable:!0,get:function(){return a.BracketWrapper}});var n=r(1168);Object.defineProperty(t,"ParenthesisWrapper",{enumerable:!0,get:function(){return n.ParenthesisWrapper}});var o=r(5025);Object.defineProperty(t,"GenericWrapper",{enumerable:!0,get:function(){return o.GenericWrapper}})},1168:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ParenthesisWrapper=void 0;const a=r(1855);t.ParenthesisWrapper=class{constructor(){this._open="\\left(",this._close="\\right)"}wrap(e){return new a.Wrapper(this._open,this._close).wrap(e)}wrapIfMoreThanOneChar(e){return e.length<=1?e:this.wrap(e)}}},1855:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Wrapper=void 0,t.Wrapper=class{constructor(e,t){this._open=e,this._close=t}wrap(e){return this._open+e+this._close}}},2697:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.VoidMathMLElement=void 0,t.VoidMathMLElement=class{constructor(){this.name="void",this.value="",this.children=[],this.attributes={}}}},4760:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericSpacingWrapper=void 0;const a=r(4279);t.GenericSpacingWrapper=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}},9376:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GenericUnderOver=void 0;const a=r(799),n=r(8917),o=r(472);t.GenericUnderOver=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert(),i=(0,a.mathMLElementToLaTeXConverter)(t[1]).convert();return this._applyCommand(o,i)}_applyCommand(e,t){const r=this._mathmlElement.name.match(/under/)?s.Under:s.Over;return new i(r).apply(e,t)}};class i{constructor(e){this._type=e}apply(e,t){return o.latexAccents.includes(t)?`${t}{${e}}`:`${this._defaultCommand}{${t}}{${e}}`}get _defaultCommand(){return this._type===s.Under?"\\underset":"\\overset"}}var s;!function(e){e[e.Under=0]="Under",e[e.Over=1]="Over"}(s||(s={}))},6959:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=t.GenericUnderOver=t.GenericSpacingWrapper=t.MTr=t.MTable=t.MUnderover=t.MText=t.MMultiscripts=t.MSubsup=t.MSub=t.MSup=t.MPhantom=t.MError=t.MEnclose=t.MAction=t.MRoot=t.MFrac=t.MFenced=t.MSqrt=t.MN=t.MO=t.MI=t.Math=void 0;var a=r(393);Object.defineProperty(t,"Math",{enumerable:!0,get:function(){return a.Math}});var n=r(7037);Object.defineProperty(t,"MI",{enumerable:!0,get:function(){return n.MI}});var o=r(3487);Object.defineProperty(t,"MO",{enumerable:!0,get:function(){return o.MO}});var i=r(4464);Object.defineProperty(t,"MN",{enumerable:!0,get:function(){return i.MN}});var s=r(8686);Object.defineProperty(t,"MSqrt",{enumerable:!0,get:function(){return s.MSqrt}});var l=r(9511);Object.defineProperty(t,"MFenced",{enumerable:!0,get:function(){return l.MFenced}});var c=r(6440);Object.defineProperty(t,"MFrac",{enumerable:!0,get:function(){return c.MFrac}});var u=r(6052);Object.defineProperty(t,"MRoot",{enumerable:!0,get:function(){return u.MRoot}});var h=r(1678);Object.defineProperty(t,"MAction",{enumerable:!0,get:function(){return h.MAction}});var d=r(2631);Object.defineProperty(t,"MEnclose",{enumerable:!0,get:function(){return d.MEnclose}});var m=r(1840);Object.defineProperty(t,"MError",{enumerable:!0,get:function(){return m.MError}});var p=r(7443);Object.defineProperty(t,"MPhantom",{enumerable:!0,get:function(){return p.MPhantom}});var f=r(6926);Object.defineProperty(t,"MSup",{enumerable:!0,get:function(){return f.MSup}});var x=r(2564);Object.defineProperty(t,"MSub",{enumerable:!0,get:function(){return x.MSub}});var g=r(1358);Object.defineProperty(t,"MSubsup",{enumerable:!0,get:function(){return g.MSubsup}});var w=r(8303);Object.defineProperty(t,"MMultiscripts",{enumerable:!0,get:function(){return w.MMultiscripts}});var b=r(3951);Object.defineProperty(t,"MText",{enumerable:!0,get:function(){return b.MText}});var v=r(1222);Object.defineProperty(t,"MUnderover",{enumerable:!0,get:function(){return v.MUnderover}});var C=r(2350);Object.defineProperty(t,"MTable",{enumerable:!0,get:function(){return C.MTable}});var A=r(1586);Object.defineProperty(t,"MTr",{enumerable:!0,get:function(){return A.MTr}});var E=r(4760);Object.defineProperty(t,"GenericSpacingWrapper",{enumerable:!0,get:function(){return E.GenericSpacingWrapper}});var _=r(9376);Object.defineProperty(t,"GenericUnderOver",{enumerable:!0,get:function(){return _.GenericUnderOver}});var y=r(9165);Object.defineProperty(t,"Void",{enumerable:!0,get:function(){return y.Void}})},1678:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAction=void 0;const a=r(799);t.MAction=class{constructor(e){this._mathmlElement=e}convert(){const{children:e}=this._mathmlElement;return this._isToggle()?e.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\Longrightarrow "):(0,a.mathMLElementToLaTeXConverter)(e[0]).convert()}_isToggle(){const{actiontype:e}=this._mathmlElement.attributes;return"toggle"===e||!e}}},393:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Math=void 0;const a=r(799),n=r(2424);t.Math=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return(0,n.normalizeWhiteSpaces)(e)}}},2631:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MEnclose=void 0;const a=r(799);t.MEnclose=class{constructor(e){this._mathmlElement=e}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ");return"actuarial"===this._notation?`\\overline{\\left.${e}\\right|}`:"radical"===this._notation?`\\sqrt{${e}}`:["box","roundedbox","circle"].includes(this._notation)?`\\boxed{${e}}`:"left"===this._notation?`\\left|${e}`:"right"===this._notation?`${e}\\right|`:"top"===this._notation?`\\overline{${e}}`:"bottom"===this._notation?`\\underline{${e}}`:"updiagonalstrike"===this._notation?`\\cancel{${e}}`:"downdiagonalstrike"===this._notation?`\\bcancel{${e}}`:"updiagonalarrow"===this._notation?`\\cancelto{}{${e}}`:["verticalstrike","horizontalstrike"].includes(this._notation)?`\\hcancel{${e}}`:"madruwb"===this._notation?`\\underline{${e}\\right|}`:"phasorangle"===this._notation?`{\\angle \\underline{${e}}}`:`\\overline{\\left.\\right)${e}}`}get _notation(){return this._mathmlElement.attributes.notation||"longdiv"}}},1840:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MError=void 0;const a=r(799);t.MError=class{constructor(e){this._mathmlElement=e}convert(){return`\\color{red}{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},9511:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFenced=void 0;const a=r(799),n=r(4279);t.MFenced=class{constructor(e){this._mathmlElement=e,this._open=this._mathmlElement.attributes.open||"",this._close=this._mathmlElement.attributes.close||"",this._separators=Array.from(this._mathmlElement.attributes.separators||"")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert()));return this._isThereRelativeOfName(this._mathmlElement.children,"mtable")?new i(this._open,this._close).apply(e):new o(this._open,this._close,this._separators).apply(e)}_isThereRelativeOfName(e,t){return e.some((e=>e.name===t||this._isThereRelativeOfName(e.children,t)))}};class o{constructor(e,t,r){this._open=e||"(",this._close=t||")",this._separators=r}apply(e){const t=n.JoinWithManySeparators.join(e,this._separators);return new n.GenericWrapper(this._open,this._close).wrap(t)}}class i{constructor(e,t){this._genericCommand="matrix",this._separators=new s(e,t)}apply(e){const t=this._command,r=`\\begin{${t}}\n${e.join("")}\n\\end{${t}}`;return t===this._genericCommand?this._separators.wrap(r):r}get _command(){return this._separators.areParentheses()?"pmatrix":this._separators.areSquareBrackets()?"bmatrix":this._separators.areBrackets()?"Bmatrix":this._separators.areDivides()?"vmatrix":this._separators.areParallels()?"Vmatrix":this._separators.areNotEqual()?this._genericCommand:"bmatrix"}}class s{constructor(e,t){this._open=e,this._close=t}wrap(e){return new n.GenericWrapper(this._open,this._close).wrap(e)}areParentheses(){return this._compare("(",")")}areSquareBrackets(){return this._compare("[","]")}areBrackets(){return this._compare("{","}")}areDivides(){return this._compare("|","|")}areParallels(){return this._compare("||","||")}areNotEqual(){return this._open!==this._close}_compare(e,t){return this._open===e&&this._close===t}}},6440:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MFrac=void 0;const a=r(8917),n=r(4279);t.MFrac=class{constructor(e){this._mathmlElement=e}convert(){const{children:e,name:t}=this._mathmlElement,r=e.length;if(2!==r)throw new a.InvalidNumberOfChildrenError(t,2,r);const o=(0,n.mathMLElementToLaTeXConverter)(e[0]).convert(),i=(0,n.mathMLElementToLaTeXConverter)(e[1]).convert();return this._isBevelled()?`${this._wrapIfMoreThanOneChar(o)}/${this._wrapIfMoreThanOneChar(i)}`:`\\frac{${o}}{${i}}`}_wrapIfMoreThanOneChar(e){return(new n.ParenthesisWrapper).wrapIfMoreThanOneChar(e)}_isBevelled(){return!!this._mathmlElement.attributes.bevelled}}},7037:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MI=void 0;const a=r(4279),n=r(5406),o=r(6122);t.MI=class{constructor(e){this.utf8Converter=new o.HashUTF8ToLtXConverter,this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value);if(" "===e)return i.apply(e);const t=e.trim(),r=i.apply(t),n=this.utf8Converter.convert(r);return n!==r?n:this.wrapInMathVariant(r,this.getMathVariant(this._mathmlElement.attributes))}getMathVariant(e){if(e&&e.mathvariant)return e.mathvariant}wrapInMathVariant(e,t){switch(t){case"bold":return`\\mathbf{${e}}`;case"italic":return`\\mathit{${e}}`;case"bold-italic":return`\\mathbf{\\mathit{${e}}}`;case"double-struck":return`\\mathbb{${e}}`;case"bold-fraktur":return`\\mathbf{\\mathfrak{${e}}}`;case"script":return`\\mathcal{${e}}`;case"bold-script":return`\\mathbf{\\mathcal{${e}}}`;case"fraktur":return`\\mathfrak{${e}}`;case"sans-serif":return`\\mathsf{${e}}`;case"bold-sans-serif":return`\\mathbf{\\mathsf{${e}}}`;case"sans-serif-italic":return`\\mathsf{\\mathit{${e}}}`;case"sans-serif-bold-italic":return`\\mathbf{\\mathsf{\\mathit{${e}}}}`;case"monospace":return`\\mathtt{${e}}`;default:return e}}};class i{constructor(e){this._value=e}static apply(e){return new i(e)._apply()}_apply(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new o.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathSymbolsByChar[this._value]}_findByGlyph(){return n.allMathSymbolsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},8303:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MMultiscripts=void 0;const a=r(4279),n=r(8917);t.MMultiscripts=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(r<3)throw new n.InvalidNumberOfChildrenError(e,3,r,"at least");const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return this._prescriptLatex()+this._wrapInParenthesisIfThereIsSpace(o)+this._postscriptLatex()}_prescriptLatex(){const{children:e}=this._mathmlElement;let t,r;if(this._isPrescripts(e[1]))t=e[2],r=e[3];else{if(!this._isPrescripts(e[3]))return"";t=e[4],r=e[5]}return`\\_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_postscriptLatex(){const{children:e}=this._mathmlElement;if(this._isPrescripts(e[1]))return"";const t=e[1],r=e[2];return`_{${(0,a.mathMLElementToLaTeXConverter)(t).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(r).convert()}}`}_wrapInParenthesisIfThereIsSpace(e){return e.match(/\s+/g)?(new a.ParenthesisWrapper).wrap(e):e}_isPrescripts(e){return"mprescripts"===(null==e?void 0:e.name)}}},4464:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MN=void 0;const a=r(4279),n=r(5406);t.MN=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return n.mathNumberByGlyph[e]||e}}},3487:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MO=void 0;const a=r(4279),n=r(5406);t.MO=class{constructor(e){this._mathmlElement=e}convert(){const e=(0,a.normalizeWhiteSpaces)(this._mathmlElement.value).trim();return o.operate(e)}};class o{constructor(e){this._value=e}static operate(e){return new o(e)._operate()}_operate(){return this._findByCharacter()||this._findByGlyph()||this._findByNumber()||(new n.HashUTF8ToLtXConverter).convert(this._value)}_findByCharacter(){return n.allMathOperatorsByChar[this._value]}_findByGlyph(){return n.allMathOperatorsByGlyph[this._value]}_findByNumber(){return n.mathNumberByGlyph[this._value]}}},7443:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MPhantom=void 0,t.MPhantom=class{constructor(e){this._mathmlElement=e}convert(){return""}}},6052:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MRoot=void 0;const a=r(4279),n=r(8917);t.MRoot=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const o=(0,a.mathMLElementToLaTeXConverter)(t[0]).convert();return`\\sqrt[${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}]{${o}}`}}},8686:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSqrt=void 0;const a=r(4279);t.MSqrt=class{constructor(e){this._mathmlElement=e}convert(){return`\\sqrt{${this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" ")}}`}}},2564:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSub=void 0;const a=r(4279),n=r(8917);t.MSub=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},1358:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSubsup=void 0;const a=r(4279),n=r(8917);t.MSubsup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);const a=t[0],o=t[1],i=t[2];return`${this._handleBaseChild(a)}_${this._handleSubscriptChild(o)}^${this._handleSuperscriptChild(i)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleSubscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}_handleSuperscriptChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},6926:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MSup=void 0;const a=r(4279),n=r(8917);t.MSup=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(2!==r)throw new n.InvalidNumberOfChildrenError(e,2,r);const a=t[0],o=t[1];return`${this._handleBaseChild(a)}^${this._handleExponentChild(o)}`}_handleBaseChild(e){const t=e.children,r=(0,a.mathMLElementToLaTeXConverter)(e).convert();return t.length<=1?r:(new a.ParenthesisWrapper).wrapIfMoreThanOneChar(r)}_handleExponentChild(e){const t=(0,a.mathMLElementToLaTeXConverter)(e).convert();return(new a.BracketWrapper).wrap(t)}}},2350:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTable=void 0;const a=r(4279);t.MTable=class{constructor(e){this._mathmlElement=e,this._addFlagRecursiveIfName(this._mathmlElement.children,"mtable","innerTable")}convert(){const e=this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" \\\\\n");return this._hasFlag("innerTable")?this._wrap(e):e}_wrap(e){return`\\begin{matrix}${e}\\end{matrix}`}_addFlagRecursiveIfName(e,t,r){e.forEach((e=>{e.name===t&&(e.attributes[r]=r),this._addFlagRecursiveIfName(e.children,t,r)}))}_hasFlag(e){return!!this._mathmlElement.attributes[e]}}},3951:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MText=void 0;const a=r(7037);t.MText=class{constructor(e){this._mathmlElement=e}convert(){const{attributes:e,value:t}=this._mathmlElement;return[...t].map((e=>/^[a-zA-Z0-9]$/.test(e)||" "===e?{value:e,isAlphanumeric:!0}:{value:e,isAlphanumeric:!1})).reduce(((e,t)=>{if(t.isAlphanumeric){const r=e[e.length-1];if(r&&r.isAlphanumeric)return r.value+=t.value,e}return[...e,t]}),[]).map((t=>t.isAlphanumeric?new n(e.mathvariant).apply(t.value):new a.MI({name:"mi",attributes:{},children:[],value:t.value}).convert())).join("")}};class n{constructor(e){this._mathvariant=e||"normal"}apply(e){return this._commands.reduce(((t,r,a)=>0===a?`${r}{${e}}`:`${r}{${t}}`),"")}get _commands(){switch(this._mathvariant){case"bold":return["\\textbf"];case"italic":return["\\textit"];case"bold-italic":return["\\textit","\\textbf"];case"double-struck":return["\\mathbb"];case"monospace":return["\\mathtt"];case"bold-fraktur":case"fraktur":return["\\mathfrak"];default:return["\\text"]}}}},1586:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MTr=void 0;const a=r(4279);t.MTr=class{constructor(e){this._mathmlElement=e}convert(){return this._mathmlElement.children.map((e=>(0,a.mathMLElementToLaTeXConverter)(e))).map((e=>e.convert())).join(" & ")}}},1222:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MUnderover=void 0;const a=r(4279),n=r(8917);t.MUnderover=class{constructor(e){this._mathmlElement=e}convert(){const{name:e,children:t}=this._mathmlElement,r=t.length;if(3!==r)throw new n.InvalidNumberOfChildrenError(e,3,r);return`${(0,a.mathMLElementToLaTeXConverter)(t[0]).convert()}_{${(0,a.mathMLElementToLaTeXConverter)(t[1]).convert()}}^{${(0,a.mathMLElementToLaTeXConverter)(t[2]).convert()}}`}}},9165:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Void=void 0,t.Void=class{constructor(e){this._mathmlElement=e}convert(){return""}}},5443:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return n(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLElementToLatexConverterAdapter=void 0;const i=o(r(6959)),s=r(2697);t.MathMLElementToLatexConverterAdapter=class{constructor(e){this._mathMLElement=null!=e?e:new s.VoidMathMLElement}toLatexConverter(){const{name:e}=this._mathMLElement;return new(l[e]||i.GenericSpacingWrapper)(this._mathMLElement)}};const l={math:i.Math,mi:i.MI,mo:i.MO,mn:i.MN,msqrt:i.MSqrt,mfenced:i.MFenced,mfrac:i.MFrac,mroot:i.MRoot,maction:i.MAction,menclose:i.MEnclose,merror:i.MError,mphantom:i.MPhantom,msup:i.MSup,msub:i.MSub,msubsup:i.MSubsup,mmultiscripts:i.MMultiscripts,mtext:i.MText,munderover:i.MUnderover,mtable:i.MTable,mtr:i.MTr,mover:i.GenericUnderOver,munder:i.GenericUnderOver,mrow:i.GenericSpacingWrapper,mpadded:i.GenericSpacingWrapper,void:i.Void}},5243:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorHandler=void 0,t.ErrorHandler=class{constructor(){this._errors=[],this.errorLocator={}}fixError(e,t){return this._isMissingAttributeValueError(t)?(this._errors.push(t),this._fixMissingAttribute(t,e)):e}isThereAnyErrors(){return this._errors.length>0}cleanErrors(){this._errors=[]}_fixMissingAttribute(e,t){const r=e.split('"')[1];if(r)return t.replace(this._matchMissingValueForAttribute(r),"");for(;this._mathGenericMissingValue().exec(t);)t=t.replace(this._mathGenericMissingValue(),"$1$3");return t}_matchMissingValueForAttribute(e){return new RegExp(`(${e}=(?!("|')))|(${e}(?!("|')))`,"gm")}_mathGenericMissingValue(){return/(\<.* )(\w+=(?!\"|\'))(.*\>)/gm}_isMissingAttributeValueError(e){return!!e.includes("attribute")&&!!e.includes("missed")||e.includes("attribute value missed")}}},9208:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(9548),t),n(r(5243),t),n(r(1101),t)},1101:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ElementsToMathMLAdapter=void 0,t.ElementsToMathMLAdapter=class{convert(e){return e.filter((e=>void 0!==e.tagName)).map((e=>this._convertElement(e)))}_convertElement(e){return{name:e.tagName,attributes:this._convertElementAttributes(e.attributes),value:this._hasElementChild(e)?"":e.textContent||"",children:this._hasElementChild(e)?this.convert(Array.from(e.childNodes)):[]}}_convertElementAttributes(e){return Array.from(e).reduce(((e,t)=>Object.assign({[t.nodeName]:t.nodeValue===t.nodeName?"":t.nodeValue},e)),{})}_hasElementChild(e){const t=e.childNodes;return!!t&&0!==t.length&&this._isThereAnyNoTextNode(t)}_isThereAnyNoTextNode(e){return Array.from(e).some((e=>"#text"!==e.nodeName))}}},9548:function(e,t,r){"use strict";var a=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.XmlToMathMLAdapter=void 0;const n=a(r(8978));t.XmlToMathMLAdapter=class{constructor(e,t){this._xml="",this._elementsConvertor=e,this._errorHandler=t,this._xmlDOM=new n.default.DOMParser({locator:this._errorHandler.errorLocator,errorHandler:this._fixError.bind(this)})}convert(e){return this._xml=this._removeLineBreaks(e),this._xml=this._removeMsWordPrefixes(this._xml),this._elementsConvertor.convert(this._mathMLElements)}_fixError(e){this._xml=this._errorHandler.fixError(this._xml,e)}_removeLineBreaks(e){return e.replace(/\n|\r\n|\r/g,"")}_removeMsWordPrefixes(e){return e.replace(/mml:/g,"")}get _mathMLElements(){let e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math");return this._errorHandler.isThereAnyErrors()&&(this._errorHandler.cleanErrors(),e=this._xmlDOM.parseFromString(this._xml).getElementsByTagName("math")),Array.from(e)}}},7941:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(8585),t)},8585:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.makeToMathElementsConverter=void 0;const a=r(9208);t.makeToMathElementsConverter=()=>{const e=new a.ElementsToMathMLAdapter,t=new a.ErrorHandler;return new a.XmlToMathMLAdapter(e,t)}},8672:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(3798),t)},3798:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MathMLToLaTeX=void 0;const a=r(5443),n=r(7941);t.MathMLToLaTeX=class{static convert(e){return(0,n.makeToMathElementsConverter)().convert(e).map((e=>new a.MathMLElementToLatexConverterAdapter(e).toLatexConverter())).map((e=>e.convert())).join("").trim()}}},2965:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByChar=void 0,t.allMathOperatorsByChar={_:"\\underline","&#x23E1;":"\\underbrace","&#x23E0;":"\\overbrace","&#x23DF;":"\\underbrace","&#x23DE;":"\\overbrace","&#x23DD;":"\\underbrace","&#x23DC;":"\\overbrace","&#x23B5;":"\\underbrace","&#x23B4;":"\\overbrace","&#x20DC;":"\\square","&#x20DB;":"\\square","&#x2064;":"","&#x2057;":"''''","&#x203E;":"\\bar","&#x2037;":"```","&#x2036;":"``","&#x2035;":"`","&#x2034;":"'''","&#x2033;":"''","&#x201F;":"``","&#x201E;":",,","&#x201B;":"`","&#x201A;":",","&#x302;":"\\hat","&#x2F7;":"\\sim","&#x2DD;":"\\sim","&#x2DC;":"\\sim","&#x2DA;":"\\circ","&#x2D9;":"\\cdot","&#x2D8;":"","&#x2CD;":"\\_","&#x2CB;":"ˋ","&#x2CA;":"ˊ","&#x2C9;":"ˉ","&#x2C7;":"","&#x2C6;":"\\hat","&#xBA;":"o","&#xB9;":"1","&#xB8;":"¸","&#xB4;":"´","&#xB3;":"3","&#xB2;":"2","&#xB0;":"\\circ","&#xAF;":"\\bar","&#xAA;":"a","&#xA8;":"\\cdot\\cdot","~":"\\sim","`":"`","^":"\\hat","--":"--","++":"++","&amp;":"\\&","&#x2061;":"","&#x221C;":"\\sqrt[4]{}","&#x221B;":"\\sqrt[3]{}","&#x221A;":"\\sqrt{}","&#x2146;":"d","&#x2145;":"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","&#x266F;":"\\#","&#x266E;":"","&#x266D;":"","&#x2032;":"'","&lt;>":"<>","**":"\\star\\star","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x2299;":"\\bigodot","&#xAC;":"\\neg","&#x2222;":"\\measuredangle","&#x2221;":"\\measuredangle","&#x2220;":"\\angle","&#xF7;":"\\div","/":"/","&#x2216;":"\\backslash","\\":"\\backslash","%":"\\%","&#x2297;":"\\bigotimes","&#xB7;":"\\cdot","&#x2A3F;":"\\coprod","&#x2A2F;":"\\times","&#x22C5;":"\\cdot","&#x22A1;":"\\boxdot","&#x22A0;":"\\boxtimes","&#x2062;":"","&#x2043;":"-","&#x2022;":"\\cdot","&#xD7;":"\\times",".":".","*":"\\star","&#x222A;":"\\cup","&#x2229;":"\\cap","&#x2210;":"\\coprod","&#x220F;":"\\prod","&#x2240;":"","&#x2AFF;":"","&#x2AFC;":"\\mid\\mid\\mid","&#x2A09;":"\\times","&#x2A08;":"","&#x2A07;":"","&#x2A06;":"\\sqcup","&#x2A05;":"\\sqcap","&#x2A02;":"\\otimes","&#x2A00;":"\\odot","&#x22C2;":"\\cap","&#x22C1;":"\\vee","&#x22C0;":"\\wedge","&#x2A04;":"\\uplus","&#x2A03;":"\\cup","&#x22C3;":"\\cup","&#x2A1C;":"\\underline{\\int}","&#x2A1B;":"\\overline{\\int}","&#x2A1A;":"\\int","&#x2A19;":"\\int","&#x2A18;":"\\int","&#x2A17;":"\\int","&#x2A16;":"\\oint","&#x2A15;":"\\oint","&#x2A14;":"\\int","&#x2A13;":"\\int","&#x2A12;":"\\int","&#x2A11;":"\\int","&#x2A10;":"\\int","&#x2A0F;":"\\bcancel{\\int}","&#x2A0E;":"","&#x2A0D;":"\\hcancel{\\int}","&#x2A0C;":"\\iiiint","&#x2233;":"\\oint","&#x2232;":"\\oint","&#x2231;":"\\int","&#x2230;":"\\oiint","&#x222F;":"\\oiint","&#x222E;":"\\oint","&#x222B;":"\\int","&#x2A01;":"\\oplus","&#x2298;":"\\oslash","&#x2296;":"\\ominus","&#x2295;":"\\oplus","&#x222D;":"\\iiint","&#x222C;":"\\iint","&#x2A0B;":"","&#x2A0A;":"","&#x2211;":"\\sum","&#x229F;":"\\boxminus","&#x229E;":"\\boxplus","&#x2214;":"\\dot{+}","&#x2213;":"+-","&#x2212;":"-","&#xB1;":"\\pm","-":"-","+":"+","&#x2B46;":"\\Rrightarrow","&#x2B45;":"\\Lleftarrow","&#x29F4;":":\\rightarrow","&#x29EF;":"","&#x29DF;":"\\bullet-\\bullet","&#x299F;":"\\angle","&#x299E;":"\\measuredangle","&#x299D;":"\\measuredangle","&#x299C;":"\\perp","&#x299B;":"\\measuredangle","&#x299A;":"","&#x2999;":"\\vdots","&#x297F;":"","&#x297E;":"","&#x297D;":"\\prec","&#x297C;":"\\succ","&#x297B;":"\\underset{\\rightarrow}{\\supset}","&#x297A;":"","&#x2979;":"\\underset{\\rightarrow}{\\subset}","&#x2978;":"\\underset{\\rightarrow}{>}","&#x2977;":"","&#x2976;":"\\underset{\\leftarrow}{<}","&#x2975;":"\\underset{\\approx}{\\rightarrow}","&#x2974;":"\\underset{\\sim}{\\rightarrow}","&#x2973;":"\\underset{\\sim}{\\leftarrow}","&#x2972;":"\\overset{\\sim}{\\rightarrow}","&#x2971;":"\\overset{=}{\\rightarrow}","&#x2970;":"","&#x296F;":"","&#x296E;":"","&#x296D;":"\\overline{\\rightharpoondown}","&#x296C;":"\\underline{\\rightharpoonup}","&#x296B;":"\\overline{\\leftharpoondown}","&#x296A;":"\\underline{\\leftharpoonup}","&#x2969;":"\\rightleftharpoons","&#x2968;":"\\rightleftharpoons","&#x2967;":"\\rightleftharpoons","&#x2966;":"\\rightleftharpoons","&#x2965;":"\\Downarrow","&#x2964;":"\\Rightarrow","&#x2963;":"\\Uparrow","&#x2962;":"\\Leftarrow","&#x2961;":"\\downarrow","&#x2960;":"\\uparrow","&#x295F;":"\\rightarrow","&#x295E;":"\\leftarrow","&#x295D;":"\\downarrow","&#x295C;":"\\uparrow","&#x295B;":"\\rightarrow","&#x295A;":"\\leftarrow","&#x2959;":"\\downarrow","&#x2958;":"\\uparrow","&#x2957;":"\\rightarrow","&#x2956;":"\\leftarrow","&#x2955;":"\\downarrow","&#x2954;":"\\uparrow","&#x2953;":"\\rightarrow","&#x2952;":"\\leftarrow","&#x2951;":"\\updownarrow","&#x2950;":"\\leftrightarrow","&#x294F;":"\\updownarrow","&#x294E;":"\\leftrightarrow","&#x294D;":"\\updownarrow","&#x294C;":"\\updownarrow","&#x294B;":"\\leftrightarrow","&#x294A;":"\\leftrightarrow","&#x2949;":"","&#x2948;":"\\leftrightarrow","&#x2947;":"\\nrightarrow","&#x2946;":"","&#x2945;":"","&#x2944;":"\\rightleftarrows","&#x2943;":"\\leftrightarrows","&#x2942;":"\\rightleftarrows","&#x2941;":"\\circlearrowright","&#x2940;":"\\circlearrowleft","&#x293F;":"\\rightarrow","&#x293E;":"\\leftarrow","&#x293D;":"","&#x293C;":"","&#x293B;":"","&#x293A;":"","&#x2939;":"","&#x2938;":"","&#x2937;":"\\Rsh","&#x2936;":"\\Lsh","&#x2935;":"\\downarrow","&#x2934;":"\\uparrow","&#x2933;":"\\leadsto","&#x2932;":"","&#x2931;":"","&#x2930;":"","&#x292F;":"","&#x292E;":"","&#x292D;":"","&#x292C;":"\\times","&#x292B;":"\\times","&#x292A;":"","&#x2929;":"","&#x2928;":"","&#x2927;":"","&#x2926;":"","&#x2925;":"","&#x2924;":"","&#x2923;":"","&#x2922;":"","&#x2921;":"","&#x2920;":"\\mapsto\\cdot","&#x291F;":"\\cdot\\leftarrow","&#x291E;":"\\rightarrow\\cdot","&#x291D;":"\\leftarrow","&#x291C;":"\\rightarrow","&#x291B;":"\\leftarrow","&#x291A;":"\\rightarrow","&#x2919;":"\\leftarrow","&#x2918;":"\\rightarrow","&#x2917;":"\\rightarrow","&#x2916;":"\\rightarrow","&#x2915;":"\\rightarrow","&#x2914;":"\\rightarrow","&#x2913;":"\\downarrow","&#x2912;":"\\uparrow","&#x2911;":"\\rightarrow","&#x2910;":"\\rightarrow","&#x290F;":"\\rightarrow","&#x290E;":"\\leftarrow","&#x290D;":"\\rightarrow","&#x290C;":"\\leftarrow","&#x290B;":"\\Downarrow","&#x290A;":"\\Uparrow","&#x2909;":"\\uparrow","&#x2908;":"\\downarrow","&#x2907;":"\\Rightarrow","&#x2906;":"\\Leftarrow","&#x2905;":"\\mapsto","&#x2904;":"\\nLeftrightarrow","&#x2903;":"\\nRightarrow","&#x2902;":"\\nLeftarrow","&#x2901;":"\\rightsquigarrow","&#x2900;":"\\rightsquigarrow","&#x27FF;":"\\rightsquigarrow","&#x27FE;":"\\Rightarrow","&#x27FD;":"\\Leftarrow","&#x27FC;":"\\mapsto","&#x27FB;":"\\leftarrow","&#x27FA;":"\\Longleftrightarrow","&#x27F9;":"\\Longrightarrow","&#x27F8;":"\\Longleftarrow","&#x27F7;":"\\leftrightarrow","&#x27F6;":"\\rightarrow","&#x27F5;":"\\leftarrow","&#x27F1;":"\\Downarrow","&#x27F0;":"\\Uparrow","&#x22B8;":"\\rightarrow","&#x21FF;":"\\leftrightarrow","&#x21FE;":"\\rightarrow","&#x21FD;":"\\leftarrow","&#x21FC;":"\\nleftrightarrow","&#x21FB;":"\\nrightarrow","&#x21FA;":"\\nleftarrow","&#x21F9;":"\\nleftrightarrow","&#x21F8;":"\\nrightarrow","&#x21F7;":"\\nleftarrow","&#x21F6;":"\\Rrightarrow","&#x21F5;":"","&#x21F4;":"\\rightarrow","&#x21F3;":"\\Updownarrow","&#x21F2;":"\\searrow","&#x21F1;":"\\nwarrow","&#x21F0;":"\\Leftarrow","&#x21EF;":"\\Uparrow","&#x21EE;":"\\Uparrow","&#x21ED;":"\\Uparrow","&#x21EC;":"\\Uparrow","&#x21EB;":"\\Uparrow","&#x21EA;":"\\Uparrow","&#x21E9;":"\\Downarrow","&#x21E8;":"\\Rightarrow","&#x21E7;":"\\Uparrow","&#x21E6;":"\\Leftarrow","&#x21E5;":"\\rightarrow","&#x21E4;":"\\leftarrow","&#x21E3;":"\\downarrow","&#x21E2;":"\\rightarrow","&#x21E1;":"\\uparrow","&#x21E0;":"\\leftarrow","&#x21DF;":"\\downarrow","&#x21DE;":"\\uparrow","&#x21DD;":"\\rightsquigarrow","&#x21DC;":"\\leftarrow","&#x21DB;":"\\Rrightarrow","&#x21DA;":"\\Lleftarrow","&#x21D9;":"\\swarrow","&#x21D8;":"\\searrow","&#x21D7;":"\\nearrow","&#x21D6;":"\\nwarrow","&#x21D5;":"\\Updownarrow","&#x21D4;":"\\Leftrightarrow","&#x21D3;":"\\Downarrow","&#x21D2;":"\\Rightarrow","&#x21D1;":"\\Uparrow","&#x21D0;":"\\Leftarrow","&#x21CF;":"\\nRightarrow","&#x21CE;":"\\nLeftrightarrow","&#x21CD;":"\\nLeftarrow","&#x21CC;":"\\rightleftharpoons","&#x21CB;":"\\leftrightharpoons","&#x21CA;":"\\downdownarrows","&#x21C9;":"\\rightrightarrows","&#x21C8;":"\\upuparrows","&#x21C7;":"\\leftleftarrows","&#x21C6;":"\\leftrightarrows","&#x21C5;":"","&#x21C4;":"\\rightleftarrows","&#x21C3;":"\\downharpoonleft","&#x21C2;":"\\downharpoonright","&#x21C1;":"\\rightharpoondown","&#x21C0;":"\\rightharpoonup","&#x21BF;":"\\upharpoonleft","&#x21BE;":"\\upharpoonright","&#x21BD;":"\\leftharpoondown","&#x21BC;":"\\leftharpoonup","&#x21BB;":"\\circlearrowright","&#x21BA;":"\\circlearrowleft","&#x21B9;":"\\leftrightarrows","&#x21B8;":"\\overline{\\nwarrow}","&#x21B7;":"\\curvearrowright","&#x21B6;":"\\curvearrowleft","&#x21B5;":"\\swarrow","&#x21B4;":"\\searrow","&#x21B3;":"\\Rsh","&#x21B2;":"\\Lsh","&#x21B1;":"\\Rsh","&#x21B0;":"\\Lsh","&#x21AF;":"\\swarrow","&#x21AE;":"","&#x21AD;":"\\leftrightsquigarrow","&#x21AC;":"\\looparrowright","&#x21AB;":"\\looparrowleft","&#x21AA;":"\\hookrightarrow","&#x21A9;":"\\hookleftarrow","&#x21A8;":"\\underline{\\updownarrow}","&#x21A7;":"\\downarrow","&#x21A6;":"\\rightarrowtail","&#x21A5;":"\\uparrow","&#x21A4;":"\\leftarrowtail","&#x21A3;":"\\rightarrowtail","&#x21A2;":"\\leftarrowtail","&#x21A1;":"\\downarrow","&#x21A0;":"\\twoheadrightarrow","&#x219F;":"\\uparrow","&#x219E;":"\\twoheadleftarrow","&#x219D;":"\\nearrow","&#x219C;":"\\nwarrow","&#x219B;":"","&#x219A;":"","&#x2199;":"\\swarrow","&#x2198;":"\\searrow","&#x2197;":"\\nearrow","&#x2196;":"\\nwarrow","&#x2195;":"\\updownarrow","&#x2194;":"\\leftrightarrow","&#x2193;":"\\downarrow","&#x2192;":"\\rightarrow","&#x2191;":"\\uparrow","&#x2190;":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\left|\\right.","&#x2AFE;":"","&#x2AFD;":"//","&#x2AFB;":"///","&#x2AFA;":"","&#x2AF9;":"","&#x2AF8;":"","&#x2AF7;":"","&#x2AF6;":"\\vdots","&#x2AF5;":"","&#x2AF4;":"","&#x2AF3;":"","&#x2AF2;":"\\nparallel","&#x2AF1;":"","&#x2AF0;":"","&#x2AEF;":"","&#x2AEE;":"\\bcancel{\\mid}","&#x2AED;":"","&#x2AEC;":"","&#x2AEB;":"","&#x2AEA;":"","&#x2AE9;":"","&#x2AE8;":"\\underline{\\perp}","&#x2AE7;":"\\overline{\\top}","&#x2AE6;":"","&#x2AE5;":"","&#x2AE4;":"","&#x2AE3;":"","&#x2AE2;":"","&#x2AE1;":"","&#x2AE0;":"\\perp","&#x2ADF;":"\\top","&#x2ADE;":"\\dashv","&#x2ADD;&#x338;":"","&#x2ADD;":"","&#x2ADB;":"\\pitchfork","&#x2ADA;":"","&#x2AD9;":"","&#x2AD8;":"","&#x2AD7;":"","&#x2AD6;":"","&#x2AD5;":"","&#x2AD4;":"","&#x2AD3;":"","&#x2AD2;":"","&#x2AD1;":"","&#x2AD0;":"","&#x2ACF;":"","&#x2ACE;":"","&#x2ACD;":"","&#x2ACC;":"\\underset{\\neq}{\\supset}","&#x2ACB;":"\\underset{\\neq}{\\subset}","&#x2ACA;":"\\underset{\\approx}{\\supset}","&#x2AC9;":"\\underset{\\approx}{\\subset}","&#x2AC8;":"\\underset{\\sim}{\\supset}","&#x2AC7;":"\\underset{\\sim}{\\subset}","&#x2AC6;":"\\supseteqq","&#x2AC5;":"\\subseteqq","&#x2AC4;":"\\dot{\\supseteq}","&#x2AC3;":"\\dot{\\subseteq}","&#x2AC2;":"\\underset{\\times}{\\supset}","&#x2AC1;":"\\underset{\\times}{\\subset}","&#x2AC0;":"\\underset{+}{\\supset}","&#x2ABF;":"\\underset{+}{\\subset}","&#x2ABE;":"","&#x2ABD;":"","&#x2ABC;":"\\gg ","&#x2ABB;":"\\ll","&#x2ABA;":"\\underset{\\cancel{\\approx}}{\\succ}","&#x2AB9;":"\\underset{\\cancel{\\approx}}{\\prec}","&#x2AB8;":"\\underset{\\approx}{\\succ}","&#x2AB7;":"\\underset{\\approx}{\\prec}","&#x2AB6;":"\\underset{\\cancel{=}}{\\succ}","&#x2AB5;":"\\underset{\\cancel{=}}{\\prec}","&#x2AB4;":"\\underset{=}{\\succ}","&#x2AB3;":"\\underset{=}{\\prec}","&#x2AB2;":"","&#x2AB1;":"","&#x2AAE;":"","&#x2AAD;":"\\underline{\\hcancel{>}}","&#x2AAC;":"\\underline{\\hcancel{>}}","&#x2AAB;":"\\hcancel{>}","&#x2AAA;":"\\hcancel{<}","&#x2AA9;":"","&#x2AA8;":"","&#x2AA7;":"\\vartriangleright","&#x2AA6;":"\\vartriangleleft","&#x2AA5;":"><","&#x2AA4;":"><","&#x2AA3;":"\\underline{\\ll}","&#x2AA2;&#x338;":"\\cancel{\\gg}","&#x2AA2;":"\\gg","&#x2AA1;&#x338;":"\\cancel{\\ll}","&#x2AA1;":"\\ll","&#x2AA0;":"\\overset{\\sim}{\\geqq}","&#x2A9F;":"\\overset{\\sim}{\\leqq}","&#x2A9E;":"\\overset{\\sim}{>}","&#x2A9D;":"\\overset{\\sim}{<}","&#x2A9C;":"","&#x2A9B;":"","&#x2A9A;":"\\overset{=}{>}","&#x2A99;":"\\overset{=}{<}","&#x2A98;":"","&#x2A97;":"","&#x2A96;":"","&#x2A95;":"","&#x2A94;":"","&#x2A93;":"","&#x2A92;":"\\underset{=}{\\gtrless}","&#x2A91;":"\\underset{=}{\\lessgtr}","&#x2A90;":"\\underset{<}{\\gtrsim}","&#x2A8F;":"\\underset{>}{\\lesssim}","&#x2A8E;":"\\underset{\\simeq}{>}","&#x2A8D;":"\\underset{\\simeq}{<}","&#x2A8C;":"\\gtreqqless","&#x2A8B;":"\\lesseqqgtr","&#x2A8A;":"\\underset{\\cancel{\\approx}}{>}","&#x2A89;":"\\underset{\\approx}{<}","&#x2A86;":"\\underset{\\approx}{>}","&#x2A85;":"\\underset{\\approx}{<}","&#x2A84;":"","&#x2A83;":"","&#x2A82;":"","&#x2A81;":"","&#x2A80;":"","&#x2A7F;":"","&#x2A7E;&#x338;":"\\bcancel{\\geq}","&#x2A7E;":"\\geq","&#x2A7D;&#x338;":"\\bcancel{\\leq}","&#x2A7D;":"\\leq","&#x2A7C;":"","&#x2A7B;":"","&#x2A7A;":"","&#x2A79;":"","&#x2A78;":"\\overset{\\dots}{\\equiv}","&#x2A77;":"","&#x2A76;":"===","&#x2A75;":"==","&#x2A74;":"::=","&#x2A73;":"","&#x2A72;":"\\underset{=}{+}","&#x2A71;":"\\overset{=}{+}","&#x2A70;":"\\overset{\\approx}{=}","&#x2A6F;":"\\overset{\\wedge}{=}","&#x2A6E;":"\\overset{*}{=}","&#x2A6D;":"\\dot{\\approx}","&#x2A6C;":"","&#x2A6B;":"","&#x2A6A;":"\\dot{\\sim}","&#x2A69;":"","&#x2A68;":"","&#x2A67;":"\\dot{\\equiv}","&#x2A66;":"\\underset{\\cdot}{=}","&#x2A65;":"","&#x2A64;":"","&#x2A63;":"\\underset{=}{\\vee}","&#x2A62;":"\\overset{=}{\\vee}","&#x2A61;":"ul(vv)","&#x2A60;":"\\underset{=}{\\wedge}","&#x2A5F;":"\\underline{\\wedge}","&#x2A5E;":"\\overset{=}{\\wedge}","&#x2A5D;":"\\hcancel{\\vee}","&#x2A5C;":"\\hcancel{\\wedge}","&#x2A5B;":"","&#x2A5A;":"","&#x2A59;":"","&#x2A58;":"\\vee","&#x2A57;":"\\wedge","&#x2A56;":"","&#x2A55;":"","&#x2A54;":"","&#x2A53;":"","&#x2A52;":"\\dot{\\vee}","&#x2A51;":"\\dot{\\wedge}","&#x2A50;":"","&#x2A4F;":"","&#x2A4E;":"","&#x2A4D;":"\\overline{\\cap}","&#x2A4C;":"\\overline{\\cup}","&#x2A4B;":"","&#x2A4A;":"","&#x2A49;":"","&#x2A48;":"","&#x2A47;":"","&#x2A46;":"","&#x2A45;":"","&#x2A44;":"","&#x2A43;":"\\overline{\\cap}","&#x2A42;":"\\overline{\\cup}","&#x2A41;":"","&#x2A40;":"","&#x2A3E;":"","&#x2A3D;":"\\llcorner","&#x2A3C;":"\\lrcorner","&#x2A3B;":"","&#x2A3A;":"","&#x2A39;":"","&#x2A38;":"","&#x2A37;":"","&#x2A36;":"\\hat{\\otimes}","&#x2A35;":"","&#x2A34;":"","&#x2A33;":"","&#x2A32;":"\\underline{\\times}","&#x2A31;":"\\underline{\\times}","&#x2A30;":"\\dot{\\times}","&#x2A2E;":"","&#x2A2D;":"","&#x2A2C;":"","&#x2A2B;":"","&#x2A2A;":"","&#x2A29;":"","&#x2A28;":"","&#x2A27;":"","&#x2A26;":"\\underset{\\sim}{+}","&#x2A25;":"\\underset{\\circ}{+}","&#x2A24;":"\\overset{\\sim}{+}","&#x2A23;":"\\hat{+}","&#x2A22;":"\\dot{+}","&#x2A21;":"\\upharpoonright","&#x2A20;":">>","&#x2A1F;":"","&#x2A1E;":"\\triangleleft","&#x2A1D;":"\\bowtie","&#x29FF;":"","&#x29FE;":"+","&#x29FB;":"\\hcancel{|||}","&#x29FA;":"\\hcancel{||}","&#x29F9;":"\\backslash","&#x29F8;":"/","&#x29F7;":"hcancel{\backslash}","&#x29F6;":"","&#x29F5;":"\\backslash","&#x29F2;":"\\Phi","&#x29F1;":"","&#x29F0;":"","&#x29EE;":"","&#x29ED;":"","&#x29EC;":"","&#x29EB;":"\\lozenge","&#x29EA;":"","&#x29E9;":"","&#x29E8;":"","&#x29E7;":"\\ddagger","&#x29E2;":"\\sqcup\\sqcup","&#x29E1;":"","&#x29E0;":"\\square","&#x29DE;":"","&#x29DD;":"","&#x29DC;":"","&#x29DB;":"\\{\\{","&#x29D9;":"\\{","&#x29D8;":"\\}","&#x29D7;":"","&#x29D6;":"","&#x29D5;":"\\bowtie","&#x29D4;":"\\bowtie","&#x29D3;":"\\bowtie","&#x29D2;":"\\bowtie","&#x29D1;":"\\bowtie","&#x29D0;&#x338;":"| \\not\\triangleright","&#x29D0;":"| \\triangleright","&#x29CF;&#x338;":"\\not\\triangleleft |","&#x29CF;":"\\triangleleft |","&#x29CE;":"","&#x29CD;":"\\triangle","&#x29CC;":"","&#x29CB;":"\\underline{\\triangle}","&#x29CA;":"\\dot{\\triangle}","&#x29C9;":"","&#x29C8;":"\\boxed{\\circ}","&#x29C7;":"\\boxed{\\circ}","&#x29C6;":"\\boxed{\\rightarrow}","&#x29C5;":"\\bcancel{\\square}","&#x29C4;":"\\cancel{\\square}","&#x29C3;":"\\odot","&#x29C2;":"\\odot","&#x29BF;":"\\odot","&#x29BE;":"\\odot","&#x29BD;":"\\varnothing","&#x29BC;":"\\oplus","&#x29BB;":"\\otimes","&#x29BA;":"","&#x29B9;":"\\varnothing","&#x29B8;":"\\varnothing","&#x29B7;":"\\ominus","&#x29B6;":"\\ominus","&#x29B5;":"\\ominus","&#x29B4;":"\\vec{\\varnothing}","&#x29B3;":"\\vec{\\varnothing}","&#x29B2;":"\\dot{\\varnothing}","&#x29B1;":"\\overline{\\varnothing}","&#x29B0;":"\\varnothing","&#x29AF;":"","&#x29AE;":"","&#x29AD;":"","&#x29AC;":"","&#x29AB;":"","&#x29AA;":"","&#x29A9;":"","&#x29A8;":"","&#x29A7;":"","&#x29A6;":"","&#x29A5;":"","&#x29A4;":"","&#x29A3;":"","&#x29A2;":"","&#x29A1;":"\\not\\lor","&#x29A0;":"\\bcancel{>}","&#x2982;":":","&#x2981;":"\\circ","&#x2758;":"|","&#x25B2;":"\\bigtriangleup","&#x22FF;":"\\Epsilon","&#x22FE;":"\\overline{\\ni}","&#x22FD;":"\\overline{\\ni}","&#x22FC;":"\\in","&#x22FB;":"\\in","&#x22FA;":"\\in","&#x22F9;":"\\underline{\\in}","&#x22F8;":"\\underline{\\in}","&#x22F7;":"\\overline{\\in}","&#x22F6;":"\\overline{\\in}","&#x22F5;":"\\dot{\\in}","&#x22F4;":"\\in","&#x22F3;":"\\in","&#x22F2;":"\\in","&#x22F0;":"\\ddots","&#x22E9;":"\\underset{\\sim}{\\succ}","&#x22E8;":"\\underset{\\sim}{\\prec}","&#x22E7;":"\\underset{\\not\\sim}{>}","&#x22E6;":"\\underset{\\not\\sim}{<}","&#x22E5;":"\\not\\sqsupseteq","&#x22E4;":"\\not\\sqsubseteq","&#x22E3;":"\\not\\sqsupseteq","&#x22E2;":"\\not\\sqsubseteq","&#x22E1;":"\\nsucc","&#x22E0;":"\\nprec","&#x22DF;":"\\succ","&#x22DE;":"\\prec","&#x22DD;":"\\overline{>}","&#x22DC;":"\\overline{<}","&#x22DB;":"\\underset{>}{\\leq}","&#x22DA;":"\\underset{<}{\\geq}","&#x22D5;":"\\#","&#x22D3;":"\\cup","&#x22D2;":"\\cap","&#x22D1;":"\\supset","&#x22D0;":"\\subset","&#x22CF;":"\\wedge","&#x22CE;":"\\vee","&#x22CD;":"\\simeq","&#x22C8;":"\\bowtie","&#x22C7;":"\\ast","&#x22C6;":"\\star","&#x22C4;":"\\diamond","&#x22BF;":"\\triangle","&#x22BE;":"\\measuredangle","&#x22BD;":"\\overline{\\lor}","&#x22BC;":"\\overline{\\land}","&#x22BB;":"\\underline{\\lor}","&#x22BA;":"\\top","&#x22B9;":"","&#x22B7;":"\\circ\\multimap","&#x22B6;":"\\circ\\multimap","&#x22B3;":"\\triangleright","&#x22B2;":"\\triangleleft","&#x22B1;":"\\succ","&#x22B0;":"\\prec","&#x22AB;":"|\\models","&#x22AA;":"|\\models","&#x22A7;":"\\models","&#x22A6;":"\\vdash","&#x229D;":"\\ominus","&#x229C;":"\\ominus","&#x229B;":"\\odot","&#x229A;":"\\odot","&#x2294;":"\\sqcup","&#x2293;":"\\sqcap","&#x2292;":"\\sqsupseteq","&#x2291;":"\\sqsubseteq","&#x2290;&#x338;":"\\not\\sqsupset","&#x2290;":"\\sqsupset","&#x228F;&#x338;":"\\not\\sqsubset","&#x228F;":"\\sqsubset","&#x228E;":"\\cup","&#x228D;":"\\cup","&#x228C;":"\\cup","&#x227F;&#x338;":"\\not\\succsim","&#x227F;":"\\succsim","&#x227E;":"\\precsim","&#x2279;":"\\not\\overset{>}{<}","&#x2278;":"\\not\\overset{>}{<}","&#x2277;":"\\overset{>}{<}","&#x2276;":"\\overset{<}{>}","&#x2275;":"\\not\\geg","&#x2274;":"\\not\\leq","&#x2273;":"\\geg","&#x2272;":"\\leq","&#x226C;":"","&#x2267;":"\\geg","&#x2266;&#x338;":"\\not\\leq","&#x2266;":"\\leq","&#x2263;":"\\overset{=}{=} ","&#x225E;":"\\overset{m}{=} ","&#x225D;":"\\overset{def}{=}","&#x2258;":"=","&#x2256;":"=","&#x2255;":"=:","&#x2253;":"\\doteq","&#x2252;":"\\doteq","&#x2251;":"\\doteq","&#x2250;":"\\doteq","&#x224F;&#x338;":"","&#x224F;":"","&#x224E;&#x338;":"","&#x224E;":"","&#x224C;":"\\approx","&#x224B;":"\\approx","&#x224A;":"\\approx","&#x2242;&#x338;":"\\neq","&#x2242;":"=","&#x223F;":"\\sim","&#x223E;":"\\infty","&#x223D;&#x331;":"\\sim","&#x223D;":"\\sim","&#x223B;":"\\sim","&#x223A;":":-:","&#x2239;":"-:","&#x2238;":"\\bot","&#x2237;":"::","&#x2236;":":","&#x2223;":"|","&#x221F;":"\\llcorner","&#x2219;":"\\cdot","&#x2218;":"\\circ","&#x2217;":"*","&#x2215;":"/","&#x220E;":"\\square","&#x220D;":"\\ni","&#x220A;":"\\in","&#x2206;":"\\Delta","&#x2044;":"/","&#x2AB0;&#x338;":"\\nsucceq","&#x2AB0;":"\\succeq","&#x2AAF;&#x338;":"\\npreceq","&#x2AAF;":"\\preceq","&#x2A88;":"\\ngeqslant","&#x2A87;":"\\nleqslant","&#x29F3;":"\\Phi","&#x29E6;":"\\models","&#x29E5;":"\\not\\equiv","&#x29E4;":"\\approx\\neq","&#x29E3;":"\\neq","&#x29C1;":"\\circle","&#x29C0;":"\\circle","&#x25E6;":"\\circle","&#x25D7;":"\\circle","&#x25D6;":"\\circle","&#x25CF;":"\\circle","&#x25CE;":"\\circledcirc","&#x25CD;":"\\circledcirc","&#x25CC;":"\\circledcirc","&#x25C9;":"\\circledcirc","&#x25C8;":"\\diamond","&#x25C7;":"\\diamond","&#x25C6;":"\\diamond","&#x25C5;":"\\triangleleft","&#x25C4;":"\\triangleleft","&#x25C3;":"\\triangleleft","&#x25C2;":"\\triangleleft","&#x25C1;":"\\triangleleft","&#x25C0;":"\\triangleleft","&#x25BF;":"\\triangledown","&#x25BE;":"\\triangledown","&#x25BD;":"\\triangledown","&#x25BC;":"\\triangledown","&#x25B9;":"\\triangleright","&#x25B8;":"\\triangleright","&#x25B7;":"\\triangleright","&#x25B6;":"\\triangleright","&#x25B5;":"\\triangle","&#x25B4;":"\\triangle","&#x25B3;":"\\triangle","&#x25B1;":"\\square","&#x25B0;":"\\square","&#x25AF;":"\\square","&#x25AE;":"\\square","&#x25AD;":"\\square","&#x25AB;":"\\square","&#x25AA;":"\\square","&#x25A1;":"\\square","&#x25A0;":"\\square","&#x22ED;":"\\not\\triangleright","&#x22EC;":"\\not\\triangleleft","&#x22EB;":"\\not\\triangleright","&#x22EA;":"\\not\\triangleleft","&#x22D9;":"\\ggg","&#x22D8;":"\\lll","&#x22D7;":"*>","&#x22D6;":"<*","&#x22D4;":"\\pitchfork","&#x22CC;":"","&#x22CB;":"","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#x22B5;":"\\triangleright","&#x22B4;":"","&#x22A5;":"\\bot","&#x2281;":"\\nsucc","&#x2280;":"\\preceq","&#x227D;":"\\succeq","&#x227C;":"\\preceq","&#x227B;":"\\succ","&#x227A;":"\\prec","&#x2271;":"\\geq/","&#x2270;":"\\leq/","&#x226D;":"\\neq","&#x226B;&#x338;":"\\not\\gg","&#x226B;":"\\gg","&#x226A;&#x338;":"\\not\\ll","&#x226A;":"\\ll","&#x2269;":"\\ngeqslant","&#x2268;":"\\nleqslant","&#x2261;":"\\equiv","&#x225F;":"\\doteq","&#x225C;":"\\triangleq","&#x225B;":"\\doteq","&#x225A;":"\\triangleq","&#x2259;":"\\triangleq","&#x2257;":"\\doteq","&#x2254;":":=","&#x224D;":"\\asymp","&#x2247;":"\\ncong","&#x2246;":"\\ncong","&#x2245;":"\\cong","&#x2244;":"\\not\\simeq","&#x2243;":"\\simeq","&#x2241;":"\\not\\sim","&#x2226;":"\\not\\parallel","&#x2225;":"\\parallel","&#x2224;":"\\not|","&#x221D;":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","&#x2260;":"\\neq","&#x2262;":"\\equiv /","&#x2249;":"\\approx /","&#x223C;":"sim","&#x2248;":"\\approx","&#x226E;":"</","&lt;":"<","&#x226F;":">/",">=":">=",">":">","&#x2265;":"\\geq","&#x2264;":"\\leq","&lt;=":"<=","&#x228B;":"\\supsetneq","&#x228A;":"\\subsetneq","&#x2289;":"\\nsupseteq","&#x2288;":"\\nsubseteq","&#x2287;":"\\supseteq","&#x2286;":"\\subseteq","&#x2285;":"\\not\\supset","&#x2284;":"\\not\\subset","&#x2283;&#x20D2;":"\\supset |","&#x2283;":"\\supset","&#x2282;&#x20D2;":"\\subset |","&#x2282;":"\\subset","&#x220C;":"\\not\\in","&#x2209;":"\\notin","&#x2208;":"\\in","&#x2201;":"C","&#x2204;":"\\nexists","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x2227;":"\\land","&amp;&amp;":"\\&\\&","&#x2228;":"\\lor","&#x22AF;":"\\cancel{\\vDash}","&#x22AE;":"\\cancel{\\Vdash}","&#x22AD;":"\\nvDash","&#x22AC;":"\\nvDash","&#x22A9;":"\\Vdash","&#x22A8;":"\\vDash","&#x22A4;":"\\top","&#x22A3;":"\\dashv","&#x22A2;":"\\vdash","&#x220B;":"\\ni","&#x22F1;":"\\ddots","&#x22EF;":"\\hdots","&#x22EE;":"\\vdots","&#x2026;":"\\hdots","&#x3F6;":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","&#x2235;":"\\because","&#x2234;":"\\therefore ","&#x2063;":"",",":",",";":";","&#x29FD;":"\\}","&#x29FC;":"\\{","&#x2998;":"\\]","&#x2997;":"\\[","&#x2996;":"\\ll","&#x2995;":"\\gg","&#x2994;":"\\gg","&#x2993;":"\\ll","&#x2992;":"\\gg","&#x2991;":"\\ll","&#x2990;":"\\]","&#x298F;":"\\]","&#x298E;":"\\]","&#x298D;":"\\[","&#x298C;":"\\[","&#x298B;":"\\]","&#x298A;":"\\triangleright","&#x2989;":"\\triangleleft","&#x2988;":"|\\)","&#x2987;":"\\(|","&#x2986;":"|\\)","&#x2985;":"\\(\\(","&#x2984;":"|\\}","&#x2983;":"\\{|","&#x2980;":"\\||","&#x27EF;":"\\left. \\right]","&#x27EE;":"\\left[ \\right.","&#x27ED;":"\\left. \\right]]","&#x27EC;":"\\left[[ \\right.","&#x27EB;":"\\gg","&#x27EA;":"\\ll","&#x27E9;":"\\rangle","&#x27E8;":"\\langle","&#x27E7;":"\\left. \\right]]","&#x27E6;":"\\left[[ \\right.","&#x2773;":"\\left.\\right)","&#x2772;":"\\left(\\right.","&#x232A;":"\\rangle","&#x2329;":"\\langle","&#x230B;":"\\rfloor","&#x230A;":"\\lfloor","&#x2309;":"\\rceil","&#x2308;":"\\lceil","&#x2016;":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","&#x201D;":'"',"&#x201C;":"``","&#x2019;":"'","&#x2018;":"`","%CE%B1":"\\alpha","%CE%B2":"\\beta","%CE%B3":"\\gamma","%CE%93":"\\Gamma","%CE%B4":"\\delta","%CE%94":"\\Delta","%CF%B5":"\\epsilon","%CE%B6":"\\zeta","%CE%B7":"\\eta","%CE%B8":"\\theta","%CE%98":"\\Theta","%CE%B9":"\\iota","%CE%BA":"\\kappa","%CE%BB":"\\lambda","%CE%BC":"\\mu","%CE%BD":"\\nu","%CE%BF":"\\omicron","%CF%80":"\\pi","%CE%A0":"\\Pi","%CF%81":"\\pho","%CF%83":"\\sigma","%CE%A3":"\\Sigma","%CF%84":"\\tau","%CF%85":"\\upsilon","%CE%A5":"\\Upsilon","%CF%95":"\\phi","%CE%A6":"\\Phi","%CF%87":"\\chi","%CF%88":"\\psi","%CE%A8":"\\Psi","%CF%89":"\\omega","%CE%A9":"\\Omega"}},9039:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathOperatorsByGlyph=void 0,t.allMathOperatorsByGlyph={_:"\\underline","⏡":"\\underbrace","⏠":"\\overbrace","⏟":"\\underbrace","⏞":"\\overbrace","⏝":"\\underbrace","⏜":"\\overbrace","⎵":"\\underbrace","⎴":"\\overbrace","⃜":"\\square","⃛":"\\square","⁤":"","⁗":"''''","‾":"\\overline","‷":"```","‶":"``","‵":"`","‴":"'''","″":"''","‟":"``","„":",,","‛":"`","‚":",","^":"\\hat","˷":"\\sim","˝":"\\sim","˜":"\\sim","˚":"\\circ","˙":"\\cdot","˘":" ",ˍ:"\\_",ˋ:"ˋ",ˊ:"ˊ",ˉ:"ˉ",ˇ:"",ˆ:"\\hat",º:"o","¹":"1","¸":",","´":"´","³":"3","²":"2","°":"\\circ","¯":"\\bar",ª:"a","↛":"\\nrightarrow","¨":"\\cdot\\cdot","~":"\\sim","`":"`","--":"--","++":"++","&":"\\&","∜":"\\sqrt[4]{}","∛":"\\sqrt[3]{}","√":"\\sqrt{}",ⅆ:"d",ⅅ:"\\mathbb{D}","?":"?","@":"@","//":"//","!!":"!!","!":"!","♯":"\\#","♮":"","♭":"","′":"'","<>":"<>","**":"\\star\\star","∇":"\\nabla","∂":"\\partial","⊙":"\\bigodot","¬":"\\neg","∢":"\\measuredangle","∡":"\\measuredangle","∠":"\\angle","÷":"\\div","/":"/","∖":"\\backslash","\\":"\\backslash","%":"\\%","⊗":"\\bigotimes","·":"\\cdot","⨿":"\\coprod","⨯":"\\times","⋅":"\\cdot","⊡":"\\boxdot","⊠":"\\boxtimes","⁢":"","⁃":"-","•":"\\cdot",".":".","*":"\\star","∪":"\\cup","∩":"\\cap","∐":"\\coprod","∏":"\\prod","≀":"","⫿":"","⫼":"\\mid\\mid\\mid","⨉":"\\times","⨈":"","⨇":"","⨆":"\\sqcup","⨅":"\\sqcap","⨂":"\\otimes","⨀":"\\odot","⋂":"\\cap","⋁":"\\vee","⋀":"\\wedge","⨄":"\\uplus","⨃":"\\cup","⋃":"\\cup","⨜":"\\underline{\\int}","⨛":"\\overline{\\int}","⨚":"\\int","⨙":"\\int","⨘":"\\int","⨗":"\\int","⨖":"\\oint","⨕":"\\oint","⨔":"\\int","⨓":"\\int","⨒":"\\int","⨑":"\\int","⨐":"\\int","⨏":"\\bcancel{\\int}","⨎":"","⨍":"\\hcancel{\\int}","⨌":"\\iiiint","∳":"\\oint","∲":"\\oint","∱":"\\int","∰":"\\oiint","∯":"\\oiint","∮":"\\oint","∫":"\\int","⨁":"\\oplus","⊘":"\\oslash","⊖":"\\ominus","⊕":"\\oplus","∭":"\\iiint","∬":"\\iint","⨋":"","⨊":"","∑":"\\sum","⊟":"\\boxminus","⊞":"\\boxplus","∔":"\\dot{+}","∓":"+-","−":"-","±":"\\pm","-":"-","+":"+","⭆":"\\Rrightarrow","⭅":"\\Lleftarrow","⧴":":\\rightarrow","⧯":"","⧟":"\\bullet-\\bullet","⦟":"\\angle","⦞":"\\measuredangle","⦝":"\\measuredangle","⦜":"\\perp","⦛":"\\measuredangle","⦚":"","⦙":"\\vdots","⥿":"","⥾":"","⥽":"\\prec","⥼":"\\succ","⥻":"\\underset{\\rightarrow}{\\supset}","⥺":"","⥹":"\\underset{\\rightarrow}{\\subset}","⥸":"\\underset{\\rightarrow}{>}","⥷":"","⥶":"\\underset{\\leftarrow}{<}","⥵":"\\underset{\\approx}{\\rightarrow}","⥴":"\\underset{\\sim}{\\rightarrow}","⥳":"\\underset{\\sim}{\\leftarrow}","⥲":"\\overset{\\sim}{\\rightarrow}","⥱":"\\overset{=}{\\rightarrow}","⥰":"","⥯":"","⥮":"","⥭":"\\overline{\\rightharpoondown}","⥬":"\\underline{\\rightharpoonup}","⥫":"\\overline{\\leftharpoondown}","⥪":"\\underline{\\leftharpoonup}","⥩":"\\rightleftharpoons","⥨":"\\rightleftharpoons","⥧":"\\rightleftharpoons","⥦":"\\rightleftharpoons","⥥":"\\Downarrow","⥤":"\\Rightarrow","⥣":"\\Uparrow","⥢":"\\Leftarrow","⥡":"\\downarrow","⥠":"\\uparrow","⥟":"\\rightarrow","⥞":"\\leftarrow","⥝":"\\downarrow","⥜":"\\uparrow","⥛":"\\rightarrow","⥚":"\\leftarrow","⥙":"\\downarrow","⥘":"\\uparrow","⥗":"\\rightarrow","⥖":"\\leftarrow","⥕":"\\downarrow","⥔":"\\uparrow","⥓":"\\rightarrow","⥒":"\\leftarrow","⥑":"\\updownarrow","⥐":"\\leftrightarrow","⥏":"\\updownarrow","⥎":"\\leftrightarrow","⥍":"\\updownarrow","⥌":"\\updownarrow","⥋":"\\leftrightarrow","⥊":"\\leftrightarrow","⥉":"","⥈":"\\leftrightarrow","⥇":"\\nrightarrow","⥆":"","⥅":"","⥄":"\\rightleftarrows","⥃":"\\leftrightarrows","⥂":"\\rightleftarrows","⥁":"\\circlearrowright","⥀":"\\circlearrowleft","⤿":"\\rightarrow","⤾":"\\leftarrow","⤽":"\\leftarrow","⤼":"\\rightarrow","⤻":"\\rightarrow","⤺":"\\leftarrow","⤹":"\\downarrow","⤸":"\\downarrow","⤷":"\\Rsh","⤶":"\\Lsh","⤵":"\\downarrow","⤴":"\\uparrow","⤳":"\\rightarrow","⤲":"\\leftarrow","⤱":" ","⤰":" ","⤯":" ","⤮":" ","⤭":" ","⤬":"\\times","⤫":"\\times","⤪":" ","⤩":" ","⤨":" ","⤧":" ","⤦":" ","⤥":" ","⤤":" ","⤣":" ","⤢":" ","⤡":" ","⤠":"\\mapsto\\cdot","⤟":"\\cdot\\leftarrow","⤞":"\\rightarrow\\cdot","⤝":"\\leftarrow","⤜":"\\rightarrow","⤛":"\\leftarrow","⤚":"\\rightarrow","⤙":"\\leftarrow","⤘":"\\rightarrow","⤗":"\\rightarrow","⤖":"\\rightarrow","⤕":"\\rightarrow","⤔":"\\rightarrow","⤓":"\\downarrow","⤒":"\\uparrow","⤑":"\\rightarrow","⤐":"\\rightarrow","⤏":"\\rightarrow","⤎":"\\leftarrow","⤍":"\\rightarrow","⤌":"\\leftarrow","⤋":"\\Downarrow","⤊":"\\Uparrow","⤉":"\\uparrow","⤈":"\\downarrow","⤇":"\\Rightarrow","⤆":"\\Leftarrow","⤅":"\\mapsto","⤄":"\\nLeftrightarrow","⤃":"\\nRightarrow","⤂":"\\nLeftarrow","⤁":"\\rightsquigarrow","⤀":"\\rightsquigarrow","⟿":"\\rightsquigarrow","⟾":"\\Rightarrow","⟽":"\\Leftarrow","⟼":"\\mapsto","⟻":"\\leftarrow","⟺":"\\Longleftrightarrow","⟹":"\\Longrightarrow","⟸":"\\Longleftarrow","⟷":"\\leftrightarrow","⟶":"\\rightarrow","⟵":"\\leftarrow","⟱":"\\Downarrow","⟰":"\\Uparrow","⊸":"\\rightarrow","⇿":"\\leftrightarrow","⇾":"\\rightarrow","⇽":"\\leftarrow","⇼":"\\nleftrightarrow","⇻":"\\nrightarrow","⇺":"\\nleftarrow","⇹":"\\nleftrightarrow","⇸":"\\nrightarrow","⇷":"\\nleftarrow","⇶":"\\Rrightarrow","⇵":"","⇴":"\\rightarrow","⇳":"\\Updownarrow","⇲":"\\searrow","⇱":"\\nwarrow","⇰":"\\Leftarrow","⇯":"\\Uparrow","⇮":"\\Uparrow","⇭":"\\Uparrow","⇬":"\\Uparrow","⇫":"\\Uparrow","⇪":"\\Uparrow","⇩":"\\Downarrow","⇨":"\\Rightarrow","⇧":"\\Uparrow","⇦":"\\Leftarrow","⇥":"\\rightarrow","⇤":"\\leftarrow","⇣":"\\downarrow","⇢":"\\rightarrow","⇡":"\\uparrow","⇠":"\\leftarrow","⇟":"\\downarrow","⇞":"\\uparrow","⇝":"\\rightsquigarrow","⇜":"\\leftarrow","⇛":"\\Rrightarrow","⇚":"\\Lleftarrow","⇙":"\\swarrow","⇘":"\\searrow","⇗":"\\nearrow","⇖":"\\nwarrow","⇕":"\\Updownarrow","⇔":"\\Leftrightarrow","⇓":"\\Downarrow","⇒":"\\Rightarrow","⇑":"\\Uparrow","⇐":"\\Leftarrow","⇏":"\\nRightarrow","⇎":"\\nLeftrightarrow","⇍":"\\nLeftarrow","⇌":"\\rightleftharpoons","⇋":"\\leftrightharpoons","⇊":"\\downdownarrows","⇉":"\\rightrightarrows","⇈":"\\upuparrows","⇇":"\\leftleftarrows","⇆":"\\leftrightarrows","⇅":"","⇄":"\\rightleftarrows","⇃":"\\downharpoonleft","⇂":"\\downharpoonright","⇁":"\\rightharpoondown","⇀":"\\rightharpoonup","↿":"\\upharpoonleft","↾":"\\upharpoonright","↽":"\\leftharpoondown","↼":"\\leftharpoonup","↻":"\\circlearrowright","↺":"\\circlearrowleft","↹":"\\leftrightarrows","↸":"\\overline{\\nwarrow}","↷":"\\curvearrowright","↶":"\\curvearrowleft","↵":"\\swarrow","↴":"\\searrow","↳":"\\Rsh","↲":"\\Lsh","↱":"\\Rsh","↰":"\\Lsh","↯":"\\swarrow","↮":"","↭":"\\leftrightsquigarrow","↬":"\\looparrowright","↫":"\\looparrowleft","↪":"\\hookrightarrow","↩":"\\hookleftarrow","↨":"\\underline{\\updownarrow}","↧":"\\downarrow","↦":"\\rightarrowtail","↥":"\\uparrow","↤":"\\leftarrowtail","↣":"\\rightarrowtail","↢":"\\leftarrowtail","↡":"\\downarrow","↠":"\\twoheadrightarrow","↟":"\\uparrow","↞":"\\twoheadleftarrow","↝":"\\nearrow","↜":"\\nwarrow","↚":"","↙":"\\swarrow","↘":"\\searrow","↗":"\\nearrow","↖":"\\nwarrow","↕":"\\updownarrow","↔":"\\leftrightarrow","↓":"\\downarrow","→":"\\rightarrow","↑":"\\uparrow","←":"\\leftarrow","|||":"\\left|||\\right.","||":"\\left||\\right.","|":"\\mid","⫾":"","⫽":"//","⫻":"///","⫺":"","⫹":"","⫸":"","⫷":"","⫶":"\\vdots","⫵":"","⫴":"","⫳":"","⫲":"\\nparallel","⫱":"","⫰":"","⫯":"","⫮":"\\bcancel{\\mid}","⫭":"","⫬":"","⫫":"","⫪":"","⫩":"","⫨":"\\underline{\\perp}","⫧":"\\overline{\\top}","⫦":"","⫥":"","⫤":"","⫣":"","⫢":"","⫡":"","⫠":"\\perp","⫟":"\\top","⫞":"\\dashv","⫝̸":"","⫝":"","⫛":"\\pitchfork","⫚":"","⫙":"","⫘":"","⫗":"","⫖":"","⫕":"","⫔":"","⫓":"","⫒":"","⫑":"","⫐":"","⫏":"","⫎":"","⫍":"","⫌":"\\underset{\\neq}{\\supset}","⫋":"\\underset{\\neq}{\\subset}","⫊":"\\underset{\\approx}{\\supset}","⫉":"\\underset{\\approx}{\\subset}","⫈":"\\underset{\\sim}{\\supset}","⫇":"\\underset{\\sim}{\\subset}","⫆":"\\supseteqq","⫅":"\\subseteqq","⫄":"\\dot{\\supseteq}","⫃":"\\dot{\\subseteq}","⫂":"\\underset{\\times}{\\supset}","⫁":"\\underset{\\times}{\\subset}","⫀":"\\underset{+}{\\supset}","⪿":"\\underset{+}{\\subset}","⪾":"","⪽":"","⪼":"\\gg ","⪻":"\\ll","⪺":"\\underset{\\cancel{\\approx}}{\\succ}","⪹":"\\underset{\\cancel{\\approx}}{\\prec}","⪸":"\\underset{\\approx}{\\succ}","⪷":"\\underset{\\approx}{\\prec}","⪶":"\\underset{\\cancel{=}}{\\succ}","⪵":"\\underset{\\cancel{=}}{\\prec}","⪴":"\\underset{=}{\\succ}","⪳":"\\underset{=}{\\prec}","⪲":"","⪱":"","⪮":"","⪭":"\\underline{\\hcancel{>}}","⪬":"\\underline{\\hcancel{>}}","⪫":"\\hcancel{>}","⪪":"\\hcancel{<}","⪩":"","⪨":"","⪧":"\\vartriangleright","⪦":"\\vartriangleleft","⪥":"><","⪤":"><","⪣":"\\underline{\\ll}","⪢̸":"\\cancel{\\gg}","⪢":"\\gg","⪡̸":"\\cancel{\\ll}","⪡":"\\ll","⪠":"\\overset{\\sim}{\\geqq}","⪟":"\\overset{\\sim}{\\leqq}","⪞":"\\overset{\\sim}{>}","⪝":"\\overset{\\sim}{<}","⪜":"","⪛":"","⪚":"\\overset{=}{>}","⪙":"\\overset{=}{<}","⪘":"","⪗":"","⪖":"","⪕":"","⪔":"","⪓":"","⪒":"\\underset{=}{\\gtrless}","⪑":"\\underset{=}{\\lessgtr}","⪐":"\\underset{<}{\\gtrsim}","⪏":"\\underset{>}{\\lesssim}","⪎":"\\underset{\\simeq}{>}","⪍":"\\underset{\\simeq}{<}","⪌":"\\gtreqqless","⪋":"\\lesseqqgtr","⪊":"\\underset{\\cancel{\\approx}}{>}","⪉":"\\underset{\\approx}{<}","⪆":"\\underset{\\approx}{>}","⪅":"\\underset{\\approx}{<}","⪄":"","⪃":"","⪂":"","⪁":"","⪀":"","⩿":"","⩾̸":"\\bcancel{\\geq}","⩾":"\\geq","⩽̸":"\\bcancel{\\leq}","⩽":"\\leq","⩼":"","⩻":"","⩺":"","⩹":"","⩸":"\\overset{\\dots}{\\equiv}","⩷":"","⩶":"===","⩵":"==","⩴":"::=","⩳":"","⩲":"\\underset{=}{+}","⩱":"\\overset{=}{+}","⩰":"\\overset{\\approx}{=}","⩯":"\\overset{\\wedge}{=}","⩮":"\\overset{*}{=}","⩭":"\\dot{\\approx}","⩬":"","⩫":"","⩪":"\\dot{\\sim}","⩩":"","⩨":"","⩧":"\\dot{\\equiv}","⩦":"\\underset{\\cdot}{=}","⩥":"","⩤":"","⩣":"\\underset{=}{\\vee}","⩢":"\\overset{=}{\\vee}","⩡":"ul(vv)","⩠":"\\underset{=}{\\wedge}","⩟":"\\underline{\\wedge}","⩞":"\\overset{=}{\\wedge}","⩝":"\\hcancel{\\vee}","⩜":"\\hcancel{\\wedge}","⩛":"","⩚":"","⩙":"","⩘":"\\vee","⩗":"\\wedge","⩖":"","⩕":"","⩔":"","⩓":"","⩒":"\\dot{\\vee}","⩑":"\\dot{\\wedge}","⩐":"","⩏":"","⩎":"","⩍":"\\overline{\\cap}","⩌":"\\overline{\\cup}","⩋":"","⩊":"","⩉":"","⩈":"","⩇":"","⩆":"","⩅":"","⩄":"","⩃":"\\overline{\\cap}","⩂":"\\overline{\\cup}","⩁":"","⩀":"","⨾":"","⨽":"\\llcorner","⨼":"\\lrcorner","⨻":"","⨺":"","⨹":"","⨸":"","⨷":"","⨶":"\\hat{\\otimes}","⨵":"","⨴":"","⨳":"","⨲":"\\underline{\\times}","⨱":"\\underline{\\times}","⨰":"\\dot{\\times}","⨮":"\\bigodot","⨭":"\\bigodot","⨬":"","⨫":"","⨪":"","⨩":"","⨨":"","⨧":"","◻":"\\Box","⨦":"\\underset{\\sim}{+}","⨥":"\\underset{\\circ}{+}","⨤":"\\overset{\\sim}{+}","⨣":"\\hat{+}","⨢":"\\dot{+}","⨡":"\\upharpoonright","⨠":">>","⨟":"","⨞":"\\triangleleft","⨝":"\\bowtie","⧿":"","⧾":"+","⧻":"\\hcancel{|||}","⧺":"\\hcancel{||}","⧹":"\\backslash","⧸":"/","⧷":"hcancel{\backslash}","⧶":"","⧵":"\\backslash","⧲":"\\Phi","⧱":"","⧰":"","⧮":"","⧭":"","⧬":"","⧫":"\\lozenge","⧪":"","⧩":"","⧨":"","⧧":"\\ddagger","⧢":"\\sqcup\\sqcup","⧡":"","⧠":"\\square","⧞":"","⧝":"","⧜":"","⧛":"\\{\\{","⧙":"\\{","⧘":"\\}","⧗":"","⧖":"","⧕":"\\bowtie","⧔":"\\bowtie","⧓":"\\bowtie","⧒":"\\bowtie","⧑":"\\bowtie","⧐̸":"| \\not\\triangleright","⧐":"| \\triangleright","⧏̸":"\\not\\triangleleft |","⧏":"\\triangleleft |","⧎":"","⧍":"\\triangle","⧌":"","⧋":"\\underline{\\triangle}","⧊":"\\dot{\\triangle}","⧉":"","⧈":"\\boxed{\\circ}","⧇":"\\boxed{\\circ}","⧆":"\\boxed{\\rightarrow}","⧅":"\\bcancel{\\square}","⧄":"\\cancel{\\square}","⧃":"\\odot","⧂":"\\odot","⦿":"\\odot","⦾":"\\odot","⦽":"\\varnothing","⦼":"\\oplus","⦻":"\\otimes","⦺":"","⦹":"\\varnothing","⦸":"\\varnothing","⦷":"\\ominus","⦶":"\\ominus","⦵":"\\ominus","⦴":"\\vec{\\varnothing}","⦳":"\\vec{\\varnothing}","⦲":"\\dot{\\varnothing}","⦱":"\\overline{\\varnothing}","⦰":"\\varnothing","⦯":"\\measuredangle","⦮":"\\measuredangle","⦭":"\\measuredangle","⦬":"\\measuredangle","⦫":"\\measuredangle","⦪":"\\measuredangle","⦩":"\\measuredangle","⦨":"\\measuredangle","⦧":"","⦦":"","⦥":"","⦤":"","⦣":"\\ulcorner","⦢":"\\measuredangle","⦡":"\\not\\lor","⦠":"\\bcancel{>}","⦂":":","⦁":"\\cdot","❘":"\\mid","▲":"\\bigtriangleup","⋿":"\\Epsilon","⋾":"\\overline{\\ni}","⋽":"\\overline{\\ni}","⋼":"\\in","⋻":"\\in","⋺":"\\in","⋹":"\\underline{\\in}","⋸":"\\underline{\\in}","⋷":"\\overline{\\in}","⋶":"\\overline{\\in}","⋵":"\\dot{\\in}","⋴":"\\in","⋳":"\\in","⋲":"\\in","⋰":"\\ddots","։":":","⋩":"\\underset{\\sim}{\\succ}","⋨":"\\underset{\\sim}{\\prec}","⋧":"\\underset{\\not\\sim}{>}","⋦":"\\underset{\\not\\sim}{<}","⋥":"\\not\\sqsupseteq","⋤":"\\not\\sqsubseteq","⋣":"\\not\\sqsupseteq","⋢":"\\not\\sqsubseteq","⋡":"\\nsucc","⋠":"\\nprec","⋟":"\\succ","⋞":"\\prec","⋝":"\\overline{>}","⋜":"\\overline{<}","⋛":"\\underset{>}{\\leq}","⋚":"\\underset{<}{\\geq}","⋕":"\\#","⋓":"\\cup","⋒":"\\cap","⋑":"\\supset","⋐":"\\subset","⋏":"\\wedge","⋎":"\\vee","⋍":"\\simeq","⋈":"\\Join","⋇":"\\ast","⋆":"\\star","⋄":"\\diamond","⊿":"\\triangle","⊾":"\\measuredangle","⊽":"\\overline{\\lor}","⊼":"\\overline{\\land}","⊻":"\\underline{\\lor}","⊺":"\\top",土:"\\pm",十:"+","⊹":"","⊷":"\\circ\\multimap","⊶":"\\circ\\multimap","⊳":"\\triangleright","⊲":"\\triangleleft","⊱":"\\succ","⊰":"\\prec","⊫":"|\\models","⊪":"|\\models","⊧":"\\models","⊦":"\\vdash","⊝":"\\ominus","⊜":"\\ominus","⊛":"\\odot","⊚":"\\odot","⊔":"\\sqcup","⊓":"\\sqcap","⊒":"\\sqsupseteq","⊑":"\\sqsubseteq","⊐̸":"\\not\\sqsupset","⊐":"\\sqsupset","⊏̸":"\\not\\sqsubset","⊏":"\\sqsubset","⊎":"\\cup","⊍":"\\cup","⊌":"\\cup","≿̸":"\\not\\succsim","≿":"\\succsim","≾":"\\precsim","≹":"\\not\\overset{>}{<}","≸":"\\not\\overset{>}{<}","≷":"\\overset{>}{<}","≶":"\\overset{<}{>}","≵":"\\not\\geg","≴":"\\not\\leq","≳":"\\geg","≲":"\\leq","≬":"","≧":"\\geg","≦̸":"\\not\\leq","≦":"\\leq","≣":"\\overset{=}{=} ","≞":"\\overset{m}{=} ","≝":"\\overset{def}{=}","≘":"=","≖":"=","≕":"=:","≓":"\\doteq","≒":"\\doteq","≑":"\\doteq","≐":"\\doteq","≏̸":"","≏":"","≎̸":"","≎":"","≌":"\\approx","≋":"\\approx","≊":"\\approx","≂̸":"\\neq","≂":"=","∿":"\\sim","∾":"\\infty","∽̱":"\\sim","∽":"\\sim","∻":"\\sim","∺":":-:","∹":"-:","∸":"\\bot","∷":"::","∶":":","∣":"\\mid","∟":"\\llcorner","∘":"\\circ","∗":"*","∕":"/","∎":"\\square","∍":"\\ni","∊":"\\in","∆":"\\Delta","⁄":"/","⪰̸":"\\nsucceq","⪰":"\\succeq","⪯̸":"\\npreceq","⪯":"\\preceq","⪈":"\\ngeqslant","⪇":"\\nleqslant","⧳":"\\Phi","⧦":"\\models","⧥":"\\not\\equiv","⧤":"\\approx\\neq","⧣":"\\neq","⧁":"\\circle","⧀":"\\circle","◦":"\\circle","◗":"\\circle","◖":"\\circle","●":"\\circle","◎":"\\circledcirc","◍":"\\circledcirc","◌":"\\circledcirc","◉":"\\circledcirc","◈":"\\diamond","◇":"\\diamond","◆":"\\diamond","◅":"\\triangleleft","◄":"\\triangleleft","◃":"\\triangleleft","◂":"\\triangleleft","◁":"\\triangleleft","◀":"\\triangleleft","▿":"\\triangledown","▾":"\\triangledown","▽":"\\triangledown","▼":"\\triangledown","▹":"\\triangleright","▸":"\\triangleright","▷":"\\triangleright","▶":"\\triangleright","▵":"\\triangle","▴":"\\triangle","△":"\\triangle","▱":"\\square","▰":"\\blacksquare","▯":"\\square","▮":"\\blacksquare","▭":"\\square","▫":"\\square","▪":"\\square","□":"\\square","■":"\\blacksquare","⋭":"\\not\\triangleright","⋬":"\\not\\triangleleft","⋫":"\\not\\triangleright","⋪":"\\not\\triangleleft","⋙":"\\ggg","⋘":"\\lll","⋗":"*>","⋖":"<*","⋔":"\\pitchfork","⋌":"","⋋":"\\bowtie","⋊":"\\ltimes","⋉":"\\rtimes","⊵":"\\triangleright","\\triangleleft":"","⊥":"\\bot","⊁":"\\nsucc","⊀":"\\preceq","≽":"\\succeq","≼":"\\preceq","≻":"\\succ","≺":"\\prec","≱":"\\geq/","≰":"\\leq/","≭":"\\neq","≫̸":"\\not\\gg","≫":"\\gg","≪̸":"\\not\\ll","≪":"\\ll","≩":"\\ngeqslant","≨":"\\nleqslant","≡":"\\equiv","≟":"\\doteq","≜":"\\triangleq","≛":"\\doteq","≚":"\\triangleq","≙":"\\triangleq","≗":"\\doteq","≔":":=","≍":"\\asymp","≇":"\\ncong","≆":"\\ncong","≅":"\\cong","≄":"\\not\\simeq","≃":"\\simeq","≁":"\\not\\sim","∦":"\\not\\parallel","∥":"\\parallel","∤":"\\not|","∝":"\\propto","==":"==","=":"=",":=":":=","/=":"=","-=":"-=","+=":"+=","*=":"*=","!=":"!=","≠":"\\neq","≢":"\\equiv /","≉":"\\approx /","∼":"sim","≈":"\\approx","≮":"</","<":"<","≯":">/",">=":">=",">":">","≥":"\\geq","≤":"\\leq","<=":"<=","⊋":"\\supsetneq","⊊":"\\subsetneq","⊉":"\\nsupseteq","⊈":"\\nsubseteq","⊇":"\\supseteq","⊆":"\\subseteq","⊅":"\\not\\supset","⊄":"\\not\\subset","⊃⃒":"\\supset |","⊃":"\\supset","⊂⃒":"\\subset |","⊂":"\\subset","∌":"\\not\\in","∉":"\\notin","∈":"\\in","∁":"C","∄":"\\nexists","∃":"\\exists","∀":"\\forall","∧":"\\land","&&":"\\&\\&","∨":"\\lor","⊯":"\\cancel{\\vDash}","⊮":"\\cancel{\\Vdash}","⊭":"\\nvDash","⊬":"\\nvDash","⊩":"\\Vdash","⊨":"\\vDash","⊤":"\\top","⊣":"\\dashv","⊢":"\\vdash","∋":"\\ni","⋱":"\\ddots","⋯":"\\hdots","⋮":"\\vdots","϶":"\\ni",":":":","...":"\\cdots","..":"..","->":"->","∵":"\\because","∴":"\\therefore ","⁣":"\\llbracket",",":",",";":";","⧽":"\\}","⧼":"\\{","⦘":"\\]","⦗":"\\[","⦖":"\\ll","⦕":"\\gg","⦔":"\\gg","⦓":"\\ll","⦒":"\\gg","⦑":"\\ll","⦐":"\\]","⦏":"\\]","⦎":"\\]","⦍":"\\[","⦌":"\\[","⦋":"\\]","⦊":"\\triangleright","⦉":"\\triangleleft","⦈":"|\\)","⦇":"\\(|","⦆":"|\\)","⦅":"\\(\\(","⦄":"|\\}","⦃":"\\{|","⦀":"\\||","⟯":"\\left. \\right]","⟮":"\\left[ \\right.","⟭":"\\left. \\right]]","⟬":"\\left[[ \\right.","⟫":"\\gg","⟪":"\\ll","⟧":"\\)|","⟦":"\\(|","❳":"\\left.\\right)","❲":"\\left(\\right.","〉":"\\rangle","〈":"\\langle","⌋":"\\rfloor","⌊":"\\lfloor","⌉":"\\rceil","⌈":"\\lceil","‖":"\\parallel","}":"\\left.\\right}","{":"\\left{\\right.","]":"\\left]\\right.","[":"\\left[\\right.",")":"\\left.\\right)","(":"\\left(\\right.","”":'\\"',"“":"\\text{``}","’":"'","‘":"`",α:"\\alpha",β:"\\beta",γ:"\\gamma",Γ:"\\Gamma",δ:"\\delta",Δ:"\\Delta",ϵ:"\\epsilon",ζ:"\\zeta",η:"\\eta",θ:"\\theta",Θ:"\\Theta",ι:"\\iota",κ:"\\kappa",λ:"\\lambda",ν:"\\nu",ο:"\\omicron",π:"\\pi",Π:"\\Pi",ρ:"\\rho",σ:"\\sigma",Σ:"\\Sigma",τ:"\\tau",υ:"\\upsilon",Υ:"\\Upsilon",ϕ:"\\phi",Φ:"\\Phi",χ:"\\chi",ψ:"\\psi",Ψ:"\\Psi",ω:"\\omega",Ω:"\\Omega",Ω:"\\Omega","∅":"\\emptyset","⟲":"\\circlearrowleft","⟳":"\\circlearrowright","×":"\\times","½":"\\dfrac{1}{2}",μ:"\\mu",Ө:"\\theta","✓":"\\checkmark","⟩":"\\rangle","⟨":"\\langle","¼":"\\dfrac{1}{4}","…":"\\ldots",ℏ:"\\hbar",ℜ:"\\mathfrak{R}",Ѳ:"\\theta",Ø:"\\emptyset",ϱ:"\\varrho",ф:"\\phi",ℇ:"\\varepsilon",T:"T","∙":"\\cdot",Ρ:"P","∞":"\\infty",ᐁ:"\\nabla",ƞ:"\\eta","⁺":"^{+}","⁻":"^{-}","⁼":"^{=}","⁽":"^{(}","⁾":"^{)}","〗":"\\)|","〖":"\\langle",";":";","൦":"\\circ","┴":"\\perp","✕":"\\times","⎻":"-","»":"\\gg","⬆":"\\uparrow","⬇":"\\downarrow","⬅":"\\leftarrow","➡":"\\rightarrow","⎼":"-","⎜":"\\mid","⎥":"\\mid",ħ:"\\hbar","⮕":"\\rightarrow","・":"\\cdot","¦":"\\mid","£":"\\pounds","¥":"\\yen","✗":"\\times","✔":"\\checkmark",ⁿ:"^{n}","«":"\\ll",เ:"\\prime","†":"\\dagger","│":"\\mid",$:"\\$","#":"\\#","℃":"\\text{\\textdegree C}","℉":"\\text{\\textdegree F}","█":"\\blacksquare","℧":"\\mho",ⅇ:"\\text{e}",ɼ:"r","‡":"\\ddagger",ἱ:"i",ϒ:"\\Upsilon",𝛿:"\\delta","˳":"\\cdot",ѳ:"\\theta",𝜙:"\\phi",П:"\\prod",о:"o",ђ:"\\hbar",Ʌ:"\\Lambda","।":"\\mid","€":"\\euro",ῡ:"\\bar{u}",φ:"\\varphi",ȼ:"c",𝞮:"\\epsilon",Χ:"\\mathsf{X}",ₙ:"_{n}"}},8249:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByChar=void 0,t.allMathSymbolsByChar={"&#xA0;":"\\textrm{ }","&#x2203;":"\\exists","&#x2200;":"\\forall","&#x21D4;":"\\iff","&#x21D2;":"=>","&#xAC;":"\\neg","&#x2124;":"\\mathbb{Z}","&#x211D;":"\\mathbb{R}","&#x211A;":"\\mathbb{Q}","&#x2115;":"\\mathbb{N}","&#x2102;":"CC","&#x25A1;":"\\square","&#x22C4;":"\\diamond","&#x25B3;":"\\triangle","&#x2322;":"\\frown","&#x2220;":"\\angle","&#x22F1;":"\\ddots","&#x22EE;":"\\vdots","&#x2235;":"\\because","&#x2234;":"\\therefore","&#x2135;":"\\aleph","&#x2205;":"\\oslash","&#xB1;":"\\pm","&#x2207;":"\\nabla","&#x2202;":"\\partial","&#x222E;":"\\oint","&#x222B;":"\\int","&#x22C3;":"\\cup","&#x222A;":"\\cup","&#x22C2;":"\\cap","&#x2229;":"\\cap","&#x22C1;":"\\vee","&#x2228;":"\\vee","&#x22C0;":"\\wedge","&#x2227;":"\\wedge","&#x220F;":"\\prod","&#x2211;":"\\sum","&#x2299;":"\\bigodot","&#x2297;":"\\bigoplus","&#x2295;":"o+","&#x2218;":"@","&#x22C8;":"\\bowtie","&#x22CA;":"\\rtimes","&#x22C9;":"\\ltimes","&#xF7;":"\\div","&#xD7;":"\\times","\\":"\\backslash","&#x22C6;":"\\star","&#x2217;":"\\star","&#x22C5;":"\\cdot","&#x3A9;":"\\Omega","&#x3C9;":"\\omega","&#x3A8;":"\\Psi","&#x3C8;":"\\psi","&#x3C7;":"\\chi","&#x3C6;":"\\varphi","&#x3A6;":"\\Phi","&#x3D5;":"\\phi","&#x3C5;":"\\upsilon","&#x3C4;":"\\tau","&#x3A3;":"\\Sigma","&#x3C3;":"\\sigma","&#x3C1;":"\\rho","&#x3A0;":"\\Pi","&#x3C0;":"\\pi","&#x39E;":"\\Xi","&#x3BE;":"\\xi","&#x3BD;":"\\nu","&#x3BC;":"\\mu","&#x39B;":"\\Lambda","&#x3BB;":"\\lambda","&#x3BA;":"\\kappa","&#x3B9;":"\\iota","&#x3D1;":"\\vartheta","&#x398;":"\\Theta","&#x3B8;":"\\theta","&#x3B7;":"\\eta","&#x3B6;":"\\zeta","&#x25B;":"\\varepsilon","&#x3B5;":"\\epsilon","&#x394;":"\\Delta","&#x3B4;":"\\delta","&#x393;":"\\Gamma","&#x3B3;":"\\gamma","&#x3B2;":"\\beta","&#x3B1;":"\\alpha","&#x221E;":"\\infty","‬":"\\text{\\textdir TRT}","‎":"\\text{\\textdir LTR}"}},8171:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allMathSymbolsByGlyph=void 0,t.allMathSymbolsByGlyph={" ":"\\textrm{ }","∃":"\\exists","∀":"\\forall","⇔":"\\iff","⇒":"\\Rightarrow","¬":"\\neg","□":"\\square","⋄":"\\diamond","△":"\\triangle","⌢":"\\frown","∠":"\\angle","⋱":"\\ddots","⋮":"\\vdots","∵":"\\because","∴":"\\therefore",ℵ:"\\aleph","∅":"\\emptyset","±":"\\pm","∇":"\\nabla","∂":"\\partial","∮":"\\oint","∫":"\\int","⋃":"\\cup","∪":"\\cup","⋂":"\\cap","∩":"\\cap","⋁":"\\vee","∨":"\\vee","⋀":"\\wedge","∧":"\\wedge","∏":"\\prod","∑":"\\sum","⊙":"\\bigodot","⊗":"\\bigoplus","⊕":"o+","∘":"@","⋈":"\\bowtie","⋊":"\\rtimes","⋉":"\\ltimes","÷":"\\div","×":"\\times","\\":"\\backslash","⋆":"\\star","∗":"\\star","⋅":"\\cdot",Ω:"\\Omega",ω:"\\omega",Ψ:"\\Psi",ψ:"\\psi",χ:"\\chi",φ:"\\varphi",Φ:"\\Phi",ϕ:"\\phi",υ:"\\upsilon",τ:"\\tau",Σ:"\\Sigma",σ:"\\sigma",ρ:"\\rho",Π:"\\Pi",π:"\\pi",Ξ:"\\Xi",ξ:"\\xi",ν:"\\nu",μ:"\\mu",Λ:"\\Lambda",λ:"\\lambda",κ:"\\kappa",ι:"\\iota",ϑ:"\\vartheta",Θ:"\\Theta",θ:"\\theta",η:"\\eta",ζ:"\\zeta",ɛ:"\\varepsilon",ε:"\\epsilon",Δ:"\\Delta",δ:"\\delta",Γ:"\\Gamma",γ:"\\gamma",β:"\\beta",α:"\\alpha","∞":"\\infty",ϵ:"\\epsilon",µ:"\\mu","²":"^{2}",ı:"\\imath","∎":"\\blacksquare",ม:"\\mathbf{m}",Ω:"\\Omega","⟲":"\\circlearrowleft","⟳":"\\circlearrowright",त:" ","¥":"\\yen","⁽":"^{(}","⁾":"^{)}",ß:"\\ss",Ћ:"\\hbar","⦵":"\\ominus","⊿":"\\bigtriangleup","↛'":"\\nrightarrow","†":"\\dagger",เ:"\\prime",白:" ","⿱":" ",ℸ:"\\wp",퓰:" ",ⁿ:"^{n}","✔":"\\checkmark","✗":"\\times","½":"\\dfrac{1}{2}",Ө:"\\theta","✓":"\\checkmark","⟩":"\\rangle","⟨":"\\langle","〈":"\\langle","¼":"\\dfrac{1}{4}","…":"\\ldots",ℏ:"\\hbar",ℜ:"\\mathfrak{R}",Ѳ:"\\theta",Ø:"\\emptyset",ϱ:"\\varrho",ф:"\\phi",T:"T","∙":"\\cdot",Ρ:"P",ᐁ:"\\nabla",ƞ:"\\eta",ɣ:"\\gamma",ћ:"\\hbar",Ɛ:"\\varepsilon",ⅅ:"\\_{D}",𝜆:"\\lambda","〗":"\\rangle","〖":"\\langle",";":";",𝑥:"x",𝑦:"y",𝑧:"z",𝑖:"i",𝑗:"j",𝑘:"k",𝑚:"m",𝑒:"e",𝑟:"r",ɳ:"\\eta",𝛽:"\\beta","⍵":"\\omega",℘:"\\wp",𝜋:"\\pi",Є:"\\epsilon",є:"\\epsilon",𝜀:"\\epsilon",п:"\\pi",Ν:"\\nu",ɵ:"\\theta",𝜓:"\\psi",ϴ:"\\theta",ɸ:"\\phi",Ӷ:"\\Gamma",ɭ:"\\ell",ʋ:"\\upsilon",𝛟:"\\varphi","⍬":"\\theta",Ф:"\\Phi",𝜑:"\\varphi",ⅈ:"i",ο:"o",ơ:"o",ƒ:"f","⍴":"\\rho","🇽":"x",𝑝:"p",𝑞:"q",𝑠:"s",𝑡:"t",𝑢:"u",𝑣:"v",𝑤:"w",𝑎:"a",𝑏:"b",𝑐:"c",𝑑:"d",𝑓:"f",𝑔:"g",𝑙:"l",𝑛:"n",𝑜:"o",𝔀:"w",𝚟:"v",ṁ:"m","൦":"\\circ","┴":"\\perp","✕":"\\times","∣":"\\mid",Փ:"\\Phi","⎜":"\\mid",ħ:"\\hbar",ፈ:" ","⦨":"\\llbracket",ế:"\\hat{e}","¢":"\\cent","⤹":"\\downarrow","⤸":"\\downarrow","⤷":"\\Rsh","⤶":"\\Lsh","⤵":"\\downarrow","⤴":"\\uparrow","⤳":"\\rightarrow","|":"\\mid","⎥":"\\mid","♥":"\\heartsuit",О:"0",Υ:"Y",х:"x",𝓏:"z",𝓎:"y",𝓍:"x",р:"p",а:"a","£":"\\pounds",m:"m",𝚵:"\\Xi","⓪":"\\textcircled{0}","①":"\\textcircled{1}","②":"\\textcircled{2}","③":"\\textcircled{3}","④":"\\textcircled{4}","⑤":"\\textcircled{5}","⑥":"\\textcircled{6}","⑦":"\\textcircled{7}","⑧":"\\textcircled{8}","⑨":"\\textcircled{9}","⑩":"\\textcircled{10}","⑪":"\\textcircled{11}","⑫":"\\textcircled{12}","⑬":"\\textcircled{13}","⑭":"\\textcircled{14}","⑮":"\\textcircled{15}","⑯":"\\textcircled{16}","⑰":"\\textcircled{17}","⑱":"\\textcircled{18}","⑲":"\\textcircled{19}","⑳":"\\textcircled{20}","㉑":"\\textcircled{21}","㉒":"\\textcircled{22}","㉓":"\\textcircled{23}","㉔":"\\textcircled{24}","㉕":"\\textcircled{25}","㉖":"\\textcircled{26}","㉗":"\\textcircled{27}","㉘":"\\textcircled{28}","㉙":"\\textcircled{29}","㉚":"\\textcircled{30}","㉛":"\\textcircled{31}","㉜":"\\textcircled{32}","㉝":"\\textcircled{33}","㉞":"\\textcircled{34}","㉟":"\\textcircled{35}","㊱":"\\textcircled{36}","㊲":"\\textcircled{37}","㊳":"\\textcircled{38}","㊴":"\\textcircled{39}","㊵":"\\textcircled{40}","㊶":"\\textcircled{41}","㊷":"\\textcircled{42}","㊸":"\\textcircled{43}","㊹":"\\textcircled{44}","㊺":"\\textcircled{45}","㊻":"\\textcircled{46}","㊼":"\\textcircled{47}","㊽":"\\textcircled{48}","㊾":"\\textcircled{49}","㊿":"\\textcircled{50}","&":"\\&","‖":"\\parallel","%":"\\%","“":"\\text{``}",$:"\\$","#":"\\#","℃":"\\text{\\textdegree C}","℉":"\\text{\\textdegree F}","█":"\\blacksquare","℧":"\\mho","⌋":"\\rfloor","⌊":"\\lfloor","⌉":"\\rceil","⌈":"\\lceil",ℇ:"\\varepsilon",ⅇ:"\\text{e}",ɼ:"r","↛":"\\nrightarrow",ˆ:"\\hat{}","‾":"\\overline","→":"\\rightarrow","‡":"\\ddagger","・":"\\cdot","▱":"\\square","∆":"\\Delta",ἱ:"i","∡":"\\angle",ϒ:"\\Upsilon","↓":"\\downarrow","↑":"\\uparrow","»":"\\gg","⊤":"\\top","⧸":"/",𝛿:"\\delta","˳":"\\cdot","։":":","⦪":"\\measuredangle","⦩":"\\measuredangle","⦫":"\\measuredangle","⦁":"\\cdot",ѳ:"\\theta","⦢":"\\measuredangle","¸":",","⎻":"\\overline","⟦":"\\llbracket",𝜙:"\\phi",П:"\\prod",о:"o","≈":"\\approx","≤":"\\leq",ђ:"\\hbar",Ʌ:"\\Lambda",土:"\\pm","⎼":"-",十:"+","≠":"\\neq","←":"\\leftarrow","।":"\\mid","€":"\\euro","˘":" ",ῡ:"\\bar{u}","∥":"\\parallel","↔":"\\leftrightarrow","√":"\\sqrt{}",ȼ:"c",𝞮:"\\epsilon","·":"\\cdot","⦬":"\\measuredangle","⦮":"\\measuredangle","⦭":"\\measuredangle","«":"\\ll",Χ:"\\mathsf{X}","│":"\\mid","〉":"\\rangle",ₙ:"_{n}","▫":"\\square","●":"\\circle","”":'\\"'}},5406:function(e,t,r){"use strict";var a=this&&this.__createBinding||(Object.create?function(e,t,r,a){void 0===a&&(a=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,a,n)}:function(e,t,r,a){void 0===a&&(a=r),e[a]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||a(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(2965),t),n(r(9039),t),n(r(8249),t),n(r(8171),t),n(r(472),t),n(r(4320),t),n(r(6122),t)},472:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.latexAccents=void 0,t.latexAccents=["\\hat","\\bar","\\underbrace","\\overbrace"]},4320:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mathNumberByGlyph=void 0,t.mathNumberByGlyph={"₀":"_{0}","₁":"_{1}","₂":"_{2}","₃":"_{3}","₄":"_{4}","₅":"_{5}","₆":"_{6}","₇":"_{7}","₈":"_{8}","₉":"_{9}","⁰":"^{0}","¹":"^{1}","²":"^{2}","³":"^{3}","⁴":"^{4}","⁵":"^{5}","⁶":"^{6}","⁷":"^{7}","⁸":"^{8}","⁹":"^{9}",ⁿ:"^{n}",ₙ:"_{n}","⓪":"\\textcircled{0}","①":"\\textcircled{1}","②":"\\textcircled{2}","③":"\\textcircled{3}","④":"\\textcircled{4}","⑤":"\\textcircled{5}","⑥":"\\textcircled{6}","⑦":"\\textcircled{7}","⑧":"\\textcircled{8}","⑨":"\\textcircled{9}","⑩":"\\textcircled{10}","⑪":"\\textcircled{11}","⑫":"\\textcircled{12}","⑬":"\\textcircled{13}","⑭":"\\textcircled{14}","⑮":"\\textcircled{15}","⑯":"\\textcircled{16}","⑰":"\\textcircled{17}","⑱":"\\textcircled{18}","⑲":"\\textcircled{19}","⑳":"\\textcircled{20}","㉑":"\\textcircled{21}","㉒":"\\textcircled{22}","㉓":"\\textcircled{23}","㉔":"\\textcircled{24}","㉕":"\\textcircled{25}","㉖":"\\textcircled{26}","㉗":"\\textcircled{27}","㉘":"\\textcircled{28}","㉙":"\\textcircled{29}","㉚":"\\textcircled{30}","㉛":"\\textcircled{31}","㉜":"\\textcircled{32}","㉝":"\\textcircled{33}","㉞":"\\textcircled{34}","㉟":"\\textcircled{35}","㊱":"\\textcircled{36}","㊲":"\\textcircled{37}","㊳":"\\textcircled{38}","㊴":"\\textcircled{39}","㊵":"\\textcircled{40}","㊶":"\\textcircled{41}","㊷":"\\textcircled{42}","㊸":"\\textcircled{43}","㊹":"\\textcircled{44}","㊺":"\\textcircled{45}","㊻":"\\textcircled{46}","㊼":"\\textcircled{47}","㊽":"\\textcircled{48}","㊾":"\\textcircled{49}","㊿":"\\textcircled{50}","½":"\\dfrac{1}{2}","⅓":"\\dfrac{1}{3}","⅔":"\\dfrac{2}{3}","¼":"\\dfrac{1}{4}","¾":"\\dfrac{3}{4}","⅕":"\\dfrac{1}{5}","⅖":"\\dfrac{2}{5}","⅗":"\\dfrac{3}{5}","⅘":"\\dfrac{4}{5}","⅙":"\\dfrac{1}{6}","⅚":"\\dfrac{5}{6}","⅐":"\\dfrac{1}{7}","⅛":"\\dfrac{1}{8}","⅜":"\\dfrac{3}{8}","⅝":"\\dfrac{5}{8}","⅞":"\\dfrac{7}{8}","⅑":"\\dfrac{1}{9}","⅒":"\\dfrac{1}{10}"}},6122:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.HashUTF8ToLtXConverter=void 0,t.HashUTF8ToLtXConverter=class{convert(e){if(e.match(/[a-z0-9]/i))return e;const t=r[e];if(t){return this.convertAccentCharToLtX(t)||e}return this.convertSpecialCharToLtX(e)||e}convertAccentCharToLtX(e){const{char:t,accent:r}=e,n=a[r];return n?`\\${n}{${t}}`:null}convertSpecialCharToLtX(e){const t=n[e];if(!t)return null;const{letter:r,fontCmd:a}=t;return`\\${a}{${r}}`}};const r={á:{char:"a",accent:"´"},à:{char:"a",accent:"`"},â:{char:"a",accent:"^"},ã:{char:"a",accent:"~"},ä:{char:"a",accent:"¨"},å:{char:"a",accent:"˚"},ą:{char:"a",accent:"˙"},ă:{char:"a",accent:"˘"},ǎ:{char:"a",accent:"ˇ"},ǟ:{char:"a",accent:"ˆ"},ǻ:{char:"a",accent:"˙"},ǡ:{char:"a",accent:"-"},ā:{char:"a",accent:"-"},é:{char:"e",accent:"´"},è:{char:"e",accent:"`"},ê:{char:"e",accent:"^"},ë:{char:"e",accent:"¨"},ę:{char:"e",accent:"˙"},ě:{char:"e",accent:"ˇ"},ȇ:{char:"i",accent:"^"},ё:{char:"e",accent:"¨"},ē:{char:"e",accent:"-"},í:{char:"i",accent:"´"},ì:{char:"i",accent:"`"},î:{char:"i",accent:"^"},ï:{char:"i",accent:"¨"},į:{char:"i",accent:"˙"},ǐ:{char:"i",accent:"ˇ"},ȉ:{char:"i",accent:"`"},ȋ:{char:"i",accent:"¨"},ī:{char:"i",accent:"-"},ó:{char:"o",accent:"´"},ò:{char:"o",accent:"`"},ô:{char:"o",accent:"^"},õ:{char:"o",accent:"~"},ö:{char:"o",accent:"¨"},ő:{char:"o",accent:"˝"},ǒ:{char:"o",accent:"ˇ"},ȍ:{char:"o",accent:"`"},ȏ:{char:"o",accent:"¨"},ȫ:{char:"o",accent:"˘"},ȭ:{char:"o",accent:"˝"},ȯ:{char:"o",accent:"˙"},ō:{char:"o",accent:"-"},ú:{char:"u",accent:"´"},ù:{char:"u",accent:"`"},û:{char:"u",accent:"^"},ü:{char:"u",accent:"¨"},ű:{char:"u",accent:"˝"},ǔ:{char:"u",accent:"ˇ"},ǖ:{char:"u",accent:"¨"},ǘ:{char:"u",accent:"¨"},ǚ:{char:"u",accent:"¨"},ǜ:{char:"u",accent:"¨"},ȕ:{char:"u",accent:"`"},ȗ:{char:"u",accent:"¨"},ū:{char:"u",accent:"-"},ý:{char:"y",accent:"´"},ỳ:{char:"y",accent:"`"},ŷ:{char:"y",accent:"^"},ÿ:{char:"y",accent:"¨"},ȳ:{char:"y",accent:"-"},Á:{char:"A",accent:"´"},À:{char:"A",accent:"`"},Â:{char:"A",accent:"^"},Ã:{char:"A",accent:"~"},Ä:{char:"A",accent:"¨"},Å:{char:"A",accent:"˚"},Å:{char:"A",accent:"˚"},Ȧ:{char:"A",accent:"˙"},Ă:{char:"A",accent:"˘"},Ǎ:{char:"A",accent:"ˇ"},Ǟ:{char:"A",accent:"˝"},Ǻ:{char:"A",accent:"˚"},Ǡ:{char:"A",accent:"-"},Ā:{char:"A",accent:"-"},É:{char:"E",accent:"´"},È:{char:"E",accent:"`"},Ė:{char:"E",accent:"˙"},Ê:{char:"E",accent:"^"},Ë:{char:"E",accent:"¨"},Ě:{char:"E",accent:"ˇ"},Ȅ:{char:"E",accent:"`"},Ȇ:{char:"E",accent:"¨"},Ē:{char:"E",accent:"-"},Í:{char:"I",accent:"´"},Ì:{char:"I",accent:"`"},Î:{char:"I",accent:"^"},Ï:{char:"I",accent:"¨"},Ĭ:{char:"I",accent:"˘"},Ǐ:{char:"I",accent:"ˇ"},Ȉ:{char:"I",accent:"`"},Ȋ:{char:"I",accent:"¨"},Ī:{char:"I",accent:"-"},Ó:{char:"O",accent:"´"},Ò:{char:"O",accent:"`"},Ô:{char:"O",accent:"^"},Õ:{char:"O",accent:"~"},Ö:{char:"O",accent:"¨"},Ő:{char:"O",accent:"˝"},Ǒ:{char:"O",accent:"ˇ"},Ȍ:{char:"O",accent:"`"},Ȏ:{char:"O",accent:"¨"},Ȫ:{char:"O",accent:"˘"},Ȭ:{char:"O",accent:"˝"},Ȯ:{char:"O",accent:"˙"},Ō:{char:"O",accent:"-"},Ú:{char:"U",accent:"´"},Ù:{char:"U",accent:"`"},Û:{char:"U",accent:"^"},Ü:{char:"U",accent:"¨"},Ű:{char:"U",accent:"˝"},Ǔ:{char:"U",accent:"ˇ"},Ǖ:{char:"U",accent:"¨"},Ȕ:{char:"U",accent:"`"},Ȗ:{char:"U",accent:"¨"},Ū:{char:"U",accent:"-"},Ý:{char:"Y",accent:"´"},Ỳ:{char:"Y",accent:"`"},Ŷ:{char:"Y",accent:"^"},Ÿ:{char:"Y",accent:"¨"},Ȳ:{char:"Y",accent:"-"},ñ:{char:"n",accent:"~"},Ñ:{char:"N",accent:"~"},ç:{char:"c",accent:"˙"},Ç:{char:"C",accent:"˙"},ṽ:{char:"v",accent:"~"},Ṽ:{char:"V",accent:"~"},ĵ:{char:"j",accent:"^"},Ĵ:{char:"J",accent:"^"},ź:{char:"z",accent:"´"},Ź:{char:"Z",accent:"´"},Ż:{char:"Z",accent:"^"},ż:{char:"z",accent:"^"},Ž:{char:"Z",accent:"ˇ"},ž:{char:"z",accent:"ˇ"},ẑ:{char:"z",accent:"ˆ"}},a={"´":"grave","`":"acute","^":"hat","~":"tilde","¨":"ddot","˚":"mathring","˘":"breve",ˇ:"check","˝":"ddot","˙":"dot","-":"bar",ˆ:"hat","˜":"tilde"},n={𝐀:{letter:"A",fontCmd:"mathbf"},𝐁:{letter:"B",fontCmd:"mathbf"},𝐂:{letter:"C",fontCmd:"mathbf"},𝐃:{letter:"D",fontCmd:"mathbf"},𝐄:{letter:"E",fontCmd:"mathbf"},Ε:{letter:"E",fontCmd:"mathbf"},𝐅:{letter:"F",fontCmd:"mathbf"},𝐆:{letter:"G",fontCmd:"mathbf"},𝐇:{letter:"H",fontCmd:"mathbf"},𝐈:{letter:"I",fontCmd:"mathbf"},𝐉:{letter:"J",fontCmd:"mathbf"},𝐊:{letter:"K",fontCmd:"mathbf"},𝐋:{letter:"L",fontCmd:"mathbf"},𝐌:{letter:"M",fontCmd:"mathbf"},𝐍:{letter:"N",fontCmd:"mathbf"},𝐎:{letter:"O",fontCmd:"mathbf"},𝐏:{letter:"P",fontCmd:"mathbf"},𝐐:{letter:"Q",fontCmd:"mathbf"},𝐑:{letter:"R",fontCmd:"mathbf"},𝐒:{letter:"S",fontCmd:"mathbf"},𝐓:{letter:"T",fontCmd:"mathbf"},𝐔:{letter:"U",fontCmd:"mathbf"},𝐕:{letter:"V",fontCmd:"mathbf"},𝐖:{letter:"W",fontCmd:"mathbf"},𝐗:{letter:"X",fontCmd:"mathbf"},𝞆:{letter:"X",fontCmd:"mathbf"},𝐘:{letter:"Y",fontCmd:"mathbf"},𝐙:{letter:"Z",fontCmd:"mathbf"},"𝟎":{letter:"0",fontCmd:"mathbf"},"𝟏":{letter:"1",fontCmd:"mathbf"},"𝟐":{letter:"2",fontCmd:"mathbf"},"𝟑":{letter:"3",fontCmd:"mathbf"},"𝟒":{letter:"4",fontCmd:"mathbf"},"𝟓":{letter:"5",fontCmd:"mathbf"},"𝟔":{letter:"6",fontCmd:"mathbf"},"𝟕":{letter:"7",fontCmd:"mathbf"},"𝟖":{letter:"8",fontCmd:"mathbf"},"𝟗":{letter:"9",fontCmd:"mathbf"},𝐴:{letter:"A",fontCmd:"mathit"},𝐵:{letter:"B",fontCmd:"mathit"},𝐶:{letter:"C",fontCmd:"mathit"},𝐷:{letter:"D",fontCmd:"mathit"},𝐸:{letter:"E",fontCmd:"mathit"},𝐹:{letter:"F",fontCmd:"mathit"},𝐺:{letter:"G",fontCmd:"mathit"},𝐻:{letter:"H",fontCmd:"mathit"},𝐼:{letter:"I",fontCmd:"mathit"},Ι:{letter:"I",fontCmd:"mathit"},𝐽:{letter:"J",fontCmd:"mathit"},𝐾:{letter:"K",fontCmd:"mathit"},𝐿:{letter:"L",fontCmd:"mathit"},𝑀:{letter:"M",fontCmd:"mathit"},𝑁:{letter:"N",fontCmd:"mathit"},𝑂:{letter:"O",fontCmd:"mathit"},𝑃:{letter:"P",fontCmd:"mathit"},𝑄:{letter:"Q",fontCmd:"mathit"},𝑅:{letter:"R",fontCmd:"mathit"},𝑆:{letter:"S",fontCmd:"mathit"},𝑇:{letter:"T",fontCmd:"mathit"},𝑈:{letter:"U",fontCmd:"mathit"},𝑉:{letter:"V",fontCmd:"mathit"},𝑊:{letter:"W",fontCmd:"mathit"},𝑋:{letter:"X",fontCmd:"mathit"},𝑌:{letter:"Y",fontCmd:"mathit"},𝑍:{letter:"Z",fontCmd:"mathit"},𝔸:{letter:"A",fontCmd:"mathbb"},𝔹:{letter:"B",fontCmd:"mathbb"},ℂ:{letter:"C",fontCmd:"mathbb"},𝔻:{letter:"D",fontCmd:"mathbb"},𝔼:{letter:"E",fontCmd:"mathbb"},𝔽:{letter:"F",fontCmd:"mathbb"},𝔾:{letter:"G",fontCmd:"mathbb"},ℍ:{letter:"H",fontCmd:"mathbb"},𝕀:{letter:"I",fontCmd:"mathbb"},𝕁:{letter:"J",fontCmd:"mathbb"},𝕂:{letter:"K",fontCmd:"mathbb"},𝕃:{letter:"L",fontCmd:"mathbb"},𝕄:{letter:"M",fontCmd:"mathbb"},ℕ:{letter:"N",fontCmd:"mathbb"},𝕆:{letter:"O",fontCmd:"mathbb"},ℙ:{letter:"P",fontCmd:"mathbb"},ℚ:{letter:"Q",fontCmd:"mathbb"},ℝ:{letter:"R",fontCmd:"mathbb"},𝕊:{letter:"S",fontCmd:"mathbb"},𝕋:{letter:"T",fontCmd:"mathbb"},𝕌:{letter:"U",fontCmd:"mathbb"},𝕍:{letter:"V",fontCmd:"mathbb"},𝕎:{letter:"W",fontCmd:"mathbb"},𝕏:{letter:"X",fontCmd:"mathbb"},𝕐:{letter:"Y",fontCmd:"mathbb"},ℤ:{letter:"Z",fontCmd:"mathbb"},"𝟘":{letter:"0",fontCmd:"mathbb"},"𝟙":{letter:"1",fontCmd:"mathbb"},"𝟚":{letter:"2",fontCmd:"mathbb"},"𝟛":{letter:"3",fontCmd:"mathbb"},"𝟜":{letter:"4",fontCmd:"mathbb"},"𝟝":{letter:"5",fontCmd:"mathbb"},"𝟞":{letter:"6",fontCmd:"mathbb"},"𝟟":{letter:"7",fontCmd:"mathbb"},"𝟠":{letter:"8",fontCmd:"mathbb"},"𝟡":{letter:"9",fontCmd:"mathbb"},𝒜:{letter:"A",fontCmd:"mathcal"},𝓐:{letter:"A",fontCmd:"mathcal"},ℬ:{letter:"B",fontCmd:"mathcal"},𝒞:{letter:"C",fontCmd:"mathcal"},𝒟:{letter:"D",fontCmd:"mathcal"},𝓓:{letter:"D",fontCmd:"mathcal"},ℰ:{letter:"E",fontCmd:"mathcal"},ℱ:{letter:"F",fontCmd:"mathcal"},𝓕:{letter:"F",fontCmd:"mathcal"},𝒢:{letter:"G",fontCmd:"mathcal"},ℋ:{letter:"H",fontCmd:"mathcal"},ℐ:{letter:"I",fontCmd:"mathcal"},𝒥:{letter:"J",fontCmd:"mathcal"},𝒦:{letter:"K",fontCmd:"mathcal"},ℒ:{letter:"L",fontCmd:"mathcal"},𝓛:{letter:"L",fontCmd:"mathcal"},ℳ:{letter:"M",fontCmd:"mathcal"},𝒩:{letter:"N",fontCmd:"mathcal"},𝒪:{letter:"O",fontCmd:"mathcal"},𝓞:{letter:"O",fontCmd:"mathcal"},𝒫:{letter:"P",fontCmd:"mathcal"},𝒬:{letter:"Q",fontCmd:"mathcal"},ℛ:{letter:"R",fontCmd:"mathcal"},𝕽:{letter:"R",fontCmd:"mathcal"},"℟":{letter:"R",fontCmd:"mathcal"},𝒮:{letter:"S",fontCmd:"mathcal"},𝒯:{letter:"T",fontCmd:"mathcal"},𝒰:{letter:"U",fontCmd:"mathcal"},𝒱:{letter:"V",fontCmd:"mathcal"},𝒲:{letter:"W",fontCmd:"mathcal"},𝒳:{letter:"X",fontCmd:"mathcal"},𝒴:{letter:"Y",fontCmd:"mathcal"},𝒵:{letter:"Z",fontCmd:"mathcal"},𝔄:{letter:"A",fontCmd:"mathfrak"},𝔅:{letter:"B",fontCmd:"mathfrak"},ℭ:{letter:"C",fontCmd:"mathfrak"},𝔇:{letter:"D",fontCmd:"mathfrak"},𝔈:{letter:"E",fontCmd:"mathfrak"},𝔉:{letter:"F",fontCmd:"mathfrak"},𝔊:{letter:"G",fontCmd:"mathfrak"},ℌ:{letter:"H",fontCmd:"mathfrak"},ℑ:{letter:"I",fontCmd:"mathfrak"},𝔍:{letter:"J",fontCmd:"mathfrak"},𝔎:{letter:"K",fontCmd:"mathfrak"},𝔏:{letter:"L",fontCmd:"mathfrak"},𝔐:{letter:"M",fontCmd:"mathfrak"},𝔑:{letter:"N",fontCmd:"mathfrak"},𝔒:{letter:"O",fontCmd:"mathfrak"},𝔓:{letter:"P",fontCmd:"mathfrak"},𝔔:{letter:"Q",fontCmd:"mathfrak"},ℜ:{letter:"R",fontCmd:"mathfrak"},𝔖:{letter:"S",fontCmd:"mathfrak"},𝔗:{letter:"T",fontCmd:"mathfrak"},𝔘:{letter:"U",fontCmd:"mathfrak"},𝔙:{letter:"V",fontCmd:"mathfrak"},𝔚:{letter:"W",fontCmd:"mathfrak"},𝔛:{letter:"X",fontCmd:"mathfrak"},𝔜:{letter:"Y",fontCmd:"mathfrak"},ℨ:{letter:"Z",fontCmd:"mathfrak"},𝖠:{letter:"A",fontCmd:"mathsf"},Α:{letter:"A",fontCmd:"mathsf"},𝖡:{letter:"B",fontCmd:"mathsf"},Β:{letter:"B",fontCmd:"mathsf"},𝖢:{letter:"C",fontCmd:"mathsf"},𝖣:{letter:"D",fontCmd:"mathsf"},𝖤:{letter:"E",fontCmd:"mathsf"},𝖥:{letter:"F",fontCmd:"mathsf"},𝖦:{letter:"G",fontCmd:"mathsf"},𝖧:{letter:"H",fontCmd:"mathsf"},𝖨:{letter:"I",fontCmd:"mathsf"},𝖩:{letter:"J",fontCmd:"mathsf"},ȷ:{letter:"J",fontCmd:"mathsf"},𝖪:{letter:"K",fontCmd:"mathsf"},Κ:{letter:"K",fontCmd:"mathsf"},𝖫:{letter:"L",fontCmd:"mathsf"},𝖬:{letter:"M",fontCmd:"mathsf"},𝖭:{letter:"N",fontCmd:"mathsf"},𝖮:{letter:"O",fontCmd:"mathsf"},𝖯:{letter:"P",fontCmd:"mathsf"},𝖰:{letter:"Q",fontCmd:"mathsf"},𝖱:{letter:"R",fontCmd:"mathsf"},𝖲:{letter:"S",fontCmd:"mathsf"},𝖳:{letter:"T",fontCmd:"mathsf"},𝖴:{letter:"U",fontCmd:"mathsf"},𝖵:{letter:"V",fontCmd:"mathsf"},𝖶:{letter:"W",fontCmd:"mathsf"},𝖷:{letter:"X",fontCmd:"mathsf"},Χ:{letter:"X",fontCmd:"mathsf"},𝖸:{letter:"Y",fontCmd:"mathsf"},𝖹:{letter:"Z",fontCmd:"mathsf"},𝚨:{letter:"A",fontCmd:"mathtt"},𝚩:{letter:"B",fontCmd:"mathtt"},𝚪:{letter:"\\Gamma",fontCmd:"mathtt"},𝚫:{letter:"\\Delta",fontCmd:"mathtt"},𝚬:{letter:"E",fontCmd:"mathtt"},𝚭:{letter:"F",fontCmd:"mathtt"},𝚮:{letter:"G",fontCmd:"mathtt"},𝚯:{letter:"\\Theta",fontCmd:"mathtt"},𝚰:{letter:"I",fontCmd:"mathtt"},𝚱:{letter:"J",fontCmd:"mathtt"},𝚲:{letter:"\\Lambda",fontCmd:"mathtt"},𝚳:{letter:"L",fontCmd:"mathtt"},𝚴:{letter:"M",fontCmd:"mathtt"},𝚵:{letter:"\\Pi",fontCmd:"mathtt"},𝚶:{letter:"O",fontCmd:"mathtt"},𝚷:{letter:"\\Pi",fontCmd:"mathtt"},𝚸:{letter:"Q",fontCmd:"mathtt"},𝚹:{letter:"R",fontCmd:"mathtt"},𝚺:{letter:"S",fontCmd:"mathtt"},𝚻:{letter:"T",fontCmd:"mathtt"},𝚼:{letter:"U",fontCmd:"mathtt"},𝚽:{letter:"\\Phi",fontCmd:"mathtt"},𝚾:{letter:"W",fontCmd:"mathtt"},𝚿:{letter:"\\Psi",fontCmd:"mathtt"},𝛀:{letter:"\\Omega",fontCmd:"mathtt"}}}},t={};function r(a){var n=t[a];if(void 0!==n)return n.exports;var o=t[a]={exports:{}};return e[a].call(o.exports,o,o.exports,r),o.exports}var a={};return(()=>{"use strict";var e=a;Object.defineProperty(e,"__esModule",{value:!0}),e.MathMLToLaTeX=void 0;var t=r(8672);Object.defineProperty(e,"MathMLToLaTeX",{enumerable:!0,get:function(){return t.MathMLToLaTeX}})})(),a})()));
//# sourceMappingURL=bundle.min.js.map

/***/ }),

/***/ 608:
/*!*************************!*\
  !*** ./src/metadata.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MetadataExtractor = void 0;
class MetadataExtractor {
    static extract(doc, schemaOrgData) {
        var _a, _b;
        let domain = '';
        let url = '';
        try {
            // Try to get URL from document location
            url = ((_a = doc.location) === null || _a === void 0 ? void 0 : _a.href) || '';
            // If no URL from location, try other sources
            if (!url) {
                url = this.getMetaContent(doc, "property", "og:url") ||
                    this.getMetaContent(doc, "property", "twitter:url") ||
                    this.getSchemaProperty(doc, schemaOrgData, 'url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntityOfPage.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'mainEntity.url') ||
                    this.getSchemaProperty(doc, schemaOrgData, 'WebSite.url') ||
                    ((_b = doc.querySelector('link[rel="canonical"]')) === null || _b === void 0 ? void 0 : _b.getAttribute('href')) || '';
            }
            if (url) {
                domain = new URL(url).hostname.replace(/^www\./, '');
            }
        }
        catch (e) {
            // If URL parsing fails, try to get from base tag
            const baseTag = doc.querySelector('base[href]');
            if (baseTag) {
                try {
                    url = baseTag.getAttribute('href') || '';
                    domain = new URL(url).hostname.replace(/^www\./, '');
                }
                catch (e) {
                    console.warn('Failed to parse base URL:', e);
                }
            }
        }
        return {
            title: this.getTitle(doc, schemaOrgData),
            description: this.getDescription(doc, schemaOrgData),
            domain,
            favicon: this.getFavicon(doc, url),
            image: this.getImage(doc, schemaOrgData),
            published: this.getPublished(doc, schemaOrgData),
            author: this.getAuthor(doc, schemaOrgData),
            site: this.getSite(doc, schemaOrgData),
            schemaOrgData,
            wordCount: 0,
            parseTime: 0
        };
    }
    static getAuthor(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "sailthru.author") ||
            this.getSchemaProperty(doc, schemaOrgData, 'author.name') ||
            this.getMetaContent(doc, "property", "author") ||
            this.getMetaContent(doc, "name", "byl") ||
            this.getMetaContent(doc, "name", "author") ||
            this.getMetaContent(doc, "name", "authorList") ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "twitter:creator") ||
            this.getMetaContent(doc, "name", "application-name") ||
            '');
    }
    static getSite(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'publisher.name') ||
            this.getMetaContent(doc, "property", "og:site_name") ||
            this.getSchemaProperty(doc, schemaOrgData, 'WebSite.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'sourceOrganization.name') ||
            this.getMetaContent(doc, "name", "copyright") ||
            this.getSchemaProperty(doc, schemaOrgData, 'copyrightHolder.name') ||
            this.getSchemaProperty(doc, schemaOrgData, 'isPartOf.name') ||
            this.getMetaContent(doc, "name", "application-name") ||
            this.getAuthor(doc, schemaOrgData) ||
            '');
    }
    static getTitle(doc, schemaOrgData) {
        var _a, _b;
        const rawTitle = (this.getMetaContent(doc, "property", "og:title") ||
            this.getMetaContent(doc, "name", "twitter:title") ||
            this.getSchemaProperty(doc, schemaOrgData, 'headline') ||
            this.getMetaContent(doc, "name", "title") ||
            this.getMetaContent(doc, "name", "sailthru.title") ||
            ((_b = (_a = doc.querySelector('title')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.trim()) ||
            '');
        return this.cleanTitle(rawTitle, this.getSite(doc, schemaOrgData));
    }
    static cleanTitle(title, siteName) {
        if (!title || !siteName)
            return title;
        // Remove site name if it exists
        const siteNameEscaped = siteName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const patterns = [
            `\\s*[\\|\\-–—]\\s*${siteNameEscaped}\\s*$`, // Title | Site Name
            `^\\s*${siteNameEscaped}\\s*[\\|\\-–—]\\s*`, // Site Name | Title
        ];
        for (const pattern of patterns) {
            const regex = new RegExp(pattern, 'i');
            if (regex.test(title)) {
                title = title.replace(regex, '');
                break;
            }
        }
        return title.trim();
    }
    static getDescription(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "name", "description") ||
            this.getMetaContent(doc, "property", "description") ||
            this.getMetaContent(doc, "property", "og:description") ||
            this.getSchemaProperty(doc, schemaOrgData, 'description') ||
            this.getMetaContent(doc, "name", "twitter:description") ||
            this.getMetaContent(doc, "name", "sailthru.description") ||
            '');
    }
    static getImage(doc, schemaOrgData) {
        return (this.getMetaContent(doc, "property", "og:image") ||
            this.getMetaContent(doc, "name", "twitter:image") ||
            this.getSchemaProperty(doc, schemaOrgData, 'image.url') ||
            this.getMetaContent(doc, "name", "sailthru.image.full") ||
            '');
    }
    static getFavicon(doc, baseUrl) {
        var _a, _b;
        const iconFromMeta = this.getMetaContent(doc, "property", "og:image:favicon");
        if (iconFromMeta)
            return iconFromMeta;
        const iconLink = (_a = doc.querySelector("link[rel='icon']")) === null || _a === void 0 ? void 0 : _a.getAttribute("href");
        if (iconLink)
            return iconLink;
        const shortcutLink = (_b = doc.querySelector("link[rel='shortcut icon']")) === null || _b === void 0 ? void 0 : _b.getAttribute("href");
        if (shortcutLink)
            return shortcutLink;
        // Only try to construct favicon URL if we have a valid base URL
        if (baseUrl) {
            try {
                return new URL("/favicon.ico", baseUrl).href;
            }
            catch (e) {
                console.warn('Failed to construct favicon URL:', e);
            }
        }
        return '';
    }
    static getPublished(doc, schemaOrgData) {
        return (this.getSchemaProperty(doc, schemaOrgData, 'datePublished') ||
            this.getMetaContent(doc, "name", "publishDate") ||
            this.getMetaContent(doc, "property", "article:published_time") ||
            this.getTimeElement(doc) ||
            this.getMetaContent(doc, "name", "sailthru.date") ||
            '');
    }
    static getMetaContent(doc, attr, value) {
        var _a, _b;
        const selector = `meta[${attr}]`;
        const element = Array.from(doc.querySelectorAll(selector))
            .find(el => { var _a; return ((_a = el.getAttribute(attr)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === value.toLowerCase(); });
        const content = element ? (_b = (_a = element.getAttribute("content")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : "" : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static getTimeElement(doc) {
        var _a, _b, _c, _d;
        const selector = `time`;
        const element = Array.from(doc.querySelectorAll(selector))[0];
        const content = element ? ((_d = (_b = (_a = element.getAttribute("datetime")) === null || _a === void 0 ? void 0 : _a.trim()) !== null && _b !== void 0 ? _b : (_c = element.textContent) === null || _c === void 0 ? void 0 : _c.trim()) !== null && _d !== void 0 ? _d : "") : "";
        return this.decodeHTMLEntities(content, doc);
    }
    static decodeHTMLEntities(text, doc) {
        const textarea = doc.createElement('textarea');
        textarea.innerHTML = text;
        return textarea.value;
    }
    static getSchemaProperty(doc, schemaOrgData, property, defaultValue = '') {
        if (!schemaOrgData)
            return defaultValue;
        const searchSchema = (data, props, fullPath, isExactMatch = true) => {
            if (typeof data === 'string') {
                return props.length === 0 ? [data] : [];
            }
            if (!data || typeof data !== 'object') {
                return [];
            }
            if (Array.isArray(data)) {
                const currentProp = props[0];
                if (/^\[\d+\]$/.test(currentProp)) {
                    const index = parseInt(currentProp.slice(1, -1));
                    if (data[index]) {
                        return searchSchema(data[index], props.slice(1), fullPath, isExactMatch);
                    }
                    return [];
                }
                if (props.length === 0 && data.every(item => typeof item === 'string' || typeof item === 'number')) {
                    return data.map(String);
                }
                return data.flatMap(item => searchSchema(item, props, fullPath, isExactMatch));
            }
            const [currentProp, ...remainingProps] = props;
            if (!currentProp) {
                if (typeof data === 'string')
                    return [data];
                if (typeof data === 'object' && data.name) {
                    return [data.name];
                }
                return [];
            }
            if (data.hasOwnProperty(currentProp)) {
                return searchSchema(data[currentProp], remainingProps, fullPath ? `${fullPath}.${currentProp}` : currentProp, true);
            }
            if (!isExactMatch) {
                const nestedResults = [];
                for (const key in data) {
                    if (typeof data[key] === 'object') {
                        const results = searchSchema(data[key], props, fullPath ? `${fullPath}.${key}` : key, false);
                        nestedResults.push(...results);
                    }
                }
                if (nestedResults.length > 0) {
                    return nestedResults;
                }
            }
            return [];
        };
        try {
            let results = searchSchema(schemaOrgData, property.split('.'), '', true);
            if (results.length === 0) {
                results = searchSchema(schemaOrgData, property.split('.'), '', false);
            }
            const result = results.length > 0 ? results.filter(Boolean).join(', ') : defaultValue;
            return this.decodeHTMLEntities(result, doc);
        }
        catch (error) {
            console.error(`Error in getSchemaProperty for ${property}:`, error);
            return defaultValue;
        }
    }
    static extractSchemaOrgData(doc) {
        const schemaScripts = doc.querySelectorAll('script[type="application/ld+json"]');
        const schemaData = [];
        schemaScripts.forEach(script => {
            let jsonContent = script.textContent || '';
            try {
                jsonContent = jsonContent
                    .replace(/\/\*[\s\S]*?\*\/|^\s*\/\/.*$/gm, '')
                    .replace(/^\s*<!\[CDATA\[([\s\S]*?)\]\]>\s*$/, '$1')
                    .replace(/^\s*(\*\/|\/\*)\s*|\s*(\*\/|\/\*)\s*$/g, '')
                    .trim();
                const jsonData = JSON.parse(jsonContent);
                if (jsonData['@graph'] && Array.isArray(jsonData['@graph'])) {
                    schemaData.push(...jsonData['@graph']);
                }
                else {
                    schemaData.push(jsonData);
                }
            }
            catch (error) {
                console.error('Error parsing schema.org data:', error);
                console.error('Problematic JSON content:', jsonContent);
            }
        });
        return schemaData;
    }
}
exports.MetadataExtractor = MetadataExtractor;


/***/ }),

/***/ 628:
/*!*************************!*\
  !*** ./src/defuddle.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
const metadata_1 = __webpack_require__(/*! ./metadata */ 608);
const constants_1 = __webpack_require__(/*! ./constants */ 640);
const math_1 = __webpack_require__(/*! ./math */ 315);
const ELEMENT_STANDARDIZATION_RULES = [
    // Math elements
    ...math_1.mathStandardizationRules,
    // Code blocks
    {
        selector: 'pre',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Function to get language from class
            const getLanguageFromClass = (element) => {
                // Check data-lang attribute first
                const dataLang = element.getAttribute('data-lang');
                if (dataLang) {
                    return dataLang.toLowerCase();
                }
                // Define language patterns
                const languagePatterns = [
                    /^language-(\w+)$/, // language-javascript
                    /^lang-(\w+)$/, // lang-javascript
                    /^(\w+)-code$/, // javascript-code
                    /^code-(\w+)$/, // code-javascript
                    /^syntax-(\w+)$/, // syntax-javascript
                    /^code-snippet__(\w+)$/, // code-snippet__javascript
                    /^highlight-(\w+)$/, // highlight-javascript
                    /^(\w+)-snippet$/ // javascript-snippet
                ];
                // Then check the class attribute for patterns
                if (element.className && typeof element.className === 'string') {
                    for (const pattern of languagePatterns) {
                        const match = element.className.toLowerCase().match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                    // Then check for supported language
                    if (constants_1.SUPPORTED_LANGUAGES.has(element.className.toLowerCase())) {
                        return element.className.toLowerCase();
                    }
                }
                const classNames = Array.from(element.classList);
                for (const className of classNames) {
                    // Check patterns first
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match) {
                            return match[1].toLowerCase();
                        }
                    }
                }
                // Only check bare language names if no patterns were found
                for (const className of classNames) {
                    if (constants_1.SUPPORTED_LANGUAGES.has(className.toLowerCase())) {
                        return className.toLowerCase();
                    }
                }
                return '';
            };
            // Try to get the language from the element and its ancestors
            let language = '';
            let currentElement = el;
            while (currentElement && !language) {
                language = getLanguageFromClass(currentElement);
                // Also check for code elements within the current element
                if (!language && currentElement.querySelector('code')) {
                    language = getLanguageFromClass(currentElement.querySelector('code'));
                }
                currentElement = currentElement.parentElement;
            }
            // Function to recursively extract text content while preserving structure
            const extractStructuredText = (element) => {
                if (element.nodeType === Node.TEXT_NODE) {
                    return element.textContent || '';
                }
                let text = '';
                if (element instanceof HTMLElement) {
                    // Handle line breaks
                    if (element.tagName === 'BR') {
                        return '\n';
                    }
                    // Handle code elements and their children
                    element.childNodes.forEach(child => {
                        text += extractStructuredText(child);
                    });
                    // Add newline after each code element
                    if (element.tagName === 'CODE') {
                        text += '\n';
                    }
                }
                return text;
            };
            // Extract all text content
            let codeContent = extractStructuredText(el);
            // Clean up the content
            codeContent = codeContent
                // Remove any extra newlines at the start
                .replace(/^\n+/, '')
                // Remove any extra newlines at the end
                .replace(/\n+$/, '')
                // Replace multiple consecutive newlines with a single newline
                .replace(/\n{3,}/g, '\n\n');
            // Create new pre element
            const newPre = document.createElement('pre');
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    newPre.setAttribute(attr.name, attr.value);
                }
            });
            // Create code element
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    },
    // Simplify headings by removing internal navigation elements
    {
        selector: 'h1, h2, h3, h4, h5, h6',
        element: 'keep',
        transform: (el) => {
            var _a, _b, _c, _d, _e;
            // If heading only contains a single anchor with internal link
            if (el.children.length === 1 &&
                ((_a = el.firstElementChild) === null || _a === void 0 ? void 0 : _a.tagName) === 'A' &&
                (((_b = el.firstElementChild.getAttribute('href')) === null || _b === void 0 ? void 0 : _b.includes('#')) ||
                    ((_c = el.firstElementChild.getAttribute('href')) === null || _c === void 0 ? void 0 : _c.startsWith('#')))) {
                // Create new heading of same level
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes from original heading
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                return newHeading;
            }
            // If heading contains navigation buttons or other utility elements
            const buttons = el.querySelectorAll('button');
            if (buttons.length > 0) {
                const newHeading = document.createElement(el.tagName);
                // Copy allowed attributes
                Array.from(el.attributes).forEach(attr => {
                    if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                        newHeading.setAttribute(attr.name, attr.value);
                    }
                });
                // Just use the text content
                newHeading.textContent = ((_e = el.textContent) === null || _e === void 0 ? void 0 : _e.trim()) || '';
                return newHeading;
            }
            return el;
        }
    },
    // Convert divs with paragraph role to actual paragraphs
    {
        selector: 'div[data-testid^="paragraph"], div[role="paragraph"]',
        element: 'p',
        transform: (el) => {
            const p = document.createElement('p');
            // Copy innerHTML
            p.innerHTML = el.innerHTML;
            // Copy allowed attributes
            Array.from(el.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    p.setAttribute(attr.name, attr.value);
                }
            });
            return p;
        }
    },
    // Convert divs with list roles to actual lists
    {
        selector: 'div[role="list"]',
        element: 'ul',
        // Custom handler for list type detection and transformation
        transform: (el) => {
            var _a;
            // First determine if this is an ordered list
            const firstItem = el.querySelector('div[role="listitem"] .label');
            const label = ((_a = firstItem === null || firstItem === void 0 ? void 0 : firstItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
            const isOrdered = label.match(/^\d+\)/);
            // Create the appropriate list type
            const list = document.createElement(isOrdered ? 'ol' : 'ul');
            // Process each list item
            const items = el.querySelectorAll('div[role="listitem"]');
            items.forEach(item => {
                const li = document.createElement('li');
                const content = item.querySelector('.content');
                if (content) {
                    // Convert any paragraph divs inside content
                    const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
                    paragraphDivs.forEach(div => {
                        const p = document.createElement('p');
                        p.innerHTML = div.innerHTML;
                        div.replaceWith(p);
                    });
                    // Convert any nested lists recursively
                    const nestedLists = content.querySelectorAll('div[role="list"]');
                    nestedLists.forEach(nestedList => {
                        var _a;
                        const firstNestedItem = nestedList.querySelector('div[role="listitem"] .label');
                        const nestedLabel = ((_a = firstNestedItem === null || firstNestedItem === void 0 ? void 0 : firstNestedItem.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        const isNestedOrdered = nestedLabel.match(/^\d+\)/);
                        const newNestedList = document.createElement(isNestedOrdered ? 'ol' : 'ul');
                        // Process nested items
                        const nestedItems = nestedList.querySelectorAll('div[role="listitem"]');
                        nestedItems.forEach(nestedItem => {
                            const nestedLi = document.createElement('li');
                            const nestedContent = nestedItem.querySelector('.content');
                            if (nestedContent) {
                                // Convert paragraph divs in nested items
                                const nestedParagraphs = nestedContent.querySelectorAll('div[role="paragraph"]');
                                nestedParagraphs.forEach(div => {
                                    const p = document.createElement('p');
                                    p.innerHTML = div.innerHTML;
                                    div.replaceWith(p);
                                });
                                nestedLi.innerHTML = nestedContent.innerHTML;
                            }
                            newNestedList.appendChild(nestedLi);
                        });
                        nestedList.replaceWith(newNestedList);
                    });
                    li.innerHTML = content.innerHTML;
                }
                list.appendChild(li);
            });
            return list;
        }
    },
    {
        selector: 'div[role="listitem"]',
        element: 'li',
        // Custom handler for list item content
        transform: (el) => {
            const content = el.querySelector('.content');
            if (!content)
                return el;
            // Convert any paragraph divs inside content
            const paragraphDivs = content.querySelectorAll('div[role="paragraph"]');
            paragraphDivs.forEach(div => {
                const p = document.createElement('p');
                p.innerHTML = div.innerHTML;
                div.replaceWith(p);
            });
            return content;
        }
    },
    // Code blocks with syntax highlighting
    {
        selector: '.wp-block-syntaxhighlighter-code, .syntaxhighlighter, .highlight, .highlight-source, .wp-block-code, pre[class*="language-"], pre[class*="brush:"]',
        element: 'pre',
        transform: (el) => {
            if (!(el instanceof HTMLElement))
                return el;
            // Create new pre element
            const newPre = document.createElement('pre');
            // Try to detect language
            let language = '';
            // Check for WordPress syntax highlighter specific format
            const syntaxEl = el.querySelector('.syntaxhighlighter');
            if (syntaxEl) {
                // Get language from syntaxhighlighter class
                const classes = Array.from(syntaxEl.classList);
                const langClass = classes.find(c => !['syntaxhighlighter', 'nogutter'].includes(c));
                if (langClass && constants_1.SUPPORTED_LANGUAGES.has(langClass.toLowerCase())) {
                    language = langClass.toLowerCase();
                }
            }
            // If no language found yet, check other common patterns
            if (!language) {
                const classNames = Array.from(el.classList);
                const languagePatterns = [
                    /(?:^|\s)(?:language|lang|brush|syntax)-(\w+)(?:\s|$)/i,
                    /(?:^|\s)(\w+)(?:\s|$)/i
                ];
                for (const className of classNames) {
                    for (const pattern of languagePatterns) {
                        const match = className.match(pattern);
                        if (match && match[1] && constants_1.SUPPORTED_LANGUAGES.has(match[1].toLowerCase())) {
                            language = match[1].toLowerCase();
                            break;
                        }
                    }
                    if (language)
                        break;
                }
            }
            // Extract code content, handling various formats
            let codeContent = '';
            // Handle WordPress syntax highlighter table format
            const codeContainer = el.querySelector('.syntaxhighlighter table .code .container');
            if (codeContainer) {
                // Process each line
                const lines = Array.from(codeContainer.children);
                codeContent = lines
                    .map(line => {
                    // Get all code elements in this line
                    const codeParts = Array.from(line.querySelectorAll('code'))
                        .map(code => {
                        // Get the text content, preserving spaces
                        let text = code.textContent || '';
                        // If this is a 'spaces' class element, convert to actual spaces
                        if (code.classList.contains('spaces')) {
                            text = ' '.repeat(text.length);
                        }
                        return text;
                    })
                        .join('');
                    return codeParts || line.textContent || '';
                })
                    .join('\n');
            }
            else {
                // Handle WordPress syntax highlighter non-table format
                const codeLines = el.querySelectorAll('.code .line');
                if (codeLines.length > 0) {
                    codeContent = Array.from(codeLines)
                        .map(line => {
                        const codeParts = Array.from(line.querySelectorAll('code'))
                            .map(code => code.textContent || '')
                            .join('');
                        return codeParts || line.textContent || '';
                    })
                        .join('\n');
                }
                else {
                    // Fallback to regular text content
                    codeContent = el.textContent || '';
                }
            }
            // Clean up the content
            codeContent = codeContent
                .replace(/^\s+|\s+$/g, '') // Trim start/end whitespace
                .replace(/\t/g, '    ') // Convert tabs to spaces
                .replace(/\n{3,}/g, '\n\n') // Normalize multiple newlines
                .replace(/\u00a0/g, ' '); // Replace non-breaking spaces with regular spaces
            // Create code element with language class if detected
            const code = document.createElement('code');
            if (language) {
                code.setAttribute('data-lang', language);
                code.setAttribute('class', `language-${language}`);
            }
            code.textContent = codeContent;
            newPre.appendChild(code);
            return newPre;
        }
    }
];
class Defuddle {
    /**
     * Create a new Defuddle instance
     * @param doc - The document to parse
     * @param options - Options for parsing
     */
    constructor(doc, options = {}) {
        this.doc = doc;
        this.options = options;
        this.debug = options.debug || false;
    }
    /**
     * Parse the document and extract its main content
     */
    parse() {
        const startTime = performance.now();
        // Extract metadata first since we'll need it in multiple places
        const schemaOrgData = metadata_1.MetadataExtractor.extractSchemaOrgData(this.doc);
        const metadata = metadata_1.MetadataExtractor.extract(this.doc, schemaOrgData);
        try {
            // Evaluate styles and sizes on original document
            const mobileStyles = this._evaluateMediaQueries(this.doc);
            // Check for small images in original document, excluding lazy-loaded ones
            const smallImages = this.findSmallImages(this.doc);
            // Clone document
            const clone = this.doc.cloneNode(true);
            // Apply mobile style to clone
            this.applyMobileStyles(clone, mobileStyles);
            // Find main content
            const mainContent = this.findMainContent(clone);
            if (!mainContent) {
                const endTime = performance.now();
                return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
            }
            // Remove small images identified from original document
            this.removeSmallImages(clone, smallImages);
            // Perform other destructive operations on the clone
            this.removeHiddenElements(clone);
            this.removeClutter(clone);
            // Clean up the main content
            this.cleanContent(mainContent, metadata);
            const content = mainContent ? mainContent.outerHTML : this.doc.body.innerHTML;
            const endTime = performance.now();
            return Object.assign(Object.assign({ content }, metadata), { wordCount: this.countWords(content), parseTime: Math.round(endTime - startTime) });
        }
        catch (error) {
            console.error('Defuddle', 'Error processing document:', error);
            const endTime = performance.now();
            return Object.assign(Object.assign({ content: this.doc.body.innerHTML }, metadata), { wordCount: this.countWords(this.doc.body.innerHTML), parseTime: Math.round(endTime - startTime) });
        }
    }
    countWords(content) {
        // Create a temporary div to parse HTML content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = content;
        // Get text content, removing extra whitespace
        const text = tempDiv.textContent || '';
        const words = text
            .trim()
            .replace(/\s+/g, ' ') // Replace multiple spaces with single space
            .split(' ')
            .filter(word => word.length > 0); // Filter out empty strings
        return words.length;
    }
    // Make all other methods private by removing the static keyword and using private
    _log(...args) {
        if (this.debug) {
            console.log('Defuddle:', ...args);
        }
    }
    _evaluateMediaQueries(doc) {
        const mobileStyles = [];
        const maxWidthRegex = /max-width[^:]*:\s*(\d+)/;
        try {
            // Get all styles, including inline styles
            const sheets = Array.from(doc.styleSheets).filter(sheet => {
                try {
                    // Access rules once to check validity
                    sheet.cssRules;
                    return true;
                }
                catch (e) {
                    // Expected error for cross-origin stylesheets
                    if (e instanceof DOMException && e.name === 'SecurityError') {
                        return false;
                    }
                    throw e;
                }
            });
            // Process all sheets in a single pass
            const mediaRules = sheets.flatMap(sheet => {
                try {
                    return Array.from(sheet.cssRules)
                        .filter((rule) => rule instanceof CSSMediaRule &&
                        rule.conditionText.includes('max-width'));
                }
                catch (e) {
                    if (this.debug) {
                        console.warn('Defuddle: Failed to process stylesheet:', e);
                    }
                    return [];
                }
            });
            // Process all media rules in a single pass
            mediaRules.forEach(rule => {
                const match = rule.conditionText.match(maxWidthRegex);
                if (match) {
                    const maxWidth = parseInt(match[1]);
                    if (constants_1.MOBILE_WIDTH <= maxWidth) {
                        // Batch process all style rules
                        const styleRules = Array.from(rule.cssRules)
                            .filter((r) => r instanceof CSSStyleRule);
                        styleRules.forEach(cssRule => {
                            try {
                                mobileStyles.push({
                                    selector: cssRule.selectorText,
                                    styles: cssRule.style.cssText
                                });
                            }
                            catch (e) {
                                if (this.debug) {
                                    console.warn('Defuddle: Failed to process CSS rule:', e);
                                }
                            }
                        });
                    }
                }
            });
        }
        catch (e) {
            console.error('Defuddle: Error evaluating media queries:', e);
        }
        return mobileStyles;
    }
    applyMobileStyles(doc, mobileStyles) {
        let appliedCount = 0;
        mobileStyles.forEach(({ selector, styles }) => {
            try {
                const elements = doc.querySelectorAll(selector);
                elements.forEach(element => {
                    element.setAttribute('style', (element.getAttribute('style') || '') + styles);
                    appliedCount++;
                });
            }
            catch (e) {
                console.error('Defuddle', 'Error applying styles for selector:', selector, e);
            }
        });
    }
    removeHiddenElements(doc) {
        let count = 0;
        const elementsToRemove = new Set();
        // First pass: Get all elements matching hidden selectors
        const hiddenElements = doc.querySelectorAll(constants_1.HIDDEN_ELEMENT_SELECTORS);
        hiddenElements.forEach(el => elementsToRemove.add(el));
        count += hiddenElements.length;
        // Second pass: Use TreeWalker for efficient traversal
        const treeWalker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT, {
            acceptNode: (node) => {
                // Skip elements already marked for removal
                if (elementsToRemove.has(node)) {
                    return NodeFilter.FILTER_REJECT;
                }
                return NodeFilter.FILTER_ACCEPT;
            }
        });
        // Batch style computations
        const elements = [];
        let currentNode;
        while (currentNode = treeWalker.nextNode()) {
            elements.push(currentNode);
        }
        // Process styles in batches to minimize layout thrashing
        const BATCH_SIZE = 100;
        for (let i = 0; i < elements.length; i += BATCH_SIZE) {
            const batch = elements.slice(i, i + BATCH_SIZE);
            // Read phase - gather all computedStyles
            const styles = batch.map(el => window.getComputedStyle(el));
            // Write phase - mark elements for removal
            batch.forEach((element, index) => {
                const computedStyle = styles[index];
                if (computedStyle.display === 'none' ||
                    computedStyle.visibility === 'hidden' ||
                    computedStyle.opacity === '0') {
                    elementsToRemove.add(element);
                    count++;
                }
            });
        }
        // Final pass: Batch remove all hidden elements
        elementsToRemove.forEach(el => el.remove());
        this._log('Removed hidden elements:', count);
    }
    removeClutter(doc) {
        const startTime = performance.now();
        let exactSelectorCount = 0;
        let partialSelectorCount = 0;
        // Track all elements to be removed
        const elementsToRemove = new Set();
        // First collect elements matching exact selectors
        const exactElements = doc.querySelectorAll(constants_1.EXACT_SELECTORS.join(','));
        exactElements.forEach(el => {
            if (el === null || el === void 0 ? void 0 : el.parentNode) {
                elementsToRemove.add(el);
                exactSelectorCount++;
            }
        });
        // Pre-compile regexes and combine into a single regex for better performance
        const combinedPattern = constants_1.PARTIAL_SELECTORS.join('|');
        const partialRegex = new RegExp(combinedPattern, 'i');
        // Create an efficient attribute selector for elements we care about
        const attributeSelector = '[class],[id],[data-testid],[data-qa],[data-cy]';
        const allElements = doc.querySelectorAll(attributeSelector);
        // Process elements for partial matches
        allElements.forEach(el => {
            // Skip if already marked for removal
            if (elementsToRemove.has(el)) {
                return;
            }
            // Get all relevant attributes and combine into a single string
            const attrs = [
                el.className && typeof el.className === 'string' ? el.className : '',
                el.id || '',
                el.getAttribute('data-testid') || '',
                el.getAttribute('data-qa') || '',
                el.getAttribute('data-cy') || ''
            ].join(' ').toLowerCase();
            // Skip if no attributes to check
            if (!attrs.trim()) {
                return;
            }
            // Check for partial match using single regex test
            if (partialRegex.test(attrs)) {
                elementsToRemove.add(el);
                partialSelectorCount++;
            }
        });
        // Remove all collected elements in a single pass
        elementsToRemove.forEach(el => el.remove());
        const endTime = performance.now();
        this._log('Removed clutter elements:', {
            exactSelectors: exactSelectorCount,
            partialSelectors: partialSelectorCount,
            total: elementsToRemove.size,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    flattenDivs(element) {
        let processedCount = 0;
        const startTime = performance.now();
        // Process in batches to maintain performance
        let keepProcessing = true;
        const shouldPreserveElement = (el) => {
            const tagName = el.tagName.toLowerCase();
            // Check if element should be preserved
            if (constants_1.PRESERVE_ELEMENTS.has(tagName))
                return true;
            // Check for semantic roles
            const role = el.getAttribute('role');
            if (role && ['article', 'main', 'navigation', 'banner', 'contentinfo'].includes(role)) {
                return true;
            }
            // Check for semantic classes
            const className = el.className.toLowerCase();
            if (className.match(/(?:article|main|content|footnote|reference|bibliography)/)) {
                return true;
            }
            // Check if div contains mixed content types that should be preserved
            if (tagName === 'div') {
                const children = Array.from(el.children);
                const hasPreservedElements = children.some(child => constants_1.PRESERVE_ELEMENTS.has(child.tagName.toLowerCase()) ||
                    child.getAttribute('role') === 'article' ||
                    child.className.toLowerCase().includes('article'));
                if (hasPreservedElements)
                    return true;
            }
            return false;
        };
        const isWrapperDiv = (div) => {
            var _a;
            // Check if it's just empty space
            if (!((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim()))
                return true;
            // Check if it only contains other divs or block elements
            const children = Array.from(div.children);
            if (children.length === 0)
                return true;
            // Check if all children are block elements
            const allBlockElements = children.every(child => {
                const tag = child.tagName.toLowerCase();
                return tag === 'div' || tag === 'p' || tag === 'h1' || tag === 'h2' ||
                    tag === 'h3' || tag === 'h4' || tag === 'h5' || tag === 'h6' ||
                    tag === 'ul' || tag === 'ol' || tag === 'pre' || tag === 'blockquote' ||
                    tag === 'figure';
            });
            if (allBlockElements)
                return true;
            // Check for common wrapper patterns
            const className = div.className.toLowerCase();
            const isWrapper = /(?:wrapper|container|layout|row|col|grid|flex|outer|inner|content-area)/i.test(className);
            if (isWrapper)
                return true;
            // Check if it has excessive whitespace or empty text nodes
            const textNodes = Array.from(div.childNodes).filter(node => { var _a; return node.nodeType === Node.TEXT_NODE && ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.trim()); });
            if (textNodes.length === 0)
                return true;
            // Check if it's a div that only contains block elements
            const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                const tag = child.tagName.toLowerCase();
                return constants_1.INLINE_ELEMENTS.has(tag);
            });
            if (hasOnlyBlockElements)
                return true;
            return false;
        };
        // Function to process a single div
        const processDiv = (div) => {
            var _a, _b;
            // Skip processing if div has been removed or should be preserved
            if (!div.isConnected || shouldPreserveElement(div))
                return false;
            // Case 1: Empty div or div with only whitespace
            if (!div.hasChildNodes() || !((_a = div.textContent) === null || _a === void 0 ? void 0 : _a.trim())) {
                div.remove();
                processedCount++;
                return true;
            }
            // Case 2: Top-level div - be more aggressive
            if (div.parentElement === element) {
                const children = Array.from(div.children);
                const hasOnlyBlockElements = children.length > 0 && !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (hasOnlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
            }
            // Case 3: Wrapper div - merge up aggressively
            if (isWrapperDiv(div)) {
                // Special case: if div only contains block elements, merge them up
                const children = Array.from(div.children);
                const onlyBlockElements = !children.some(child => {
                    const tag = child.tagName.toLowerCase();
                    return constants_1.INLINE_ELEMENTS.has(tag);
                });
                if (onlyBlockElements) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    return true;
                }
                // Otherwise handle as normal wrapper
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            // Case 4: Div only contains text content - convert to paragraph
            if (!div.children.length && ((_b = div.textContent) === null || _b === void 0 ? void 0 : _b.trim())) {
                const p = document.createElement('p');
                p.textContent = div.textContent;
                div.replaceWith(p);
                processedCount++;
                return true;
            }
            // Case 5: Div has single child
            if (div.children.length === 1) {
                const child = div.firstElementChild;
                const childTag = child.tagName.toLowerCase();
                // Don't unwrap if child is inline or should be preserved
                if (!constants_1.INLINE_ELEMENTS.has(childTag) && !shouldPreserveElement(child)) {
                    div.replaceWith(child);
                    processedCount++;
                    return true;
                }
            }
            // Case 6: Deeply nested div - merge up
            let nestingDepth = 0;
            let parent = div.parentElement;
            while (parent) {
                if (parent.tagName.toLowerCase() === 'div') {
                    nestingDepth++;
                }
                parent = parent.parentElement;
            }
            if (nestingDepth > 0) { // Changed from > 1 to > 0 to be more aggressive
                const fragment = document.createDocumentFragment();
                while (div.firstChild) {
                    fragment.appendChild(div.firstChild);
                }
                div.replaceWith(fragment);
                processedCount++;
                return true;
            }
            return false;
        };
        // First pass: Process top-level divs
        const processTopLevelDivs = () => {
            const topDivs = Array.from(element.children).filter(el => el.tagName.toLowerCase() === 'div');
            let modified = false;
            topDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Second pass: Process remaining divs from deepest to shallowest
        const processRemainingDivs = () => {
            const allDivs = Array.from(element.getElementsByTagName('div'))
                .sort((a, b) => {
                // Count nesting depth
                const getDepth = (el) => {
                    let depth = 0;
                    let parent = el.parentElement;
                    while (parent) {
                        if (parent.tagName.toLowerCase() === 'div')
                            depth++;
                        parent = parent.parentElement;
                    }
                    return depth;
                };
                return getDepth(b) - getDepth(a); // Process deepest first
            });
            let modified = false;
            allDivs.forEach(div => {
                if (processDiv(div)) {
                    modified = true;
                }
            });
            return modified;
        };
        // Final cleanup pass - aggressively flatten remaining divs
        const finalCleanup = () => {
            const remainingDivs = Array.from(element.getElementsByTagName('div'));
            let modified = false;
            remainingDivs.forEach(div => {
                // Check if div only contains paragraphs
                const children = Array.from(div.children);
                const onlyParagraphs = children.every(child => child.tagName.toLowerCase() === 'p');
                if (onlyParagraphs || (!shouldPreserveElement(div) && isWrapperDiv(div))) {
                    const fragment = document.createDocumentFragment();
                    while (div.firstChild) {
                        fragment.appendChild(div.firstChild);
                    }
                    div.replaceWith(fragment);
                    processedCount++;
                    modified = true;
                }
            });
            return modified;
        };
        // Execute all passes until no more changes
        do {
            keepProcessing = false;
            if (processTopLevelDivs())
                keepProcessing = true;
            if (processRemainingDivs())
                keepProcessing = true;
            if (finalCleanup())
                keepProcessing = true;
        } while (keepProcessing);
        const endTime = performance.now();
        this._log('Flattened divs:', {
            count: processedCount,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
    }
    cleanContent(element, metadata) {
        // Remove HTML comments
        this.removeHtmlComments(element);
        // Handle H1 elements - remove first one and convert others to H2
        this.handleHeadings(element, metadata.title);
        // Standardize footnotes and citations
        this.standardizeFootnotes(element);
        // Handle lazy-loaded images
        this.handleLazyImages(element);
        // Convert embedded content to standard formats
        this.standardizeElements(element);
        // Skip div flattening in debug mode
        if (!this.debug) {
            // First pass of div flattening
            this.flattenDivs(element);
            // Strip unwanted attributes
            this.stripUnwantedAttributes(element);
            // Remove empty elements
            this.removeEmptyElements(element);
            // Remove trailing headings
            this.removeTrailingHeadings(element);
            // Final pass of div flattening after cleanup operations
            this.flattenDivs(element);
        }
        else {
            // In debug mode, still do basic cleanup but preserve structure
            this.stripUnwantedAttributes(element);
            this.removeEmptyElements(element);
            this.removeTrailingHeadings(element);
            this._log('Debug mode: Skipping div flattening to preserve structure');
        }
    }
    removeTrailingHeadings(element) {
        let removedCount = 0;
        const hasContentAfter = (el) => {
            // Check if there's any meaningful content after this element
            let nextContent = '';
            let sibling = el.nextSibling;
            // First check direct siblings
            while (sibling) {
                if (sibling.nodeType === Node.TEXT_NODE) {
                    nextContent += sibling.textContent || '';
                }
                else if (sibling.nodeType === Node.ELEMENT_NODE) {
                    // If we find an element sibling, check its content
                    nextContent += sibling.textContent || '';
                }
                sibling = sibling.nextSibling;
            }
            // If we found meaningful content at this level, return true
            if (nextContent.trim()) {
                return true;
            }
            // If no content found at this level and we have a parent,
            // check for content after the parent
            const parent = el.parentElement;
            if (parent && parent !== element) {
                return hasContentAfter(parent);
            }
            return false;
        };
        // Process all headings from bottom to top
        const headings = Array.from(element.querySelectorAll('h1, h2, h3, h4, h5, h6'))
            .reverse();
        headings.forEach(heading => {
            if (!hasContentAfter(heading)) {
                heading.remove();
                removedCount++;
            }
            else {
                // Stop processing once we find a heading with content after it
                return;
            }
        });
        if (removedCount > 0) {
            this._log('Removed trailing headings:', removedCount);
        }
    }
    handleHeadings(element, title) {
        var _a;
        const h1s = element.getElementsByTagName('h1');
        Array.from(h1s).forEach(h1 => {
            var _a;
            const h2 = document.createElement('h2');
            h2.innerHTML = h1.innerHTML;
            // Copy allowed attributes
            Array.from(h1.attributes).forEach(attr => {
                if (constants_1.ALLOWED_ATTRIBUTES.has(attr.name)) {
                    h2.setAttribute(attr.name, attr.value);
                }
            });
            (_a = h1.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(h2, h1);
        });
        // Remove first H2 if it matches title
        const h2s = element.getElementsByTagName('h2');
        if (h2s.length > 0) {
            const firstH2 = h2s[0];
            const firstH2Text = ((_a = firstH2.textContent) === null || _a === void 0 ? void 0 : _a.trim().toLowerCase()) || '';
            const normalizedTitle = title.toLowerCase().trim();
            if (normalizedTitle && normalizedTitle === firstH2Text) {
                firstH2.remove();
            }
        }
    }
    removeHtmlComments(element) {
        const comments = [];
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_COMMENT, null);
        let node;
        while (node = walker.nextNode()) {
            comments.push(node);
        }
        comments.forEach(comment => {
            comment.remove();
        });
        this._log('Removed HTML comments:', comments.length);
    }
    stripUnwantedAttributes(element) {
        let attributeCount = 0;
        const processElement = (el) => {
            // Skip SVG elements - preserve all their attributes
            if (el instanceof SVGElement) {
                return;
            }
            const attributes = Array.from(el.attributes);
            attributes.forEach(attr => {
                const attrName = attr.name.toLowerCase();
                // In debug mode, allow debug attributes and data- attributes
                if (this.debug) {
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName) &&
                        !constants_1.ALLOWED_ATTRIBUTES_DEBUG.has(attrName) &&
                        !attrName.startsWith('data-')) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
                else {
                    // In normal mode, only allow standard attributes
                    if (!constants_1.ALLOWED_ATTRIBUTES.has(attrName)) {
                        el.removeAttribute(attr.name);
                        attributeCount++;
                    }
                }
            });
        };
        processElement(element);
        element.querySelectorAll('*').forEach(processElement);
        this._log('Stripped attributes:', attributeCount);
    }
    removeEmptyElements(element) {
        let removedCount = 0;
        let iterations = 0;
        let keepRemoving = true;
        while (keepRemoving) {
            iterations++;
            keepRemoving = false;
            // Get all elements without children, working from deepest first
            const emptyElements = Array.from(element.getElementsByTagName('*')).filter(el => {
                if (constants_1.ALLOWED_EMPTY_ELEMENTS.has(el.tagName.toLowerCase())) {
                    return false;
                }
                // Check if element has only whitespace or &nbsp;
                const textContent = el.textContent || '';
                const hasOnlyWhitespace = textContent.trim().length === 0;
                const hasNbsp = textContent.includes('\u00A0'); // Unicode non-breaking space
                // Check if element has no meaningful children
                const hasNoChildren = !el.hasChildNodes() ||
                    (Array.from(el.childNodes).every(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            const nodeText = node.textContent || '';
                            return nodeText.trim().length === 0 && !nodeText.includes('\u00A0');
                        }
                        return false;
                    }));
                // Special case: Check for divs that only contain spans with commas
                if (el.tagName.toLowerCase() === 'div') {
                    const children = Array.from(el.children);
                    const hasOnlyCommaSpans = children.length > 0 && children.every(child => {
                        var _a;
                        if (child.tagName.toLowerCase() !== 'span')
                            return false;
                        const content = ((_a = child.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                        return content === ',' || content === '' || content === ' ';
                    });
                    if (hasOnlyCommaSpans)
                        return true;
                }
                return hasOnlyWhitespace && !hasNbsp && hasNoChildren;
            });
            if (emptyElements.length > 0) {
                emptyElements.forEach(el => {
                    el.remove();
                    removedCount++;
                });
                keepRemoving = true;
            }
        }
        this._log('Removed empty elements:', {
            count: removedCount,
            iterations
        });
    }
    createFootnoteItem(footnoteNumber, content, refs) {
        const newItem = document.createElement('li');
        newItem.className = 'footnote';
        newItem.id = `fn:${footnoteNumber}`;
        // Handle content
        if (typeof content === 'string') {
            const paragraph = document.createElement('p');
            paragraph.innerHTML = content;
            newItem.appendChild(paragraph);
        }
        else {
            // Get all paragraphs from the content
            const paragraphs = Array.from(content.querySelectorAll('p'));
            if (paragraphs.length === 0) {
                // If no paragraphs, wrap content in a paragraph
                const paragraph = document.createElement('p');
                paragraph.innerHTML = content.innerHTML;
                newItem.appendChild(paragraph);
            }
            else {
                // Copy existing paragraphs
                paragraphs.forEach(p => {
                    const newP = document.createElement('p');
                    newP.innerHTML = p.innerHTML;
                    newItem.appendChild(newP);
                });
            }
        }
        // Add backlink(s) to the last paragraph
        const lastParagraph = newItem.querySelector('p:last-of-type') || newItem;
        refs.forEach((refId, index) => {
            const backlink = document.createElement('a');
            backlink.href = `#${refId}`;
            backlink.title = 'return to article';
            backlink.className = 'footnote-backref';
            backlink.innerHTML = '↩';
            if (index < refs.length - 1) {
                backlink.innerHTML += ' ';
            }
            lastParagraph.appendChild(backlink);
        });
        return newItem;
    }
    collectFootnotes(element) {
        const footnotes = {};
        let footnoteCount = 1;
        const processedIds = new Set(); // Track processed IDs
        // Collect all footnotes and their IDs from footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => {
            // Substack has individual footnote divs with no parent
            if (list.matches('div.footnote[data-component-name="FootnoteToDOM"]')) {
                const anchor = list.querySelector('a.footnote-number');
                const content = list.querySelector('.footnote-content');
                if (anchor && content) {
                    const id = anchor.id.replace('footnote-', '').toLowerCase();
                    if (id && !processedIds.has(id)) {
                        footnotes[footnoteCount] = {
                            content: content,
                            originalId: id,
                            refs: []
                        };
                        processedIds.add(id);
                        footnoteCount++;
                    }
                }
                return;
            }
            // Common format using OL/UL and LI elements
            const items = list.querySelectorAll('li, div[role="listitem"]');
            items.forEach(li => {
                var _a, _b, _c, _d;
                let id = '';
                let content = null;
                // Handle citations with .citations class
                const citationsDiv = li.querySelector('.citations');
                if ((_a = citationsDiv === null || citationsDiv === void 0 ? void 0 : citationsDiv.id) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith('r')) {
                    id = citationsDiv.id.toLowerCase();
                    // Look for citation content within the citations div
                    const citationContent = citationsDiv.querySelector('.citation-content');
                    if (citationContent) {
                        content = citationContent;
                    }
                }
                else {
                    // Extract ID from various formats
                    if (li.id.toLowerCase().startsWith('bib.bib')) {
                        id = li.id.replace('bib.bib', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn:')) {
                        id = li.id.replace('fn:', '').toLowerCase();
                    }
                    else if (li.id.toLowerCase().startsWith('fn')) {
                        id = li.id.replace('fn', '').toLowerCase();
                        // Nature.com
                    }
                    else if (li.hasAttribute('data-counter')) {
                        id = ((_c = (_b = li.getAttribute('data-counter')) === null || _b === void 0 ? void 0 : _b.replace(/\.$/, '')) === null || _c === void 0 ? void 0 : _c.toLowerCase()) || '';
                    }
                    else {
                        const match = (_d = li.id.split('/').pop()) === null || _d === void 0 ? void 0 : _d.match(/cite_note-(.+)/);
                        id = match ? match[1].toLowerCase() : li.id.toLowerCase();
                    }
                    content = li;
                }
                if (id && !processedIds.has(id)) {
                    footnotes[footnoteCount] = {
                        content: content || li,
                        originalId: id,
                        refs: []
                    };
                    processedIds.add(id);
                    footnoteCount++;
                }
            });
        });
        return footnotes;
    }
    findOuterFootnoteContainer(el) {
        let current = el;
        let parent = el.parentElement;
        // Keep going up until we find an element that's not a span or sup
        while (parent && (parent.tagName.toLowerCase() === 'span' ||
            parent.tagName.toLowerCase() === 'sup')) {
            current = parent;
            parent = parent.parentElement;
        }
        return current;
    }
    // Every footnote reference should be a sup element with an anchor inside
    // e.g. <sup id="fnref:1"><a href="#fn:1">1</a></sup>
    createFootnoteReference(footnoteNumber, refId) {
        const sup = document.createElement('sup');
        sup.id = refId;
        const link = document.createElement('a');
        link.href = `#fn:${footnoteNumber}`;
        link.textContent = footnoteNumber;
        sup.appendChild(link);
        return sup;
    }
    standardizeFootnotes(element) {
        const footnotes = this.collectFootnotes(element);
        // Standardize inline footnotes using the collected IDs
        const footnoteInlineReferences = element.querySelectorAll(constants_1.FOOTNOTE_INLINE_REFERENCES);
        // Group references by their parent sup element
        const supGroups = new Map();
        footnoteInlineReferences.forEach(el => {
            var _a, _b, _c, _d;
            if (!(el instanceof HTMLElement))
                return;
            let footnoteId = '';
            let footnoteContent = '';
            // Extract footnote ID based on element type
            // Nature.com
            if (el.matches('a[id^="ref-link"]')) {
                footnoteId = ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                // Science.org
            }
            else if (el.matches('a[role="doc-biblioref"]')) {
                const xmlRid = el.getAttribute('data-xml-rid');
                if (xmlRid) {
                    footnoteId = xmlRid;
                }
                else {
                    const href = el.getAttribute('href');
                    if (href === null || href === void 0 ? void 0 : href.startsWith('#core-R')) {
                        footnoteId = href.replace('#core-', '');
                    }
                }
                // Substack
            }
            else if (el.matches('a.footnote-anchor, span.footnote-hovercard-target a')) {
                const id = ((_b = el.id) === null || _b === void 0 ? void 0 : _b.replace('footnote-anchor-', '')) || '';
                if (id) {
                    footnoteId = id.toLowerCase();
                }
                // Arxiv
            }
            else if (el.matches('cite.ltx_cite')) {
                const link = el.querySelector('a');
                if (link) {
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_c = href.split('/').pop()) === null || _c === void 0 ? void 0 : _c.match(/bib\.bib(\d+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                }
            }
            else if (el.matches('sup.reference')) {
                const links = el.querySelectorAll('a');
                Array.from(links).forEach(link => {
                    var _a;
                    const href = link.getAttribute('href');
                    if (href) {
                        const match = (_a = href.split('/').pop()) === null || _a === void 0 ? void 0 : _a.match(/(?:cite_note|cite_ref)-(.+)/);
                        if (match) {
                            footnoteId = match[1].toLowerCase();
                        }
                    }
                });
            }
            else if (el.matches('sup[id^="fnref:"]')) {
                footnoteId = el.id.replace('fnref:', '').toLowerCase();
            }
            else if (el.matches('sup[id^="fnr"]')) {
                footnoteId = el.id.replace('fnr', '').toLowerCase();
            }
            else if (el.matches('span.footnote-reference')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
            }
            else if (el.matches('span.footnote-link')) {
                footnoteId = el.getAttribute('data-footnote-id') || '';
                footnoteContent = el.getAttribute('data-footnote-content') || '';
            }
            else if (el.matches('a.citation')) {
                footnoteId = ((_d = el.textContent) === null || _d === void 0 ? void 0 : _d.trim()) || '';
                footnoteContent = el.getAttribute('href') || '';
            }
            else if (el.matches('a[id^="fnref"]')) {
                footnoteId = el.id.replace('fnref', '').toLowerCase();
            }
            else {
                // Other citation types
                const href = el.getAttribute('href');
                if (href) {
                    const id = href.replace(/^[#]/, '');
                    footnoteId = id.toLowerCase();
                }
            }
            if (footnoteId) {
                // Find the footnote number by matching the original ID
                const footnoteEntry = Object.entries(footnotes).find(([_, data]) => data.originalId === footnoteId.toLowerCase());
                if (footnoteEntry) {
                    const [footnoteNumber, footnoteData] = footnoteEntry;
                    // Create footnote reference ID
                    const refId = footnoteData.refs.length > 0 ?
                        `fnref:${footnoteNumber}-${footnoteData.refs.length + 1}` :
                        `fnref:${footnoteNumber}`;
                    footnoteData.refs.push(refId);
                    // Find the outermost container (span or sup)
                    const container = this.findOuterFootnoteContainer(el);
                    // If container is a sup, group references
                    if (container.tagName.toLowerCase() === 'sup') {
                        if (!supGroups.has(container)) {
                            supGroups.set(container, []);
                        }
                        const group = supGroups.get(container);
                        group.push(this.createFootnoteReference(footnoteNumber, refId));
                    }
                    else {
                        // Replace the container directly
                        container.replaceWith(this.createFootnoteReference(footnoteNumber, refId));
                    }
                }
            }
        });
        // Handle grouped references
        supGroups.forEach((references, container) => {
            if (references.length > 0) {
                // Create a document fragment to hold all the references
                const fragment = document.createDocumentFragment();
                // Add each reference as its own sup element
                references.forEach((ref, index) => {
                    const link = ref.querySelector('a');
                    if (link) {
                        const sup = document.createElement('sup');
                        sup.id = ref.id;
                        sup.appendChild(link.cloneNode(true));
                        fragment.appendChild(sup);
                    }
                });
                container.replaceWith(fragment);
            }
        });
        // Create the standardized footnote list
        const newList = document.createElement('footnotes');
        newList.className = 'footnotes';
        const orderedList = document.createElement('ol');
        // Create footnote items in order
        Object.entries(footnotes).forEach(([number, data]) => {
            const newItem = this.createFootnoteItem(parseInt(number), data.content, data.refs);
            orderedList.appendChild(newItem);
        });
        // Remove original footnote lists
        const footnoteLists = element.querySelectorAll(constants_1.FOOTNOTE_LIST_SELECTORS);
        footnoteLists.forEach(list => list.remove());
        // If we have any footnotes, add the new list to the document
        if (orderedList.children.length > 0) {
            newList.appendChild(orderedList);
            element.appendChild(newList);
        }
    }
    handleLazyImages(element) {
        let processedCount = 0;
        const lazyImages = element.querySelectorAll('img[data-src], img[data-srcset]');
        lazyImages.forEach(img => {
            if (!(img instanceof HTMLImageElement))
                return;
            // Handle data-src
            const dataSrc = img.getAttribute('data-src');
            if (dataSrc && !img.src) {
                img.src = dataSrc;
                processedCount++;
            }
            // Handle data-srcset
            const dataSrcset = img.getAttribute('data-srcset');
            if (dataSrcset && !img.srcset) {
                img.srcset = dataSrcset;
                processedCount++;
            }
            // Remove lazy loading related classes and attributes
            img.classList.remove('lazy', 'lazyload');
            img.removeAttribute('data-ll-status');
            img.removeAttribute('data-src');
            img.removeAttribute('data-srcset');
        });
        this._log('Processed lazy images:', processedCount);
    }
    standardizeElements(element) {
        let processedCount = 0;
        // Convert elements based on standardization rules
        ELEMENT_STANDARDIZATION_RULES.forEach(rule => {
            const elements = element.querySelectorAll(rule.selector);
            elements.forEach(el => {
                if (rule.transform) {
                    // If there's a transform function, use it to create the new element
                    const transformed = rule.transform(el);
                    el.replaceWith(transformed);
                    processedCount++;
                }
            });
        });
        // Convert lite-youtube elements
        const liteYoutubeElements = element.querySelectorAll('lite-youtube');
        liteYoutubeElements.forEach(el => {
            const videoId = el.getAttribute('videoid');
            if (!videoId)
                return;
            const iframe = document.createElement('iframe');
            iframe.width = '560';
            iframe.height = '315';
            iframe.src = `https://www.youtube.com/embed/${videoId}`;
            iframe.title = el.getAttribute('videotitle') || 'YouTube video player';
            iframe.frameBorder = '0';
            iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            iframe.setAttribute('allowfullscreen', '');
            el.replaceWith(iframe);
            processedCount++;
        });
        // Add future embed conversions (Twitter, Instagram, etc.)
        this._log('Converted embedded elements:', processedCount);
    }
    // Find small IMG and SVG elements
    findSmallImages(doc) {
        const MIN_DIMENSION = 33;
        const smallImages = new Set();
        const transformRegex = /scale\(([\d.]+)\)/;
        const startTime = performance.now();
        let processedCount = 0;
        // 1. Read phase - Gather all elements in a single pass
        const elements = [
            ...Array.from(doc.getElementsByTagName('img')),
            ...Array.from(doc.getElementsByTagName('svg'))
        ].filter(element => {
            // Skip lazy-loaded images that haven't been processed yet
            // and math images which may be small
            if (element instanceof HTMLImageElement) {
                const ignoredImage = element.classList.contains('lazy') ||
                    element.classList.contains('lazyload') ||
                    element.classList.contains('latex') ||
                    element.hasAttribute('decoding') ||
                    element.hasAttribute('data-src') ||
                    element.hasAttribute('data-srcset');
                return !ignoredImage;
            }
            return true;
        });
        if (elements.length === 0) {
            return smallImages;
        }
        // 2. Batch process - Collect all measurements in one go
        const measurements = elements.map(element => ({
            element,
            // Static attributes (no reflow)
            naturalWidth: element instanceof HTMLImageElement ? element.naturalWidth : 0,
            naturalHeight: element instanceof HTMLImageElement ? element.naturalHeight : 0,
            attrWidth: parseInt(element.getAttribute('width') || '0'),
            attrHeight: parseInt(element.getAttribute('height') || '0')
        }));
        // 3. Batch compute styles - Process in chunks to avoid long tasks
        const BATCH_SIZE = 50;
        for (let i = 0; i < measurements.length; i += BATCH_SIZE) {
            const batch = measurements.slice(i, i + BATCH_SIZE);
            try {
                // Read phase - compute all styles at once
                const styles = batch.map(({ element }) => window.getComputedStyle(element));
                const rects = batch.map(({ element }) => element.getBoundingClientRect());
                // Process phase - no DOM operations
                batch.forEach((measurement, index) => {
                    var _a;
                    try {
                        const style = styles[index];
                        const rect = rects[index];
                        // Get transform scale in the same batch
                        const transform = style.transform;
                        const scale = transform ?
                            parseFloat(((_a = transform.match(transformRegex)) === null || _a === void 0 ? void 0 : _a[1]) || '1') : 1;
                        // Calculate effective dimensions
                        const widths = [
                            measurement.naturalWidth,
                            measurement.attrWidth,
                            parseInt(style.width) || 0,
                            rect.width * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        const heights = [
                            measurement.naturalHeight,
                            measurement.attrHeight,
                            parseInt(style.height) || 0,
                            rect.height * scale
                        ].filter(dim => typeof dim === 'number' && dim > 0);
                        // Decision phase - no DOM operations
                        if (widths.length > 0 && heights.length > 0) {
                            const effectiveWidth = Math.min(...widths);
                            const effectiveHeight = Math.min(...heights);
                            if (effectiveWidth < MIN_DIMENSION || effectiveHeight < MIN_DIMENSION) {
                                const identifier = this.getElementIdentifier(measurement.element);
                                if (identifier) {
                                    smallImages.add(identifier);
                                    processedCount++;
                                }
                            }
                        }
                    }
                    catch (e) {
                        if (this.debug) {
                            console.warn('Defuddle: Failed to process element dimensions:', e);
                        }
                    }
                });
            }
            catch (e) {
                if (this.debug) {
                    console.warn('Defuddle: Failed to process batch:', e);
                }
            }
        }
        const endTime = performance.now();
        this._log('Found small elements:', {
            count: processedCount,
            totalElements: elements.length,
            processingTime: `${(endTime - startTime).toFixed(2)}ms`
        });
        return smallImages;
    }
    removeSmallImages(doc, smallImages) {
        let removedCount = 0;
        ['img', 'svg'].forEach(tag => {
            const elements = doc.getElementsByTagName(tag);
            Array.from(elements).forEach(element => {
                const identifier = this.getElementIdentifier(element);
                if (identifier && smallImages.has(identifier)) {
                    element.remove();
                    removedCount++;
                }
            });
        });
        this._log('Removed small elements:', removedCount);
    }
    getElementIdentifier(element) {
        // Try to create a unique identifier using various attributes
        if (element instanceof HTMLImageElement) {
            // For lazy-loaded images, use data-src as identifier if available
            const dataSrc = element.getAttribute('data-src');
            if (dataSrc)
                return `src:${dataSrc}`;
            const src = element.src || '';
            const srcset = element.srcset || '';
            const dataSrcset = element.getAttribute('data-srcset');
            if (src)
                return `src:${src}`;
            if (srcset)
                return `srcset:${srcset}`;
            if (dataSrcset)
                return `srcset:${dataSrcset}`;
        }
        const id = element.id || '';
        const className = element.className || '';
        const viewBox = element instanceof SVGElement ? element.getAttribute('viewBox') || '' : '';
        if (id)
            return `id:${id}`;
        if (viewBox)
            return `viewBox:${viewBox}`;
        if (className)
            return `class:${className}`;
        return null;
    }
    findMainContent(doc) {
        // Find all potential content containers
        const candidates = [];
        constants_1.ENTRY_POINT_ELEMENTS.forEach((selector, index) => {
            const elements = doc.querySelectorAll(selector);
            elements.forEach(element => {
                // Base score from selector priority (earlier = higher)
                let score = (constants_1.ENTRY_POINT_ELEMENTS.length - index) * 10;
                // Add score based on content analysis
                score += this.scoreElement(element);
                candidates.push({ element, score });
            });
        });
        if (candidates.length === 0) {
            // Fall back to scoring block elements
            // Currently <body> element is used as the fallback, so this is not used
            return this.findContentByScoring(doc);
        }
        // Sort by score descending
        candidates.sort((a, b) => b.score - a.score);
        if (this.debug) {
            this._log('Content candidates:', candidates.map(c => ({
                element: c.element.tagName,
                selector: this.getElementSelector(c.element),
                score: c.score
            })));
        }
        return candidates[0].element;
    }
    findContentByScoring(doc) {
        const candidates = this.scoreElements(doc);
        return candidates.length > 0 ? candidates[0].element : null;
    }
    getElementSelector(element) {
        const parts = [];
        let current = element;
        while (current && current !== this.doc.documentElement) {
            let selector = current.tagName.toLowerCase();
            if (current.id) {
                selector += '#' + current.id;
            }
            else if (current.className && typeof current.className === 'string') {
                selector += '.' + current.className.trim().split(/\s+/).join('.');
            }
            parts.unshift(selector);
            current = current.parentElement;
        }
        return parts.join(' > ');
    }
    scoreElements(doc) {
        const candidates = [];
        constants_1.BLOCK_ELEMENTS.forEach((tag) => {
            Array.from(doc.getElementsByTagName(tag)).forEach((element) => {
                const score = this.scoreElement(element);
                if (score > 0) {
                    candidates.push({ score, element });
                }
            });
        });
        return candidates.sort((a, b) => b.score - a.score);
    }
    scoreElement(element) {
        let score = 0;
        // Score based on element properties
        const className = element.className && typeof element.className === 'string' ?
            element.className.toLowerCase() : '';
        const id = element.id ? element.id.toLowerCase() : '';
        // Score based on content
        const text = element.textContent || '';
        const words = text.split(/\s+/).length;
        score += Math.min(Math.floor(words / 100), 3);
        // Score based on link density
        const links = element.getElementsByTagName('a');
        const linkText = Array.from(links).reduce((acc, link) => { var _a; return acc + (((_a = link.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0); }, 0);
        const linkDensity = text.length ? linkText / text.length : 0;
        if (linkDensity > 0.5) {
            score -= 10;
        }
        // Score based on presence of meaningful elements
        const paragraphs = element.getElementsByTagName('p').length;
        score += paragraphs;
        const images = element.getElementsByTagName('img').length;
        score += Math.min(images * 3, 9);
        return score;
    }
}
exports.Defuddle = Defuddle;


/***/ }),

/***/ 640:
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SUPPORTED_LANGUAGES = exports.ALLOWED_ATTRIBUTES_DEBUG = exports.ALLOWED_ATTRIBUTES = exports.ALLOWED_EMPTY_ELEMENTS = exports.FOOTNOTE_LIST_SELECTORS = exports.FOOTNOTE_INLINE_REFERENCES = exports.PARTIAL_SELECTORS = exports.EXACT_SELECTORS = exports.HIDDEN_ELEMENT_SELECTORS = exports.INLINE_ELEMENTS = exports.PRESERVE_ELEMENTS = exports.BLOCK_ELEMENTS = exports.MOBILE_WIDTH = exports.ENTRY_POINT_ELEMENTS = void 0;
// Entry point elements
// These are the elements that will be used to find the main content
exports.ENTRY_POINT_ELEMENTS = [
    'article',
    '[role="article"]',
    '.post-content',
    '.article-content',
    '#article-content',
    '.content-article',
    'main',
    '[role="main"]',
    'body' // ensures there is always a match
];
exports.MOBILE_WIDTH = 600;
exports.BLOCK_ELEMENTS = ['div', 'section', 'article', 'main'];
// Elements that should not be unwrapped
exports.PRESERVE_ELEMENTS = new Set([
    'pre', 'code', 'table', 'thead', 'tbody', 'tr', 'td', 'th',
    'ul', 'ol', 'li', 'dl', 'dt', 'dd',
    'figure', 'figcaption', 'picture',
    'details', 'summary',
    'blockquote',
    'form', 'fieldset'
]);
// Inline elements that should not be unwrapped
exports.INLINE_ELEMENTS = new Set([
    'a', 'span', 'strong', 'em', 'i', 'b', 'u', 'code', 'br', 'small',
    'sub', 'sup', 'mark', 'del', 'ins', 'q', 'abbr', 'cite', 'time'
]);
// Hidden elements that should be removed
exports.HIDDEN_ELEMENT_SELECTORS = [
    '[hidden]',
    //	'[aria-hidden="true"]', needed for math formulas
    //	'[style*="display: none"]', needed for for math formulas
    //	'[style*="display:none"]',
    '[style*="visibility: hidden"]',
    '[style*="visibility:hidden"]',
    '.hidden',
    '.invisible'
].join(',');
// Selectors to be removed
exports.EXACT_SELECTORS = [
    // scripts, styles
    'noscript',
    'script',
    'style',
    // ads
    '.ad:not([class*="gradient"])',
    '[class^="ad-" i]',
    '[class$="-ad" i]',
    '[id^="ad-" i]',
    '[id$="-ad" i]',
    '[role="banner" i]',
    '.promo',
    '.Promo',
    '#barrier-page', // ft.com
    // comments
    '[id="comments" i]',
    // header, nav
    'header',
    '.header',
    '#header',
    'nav',
    '.navigation',
    '#navigation',
    '[role="navigation" i]',
    '[role="dialog" i]',
    '[role*="complementary" i]',
    '[class*="pagination" i]',
    '.menu',
    '#menu',
    '#siteSub',
    // metadata
    '.author',
    '.Author',
    '.contributor',
    '.date',
    '.meta',
    '.tags',
    '.toc',
    '.Toc',
    '#toc',
    '#title',
    '#Title',
    '[href*="/category"]',
    '[href*="/categories"]',
    '[href*="/tag/"]',
    '[href*="/tags/"]',
    '[href*="/topics"]',
    '[href*="author"]',
    '[href="#site-content"]',
    '[src*="author"]',
    // footer
    'footer',
    // inputs, forms, elements
    'aside',
    'button',
    // '[role="button"]', Medium images
    'canvas',
    'dialog',
    'fieldset',
    'form',
    'input:not([type="checkbox"])',
    'label',
    'link',
    'option',
    'select',
    'textarea',
    'time',
    // iframes
    'instaread-player',
    'iframe:not([src*="youtube"]):not([src*="youtu.be"]):not([src*="vimeo"]):not([src*="twitter"])',
    // logos
    '[class="logo" i]',
    '#logo',
    '#Logo',
    // newsletter
    '#newsletter',
    '#Newsletter',
    // hidden for print
    '.noprint',
    '[data-link-name*="skip" i]',
    '[data-print-layout="hide" i]',
    '[data-block="donotprint" i]',
    // footnotes, citations
    '[class*="clickable-icon" i]',
    'li span[class*="ltx_tag" i][class*="ltx_tag_item" i]',
    'a[href^="#"][class*="anchor" i]',
    'a[href^="#"][class*="ref" i]',
    // link lists
    '[data-container*="most-viewed" i]',
    // sidebar
    '.sidebar',
    '.Sidebar',
    '#sidebar',
    '#Sidebar',
    '#sitesub',
    // other
    '#primaryaudio', // NPR
    '#NYT_ABOVE_MAIN_CONTENT_REGION',
    '[data-testid="photoviewer-children-figure"] > span', // New York Times
    'table.infobox',
    '.pencraft:not(.pc-display-contents)', // Substack
    '[data-optimizely="related-articles-section" i]' // The Economist
];
// Removal patterns tested against attributes: class, id, data-testid, and data-qa
// Case insensitive, partial matches allowed
exports.PARTIAL_SELECTORS = [
    'access-wall',
    'activitypub',
    'actioncall',
    'appendix',
    'avatar',
    'advert',
    '-ad-',
    '_ad_',
    'allterms',
    'around-the-web',
    'article-bottom-section',
    'article__copy',
    'article_date',
    'article-end ',
    'article_header',
    'article__header',
    'article__info',
    'article-info',
    'article__meta',
    'article-subject',
    'article_subject',
    'article-snippet',
    'article-separator',
    'article--share',
    'article--topics',
    'articletags',
    'article-tags',
    'article_tags',
    'article-title',
    'article_title',
    'articletopics',
    'article-topics',
    'article-type',
    'article--lede', // The Verge
    'articlewell',
    'associated-people',
    'audio-card',
    //	'author', Gwern
    'authored-by',
    'author-box',
    'author-name',
    'author-bio',
    'author-mini-bio',
    'back-to-top',
    'backlinks-section',
    'banner',
    'bio-block',
    'blog-pager',
    'bookmark-',
    '-bookmark',
    'bottom-of-article',
    'brand-bar',
    'breadcrumb',
    'button-wrapper',
    'btn-',
    '-btn',
    'byline',
    'captcha',
    'card-text',
    'card-media',
    'cat_header',
    'catlinks',
    'chapter-list', // The Economist
    'collections',
    'comments',
    //	'-comment', Syntax highlighting
    'commentbox',
    'comment-count',
    'comment-content',
    'comment-form',
    'comment-number',
    'comment-respond',
    'comment-thread',
    'complementary',
    'consent',
    'content-card', // The Verge
    'content-topics',
    'contentpromo',
    'context-widget', // Reuters
    'core-collateral',
    '_cta',
    '-cta',
    'cta-',
    'cta_',
    'current-issue', // The Nation
    'custom-list-number',
    'dateline',
    'dateheader',
    'date-header',
    'date_header-',
    //	'dialog',
    'disclaimer',
    'disclosure',
    'discussion',
    'discuss_',
    'disqus',
    'donate',
    'dropdown', // Ars Technica
    'eletters',
    'emailsignup',
    'engagement-widget',
    'entry-author-info',
    'entry-categories',
    'entry-date',
    'entry-meta',
    'entry-title',
    'entry-utility',
    'eyebrow',
    'expand-reduce',
    'externallinkembedwrapper', // The New Yorker
    'extra-services',
    'extra-title',
    'facebook',
    'favorite',
    'feedback',
    'feed-links',
    'field-site-sections',
    'fixed',
    'floating-vid',
    'follow',
    'footer',
    'footnote-back',
    'footnoteback',
    'for-you',
    'frontmatter',
    'further-reading',
    'gist-meta',
    //	'global',
    'google',
    'goog-',
    'graph-view',
    'header-logo',
    'header-pattern', // The Verge
    'hero-list',
    'hide-for-print',
    'hide-print',
    'hide-when-no-script',
    'hidden-sidenote',
    'interlude',
    'interaction',
    'jumplink',
    'jump-to-',
    //	'keyword', // used in syntax highlighting
    'kicker',
    'labstab', // Arxiv
    '-labels',
    'language-name',
    'latest-content',
    '-ledes-', // The Verge
    '-license',
    'link-box',
    'links-grid', // BBC
    'links-title', // BBC
    'listing-dynamic-terms', // Boston Review
    'list-tags',
    'loading',
    'loa-info',
    'logo_container',
    'ltx_role_refnum', // Arxiv
    'ltx_tag_bibitem',
    'ltx_error',
    'marketing',
    'media-inquiry',
    'menu-',
    'meta-',
    'metadata',
    'might-like',
    '_modal',
    '-modal',
    'more-',
    'morenews',
    'morestories',
    'move-helper',
    'mw-editsection',
    'mw-cite-backlink',
    'mw-indicators',
    'mw-jump-link',
    'nav-',
    'nav_',
    'navbar',
    //	'navigation',
    'next-',
    'news-story-title',
    //	'newsletter', used on Substack
    'newsletter_',
    'newsletter-signup',
    'newslettersignup',
    'newsletterwidget',
    'newsletterwrapper',
    'not-found',
    'nomobile',
    'noprint',
    'originally-published', // Mercury News
    'outline-view',
    'overlay',
    'page-title',
    '-partners',
    'plea',
    'popular',
    //	'popup', Gwern
    'pop-up',
    'popover',
    'post-bottom',
    'post__category',
    'postcomment',
    'postdate',
    'post-author',
    'post-date',
    'post_date',
    'post-feeds',
    'postinfo',
    'post-info',
    'post_info',
    'post-inline-date',
    'post-links',
    'post-meta',
    'postmeta',
    'postsnippet',
    'post_snippet',
    'post-snippet',
    'posttitle',
    'post-title',
    'post_title',
    'posttax',
    'post-tax',
    'post_tax',
    'posttag',
    'post_tag',
    'post-tag',
    //	'preview', used on Obsidian Publish
    'prevnext',
    'previousnext',
    'press-inquiries',
    'print-none',
    'print-header',
    'profile',
    //	'promo',
    'promo-box',
    'pubdate',
    'pub_date',
    'pub-date',
    'publication-date',
    'publicationName', // Medium
    'qr-code',
    'qr_code',
    '_rail',
    'readmore',
    'read-next',
    'read_next',
    'read_time',
    'read-time',
    'reading_time',
    'reading-time',
    'reading-list',
    'recentpost',
    'recent_post',
    'recent-post',
    'recommend',
    'redirectedfrom',
    'recirc',
    'register',
    'related',
    'relevant',
    'reversefootnote',
    'screen-reader-text',
    //	'share',
    //	'-share', scitechdaily.com
    'share-box',
    'sharedaddy',
    'share-icons',
    'sharelinks',
    'share-section',
    'sidebartitle',
    'sidebar_',
    'sidebar-content',
    'similar-',
    'similar_',
    'similars-',
    'sideitems',
    'side-box',
    'site-index',
    'site-header',
    'site-logo',
    'site-name',
    //	'skip-',
    //	'skip-link', TechCrunch
    '_skip-link',
    'slug-wrap',
    'social',
    'speechify-ignore',
    'sponsor',
    'springercitation',
    //	'-stats',
    '_stats',
    'sticky',
    'storyreadtime', // Medium
    'storypublishdate', // Medium
    'subject-label',
    'subscribe',
    '_tags',
    'tags__item',
    'tag_list',
    'taxonomy',
    'table-of-contents',
    'tabs-',
    //	'teaser', Nature
    'terminaltout',
    'time-rubric',
    'timestamp',
    'tip_off',
    'tiptout',
    '-tout-',
    '-toc',
    'toggle-caption',
    'topic-list',
    'toolbar',
    'tooltip',
    'top-wrapper',
    'tree-item',
    'trending',
    'trust-feat',
    'trust-badge',
    'twitter',
    'visually-hidden',
    'welcomebox'
    //	'widget-'
];
// Selectors for footnotes and citations
exports.FOOTNOTE_INLINE_REFERENCES = [
    'sup.reference',
    'cite.ltx_cite',
    'sup[id^="fnr"]',
    'sup[id^="fnref:"]',
    'span.footnote-link',
    'a.citation',
    'a[id^="ref-link"]',
    'a[href^="#fn"]',
    'a[href^="#cite"]',
    'a[href^="#reference"]',
    'a[href^="#footnote"]',
    'a[href^="#r"]', // Common in academic papers
    'a[href^="#b"]', // Common for bibliography references
    'a[href*="cite_note"]',
    'a[href*="cite_ref"]',
    'a.footnote-anchor', // Substack
    'span.footnote-hovercard-target a', // Substack
    'a[role="doc-biblioref"]', // Science.org
    'a[id^="fnref"]',
    'a[id^="ref-link"]', // Nature.com
].join(',');
exports.FOOTNOTE_LIST_SELECTORS = [
    'div.footnote ol',
    'div.footnotes ol',
    'div[role="doc-endnotes"]',
    'div[role="doc-footnotes"]',
    'ol.footnotes-list',
    'ol.footnotes',
    'ol.references',
    'ol[class*="article-references"]',
    'section.footnotes ol',
    'section[role="doc-endnotes"]',
    'section[role="doc-footnotes"]',
    'section[role="doc-bibliography"]',
    'ul.footnotes-list',
    'ul.ltx_biblist',
    'div.footnote[data-component-name="FootnoteToDOM"]' // Substack
].join(',');
// Elements that are allowed to be empty
// These are not removed even if they have no content
exports.ALLOWED_EMPTY_ELEMENTS = new Set([
    'area',
    'audio',
    'base',
    'br',
    'circle',
    'col',
    'defs',
    'ellipse',
    'embed',
    'figure',
    'g',
    'hr',
    'iframe',
    'img',
    'input',
    'line',
    'link',
    'mask',
    'meta',
    'object',
    'param',
    'path',
    'pattern',
    'picture',
    'polygon',
    'polyline',
    'rect',
    'source',
    'stop',
    'svg',
    'td',
    'th',
    'track',
    'use',
    'video',
    'wbr'
]);
// Attributes to keep
exports.ALLOWED_ATTRIBUTES = new Set([
    'alt',
    'allow',
    'allowfullscreen',
    'aria-label',
    'checked',
    'colspan',
    'controls',
    'data-latex',
    'data-src',
    'data-srcset',
    'data-lang',
    'dir',
    'display',
    'frameborder',
    'headers',
    'height',
    'href',
    'lang',
    'role',
    'rowspan',
    'src',
    'srcset',
    'title',
    'type',
    'width',
    // MathML attributes
    'accent',
    'accentunder',
    'align',
    'columnalign',
    'columnlines',
    'columnspacing',
    'columnspan',
    'data-mjx-texclass',
    'depth',
    'displaystyle',
    'fence',
    'frame',
    'framespacing',
    'linethickness',
    'lspace',
    'mathbackground',
    'mathcolor',
    'mathsize',
    'mathvariant',
    'maxsize',
    'minsize',
    'movablelimits',
    'notation',
    'rowalign',
    'rowlines',
    'rowspacing',
    'rowspan',
    'rspace',
    'scriptlevel',
    'separator',
    'stretchy',
    'symmetric',
    'voffset',
    'xmlns'
]);
exports.ALLOWED_ATTRIBUTES_DEBUG = new Set([
    'class',
    'id',
]);
// Supported languages for code blocks
exports.SUPPORTED_LANGUAGES = new Set([
    // Markup & Web
    'markup', 'html', 'xml', 'svg', 'mathml', 'ssml', 'atom', 'rss',
    'javascript', 'js', 'jsx', 'typescript', 'ts', 'tsx',
    'webassembly', 'wasm',
    // Common Programming Languages
    'python',
    'java',
    'csharp', 'cs', 'dotnet', 'aspnet',
    'cpp', 'c++', 'c', 'objc',
    'ruby', 'rb',
    'php',
    'golang',
    'rust',
    'swift',
    'kotlin',
    'scala',
    'dart',
    // Shell & Scripting
    'bash', 'shell', 'sh',
    'powershell',
    'batch',
    // Data & Config
    'json', 'jsonp',
    'yaml', 'yml',
    'toml',
    'dockerfile',
    'gitignore',
    // Query Languages
    'sql', 'mysql', 'postgresql',
    'graphql',
    'mongodb',
    'sparql',
    // Markup & Documentation
    'markdown', 'md',
    'latex', 'tex',
    'asciidoc', 'adoc',
    'jsdoc',
    // Functional Languages
    'haskell', 'hs',
    'elm',
    'elixir',
    'erlang',
    'ocaml',
    'fsharp',
    'scheme',
    'lisp', 'elisp',
    'clojure',
    // Other Languages
    'matlab',
    'fortran',
    'cobol',
    'pascal',
    'perl',
    'lua',
    'julia',
    'groovy',
    'crystal',
    'nim',
    'zig',
    // Domain Specific
    'regex',
    'gradle',
    'cmake',
    'makefile',
    'nix',
    'terraform',
    'solidity',
    'glsl',
    'hlsl',
    // Assembly
    'nasm',
    'masm',
    'armasm',
    // Game Development
    'gdscript',
    'unrealscript',
    // Others
    'abap',
    'actionscript',
    'ada',
    'agda',
    'antlr4',
    'applescript',
    'arduino',
    'coffeescript',
    'django',
    'erlang',
    'fortran',
    'haxe',
    'idris',
    'kotlin',
    'livescript',
    'matlab',
    'nginx',
    'pascal',
    'prolog',
    'puppet',
    'scala',
    'scheme',
    'tcl',
    'verilog',
    'vhdl'
]);


/***/ }),

/***/ 914:
/*!*******************************************!*\
  !*** ./node_modules/temml/dist/temml.cjs ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/**
 * This is the ParseError class, which is the main error thrown by Temml
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 */
class ParseError {
  constructor(
    message, // The error message
    token // An object providing position information
  ) {
    let error = " " + message;
    let start;

    const loc = token && token.loc;
    if (loc && loc.start <= loc.end) {
      // If we have the input and a position, make the error a bit fancier

      // Get the input
      const input = loc.lexer.input;

      // Prepend some information
      start = loc.start;
      const end = loc.end;
      if (start === input.length) {
        error += " at end of input: ";
      } else {
        error += " at position " + (start + 1) + ": \n";
      }

      // Underline token in question using combining underscores
      const underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

      // Extract some context from the input and add it to the error
      let left;
      if (start > 15) {
        left = "…" + input.slice(start - 15, start);
      } else {
        left = input.slice(0, start);
      }
      let right;
      if (end + 15 < input.length) {
        right = input.slice(end, end + 15) + "…";
      } else {
        right = input.slice(end);
      }
      error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    const self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;
    self.position = start;
    return self;
  }
}

ParseError.prototype.__proto__ = Error.prototype;

//
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide a default value if a setting is undefined
 */
const deflt = function(setting, defaultIfUndefined) {
  return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

const uppercase = /([A-Z])/g;
const hyphenate = function(str) {
  return str.replace(uppercase, "-$1").toLowerCase();
};

const ESCAPE_LOOKUP = {
  "&": "&amp;",
  ">": "&gt;",
  "<": "&lt;",
  '"': "&quot;",
  "'": "&#x27;"
};

const ESCAPE_REGEX = /[&><"']/g;

/**
 * Escapes text to prevent scripting attacks.
 */
function escape(text) {
  return String(text).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
const getBaseElem = function(group) {
  if (group.type === "ordgroup") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "color") {
    if (group.body.length === 1) {
      return getBaseElem(group.body[0]);
    } else {
      return group;
    }
  } else if (group.type === "font") {
    return getBaseElem(group.body);
  } else {
    return group;
  }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
const isCharacterBox = function(group) {
  const baseElem = getBaseElem(group);

  // These are all the types of groups which hold single characters
  return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom"
};

const assert = function(value) {
  if (!value) {
    throw new Error("Expected non-null, but got " + String(value));
  }
  return value;
};

/**
 * Return the protocol of a URL, or "_relative" if the URL does not specify a
 * protocol (and thus is relative), or `null` if URL has invalid protocol
 * (so should be outright rejected).
 */
const protocolFromUrl = function(url) {
  // Check for possible leading protocol.
  // https://url.spec.whatwg.org/#url-parsing strips leading whitespace
  // (\x00) or C0 control (\x00-\x1F) characters.
  // eslint-disable-next-line no-control-regex
  const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
  if (!protocol) {
    return "_relative";
  }
  // Reject weird colons
  if (protocol[2] !== ":") {
    return null;
  }
  // Reject invalid characters in scheme according to
  // https://datatracker.ietf.org/doc/html/rfc3986#section-3.1
  if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
    return null;
  }
  // Lowercase the protocol
  return protocol[1].toLowerCase();
};

/**
 * Round `n` to 4 decimal places, or to the nearest 1/10,000th em. The TeXbook
 * gives an acceptable rounding error of 100sp (which would be the nearest
 * 1/6551.6em with our ptPerEm = 10):
 * http://www.ctex.org/documents/shredder/src/texbook.pdf#page=69
 */
const round = function(n) {
  return +n.toFixed(4);
};

var utils = {
  deflt,
  escape,
  hyphenate,
  getBaseElem,
  isCharacterBox,
  protocolFromUrl,
  round
};

/**
 * This is a module for storing settings passed into Temml. It correctly handles
 * default settings.
 */


/**
 * The main Settings object
 */
class Settings {
  constructor(options) {
    // allow null options
    options = options || {};
    this.displayMode = utils.deflt(options.displayMode, false);    // boolean
    this.annotate = utils.deflt(options.annotate, false);           // boolean
    this.leqno = utils.deflt(options.leqno, false);                // boolean
    this.throwOnError = utils.deflt(options.throwOnError, false);  // boolean
    this.errorColor = utils.deflt(options.errorColor, "#b22222");  // string
    this.macros = options.macros || {};
    this.wrap = utils.deflt(options.wrap, "tex");                    // "tex" | "="
    this.xml = utils.deflt(options.xml, false);                     // boolean
    this.colorIsTextColor = utils.deflt(options.colorIsTextColor, false);  // booelean
    this.strict = utils.deflt(options.strict, false);    // boolean
    this.trust = utils.deflt(options.trust, false);  // trust context. See html.js.
    this.maxSize = (options.maxSize === undefined
      ? [Infinity, Infinity]
      : Array.isArray(options.maxSize)
      ? options.maxSize
      : [Infinity, Infinity]
    );
    this.maxExpand = Math.max(0, utils.deflt(options.maxExpand, 1000)); // number
  }

  /**
   * Check whether to test potentially dangerous input, and return
   * `true` (trusted) or `false` (untrusted).  The sole argument `context`
   * should be an object with `command` field specifying the relevant LaTeX
   * command (as a string starting with `\`), and any other arguments, etc.
   * If `context` has a `url` field, a `protocol` field will automatically
   * get added by this function (changing the specified object).
   */
  isTrusted(context) {
    if (context.url && !context.protocol) {
      const protocol = utils.protocolFromUrl(context.url);
      if (protocol == null) {
        return false
      }
      context.protocol = protocol;
    }
    const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
    return Boolean(trust);
  }
}

/**
 * All registered functions.
 * `functions.js` just exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary.
 */
const _functions = {};

/**
 * All MathML builders. Should be only used in the `define*` and the `build*ML`
 * functions.
 */
const _mathmlGroupBuilders = {};

function defineFunction({
  type,
  names,
  props,
  handler,
  mathmlBuilder
}) {
  // Set default values of functions
  const data = {
    type,
    numArgs: props.numArgs,
    argTypes: props.argTypes,
    allowedInArgument: !!props.allowedInArgument,
    allowedInText: !!props.allowedInText,
    allowedInMath: props.allowedInMath === undefined ? true : props.allowedInMath,
    numOptionalArgs: props.numOptionalArgs || 0,
    infix: !!props.infix,
    primitive: !!props.primitive,
    handler: handler
  };
  for (let i = 0; i < names.length; ++i) {
    _functions[names[i]] = data;
  }
  if (type) {
    if (mathmlBuilder) {
      _mathmlGroupBuilders[type] = mathmlBuilder;
    }
  }
}

/**
 * Use this to register only the MathML builder for a function(e.g.
 * if the function's ParseNode is generated in Parser.js rather than via a
 * stand-alone handler provided to `defineFunction`).
 */
function defineFunctionBuilders({ type, mathmlBuilder }) {
  defineFunction({
    type,
    names: [],
    props: { numArgs: 0 },
    handler() {
      throw new Error("Should never be called.")
    },
    mathmlBuilder
  });
}

const normalizeArgument = function(arg) {
  return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg
};

// Since the corresponding buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
const ordargument = function(arg) {
  return arg.type === "ordgroup" ? arg.body : [arg]
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. It only contains
 * children and doesn't have any DOM node properties.
 */
class DocumentFragment {
  constructor(children) {
    this.children = children;
    this.classes = [];
    this.style = {};
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  /** Convert the fragment into a node. */
  toNode() {
    const frag = document.createDocumentFragment();

    for (let i = 0; i < this.children.length; i++) {
      frag.appendChild(this.children[i].toNode());
    }

    return frag;
  }

  /** Convert the fragment into HTML markup. */
  toMarkup() {
    let markup = "";

    // Simply concatenate the markup for the children together.
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText. Applies to
   * MathDomNode's only.
   */
  toText() {
    // To avoid this, we would subclass documentFragment separately for
    // MathML, but polyfills for subclassing is expensive per PR 1469.
    const toText = (child) => child.toText();
    return this.children.map(toText).join("");
  }
}

/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 *
 */

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove empty classes.
 */
const createClass = function(classes) {
  return classes.filter((cls) => cls).join(" ");
};

const initNode = function(classes, style) {
  this.classes = classes || [];
  this.attributes = {};
  this.style = style || {};
};

/**
 * Convert into an HTML node
 */
const toNode = function(tagName) {
  const node = document.createElement(tagName);

  // Apply the class
  node.className = createClass(this.classes);

  // Apply inline styles
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      node.style[style] = this.style[style];
    }
  }

  // Apply attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      node.setAttribute(attr, this.attributes[attr]);
    }
  }

  // Append the children, also as HTML nodes
  for (let i = 0; i < this.children.length; i++) {
    node.appendChild(this.children[i].toNode());
  }

  return node;
};

/**
 * Convert into an HTML markup string
 */
const toMarkup = function(tagName) {
  let markup = `<${tagName}`;

  // Add the class
  if (this.classes.length) {
    markup += ` class="${utils.escape(createClass(this.classes))}"`;
  }

  let styles = "";

  // Add the styles, after hyphenation
  for (const style in this.style) {
    if (Object.prototype.hasOwnProperty.call(this.style, style )) {
      styles += `${utils.hyphenate(style)}:${this.style[style]};`;
    }
  }

  if (styles) {
    markup += ` style="${styles}"`;
  }

  // Add the attributes
  for (const attr in this.attributes) {
    if (Object.prototype.hasOwnProperty.call(this.attributes, attr )) {
      markup += ` ${attr}="${utils.escape(this.attributes[attr])}"`;
    }
  }

  markup += ">";

  // Add the markup of the children, also as markup
  for (let i = 0; i < this.children.length; i++) {
    markup += this.children[i].toMarkup();
  }

  markup += `</${tagName}>`;

  return markup;
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style.
 *
 */
class Span {
  constructor(classes, children, style) {
    initNode.call(this, classes, style);
    this.children = children || [];
  }

  setAttribute(attribute, value) {
    this.attributes[attribute] = value;
  }

  toNode() {
    return toNode.call(this, "span");
  }

  toMarkup() {
    return toMarkup.call(this, "span");
  }
}

let TextNode$1 = class TextNode {
  constructor(text) {
    this.text = text;
  }
  toNode() {
    return document.createTextNode(this.text);
  }
  toMarkup() {
    return utils.escape(this.text);
  }
};

// Create an <a href="…"> node.
class AnchorNode {
  constructor(href, classes, children) {
    this.href = href;
    this.classes = classes;
    this.children = children || [];
  }

  toNode() {
    const node = document.createElement("a");
    node.setAttribute("href", this.href);
    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }
    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }
    return node
  }

  toMarkup() {
    let markup = `<a href='${utils.escape(this.href)}'`;
    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }
    markup += ">";
    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }
    markup += "</a>";
    return markup
  }
}

/*
 * This node represents an image embed (<img>) element.
 */
class Img {
  constructor(src, alt, style) {
    this.alt = alt;
    this.src = src;
    this.classes = ["mord"];
    this.style = style;
  }

  hasClass(className) {
    return this.classes.includes(className);
  }

  toNode() {
    const node = document.createElement("img");
    node.src = this.src;
    node.alt = this.alt;
    node.className = "mord";

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    return node;
  }

  toMarkup() {
    let markup = `<img src='${this.src}' alt='${this.alt}'`;

    // Add the styles, after hyphenation
    let styles = "";
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }
    if (styles) {
      markup += ` style="${utils.escape(styles)}"`;
    }

    markup += ">";
    return markup;
  }
}

//
/**
 * These objects store data about MathML nodes.
 * The `toNode` and `toMarkup` functions  create namespaced DOM nodes and
 * HTML text markup respectively.
 */


function newDocumentFragment(children) {
  return new DocumentFragment(children);
}

/**
 * This node represents a general purpose MathML node of any type,
 * for example, `"mo"` or `"mspace"`, corresponding to `<mo>` and
 * `<mspace>` tags).
 */
class MathNode {
  constructor(type, children, classes, style) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
    this.classes = classes || [];
    this.style = style || {};   // Used for <mstyle> elements
    this.label = "";
  }

  /**
   * Sets an attribute on a MathML node. MathML depends on attributes to convey a
   * semantic content, so this is used heavily.
   */
  setAttribute(name, value) {
    this.attributes[name] = value;
  }

  /**
   * Gets an attribute on a MathML node.
   */
  getAttribute(name) {
    return this.attributes[name];
  }

  setLabel(value) {
    this.label = value;
  }

  /**
   * Converts the math node into a MathML-namespaced DOM element.
   */
  toNode() {
    const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);

    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        node.setAttribute(attr, this.attributes[attr]);
      }
    }

    if (this.classes.length > 0) {
      node.className = createClass(this.classes);
    }

    // Apply inline styles
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        node.style[style] = this.style[style];
      }
    }

    for (let i = 0; i < this.children.length; i++) {
      node.appendChild(this.children[i].toNode());
    }

    return node;
  }

  /**
   * Converts the math node into an HTML markup string.
   */
  toMarkup() {
    let markup = "<" + this.type;

    // Add the attributes
    for (const attr in this.attributes) {
      if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
        markup += " " + attr + '="';
        markup += utils.escape(this.attributes[attr]);
        markup += '"';
      }
    }

    if (this.classes.length > 0) {
      markup += ` class="${utils.escape(createClass(this.classes))}"`;
    }

    let styles = "";

    // Add the styles, after hyphenation
    for (const style in this.style) {
      if (Object.prototype.hasOwnProperty.call(this.style, style )) {
        styles += `${utils.hyphenate(style)}:${this.style[style]};`;
      }
    }

    if (styles) {
      markup += ` style="${styles}"`;
    }

    markup += ">";

    for (let i = 0; i < this.children.length; i++) {
      markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
  }

  /**
   * Converts the math node into a string, similar to innerText, but escaped.
   */
  toText() {
    return this.children.map((child) => child.toText()).join("");
  }
}

/**
 * This node represents a piece of text.
 */
class TextNode {
  constructor(text) {
    this.text = text;
  }

  /**
   * Converts the text node into a DOM text node.
   */
  toNode() {
    return document.createTextNode(this.text);
  }

  /**
   * Converts the text node into escaped HTML markup
   * (representing the text itself).
   */
  toMarkup() {
    return utils.escape(this.toText());
  }

  /**
   * Converts the text node into a string
   * (representing the text itself).
   */
  toText() {
    return this.text;
  }
}

// Do not make an <mrow> the only child of a <mstyle>.
// An <mstyle> acts as its own implicit <mrow>.
const wrapWithMstyle = expression => {
  let node;
  if (expression.length === 1 && expression[0].type === "mrow") {
    node = expression.pop();
    node.type = "mstyle";
  } else {
    node = new MathNode("mstyle", expression);
  }
  return node
};

var mathMLTree = {
  MathNode,
  TextNode,
  newDocumentFragment
};

/**
 * This file provides support for building horizontal stretchy elements.
 */


// TODO: Remove when Chromium stretches \widetilde & \widehat
const estimatedWidth = node => {
  let width = 0;
  if (node.body) {
    for (const item of node.body) {
      width += estimatedWidth(item);
    }
  } else if (node.type === "supsub") {
    width += estimatedWidth(node.base);
    if (node.sub) { width += 0.7 * estimatedWidth(node.sub); }
    if (node.sup) { width += 0.7 * estimatedWidth(node.sup); }
  } else if (node.type === "mathord" || node.type === "textord") {
    for (const ch of node.text.split('')) {
      const codePoint = ch.codePointAt(0);
      if ((0x60 < codePoint && codePoint < 0x7B) || (0x03B0 < codePoint && codePoint < 0x3CA)) {
        width += 0.56; // lower case latin or greek. Use advance width of letter n
      } else if (0x2F < codePoint && codePoint < 0x3A) {
        width += 0.50; // numerals.
      } else {
        width += 0.92; // advance width of letter M
      }
    }
  } else {
    width += 1.0;
  }
  return width
};

const stretchyCodePoint = {
  widehat: "^",
  widecheck: "ˇ",
  widetilde: "~",
  wideparen: "⏜", // \u23dc
  utilde: "~",
  overleftarrow: "\u2190",
  underleftarrow: "\u2190",
  xleftarrow: "\u2190",
  overrightarrow: "\u2192",
  underrightarrow: "\u2192",
  xrightarrow: "\u2192",
  underbrace: "\u23df",
  overbrace: "\u23de",
  overgroup: "\u23e0",
  overparen: "⏜",
  undergroup: "\u23e1",
  underparen: "\u23dd",
  overleftrightarrow: "\u2194",
  underleftrightarrow: "\u2194",
  xleftrightarrow: "\u2194",
  Overrightarrow: "\u21d2",
  xRightarrow: "\u21d2",
  overleftharpoon: "\u21bc",
  xleftharpoonup: "\u21bc",
  overrightharpoon: "\u21c0",
  xrightharpoonup: "\u21c0",
  xLeftarrow: "\u21d0",
  xLeftrightarrow: "\u21d4",
  xhookleftarrow: "\u21a9",
  xhookrightarrow: "\u21aa",
  xmapsto: "\u21a6",
  xrightharpoondown: "\u21c1",
  xleftharpoondown: "\u21bd",
  xtwoheadleftarrow: "\u219e",
  xtwoheadrightarrow: "\u21a0",
  xlongequal: "=",
  xrightleftarrows: "\u21c4",
  yields: "\u2192",
  yieldsLeft: "\u2190",
  mesomerism: "\u2194",
  longrightharpoonup: "\u21c0",
  longleftharpoondown: "\u21bd",
  eqrightharpoonup: "\u21c0",
  eqleftharpoondown: "\u21bd",
  "\\cdrightarrow": "\u2192",
  "\\cdleftarrow": "\u2190",
  "\\cdlongequal": "="
};

const mathMLnode = function(label) {
  const child = new mathMLTree.TextNode(stretchyCodePoint[label.slice(1)]);
  const node = new mathMLTree.MathNode("mo", [child]);
  node.setAttribute("stretchy", "true");
  return node
};

const crookedWides = ["\\widetilde", "\\widehat", "\\widecheck", "\\utilde"];

// TODO: Remove when Chromium stretches \widetilde & \widehat
const accentNode = (group) => {
  const mo = mathMLnode(group.label);
  if (crookedWides.includes(group.label)) {
    const width = estimatedWidth(group.base);
    if (1 < width && width < 1.6) {
      mo.classes.push("tml-crooked-2");
    } else if (1.6 <= width && width < 2.5) {
      mo.classes.push("tml-crooked-3");
    } else if (2.5 <= width) {
      mo.classes.push("tml-crooked-4");
    }
  }
  return mo
};

var stretchy = {
  mathMLnode,
  accentNode
};

/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are two properties they can have:
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

// Some of these have a "-token" suffix since these are also used as `ParseNode`
// types for raw text tokens, and we want to avoid conflicts with higher-level
// `ParseNode` types. These `ParseNode`s are constructed within `Parser` by
// looking up the `symbols` map.
const ATOMS = {
  bin: 1,
  close: 1,
  inner: 1,
  open: 1,
  punct: 1,
  rel: 1
};
const NON_ATOMS = {
  "accent-token": 1,
  mathord: 1,
  "op-token": 1,
  spacing: 1,
  textord: 1
};

const symbols = {
  math: {},
  text: {}
};

/** `acceptUnicodeChar = true` is only applicable if `replace` is set. */
function defineSymbol(mode, group, replace, name, acceptUnicodeChar) {
  symbols[mode][name] = { group, replace };

  if (acceptUnicodeChar && replace) {
    symbols[mode][replace] = symbols[mode][name];
  }
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
const math = "math";
const text = "text";

// groups:
const accent = "accent-token";
const bin = "bin";
const close = "close";
const inner = "inner";
const mathord = "mathord";
const op = "op-token";
const open = "open";
const punct = "punct";
const rel = "rel";
const spacing = "spacing";
const textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, rel, "\u2261", "\\equiv", true);
defineSymbol(math, rel, "\u227a", "\\prec", true);
defineSymbol(math, rel, "\u227b", "\\succ", true);
defineSymbol(math, rel, "\u223c", "\\sim", true);
defineSymbol(math, rel, "\u27c2", "\\perp", true);
defineSymbol(math, rel, "\u2aaf", "\\preceq", true);
defineSymbol(math, rel, "\u2ab0", "\\succeq", true);
defineSymbol(math, rel, "\u2243", "\\simeq", true);
defineSymbol(math, rel, "\u224c", "\\backcong", true);
defineSymbol(math, rel, "|", "\\mid", true);
defineSymbol(math, rel, "\u226a", "\\ll", true);
defineSymbol(math, rel, "\u226b", "\\gg", true);
defineSymbol(math, rel, "\u224d", "\\asymp", true);
defineSymbol(math, rel, "\u2225", "\\parallel");
defineSymbol(math, rel, "\u2323", "\\smile", true);
defineSymbol(math, rel, "\u2291", "\\sqsubseteq", true);
defineSymbol(math, rel, "\u2292", "\\sqsupseteq", true);
defineSymbol(math, rel, "\u2250", "\\doteq", true);
defineSymbol(math, rel, "\u2322", "\\frown", true);
defineSymbol(math, rel, "\u220b", "\\ni", true);
defineSymbol(math, rel, "\u220c", "\\notni", true);
defineSymbol(math, rel, "\u221d", "\\propto", true);
defineSymbol(math, rel, "\u22a2", "\\vdash", true);
defineSymbol(math, rel, "\u22a3", "\\dashv", true);
defineSymbol(math, rel, "\u220b", "\\owns");
defineSymbol(math, rel, "\u2258", "\\arceq", true);
defineSymbol(math, rel, "\u2259", "\\wedgeq", true);
defineSymbol(math, rel, "\u225a", "\\veeeq", true);
defineSymbol(math, rel, "\u225b", "\\stareq", true);
defineSymbol(math, rel, "\u225d", "\\eqdef", true);
defineSymbol(math, rel, "\u225e", "\\measeq", true);
defineSymbol(math, rel, "\u225f", "\\questeq", true);
defineSymbol(math, rel, "\u2260", "\\ne", true);
defineSymbol(math, rel, "\u2260", "\\neq");
// unicodemath
defineSymbol(math, rel, "\u2a75", "\\eqeq", true);
defineSymbol(math, rel, "\u2a76", "\\eqeqeq", true);
// mathtools.sty
defineSymbol(math, rel, "\u2237", "\\dblcolon", true);
defineSymbol(math, rel, "\u2254", "\\coloneqq", true);
defineSymbol(math, rel, "\u2255", "\\eqqcolon", true);
defineSymbol(math, rel, "\u2239", "\\eqcolon", true);
defineSymbol(math, rel, "\u2A74", "\\Coloneqq", true);

// Punctuation
defineSymbol(math, punct, "\u002e", "\\ldotp");
defineSymbol(math, punct, "\u00b7", "\\cdotp");

// Misc Symbols
defineSymbol(math, textord, "\u0023", "\\#");
defineSymbol(text, textord, "\u0023", "\\#");
defineSymbol(math, textord, "\u0026", "\\&");
defineSymbol(text, textord, "\u0026", "\\&");
defineSymbol(math, textord, "\u2135", "\\aleph", true);
defineSymbol(math, textord, "\u2200", "\\forall", true);
defineSymbol(math, textord, "\u210f", "\\hbar", true);
defineSymbol(math, textord, "\u2203", "\\exists", true);
// ∇ is actually a unary operator, not binary. But this works.
defineSymbol(math, bin, "\u2207", "\\nabla", true);
defineSymbol(math, textord, "\u266d", "\\flat", true);
defineSymbol(math, textord, "\u2113", "\\ell", true);
defineSymbol(math, textord, "\u266e", "\\natural", true);
defineSymbol(math, textord, "Å", "\\Angstrom", true);
defineSymbol(text, textord, "Å", "\\Angstrom", true);
defineSymbol(math, textord, "\u2663", "\\clubsuit", true);
defineSymbol(math, textord, "\u2667", "\\varclubsuit", true);
defineSymbol(math, textord, "\u2118", "\\wp", true);
defineSymbol(math, textord, "\u266f", "\\sharp", true);
defineSymbol(math, textord, "\u2662", "\\diamondsuit", true);
defineSymbol(math, textord, "\u2666", "\\vardiamondsuit", true);
defineSymbol(math, textord, "\u211c", "\\Re", true);
defineSymbol(math, textord, "\u2661", "\\heartsuit", true);
defineSymbol(math, textord, "\u2665", "\\varheartsuit", true);
defineSymbol(math, textord, "\u2111", "\\Im", true);
defineSymbol(math, textord, "\u2660", "\\spadesuit", true);
defineSymbol(math, textord, "\u2664", "\\varspadesuit", true);
defineSymbol(math, textord, "\u2640", "\\female", true);
defineSymbol(math, textord, "\u2642", "\\male", true);
defineSymbol(math, textord, "\u00a7", "\\S", true);
defineSymbol(text, textord, "\u00a7", "\\S");
defineSymbol(math, textord, "\u00b6", "\\P", true);
defineSymbol(text, textord, "\u00b6", "\\P");
defineSymbol(text, textord, "\u263a", "\\smiley", true);
defineSymbol(math, textord, "\u263a", "\\smiley", true);

// Math and Text
defineSymbol(math, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\dag");
defineSymbol(text, textord, "\u2020", "\\textdagger");
defineSymbol(math, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\ddag");
defineSymbol(text, textord, "\u2021", "\\textdaggerdbl");

// Large Delimiters
defineSymbol(math, close, "\u23b1", "\\rmoustache", true);
defineSymbol(math, open, "\u23b0", "\\lmoustache", true);
defineSymbol(math, close, "\u27ef", "\\rgroup", true);
defineSymbol(math, open, "\u27ee", "\\lgroup", true);

// Binary Operators
defineSymbol(math, bin, "\u2213", "\\mp", true);
defineSymbol(math, bin, "\u2296", "\\ominus", true);
defineSymbol(math, bin, "\u228e", "\\uplus", true);
defineSymbol(math, bin, "\u2293", "\\sqcap", true);
defineSymbol(math, bin, "\u2217", "\\ast");
defineSymbol(math, bin, "\u2294", "\\sqcup", true);
defineSymbol(math, bin, "\u25ef", "\\bigcirc", true);
defineSymbol(math, bin, "\u2219", "\\bullet", true);
defineSymbol(math, bin, "\u2021", "\\ddagger");
defineSymbol(math, bin, "\u2240", "\\wr", true);
defineSymbol(math, bin, "\u2a3f", "\\amalg");
defineSymbol(math, bin, "\u0026", "\\And"); // from amsmath
defineSymbol(math, bin, "\u2AFD", "\\sslash", true); // from stmaryrd

// Arrow Symbols
defineSymbol(math, rel, "\u27f5", "\\longleftarrow", true);
defineSymbol(math, rel, "\u21d0", "\\Leftarrow", true);
defineSymbol(math, rel, "\u27f8", "\\Longleftarrow", true);
defineSymbol(math, rel, "\u27f6", "\\longrightarrow", true);
defineSymbol(math, rel, "\u21d2", "\\Rightarrow", true);
defineSymbol(math, rel, "\u27f9", "\\Longrightarrow", true);
defineSymbol(math, rel, "\u2194", "\\leftrightarrow", true);
defineSymbol(math, rel, "\u27f7", "\\longleftrightarrow", true);
defineSymbol(math, rel, "\u21d4", "\\Leftrightarrow", true);
defineSymbol(math, rel, "\u27fa", "\\Longleftrightarrow", true);
defineSymbol(math, rel, "\u21a4", "\\mapsfrom", true);
defineSymbol(math, rel, "\u21a6", "\\mapsto", true);
defineSymbol(math, rel, "\u27fc", "\\longmapsto", true);
defineSymbol(math, rel, "\u2197", "\\nearrow", true);
defineSymbol(math, rel, "\u21a9", "\\hookleftarrow", true);
defineSymbol(math, rel, "\u21aa", "\\hookrightarrow", true);
defineSymbol(math, rel, "\u2198", "\\searrow", true);
defineSymbol(math, rel, "\u21bc", "\\leftharpoonup", true);
defineSymbol(math, rel, "\u21c0", "\\rightharpoonup", true);
defineSymbol(math, rel, "\u2199", "\\swarrow", true);
defineSymbol(math, rel, "\u21bd", "\\leftharpoondown", true);
defineSymbol(math, rel, "\u21c1", "\\rightharpoondown", true);
defineSymbol(math, rel, "\u2196", "\\nwarrow", true);
defineSymbol(math, rel, "\u21cc", "\\rightleftharpoons", true);
defineSymbol(math, mathord, "\u21af", "\\lightning", true);
defineSymbol(math, mathord, "\u220E", "\\QED", true);
defineSymbol(math, mathord, "\u2030", "\\permil", true);
defineSymbol(text, textord, "\u2030", "\\permil");
defineSymbol(math, mathord, "\u2609", "\\astrosun", true);
defineSymbol(math, mathord, "\u263c", "\\sun", true);
defineSymbol(math, mathord, "\u263e", "\\leftmoon", true);
defineSymbol(math, mathord, "\u263d", "\\rightmoon", true);
defineSymbol(math, mathord, "\u2295", "\\Earth");

// AMS Negated Binary Relations
defineSymbol(math, rel, "\u226e", "\\nless", true);
// Symbol names preceeded by "@" each have a corresponding macro.
defineSymbol(math, rel, "\u2a87", "\\lneq", true);
defineSymbol(math, rel, "\u2268", "\\lneqq", true);
defineSymbol(math, rel, "\u2268\ufe00", "\\lvertneqq");
defineSymbol(math, rel, "\u22e6", "\\lnsim", true);
defineSymbol(math, rel, "\u2a89", "\\lnapprox", true);
defineSymbol(math, rel, "\u2280", "\\nprec", true);
// unicode-math maps \u22e0 to \npreccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e0", "\\npreceq", true);
defineSymbol(math, rel, "\u22e8", "\\precnsim", true);
defineSymbol(math, rel, "\u2ab9", "\\precnapprox", true);
defineSymbol(math, rel, "\u2241", "\\nsim", true);
defineSymbol(math, rel, "\u2224", "\\nmid", true);
defineSymbol(math, rel, "\u2224", "\\nshortmid");
defineSymbol(math, rel, "\u22ac", "\\nvdash", true);
defineSymbol(math, rel, "\u22ad", "\\nvDash", true);
defineSymbol(math, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, rel, "\u22ec", "\\ntrianglelefteq", true);
defineSymbol(math, rel, "\u2284", "\\nsubset", true);
defineSymbol(math, rel, "\u2285", "\\nsupset", true);
defineSymbol(math, rel, "\u228a", "\\subsetneq", true);
defineSymbol(math, rel, "\u228a\ufe00", "\\varsubsetneq");
defineSymbol(math, rel, "\u2acb", "\\subsetneqq", true);
defineSymbol(math, rel, "\u2acb\ufe00", "\\varsubsetneqq");
defineSymbol(math, rel, "\u226f", "\\ngtr", true);
defineSymbol(math, rel, "\u2a88", "\\gneq", true);
defineSymbol(math, rel, "\u2269", "\\gneqq", true);
defineSymbol(math, rel, "\u2269\ufe00", "\\gvertneqq");
defineSymbol(math, rel, "\u22e7", "\\gnsim", true);
defineSymbol(math, rel, "\u2a8a", "\\gnapprox", true);
defineSymbol(math, rel, "\u2281", "\\nsucc", true);
// unicode-math maps \u22e1 to \nsucccurlyeq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u22e1", "\\nsucceq", true);
defineSymbol(math, rel, "\u22e9", "\\succnsim", true);
defineSymbol(math, rel, "\u2aba", "\\succnapprox", true);
// unicode-math maps \u2246 to \simneqq. We'll use the AMS synonym.
defineSymbol(math, rel, "\u2246", "\\ncong", true);
defineSymbol(math, rel, "\u2226", "\\nparallel", true);
defineSymbol(math, rel, "\u2226", "\\nshortparallel");
defineSymbol(math, rel, "\u22af", "\\nVDash", true);
defineSymbol(math, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, rel, "\u22ed", "\\ntrianglerighteq", true);
defineSymbol(math, rel, "\u228b", "\\supsetneq", true);
defineSymbol(math, rel, "\u228b", "\\varsupsetneq");
defineSymbol(math, rel, "\u2acc", "\\supsetneqq", true);
defineSymbol(math, rel, "\u2acc\ufe00", "\\varsupsetneqq");
defineSymbol(math, rel, "\u22ae", "\\nVdash", true);
defineSymbol(math, rel, "\u2ab5", "\\precneqq", true);
defineSymbol(math, rel, "\u2ab6", "\\succneqq", true);
defineSymbol(math, bin, "\u22b4", "\\unlhd");
defineSymbol(math, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, rel, "\u219a", "\\nleftarrow", true);
defineSymbol(math, rel, "\u219b", "\\nrightarrow", true);
defineSymbol(math, rel, "\u21cd", "\\nLeftarrow", true);
defineSymbol(math, rel, "\u21cf", "\\nRightarrow", true);
defineSymbol(math, rel, "\u21ae", "\\nleftrightarrow", true);
defineSymbol(math, rel, "\u21ce", "\\nLeftrightarrow", true);

// AMS Misc
defineSymbol(math, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, textord, "\u210f", "\\hslash");
defineSymbol(math, textord, "\u25bd", "\\triangledown");
defineSymbol(math, textord, "\u25ca", "\\lozenge");
defineSymbol(math, textord, "\u24c8", "\\circledS");
defineSymbol(math, textord, "\u00ae", "\\circledR", true);
defineSymbol(text, textord, "\u00ae", "\\circledR");
defineSymbol(text, textord, "\u00ae", "\\textregistered");
defineSymbol(math, textord, "\u2221", "\\measuredangle", true);
defineSymbol(math, textord, "\u2204", "\\nexists");
defineSymbol(math, textord, "\u2127", "\\mho");
defineSymbol(math, textord, "\u2132", "\\Finv", true);
defineSymbol(math, textord, "\u2141", "\\Game", true);
defineSymbol(math, textord, "\u2035", "\\backprime");
defineSymbol(math, textord, "\u2036", "\\backdprime");
defineSymbol(math, textord, "\u2037", "\\backtrprime");
defineSymbol(math, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, textord, "\u2605", "\\bigstar");
defineSymbol(math, textord, "\u2222", "\\sphericalangle", true);
defineSymbol(math, textord, "\u2201", "\\complement", true);
// unicode-math maps U+F0 to \matheth. We map to AMS function \eth
defineSymbol(math, textord, "\u00f0", "\\eth", true);
defineSymbol(text, textord, "\u00f0", "\u00f0");
defineSymbol(math, textord, "\u2571", "\\diagup");
defineSymbol(math, textord, "\u2572", "\\diagdown");
defineSymbol(math, textord, "\u25a1", "\\square");
defineSymbol(math, textord, "\u25a1", "\\Box");
defineSymbol(math, textord, "\u25ca", "\\Diamond");
// unicode-math maps U+A5 to \mathyen. We map to AMS function \yen
defineSymbol(math, textord, "\u00a5", "\\yen", true);
defineSymbol(text, textord, "\u00a5", "\\yen", true);
defineSymbol(math, textord, "\u2713", "\\checkmark", true);
defineSymbol(text, textord, "\u2713", "\\checkmark");
defineSymbol(math, textord, "\u2717", "\\ballotx", true);
defineSymbol(text, textord, "\u2717", "\\ballotx");
defineSymbol(text, textord, "\u2022", "\\textbullet");

// AMS Hebrew
defineSymbol(math, textord, "\u2136", "\\beth", true);
defineSymbol(math, textord, "\u2138", "\\daleth", true);
defineSymbol(math, textord, "\u2137", "\\gimel", true);

// AMS Greek
defineSymbol(math, textord, "\u03dd", "\\digamma", true);
defineSymbol(math, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, open, "\u231C", "\\ulcorner", true);
defineSymbol(math, close, "\u231D", "\\urcorner", true);
defineSymbol(math, open, "\u231E", "\\llcorner", true);
defineSymbol(math, close, "\u231F", "\\lrcorner", true);

// AMS Binary Relations
defineSymbol(math, rel, "\u2266", "\\leqq", true);
defineSymbol(math, rel, "\u2a7d", "\\leqslant", true);
defineSymbol(math, rel, "\u2a95", "\\eqslantless", true);
defineSymbol(math, rel, "\u2272", "\\lesssim", true);
defineSymbol(math, rel, "\u2a85", "\\lessapprox", true);
defineSymbol(math, rel, "\u224a", "\\approxeq", true);
defineSymbol(math, bin, "\u22d6", "\\lessdot");
defineSymbol(math, rel, "\u22d8", "\\lll", true);
defineSymbol(math, rel, "\u2276", "\\lessgtr", true);
defineSymbol(math, rel, "\u22da", "\\lesseqgtr", true);
defineSymbol(math, rel, "\u2a8b", "\\lesseqqgtr", true);
defineSymbol(math, rel, "\u2251", "\\doteqdot");
defineSymbol(math, rel, "\u2253", "\\risingdotseq", true);
defineSymbol(math, rel, "\u2252", "\\fallingdotseq", true);
defineSymbol(math, rel, "\u223d", "\\backsim", true);
defineSymbol(math, rel, "\u22cd", "\\backsimeq", true);
defineSymbol(math, rel, "\u2ac5", "\\subseteqq", true);
defineSymbol(math, rel, "\u22d0", "\\Subset", true);
defineSymbol(math, rel, "\u228f", "\\sqsubset", true);
defineSymbol(math, rel, "\u227c", "\\preccurlyeq", true);
defineSymbol(math, rel, "\u22de", "\\curlyeqprec", true);
defineSymbol(math, rel, "\u227e", "\\precsim", true);
defineSymbol(math, rel, "\u2ab7", "\\precapprox", true);
defineSymbol(math, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, rel, "\u22a8", "\\vDash", true);
defineSymbol(math, rel, "\u22ab", "\\VDash", true);
defineSymbol(math, rel, "\u22aa", "\\Vvdash", true);
defineSymbol(math, rel, "\u2323", "\\smallsmile");
defineSymbol(math, rel, "\u2322", "\\smallfrown");
defineSymbol(math, rel, "\u224f", "\\bumpeq", true);
defineSymbol(math, rel, "\u224e", "\\Bumpeq", true);
defineSymbol(math, rel, "\u2267", "\\geqq", true);
defineSymbol(math, rel, "\u2a7e", "\\geqslant", true);
defineSymbol(math, rel, "\u2a96", "\\eqslantgtr", true);
defineSymbol(math, rel, "\u2273", "\\gtrsim", true);
defineSymbol(math, rel, "\u2a86", "\\gtrapprox", true);
defineSymbol(math, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, rel, "\u22d9", "\\ggg", true);
defineSymbol(math, rel, "\u2277", "\\gtrless", true);
defineSymbol(math, rel, "\u22db", "\\gtreqless", true);
defineSymbol(math, rel, "\u2a8c", "\\gtreqqless", true);
defineSymbol(math, rel, "\u2256", "\\eqcirc", true);
defineSymbol(math, rel, "\u2257", "\\circeq", true);
defineSymbol(math, rel, "\u225c", "\\triangleq", true);
defineSymbol(math, rel, "\u223c", "\\thicksim");
defineSymbol(math, rel, "\u2248", "\\thickapprox");
defineSymbol(math, rel, "\u2ac6", "\\supseteqq", true);
defineSymbol(math, rel, "\u22d1", "\\Supset", true);
defineSymbol(math, rel, "\u2290", "\\sqsupset", true);
defineSymbol(math, rel, "\u227d", "\\succcurlyeq", true);
defineSymbol(math, rel, "\u22df", "\\curlyeqsucc", true);
defineSymbol(math, rel, "\u227f", "\\succsim", true);
defineSymbol(math, rel, "\u2ab8", "\\succapprox", true);
defineSymbol(math, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, rel, "\u22a9", "\\Vdash", true);
defineSymbol(math, rel, "\u2223", "\\shortmid");
defineSymbol(math, rel, "\u2225", "\\shortparallel");
defineSymbol(math, rel, "\u226c", "\\between", true);
defineSymbol(math, rel, "\u22d4", "\\pitchfork", true);
defineSymbol(math, rel, "\u221d", "\\varpropto");
defineSymbol(math, rel, "\u25c0", "\\blacktriangleleft");
// unicode-math says that \therefore is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2234", "\\therefore", true);
defineSymbol(math, rel, "\u220d", "\\backepsilon");
defineSymbol(math, rel, "\u25b6", "\\blacktriangleright");
// unicode-math says that \because is a mathord atom.
// We kept the amssymb atom type, which is rel.
defineSymbol(math, rel, "\u2235", "\\because", true);
defineSymbol(math, rel, "\u22d8", "\\llless");
defineSymbol(math, rel, "\u22d9", "\\gggtr");
defineSymbol(math, bin, "\u22b2", "\\lhd");
defineSymbol(math, bin, "\u22b3", "\\rhd");
defineSymbol(math, rel, "\u2242", "\\eqsim", true);
defineSymbol(math, rel, "\u2251", "\\Doteq", true);
defineSymbol(math, rel, "\u297d", "\\strictif", true);
defineSymbol(math, rel, "\u297c", "\\strictfi", true);

// AMS Binary Operators
defineSymbol(math, bin, "\u2214", "\\dotplus", true);
defineSymbol(math, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, bin, "\u22d2", "\\Cap", true);
defineSymbol(math, bin, "\u22d3", "\\Cup", true);
defineSymbol(math, bin, "\u2a5e", "\\doublebarwedge", true);
defineSymbol(math, bin, "\u229f", "\\boxminus", true);
defineSymbol(math, bin, "\u229e", "\\boxplus", true);
defineSymbol(math, bin, "\u29C4", "\\boxslash", true);
defineSymbol(math, bin, "\u22c7", "\\divideontimes", true);
defineSymbol(math, bin, "\u22c9", "\\ltimes", true);
defineSymbol(math, bin, "\u22ca", "\\rtimes", true);
defineSymbol(math, bin, "\u22cb", "\\leftthreetimes", true);
defineSymbol(math, bin, "\u22cc", "\\rightthreetimes", true);
defineSymbol(math, bin, "\u22cf", "\\curlywedge", true);
defineSymbol(math, bin, "\u22ce", "\\curlyvee", true);
defineSymbol(math, bin, "\u229d", "\\circleddash", true);
defineSymbol(math, bin, "\u229b", "\\circledast", true);
defineSymbol(math, bin, "\u22ba", "\\intercal", true);
defineSymbol(math, bin, "\u22d2", "\\doublecap");
defineSymbol(math, bin, "\u22d3", "\\doublecup");
defineSymbol(math, bin, "\u22a0", "\\boxtimes", true);
defineSymbol(math, bin, "\u22c8", "\\bowtie", true);
defineSymbol(math, bin, "\u22c8", "\\Join");
defineSymbol(math, bin, "\u27d5", "\\leftouterjoin", true);
defineSymbol(math, bin, "\u27d6", "\\rightouterjoin", true);
defineSymbol(math, bin, "\u27d7", "\\fullouterjoin", true);

// stix Binary Operators
defineSymbol(math, bin, "\u2238", "\\dotminus", true);
defineSymbol(math, bin, "\u27D1", "\\wedgedot", true);
defineSymbol(math, bin, "\u27C7", "\\veedot", true);
defineSymbol(math, bin, "\u2A62", "\\doublebarvee", true);
defineSymbol(math, bin, "\u2A63", "\\veedoublebar", true);
defineSymbol(math, bin, "\u2A5F", "\\wedgebar", true);
defineSymbol(math, bin, "\u2A60", "\\wedgedoublebar", true);
defineSymbol(math, bin, "\u2A54", "\\Vee", true);
defineSymbol(math, bin, "\u2A53", "\\Wedge", true);
defineSymbol(math, bin, "\u2A43", "\\barcap", true);
defineSymbol(math, bin, "\u2A42", "\\barcup", true);
defineSymbol(math, bin, "\u2A48", "\\capbarcup", true);
defineSymbol(math, bin, "\u2A40", "\\capdot", true);
defineSymbol(math, bin, "\u2A47", "\\capovercup", true);
defineSymbol(math, bin, "\u2A46", "\\cupovercap", true);
defineSymbol(math, bin, "\u2A4D", "\\closedvarcap", true);
defineSymbol(math, bin, "\u2A4C", "\\closedvarcup", true);
defineSymbol(math, bin, "\u2A2A", "\\minusdot", true);
defineSymbol(math, bin, "\u2A2B", "\\minusfdots", true);
defineSymbol(math, bin, "\u2A2C", "\\minusrdots", true);
defineSymbol(math, bin, "\u22BB", "\\Xor", true);
defineSymbol(math, bin, "\u22BC", "\\Nand", true);
defineSymbol(math, bin, "\u22BD", "\\Nor", true);
defineSymbol(math, bin, "\u22BD", "\\barvee");
defineSymbol(math, bin, "\u2AF4", "\\interleave", true);
defineSymbol(math, bin, "\u29E2", "\\shuffle", true);
defineSymbol(math, bin, "\u2AF6", "\\threedotcolon", true);
defineSymbol(math, bin, "\u2982", "\\typecolon", true);
defineSymbol(math, bin, "\u223E", "\\invlazys", true);
defineSymbol(math, bin, "\u2A4B", "\\twocaps", true);
defineSymbol(math, bin, "\u2A4A", "\\twocups", true);
defineSymbol(math, bin, "\u2A4E", "\\Sqcap", true);
defineSymbol(math, bin, "\u2A4F", "\\Sqcup", true);
defineSymbol(math, bin, "\u2A56", "\\veeonvee", true);
defineSymbol(math, bin, "\u2A55", "\\wedgeonwedge", true);
defineSymbol(math, bin, "\u29D7", "\\blackhourglass", true);
defineSymbol(math, bin, "\u29C6", "\\boxast", true);
defineSymbol(math, bin, "\u29C8", "\\boxbox", true);
defineSymbol(math, bin, "\u29C7", "\\boxcircle", true);
defineSymbol(math, bin, "\u229C", "\\circledequal", true);
defineSymbol(math, bin, "\u29B7", "\\circledparallel", true);
defineSymbol(math, bin, "\u29B6", "\\circledvert", true);
defineSymbol(math, bin, "\u29B5", "\\circlehbar", true);
defineSymbol(math, bin, "\u27E1", "\\concavediamond", true);
defineSymbol(math, bin, "\u27E2", "\\concavediamondtickleft", true);
defineSymbol(math, bin, "\u27E3", "\\concavediamondtickright", true);
defineSymbol(math, bin, "\u22C4", "\\diamond", true);
defineSymbol(math, bin, "\u29D6", "\\hourglass", true);
defineSymbol(math, bin, "\u27E0", "\\lozengeminus", true);
defineSymbol(math, bin, "\u233D", "\\obar", true);
defineSymbol(math, bin, "\u29B8", "\\obslash", true);
defineSymbol(math, bin, "\u2A38", "\\odiv", true);
defineSymbol(math, bin, "\u29C1", "\\ogreaterthan", true);
defineSymbol(math, bin, "\u29C0", "\\olessthan", true);
defineSymbol(math, bin, "\u29B9", "\\operp", true);
defineSymbol(math, bin, "\u2A37", "\\Otimes", true);
defineSymbol(math, bin, "\u2A36", "\\otimeshat", true);
defineSymbol(math, bin, "\u22C6", "\\star", true);
defineSymbol(math, bin, "\u25B3", "\\triangle", true);
defineSymbol(math, bin, "\u2A3A", "\\triangleminus", true);
defineSymbol(math, bin, "\u2A39", "\\triangleplus", true);
defineSymbol(math, bin, "\u2A3B", "\\triangletimes", true);
defineSymbol(math, bin, "\u27E4", "\\whitesquaretickleft", true);
defineSymbol(math, bin, "\u27E5", "\\whitesquaretickright", true);
defineSymbol(math, bin, "\u2A33", "\\smashtimes", true);

// AMS Arrows
// Note: unicode-math maps \u21e2 to their own function \rightdasharrow.
// We'll map it to AMS function \dashrightarrow. It produces the same atom.
defineSymbol(math, rel, "\u21e2", "\\dashrightarrow", true);
// unicode-math maps \u21e0 to \leftdasharrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21e0", "\\dashleftarrow", true);
defineSymbol(math, rel, "\u21c7", "\\leftleftarrows", true);
defineSymbol(math, rel, "\u21c6", "\\leftrightarrows", true);
defineSymbol(math, rel, "\u21da", "\\Lleftarrow", true);
defineSymbol(math, rel, "\u219e", "\\twoheadleftarrow", true);
defineSymbol(math, rel, "\u21a2", "\\leftarrowtail", true);
defineSymbol(math, rel, "\u21ab", "\\looparrowleft", true);
defineSymbol(math, rel, "\u21cb", "\\leftrightharpoons", true);
defineSymbol(math, rel, "\u21b6", "\\curvearrowleft", true);
// unicode-math maps \u21ba to \acwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21ba", "\\circlearrowleft", true);
defineSymbol(math, rel, "\u21b0", "\\Lsh", true);
defineSymbol(math, rel, "\u21c8", "\\upuparrows", true);
defineSymbol(math, rel, "\u21bf", "\\upharpoonleft", true);
defineSymbol(math, rel, "\u21c3", "\\downharpoonleft", true);
defineSymbol(math, rel, "\u22b6", "\\origof", true);
defineSymbol(math, rel, "\u22b7", "\\imageof", true);
defineSymbol(math, rel, "\u22b8", "\\multimap", true);
defineSymbol(math, rel, "\u21ad", "\\leftrightsquigarrow", true);
defineSymbol(math, rel, "\u21c9", "\\rightrightarrows", true);
defineSymbol(math, rel, "\u21c4", "\\rightleftarrows", true);
defineSymbol(math, rel, "\u21a0", "\\twoheadrightarrow", true);
defineSymbol(math, rel, "\u21a3", "\\rightarrowtail", true);
defineSymbol(math, rel, "\u21ac", "\\looparrowright", true);
defineSymbol(math, rel, "\u21b7", "\\curvearrowright", true);
// unicode-math maps \u21bb to \cwopencirclearrow. We'll use the AMS synonym.
defineSymbol(math, rel, "\u21bb", "\\circlearrowright", true);
defineSymbol(math, rel, "\u21b1", "\\Rsh", true);
defineSymbol(math, rel, "\u21ca", "\\downdownarrows", true);
defineSymbol(math, rel, "\u21be", "\\upharpoonright", true);
defineSymbol(math, rel, "\u21c2", "\\downharpoonright", true);
defineSymbol(math, rel, "\u21dd", "\\rightsquigarrow", true);
defineSymbol(math, rel, "\u21dd", "\\leadsto");
defineSymbol(math, rel, "\u21db", "\\Rrightarrow", true);
defineSymbol(math, rel, "\u21be", "\\restriction");

defineSymbol(math, textord, "\u2018", "`");
defineSymbol(math, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\$");
defineSymbol(text, textord, "$", "\\textdollar");
defineSymbol(math, textord, "¢", "\\cent");
defineSymbol(text, textord, "¢", "\\cent");
defineSymbol(math, textord, "%", "\\%");
defineSymbol(text, textord, "%", "\\%");
defineSymbol(math, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\_");
defineSymbol(text, textord, "_", "\\textunderscore");
defineSymbol(text, textord, "\u2423", "\\textvisiblespace", true);
defineSymbol(math, textord, "\u2220", "\\angle", true);
defineSymbol(math, textord, "\u221e", "\\infty", true);
defineSymbol(math, textord, "\u2032", "\\prime");
defineSymbol(math, textord, "\u2033", "\\dprime");
defineSymbol(math, textord, "\u2034", "\\trprime");
defineSymbol(math, textord, "\u2057", "\\qprime");
defineSymbol(math, textord, "\u25b3", "\\triangle");
defineSymbol(text, textord, "\u0391", "\\Alpha", true);
defineSymbol(text, textord, "\u0392", "\\Beta", true);
defineSymbol(text, textord, "\u0393", "\\Gamma", true);
defineSymbol(text, textord, "\u0394", "\\Delta", true);
defineSymbol(text, textord, "\u0395", "\\Epsilon", true);
defineSymbol(text, textord, "\u0396", "\\Zeta", true);
defineSymbol(text, textord, "\u0397", "\\Eta", true);
defineSymbol(text, textord, "\u0398", "\\Theta", true);
defineSymbol(text, textord, "\u0399", "\\Iota", true);
defineSymbol(text, textord, "\u039a", "\\Kappa", true);
defineSymbol(text, textord, "\u039b", "\\Lambda", true);
defineSymbol(text, textord, "\u039c", "\\Mu", true);
defineSymbol(text, textord, "\u039d", "\\Nu", true);
defineSymbol(text, textord, "\u039e", "\\Xi", true);
defineSymbol(text, textord, "\u039f", "\\Omicron", true);
defineSymbol(text, textord, "\u03a0", "\\Pi", true);
defineSymbol(text, textord, "\u03a1", "\\Rho", true);
defineSymbol(text, textord, "\u03a3", "\\Sigma", true);
defineSymbol(text, textord, "\u03a4", "\\Tau", true);
defineSymbol(text, textord, "\u03a5", "\\Upsilon", true);
defineSymbol(text, textord, "\u03a6", "\\Phi", true);
defineSymbol(text, textord, "\u03a7", "\\Chi", true);
defineSymbol(text, textord, "\u03a8", "\\Psi", true);
defineSymbol(text, textord, "\u03a9", "\\Omega", true);
defineSymbol(math, mathord, "\u0391", "\\Alpha", true);
defineSymbol(math, mathord, "\u0392", "\\Beta", true);
defineSymbol(math, mathord, "\u0393", "\\Gamma", true);
defineSymbol(math, mathord, "\u0394", "\\Delta", true);
defineSymbol(math, mathord, "\u0395", "\\Epsilon", true);
defineSymbol(math, mathord, "\u0396", "\\Zeta", true);
defineSymbol(math, mathord, "\u0397", "\\Eta", true);
defineSymbol(math, mathord, "\u0398", "\\Theta", true);
defineSymbol(math, mathord, "\u0399", "\\Iota", true);
defineSymbol(math, mathord, "\u039a", "\\Kappa", true);
defineSymbol(math, mathord, "\u039b", "\\Lambda", true);
defineSymbol(math, mathord, "\u039c", "\\Mu", true);
defineSymbol(math, mathord, "\u039d", "\\Nu", true);
defineSymbol(math, mathord, "\u039e", "\\Xi", true);
defineSymbol(math, mathord, "\u039f", "\\Omicron", true);
defineSymbol(math, mathord, "\u03a0", "\\Pi", true);
defineSymbol(math, mathord, "\u03a1", "\\Rho", true);
defineSymbol(math, mathord, "\u03a3", "\\Sigma", true);
defineSymbol(math, mathord, "\u03a4", "\\Tau", true);
defineSymbol(math, mathord, "\u03a5", "\\Upsilon", true);
defineSymbol(math, mathord, "\u03a6", "\\Phi", true);
defineSymbol(math, mathord, "\u03a7", "\\Chi", true);
defineSymbol(math, mathord, "\u03a8", "\\Psi", true);
defineSymbol(math, mathord, "\u03a9", "\\Omega", true);
defineSymbol(math, open, "\u00ac", "\\neg", true);
defineSymbol(math, open, "\u00ac", "\\lnot");
defineSymbol(math, textord, "\u22a4", "\\top");
defineSymbol(math, textord, "\u22a5", "\\bot");
defineSymbol(math, textord, "\u2205", "\\emptyset");
defineSymbol(math, textord, "\u2300", "\\varnothing");
defineSymbol(math, mathord, "\u03b1", "\\alpha", true);
defineSymbol(math, mathord, "\u03b2", "\\beta", true);
defineSymbol(math, mathord, "\u03b3", "\\gamma", true);
defineSymbol(math, mathord, "\u03b4", "\\delta", true);
defineSymbol(math, mathord, "\u03f5", "\\epsilon", true);
defineSymbol(math, mathord, "\u03b6", "\\zeta", true);
defineSymbol(math, mathord, "\u03b7", "\\eta", true);
defineSymbol(math, mathord, "\u03b8", "\\theta", true);
defineSymbol(math, mathord, "\u03b9", "\\iota", true);
defineSymbol(math, mathord, "\u03ba", "\\kappa", true);
defineSymbol(math, mathord, "\u03bb", "\\lambda", true);
defineSymbol(math, mathord, "\u03bc", "\\mu", true);
defineSymbol(math, mathord, "\u03bd", "\\nu", true);
defineSymbol(math, mathord, "\u03be", "\\xi", true);
defineSymbol(math, mathord, "\u03bf", "\\omicron", true);
defineSymbol(math, mathord, "\u03c0", "\\pi", true);
defineSymbol(math, mathord, "\u03c1", "\\rho", true);
defineSymbol(math, mathord, "\u03c3", "\\sigma", true);
defineSymbol(math, mathord, "\u03c4", "\\tau", true);
defineSymbol(math, mathord, "\u03c5", "\\upsilon", true);
defineSymbol(math, mathord, "\u03d5", "\\phi", true);
defineSymbol(math, mathord, "\u03c7", "\\chi", true);
defineSymbol(math, mathord, "\u03c8", "\\psi", true);
defineSymbol(math, mathord, "\u03c9", "\\omega", true);
defineSymbol(math, mathord, "\u03b5", "\\varepsilon", true);
defineSymbol(math, mathord, "\u03d1", "\\vartheta", true);
defineSymbol(math, mathord, "\u03d6", "\\varpi", true);
defineSymbol(math, mathord, "\u03f1", "\\varrho", true);
defineSymbol(math, mathord, "\u03c2", "\\varsigma", true);
defineSymbol(math, mathord, "\u03c6", "\\varphi", true);
defineSymbol(math, mathord, "\u03d8", "\\Coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\coppa", true);
defineSymbol(math, mathord, "\u03d9", "\\varcoppa", true);
defineSymbol(math, mathord, "\u03de", "\\Koppa", true);
defineSymbol(math, mathord, "\u03df", "\\koppa", true);
defineSymbol(math, mathord, "\u03e0", "\\Sampi", true);
defineSymbol(math, mathord, "\u03e1", "\\sampi", true);
defineSymbol(math, mathord, "\u03da", "\\Stigma", true);
defineSymbol(math, mathord, "\u03db", "\\stigma", true);
defineSymbol(math, mathord, "\u2aeb", "\\Bot");
defineSymbol(math, bin, "\u2217", "\u2217", true);
defineSymbol(math, bin, "+", "+");
defineSymbol(math, bin, "\u2217", "*");
defineSymbol(math, bin, "\u2044", "/", true);
defineSymbol(math, bin, "\u2044", "\u2044");
defineSymbol(math, bin, "\u2212", "-", true);
defineSymbol(math, bin, "\u22c5", "\\cdot", true);
defineSymbol(math, bin, "\u2218", "\\circ", true);
defineSymbol(math, bin, "\u00f7", "\\div", true);
defineSymbol(math, bin, "\u00b1", "\\pm", true);
defineSymbol(math, bin, "\u00d7", "\\times", true);
defineSymbol(math, bin, "\u2229", "\\cap", true);
defineSymbol(math, bin, "\u222a", "\\cup", true);
defineSymbol(math, bin, "\u2216", "\\setminus", true);
defineSymbol(math, bin, "\u2227", "\\land");
defineSymbol(math, bin, "\u2228", "\\lor");
defineSymbol(math, bin, "\u2227", "\\wedge", true);
defineSymbol(math, bin, "\u2228", "\\vee", true);
defineSymbol(math, open, "\u27e6", "\\llbracket", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u27e7", "\\rrbracket", true);
defineSymbol(math, open, "\u27e8", "\\langle", true);
defineSymbol(math, open, "\u27ea", "\\lAngle", true);
defineSymbol(math, open, "\u2989", "\\llangle", true);
defineSymbol(math, open, "|", "\\lvert");
defineSymbol(math, open, "\u2016", "\\lVert", true);
defineSymbol(math, textord, "!", "\\oc"); // cmll package
defineSymbol(math, textord, "?", "\\wn");
defineSymbol(math, textord, "\u2193", "\\shpos");
defineSymbol(math, textord, "\u2195", "\\shift");
defineSymbol(math, textord, "\u2191", "\\shneg");
defineSymbol(math, close, "?", "?");
defineSymbol(math, close, "!", "!");
defineSymbol(math, close, "‼", "‼");
defineSymbol(math, close, "\u27e9", "\\rangle", true);
defineSymbol(math, close, "\u27eb", "\\rAngle", true);
defineSymbol(math, close, "\u298a", "\\rrangle", true);
defineSymbol(math, close, "|", "\\rvert");
defineSymbol(math, close, "\u2016", "\\rVert");
defineSymbol(math, open, "\u2983", "\\lBrace", true); // stmaryrd/semantic packages
defineSymbol(math, close, "\u2984", "\\rBrace", true);
defineSymbol(math, rel, "=", "\\equal", true);
defineSymbol(math, rel, ":", ":");
defineSymbol(math, rel, "\u2248", "\\approx", true);
defineSymbol(math, rel, "\u2245", "\\cong", true);
defineSymbol(math, rel, "\u2265", "\\ge");
defineSymbol(math, rel, "\u2265", "\\geq", true);
defineSymbol(math, rel, "\u2190", "\\gets");
defineSymbol(math, rel, ">", "\\gt", true);
defineSymbol(math, rel, "\u2208", "\\in", true);
defineSymbol(math, rel, "\u2209", "\\notin", true);
defineSymbol(math, rel, "\ue020", "\\@not");
defineSymbol(math, rel, "\u2282", "\\subset", true);
defineSymbol(math, rel, "\u2283", "\\supset", true);
defineSymbol(math, rel, "\u2286", "\\subseteq", true);
defineSymbol(math, rel, "\u2287", "\\supseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteq", true);
defineSymbol(math, rel, "\u2288", "\\nsubseteqq");
defineSymbol(math, rel, "\u2289", "\\nsupseteq", true);
defineSymbol(math, rel, "\u2289", "\\nsupseteqq");
defineSymbol(math, rel, "\u22a8", "\\models");
defineSymbol(math, rel, "\u2190", "\\leftarrow", true);
defineSymbol(math, rel, "\u2264", "\\le");
defineSymbol(math, rel, "\u2264", "\\leq", true);
defineSymbol(math, rel, "<", "\\lt", true);
defineSymbol(math, rel, "\u2192", "\\rightarrow", true);
defineSymbol(math, rel, "\u2192", "\\to");
defineSymbol(math, rel, "\u2271", "\\ngeq", true);
defineSymbol(math, rel, "\u2271", "\\ngeqq");
defineSymbol(math, rel, "\u2271", "\\ngeqslant");
defineSymbol(math, rel, "\u2270", "\\nleq", true);
defineSymbol(math, rel, "\u2270", "\\nleqq");
defineSymbol(math, rel, "\u2270", "\\nleqslant");
defineSymbol(math, rel, "\u2aeb", "\\Perp", true); //cmll package
defineSymbol(math, spacing, "\u00a0", "\\ ");
defineSymbol(math, spacing, "\u00a0", "\\space");
// Ref: LaTeX Source 2e: \DeclareRobustCommand{\nobreakspace}{%
defineSymbol(math, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(text, spacing, "\u00a0", "\\ ");
defineSymbol(text, spacing, "\u00a0", " ");
defineSymbol(text, spacing, "\u00a0", "\\space");
defineSymbol(text, spacing, "\u00a0", "\\nobreakspace");
defineSymbol(math, spacing, null, "\\nobreak");
defineSymbol(math, spacing, null, "\\allowbreak");
defineSymbol(math, punct, ",", ",");
defineSymbol(text, punct, ":", ":");
defineSymbol(math, punct, ";", ";");
defineSymbol(math, bin, "\u22bc", "\\barwedge");
defineSymbol(math, bin, "\u22bb", "\\veebar");
defineSymbol(math, bin, "\u2299", "\\odot", true);
// Firefox turns ⊕ into an emoji. So append \uFE0E. Define Unicode character in macros, not here.
defineSymbol(math, bin, "\u2295\uFE0E", "\\oplus");
defineSymbol(math, bin, "\u2297", "\\otimes", true);
defineSymbol(math, textord, "\u2202", "\\partial", true);
defineSymbol(math, bin, "\u2298", "\\oslash", true);
defineSymbol(math, bin, "\u229a", "\\circledcirc", true);
defineSymbol(math, bin, "\u22a1", "\\boxdot", true);
defineSymbol(math, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, bin, "\u2020", "\\dagger");
defineSymbol(math, bin, "\u22c4", "\\diamond");
defineSymbol(math, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, bin, "\u25b9", "\\triangleright");
defineSymbol(math, open, "{", "\\{");
defineSymbol(text, textord, "{", "\\{");
defineSymbol(text, textord, "{", "\\textbraceleft");
defineSymbol(math, close, "}", "\\}");
defineSymbol(text, textord, "}", "\\}");
defineSymbol(text, textord, "}", "\\textbraceright");
defineSymbol(math, open, "{", "\\lbrace");
defineSymbol(math, close, "}", "\\rbrace");
defineSymbol(math, open, "[", "\\lbrack", true);
defineSymbol(text, textord, "[", "\\lbrack", true);
defineSymbol(math, close, "]", "\\rbrack", true);
defineSymbol(text, textord, "]", "\\rbrack", true);
defineSymbol(math, open, "(", "\\lparen", true);
defineSymbol(math, close, ")", "\\rparen", true);
defineSymbol(math, open, "⦇", "\\llparenthesis", true);
defineSymbol(math, close, "⦈", "\\rrparenthesis", true);
defineSymbol(text, textord, "<", "\\textless", true); // in T1 fontenc
defineSymbol(text, textord, ">", "\\textgreater", true); // in T1 fontenc
defineSymbol(math, open, "\u230a", "\\lfloor", true);
defineSymbol(math, close, "\u230b", "\\rfloor", true);
defineSymbol(math, open, "\u2308", "\\lceil", true);
defineSymbol(math, close, "\u2309", "\\rceil", true);
defineSymbol(math, textord, "\\", "\\backslash");
defineSymbol(math, textord, "|", "|");
defineSymbol(math, textord, "|", "\\vert");
defineSymbol(text, textord, "|", "\\textbar", true); // in T1 fontenc
defineSymbol(math, textord, "\u2016", "\\|");
defineSymbol(math, textord, "\u2016", "\\Vert");
defineSymbol(text, textord, "\u2016", "\\textbardbl");
defineSymbol(text, textord, "~", "\\textasciitilde");
defineSymbol(text, textord, "\\", "\\textbackslash");
defineSymbol(text, textord, "^", "\\textasciicircum");
defineSymbol(math, rel, "\u2191", "\\uparrow", true);
defineSymbol(math, rel, "\u21d1", "\\Uparrow", true);
defineSymbol(math, rel, "\u2193", "\\downarrow", true);
defineSymbol(math, rel, "\u21d3", "\\Downarrow", true);
defineSymbol(math, rel, "\u2195", "\\updownarrow", true);
defineSymbol(math, rel, "\u21d5", "\\Updownarrow", true);
defineSymbol(math, op, "\u2210", "\\coprod");
defineSymbol(math, op, "\u22c1", "\\bigvee");
defineSymbol(math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, op, "\u2a04", "\\biguplus");
defineSymbol(math, op, "\u2a04", "\\bigcupplus");
defineSymbol(math, op, "\u2a03", "\\bigcupdot");
defineSymbol(math, op, "\u2a07", "\\bigdoublevee");
defineSymbol(math, op, "\u2a08", "\\bigdoublewedge");
defineSymbol(math, op, "\u22c2", "\\bigcap");
defineSymbol(math, op, "\u22c3", "\\bigcup");
defineSymbol(math, op, "\u222b", "\\int");
defineSymbol(math, op, "\u222b", "\\intop");
defineSymbol(math, op, "\u222c", "\\iint");
defineSymbol(math, op, "\u222d", "\\iiint");
defineSymbol(math, op, "\u220f", "\\prod");
defineSymbol(math, op, "\u2211", "\\sum");
defineSymbol(math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, op, "\u2a00", "\\bigodot");
defineSymbol(math, op, "\u2a09", "\\bigtimes");
defineSymbol(math, op, "\u222e", "\\oint");
defineSymbol(math, op, "\u222f", "\\oiint");
defineSymbol(math, op, "\u2230", "\\oiiint");
defineSymbol(math, op, "\u2231", "\\intclockwise");
defineSymbol(math, op, "\u2232", "\\varointclockwise");
defineSymbol(math, op, "\u2a0c", "\\iiiint");
defineSymbol(math, op, "\u2a0d", "\\intbar");
defineSymbol(math, op, "\u2a0e", "\\intBar");
defineSymbol(math, op, "\u2a0f", "\\fint");
defineSymbol(math, op, "\u2a12", "\\rppolint");
defineSymbol(math, op, "\u2a13", "\\scpolint");
defineSymbol(math, op, "\u2a15", "\\pointint");
defineSymbol(math, op, "\u2a16", "\\sqint");
defineSymbol(math, op, "\u2a17", "\\intlarhk");
defineSymbol(math, op, "\u2a18", "\\intx");
defineSymbol(math, op, "\u2a19", "\\intcap");
defineSymbol(math, op, "\u2a1a", "\\intcup");
defineSymbol(math, op, "\u2a05", "\\bigsqcap");
defineSymbol(math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, op, "\u222b", "\\smallint");
defineSymbol(text, inner, "\u2026", "\\textellipsis");
defineSymbol(math, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u2026", "\\ldots", true);
defineSymbol(math, inner, "\u22f0", "\\iddots", true);
defineSymbol(math, inner, "\u22ef", "\\@cdots", true);
defineSymbol(math, inner, "\u22f1", "\\ddots", true);
defineSymbol(math, textord, "\u22ee", "\\varvdots"); // \vdots is a macro
defineSymbol(text, textord, "\u22ee", "\\varvdots");
defineSymbol(math, accent, "\u02ca", "\\acute");
defineSymbol(math, accent, "\u0060", "\\grave");
defineSymbol(math, accent, "\u00a8", "\\ddot");
defineSymbol(math, accent, "\u2026", "\\dddot");
defineSymbol(math, accent, "\u2026\u002e", "\\ddddot");
defineSymbol(math, accent, "\u007e", "\\tilde");
defineSymbol(math, accent, "\u203e", "\\bar");
defineSymbol(math, accent, "\u02d8", "\\breve");
defineSymbol(math, accent, "\u02c7", "\\check");
defineSymbol(math, accent, "\u005e", "\\hat");
defineSymbol(math, accent, "\u2192", "\\vec");
defineSymbol(math, accent, "\u02d9", "\\dot");
defineSymbol(math, accent, "\u02da", "\\mathring");
defineSymbol(math, mathord, "\u0131", "\\imath", true);
defineSymbol(math, mathord, "\u0237", "\\jmath", true);
defineSymbol(math, textord, "\u0131", "\u0131");
defineSymbol(math, textord, "\u0237", "\u0237");
defineSymbol(text, textord, "\u0131", "\\i", true);
defineSymbol(text, textord, "\u0237", "\\j", true);
defineSymbol(text, textord, "\u00df", "\\ss", true);
defineSymbol(text, textord, "\u00e6", "\\ae", true);
defineSymbol(text, textord, "\u0153", "\\oe", true);
defineSymbol(text, textord, "\u00f8", "\\o", true);
defineSymbol(math, mathord, "\u00f8", "\\o", true);
defineSymbol(text, textord, "\u00c6", "\\AE", true);
defineSymbol(text, textord, "\u0152", "\\OE", true);
defineSymbol(text, textord, "\u00d8", "\\O", true);
defineSymbol(math, mathord, "\u00d8", "\\O", true);
defineSymbol(text, accent, "\u02ca", "\\'"); // acute
defineSymbol(text, accent, "\u02cb", "\\`"); // grave
defineSymbol(text, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(text, accent, "\u02dc", "\\~"); // tilde
defineSymbol(text, accent, "\u02c9", "\\="); // macron
defineSymbol(text, accent, "\u02d8", "\\u"); // breve
defineSymbol(text, accent, "\u02d9", "\\."); // dot above
defineSymbol(text, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(text, accent, "\u02da", "\\r"); // ring above
defineSymbol(text, accent, "\u02c7", "\\v"); // caron
defineSymbol(text, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(text, accent, "\u02dd", "\\H"); // double acute
defineSymbol(math, accent, "\u02ca", "\\'"); // acute
defineSymbol(math, accent, "\u02cb", "\\`"); // grave
defineSymbol(math, accent, "\u02c6", "\\^"); // circumflex
defineSymbol(math, accent, "\u02dc", "\\~"); // tilde
defineSymbol(math, accent, "\u02c9", "\\="); // macron
defineSymbol(math, accent, "\u02d8", "\\u"); // breve
defineSymbol(math, accent, "\u02d9", "\\."); // dot above
defineSymbol(math, accent, "\u00b8", "\\c"); // cedilla
defineSymbol(math, accent, "\u02da", "\\r"); // ring above
defineSymbol(math, accent, "\u02c7", "\\v"); // caron
defineSymbol(math, accent, "\u00a8", '\\"'); // diaeresis
defineSymbol(math, accent, "\u02dd", "\\H"); // double acute

// These ligatures are detected and created in Parser.js's `formLigatures`.
const ligatures = {
  "--": true,
  "---": true,
  "``": true,
  "''": true
};

defineSymbol(text, textord, "\u2013", "--", true);
defineSymbol(text, textord, "\u2013", "\\textendash");
defineSymbol(text, textord, "\u2014", "---", true);
defineSymbol(text, textord, "\u2014", "\\textemdash");
defineSymbol(text, textord, "\u2018", "`", true);
defineSymbol(text, textord, "\u2018", "\\textquoteleft");
defineSymbol(text, textord, "\u2019", "'", true);
defineSymbol(text, textord, "\u2019", "\\textquoteright");
defineSymbol(text, textord, "\u201c", "``", true);
defineSymbol(text, textord, "\u201c", "\\textquotedblleft");
defineSymbol(text, textord, "\u201d", "''", true);
defineSymbol(text, textord, "\u201d", "\\textquotedblright");
//  \degree from gensymb package
defineSymbol(math, textord, "\u00b0", "\\degree", true);
defineSymbol(text, textord, "\u00b0", "\\degree");
// \textdegree from inputenc package
defineSymbol(text, textord, "\u00b0", "\\textdegree", true);
// TODO: In LaTeX, \pounds can generate a different character in text and math
// mode, but among our fonts, only Main-Regular defines this character "163".
defineSymbol(math, textord, "\u00a3", "\\pounds");
defineSymbol(math, textord, "\u00a3", "\\mathsterling", true);
defineSymbol(text, textord, "\u00a3", "\\pounds");
defineSymbol(text, textord, "\u00a3", "\\textsterling", true);
defineSymbol(math, textord, "\u2720", "\\maltese");
defineSymbol(text, textord, "\u2720", "\\maltese");
defineSymbol(math, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\euro", true);
defineSymbol(text, textord, "\u20ac", "\\texteuro");
defineSymbol(math, textord, "\u00a9", "\\copyright", true);
defineSymbol(text, textord, "\u00a9", "\\textcopyright");
defineSymbol(math, textord, "\u2300", "\\diameter", true);
defineSymbol(text, textord, "\u2300", "\\diameter");

// Italic Greek
defineSymbol(math, textord, "𝛤", "\\varGamma");
defineSymbol(math, textord, "𝛥", "\\varDelta");
defineSymbol(math, textord, "𝛩", "\\varTheta");
defineSymbol(math, textord, "𝛬", "\\varLambda");
defineSymbol(math, textord, "𝛯", "\\varXi");
defineSymbol(math, textord, "𝛱", "\\varPi");
defineSymbol(math, textord, "𝛴", "\\varSigma");
defineSymbol(math, textord, "𝛶", "\\varUpsilon");
defineSymbol(math, textord, "𝛷", "\\varPhi");
defineSymbol(math, textord, "𝛹", "\\varPsi");
defineSymbol(math, textord, "𝛺", "\\varOmega");
defineSymbol(text, textord, "𝛤", "\\varGamma");
defineSymbol(text, textord, "𝛥", "\\varDelta");
defineSymbol(text, textord, "𝛩", "\\varTheta");
defineSymbol(text, textord, "𝛬", "\\varLambda");
defineSymbol(text, textord, "𝛯", "\\varXi");
defineSymbol(text, textord, "𝛱", "\\varPi");
defineSymbol(text, textord, "𝛴", "\\varSigma");
defineSymbol(text, textord, "𝛶", "\\varUpsilon");
defineSymbol(text, textord, "𝛷", "\\varPhi");
defineSymbol(text, textord, "𝛹", "\\varPsi");
defineSymbol(text, textord, "𝛺", "\\varOmega");


// There are lots of symbols which are the same, so we add them in afterwards.
// All of these are textords in math mode
const mathTextSymbols = '0123456789/@."';
for (let i = 0; i < mathTextSymbols.length; i++) {
  const ch = mathTextSymbols.charAt(i);
  defineSymbol(math, textord, ch, ch);
}

// All of these are textords in text mode
const textSymbols = '0123456789!@*()-=+";:?/.,';
for (let i = 0; i < textSymbols.length; i++) {
  const ch = textSymbols.charAt(i);
  defineSymbol(text, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
for (let i = 0; i < letters.length; i++) {
  const ch = letters.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// Some more letters in Unicode Basic Multilingual Plane.
const narrow = "ÇÐÞçþℂℍℕℙℚℝℤℎℏℊℋℌℐℑℒℓ℘ℛℜℬℰℱℳℭℨ";
for (let i = 0; i < narrow.length; i++) {
  const ch = narrow.charAt(i);
  defineSymbol(math, mathord, ch, ch);
  defineSymbol(text, textord, ch, ch);
}

// The next loop loads wide (surrogate pair) characters.
// We support some letters in the Unicode range U+1D400 to U+1D7FF,
// Mathematical Alphanumeric Symbols.
let wideChar = "";
for (let i = 0; i < letters.length; i++) {
  // The hex numbers in the next line are a surrogate pair.
  // 0xD835 is the high surrogate for all letters in the range we support.
  // 0xDC00 is the low surrogate for bold A.
  wideChar = String.fromCharCode(0xd835, 0xdc00 + i); // A-Z a-z bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc34 + i); // A-Z a-z italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdc68 + i); // A-Z a-z bold italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd04 + i); // A-Z a-z Fractur
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdda0 + i); // A-Z a-z sans-serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xddd4 + i); // A-Z a-z sans bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde08 + i); // A-Z a-z sans italic
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xde70 + i); // A-Z a-z monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdd38 + i); // A-Z a-z double struck
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  const ch = letters.charAt(i);
  wideChar = String.fromCharCode(0xd835, 0xdc9c + i); // A-Z a-z calligraphic
  defineSymbol(math, mathord, ch, wideChar);
  defineSymbol(text, textord, ch, wideChar);
}

// Next, some wide character numerals
for (let i = 0; i < 10; i++) {
  wideChar = String.fromCharCode(0xd835, 0xdfce + i); // 0-9 bold
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfe2 + i); // 0-9 sans serif
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdfec + i); // 0-9 bold sans
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);

  wideChar = String.fromCharCode(0xd835, 0xdff6 + i); // 0-9 monospace
  defineSymbol(math, mathord, wideChar, wideChar);
  defineSymbol(text, textord, wideChar, wideChar);
}

/*
 * Neither Firefox nor Chrome support hard line breaks or soft line breaks.
 * (Despite https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs)
 * So Temml has work-arounds for both hard and soft breaks.
 * The work-arounds sadly do not work simultaneously. Any top-level hard
 * break makes soft line breaks impossible.
 *
 * Hard breaks are simulated by creating a <mtable> and putting each line in its own <mtr>.
 *
 * To create soft line breaks, Temml avoids using the <semantics> and <annotation> tags.
 * Then the top level of a <math> element can be occupied by <mrow> elements, and the browser
 * will break after a <mrow> if the expression extends beyond the container limit.
 *
 * The default is for soft line breaks after each top-level binary or
 * relational operator, per TeXbook p. 173. So we gather the expression into <mrow>s so that
 * each <mrow> ends in a binary or relational operator.
 *
 * An option is for soft line breaks before an "=" sign. That changes the <mrow>s.
 *
 * Soft line breaks will not work in Chromium and Safari, only Firefox.
 *
 * Hopefully browsers will someday do their own linebreaking and we will be able to delete
 * much of this module.
 */

const openDelims = "([{⌊⌈⟨⟮⎰⟦⦃";
const closeDelims = ")]}⌋⌉⟩⟯⎱⟦⦄";

function setLineBreaks(expression, wrapMode, isDisplayMode) {
  const mtrs = [];
  let mrows = [];
  let block = [];
  let numTopLevelEquals = 0;
  let i = 0;
  let level = 0;
  while (i < expression.length) {
    while (expression[i] instanceof DocumentFragment) {
      expression.splice(i, 1, ...expression[i].children); // Expand the fragment.
    }
    const node = expression[i];
    if (node.attributes && node.attributes.linebreak &&
      node.attributes.linebreak === "newline") {
      // A hard line break. Create a <mtr> for the current block.
      if (block.length > 0) {
        mrows.push(new mathMLTree.MathNode("mrow", block));
      }
      mrows.push(node);
      block = [];
      const mtd = new mathMLTree.MathNode("mtd", mrows);
      mtd.style.textAlign = "left";
      mtrs.push(new mathMLTree.MathNode("mtr", [mtd]));
      mrows = [];
      i += 1;
      continue
    }
    block.push(node);
    if (node.type && node.type === "mo" && node.children.length === 1 &&
        !Object.prototype.hasOwnProperty.call(node.attributes, "movablelimits")) {
      const ch = node.children[0].text;
      if (openDelims.indexOf(ch) > -1) {
        level += 1;
      } else if (closeDelims.indexOf(ch) > -1) {
        level -= 1;
      } else if (level === 0 && wrapMode === "=" && ch === "=") {
        numTopLevelEquals += 1;
        if (numTopLevelEquals > 1) {
          block.pop();
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [node];
        }
      } else if (level === 0 && wrapMode === "tex" && ch !== "∇") {
        // Check if the following node is a \nobreak text node, e.g. "~""
        const next = i < expression.length - 1 ? expression[i + 1] : null;
        let glueIsFreeOfNobreak = true;
        if (
          !(
            next &&
            next.type === "mtext" &&
            next.attributes.linebreak &&
            next.attributes.linebreak === "nobreak"
          )
        ) {
          // We may need to start a new block.
          // First, put any post-operator glue on same line as operator.
          for (let j = i + 1; j < expression.length; j++) {
            const nd = expression[j];
            if (
              nd.type &&
              nd.type === "mspace" &&
              !(nd.attributes.linebreak && nd.attributes.linebreak === "newline")
            ) {
              block.push(nd);
              i += 1;
              if (
                nd.attributes &&
                nd.attributes.linebreak &&
                nd.attributes.linebreak === "nobreak"
              ) {
                glueIsFreeOfNobreak = false;
              }
            } else {
              break;
            }
          }
        }
        if (glueIsFreeOfNobreak) {
          // Start a new block. (Insert a soft linebreak.)
          const element = new mathMLTree.MathNode("mrow", block);
          mrows.push(element);
          block = [];
        }
      }
    }
    i += 1;
  }
  if (block.length > 0) {
    const element = new mathMLTree.MathNode("mrow", block);
    mrows.push(element);
  }
  if (mtrs.length > 0) {
    const mtd = new mathMLTree.MathNode("mtd", mrows);
    mtd.style.textAlign = "left";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    mtrs.push(mtr);
    const mtable = new mathMLTree.MathNode("mtable", mtrs);
    if (!isDisplayMode) {
      mtable.setAttribute("columnalign", "left");
      mtable.setAttribute("rowspacing", "0em");
    }
    return mtable
  }
  return mathMLTree.newDocumentFragment(mrows);
}

/**
 * This file converts a parse tree into a corresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */


/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
const makeText = function(text, mode, style) {
  if (
    symbols[mode][text] &&
    symbols[mode][text].replace &&
    text.charCodeAt(0) !== 0xd835 &&
    !(
      Object.prototype.hasOwnProperty.call(ligatures, text) &&
      style &&
      ((style.fontFamily && style.fontFamily.slice(4, 6) === "tt") ||
        (style.font && style.font.slice(4, 6) === "tt"))
    )
  ) {
    text = symbols[mode][text].replace;
  }

  return new mathMLTree.TextNode(text);
};

const copyChar = (newRow, child) => {
  if (newRow.children.length === 0 ||
      newRow.children[newRow.children.length - 1].type !== "mtext") {
    const mtext = new mathMLTree.MathNode(
      "mtext",
      [new mathMLTree.TextNode(child.children[0].text)]
    );
    newRow.children.push(mtext);
  } else {
    newRow.children[newRow.children.length - 1].children[0].text += child.children[0].text;
  }
};

const consolidateText = mrow => {
  // If possible, consolidate adjacent <mtext> elements into a single element.
  if (mrow.type !== "mrow" && mrow.type !== "mstyle") { return mrow }
  if (mrow.children.length === 0) { return mrow } // empty group, e.g., \text{}
  const newRow = new mathMLTree.MathNode("mrow");
  for (let i = 0; i < mrow.children.length; i++) {
    const child = mrow.children[i];
    if (child.type === "mtext" && Object.keys(child.attributes).length === 0) {
      copyChar(newRow, child);
    } else if (child.type === "mrow") {
      // We'll also check the children of an mrow. One level only. No recursion.
      let canConsolidate = true;
      for (let j = 0; j < child.children.length; j++) {
        const grandChild = child.children[j];
        if (grandChild.type !== "mtext" || Object.keys(child.attributes).length !== 0) {
          canConsolidate = false;
          break
        }
      }
      if (canConsolidate) {
        for (let j = 0; j < child.children.length; j++) {
          const grandChild = child.children[j];
          copyChar(newRow, grandChild);
        }
      } else {
        newRow.children.push(child);
      }
    } else {
      newRow.children.push(child);
    }
  }
  for (let i = 0; i < newRow.children.length; i++) {
    if (newRow.children[i].type === "mtext") {
      const mtext = newRow.children[i];
      // Firefox does not render a space at either end of an <mtext> string.
      // To get proper rendering, we replace leading or trailing spaces with no-break spaces.
      if (mtext.children[0].text.charAt(0) === " ") {
        mtext.children[0].text = "\u00a0" + mtext.children[0].text.slice(1);
      }
      const L = mtext.children[0].text.length;
      if (L > 0 && mtext.children[0].text.charAt(L - 1) === " ") {
        mtext.children[0].text = mtext.children[0].text.slice(0, -1) + "\u00a0";
      }
      for (const [key, value] of Object.entries(mrow.attributes)) {
        mtext.attributes[key] = value;
      }
    }
  }
  if (newRow.children.length === 1 && newRow.children[0].type === "mtext") {
    return newRow.children[0]; // A consolidated <mtext>
  } else {
    return newRow
  }
};

/**
 * Wrap the given array of nodes in an <mrow> node if needed, i.e.,
 * unless the array has length 1.  Always returns a single node.
 */
const makeRow = function(body, semisimple = false) {
  if (body.length === 1 && !(body[0] instanceof DocumentFragment)) {
    return body[0];
  } else if (!semisimple) {
    // Suppress spacing on <mo> nodes at both ends of the row.
    if (body[0] instanceof MathNode && body[0].type === "mo" && !body[0].attributes.fence) {
      body[0].attributes.lspace = "0em";
      body[0].attributes.rspace = "0em";
    }
    const end = body.length - 1;
    if (body[end] instanceof MathNode && body[end].type === "mo" && !body[end].attributes.fence) {
      body[end].attributes.lspace = "0em";
      body[end].attributes.rspace = "0em";
    }
  }
  return new mathMLTree.MathNode("mrow", body);
};

/**
 * Check for <mi>.</mi> which is how a dot renders in MathML,
 * or <mo separator="true" lspace="0em" rspace="0em">,</mo>
 * which is how a braced comma {,} renders in MathML
 */
function isNumberPunctuation(group) {
  if (!group) {
    return false
  }
  if (group.type === 'mi' && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '.'
  } else if (group.type === "mtext" && group.children.length === 1) {
    const child = group.children[0];
    return child instanceof TextNode && child.text === '\u2008' // punctuation space
  } else if (group.type === 'mo' && group.children.length === 1 &&
    group.getAttribute('separator') === 'true' &&
    group.getAttribute('lspace') === '0em' &&
    group.getAttribute('rspace') === '0em') {
    const child = group.children[0];
    return child instanceof TextNode && child.text === ','
  } else {
    return false
  }
}
const isComma = (expression, i) => {
  const node = expression[i];
  const followingNode = expression[i + 1];
  return (node.type === "atom" && node.text === ",") &&
    // Don't consolidate if there is a space after the comma.
    node.loc && followingNode.loc && node.loc.end === followingNode.loc.start
};

const isRel = item => {
  return (item.type === "atom" && item.family === "rel") ||
      (item.type === "mclass" && item.mclass === "mrel")
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes.  Also do a couple chores along the way:
 * (1) Suppress spacing when an author wraps an operator w/braces, as in {=}.
 * (2) Suppress spacing between two adjacent relations.
 */
const buildExpression = function(expression, style, semisimple = false) {
  if (!semisimple && expression.length === 1) {
    const group = buildGroup$1(expression[0], style);
    if (group instanceof MathNode && group.type === "mo") {
      // When TeX writers want to suppress spacing on an operator,
      // they often put the operator by itself inside braces.
      group.setAttribute("lspace", "0em");
      group.setAttribute("rspace", "0em");
    }
    return [group];
  }

  const groups = [];
  const groupArray = [];
  let lastGroup;
  for (let i = 0; i < expression.length; i++) {
    groupArray.push(buildGroup$1(expression[i], style));
  }

  for (let i = 0; i < groupArray.length; i++) {
    const group = groupArray[i];

    // Suppress spacing between adjacent relations
    if (i < expression.length - 1 && isRel(expression[i]) && isRel(expression[i + 1])) {
      group.setAttribute("rspace", "0em");
    }
    if (i > 0 && isRel(expression[i]) && isRel(expression[i - 1])) {
      group.setAttribute("lspace", "0em");
    }

    // Concatenate numbers
    if (group.type === 'mn' && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (isNumberPunctuation(group) && lastGroup && lastGroup.type === 'mn') {
      // Concatenate <mn>...</mn> followed by <mi>.</mi>
      lastGroup.children.push(...group.children);
      continue
    } else if (lastGroup && lastGroup.type === "mn" && i < groupArray.length - 1 &&
      groupArray[i + 1].type === "mn" && isComma(expression, i)) {
      lastGroup.children.push(...group.children);
      continue
    } else if (group.type === 'mn' && isNumberPunctuation(lastGroup)) {
      // Concatenate <mi>.</mi> followed by <mn>...</mn>
      group.children = [...lastGroup.children, ...group.children];
      groups.pop();
    } else if ((group.type === 'msup' || group.type === 'msub') &&
        group.children.length >= 1 && lastGroup &&
        (lastGroup.type === 'mn' || isNumberPunctuation(lastGroup))) {
      // Put preceding <mn>...</mn> or <mi>.</mi> inside base of
      // <msup><mn>...base...</mn>...exponent...</msup> (or <msub>)
      const base = group.children[0];
      if (base instanceof MathNode && base.type === 'mn' && lastGroup) {
        base.children = [...lastGroup.children, ...base.children];
        groups.pop();
      }
    }
    groups.push(group);
    lastGroup = group;
  }
  return groups
};

/**
 * Equivalent to buildExpression, but wraps the elements in an <mrow>
 * if there's more than one.  Returns a single node instead of an array.
 */
const buildExpressionRow = function(expression, style, semisimple = false) {
  return makeRow(buildExpression(expression, style, semisimple), semisimple);
};

/**
 * Takes a group from the parser and calls the appropriate groupBuilders function
 * on it to produce a MathML node.
 */
const buildGroup$1 = function(group, style) {
  if (!group) {
    return new mathMLTree.MathNode("mrow");
  }

  if (_mathmlGroupBuilders[group.type]) {
    // Call the groupBuilders function
    const result = _mathmlGroupBuilders[group.type](group, style);
    return result;
  } else {
    throw new ParseError("Got group of unknown type: '" + group.type + "'");
  }
};

const glue$1 = _ => {
  return new mathMLTree.MathNode("mtd", [], [], { padding: "0", width: "50%" })
};

const labelContainers = ["mrow", "mtd", "mtable", "mtr"];
const getLabel = parent => {
  for (const node of parent.children) {
    if (node.type && labelContainers.includes(node.type)) {
      if (node.classes && node.classes[0] === "tml-label") {
        const label = node.label;
        return label
      } else {
        const label = getLabel(node);
        if (label) { return label }
      }
    } else if (!node.type) {
      const label = getLabel(node);
      if (label) { return label }
    }
  }
};

const taggedExpression = (expression, tag, style, leqno) => {
  tag = buildExpressionRow(tag[0].body, style);
  tag = consolidateText(tag);
  tag.classes.push("tml-tag");

  const label = getLabel(expression); // from a \label{} function.
  expression = new mathMLTree.MathNode("mtd", [expression]);
  const rowArray = [glue$1(), expression, glue$1()];
  rowArray[leqno ? 0 : 2].classes.push(leqno ? "tml-left" : "tml-right");
  rowArray[leqno ? 0 : 2].children.push(tag);
  const mtr = new mathMLTree.MathNode("mtr", rowArray, ["tml-tageqn"]);
  if (label) { mtr.setAttribute("id", label); }
  const table = new mathMLTree.MathNode("mtable", [mtr]);
  table.style.width = "100%";
  table.setAttribute("displaystyle", "true");
  return table
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it.
 */
function buildMathML(tree, texExpression, style, settings) {
  // Strip off outer tag wrapper for processing below.
  let tag = null;
  if (tree.length === 1 && tree[0].type === "tag") {
    tag = tree[0].tag;
    tree = tree[0].body;
  }

  const expression = buildExpression(tree, style);

  if (expression.length === 1 && expression[0] instanceof AnchorNode) {
    return expression[0]
  }

  const wrap = (settings.displayMode || settings.annotate) ? "none" : settings.wrap;

  const n1 = expression.length === 0 ? null : expression[0];
  let wrapper = expression.length === 1 && tag === null && (n1 instanceof MathNode)
      ? expression[0]
      : setLineBreaks(expression, wrap, settings.displayMode);

  if (tag) {
    wrapper = taggedExpression(wrapper, tag, style, settings.leqno);
  }

  if (settings.annotate) {
    // Build a TeX annotation of the source
    const annotation = new mathMLTree.MathNode(
      "annotation", [new mathMLTree.TextNode(texExpression)]);
    annotation.setAttribute("encoding", "application/x-tex");
    wrapper = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
  }

  const math = new mathMLTree.MathNode("math", [wrapper]);

  if (settings.xml) {
    math.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
  }
  if (wrapper.style.width) {
    math.style.width = "100%";
  }
  if (settings.displayMode) {
    math.setAttribute("display", "block");
    math.style.display = "block math"; // necessary in Chromium.
    // Firefox and Safari do not recognize display: "block math".
    // Set a class so that the CSS file can set display: block.
    math.classes = ["tml-display"];
  }
  return math;
}

const smalls = "acegıȷmnopqrsuvwxyzαγεηικμνοπρςστυχωϕ𝐚𝐜𝐞𝐠𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐮𝐯𝐰𝐱𝐲𝐳";
const talls = "ABCDEFGHIJKLMNOPQRSTUVWXYZbdfhkltΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩβδλζφθψ"
             + "𝐀𝐁𝐂𝐃𝐄𝐅𝐆𝐇𝐈𝐉𝐊𝐋𝐌𝐍𝐎𝐏𝐐𝐑𝐒𝐓𝐔𝐕𝐖𝐗𝐘𝐙𝐛𝐝𝐟𝐡𝐤𝐥𝐭";
const longSmalls = new Set(["\\alpha", "\\gamma", "\\delta", "\\epsilon", "\\eta", "\\iota",
  "\\kappa", "\\mu", "\\nu", "\\pi", "\\rho", "\\sigma", "\\tau", "\\upsilon", "\\chi", "\\psi",
  "\\omega", "\\imath", "\\jmath"]);
const longTalls = new Set(["\\Gamma", "\\Delta", "\\Sigma", "\\Omega", "\\beta", "\\delta",
  "\\lambda", "\\theta", "\\psi"]);

const mathmlBuilder$a = (group, style) => {
  const accentNode = group.isStretchy
    ? stretchy.accentNode(group)
    : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);

  if (group.label === "\\vec") {
    accentNode.style.transform = "scale(0.75) translate(10%, 30%)";
  } else {
    accentNode.style.mathStyle = "normal";
    accentNode.style.mathDepth = "0";
    if (needWebkitShift.has(group.label) &&  utils.isCharacterBox(group.base)) {
      let shift = "";
      const ch = group.base.text;
      if (smalls.indexOf(ch) > -1 || longSmalls.has(ch)) { shift = "tml-xshift"; }
      if (talls.indexOf(ch) > -1  || longTalls.has(ch))  { shift = "tml-capshift"; }
      if (shift) { accentNode.classes.push(shift); }
    }
  }
  if (!group.isStretchy) {
    accentNode.setAttribute("stretchy", "false");
  }

  const node = new mathMLTree.MathNode((group.label === "\\c" ? "munder" : "mover"),
    [buildGroup$1(group.base, style), accentNode]
  );

  return node;
};

const nonStretchyAccents = new Set([
  "\\acute",
  "\\grave",
  "\\ddot",
  "\\dddot",
  "\\ddddot",
  "\\tilde",
  "\\bar",
  "\\breve",
  "\\check",
  "\\hat",
  "\\vec",
  "\\dot",
  "\\mathring"
]);

const needWebkitShift = new Set([
  "\\acute",
  "\\bar",
  "\\breve",
  "\\check",
  "\\dot",
  "\\ddot",
  "\\grave",
  "\\hat",
  "\\mathring",
  "\\'", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"
]);

const combiningChar = {
  "\\`": "\u0300",
  "\\'": "\u0301",
  "\\^": "\u0302",
  "\\~": "\u0303",
  "\\=": "\u0304",
  "\\u": "\u0306",
  "\\.": "\u0307",
  '\\"': "\u0308",
  "\\r": "\u030A",
  "\\H": "\u030B",
  "\\v": "\u030C"
};

// Accents
defineFunction({
  type: "accent",
  names: [
    "\\acute",
    "\\grave",
    "\\ddot",
    "\\dddot",
    "\\ddddot",
    "\\tilde",
    "\\bar",
    "\\breve",
    "\\check",
    "\\hat",
    "\\vec",
    "\\dot",
    "\\mathring",
    "\\overparen",
    "\\widecheck",
    "\\widehat",
    "\\wideparen",
    "\\widetilde",
    "\\overrightarrow",
    "\\overleftarrow",
    "\\Overrightarrow",
    "\\overleftrightarrow",
    "\\overgroup",
    "\\overleftharpoon",
    "\\overrightharpoon"
  ],
  props: {
    numArgs: 1
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);

    const isStretchy = !nonStretchyAccents.has(context.funcName);

    return {
      type: "accent",
      mode: context.parser.mode,
      label: context.funcName,
      isStretchy: isStretchy,
      base: base
    };
  },
  mathmlBuilder: mathmlBuilder$a
});

// Text-mode accents
defineFunction({
  type: "accent",
  names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\c", "\\u", "\\.", '\\"', "\\r", "\\H", "\\v"],
  props: {
    numArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const base = normalizeArgument(args[0]);
    const mode = context.parser.mode;

    if (mode === "math" && context.parser.settings.strict) {
      // LaTeX only writes a warning. It doesn't stop. We'll issue the same warning.
      // eslint-disable-next-line no-console
      console.log(`Temml parse error: Command ${context.funcName} is invalid in math mode.`);
    }

    if (mode === "text" && base.text && base.text.length === 1
        && context.funcName in combiningChar  && smalls.indexOf(base.text) > -1) {
      // Return a combining accent character
      return {
        type: "textord",
        mode: "text",
        text: base.text + combiningChar[context.funcName]
      }
    } else {
      // Build up the accent
      return {
        type: "accent",
        mode: mode,
        label: context.funcName,
        isStretchy: false,
        base: base
      }
    }
  },
  mathmlBuilder: mathmlBuilder$a
});

defineFunction({
  type: "accentUnder",
  names: [
    "\\underleftarrow",
    "\\underrightarrow",
    "\\underleftrightarrow",
    "\\undergroup",
    "\\underparen",
    "\\utilde"
  ],
  props: {
    numArgs: 1
  },
  handler: ({ parser, funcName }, args) => {
    const base = args[0];
    return {
      type: "accentUnder",
      mode: parser.mode,
      label: funcName,
      base: base
    };
  },
  mathmlBuilder: (group, style) => {
    const accentNode = stretchy.accentNode(group);
    accentNode.style["math-depth"] = 0;
    const node = new mathMLTree.MathNode("munder", [
      buildGroup$1(group.base, style),
      accentNode
    ]);
    return node;
  }
});

/**
 * This file does conversion between units.  In particular, it provides
 * calculateSize to convert other units into CSS units.
 */


const ptPerUnit = {
  // Convert to CSS (Postscipt) points, not TeX points
  // https://en.wikibooks.org/wiki/LaTeX/Lengths and
  // https://tex.stackexchange.com/a/8263
  pt: 800 / 803, // convert TeX point to CSS (Postscript) point
  pc: (12 * 800) / 803, // pica
  dd: ((1238 / 1157) * 800) / 803, // didot
  cc: ((14856 / 1157) * 800) / 803, // cicero (12 didot)
  nd: ((685 / 642) * 800) / 803, // new didot
  nc: ((1370 / 107) * 800) / 803, // new cicero (12 new didot)
  sp: ((1 / 65536) * 800) / 803, // scaled point (TeX's internal smallest unit)
  mm: (25.4 / 72),
  cm: (2.54 / 72),
  in: (1 / 72),
  px: (96 / 72)
};

/**
 * Determine whether the specified unit (either a string defining the unit
 * or a "size" parse node containing a unit field) is valid.
 */
const validUnits = [
  "em",
  "ex",
  "mu",
  "pt",
  "mm",
  "cm",
  "in",
  "px",
  "bp",
  "pc",
  "dd",
  "cc",
  "nd",
  "nc",
  "sp"
];

const validUnit = function(unit) {
  if (typeof unit !== "string") {
    unit = unit.unit;
  }
  return validUnits.indexOf(unit) > -1
};

const emScale = styleLevel => {
  const scriptLevel = Math.max(styleLevel - 1, 0);
  return [1, 0.7, 0.5][scriptLevel]
};

/*
 * Convert a "size" parse node (with numeric "number" and string "unit" fields,
 * as parsed by functions.js argType "size") into a CSS value.
 */
const calculateSize = function(sizeValue, style) {
  let number = sizeValue.number;
  if (style.maxSize[0] < 0 && number > 0) {
    return { number: 0, unit: "em" }
  }
  const unit = sizeValue.unit;
  switch (unit) {
    case "mm":
    case "cm":
    case "in":
    case "px": {
      const numInCssPts = number * ptPerUnit[unit];
      if (numInCssPts > style.maxSize[1]) {
        return { number: style.maxSize[1], unit: "pt" }
      }
      return { number, unit }; // absolute CSS units.
    }
    case "em":
    case "ex": {
      // In TeX, em and ex do not change size in \scriptstyle.
      if (unit === "ex") { number *= 0.431; }
      number = Math.min(number / emScale(style.level), style.maxSize[0]);
      return { number: utils.round(number), unit: "em" };
    }
    case "bp": {
      if (number > style.maxSize[1]) { number = style.maxSize[1]; }
      return { number, unit: "pt" }; // TeX bp is a CSS pt. (1/72 inch).
    }
    case "pt":
    case "pc":
    case "dd":
    case "cc":
    case "nd":
    case "nc":
    case "sp": {
      number = Math.min(number * ptPerUnit[unit], style.maxSize[1]);
      return { number: utils.round(number), unit: "pt" }
    }
    case "mu": {
      number = Math.min(number / 18, style.maxSize[0]);
      return { number: utils.round(number), unit: "em" }
    }
    default:
      throw new ParseError("Invalid unit: '" + unit + "'")
  }
};

// Helper functions

const padding$1 = width => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", width + "em");
  return node
};

const paddedNode = (group, lspace = 0.3, rspace = 0, mustSmash = false) => {
  if (group == null && rspace === 0) { return padding$1(lspace) }
  const row = group ? [group] : [];
  if (lspace !== 0)   { row.unshift(padding$1(lspace)); }
  if (rspace > 0) { row.push(padding$1(rspace)); }
  if (mustSmash) {
    // Used for the bottom arrow in a {CD} environment
    const mpadded = new mathMLTree.MathNode("mpadded", row);
    mpadded.setAttribute("height", "0");
    return mpadded
  } else {
    return new mathMLTree.MathNode("mrow", row)
  }
};

const labelSize = (size, scriptLevel) =>  Number(size) / emScale(scriptLevel);

const munderoverNode = (fName, body, below, style) => {
  const arrowNode = stretchy.mathMLnode(fName);
  // Is this the short part of a mhchem equilibrium arrow?
  const isEq = fName.slice(1, 3) === "eq";
  const minWidth = fName.charAt(1) === "x"
    ? "1.75"  // mathtools extensible arrows are ≥ 1.75em long
    : fName.slice(2, 4) === "cd"
    ? "3.0"  // cd package arrows
    : isEq
    ? "1.0"  // The shorter harpoon of a mhchem equilibrium arrow
    : "2.0"; // other mhchem arrows
  // TODO: When Firefox supports minsize, use the next line.
  //arrowNode.setAttribute("minsize", String(minWidth) + "em")
  arrowNode.setAttribute("lspace", "0");
  arrowNode.setAttribute("rspace", (isEq ? "0.5em" : "0"));

  // <munderover> upper and lower labels are set to scriptlevel by MathML
  // So we have to adjust our label dimensions accordingly.
  const labelStyle = style.withLevel(style.level < 2 ? 2 : 3);
  const minArrowWidth = labelSize(minWidth, labelStyle.level);
  // The dummyNode will be inside a <mover> inside a <mover>
  // So it will be at scriptlevel 3
  const dummyWidth = labelSize(minWidth, 3);
  const emptyLabel = paddedNode(null, minArrowWidth.toFixed(4), 0);
  const dummyNode = paddedNode(null, dummyWidth.toFixed(4), 0);
  // The arrow is a little longer than the label. Set a spacer length.
  const space = labelSize((isEq ? 0 : 0.3), labelStyle.level).toFixed(4);
  let upperNode;
  let lowerNode;

  const gotUpper = (body && body.body &&
    // \hphantom        visible content
    (body.body.body || body.body.length > 0));
  if (gotUpper) {
    let label =  buildGroup$1(body, labelStyle);
    const mustSmash = (fName === "\\\\cdrightarrow" || fName === "\\\\cdleftarrow");
    label = paddedNode(label, space, space, mustSmash);
    // Since Firefox does not support minsize, stack a invisible node
    // on top of the label. Its width will serve as a min-width.
    // TODO: Refactor this after Firefox supports minsize.
    upperNode = new mathMLTree.MathNode("mover", [label, dummyNode]);
  }
  const gotLower = (below && below.body &&
    (below.body.body || below.body.length > 0));
  if (gotLower) {
    let label =  buildGroup$1(below, labelStyle);
    label = paddedNode(label, space, space);
    lowerNode = new mathMLTree.MathNode("munder", [label, dummyNode]);
  }

  let node;
  if (!gotUpper && !gotLower) {
    node = new mathMLTree.MathNode("mover", [arrowNode, emptyLabel]);
  } else if (gotUpper && gotLower) {
    node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
  } else if (gotUpper) {
    node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
  } else {
    node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
  }
  if (minWidth === "3.0") { node.style.height = "1em"; } // CD environment
  node.setAttribute("accent", "false"); // Necessary for MS Word
  return node
};

// Stretchy arrows with an optional argument
defineFunction({
  type: "xArrow",
  names: [
    "\\xleftarrow",
    "\\xrightarrow",
    "\\xLeftarrow",
    "\\xRightarrow",
    "\\xleftrightarrow",
    "\\xLeftrightarrow",
    "\\xhookleftarrow",
    "\\xhookrightarrow",
    "\\xmapsto",
    "\\xrightharpoondown",
    "\\xrightharpoonup",
    "\\xleftharpoondown",
    "\\xleftharpoonup",
    "\\xlongequal",
    "\\xtwoheadrightarrow",
    "\\xtwoheadleftarrow",
    // The next 5 functions are here only to support mhchem
    "\\yields",
    "\\yieldsLeft",
    "\\mesomerism",
    "\\longrightharpoonup",
    "\\longleftharpoondown",
    // The next 3 functions are here only to support the {CD} environment.
    "\\\\cdrightarrow",
    "\\\\cdleftarrow",
    "\\\\cdlongequal"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    return {
      type: "xArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    // Build the arrow and its labels.
    const node = munderoverNode(group.name, group.body, group.below, style);
    // Create operator spacing for a relation.
    const row = [node];
    row.unshift(padding$1(0.2778));
    row.push(padding$1(0.2778));
    return new mathMLTree.MathNode("mrow", row)
  }
});

const arrowComponent = {
  "\\xtofrom": ["\\xrightarrow", "\\xleftarrow"],
  "\\xleftrightharpoons": ["\\xleftharpoonup", "\\xrightharpoondown"],
  "\\xrightleftharpoons": ["\\xrightharpoonup", "\\xleftharpoondown"],
  "\\yieldsLeftRight": ["\\yields", "\\yieldsLeft"],
  // The next three all get the same harpoon glyphs. Only the lengths and paddings differ.
  "\\equilibrium": ["\\longrightharpoonup", "\\longleftharpoondown"],
  "\\equilibriumRight": ["\\longrightharpoonup", "\\eqleftharpoondown"],
  "\\equilibriumLeft": ["\\eqrightharpoonup", "\\longleftharpoondown"]
};

// Browsers are not good at stretching a glyph that contains a pair of stacked arrows such as ⇄.
// So we stack a pair of single arrows.
defineFunction({
  type: "stackedArrow",
  names: [
    "\\xtofrom",              // expfeil
    "\\xleftrightharpoons",   // mathtools
    "\\xrightleftharpoons",   // mathtools
    "\\yieldsLeftRight",      // mhchem
    "\\equilibrium",          // mhchem
    "\\equilibriumRight",
    "\\equilibriumLeft"
  ],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser, funcName }, args, optArgs) {
    const lowerArrowBody = args[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: args[0]
      }
      : null;
    const upperArrowBelow = optArgs[0]
      ? {
        type: "hphantom",
        mode: parser.mode,
        body: optArgs[0]
      }
      : null;
    return {
      type: "stackedArrow",
      mode: parser.mode,
      name: funcName,
      body: args[0],
      upperArrowBelow,
      lowerArrowBody,
      below: optArgs[0]
    };
  },
  mathmlBuilder(group, style) {
    const topLabel = arrowComponent[group.name][0];
    const botLabel = arrowComponent[group.name][1];
    const topArrow = munderoverNode(topLabel, group.body, group.upperArrowBelow, style);
    const botArrow = munderoverNode(botLabel, group.lowerArrowBody, group.below, style);
    let wrapper;

    const raiseNode = new mathMLTree.MathNode("mpadded", [topArrow]);
    raiseNode.setAttribute("voffset", "0.3em");
    raiseNode.setAttribute("height", "+0.3em");
    raiseNode.setAttribute("depth", "-0.3em");
    // One of the arrows is given ~zero width. so the other has the same horzontal alignment.
    if (group.name === "\\equilibriumLeft") {
      const botNode =  new mathMLTree.MathNode("mpadded", [botArrow]);
      botNode.setAttribute("width", "0.5em");
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), botNode, raiseNode, padding$1(0.2778)]
      );
    } else {
      raiseNode.setAttribute("width", (group.name === "\\equilibriumRight" ? "0.5em" : "0"));
      wrapper = new mathMLTree.MathNode(
        "mpadded",
        [padding$1(0.2778), raiseNode, botArrow, padding$1(0.2778)]
      );
    }

    wrapper.setAttribute("voffset", "-0.18em");
    wrapper.setAttribute("height", "-0.18em");
    wrapper.setAttribute("depth", "+0.18em");
    return wrapper
  }
});

/**
 * All registered environments.
 * `environments.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `environments.js`.
 */
const _environments = {};

function defineEnvironment({ type, names, props, handler, mathmlBuilder }) {
  // Set default values of environments.
  const data = {
    type,
    numArgs: props.numArgs || 0,
    allowedInText: false,
    numOptionalArgs: 0,
    handler
  };
  for (let i = 0; i < names.length; ++i) {
    _environments[names[i]] = data;
  }
  if (mathmlBuilder) {
    _mathmlGroupBuilders[type] = mathmlBuilder;
  }
}

/**
 * Asserts that the node is of the given type and returns it with stricter
 * typing. Throws if the node's type does not match.
 */
function assertNodeType(node, type) {
  if (!node || node.type !== type) {
    throw new Error(
      `Expected node of type ${type}, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return node;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function assertSymbolNodeType(node) {
  const typedNode = checkSymbolNodeType(node);
  if (!typedNode) {
    throw new Error(
      `Expected node of symbol group type, but got ` +
        (node ? `node of type ${node.type}` : String(node))
    );
  }
  return typedNode;
}

/**
 * Returns the node more strictly typed iff it is of the given type. Otherwise,
 * returns null.
 */
function checkSymbolNodeType(node) {
  if (node && (node.type === "atom" ||
      Object.prototype.hasOwnProperty.call(NON_ATOMS, node.type))) {
    return node;
  }
  return null;
}

const cdArrowFunctionName = {
  ">": "\\\\cdrightarrow",
  "<": "\\\\cdleftarrow",
  "=": "\\\\cdlongequal",
  A: "\\uparrow",
  V: "\\downarrow",
  "|": "\\Vert",
  ".": "no arrow"
};

const newCell = () => {
  // Create an empty cell, to be filled below with parse nodes.
  return { type: "styling", body: [], mode: "math", scriptLevel: "display" };
};

const isStartOfArrow = (node) => {
  return node.type === "textord" && node.text === "@";
};

const isLabelEnd = (node, endChar) => {
  return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
};

function cdArrow(arrowChar, labels, parser) {
  // Return a parse tree of an arrow and its labels.
  // This acts in a way similar to a macro expansion.
  const funcName = cdArrowFunctionName[arrowChar];
  switch (funcName) {
    case "\\\\cdrightarrow":
    case "\\\\cdleftarrow":
      return parser.callFunction(funcName, [labels[0]], [labels[1]]);
    case "\\uparrow":
    case "\\downarrow": {
      const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
      const bareArrow = {
        type: "atom",
        text: funcName,
        mode: "math",
        family: "rel"
      };
      const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
      const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
      const arrowGroup = {
        type: "ordgroup",
        mode: "math",
        body: [leftLabel, sizedArrow, rightLabel],
        semisimple: true
      };
      return parser.callFunction("\\\\cdparent", [arrowGroup], []);
    }
    case "\\\\cdlongequal":
      return parser.callFunction("\\\\cdlongequal", [], []);
    case "\\Vert": {
      const arrow = { type: "textord", text: "\\Vert", mode: "math" };
      return parser.callFunction("\\Big", [arrow], []);
    }
    default:
      return { type: "textord", text: " ", mode: "math" };
  }
}

function parseCD(parser) {
  // Get the array's parse nodes with \\ temporarily mapped to \cr.
  const parsedRows = [];
  parser.gullet.beginGroup();
  parser.gullet.macros.set("\\cr", "\\\\\\relax");
  parser.gullet.beginGroup();
  while (true) {
    // Get the parse nodes for the next row.
    parsedRows.push(parser.parseExpression(false, "\\\\"));
    parser.gullet.endGroup();
    parser.gullet.beginGroup();
    const next = parser.fetch().text;
    if (next === "&" || next === "\\\\") {
      parser.consume();
    } else if (next === "\\end") {
      if (parsedRows[parsedRows.length - 1].length === 0) {
        parsedRows.pop(); // final row ended in \\
      }
      break;
    } else {
      throw new ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
    }
  }

  let row = [];
  const body = [row];

  // Loop thru the parse nodes. Collect them into cells and arrows.
  for (let i = 0; i < parsedRows.length; i++) {
    // Start a new row.
    const rowNodes = parsedRows[i];
    // Create the first cell.
    let cell = newCell();

    for (let j = 0; j < rowNodes.length; j++) {
      if (!isStartOfArrow(rowNodes[j])) {
        // If a parseNode is not an arrow, it goes into a cell.
        cell.body.push(rowNodes[j]);
      } else {
        // Parse node j is an "@", the start of an arrow.
        // Before starting on the arrow, push the cell into `row`.
        row.push(cell);

        // Now collect parseNodes into an arrow.
        // The character after "@" defines the arrow type.
        j += 1;
        const arrowChar = assertSymbolNodeType(rowNodes[j]).text;

        // Create two empty label nodes. We may or may not use them.
        const labels = new Array(2);
        labels[0] = { type: "ordgroup", mode: "math", body: [] };
        labels[1] = { type: "ordgroup", mode: "math", body: [] };

        // Process the arrow.
        if ("=|.".indexOf(arrowChar) > -1) ; else if ("<>AV".indexOf(arrowChar) > -1) {
          // Four arrows, `@>>>`, `@<<<`, `@AAA`, and `@VVV`, each take
          // two optional labels. E.g. the right-point arrow syntax is
          // really:  @>{optional label}>{optional label}>
          // Collect parseNodes into labels.
          for (let labelNum = 0; labelNum < 2; labelNum++) {
            let inLabel = true;
            for (let k = j + 1; k < rowNodes.length; k++) {
              if (isLabelEnd(rowNodes[k], arrowChar)) {
                inLabel = false;
                j = k;
                break;
              }
              if (isStartOfArrow(rowNodes[k])) {
                throw new ParseError(
                  "Missing a " + arrowChar + " character to complete a CD arrow.",
                  rowNodes[k]
                );
              }

              labels[labelNum].body.push(rowNodes[k]);
            }
            if (inLabel) {
              // isLabelEnd never returned a true.
              throw new ParseError(
                "Missing a " + arrowChar + " character to complete a CD arrow.",
                rowNodes[j]
              );
            }
          }
        } else {
          throw new ParseError(`Expected one of "<>AV=|." after @.`);
        }

        // Now join the arrow to its labels.
        const arrow = cdArrow(arrowChar, labels, parser);

        // Wrap the arrow in a styling node
        row.push(arrow);
        // In CD's syntax, cells are implicit. That is, everything that
        // is not an arrow gets collected into a cell. So create an empty
        // cell now. It will collect upcoming parseNodes.
        cell = newCell();
      }
    }
    if (i % 2 === 0) {
      // Even-numbered rows consist of: cell, arrow, cell, arrow, ... cell
      // The last cell is not yet pushed into `row`, so:
      row.push(cell);
    } else {
      // Odd-numbered rows consist of: vert arrow, empty cell, ... vert arrow
      // Remove the empty cell that was placed at the beginning of `row`.
      row.shift();
    }
    row = [];
    body.push(row);
  }
  body.pop();

  // End row group
  parser.gullet.endGroup();
  // End array group defining \\
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: "math",
    body,
    tags: null,
    labels: new Array(body.length + 1).fill(""),
    envClasses: ["jot", "cd"],
    cols: [],
    hLinesBeforeRow: new Array(body.length + 1).fill([])
  };
}

// The functions below are not available for general use.
// They are here only for internal use by the {CD} environment in placing labels
// next to vertical arrows.

// We don't need any such functions for horizontal arrows because we can reuse
// the functionality that already exists for extensible arrows.

defineFunction({
  type: "cdlabel",
  names: ["\\\\cdleft", "\\\\cdright"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "cdlabel",
      mode: parser.mode,
      side: funcName.slice(4),
      label: args[0]
    };
  },
  mathmlBuilder(group, style) {
    if (group.label.body.length === 0) {
      return new mathMLTree.MathNode("mrow", style)  // empty label
    }
    // Abuse an <mtable> to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.label, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    const mtable = new mathMLTree.MathNode("mtable", [mtr]);
    const label = new mathMLTree.MathNode("mpadded", [mtable]);
    // Set the label width to zero so that the arrow will be centered under the corner cell.
    label.setAttribute("width", "0");
    label.setAttribute("displaystyle", "false");
    label.setAttribute("scriptlevel", "1");
    if (group.side === "left") {
      label.style.display = "flex";
      label.style.justifyContent = "flex-end";
    }
    return label;
  }
});

defineFunction({
  type: "cdlabelparent",
  names: ["\\\\cdparent"],
  props: {
    numArgs: 1
  },
  handler({ parser }, args) {
    return {
      type: "cdlabelparent",
      mode: parser.mode,
      fragment: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow", [buildGroup$1(group.fragment, style)]);
  }
});

const ordGroup = (body) => {
  return {
    "type": "ordgroup",
    "mode": "math",
    "body": body,
    "semisimple": true
  }
};

const phantom = (body, type) => {
  return {
    "type": type,
    "mode": "math",
    "body": ordGroup(body)
  }
};

/*
 * A helper for \bordermatrix.
 * parseArray() has parsed the tokens as if the environment
 * was \begin{matrix}. That parse tree is this function’s input.
 * Here, we rearrange the parse tree to get one that will
 * result in TeX \bordermatrix.
 * The final result includes a {pmatrix}, which is the bottom
 * half of a <mover> element. The top of the <mover> contains
 * the \bordermatrix headings. The top section also contains the
 * contents of the bottom {pmatrix}. Those elements are hidden via
 * \hphantom, but they ensure that column widths are the same top and
 * bottom.
 *
 * We also create a left {matrix} with a single column that contains
 * elements shifted out of the matrix. The left {matrix} also
 * contains \vphantom copies of the other {pmatrix} elements.
 * As before, this ensures consistent row heights of left and main.
 */

const bordermatrixParseTree = (matrix, delimiters) => {
  const body = matrix.body;
  body[0].shift(); // dispose of top left cell

  // Create an array for the left column
  const leftColumnBody = new Array(body.length - 1).fill().map(() => []);
  for (let i = 1; i < body.length; i++) {
    // The visible part of the cell
    leftColumnBody[i - 1].push(body[i].shift());
    // A vphantom with contents from the pmatrix, to set minimum cell height
    const phantomBody = [];
    for (let j = 0; j < body[i].length; j++) {
      phantomBody.push(structuredClone(body[i][j]));
    }
    leftColumnBody[i - 1].push(phantom(phantomBody, "vphantom"));
  }

  // Create an array for the top row
  const topRowBody = new Array(body.length).fill().map(() => []);
  for (let j = 0; j < body[0].length; j++) {
    topRowBody[0].push(structuredClone(body[0][j]));
  }
  // Copy the rest of the pmatrix, but squashed via \hphantom
  for (let i = 1; i < body.length; i++) {
    for (let j = 0; j < body[0].length; j++) {
      topRowBody[i].push(phantom(structuredClone(body[i][j]).body, "hphantom"));
    }
  }

  // Squash the top row of the main {pmatrix}
  for (let j = 0; j < body[0].length; j++) {
    body[0][j] = phantom(structuredClone(body[0][j]).body, "hphantom");
  }

  // Now wrap the arrays in the proper parse nodes.

  const leftColumn = {
    type: "array",
    mode: "math",
    body: leftColumnBody,
    cols: [{ type: "align", align: "c" }],
    rowGaps: new Array(leftColumnBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(leftColumnBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(leftColumnBody.length).fill(""),
    arraycolsep: { "number": 0.04, unit: "em" }
  };

  const topRow = {
    type: "array",
    mode: "math",
    body: topRowBody,
    cols: new Array(topRowBody.length).fill({ type: "align", align: "c" }),
    rowGaps: new Array(topRowBody.length - 1).fill(null),
    hLinesBeforeRow: new Array(topRowBody.length + 1).fill().map(() => []),
    envClasses: [],
    scriptLevel: "text",
    arraystretch: 1,
    labels: new Array(topRowBody.length).fill(""),
    arraycolsep: null
  };

  const topWrapper = {
    type: "styling",
    mode: "math",
    scriptLevel: "text", // Must set this explicitly.
    body: [topRow]       // Default level is "script".
  };

  const container = {
    type: "leftright",
    mode: "math",
    body: [matrix],
    left: delimiters ? delimiters[0] : "(",
    right: delimiters ? delimiters[1] : ")",
    rightColor: undefined
  };

  const base = {
    type: "op",   // The base of a TeX \overset
    mode: "math",
    limits: true,
    alwaysHandleSupSub: true,
    parentIsSupSub: true,
    symbol: false,
    stack: true,
    suppressBaseShift: true,
    body: [container]
  };

  const mover = {
    type: "supsub",  // We're using the MathML equivalent
    mode: "math",    // of TeX \overset.
    base: base,      // That keeps the {pmatrix} aligned with
    sup: topWrapper, // the math centerline.
    sub: null
  };

  return ordGroup([leftColumn, mover])
};

/**
 * Lexing or parsing positional information for error reporting.
 * This object is immutable.
 */
class SourceLocation {
  constructor(lexer, start, end) {
    this.lexer = lexer; // Lexer holding the input string.
    this.start = start; // Start offset, zero-based inclusive.
    this.end = end;     // End offset, zero-based exclusive.
  }

  /**
   * Merges two `SourceLocation`s from location providers, given they are
   * provided in order of appearance.
   * - Returns the first one's location if only the first is provided.
   * - Returns a merged range of the first and the last if both are provided
   *   and their lexers match.
   * - Otherwise, returns null.
   */
  static range(first, second) {
    if (!second) {
      return first && first.loc;
    } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
      return null;
    } else {
      return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
    }
  }
}

/**
 * Interface required to break circular dependency between Token, Lexer, and
 * ParseError.
 */

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information is optional, so it is OK to construct synthetic
 * tokens if appropriate. Not providing available position information may
 * lead to degraded error reporting, though.
 */
class Token {
  constructor(
    text, // the text of this token
    loc
  ) {
    this.text = text;
    this.loc = loc;
  }

  /**
   * Given a pair of tokens (this and endToken), compute a `Token` encompassing
   * the whole input range enclosed by these two.
   */
  range(
    endToken, // last token of the range, inclusive
    text // the text of the newly constructed token
  ) {
    return new Token(text, SourceLocation.range(this, endToken));
  }
}

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are
// provided in the the arrays below, in that order.
//

// Math style is not quite the same thing as script level.
const StyleLevel = {
  DISPLAY: 0,
  TEXT: 1,
  SCRIPT: 2,
  SCRIPTSCRIPT: 3
};

/**
 * All registered global/built-in macros.
 * `macros.js` exports this same dictionary again and makes it public.
 * `Parser.js` requires this dictionary via `macros.js`.
 */
const _macros = {};

// This function might one day accept an additional argument and do more things.
function defineMacro(name, body) {
  _macros[name] = body;
}

/**
 * Predefined macros for Temml.
 * This can be used to define some commands in terms of others.
 */

const macros = _macros;

//////////////////////////////////////////////////////////////////////
// macro tools

defineMacro("\\noexpand", function(context) {
  // The expansion is the token itself; but that token is interpreted
  // as if its meaning were ‘\relax’ if it is a control sequence that
  // would ordinarily be expanded by TeX’s expansion rules.
  const t = context.popToken();
  if (context.isExpandable(t.text)) {
    t.noexpand = true;
    t.treatAsRelax = true;
  }
  return { tokens: [t], numArgs: 0 };
});

defineMacro("\\expandafter", function(context) {
  // TeX first reads the token that comes immediately after \expandafter,
  // without expanding it; let’s call this token t. Then TeX reads the
  // token that comes after t (and possibly more tokens, if that token
  // has an argument), replacing it by its expansion. Finally TeX puts
  // t back in front of that expansion.
  const t = context.popToken();
  context.expandOnce(true); // expand only an expandable token
  return { tokens: [t], numArgs: 0 };
});

// LaTeX's \@firstoftwo{#1}{#2} expands to #1, skipping #2
// TeX source: \long\def\@firstoftwo#1#2{#1}
defineMacro("\\@firstoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[0], numArgs: 0 };
});

// LaTeX's \@secondoftwo{#1}{#2} expands to #2, skipping #1
// TeX source: \long\def\@secondoftwo#1#2{#2}
defineMacro("\\@secondoftwo", function(context) {
  const args = context.consumeArgs(2);
  return { tokens: args[1], numArgs: 0 };
});

// LaTeX's \@ifnextchar{#1}{#2}{#3} looks ahead to the next (unexpanded)
// symbol that isn't a space, consuming any spaces but not consuming the
// first nonspace character.  If that nonspace character matches #1, then
// the macro expands to #2; otherwise, it expands to #3.
defineMacro("\\@ifnextchar", function(context) {
  const args = context.consumeArgs(3); // symbol, if, else
  context.consumeSpaces();
  const nextToken = context.future();
  if (args[0].length === 1 && args[0][0].text === nextToken.text) {
    return { tokens: args[1], numArgs: 0 };
  } else {
    return { tokens: args[2], numArgs: 0 };
  }
});

// LaTeX's \@ifstar{#1}{#2} looks ahead to the next (unexpanded) symbol.
// If it is `*`, then it consumes the symbol, and the macro expands to #1;
// otherwise, the macro expands to #2 (without consuming the symbol).
// TeX source: \def\@ifstar#1{\@ifnextchar *{\@firstoftwo{#1}}}
defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");

// LaTeX's \TextOrMath{#1}{#2} expands to #1 in text mode, #2 in math mode
defineMacro("\\TextOrMath", function(context) {
  const args = context.consumeArgs(2);
  if (context.mode === "text") {
    return { tokens: args[0], numArgs: 0 };
  } else {
    return { tokens: args[1], numArgs: 0 };
  }
});

const stringFromArg = arg => {
  // Reverse the order of the arg and return a string.
  let str = "";
  for (let i = arg.length - 1; i > -1; i--) {
    str += arg[i].text;
  }
  return str
};

// Lookup table for parsing numbers in base 8 through 16
const digitToNumber = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  a: 10,
  A: 10,
  b: 11,
  B: 11,
  c: 12,
  C: 12,
  d: 13,
  D: 13,
  e: 14,
  E: 14,
  f: 15,
  F: 15
};

const nextCharNumber = context => {
  const numStr = context.future().text;
  if (numStr === "EOF") { return [null, ""] }
  return [digitToNumber[numStr.charAt(0)], numStr]
};

const appendCharNumbers = (number, numStr, base) => {
  for (let i = 1; i < numStr.length; i++) {
    const digit = digitToNumber[numStr.charAt(i)];
    number *= base;
    number += digit;
  }
  return number
};

// TeX \char makes a literal character (catcode 12) using the following forms:
// (see The TeXBook, p. 43)
//   \char123  -- decimal
//   \char'123 -- octal
//   \char"123 -- hex
//   \char`x   -- character that can be written (i.e. isn't active)
//   \char`\x  -- character that cannot be written (e.g. %)
// These all refer to characters from the font, so we turn them into special
// calls to a function \@char dealt with in the Parser.
defineMacro("\\char", function(context) {
  let token = context.popToken();
  let base;
  let number = "";
  if (token.text === "'") {
    base = 8;
    token = context.popToken();
  } else if (token.text === '"') {
    base = 16;
    token = context.popToken();
  } else if (token.text === "`") {
    token = context.popToken();
    if (token.text[0] === "\\") {
      number = token.text.charCodeAt(1);
    } else if (token.text === "EOF") {
      throw new ParseError("\\char` missing argument");
    } else {
      number = token.text.charCodeAt(0);
    }
  } else {
    base = 10;
  }
  if (base) {
    // Parse a number in the given base, starting with first `token`.
    let numStr = token.text;
    number = digitToNumber[numStr.charAt(0)];
    if (number == null || number >= base) {
      throw new ParseError(`Invalid base-${base} digit ${token.text}`);
    }
    number = appendCharNumbers(number, numStr, base);
    let digit;
    [digit, numStr] = nextCharNumber(context);
    while (digit != null && digit < base) {
      number *= base;
      number += digit;
      number = appendCharNumbers(number, numStr, base);
      context.popToken();
      [digit, numStr] = nextCharNumber(context);
    }
  }
  return `\\@char{${number}}`;
});

function recreateArgStr(context) {
  // Recreate the macro's original argument string from the array of parse tokens.
  const tokens = context.consumeArgs(1)[0];
  let str = "";
  let expectedLoc = tokens[tokens.length - 1].loc.start;
  for (let i = tokens.length - 1; i >= 0; i--) {
    const actualLoc = tokens[i].loc.start;
    if (actualLoc > expectedLoc) {
      // context.consumeArgs has eaten a space.
      str += " ";
      expectedLoc = actualLoc;
    }
    str += tokens[i].text;
    expectedLoc += tokens[i].text.length;
  }
  return str
}

// The Latin Modern font renders <mi>√</mi> at the wrong vertical alignment.
// This macro provides a better rendering.
defineMacro("\\surd", '\\sqrt{\\vphantom{|}}');

// See comment for \oplus in symbols.js.
defineMacro("\u2295", "\\oplus");

// Since Temml has no \par, ignore \long.
defineMacro("\\long", "");

//////////////////////////////////////////////////////////////////////
// Grouping
// \let\bgroup={ \let\egroup=}
defineMacro("\\bgroup", "{");
defineMacro("\\egroup", "}");

// Symbols from latex.ltx:
// \def~{\nobreakspace{}}
// \def\lq{`}
// \def\rq{'}
// \def \aa {\r a}
defineMacro("~", "\\nobreakspace");
defineMacro("\\lq", "`");
defineMacro("\\rq", "'");
defineMacro("\\aa", "\\r a");

defineMacro("\\Bbbk", "\\Bbb{k}");

// \mathstrut from the TeXbook, p 360
defineMacro("\\mathstrut", "\\vphantom{(}");

// \underbar from TeXbook p 353
defineMacro("\\underbar", "\\underline{\\text{#1}}");

//////////////////////////////////////////////////////////////////////
// LaTeX_2ε

// \vdots{\vbox{\baselineskip4\p@  \lineskiplimit\z@
// \kern6\p@\hbox{.}\hbox{.}\hbox{.}}}
// We'll call \varvdots, which gets a glyph from symbols.js.
// The zero-width rule gets us an equivalent to the vertical 6pt kern.
defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
defineMacro("\u22ee", "\\vdots");

// {array} environment gaps
defineMacro("\\arraystretch", "1");     // line spacing factor times 12pt
defineMacro("\\arraycolsep", "6pt");    // half the width separating columns

//////////////////////////////////////////////////////////////////////
// amsmath.sty
// http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf

//\newcommand{\substack}[1]{\subarray{c}#1\endsubarray}
defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");

// \def\iff{\DOTSB\;\Longleftrightarrow\;}
// \def\implies{\DOTSB\;\Longrightarrow\;}
// \def\impliedby{\DOTSB\;\Longleftarrow\;}
defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");

// AMSMath's automatic \dots, based on \mdots@@ macro.
const dotsByToken = {
  ",": "\\dotsc",
  "\\not": "\\dotsb",
  // \keybin@ checks for the following:
  "+": "\\dotsb",
  "=": "\\dotsb",
  "<": "\\dotsb",
  ">": "\\dotsb",
  "-": "\\dotsb",
  "*": "\\dotsb",
  ":": "\\dotsb",
  // Symbols whose definition starts with \DOTSB:
  "\\DOTSB": "\\dotsb",
  "\\coprod": "\\dotsb",
  "\\bigvee": "\\dotsb",
  "\\bigwedge": "\\dotsb",
  "\\biguplus": "\\dotsb",
  "\\bigcap": "\\dotsb",
  "\\bigcup": "\\dotsb",
  "\\prod": "\\dotsb",
  "\\sum": "\\dotsb",
  "\\bigotimes": "\\dotsb",
  "\\bigoplus": "\\dotsb",
  "\\bigodot": "\\dotsb",
  "\\bigsqcap": "\\dotsb",
  "\\bigsqcup": "\\dotsb",
  "\\bigtimes": "\\dotsb",
  "\\And": "\\dotsb",
  "\\longrightarrow": "\\dotsb",
  "\\Longrightarrow": "\\dotsb",
  "\\longleftarrow": "\\dotsb",
  "\\Longleftarrow": "\\dotsb",
  "\\longleftrightarrow": "\\dotsb",
  "\\Longleftrightarrow": "\\dotsb",
  "\\mapsto": "\\dotsb",
  "\\longmapsto": "\\dotsb",
  "\\hookrightarrow": "\\dotsb",
  "\\doteq": "\\dotsb",
  // Symbols whose definition starts with \mathbin:
  "\\mathbin": "\\dotsb",
  // Symbols whose definition starts with \mathrel:
  "\\mathrel": "\\dotsb",
  "\\relbar": "\\dotsb",
  "\\Relbar": "\\dotsb",
  "\\xrightarrow": "\\dotsb",
  "\\xleftarrow": "\\dotsb",
  // Symbols whose definition starts with \DOTSI:
  "\\DOTSI": "\\dotsi",
  "\\int": "\\dotsi",
  "\\oint": "\\dotsi",
  "\\iint": "\\dotsi",
  "\\iiint": "\\dotsi",
  "\\iiiint": "\\dotsi",
  "\\idotsint": "\\dotsi",
  // Symbols whose definition starts with \DOTSX:
  "\\DOTSX": "\\dotsx"
};

defineMacro("\\dots", function(context) {
  // TODO: If used in text mode, should expand to \textellipsis.
  // However, in Temml, \textellipsis and \ldots behave the same
  // (in text mode), and it's unlikely we'd see any of the math commands
  // that affect the behavior of \dots when in text mode.  So fine for now
  // (until we support \ifmmode ... \else ... \fi).
  let thedots = "\\dotso";
  const next = context.expandAfterFuture().text;
  if (next in dotsByToken) {
    thedots = dotsByToken[next];
  } else if (next.slice(0, 4) === "\\not") {
    thedots = "\\dotsb";
  } else if (next in symbols.math) {
    if (["bin", "rel"].includes(symbols.math[next].group)) {
      thedots = "\\dotsb";
    }
  }
  return thedots;
});

const spaceAfterDots = {
  // \rightdelim@ checks for the following:
  ")": true,
  "]": true,
  "\\rbrack": true,
  "\\}": true,
  "\\rbrace": true,
  "\\rangle": true,
  "\\rceil": true,
  "\\rfloor": true,
  "\\rgroup": true,
  "\\rmoustache": true,
  "\\right": true,
  "\\bigr": true,
  "\\biggr": true,
  "\\Bigr": true,
  "\\Biggr": true,
  // \extra@ also tests for the following:
  $: true,
  // \extrap@ checks for the following:
  ";": true,
  ".": true,
  ",": true
};

defineMacro("\\dotso", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\dotsc", function(context) {
  const next = context.future().text;
  // \dotsc uses \extra@ but not \extrap@, instead specially checking for
  // ';' and '.', but doesn't check for ','.
  if (next in spaceAfterDots && next !== ",") {
    return "\\ldots\\,";
  } else {
    return "\\ldots";
  }
});

defineMacro("\\cdots", function(context) {
  const next = context.future().text;
  if (next in spaceAfterDots) {
    return "\\@cdots\\,";
  } else {
    return "\\@cdots";
  }
});

defineMacro("\\dotsb", "\\cdots");
defineMacro("\\dotsm", "\\cdots");
defineMacro("\\dotsi", "\\!\\cdots");
defineMacro("\\idotsint", "\\dotsi");
// amsmath doesn't actually define \dotsx, but \dots followed by a macro
// starting with \DOTSX implies \dotso, and then \extra@ detects this case
// and forces the added `\,`.
defineMacro("\\dotsx", "\\ldots\\,");

// \let\DOTSI\relax
// \let\DOTSB\relax
// \let\DOTSX\relax
defineMacro("\\DOTSI", "\\relax");
defineMacro("\\DOTSB", "\\relax");
defineMacro("\\DOTSX", "\\relax");

// Spacing, based on amsmath.sty's override of LaTeX defaults
// \DeclareRobustCommand{\tmspace}[3]{%
//   \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
// \renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\,", "{\\tmspace+{3mu}{.1667em}}");
// \let\thinspace\,
defineMacro("\\thinspace", "\\,");
// \def\>{\mskip\medmuskip}
// \renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
// TODO: \> and math mode of \: should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\>", "\\mskip{4mu}");
defineMacro("\\:", "{\\tmspace+{4mu}{.2222em}}");
// \let\medspace\:
defineMacro("\\medspace", "\\:");
// \renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip = 5mu plus 5mu
defineMacro("\\;", "{\\tmspace+{5mu}{.2777em}}");
// \let\thickspace\;
defineMacro("\\thickspace", "\\;");
// \renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
// TODO: math mode should use \thinmuskip
defineMacro("\\!", "{\\tmspace-{3mu}{.1667em}}");
// \let\negthinspace\!
defineMacro("\\negthinspace", "\\!");
// \newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
// TODO: math mode should use \medmuskip
defineMacro("\\negmedspace", "{\\tmspace-{4mu}{.2222em}}");
// \newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
// TODO: math mode should use \thickmuskip
defineMacro("\\negthickspace", "{\\tmspace-{5mu}{.277em}}");
// \def\enspace{\kern.5em }
defineMacro("\\enspace", "\\kern.5em ");
// \def\enskip{\hskip.5em\relax}
defineMacro("\\enskip", "\\hskip.5em\\relax");
// \def\quad{\hskip1em\relax}
defineMacro("\\quad", "\\hskip1em\\relax");
// \def\qquad{\hskip2em\relax}
defineMacro("\\qquad", "\\hskip2em\\relax");

defineMacro("\\AA", "\\TextOrMath{\\Angstrom}{\\mathring{A}}\\relax");

// \tag@in@display form of \tag
defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
defineMacro("\\tag@literal", (context) => {
  if (context.macros.get("\\df@tag")) {
    throw new ParseError("Multiple \\tag");
  }
  return "\\gdef\\df@tag{\\text{#1}}";
});
defineMacro("\\notag", "\\nonumber");
defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");

// \renewcommand{\bmod}{\nonscript\mskip-\medmuskip\mkern5mu\mathbin
//   {\operator@font mod}\penalty900
//   \mkern5mu\nonscript\mskip-\medmuskip}
// \newcommand{\pod}[1]{\allowbreak
//   \if@display\mkern18mu\else\mkern8mu\fi(#1)}
// \renewcommand{\pmod}[1]{\pod{{\operator@font mod}\mkern6mu#1}}
// \newcommand{\mod}[1]{\allowbreak\if@display\mkern18mu
//   \else\mkern12mu\fi{\operator@font mod}\,\,#1}
// TODO: math mode should use \medmuskip = 4mu plus 2mu minus 4mu
defineMacro("\\bmod", "\\mathbin{\\text{mod}}");
defineMacro(
  "\\pod",
  "\\allowbreak" + "\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)"
);
defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
defineMacro(
  "\\mod",
  "\\allowbreak" +
    "\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}" +
    "{\\rm mod}\\,\\,#1"
);

//////////////////////////////////////////////////////////////////////
// LaTeX source2e

// \expandafter\let\expandafter\@normalcr
//     \csname\expandafter\@gobble\string\\ \endcsname
// \DeclareRobustCommand\newline{\@normalcr\relax}
defineMacro("\\newline", "\\\\\\relax");

// \def\TeX{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@}
// TODO: Doesn't normally work in math mode because \@ fails.
defineMacro("\\TeX", "\\textrm{T}\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125em\\textrm{X}");

defineMacro(
  "\\LaTeX",
    "\\textrm{L}\\kern-.35em\\raisebox{0.2em}{\\scriptstyle A}\\kern-.15em\\TeX"
);

defineMacro(
  "\\Temml",
  // eslint-disable-next-line max-len
  "\\textrm{T}\\kern-0.2em\\lower{0.2em}{\\textrm{E}}\\kern-0.08em{\\textrm{M}\\kern-0.08em\\raise{0.2em}\\textrm{M}\\kern-0.08em\\textrm{L}}"
);

// \DeclareRobustCommand\hspace{\@ifstar\@hspacer\@hspace}
// \def\@hspace#1{\hskip  #1\relax}
// \def\@hspacer#1{\vrule \@width\z@\nobreak
//                 \hskip #1\hskip \z@skip}
defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
defineMacro("\\@hspace", "\\hskip #1\\relax");
defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");

defineMacro("\\colon", `\\mathpunct{\\char"3a}`);

//////////////////////////////////////////////////////////////////////
// mathtools.sty

defineMacro("\\prescript", "\\pres@cript{_{#1}^{#2}}{}{#3}");

//\providecommand\ordinarycolon{:}
defineMacro("\\ordinarycolon", `\\char"3a`);
// Raise to center on the math axis, as closely as possible.
defineMacro("\\vcentcolon", "\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}}");
// \providecommand*\coloneq{\vcentcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\coloneq", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2212}');
// \providecommand*\Coloneq{\dblcolon\mathrel{\mkern-1.2mu}\mathrel{-}}
defineMacro("\\Coloneq", '\\mathrel{\\char"2237\\char"2212}');
// \providecommand*\Eqqcolon{=\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqqcolon", '\\mathrel{\\char"3d\\char"2237}');
// \providecommand*\Eqcolon{\mathrel{-}\mathrel{\mkern-1.2mu}\dblcolon}
defineMacro("\\Eqcolon", '\\mathrel{\\char"2212\\char"2237}');
// \providecommand*\colonapprox{\vcentcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\colonapprox", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"2248}');
// \providecommand*\Colonapprox{\dblcolon\mathrel{\mkern-1.2mu}\approx}
defineMacro("\\Colonapprox", '\\mathrel{\\char"2237\\char"2248}');
// \providecommand*\colonsim{\vcentcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');
// \providecommand*\Colonsim{\dblcolon\mathrel{\mkern-1.2mu}\sim}
defineMacro("\\Colonsim", '\\mathrel{\\raisebox{0.035em}{\\ordinarycolon}\\char"223c}');

//////////////////////////////////////////////////////////////////////
// colonequals.sty

// Alternate names for mathtools's macros:
defineMacro("\\ratio", "\\vcentcolon");
defineMacro("\\coloncolon", "\\dblcolon");
defineMacro("\\colonequals", "\\coloneqq");
defineMacro("\\coloncolonequals", "\\Coloneqq");
defineMacro("\\equalscolon", "\\eqqcolon");
defineMacro("\\equalscoloncolon", "\\Eqqcolon");
defineMacro("\\colonminus", "\\coloneq");
defineMacro("\\coloncolonminus", "\\Coloneq");
defineMacro("\\minuscolon", "\\eqcolon");
defineMacro("\\minuscoloncolon", "\\Eqcolon");
// \colonapprox name is same in mathtools and colonequals.
defineMacro("\\coloncolonapprox", "\\Colonapprox");
// \colonsim name is same in mathtools and colonequals.
defineMacro("\\coloncolonsim", "\\Colonsim");

// Present in newtxmath, pxfonts and txfonts
defineMacro("\\notni", "\\mathrel{\\char`\u220C}");
defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");

//////////////////////////////////////////////////////////////////////
// From amsopn.sty
defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{\\text{lim}}}");
defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{\\text{lim}}}");
defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{\\text{lim}}}");
defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{\\text{lim}}}");

defineMacro("\\centerdot", "{\\medspace\\rule{0.167em}{0.189em}\\medspace}");

//////////////////////////////////////////////////////////////////////
// statmath.sty
// https://ctan.math.illinois.edu/macros/latex/contrib/statmath/statmath.pdf

defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
defineMacro("\\plim", "\\DOTSB\\operatorname*{plim}");

//////////////////////////////////////////////////////////////////////
// MnSymbol.sty

defineMacro("\\leftmodels", "\\mathop{\\reflectbox{$\\models$}}");

//////////////////////////////////////////////////////////////////////
// braket.sty
// http://ctan.math.washington.edu/tex-archive/macros/latex/contrib/braket/braket.pdf

defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
defineMacro("\\Bra", "\\left\\langle#1\\right|");
defineMacro("\\Ket", "\\left|#1\\right\\rangle");
// A helper for \Braket and \Set
const replaceVert = (argStr, match) => {
  const ch = match[0] === "|" ? "\\vert" : "\\Vert";
  const replaceStr = `}\\,\\middle${ch}\\,{`;
  return argStr.slice(0, match.index) + replaceStr + argStr.slice(match.index + match[0].length)
};
defineMacro("\\Braket",  function(context) {
  let argStr = recreateArgStr(context);
  const regEx = /\|\||\||\\\|/g;
  let match;
  while ((match = regEx.exec(argStr)) !== null) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\langle{" + argStr + "}\\right\\rangle"
});
defineMacro("\\Set",  function(context) {
  let argStr = recreateArgStr(context);
  const match = /\|\||\||\\\|/.exec(argStr);
  if (match) {
    argStr = replaceVert(argStr, match);
  }
  return "\\left\\{\\:{" + argStr + "}\\:\\right\\}"
});
defineMacro("\\set",  function(context) {
  const argStr = recreateArgStr(context);
  return "\\{{" + argStr.replace(/\|/, "}\\mid{") + "}\\}"
});

//////////////////////////////////////////////////////////////////////
// actuarialangle.dtx
defineMacro("\\angln", "{\\angl n}");

//////////////////////////////////////////////////////////////////////
// derivative.sty
defineMacro("\\odv", "\\@ifstar\\odv@next\\odv@numerator");
defineMacro("\\odv@numerator", "\\frac{\\mathrm{d}#1}{\\mathrm{d}#2}");
defineMacro("\\odv@next", "\\frac{\\mathrm{d}}{\\mathrm{d}#2}#1");
defineMacro("\\pdv", "\\@ifstar\\pdv@next\\pdv@numerator");

const pdvHelper = args => {
  const numerator = args[0][0].text;
  const denoms = stringFromArg(args[1]).split(",");
  const power = String(denoms.length);
  const numOp = power === "1" ? "\\partial" : `\\partial^${power}`;
  let denominator = "";
  denoms.map(e => { denominator += "\\partial " + e.trim() +  "\\,";});
  return [numerator, numOp,  denominator.replace(/\\,$/, "")]
};
defineMacro("\\pdv@numerator", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp} ${numerator}}{${denominator}}`
});
defineMacro("\\pdv@next", function(context) {
  const [numerator, numOp, denominator] = pdvHelper(context.consumeArgs(2));
  return `\\frac{${numOp}}{${denominator}} ${numerator}`
});

//////////////////////////////////////////////////////////////////////
// upgreek.dtx
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\upbeta", "\\up@greek{\\beta}");
defineMacro("\\upgamma", "\\up@greek{\\gamma}");
defineMacro("\\updelta", "\\up@greek{\\delta}");
defineMacro("\\upepsilon", "\\up@greek{\\epsilon}");
defineMacro("\\upzeta", "\\up@greek{\\zeta}");
defineMacro("\\upeta", "\\up@greek{\\eta}");
defineMacro("\\uptheta", "\\up@greek{\\theta}");
defineMacro("\\upiota", "\\up@greek{\\iota}");
defineMacro("\\upkappa", "\\up@greek{\\kappa}");
defineMacro("\\uplambda", "\\up@greek{\\lambda}");
defineMacro("\\upmu", "\\up@greek{\\mu}");
defineMacro("\\upnu", "\\up@greek{\\nu}");
defineMacro("\\upxi", "\\up@greek{\\xi}");
defineMacro("\\upomicron", "\\up@greek{\\omicron}");
defineMacro("\\uppi", "\\up@greek{\\pi}");
defineMacro("\\upalpha", "\\up@greek{\\alpha}");
defineMacro("\\uprho", "\\up@greek{\\rho}");
defineMacro("\\upsigma", "\\up@greek{\\sigma}");
defineMacro("\\uptau", "\\up@greek{\\tau}");
defineMacro("\\upupsilon", "\\up@greek{\\upsilon}");
defineMacro("\\upphi", "\\up@greek{\\phi}");
defineMacro("\\upchi", "\\up@greek{\\chi}");
defineMacro("\\uppsi", "\\up@greek{\\psi}");
defineMacro("\\upomega", "\\up@greek{\\omega}");

//////////////////////////////////////////////////////////////////////
// cmll package
defineMacro("\\invamp", '\\mathbin{\\char"214b}');
defineMacro("\\parr", '\\mathbin{\\char"214b}');
defineMacro("\\with", '\\mathbin{\\char"26}');
defineMacro("\\multimapinv", '\\mathrel{\\char"27dc}');
defineMacro("\\multimapboth", '\\mathrel{\\char"29df}');
defineMacro("\\scoh", '{\\mkern5mu\\char"2322\\mkern5mu}');
defineMacro("\\sincoh", '{\\mkern5mu\\char"2323\\mkern5mu}');
defineMacro("\\coh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2322}}}
{\\smash{\\lower4mu{\\char"2323}}}\\mkern5mu}`);
defineMacro("\\incoh", `{\\mkern5mu\\rule{}{0.7em}\\mathrlap{\\smash{\\raise2mu{\\char"2323}}}
{\\smash{\\lower4mu{\\char"2322}}}\\mkern5mu}`);


//////////////////////////////////////////////////////////////////////
// chemstyle package
defineMacro("\\standardstate", "\\text{\\tiny\\char`⦵}");

﻿/* eslint-disable */
/* -*- Mode: JavaScript; indent-tabs-mode:nil; js-indent-level: 2 -*- */
/* vim: set ts=2 et sw=2 tw=80: */

/*************************************************************
 *
 *  Temml mhchem.js
 *
 *  This file implements a Temml version of mhchem version 3.3.0.
 *  It is adapted from MathJax/extensions/TeX/mhchem.js
 *  It differs from the MathJax version as follows:
 *    1. The interface is changed so that it can be called from Temml, not MathJax.
 *    2. \rlap and \llap are replaced with \mathrlap and \mathllap.
 *    3. The reaction arrow code is simplified. All reaction arrows are rendered
 *       using Temml extensible arrows instead of building non-extensible arrows.
 *    4. The ~bond forms are composed entirely of \rule elements.
 *    5. Two dashes in _getBond are wrapped in braces to suppress spacing. i.e., {-}
 *    6. The electron dot uses \textbullet instead of \bullet.
 *    7. \smash[T] has been removed. (WebKit hides anything inside \smash{…})
 *
 *    This code, as other Temml code, is released under the MIT license.
 * 
 * /*************************************************************
 *
 *  MathJax/extensions/TeX/mhchem.js
 *
 *  Implements the \ce command for handling chemical formulas
 *  from the mhchem LaTeX package.
 *
 *  ---------------------------------------------------------------------
 *
 *  Copyright (c) 2011-2015 The MathJax Consortium
 *  Copyright (c) 2015-2018 Martin Hensel
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

//
// Coding Style
//   - use '' for identifiers that can by minified/uglified
//   - use "" for strings that need to stay untouched

// version: "3.3.0" for MathJax and Temml


// Add \ce, \pu, and \tripleDash to the Temml macros.

defineMacro("\\ce", function(context) {
  return chemParse(context.consumeArgs(1)[0], "ce")
});

defineMacro("\\pu", function(context) {
  return chemParse(context.consumeArgs(1)[0], "pu");
});

// Math fonts do not include glyphs for the ~ form of bonds. So we'll send path geometry
// So we'll compose characters built from \rule elements.
defineMacro("\\uniDash", `{\\rule{0.672em}{0.06em}}`)
defineMacro("\\triDash", `{\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}\\kern2mu\\rule{0.15em}{0.06em}}`)
defineMacro("\\tripleDash", `\\kern0.075em\\raise0.25em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverLine", `\\kern0.075em\\mathrlap{\\raise0.125em{\\uniDash}}\\raise0.34em{\\triDash}\\kern0.075em`)
defineMacro("\\tripleDashOverDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\triDash}}\\raise0.27em{\\uniDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)
defineMacro("\\tripleDashBetweenDoubleLine", `\\kern0.075em\\mathrlap{\\mathrlap{\\raise0.48em{\\uniDash}}\\raise0.27em{\\triDash}}{\\raise0.05em{\\uniDash}}\\kern0.075em`)

  //
  //  This is the main function for handing the \ce and \pu commands.
  //  It takes the argument to \ce or \pu and returns the corresponding TeX string.
  //

  var chemParse = function (tokens, stateMachine) {
    // Recreate the argument string from Temml's array of tokens.
    var str = "";
    var expectedLoc = tokens.length && tokens[tokens.length - 1].loc.start
    for (var i = tokens.length - 1; i >= 0; i--) {
      if(tokens[i].loc.start > expectedLoc) {
        // context.consumeArgs has eaten a space.
        str += " ";
        expectedLoc = tokens[i].loc.start;
      }
      str += tokens[i].text;
      expectedLoc += tokens[i].text.length;
    }
    // Call the mhchem core parser.
    var tex = texify.go(mhchemParser.go(str, stateMachine));
    return tex;
  };

  //
  // Core parser for mhchem syntax  (recursive)
  //
  /** @type {MhchemParser} */
  var mhchemParser = {
    //
    // Parses mchem \ce syntax
    //
    // Call like
    //   go("H2O");
    //
    go: function (input, stateMachine) {
      if (!input) { return []; }
      if (stateMachine === undefined) { stateMachine = 'ce'; }
      var state = '0';

      //
      // String buffers for parsing:
      //
      // buffer.a == amount
      // buffer.o == element
      // buffer.b == left-side superscript
      // buffer.p == left-side subscript
      // buffer.q == right-side subscript
      // buffer.d == right-side superscript
      //
      // buffer.r == arrow
      // buffer.rdt == arrow, script above, type
      // buffer.rd == arrow, script above, content
      // buffer.rqt == arrow, script below, type
      // buffer.rq == arrow, script below, content
      //
      // buffer.text_
      // buffer.rm
      // etc.
      //
      // buffer.parenthesisLevel == int, starting at 0
      // buffer.sb == bool, space before
      // buffer.beginsWithBond == bool
      //
      // These letters are also used as state names.
      //
      // Other states:
      // 0 == begin of main part (arrow/operator unlikely)
      // 1 == next entity
      // 2 == next entity (arrow/operator unlikely)
      // 3 == next atom
      // c == macro
      //
      /** @type {Buffer} */
      var buffer = {};
      buffer['parenthesisLevel'] = 0;

      input = input.replace(/\n/g, " ");
      input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
      input = input.replace(/[\u2026]/g, "...");

      //
      // Looks through mhchemParser.transitions, to execute a matching action
      // (recursive)
      //
      var lastInput;
      var watchdog = 10;
      /** @type {ParserOutput[]} */
      var output = [];
      while (true) {
        if (lastInput !== input) {
          watchdog = 10;
          lastInput = input;
        } else {
          watchdog--;
        }
        //
        // Find actions in transition table
        //
        var machine = mhchemParser.stateMachines[stateMachine];
        var t = machine.transitions[state] || machine.transitions['*'];
        iterateTransitions:
        for (var i=0; i<t.length; i++) {
          var matches = mhchemParser.patterns.match_(t[i].pattern, input);
          if (matches) {
            //
            // Execute actions
            //
            var task = t[i].task;
            for (var iA=0; iA<task.action_.length; iA++) {
              var o;
              //
              // Find and execute action
              //
              if (machine.actions[task.action_[iA].type_]) {
                o = machine.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else if (mhchemParser.actions[task.action_[iA].type_]) {
                o = mhchemParser.actions[task.action_[iA].type_](buffer, matches.match_, task.action_[iA].option);
              } else {
                throw ["MhchemBugA", "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"];  // Trying to use non-existing action
              }
              //
              // Add output
              //
              mhchemParser.concatArray(output, o);
            }
            //
            // Set next state,
            // Shorten input,
            // Continue with next character
            //   (= apply only one transition per position)
            //
            state = task.nextState || state;
            if (input.length > 0) {
              if (!task.revisit) {
                input = matches.remainder;
              }
              if (!task.toContinue) {
                break iterateTransitions;
              }
            } else {
              return output;
            }
          }
        }
        //
        // Prevent infinite loop
        //
        if (watchdog <= 0) {
          throw ["MhchemBugU", "mhchem bug U. Please report."];  // Unexpected character
        }
      }
    },
    concatArray: function (a, b) {
      if (b) {
        if (Array.isArray(b)) {
          for (var iB=0; iB<b.length; iB++) {
            a.push(b[iB]);
          }
        } else {
          a.push(b);
        }
      }
    },

    patterns: {
      //
      // Matching patterns
      // either regexps or function that return null or {match_:"a", remainder:"bc"}
      //
      patterns: {
        // property names must not look like integers ("2") for correct property traversal order, later on
        'empty': /^$/,
        'else': /^./,
        'else2': /^./,
        'space': /^\s/,
        'space A': /^\s(?=[A-Z\\$])/,
        'space$': /^\s$/,
        'a-z': /^[a-z]/,
        'x': /^x/,
        'x$': /^x$/,
        'i$': /^i$/,
        'letters': /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
        '\\greek': /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
        'one lowercase latin letter $': /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
        '$one lowercase latin letter$ $': /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
        'one lowercase greek letter $': /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
        'digits': /^[0-9]+/,
        '-9.,9': /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
        '-9.,9 no missing 0': /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
        '(-)(9.,9)(e)(99)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '(-)(9)^(-9)': function (input) {
          var m = input.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
          if (m && m[0]) {
            return { match_: m.splice(1), remainder: input.substr(m[0].length) };
          }
          return null;
        },
        'state of aggregation $': function (input) {  // ... or crystal system
          var a = mhchemParser.patterns.findObserveGroups(input, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");  // (aq), (aq,$\infty$), (aq, sat)
          if (a  &&  a.remainder.match(/^($|[\s,;\)\]\}])/)) { return a; }  //  AND end of 'phrase'
          var m = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);  // OR crystal system ($o$) (\ca$c$)
          if (m) {
            return { match_: m[0], remainder: input.substr(m[0].length) };
          }
          return null;
        },
        '_{(state of aggregation)}$': /^_\{(\([a-z]{1,3}\))\}/,
        '{[(': /^(?:\\\{|\[|\()/,
        ')]}': /^(?:\)|\]|\\\})/,
        ', ': /^[,;]\s*/,
        ',': /^[,;]/,
        '.': /^[.]/,
        '. ': /^([.\u22C5\u00B7\u2022])\s*/,
        '...': /^\.\.\.(?=$|[^.])/,
        '* ': /^([*])\s*/,
        '^{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^{", "", "", "}"); },
        '^($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", "$", "$", ""); },
        '^a': /^\^([0-9]+|[^\\_])/,
        '^\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '^\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "^", /^\\[a-zA-Z]+\{/, "}", ""); },
        '^\\x': /^\^(\\[a-zA-Z]+)\s*/,
        '^(-1)': /^\^(-?\d+)/,
        '\'': /^'/,
        '_{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_{", "", "", "}"); },
        '_($...$)': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", "$", "$", ""); },
        '_9': /^_([+\-]?[0-9]+|[^\\])/,
        '_\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '_\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "_", /^\\[a-zA-Z]+\{/, "}", ""); },
        '_\\x': /^_(\\[a-zA-Z]+)\s*/,
        '^_': /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
        '{}': /^\{\}/,
        '{...}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "{", "}", ""); },
        '{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}"); },
        '$...$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", "$", "$", ""); },
        '${(...)}$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "${", "", "", "}$"); },
        '$(...)$': function (input) { return mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$"); },
        '=<>': /^[=<>]/,
        '#': /^[#\u2261]/,
        '+': /^\+/,
        '-$': /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,  // -space -, -; -] -/ -$ -state-of-aggregation
        '-9': /^-(?=[0-9])/,
        '- orbital overlap': /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
        '-': /^-/,
        'pm-operator': /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
        'operator': /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
        'arrowUpDown': /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
        '\\bond{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\bond{", "", "", "}"); },
        '->': /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
        'CMT': /^[CMT](?=\[)/,
        '[(...)]': function (input) { return mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]"); },
        '1st-level escape': /^(&|\\\\|\\hline)\s*/,
        '\\,': /^(?:\\[,\ ;:])/,  // \\x - but output no space before
        '\\x{}{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true); },
        '\\x{}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "", /^\\[a-zA-Z]+\{/, "}", ""); },
        '\\ca': /^\\ca(?:\s+|(?![a-zA-Z]))/,
        '\\x': /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
        'orbital': /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,  // only those with numbers in front, because the others will be formatted correctly anyway
        'others': /^[\/~|]/,
        '\\frac{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\frac{", "", "", "}", "{", "", "", "}"); },
        '\\overset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\overset{", "", "", "}", "{", "", "", "}"); },
        '\\underset{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underset{", "", "", "}", "{", "", "", "}"); },
        '\\underbrace{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\underbrace{", "", "", "}_", "{", "", "", "}"); },
        '\\color{(...)}0': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}"); },
        '\\color{(...)}{(...)}1': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color{", "", "", "}", "{", "", "", "}"); },
        '\\color(...){(...)}2': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}"); },
        '\\ce{(...)}': function (input) { return mhchemParser.patterns.findObserveGroups(input, "\\ce{", "", "", "}"); },
        'oxidation$': /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
        'd-oxidation$': /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,  // 0 could be oxidation or charge
        'roman numeral': /^[IVX]+/,
        '1/2$': /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
        'amount': function (input) {
          var match;
          // e.g. 2, 0.5, 1/2, -2, n/2, +;  $a$ could be added later in parsing
          match = input.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          var a = mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
          if (a) {  // e.g. $2n-1$, $-$
            match = a.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/);
            if (match) {
              return { match_: match[0], remainder: input.substr(match[0].length) };
            }
          }
          return null;
        },
        'amount2': function (input) { return this['amount'](input); },
        '(KV letters),': /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
        'formula$': function (input) {
          if (input.match(/^\([a-z]+\)$/)) { return null; }  // state of aggregation = no formula
          var match = input.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
          if (match) {
            return { match_: match[0], remainder: input.substr(match[0].length) };
          }
          return null;
        },
        'uprightEntities': /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
        '/': /^\s*(\/)\s*/,
        '//': /^\s*(\/\/)\s*/,
        '*': /^\s*[*.]\s*/
      },
      findObserveGroups: function (input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
        /** @type {{(input: string, pattern: string | RegExp): string | string[] | null;}} */
        var _match = function (input, pattern) {
          if (typeof pattern === "string") {
            if (input.indexOf(pattern) !== 0) { return null; }
            return pattern;
          } else {
            var match = input.match(pattern);
            if (!match) { return null; }
            return match[0];
          }
        };
        /** @type {{(input: string, i: number, endChars: string | RegExp): {endMatchBegin: number, endMatchEnd: number} | null;}} */
        var _findObserveGroups = function (input, i, endChars) {
          var braces = 0;
          while (i < input.length) {
            var a = input.charAt(i);
            var match = _match(input.substr(i), endChars);
            if (match !== null  &&  braces === 0) {
              return { endMatchBegin: i, endMatchEnd: i + match.length };
            } else if (a === "{") {
              braces++;
            } else if (a === "}") {
              if (braces === 0) {
                throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
              } else {
                braces--;
              }
            }
            i++;
          }
          if (braces > 0) {
            return null;
          }
          return null;
        };
        var match = _match(input, begExcl);
        if (match === null) { return null; }
        input = input.substr(match.length);
        match = _match(input, begIncl);
        if (match === null) { return null; }
        var e = _findObserveGroups(input, match.length, endIncl || endExcl);
        if (e === null) { return null; }
        var match1 = input.substring(0, (endIncl ? e.endMatchEnd : e.endMatchBegin));
        if (!(beg2Excl || beg2Incl)) {
          return {
            match_: match1,
            remainder: input.substr(e.endMatchEnd)
          };
        } else {
          var group2 = this.findObserveGroups(input.substr(e.endMatchEnd), beg2Excl, beg2Incl, end2Incl, end2Excl);
          if (group2 === null) { return null; }
          /** @type {string[]} */
          var matchRet = [match1, group2.match_];
          return {
            match_: (combine ? matchRet.join("") : matchRet),
            remainder: group2.remainder
          };
        }
      },

      //
      // Matching function
      // e.g. match("a", input) will look for the regexp called "a" and see if it matches
      // returns null or {match_:"a", remainder:"bc"}
      //
      match_: function (m, input) {
        var pattern = mhchemParser.patterns.patterns[m];
        if (pattern === undefined) {
          throw ["MhchemBugP", "mhchem bug P. Please report. (" + m + ")"];  // Trying to use non-existing pattern
        } else if (typeof pattern === "function") {
          return mhchemParser.patterns.patterns[m](input);  // cannot use cached var pattern here, because some pattern functions need this===mhchemParser
        } else {  // RegExp
          var match = input.match(pattern);
          if (match) {
            var mm;
            if (match[2]) {
              mm = [ match[1], match[2] ];
            } else if (match[1]) {
              mm = match[1];
            } else {
              mm = match[0];
            }
            return { match_: mm, remainder: input.substr(match[0].length) };
          }
          return null;
        }
      }
    },

    //
    // Generic state machine actions
    //
    actions: {
      'a=': function (buffer, m) { buffer.a = (buffer.a || "") + m; },
      'b=': function (buffer, m) { buffer.b = (buffer.b || "") + m; },
      'p=': function (buffer, m) { buffer.p = (buffer.p || "") + m; },
      'o=': function (buffer, m) { buffer.o = (buffer.o || "") + m; },
      'q=': function (buffer, m) { buffer.q = (buffer.q || "") + m; },
      'd=': function (buffer, m) { buffer.d = (buffer.d || "") + m; },
      'rm=': function (buffer, m) { buffer.rm = (buffer.rm || "") + m; },
      'text=': function (buffer, m) { buffer.text_ = (buffer.text_ || "") + m; },
      'insert': function (buffer, m, a) { return { type_: a }; },
      'insert+p1': function (buffer, m, a) { return { type_: a, p1: m }; },
      'insert+p1+p2': function (buffer, m, a) { return { type_: a, p1: m[0], p2: m[1] }; },
      'copy': function (buffer, m) { return m; },
      'rm': function (buffer, m) { return { type_: 'rm', p1: m || ""}; },
      'text': function (buffer, m) { return mhchemParser.go(m, 'text'); },
      '{text}': function (buffer, m) {
        var ret = [ "{" ];
        mhchemParser.concatArray(ret, mhchemParser.go(m, 'text'));
        ret.push("}");
        return ret;
      },
      'tex-math': function (buffer, m) { return mhchemParser.go(m, 'tex-math'); },
      'tex-math tight': function (buffer, m) { return mhchemParser.go(m, 'tex-math tight'); },
      'bond': function (buffer, m, k) { return { type_: 'bond', kind_: k || m }; },
      'color0-output': function (buffer, m) { return { type_: 'color0', color: m[0] }; },
      'ce': function (buffer, m) { return mhchemParser.go(m); },
      '1/2': function (buffer, m) {
        /** @type {ParserOutput[]} */
        var ret = [];
        if (m.match(/^[+\-]/)) {
          ret.push(m.substr(0, 1));
          m = m.substr(1);
        }
        var n = m.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
        n[1] = n[1].replace(/\$/g, "");
        ret.push({ type_: 'frac', p1: n[1], p2: n[2] });
        if (n[3]) {
          n[3] = n[3].replace(/\$/g, "");
          ret.push({ type_: 'tex-math', p1: n[3] });
        }
        return ret;
      },
      '9,9': function (buffer, m) { return mhchemParser.go(m, '9,9'); }
    },
    //
    // createTransitions
    // convert  { 'letter': { 'state': { action_: 'output' } } }  to  { 'state' => [ { pattern: 'letter', task: { action_: [{type_: 'output'}] } } ] }
    // with expansion of 'a|b' to 'a' and 'b' (at 2 places)
    //
    createTransitions: function (o) {
      var pattern, state;
      /** @type {string[]} */
      var stateArray;
      var i;
      //
      // 1. Collect all states
      //
      /** @type {Transitions} */
      var transitions = {};
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = state.split("|");
          o[pattern][state].stateArray = stateArray;
          for (i=0; i<stateArray.length; i++) {
            transitions[stateArray[i]] = [];
          }
        }
      }
      //
      // 2. Fill states
      //
      for (pattern in o) {
        for (state in o[pattern]) {
          stateArray = o[pattern][state].stateArray || [];
          for (i=0; i<stateArray.length; i++) {
            //
            // 2a. Normalize actions into array:  'text=' ==> [{type_:'text='}]
            // (Note to myself: Resolving the function here would be problematic. It would need .bind (for *this*) and currying (for *option*).)
            //
            /** @type {any} */
            var p = o[pattern][state];
            if (p.action_) {
              p.action_ = [].concat(p.action_);
              for (var k=0; k<p.action_.length; k++) {
                if (typeof p.action_[k] === "string") {
                  p.action_[k] = { type_: p.action_[k] };
                }
              }
            } else {
              p.action_ = [];
            }
            //
            // 2.b Multi-insert
            //
            var patternArray = pattern.split("|");
            for (var j=0; j<patternArray.length; j++) {
              if (stateArray[i] === '*') {  // insert into all
                for (var t in transitions) {
                  transitions[t].push({ pattern: patternArray[j], task: p });
                }
              } else {
                transitions[stateArray[i]].push({ pattern: patternArray[j], task: p });
              }
            }
          }
        }
      }
      return transitions;
    },
    stateMachines: {}
  };

  //
  // Definition of state machines
  //
  mhchemParser.stateMachines = {
    //
    // \ce state machines
    //
    //#region ce
    'ce': {  // main parser
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'else':  {
          '0|1|2': { action_: 'beginsWithBond=false', revisit: true, toContinue: true } },
        'oxidation$': {
          '0': { action_: 'oxidation-output' } },
        'CMT': {
          'r': { action_: 'rdt=', nextState: 'rt' },
          'rd': { action_: 'rqt=', nextState: 'rdt' } },
        'arrowUpDown': {
          '0|1|2|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '1' } },
        'uprightEntities': {
          '0|1|2': { action_: [ 'o=', 'output' ], nextState: '1' } },
        'orbital': {
          '0|1|2|3': { action_: 'o=', nextState: 'o' } },
        '->': {
          '0|1|2|3': { action_: 'r=', nextState: 'r' },
          'a|as': { action_: [ 'output', 'r=' ], nextState: 'r' },
          '*': { action_: [ 'output', 'r=' ], nextState: 'r' } },
        '+': {
          'o': { action_: 'd= kv',  nextState: 'd' },
          'd|D': { action_: 'd=', nextState: 'd' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd|qD': { action_: 'd=', nextState: 'qd' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' },
          '3': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        'amount': {
          '0|2': { action_: 'a=', nextState: 'a' } },
        'pm-operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', { type_: 'operator', option: '\\pm' } ], nextState: '0' } },
        'operator': {
          '0|1|2|a|as': { action_: [ 'sb=false', 'output', 'operator' ], nextState: '0' } },
        '-$': {
          'o|q': { action_: [ 'charge or bond', 'output' ],  nextState: 'qd' },
          'd': { action_: 'd=', nextState: 'd' },
          'D': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' },
          'q': { action_: 'd=',  nextState: 'qd' },
          'qd': { action_: 'd=', nextState: 'qd' },
          'qD|dq': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        '-9': {
          '3|o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '3' } },
        '- orbital overlap': {
          'o': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'd': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' } },
        '-': {
          '0|1|2': { action_: [ { type_: 'output', option: 1 }, 'beginsWithBond=true', { type_: 'bond', option: "-" } ], nextState: '3' },
          '3': { action_: { type_: 'bond', option: "-" } },
          'a': { action_: [ 'output', { type_: 'insert', option: 'hyphen' } ], nextState: '2' },
          'as': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "-" } ], nextState: '3' },
          'b': { action_: 'b=' },
          'o': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'q': { action_: { type_: '- after o/d', option: false }, nextState: '2' },
          'd|qd|dq': { action_: { type_: '- after o/d', option: true }, nextState: '2' },
          'D|qD|p': { action_: [ 'output', { type_: 'bond', option: "-" } ], nextState: '3' } },
        'amount2': {
          '1|3': { action_: 'a=', nextState: 'a' } },
        'letters': {
          '0|1|2|3|a|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },
          'q|dq': { action_: ['output', 'o='], nextState: 'o' },
          'd|D|qd|qD': { action_: 'o after d', nextState: 'o' } },
        'digits': {
          'o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q': { action_: [ 'output', 'o=' ], nextState: 'o' },
          'a': { action_: 'o=', nextState: 'o' } },
        'space A': {
          'b|p|bp': {} },
        'space': {
          'a': { nextState: 'as' },
          '0': { action_: 'sb=false' },
          '1|2': { action_: 'sb=true' },
          'r|rt|rd|rdt|rdq': { action_: 'output', nextState: '0' },
          '*': { action_: [ 'output', 'sb=true' ], nextState: '1'} },
        '1st-level escape': {
          '1|2': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ] },
          '*': { action_: [ 'output', { type_: 'insert+p1', option: '1st-level escape' } ], nextState: '0' } },
        '[(...)]': {
          'r|rt': { action_: 'rd=', nextState: 'rd' },
          'rd|rdt': { action_: 'rq=', nextState: 'rdq' } },
        '...': {
          'o|d|D|dq|qd|qD': { action_: [ 'output', { type_: 'bond', option: "..." } ], nextState: '3' },
          '*': { action_: [ { type_: 'output', option: 1 }, { type_: 'insert', option: 'ellipsis' } ], nextState: '1' } },
        '. |* ': {
          '*': { action_: [ 'output', { type_: 'insert', option: 'addition compound' } ], nextState: '1' } },
        'state of aggregation $': {
          '*': { action_: [ 'output', 'state of aggregation' ], nextState: '1' } },
        '{[(': {
          'a|as|o': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '0|1|2|3': { action_: [ 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' },
          '*': { action_: [ 'output', 'o=', 'output', 'parenthesisLevel++' ], nextState: '2' } },
        ')]}': {
          '0|1|2|3|b|p|bp|o': { action_: [ 'o=', 'parenthesisLevel--' ], nextState: 'o' },
          'a|as|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=', 'parenthesisLevel--' ], nextState: 'o' } },
        ', ': {
          '*': { action_: [ 'output', 'comma' ], nextState: '0' } },
        '^_': {  // ^ and _ without a sensible argument
          '*': { } },
        '^{(...)}|^($...$)': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'D' },
          'q': { action_: 'd=', nextState: 'qD' },
          'd|D|qd|qD|dq': { action_: [ 'output', 'd=' ], nextState: 'D' } },
        '^a|^\\x{}{}|^\\x{}|^\\x|\'': {
          '0|1|2|as': { action_: 'b=', nextState: 'b' },
          'p': { action_: 'b=', nextState: 'bp' },
          '3|o': { action_: 'd= kv', nextState: 'd' },
          'q': { action_: 'd=', nextState: 'qd' },
          'd|qd|D|qD': { action_: 'd=' },
          'dq': { action_: [ 'output', 'd=' ], nextState: 'd' } },
        '_{(state of aggregation)}$': {
          'd|D|q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x': {
          '0|1|2|as': { action_: 'p=', nextState: 'p' },
          'b': { action_: 'p=', nextState: 'bp' },
          '3|o': { action_: 'q=', nextState: 'q' },
          'd|D': { action_: 'q=', nextState: 'dq' },
          'q|qd|qD|dq': { action_: [ 'output', 'q=' ], nextState: 'q' } },
        '=<>': {
          '0|1|2|3|a|as|o|q|d|D|qd|qD|dq': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: '3' } },
        '#': {
          '0|1|2|3|a|as|o': { action_: [ { type_: 'output', option: 2 }, { type_: 'bond', option: "#" } ], nextState: '3' } },
        '{}': {
          '*': { action_: { type_: 'output', option: 1 },  nextState: '1' } },
        '{...}': {
          '0|1|2|3|a|as|b|p|bp': { action_: 'o=', nextState: 'o' },
          'o|d|D|q|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '$...$': {
          'a': { action_: 'a=' },  // 2$n$
          '0|1|2|3|as|b|p|bp|o': { action_: 'o=', nextState: 'o' },  // not 'amount'
          'as|o': { action_: 'o=' },
          'q|d|D|qd|qD|dq': { action_: [ 'output', 'o=' ], nextState: 'o' } },
        '\\bond{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'bond' ], nextState: "3" } },
        '\\frac{(...)}': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'frac-output' ], nextState: '3' } },
        '\\overset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'overset-output' ], nextState: '3' } },
        '\\underset{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underset-output' ], nextState: '3' } },
        '\\underbrace{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'underbrace-output' ], nextState: '3' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color-output' ], nextState: '3' } },
        '\\color{(...)}0': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'color0-output' ] } },
        '\\ce{(...)}': {
          '*': { action_: [ { type_: 'output', option: 2 }, 'ce' ], nextState: '3' } },
        '\\,': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '1' } },
        '\\x{}{}|\\x{}|\\x': {
          '0|1|2|3|a|as|b|p|bp|o|c0': { action_: [ 'o=', 'output' ], nextState: '3' },
          '*': { action_: ['output', 'o=', 'output' ], nextState: '3' } },
        'others': {
          '*': { action_: [ { type_: 'output', option: 1 }, 'copy' ], nextState: '3' } },
        'else2': {
          'a': { action_: 'a to o', nextState: 'o', revisit: true },
          'as': { action_: [ 'output', 'sb=true' ], nextState: '1', revisit: true },
          'r|rt|rd|rdt|rdq': { action_: [ 'output' ], nextState: '0', revisit: true },
          '*': { action_: [ 'output', 'copy' ], nextState: '3' } }
      }),
      actions: {
        'o after d': function (buffer, m) {
          var ret;
          if ((buffer.d || "").match(/^[0-9]+$/)) {
            var tmp = buffer.d;
            buffer.d = undefined;
            ret = this['output'](buffer);
            buffer.b = tmp;
          } else {
            ret = this['output'](buffer);
          }
          mhchemParser.actions['o='](buffer, m);
          return ret;
        },
        'd= kv': function (buffer, m) {
          buffer.d = m;
          buffer.dType = 'kv';
        },
        'charge or bond': function (buffer, m) {
          if (buffer['beginsWithBond']) {
            /** @type {ParserOutput[]} */
            var ret = [];
            mhchemParser.concatArray(ret, this['output'](buffer));
            mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            return ret;
          } else {
            buffer.d = m;
          }
        },
        '- after o/d': function (buffer, m, isAfterD) {
          var c1 = mhchemParser.patterns.match_('orbital', buffer.o || "");
          var c2 = mhchemParser.patterns.match_('one lowercase greek letter $', buffer.o || "");
          var c3 = mhchemParser.patterns.match_('one lowercase latin letter $', buffer.o || "");
          var c4 = mhchemParser.patterns.match_('$one lowercase latin letter$ $', buffer.o || "");
          var hyphenFollows =  m==="-" && ( c1 && c1.remainder===""  ||  c2  ||  c3  ||  c4 );
          if (hyphenFollows && !buffer.a && !buffer.b && !buffer.p && !buffer.d && !buffer.q && !c1 && c3) {
            buffer.o = '$' + buffer.o + '$';
          }
          /** @type {ParserOutput[]} */
          var ret = [];
          if (hyphenFollows) {
            mhchemParser.concatArray(ret, this['output'](buffer));
            ret.push({ type_: 'hyphen' });
          } else {
            c1 = mhchemParser.patterns.match_('digits', buffer.d || "");
            if (isAfterD && c1 && c1.remainder==='') {
              mhchemParser.concatArray(ret, mhchemParser.actions['d='](buffer, m));
              mhchemParser.concatArray(ret, this['output'](buffer));
            } else {
              mhchemParser.concatArray(ret, this['output'](buffer));
              mhchemParser.concatArray(ret, mhchemParser.actions['bond'](buffer, m, "-"));
            }
          }
          return ret;
        },
        'a to o': function (buffer) {
          buffer.o = buffer.a;
          buffer.a = undefined;
        },
        'sb=true': function (buffer) { buffer.sb = true; },
        'sb=false': function (buffer) { buffer.sb = false; },
        'beginsWithBond=true': function (buffer) { buffer['beginsWithBond'] = true; },
        'beginsWithBond=false': function (buffer) { buffer['beginsWithBond'] = false; },
        'parenthesisLevel++': function (buffer) { buffer['parenthesisLevel']++; },
        'parenthesisLevel--': function (buffer) { buffer['parenthesisLevel']--; },
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation', p1: mhchemParser.go(m, 'o') };
        },
        'comma': function (buffer, m) {
          var a = m.replace(/\s*$/, '');
          var withSpace = (a !== m);
          if (withSpace  &&  buffer['parenthesisLevel'] === 0) {
            return { type_: 'comma enumeration L', p1: a };
          } else {
            return { type_: 'comma enumeration M', p1: a };
          }
        },
        'output': function (buffer, m, entityFollows) {
          // entityFollows:
          //   undefined = if we have nothing else to output, also ignore the just read space (buffer.sb)
          //   1 = an entity follows, never omit the space if there was one just read before (can only apply to state 1)
          //   2 = 1 + the entity can have an amount, so output a\, instead of converting it to o (can only apply to states a|as)
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          if (!buffer.r) {
            ret = [];
            if (!buffer.a && !buffer.b && !buffer.p && !buffer.o && !buffer.q && !buffer.d && !entityFollows) {
              //ret = [];
            } else {
              if (buffer.sb) {
                ret.push({ type_: 'entitySkip' });
              }
              if (!buffer.o && !buffer.q && !buffer.d && !buffer.b && !buffer.p && entityFollows!==2) {
                buffer.o = buffer.a;
                buffer.a = undefined;
              } else if (!buffer.o && !buffer.q && !buffer.d && (buffer.b || buffer.p)) {
                buffer.o = buffer.a;
                buffer.d = buffer.b;
                buffer.q = buffer.p;
                buffer.a = buffer.b = buffer.p = undefined;
              } else {
                if (buffer.o && buffer.dType==='kv' && mhchemParser.patterns.match_('d-oxidation$', buffer.d || "")) {
                  buffer.dType = 'oxidation';
                } else if (buffer.o && buffer.dType==='kv' && !buffer.q) {
                  buffer.dType = undefined;
                }
              }
              ret.push({
                type_: 'chemfive',
                a: mhchemParser.go(buffer.a, 'a'),
                b: mhchemParser.go(buffer.b, 'bd'),
                p: mhchemParser.go(buffer.p, 'pq'),
                o: mhchemParser.go(buffer.o, 'o'),
                q: mhchemParser.go(buffer.q, 'pq'),
                d: mhchemParser.go(buffer.d, (buffer.dType === 'oxidation' ? 'oxidation' : 'bd')),
                dType: buffer.dType
              });
            }
          } else {  // r
            /** @type {ParserOutput[]} */
            var rd;
            if (buffer.rdt === 'M') {
              rd = mhchemParser.go(buffer.rd, 'tex-math');
            } else if (buffer.rdt === 'T') {
              rd = [ { type_: 'text', p1: buffer.rd || "" } ];
            } else {
              rd = mhchemParser.go(buffer.rd);
            }
            /** @type {ParserOutput[]} */
            var rq;
            if (buffer.rqt === 'M') {
              rq = mhchemParser.go(buffer.rq, 'tex-math');
            } else if (buffer.rqt === 'T') {
              rq = [ { type_: 'text', p1: buffer.rq || ""} ];
            } else {
              rq = mhchemParser.go(buffer.rq);
            }
            ret = {
              type_: 'arrow',
              r: buffer.r,
              rd: rd,
              rq: rq
            };
          }
          for (var p in buffer) {
            if (p !== 'parenthesisLevel'  &&  p !== 'beginsWithBond') {
              delete buffer[p];
            }
          }
          return ret;
        },
        'oxidation-output': function (buffer, m) {
          var ret = [ "{" ];
          mhchemParser.concatArray(ret, mhchemParser.go(m, 'oxidation'));
          ret.push("}");
          return ret;
        },
        'frac-output': function (buffer, m) {
          return { type_: 'frac-ce', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'overset-output': function (buffer, m) {
          return { type_: 'overset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underset-output': function (buffer, m) {
          return { type_: 'underset', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'underbrace-output': function (buffer, m) {
          return { type_: 'underbrace', p1: mhchemParser.go(m[0]), p2: mhchemParser.go(m[1]) };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1]) };
        },
        'r=': function (buffer, m) { buffer.r = m; },
        'rdt=': function (buffer, m) { buffer.rdt = m; },
        'rd=': function (buffer, m) { buffer.rd = m; },
        'rqt=': function (buffer, m) { buffer.rqt = m; },
        'rq=': function (buffer, m) { buffer.rq = m; },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; }
      }
    },
    'a': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        '$(...)$': {
          '*': { action_: 'tex-math tight', nextState: '1' } },
        ',': {
          '*': { action_: { type_: 'insert', option: 'commaDecimal' } } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'o': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '1', revisit: true } },
        'letters': {
          '*': { action_: 'rm' } },
        '\\ca': {
          '*': { action_: { type_: 'insert', option: 'circa' } } },
        '\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: '{text}' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {}
    },
    'text': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '{...}': {
          '*': { action_: 'text=' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '\\greek': {
          '*': { action_: [ 'output', 'rm' ] } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: [ 'output', 'copy' ] } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.text_) {
            /** @type {ParserOutput} */
            var ret = { type_: 'text', p1: buffer.text_ };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'pq': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'state of aggregation $': {
          '*': { action_: 'state of aggregation' } },
        'i$': {
          '0': { nextState: '!f', revisit: true } },
        '(KV letters),': {
          '0': { action_: 'rm', nextState: '0' } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        '1/2$': {
          '0': { action_: '1/2' } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'letters': {
          '*': { action_: 'rm' } },
        '-9.,9': {
          '*': { action_: '9,9'  } },
        ',': {
          '*': { action_: { type_: 'insert+p1', option: 'comma enumeration S' } } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'state of aggregation': function (buffer, m) {
          return { type_: 'state of aggregation subscript', p1: mhchemParser.go(m, 'o') };
        },
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'pq') };
        }
      }
    },
    'bd': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'x$': {
          '0': { nextState: '!f', revisit: true } },
        'formula$': {
          '0': { nextState: 'f', revisit: true } },
        'else': {
          '0': { nextState: '!f', revisit: true } },
        '-9.,9 no missing 0': {
          '*': { action_: '9,9' } },
        '.': {
          '*': { action_: { type_: 'insert', option: 'electron dot' } } },
        'a-z': {
          'f': { action_: 'tex-math' } },
        'x': {
          '*': { action_: { type_: 'insert', option: 'KV x' } } },
        'letters': {
          '*': { action_: 'rm' } },
        '\'': {
          '*': { action_: { type_: 'insert', option: 'prime' } } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        '{(...)}': {
          '*': { action_: 'text' } },
        '\\color{(...)}{(...)}1|\\color(...){(...)}2': {
          '*': { action_: 'color-output' } },
        '\\color{(...)}0': {
          '*': { action_: 'color0-output' } },
        '\\ce{(...)}': {
          '*': { action_: 'ce' } },
        '\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'copy' } },
        'else2': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'color-output': function (buffer, m) {
          return { type_: 'color', color1: m[0], color2: mhchemParser.go(m[1], 'bd') };
        }
      }
    },
    'oxidation': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        'roman numeral': {
          '*': { action_: 'roman-numeral' } },
        '${(...)}$|$(...)$': {
          '*': { action_: 'tex-math' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'roman-numeral': function (buffer, m) { return { type_: 'roman numeral', p1: m || "" }; }
      }
    },
    'tex-math': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    'tex-math tight': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '\\ce{(...)}': {
          '*': { action_: [ 'output', 'ce' ] } },
        '{...}|\\,|\\x{}{}|\\x{}|\\x': {
          '*': { action_: 'o=' } },
        '-|+': {
          '*': { action_: 'tight operator' } },
        'else': {
          '*': { action_: 'o=' } }
      }),
      actions: {
        'tight operator': function (buffer, m) { buffer.o = (buffer.o || "") + "{"+m+"}"; },
        'output': function (buffer) {
          if (buffer.o) {
            /** @type {ParserOutput} */
            var ret = { type_: 'tex-math', p1: buffer.o };
            for (var p in buffer) { delete buffer[p]; }
            return ret;
          }
        }
      }
    },
    '9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': {} },
        ',': {
          '*': { action_: 'comma' } },
        'else': {
          '*': { action_: 'copy' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; }
      }
    },
    //#endregion
    //
    // \pu state machines
    //
    //#region pu
    'pu': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        'space$': {
          '*': { action_: [ 'output', 'space' ] } },
        '{[(|)]}': {
          '0|a': { action_: 'copy' } },
        '(-)(9)^(-9)': {
          '0': { action_: 'number^', nextState: 'a' } },
        '(-)(9.,9)(e)(99)': {
          '0': { action_: 'enumber', nextState: 'a' } },
        'space': {
          '0|a': {} },
        'pm-operator': {
          '0|a': { action_: { type_: 'operator', option: '\\pm' }, nextState: '0' } },
        'operator': {
          '0|a': { action_: 'copy', nextState: '0' } },
        '//': {
          'd': { action_: 'o=', nextState: '/' } },
        '/': {
          'd': { action_: 'o=', nextState: '/' } },
        '{...}|else': {
          '0|d': { action_: 'd=', nextState: 'd' },
          'a': { action_: [ 'space', 'd=' ], nextState: 'd' },
          '/|q': { action_: 'q=', nextState: 'q' } }
      }),
      actions: {
        'enumber': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          if (m[1]) {
            mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
            if (m[2]) {
              if (m[2].match(/[,.]/)) {
                mhchemParser.concatArray(ret, mhchemParser.go(m[2], 'pu-9,9'));
              } else {
                ret.push(m[2]);
              }
            }
            m[3] = m[4] || m[3];
            if (m[3]) {
              m[3] = m[3].trim();
              if (m[3] === "e"  ||  m[3].substr(0, 1) === "*") {
                ret.push({ type_: 'cdot' });
              } else {
                ret.push({ type_: 'times' });
              }
            }
          }
          if (m[3]) {
            ret.push("10^{"+m[5]+"}");
          }
          return ret;
        },
        'number^': function (buffer, m) {
          /** @type {ParserOutput[]} */
          var ret = [];
          if (m[0] === "+-"  ||  m[0] === "+/-") {
            ret.push("\\pm ");
          } else if (m[0]) {
            ret.push(m[0]);
          }
          mhchemParser.concatArray(ret, mhchemParser.go(m[1], 'pu-9,9'));
          ret.push("^{"+m[2]+"}");
          return ret;
        },
        'operator': function (buffer, m, p1) { return { type_: 'operator', kind_: (p1 || m) }; },
        'space': function () { return { type_: 'pu-space-1' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret;
          var md = mhchemParser.patterns.match_('{(...)}', buffer.d || "");
          if (md  &&  md.remainder === '') { buffer.d = md.match_; }
          var mq = mhchemParser.patterns.match_('{(...)}', buffer.q || "");
          if (mq  &&  mq.remainder === '') { buffer.q = mq.match_; }
          if (buffer.d) {
            buffer.d = buffer.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.d = buffer.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
          }
          if (buffer.q) {  // fraction
            buffer.q = buffer.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
            buffer.q = buffer.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
            var b5 = {
              d: mhchemParser.go(buffer.d, 'pu'),
              q: mhchemParser.go(buffer.q, 'pu')
            };
            if (buffer.o === '//') {
              ret = { type_: 'pu-frac', p1: b5.d, p2: b5.q };
            } else {
              ret = b5.d;
              if (b5.d.length > 1  ||  b5.q.length > 1) {
                ret.push({ type_: ' / ' });
              } else {
                ret.push({ type_: '/' });
              }
              mhchemParser.concatArray(ret, b5.q);
            }
          } else {  // no fraction
            ret = mhchemParser.go(buffer.d, 'pu-2');
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-2': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '*': { action_: 'output' } },
        '*': {
          '*': { action_: [ 'output', 'cdot' ], nextState: '0' } },
        '\\x': {
          '*': { action_: 'rm=' } },
        'space': {
          '*': { action_: [ 'output', 'space' ], nextState: '0' } },
        '^{(...)}|^(-1)': {
          '1': { action_: '^(-1)' } },
        '-9.,9': {
          '0': { action_: 'rm=', nextState: '0' },
          '1': { action_: '^(-1)', nextState: '0' } },
        '{...}|else': {
          '*': { action_: 'rm=', nextState: '1' } }
      }),
      actions: {
        'cdot': function () { return { type_: 'tight cdot' }; },
        '^(-1)': function (buffer, m) { buffer.rm += "^{"+m+"}"; },
        'space': function () { return { type_: 'pu-space-2' }; },
        'output': function (buffer) {
          /** @type {ParserOutput | ParserOutput[]} */
          var ret = [];
          if (buffer.rm) {
            var mrm = mhchemParser.patterns.match_('{(...)}', buffer.rm || "");
            if (mrm  &&  mrm.remainder === '') {
              ret = mhchemParser.go(mrm.match_, 'pu');
            } else {
              ret = { type_: 'rm', p1: buffer.rm };
            }
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    },
    'pu-9,9': {
      transitions: mhchemParser.createTransitions({
        'empty': {
          '0': { action_: 'output-0' },
          'o': { action_: 'output-o' } },
        ',': {
          '0': { action_: [ 'output-0', 'comma' ], nextState: 'o' } },
        '.': {
          '0': { action_: [ 'output-0', 'copy' ], nextState: 'o' } },
        'else': {
          '*': { action_: 'text=' } }
      }),
      actions: {
        'comma': function () { return { type_: 'commaDecimal' }; },
        'output-0': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length % 3;
            if (a === 0) { a = 3; }
            for (var i=buffer.text_.length-3; i>0; i-=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(0, a));
            ret.reverse();
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        },
        'output-o': function (buffer) {
          /** @type {ParserOutput[]} */
          var ret = [];
          buffer.text_ = buffer.text_ || "";
          if (buffer.text_.length > 4) {
            var a = buffer.text_.length - 3;
            for (var i=0; i<a; i+=3) {
              ret.push(buffer.text_.substr(i, 3));
              ret.push({ type_: '1000 separator' });
            }
            ret.push(buffer.text_.substr(i));
          } else {
            ret.push(buffer.text_);
          }
          for (var p in buffer) { delete buffer[p]; }
          return ret;
        }
      }
    }
    //#endregion
  };

  //
  // texify: Take MhchemParser output and convert it to TeX
  //
  /** @type {Texify} */
  var texify = {
    go: function (input, isInner) {  // (recursive, max 4 levels)
      if (!input) { return ""; }
      var res = "";
      var cee = false;
      for (var i=0; i < input.length; i++) {
        var inputi = input[i];
        if (typeof inputi === "string") {
          res += inputi;
        } else {
          res += texify._go2(inputi);
          if (inputi.type_ === '1st-level escape') { cee = true; }
        }
      }
      if (!isInner && !cee && res) {
        res = "{" + res + "}";
      }
      return res;
    },
    _goInner: function (input) {
      if (!input) { return input; }
      return texify.go(input, true);
    },
    _go2: function (buf) {
      /** @type {undefined | string} */
      var res;
      switch (buf.type_) {
        case 'chemfive':
          res = "";
          var b5 = {
            a: texify._goInner(buf.a),
            b: texify._goInner(buf.b),
            p: texify._goInner(buf.p),
            o: texify._goInner(buf.o),
            q: texify._goInner(buf.q),
            d: texify._goInner(buf.d)
          };
          //
          // a
          //
          if (b5.a) {
            if (b5.a.match(/^[+\-]/)) { b5.a = "{"+b5.a+"}"; }
            res += b5.a + "\\,";
          }
          //
          // b and p
          //
          if (b5.b || b5.p) {
            res += "{\\vphantom{X}}";
            res += "^{\\hphantom{"+(b5.b||"")+"}}_{\\hphantom{"+(b5.p||"")+"}}";
            res += "{\\vphantom{X}}";
            // In the next two lines, I've removed \smash[t] (ron)
            // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
            //res += "^{\\smash[t]{\\vphantom{2}}\\mathllap{"+(b5.b||"")+"}}";
            res += "^{\\vphantom{2}\\mathllap{"+(b5.b||"")+"}}";
            //res += "_{\\vphantom{2}\\mathllap{\\smash[t]{"+(b5.p||"")+"}}}";
            res += "_{\\vphantom{2}\\mathllap{"+(b5.p||"")+"}}";
          }
          //
          // o
          //
          if (b5.o) {
            if (b5.o.match(/^[+\-]/)) { b5.o = "{"+b5.o+"}"; }
            res += b5.o;
          }
          //
          // q and d
          //
          if (buf.dType === 'kv') {
            if (b5.d || b5.q) {
              res += "{\\vphantom{X}}";
            }
            if (b5.d) {
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else if (buf.dType === 'oxidation') {
            if (b5.d) {
              res += "{\\vphantom{X}}";
              res += "^{"+b5.d+"}";
            }
            if (b5.q) {
              // A Firefox bug adds a bogus depth to <mphantom>, so we change \vphantom{X} to {}
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
          } else {
            if (b5.q) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              // In the next line, I've removed \smash[t] (ron)
              // TODO: Revert \smash[t] when WebKit properly renders <mpadded> w/height="0"
              //res += "_{\\smash[t]{"+b5.q+"}}";
              res += "_{"+b5.q+"}";
            }
            if (b5.d) {
              // TODO: Reinstate \vphantom{X} when the Firefox bug is fixed.
//              res += "{\\vphantom{X}}";
              res += "{{}}";
              res += "^{"+b5.d+"}";
            }
          }
          break;
        case 'rm':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'text':
          if (buf.p1.match(/[\^_]/)) {
            buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
            res = "\\mathrm{"+buf.p1+"}";
          } else {
            res = "\\text{"+buf.p1+"}";
          }
          break;
        case 'roman numeral':
          res = "\\mathrm{"+buf.p1+"}";
          break;
        case 'state of aggregation':
          res = "\\mskip2mu "+texify._goInner(buf.p1);
          break;
        case 'state of aggregation subscript':
          res = "\\mskip1mu "+texify._goInner(buf.p1);
          break;
        case 'bond':
          res = texify._getBond(buf.kind_);
          if (!res) {
            throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + buf.kind_ + ")"];
          }
          break;
        case 'frac':
          var c = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
          res = "\\mathchoice{\\textstyle"+c+"}{"+c+"}{"+c+"}{"+c+"}";
          break;
        case 'pu-frac':
          var d = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          res = "\\mathchoice{\\textstyle"+d+"}{"+d+"}{"+d+"}{"+d+"}";
          break;
        case 'tex-math':
          res = buf.p1 + " ";
          break;
        case 'frac-ce':
          res = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'overset':
          res = "\\overset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underset':
          res = "\\underset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
          break;
        case 'underbrace':
          res =  "\\underbrace{" + texify._goInner(buf.p1) + "}_{" + texify._goInner(buf.p2) + "}";
          break;
        case 'color':
          res = "{\\color{" + buf.color1 + "}{" + texify._goInner(buf.color2) + "}}";
          break;
        case 'color0':
          res = "\\color{" + buf.color + "}";
          break;
        case 'arrow':
          var b6 = {
            rd: texify._goInner(buf.rd),
            rq: texify._goInner(buf.rq)
          };
          var arrow = texify._getArrow(buf.r);
          if (b6.rq) { arrow += "[{\\rm " + b6.rq + "}]"; }
          if (b6.rd) {
            arrow += "{\\rm " + b6.rd + "}";
          } else {
            arrow += "{}";
          }
          res = arrow;
          break;
        case 'operator':
          res = texify._getOperator(buf.kind_);
          break;
        case '1st-level escape':
          res = buf.p1+" ";  // &, \\\\, \\hlin
          break;
        case 'space':
          res = " ";
          break;
        case 'entitySkip':
          res = "~";
          break;
        case 'pu-space-1':
          res = "~";
          break;
        case 'pu-space-2':
          res = "\\mkern3mu ";
          break;
        case '1000 separator':
          res = "\\mkern2mu ";
          break;
        case 'commaDecimal':
          res = "{,}";
          break;
          case 'comma enumeration L':
          res = "{"+buf.p1+"}\\mkern6mu ";
          break;
        case 'comma enumeration M':
          res = "{"+buf.p1+"}\\mkern3mu ";
          break;
        case 'comma enumeration S':
          res = "{"+buf.p1+"}\\mkern1mu ";
          break;
        case 'hyphen':
          res = "\\text{-}";
          break;
        case 'addition compound':
          res = "\\,{\\cdot}\\,";
          break;
        case 'electron dot':
          res = "\\mkern1mu \\text{\\textbullet}\\mkern1mu ";
          break;
        case 'KV x':
          res = "{\\times}";
          break;
        case 'prime':
          res = "\\prime ";
          break;
        case 'cdot':
          res = "\\cdot ";
          break;
        case 'tight cdot':
          res = "\\mkern1mu{\\cdot}\\mkern1mu ";
          break;
        case 'times':
          res = "\\times ";
          break;
        case 'circa':
          res = "{\\sim}";
          break;
        case '^':
          res = "uparrow";
          break;
        case 'v':
          res = "downarrow";
          break;
        case 'ellipsis':
          res = "\\ldots ";
          break;
        case '/':
          res = "/";
          break;
        case ' / ':
          res = "\\,/\\,";
          break;
        default:
          assertNever(buf);
          throw ["MhchemBugT", "mhchem bug T. Please report."];  // Missing texify rule or unknown MhchemParser output
      }
      assertString(res);
      return res;
    },
    _getArrow: function (a) {
      switch (a) {
        case "->": return "\\yields";
        case "\u2192": return "\\yields";
        case "\u27F6": return "\\yields";
        case "<-": return "\\yieldsLeft";
        case "<->": return "\\mesomerism";
        case "<-->": return "\\yieldsLeftRight";
        case "<=>": return "\\equilibrium";
        case "\u21CC": return "\\equilibrium";
        case "<=>>": return "\\equilibriumRight";
        case "<<=>": return "\\equilibriumLeft";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getBond: function (a) {
      switch (a) {
        case "-": return "{-}";
        case "1": return "{-}";
        case "=": return "{=}";
        case "2": return "{=}";
        case "#": return "{\\equiv}";
        case "3": return "{\\equiv}";
        case "~": return "{\\tripleDash}";
        case "~-": return "{\\tripleDashOverLine}";
        case "~=": return "{\\tripleDashOverDoubleLine}";
        case "~--": return "{\\tripleDashOverDoubleLine}";
        case "-~-": return "{\\tripleDashBetweenDoubleLine}";
        case "...": return "{{\\cdot}{\\cdot}{\\cdot}}";
        case "....": return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
        case "->": return "{\\rightarrow}";
        case "<-": return "{\\leftarrow}";
        case "<": return "{<}";
        case ">": return "{>}";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    },
    _getOperator: function (a) {
      switch (a) {
        case "+": return " {}+{} ";
        case "-": return " {}-{} ";
        case "=": return " {}={} ";
        case "<": return " {}<{} ";
        case ">": return " {}>{} ";
        case "<<": return " {}\\ll{} ";
        case ">>": return " {}\\gg{} ";
        case "\\pm": return " {}\\pm{} ";
        case "\\approx": return " {}\\approx{} ";
        case "$\\approx$": return " {}\\approx{} ";
        case "v": return " \\downarrow{} ";
        case "(v)": return " \\downarrow{} ";
        case "^": return " \\uparrow{} ";
        case "(^)": return " \\uparrow{} ";
        default:
          assertNever(a);
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    }
  };

  //
  // Helpers for code analysis
  // Will show type error at calling position
  //
  /** @param {number} a */
  function assertNever(a) {}
  /** @param {string} a */
  function assertString(a) {}

/* eslint-disable no-undef */

//////////////////////////////////////////////////////////////////////
// texvc.sty

// The texvc package contains macros available in mediawiki pages.
// We omit the functions deprecated at
// https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax

// We also omit texvc's \O, which conflicts with \text{\O}

defineMacro("\\darr", "\\downarrow");
defineMacro("\\dArr", "\\Downarrow");
defineMacro("\\Darr", "\\Downarrow");
defineMacro("\\lang", "\\langle");
defineMacro("\\rang", "\\rangle");
defineMacro("\\uarr", "\\uparrow");
defineMacro("\\uArr", "\\Uparrow");
defineMacro("\\Uarr", "\\Uparrow");
defineMacro("\\N", "\\mathbb{N}");
defineMacro("\\R", "\\mathbb{R}");
defineMacro("\\Z", "\\mathbb{Z}");
defineMacro("\\alef", "\\aleph");
defineMacro("\\alefsym", "\\aleph");
defineMacro("\\bull", "\\bullet");
defineMacro("\\clubs", "\\clubsuit");
defineMacro("\\cnums", "\\mathbb{C}");
defineMacro("\\Complex", "\\mathbb{C}");
defineMacro("\\Dagger", "\\ddagger");
defineMacro("\\diamonds", "\\diamondsuit");
defineMacro("\\empty", "\\emptyset");
defineMacro("\\exist", "\\exists");
defineMacro("\\harr", "\\leftrightarrow");
defineMacro("\\hArr", "\\Leftrightarrow");
defineMacro("\\Harr", "\\Leftrightarrow");
defineMacro("\\hearts", "\\heartsuit");
defineMacro("\\image", "\\Im");
defineMacro("\\infin", "\\infty");
defineMacro("\\isin", "\\in");
defineMacro("\\larr", "\\leftarrow");
defineMacro("\\lArr", "\\Leftarrow");
defineMacro("\\Larr", "\\Leftarrow");
defineMacro("\\lrarr", "\\leftrightarrow");
defineMacro("\\lrArr", "\\Leftrightarrow");
defineMacro("\\Lrarr", "\\Leftrightarrow");
defineMacro("\\natnums", "\\mathbb{N}");
defineMacro("\\plusmn", "\\pm");
defineMacro("\\rarr", "\\rightarrow");
defineMacro("\\rArr", "\\Rightarrow");
defineMacro("\\Rarr", "\\Rightarrow");
defineMacro("\\real", "\\Re");
defineMacro("\\reals", "\\mathbb{R}");
defineMacro("\\Reals", "\\mathbb{R}");
defineMacro("\\sdot", "\\cdot");
defineMacro("\\sect", "\\S");
defineMacro("\\spades", "\\spadesuit");
defineMacro("\\sub", "\\subset");
defineMacro("\\sube", "\\subseteq");
defineMacro("\\supe", "\\supseteq");
defineMacro("\\thetasym", "\\vartheta");
defineMacro("\\weierp", "\\wp");

/* eslint-disable no-undef */

/****************************************************
 *
 *  physics.js
 *
 *  Implements the Physics Package for LaTeX input.
 *
 *  ---------------------------------------------------------------------
 *
 *  The original version of this file is licensed as follows:
 *  Copyright (c) 2015-2016 Kolen Cheung <https://github.com/ickc/MathJax-third-party-extensions>.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *  ---------------------------------------------------------------------
 *
 *  This file has been revised from the original in the following ways:
 *  1. The interface is changed so that it can be called from Temml, not MathJax.
 *  2. \Re and \Im are not used, to avoid conflict with existing LaTeX letters.
 *
 *  This revision of the file is released under the MIT license.
 *  https://mit-license.org/
 */
defineMacro("\\quantity", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\qty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\pqty", "{\\left( #1 \\right)}");
defineMacro("\\bqty", "{\\left[ #1 \\right]}");
defineMacro("\\vqty", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\Bqty", "{\\left\\{ #1 \\right\\}}");
defineMacro("\\absolutevalue", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\abs", "{\\left\\vert #1 \\right\\vert}");
defineMacro("\\norm", "{\\left\\Vert #1 \\right\\Vert}");
defineMacro("\\evaluated", "{\\left.#1 \\right\\vert}");
defineMacro("\\eval", "{\\left.#1 \\right\\vert}");
defineMacro("\\order", "{\\mathcal{O} \\left( #1 \\right)}");
defineMacro("\\commutator", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\comm", "{\\left[ #1 , #2 \\right]}");
defineMacro("\\anticommutator", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\acomm", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\poissonbracket", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\pb", "{\\left\\{ #1 , #2 \\right\\}}");
defineMacro("\\vectorbold", "{\\boldsymbol{ #1 }}");
defineMacro("\\vb", "{\\boldsymbol{ #1 }}");
defineMacro("\\vectorarrow", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\va", "{\\vec{\\boldsymbol{ #1 }}}");
defineMacro("\\vectorunit", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\vu", "{{\\boldsymbol{\\hat{ #1 }}}}");
defineMacro("\\dotproduct", "\\mathbin{\\boldsymbol\\cdot}");
defineMacro("\\vdot", "{\\boldsymbol\\cdot}");
defineMacro("\\crossproduct", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cross", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\cp", "\\mathbin{\\boldsymbol\\times}");
defineMacro("\\gradient", "{\\boldsymbol\\nabla}");
defineMacro("\\grad", "{\\boldsymbol\\nabla}");
defineMacro("\\divergence", "{\\grad\\vdot}");
//defineMacro("\\div", "{\\grad\\vdot}"); Not included in Temml. Conflicts w/LaTeX \div
defineMacro("\\curl", "{\\grad\\cross}");
defineMacro("\\laplacian", "\\nabla^2");
defineMacro("\\tr", "{\\operatorname{tr}}");
defineMacro("\\Tr", "{\\operatorname{Tr}}");
defineMacro("\\rank", "{\\operatorname{rank}}");
defineMacro("\\erf", "{\\operatorname{erf}}");
defineMacro("\\Res", "{\\operatorname{Res}}");
defineMacro("\\principalvalue", "{\\mathcal{P}}");
defineMacro("\\pv", "{\\mathcal{P}}");
defineMacro("\\PV", "{\\operatorname{P.V.}}");
// Temml does not use the next two lines. They conflict with LaTeX letters.
//defineMacro("\\Re", "{\\operatorname{Re} \\left\\{ #1 \\right\\}}");
//defineMacro("\\Im", "{\\operatorname{Im} \\left\\{ #1 \\right\\}}");
defineMacro("\\qqtext", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qq", "{\\quad\\text{ #1 }\\quad}");
defineMacro("\\qcomma", "{\\text{,}\\quad}");
defineMacro("\\qc", "{\\text{,}\\quad}");
defineMacro("\\qcc", "{\\quad\\text{c.c.}\\quad}");
defineMacro("\\qif", "{\\quad\\text{if}\\quad}");
defineMacro("\\qthen", "{\\quad\\text{then}\\quad}");
defineMacro("\\qelse", "{\\quad\\text{else}\\quad}");
defineMacro("\\qotherwise", "{\\quad\\text{otherwise}\\quad}");
defineMacro("\\qunless", "{\\quad\\text{unless}\\quad}");
defineMacro("\\qgiven", "{\\quad\\text{given}\\quad}");
defineMacro("\\qusing", "{\\quad\\text{using}\\quad}");
defineMacro("\\qassume", "{\\quad\\text{assume}\\quad}");
defineMacro("\\qsince", "{\\quad\\text{since}\\quad}");
defineMacro("\\qlet", "{\\quad\\text{let}\\quad}");
defineMacro("\\qfor", "{\\quad\\text{for}\\quad}");
defineMacro("\\qall", "{\\quad\\text{all}\\quad}");
defineMacro("\\qeven", "{\\quad\\text{even}\\quad}");
defineMacro("\\qodd", "{\\quad\\text{odd}\\quad}");
defineMacro("\\qinteger", "{\\quad\\text{integer}\\quad}");
defineMacro("\\qand", "{\\quad\\text{and}\\quad}");
defineMacro("\\qor", "{\\quad\\text{or}\\quad}");
defineMacro("\\qas", "{\\quad\\text{as}\\quad}");
defineMacro("\\qin", "{\\quad\\text{in}\\quad}");
defineMacro("\\differential", "{\\text{d}}");
defineMacro("\\dd", "{\\text{d}}");
defineMacro("\\derivative", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\dv", "{\\frac{\\text{d}{ #1 }}{\\text{d}{ #2 }}}");
defineMacro("\\partialderivative", "{\\frac{\\partial{ #1 }}{\\partial{ #2 }}}");
defineMacro("\\variation", "{\\delta}");
defineMacro("\\var", "{\\delta}");
defineMacro("\\functionalderivative", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\fdv", "{\\frac{\\delta{ #1 }}{\\delta{ #2 }}}");
defineMacro("\\innerproduct", "{\\left\\langle {#1} \\mid { #2} \\right\\rangle}");
defineMacro("\\outerproduct",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\dyad",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\ketbra",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\op",
  "{\\left\\vert { #1 } \\right\\rangle\\left\\langle { #2} \\right\\vert}");
defineMacro("\\expectationvalue", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\expval", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\ev", "{\\left\\langle {#1 } \\right\\rangle}");
defineMacro("\\matrixelement",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\matrixel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");
defineMacro("\\mel",
  "{\\left\\langle{ #1 }\\right\\vert{ #2 }\\left\\vert{#3}\\right\\rangle}");

// Helper functions
function getHLines(parser) {
  // Return an array. The array length = number of hlines.
  // Each element in the array tells if the line is dashed.
  const hlineInfo = [];
  parser.consumeSpaces();
  let nxt = parser.fetch().text;
  if (nxt === "\\relax") {
    parser.consume();
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  while (nxt === "\\hline" || nxt === "\\hdashline") {
    parser.consume();
    hlineInfo.push(nxt === "\\hdashline");
    parser.consumeSpaces();
    nxt = parser.fetch().text;
  }
  return hlineInfo;
}

const validateAmsEnvironmentContext = context => {
  const settings = context.parser.settings;
  if (!settings.displayMode) {
    throw new ParseError(`{${context.envName}} can be used only in display mode.`);
  }
};

const sizeRegEx$1 = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const arrayGaps = macros => {
  let arraystretch = macros.get("\\arraystretch");
  if (typeof arraystretch !== "string") {
    arraystretch = stringFromArg(arraystretch.tokens);
  }
  arraystretch = isNaN(arraystretch) ? null : Number(arraystretch);
  let arraycolsepStr = macros.get("\\arraycolsep");
  if (typeof arraycolsepStr !== "string") {
    arraycolsepStr = stringFromArg(arraycolsepStr.tokens);
  }
  const match = sizeRegEx$1.exec(arraycolsepStr);
  const arraycolsep = match
    ? { number: +(match[1] + match[2]), unit: match[3] }
    : null;
  return [arraystretch, arraycolsep]
};

const checkCellForLabels = cell => {
  // Check if the author wrote a \tag{} inside this cell.
  let rowLabel = "";
  for (let i = 0; i < cell.length; i++) {
    if (cell[i].type === "label") {
      if (rowLabel) { throw new ParseError(("Multiple \\labels in one row")) }
      rowLabel = cell[i].string;
    }
  }
  return rowLabel
};

// autoTag (an argument to parseArray) can be one of three values:
// * undefined: Regular (not-top-level) array; no tags on each row
// * true: Automatic equation numbering, overridable by \tag
// * false: Tags allowed on each row, but no automatic numbering
// This function *doesn't* work with the "split" environment name.
function getAutoTag(name) {
  if (name.indexOf("ed") === -1) {
    return name.indexOf("*") === -1;
  }
  // return undefined;
}

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.  If given an optional argument scriptLevel
 * ("text", "display", etc.), then each cell is cast into that scriptLevel.
 */
function parseArray(
  parser,
  {
    cols, // [{ type: string , align: l|c|r|null }]
    envClasses, // align(ed|at|edat) | array | cases | cd | small | multline
    autoTag,        // boolean
    singleRow,      // boolean
    emptySingleRow, // boolean
    maxNumCols,     // number
    leqno,          // boolean
    arraystretch,   // number  | null
    arraycolsep     // size value | null
},
  scriptLevel
) {
  const endToken = envClasses && envClasses.includes("bordermatrix") ? "}" : "\\end";
  parser.gullet.beginGroup();
  if (!singleRow) {
    // \cr is equivalent to \\ without the optional size argument (see below)
    // TODO: provide helpful error when \cr is used outside array environment
    parser.gullet.macros.set("\\cr", "\\\\\\relax");
  }

  // Start group for first cell
  parser.gullet.beginGroup();

  let row = [];
  const body = [row];
  const rowGaps = [];
  const labels = [];

  const hLinesBeforeRow = [];

  const tags = (autoTag != null ? [] : undefined);

  // amsmath uses \global\@eqnswtrue and \global\@eqnswfalse to represent
  // whether this row should have an equation number.  Simulate this with
  // a \@eqnsw macro set to 1 or 0.
  function beginRow() {
    if (autoTag) {
      parser.gullet.macros.set("\\@eqnsw", "1", true);
    }
  }
  function endRow() {
    if (tags) {
      if (parser.gullet.macros.get("\\df@tag")) {
        tags.push(parser.subparse([new Token("\\df@tag")]));
        parser.gullet.macros.set("\\df@tag", undefined, true);
      } else {
        tags.push(Boolean(autoTag) &&
            parser.gullet.macros.get("\\@eqnsw") === "1");
      }
    }
  }
  beginRow();

  // Test for \hline at the top of the array.
  hLinesBeforeRow.push(getHLines(parser));

  while (true) {
    // Parse each cell in its own group (namespace)
    let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
    parser.gullet.endGroup();
    parser.gullet.beginGroup();

    cell = {
      type: "ordgroup",
      mode: parser.mode,
      body: cell,
      semisimple: true
    };
    row.push(cell);
    const next = parser.fetch().text;
    if (next === "&") {
      if (maxNumCols && row.length === maxNumCols) {
        if (envClasses.includes("array")) {
          if (parser.settings.strict) {
            throw new ParseError("Too few columns " + "specified in the {array} column argument.",
              parser.nextToken)
          }
        } else if (maxNumCols === 2) {
          throw new ParseError("The split environment accepts no more than two columns",
            parser.nextToken);
        } else {
          throw new ParseError("The equation environment accepts only one column",
            parser.nextToken)
        }
      }
      parser.consume();
    } else if (next === endToken) {
      endRow();
      // Arrays terminate newlines with `\crcr` which consumes a `\cr` if
      // the last line is empty.  However, AMS environments keep the
      // empty row if it's the only one.
      // NOTE: Currently, `cell` is the last item added into `row`.
      if (row.length === 1 && cell.body.length === 0 && (body.length > 1 || !emptySingleRow)) {
        body.pop();
      }
      labels.push(checkCellForLabels(cell.body));
      if (hLinesBeforeRow.length < body.length + 1) {
        hLinesBeforeRow.push([]);
      }
      break;
    } else if (next === "\\\\") {
      parser.consume();
      let size;
      // \def\Let@{\let\\\math@cr}
      // \def\math@cr{...\math@cr@}
      // \def\math@cr@{\new@ifnextchar[\math@cr@@{\math@cr@@[\z@]}}
      // \def\math@cr@@[#1]{...\math@cr@@@...}
      // \def\math@cr@@@{\cr}
      if (parser.gullet.future().text !== " ") {
        size = parser.parseSizeGroup(true);
      }
      rowGaps.push(size ? size.value : null);
      endRow();

      labels.push(checkCellForLabels(cell.body));

      // check for \hline(s) following the row separator
      hLinesBeforeRow.push(getHLines(parser));

      row = [];
      body.push(row);
      beginRow();
    } else {
      throw new ParseError("Expected & or \\\\ or \\cr or " + endToken, parser.nextToken);
    }
  }

  // End cell group
  parser.gullet.endGroup();
  // End array group defining \cr
  parser.gullet.endGroup();

  return {
    type: "array",
    mode: parser.mode,
    body,
    cols,
    rowGaps,
    hLinesBeforeRow,
    envClasses,
    autoTag,
    scriptLevel,
    tags,
    labels,
    leqno,
    arraystretch,
    arraycolsep
  };
}

// Decides on a scriptLevel for cells in an array according to whether the given
// environment name starts with the letter 'd'.
function dCellStyle(envName) {
  return envName.slice(0, 1) === "d" ? "display" : "text"
}

const alignMap = {
  c: "center ",
  l: "left ",
  r: "right "
};

const glue = group => {
  const glueNode = new mathMLTree.MathNode("mtd", []);
  glueNode.style = { padding: "0", width: "50%" };
  if (group.envClasses.includes("multline")) {
    glueNode.style.width = "7.5%";
  }
  return glueNode
};

const mathmlBuilder$9 = function(group, style) {
  const tbl = [];
  const numRows = group.body.length;
  const hlines = group.hLinesBeforeRow;

  for (let i = 0; i < numRows; i++) {
    const rw = group.body[i];
    const row = [];
    const cellLevel = group.scriptLevel === "text"
      ? StyleLevel.TEXT
      : group.scriptLevel === "script"
      ? StyleLevel.SCRIPT
      : StyleLevel.DISPLAY;

    for (let j = 0; j < rw.length; j++) {
      const mtd = new mathMLTree.MathNode(
        "mtd",
        [buildGroup$1(rw[j], style.withLevel(cellLevel))]
      );

      if (group.envClasses.includes("multline")) {
        const align = i === 0 ? "left" : i === numRows - 1 ? "right" : "center";
        mtd.setAttribute("columnalign", align);
        if (align !== "center") {
          mtd.classes.push("tml-" + align);
        }
      }
      row.push(mtd);
    }
    const numColumns = group.body[0].length;
    // Fill out a short row with empty <mtd> elements.
    for (let k = 0; k < numColumns - rw.length; k++) {
      row.push(new mathMLTree.MathNode("mtd", [], style));
    }
    if (group.autoTag) {
      const tag = group.tags[i];
      let tagElement;
      if (tag === true) {  // automatic numbering
        tagElement = new mathMLTree.MathNode("mtext", [new Span(["tml-eqn"])]);
      } else if (tag === false) {
        // \nonumber/\notag or starred environment
        tagElement = new mathMLTree.MathNode("mtext", [], []);
      } else {  // manual \tag
        tagElement = buildExpressionRow(tag[0].body, style.withLevel(cellLevel), true);
        tagElement = consolidateText(tagElement);
        tagElement.classes = ["tml-tag"];
      }
      if (tagElement) {
        row.unshift(glue(group));
        row.push(glue(group));
        if (group.leqno) {
          row[0].children.push(tagElement);
          row[0].classes.push("tml-left");
        } else {
          row[row.length - 1].children.push(tagElement);
          row[row.length - 1].classes.push("tml-right");
        }
      }
    }
    const mtr = new mathMLTree.MathNode("mtr", row, []);
    const label = group.labels.shift();
    if (label && group.tags && group.tags[i]) {
      mtr.setAttribute("id", label);
      if (Array.isArray(group.tags[i])) { mtr.classes.push("tml-tageqn"); }
    }

    // Write horizontal rules
    if (i === 0 && hlines[0].length > 0) {
      if (hlines[0].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderTop = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderTop = hlines[0][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }
    if (hlines[i + 1].length > 0) {
      if (hlines[i + 1].length === 2) {
        mtr.children.forEach(cell => { cell.style.borderBottom = "0.15em double"; });
      } else {
        mtr.children.forEach(cell => {
          cell.style.borderBottom = hlines[i + 1][0] ? "0.06em dashed" : "0.06em solid";
        });
      }
    }

    // Check for \hphantom \from \bordermatrix
    let mustSquashRow = true;
    for (let j = 0; j < mtr.children.length; j++) {
      const child = mtr.children[j].children[0];
      if (!(child && child.type === "mpadded" && child.attributes.height === "0px")) {
        mustSquashRow = false;
        break
      }
    }
    if (mustSquashRow) {
      // All the cell contents are \hphantom. Squash the padding.
      for (let j = 0; j < mtr.children.length; j++) {
        mtr.children[j].style.paddingTop = "0";
        mtr.children[j].style.paddingBottom = "0";
      }
    }

    tbl.push(mtr);
  }

  if (group.arraystretch && group.arraystretch !== 1) {
    // In LaTeX, \arraystretch is a factor applied to a 12pt strut height.
    // It defines a baseline to baseline distance.
    // Here, we do an approximation of that approach.
    const pad = String(1.4 * group.arraystretch - 0.8) + "ex";
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingTop = pad;
        tbl[i].children[j].style.paddingBottom = pad;
      }
    }
  }

  let sidePadding;
  let sidePadUnit;
  if (group.envClasses.length > 0) {
    sidePadding = group.envClasses.includes("abut")
      ? "0"
      : group.envClasses.includes("cases")
      ? "0"
      : group.envClasses.includes("small")
      ? "0.1389"
      : group.envClasses.includes("cd")
      ? "0.25"
      : "0.4"; // default side padding
    sidePadUnit = "em";
  }
  if (group.arraycolsep) {
    const arraySidePad = calculateSize(group.arraycolsep, style);
    sidePadding = arraySidePad.number.toFixed(4);
    sidePadUnit = arraySidePad.unit;
  }
  if (sidePadding) {
    const numCols = tbl.length === 0 ? 0 : tbl[0].children.length;

    const sidePad = (j, hand) => {
      if (j === 0 && hand === 0) { return "0" }
      if (j === numCols - 1 && hand === 1) { return "0" }
      if (group.envClasses[0] !== "align") { return sidePadding }
      if (hand === 1) { return "0" }
      if (group.autoTag) {
        return (j % 2) ? "1" : "0"
      } else {
        return (j % 2) ? "0" : "1"
      }
    };

    // Side padding
    for (let i = 0; i < tbl.length; i++) {
      for (let j = 0; j < tbl[i].children.length; j++) {
        tbl[i].children[j].style.paddingLeft = `${sidePad(j, 0)}${sidePadUnit}`;
        tbl[i].children[j].style.paddingRight = `${sidePad(j, 1)}${sidePadUnit}`;
      }
    }
  }
  if (group.envClasses.length === 0) {
    // Set zero padding on side of the matrix
    for (let i = 0; i < tbl.length; i++) {
      tbl[i].children[0].style.paddingLeft = "0em";
      if (tbl[i].children.length === tbl[0].children.length) {
        tbl[i].children[tbl[i].children.length - 1].style.paddingRight = "0em";
      }
    }
  }

  if (group.envClasses.length > 0) {
    // Justification
    const align = group.envClasses.includes("align") || group.envClasses.includes("alignat");
    for (let i = 0; i < tbl.length; i++) {
      const row = tbl[i];
      if (align) {
        for (let j = 0; j < row.children.length; j++) {
          // Chromium does not recognize text-align: left. Use -webkit-
          // TODO: Remove -webkit- when Chromium no longer needs it.
          row.children[j].classes = ["tml-" + (j % 2 ? "left" : "right")];
        }
        if (group.autoTag) {
          const k = group.leqno ? 0 : row.children.length - 1;
          row.children[k].classes = ["tml-" + (group.leqno ? "left" : "right")];
        }
      }
      if (row.children.length > 1 && group.envClasses.includes("cases")) {
        row.children[1].style.paddingLeft = "1em";
      }

      if (group.envClasses.includes("cases") || group.envClasses.includes("subarray")) {
        for (const cell of row.children) {
          cell.classes.push("tml-left");
        }
      }
    }
  }

  let table = new mathMLTree.MathNode("mtable", tbl);
  if (group.envClasses.length > 0) {
    // Top & bottom padding
    if (group.envClasses.includes("jot")) {
      table.classes.push("tml-jot");
    } else if (group.envClasses.includes("small")) {
      table.classes.push("tml-small");
    }
  }
  if (group.scriptLevel === "display") { table.setAttribute("displaystyle", "true"); }

  if (group.autoTag || group.envClasses.includes("multline")) {
    table.style.width = "100%";
  }

  // Column separator lines and column alignment
  let align = "";

  if (group.cols && group.cols.length > 0) {
    const cols = group.cols;
    let prevTypeWasAlign = false;
    let iStart = 0;
    let iEnd = cols.length;

    while (cols[iStart].type === "separator") {
      iStart += 1;
    }
    while (cols[iEnd - 1].type === "separator") {
      iEnd -= 1;
    }

    if (cols[0].type === "separator") {
      const sep = cols[1].type === "separator"
        ? "0.15em double"
        : cols[0].separator === "|"
        ? "0.06em solid "
        : "0.06em dashed ";
      for (const row of table.children) {
        row.children[0].style.borderLeft = sep;
      }
    }
    let iCol = group.autoTag ? 0 : -1;
    for (let i = iStart; i < iEnd; i++) {
      if (cols[i].type === "align") {
        const colAlign = alignMap[cols[i].align];
        align += colAlign;
        iCol += 1;
        for (const row of table.children) {
          if (colAlign.trim() !== "center" && iCol < row.children.length) {
            row.children[iCol].classes = ["tml-" + colAlign.trim()];
          }
        }
        prevTypeWasAlign = true;
      } else if (cols[i].type === "separator") {
        // MathML accepts only single lines between cells.
        // So we read only the first of consecutive separators.
        if (prevTypeWasAlign) {
          const sep = cols[i + 1].type === "separator"
            ? "0.15em double"
            : cols[i].separator === "|"
            ? "0.06em solid"
            : "0.06em dashed";
          for (const row of table.children) {
            if (iCol < row.children.length) {
              row.children[iCol].style.borderRight = sep;
            }
          }
        }
        prevTypeWasAlign = false;
      }
    }
    if (cols[cols.length - 1].type === "separator") {
      const sep = cols[cols.length - 2].type === "separator"
        ? "0.15em double"
        : cols[cols.length - 1].separator === "|"
        ? "0.06em solid"
        : "0.06em dashed";
      for (const row of table.children) {
        row.children[row.children.length - 1].style.borderRight = sep;
        row.children[row.children.length - 1].style.paddingRight = "0.4em";
      }
    }
  }
  if (group.autoTag) {
     // allow for glue cells on each side
    align = "left " + (align.length > 0 ? align : "center ") + "right ";
  }
  if (align) {
    // Firefox reads this attribute, not the -webkit-left|right written above.
    // TODO: When Chrome no longer needs "-webkit-", use CSS and delete the next line.
    table.setAttribute("columnalign", align.trim());
  }

  if (group.envClasses.includes("small")) {
    // A small array. Wrap in scriptstyle.
    table = new mathMLTree.MathNode("mstyle", [table]);
    table.setAttribute("scriptlevel", "1");
  }

  return table
};

// Convenience function for align, align*, aligned, alignat, alignat*, alignedat, split.
const alignedHandler = function(context, args) {
  if (context.envName.indexOf("ed") === -1) {
    validateAmsEnvironmentContext(context);
  }
  const isSplit = context.envName === "split";
  const cols = [];
  const res = parseArray(
    context.parser,
    {
      cols,
      emptySingleRow: true,
      autoTag: isSplit ? undefined : getAutoTag(context.envName),
      envClasses: ["abut", "jot"], // set row spacing & provisional column spacing
      maxNumCols: context.envName === "split" ? 2 : undefined,
      leqno: context.parser.settings.leqno
    },
    "display"
  );

  // Determining number of columns.
  // 1. If the first argument is given, we use it as a number of columns,
  //    and makes sure that each row doesn't exceed that number.
  // 2. Otherwise, just count number of columns = maximum number
  //    of cells in each row ("aligned" mode -- isAligned will be true).
  //
  // At the same time, prepend empty group {} at beginning of every second
  // cell in each row (starting with second cell) so that operators become
  // binary.  This behavior is implemented in amsmath's \start@aligned.
  let numMaths;
  let numCols = 0;
  const isAlignedAt = context.envName.indexOf("at") > -1;
  if (args[0] && isAlignedAt) {
    // alignat environment takes an argument w/ number of columns
    let arg0 = "";
    for (let i = 0; i < args[0].body.length; i++) {
      const textord = assertNodeType(args[0].body[i], "textord");
      arg0 += textord.text;
    }
    if (isNaN(arg0)) {
      throw new ParseError("The alignat enviroment requires a numeric first argument.")
    }
    numMaths = Number(arg0);
    numCols = numMaths * 2;
  }
  res.body.forEach(function(row) {
    if (isAlignedAt) {
      // Case 1
      const curMaths = row.length / 2;
      if (numMaths < curMaths) {
        throw new ParseError(
          "Too many math in a row: " + `expected ${numMaths}, but got ${curMaths}`,
          row[0]
        );
      }
    } else if (numCols < row.length) {
      // Case 2
      numCols = row.length;
    }
  });

  // Adjusting alignment.
  // In aligned mode, we add one \qquad between columns;
  // otherwise we add nothing.
  for (let i = 0; i < numCols; ++i) {
    let align = "r";
    if (i % 2 === 1) {
      align = "l";
    }
    cols[i] = {
      type: "align",
      align: align
    };
  }
  if (context.envName === "split") ; else if (isAlignedAt) {
    res.envClasses.push("alignat"); // Sets justification
  } else {
    res.envClasses[0] = "align"; // Sets column spacing & justification
  }
  return res;
};

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
// {darray} is an {array} environment where cells are set in \displaystyle,
// as defined in nccmath.sty.
defineEnvironment({
  type: "array",
  names: ["array", "darray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Since no types are specified above, the two possibilities are
    // - The argument is wrapped in {} or [], in which case Parser's
    //   parseGroup() returns an "ordgroup" wrapping some symbol node.
    // - The argument is a bare symbol node.
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      if ("lcr".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      } else if (ca === "|") {
        return {
          type: "separator",
          separator: "|"
        };
      } else if (ca === ":") {
        return {
          type: "separator",
          separator: ":"
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    const res = {
      cols,
      envClasses: ["array"],
      maxNumCols: cols.length,
      arraystretch,
      arraycolsep
    };
    return parseArray(context.parser, res, dCellStyle(context.envName));
  },
  mathmlBuilder: mathmlBuilder$9
});

// The matrix environments of amsmath build on the array environment
// of LaTeX, which is discussed above.
// The mathtools package adds starred versions of the same environments.
// These have an optional argument to choose left|center|right justification.
defineEnvironment({
  type: "array",
  names: [
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix",
    "matrix*",
    "pmatrix*",
    "bmatrix*",
    "Bmatrix*",
    "vmatrix*",
    "Vmatrix*"
  ],
  props: {
    numArgs: 0
  },
  handler(context) {
    const delimiters = {
      matrix: null,
      pmatrix: ["(", ")"],
      bmatrix: ["[", "]"],
      Bmatrix: ["\\{", "\\}"],
      vmatrix: ["|", "|"],
      Vmatrix: ["\\Vert", "\\Vert"]
    }[context.envName.replace("*", "")];
    // \hskip -\arraycolsep in amsmath
    let colAlign = "c";
    const payload = {
      envClasses: [],
      cols: []
    };
    if (context.envName.charAt(context.envName.length - 1) === "*") {
      // It's one of the mathtools starred functions.
      // Parse the optional alignment argument.
      const parser = context.parser;
      parser.consumeSpaces();
      if (parser.fetch().text === "[") {
        parser.consume();
        parser.consumeSpaces();
        colAlign = parser.fetch().text;
        if ("lcr".indexOf(colAlign) === -1) {
          throw new ParseError("Expected l or c or r", parser.nextToken);
        }
        parser.consume();
        parser.consumeSpaces();
        parser.expect("]");
        parser.consume();
        payload.cols = [];
      }
    }
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: colAlign });
    const [arraystretch, arraycolsep] = arrayGaps(context.parser.gullet.macros);
    res.arraystretch = arraystretch;
    if (arraycolsep && !(arraycolsep === 6 && arraycolsep === "pt")) {
      res.arraycolsep = arraycolsep;
    }
    return delimiters
      ? {
        type: "leftright",
        mode: context.mode,
        body: [res],
        left: delimiters[0],
        right: delimiters[1],
        rightColor: undefined // \right uninfluenced by \color in array
      }
      : res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["bordermatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { cols: [], envClasses: ["bordermatrix"] };
    const res = parseArray(context.parser, payload, "text");
    res.cols = new Array(res.body[0].length).fill({ type: "align", align: "c" });
    res.envClasses = [];
    res.arraystretch = 1;
    if (context.envName === "matrix") { return res}
    return bordermatrixParseTree(res, context.delimiters)
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["smallmatrix"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = { type: "small" };
    const res = parseArray(context.parser, payload, "script");
    res.envClasses = ["small"];
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["subarray"],
  props: {
    numArgs: 1
  },
  handler(context, args) {
    // Parsing of {subarray} is similar to {array}
    const symNode = checkSymbolNodeType(args[0]);
    const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
    const cols = colalign.map(function(nde) {
      const node = assertSymbolNodeType(nde);
      const ca = node.text;
      // {subarray} only recognizes "l" & "c"
      if ("lc".indexOf(ca) !== -1) {
        return {
          type: "align",
          align: ca
        };
      }
      throw new ParseError("Unknown column alignment: " + ca, nde);
    });
    if (cols.length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    let res = {
      cols,
      envClasses: ["small"]
    };
    res = parseArray(context.parser, res, "script");
    if (res.body.length > 0 && res.body[0].length > 1) {
      throw new ParseError("{subarray} can contain only one column");
    }
    return res;
  },
  mathmlBuilder: mathmlBuilder$9
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def
// \left\{\begin{array}{@{}l@{\quad}l@{}} … \end{array}\right.
// {dcases} is a {cases} environment where cells are set in \displaystyle,
// as defined in mathtools.sty.
// {rcases} is another mathtools environment. It's brace is on the right side.
defineEnvironment({
  type: "array",
  names: ["cases", "dcases", "rcases", "drcases"],
  props: {
    numArgs: 0
  },
  handler(context) {
    const payload = {
      cols: [],
      envClasses: ["cases"]
    };
    const res = parseArray(context.parser, payload, dCellStyle(context.envName));
    return {
      type: "leftright",
      mode: context.mode,
      body: [res],
      left: context.envName.indexOf("r") > -1 ? "." : "\\{",
      right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
      rightColor: undefined
    };
  },
  mathmlBuilder: mathmlBuilder$9
});

// In the align environment, one uses ampersands, &, to specify number of
// columns in each row, and to locate spacing between each column.
// align gets automatic numbering. align* and aligned do not.
// The alignedat environment can be used in math mode.
defineEnvironment({
  type: "array",
  names: ["align", "align*", "aligned", "split"],
  props: {
    numArgs: 0
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// alignat environment is like an align environment, but one must explicitly
// specify maximum number of columns in each row, and can adjust where spacing occurs.
defineEnvironment({
  type: "array",
  names: ["alignat", "alignat*", "alignedat"],
  props: {
    numArgs: 1
  },
  handler: alignedHandler,
  mathmlBuilder: mathmlBuilder$9
});

// A gathered environment is like an array environment with one centered
// column, but where rows are considered lines so get \jot line spacing
// and contents are set in \displaystyle.
defineEnvironment({
  type: "array",
  names: ["gathered", "gather", "gather*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    if (context.envName !== "gathered") {
      validateAmsEnvironmentContext(context);
    }
    const res = {
      cols: [],
      envClasses: ["abut", "jot"],
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["equation", "equation*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: getAutoTag(context.envName),
      emptySingleRow: true,
      singleRow: true,
      maxNumCols: 1,
      envClasses: ["align"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["multline", "multline*"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    const res = {
      autoTag: context.envName === "multline",
      maxNumCols: 1,
      envClasses: ["jot", "multline"],
      leqno: context.parser.settings.leqno
    };
    return parseArray(context.parser, res, "display");
  },
  mathmlBuilder: mathmlBuilder$9
});

defineEnvironment({
  type: "array",
  names: ["CD"],
  props: {
    numArgs: 0
  },
  handler(context) {
    validateAmsEnvironmentContext(context);
    return parseCD(context.parser);
  },
  mathmlBuilder: mathmlBuilder$9
});

// Catch \hline outside array environment
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\hline", "\\hdashline"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: true
  },
  handler(context, args) {
    throw new ParseError(`${context.funcName} valid only within array environment`);
  }
});

const environments = _environments;

// \bordermatrix  from TeXbook pp 177 & 361
// Optional argument from Herbert Voß, Math mode, p 20
// Ref: https://tug.ctan.org/obsolete/info/math/voss/mathmode/Mathmode.pdf

defineFunction({
  type: "bordermatrix",
  names: ["\\bordermatrix", "\\matrix"],
  props: {
    numArgs: 0,
    numOptionalArgs: 1
  },
  handler: ({ parser, funcName }, args, optArgs) => {
    // Find out if the author has defined custom delimiters
    let delimiters = ["(", ")"];
    if (funcName === "\\bordermatrix" && optArgs[0] && optArgs[0].body) {
      const body = optArgs[0].body;
      if (body.length === 2 && body[0].type === "atom" && body[1].type === "atom") {
        if (body[0].family === "open" && body[1].family === "close") {
          delimiters = [body[0].text, body[1].text];
        }
      }
    }
    // consume the opening brace
    parser.consumeSpaces();
    parser.consume();

    // Pass control to the environment handler in array.js.
    const env = environments["bordermatrix"];
    const context = {
      mode: parser.mode,
      envName: funcName.slice(1),
      delimiters,
      parser
    };
    const result = env.handler(context);
    parser.expect("}", true);
    return result
  }
});

// \@char is an internal function that takes a grouped decimal argument like
// {123} and converts into symbol with code 123.  It is used by the *macro*
// \char defined in macros.js.
defineFunction({
  type: "textord",
  names: ["\\@char"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, token }, args) {
    const arg = assertNodeType(args[0], "ordgroup");
    const group = arg.body;
    let number = "";
    for (let i = 0; i < group.length; i++) {
      const node = assertNodeType(group[i], "textord");
      number += node.text;
    }
    const code = parseInt(number);
    if (isNaN(code)) {
      throw new ParseError(`\\@char has non-numeric argument ${number}`, token)
    }
    return {
      type: "textord",
      mode: parser.mode,
      text: String.fromCodePoint(code)
    }
  }
});

// Helpers
const htmlRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6})$/i;
const htmlOrNameRegEx = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i;
const RGBregEx = /^ *\d{1,3} *(?:, *\d{1,3} *){2}$/;
const rgbRegEx = /^ *[10](?:\.\d*)? *(?:, *[10](?:\.\d*)? *){2}$/;
const xcolorHtmlRegEx = /^[a-f0-9]{6}$/i;
const toHex = num => {
  let str = num.toString(16);
  if (str.length === 1) { str = "0" + str; }
  return str
};

// Colors from Tables 4.1 and 4.2 of the xcolor package.
// Table 4.1 (lower case) RGB values are taken from chroma and xcolor.dtx.
// Table 4.2 (Capitalizzed) values were sampled, because Chroma contains a unreliable
// conversion from cmyk to RGB. See https://tex.stackexchange.com/a/537274.
const xcolors = JSON.parse(`{
  "Apricot": "#ffb484",
  "Aquamarine": "#08b4bc",
  "Bittersweet": "#c84c14",
  "blue": "#0000FF",
  "Blue": "#303494",
  "BlueGreen": "#08b4bc",
  "BlueViolet": "#503c94",
  "BrickRed": "#b8341c",
  "brown": "#BF8040",
  "Brown": "#802404",
  "BurntOrange": "#f8941c",
  "CadetBlue": "#78749c",
  "CarnationPink": "#f884b4",
  "Cerulean": "#08a4e4",
  "CornflowerBlue": "#40ace4",
  "cyan": "#00FFFF",
  "Cyan": "#08acec",
  "Dandelion": "#ffbc44",
  "darkgray": "#404040",
  "DarkOrchid": "#a8548c",
  "Emerald": "#08ac9c",
  "ForestGreen": "#089c54",
  "Fuchsia": "#90348c",
  "Goldenrod": "#ffdc44",
  "gray": "#808080",
  "Gray": "#98949c",
  "green": "#00FF00",
  "Green": "#08a44c",
  "GreenYellow": "#e0e474",
  "JungleGreen": "#08ac9c",
  "Lavender": "#f89cc4",
  "lightgray": "#c0c0c0",
  "lime": "#BFFF00",
  "LimeGreen": "#90c43c",
  "magenta": "#FF00FF",
  "Magenta": "#f0048c",
  "Mahogany": "#b0341c",
  "Maroon": "#b03434",
  "Melon": "#f89c7c",
  "MidnightBlue": "#086494",
  "Mulberry": "#b03c94",
  "NavyBlue": "#086cbc",
  "olive": "#7F7F00",
  "OliveGreen": "#407c34",
  "orange": "#FF8000",
  "Orange": "#f8843c",
  "OrangeRed": "#f0145c",
  "Orchid": "#b074ac",
  "Peach": "#f8945c",
  "Periwinkle": "#8074bc",
  "PineGreen": "#088c74",
  "pink": "#ff7f7f",
  "Plum": "#98248c",
  "ProcessBlue": "#08b4ec",
  "purple": "#BF0040",
  "Purple": "#a0449c",
  "RawSienna": "#983c04",
  "red": "#ff0000",
  "Red": "#f01c24",
  "RedOrange": "#f86434",
  "RedViolet": "#a0246c",
  "Rhodamine": "#f0549c",
  "Royallue": "#0874bc",
  "RoyalPurple": "#683c9c",
  "RubineRed": "#f0047c",
  "Salmon": "#f8948c",
  "SeaGreen": "#30bc9c",
  "Sepia": "#701404",
  "SkyBlue": "#48c4dc",
  "SpringGreen": "#c8dc64",
  "Tan": "#e09c74",
  "teal": "#007F7F",
  "TealBlue": "#08acb4",
  "Thistle": "#d884b4",
  "Turquoise": "#08b4cc",
  "violet": "#800080",
  "Violet": "#60449c",
  "VioletRed": "#f054a4",
  "WildStrawberry": "#f0246c",
  "yellow": "#FFFF00",
  "Yellow": "#fff404",
  "YellowGreen": "#98cc6c",
  "YellowOrange": "#ffa41c"
}`);

const colorFromSpec = (model, spec) => {
  let color = "";
  if (model === "HTML") {
    if (!htmlRegEx.test(spec)) {
      throw new ParseError("Invalid HTML input.")
    }
    color = spec;
  } else if (model === "RGB") {
    if (!RGBregEx.test(spec)) {
      throw new ParseError("Invalid RGB input.")
    }
    spec.split(",").map(e => { color += toHex(Number(e.trim())); });
  } else {
    if (!rgbRegEx.test(spec)) {
      throw new ParseError("Invalid rbg input.")
    }
    spec.split(",").map(e => {
      const num = Number(e.trim());
      if (num > 1) { throw new ParseError("Color rgb input must be < 1.") }
      color += toHex(Number((num * 255).toFixed(0)));
    });
  }
  if (color.charAt(0) !== "#") { color = "#" + color; }
  return color
};

const validateColor = (color, macros, token) => {
  const macroName = `\\\\color@${color}`; // from \defineColor.
  const match = htmlOrNameRegEx.exec(color);
  if (!match) { throw new ParseError("Invalid color: '" + color + "'", token) }
  // We allow a 6-digit HTML color spec without a leading "#".
  // This follows the xcolor package's HTML color model.
  // Predefined color names are all missed by this RegEx pattern.
  if (xcolorHtmlRegEx.test(color)) {
    return "#" + color
  } else if (color.charAt(0) === "#") {
    return color
  } else if (macros.has(macroName)) {
    color = macros.get(macroName).tokens[0].text;
  } else if (xcolors[color]) {
    color = xcolors[color];
  }
  return color
};

const mathmlBuilder$8 = (group, style) => {
  // In LaTeX, color is not supposed to change the spacing of any node.
  // So instead of wrapping the group in an <mstyle>, we apply
  // the color individually to each node and return a document fragment.
  let expr = buildExpression(group.body, style.withColor(group.color));
  expr = expr.map(e => {
    e.style.color = group.color;
    return e
  });
  return mathMLTree.newDocumentFragment(expr)
};

defineFunction({
  type: "color",
  names: ["\\textcolor"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "original"]
  },
  handler({ parser, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }
    const body = args[1];
    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: true,
      body: ordargument(body)
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\color"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw"]
  },
  handler({ parser, breakOnTokenText, token }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros, token);
    }

    // Parse out the implicit body that should be colored.
    const body = parser.parseExpression(true, breakOnTokenText, true);

    return {
      type: "color",
      mode: parser.mode,
      color,
      isTextColor: false,
      body
    }
  },
  mathmlBuilder: mathmlBuilder$8
});

defineFunction({
  type: "color",
  names: ["\\definecolor"],
  props: {
    numArgs: 3,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw"]
  },
  handler({ parser, funcName, token }, args) {
    const name = assertNodeType(args[0], "raw").string;
    if (!/^[A-Za-z]+$/.test(name)) {
      throw new ParseError("Color name must be latin letters.", token)
    }
    const model = assertNodeType(args[1], "raw").string;
    if (!["HTML", "RGB", "rgb"].includes(model)) {
      throw new ParseError("Color model must be HTML, RGB, or rgb.", token)
    }
    const spec = assertNodeType(args[2], "raw").string;
    const color = colorFromSpec(model, spec);
    parser.gullet.macros.set(`\\\\color@${name}`, { tokens: [{ text: color }], numArgs: 0 });
    return { type: "internal", mode: parser.mode }
  }
  // No mathmlBuilder. The point of \definecolor is to set a macro.
});

// Row breaks within tabular environments, and line breaks at top level


// \DeclareRobustCommand\\{...\@xnewline}
defineFunction({
  type: "cr",
  names: ["\\\\"],
  props: {
    numArgs: 0,
    numOptionalArgs: 0,
    allowedInText: true
  },

  handler({ parser }, args, optArgs) {
    const size = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
    const newLine = !parser.settings.displayMode;
    return {
      type: "cr",
      mode: parser.mode,
      newLine,
      size: size && assertNodeType(size, "size").value
    }
  },

  // The following builder is called only at the top level,
  // not within tabular/array environments.

  mathmlBuilder(group, style) {
    // MathML 3.0 calls for newline to occur in an <mo> or an <mspace>.
    // Ref: https://www.w3.org/TR/MathML3/chapter3.html#presm.linebreaking
    const node = new mathMLTree.MathNode("mo");
    if (group.newLine) {
      node.setAttribute("linebreak", "newline");
      if (group.size) {
        const size = calculateSize(group.size, style);
        node.setAttribute("height", size.number + size.unit);
      }
    }
    return node
  }
});

const globalMap = {
  "\\global": "\\global",
  "\\long": "\\\\globallong",
  "\\\\globallong": "\\\\globallong",
  "\\def": "\\gdef",
  "\\gdef": "\\gdef",
  "\\edef": "\\xdef",
  "\\xdef": "\\xdef",
  "\\let": "\\\\globallet",
  "\\futurelet": "\\\\globalfuture"
};

const checkControlSequence = (tok) => {
  const name = tok.text;
  if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
    throw new ParseError("Expected a control sequence", tok);
  }
  return name;
};

const getRHS = (parser) => {
  let tok = parser.gullet.popToken();
  if (tok.text === "=") {
    // consume optional equals
    tok = parser.gullet.popToken();
    if (tok.text === " ") {
      // consume one optional space
      tok = parser.gullet.popToken();
    }
  }
  return tok;
};

const letCommand = (parser, name, tok, global) => {
  let macro = parser.gullet.macros.get(tok.text);
  if (macro == null) {
    // don't expand it later even if a macro with the same name is defined
    // e.g., \let\foo=\frac \def\frac{\relax} \frac12
    tok.noexpand = true;
    macro = {
      tokens: [tok],
      numArgs: 0,
      // reproduce the same behavior in expansion
      unexpandable: !parser.gullet.isExpandable(tok.text)
    };
  }
  parser.gullet.macros.set(name, macro, global);
};

// <assignment> -> <non-macro assignment>|<macro assignment>
// <non-macro assignment> -> <simple assignment>|\global<non-macro assignment>
// <macro assignment> -> <definition>|<prefix><macro assignment>
// <prefix> -> \global|\long|\outer
defineFunction({
  type: "internal",
  names: [
    "\\global",
    "\\long",
    "\\\\globallong" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser, funcName }) {
    parser.consumeSpaces();
    const token = parser.fetch();
    if (globalMap[token.text]) {
      // Temml doesn't have \par, so ignore \long
      if (funcName === "\\global" || funcName === "\\\\globallong") {
        token.text = globalMap[token.text];
      }
      return assertNodeType(parser.parseFunction(), "internal");
    }
    throw new ParseError(`Invalid token after macro prefix`, token);
  }
});

// Basic support for macro definitions: \def, \gdef, \edef, \xdef
// <definition> -> <def><control sequence><definition text>
// <def> -> \def|\gdef|\edef|\xdef
// <definition text> -> <parameter text><left brace><balanced text><right brace>
defineFunction({
  type: "internal",
  names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let tok = parser.gullet.popToken();
    const name = tok.text;
    if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
      throw new ParseError("Expected a control sequence", tok);
    }

    let numArgs = 0;
    let insert;
    const delimiters = [[]];
    // <parameter text> contains no braces
    while (parser.gullet.future().text !== "{") {
      tok = parser.gullet.popToken();
      if (tok.text === "#") {
        // If the very last character of the <parameter text> is #, so that
        // this # is immediately followed by {, TeX will behave as if the {
        // had been inserted at the right end of both the parameter text
        // and the replacement text.
        if (parser.gullet.future().text === "{") {
          insert = parser.gullet.future();
          delimiters[numArgs].push("{");
          break;
        }

        // A parameter, the first appearance of # must be followed by 1,
        // the next by 2, and so on; up to nine #’s are allowed
        tok = parser.gullet.popToken();
        if (!/^[1-9]$/.test(tok.text)) {
          throw new ParseError(`Invalid argument number "${tok.text}"`);
        }
        if (parseInt(tok.text) !== numArgs + 1) {
          throw new ParseError(`Argument number "${tok.text}" out of order`);
        }
        numArgs++;
        delimiters.push([]);
      } else if (tok.text === "EOF") {
        throw new ParseError("Expected a macro definition");
      } else {
        delimiters[numArgs].push(tok.text);
      }
    }
    // replacement text, enclosed in '{' and '}' and properly nested
    let { tokens } = parser.gullet.consumeArg();
    if (insert) {
      tokens.unshift(insert);
    }

    if (funcName === "\\edef" || funcName === "\\xdef") {
      tokens = parser.gullet.expandTokens(tokens);
      if (tokens.length > parser.gullet.settings.maxExpand) {
        throw new ParseError("Too many expansions in an " + funcName);
      }
      tokens.reverse(); // to fit in with stack order
    }
    // Final arg is the expansion of the macro
    parser.gullet.macros.set(
      name,
      { tokens, numArgs, delimiters },
      funcName === globalMap[funcName]
    );
    return { type: "internal", mode: parser.mode };
  }
});

// <simple assignment> -> <let assignment>
// <let assignment> -> \futurelet<control sequence><token><token>
//     | \let<control sequence><equals><one optional space><token>
// <equals> -> <optional spaces>|<optional spaces>=
defineFunction({
  type: "internal",
  names: [
    "\\let",
    "\\\\globallet" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    parser.gullet.consumeSpaces();
    const tok = getRHS(parser);
    letCommand(parser, name, tok, funcName === "\\\\globallet");
    return { type: "internal", mode: parser.mode };
  }
});

// ref: https://www.tug.org/TUGboat/tb09-3/tb22bechtolsheim.pdf
defineFunction({
  type: "internal",
  names: [
    "\\futurelet",
    "\\\\globalfuture" // can’t be entered directly
  ],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    const name = checkControlSequence(parser.gullet.popToken());
    const middle = parser.gullet.popToken();
    const tok = parser.gullet.popToken();
    letCommand(parser, name, tok, funcName === "\\\\globalfuture");
    parser.gullet.pushToken(tok);
    parser.gullet.pushToken(middle);
    return { type: "internal", mode: parser.mode };
  }
});

defineFunction({
  type: "internal",
  names: ["\\newcommand", "\\renewcommand", "\\providecommand"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ parser, funcName }) {
    let name = "";
    const tok = parser.gullet.popToken();
    if (tok.text === "{") {
      name = checkControlSequence(parser.gullet.popToken());
      parser.gullet.popToken();
    } else {
      name = checkControlSequence(tok);
    }

    const exists = parser.gullet.isDefined(name);
    if (exists && funcName === "\\newcommand") {
      throw new ParseError(
        `\\newcommand{${name}} attempting to redefine ${name}; use \\renewcommand`
      );
    }
    if (!exists && funcName === "\\renewcommand") {
      throw new ParseError(
        `\\renewcommand{${name}} when command ${name} does not yet exist; use \\newcommand`
      );
    }

    let numArgs = 0;
    if (parser.gullet.future().text === "[") {
      let tok = parser.gullet.popToken();
      tok = parser.gullet.popToken();
      if (!/^[0-9]$/.test(tok.text)) {
        throw new ParseError(`Invalid number of arguments: "${tok.text}"`);
      }
      numArgs = parseInt(tok.text);
      tok = parser.gullet.popToken();
      if (tok.text !== "]") {
        throw new ParseError(`Invalid argument "${tok.text}"`);
      }
    }

    // replacement text, enclosed in '{' and '}' and properly nested
    const { tokens } = parser.gullet.consumeArg();

    if (!(funcName === "\\providecommand" && parser.gullet.macros.has(name))) {
      // Ignore \providecommand
      parser.gullet.macros.set(
        name,
        { tokens, numArgs }
      );
    }

    return { type: "internal", mode: parser.mode };

  }
});

// Extra data needed for the delimiter handler down below
const delimiterSizes = {
  "\\bigl": { mclass: "mopen", size: 1 },
  "\\Bigl": { mclass: "mopen", size: 2 },
  "\\biggl": { mclass: "mopen", size: 3 },
  "\\Biggl": { mclass: "mopen", size: 4 },
  "\\bigr": { mclass: "mclose", size: 1 },
  "\\Bigr": { mclass: "mclose", size: 2 },
  "\\biggr": { mclass: "mclose", size: 3 },
  "\\Biggr": { mclass: "mclose", size: 4 },
  "\\bigm": { mclass: "mrel", size: 1 },
  "\\Bigm": { mclass: "mrel", size: 2 },
  "\\biggm": { mclass: "mrel", size: 3 },
  "\\Biggm": { mclass: "mrel", size: 4 },
  "\\big": { mclass: "mord", size: 1 },
  "\\Big": { mclass: "mord", size: 2 },
  "\\bigg": { mclass: "mord", size: 3 },
  "\\Bigg": { mclass: "mord", size: 4 }
};

const delimiters = [
  "(",
  "\\lparen",
  ")",
  "\\rparen",
  "[",
  "\\lbrack",
  "]",
  "\\rbrack",
  "\\{",
  "\\lbrace",
  "\\}",
  "\\rbrace",
  "⦇",
  "\\llparenthesis",
  "⦈",
  "\\rrparenthesis",
  "\\lfloor",
  "\\rfloor",
  "\u230a",
  "\u230b",
  "\\lceil",
  "\\rceil",
  "\u2308",
  "\u2309",
  "<",
  ">",
  "\\langle",
  "\u27e8",
  "\\rangle",
  "\u27e9",
  "\\lAngle",
  "\u27ea",
  "\\rAngle",
  "\u27eb",
  "\\llangle",
  "⦉",
  "\\rrangle",
  "⦊",
  "\\lt",
  "\\gt",
  "\\lvert",
  "\\rvert",
  "\\lVert",
  "\\rVert",
  "\\lgroup",
  "\\rgroup",
  "\u27ee",
  "\u27ef",
  "\\lmoustache",
  "\\rmoustache",
  "\u23b0",
  "\u23b1",
  "\\llbracket",
  "\\rrbracket",
  "\u27e6",
  "\u27e6",
  "\\lBrace",
  "\\rBrace",
  "\u2983",
  "\u2984",
  "/",
  "\\backslash",
  "|",
  "\\vert",
  "\\|",
  "\\Vert",
  "\u2016",
  "\\uparrow",
  "\\Uparrow",
  "\\downarrow",
  "\\Downarrow",
  "\\updownarrow",
  "\\Updownarrow",
  "."
];

// Export isDelimiter for benefit of parser.
const dels = ["}", "\\left", "\\middle", "\\right"];
const isDelimiter = str => str.length > 0 &&
  (delimiters.includes(str) || delimiterSizes[str] || dels.includes(str));

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

// Delimiter functions
function checkDelimiter(delim, context) {
  const symDelim = checkSymbolNodeType(delim);
  if (symDelim && delimiters.includes(symDelim.text)) {
    // If a character is not in the MathML operator dictionary, it will not stretch.
    // Replace such characters w/characters that will stretch.
    if (["<", "\\lt"].includes(symDelim.text)) { symDelim.text = "⟨"; }
    if ([">", "\\gt"].includes(symDelim.text)) { symDelim.text = "⟩"; }
    return symDelim;
  } else if (symDelim) {
    throw new ParseError(`Invalid delimiter '${symDelim.text}' after '${context.funcName}'`, delim);
  } else {
    throw new ParseError(`Invalid delimiter type '${delim.type}'`, delim);
  }
}

//                               /         \
const needExplicitStretch = ["\u002F", "\u005C", "\\backslash", "\\vert", "|"];

defineFunction({
  type: "delimsizing",
  names: [
    "\\bigl",
    "\\Bigl",
    "\\biggl",
    "\\Biggl",
    "\\bigr",
    "\\Bigr",
    "\\biggr",
    "\\Biggr",
    "\\bigm",
    "\\Bigm",
    "\\biggm",
    "\\Biggm",
    "\\big",
    "\\Big",
    "\\bigg",
    "\\Bigg"
  ],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    return {
      type: "delimsizing",
      mode: context.parser.mode,
      size: delimiterSizes[context.funcName].size,
      mclass: delimiterSizes[context.funcName].mclass,
      delim: delim.text
    };
  },
  mathmlBuilder: (group) => {
    const children = [];

    if (group.delim === ".") { group.delim = ""; }
    children.push(makeText(group.delim, group.mode));

    const node = new mathMLTree.MathNode("mo", children);

    if (group.mclass === "mopen" || group.mclass === "mclose") {
      // Only some of the delimsizing functions act as fences, and they
      // return "mopen" or "mclose" mclass.
      node.setAttribute("fence", "true");
    } else {
      // Explicitly disable fencing if it's not a fence, to override the
      // defaults.
      node.setAttribute("fence", "false");
    }
    if (needExplicitStretch.includes(group.delim) || group.delim.indexOf("arrow") > -1) {
      // We have to explicitly set stretchy to true.
      node.setAttribute("stretchy", "true");
    }
    node.setAttribute("symmetric", "true"); // Needed for tall arrows in Firefox.
    node.setAttribute("minsize", sizeToMaxHeight[group.size] + "em");
    node.setAttribute("maxsize", sizeToMaxHeight[group.size] + "em");
    return node;
  }
});

function assertParsed(group) {
  if (!group.body) {
    throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
  }
}

defineFunction({
  type: "leftright-right",
  names: ["\\right"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    return {
      type: "leftright-right",
      mode: context.parser.mode,
      delim: checkDelimiter(args[0], context).text
    };
  }
});

defineFunction({
  type: "leftright",
  names: ["\\left"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);

    const parser = context.parser;
    // Parse out the implicit body
    ++parser.leftrightDepth;
    // parseExpression stops before '\\right' or `\\middle`
    let body = parser.parseExpression(false, null, true);
    let nextToken = parser.fetch();
    while (nextToken.text === "\\middle") {
      // `\middle`, from the ε-TeX package, ends one group and starts another group.
      // We had to parse this expression with `breakOnMiddle` enabled in order
      // to get TeX-compliant parsing of \over.
      // But we do not want, at this point, to end on \middle, so continue
      // to parse until we fetch a `\right`.
      parser.consume();
      const middle = parser.fetch().text;
      if (!symbols.math[middle]) {
        throw new ParseError(`Invalid delimiter '${middle}' after '\\middle'`);
      }
      checkDelimiter({ type: "atom", mode: "math", text: middle }, { funcName: "\\middle" });
      body.push({ type: "middle", mode: "math", delim: middle });
      parser.consume();
      body = body.concat(parser.parseExpression(false, null, true));
      nextToken = parser.fetch();
    }
    --parser.leftrightDepth;
    // Check the next token
    parser.expect("\\right", false);
    const right = assertNodeType(parser.parseFunction(), "leftright-right");
    return {
      type: "leftright",
      mode: parser.mode,
      body,
      left: delim.text,
      right: right.delim
    };
  },
  mathmlBuilder: (group, style) => {
    assertParsed(group);
    const inner = buildExpression(group.body, style);

    if (group.left === ".") { group.left = ""; }
    const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
    leftNode.setAttribute("fence", "true");
    leftNode.setAttribute("form", "prefix");
    if (group.left === "/" || group.left === "\u005C" || group.left.indexOf("arrow") > -1) {
      leftNode.setAttribute("stretchy", "true");
    }
    inner.unshift(leftNode);

    if (group.right === ".") { group.right = ""; }
    const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
    rightNode.setAttribute("fence", "true");
    rightNode.setAttribute("form", "postfix");
    if (group.right === "\u2216" || group.right.indexOf("arrow") > -1) {
      rightNode.setAttribute("stretchy", "true");
    }
    if (group.body.length > 0) {
      const lastElement = group.body[group.body.length - 1];
      if (lastElement.type === "color" && !lastElement.isTextColor) {
        // \color is a switch. If the last element is of type "color" then
        // the user set the \color switch and left it on.
        // A \right delimiter turns the switch off, but the delimiter itself gets the color.
        rightNode.setAttribute("mathcolor", lastElement.color);
      }
    }
    inner.push(rightNode);

    return makeRow(inner);
  }
});

defineFunction({
  type: "middle",
  names: ["\\middle"],
  props: {
    numArgs: 1,
    argTypes: ["primitive"]
  },
  handler: (context, args) => {
    const delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
      throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
      type: "middle",
      mode: context.parser.mode,
      delim: delim.text
    };
  },
  mathmlBuilder: (group, style) => {
    const textNode = makeText(group.delim, group.mode);
    const middleNode = new mathMLTree.MathNode("mo", [textNode]);
    middleNode.setAttribute("fence", "true");
    if (group.delim.indexOf("arrow") > -1) {
      middleNode.setAttribute("stretchy", "true");
    }
    // The next line is not semantically correct, but
    // Chromium fails to stretch if it is not there.
    middleNode.setAttribute("form", "prefix");
    // MathML gives 5/18em spacing to each <mo> element.
    // \middle should get delimiter spacing instead.
    middleNode.setAttribute("lspace", "0.05em");
    middleNode.setAttribute("rspace", "0.05em");
    return middleNode;
  }
});

const padding = _ => {
  const node = new mathMLTree.MathNode("mspace");
  node.setAttribute("width", "3pt");
  return node
};

const mathmlBuilder$7 = (group, style) => {
  let node;
  if (group.label.indexOf("colorbox") > -1 || group.label === "\\boxed") {
    // MathML core does not support +width attribute in <mpadded>.
    // Firefox does not reliably add side padding.
    // Insert <mspace>
    node = new mathMLTree.MathNode("mrow", [
      padding(),
      buildGroup$1(group.body, style),
      padding()
    ]);
  } else {
    node = new mathMLTree.MathNode("menclose", [buildGroup$1(group.body, style)]);
  }
  switch (group.label) {
    case "\\overline":
      node.setAttribute("notation", "top"); // for Firefox & WebKit
      node.classes.push("tml-overline");    // for Chromium
      break
    case "\\underline":
      node.setAttribute("notation", "bottom");
      node.classes.push("tml-underline");
      break
    case "\\cancel":
      node.setAttribute("notation", "updiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "upstrike"]));
      break
    case "\\bcancel":
      node.setAttribute("notation", "downdiagonalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "downstrike"]));
      break
    case "\\sout":
      node.setAttribute("notation", "horizontalstrike");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["tml-cancel", "sout"]));
      break
    case "\\xcancel":
      node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
      node.classes.push("tml-xcancel");
      break
    case "\\longdiv":
      node.setAttribute("notation", "longdiv");
      node.classes.push("longdiv-top");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["longdiv-arc"]));
      break
    case "\\phase":
      node.setAttribute("notation", "phasorangle");
      node.classes.push("phasor-bottom");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["phasor-angle"]));
      break
    case "\\textcircled":
      node.setAttribute("notation", "circle");
      node.classes.push("circle-pad");
      node.children.push(new mathMLTree.MathNode("mrow", [], ["textcircle"]));
      break
    case "\\angl":
      node.setAttribute("notation", "actuarial");
      node.classes.push("actuarial");
      break
    case "\\boxed":
      // \newcommand{\boxed}[1]{\fbox{\m@th$\displaystyle#1$}} from amsmath.sty
      node.setAttribute("notation", "box");
      node.classes.push("tml-box");
      node.setAttribute("scriptlevel", "0");
      node.setAttribute("displaystyle", "true");
      break
    case "\\fbox":
      node.setAttribute("notation", "box");
      node.classes.push("tml-fbox");
      break
    case "\\fcolorbox":
    case "\\colorbox": {
      // <menclose> doesn't have a good notation option for \colorbox.
      // So use <mpadded> instead. Set some attributes that come
      // included with <menclose>.
      //const fboxsep = 3; // 3 pt from LaTeX source2e
      //node.setAttribute("height", `+${2 * fboxsep}pt`)
      //node.setAttribute("voffset", `${fboxsep}pt`)
      const style = { padding: "3pt 0 3pt 0" };

      if (group.label === "\\fcolorbox") {
        style.border = "0.0667em solid " + String(group.borderColor);
      }
      node.style = style;
      break
    }
  }
  if (group.backgroundColor) {
    node.setAttribute("mathbackground", group.backgroundColor);
  }
  return node;
};

defineFunction({
  type: "enclose",
  names: ["\\colorbox"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let color = "";
    if (model) {
      const spec = assertNodeType(args[0], "raw").string;
      color = colorFromSpec(model, spec);
    } else {
      color = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
    }
    const body = args[1];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor: color,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fcolorbox"],
  props: {
    numArgs: 3,
    numOptionalArgs: 1,
    allowedInText: true,
    argTypes: ["raw", "raw", "raw", "text"]
  },
  handler({ parser, funcName }, args, optArgs) {
    const model = optArgs[0] && assertNodeType(optArgs[0], "raw").string;
    let borderColor = "";
    let backgroundColor;
    if (model) {
      const borderSpec = assertNodeType(args[0], "raw").string;
      const backgroundSpec = assertNodeType(args[0], "raw").string;
      borderColor = colorFromSpec(model, borderSpec);
      backgroundColor = colorFromSpec(model, backgroundSpec);
    } else {
      borderColor = validateColor(assertNodeType(args[0], "raw").string, parser.gullet.macros);
      backgroundColor = validateColor(assertNodeType(args[1], "raw").string, parser.gullet.macros);
    }
    const body = args[2];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      backgroundColor,
      borderColor,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\fbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "enclose",
      mode: parser.mode,
      label: "\\fbox",
      body: args[0]
    };
  }
});

defineFunction({
  type: "enclose",
  names: ["\\angl", "\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\overline",
    "\\boxed", "\\longdiv", "\\phase"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

defineFunction({
  type: "enclose",
  names: ["\\underline"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});


defineFunction({
  type: "enclose",
  names: ["\\textcircled"],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "enclose",
      mode: parser.mode,
      label: funcName,
      body
    };
  },
  mathmlBuilder: mathmlBuilder$7
});

// Environment delimiters. HTML/MathML rendering is defined in the corresponding
// defineEnvironment definitions.
defineFunction({
  type: "environment",
  names: ["\\begin", "\\end"],
  props: {
    numArgs: 1,
    argTypes: ["text"]
  },
  handler({ parser, funcName }, args) {
    const nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
      throw new ParseError("Invalid environment name", nameGroup);
    }
    let envName = "";
    for (let i = 0; i < nameGroup.body.length; ++i) {
      envName += assertNodeType(nameGroup.body[i], "textord").text;
    }

    if (funcName === "\\begin") {
      // begin...end is similar to left...right
      if (!Object.prototype.hasOwnProperty.call(environments, envName )) {
        throw new ParseError("No such environment: " + envName, nameGroup);
      }
      // Build the environment object. Arguments and other information will
      // be made available to the begin and end methods using properties.
      const env = environments[envName];
      const { args, optArgs } = parser.parseArguments("\\begin{" + envName + "}", env);
      const context = {
        mode: parser.mode,
        envName,
        parser
      };
      const result = env.handler(context, args, optArgs);
      parser.expect("\\end", false);
      const endNameToken = parser.nextToken;
      const end = assertNodeType(parser.parseFunction(), "environment");
      if (end.name !== envName) {
        throw new ParseError(
          `Mismatch: \\begin{${envName}} matched by \\end{${end.name}}`,
          endNameToken
        );
      }
      return result;
    }

    return {
      type: "environment",
      mode: parser.mode,
      name: envName,
      nameGroup
    };
  }
});

defineFunction({
  type: "envTag",
  names: ["\\env@tag"],
  props: {
    numArgs: 1,
    argTypes: ["math"]
  },
  handler({ parser }, args) {
    return {
      type: "envTag",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

defineFunction({
  type: "noTag",
  names: ["\\env@notag"],
  props: {
    numArgs: 0
  },
  handler({ parser }) {
    return {
      type: "noTag",
      mode: parser.mode
    };
  },
  mathmlBuilder(group, style) {
    return new mathMLTree.MathNode("mrow");
  }
});

const isLongVariableName = (group, font) => {
  if (font !== "mathrm" || group.body.type !== "ordgroup" || group.body.body.length === 1) {
    return false
  }
  if (group.body.body[0].type !== "mathord") { return false }
  for (let i = 1; i < group.body.body.length; i++) {
    const parseNodeType = group.body.body[i].type;
    if (!(parseNodeType ===  "mathord" ||
    (parseNodeType ===  "textord" && !isNaN(group.body.body[i].text)))) {
      return false
    }
  }
  return true
};

const mathmlBuilder$6 = (group, style) => {
  const font = group.font;
  const newStyle = style.withFont(font);
  const mathGroup = buildGroup$1(group.body, newStyle);

  if (mathGroup.children.length === 0) { return mathGroup } // empty group, e.g., \mathrm{}
  if (font === "boldsymbol" && ["mo", "mpadded", "mrow"].includes(mathGroup.type)) {
    mathGroup.style.fontWeight = "bold";
    return mathGroup
  }
  // Check if it is possible to consolidate elements into a single <mi> element.
  if (isLongVariableName(group, font)) {
    // This is a \mathrm{…} group. It gets special treatment because symbolsOrd.js
    // wraps <mi> elements with <mrow>s to work around a Firefox bug.
    const mi = mathGroup.children[0].children[0];
    delete mi.attributes.mathvariant;
    for (let i = 1; i < mathGroup.children.length; i++) {
      mi.children[0].text += mathGroup.children[i].type === "mn"
        ? mathGroup.children[i].children[0].text
        : mathGroup.children[i].children[0].children[0].text;
    }
    // Wrap in a <mrow> to prevent the same Firefox bug.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  let canConsolidate = mathGroup.children[0].type === "mo";
  for (let i = 1; i < mathGroup.children.length; i++) {
    if (mathGroup.children[i].type === "mo" && font === "boldsymbol") {
      mathGroup.children[i].style.fontWeight = "bold";
    }
    if (mathGroup.children[i].type !== "mi") { canConsolidate = false; }
    const localVariant = mathGroup.children[i].attributes &&
      mathGroup.children[i].attributes.mathvariant || "";
    if (localVariant !== "normal") { canConsolidate = false; }
  }
  if (!canConsolidate) { return mathGroup }
  // Consolidate the <mi> elements.
  const mi = mathGroup.children[0];
  for (let i = 1; i < mathGroup.children.length; i++) {
    mi.children.push(mathGroup.children[i].children[0]);
  }
  if (mi.attributes.mathvariant && mi.attributes.mathvariant === "normal") {
    // Workaround for a Firefox bug that renders spurious space around
    // a <mi mathvariant="normal">
    // Ref: https://bugs.webkit.org/show_bug.cgi?id=129097
    // We insert a text node that contains a zero-width space and wrap in an mrow.
    // TODO: Get rid of this <mi> workaround when the Firefox bug is fixed.
    const bogus = new mathMLTree.MathNode("mtext", new mathMLTree.TextNode("\u200b"));
    return new mathMLTree.MathNode("mrow", [bogus, mi])
  }
  return mi
};

const fontAliases = {
  "\\Bbb": "\\mathbb",
  "\\bold": "\\mathbf",
  "\\frak": "\\mathfrak",
  "\\bm": "\\boldsymbol"
};

defineFunction({
  type: "font",
  names: [
    // styles
    "\\mathrm",
    "\\mathit",
    "\\mathbf",
    "\\mathnormal",
    "\\up@greek",
    "\\boldsymbol",

    // families
    "\\mathbb",
    "\\mathcal",
    "\\mathfrak",
    "\\mathscr",
    "\\mathsf",
    "\\mathsfit",
    "\\mathtt",

    // aliases
    "\\Bbb",
    "\\bm",
    "\\bold",
    "\\frak"
  ],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = normalizeArgument(args[0]);
    let func = funcName;
    if (func in fontAliases) {
      func = fontAliases[func];
    }
    return {
      type: "font",
      mode: parser.mode,
      font: func.slice(1),
      body
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

// Old font changing functions
defineFunction({
  type: "font",
  names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ parser, funcName, breakOnTokenText }, args) => {
    const { mode } = parser;
    const body = parser.parseExpression(true, breakOnTokenText, true);
    const fontStyle = `math${funcName.slice(1)}`;

    return {
      type: "font",
      mode: mode,
      font: fontStyle,
      body: {
        type: "ordgroup",
        mode: parser.mode,
        body
      }
    };
  },
  mathmlBuilder: mathmlBuilder$6
});

const stylArray = ["display", "text", "script", "scriptscript"];
const scriptLevel = { auto: -1, display: 0, text: 0, script: 1, scriptscript: 2 };

const mathmlBuilder$5 = (group, style) => {
  // Track the scriptLevel of the numerator and denominator.
  // We may need that info for \mathchoice or for adjusting em dimensions.
  const childOptions = group.scriptLevel === "auto"
    ? style.incrementLevel()
    : group.scriptLevel === "display"
    ? style.withLevel(StyleLevel.TEXT)
    : group.scriptLevel === "text"
    ? style.withLevel(StyleLevel.SCRIPT)
    : style.withLevel(StyleLevel.SCRIPTSCRIPT);

  // Chromium (wrongly) continues to shrink fractions beyond scriptscriptlevel.
  // So we check for levels that Chromium shrinks too small.
  // If necessary, set an explicit fraction depth.
  const numer = buildGroup$1(group.numer, childOptions);
  const denom = buildGroup$1(group.denom, childOptions);
  if (style.level === 3) {
    numer.style.mathDepth = "2";
    numer.setAttribute("scriptlevel", "2");
    denom.style.mathDepth = "2";
    denom.setAttribute("scriptlevel", "2");
  }

  let node = new mathMLTree.MathNode("mfrac", [numer, denom]);

  if (!group.hasBarLine) {
    node.setAttribute("linethickness", "0px");
  } else if (group.barSize) {
    const ruleWidth = calculateSize(group.barSize, style);
    node.setAttribute("linethickness", ruleWidth.number + ruleWidth.unit);
  }

  if (group.leftDelim != null || group.rightDelim != null) {
    const withDelims = [];

    if (group.leftDelim != null) {
      const leftOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))
      ]);
      leftOp.setAttribute("fence", "true");
      withDelims.push(leftOp);
    }

    withDelims.push(node);

    if (group.rightDelim != null) {
      const rightOp = new mathMLTree.MathNode("mo", [
        new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))
      ]);
      rightOp.setAttribute("fence", "true");
      withDelims.push(rightOp);
    }

    node = makeRow(withDelims);
  }

  if (group.scriptLevel !== "auto") {
    node = new mathMLTree.MathNode("mstyle", [node]);
    node.setAttribute("displaystyle", String(group.scriptLevel === "display"));
    node.setAttribute("scriptlevel", scriptLevel[group.scriptLevel]);
  }

  return node;
};

defineFunction({
  type: "genfrac",
  names: [
    "\\dfrac",
    "\\frac",
    "\\tfrac",
    "\\dbinom",
    "\\binom",
    "\\tbinom",
    "\\\\atopfrac", // can’t be entered directly
    "\\\\bracefrac",
    "\\\\brackfrac" // ditto
  ],
  props: {
    numArgs: 2,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];
    let hasBarLine = false;
    let leftDelim = null;
    let rightDelim = null;
    let scriptLevel = "auto";

    switch (funcName) {
      case "\\dfrac":
      case "\\frac":
      case "\\tfrac":
        hasBarLine = true;
        break;
      case "\\\\atopfrac":
        hasBarLine = false;
        break;
      case "\\dbinom":
      case "\\binom":
      case "\\tbinom":
        leftDelim = "(";
        rightDelim = ")";
        break;
      case "\\\\bracefrac":
        leftDelim = "\\{";
        rightDelim = "\\}";
        break;
      case "\\\\brackfrac":
        leftDelim = "[";
        rightDelim = "]";
        break;
      default:
        throw new Error("Unrecognized genfrac command");
    }

    switch (funcName) {
      case "\\dfrac":
      case "\\dbinom":
        scriptLevel = "display";
        break;
      case "\\tfrac":
      case "\\tbinom":
        scriptLevel = "text";
        break;
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: false,
      numer,
      denom,
      hasBarLine,
      leftDelim,
      rightDelim,
      scriptLevel,
      barSize: null
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

defineFunction({
  type: "genfrac",
  names: ["\\cfrac"],
  props: {
    numArgs: 2
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const denom = args[1];

    return {
      type: "genfrac",
      mode: parser.mode,
      continued: true,
      numer,
      denom,
      hasBarLine: true,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "display",
      barSize: null
    };
  }
});

// Infix generalized fractions -- these are not rendered directly, but replaced
// immediately by one of the variants above.
defineFunction({
  type: "infix",
  names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
  props: {
    numArgs: 0,
    infix: true
  },
  handler({ parser, funcName, token }) {
    let replaceWith;
    switch (funcName) {
      case "\\over":
        replaceWith = "\\frac";
        break;
      case "\\choose":
        replaceWith = "\\binom";
        break;
      case "\\atop":
        replaceWith = "\\\\atopfrac";
        break;
      case "\\brace":
        replaceWith = "\\\\bracefrac";
        break;
      case "\\brack":
        replaceWith = "\\\\brackfrac";
        break;
      default:
        throw new Error("Unrecognized infix genfrac command");
    }
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith,
      token
    };
  }
});

const delimFromValue = function(delimString) {
  let delim = null;
  if (delimString.length > 0) {
    delim = delimString;
    delim = delim === "." ? null : delim;
  }
  return delim;
};

defineFunction({
  type: "genfrac",
  names: ["\\genfrac"],
  props: {
    numArgs: 6,
    allowedInArgument: true,
    argTypes: ["math", "math", "size", "text", "math", "math"]
  },
  handler({ parser }, args) {
    const numer = args[4];
    const denom = args[5];

    // Look into the parse nodes to get the desired delimiters.
    const leftNode = normalizeArgument(args[0]);
    const leftDelim = leftNode.type === "atom" && leftNode.family === "open"
      ? delimFromValue(leftNode.text)
      : null;
    const rightNode = normalizeArgument(args[1]);
    const rightDelim =
      rightNode.type === "atom" && rightNode.family === "close"
        ? delimFromValue(rightNode.text)
        : null;

    const barNode = assertNodeType(args[2], "size");
    let hasBarLine;
    let barSize = null;
    if (barNode.isBlank) {
      // \genfrac acts differently than \above.
      // \genfrac treats an empty size group as a signal to use a
      // standard bar size. \above would see size = 0 and omit the bar.
      hasBarLine = true;
    } else {
      barSize = barNode.value;
      hasBarLine = barSize.number > 0;
    }

    // Find out if we want displaystyle, textstyle, etc.
    let scriptLevel = "auto";
    let styl = args[3];
    if (styl.type === "ordgroup") {
      if (styl.body.length > 0) {
        const textOrd = assertNodeType(styl.body[0], "textord");
        scriptLevel = stylArray[Number(textOrd.text)];
      }
    } else {
      styl = assertNodeType(styl, "textord");
      scriptLevel = stylArray[Number(styl.text)];
    }

    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim,
      rightDelim,
      scriptLevel
    };
  },
  mathmlBuilder: mathmlBuilder$5
});

// \above is an infix fraction that also defines a fraction bar size.
defineFunction({
  type: "infix",
  names: ["\\above"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    infix: true
  },
  handler({ parser, funcName, token }, args) {
    return {
      type: "infix",
      mode: parser.mode,
      replaceWith: "\\\\abovefrac",
      barSize: assertNodeType(args[0], "size").value,
      token
    };
  }
});

defineFunction({
  type: "genfrac",
  names: ["\\\\abovefrac"],
  props: {
    numArgs: 3,
    argTypes: ["math", "size", "math"]
  },
  handler: ({ parser, funcName }, args) => {
    const numer = args[0];
    const barSize = assert(assertNodeType(args[1], "infix").barSize);
    const denom = args[2];

    const hasBarLine = barSize.number > 0;
    return {
      type: "genfrac",
      mode: parser.mode,
      numer,
      denom,
      continued: false,
      hasBarLine,
      barSize,
      leftDelim: null,
      rightDelim: null,
      scriptLevel: "auto"
    };
  },

  mathmlBuilder: mathmlBuilder$5
});

// \hbox is provided for compatibility with LaTeX functions that act on a box.
// This function by itself doesn't do anything but set scriptlevel to \textstyle
// and prevent a soft line break.

defineFunction({
  type: "hbox",
  names: ["\\hbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInArgument: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "hbox",
      mode: parser.mode,
      body: ordargument(args[0])
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = style.withLevel(StyleLevel.TEXT);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

const mathmlBuilder$4 = (group, style) => {
  const accentNode = stretchy.mathMLnode(group.label);
  accentNode.style["math-depth"] = 0;
  return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [
    buildGroup$1(group.base, style),
    accentNode
  ]);
};

// Horizontal stretchy braces
defineFunction({
  type: "horizBrace",
  names: ["\\overbrace", "\\underbrace"],
  props: {
    numArgs: 1
  },
  handler({ parser, funcName }, args) {
    return {
      type: "horizBrace",
      mode: parser.mode,
      label: funcName,
      isOver: /^\\over/.test(funcName),
      base: args[0]
    };
  },
  mathmlBuilder: mathmlBuilder$4
});

defineFunction({
  type: "href",
  names: ["\\href"],
  props: {
    numArgs: 2,
    argTypes: ["url", "original"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const body = args[1];
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\href",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\href" is not trusted`, token)
    }

    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const math = new MathNode("math", [buildExpressionRow(group.body, style)]);
    const anchorNode = new AnchorNode(group.href, [], [math]);
    return anchorNode
  }
});

defineFunction({
  type: "href",
  names: ["\\url"],
  props: {
    numArgs: 1,
    argTypes: ["url"],
    allowedInText: true
  },
  handler: ({ parser, token }, args) => {
    const href = assertNodeType(args[0], "url").url;

    if (
      !parser.settings.isTrusted({
        command: "\\url",
        url: href
      })
    ) {
      throw new ParseError(`Function "\\url" is not trusted`, token)
    }

    const chars = [];
    for (let i = 0; i < href.length; i++) {
      let c = href[i];
      if (c === "~") {
        c = "\\textasciitilde";
      }
      chars.push({
        type: "textord",
        mode: "text",
        text: c
      });
    }
    const body = {
      type: "text",
      mode: parser.mode,
      font: "\\texttt",
      body: chars
    };
    return {
      type: "href",
      mode: parser.mode,
      href,
      body: ordargument(body)
    };
  }
});

defineFunction({
  type: "html",
  names: ["\\class", "\\id", "\\style", "\\data"],
  props: {
    numArgs: 2,
    argTypes: ["raw", "original"],
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    const value = assertNodeType(args[0], "raw").string;
    const body = args[1];

    if (parser.settings.strict) {
      throw new ParseError(`Function "${funcName}" is disabled in strict mode`, token)
    }

    let trustContext;
    const attributes = {};

    switch (funcName) {
      case "\\class":
        attributes.class = value;
        trustContext = {
          command: "\\class",
          class: value
        };
        break;
      case "\\id":
        attributes.id = value;
        trustContext = {
          command: "\\id",
          id: value
        };
        break;
      case "\\style":
        attributes.style = value;
        trustContext = {
          command: "\\style",
          style: value
        };
        break;
      case "\\data": {
        const data = value.split(",");
        for (let i = 0; i < data.length; i++) {
          const keyVal = data[i].split("=");
          if (keyVal.length !== 2) {
            throw new ParseError("Error parsing key-value for \\data");
          }
          attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
        }

        trustContext = {
          command: "\\data",
          attributes
        };
        break;
      }
      default:
        throw new Error("Unrecognized html command");
    }

    if (!parser.settings.isTrusted(trustContext)) {
      throw new ParseError(`Function "${funcName}" is not trusted`, token)
    }
    return {
      type: "html",
      mode: parser.mode,
      attributes,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const element =  buildExpressionRow(group.body, style);

    const classes = [];
    if (group.attributes.class) {
      classes.push(...group.attributes.class.trim().split(/\s+/));
    }
    element.classes = classes;

    for (const attr in group.attributes) {
      if (attr !== "class" && Object.prototype.hasOwnProperty.call(group.attributes, attr)) {
        element.setAttribute(attr, group.attributes[attr]);
      }
    }

    return element;
  }
});

const sizeData = function(str) {
  if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
    // str is a number with no unit specified.
    // default unit is bp, per graphix package.
    return { number: +str, unit: "bp" }
  } else {
    const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
    if (!match) {
      throw new ParseError("Invalid size: '" + str + "' in \\includegraphics");
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
    }
    return data
  }
};

defineFunction({
  type: "includegraphics",
  names: ["\\includegraphics"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    argTypes: ["raw", "url"],
    allowedInText: false
  },
  handler: ({ parser, token }, args, optArgs) => {
    let width = { number: 0, unit: "em" };
    let height = { number: 0.9, unit: "em" };  // sorta character sized.
    let totalheight = { number: 0, unit: "em" };
    let alt = "";

    if (optArgs[0]) {
      const attributeStr = assertNodeType(optArgs[0], "raw").string;

      // Parser.js does not parse key/value pairs. We get a string.
      const attributes = attributeStr.split(",");
      for (let i = 0; i < attributes.length; i++) {
        const keyVal = attributes[i].split("=");
        if (keyVal.length === 2) {
          const str = keyVal[1].trim();
          switch (keyVal[0].trim()) {
            case "alt":
              alt = str;
              break
            case "width":
              width = sizeData(str);
              break
            case "height":
              height = sizeData(str);
              break
            case "totalheight":
              totalheight = sizeData(str);
              break
            default:
              throw new ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.")
          }
        }
      }
    }

    const src = assertNodeType(args[0], "url").url;

    if (alt === "") {
      // No alt given. Use the file name. Strip away the path.
      alt = src;
      alt = alt.replace(/^.*[\\/]/, "");
      alt = alt.substring(0, alt.lastIndexOf("."));
    }

    if (
      !parser.settings.isTrusted({
        command: "\\includegraphics",
        url: src
      })
    ) {
      throw new ParseError(`Function "\\includegraphics" is not trusted`, token)
    }

    return {
      type: "includegraphics",
      mode: parser.mode,
      alt: alt,
      width: width,
      height: height,
      totalheight: totalheight,
      src: src
    }
  },
  mathmlBuilder: (group, style) => {
    const height = calculateSize(group.height, style);
    const depth = { number: 0, unit: "em" };

    if (group.totalheight.number > 0) {
      if (group.totalheight.unit === height.unit &&
        group.totalheight.number > height.number) {
        depth.number = group.totalheight.number - height.number;
        depth.unit = height.unit;
      }
    }

    let width = 0;
    if (group.width.number > 0) {
      width = calculateSize(group.width, style);
    }

    const graphicStyle = { height: height.number + depth.number + "em" };
    if (width.number > 0) {
      graphicStyle.width = width.number + width.unit;
    }
    if (depth.number > 0) {
      graphicStyle.verticalAlign = -depth.number + depth.unit;
    }

    const node = new Img(group.src, group.alt, graphicStyle);
    node.height = height;
    node.depth = depth;
    return new mathMLTree.MathNode("mtext", [node])
  }
});

// Horizontal spacing commands


// TODO: \hskip and \mskip should support plus and minus in lengths

defineFunction({
  type: "kern",
  names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
  props: {
    numArgs: 1,
    argTypes: ["size"],
    primitive: true,
    allowedInText: true
  },
  handler({ parser, funcName, token }, args) {
    const size = assertNodeType(args[0], "size");
    if (parser.settings.strict) {
      const mathFunction = funcName[1] === "m"; // \mkern, \mskip
      const muUnit = size.value.unit === "mu";
      if (mathFunction) {
        if (!muUnit) {
          throw new ParseError(`LaTeX's ${funcName} supports only mu units, ` +
            `not ${size.value.unit} units`, token)
        }
        if (parser.mode !== "math") {
          throw new ParseError(`LaTeX's ${funcName} works only in math mode`, token)
        }
      } else {
        // !mathFunction
        if (muUnit) {
          throw new ParseError(`LaTeX's ${funcName} doesn't support mu units`, token)
        }
      }
    }
    return {
      type: "kern",
      mode: parser.mode,
      dimension: size.value
    };
  },
  mathmlBuilder(group, style) {
    const dimension = calculateSize(group.dimension, style);
    const ch = dimension.unit === "em" ? spaceCharacter(dimension.number) : "";
    if (group.mode === "text" && ch.length > 0) {
      const character = new mathMLTree.TextNode(ch);
      return new mathMLTree.MathNode("mtext", [character]);
    } else {
      const node = new mathMLTree.MathNode("mspace");
      node.setAttribute("width", dimension.number + dimension.unit);
      if (dimension.number < 0) {
        node.style.marginLeft = dimension.number + dimension.unit;
      }
      return node;
    }
  }
});

const spaceCharacter = function(width) {
  if (width >= 0.05555 && width <= 0.05556) {
    return "\u200a"; // &VeryThinSpace;
  } else if (width >= 0.1666 && width <= 0.1667) {
    return "\u2009"; // &ThinSpace;
  } else if (width >= 0.2222 && width <= 0.2223) {
    return "\u2005"; // &MediumSpace;
  } else if (width >= 0.2777 && width <= 0.2778) {
    return "\u2005\u200a"; // &ThickSpace;
  } else {
    return "";
  }
};

// Limit valid characters to a small set, for safety.
const invalidIdRegEx = /[^A-Za-z_0-9-]/g;

defineFunction({
  type: "label",
  names: ["\\label"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser }, args) {
    return {
      type: "label",
      mode: parser.mode,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Return a no-width, no-ink element with an HTML id.
    const node = new mathMLTree.MathNode("mrow", [], ["tml-label"]);
    if (group.string.length > 0) {
      node.setLabel(group.string);
    }
    return node
  }
});

// Horizontal overlap functions

const textModeLap = ["\\clap", "\\llap", "\\rlap"];

defineFunction({
  type: "lap",
  names: ["\\mathllap", "\\mathrlap", "\\mathclap", "\\clap", "\\llap", "\\rlap"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser, funcName, token }, args) => {
    if (textModeLap.includes(funcName)) {
      if (parser.settings.strict && parser.mode !== "text") {
        throw new ParseError(`{${funcName}} can be used only in text mode.
 Try \\math${funcName.slice(1)}`, token)
      }
      funcName = funcName.slice(1);
    } else {
      funcName = funcName.slice(5);
    }
    const body = args[0];
    return {
      type: "lap",
      mode: parser.mode,
      alignment: funcName,
      body
    }
  },
  mathmlBuilder: (group, style) => {
    // mathllap, mathrlap, mathclap
    let strut;
    if (group.alignment === "llap") {
      // We need an invisible strut with the same depth as the group.
      // We can't just read the depth, so we use \vphantom methods.
      const phantomInner = buildExpression(ordargument(group.body), style);
      const phantom = new mathMLTree.MathNode("mphantom", phantomInner);
      strut = new mathMLTree.MathNode("mpadded", [phantom]);
      strut.setAttribute("width", "0px");
    }

    const inner = buildGroup$1(group.body, style);
    let node;
    if (group.alignment === "llap") {
      inner.style.position = "absolute";
      inner.style.right = "0";
      inner.style.bottom = `0`; // If we could have read the ink depth, it would go here.
      node = new mathMLTree.MathNode("mpadded", [strut, inner]);
    } else {
      node = new mathMLTree.MathNode("mpadded", [inner]);
    }

    if (group.alignment === "rlap") {
      if (group.body.body.length > 0 && group.body.body[0].type === "genfrac") {
        // In Firefox, a <mpadded> squashes the 3/18em padding of a child \frac. Put it back.
        node.setAttribute("lspace", "0.16667em");
      }
    } else {
      const offset = group.alignment === "llap" ? "-1" : "-0.5";
      node.setAttribute("lspace", offset + "width");
      if (group.alignment === "llap") {
        node.style.position = "relative";
      } else {
        node.style.display = "flex";
        node.style.justifyContent = "center";
      }
    }
    node.setAttribute("width", "0px");
    return node
  }
});

// Switching from text mode back to math mode
defineFunction({
  type: "ordgroup",
  names: ["\\(", "$"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler({ funcName, parser }, args) {
    const outerMode = parser.mode;
    parser.switchMode("math");
    const close = funcName === "\\(" ? "\\)" : "$";
    const body = parser.parseExpression(false, close);
    parser.expect(close);
    parser.switchMode(outerMode);
    return {
      type: "ordgroup",
      mode: parser.mode,
      body
    };
  }
});

// Check for extra closing math delimiters
defineFunction({
  type: "text", // Doesn't matter what this is.
  names: ["\\)", "\\]"],
  props: {
    numArgs: 0,
    allowedInText: true,
    allowedInMath: false
  },
  handler(context, token) {
    throw new ParseError(`Mismatched ${context.funcName}`, token);
  }
});

const chooseStyle = (group, style) => {
  switch (style.level) {
    case StyleLevel.DISPLAY:       // 0
      return group.display;
    case StyleLevel.TEXT:          // 1
      return group.text;
    case StyleLevel.SCRIPT:        // 2
      return group.script;
    case StyleLevel.SCRIPTSCRIPT:  // 3
      return group.scriptscript;
    default:
      return group.text;
  }
};

defineFunction({
  type: "mathchoice",
  names: ["\\mathchoice"],
  props: {
    numArgs: 4,
    primitive: true
  },
  handler: ({ parser }, args) => {
    return {
      type: "mathchoice",
      mode: parser.mode,
      display: ordargument(args[0]),
      text: ordargument(args[1]),
      script: ordargument(args[2]),
      scriptscript: ordargument(args[3])
    };
  },
  mathmlBuilder: (group, style) => {
    const body = chooseStyle(group, style);
    return buildExpressionRow(body, style);
  }
});

const textAtomTypes = ["text", "textord", "mathord", "atom"];

function mathmlBuilder$3(group, style) {
  let node;
  const inner = buildExpression(group.body, style);

  if (group.mclass === "minner") {
    node = new mathMLTree.MathNode("mpadded", inner);
  } else if (group.mclass === "mord") {
    if (group.isCharacterBox || inner[0].type === "mathord") {
      node = inner[0];
      node.type = "mi";
      if (node.children.length === 1 && node.children[0].text && node.children[0].text === "∇") {
        node.setAttribute("mathvariant", "normal");
      }
    } else {
      node = new mathMLTree.MathNode("mi", inner);
    }
  } else {
    node = new mathMLTree.MathNode("mrow", inner);
    if (group.mustPromote) {
      node = inner[0];
      node.type = "mo";
      if (group.isCharacterBox && group.body[0].text && /[A-Za-z]/.test(group.body[0].text)) {
        node.setAttribute("mathvariant", "italic");
      }
    } else {
      node = new mathMLTree.MathNode("mrow", inner);
    }

    // Set spacing based on what is the most likely adjacent atom type.
    // See TeXbook p170.
    const doSpacing = style.level < 2; // Operator spacing is zero inside a (sub|super)script.
    if (node.type === "mrow") {
      if (doSpacing ) {
        if (group.mclass === "mbin") {
          // medium space
          node.children.unshift(padding$1(0.2222));
          node.children.push(padding$1(0.2222));
        } else if (group.mclass === "mrel") {
          // thickspace
          node.children.unshift(padding$1(0.2778));
          node.children.push(padding$1(0.2778));
        } else if (group.mclass === "mpunct") {
          node.children.push(padding$1(0.1667));
        } else if (group.mclass === "minner") {
          node.children.unshift(padding$1(0.0556));  // 1 mu is the most likely option
          node.children.push(padding$1(0.0556));
        }
      }
    } else {
      if (group.mclass === "mbin") {
        // medium space
        node.attributes.lspace = (doSpacing ? "0.2222em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2222em" : "0");
      } else if (group.mclass === "mrel") {
        // thickspace
        node.attributes.lspace = (doSpacing ? "0.2778em" : "0");
        node.attributes.rspace = (doSpacing ? "0.2778em" : "0");
      } else if (group.mclass === "mpunct") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = (doSpacing ? "0.1667em" : "0");
      } else if (group.mclass === "mopen" || group.mclass === "mclose") {
        node.attributes.lspace = "0em";
        node.attributes.rspace = "0em";
      } else if (group.mclass === "minner" && doSpacing) {
        node.attributes.lspace = "0.0556em"; // 1 mu is the most likely option
        node.attributes.width = "+0.1111em";
      }
    }

    if (!(group.mclass === "mopen" || group.mclass === "mclose")) {
      delete node.attributes.stretchy;
      delete node.attributes.form;
    }
  }
  return node;
}

// Math class commands except \mathop
defineFunction({
  type: "mclass",
  names: [
    "\\mathord",
    "\\mathbin",
    "\\mathrel",
    "\\mathopen",
    "\\mathclose",
    "\\mathpunct",
    "\\mathinner"
  ],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    const isCharacterBox = utils.isCharacterBox(body);
    // We should not wrap a <mo> around a <mi> or <mord>. That would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    let mustPromote = true;
    const mord = { type: "mathord", text: "", mode: parser.mode };
    const arr = (body.body) ? body.body : [body];
    for (const arg of arr) {
      if (textAtomTypes.includes(arg.type)) {
        if (symbols[parser.mode][arg.text]) {
          mord.text += symbols[parser.mode][arg.text].replace;
        } else if (arg.text) {
          mord.text += arg.text;
        } else if (arg.body) {
          arg.body.map(e => { mord.text += e.text; });
        }
      } else {
        mustPromote = false;
        break
      }
    }
    if (mustPromote && funcName === "\\mathord" && mord.type === "mathord"
                    && mord.text.length > 1) {
      return mord
    } else {
      return {
        type: "mclass",
        mode: parser.mode,
        mclass: "m" + funcName.slice(5),
        body: ordargument(mustPromote ? mord : body),
        isCharacterBox,
        mustPromote
      };
    }
  },
  mathmlBuilder: mathmlBuilder$3
});

const binrelClass = (arg) => {
  // \binrel@ spacing varies with (bin|rel|ord) of the atom in the argument.
  // (by rendering separately and with {}s before and after, and measuring
  // the change in spacing).  We'll do roughly the same by detecting the
  // atom type directly.
  const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
  if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
    return "m" + atom.family;
  } else {
    return "mord";
  }
};

// \@binrel{x}{y} renders like y but as mbin/mrel/mord if x is mbin/mrel/mord.
// This is equivalent to \binrel@{x}\binrel@@{y} in AMSTeX.
defineFunction({
  type: "mclass",
  names: ["\\@binrel"],
  props: {
    numArgs: 2
  },
  handler({ parser }, args) {
    return {
      type: "mclass",
      mode: parser.mode,
      mclass: binrelClass(args[0]),
      body: ordargument(args[1]),
      isCharacterBox: utils.isCharacterBox(args[1])
    };
  }
});

// Build a relation or stacked op by placing one symbol on top of another
defineFunction({
  type: "mclass",
  names: ["\\stackrel", "\\overset", "\\underset"],
  props: {
    numArgs: 2
  },
  handler({ parser, funcName }, args) {
    const baseArg = args[1];
    const shiftedArg = args[0];

    const baseOp = {
      type: "op",
      mode: baseArg.mode,
      limits: true,
      alwaysHandleSupSub: true,
      parentIsSupSub: false,
      symbol: false,
      stack: true,
      suppressBaseShift: funcName !== "\\stackrel",
      body: ordargument(baseArg)
    };

    return {
      type: "supsub",
      mode: shiftedArg.mode,
      base: baseOp,
      sup: funcName === "\\underset" ? null : shiftedArg,
      sub: funcName === "\\underset" ? shiftedArg : null
    };
  },
  mathmlBuilder: mathmlBuilder$3
});

// Helper function
const buildGroup = (el, style, noneNode) => {
  if (!el) { return noneNode }
  const node = buildGroup$1(el, style);
  if (node.type === "mrow" && node.children.length === 0) { return noneNode }
  return node
};

defineFunction({
  type: "multiscript",
  names: ["\\sideset", "\\pres@cript"], // See macros.js for \prescript
  props: {
    numArgs: 3
  },
  handler({ parser, funcName, token }, args) {
    if (args[2].body.length === 0) {
      throw new ParseError(funcName + `cannot parse an empty base.`)
    }
    const base = args[2].body[0];
    if (parser.settings.strict && funcName === "\\sideset" && !base.symbol) {
      throw new ParseError(`The base of \\sideset must be a big operator. Try \\prescript.`)
    }

    if ((args[0].body.length > 0 && args[0].body[0].type !== "supsub") ||
        (args[1].body.length > 0 && args[1].body[0].type !== "supsub")) {
      throw new ParseError("\\sideset can parse only subscripts and " +
                            "superscripts in its first two arguments", token)
    }

    // The prescripts and postscripts come wrapped in a supsub.
    const prescripts = args[0].body.length > 0 ? args[0].body[0] : null;
    const postscripts = args[1].body.length > 0 ? args[1].body[0] : null;

    if (!prescripts && !postscripts) {
      return base
    } else if (!prescripts) {
      // It's not a multi-script. Get a \textstyle supsub.
      return {
        type: "styling",
        mode: parser.mode,
        scriptLevel: "text",
        body: [{
          type: "supsub",
          mode: parser.mode,
          base,
          sup: postscripts.sup,
          sub: postscripts.sub
        }]
      }
    } else {
      return {
        type: "multiscript",
        mode: parser.mode,
        isSideset: funcName === "\\sideset",
        prescripts,
        postscripts,
        base
      }
    }
  },
  mathmlBuilder(group, style) {
    const base =  buildGroup$1(group.base, style);

    const prescriptsNode = new mathMLTree.MathNode("mprescripts");
    const noneNode = new mathMLTree.MathNode("none");
    let children = [];

    const preSub = buildGroup(group.prescripts.sub, style, noneNode);
    const preSup = buildGroup(group.prescripts.sup, style, noneNode);
    if (group.isSideset) {
      // This seems silly, but LaTeX does this. Firefox ignores it, which does not make me sad.
      preSub.setAttribute("style", "text-align: left;");
      preSup.setAttribute("style", "text-align: left;");
    }

    if (group.postscripts) {
      const postSub = buildGroup(group.postscripts.sub, style, noneNode);
      const postSup = buildGroup(group.postscripts.sup, style, noneNode);
      children = [base, postSub, postSup, prescriptsNode, preSub, preSup];
    } else {
      children = [base, prescriptsNode, preSub, preSup];
    }

    return new mathMLTree.MathNode("mmultiscripts", children);
  }
});

defineFunction({
  type: "not",
  names: ["\\not"],
  props: {
    numArgs: 1,
    primitive: true,
    allowedInText: false
  },
  handler({ parser }, args) {
    const isCharacterBox = utils.isCharacterBox(args[0]);
    let body;
    if (isCharacterBox) {
      body = ordargument(args[0]);
      if (body[0].text.charAt(0) === "\\") {
        body[0].text = symbols.math[body[0].text].replace;
      }
      // \u0338 is the Unicode Combining Long Solidus Overlay
      body[0].text = body[0].text.slice(0, 1) + "\u0338" + body[0].text.slice(1);
    } else {
      // When the argument is not a character box, TeX does an awkward, poorly placed overlay.
      // We'll do the same.
      const notNode = { type: "textord", mode: "math", text: "\u0338" };
      const kernNode = { type: "kern", mode: "math", dimension: { number: -0.6, unit: "em" } };
      body = [notNode, kernNode, args[0]];
    }
    return {
      type: "not",
      mode: parser.mode,
      body,
      isCharacterBox
    };
  },
  mathmlBuilder(group, style) {
    if (group.isCharacterBox) {
      const inner = buildExpression(group.body, style, true);
      return inner[0]
    } else {
      return buildExpressionRow(group.body, style)
    }
  }
});

// Limits, symbols

// Some helpers

const ordAtomTypes = ["textord", "mathord", "atom"];

// Most operators have a large successor symbol, but these don't.
const noSuccessor = ["\\smallint"];

// Math operators (e.g. \sin) need a space between these types and themselves:
const ordTypes = ["textord", "mathord", "ordgroup", "close", "leftright", "font"];

// NOTE: Unlike most `builders`s, this one handles not only "op", but also
// "supsub" since some of them (like \int) can affect super/subscripting.

const setSpacing = node => {
  // The user wrote a \mathop{…} function. Change spacing from default to OP spacing.
  // The most likely spacing for an OP is a thin space per TeXbook p170.
  node.attributes.lspace = "0.1667em";
  node.attributes.rspace = "0.1667em";
};

const mathmlBuilder$2 = (group, style) => {
  let node;

  if (group.symbol) {
    // This is a symbol. Just add the symbol.
    node = new MathNode("mo", [makeText(group.name, group.mode)]);
    if (noSuccessor.includes(group.name)) {
      node.setAttribute("largeop", "false");
    } else {
      node.setAttribute("movablelimits", "false");
    }
    if (group.fromMathOp) { setSpacing(node); }
  } else if (group.body) {
    // This is an operator with children. Add them.
    node = new MathNode("mo", buildExpression(group.body, style));
    if (group.fromMathOp) { setSpacing(node); }
  } else {
    // This is a text operator. Add all of the characters from the operator's name.
    node = new MathNode("mi", [new TextNode(group.name.slice(1))]);

    if (!group.parentIsSupSub) {
      // Append an invisible <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new MathNode("mo", [makeText("\u2061", "text")]);
      const row = [node, operator];
      // Set spacing
      if (group.needsLeadingSpace) {
        const lead = new MathNode("mspace");
        lead.setAttribute("width", "0.1667em"); // thin space.
        row.unshift(lead);
      }
      if (!group.isFollowedByDelimiter) {
        const trail = new MathNode("mspace");
        trail.setAttribute("width", "0.1667em"); // thin space.
        row.push(trail);
      }
      node = new MathNode("mrow", row);
    }
  }

  return node;
};

const singleCharBigOps = {
  "\u220F": "\\prod",
  "\u2210": "\\coprod",
  "\u2211": "\\sum",
  "\u22c0": "\\bigwedge",
  "\u22c1": "\\bigvee",
  "\u22c2": "\\bigcap",
  "\u22c3": "\\bigcup",
  "\u2a00": "\\bigodot",
  "\u2a01": "\\bigoplus",
  "\u2a02": "\\bigotimes",
  "\u2a04": "\\biguplus",
  "\u2a05": "\\bigsqcap",
  "\u2a06": "\\bigsqcup",
  "\u2a03": "\\bigcupdot",
  "\u2a07": "\\bigdoublevee",
  "\u2a08": "\\bigdoublewedge",
  "\u2a09": "\\bigtimes"
};

defineFunction({
  type: "op",
  names: [
    "\\coprod",
    "\\bigvee",
    "\\bigwedge",
    "\\biguplus",
    "\\bigcupplus",
    "\\bigcupdot",
    "\\bigcap",
    "\\bigcup",
    "\\bigdoublevee",
    "\\bigdoublewedge",
    "\\intop",
    "\\prod",
    "\\sum",
    "\\bigotimes",
    "\\bigoplus",
    "\\bigodot",
    "\\bigsqcap",
    "\\bigsqcup",
    "\\bigtimes",
    "\\smallint",
    "\u220F",
    "\u2210",
    "\u2211",
    "\u22c0",
    "\u22c1",
    "\u22c2",
    "\u22c3",
    "\u2a00",
    "\u2a01",
    "\u2a02",
    "\u2a04",
    "\u2a06"
  ],
  props: {
    numArgs: 0
  },
  handler: ({ parser, funcName }, args) => {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharBigOps[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: true,
      stack: false, // This is true for \stackrel{}, not here.
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Note: calling defineFunction with a type that's already been defined only
// works because the same mathmlBuilder is being used.
defineFunction({
  type: "op",
  names: ["\\mathop"],
  props: {
    numArgs: 1,
    primitive: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    // It would be convienient to just wrap a <mo> around the argument.
    // But if the argument is a <mi> or <mord>, that would be invalid MathML.
    // In that case, we instead promote the text contents of the body to the parent.
    const arr = (body.body) ? body.body : [body];
    const isSymbol = arr.length === 1 && ordAtomTypes.includes(arr[0].type);
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: isSymbol,
      fromMathOp: true,
      stack: false,
      name: isSymbol ? arr[0].text : null,
      body: isSymbol ? null : ordargument(body)
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

const singleCharIntegrals = {
  "\u222b": "\\int",
  "\u222c": "\\iint",
  "\u222d": "\\iiint",
  "\u222e": "\\oint",
  "\u222f": "\\oiint",
  "\u2230": "\\oiiint",
  "\u2231": "\\intclockwise",
  "\u2232": "\\varointclockwise",
  "\u2a0c": "\\iiiint",
  "\u2a0d": "\\intbar",
  "\u2a0e": "\\intBar",
  "\u2a0f": "\\fint",
  "\u2a12": "\\rppolint",
  "\u2a13": "\\scpolint",
  "\u2a15": "\\pointint",
  "\u2a16": "\\sqint",
  "\u2a17": "\\intlarhk",
  "\u2a18": "\\intx",
  "\u2a19": "\\intcap",
  "\u2a1a": "\\intcup"
};

// No limits, not symbols
defineFunction({
  type: "op",
  names: [
    "\\arcsin",
    "\\arccos",
    "\\arctan",
    "\\arctg",
    "\\arcctg",
    "\\arg",
    "\\ch",
    "\\cos",
    "\\cosec",
    "\\cosh",
    "\\cot",
    "\\cotg",
    "\\coth",
    "\\csc",
    "\\ctg",
    "\\cth",
    "\\deg",
    "\\dim",
    "\\exp",
    "\\hom",
    "\\ker",
    "\\lg",
    "\\ln",
    "\\log",
    "\\sec",
    "\\sin",
    "\\sinh",
    "\\sh",
    "\\sgn",
    "\\tan",
    "\\tanh",
    "\\tg",
    "\\th"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// Limits, not symbols
defineFunction({
  type: "op",
  names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "op",
      mode: parser.mode,
      limits: true,
      parentIsSupSub: false,
      symbol: false,
      stack: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType),
      name: funcName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// No limits, symbols
defineFunction({
  type: "op",
  names: [
    "\\int",
    "\\iint",
    "\\iiint",
    "\\iiiint",
    "\\oint",
    "\\oiint",
    "\\oiiint",
    "\\intclockwise",
    "\\varointclockwise",
    "\\intbar",
    "\\intBar",
    "\\fint",
    "\\rppolint",
    "\\scpolint",
    "\\pointint",
    "\\sqint",
    "\\intlarhk",
    "\\intx",
    "\\intcap",
    "\\intcup",
    "\u222b",
    "\u222c",
    "\u222d",
    "\u222e",
    "\u222f",
    "\u2230",
    "\u2231",
    "\u2232",
    "\u2a0c",
    "\u2a0d",
    "\u2a0e",
    "\u2a0f",
    "\u2a12",
    "\u2a13",
    "\u2a15",
    "\u2a16",
    "\u2a17",
    "\u2a18",
    "\u2a19",
    "\u2a1a"
  ],
  props: {
    numArgs: 0
  },
  handler({ parser, funcName }) {
    let fName = funcName;
    if (fName.length === 1) {
      fName = singleCharIntegrals[fName];
    }
    return {
      type: "op",
      mode: parser.mode,
      limits: false,
      parentIsSupSub: false,
      symbol: true,
      stack: false,
      name: fName
    };
  },
  mathmlBuilder: mathmlBuilder$2
});

// NOTE: Unlike most builders, this one handles not only
// "operatorname", but also  "supsub" since \operatorname* can
// affect super/subscripting.

const mathmlBuilder$1 = (group, style) => {
  let expression = buildExpression(group.body, style.withFont("mathrm"));

  // Is expression a string or has it something like a fraction?
  let isAllString = true; // default
  for (let i = 0; i < expression.length; i++) {
    let node = expression[i];
    if (node instanceof mathMLTree.MathNode) {
      if ((node.type === "mrow" || node.type === "mpadded") && node.children.length === 1 &&
          node.children[0] instanceof mathMLTree.MathNode) {
        node = node.children[0];
      }
      switch (node.type) {
        case "mi":
        case "mn":
        case "ms":
        case "mtext":
          break; // Do nothing yet.
        case "mspace":
          {
            if (node.attributes.width) {
              const width = node.attributes.width.replace("em", "");
              const ch = spaceCharacter(Number(width));
              if (ch === "") {
                isAllString = false;
              } else {
                expression[i] = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(ch)]);
              }
            }
          }
          break
        case "mo": {
          const child = node.children[0];
          if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
            child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
          } else {
            isAllString = false;
          }
          break
        }
        default:
          isAllString = false;
      }
    } else {
      isAllString = false;
    }
  }

  if (isAllString) {
    // Write a single TextNode instead of multiple nested tags.
    const word = expression.map((node) => node.toText()).join("");
    expression = [new mathMLTree.TextNode(word)];
  } else if (
    expression.length === 1
    && ["mover", "munder"].includes(expression[0].type) &&
    (expression[0].children[0].type === "mi" || expression[0].children[0].type === "mtext")
  ) {
    expression[0].children[0].type = "mi";
    if (group.parentIsSupSub) {
      return new mathMLTree.MathNode("mrow", expression)
    } else {
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      return mathMLTree.newDocumentFragment([expression[0], operator])
    }
  }

  let wrapper;
  if (isAllString) {
    wrapper = new mathMLTree.MathNode("mi", expression);
    if (expression[0].text.length === 1) {
      wrapper.setAttribute("mathvariant", "normal");
    }
  } else {
    wrapper = new mathMLTree.MathNode("mrow", expression);
  }

  if (!group.parentIsSupSub) {
    // Append an <mo>&ApplyFunction;</mo>.
    // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
    const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
    const fragment = [wrapper, operator];
    if (group.needsLeadingSpace) {
      // LaTeX gives operator spacing, but a <mi> gets ord spacing.
      // So add a leading space.
      const space = new mathMLTree.MathNode("mspace");
      space.setAttribute("width", "0.1667em"); // thin space.
      fragment.unshift(space);
    }
    if (!group.isFollowedByDelimiter) {
      const trail = new mathMLTree.MathNode("mspace");
      trail.setAttribute("width", "0.1667em"); // thin space.
      fragment.push(trail);
    }
    return mathMLTree.newDocumentFragment(fragment)
  }

  return wrapper
};

// \operatorname
// amsopn.dtx: \mathop{#1\kern\z@\operator@font#3}\newmcodes@
defineFunction({
  type: "operatorname",
  names: ["\\operatorname@", "\\operatornamewithlimits"],
  props: {
    numArgs: 1,
    allowedInArgument: true
  },
  handler: ({ parser, funcName }, args) => {
    const body = args[0];
    const prevAtomType = parser.prevAtomType;
    const next = parser.gullet.future().text;
    return {
      type: "operatorname",
      mode: parser.mode,
      body: ordargument(body),
      alwaysHandleSupSub: (funcName === "\\operatornamewithlimits"),
      limits: false,
      parentIsSupSub: false,
      isFollowedByDelimiter: isDelimiter(next),
      needsLeadingSpace: prevAtomType.length > 0 && ordTypes.includes(prevAtomType)
    };
  },
  mathmlBuilder: mathmlBuilder$1
});

defineMacro("\\operatorname",
  "\\@ifstar\\operatornamewithlimits\\operatorname@");

defineFunctionBuilders({
  type: "ordgroup",
  mathmlBuilder(group, style) {
    return buildExpressionRow(group.body, style, group.semisimple);
  }
});

defineFunction({
  type: "phantom",
  names: ["\\phantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "phantom",
      mode: parser.mode,
      body: ordargument(body)
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(group.body, style);
    return new mathMLTree.MathNode("mphantom", inner);
  }
});

defineFunction({
  type: "hphantom",
  names: ["\\hphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "hphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("height", "0px");
    node.setAttribute("depth", "0px");
    return node;
  }
});

defineFunction({
  type: "vphantom",
  names: ["\\vphantom"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args) => {
    const body = args[0];
    return {
      type: "vphantom",
      mode: parser.mode,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const inner = buildExpression(ordargument(group.body), style);
    const phantom = new mathMLTree.MathNode("mphantom", inner);
    const node = new mathMLTree.MathNode("mpadded", [phantom]);
    node.setAttribute("width", "0px");
    return node;
  }
});

// In LaTeX, \pmb is a simulation of bold font.
// The version of \pmb in ambsy.sty works by typesetting three copies of the argument
// with small offsets. We use CSS font-weight:bold.

defineFunction({
  type: "pmb",
  names: ["\\pmb"],
  props: {
    numArgs: 1,
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "pmb",
      mode: parser.mode,
      body: ordargument(args[0])
    }
  },
  mathmlBuilder(group, style) {
    const inner = buildExpression(group.body, style);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    node.setAttribute("style", "font-weight:bold");
    return node
  }
});

// \raise, \lower, and \raisebox

const mathmlBuilder = (group, style) => {
  const newStyle = style.withLevel(StyleLevel.TEXT);
  const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, newStyle)]);
  const dy = calculateSize(group.dy, style);
  node.setAttribute("voffset", dy.number + dy.unit);
  // Add padding, which acts to increase height in Chromium.
  // TODO: Figure out some way to change height in Firefox w/o breaking Chromium.
  if (dy.number > 0) {
    node.style.padding = dy.number + dy.unit + " 0 0 0";
  } else {
    node.style.padding = "0 0 " + Math.abs(dy.number) + dy.unit + " 0";
  }
  return node
};

defineFunction({
  type: "raise",
  names: ["\\raise", "\\lower"],
  props: {
    numArgs: 2,
    argTypes: ["size", "primitive"],
    primitive: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    if (funcName === "\\lower") { amount.number *= -1; }
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});


defineFunction({
  type: "raise",
  names: ["\\raisebox"],
  props: {
    numArgs: 2,
    argTypes: ["size", "hbox"],
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const amount = assertNodeType(args[0], "size").value;
    const body = args[1];
    return {
      type: "raise",
      mode: parser.mode,
      dy: amount,
      body
    };
  },
  mathmlBuilder
});

defineFunction({
  type: "ref",
  names: ["\\ref", "\\eqref"],
  props: {
    numArgs: 1,
    argTypes: ["raw"]
  },
  handler({ parser, funcName }, args) {
    return {
      type: "ref",
      mode: parser.mode,
      funcName,
      string: args[0].string.replace(invalidIdRegEx, "")
    };
  },
  mathmlBuilder(group, style) {
    // Create an empty <a> node. Set a class and an href attribute.
    // The post-processor will populate with the target's tag or equation number.
    const classes = group.funcName === "\\ref" ? ["tml-ref"] : ["tml-ref", "tml-eqref"];
    return new AnchorNode("#" + group.string, classes, null)
  }
});

defineFunction({
  type: "reflect",
  names: ["\\reflectbox"],
  props: {
    numArgs: 1,
    argTypes: ["hbox"],
    allowedInText: true
  },
  handler({ parser }, args) {
    return {
      type: "reflect",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    const node = buildGroup$1(group.body, style);
    node.style.transform = "scaleX(-1)";
    return node
  }
});

defineFunction({
  type: "internal",
  names: ["\\relax"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler({ parser }) {
    return {
      type: "internal",
      mode: parser.mode
    };
  }
});

defineFunction({
  type: "rule",
  names: ["\\rule"],
  props: {
    numArgs: 2,
    numOptionalArgs: 1,
    allowedInText: true,
    allowedInMath: true,
    argTypes: ["size", "size", "size"]
  },
  handler({ parser }, args, optArgs) {
    const shift = optArgs[0];
    const width = assertNodeType(args[0], "size");
    const height = assertNodeType(args[1], "size");
    return {
      type: "rule",
      mode: parser.mode,
      shift: shift && assertNodeType(shift, "size").value,
      width: width.value,
      height: height.value
    };
  },
  mathmlBuilder(group, style) {
    const width = calculateSize(group.width, style);
    const height = calculateSize(group.height, style);
    const shift = group.shift
      ? calculateSize(group.shift, style)
      : { number: 0, unit: "em" };
    const color = (style.color && style.getColor()) || "black";

    const rule = new mathMLTree.MathNode("mspace");
    if (width.number > 0 && height.number > 0) {
      rule.setAttribute("mathbackground", color);
    }
    rule.setAttribute("width", width.number + width.unit);
    rule.setAttribute("height", height.number + height.unit);
    if (shift.number === 0) { return rule }

    const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
    if (shift.number >= 0) {
      wrapper.setAttribute("height", "+" + shift.number + shift.unit);
    } else {
      wrapper.setAttribute("height", shift.number + shift.unit);
      wrapper.setAttribute("depth", "+" + -shift.number + shift.unit);
    }
    wrapper.setAttribute("voffset", shift.number + shift.unit);
    return wrapper;
  }
});

// The size mappings are taken from TeX with \normalsize=10pt.
// We don't have to track script level. MathML does that.
const sizeMap = {
  "\\tiny": 0.5,
  "\\sixptsize": 0.6,
  "\\Tiny": 0.6,
  "\\scriptsize": 0.7,
  "\\footnotesize": 0.8,
  "\\small": 0.9,
  "\\normalsize": 1.0,
  "\\large": 1.2,
  "\\Large": 1.44,
  "\\LARGE": 1.728,
  "\\huge": 2.074,
  "\\Huge": 2.488
};

defineFunction({
  type: "sizing",
  names: [
    "\\tiny",
    "\\sixptsize",
    "\\Tiny",
    "\\scriptsize",
    "\\footnotesize",
    "\\small",
    "\\normalsize",
    "\\large",
    "\\Large",
    "\\LARGE",
    "\\huge",
    "\\Huge"
  ],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler: ({ breakOnTokenText, funcName, parser }, args) => {
    if (parser.settings.strict && parser.mode === "math") {
      // eslint-disable-next-line no-console
      console.log(`Temml strict-mode warning: Command ${funcName} is invalid in math mode.`);
    }
    const body = parser.parseExpression(false, breakOnTokenText, true);
    return {
      type: "sizing",
      mode: parser.mode,
      funcName,
      body
    };
  },
  mathmlBuilder: (group, style) => {
    const newStyle = style.withFontSize(sizeMap[group.funcName]);
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);
    const factor = (sizeMap[group.funcName] / style.fontSize).toFixed(4);
    node.setAttribute("mathsize", factor + "em");
    return node;
  }
});

// smash, with optional [tb], as in AMS

defineFunction({
  type: "smash",
  names: ["\\smash"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1,
    allowedInText: true
  },
  handler: ({ parser }, args, optArgs) => {
    let smashHeight = false;
    let smashDepth = false;
    const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
    if (tbArg) {
      // Optional [tb] argument is engaged.
      // ref: amsmath: \renewcommand{\smash}[1][tb]{%
      //               def\mb@t{\ht}\def\mb@b{\dp}\def\mb@tb{\ht\z@\z@\dp}%
      let letter = "";
      for (let i = 0; i < tbArg.body.length; ++i) {
        const node = tbArg.body[i];
        // TODO: Write an AssertSymbolNode
        letter = node.text;
        if (letter === "t") {
          smashHeight = true;
        } else if (letter === "b") {
          smashDepth = true;
        } else {
          smashHeight = false;
          smashDepth = false;
          break;
        }
      }
    } else {
      smashHeight = true;
      smashDepth = true;
    }

    const body = args[0];
    return {
      type: "smash",
      mode: parser.mode,
      body,
      smashHeight,
      smashDepth
    };
  },
  mathmlBuilder: (group, style) => {
    const node = new mathMLTree.MathNode("mpadded", [buildGroup$1(group.body, style)]);

    if (group.smashHeight) {
      node.setAttribute("height", "0px");
    }

    if (group.smashDepth) {
      node.setAttribute("depth", "0px");
    }

    return node;
  }
});

defineFunction({
  type: "sqrt",
  names: ["\\sqrt"],
  props: {
    numArgs: 1,
    numOptionalArgs: 1
  },
  handler({ parser }, args, optArgs) {
    const index = optArgs[0];
    const body = args[0];
    return {
      type: "sqrt",
      mode: parser.mode,
      body,
      index
    };
  },
  mathmlBuilder(group, style) {
    const { body, index } = group;
    return index
      ? new mathMLTree.MathNode("mroot", [
        buildGroup$1(body, style),
        buildGroup$1(index, style.incrementLevel())
      ])
    : new mathMLTree.MathNode("msqrt", [buildGroup$1(body, style)]);
  }
});

const styleMap = {
  display: 0,
  text: 1,
  script: 2,
  scriptscript: 3
};

const styleAttributes = {
  display: ["0", "true"],
  text: ["0", "false"],
  script: ["1", "false"],
  scriptscript: ["2", "false"]
};

defineFunction({
  type: "styling",
  names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
  props: {
    numArgs: 0,
    allowedInText: true,
    primitive: true
  },
  handler({ breakOnTokenText, funcName, parser }, args) {
    // parse out the implicit body
    const body = parser.parseExpression(true, breakOnTokenText, true);

    const scriptLevel = funcName.slice(1, funcName.length - 5);
    return {
      type: "styling",
      mode: parser.mode,
      // Figure out what scriptLevel to use by pulling out the scriptLevel from
      // the function name
      scriptLevel,
      body
    };
  },
  mathmlBuilder(group, style) {
    // Figure out what scriptLevel we're changing to.
    const newStyle = style.withLevel(styleMap[group.scriptLevel]);
    // The style argument in the next line does NOT directly set a MathML script level.
    // It just tracks the style level, in case we need to know it for supsub or mathchoice.
    const inner = buildExpression(group.body, newStyle);
    // Wrap with an <mstyle> element.
    const node = wrapWithMstyle(inner);

    const attr = styleAttributes[group.scriptLevel];

    // Here is where we set the MathML script level.
    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
  }
});

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * Sometimes, groups perform special rules when they have superscripts or
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */

// Helpers
const symbolRegEx = /^m(over|under|underover)$/;

// Super scripts and subscripts, whose precise placement can depend on other
// functions that precede them.
defineFunctionBuilders({
  type: "supsub",
  mathmlBuilder(group, style) {
    // Is the inner group a relevant horizontal brace?
    let isBrace = false;
    let isOver;
    let isSup;
    let appendApplyFunction = false;
    let appendSpace = false;
    let needsLeadingSpace = false;

    if (group.base && group.base.type === "horizBrace") {
      isSup = !!group.sup;
      if (isSup === group.base.isOver) {
        isBrace = true;
        isOver = group.base.isOver;
      }
    }

    if (group.base && !group.base.stack &&
      (group.base.type === "op" || group.base.type === "operatorname")) {
      group.base.parentIsSupSub = true;
      appendApplyFunction = !group.base.symbol;
      appendSpace = appendApplyFunction && !group.isFollowedByDelimiter;
      needsLeadingSpace = group.base.needsLeadingSpace;
    }

    const children = group.base && group.base.stack
      ? [buildGroup$1(group.base.body[0], style)]
      : [buildGroup$1(group.base, style)];

    // Note regarding scriptstyle level.
    // (Sub|super)scripts should not shrink beyond MathML scriptlevel 2 aka \scriptscriptstyle
    // Ref: https://w3c.github.io/mathml-core/#the-displaystyle-and-scriptlevel-attributes
    // (BTW, MathML scriptlevel 2 is equal to Temml level 3.)
    // But Chromium continues to shrink the (sub|super)scripts. So we explicitly set scriptlevel 2.

    const childStyle = style.inSubOrSup();
    if (group.sub) {
      const sub = buildGroup$1(group.sub, childStyle);
      if (style.level === 3) { sub.setAttribute("scriptlevel", "2"); }
      children.push(sub);
    }

    if (group.sup) {
      const sup = buildGroup$1(group.sup, childStyle);
      if (style.level === 3) { sup.setAttribute("scriptlevel", "2"); }
      const testNode = sup.type === "mrow" ? sup.children[0] : sup;
      if ((testNode && testNode.type === "mo" && testNode.classes.includes("tml-prime"))
        && group.base && group.base.text && "fF".indexOf(group.base.text) > -1) {
        // Chromium does not address italic correction on prime.  Prevent f′ from overlapping.
        testNode.classes.push("prime-pad");
      }
      children.push(sup);
    }

    let nodeType;
    if (isBrace) {
      nodeType = isOver ? "mover" : "munder";
    } else if (!group.sub) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "mover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "mover";
      } else {
        nodeType = "msup";
      }
    } else if (!group.sup) {
      const base = group.base;
      if (
        base &&
        base.type === "op" &&
        base.limits &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munder";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (base.limits || style.level === StyleLevel.DISPLAY)
      ) {
        nodeType = "munder";
      } else {
        nodeType = "msub";
      }
    } else {
      const base = group.base;
      if (base && ((base.type === "op" && base.limits) || base.type === "multiscript") &&
        (style.level === StyleLevel.DISPLAY || base.alwaysHandleSupSub)
      ) {
        nodeType = "munderover";
      } else if (
        base &&
        base.type === "operatorname" &&
        base.alwaysHandleSupSub &&
        (style.level === StyleLevel.DISPLAY || base.limits)
      ) {
        nodeType = "munderover";
      } else {
        nodeType = "msubsup";
      }
    }

    let node = new mathMLTree.MathNode(nodeType, children);
    if (appendApplyFunction) {
      // Append an <mo>&ApplyFunction;</mo>.
      // ref: https://www.w3.org/TR/REC-MathML/chap3_2.html#sec3.2.4
      const operator = new mathMLTree.MathNode("mo", [makeText("\u2061", "text")]);
      if (needsLeadingSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node = mathMLTree.newDocumentFragment([space, node, operator]);
      } else {
        node = mathMLTree.newDocumentFragment([node, operator]);
      }
      if (appendSpace) {
        const space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.1667em"); // thin space.
        node.children.push(space);
      }
    } else if (symbolRegEx.test(nodeType)) {
      // Wrap in a <mrow>. Otherwise Firefox stretchy parens will not stretch to include limits.
      node = new mathMLTree.MathNode("mrow", [node]);
    }

    return node
  }
});

// Operator ParseNodes created in Parser.js from symbol Groups in src/symbols.js.

const short = ["\\shortmid", "\\nshortmid", "\\shortparallel",
  "\\nshortparallel", "\\smallsetminus"];

const arrows = ["\\Rsh", "\\Lsh", "\\restriction"];

const isArrow = str => {
  if (str.length === 1) {
    const codePoint = str.codePointAt(0);
    return (0x218f < codePoint && codePoint < 0x2200)
  }
  return str.indexOf("arrow") > -1 || str.indexOf("harpoon") > -1 || arrows.includes(str)
};

defineFunctionBuilders({
  type: "atom",
  mathmlBuilder(group, style) {
    const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
    if (group.family === "punct") {
      node.setAttribute("separator", "true");
    } else if (group.family === "open" || group.family === "close") {
      // Delims built here should not stretch vertically.
      // See delimsizing.js for stretchy delims.
      if (group.family === "open") {
        node.setAttribute("form", "prefix");
        // Set an explicit attribute for stretch. Otherwise Firefox may do it wrong.
        node.setAttribute("stretchy", "false");
      } else if (group.family === "close") {
        node.setAttribute("form", "postfix");
        node.setAttribute("stretchy", "false");
      }
    } else if (group.text === "\\mid") {
      // Firefox messes up this spacing if at the end of an <mrow>. See it explicitly.
      node.setAttribute("lspace", "0.22em"); // medium space
      node.setAttribute("rspace", "0.22em");
      node.setAttribute("stretchy", "false");
    } else if (group.family === "rel" && isArrow(group.text)) {
      node.setAttribute("stretchy", "false");
    } else if (short.includes(group.text)) {
      node.setAttribute("mathsize", "70%");
    } else if (group.text === ":") {
      // ":" is not in the MathML operator dictionary. Give it BIN spacing.
      node.attributes.lspace = "0.2222em";
      node.attributes.rspace = "0.2222em";
    } else if (group.needsSpacing) {
      // Fix a MathML bug that occurs when a <mo> is between two <mtext> elements.
      if (group.family === "bin") {
        return new mathMLTree.MathNode("mrow", [padding$1(0.222), node, padding$1(0.222)])
      } else {
        // REL spacing
        return new mathMLTree.MathNode("mrow", [padding$1(0.2778), node, padding$1(0.2778)])
      }
    }
    return node;
  }
});

/**
 * Maps TeX font commands to "mathvariant" attribute in buildMathML.js
 */
const fontMap = {
  // styles
  mathbf: "bold",
  mathrm: "normal",
  textit: "italic",
  mathit: "italic",
  mathnormal: "italic",

  // families
  mathbb: "double-struck",
  mathcal: "script",
  mathfrak: "fraktur",
  mathscr: "script",
  mathsf: "sans-serif",
  mathtt: "monospace"
};

/**
 * Returns the math variant as a string or null if none is required.
 */
const getVariant = function(group, style) {
  // Handle font specifiers as best we can.
  // Chromium does not support the MathML mathvariant attribute.
  // So we'll use Unicode replacement characters instead.
  // But first, determine the math variant.

  // Deal with the \textit, \textbf, etc., functions.
  if (style.fontFamily === "texttt") {
    return "monospace"
  } else if (style.fontFamily === "textsc") {
    return "normal"; // handled via character substitution in symbolsOrd.js.
  } else if (style.fontFamily === "textsf") {
    if (style.fontShape === "textit" && style.fontWeight === "textbf") {
      return "sans-serif-bold-italic"
    } else if (style.fontShape === "textit") {
      return "sans-serif-italic"
    } else if (style.fontWeight === "textbf") {
      return "sans-serif-bold"
    } else {
      return "sans-serif"
    }
  } else if (style.fontShape === "textit" && style.fontWeight === "textbf") {
    return "bold-italic"
  } else if (style.fontShape === "textit") {
    return "italic"
  } else if (style.fontWeight === "textbf") {
    return "bold"
  }

  // Deal with the \mathit, mathbf, etc, functions.
  const font = style.font;
  if (!font || font === "mathnormal") {
    return null
  }

  const mode = group.mode;
  switch (font) {
    case "mathit":
      return "italic"
    case "mathrm": {
      const codePoint = group.text.codePointAt(0);
      // LaTeX \mathrm returns italic for Greek characters.
      return  (0x03ab < codePoint && codePoint < 0x03cf) ? "italic" : "normal"
    }
    case "greekItalic":
      return "italic"
    case "up@greek":
      return "normal"
    case "boldsymbol":
    case "mathboldsymbol":
      return "bold-italic"
    case "mathbf":
      return "bold"
    case "mathbb":
      return "double-struck"
    case "mathfrak":
      return "fraktur"
    case "mathscr":
    case "mathcal":
      return "script"
    case "mathsf":
      return "sans-serif"
    case "mathsfit":
      return "sans-serif-italic"
    case "mathtt":
      return "monospace"
  }

  let text = group.text;
  if (symbols[mode][text] && symbols[mode][text].replace) {
    text = symbols[mode][text].replace;
  }

  return Object.prototype.hasOwnProperty.call(fontMap, font) ? fontMap[font] : null
};

// Chromium does not support the MathML `mathvariant` attribute.
// Instead, we replace ASCII characters with Unicode characters that
// are defined in the font as bold, italic, double-struck, etc.
// This module identifies those Unicode code points.

// First, a few helpers.
const script = Object.freeze({
  B: 0x20EA, // Offset from ASCII B to Unicode script B
  E: 0x20EB,
  F: 0x20EB,
  H: 0x20C3,
  I: 0x20C7,
  L: 0x20C6,
  M: 0x20E6,
  R: 0x20C9,
  e: 0x20CA,
  g: 0x20A3,
  o: 0x20C5
});

const frak = Object.freeze({
  C: 0x20EA,
  H: 0x20C4,
  I: 0x20C8,
  R: 0x20CA,
  Z: 0x20CE
});

const bbb = Object.freeze({
  C: 0x20BF, // blackboard bold
  H: 0x20C5,
  N: 0x20C7,
  P: 0x20C9,
  Q: 0x20C9,
  R: 0x20CB,
  Z: 0x20CA
});

const bold = Object.freeze({
  "\u03f5": 0x1D2E7, // lunate epsilon
  "\u03d1": 0x1D30C, // vartheta
  "\u03f0": 0x1D2EE, // varkappa
  "\u03c6": 0x1D319, // varphi
  "\u03f1": 0x1D2EF, // varrho
  "\u03d6": 0x1D30B  // varpi
});

const boldItalic = Object.freeze({
  "\u03f5": 0x1D35B, // lunate epsilon
  "\u03d1": 0x1D380, // vartheta
  "\u03f0": 0x1D362, // varkappa
  "\u03c6": 0x1D38D, // varphi
  "\u03f1": 0x1D363, // varrho
  "\u03d6": 0x1D37F  // varpi
});

const boldsf = Object.freeze({
  "\u03f5": 0x1D395, // lunate epsilon
  "\u03d1": 0x1D3BA, // vartheta
  "\u03f0": 0x1D39C, // varkappa
  "\u03c6": 0x1D3C7, // varphi
  "\u03f1": 0x1D39D, // varrho
  "\u03d6": 0x1D3B9  // varpi
});

const bisf = Object.freeze({
  "\u03f5": 0x1D3CF, // lunate epsilon
  "\u03d1": 0x1D3F4, // vartheta
  "\u03f0": 0x1D3D6, // varkappa
  "\u03c6": 0x1D401, // varphi
  "\u03f1": 0x1D3D7, // varrho
  "\u03d6": 0x1D3F3  // varpi
});

// Code point offsets below are derived from https://www.unicode.org/charts/PDF/U1D400.pdf
const offset = Object.freeze({
  upperCaseLatin: { // A-Z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3BF },
    "italic": ch =>                 { return 0x1D3F3 },
    "bold-italic": ch =>            { return 0x1D427 },
    "script": ch =>                 { return script[ch] || 0x1D45B },
    "script-bold": ch =>            { return 0x1D48F },
    "fraktur": ch =>                { return frak[ch] || 0x1D4C3 },
    "fraktur-bold": ch =>           { return 0x1D52B },
    "double-struck": ch =>          { return bbb[ch] || 0x1D4F7 },
    "sans-serif": ch =>             { return 0x1D55F },
    "sans-serif-bold": ch =>        { return 0x1D593 },
    "sans-serif-italic": ch =>      { return 0x1D5C7 },
    "sans-serif-bold-italic": ch => { return 0x1D63C },
    "monospace": ch =>              { return 0x1D62F }
  },
  lowerCaseLatin: { // a-z
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D3B9 },
    "italic": ch =>                 { return ch === "h" ? 0x20A6 : 0x1D3ED },
    "bold-italic": ch =>            { return 0x1D421 },
    "script": ch =>                 { return script[ch] || 0x1D455 },
    "script-bold": ch =>            { return 0x1D489 },
    "fraktur": ch =>                { return 0x1D4BD },
    "fraktur-bold": ch =>           { return 0x1D525 },
    "double-struck": ch =>          { return 0x1D4F1 },
    "sans-serif": ch =>             { return 0x1D559 },
    "sans-serif-bold": ch =>        { return 0x1D58D },
    "sans-serif-italic": ch =>      { return 0x1D5C1 },
    "sans-serif-bold-italic": ch => { return 0x1D5F5 },
    "monospace": ch =>              { return 0x1D629 }
  },
  upperCaseGreek: { // A-Ω
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D317 },
    "italic": ch =>                 { return 0x1D351 },
    // \boldsymbol actually returns upright bold for upperCaseGreek
    "bold-italic": ch =>            { return 0x1D317 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3C5 },
    "sans-serif-bold": ch =>        { return 0x1D3C5 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3FF },
    "monospace": ch =>              { return 0 }
  },
  lowerCaseGreek: { // α-ω
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D311 },
    "italic": ch =>                 { return 0x1D34B },
    "bold-italic": ch =>            { return ch === "\u03d5" ? 0x1D37E : 0x1D385 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    // Unicode has no code points for regular-weight san-serif Greek. Use bold.
    "sans-serif": ch =>             { return 0x1D3BF },
    "sans-serif-bold": ch =>        { return 0x1D3BF },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0x1D3F9 },
    "monospace": ch =>              { return 0 }
  },
  varGreek: { // \varGamma, etc
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return  bold[ch] || -51 },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return boldItalic[ch] || 0x3A },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0 },
    "sans-serif": ch =>             { return boldsf[ch] || 0x74 },
    "sans-serif-bold": ch =>        { return boldsf[ch] || 0x74 },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return bisf[ch] || 0xAE },
    "monospace": ch =>              { return 0 }
  },
  numeral: { // 0-9
    "normal": ch =>                 { return 0 },
    "bold": ch =>                   { return 0x1D79E },
    "italic": ch =>                 { return 0 },
    "bold-italic": ch =>            { return 0 },
    "script": ch =>                 { return 0 },
    "script-bold": ch =>            { return 0 },
    "fraktur": ch =>                { return 0 },
    "fraktur-bold": ch =>           { return 0 },
    "double-struck": ch =>          { return 0x1D7A8 },
    "sans-serif": ch =>             { return 0x1D7B2 },
    "sans-serif-bold": ch =>        { return 0x1D7BC },
    "sans-serif-italic": ch =>      { return 0 },
    "sans-serif-bold-italic": ch => { return 0 },
    "monospace": ch =>              { return 0x1D7C6 }
  }
});

const variantChar = (ch, variant) => {
  const codePoint = ch.codePointAt(0);
  const block = 0x40 < codePoint && codePoint < 0x5b
    ? "upperCaseLatin"
    : 0x60 < codePoint && codePoint < 0x7b
    ? "lowerCaseLatin"
    : (0x390  < codePoint && codePoint < 0x3AA)
    ? "upperCaseGreek"
    : 0x3B0 < codePoint && codePoint < 0x3CA || ch === "\u03d5"
    ? "lowerCaseGreek"
    : 0x1D6E1 < codePoint && codePoint < 0x1D6FC  || bold[ch]
    ? "varGreek"
    : (0x2F < codePoint && codePoint <  0x3A)
    ? "numeral"
    : "other";
  return block === "other"
    ? ch
    : String.fromCodePoint(codePoint + offset[block][variant](ch))
};

const smallCaps = Object.freeze({
  a: "ᴀ",
  b: "ʙ",
  c: "ᴄ",
  d: "ᴅ",
  e: "ᴇ",
  f: "ꜰ",
  g: "ɢ",
  h: "ʜ",
  i: "ɪ",
  j: "ᴊ",
  k: "ᴋ",
  l: "ʟ",
  m: "ᴍ",
  n: "ɴ",
  o: "ᴏ",
  p: "ᴘ",
  q: "ǫ",
  r: "ʀ",
  s: "s",
  t: "ᴛ",
  u: "ᴜ",
  v: "ᴠ",
  w: "ᴡ",
  x: "x",
  y: "ʏ",
  z: "ᴢ"
});

// "mathord" and "textord" ParseNodes created in Parser.js from symbol Groups in
// src/symbols.js.

const numberRegEx = /^\d(?:[\d,.]*\d)?$/;
const latinRegEx = /[A-Ba-z]/;
const primes = new Set(["\\prime", "\\dprime", "\\trprime", "\\qprime",
  "\\backprime", "\\backdprime", "\\backtrprime"]);

const italicNumber = (text, variant, tag) => {
  const mn = new mathMLTree.MathNode(tag, [text]);
  const wrapper = new mathMLTree.MathNode("mstyle", [mn]);
  wrapper.style["font-style"] = "italic";
  wrapper.style["font-family"] = "Cambria, 'Times New Roman', serif";
  if (variant === "bold-italic") { wrapper.style["font-weight"] = "bold"; }
  return wrapper
};

defineFunctionBuilders({
  type: "mathord",
  mathmlBuilder(group, style) {
    const text = makeText(group.text, group.mode, style);
    const codePoint = text.text.codePointAt(0);
    // Test for upper-case Greek
    const defaultVariant = (0x0390 < codePoint && codePoint < 0x03aa) ? "normal" : "italic";
    const variant = getVariant(group, style) || defaultVariant;
    if (variant === "script") {
      text.text = variantChar(text.text, variant);
      return new mathMLTree.MathNode("mi", [text], [style.font])
    } else if (variant !== "italic") {
      text.text = variantChar(text.text, variant);
    }
    let node = new mathMLTree.MathNode("mi", [text]);
    // TODO: Handle U+1D49C - U+1D4CF per https://www.unicode.org/charts/PDF/U1D400.pdf
    if (variant === "normal") {
      node.setAttribute("mathvariant", "normal");
      if (text.text.length === 1) {
        // A Firefox bug will apply spacing here, but there should be none. Fix it.
        node = new mathMLTree.MathNode("mpadded", [node]);
        node.setAttribute("lspace", "0");
        node.setAttribute("rspace", "0");
      }
    }
    return node
  }
});

defineFunctionBuilders({
  type: "textord",
  mathmlBuilder(group, style) {
    let ch = group.text;
    const codePoint = ch.codePointAt(0);
    if (style.fontFamily === "textsc") {
      // Convert small latin letters to small caps.
      if (96 < codePoint && codePoint < 123) {
        ch = smallCaps[ch];
      }
    }
    const text = makeText(ch, group.mode, style);
    const variant = getVariant(group, style) || "normal";

    let node;
    if (numberRegEx.test(group.text)) {
      const tag = group.mode === "text" ? "mtext" : "mn";
      if (variant === "italic" || variant === "bold-italic") {
        return italicNumber(text, variant, tag)
      } else {
        if (variant !== "normal") {
          text.text = text.text.split("").map(c => variantChar(c, variant)).join("");
        }
        node = new mathMLTree.MathNode(tag, [text]);
      }
    } else if (group.mode === "text") {
      if (variant !== "normal") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mtext", [text]);
    } else if (primes.has(group.text)) {
      node = new mathMLTree.MathNode("mo", [text]);
      // TODO: If/when Chromium uses ssty variant for prime, remove the next line.
      node.classes.push("tml-prime");
    } else {
      const origText = text.text;
      if (variant !== "italic") {
        text.text = variantChar(text.text, variant);
      }
      node = new mathMLTree.MathNode("mi", [text]);
      if (text.text === origText && latinRegEx.test(origText)) {
        node.setAttribute("mathvariant", "italic");
      }
    }
    return node
  }
});

// A map of CSS-based spacing functions to their CSS class.
const cssSpace = {
  "\\nobreak": "nobreak",
  "\\allowbreak": "allowbreak"
};

// A lookup table to determine whether a spacing function/symbol should be
// treated like a regular space character.  If a symbol or command is a key
// in this table, then it should be a regular space character.  Furthermore,
// the associated value may have a `className` specifying an extra CSS class
// to add to the created `span`.
const regularSpace = {
  " ": {},
  "\\ ": {},
  "~": {
    className: "nobreak"
  },
  "\\space": {},
  "\\nobreakspace": {
    className: "nobreak"
  }
};

// ParseNode<"spacing"> created in Parser.js from the "spacing" symbol Groups in
// src/symbols.js.
defineFunctionBuilders({
  type: "spacing",
  mathmlBuilder(group, style) {
    let node;

    if (Object.prototype.hasOwnProperty.call(regularSpace, group.text)) {
      // Firefox does not render a space in a <mtext> </mtext>. So write a no-break space.
      // TODO: If Firefox fixes that bug, uncomment the next line and write ch into the node.
      //const ch = (regularSpace[group.text].className === "nobreak") ? "\u00a0" : " "
      node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else if (Object.prototype.hasOwnProperty.call(cssSpace, group.text)) {
      // MathML 3.0 calls for nobreak to occur in an <mo>, not an <mtext>
      // Ref: https://www.w3.org/Math/draft-spec/mathml.html#chapter3_presm.lbattrs
      node = new mathMLTree.MathNode("mo");
      if (group.text === "\\nobreak") {
        node.setAttribute("linebreak", "nobreak");
      }
    } else {
      throw new ParseError(`Unknown type of space "${group.text}"`)
    }

    return node
  }
});

defineFunctionBuilders({
  type: "tag"
});

// For a \tag, the work usually done in a mathmlBuilder is instead done in buildMathML.js.
// That way, a \tag can be pulled out of the parse tree and wrapped around the outer node.

// Non-mathy text, possibly in a font
const textFontFamilies = {
  "\\text": undefined,
  "\\textrm": "textrm",
  "\\textsf": "textsf",
  "\\texttt": "texttt",
  "\\textnormal": "textrm",
  "\\textsc": "textsc"      // small caps
};

const textFontWeights = {
  "\\textbf": "textbf",
  "\\textmd": "textmd"
};

const textFontShapes = {
  "\\textit": "textit",
  "\\textup": "textup"
};

const styleWithFont = (group, style) => {
  const font = group.font;
  // Checks if the argument is a font family or a font style.
  if (!font) {
    return style;
  } else if (textFontFamilies[font]) {
    return style.withTextFontFamily(textFontFamilies[font]);
  } else if (textFontWeights[font]) {
    return style.withTextFontWeight(textFontWeights[font]);
  } else if (font === "\\emph") {
    return style.fontShape === "textit"
      ? style.withTextFontShape("textup")
      : style.withTextFontShape("textit")
  }
  return style.withTextFontShape(textFontShapes[font])
};

defineFunction({
  type: "text",
  names: [
    // Font families
    "\\text",
    "\\textrm",
    "\\textsf",
    "\\texttt",
    "\\textnormal",
    "\\textsc",
    // Font weights
    "\\textbf",
    "\\textmd",
    // Font Shapes
    "\\textit",
    "\\textup",
    "\\emph"
  ],
  props: {
    numArgs: 1,
    argTypes: ["text"],
    allowedInArgument: true,
    allowedInText: true
  },
  handler({ parser, funcName }, args) {
    const body = args[0];
    return {
      type: "text",
      mode: parser.mode,
      body: ordargument(body),
      font: funcName
    };
  },
  mathmlBuilder(group, style) {
    const newStyle = styleWithFont(group, style);
    const mrow = buildExpressionRow(group.body, newStyle);
    return consolidateText(mrow)
  }
});

// \vcenter:  Vertically center the argument group on the math axis.

defineFunction({
  type: "vcenter",
  names: ["\\vcenter"],
  props: {
    numArgs: 1,
    argTypes: ["original"],
    allowedInText: false
  },
  handler({ parser }, args) {
    return {
      type: "vcenter",
      mode: parser.mode,
      body: args[0]
    };
  },
  mathmlBuilder(group, style) {
    // Use a math table to create vertically centered content.
    const mtd = new mathMLTree.MathNode("mtd", [buildGroup$1(group.body, style)]);
    mtd.style.padding = "0";
    const mtr = new mathMLTree.MathNode("mtr", [mtd]);
    return new mathMLTree.MathNode("mtable", [mtr])
  }
});

defineFunction({
  type: "verb",
  names: ["\\verb"],
  props: {
    numArgs: 0,
    allowedInText: true
  },
  handler(context, args, optArgs) {
    // \verb and \verb* are dealt with directly in Parser.js.
    // If we end up here, it's because of a failure to match the two delimiters
    // in the regex in Lexer.js.  LaTeX raises the following error when \verb is
    // terminated by end of line (or file).
    throw new ParseError("\\verb ended by end of line instead of matching delimiter");
  },
  mathmlBuilder(group, style) {
    const text = new mathMLTree.TextNode(makeVerb(group));
    const node = new mathMLTree.MathNode("mtext", [text]);
    node.setAttribute("mathvariant", "monospace");
    return node;
  }
});

/**
 * Converts verb group into body string.
 *
 * \verb* replaces each space with an open box \u2423
 * \verb replaces each space with a no-break space \xA0
 */
const makeVerb = (group) => group.body.replace(/ /g, group.star ? "\u2423" : "\xA0");

/** Include this to ensure that all functions are defined. */

const functions = _functions;

/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */


/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first two groups
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - mathches numerals
 * - matches a backslash followed by one or more whitespace characters
 * - matches a backslash followed by one or more letters then whitespace
 * - matches a backslash followed by any BMP character
 * Capturing groups:
 *   [1] regular whitespace
 *   [2] backslash followed by whitespace
 *   [3] anything else, which may include:
 *     [4] left character of \verb*
 *     [5] left character of \verb
 *     [6] backslash followed by word, excluding any trailing whitespace
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
const spaceRegexString = "[ \r\n\t]";
const controlWordRegexString = "\\\\[a-zA-Z@]+";
const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
const controlWordWhitespaceRegexString = `(${controlWordRegexString})${spaceRegexString}*`;
const controlSpaceRegexString = "\\\\(\n|[ \r\t]+\n?)[ \r\t]*";
const combiningDiacriticalMarkString = "[\u0300-\u036f]";
const combiningDiacriticalMarksEndRegex = new RegExp(`${combiningDiacriticalMarkString}+$`);
const tokenRegexString =
  `(${spaceRegexString}+)|` + // whitespace
  `${controlSpaceRegexString}|` +  // whitespace
  "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" + // single codepoint
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
  `${combiningDiacriticalMarkString}*` + // ...plus accents
  "|\\\\verb\\*([^]).*?\\4" + // \verb*
  "|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
  `|${controlWordWhitespaceRegexString}` + // \macroName + spaces
  `|${controlSymbolRegexString})`; // \\, \', etc.

/** Main Lexer class */
class Lexer {
  constructor(input, settings) {
    // Separate accents from characters
    this.input = input;
    this.settings = settings;
    this.tokenRegex = new RegExp(tokenRegexString, 'g');
    // Category codes. The lexer only supports comment characters (14) for now.
    // MacroExpander additionally distinguishes active (13).
    this.catcodes = {
      "%": 14, // comment character
      "~": 13  // active character
    };
  }

  setCatcode(char, code) {
    this.catcodes[char] = code;
  }

  /**
   * This function lexes a single token.
   */
  lex() {
    const input = this.input;
    const pos = this.tokenRegex.lastIndex;
    if (pos === input.length) {
      return new Token("EOF", new SourceLocation(this, pos, pos));
    }
    const match = this.tokenRegex.exec(input);
    if (match === null || match.index !== pos) {
      throw new ParseError(
        `Unexpected character: '${input[pos]}'`,
        new Token(input[pos], new SourceLocation(this, pos, pos + 1))
      );
    }
    const text = match[6] || match[3] || (match[2] ? "\\ " : " ");

    if (this.catcodes[text] === 14) {
      // comment character
      const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
      if (nlIndex === -1) {
        this.tokenRegex.lastIndex = input.length; // EOF
        if (this.settings.strict) {
          throw new ParseError("% comment has no terminating newline; LaTeX would " +
              "fail because of commenting the end of math mode")
        }
      } else {
        this.tokenRegex.lastIndex = nlIndex + 1;
      }
      return this.lex();
    }

    return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
  }
}

/**
 * A `Namespace` refers to a space of nameable things like macros or lengths,
 * which can be `set` either globally or local to a nested group, using an
 * undo stack similar to how TeX implements this functionality.
 * Performance-wise, `get` and local `set` take constant time, while global
 * `set` takes time proportional to the depth of group nesting.
 */


class Namespace {
  /**
   * Both arguments are optional.  The first argument is an object of
   * built-in mappings which never change.  The second argument is an object
   * of initial (global-level) mappings, which will constantly change
   * according to any global/top-level `set`s done.
   */
  constructor(builtins = {}, globalMacros = {}) {
    this.current = globalMacros;
    this.builtins = builtins;
    this.undefStack = [];
  }

  /**
   * Start a new nested group, affecting future local `set`s.
   */
  beginGroup() {
    this.undefStack.push({});
  }

  /**
   * End current nested group, restoring values before the group began.
   */
  endGroup() {
    if (this.undefStack.length === 0) {
      throw new ParseError(
        "Unbalanced namespace destruction: attempt " +
          "to pop global namespace; please report this as a bug"
      );
    }
    const undefs = this.undefStack.pop();
    for (const undef in undefs) {
      if (Object.prototype.hasOwnProperty.call(undefs, undef )) {
        if (undefs[undef] === undefined) {
          delete this.current[undef];
        } else {
          this.current[undef] = undefs[undef];
        }
      }
    }
  }

  /**
   * Detect whether `name` has a definition.  Equivalent to
   * `get(name) != null`.
   */
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.current, name ) ||
    Object.prototype.hasOwnProperty.call(this.builtins, name );
  }

  /**
   * Get the current value of a name, or `undefined` if there is no value.
   *
   * Note: Do not use `if (namespace.get(...))` to detect whether a macro
   * is defined, as the definition may be the empty string which evaluates
   * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
   * `if (namespace.has(...))`.
   */
  get(name) {
    if (Object.prototype.hasOwnProperty.call(this.current, name )) {
      return this.current[name];
    } else {
      return this.builtins[name];
    }
  }

  /**
   * Set the current value of a name, and optionally set it globally too.
   * Local set() sets the current value and (when appropriate) adds an undo
   * operation to the undo stack.  Global set() may change the undo
   * operation at every level, so takes time linear in their number.
   */
  set(name, value, global = false) {
    if (global) {
      // Global set is equivalent to setting in all groups.  Simulate this
      // by destroying any undos currently scheduled for this name,
      // and adding an undo with the *new* value (in case it later gets
      // locally reset within this environment).
      for (let i = 0; i < this.undefStack.length; i++) {
        delete this.undefStack[i][name];
      }
      if (this.undefStack.length > 0) {
        this.undefStack[this.undefStack.length - 1][name] = value;
      }
    } else {
      // Undo this set at end of this group (possibly to `undefined`),
      // unless an undo is already in place, in which case that older
      // value is the correct one.
      const top = this.undefStack[this.undefStack.length - 1];
      if (top && !Object.prototype.hasOwnProperty.call(top, name )) {
        top[name] = this.current[name];
      }
    }
    this.current[name] = value;
  }
}

/**
 * This file contains the “gullet” where macros are expanded
 * until only non-macro tokens remain.
 */


// List of commands that act like macros but aren't defined as a macro,
// function, or symbol.  Used in `isDefined`.
const implicitCommands = {
  "^": true, // Parser.js
  _: true, // Parser.js
  "\\limits": true, // Parser.js
  "\\nolimits": true // Parser.js
};

class MacroExpander {
  constructor(input, settings, mode) {
    this.settings = settings;
    this.expansionCount = 0;
    this.feed(input);
    // Make new global namespace
    this.macros = new Namespace(macros, settings.macros);
    this.mode = mode;
    this.stack = []; // contains tokens in REVERSE order
  }

  /**
   * Feed a new input string to the same MacroExpander
   * (with existing macros etc.).
   */
  feed(input) {
    this.lexer = new Lexer(input, this.settings);
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
  }

  /**
   * Start a new group nesting within all namespaces.
   */
  beginGroup() {
    this.macros.beginGroup();
  }

  /**
   * End current group nesting within all namespaces.
   */
  endGroup() {
    this.macros.endGroup();
  }

  /**
   * Returns the topmost token on the stack, without expanding it.
   * Similar in behavior to TeX's `\futurelet`.
   */
  future() {
    if (this.stack.length === 0) {
      this.pushToken(this.lexer.lex());
    }
    return this.stack[this.stack.length - 1]
  }

  /**
   * Remove and return the next unexpanded token.
   */
  popToken() {
    this.future(); // ensure non-empty stack
    return this.stack.pop();
  }

  /**
   * Add a given token to the token stack.  In particular, this get be used
   * to put back a token returned from one of the other methods.
   */
  pushToken(token) {
    this.stack.push(token);
  }

  /**
   * Append an array of tokens to the token stack.
   */
  pushTokens(tokens) {
    this.stack.push(...tokens);
  }

  /**
   * Find an macro argument without expanding tokens and append the array of
   * tokens to the token stack. Uses Token as a container for the result.
   */
  scanArgument(isOptional) {
    let start;
    let end;
    let tokens;
    if (isOptional) {
      this.consumeSpaces(); // \@ifnextchar gobbles any space following it
      if (this.future().text !== "[") {
        return null;
      }
      start = this.popToken(); // don't include [ in tokens
      ({ tokens, end } = this.consumeArg(["]"]));
    } else {
      ({ tokens, start, end } = this.consumeArg());
    }

    // indicate the end of an argument
    this.pushToken(new Token("EOF", end.loc));

    this.pushTokens(tokens);
    return start.range(end, "");
  }

  /**
   * Consume all following space tokens, without expansion.
   */
  consumeSpaces() {
    for (;;) {
      const token = this.future();
      if (token.text === " ") {
        this.stack.pop();
      } else {
        break;
      }
    }
  }

  /**
   * Consume an argument from the token stream, and return the resulting array
   * of tokens and start/end token.
   */
  consumeArg(delims) {
    // The argument for a delimited parameter is the shortest (possibly
    // empty) sequence of tokens with properly nested {...} groups that is
    // followed ... by this particular list of non-parameter tokens.
    // The argument for an undelimited parameter is the next nonblank
    // token, unless that token is ‘{’, when the argument will be the
    // entire {...} group that follows.
    const tokens = [];
    const isDelimited = delims && delims.length > 0;
    if (!isDelimited) {
      // Ignore spaces between arguments.  As the TeXbook says:
      // "After you have said ‘\def\row#1#2{...}’, you are allowed to
      //  put spaces between the arguments (e.g., ‘\row x n’), because
      //  TeX doesn’t use single spaces as undelimited arguments."
      this.consumeSpaces();
    }
    const start = this.future();
    let tok;
    let depth = 0;
    let match = 0;
    do {
      tok = this.popToken();
      tokens.push(tok);
      if (tok.text === "{") {
        ++depth;
      } else if (tok.text === "}") {
        --depth;
        if (depth === -1) {
          throw new ParseError("Extra }", tok);
        }
      } else if (tok.text === "EOF") {
        throw new ParseError(
          "Unexpected end of input in a macro argument" +
            ", expected '" +
            (delims && isDelimited ? delims[match] : "}") +
            "'",
          tok
        );
      }
      if (delims && isDelimited) {
        if ((depth === 0 || (depth === 1 && delims[match] === "{")) && tok.text === delims[match]) {
          ++match;
          if (match === delims.length) {
            // don't include delims in tokens
            tokens.splice(-match, match);
            break;
          }
        } else {
          match = 0;
        }
      }
    } while (depth !== 0 || isDelimited);
    // If the argument found ... has the form ‘{<nested tokens>}’,
    // ... the outermost braces enclosing the argument are removed
    if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
      tokens.pop();
      tokens.shift();
    }
    tokens.reverse(); // to fit in with stack order
    return { tokens, start, end: tok };
  }

  /**
   * Consume the specified number of (delimited) arguments from the token
   * stream and return the resulting array of arguments.
   */
  consumeArgs(numArgs, delimiters) {
    if (delimiters) {
      if (delimiters.length !== numArgs + 1) {
        throw new ParseError("The length of delimiters doesn't match the number of args!");
      }
      const delims = delimiters[0];
      for (let i = 0; i < delims.length; i++) {
        const tok = this.popToken();
        if (delims[i] !== tok.text) {
          throw new ParseError("Use of the macro doesn't match its definition", tok);
        }
      }
    }

    const args = [];
    for (let i = 0; i < numArgs; i++) {
      args.push(this.consumeArg(delimiters && delimiters[i + 1]).tokens);
    }
    return args;
  }

  /**
   * Expand the next token only once if possible.
   *
   * If the token is expanded, the resulting tokens will be pushed onto
   * the stack in reverse order, and the number of such tokens will be
   * returned.  This number might be zero or positive.
   *
   * If not, the return value is `false`, and the next token remains at the
   * top of the stack.
   *
   * In either case, the next token will be on the top of the stack,
   * or the stack will be empty (in case of empty expansion
   * and no other tokens).
   *
   * Used to implement `expandAfterFuture` and `expandNextToken`.
   *
   * If expandableOnly, only expandable tokens are expanded and
   * an undefined control sequence results in an error.
   */
  expandOnce(expandableOnly) {
    const topToken = this.popToken();
    const name = topToken.text;
    const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
    if (expansion == null || (expandableOnly && expansion.unexpandable)) {
      if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
        throw new ParseError("Undefined control sequence: " + name);
      }
      this.pushToken(topToken);
      return false;
    }
    this.expansionCount++;
    if (this.expansionCount > this.settings.maxExpand) {
      throw new ParseError(
        "Too many expansions: infinite loop or " + "need to increase maxExpand setting"
      );
    }
    let tokens = expansion.tokens;
    const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
    if (expansion.numArgs) {
      // paste arguments in place of the placeholders
      tokens = tokens.slice(); // make a shallow copy
      for (let i = tokens.length - 1; i >= 0; --i) {
        let tok = tokens[i];
        if (tok.text === "#") {
          if (i === 0) {
            throw new ParseError("Incomplete placeholder at end of macro body", tok);
          }
          tok = tokens[--i]; // next token on stack
          if (tok.text === "#") {
            // ## → #
            tokens.splice(i + 1, 1); // drop first #
          } else if (/^[1-9]$/.test(tok.text)) {
            // replace the placeholder with the indicated argument
            tokens.splice(i, 2, ...args[+tok.text - 1]);
          } else {
            throw new ParseError("Not a valid argument number", tok);
          }
        }
      }
    }
    // Concatenate expansion onto top of stack.
    this.pushTokens(tokens);
    return tokens.length;
  }

  /**
   * Expand the next token only once (if possible), and return the resulting
   * top token on the stack (without removing anything from the stack).
   * Similar in behavior to TeX's `\expandafter\futurelet`.
   * Equivalent to expandOnce() followed by future().
   */
  expandAfterFuture() {
    this.expandOnce();
    return this.future();
  }

  /**
   * Recursively expand first token, then return first non-expandable token.
   */
  expandNextToken() {
    for (;;) {
      if (this.expandOnce() === false) { // fully expanded
        const token = this.stack.pop();
        // The token after \noexpand is interpreted as if its meaning were ‘\relax’
        if (token.treatAsRelax) {
          token.text = "\\relax";
        }
        return token
      }
    }

    // This pathway is impossible.
    throw new Error(); // eslint-disable-line no-unreachable
  }

  /**
   * Fully expand the given macro name and return the resulting list of
   * tokens, or return `undefined` if no such macro is defined.
   */
  expandMacro(name) {
    return this.macros.has(name) ? this.expandTokens([new Token(name)]) : undefined;
  }

  /**
   * Fully expand the given token stream and return the resulting list of
   * tokens.  Note that the input tokens are in reverse order, but the
   * output tokens are in forward order.
   */
  expandTokens(tokens) {
    const output = [];
    const oldStackLength = this.stack.length;
    this.pushTokens(tokens);
    while (this.stack.length > oldStackLength) {
      // Expand only expandable tokens
      if (this.expandOnce(true) === false) {  // fully expanded
        const token = this.stack.pop();
        if (token.treatAsRelax) {
          // the expansion of \noexpand is the token itself
          token.noexpand = false;
          token.treatAsRelax = false;
        }
        output.push(token);
      }
    }
    return output;
  }

  /**
   * Fully expand the given macro name and return the result as a string,
   * or return `undefined` if no such macro is defined.
   */
  expandMacroAsText(name) {
    const tokens = this.expandMacro(name);
    if (tokens) {
      return tokens.map((token) => token.text).join("");
    } else {
      return tokens;
    }
  }

  /**
   * Returns the expanded macro as a reversed array of tokens and a macro
   * argument count.  Or returns `null` if no such macro.
   */
  _getExpansion(name) {
    const definition = this.macros.get(name);
    if (definition == null) {
      // mainly checking for undefined here
      return definition;
    }
    // If a single character has an associated catcode other than 13
    // (active character), then don't expand it.
    if (name.length === 1) {
      const catcode = this.lexer.catcodes[name];
      if (catcode != null && catcode !== 13) {
        return
      }
    }
    const expansion = typeof definition === "function" ? definition(this) : definition;
    if (typeof expansion === "string") {
      let numArgs = 0;
      if (expansion.indexOf("#") !== -1) {
        const stripped = expansion.replace(/##/g, "");
        while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
          ++numArgs;
        }
      }
      const bodyLexer = new Lexer(expansion, this.settings);
      const tokens = [];
      let tok = bodyLexer.lex();
      while (tok.text !== "EOF") {
        tokens.push(tok);
        tok = bodyLexer.lex();
      }
      tokens.reverse(); // to fit in with stack using push and pop
      const expanded = { tokens, numArgs };
      return expanded;
    }

    return expansion;
  }

  /**
   * Determine whether a command is currently "defined" (has some
   * functionality), meaning that it's a macro (in the current group),
   * a function, a symbol, or one of the special commands listed in
   * `implicitCommands`.
   */
  isDefined(name) {
    return (
      this.macros.has(name) ||
      Object.prototype.hasOwnProperty.call(functions, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.math, name ) ||
      Object.prototype.hasOwnProperty.call(symbols.text, name ) ||
      Object.prototype.hasOwnProperty.call(implicitCommands, name )
    );
  }

  /**
   * Determine whether a command is expandable.
   */
  isExpandable(name) {
    const macro = this.macros.get(name);
    return macro != null
      ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable
      : Object.prototype.hasOwnProperty.call(functions, name ) && !functions[name].primitive;
  }
}

// Helpers for Parser.js handling of Unicode (sub|super)script characters.

const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;

const uSubsAndSups = Object.freeze({
  '₊': '+',
  '₋': '-',
  '₌': '=',
  '₍': '(',
  '₎': ')',
  '₀': '0',
  '₁': '1',
  '₂': '2',
  '₃': '3',
  '₄': '4',
  '₅': '5',
  '₆': '6',
  '₇': '7',
  '₈': '8',
  '₉': '9',
  '\u2090': 'a',
  '\u2091': 'e',
  '\u2095': 'h',
  '\u1D62': 'i',
  '\u2C7C': 'j',
  '\u2096': 'k',
  '\u2097': 'l',
  '\u2098': 'm',
  '\u2099': 'n',
  '\u2092': 'o',
  '\u209A': 'p',
  '\u1D63': 'r',
  '\u209B': 's',
  '\u209C': 't',
  '\u1D64': 'u',
  '\u1D65': 'v',
  '\u2093': 'x',
  '\u1D66': 'β',
  '\u1D67': 'γ',
  '\u1D68': 'ρ',
  '\u1D69': '\u03d5',
  '\u1D6A': 'χ',
  '⁺': '+',
  '⁻': '-',
  '⁼': '=',
  '⁽': '(',
  '⁾': ')',
  '⁰': '0',
  '¹': '1',
  '²': '2',
  '³': '3',
  '⁴': '4',
  '⁵': '5',
  '⁶': '6',
  '⁷': '7',
  '⁸': '8',
  '⁹': '9',
  '\u1D2C': 'A',
  '\u1D2E': 'B',
  '\u1D30': 'D',
  '\u1D31': 'E',
  '\u1D33': 'G',
  '\u1D34': 'H',
  '\u1D35': 'I',
  '\u1D36': 'J',
  '\u1D37': 'K',
  '\u1D38': 'L',
  '\u1D39': 'M',
  '\u1D3A': 'N',
  '\u1D3C': 'O',
  '\u1D3E': 'P',
  '\u1D3F': 'R',
  '\u1D40': 'T',
  '\u1D41': 'U',
  '\u2C7D': 'V',
  '\u1D42': 'W',
  '\u1D43': 'a',
  '\u1D47': 'b',
  '\u1D9C': 'c',
  '\u1D48': 'd',
  '\u1D49': 'e',
  '\u1DA0': 'f',
  '\u1D4D': 'g',
  '\u02B0': 'h',
  '\u2071': 'i',
  '\u02B2': 'j',
  '\u1D4F': 'k',
  '\u02E1': 'l',
  '\u1D50': 'm',
  '\u207F': 'n',
  '\u1D52': 'o',
  '\u1D56': 'p',
  '\u02B3': 'r',
  '\u02E2': 's',
  '\u1D57': 't',
  '\u1D58': 'u',
  '\u1D5B': 'v',
  '\u02B7': 'w',
  '\u02E3': 'x',
  '\u02B8': 'y',
  '\u1DBB': 'z',
  '\u1D5D': 'β',
  '\u1D5E': 'γ',
  '\u1D5F': 'δ',
  '\u1D60': '\u03d5',
  '\u1D61': 'χ',
  '\u1DBF': 'θ'
});

// Used for Unicode input of calligraphic and script letters
const asciiFromScript = Object.freeze({
  "\ud835\udc9c": "A",
  "\u212c": "B",
  "\ud835\udc9e": "C",
  "\ud835\udc9f": "D",
  "\u2130": "E",
  "\u2131": "F",
  "\ud835\udca2": "G",
  "\u210B": "H",
  "\u2110": "I",
  "\ud835\udca5": "J",
  "\ud835\udca6": "K",
  "\u2112": "L",
  "\u2133": "M",
  "\ud835\udca9": "N",
  "\ud835\udcaa": "O",
  "\ud835\udcab": "P",
  "\ud835\udcac": "Q",
  "\u211B": "R",
  "\ud835\udcae": "S",
  "\ud835\udcaf": "T",
  "\ud835\udcb0": "U",
  "\ud835\udcb1": "V",
  "\ud835\udcb2": "W",
  "\ud835\udcb3": "X",
  "\ud835\udcb4": "Y",
  "\ud835\udcb5": "Z"
});

// Mapping of Unicode accent characters to their LaTeX equivalent in text and
// math mode (when they exist).
var unicodeAccents = {
  "\u0301": { text: "\\'", math: "\\acute" },
  "\u0300": { text: "\\`", math: "\\grave" },
  "\u0308": { text: '\\"', math: "\\ddot" },
  "\u0303": { text: "\\~", math: "\\tilde" },
  "\u0304": { text: "\\=", math: "\\bar" },
  "\u0306": { text: "\\u", math: "\\breve" },
  "\u030c": { text: "\\v", math: "\\check" },
  "\u0302": { text: "\\^", math: "\\hat" },
  "\u0307": { text: "\\.", math: "\\dot" },
  "\u030a": { text: "\\r", math: "\\mathring" },
  "\u030b": { text: "\\H" },
  '\u0327': { text: '\\c' }
};

var unicodeSymbols = {
  "á": "á",
  "à": "à",
  "ä": "ä",
  "ǟ": "ǟ",
  "ã": "ã",
  "ā": "ā",
  "ă": "ă",
  "ắ": "ắ",
  "ằ": "ằ",
  "ẵ": "ẵ",
  "ǎ": "ǎ",
  "â": "â",
  "ấ": "ấ",
  "ầ": "ầ",
  "ẫ": "ẫ",
  "ȧ": "ȧ",
  "ǡ": "ǡ",
  "å": "å",
  "ǻ": "ǻ",
  "ḃ": "ḃ",
  "ć": "ć",
  "č": "č",
  "ĉ": "ĉ",
  "ċ": "ċ",
  "ď": "ď",
  "ḋ": "ḋ",
  "é": "é",
  "è": "è",
  "ë": "ë",
  "ẽ": "ẽ",
  "ē": "ē",
  "ḗ": "ḗ",
  "ḕ": "ḕ",
  "ĕ": "ĕ",
  "ě": "ě",
  "ê": "ê",
  "ế": "ế",
  "ề": "ề",
  "ễ": "ễ",
  "ė": "ė",
  "ḟ": "ḟ",
  "ǵ": "ǵ",
  "ḡ": "ḡ",
  "ğ": "ğ",
  "ǧ": "ǧ",
  "ĝ": "ĝ",
  "ġ": "ġ",
  "ḧ": "ḧ",
  "ȟ": "ȟ",
  "ĥ": "ĥ",
  "ḣ": "ḣ",
  "í": "í",
  "ì": "ì",
  "ï": "ï",
  "ḯ": "ḯ",
  "ĩ": "ĩ",
  "ī": "ī",
  "ĭ": "ĭ",
  "ǐ": "ǐ",
  "î": "î",
  "ǰ": "ǰ",
  "ĵ": "ĵ",
  "ḱ": "ḱ",
  "ǩ": "ǩ",
  "ĺ": "ĺ",
  "ľ": "ľ",
  "ḿ": "ḿ",
  "ṁ": "ṁ",
  "ń": "ń",
  "ǹ": "ǹ",
  "ñ": "ñ",
  "ň": "ň",
  "ṅ": "ṅ",
  "ó": "ó",
  "ò": "ò",
  "ö": "ö",
  "ȫ": "ȫ",
  "õ": "õ",
  "ṍ": "ṍ",
  "ṏ": "ṏ",
  "ȭ": "ȭ",
  "ō": "ō",
  "ṓ": "ṓ",
  "ṑ": "ṑ",
  "ŏ": "ŏ",
  "ǒ": "ǒ",
  "ô": "ô",
  "ố": "ố",
  "ồ": "ồ",
  "ỗ": "ỗ",
  "ȯ": "ȯ",
  "ȱ": "ȱ",
  "ő": "ő",
  "ṕ": "ṕ",
  "ṗ": "ṗ",
  "ŕ": "ŕ",
  "ř": "ř",
  "ṙ": "ṙ",
  "ś": "ś",
  "ṥ": "ṥ",
  "š": "š",
  "ṧ": "ṧ",
  "ŝ": "ŝ",
  "ṡ": "ṡ",
  "ẗ": "ẗ",
  "ť": "ť",
  "ṫ": "ṫ",
  "ú": "ú",
  "ù": "ù",
  "ü": "ü",
  "ǘ": "ǘ",
  "ǜ": "ǜ",
  "ǖ": "ǖ",
  "ǚ": "ǚ",
  "ũ": "ũ",
  "ṹ": "ṹ",
  "ū": "ū",
  "ṻ": "ṻ",
  "ŭ": "ŭ",
  "ǔ": "ǔ",
  "û": "û",
  "ů": "ů",
  "ű": "ű",
  "ṽ": "ṽ",
  "ẃ": "ẃ",
  "ẁ": "ẁ",
  "ẅ": "ẅ",
  "ŵ": "ŵ",
  "ẇ": "ẇ",
  "ẘ": "ẘ",
  "ẍ": "ẍ",
  "ẋ": "ẋ",
  "ý": "ý",
  "ỳ": "ỳ",
  "ÿ": "ÿ",
  "ỹ": "ỹ",
  "ȳ": "ȳ",
  "ŷ": "ŷ",
  "ẏ": "ẏ",
  "ẙ": "ẙ",
  "ź": "ź",
  "ž": "ž",
  "ẑ": "ẑ",
  "ż": "ż",
  "Á": "Á",
  "À": "À",
  "Ä": "Ä",
  "Ǟ": "Ǟ",
  "Ã": "Ã",
  "Ā": "Ā",
  "Ă": "Ă",
  "Ắ": "Ắ",
  "Ằ": "Ằ",
  "Ẵ": "Ẵ",
  "Ǎ": "Ǎ",
  "Â": "Â",
  "Ấ": "Ấ",
  "Ầ": "Ầ",
  "Ẫ": "Ẫ",
  "Ȧ": "Ȧ",
  "Ǡ": "Ǡ",
  "Å": "Å",
  "Ǻ": "Ǻ",
  "Ḃ": "Ḃ",
  "Ć": "Ć",
  "Č": "Č",
  "Ĉ": "Ĉ",
  "Ċ": "Ċ",
  "Ď": "Ď",
  "Ḋ": "Ḋ",
  "É": "É",
  "È": "È",
  "Ë": "Ë",
  "Ẽ": "Ẽ",
  "Ē": "Ē",
  "Ḗ": "Ḗ",
  "Ḕ": "Ḕ",
  "Ĕ": "Ĕ",
  "Ě": "Ě",
  "Ê": "Ê",
  "Ế": "Ế",
  "Ề": "Ề",
  "Ễ": "Ễ",
  "Ė": "Ė",
  "Ḟ": "Ḟ",
  "Ǵ": "Ǵ",
  "Ḡ": "Ḡ",
  "Ğ": "Ğ",
  "Ǧ": "Ǧ",
  "Ĝ": "Ĝ",
  "Ġ": "Ġ",
  "Ḧ": "Ḧ",
  "Ȟ": "Ȟ",
  "Ĥ": "Ĥ",
  "Ḣ": "Ḣ",
  "Í": "Í",
  "Ì": "Ì",
  "Ï": "Ï",
  "Ḯ": "Ḯ",
  "Ĩ": "Ĩ",
  "Ī": "Ī",
  "Ĭ": "Ĭ",
  "Ǐ": "Ǐ",
  "Î": "Î",
  "İ": "İ",
  "Ĵ": "Ĵ",
  "Ḱ": "Ḱ",
  "Ǩ": "Ǩ",
  "Ĺ": "Ĺ",
  "Ľ": "Ľ",
  "Ḿ": "Ḿ",
  "Ṁ": "Ṁ",
  "Ń": "Ń",
  "Ǹ": "Ǹ",
  "Ñ": "Ñ",
  "Ň": "Ň",
  "Ṅ": "Ṅ",
  "Ó": "Ó",
  "Ò": "Ò",
  "Ö": "Ö",
  "Ȫ": "Ȫ",
  "Õ": "Õ",
  "Ṍ": "Ṍ",
  "Ṏ": "Ṏ",
  "Ȭ": "Ȭ",
  "Ō": "Ō",
  "Ṓ": "Ṓ",
  "Ṑ": "Ṑ",
  "Ŏ": "Ŏ",
  "Ǒ": "Ǒ",
  "Ô": "Ô",
  "Ố": "Ố",
  "Ồ": "Ồ",
  "Ỗ": "Ỗ",
  "Ȯ": "Ȯ",
  "Ȱ": "Ȱ",
  "Ő": "Ő",
  "Ṕ": "Ṕ",
  "Ṗ": "Ṗ",
  "Ŕ": "Ŕ",
  "Ř": "Ř",
  "Ṙ": "Ṙ",
  "Ś": "Ś",
  "Ṥ": "Ṥ",
  "Š": "Š",
  "Ṧ": "Ṧ",
  "Ŝ": "Ŝ",
  "Ṡ": "Ṡ",
  "Ť": "Ť",
  "Ṫ": "Ṫ",
  "Ú": "Ú",
  "Ù": "Ù",
  "Ü": "Ü",
  "Ǘ": "Ǘ",
  "Ǜ": "Ǜ",
  "Ǖ": "Ǖ",
  "Ǚ": "Ǚ",
  "Ũ": "Ũ",
  "Ṹ": "Ṹ",
  "Ū": "Ū",
  "Ṻ": "Ṻ",
  "Ŭ": "Ŭ",
  "Ǔ": "Ǔ",
  "Û": "Û",
  "Ů": "Ů",
  "Ű": "Ű",
  "Ṽ": "Ṽ",
  "Ẃ": "Ẃ",
  "Ẁ": "Ẁ",
  "Ẅ": "Ẅ",
  "Ŵ": "Ŵ",
  "Ẇ": "Ẇ",
  "Ẍ": "Ẍ",
  "Ẋ": "Ẋ",
  "Ý": "Ý",
  "Ỳ": "Ỳ",
  "Ÿ": "Ÿ",
  "Ỹ": "Ỹ",
  "Ȳ": "Ȳ",
  "Ŷ": "Ŷ",
  "Ẏ": "Ẏ",
  "Ź": "Ź",
  "Ž": "Ž",
  "Ẑ": "Ẑ",
  "Ż": "Ż",
  "ά": "ά",
  "ὰ": "ὰ",
  "ᾱ": "ᾱ",
  "ᾰ": "ᾰ",
  "έ": "έ",
  "ὲ": "ὲ",
  "ή": "ή",
  "ὴ": "ὴ",
  "ί": "ί",
  "ὶ": "ὶ",
  "ϊ": "ϊ",
  "ΐ": "ΐ",
  "ῒ": "ῒ",
  "ῑ": "ῑ",
  "ῐ": "ῐ",
  "ό": "ό",
  "ὸ": "ὸ",
  "ύ": "ύ",
  "ὺ": "ὺ",
  "ϋ": "ϋ",
  "ΰ": "ΰ",
  "ῢ": "ῢ",
  "ῡ": "ῡ",
  "ῠ": "ῠ",
  "ώ": "ώ",
  "ὼ": "ὼ",
  "Ύ": "Ύ",
  "Ὺ": "Ὺ",
  "Ϋ": "Ϋ",
  "Ῡ": "Ῡ",
  "Ῠ": "Ῠ",
  "Ώ": "Ώ",
  "Ὼ": "Ὼ"
};

/* eslint no-constant-condition:0 */

const binLeftCancellers = ["bin", "op", "open", "punct", "rel"];
const sizeRegEx = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/;
const textRegEx = /^ *\\text/;

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.gullet.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The functions return ParseNodes.
 */

class Parser {
  constructor(input, settings, isPreamble = false) {
    // Start in math mode
    this.mode = "math";
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings, this.mode);
    // Store the settings for use in parsing
    this.settings = settings;
    // Are we defining a preamble?
    this.isPreamble = isPreamble;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
    this.prevAtomType = "";
  }

  /**
   * Checks a result to make sure it has the right type, and throws an
   * appropriate error otherwise.
   */
  expect(text, consume = true) {
    if (this.fetch().text !== text) {
      throw new ParseError(`Expected '${text}', got '${this.fetch().text}'`, this.fetch());
    }
    if (consume) {
      this.consume();
    }
  }

  /**
   * Discards the current lookahead token, considering it consumed.
   */
  consume() {
    this.nextToken = null;
  }

  /**
   * Return the current lookahead token, or if there isn't one (at the
   * beginning, or if the previous lookahead token was consume()d),
   * fetch the next token as the new lookahead token and return it.
   */
  fetch() {
    if (this.nextToken == null) {
      this.nextToken = this.gullet.expandNextToken();
    }
    return this.nextToken;
  }

  /**
   * Switches between "text" and "math" modes.
   */
  switchMode(newMode) {
    this.mode = newMode;
    this.gullet.switchMode(newMode);
  }

  /**
   * Main parsing function, which parses an entire input.
   */
  parse() {
    // Create a group namespace for every $...$, $$...$$, \[...\].)
    // A \def is then valid only within that pair of delimiters.
    this.gullet.beginGroup();

    if (this.settings.colorIsTextColor) {
      // Use old \color behavior (same as LaTeX's \textcolor) if requested.
      // We do this within the group for the math expression, so it doesn't
      // pollute settings.macros.
      this.gullet.macros.set("\\color", "\\textcolor");
    }

    // Try to parse the input
    const parse = this.parseExpression(false);

    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF");

    if (this.isPreamble) {
      const macros = Object.create(null);
      Object.entries(this.gullet.macros.current).forEach(([key, value]) => {
        macros[key] = value;
      });
      this.gullet.endGroup();
      return macros
    }

    // The only local macro that we want to save is from \tag.
    const tag = this.gullet.macros.get("\\df@tag");

    // End the group namespace for the expression
    this.gullet.endGroup();

    if (tag) { this.gullet.macros.current["\\df@tag"] = tag; }

    return parse;
  }

  static get endOfExpression() {
    return ["}", "\\endgroup", "\\end", "\\right", "\\endtoggle", "&"];
  }

  /**
   * Fully parse a separate sequence of tokens as a separate job.
   * Tokens should be specified in reverse order, as in a MacroDefinition.
   */
  subparse(tokens) {
    // Save the next token from the current job.
    const oldToken = this.nextToken;
    this.consume();

    // Run the new job, terminating it with an excess '}'
    this.gullet.pushToken(new Token("}"));
    this.gullet.pushTokens(tokens);
    const parse = this.parseExpression(false);
    this.expect("}");

    // Restore the next token from the current job.
    this.nextToken = oldToken;

    return parse;
  }

/**
   * Parses an "expression", which is a list of atoms.
   *
   * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
   *                 happens when functions have higher precedence han infix
   *                 nodes in implicit parses.
   *
   * `breakOnTokenText`: The text of the token that the expression should end
   *                     with, or `null` if something else should end the
   *                     expression.
   *
   * `breakOnMiddle`: \color, \over, and old styling functions work on an implicit group.
   *                  These groups end just before the usual tokens, but they also
   *                  end just before `\middle`.
   */
  parseExpression(breakOnInfix, breakOnTokenText, breakOnMiddle) {
    const body = [];
    this.prevAtomType = "";
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
      // Ignore spaces in math mode
      if (this.mode === "math") {
        this.consumeSpaces();
      }
      const lex = this.fetch();
      if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
        break;
      }
      if (breakOnTokenText && lex.text === breakOnTokenText) {
        break;
      }
      if (breakOnMiddle && lex.text === "\\middle") {
        break
      }
      if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
        break;
      }
      const atom = this.parseAtom(breakOnTokenText);
      if (!atom) {
        break;
      } else if (atom.type === "internal") {
        continue;
      }
      body.push(atom);
      // Keep a record of the atom type, so that op.js can set correct spacing.
      this.prevAtomType = atom.type === "atom" ? atom.family : atom.type;
    }
    if (this.mode === "text") {
      this.formLigatures(body);
    }
    return this.handleInfixNodes(body);
  }

  /**
   * Rewrites infix operators such as \over with corresponding commands such
   * as \frac.
   *
   * There can only be one infix operator per group.  If there's more than one
   * then the expression is ambiguous.  This can be resolved by adding {}.
   */
  handleInfixNodes(body) {
    let overIndex = -1;
    let funcName;

    for (let i = 0; i < body.length; i++) {
      if (body[i].type === "infix") {
        if (overIndex !== -1) {
          throw new ParseError("only one infix operator per group", body[i].token);
        }
        overIndex = i;
        funcName = body[i].replaceWith;
      }
    }

    if (overIndex !== -1 && funcName) {
      let numerNode;
      let denomNode;

      const numerBody = body.slice(0, overIndex);
      const denomBody = body.slice(overIndex + 1);

      if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
        numerNode = numerBody[0];
      } else {
        numerNode = { type: "ordgroup", mode: this.mode, body: numerBody };
      }

      if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
        denomNode = denomBody[0];
      } else {
        denomNode = { type: "ordgroup", mode: this.mode, body: denomBody };
      }

      let node;
      if (funcName === "\\\\abovefrac") {
        node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
      } else {
        node = this.callFunction(funcName, [numerNode, denomNode], []);
      }
      return [node];
    } else {
      return body;
    }
  }

  /**
   * Handle a subscript or superscript with nice errors.
   */
  handleSupSubscript(
    name // For error reporting.
  ) {
    const symbolToken = this.fetch();
    const symbol = symbolToken.text;
    this.consume();
    this.consumeSpaces(); // ignore spaces before sup/subscript argument
    const group = this.parseGroup(name);

    if (!group) {
      throw new ParseError("Expected group after '" + symbol + "'", symbolToken);
    }

    return group;
  }

  /**
   * Converts the textual input of an unsupported command into a text node
   * contained within a color node whose color is determined by errorColor
   */
  formatUnsupportedCmd(text) {
    const textordArray = [];

    for (let i = 0; i < text.length; i++) {
      textordArray.push({ type: "textord", mode: "text", text: text[i] });
    }

    const textNode = {
      type: "text",
      mode: this.mode,
      body: textordArray
    };

    const colorNode = {
      type: "color",
      mode: this.mode,
      color: this.settings.errorColor,
      body: [textNode]
    };

    return colorNode;
  }

  /**
   * Parses a group with optional super/subscripts.
   */
  parseAtom(breakOnTokenText) {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    const base = this.parseGroup("atom", breakOnTokenText);

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
      return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    let superscript;
    let subscript;
    while (true) {
      // Guaranteed in math mode, so eat any spaces first.
      this.consumeSpaces();

      // Lex the first token
      const lex = this.fetch();

      if (lex.text === "\\limits" || lex.text === "\\nolimits") {
        // We got a limit control
        if (base && base.type === "op") {
          const limits = lex.text === "\\limits";
          base.limits = limits;
          base.alwaysHandleSupSub = true;
        } else if (base && base.type === "operatorname") {
          if (base.alwaysHandleSupSub) {
            base.limits = lex.text === "\\limits";
          }
        } else {
          throw new ParseError("Limit controls must follow a math operator", lex);
        }
        this.consume();
      } else if (lex.text === "^") {
        // We got a superscript start
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        superscript = this.handleSupSubscript("superscript");
      } else if (lex.text === "_") {
        // We got a subscript start
        if (subscript) {
          throw new ParseError("Double subscript", lex);
        }
        subscript = this.handleSupSubscript("subscript");
      } else if (lex.text === "'") {
        // We got a prime
        if (superscript) {
          throw new ParseError("Double superscript", lex);
        }
        const prime = { type: "textord", mode: this.mode, text: "\\prime" };

        // Many primes can be grouped together, so we handle this here
        const primes = [prime];
        this.consume();
        // Keep lexing tokens until we get something that's not a prime
        while (this.fetch().text === "'") {
          // For each one, add another prime to the list
          primes.push(prime);
          this.consume();
        }
        // If there's a superscript following the primes, combine that
        // superscript in with the primes.
        if (this.fetch().text === "^") {
          primes.push(this.handleSupSubscript("superscript"));
        }
        // Put everything into an ordgroup as the superscript
        superscript = { type: "ordgroup", mode: this.mode, body: primes };
      } else if (uSubsAndSups[lex.text]) {
        // A Unicode subscript or superscript character.
        // We treat these similarly to the unicode-math package.
        // So we render a string of Unicode (sub|super)scripts the
        // same as a (sub|super)script of regular characters.
        const isSub = unicodeSubRegEx.test(lex.text);
        const subsupTokens = [];
        subsupTokens.push(new Token(uSubsAndSups[lex.text]));
        this.consume();
        // Continue fetching tokens to fill out the group.
        while (true) {
          const token = this.fetch().text;
          if (!(uSubsAndSups[token])) { break }
          if (unicodeSubRegEx.test(token) !== isSub) { break }
          subsupTokens.unshift(new Token(uSubsAndSups[token]));
          this.consume();
        }
        // Now create a (sub|super)script.
        const body = this.subparse(subsupTokens);
        if (isSub) {
          subscript = { type: "ordgroup", mode: "math", body };
        } else {
          superscript = { type: "ordgroup", mode: "math", body };
        }
      } else {
        // If it wasn't ^, _, a Unicode (sub|super)script, or ', stop parsing super/subscripts
        break;
      }
    }

    if (superscript || subscript) {
      if (base && base.type === "multiscript" && !base.postscripts) {
        // base is the result of a \prescript function.
        // Write the sub- & superscripts into the multiscript element.
        base.postscripts = { sup: superscript, sub: subscript };
        return base
      } else {
        // We got either a superscript or subscript, create a supsub
        const isFollowedByDelimiter = (!base || base.type !== "op" && base.type !== "operatorname")
          ? undefined
          : isDelimiter(this.nextToken.text);
        return {
          type: "supsub",
          mode: this.mode,
          base: base,
          sup: superscript,
          sub: subscript,
          isFollowedByDelimiter
        }
      }
    } else {
      // Otherwise return the original body
      return base;
    }
  }

  /**
   * Parses an entire function, including its base and all of its arguments.
   */
  parseFunction(
    breakOnTokenText,
    name // For determining its context
  ) {
    const token = this.fetch();
    const func = token.text;
    const funcData = functions[func];
    if (!funcData) {
      return null;
    }
    this.consume(); // consume command token

    if (name && name !== "atom" && !funcData.allowedInArgument) {
      throw new ParseError(
        "Got function '" + func + "' with no arguments" + (name ? " as " + name : ""),
        token
      );
    } else if (this.mode === "text" && !funcData.allowedInText) {
      throw new ParseError("Can't use function '" + func + "' in text mode", token);
    } else if (this.mode === "math" && funcData.allowedInMath === false) {
      throw new ParseError("Can't use function '" + func + "' in math mode", token);
    }

    const prevAtomType = this.prevAtomType;
    const { args, optArgs } = this.parseArguments(func, funcData);
    this.prevAtomType = prevAtomType;
    return this.callFunction(func, args, optArgs, token, breakOnTokenText);
  }

  /**
   * Call a function handler with a suitable context and arguments.
   */
  callFunction(name, args, optArgs, token, breakOnTokenText) {
    const context = {
      funcName: name,
      parser: this,
      token,
      breakOnTokenText
    };
    const func = functions[name];
    if (func && func.handler) {
      return func.handler(context, args, optArgs);
    } else {
      throw new ParseError(`No function handler for ${name}`);
    }
  }

  /**
   * Parses the arguments of a function or environment
   */
  parseArguments(
    func, // Should look like "\name" or "\begin{name}".
    funcData
  ) {
    const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
      return { args: [], optArgs: [] };
    }

    const args = [];
    const optArgs = [];

    for (let i = 0; i < totalArgs; i++) {
      let argType = funcData.argTypes && funcData.argTypes[i];
      const isOptional = i < funcData.numOptionalArgs;

      if (
        (funcData.primitive && argType == null) ||
        // \sqrt expands into primitive if optional argument doesn't exist
        (funcData.type === "sqrt" && i === 1 && optArgs[0] == null)
      ) {
        argType = "primitive";
      }

      const arg = this.parseGroupOfType(`argument to '${func}'`, argType, isOptional);
      if (isOptional) {
        optArgs.push(arg);
      } else if (arg != null) {
        args.push(arg);
      } else {
        // should be unreachable
        throw new ParseError("Null argument, please report this as a bug");
      }
    }

    return { args, optArgs };
  }

  /**
   * Parses a group when the mode is changing.
   */
  parseGroupOfType(name, type, optional) {
    switch (type) {
      case "size":
        return this.parseSizeGroup(optional);
      case "url":
        return this.parseUrlGroup(optional);
      case "math":
      case "text":
        return this.parseArgumentGroup(optional, type);
      case "hbox": {
        // hbox argument type wraps the argument in the equivalent of
        // \hbox, which is like \text but switching to \textstyle size.
        const group = this.parseArgumentGroup(optional, "text");
        return group != null
          ? {
            type: "styling",
            mode: group.mode,
            body: [group],
            scriptLevel: "text" // simulate \textstyle
          }
          : null;
      }
      case "raw": {
        const token = this.parseStringGroup("raw", optional);
        return token != null
          ? {
            type: "raw",
            mode: "text",
            string: token.text
          }
          : null;
      }
      case "primitive": {
        if (optional) {
          throw new ParseError("A primitive argument cannot be optional");
        }
        const group = this.parseGroup(name);
        if (group == null) {
          throw new ParseError("Expected group as " + name, this.fetch());
        }
        return group;
      }
      case "original":
      case null:
      case undefined:
        return this.parseArgumentGroup(optional);
      default:
        throw new ParseError("Unknown group type as " + name, this.fetch());
    }
  }

  /**
   * Discard any space tokens, fetching the next non-space token.
   */
  consumeSpaces() {
    while (true) {
      const ch = this.fetch().text;
      // \ufe0e is the Unicode variation selector to supress emoji. Ignore it.
      if (ch === " " || ch === "\u00a0" || ch === "\ufe0e") {
        this.consume();
      } else {
        break
      }
    }
  }

  /**
   * Parses a group, essentially returning the string formed by the
   * brace-enclosed tokens plus some position information.
   */
  parseStringGroup(
    modeName, // Used to describe the mode in error messages.
    optional
  ) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF") {
      str += nextToken.text;
      this.consume();
    }
    this.consume(); // consume the end of the argument
    argToken.text = str;
    return argToken;
  }

  /**
   * Parses a regex-delimited group: the largest sequence of tokens
   * whose concatenated strings match `regex`. Returns the string
   * formed by the tokens plus some position information.
   */
  parseRegexGroup(
    regex,
    modeName // Used to describe the mode in error messages.
  ) {
    const firstToken = this.fetch();
    let lastToken = firstToken;
    let str = "";
    let nextToken;
    while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
      lastToken = nextToken;
      str += lastToken.text;
      this.consume();
    }
    if (str === "") {
      throw new ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
    }
    return firstToken.range(lastToken, str);
  }

  /**
   * Parses a size specification, consisting of magnitude and unit.
   */
  parseSizeGroup(optional) {
    let res;
    let isBlank = false;
    // don't expand before parseStringGroup
    this.gullet.consumeSpaces();
    if (!optional && this.gullet.future().text !== "{") {
      res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
    } else {
      res = this.parseStringGroup("size", optional);
    }
    if (!res) {
      return null;
    }
    if (!optional && res.text.length === 0) {
      // Because we've tested for what is !optional, this block won't
      // affect \kern, \hspace, etc. It will capture the mandatory arguments
      // to \genfrac and \above.
      res.text = "0pt"; // Enable \above{}
      isBlank = true; // This is here specifically for \genfrac
    }
    const match = sizeRegEx.exec(res.text);
    if (!match) {
      throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    const data = {
      number: +(match[1] + match[2]), // sign + magnitude, cast to number
      unit: match[3]
    };
    if (!validUnit(data)) {
      throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return {
      type: "size",
      mode: this.mode,
      value: data,
      isBlank
    };
  }

  /**
   * Parses an URL, checking escaped letters and allowed protocols,
   * and setting the catcode of % as an active character (as in \hyperref).
   */
  parseUrlGroup(optional) {
    this.gullet.lexer.setCatcode("%", 13); // active character
    this.gullet.lexer.setCatcode("~", 12); // other character
    const res = this.parseStringGroup("url", optional);
    this.gullet.lexer.setCatcode("%", 14); // comment character
    this.gullet.lexer.setCatcode("~", 13); // active character
    if (res == null) {
      return null;
    }
    // hyperref package allows backslashes alone in href, but doesn't
    // generate valid links in such cases; we interpret this as
    // "undefined" behaviour, and keep them as-is. Some browser will
    // replace backslashes with forward slashes.
    let url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
    url = res.text.replace(/{\u2044}/g, "/");
    return {
      type: "url",
      mode: this.mode,
      url
    };
  }

  /**
   * Parses an argument with the mode specified.
   */
  parseArgumentGroup(optional, mode) {
    const argToken = this.gullet.scanArgument(optional);
    if (argToken == null) {
      return null;
    }
    const outerMode = this.mode;
    if (mode) {
      // Switch to specified mode
      this.switchMode(mode);
    }

    this.gullet.beginGroup();
    const expression = this.parseExpression(false, "EOF");
    // TODO: find an alternative way to denote the end
    this.expect("EOF"); // expect the end of the argument
    this.gullet.endGroup();
    const result = {
      type: "ordgroup",
      mode: this.mode,
      loc: argToken.loc,
      body: expression
    };

    if (mode) {
      // Switch mode back
      this.switchMode(outerMode);
    }
    return result;
  }

  /**
   * Parses an ordinary group, which is either a single nucleus (like "x")
   * or an expression in braces (like "{x+y}") or an implicit group, a group
   * that starts at the current position, and ends right before a higher explicit
   * group ends, or at EOF.
   */
  parseGroup(
    name, // For error reporting.
    breakOnTokenText
  ) {
    const firstToken = this.fetch();
    const text = firstToken.text;

    let result;
    // Try to parse an open brace or \begingroup
    if (text === "{" || text === "\\begingroup" || text === "\\toggle") {
      this.consume();
      const groupEnd = text === "{"
        ? "}"
        : text === "\\begingroup"
        ? "\\endgroup"
        : "\\endtoggle";

      this.gullet.beginGroup();
      // If we get a brace, parse an expression
      const expression = this.parseExpression(false, groupEnd);
      const lastToken = this.fetch();
      this.expect(groupEnd); // Check that we got a matching closing brace
      this.gullet.endGroup();
      result = {
        type: (lastToken.text === "\\endtoggle" ? "toggle" : "ordgroup"),
        mode: this.mode,
        loc: SourceLocation.range(firstToken, lastToken),
        body: expression,
        // A group formed by \begingroup...\endgroup is a semi-simple group
        // which doesn't affect spacing in math mode, i.e., is transparent.
        // https://tex.stackexchange.com/questions/1930/
        semisimple: text === "\\begingroup" || undefined
      };
    } else {
      // If there exists a function with this name, parse the function.
      // Otherwise, just return a nucleus
      result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
      if (result == null && text[0] === "\\" &&
          !Object.prototype.hasOwnProperty.call(implicitCommands, text )) {
        result = this.formatUnsupportedCmd(text);
        this.consume();
      }
    }
    return result;
  }

  /**
   * Form ligature-like combinations of characters for text mode.
   * This includes inputs like "--", "---", "``" and "''".
   * The result will simply replace multiple textord nodes with a single
   * character in each value by a single textord node having multiple
   * characters in its value.  The representation is still ASCII source.
   * The group will be modified in place.
   */
  formLigatures(group) {
    let n = group.length - 1;
    for (let i = 0; i < n; ++i) {
      const a = group[i];
      const v = a.text;
      if (v === "-" && group[i + 1].text === "-") {
        if (i + 1 < n && group[i + 2].text === "-") {
          group.splice(i, 3, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 2]),
            text: "---"
          });
          n -= 2;
        } else {
          group.splice(i, 2, {
            type: "textord",
            mode: "text",
            loc: SourceLocation.range(a, group[i + 1]),
            text: "--"
          });
          n -= 1;
        }
      }
      if ((v === "'" || v === "`") && group[i + 1].text === v) {
        group.splice(i, 2, {
          type: "textord",
          mode: "text",
          loc: SourceLocation.range(a, group[i + 1]),
          text: v + v
        });
        n -= 1;
      }
    }
  }

  /**
   * Parse a single symbol out of the string. Here, we handle single character
   * symbols and special functions like \verb.
   */
  parseSymbol() {
    const nucleus = this.fetch();
    let text = nucleus.text;

    if (/^\\verb[^a-zA-Z]/.test(text)) {
      this.consume();
      let arg = text.slice(5);
      const star = arg.charAt(0) === "*";
      if (star) {
        arg = arg.slice(1);
      }
      // Lexer's tokenRegex is constructed to always have matching
      // first/last characters.
      if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
        throw new ParseError(`\\verb assertion failed --
                    please report what input caused this bug`);
      }
      arg = arg.slice(1, -1); // remove first and last char
      return {
        type: "verb",
        mode: "text",
        body: arg,
        star
      };
    }
    // At this point, we should have a symbol, possibly with accents.
    // First expand any accented base symbol according to unicodeSymbols.
    if (Object.prototype.hasOwnProperty.call(unicodeSymbols, text[0]) &&
      this.mode === "math" && !symbols[this.mode][text[0]]) {
      // This behavior is not strict (XeTeX-compatible) in math mode.
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Accented Unicode text character "${text[0]}" used in ` + `math mode`,
          nucleus
        );
      }
      text = unicodeSymbols[text[0]] + text.slice(1);
    }
    // Strip off any combining characters
    const match = this.mode === "math"
      ? combiningDiacriticalMarksEndRegex.exec(text)
      : null;
    if (match) {
      text = text.substring(0, match.index);
      if (text === "i") {
        text = "\u0131"; // dotless i, in math and text mode
      } else if (text === "j") {
        text = "\u0237"; // dotless j, in math and text mode
      }
    }
    // Recognize base symbol
    let symbol;
    if (symbols[this.mode][text]) {
      let group = symbols[this.mode][text].group;
      if (group === "bin" && binLeftCancellers.includes(this.prevAtomType)) {
        // Change from a binary operator to a unary (prefix) operator
        group = "open";
      }
      const loc = SourceLocation.range(nucleus);
      let s;
      if (Object.prototype.hasOwnProperty.call(ATOMS, group )) {
        const family = group;
        s = {
          type: "atom",
          mode: this.mode,
          family,
          loc,
          text
        };
        if ((family === "rel" || family === "bin") && this.prevAtomType === "text") {
          if (textRegEx.test(loc.lexer.input.slice(loc.end))) {
            s.needsSpacing = true;  // Fix a MathML bug.
          }
        }
      } else {
        if (asciiFromScript[text]) {
          // Unicode 14 disambiguates chancery from roundhand.
          // See https://www.unicode.org/charts/PDF/U1D400.pdf
          this.consume();
          const nextCode = this.fetch().text.charCodeAt(0);
          // mathcal is Temml default. Use mathscript if called for.
          const font = nextCode === 0xfe01 ? "mathscr" : "mathcal";
          if (nextCode === 0xfe00 || nextCode === 0xfe01) { this.consume(); }
          return {
            type: "font",
            mode: "math",
            font,
            body: { type: "mathord", mode: "math", loc, text: asciiFromScript[text] }
          }
        }
        // Default ord character. No disambiguation necessary.
        s = {
          type: group,
          mode: this.mode,
          loc,
          text
        };
      }
      symbol = s;
    } else if (text.charCodeAt(0) >= 0x80 || combiningDiacriticalMarksEndRegex.exec(text)) {
      // no symbol for e.g. ^
      if (this.settings.strict && this.mode === "math") {
        throw new ParseError(`Unicode text character "${text[0]}" used in math mode`, nucleus)
      }
      // All nonmathematical Unicode characters are rendered as if they
      // are in text mode (wrapped in \text) because that's what it
      // takes to render them in LaTeX.
      symbol = {
        type: "textord",
        mode: "text",
        loc: SourceLocation.range(nucleus),
        text
      };
    } else {
      return null; // EOF, ^, _, {, }, etc.
    }
    this.consume();
    // Transform combining characters into accents
    if (match) {
      for (let i = 0; i < match[0].length; i++) {
        const accent = match[0][i];
        if (!unicodeAccents[accent]) {
          throw new ParseError(`Unknown accent ' ${accent}'`, nucleus);
        }
        const command = unicodeAccents[accent][this.mode] ||
                        unicodeAccents[accent].text;
        if (!command) {
          throw new ParseError(`Accent ${accent} unsupported in ${this.mode} mode`, nucleus);
        }
        symbol = {
          type: "accent",
          mode: this.mode,
          loc: SourceLocation.range(nucleus),
          label: command,
          isStretchy: false,
          base: symbol
        };
      }
    }
    return symbol;
  }
}

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
const parseTree = function(toParse, settings) {
  if (!(typeof toParse === "string" || toParse instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(toParse, settings);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];

  let tree = parser.parse();

  // LaTeX ignores a \tag placed outside an AMS environment.
  if (!(tree.length > 0 &&  tree[0].type && tree[0].type === "array" && tree[0].addEqnNum)) {
    // If the input used \tag, it will set the \df@tag macro to the tag.
    // In this case, we separately parse the tag and wrap the tree.
    if (parser.gullet.macros.get("\\df@tag")) {
      if (!settings.displayMode) {
        throw new ParseError("\\tag works only in display mode")
      }
      parser.gullet.feed("\\df@tag");
      tree = [
        {
          type: "tag",
          mode: "text",
          body: tree,
          tag: parser.parse()
        }
      ];
    }
  }

  return tree
};

/**
 * This file contains information about the style that the mathmlBuilder carries
 * around with it. Data is held in an `Style` object, and when
 * recursing, a new `Style` object can be created with the `.with*` functions.
 */

const subOrSupLevel = [2, 2, 3, 3];

/**
 * This is the main Style class. It contains the current style.level, color, and font.
 *
 * Style objects should not be modified. To create a new Style with
 * different properties, call a `.with*` method.
 */
class Style {
  constructor(data) {
    // Style.level can be 0 | 1 | 2 | 3, which correspond to
    //       displaystyle, textstyle, scriptstyle, and scriptscriptstyle.
    // style.level usually does not directly set MathML's script level. MathML does that itself.
    // However, Chromium does not stop shrinking after scriptscriptstyle, so we do explicitly
    // set a scriptlevel attribute in those conditions.
    // We also use style.level to track math style so that we can get the correct
    // scriptlevel when needed in supsub.js, mathchoice.js, or for dimensions in em.
    this.level = data.level;
    this.color = data.color;  // string | void
    // A font family applies to a group of fonts (i.e. SansSerif), while a font
    // represents a specific font (i.e. SansSerif Bold).
    // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
    this.font = data.font || "";                // string
    this.fontFamily = data.fontFamily || "";    // string
    this.fontSize = data.fontSize || 1.0;       // number
    this.fontWeight = data.fontWeight || "";
    this.fontShape = data.fontShape || "";
    this.maxSize = data.maxSize;                // [number, number]
  }

  /**
   * Returns a new style object with the same properties as "this".  Properties
   * from "extension" will be copied to the new style object.
   */
  extend(extension) {
    const data = {
      level: this.level,
      color: this.color,
      font: this.font,
      fontFamily: this.fontFamily,
      fontSize: this.fontSize,
      fontWeight: this.fontWeight,
      fontShape: this.fontShape,
      maxSize: this.maxSize
    };

    for (const key in extension) {
      if (Object.prototype.hasOwnProperty.call(extension, key)) {
        data[key] = extension[key];
      }
    }

    return new Style(data);
  }

  withLevel(n) {
    return this.extend({
      level: n
    });
  }

  incrementLevel() {
    return this.extend({
      level: Math.min(this.level + 1, 3)
    });
  }

  inSubOrSup() {
    return this.extend({
      level: subOrSupLevel[this.level]
    })
  }

  /**
   * Create a new style object with the given color.
   */
  withColor(color) {
    return this.extend({
      color: color
    });
  }

  /**
   * Creates a new style object with the given math font or old text font.
   * @type {[type]}
   */
  withFont(font) {
    return this.extend({
      font
    });
  }

  /**
   * Create a new style objects with the given fontFamily.
   */
  withTextFontFamily(fontFamily) {
    return this.extend({
      fontFamily,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font size
   */
  withFontSize(num) {
    return this.extend({
      fontSize: num
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontWeight(fontWeight) {
    return this.extend({
      fontWeight,
      font: ""
    });
  }

  /**
   * Creates a new style object with the given font weight
   */
  withTextFontShape(fontShape) {
    return this.extend({
      fontShape,
      font: ""
    });
  }

  /**
   * Gets the CSS color of the current style object
   */
  getColor() {
    return this.color;
  }
}

/* Temml Post Process
 * Populate the text contents of each \ref & \eqref
 *
 * As with other Temml code, this file is released under terms of the MIT license.
 * https://mit-license.org/
 */

const version = "0.11.02";

function postProcess(block) {
  const labelMap = {};
  let i = 0;

  // Get a collection of the parents of each \tag & auto-numbered equation
  const amsEqns = document.getElementsByClassName('tml-eqn');
  for (let parent of amsEqns) {
    // AMS automatically numbered equation.
    // Assign an id.
    i += 1;
    parent.setAttribute("id", "tml-eqn-" + String(i));
    // No need to write a number into the text content of the element.
    // A CSS counter has done that even if this postProcess() function is not used.

    // Find any \label that refers to an AMS automatic eqn number.
    while (true) {
      if (parent.tagName === "mtable") { break }
      const labels = parent.getElementsByClassName("tml-label");
      if (labels.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = String(i);
        break
      } else {
        parent = parent.parentElement;
      }
    }
  }

  // Find \labels associated with \tag
  const taggedEqns = document.getElementsByClassName('tml-tageqn');
  for (const parent of taggedEqns) {
    const labels = parent.getElementsByClassName("tml-label");
    if (labels.length > 0) {
      const tags = parent.getElementsByClassName("tml-tag");
      if (tags.length > 0) {
        const id = parent.attributes.id.value;
        labelMap[id] = tags[0].textContent;
      }
    }
  }

  // Populate \ref & \eqref text content
  const refs = block.getElementsByClassName("tml-ref");
  [...refs].forEach(ref => {
    const attr = ref.getAttribute("href");
    let str = labelMap[attr.slice(1)];
    if (ref.className.indexOf("tml-eqref") === -1) {
      // \ref. Omit parens.
      str = str.replace(/^\(/, "");
      str = str.replace(/\)$/, "");
    } else {
      // \eqref. Include parens
      if (str.charAt(0) !== "(") { str = "(" + str; }
      if (str.slice(-1) !== ")") { str =  str + ")"; }
    }
    const mtext = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mtext");
    mtext.appendChild(document.createTextNode(str));
    const math =  document.createElementNS("http://www.w3.org/1998/Math/MathML", "math");
    math.appendChild(mtext);
    ref.textContent = '';
    ref.appendChild(math);
  });
}

const findEndOfMath = function(delimiter, text, startIndex) {
  // Adapted from
  // https://github.com/Khan/perseus/blob/master/src/perseus-markdown.jsx
  let index = startIndex;
  let braceLevel = 0;

  const delimLength = delimiter.length;

  while (index < text.length) {
    const character = text[index];

    if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter) {
      return index;
    } else if (character === "\\") {
      index++;
    } else if (character === "{") {
      braceLevel++;
    } else if (character === "}") {
      braceLevel--;
    }

    index++;
  }

  return -1;
};

const escapeRegex = function(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
};

const amsRegex = /^\\(?:begin|(?:eq)?ref){/;

const splitAtDelimiters = function(text, delimiters) {
  let index;
  const data = [];

  const regexLeft = new RegExp(
    "(" + delimiters.map((x) => escapeRegex(x.left)).join("|") + ")"
  );

  while (true) {
    index = text.search(regexLeft);
    if (index === -1) {
      break;
    }
    if (index > 0) {
      data.push({
        type: "text",
        data: text.slice(0, index)
      });
      text = text.slice(index); // now text starts with delimiter
    }
    // ... so this always succeeds:
    const i = delimiters.findIndex((delim) => text.startsWith(delim.left));
    index = findEndOfMath(delimiters[i].right, text, delimiters[i].left.length);
    if (index === -1) {
      break;
    }
    const rawData = text.slice(0, index + delimiters[i].right.length);
    const math = amsRegex.test(rawData)
      ? rawData
      : text.slice(delimiters[i].left.length, index);
    data.push({
      type: "math",
      data: math,
      rawData,
      display: delimiters[i].display
    });
    text = text.slice(index + delimiters[i].right.length);
  }

  if (text !== "") {
    data.push({
      type: "text",
      data: text
    });
  }

  return data;
};

const defaultDelimiters = [
  { left: "$$", right: "$$", display: true },
  { left: "\\(", right: "\\)", display: false },
  // LaTeX uses $…$, but it ruins the display of normal `$` in text:
  // {left: "$", right: "$", display: false},
  // $ must come after $$

  // Render AMS environments even if outside $$…$$ delimiters.
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  // Ditto \ref & \eqref
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false },

  { left: "\\[", right: "\\]", display: true }
];

const firstDraftDelimiters = {
  "$": [
         { left: "$$", right: "$$", display: true },
         { left: "$`", right: "`$", display: false },
         { left: "$", right: "$", display: false }
  ],
  "(": [
    { left: "\\[", right: "\\]", display: true },
    { left: "\\(", right: "\\)", display: false }
  ]
};

const amsDelimiters = [
  { left: "\\begin{equation}", right: "\\end{equation}", display: true },
  { left: "\\begin{equation*}", right: "\\end{equation*}", display: true },
  { left: "\\begin{align}", right: "\\end{align}", display: true },
  { left: "\\begin{align*}", right: "\\end{align*}", display: true },
  { left: "\\begin{alignat}", right: "\\end{alignat}", display: true },
  { left: "\\begin{alignat*}", right: "\\end{alignat*}", display: true },
  { left: "\\begin{gather}", right: "\\end{gather}", display: true },
  { left: "\\begin{gather*}", right: "\\end{gather*}", display: true },
  { left: "\\begin{CD}", right: "\\end{CD}", display: true },
  { left: "\\ref{", right: "}", display: false },
  { left: "\\eqref{", right: "}", display: false }
];

const delimitersFromKey = key => {
  if (key === "$" || key === "(") {
    return firstDraftDelimiters[key];
  } else if (key === "$+" || key === "(+") {
    const firstDraft = firstDraftDelimiters[key.slice(0, 1)];
    return firstDraft.concat(amsDelimiters)
  } else if (key === "ams") {
    return amsDelimiters
  } else if (key === "all") {
    return (firstDraftDelimiters["("]).concat(firstDraftDelimiters["$"]).concat(amsDelimiters)
  } else {
    return defaultDelimiters
  }
};

/* Note: optionsCopy is mutated by this method. If it is ever exposed in the
 * API, we should copy it before mutating.
 */
const renderMathInText = function(text, optionsCopy) {
  const data = splitAtDelimiters(text, optionsCopy.delimiters);
  if (data.length === 1 && data[0].type === "text") {
    // There is no formula in the text.
    // Let's return null which means there is no need to replace
    // the current text node with a new one.
    return null;
  }

  const fragment = document.createDocumentFragment();

  for (let i = 0; i < data.length; i++) {
    if (data[i].type === "text") {
      fragment.appendChild(document.createTextNode(data[i].data));
    } else {
      const span = document.createElement("span");
      let math = data[i].data;
      // Override any display mode defined in the settings with that
      // defined by the text itself
      optionsCopy.displayMode = data[i].display;
      try {
        if (optionsCopy.preProcess) {
          math = optionsCopy.preProcess(math);
        }
        // Importing render() from temml.js would be a circular dependency.
        // So call the global version.
        // eslint-disable-next-line no-undef
        temml.render(math, span, optionsCopy);
      } catch (e) {
        if (!(e instanceof ParseError)) {
          throw e;
        }
        optionsCopy.errorCallback(
          "Temml auto-render: Failed to parse `" + data[i].data + "` with ",
          e
        );
        fragment.appendChild(document.createTextNode(data[i].rawData));
        continue;
      }
      fragment.appendChild(span);
    }
  }

  return fragment;
};

const renderElem = function(elem, optionsCopy) {
  for (let i = 0; i < elem.childNodes.length; i++) {
    const childNode = elem.childNodes[i];
    if (childNode.nodeType === 3) {
      // Text node
      const frag = renderMathInText(childNode.textContent, optionsCopy);
      if (frag) {
        i += frag.childNodes.length - 1;
        elem.replaceChild(frag, childNode);
      }
    } else if (childNode.nodeType === 1) {
      // Element node
      const className = " " + childNode.className + " ";
      const shouldRender =
        optionsCopy.ignoredTags.indexOf(childNode.nodeName.toLowerCase()) === -1 &&
        optionsCopy.ignoredClasses.every((x) => className.indexOf(" " + x + " ") === -1);

      if (shouldRender) {
        renderElem(childNode, optionsCopy);
      }
    }
    // Otherwise, it's something else, and ignore it.
  }
};

const renderMathInElement = function(elem, options) {
  if (!elem) {
    throw new Error("No element provided to render");
  }

  const optionsCopy = {};

  // Object.assign(optionsCopy, option)
  for (const option in options) {
    if (Object.prototype.hasOwnProperty.call(options, option)) {
      optionsCopy[option] = options[option];
    }
  }

  if (optionsCopy.fences) {
    optionsCopy.delimiters = delimitersFromKey(optionsCopy.fences);
  } else {
    optionsCopy.delimiters = optionsCopy.delimiters || defaultDelimiters;
  }
  optionsCopy.ignoredTags = optionsCopy.ignoredTags || [
    "script",
    "noscript",
    "style",
    "textarea",
    "pre",
    "code",
    "option"
  ];
  optionsCopy.ignoredClasses = optionsCopy.ignoredClasses || [];
  // eslint-disable-next-line no-console
  optionsCopy.errorCallback = optionsCopy.errorCallback || console.error;

  // Enable sharing of global macros defined via `\gdef` between different
  // math elements within a single call to `renderMathInElement`.
  optionsCopy.macros = optionsCopy.macros || {};

  renderElem(elem, optionsCopy);
  postProcess(elem);
};

/* eslint no-console:0 */
/**
 * This is the main entry point for Temml. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from Temml are
 * errors in the expression, or errors in javascript handling.
 */


/**
 * @type {import('./temml').render}
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
let render = function(expression, baseNode, options = {}) {
  baseNode.textContent = "";
  const alreadyInMathElement = baseNode.tagName.toLowerCase() === "math";
  if (alreadyInMathElement) { options.wrap = "none"; }
  const math = renderToMathMLTree(expression, options);
  if (alreadyInMathElement) {
    // The <math> element already exists. Populate it.
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else if (math.children.length > 1) {
    baseNode.textContent = "";
    math.children.forEach(e => { baseNode.appendChild(e.toNode()); });
  } else {
    baseNode.appendChild(math.toNode());
  }
};

// Temml's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
  if (document.compatMode !== "CSS1Compat") {
    typeof console !== "undefined" &&
      console.warn(
        "Warning: Temml doesn't work in quirks mode. Make sure your " +
          "website has a suitable doctype."
      );

    render = function() {
      throw new ParseError("Temml doesn't work in quirks mode.");
    };
  }
}

/**
 * @type {import('./temml').renderToString}
 * Parse and build an expression, and return the markup for that.
 */
const renderToString = function(expression, options) {
  const markup = renderToMathMLTree(expression, options).toMarkup();
  return markup;
};

/**
 * @type {import('./temml').generateParseTree}
 * Parse an expression and return the parse tree.
 */
const generateParseTree = function(expression, options) {
  const settings = new Settings(options);
  return parseTree(expression, settings);
};

/**
 * @type {import('./temml').definePreamble}
 * Take an expression which contains a preamble.
 * Parse it and return the macros.
 */
const definePreamble = function(expression, options) {
  const settings = new Settings(options);
  settings.macros = {};
  if (!(typeof expression === "string" || expression instanceof String)) {
    throw new TypeError("Temml can only parse string typed expression")
  }
  const parser = new Parser(expression, settings, true);
  // Blank out any \df@tag to avoid spurious "Duplicate \tag" errors
  delete parser.gullet.macros.current["\\df@tag"];
  const macros = parser.parse();
  return macros
};

/**
 * If the given error is a Temml ParseError,
 * renders the invalid LaTeX as a span with hover title giving the Temml
 * error message.  Otherwise, simply throws the error.
 */
const renderError = function(error, expression, options) {
  if (options.throwOnError || !(error instanceof ParseError)) {
    throw error;
  }
  const node = new Span(["temml-error"], [new TextNode$1(expression + "\n\n" + error.toString())]);
  node.style.color = options.errorColor;
  node.style.whiteSpace = "pre-line";
  return node;
};

/**
 * @type {import('./temml').renderToMathMLTree}
 * Generates and returns the Temml build tree. This is used for advanced
 * use cases (like rendering to custom output).
 */
const renderToMathMLTree = function(expression, options) {
  const settings = new Settings(options);
  try {
    const tree = parseTree(expression, settings);
    const style = new Style({
      level: settings.displayMode ? StyleLevel.DISPLAY : StyleLevel.TEXT,
      maxSize: settings.maxSize
    });
    return buildMathML(tree, expression, style, settings);
  } catch (error) {
    return renderError(error, expression, settings);
  }
};

/** @type {import('./temml').default} */
var temml$1 = {
  /**
   * Current Temml version
   */
  version: version,
  /**
   * Renders the given LaTeX into MathML, and adds
   * it as a child to the specified DOM node.
   */
  render,
  /**
   * Renders the given LaTeX into MathML string,
   * for sending to the client.
   */
  renderToString,
  /**
   * Finds all the math delimiters in a given element of a running HTML document
   * and converts the contents of each instance into a <math> element.
   */
  renderMathInElement,
  /**
   * Post-process an entire HTML block.
   * Writes AMS auto-numbers and implements \ref{}.
   * Typcally called once, after a loop has rendered many individual spans.
   */
  postProcess,
  /**
   * Temml error, usually during parsing.
   */
  ParseError,
  /**
   * Creates a set of macros with document-wide scope.
   */
  definePreamble,
  /**
   * Parses the given LaTeX into Temml's internal parse tree structure,
   * without rendering to HTML or MathML.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __parse: generateParseTree,
  /**
   * Renders the given LaTeX into a MathML internal DOM tree
   * representation, without flattening that representation to a string.
   *
   * NOTE: This method is not currently recommended for public use.
   * The internal tree representation is unstable and is very likely
   * to change. Use at your own risk.
   */
  __renderToMathMLTree: renderToMathMLTree,
  /**
   * adds a new symbol to builtin symbols table
   */
  __defineSymbol: defineSymbol,
  /**
   * adds a new macro to builtin macro list
   */
  __defineMacro: defineMacro
};

module.exports = temml$1;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Defuddle = void 0;
var defuddle_1 = __webpack_require__(/*! ./defuddle */ 628);
Object.defineProperty(exports, "Defuddle", ({ enumerable: true, get: function () { return defuddle_1.Defuddle; } }));

})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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V0FBVyxHQUFHLEVBQUUsR0FBRyxJQUFJLFNBQVMsR0FBRyxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxvQkFBb0IsSUFBSSxxQkFBcUIsSUFBSSxpSkFBaUosSUFBSSxJQUFJLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixJQUFJLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixJQUFJLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixJQUFJLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixJQUFJLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixJQUFJLDRCQUE0QixLQUFLLDRCQUE0QixJQUFJLDRCQUE0QixJQUFJLDRCQUE0QixJQUFJLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixLQUFLLDRCQUE0QixJQUFJLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixPQUFPLDRCQUE0QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixJQUFJLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixJQUFJLDZCQUE2QixJQUFJLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixJQUFJLDZCQUE2QixJQUFJLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixJQUFJLDZCQUE2QixLQUFLLDZCQUE2QixJQUFJLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixJQUFJLDZCQUE2QixLQUFLLDZCQUE2QixNQUFNLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDZCQUE2QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixJQUFJLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixJQUFJLDhCQUE4QixJQUFJLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixJQUFJLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixLQUFLLDhCQUE4QixJ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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsK0NBQStDLGVBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQyw4QkFBOEIsT0FBTztBQUNyQyw4QkFBOEI7QUFDOUIsNEJBQTRCLE9BQU87QUFDbkMsOEJBQThCLE9BQU87QUFDckMsOEJBQThCO0FBQzlCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLDZDQUE2QztBQUM3Qyw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekMsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsdUJBQXVCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQkFBa0I7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsT0FBTztBQUNoRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0Qix1QkFBdUIsMkJBQTJCO0FBQ2xELDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtB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LE1BQU0sTUFBTSxPQUFPLE1BQU07QUFDdkQsSUFBSSxRQUFRLE1BQU0sT0FBTztBQUN6QjtBQUNBLElBQUksUUFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLElBQUksS0FBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSwrQkFBK0IsRUFBRSxZQUFZLEVBQUU7QUFDL0MscUNBQXFDLEVBQUUsWUFBWSxFQUFFO0FBQ3JELHdCQUF3QixLQUFLLFVBQVUsS0FBSyxHQUFHLEVBQUU7QUFDakQsNkRBQTZELEVBQUU7QUFDL0QsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsTUFBTSxHQUFHO0FBQzFDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxpQ0FBaUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEtBQUssS0FBSyxXQUFXLGFBQWEsZUFBZTtBQUMzRixhQUFhO0FBQ2I7QUFDQTtBQUNBLENBQUM7O0FBRUQ7OztBQUdBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDJEQUEyRCxTQUFTO0FBQ3BFO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0MsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2QkFBNkI7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixFQUFFLE9BQU8seUJBQXlCLE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSxPQUFPLGVBQWUsTUFBTSxvQkFBb0I7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFNBQVM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUztBQUMzRDtBQUNBOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DLFlBQVksU0FBUzs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEMsY0FBYywwQkFBMEI7QUFDeEMsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSwwQkFBMEI7QUFDekMsY0FBYywyQkFBMkI7QUFDekMsY0FBYywyQkFBMkI7QUFDekMsZUFBZSwyQkFBMkI7QUFDMUMsZUFBZSwyQkFBMkI7QUFDMUMsY0FBYyx5QkFBeUI7QUFDdkMsY0FBYyx5QkFBeUI7QUFDdkMsZUFBZSx5QkFBeUI7QUFDeEMsZUFBZSx5QkFBeUI7QUFDeEMsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSx5QkFBeUI7QUFDdEMsY0FBYyx5QkFBeUI7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQSxJQUFJO0FBQ0osK0NBQStDLGNBQWMsV0FBVyxpQkFBaUI7QUFDekYsSUFBSTtBQUNKLG9EQUFvRCxXQUFXO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEO0FBQ0EsdUJBQXVCLDBDQUEwQyxJQUFJLHNCQUFzQjtBQUMzRixrQkFBa0IsNkNBQTZDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxJQUFJLE1BQU0seUJBQXlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isd0NBQXdDLFlBQVk7QUFDcEQsd0NBQXdDLFFBQVE7QUFDaEQsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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WSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIsa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxvQ0FBb0M7QUFDbEQ7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPLFFBQVE7QUFDcEQsZ0NBQWdDLElBQUksVUFBVSxJQUFJLFdBQVcsYUFBYTtBQUMxRTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQjtBQUNyQixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsc0NBQXNDLFVBQVU7QUFDaEQsc0NB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNILGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scURBQXFELFdBQVc7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QixHQUFHLGlCQUFpQjtBQUN4RjtBQUNBO0FBQ0Esd0RBQXdELCtCQUErQjtBQUN2RjtBQUNBLE1BQU0saUJBQWlCO0FBQ3ZCLEtBQUssd0JBQXdCO0FBQzdCO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQSxLQUFLLCtCQUErQjtBQUNwQztBQUNBO0FBQ0EsTUFBTSxpQ0FBaUM7QUFDdkMsTUFBTSx5QkFBeUIsSUFBSTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFdBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLFNBQVMsY0FBYztBQUN2QixNQUFNO0FBQ04sU0FBUyxxQkFBcUI7QUFDOUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxLQUFLO0FBQzVEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsZUFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLElBQUk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0EseUJBQXlCLDBDQUEwQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsOEJBQThCO0FBQzVDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsNEJBQTRCO0FBQzFDLGNBQWMsaUNBQWlDO0FBQy9DLGNBQWMsYUFBYTtBQUMzQixjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBEQUEwRCxFQUFFO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLLFVB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O0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O1VDM2xjQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RCQSw0REFBc0M7QUFBN0IsNkdBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vRGVmdWRkbGUvLi9zcmMvbWF0aC50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy9tYXRobWwtdG8tbGF0ZXgvZGlzdC9idW5kbGUubWluLmpzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL21ldGFkYXRhLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2RlZnVkZGxlLnRzIiwid2VicGFjazovL0RlZnVkZGxlLy4vc3JjL2NvbnN0YW50cy50cyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL25vZGVfbW9kdWxlcy90ZW1tbC9kaXN0L3RlbW1sLmNqcyIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9EZWZ1ZGRsZS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJEZWZ1ZGRsZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHRoaXMsICgpID0+IHtcbnJldHVybiAiLCJpbXBvcnQgeyBNYXRoTUxUb0xhVGVYIH0gZnJvbSAnbWF0aG1sLXRvLWxhdGV4JztcbmltcG9ydCAqIGFzIHRlbW1sIGZyb20gJ3RlbW1sJztcblxuZXhwb3J0IGludGVyZmFjZSBNYXRoRGF0YSB7XG5cdG1hdGhtbDogc3RyaW5nO1xuXHRsYXRleDogc3RyaW5nIHwgbnVsbDtcblx0aXNCbG9jazogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IGdldE1hdGhNTEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogTWF0aERhdGEgfCBudWxsID0+IHtcblx0Y29uc29sZS5sb2coJ2dldE1hdGhNTEZyb21FbGVtZW50IGlucHV0OicsIGVsLm91dGVySFRNTCk7XG5cblx0Ly8gMS4gRGlyZWN0IE1hdGhNTCBjb250ZW50XG5cdGlmIChlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdtYXRoJykge1xuXHRcdGNvbnN0IGlzQmxvY2sgPSBlbC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ2Jsb2NrJztcblx0XHRjb25zb2xlLmxvZygnRGlyZWN0IE1hdGhNTCAtIGlzQmxvY2s6JywgaXNCbG9jayk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG1hdGhtbDogZWwub3V0ZXJIVE1MLFxuXHRcdFx0bGF0ZXg6IGVsLmdldEF0dHJpYnV0ZSgnYWx0dGV4dCcpIHx8IG51bGwsXG5cdFx0XHRpc0Jsb2NrXG5cdFx0fTtcblx0fVxuXG5cdC8vIDIuIE1hdGhNTCBpbiBkYXRhLW1hdGhtbCBhdHRyaWJ1dGVcblx0Y29uc3QgbWF0aG1sU3RyID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW1hdGhtbCcpO1xuXHRpZiAobWF0aG1sU3RyKSB7XG5cdFx0Y29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdHRlbXBEaXYuaW5uZXJIVE1MID0gbWF0aG1sU3RyO1xuXHRcdGNvbnN0IG1hdGhFbGVtZW50ID0gdGVtcERpdi5xdWVyeVNlbGVjdG9yKCdtYXRoJyk7XG5cdFx0aWYgKG1hdGhFbGVtZW50KSB7XG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gbWF0aEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNwbGF5JykgPT09ICdibG9jayc7XG5cdFx0XHRjb25zb2xlLmxvZygnZGF0YS1tYXRobWwgLSBpc0Jsb2NrOicsIGlzQmxvY2spO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF0aG1sOiBtYXRoRWxlbWVudC5vdXRlckhUTUwsXG5cdFx0XHRcdGxhdGV4OiBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FsdHRleHQnKSB8fCBudWxsLFxuXHRcdFx0XHRpc0Jsb2NrXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8vIDMuIE1hdGhKYXggYXNzaXN0aXZlIE1hdGhNTFxuXHRjb25zdCBhc3Npc3RpdmVNbWxDb250YWluZXIgPSBlbC5xdWVyeVNlbGVjdG9yKCcuTUpYX0Fzc2lzdGl2ZV9NYXRoTUwsIG1qeC1hc3Npc3RpdmUtbW1sJyk7XG5cdGNvbnNvbGUubG9nKCdGb3VuZCBhc3Npc3RpdmVNbWxDb250YWluZXI6JywgYXNzaXN0aXZlTW1sQ29udGFpbmVyPy5vdXRlckhUTUwpO1xuXHRcblx0aWYgKGFzc2lzdGl2ZU1tbENvbnRhaW5lcikge1xuXHRcdGNvbnN0IG1hdGhFbGVtZW50ID0gYXNzaXN0aXZlTW1sQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRjb25zb2xlLmxvZygnRm91bmQgbWF0aEVsZW1lbnQ6JywgbWF0aEVsZW1lbnQ/Lm91dGVySFRNTCk7XG5cdFx0XG5cdFx0aWYgKG1hdGhFbGVtZW50KSB7XG5cdFx0XHQvLyBDaGVjayBib3RoIHRoZSBtYXRoIGVsZW1lbnQgYW5kIGNvbnRhaW5lciBmb3IgZGlzcGxheSBtb2RlXG5cdFx0XHRjb25zdCBtYXRoRGlzcGxheUF0dHIgPSBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKTtcblx0XHRcdGNvbnN0IGNvbnRhaW5lckRpc3BsYXlBdHRyID0gYXNzaXN0aXZlTW1sQ29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpO1xuXHRcdFx0Y29uc29sZS5sb2coJ01hdGggZGlzcGxheSBhdHRyaWJ1dGU6JywgbWF0aERpc3BsYXlBdHRyKTtcblx0XHRcdGNvbnNvbGUubG9nKCdDb250YWluZXIgZGlzcGxheSBhdHRyaWJ1dGU6JywgY29udGFpbmVyRGlzcGxheUF0dHIpO1xuXHRcdFx0XG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gbWF0aERpc3BsYXlBdHRyID09PSAnYmxvY2snIHx8IGNvbnRhaW5lckRpc3BsYXlBdHRyID09PSAnYmxvY2snO1xuXHRcdFx0Y29uc29sZS5sb2coJ0ZpbmFsIGlzQmxvY2sgZGV0ZXJtaW5hdGlvbjonLCBpc0Jsb2NrKTtcblx0XHRcdFxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0bWF0aG1sOiBtYXRoRWxlbWVudC5vdXRlckhUTUwsXG5cdFx0XHRcdGxhdGV4OiBtYXRoRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FsdHRleHQnKSB8fCBudWxsLFxuXHRcdFx0XHRpc0Jsb2NrXG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8vIDQuIEthVGVYIE1hdGhNTFxuXHRjb25zdCBrYXRleE1hdGhtbCA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5rYXRleC1tYXRobWwgbWF0aCcpO1xuXHRpZiAoa2F0ZXhNYXRobWwpIHtcblx0XHRjb25zb2xlLmxvZygnS2FUZVggTWF0aE1MIGZvdW5kJyk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG1hdGhtbDoga2F0ZXhNYXRobWwub3V0ZXJIVE1MLFxuXHRcdFx0bGF0ZXg6IG51bGwsIC8vIFdlJ2xsIGdldCBMYVRlWCBzZXBhcmF0ZWx5IGZvciBLYVRlWFxuXHRcdFx0aXNCbG9jazogZmFsc2UgLy8gV2UnbGwgZGV0ZXJtaW5lIHRoaXMgZnJvbSBjb250YWluZXJcblx0XHR9O1xuXHR9XG5cblx0Y29uc29sZS5sb2coJ05vIE1hdGhNTCBmb3VuZCcpO1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRMYXRleEZyb21FbGVtZW50ID0gKGVsOiBFbGVtZW50KTogc3RyaW5nIHwgbnVsbCA9PiB7XG5cdC8vIDEuIERpcmVjdCBkYXRhLWxhdGV4IGF0dHJpYnV0ZVxuXHRjb25zdCBkYXRhTGF0ZXggPSBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbGF0ZXgnKTtcblx0aWYgKGRhdGFMYXRleCkge1xuXHRcdHJldHVybiBkYXRhTGF0ZXg7XG5cdH1cblxuXHQvLyAyLiBXb3JkUHJlc3MgTGFUZVggaW1hZ2VzXG5cdGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXRleCcpKSB7XG5cdFx0Ly8gVHJ5IGFsdCB0ZXh0IGZpcnN0IGFzIGl0J3MgY2xlYW5lclxuXHRcdGNvbnN0IGFsdExhdGV4ID0gZWwuZ2V0QXR0cmlidXRlKCdhbHQnKTtcblx0XHRpZiAoYWx0TGF0ZXgpIHtcblx0XHRcdHJldHVybiBhbHRMYXRleDtcblx0XHR9XG5cdFx0XG5cdFx0Ly8gRmFsbGJhY2sgdG8gZXh0cmFjdGluZyBmcm9tIFVSTFxuXHRcdGNvbnN0IHNyYyA9IGVsLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBzcmMubWF0Y2goL2xhdGV4XFwucGhwXFw/bGF0ZXg9KFteJl0rKS8pO1xuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHJldHVybiBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXG5cdFx0XHRcdFx0LnJlcGxhY2UoL1xcKy9nLCAnICcpIC8vIFJlcGxhY2UgKyB3aXRoIHNwYWNlc1xuXHRcdFx0XHRcdC5yZXBsYWNlKC8lNUMvZywgJ1xcXFwnKTsgLy8gRml4IGVzY2FwZWQgYmFja3NsYXNoZXNcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAzLiBMYVRlWCBpbiBhbm5vdGF0aW9uXG5cdGNvbnN0IGFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCdhbm5vdGF0aW9uW2VuY29kaW5nPVwiYXBwbGljYXRpb24veC10ZXhcIl0nKTtcblx0aWYgKGFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0cmV0dXJuIGFubm90YXRpb24udGV4dENvbnRlbnQudHJpbSgpO1xuXHR9XG5cblx0Ly8gNC4gS2FUZVggc3BlY2lmaWMgZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLmthdGV4JykpIHtcblx0XHQvLyBUcnkga2F0ZXgtbWF0aG1sIGFubm90YXRpb24gZmlyc3Rcblx0XHRjb25zdCBrYXRleEFubm90YXRpb24gPSBlbC5xdWVyeVNlbGVjdG9yKCcua2F0ZXgtbWF0aG1sIGFubm90YXRpb25bZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiXScpO1xuXHRcdGlmIChrYXRleEFubm90YXRpb24/LnRleHRDb250ZW50KSB7XG5cdFx0XHRyZXR1cm4ga2F0ZXhBbm5vdGF0aW9uLnRleHRDb250ZW50LnRyaW0oKTtcblx0XHR9XG5cdH1cblxuXHQvLyA1LiBNYXRoSmF4IHNwZWNpZmljIGZvcm1hdHNcblx0aWYgKGVsLm1hdGNoZXMoJ3NjcmlwdFt0eXBlPVwibWF0aC90ZXhcIl0nKSkge1xuXHRcdHJldHVybiBlbC50ZXh0Q29udGVudD8udHJpbSgpIHx8IG51bGw7XG5cdH1cblxuXHQvLyA2LiBUcnkgdG8gY29udmVydCBNYXRoTUwgdG8gTGFUZVggYXMgbGFzdCByZXNvcnRcblx0Y29uc3QgbWF0aG1sID0gZ2V0TWF0aE1MRnJvbUVsZW1lbnQoZWwpO1xuXHRpZiAobWF0aG1sPy5tYXRobWwpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIE1hdGhNTFRvTGFUZVguY29udmVydChtYXRobWwubWF0aG1sKTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcignRXJyb3IgY29udmVydGluZyBNYXRoTUwgdG8gTGFUZVg6JywgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG5cblx0Ly8gNy4gRmFsbGJhY2sgdG8gYWx0IHRleHQgb3IgdGV4dCBjb250ZW50XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgbnVsbDtcbn07XG5cbmV4cG9ydCBjb25zdCBpc0Jsb2NrTWF0aCA9IChlbDogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xuXHRjb25zb2xlLmxvZygnaXNCbG9ja01hdGggY2hlY2tpbmcgZWxlbWVudDonLCBlbC5vdXRlckhUTUwpO1xuXG5cdC8vIDEuIENoZWNrIGV4cGxpY2l0IGRpc3BsYXkgYXR0cmlidXRlXG5cdGNvbnN0IGRpc3BsYXlBdHRyID0gZWwuZ2V0QXR0cmlidXRlKCdkaXNwbGF5Jyk7XG5cdGNvbnNvbGUubG9nKCdkaXNwbGF5IGF0dHJpYnV0ZTonLCBkaXNwbGF5QXR0cik7XG5cdGlmIChkaXNwbGF5QXR0ciA9PT0gJ2Jsb2NrJykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gMi4gQ2hlY2sgY29tbW9uIGNsYXNzIG5hbWVzXG5cdGNvbnN0IGNsYXNzTmFtZXMgPSBlbC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0Y29uc29sZS5sb2coJ2NsYXNzIG5hbWVzOicsIGNsYXNzTmFtZXMpO1xuXHRpZiAoY2xhc3NOYW1lcy5pbmNsdWRlcygnZGlzcGxheScpIHx8IGNsYXNzTmFtZXMuaW5jbHVkZXMoJ2Jsb2NrJykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDMuIENoZWNrIGNvbnRhaW5lciBjbGFzc2VzXG5cdGNvbnN0IGNvbnRhaW5lciA9IGVsLmNsb3Nlc3QoJy5rYXRleC1kaXNwbGF5LCAuTWF0aEpheF9EaXNwbGF5LCBbZGF0YS1kaXNwbGF5PVwiYmxvY2tcIl0nKTtcblx0Y29uc29sZS5sb2coJ2NvbnRhaW5lciBmb3VuZDonLCBjb250YWluZXI/Lm91dGVySFRNTCk7XG5cdGlmIChjb250YWluZXIpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIDQuIENoZWNrIGlmIHByZWNlZGVkIGJ5IGJsb2NrIGVsZW1lbnRcblx0Y29uc3QgcHJldkVsZW1lbnQgPSBlbC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXHRjb25zb2xlLmxvZygncHJldmlvdXMgZWxlbWVudDonLCBwcmV2RWxlbWVudD8ub3V0ZXJIVE1MKTtcblx0aWYgKHByZXZFbGVtZW50Py50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwJykge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNS4gQ2hlY2sgc3BlY2lmaWMgZm9ybWF0c1xuXHRpZiAoZWwubWF0Y2hlcygnLm13ZS1tYXRoLWZhbGxiYWNrLWltYWdlLWRpc3BsYXknKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gNi4gQ2hlY2sgS2FUZVggZGlzcGxheSBtb2RlXG5cdGlmIChlbC5tYXRjaGVzKCcua2F0ZXgnKSkge1xuXHRcdC8vIEthVGVYIGVsZW1lbnRzIGFyZSBpbmxpbmUgYnkgZGVmYXVsdFxuXHRcdC8vIE9ubHkgYmxvY2sgaWYgZXhwbGljaXRseSBtYXJrZWQgYXMgZGlzcGxheVxuXHRcdHJldHVybiBlbC5jbG9zZXN0KCcua2F0ZXgtZGlzcGxheScpICE9PSBudWxsO1xuXHR9XG5cblx0Ly8gNy4gQ2hlY2sgTWF0aEpheCB2MyBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNwbGF5JykpIHtcblx0XHRjb25zb2xlLmxvZygnRm91bmQgZGlzcGxheSBhdHRyaWJ1dGU6JywgZWwuZ2V0QXR0cmlidXRlKCdkaXNwbGF5JykpO1xuXHRcdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PT0gJ3RydWUnO1xuXHR9XG5cblx0Ly8gOC4gQ2hlY2sgcGFyZW50IGNvbnRhaW5lciBkaXNwbGF5IGF0dHJpYnV0ZVxuXHRjb25zdCBwYXJlbnRDb250YWluZXIgPSBlbC5jbG9zZXN0KCdbZGlzcGxheV0nKTtcblx0aWYgKHBhcmVudENvbnRhaW5lcikge1xuXHRcdGNvbnNvbGUubG9nKCdQYXJlbnQgY29udGFpbmVyIGRpc3BsYXk6JywgcGFyZW50Q29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpKTtcblx0XHRyZXR1cm4gcGFyZW50Q29udGFpbmVyLmdldEF0dHJpYnV0ZSgnZGlzcGxheScpID09PSAndHJ1ZSc7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudCA9IChtYXRoRGF0YTogTWF0aERhdGEgfCBudWxsLCBsYXRleDogc3RyaW5nIHwgbnVsbCwgaXNCbG9jazogYm9vbGVhbik6IEVsZW1lbnQgPT4ge1xuXHRjb25zb2xlLmxvZygnY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudCBpbnB1dHM6Jywge1xuXHRcdG1hdGhEYXRhLFxuXHRcdGxhdGV4LFxuXHRcdGlzQmxvY2tcblx0fSk7XG5cblx0Y29uc3QgbmV3TWF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21hdGgnKTtcblxuXHQvLyBTZXQgZGlzcGxheSBtb2RlXG5cdG5ld01hdGguc2V0QXR0cmlidXRlKCdkaXNwbGF5JywgaXNCbG9jayA/ICdibG9jaycgOiAnaW5saW5lJyk7XG5cblx0Ly8gU2V0IExhVGVYIGlmIGF2YWlsYWJsZVxuXHRpZiAobGF0ZXgpIHtcblx0XHRuZXdNYXRoLnNldEF0dHJpYnV0ZSgnZGF0YS1sYXRleCcsIGxhdGV4KTtcblx0fVxuXG5cdC8vIEZpcnN0IHRyeSB0byB1c2UgZXhpc3RpbmcgTWF0aE1MIGNvbnRlbnRcblx0aWYgKG1hdGhEYXRhPy5tYXRobWwpIHtcblx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGVtcERpdi5pbm5lckhUTUwgPSBtYXRoRGF0YS5tYXRobWw7XG5cdFx0Y29uc3QgbWF0aENvbnRlbnQgPSB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRpZiAobWF0aENvbnRlbnQpIHtcblx0XHRcdG5ld01hdGguaW5uZXJIVE1MID0gbWF0aENvbnRlbnQuaW5uZXJIVE1MO1xuXHRcdH1cblx0fVxuXHQvLyBJZiBubyBNYXRoTUwgY29udGVudCBidXQgd2UgaGF2ZSBMYVRlWCwgY29udmVydCB1c2luZyBUZW1tbFxuXHRlbHNlIGlmIChsYXRleCkge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zb2xlLmxvZygnQ29udmVydGluZyBMYVRlWCB0byBNYXRoTUw6JywgbGF0ZXgpO1xuXHRcdFx0XG5cdFx0XHQvLyBDb252ZXJ0IExhVGVYIHRvIE1hdGhNTCB1c2luZyBUZW1tbFxuXHRcdFx0Y29uc3QgbWF0aG1sID0gdGVtbWwucmVuZGVyVG9TdHJpbmcobGF0ZXgsIHtcblx0XHRcdFx0ZGlzcGxheU1vZGU6IGlzQmxvY2ssXG5cdFx0XHRcdHRocm93T25FcnJvcjogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdFx0Y29uc29sZS5sb2coJ1RlbW1sIGNvbnZlcnNpb24gcmVzdWx0OicsIG1hdGhtbCk7XG5cdFx0XHRcblx0XHRcdGlmICh0eXBlb2YgbWF0aG1sID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBFeHRyYWN0IHRoZSBpbm5lciBjb250ZW50IG9mIHRoZSBtYXRoIGVsZW1lbnRcblx0XHRcdFx0Y29uc3QgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHR0ZW1wRGl2LmlubmVySFRNTCA9IG1hdGhtbDtcblx0XHRcdFx0Y29uc3QgbWF0aENvbnRlbnQgPSB0ZW1wRGl2LnF1ZXJ5U2VsZWN0b3IoJ21hdGgnKTtcblx0XHRcdFx0aWYgKG1hdGhDb250ZW50KSB7XG5cdFx0XHRcdFx0Ly8gQ29weSBhdHRyaWJ1dGVzIGV4Y2VwdCBkaXNwbGF5IG1vZGVcblx0XHRcdFx0XHRBcnJheS5mcm9tKG1hdGhDb250ZW50LmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoYXR0ci5uYW1lICE9PSAnZGlzcGxheScpIHtcblx0XHRcdFx0XHRcdFx0bmV3TWF0aC5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRuZXdNYXRoLmlubmVySFRNTCA9IG1hdGhDb250ZW50LmlubmVySFRNTDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBVc2UgdGhlIGVudGlyZSBvdXRwdXQgYXMgZmFsbGJhY2tcblx0XHRcdFx0XHRuZXdNYXRoLmlubmVySFRNTCA9IG1hdGhtbDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3TWF0aC50ZXh0Q29udGVudCA9IGxhdGV4O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdFcnJvciBjb252ZXJ0aW5nIExhVGVYIHRvIE1hdGhNTDonLCBlcnJvcik7XG5cdFx0XHRuZXdNYXRoLnRleHRDb250ZW50ID0gbGF0ZXg7XG5cdFx0fVxuXHR9XG5cblx0Y29uc29sZS5sb2coJ0NyZWF0ZWQgbWF0aCBlbGVtZW50OicsIG5ld01hdGgub3V0ZXJIVE1MKTtcblx0cmV0dXJuIG5ld01hdGg7XG59O1xuXG4vLyBNYXRoIGVsZW1lbnQgc3RhbmRhcmRpemF0aW9uIHJ1bGVzXG5leHBvcnQgY29uc3QgbWF0aFN0YW5kYXJkaXphdGlvblJ1bGVzID0gW1xuXHR7XG5cdFx0Ly8gV29yZFByZXNzIExhVGVYIGltYWdlc1xuXHRcdHNlbGVjdG9yOiAnaW1nLmxhdGV4W3NyYyo9XCJsYXRleC5waHBcIl0nLFxuXHRcdGVsZW1lbnQ6ICdtYXRoJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSkgcmV0dXJuIGVsO1xuXG5cdFx0XHQvLyBHZXQgTGFUZVggZm9ybXVsYVxuXHRcdFx0Y29uc3QgbGF0ZXggPSBnZXRMYXRleEZyb21FbGVtZW50KGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gV29yZFByZXNzIExhVGVYIGltYWdlcyBhcmUgaW5saW5lIGJ5IGRlZmF1bHRcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBpc0Jsb2NrTWF0aChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBzdGFuZGFyZGl6ZWQgbWF0aCBlbGVtZW50IHdpdGhvdXQgTWF0aE1MXG5cdFx0XHRyZXR1cm4gY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudChudWxsLCBsYXRleCwgaXNCbG9jayk7XG5cdFx0fVxuXHR9LFxuXHR7XG5cdFx0Ly8gTWF0aEpheCBlbGVtZW50cyAodjIgYW5kIHYzKVxuXHRcdHNlbGVjdG9yOiBbXG5cdFx0XHQnc3Bhbi5NYXRoSmF4Jyxcblx0XHRcdCdtangtY29udGFpbmVyJyxcblx0XHRcdCdzY3JpcHRbdHlwZT1cIm1hdGgvdGV4XCJdJyxcblx0XHRcdCdzY3JpcHRbdHlwZT1cIm1hdGgvdGV4OyBtb2RlPWRpc3BsYXlcIl0nLFxuXHRcdFx0Jy5NYXRoSmF4X1ByZXZpZXcgKyBzY3JpcHRbdHlwZT1cIm1hdGgvdGV4XCJdJyxcblx0XHRcdCcuTWF0aEpheF9EaXNwbGF5Jyxcblx0XHRcdCcuTWF0aEpheF9TVkcnLFxuXHRcdFx0Jy5NYXRoSmF4X01hdGhNTCdcblx0XHRdLmpvaW4oJywnKSxcblx0XHRlbGVtZW50OiAnbWF0aCcsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIEdldCBNYXRoTUwgY29udGVudFxuXHRcdFx0Y29uc3QgbWF0aERhdGEgPSBnZXRNYXRoTUxGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIEdldCBMYVRlWCBmb3JtdWxhXG5cdFx0XHRjb25zdCBsYXRleCA9IGdldExhdGV4RnJvbUVsZW1lbnQoZWwpO1xuXHRcdFx0XG5cdFx0XHQvLyBEZXRlcm1pbmUgZGlzcGxheSBtb2RlXG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gaXNCbG9ja01hdGgoZWwpIHx8IGVsLm1hdGNoZXMoJ3NjcmlwdFt0eXBlPVwibWF0aC90ZXg7IG1vZGU9ZGlzcGxheVwiXScpO1xuXHRcdFx0XG5cdFx0XHQvLyBDcmVhdGUgc3RhbmRhcmRpemVkIG1hdGggZWxlbWVudFxuXHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW5kYXJkTWF0aEVsZW1lbnQobWF0aERhdGEsIGxhdGV4LCBpc0Jsb2NrKTtcblx0XHR9XG5cdH0sXG5cdHtcblx0XHQvLyBNZWRpYVdpa2kgbWF0aCBlbGVtZW50c1xuXHRcdHNlbGVjdG9yOiBbXG5cdFx0XHQnLm13ZS1tYXRoLWVsZW1lbnQnLFxuXHRcdFx0Jy5td2UtbWF0aC1mYWxsYmFjay1pbWFnZS1pbmxpbmUnLFxuXHRcdFx0Jy5td2UtbWF0aC1mYWxsYmFjay1pbWFnZS1kaXNwbGF5Jyxcblx0XHRcdCcubXdlLW1hdGgtbWF0aG1sLWlubGluZScsXG5cdFx0XHQnLm13ZS1tYXRoLW1hdGhtbC1kaXNwbGF5Jyxcblx0XHRcdCdtYXRoW3htbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiXSdcblx0XHRdLmpvaW4oJywnKSxcblx0XHRlbGVtZW50OiAnbWF0aCcsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIEdldCBNYXRoTUwgY29udGVudFxuXHRcdFx0Y29uc3QgbWF0aERhdGEgPSBnZXRNYXRoTUxGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIEdldCBMYVRlWCBmb3JtdWxhXG5cdFx0XHRjb25zdCBsYXRleCA9IGdldExhdGV4RnJvbUVsZW1lbnQoZWwpO1xuXHRcdFx0XG5cdFx0XHQvLyBEZXRlcm1pbmUgZGlzcGxheSBtb2RlXG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gaXNCbG9ja01hdGgoZWwpO1xuXHRcdFx0XG5cdFx0XHQvLyBDcmVhdGUgc3RhbmRhcmRpemVkIG1hdGggZWxlbWVudFxuXHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW5kYXJkTWF0aEVsZW1lbnQobWF0aERhdGEsIGxhdGV4LCBpc0Jsb2NrKTtcblx0XHR9XG5cdH0sXG5cdHtcblx0XHQvLyBLYVRlWCBlbGVtZW50c1xuXHRcdHNlbGVjdG9yOiBbXG5cdFx0XHQnLmthdGV4Jyxcblx0XHRcdCcua2F0ZXgtZGlzcGxheScsXG5cdFx0XHQnLmthdGV4LW1hdGhtbCcsXG5cdFx0XHQnLmthdGV4LWh0bWwnLFxuXHRcdFx0J1tkYXRhLWthdGV4XScsXG5cdFx0XHQnc2NyaXB0W3R5cGU9XCJtYXRoL2thdGV4XCJdJ1xuXHRcdF0uam9pbignLCcpLFxuXHRcdGVsZW1lbnQ6ICdtYXRoJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBlbDtcblxuXHRcdFx0Ly8gR2V0IE1hdGhNTCBjb250ZW50XG5cdFx0XHRjb25zdCBtYXRoRGF0YSA9IGdldE1hdGhNTEZyb21FbGVtZW50KGVsKTtcblx0XHRcdFxuXHRcdFx0Ly8gR2V0IExhVGVYIGZvcm11bGFcblx0XHRcdGNvbnN0IGxhdGV4ID0gZ2V0TGF0ZXhGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIERldGVybWluZSBkaXNwbGF5IG1vZGVcblx0XHRcdGNvbnN0IGlzQmxvY2sgPSBpc0Jsb2NrTWF0aChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIENyZWF0ZSBzdGFuZGFyZGl6ZWQgbWF0aCBlbGVtZW50XG5cdFx0XHRyZXR1cm4gY3JlYXRlU3RhbmRhcmRNYXRoRWxlbWVudChtYXRoRGF0YSwgbGF0ZXgsIGlzQmxvY2spO1xuXHRcdH1cblx0fSxcblx0e1xuXHRcdC8vIEdlbmVyaWMgbWF0aCBlbGVtZW50cyBhbmQgb3RoZXIgZm9ybWF0c1xuXHRcdHNlbGVjdG9yOiBbXG5cdFx0XHQnbWF0aCcsXG5cdFx0XHQnW2RhdGEtbWF0aF0nLFxuXHRcdFx0J1tkYXRhLWxhdGV4XScsXG5cdFx0XHQnW2RhdGEtdGV4XScsXG5cdFx0XHQnc2NyaXB0W3R5cGVePVwibWF0aC9cIl0nLFxuXHRcdFx0J2Fubm90YXRpb25bZW5jb2Rpbmc9XCJhcHBsaWNhdGlvbi94LXRleFwiXSdcblx0XHRdLmpvaW4oJywnKSxcblx0XHRlbGVtZW50OiAnbWF0aCcsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIEdldCBNYXRoTUwgY29udGVudFxuXHRcdFx0Y29uc3QgbWF0aERhdGEgPSBnZXRNYXRoTUxGcm9tRWxlbWVudChlbCk7XG5cdFx0XHRcblx0XHRcdC8vIEdldCBMYVRlWCBmb3JtdWxhXG5cdFx0XHRjb25zdCBsYXRleCA9IGdldExhdGV4RnJvbUVsZW1lbnQoZWwpO1xuXHRcdFx0XG5cdFx0XHQvLyBEZXRlcm1pbmUgZGlzcGxheSBtb2RlXG5cdFx0XHRjb25zdCBpc0Jsb2NrID0gaXNCbG9ja01hdGgoZWwpO1xuXHRcdFx0XG5cdFx0XHQvLyBDcmVhdGUgc3RhbmRhcmRpemVkIG1hdGggZWxlbWVudFxuXHRcdFx0cmV0dXJuIGNyZWF0ZVN0YW5kYXJkTWF0aEVsZW1lbnQobWF0aERhdGEsIGxhdGV4LCBpc0Jsb2NrKTtcblx0XHR9XG5cdH1cbl07ICIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuTWF0aE1MVG9MYVRlWD10KCk6ZS5NYXRoTUxUb0xhVGVYPXQoKX0odGhpcywoKCk9PigoKT0+e3ZhciBlPXs0NTgyOihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD1PYmplY3QpLHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZnJlZXplP3QuZnJlZXplKGUpOmV9dmFyIGE9cih7SFRNTDpcInRleHQvaHRtbFwiLGlzSFRNTDpmdW5jdGlvbihlKXtyZXR1cm4gZT09PWEuSFRNTH0sWE1MX0FQUExJQ0FUSU9OOlwiYXBwbGljYXRpb24veG1sXCIsWE1MX1RFWFQ6XCJ0ZXh0L3htbFwiLFhNTF9YSFRNTF9BUFBMSUNBVElPTjpcImFwcGxpY2F0aW9uL3hodG1sK3htbFwiLFhNTF9TVkdfSU1BR0U6XCJpbWFnZS9zdmcreG1sXCJ9KSxuPXIoe0hUTUw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsaXNIVE1MOmZ1bmN0aW9uKGUpe3JldHVybiBlPT09bi5IVE1MfSxTVkc6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFhNTDpcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFhNTE5TOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIn0pO3QuYXNzaWduPWZ1bmN0aW9uKGUsdCl7aWYobnVsbD09PWV8fFwib2JqZWN0XCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJ0YXJnZXQgaXMgbm90IGFuIG9iamVjdFwiKTtmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKGVbcl09dFtyXSk7cmV0dXJuIGV9LHQuZmluZD1mdW5jdGlvbihlLHQscil7aWYodm9pZCAwPT09ciYmKHI9QXJyYXkucHJvdG90eXBlKSxlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiByLmZpbmQpcmV0dXJuIHIuZmluZC5jYWxsKGUsdCk7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDthKyspaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYSkpe3ZhciBuPWVbYV07aWYodC5jYWxsKHZvaWQgMCxuLGEsZSkpcmV0dXJuIG59fSx0LmZyZWV6ZT1yLHQuTUlNRV9UWVBFPWEsdC5OQU1FU1BBQ0U9bn0sNTc1MjooZSx0LHIpPT57dmFyIGE9cig0NTgyKSxuPXIoNDcyMiksbz1yKDY1NTkpLGk9cig0NDY2KSxzPW4uRE9NSW1wbGVtZW50YXRpb24sbD1hLk5BTUVTUEFDRSxjPWkuUGFyc2VFcnJvcix1PWkuWE1MUmVhZGVyO2Z1bmN0aW9uIGgoZSl7cmV0dXJuIGUucmVwbGFjZSgvXFxyW1xcblxcdTAwODVdL2csXCJcXG5cIikucmVwbGFjZSgvW1xcclxcdTAwODVcXHUyMDI4XS9nLFwiXFxuXCIpfWZ1bmN0aW9uIGQoZSl7dGhpcy5vcHRpb25zPWV8fHtsb2NhdG9yOnt9fX1mdW5jdGlvbiBtKCl7dGhpcy5jZGF0YT0hMX1mdW5jdGlvbiBwKGUsdCl7dC5saW5lTnVtYmVyPWUubGluZU51bWJlcix0LmNvbHVtbk51bWJlcj1lLmNvbHVtbk51bWJlcn1mdW5jdGlvbiBmKGUpe2lmKGUpcmV0dXJuXCJcXG5AXCIrKGUuc3lzdGVtSWR8fFwiXCIpK1wiI1tsaW5lOlwiK2UubGluZU51bWJlcitcIixjb2w6XCIrZS5jb2x1bW5OdW1iZXIrXCJdXCJ9ZnVuY3Rpb24geChlLHQscil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGU/ZS5zdWJzdHIodCxyKTplLmxlbmd0aD49dCtyfHx0P25ldyBqYXZhLmxhbmcuU3RyaW5nKGUsdCxyKStcIlwiOmV9ZnVuY3Rpb24gZyhlLHQpe2UuY3VycmVudEVsZW1lbnQ/ZS5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZCh0KTplLmRvYy5hcHBlbmRDaGlsZCh0KX1kLnByb3RvdHlwZS5wYXJzZUZyb21TdHJpbmc9ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLm9wdGlvbnMsYT1uZXcgdSxuPXIuZG9tQnVpbGRlcnx8bmV3IG0saT1yLmVycm9ySGFuZGxlcixzPXIubG9jYXRvcixjPXIueG1sbnN8fHt9LGQ9L1xcL3g/aHRtbD8kLy50ZXN0KHQpLHA9ZD9vLkhUTUxfRU5USVRJRVM6by5YTUxfRU5USVRJRVM7cyYmbi5zZXREb2N1bWVudExvY2F0b3IocyksYS5lcnJvckhhbmRsZXI9ZnVuY3Rpb24oZSx0LHIpe2lmKCFlKXtpZih0IGluc3RhbmNlb2YgbSlyZXR1cm4gdDtlPXR9dmFyIGE9e30sbj1lIGluc3RhbmNlb2YgRnVuY3Rpb247ZnVuY3Rpb24gbyh0KXt2YXIgbz1lW3RdOyFvJiZuJiYobz0yPT1lLmxlbmd0aD9mdW5jdGlvbihyKXtlKHQscil9OmUpLGFbdF09byYmZnVuY3Rpb24oZSl7byhcIlt4bWxkb20gXCIrdCtcIl1cXHRcIitlK2YocikpfXx8ZnVuY3Rpb24oKXt9fXJldHVybiByPXJ8fHt9LG8oXCJ3YXJuaW5nXCIpLG8oXCJlcnJvclwiKSxvKFwiZmF0YWxFcnJvclwiKSxhfShpLG4scyksYS5kb21CdWlsZGVyPXIuZG9tQnVpbGRlcnx8bixkJiYoY1tcIlwiXT1sLkhUTUwpLGMueG1sPWMueG1sfHxsLlhNTDt2YXIgeD1yLm5vcm1hbGl6ZUxpbmVFbmRpbmdzfHxoO3JldHVybiBlJiZcInN0cmluZ1wiPT10eXBlb2YgZT9hLnBhcnNlKHgoZSksYyxwKTphLmVycm9ySGFuZGxlci5lcnJvcihcImludmFsaWQgZG9jIHNvdXJjZVwiKSxuLmRvY30sbS5wcm90b3R5cGU9e3N0YXJ0RG9jdW1lbnQ6ZnVuY3Rpb24oKXt0aGlzLmRvYz0obmV3IHMpLmNyZWF0ZURvY3VtZW50KG51bGwsbnVsbCxudWxsKSx0aGlzLmxvY2F0b3ImJih0aGlzLmRvYy5kb2N1bWVudFVSST10aGlzLmxvY2F0b3Iuc3lzdGVtSWQpfSxzdGFydEVsZW1lbnQ6ZnVuY3Rpb24oZSx0LHIsYSl7dmFyIG49dGhpcy5kb2Msbz1uLmNyZWF0ZUVsZW1lbnROUyhlLHJ8fHQpLGk9YS5sZW5ndGg7Zyh0aGlzLG8pLHRoaXMuY3VycmVudEVsZW1lbnQ9byx0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLG8pO2Zvcih2YXIgcz0wO3M8aTtzKyspe2U9YS5nZXRVUkkocyk7dmFyIGw9YS5nZXRWYWx1ZShzKSxjPShyPWEuZ2V0UU5hbWUocyksbi5jcmVhdGVBdHRyaWJ1dGVOUyhlLHIpKTt0aGlzLmxvY2F0b3ImJnAoYS5nZXRMb2NhdG9yKHMpLGMpLGMudmFsdWU9Yy5ub2RlVmFsdWU9bCxvLnNldEF0dHJpYnV0ZU5vZGUoYyl9fSxlbmRFbGVtZW50OmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT10aGlzLmN1cnJlbnRFbGVtZW50O2EudGFnTmFtZSx0aGlzLmN1cnJlbnRFbGVtZW50PWEucGFyZW50Tm9kZX0sc3RhcnRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKGUsdCl7fSxlbmRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKGUpe30scHJvY2Vzc2luZ0luc3RydWN0aW9uOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5kb2MuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKGUsdCk7dGhpcy5sb2NhdG9yJiZwKHRoaXMubG9jYXRvcixyKSxnKHRoaXMscil9LGlnbm9yYWJsZVdoaXRlc3BhY2U6ZnVuY3Rpb24oZSx0LHIpe30sY2hhcmFjdGVyczpmdW5jdGlvbihlLHQscil7aWYoZT14LmFwcGx5KHRoaXMsYXJndW1lbnRzKSl7aWYodGhpcy5jZGF0YSl2YXIgYT10aGlzLmRvYy5jcmVhdGVDREFUQVNlY3Rpb24oZSk7ZWxzZSBhPXRoaXMuZG9jLmNyZWF0ZVRleHROb2RlKGUpO3RoaXMuY3VycmVudEVsZW1lbnQ/dGhpcy5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChhKTovXlxccyokLy50ZXN0KGUpJiZ0aGlzLmRvYy5hcHBlbmRDaGlsZChhKSx0aGlzLmxvY2F0b3ImJnAodGhpcy5sb2NhdG9yLGEpfX0sc2tpcHBlZEVudGl0eTpmdW5jdGlvbihlKXt9LGVuZERvY3VtZW50OmZ1bmN0aW9uKCl7dGhpcy5kb2Mubm9ybWFsaXplKCl9LHNldERvY3VtZW50TG9jYXRvcjpmdW5jdGlvbihlKXsodGhpcy5sb2NhdG9yPWUpJiYoZS5saW5lTnVtYmVyPTApfSxjb21tZW50OmZ1bmN0aW9uKGUsdCxyKXtlPXguYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBhPXRoaXMuZG9jLmNyZWF0ZUNvbW1lbnQoZSk7dGhpcy5sb2NhdG9yJiZwKHRoaXMubG9jYXRvcixhKSxnKHRoaXMsYSl9LHN0YXJ0Q0RBVEE6ZnVuY3Rpb24oKXt0aGlzLmNkYXRhPSEwfSxlbmRDREFUQTpmdW5jdGlvbigpe3RoaXMuY2RhdGE9ITF9LHN0YXJ0RFREOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT10aGlzLmRvYy5pbXBsZW1lbnRhdGlvbjtpZihhJiZhLmNyZWF0ZURvY3VtZW50VHlwZSl7dmFyIG49YS5jcmVhdGVEb2N1bWVudFR5cGUoZSx0LHIpO3RoaXMubG9jYXRvciYmcCh0aGlzLmxvY2F0b3IsbiksZyh0aGlzLG4pLHRoaXMuZG9jLmRvY3R5cGU9bn19LHdhcm5pbmc6ZnVuY3Rpb24oZSl7Y29uc29sZS53YXJuKFwiW3htbGRvbSB3YXJuaW5nXVxcdFwiK2UsZih0aGlzLmxvY2F0b3IpKX0sZXJyb3I6ZnVuY3Rpb24oZSl7Y29uc29sZS5lcnJvcihcIlt4bWxkb20gZXJyb3JdXFx0XCIrZSxmKHRoaXMubG9jYXRvcikpfSxmYXRhbEVycm9yOmZ1bmN0aW9uKGUpe3Rocm93IG5ldyBjKGUsdGhpcy5sb2NhdG9yKX19LFwiZW5kRFRELHN0YXJ0RW50aXR5LGVuZEVudGl0eSxhdHRyaWJ1dGVEZWNsLGVsZW1lbnREZWNsLGV4dGVybmFsRW50aXR5RGVjbCxpbnRlcm5hbEVudGl0eURlY2wscmVzb2x2ZUVudGl0eSxnZXRFeHRlcm5hbFN1YnNldCxub3RhdGlvbkRlY2wsdW5wYXJzZWRFbnRpdHlEZWNsXCIucmVwbGFjZSgvXFx3Ky9nLChmdW5jdGlvbihlKXttLnByb3RvdHlwZVtlXT1mdW5jdGlvbigpe3JldHVybiBudWxsfX0pKSx0LkRPTVBhcnNlcj1kfSw0NzIyOihlLHQscik9Pnt2YXIgYT1yKDQ1ODIpLG49YS5maW5kLG89YS5OQU1FU1BBQ0U7ZnVuY3Rpb24gaShlKXtyZXR1cm5cIlwiIT09ZX1mdW5jdGlvbiBzKGUsdCl7cmV0dXJuIGUuaGFzT3duUHJvcGVydHkodCl8fChlW3RdPSEwKSxlfWZ1bmN0aW9uIGwoZSl7aWYoIWUpcmV0dXJuW107dmFyIHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/ZS5zcGxpdCgvW1xcdFxcblxcZlxcciBdKy8pLmZpbHRlcihpKTpbXX0oZSk7cmV0dXJuIE9iamVjdC5rZXlzKHQucmVkdWNlKHMse30pKX1mdW5jdGlvbiBjKGUsdCl7Zm9yKHZhciByIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pfWZ1bmN0aW9uIHUoZSx0KXt2YXIgcj1lLnByb3RvdHlwZTtpZighKHIgaW5zdGFuY2VvZiB0KSl7ZnVuY3Rpb24gYSgpe31hLnByb3RvdHlwZT10LnByb3RvdHlwZSxjKHIsYT1uZXcgYSksZS5wcm90b3R5cGU9cj1hfXIuY29uc3RydWN0b3IhPWUmJihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZjb25zb2xlLmVycm9yKFwidW5rbm93biBDbGFzczpcIitlKSxyLmNvbnN0cnVjdG9yPWUpfXZhciBoPXt9LGQ9aC5FTEVNRU5UX05PREU9MSxtPWguQVRUUklCVVRFX05PREU9MixwPWguVEVYVF9OT0RFPTMsZj1oLkNEQVRBX1NFQ1RJT05fTk9ERT00LHg9aC5FTlRJVFlfUkVGRVJFTkNFX05PREU9NSxnPWguRU5USVRZX05PREU9Nix3PWguUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFPTcsYj1oLkNPTU1FTlRfTk9ERT04LHY9aC5ET0NVTUVOVF9OT0RFPTksQz1oLkRPQ1VNRU5UX1RZUEVfTk9ERT0xMCxBPWguRE9DVU1FTlRfRlJBR01FTlRfTk9ERT0xMSxFPWguTk9UQVRJT05fTk9ERT0xMixfPXt9LHk9e30scT0oXy5JTkRFWF9TSVpFX0VSUj0oeVsxXT1cIkluZGV4IHNpemUgZXJyb3JcIiwxKSxfLkRPTVNUUklOR19TSVpFX0VSUj0oeVsyXT1cIkRPTVN0cmluZyBzaXplIGVycm9yXCIsMiksXy5ISUVSQVJDSFlfUkVRVUVTVF9FUlI9KHlbM109XCJIaWVyYXJjaHkgcmVxdWVzdCBlcnJvclwiLDMpKSxEPShfLldST05HX0RPQ1VNRU5UX0VSUj0oeVs0XT1cIldyb25nIGRvY3VtZW50XCIsNCksXy5JTlZBTElEX0NIQVJBQ1RFUl9FUlI9KHlbNV09XCJJbnZhbGlkIGNoYXJhY3RlclwiLDUpLF8uTk9fREFUQV9BTExPV0VEX0VSUj0oeVs2XT1cIk5vIGRhdGEgYWxsb3dlZFwiLDYpLF8uTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSPSh5WzddPVwiTm8gbW9kaWZpY2F0aW9uIGFsbG93ZWRcIiw3KSxfLk5PVF9GT1VORF9FUlI9KHlbOF09XCJOb3QgZm91bmRcIiw4KSksTT0oXy5OT1RfU1VQUE9SVEVEX0VSUj0oeVs5XT1cIk5vdCBzdXBwb3J0ZWRcIiw5KSxfLklOVVNFX0FUVFJJQlVURV9FUlI9KHlbMTBdPVwiQXR0cmlidXRlIGluIHVzZVwiLDEwKSk7ZnVuY3Rpb24gVChlLHQpe2lmKHQgaW5zdGFuY2VvZiBFcnJvcil2YXIgcj10O2Vsc2Ugcj10aGlzLEVycm9yLmNhbGwodGhpcyx5W2VdKSx0aGlzLm1lc3NhZ2U9eVtlXSxFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSYmRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcyxUKTtyZXR1cm4gci5jb2RlPWUsdCYmKHRoaXMubWVzc2FnZT10aGlzLm1lc3NhZ2UrXCI6IFwiK3QpLHJ9ZnVuY3Rpb24gTigpe31mdW5jdGlvbiBPKGUsdCl7dGhpcy5fbm9kZT1lLHRoaXMuX3JlZnJlc2g9dCxMKHRoaXMpfWZ1bmN0aW9uIEwoZSl7dmFyIHQ9ZS5fbm9kZS5faW5jfHxlLl9ub2RlLm93bmVyRG9jdW1lbnQuX2luYztpZihlLl9pbmMhPT10KXt2YXIgcj1lLl9yZWZyZXNoKGUuX25vZGUpO2lmKHdlKGUsXCJsZW5ndGhcIixyLmxlbmd0aCksIWUuJCRsZW5ndGh8fHIubGVuZ3RoPGUuJCRsZW5ndGgpZm9yKHZhciBhPXIubGVuZ3RoO2EgaW4gZTthKyspT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYSkmJmRlbGV0ZSBlW2FdO2MocixlKSxlLl9pbmM9dH19ZnVuY3Rpb24gQigpe31mdW5jdGlvbiBTKGUsdCl7Zm9yKHZhciByPWUubGVuZ3RoO3ItLTspaWYoZVtyXT09PXQpcmV0dXJuIHJ9ZnVuY3Rpb24gRihlLHQscixhKXtpZihhP3RbUyh0LGEpXT1yOnRbdC5sZW5ndGgrK109cixlKXtyLm93bmVyRWxlbWVudD1lO3ZhciBuPWUub3duZXJEb2N1bWVudDtuJiYoYSYmVihuLGUsYSksZnVuY3Rpb24oZSx0LHIpe2UmJmUuX2luYysrLHIubmFtZXNwYWNlVVJJPT09by5YTUxOUyYmKHQuX25zTWFwW3IucHJlZml4P3IubG9jYWxOYW1lOlwiXCJdPXIudmFsdWUpfShuLGUscikpfX1mdW5jdGlvbiBQKGUsdCxyKXt2YXIgYT1TKHQscik7aWYoIShhPj0wKSl0aHJvdyBuZXcgVChELG5ldyBFcnJvcihlLnRhZ05hbWUrXCJAXCIrcikpO2Zvcih2YXIgbj10Lmxlbmd0aC0xO2E8bjspdFthXT10WysrYV07aWYodC5sZW5ndGg9bixlKXt2YXIgbz1lLm93bmVyRG9jdW1lbnQ7byYmKFYobyxlLHIpLHIub3duZXJFbGVtZW50PW51bGwpfX1mdW5jdGlvbiBrKCl7fWZ1bmN0aW9uIFIoKXt9ZnVuY3Rpb24gSShlKXtyZXR1cm4oXCI8XCI9PWU/XCImbHQ7XCI6XCI+XCI9PWUmJlwiJmd0O1wiKXx8XCImXCI9PWUmJlwiJmFtcDtcInx8J1wiJz09ZSYmXCImcXVvdDtcInx8XCImI1wiK2UuY2hhckNvZGVBdCgpK1wiO1wifWZ1bmN0aW9uIFUoZSx0KXtpZih0KGUpKXJldHVybiEwO2lmKGU9ZS5maXJzdENoaWxkKWRve2lmKFUoZSx0KSlyZXR1cm4hMH13aGlsZShlPWUubmV4dFNpYmxpbmcpfWZ1bmN0aW9uIGooKXt0aGlzLm93bmVyRG9jdW1lbnQ9dGhpc31mdW5jdGlvbiBWKGUsdCxyLGEpe2UmJmUuX2luYysrLHIubmFtZXNwYWNlVVJJPT09by5YTUxOUyYmZGVsZXRlIHQuX25zTWFwW3IucHJlZml4P3IubG9jYWxOYW1lOlwiXCJdfWZ1bmN0aW9uIEcoZSx0LHIpe2lmKGUmJmUuX2luYyl7ZS5faW5jKys7dmFyIGE9dC5jaGlsZE5vZGVzO2lmKHIpYVthLmxlbmd0aCsrXT1yO2Vsc2V7Zm9yKHZhciBuPXQuZmlyc3RDaGlsZCxvPTA7bjspYVtvKytdPW4sbj1uLm5leHRTaWJsaW5nO2EubGVuZ3RoPW8sZGVsZXRlIGFbYS5sZW5ndGhdfX19ZnVuY3Rpb24gJChlLHQpe3ZhciByPXQucHJldmlvdXNTaWJsaW5nLGE9dC5uZXh0U2libGluZztyZXR1cm4gcj9yLm5leHRTaWJsaW5nPWE6ZS5maXJzdENoaWxkPWEsYT9hLnByZXZpb3VzU2libGluZz1yOmUubGFzdENoaWxkPXIsdC5wYXJlbnROb2RlPW51bGwsdC5wcmV2aW91c1NpYmxpbmc9bnVsbCx0Lm5leHRTaWJsaW5nPW51bGwsRyhlLm93bmVyRG9jdW1lbnQsZSksdH1mdW5jdGlvbiBYKGUpe3JldHVybiBlJiZlLm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9UWVBFX05PREV9ZnVuY3Rpb24gSChlKXtyZXR1cm4gZSYmZS5ub2RlVHlwZT09PVIuRUxFTUVOVF9OT0RFfWZ1bmN0aW9uIFcoZSl7cmV0dXJuIGUmJmUubm9kZVR5cGU9PT1SLlRFWFRfTk9ERX1mdW5jdGlvbiB6KGUsdCl7dmFyIHI9ZS5jaGlsZE5vZGVzfHxbXTtpZihuKHIsSCl8fFgodCkpcmV0dXJuITE7dmFyIGE9bihyLFgpO3JldHVybiEodCYmYSYmci5pbmRleE9mKGEpPnIuaW5kZXhPZih0KSl9ZnVuY3Rpb24gWShlLHQpe3ZhciByPWUuY2hpbGROb2Rlc3x8W107aWYobihyLChmdW5jdGlvbihlKXtyZXR1cm4gSChlKSYmZSE9PXR9KSkpcmV0dXJuITE7dmFyIGE9bihyLFgpO3JldHVybiEodCYmYSYmci5pbmRleE9mKGEpPnIuaW5kZXhPZih0KSl9ZnVuY3Rpb24gSihlLHQscil7dmFyIGE9ZS5jaGlsZE5vZGVzfHxbXSxvPXQuY2hpbGROb2Rlc3x8W107aWYodC5ub2RlVHlwZT09PVIuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7dmFyIGk9by5maWx0ZXIoSCk7aWYoaS5sZW5ndGg+MXx8bihvLFcpKXRocm93IG5ldyBUKHEsXCJNb3JlIHRoYW4gb25lIGVsZW1lbnQgb3IgdGV4dCBpbiBmcmFnbWVudFwiKTtpZigxPT09aS5sZW5ndGgmJiF6KGUscikpdGhyb3cgbmV3IFQocSxcIkVsZW1lbnQgaW4gZnJhZ21lbnQgY2FuIG5vdCBiZSBpbnNlcnRlZCBiZWZvcmUgZG9jdHlwZVwiKX1pZihIKHQpJiYheihlLHIpKXRocm93IG5ldyBUKHEsXCJPbmx5IG9uZSBlbGVtZW50IGNhbiBiZSBhZGRlZCBhbmQgb25seSBhZnRlciBkb2N0eXBlXCIpO2lmKFgodCkpe2lmKG4oYSxYKSl0aHJvdyBuZXcgVChxLFwiT25seSBvbmUgZG9jdHlwZSBpcyBhbGxvd2VkXCIpO3ZhciBzPW4oYSxIKTtpZihyJiZhLmluZGV4T2Yocyk8YS5pbmRleE9mKHIpKXRocm93IG5ldyBUKHEsXCJEb2N0eXBlIGNhbiBvbmx5IGJlIGluc2VydGVkIGJlZm9yZSBhbiBlbGVtZW50XCIpO2lmKCFyJiZzKXRocm93IG5ldyBUKHEsXCJEb2N0eXBlIGNhbiBub3QgYmUgYXBwZW5kZWQgc2luY2UgZWxlbWVudCBpcyBwcmVzZW50XCIpfX1mdW5jdGlvbiBaKGUsdCxyKXt2YXIgYT1lLmNoaWxkTm9kZXN8fFtdLG89dC5jaGlsZE5vZGVzfHxbXTtpZih0Lm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXt2YXIgaT1vLmZpbHRlcihIKTtpZihpLmxlbmd0aD4xfHxuKG8sVykpdGhyb3cgbmV3IFQocSxcIk1vcmUgdGhhbiBvbmUgZWxlbWVudCBvciB0ZXh0IGluIGZyYWdtZW50XCIpO2lmKDE9PT1pLmxlbmd0aCYmIVkoZSxyKSl0aHJvdyBuZXcgVChxLFwiRWxlbWVudCBpbiBmcmFnbWVudCBjYW4gbm90IGJlIGluc2VydGVkIGJlZm9yZSBkb2N0eXBlXCIpfWlmKEgodCkmJiFZKGUscikpdGhyb3cgbmV3IFQocSxcIk9ubHkgb25lIGVsZW1lbnQgY2FuIGJlIGFkZGVkIGFuZCBvbmx5IGFmdGVyIGRvY3R5cGVcIik7aWYoWCh0KSl7aWYobihhLChmdW5jdGlvbihlKXtyZXR1cm4gWChlKSYmZSE9PXJ9KSkpdGhyb3cgbmV3IFQocSxcIk9ubHkgb25lIGRvY3R5cGUgaXMgYWxsb3dlZFwiKTt2YXIgcz1uKGEsSCk7aWYociYmYS5pbmRleE9mKHMpPGEuaW5kZXhPZihyKSl0aHJvdyBuZXcgVChxLFwiRG9jdHlwZSBjYW4gb25seSBiZSBpbnNlcnRlZCBiZWZvcmUgYW4gZWxlbWVudFwiKX19ZnVuY3Rpb24gUShlLHQscixhKXsoZnVuY3Rpb24oZSx0LHIpe2lmKCFmdW5jdGlvbihlKXtyZXR1cm4gZSYmKGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLkVMRU1FTlRfTk9ERSl9KGUpKXRocm93IG5ldyBUKHEsXCJVbmV4cGVjdGVkIHBhcmVudCBub2RlIHR5cGUgXCIrZS5ub2RlVHlwZSk7aWYociYmci5wYXJlbnROb2RlIT09ZSl0aHJvdyBuZXcgVChELFwiY2hpbGQgbm90IGluIHBhcmVudFwiKTtpZighZnVuY3Rpb24oZSl7cmV0dXJuIGUmJihIKGUpfHxXKGUpfHxYKGUpfHxlLm5vZGVUeXBlPT09Ui5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFfHxlLm5vZGVUeXBlPT09Ui5DT01NRU5UX05PREV8fGUubm9kZVR5cGU9PT1SLlBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERSl9KHQpfHxYKHQpJiZlLm5vZGVUeXBlIT09Ui5ET0NVTUVOVF9OT0RFKXRocm93IG5ldyBUKHEsXCJVbmV4cGVjdGVkIG5vZGUgdHlwZSBcIit0Lm5vZGVUeXBlK1wiIGZvciBwYXJlbnQgbm9kZSB0eXBlIFwiK2Uubm9kZVR5cGUpfSkoZSx0LHIpLGUubm9kZVR5cGU9PT1SLkRPQ1VNRU5UX05PREUmJihhfHxKKShlLHQscik7dmFyIG49dC5wYXJlbnROb2RlO2lmKG4mJm4ucmVtb3ZlQ2hpbGQodCksdC5ub2RlVHlwZT09PUEpe3ZhciBvPXQuZmlyc3RDaGlsZDtpZihudWxsPT1vKXJldHVybiB0O3ZhciBpPXQubGFzdENoaWxkfWVsc2Ugbz1pPXQ7dmFyIHM9cj9yLnByZXZpb3VzU2libGluZzplLmxhc3RDaGlsZDtvLnByZXZpb3VzU2libGluZz1zLGkubmV4dFNpYmxpbmc9cixzP3MubmV4dFNpYmxpbmc9bzplLmZpcnN0Q2hpbGQ9byxudWxsPT1yP2UubGFzdENoaWxkPWk6ci5wcmV2aW91c1NpYmxpbmc9aTtkb3tvLnBhcmVudE5vZGU9ZX13aGlsZShvIT09aSYmKG89by5uZXh0U2libGluZykpO3JldHVybiBHKGUub3duZXJEb2N1bWVudHx8ZSxlKSx0Lm5vZGVUeXBlPT1BJiYodC5maXJzdENoaWxkPXQubGFzdENoaWxkPW51bGwpLHR9ZnVuY3Rpb24gSygpe3RoaXMuX25zTWFwPXt9fWZ1bmN0aW9uIGVlKCl7fWZ1bmN0aW9uIHRlKCl7fWZ1bmN0aW9uIHJlKCl7fWZ1bmN0aW9uIGFlKCl7fWZ1bmN0aW9uIG5lKCl7fWZ1bmN0aW9uIG9lKCl7fWZ1bmN0aW9uIGllKCl7fWZ1bmN0aW9uIHNlKCl7fWZ1bmN0aW9uIGxlKCl7fWZ1bmN0aW9uIGNlKCl7fWZ1bmN0aW9uIHVlKCl7fWZ1bmN0aW9uIGhlKCl7fWZ1bmN0aW9uIGRlKGUsdCl7dmFyIHI9W10sYT05PT10aGlzLm5vZGVUeXBlJiZ0aGlzLmRvY3VtZW50RWxlbWVudHx8dGhpcyxuPWEucHJlZml4LG89YS5uYW1lc3BhY2VVUkk7aWYobyYmbnVsbD09biYmbnVsbD09KG49YS5sb29rdXBQcmVmaXgobykpKXZhciBpPVt7bmFtZXNwYWNlOm8scHJlZml4Om51bGx9XTtyZXR1cm4gZmUodGhpcyxyLGUsdCxpKSxyLmpvaW4oXCJcIil9ZnVuY3Rpb24gbWUoZSx0LHIpe3ZhciBhPWUucHJlZml4fHxcIlwiLG49ZS5uYW1lc3BhY2VVUkk7aWYoIW4pcmV0dXJuITE7aWYoXCJ4bWxcIj09PWEmJm49PT1vLlhNTHx8bj09PW8uWE1MTlMpcmV0dXJuITE7Zm9yKHZhciBpPXIubGVuZ3RoO2ktLTspe3ZhciBzPXJbaV07aWYocy5wcmVmaXg9PT1hKXJldHVybiBzLm5hbWVzcGFjZSE9PW59cmV0dXJuITB9ZnVuY3Rpb24gcGUoZSx0LHIpe2UucHVzaChcIiBcIix0LCc9XCInLHIucmVwbGFjZSgvWzw+JlwiXFx0XFxuXFxyXS9nLEkpLCdcIicpfWZ1bmN0aW9uIGZlKGUsdCxyLGEsbil7aWYobnx8KG49W10pLGEpe2lmKCEoZT1hKGUpKSlyZXR1cm47aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIHZvaWQgdC5wdXNoKGUpfXN3aXRjaChlLm5vZGVUeXBlKXtjYXNlIGQ6dmFyIGk9ZS5hdHRyaWJ1dGVzLHM9aS5sZW5ndGgsbD1lLmZpcnN0Q2hpbGQsYz1lLnRhZ05hbWUsdT1jO2lmKCEocj1vLmlzSFRNTChlLm5hbWVzcGFjZVVSSSl8fHIpJiYhZS5wcmVmaXgmJmUubmFtZXNwYWNlVVJJKXtmb3IodmFyIGgsZz0wO2c8aS5sZW5ndGg7ZysrKWlmKFwieG1sbnNcIj09PWkuaXRlbShnKS5uYW1lKXtoPWkuaXRlbShnKS52YWx1ZTticmVha31pZighaClmb3IodmFyIEU9bi5sZW5ndGgtMTtFPj0wO0UtLSlpZihcIlwiPT09KF89bltFXSkucHJlZml4JiZfLm5hbWVzcGFjZT09PWUubmFtZXNwYWNlVVJJKXtoPV8ubmFtZXNwYWNlO2JyZWFrfWlmKGghPT1lLm5hbWVzcGFjZVVSSSlmb3IoRT1uLmxlbmd0aC0xO0U+PTA7RS0tKXt2YXIgXztpZigoXz1uW0VdKS5uYW1lc3BhY2U9PT1lLm5hbWVzcGFjZVVSSSl7Xy5wcmVmaXgmJih1PV8ucHJlZml4K1wiOlwiK2MpO2JyZWFrfX19dC5wdXNoKFwiPFwiLHUpO2Zvcih2YXIgeT0wO3k8czt5KyspXCJ4bWxuc1wiPT0ocT1pLml0ZW0oeSkpLnByZWZpeD9uLnB1c2goe3ByZWZpeDpxLmxvY2FsTmFtZSxuYW1lc3BhY2U6cS52YWx1ZX0pOlwieG1sbnNcIj09cS5ub2RlTmFtZSYmbi5wdXNoKHtwcmVmaXg6XCJcIixuYW1lc3BhY2U6cS52YWx1ZX0pO2Zvcih5PTA7eTxzO3krKyl7dmFyIHEsRCxNO21lKHE9aS5pdGVtKHkpLDAsbikmJihwZSh0LChEPXEucHJlZml4fHxcIlwiKT9cInhtbG5zOlwiK0Q6XCJ4bWxuc1wiLE09cS5uYW1lc3BhY2VVUkkpLG4ucHVzaCh7cHJlZml4OkQsbmFtZXNwYWNlOk19KSksZmUocSx0LHIsYSxuKX1pZihjPT09dSYmbWUoZSwwLG4pJiYocGUodCwoRD1lLnByZWZpeHx8XCJcIik/XCJ4bWxuczpcIitEOlwieG1sbnNcIixNPWUubmFtZXNwYWNlVVJJKSxuLnB1c2goe3ByZWZpeDpELG5hbWVzcGFjZTpNfSkpLGx8fHImJiEvXig/Om1ldGF8bGlua3xpbWd8YnJ8aHJ8aW5wdXQpJC9pLnRlc3QoYykpe2lmKHQucHVzaChcIj5cIiksciYmL15zY3JpcHQkL2kudGVzdChjKSlmb3IoO2w7KWwuZGF0YT90LnB1c2gobC5kYXRhKTpmZShsLHQscixhLG4uc2xpY2UoKSksbD1sLm5leHRTaWJsaW5nO2Vsc2UgZm9yKDtsOylmZShsLHQscixhLG4uc2xpY2UoKSksbD1sLm5leHRTaWJsaW5nO3QucHVzaChcIjwvXCIsdSxcIj5cIil9ZWxzZSB0LnB1c2goXCIvPlwiKTtyZXR1cm47Y2FzZSB2OmNhc2UgQTpmb3IobD1lLmZpcnN0Q2hpbGQ7bDspZmUobCx0LHIsYSxuLnNsaWNlKCkpLGw9bC5uZXh0U2libGluZztyZXR1cm47Y2FzZSBtOnJldHVybiBwZSh0LGUubmFtZSxlLnZhbHVlKTtjYXNlIHA6cmV0dXJuIHQucHVzaChlLmRhdGEucmVwbGFjZSgvWzwmPl0vZyxJKSk7Y2FzZSBmOnJldHVybiB0LnB1c2goXCI8IVtDREFUQVtcIixlLmRhdGEsXCJdXT5cIik7Y2FzZSBiOnJldHVybiB0LnB1c2goXCJcXHgzYyEtLVwiLGUuZGF0YSxcIi0tXFx4M2VcIik7Y2FzZSBDOnZhciBUPWUucHVibGljSWQsTj1lLnN5c3RlbUlkO2lmKHQucHVzaChcIjwhRE9DVFlQRSBcIixlLm5hbWUpLFQpdC5wdXNoKFwiIFBVQkxJQyBcIixUKSxOJiZcIi5cIiE9TiYmdC5wdXNoKFwiIFwiLE4pLHQucHVzaChcIj5cIik7ZWxzZSBpZihOJiZcIi5cIiE9Til0LnB1c2goXCIgU1lTVEVNIFwiLE4sXCI+XCIpO2Vsc2V7dmFyIE89ZS5pbnRlcm5hbFN1YnNldDtPJiZ0LnB1c2goXCIgW1wiLE8sXCJdXCIpLHQucHVzaChcIj5cIil9cmV0dXJuO2Nhc2UgdzpyZXR1cm4gdC5wdXNoKFwiPD9cIixlLnRhcmdldCxcIiBcIixlLmRhdGEsXCI/PlwiKTtjYXNlIHg6cmV0dXJuIHQucHVzaChcIiZcIixlLm5vZGVOYW1lLFwiO1wiKTtkZWZhdWx0OnQucHVzaChcIj8/XCIsZS5ub2RlTmFtZSl9fWZ1bmN0aW9uIHhlKGUsdCxyKXt2YXIgYTtzd2l0Y2godC5ub2RlVHlwZSl7Y2FzZSBkOihhPXQuY2xvbmVOb2RlKCExKSkub3duZXJEb2N1bWVudD1lO2Nhc2UgQTpicmVhaztjYXNlIG06cj0hMH1pZihhfHwoYT10LmNsb25lTm9kZSghMSkpLGEub3duZXJEb2N1bWVudD1lLGEucGFyZW50Tm9kZT1udWxsLHIpZm9yKHZhciBuPXQuZmlyc3RDaGlsZDtuOylhLmFwcGVuZENoaWxkKHhlKGUsbixyKSksbj1uLm5leHRTaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGdlKGUsdCxyKXt2YXIgYT1uZXcgdC5jb25zdHJ1Y3Rvcjtmb3IodmFyIG4gaW4gdClpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSl7dmFyIG89dFtuXTtcIm9iamVjdFwiIT10eXBlb2YgbyYmbyE9YVtuXSYmKGFbbl09byl9c3dpdGNoKHQuY2hpbGROb2RlcyYmKGEuY2hpbGROb2Rlcz1uZXcgTiksYS5vd25lckRvY3VtZW50PWUsYS5ub2RlVHlwZSl7Y2FzZSBkOnZhciBpPXQuYXR0cmlidXRlcyxzPWEuYXR0cmlidXRlcz1uZXcgQixsPWkubGVuZ3RoO3MuX293bmVyRWxlbWVudD1hO2Zvcih2YXIgYz0wO2M8bDtjKyspYS5zZXRBdHRyaWJ1dGVOb2RlKGdlKGUsaS5pdGVtKGMpLCEwKSk7YnJlYWs7Y2FzZSBtOnI9ITB9aWYocilmb3IodmFyIHU9dC5maXJzdENoaWxkO3U7KWEuYXBwZW5kQ2hpbGQoZ2UoZSx1LHIpKSx1PXUubmV4dFNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gd2UoZSx0LHIpe2VbdF09cn1fLklOVkFMSURfU1RBVEVfRVJSPSh5WzExXT1cIkludmFsaWQgc3RhdGVcIiwxMSksXy5TWU5UQVhfRVJSPSh5WzEyXT1cIlN5bnRheCBlcnJvclwiLDEyKSxfLklOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUj0oeVsxM109XCJJbnZhbGlkIG1vZGlmaWNhdGlvblwiLDEzKSxfLk5BTUVTUEFDRV9FUlI9KHlbMTRdPVwiSW52YWxpZCBuYW1lc3BhY2VcIiwxNCksXy5JTlZBTElEX0FDQ0VTU19FUlI9KHlbMTVdPVwiSW52YWxpZCBhY2Nlc3NcIiwxNSksVC5wcm90b3R5cGU9RXJyb3IucHJvdG90eXBlLGMoXyxUKSxOLnByb3RvdHlwZT17bGVuZ3RoOjAsaXRlbTpmdW5jdGlvbihlKXtyZXR1cm4gZT49MCYmZTx0aGlzLmxlbmd0aD90aGlzW2VdOm51bGx9LHRvU3RyaW5nOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByPVtdLGE9MDthPHRoaXMubGVuZ3RoO2ErKylmZSh0aGlzW2FdLHIsZSx0KTtyZXR1cm4gci5qb2luKFwiXCIpfSxmaWx0ZXI6ZnVuY3Rpb24oZSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0aGlzLGUpfSxpbmRleE9mOmZ1bmN0aW9uKGUpe3JldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsZSl9fSxPLnByb3RvdHlwZS5pdGVtPWZ1bmN0aW9uKGUpe3JldHVybiBMKHRoaXMpLHRoaXNbZV18fG51bGx9LHUoTyxOKSxCLnByb3RvdHlwZT17bGVuZ3RoOjAsaXRlbTpOLnByb3RvdHlwZS5pdGVtLGdldE5hbWVkSXRlbTpmdW5jdGlvbihlKXtmb3IodmFyIHQ9dGhpcy5sZW5ndGg7dC0tOyl7dmFyIHI9dGhpc1t0XTtpZihyLm5vZGVOYW1lPT1lKXJldHVybiByfX0sc2V0TmFtZWRJdGVtOmZ1bmN0aW9uKGUpe3ZhciB0PWUub3duZXJFbGVtZW50O2lmKHQmJnQhPXRoaXMuX293bmVyRWxlbWVudCl0aHJvdyBuZXcgVChNKTt2YXIgcj10aGlzLmdldE5hbWVkSXRlbShlLm5vZGVOYW1lKTtyZXR1cm4gRih0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxlLHIpLHJ9LHNldE5hbWVkSXRlbU5TOmZ1bmN0aW9uKGUpe3ZhciB0LHI9ZS5vd25lckVsZW1lbnQ7aWYociYmciE9dGhpcy5fb3duZXJFbGVtZW50KXRocm93IG5ldyBUKE0pO3JldHVybiB0PXRoaXMuZ2V0TmFtZWRJdGVtTlMoZS5uYW1lc3BhY2VVUkksZS5sb2NhbE5hbWUpLEYodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsZSx0KSx0fSxyZW1vdmVOYW1lZEl0ZW06ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXROYW1lZEl0ZW0oZSk7cmV0dXJuIFAodGhpcy5fb3duZXJFbGVtZW50LHRoaXMsdCksdH0scmVtb3ZlTmFtZWRJdGVtTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmdldE5hbWVkSXRlbU5TKGUsdCk7cmV0dXJuIFAodGhpcy5fb3duZXJFbGVtZW50LHRoaXMscikscn0sZ2V0TmFtZWRJdGVtTlM6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHI9dGhpcy5sZW5ndGg7ci0tOyl7dmFyIGE9dGhpc1tyXTtpZihhLmxvY2FsTmFtZT09dCYmYS5uYW1lc3BhY2VVUkk9PWUpcmV0dXJuIGF9cmV0dXJuIG51bGx9fSxrLnByb3RvdHlwZT17aGFzRmVhdHVyZTpmdW5jdGlvbihlLHQpe3JldHVybiEwfSxjcmVhdGVEb2N1bWVudDpmdW5jdGlvbihlLHQscil7dmFyIGE9bmV3IGo7aWYoYS5pbXBsZW1lbnRhdGlvbj10aGlzLGEuY2hpbGROb2Rlcz1uZXcgTixhLmRvY3R5cGU9cnx8bnVsbCxyJiZhLmFwcGVuZENoaWxkKHIpLHQpe3ZhciBuPWEuY3JlYXRlRWxlbWVudE5TKGUsdCk7YS5hcHBlbmRDaGlsZChuKX1yZXR1cm4gYX0sY3JlYXRlRG9jdW1lbnRUeXBlOmZ1bmN0aW9uKGUsdCxyKXt2YXIgYT1uZXcgb2U7cmV0dXJuIGEubmFtZT1lLGEubm9kZU5hbWU9ZSxhLnB1YmxpY0lkPXR8fFwiXCIsYS5zeXN0ZW1JZD1yfHxcIlwiLGF9fSxSLnByb3RvdHlwZT17Zmlyc3RDaGlsZDpudWxsLGxhc3RDaGlsZDpudWxsLHByZXZpb3VzU2libGluZzpudWxsLG5leHRTaWJsaW5nOm51bGwsYXR0cmlidXRlczpudWxsLHBhcmVudE5vZGU6bnVsbCxjaGlsZE5vZGVzOm51bGwsb3duZXJEb2N1bWVudDpudWxsLG5vZGVWYWx1ZTpudWxsLG5hbWVzcGFjZVVSSTpudWxsLHByZWZpeDpudWxsLGxvY2FsTmFtZTpudWxsLGluc2VydEJlZm9yZTpmdW5jdGlvbihlLHQpe3JldHVybiBRKHRoaXMsZSx0KX0scmVwbGFjZUNoaWxkOmZ1bmN0aW9uKGUsdCl7USh0aGlzLGUsdCxaKSx0JiZ0aGlzLnJlbW92ZUNoaWxkKHQpfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihlKXtyZXR1cm4gJCh0aGlzLGUpfSxhcHBlbmRDaGlsZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUoZSxudWxsKX0saGFzQ2hpbGROb2RlczpmdW5jdGlvbigpe3JldHVybiBudWxsIT10aGlzLmZpcnN0Q2hpbGR9LGNsb25lTm9kZTpmdW5jdGlvbihlKXtyZXR1cm4gZ2UodGhpcy5vd25lckRvY3VtZW50fHx0aGlzLHRoaXMsZSl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgZT10aGlzLmZpcnN0Q2hpbGQ7ZTspe3ZhciB0PWUubmV4dFNpYmxpbmc7dCYmdC5ub2RlVHlwZT09cCYmZS5ub2RlVHlwZT09cD8odGhpcy5yZW1vdmVDaGlsZCh0KSxlLmFwcGVuZERhdGEodC5kYXRhKSk6KGUubm9ybWFsaXplKCksZT10KX19LGlzU3VwcG9ydGVkOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKGUsdCl9LGhhc0F0dHJpYnV0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmxlbmd0aD4wfSxsb29rdXBQcmVmaXg6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXM7dDspe3ZhciByPXQuX25zTWFwO2lmKHIpZm9yKHZhciBhIGluIHIpaWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsYSkmJnJbYV09PT1lKXJldHVybiBhO3Q9dC5ub2RlVHlwZT09bT90Lm93bmVyRG9jdW1lbnQ6dC5wYXJlbnROb2RlfXJldHVybiBudWxsfSxsb29rdXBOYW1lc3BhY2VVUkk6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PXRoaXM7dDspe3ZhciByPXQuX25zTWFwO2lmKHImJk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyLGUpKXJldHVybiByW2VdO3Q9dC5ub2RlVHlwZT09bT90Lm93bmVyRG9jdW1lbnQ6dC5wYXJlbnROb2RlfXJldHVybiBudWxsfSxpc0RlZmF1bHROYW1lc3BhY2U6ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGw9PXRoaXMubG9va3VwUHJlZml4KGUpfX0sYyhoLFIpLGMoaCxSLnByb3RvdHlwZSksai5wcm90b3R5cGU9e25vZGVOYW1lOlwiI2RvY3VtZW50XCIsbm9kZVR5cGU6dixkb2N0eXBlOm51bGwsZG9jdW1lbnRFbGVtZW50Om51bGwsX2luYzoxLGluc2VydEJlZm9yZTpmdW5jdGlvbihlLHQpe2lmKGUubm9kZVR5cGU9PUEpe2Zvcih2YXIgcj1lLmZpcnN0Q2hpbGQ7cjspe3ZhciBhPXIubmV4dFNpYmxpbmc7dGhpcy5pbnNlcnRCZWZvcmUocix0KSxyPWF9cmV0dXJuIGV9cmV0dXJuIFEodGhpcyxlLHQpLGUub3duZXJEb2N1bWVudD10aGlzLG51bGw9PT10aGlzLmRvY3VtZW50RWxlbWVudCYmZS5ub2RlVHlwZT09PWQmJih0aGlzLmRvY3VtZW50RWxlbWVudD1lKSxlfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5kb2N1bWVudEVsZW1lbnQ9PWUmJih0aGlzLmRvY3VtZW50RWxlbWVudD1udWxsKSwkKHRoaXMsZSl9LHJlcGxhY2VDaGlsZDpmdW5jdGlvbihlLHQpe1EodGhpcyxlLHQsWiksZS5vd25lckRvY3VtZW50PXRoaXMsdCYmdGhpcy5yZW1vdmVDaGlsZCh0KSxIKGUpJiYodGhpcy5kb2N1bWVudEVsZW1lbnQ9ZSl9LGltcG9ydE5vZGU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4geGUodGhpcyxlLHQpfSxnZXRFbGVtZW50QnlJZDpmdW5jdGlvbihlKXt2YXIgdD1udWxsO3JldHVybiBVKHRoaXMuZG9jdW1lbnRFbGVtZW50LChmdW5jdGlvbihyKXtpZihyLm5vZGVUeXBlPT1kJiZyLmdldEF0dHJpYnV0ZShcImlkXCIpPT1lKXJldHVybiB0PXIsITB9KSksdH0sZ2V0RWxlbWVudHNCeUNsYXNzTmFtZTpmdW5jdGlvbihlKXt2YXIgdD1sKGUpO3JldHVybiBuZXcgTyh0aGlzLChmdW5jdGlvbihyKXt2YXIgYT1bXTtyZXR1cm4gdC5sZW5ndGg+MCYmVShyLmRvY3VtZW50RWxlbWVudCwoZnVuY3Rpb24obil7aWYobiE9PXImJm4ubm9kZVR5cGU9PT1kKXt2YXIgbz1uLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO2lmKG8pe3ZhciBpPWU9PT1vO2lmKCFpKXt2YXIgcz1sKG8pO2k9dC5ldmVyeSgoYz1zLGZ1bmN0aW9uKGUpe3JldHVybiBjJiYtMSE9PWMuaW5kZXhPZihlKX0pKX1pJiZhLnB1c2gobil9fXZhciBjfSkpLGF9KSl9LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEs7cmV0dXJuIHQub3duZXJEb2N1bWVudD10aGlzLHQubm9kZU5hbWU9ZSx0LnRhZ05hbWU9ZSx0LmxvY2FsTmFtZT1lLHQuY2hpbGROb2Rlcz1uZXcgTiwodC5hdHRyaWJ1dGVzPW5ldyBCKS5fb3duZXJFbGVtZW50PXQsdH0sY3JlYXRlRG9jdW1lbnRGcmFnbWVudDpmdW5jdGlvbigpe3ZhciBlPW5ldyBjZTtyZXR1cm4gZS5vd25lckRvY3VtZW50PXRoaXMsZS5jaGlsZE5vZGVzPW5ldyBOLGV9LGNyZWF0ZVRleHROb2RlOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyByZTtyZXR1cm4gdC5vd25lckRvY3VtZW50PXRoaXMsdC5hcHBlbmREYXRhKGUpLHR9LGNyZWF0ZUNvbW1lbnQ6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGFlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0LmFwcGVuZERhdGEoZSksdH0sY3JlYXRlQ0RBVEFTZWN0aW9uOmZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBuZTtyZXR1cm4gdC5vd25lckRvY3VtZW50PXRoaXMsdC5hcHBlbmREYXRhKGUpLHR9LGNyZWF0ZVByb2Nlc3NpbmdJbnN0cnVjdGlvbjpmdW5jdGlvbihlLHQpe3ZhciByPW5ldyB1ZTtyZXR1cm4gci5vd25lckRvY3VtZW50PXRoaXMsci50YWdOYW1lPXIubm9kZU5hbWU9ci50YXJnZXQ9ZSxyLm5vZGVWYWx1ZT1yLmRhdGE9dCxyfSxjcmVhdGVBdHRyaWJ1dGU6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGVlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0Lm5hbWU9ZSx0Lm5vZGVOYW1lPWUsdC5sb2NhbE5hbWU9ZSx0LnNwZWNpZmllZD0hMCx0fSxjcmVhdGVFbnRpdHlSZWZlcmVuY2U6ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IGxlO3JldHVybiB0Lm93bmVyRG9jdW1lbnQ9dGhpcyx0Lm5vZGVOYW1lPWUsdH0sY3JlYXRlRWxlbWVudE5TOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bmV3IEssYT10LnNwbGl0KFwiOlwiKSxuPXIuYXR0cmlidXRlcz1uZXcgQjtyZXR1cm4gci5jaGlsZE5vZGVzPW5ldyBOLHIub3duZXJEb2N1bWVudD10aGlzLHIubm9kZU5hbWU9dCxyLnRhZ05hbWU9dCxyLm5hbWVzcGFjZVVSST1lLDI9PWEubGVuZ3RoPyhyLnByZWZpeD1hWzBdLHIubG9jYWxOYW1lPWFbMV0pOnIubG9jYWxOYW1lPXQsbi5fb3duZXJFbGVtZW50PXIscn0sY3JlYXRlQXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj1uZXcgZWUsYT10LnNwbGl0KFwiOlwiKTtyZXR1cm4gci5vd25lckRvY3VtZW50PXRoaXMsci5ub2RlTmFtZT10LHIubmFtZT10LHIubmFtZXNwYWNlVVJJPWUsci5zcGVjaWZpZWQ9ITAsMj09YS5sZW5ndGg/KHIucHJlZml4PWFbMF0sci5sb2NhbE5hbWU9YVsxXSk6ci5sb2NhbE5hbWU9dCxyfX0sdShqLFIpLEsucHJvdG90eXBlPXtub2RlVHlwZTpkLGhhc0F0dHJpYnV0ZTpmdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlKGUpfSxnZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlKGUpO3JldHVybiB0JiZ0LnZhbHVlfHxcIlwifSxnZXRBdHRyaWJ1dGVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKGUpfSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlKGUpO3IudmFsdWU9ci5ub2RlVmFsdWU9XCJcIit0LHRoaXMuc2V0QXR0cmlidXRlTm9kZShyKX0scmVtb3ZlQXR0cmlidXRlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0QXR0cmlidXRlTm9kZShlKTt0JiZ0aGlzLnJlbW92ZUF0dHJpYnV0ZU5vZGUodCl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKGUpe3JldHVybiBlLm5vZGVUeXBlPT09QT90aGlzLmluc2VydEJlZm9yZShlLG51bGwpOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQucGFyZW50Tm9kZSYmdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLHQucGFyZW50Tm9kZT1lLHQucHJldmlvdXNTaWJsaW5nPWUubGFzdENoaWxkLHQubmV4dFNpYmxpbmc9bnVsbCx0LnByZXZpb3VzU2libGluZz90LnByZXZpb3VzU2libGluZy5uZXh0U2libGluZz10OmUuZmlyc3RDaGlsZD10LGUubGFzdENoaWxkPXQsRyhlLm93bmVyRG9jdW1lbnQsZSx0KSx0fSh0aGlzLGUpfSxzZXRBdHRyaWJ1dGVOb2RlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtKGUpfSxzZXRBdHRyaWJ1dGVOb2RlTlM6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuYXR0cmlidXRlcy5zZXROYW1lZEl0ZW1OUyhlKX0scmVtb3ZlQXR0cmlidXRlTm9kZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnJlbW92ZU5hbWVkSXRlbShlLm5vZGVOYW1lKX0scmVtb3ZlQXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhlLHQpO3ImJnRoaXMucmVtb3ZlQXR0cmlidXRlTm9kZShyKX0saGFzQXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbnVsbCE9dGhpcy5nZXRBdHRyaWJ1dGVOb2RlTlMoZSx0KX0sZ2V0QXR0cmlidXRlTlM6ZnVuY3Rpb24oZSx0KXt2YXIgcj10aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhlLHQpO3JldHVybiByJiZyLnZhbHVlfHxcIlwifSxzZXRBdHRyaWJ1dGVOUzpmdW5jdGlvbihlLHQscil7dmFyIGE9dGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZU5TKGUsdCk7YS52YWx1ZT1hLm5vZGVWYWx1ZT1cIlwiK3IsdGhpcy5zZXRBdHRyaWJ1dGVOb2RlKGEpfSxnZXRBdHRyaWJ1dGVOb2RlTlM6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbU5TKGUsdCl9LGdldEVsZW1lbnRzQnlUYWdOYW1lOmZ1bmN0aW9uKGUpe3JldHVybiBuZXcgTyh0aGlzLChmdW5jdGlvbih0KXt2YXIgcj1bXTtyZXR1cm4gVSh0LChmdW5jdGlvbihhKXthPT09dHx8YS5ub2RlVHlwZSE9ZHx8XCIqXCIhPT1lJiZhLnRhZ05hbWUhPWV8fHIucHVzaChhKX0pKSxyfSkpfSxnZXRFbGVtZW50c0J5VGFnTmFtZU5TOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyBPKHRoaXMsKGZ1bmN0aW9uKHIpe3ZhciBhPVtdO3JldHVybiBVKHIsKGZ1bmN0aW9uKG4pe249PT1yfHxuLm5vZGVUeXBlIT09ZHx8XCIqXCIhPT1lJiZuLm5hbWVzcGFjZVVSSSE9PWV8fFwiKlwiIT09dCYmbi5sb2NhbE5hbWUhPXR8fGEucHVzaChuKX0pKSxhfSkpfX0sai5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWU9Sy5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUsai5wcm90b3R5cGUuZ2V0RWxlbWVudHNCeVRhZ05hbWVOUz1LLnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TLHUoSyxSKSxlZS5wcm90b3R5cGUubm9kZVR5cGU9bSx1KGVlLFIpLHRlLnByb3RvdHlwZT17ZGF0YTpcIlwiLHN1YnN0cmluZ0RhdGE6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdGhpcy5kYXRhLnN1YnN0cmluZyhlLGUrdCl9LGFwcGVuZERhdGE6ZnVuY3Rpb24oZSl7ZT10aGlzLmRhdGErZSx0aGlzLm5vZGVWYWx1ZT10aGlzLmRhdGE9ZSx0aGlzLmxlbmd0aD1lLmxlbmd0aH0saW5zZXJ0RGF0YTpmdW5jdGlvbihlLHQpe3RoaXMucmVwbGFjZURhdGEoZSwwLHQpfSxhcHBlbmRDaGlsZDpmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoeVtxXSl9LGRlbGV0ZURhdGE6ZnVuY3Rpb24oZSx0KXt0aGlzLnJlcGxhY2VEYXRhKGUsdCxcIlwiKX0scmVwbGFjZURhdGE6ZnVuY3Rpb24oZSx0LHIpe3I9dGhpcy5kYXRhLnN1YnN0cmluZygwLGUpK3IrdGhpcy5kYXRhLnN1YnN0cmluZyhlK3QpLHRoaXMubm9kZVZhbHVlPXRoaXMuZGF0YT1yLHRoaXMubGVuZ3RoPXIubGVuZ3RofX0sdSh0ZSxSKSxyZS5wcm90b3R5cGU9e25vZGVOYW1lOlwiI3RleHRcIixub2RlVHlwZTpwLHNwbGl0VGV4dDpmdW5jdGlvbihlKXt2YXIgdD10aGlzLmRhdGEscj10LnN1YnN0cmluZyhlKTt0PXQuc3Vic3RyaW5nKDAsZSksdGhpcy5kYXRhPXRoaXMubm9kZVZhbHVlPXQsdGhpcy5sZW5ndGg9dC5sZW5ndGg7dmFyIGE9dGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHIpO3JldHVybiB0aGlzLnBhcmVudE5vZGUmJnRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSx0aGlzLm5leHRTaWJsaW5nKSxhfX0sdShyZSx0ZSksYWUucHJvdG90eXBlPXtub2RlTmFtZTpcIiNjb21tZW50XCIsbm9kZVR5cGU6Yn0sdShhZSx0ZSksbmUucHJvdG90eXBlPXtub2RlTmFtZTpcIiNjZGF0YS1zZWN0aW9uXCIsbm9kZVR5cGU6Zn0sdShuZSx0ZSksb2UucHJvdG90eXBlLm5vZGVUeXBlPUMsdShvZSxSKSxpZS5wcm90b3R5cGUubm9kZVR5cGU9RSx1KGllLFIpLHNlLnByb3RvdHlwZS5ub2RlVHlwZT1nLHUoc2UsUiksbGUucHJvdG90eXBlLm5vZGVUeXBlPXgsdShsZSxSKSxjZS5wcm90b3R5cGUubm9kZU5hbWU9XCIjZG9jdW1lbnQtZnJhZ21lbnRcIixjZS5wcm90b3R5cGUubm9kZVR5cGU9QSx1KGNlLFIpLHVlLnByb3RvdHlwZS5ub2RlVHlwZT13LHUodWUsUiksaGUucHJvdG90eXBlLnNlcmlhbGl6ZVRvU3RyaW5nPWZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZGUuY2FsbChlLHQscil9LFIucHJvdG90eXBlLnRvU3RyaW5nPWRlO3RyeXtpZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe2Z1bmN0aW9uIGJlKGUpe3N3aXRjaChlLm5vZGVUeXBlKXtjYXNlIGQ6Y2FzZSBBOnZhciB0PVtdO2ZvcihlPWUuZmlyc3RDaGlsZDtlOyk3IT09ZS5ub2RlVHlwZSYmOCE9PWUubm9kZVR5cGUmJnQucHVzaChiZShlKSksZT1lLm5leHRTaWJsaW5nO3JldHVybiB0LmpvaW4oXCJcIik7ZGVmYXVsdDpyZXR1cm4gZS5ub2RlVmFsdWV9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLnByb3RvdHlwZSxcImxlbmd0aFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTCh0aGlzKSx0aGlzLiQkbGVuZ3RofX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSLnByb3RvdHlwZSxcInRleHRDb250ZW50XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBiZSh0aGlzKX0sc2V0OmZ1bmN0aW9uKGUpe3N3aXRjaCh0aGlzLm5vZGVUeXBlKXtjYXNlIGQ6Y2FzZSBBOmZvcig7dGhpcy5maXJzdENoaWxkOyl0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7KGV8fFN0cmluZyhlKSkmJnRoaXMuYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGUpKTticmVhaztkZWZhdWx0OnRoaXMuZGF0YT1lLHRoaXMudmFsdWU9ZSx0aGlzLm5vZGVWYWx1ZT1lfX19KSx3ZT1mdW5jdGlvbihlLHQscil7ZVtcIiQkXCIrdF09cn19fWNhdGNoKHZlKXt9dC5Eb2N1bWVudFR5cGU9b2UsdC5ET01FeGNlcHRpb249VCx0LkRPTUltcGxlbWVudGF0aW9uPWssdC5FbGVtZW50PUssdC5Ob2RlPVIsdC5Ob2RlTGlzdD1OLHQuWE1MU2VyaWFsaXplcj1oZX0sNjU1OTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9cig0NTgyKS5mcmVlemU7dC5YTUxfRU5USVRJRVM9YSh7YW1wOlwiJlwiLGFwb3M6XCInXCIsZ3Q6XCI+XCIsbHQ6XCI8XCIscXVvdDonXCInfSksdC5IVE1MX0VOVElUSUVTPWEoe0FhY3V0ZTpcIsOBXCIsYWFjdXRlOlwiw6FcIixBYnJldmU6XCLEglwiLGFicmV2ZTpcIsSDXCIsYWM6XCLiiL5cIixhY2Q6XCLiiL9cIixhY0U6XCLiiL7Ms1wiLEFjaXJjOlwiw4JcIixhY2lyYzpcIsOiXCIsYWN1dGU6XCLCtFwiLEFjeTpcItCQXCIsYWN5Olwi0LBcIixBRWxpZzpcIsOGXCIsYWVsaWc6XCLDplwiLGFmOlwi4oGhXCIsQWZyOlwi8J2UhFwiLGFmcjpcIvCdlJ5cIixBZ3JhdmU6XCLDgFwiLGFncmF2ZTpcIsOgXCIsYWxlZnN5bTpcIuKEtVwiLGFsZXBoOlwi4oS1XCIsQWxwaGE6XCLOkVwiLGFscGhhOlwizrFcIixBbWFjcjpcIsSAXCIsYW1hY3I6XCLEgVwiLGFtYWxnOlwi4qi/XCIsQU1QOlwiJlwiLGFtcDpcIiZcIixBbmQ6XCLiqZNcIixhbmQ6XCLiiKdcIixhbmRhbmQ6XCLiqZVcIixhbmRkOlwi4qmcXCIsYW5kc2xvcGU6XCLiqZhcIixhbmR2Olwi4qmaXCIsYW5nOlwi4oigXCIsYW5nZTpcIuKmpFwiLGFuZ2xlOlwi4oigXCIsYW5nbXNkOlwi4oihXCIsYW5nbXNkYWE6XCLipqhcIixhbmdtc2RhYjpcIuKmqVwiLGFuZ21zZGFjOlwi4qaqXCIsYW5nbXNkYWQ6XCLipqtcIixhbmdtc2RhZTpcIuKmrFwiLGFuZ21zZGFmOlwi4qatXCIsYW5nbXNkYWc6XCLipq5cIixhbmdtc2RhaDpcIuKmr1wiLGFuZ3J0Olwi4oifXCIsYW5ncnR2YjpcIuKKvlwiLGFuZ3J0dmJkOlwi4qadXCIsYW5nc3BoOlwi4oiiXCIsYW5nc3Q6XCLDhVwiLGFuZ3phcnI6XCLijbxcIixBb2dvbjpcIsSEXCIsYW9nb246XCLEhVwiLEFvcGY6XCLwnZS4XCIsYW9wZjpcIvCdlZJcIixhcDpcIuKJiFwiLGFwYWNpcjpcIuKpr1wiLGFwRTpcIuKpsFwiLGFwZTpcIuKJilwiLGFwaWQ6XCLiiYtcIixhcG9zOlwiJ1wiLEFwcGx5RnVuY3Rpb246XCLigaFcIixhcHByb3g6XCLiiYhcIixhcHByb3hlcTpcIuKJilwiLEFyaW5nOlwiw4VcIixhcmluZzpcIsOlXCIsQXNjcjpcIvCdkpxcIixhc2NyOlwi8J2StlwiLEFzc2lnbjpcIuKJlFwiLGFzdDpcIipcIixhc3ltcDpcIuKJiFwiLGFzeW1wZXE6XCLiiY1cIixBdGlsZGU6XCLDg1wiLGF0aWxkZTpcIsOjXCIsQXVtbDpcIsOEXCIsYXVtbDpcIsOkXCIsYXdjb25pbnQ6XCLiiLNcIixhd2ludDpcIuKokVwiLGJhY2tjb25nOlwi4omMXCIsYmFja2Vwc2lsb246XCLPtlwiLGJhY2twcmltZTpcIuKAtVwiLGJhY2tzaW06XCLiiL1cIixiYWNrc2ltZXE6XCLii41cIixCYWNrc2xhc2g6XCLiiJZcIixCYXJ2Olwi4qunXCIsYmFydmVlOlwi4oq9XCIsQmFyd2VkOlwi4oyGXCIsYmFyd2VkOlwi4oyFXCIsYmFyd2VkZ2U6XCLijIVcIixiYnJrOlwi4o61XCIsYmJya3Ricms6XCLijrZcIixiY29uZzpcIuKJjFwiLEJjeTpcItCRXCIsYmN5Olwi0LFcIixiZHF1bzpcIuKAnlwiLGJlY2F1czpcIuKItVwiLEJlY2F1c2U6XCLiiLVcIixiZWNhdXNlOlwi4oi1XCIsYmVtcHR5djpcIuKmsFwiLGJlcHNpOlwiz7ZcIixiZXJub3U6XCLihKxcIixCZXJub3VsbGlzOlwi4oSsXCIsQmV0YTpcIs6SXCIsYmV0YTpcIs6yXCIsYmV0aDpcIuKEtlwiLGJldHdlZW46XCLiiaxcIixCZnI6XCLwnZSFXCIsYmZyOlwi8J2Un1wiLGJpZ2NhcDpcIuKLglwiLGJpZ2NpcmM6XCLil69cIixiaWdjdXA6XCLii4NcIixiaWdvZG90Olwi4qiAXCIsYmlnb3BsdXM6XCLiqIFcIixiaWdvdGltZXM6XCLiqIJcIixiaWdzcWN1cDpcIuKohlwiLGJpZ3N0YXI6XCLimIVcIixiaWd0cmlhbmdsZWRvd246XCLilr1cIixiaWd0cmlhbmdsZXVwOlwi4pazXCIsYmlndXBsdXM6XCLiqIRcIixiaWd2ZWU6XCLii4FcIixiaWd3ZWRnZTpcIuKLgFwiLGJrYXJvdzpcIuKkjVwiLGJsYWNrbG96ZW5nZTpcIuKnq1wiLGJsYWNrc3F1YXJlOlwi4paqXCIsYmxhY2t0cmlhbmdsZTpcIuKWtFwiLGJsYWNrdHJpYW5nbGVkb3duOlwi4pa+XCIsYmxhY2t0cmlhbmdsZWxlZnQ6XCLil4JcIixibGFja3RyaWFuZ2xlcmlnaHQ6XCLilrhcIixibGFuazpcIuKQo1wiLGJsazEyOlwi4paSXCIsYmxrMTQ6XCLilpFcIixibGszNDpcIuKWk1wiLGJsb2NrOlwi4paIXCIsYm5lOlwiPeKDpVwiLGJuZXF1aXY6XCLiiaHig6VcIixiTm90Olwi4qutXCIsYm5vdDpcIuKMkFwiLEJvcGY6XCLwnZS5XCIsYm9wZjpcIvCdlZNcIixib3Q6XCLiiqVcIixib3R0b206XCLiiqVcIixib3d0aWU6XCLii4hcIixib3hib3g6XCLip4lcIixib3hETDpcIuKVl1wiLGJveERsOlwi4pWWXCIsYm94ZEw6XCLilZVcIixib3hkbDpcIuKUkFwiLGJveERSOlwi4pWUXCIsYm94RHI6XCLilZNcIixib3hkUjpcIuKVklwiLGJveGRyOlwi4pSMXCIsYm94SDpcIuKVkFwiLGJveGg6XCLilIBcIixib3hIRDpcIuKVplwiLGJveEhkOlwi4pWkXCIsYm94aEQ6XCLilaVcIixib3hoZDpcIuKUrFwiLGJveEhVOlwi4pWpXCIsYm94SHU6XCLiladcIixib3hoVTpcIuKVqFwiLGJveGh1Olwi4pS0XCIsYm94bWludXM6XCLiip9cIixib3hwbHVzOlwi4oqeXCIsYm94dGltZXM6XCLiiqBcIixib3hVTDpcIuKVnVwiLGJveFVsOlwi4pWcXCIsYm94dUw6XCLilZtcIixib3h1bDpcIuKUmFwiLGJveFVSOlwi4pWaXCIsYm94VXI6XCLilZlcIixib3h1UjpcIuKVmFwiLGJveHVyOlwi4pSUXCIsYm94VjpcIuKVkVwiLGJveHY6XCLilIJcIixib3hWSDpcIuKVrFwiLGJveFZoOlwi4pWrXCIsYm94dkg6XCLilapcIixib3h2aDpcIuKUvFwiLGJveFZMOlwi4pWjXCIsYm94Vmw6XCLilaJcIixib3h2TDpcIuKVoVwiLGJveHZsOlwi4pSkXCIsYm94VlI6XCLilaBcIixib3hWcjpcIuKVn1wiLGJveHZSOlwi4pWeXCIsYm94dnI6XCLilJxcIixicHJpbWU6XCLigLVcIixCcmV2ZTpcIsuYXCIsYnJldmU6XCLLmFwiLGJydmJhcjpcIsKmXCIsQnNjcjpcIuKErFwiLGJzY3I6XCLwnZK3XCIsYnNlbWk6XCLigY9cIixic2ltOlwi4oi9XCIsYnNpbWU6XCLii41cIixic29sOlwiXFxcXFwiLGJzb2xiOlwi4qeFXCIsYnNvbGhzdWI6XCLin4hcIixidWxsOlwi4oCiXCIsYnVsbGV0Olwi4oCiXCIsYnVtcDpcIuKJjlwiLGJ1bXBFOlwi4qquXCIsYnVtcGU6XCLiiY9cIixCdW1wZXE6XCLiiY5cIixidW1wZXE6XCLiiY9cIixDYWN1dGU6XCLEhlwiLGNhY3V0ZTpcIsSHXCIsQ2FwOlwi4ouSXCIsY2FwOlwi4oipXCIsY2FwYW5kOlwi4qmEXCIsY2FwYnJjdXA6XCLiqYlcIixjYXBjYXA6XCLiqYtcIixjYXBjdXA6XCLiqYdcIixjYXBkb3Q6XCLiqYBcIixDYXBpdGFsRGlmZmVyZW50aWFsRDpcIuKFhVwiLGNhcHM6XCLiiKnvuIBcIixjYXJldDpcIuKBgVwiLGNhcm9uOlwiy4dcIixDYXlsZXlzOlwi4oStXCIsY2NhcHM6XCLiqY1cIixDY2Fyb246XCLEjFwiLGNjYXJvbjpcIsSNXCIsQ2NlZGlsOlwiw4dcIixjY2VkaWw6XCLDp1wiLENjaXJjOlwixIhcIixjY2lyYzpcIsSJXCIsQ2NvbmludDpcIuKIsFwiLGNjdXBzOlwi4qmMXCIsY2N1cHNzbTpcIuKpkFwiLENkb3Q6XCLEilwiLGNkb3Q6XCLEi1wiLGNlZGlsOlwiwrhcIixDZWRpbGxhOlwiwrhcIixjZW1wdHl2Olwi4qayXCIsY2VudDpcIsKiXCIsQ2VudGVyRG90OlwiwrdcIixjZW50ZXJkb3Q6XCLCt1wiLENmcjpcIuKErVwiLGNmcjpcIvCdlKBcIixDSGN5Olwi0KdcIixjaGN5Olwi0YdcIixjaGVjazpcIuKck1wiLGNoZWNrbWFyazpcIuKck1wiLENoaTpcIs6nXCIsY2hpOlwiz4dcIixjaXI6XCLil4tcIixjaXJjOlwiy4ZcIixjaXJjZXE6XCLiiZdcIixjaXJjbGVhcnJvd2xlZnQ6XCLihrpcIixjaXJjbGVhcnJvd3JpZ2h0Olwi4oa7XCIsY2lyY2xlZGFzdDpcIuKKm1wiLGNpcmNsZWRjaXJjOlwi4oqaXCIsY2lyY2xlZGRhc2g6XCLiip1cIixDaXJjbGVEb3Q6XCLiiplcIixjaXJjbGVkUjpcIsKuXCIsY2lyY2xlZFM6XCLik4hcIixDaXJjbGVNaW51czpcIuKKllwiLENpcmNsZVBsdXM6XCLiipVcIixDaXJjbGVUaW1lczpcIuKKl1wiLGNpckU6XCLip4NcIixjaXJlOlwi4omXXCIsY2lyZm5pbnQ6XCLiqJBcIixjaXJtaWQ6XCLiq69cIixjaXJzY2lyOlwi4qeCXCIsQ2xvY2t3aXNlQ29udG91ckludGVncmFsOlwi4oiyXCIsQ2xvc2VDdXJseURvdWJsZVF1b3RlOlwi4oCdXCIsQ2xvc2VDdXJseVF1b3RlOlwi4oCZXCIsY2x1YnM6XCLimaNcIixjbHVic3VpdDpcIuKZo1wiLENvbG9uOlwi4oi3XCIsY29sb246XCI6XCIsQ29sb25lOlwi4qm0XCIsY29sb25lOlwi4omUXCIsY29sb25lcTpcIuKJlFwiLGNvbW1hOlwiLFwiLGNvbW1hdDpcIkBcIixjb21wOlwi4oiBXCIsY29tcGZuOlwi4oiYXCIsY29tcGxlbWVudDpcIuKIgVwiLGNvbXBsZXhlczpcIuKEglwiLGNvbmc6XCLiiYVcIixjb25nZG90Olwi4qmtXCIsQ29uZ3J1ZW50Olwi4omhXCIsQ29uaW50Olwi4oivXCIsY29uaW50Olwi4oiuXCIsQ29udG91ckludGVncmFsOlwi4oiuXCIsQ29wZjpcIuKEglwiLGNvcGY6XCLwnZWUXCIsY29wcm9kOlwi4oiQXCIsQ29wcm9kdWN0Olwi4oiQXCIsQ09QWTpcIsKpXCIsY29weTpcIsKpXCIsY29weXNyOlwi4oSXXCIsQ291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDpcIuKIs1wiLGNyYXJyOlwi4oa1XCIsQ3Jvc3M6XCLiqK9cIixjcm9zczpcIuKcl1wiLENzY3I6XCLwnZKeXCIsY3NjcjpcIvCdkrhcIixjc3ViOlwi4quPXCIsY3N1YmU6XCLiq5FcIixjc3VwOlwi4quQXCIsY3N1cGU6XCLiq5JcIixjdGRvdDpcIuKLr1wiLGN1ZGFycmw6XCLipLhcIixjdWRhcnJyOlwi4qS1XCIsY3VlcHI6XCLii55cIixjdWVzYzpcIuKLn1wiLGN1bGFycjpcIuKGtlwiLGN1bGFycnA6XCLipL1cIixDdXA6XCLii5NcIixjdXA6XCLiiKpcIixjdXBicmNhcDpcIuKpiFwiLEN1cENhcDpcIuKJjVwiLGN1cGNhcDpcIuKphlwiLGN1cGN1cDpcIuKpilwiLGN1cGRvdDpcIuKKjVwiLGN1cG9yOlwi4qmFXCIsY3VwczpcIuKIqu+4gFwiLGN1cmFycjpcIuKGt1wiLGN1cmFycm06XCLipLxcIixjdXJseWVxcHJlYzpcIuKLnlwiLGN1cmx5ZXFzdWNjOlwi4oufXCIsY3VybHl2ZWU6XCLii45cIixjdXJseXdlZGdlOlwi4ouPXCIsY3VycmVuOlwiwqRcIixjdXJ2ZWFycm93bGVmdDpcIuKGtlwiLGN1cnZlYXJyb3dyaWdodDpcIuKGt1wiLGN1dmVlOlwi4ouOXCIsY3V3ZWQ6XCLii49cIixjd2NvbmludDpcIuKIslwiLGN3aW50Olwi4oixXCIsY3lsY3R5Olwi4oytXCIsRGFnZ2VyOlwi4oChXCIsZGFnZ2VyOlwi4oCgXCIsZGFsZXRoOlwi4oS4XCIsRGFycjpcIuKGoVwiLGRBcnI6XCLih5NcIixkYXJyOlwi4oaTXCIsZGFzaDpcIuKAkFwiLERhc2h2Olwi4qukXCIsZGFzaHY6XCLiiqNcIixkYmthcm93Olwi4qSPXCIsZGJsYWM6XCLLnVwiLERjYXJvbjpcIsSOXCIsZGNhcm9uOlwixI9cIixEY3k6XCLQlFwiLGRjeTpcItC0XCIsREQ6XCLihYVcIixkZDpcIuKFhlwiLGRkYWdnZXI6XCLigKFcIixkZGFycjpcIuKHilwiLEREb3RyYWhkOlwi4qSRXCIsZGRvdHNlcTpcIuKpt1wiLGRlZzpcIsKwXCIsRGVsOlwi4oiHXCIsRGVsdGE6XCLOlFwiLGRlbHRhOlwizrRcIixkZW1wdHl2Olwi4qaxXCIsZGZpc2h0Olwi4qW/XCIsRGZyOlwi8J2Uh1wiLGRmcjpcIvCdlKFcIixkSGFyOlwi4qWlXCIsZGhhcmw6XCLih4NcIixkaGFycjpcIuKHglwiLERpYWNyaXRpY2FsQWN1dGU6XCLCtFwiLERpYWNyaXRpY2FsRG90Olwiy5lcIixEaWFjcml0aWNhbERvdWJsZUFjdXRlOlwiy51cIixEaWFjcml0aWNhbEdyYXZlOlwiYFwiLERpYWNyaXRpY2FsVGlsZGU6XCLLnFwiLGRpYW06XCLii4RcIixEaWFtb25kOlwi4ouEXCIsZGlhbW9uZDpcIuKLhFwiLGRpYW1vbmRzdWl0Olwi4pmmXCIsZGlhbXM6XCLimaZcIixkaWU6XCLCqFwiLERpZmZlcmVudGlhbEQ6XCLihYZcIixkaWdhbW1hOlwiz51cIixkaXNpbjpcIuKLslwiLGRpdjpcIsO3XCIsZGl2aWRlOlwiw7dcIixkaXZpZGVvbnRpbWVzOlwi4ouHXCIsZGl2b254Olwi4ouHXCIsREpjeTpcItCCXCIsZGpjeTpcItGSXCIsZGxjb3JuOlwi4oyeXCIsZGxjcm9wOlwi4oyNXCIsZG9sbGFyOlwiJFwiLERvcGY6XCLwnZS7XCIsZG9wZjpcIvCdlZVcIixEb3Q6XCLCqFwiLGRvdDpcIsuZXCIsRG90RG90Olwi4oOcXCIsZG90ZXE6XCLiiZBcIixkb3RlcWRvdDpcIuKJkVwiLERvdEVxdWFsOlwi4omQXCIsZG90bWludXM6XCLiiLhcIixkb3RwbHVzOlwi4oiUXCIsZG90c3F1YXJlOlwi4oqhXCIsZG91YmxlYmFyd2VkZ2U6XCLijIZcIixEb3VibGVDb250b3VySW50ZWdyYWw6XCLiiK9cIixEb3VibGVEb3Q6XCLCqFwiLERvdWJsZURvd25BcnJvdzpcIuKHk1wiLERvdWJsZUxlZnRBcnJvdzpcIuKHkFwiLERvdWJsZUxlZnRSaWdodEFycm93Olwi4oeUXCIsRG91YmxlTGVmdFRlZTpcIuKrpFwiLERvdWJsZUxvbmdMZWZ0QXJyb3c6XCLin7hcIixEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c6XCLin7pcIixEb3VibGVMb25nUmlnaHRBcnJvdzpcIuKfuVwiLERvdWJsZVJpZ2h0QXJyb3c6XCLih5JcIixEb3VibGVSaWdodFRlZTpcIuKKqFwiLERvdWJsZVVwQXJyb3c6XCLih5FcIixEb3VibGVVcERvd25BcnJvdzpcIuKHlVwiLERvdWJsZVZlcnRpY2FsQmFyOlwi4oilXCIsRG93bkFycm93Olwi4oaTXCIsRG93bmFycm93Olwi4oeTXCIsZG93bmFycm93Olwi4oaTXCIsRG93bkFycm93QmFyOlwi4qSTXCIsRG93bkFycm93VXBBcnJvdzpcIuKHtVwiLERvd25CcmV2ZTpcIsyRXCIsZG93bmRvd25hcnJvd3M6XCLih4pcIixkb3duaGFycG9vbmxlZnQ6XCLih4NcIixkb3duaGFycG9vbnJpZ2h0Olwi4oeCXCIsRG93bkxlZnRSaWdodFZlY3RvcjpcIuKlkFwiLERvd25MZWZ0VGVlVmVjdG9yOlwi4qWeXCIsRG93bkxlZnRWZWN0b3I6XCLihr1cIixEb3duTGVmdFZlY3RvckJhcjpcIuKlllwiLERvd25SaWdodFRlZVZlY3RvcjpcIuKln1wiLERvd25SaWdodFZlY3RvcjpcIuKHgVwiLERvd25SaWdodFZlY3RvckJhcjpcIuKll1wiLERvd25UZWU6XCLiiqRcIixEb3duVGVlQXJyb3c6XCLihqdcIixkcmJrYXJvdzpcIuKkkFwiLGRyY29ybjpcIuKMn1wiLGRyY3JvcDpcIuKMjFwiLERzY3I6XCLwnZKfXCIsZHNjcjpcIvCdkrlcIixEU2N5Olwi0IVcIixkc2N5Olwi0ZVcIixkc29sOlwi4qe2XCIsRHN0cm9rOlwixJBcIixkc3Ryb2s6XCLEkVwiLGR0ZG90Olwi4ouxXCIsZHRyaTpcIuKWv1wiLGR0cmlmOlwi4pa+XCIsZHVhcnI6XCLih7VcIixkdWhhcjpcIuKlr1wiLGR3YW5nbGU6XCLipqZcIixEWmN5Olwi0I9cIixkemN5Olwi0Z9cIixkemlncmFycjpcIuKfv1wiLEVhY3V0ZTpcIsOJXCIsZWFjdXRlOlwiw6lcIixlYXN0ZXI6XCLiqa5cIixFY2Fyb246XCLEmlwiLGVjYXJvbjpcIsSbXCIsZWNpcjpcIuKJllwiLEVjaXJjOlwiw4pcIixlY2lyYzpcIsOqXCIsZWNvbG9uOlwi4omVXCIsRWN5Olwi0K1cIixlY3k6XCLRjVwiLGVERG90Olwi4qm3XCIsRWRvdDpcIsSWXCIsZURvdDpcIuKJkVwiLGVkb3Q6XCLEl1wiLGVlOlwi4oWHXCIsZWZEb3Q6XCLiiZJcIixFZnI6XCLwnZSIXCIsZWZyOlwi8J2UolwiLGVnOlwi4qqaXCIsRWdyYXZlOlwiw4hcIixlZ3JhdmU6XCLDqFwiLGVnczpcIuKqllwiLGVnc2RvdDpcIuKqmFwiLGVsOlwi4qqZXCIsRWxlbWVudDpcIuKIiFwiLGVsaW50ZXJzOlwi4o+nXCIsZWxsOlwi4oSTXCIsZWxzOlwi4qqVXCIsZWxzZG90Olwi4qqXXCIsRW1hY3I6XCLEklwiLGVtYWNyOlwixJNcIixlbXB0eTpcIuKIhVwiLGVtcHR5c2V0Olwi4oiFXCIsRW1wdHlTbWFsbFNxdWFyZTpcIuKXu1wiLGVtcHR5djpcIuKIhVwiLEVtcHR5VmVyeVNtYWxsU3F1YXJlOlwi4parXCIsZW1zcDpcIuKAg1wiLGVtc3AxMzpcIuKAhFwiLGVtc3AxNDpcIuKAhVwiLEVORzpcIsWKXCIsZW5nOlwixYtcIixlbnNwOlwi4oCCXCIsRW9nb246XCLEmFwiLGVvZ29uOlwixJlcIixFb3BmOlwi8J2UvFwiLGVvcGY6XCLwnZWWXCIsZXBhcjpcIuKLlVwiLGVwYXJzbDpcIuKno1wiLGVwbHVzOlwi4qmxXCIsZXBzaTpcIs61XCIsRXBzaWxvbjpcIs6VXCIsZXBzaWxvbjpcIs61XCIsZXBzaXY6XCLPtVwiLGVxY2lyYzpcIuKJllwiLGVxY29sb246XCLiiZVcIixlcXNpbTpcIuKJglwiLGVxc2xhbnRndHI6XCLiqpZcIixlcXNsYW50bGVzczpcIuKqlVwiLEVxdWFsOlwi4qm1XCIsZXF1YWxzOlwiPVwiLEVxdWFsVGlsZGU6XCLiiYJcIixlcXVlc3Q6XCLiiZ9cIixFcXVpbGlicml1bTpcIuKHjFwiLGVxdWl2Olwi4omhXCIsZXF1aXZERDpcIuKpuFwiLGVxdnBhcnNsOlwi4qelXCIsZXJhcnI6XCLipbFcIixlckRvdDpcIuKJk1wiLEVzY3I6XCLihLBcIixlc2NyOlwi4oSvXCIsZXNkb3Q6XCLiiZBcIixFc2ltOlwi4qmzXCIsZXNpbTpcIuKJglwiLEV0YTpcIs6XXCIsZXRhOlwizrdcIixFVEg6XCLDkFwiLGV0aDpcIsOwXCIsRXVtbDpcIsOLXCIsZXVtbDpcIsOrXCIsZXVybzpcIuKCrFwiLGV4Y2w6XCIhXCIsZXhpc3Q6XCLiiINcIixFeGlzdHM6XCLiiINcIixleHBlY3RhdGlvbjpcIuKEsFwiLEV4cG9uZW50aWFsRTpcIuKFh1wiLGV4cG9uZW50aWFsZTpcIuKFh1wiLGZhbGxpbmdkb3RzZXE6XCLiiZJcIixGY3k6XCLQpFwiLGZjeTpcItGEXCIsZmVtYWxlOlwi4pmAXCIsZmZpbGlnOlwi76yDXCIsZmZsaWc6XCLvrIBcIixmZmxsaWc6XCLvrIRcIixGZnI6XCLwnZSJXCIsZmZyOlwi8J2Uo1wiLGZpbGlnOlwi76yBXCIsRmlsbGVkU21hbGxTcXVhcmU6XCLil7xcIixGaWxsZWRWZXJ5U21hbGxTcXVhcmU6XCLilqpcIixmamxpZzpcImZqXCIsZmxhdDpcIuKZrVwiLGZsbGlnOlwi76yCXCIsZmx0bnM6XCLilrFcIixmbm9mOlwixpJcIixGb3BmOlwi8J2UvVwiLGZvcGY6XCLwnZWXXCIsRm9yQWxsOlwi4oiAXCIsZm9yYWxsOlwi4oiAXCIsZm9yazpcIuKLlFwiLGZvcmt2Olwi4quZXCIsRm91cmllcnRyZjpcIuKEsVwiLGZwYXJ0aW50Olwi4qiNXCIsZnJhYzEyOlwiwr1cIixmcmFjMTM6XCLihZNcIixmcmFjMTQ6XCLCvFwiLGZyYWMxNTpcIuKFlVwiLGZyYWMxNjpcIuKFmVwiLGZyYWMxODpcIuKFm1wiLGZyYWMyMzpcIuKFlFwiLGZyYWMyNTpcIuKFllwiLGZyYWMzNDpcIsK+XCIsZnJhYzM1Olwi4oWXXCIsZnJhYzM4Olwi4oWcXCIsZnJhYzQ1Olwi4oWYXCIsZnJhYzU2Olwi4oWaXCIsZnJhYzU4Olwi4oWdXCIsZnJhYzc4Olwi4oWeXCIsZnJhc2w6XCLigYRcIixmcm93bjpcIuKMolwiLEZzY3I6XCLihLFcIixmc2NyOlwi8J2Su1wiLGdhY3V0ZTpcIse1XCIsR2FtbWE6XCLOk1wiLGdhbW1hOlwizrNcIixHYW1tYWQ6XCLPnFwiLGdhbW1hZDpcIs+dXCIsZ2FwOlwi4qqGXCIsR2JyZXZlOlwixJ5cIixnYnJldmU6XCLEn1wiLEdjZWRpbDpcIsSiXCIsR2NpcmM6XCLEnFwiLGdjaXJjOlwixJ1cIixHY3k6XCLQk1wiLGdjeTpcItCzXCIsR2RvdDpcIsSgXCIsZ2RvdDpcIsShXCIsZ0U6XCLiiadcIixnZTpcIuKJpVwiLGdFbDpcIuKqjFwiLGdlbDpcIuKLm1wiLGdlcTpcIuKJpVwiLGdlcXE6XCLiiadcIixnZXFzbGFudDpcIuKpvlwiLGdlczpcIuKpvlwiLGdlc2NjOlwi4qqpXCIsZ2VzZG90Olwi4qqAXCIsZ2VzZG90bzpcIuKqglwiLGdlc2RvdG9sOlwi4qqEXCIsZ2VzbDpcIuKLm++4gFwiLGdlc2xlczpcIuKqlFwiLEdmcjpcIvCdlIpcIixnZnI6XCLwnZSkXCIsR2c6XCLii5lcIixnZzpcIuKJq1wiLGdnZzpcIuKLmVwiLGdpbWVsOlwi4oS3XCIsR0pjeTpcItCDXCIsZ2pjeTpcItGTXCIsZ2w6XCLiibdcIixnbGE6XCLiqqVcIixnbEU6XCLiqpJcIixnbGo6XCLiqqRcIixnbmFwOlwi4qqKXCIsZ25hcHByb3g6XCLiqopcIixnbkU6XCLiialcIixnbmU6XCLiqohcIixnbmVxOlwi4qqIXCIsZ25lcXE6XCLiialcIixnbnNpbTpcIuKLp1wiLEdvcGY6XCLwnZS+XCIsZ29wZjpcIvCdlZhcIixncmF2ZTpcImBcIixHcmVhdGVyRXF1YWw6XCLiiaVcIixHcmVhdGVyRXF1YWxMZXNzOlwi4oubXCIsR3JlYXRlckZ1bGxFcXVhbDpcIuKJp1wiLEdyZWF0ZXJHcmVhdGVyOlwi4qqiXCIsR3JlYXRlckxlc3M6XCLiibdcIixHcmVhdGVyU2xhbnRFcXVhbDpcIuKpvlwiLEdyZWF0ZXJUaWxkZTpcIuKJs1wiLEdzY3I6XCLwnZKiXCIsZ3NjcjpcIuKEilwiLGdzaW06XCLiibNcIixnc2ltZTpcIuKqjlwiLGdzaW1sOlwi4qqQXCIsR3Q6XCLiiatcIixHVDpcIj5cIixndDpcIj5cIixndGNjOlwi4qqnXCIsZ3RjaXI6XCLiqbpcIixndGRvdDpcIuKLl1wiLGd0bFBhcjpcIuKmlVwiLGd0cXVlc3Q6XCLiqbxcIixndHJhcHByb3g6XCLiqoZcIixndHJhcnI6XCLipbhcIixndHJkb3Q6XCLii5dcIixndHJlcWxlc3M6XCLii5tcIixndHJlcXFsZXNzOlwi4qqMXCIsZ3RybGVzczpcIuKJt1wiLGd0cnNpbTpcIuKJs1wiLGd2ZXJ0bmVxcTpcIuKJqe+4gFwiLGd2bkU6XCLiianvuIBcIixIYWNlazpcIsuHXCIsaGFpcnNwOlwi4oCKXCIsaGFsZjpcIsK9XCIsaGFtaWx0Olwi4oSLXCIsSEFSRGN5Olwi0KpcIixoYXJkY3k6XCLRilwiLGhBcnI6XCLih5RcIixoYXJyOlwi4oaUXCIsaGFycmNpcjpcIuKliFwiLGhhcnJ3Olwi4oatXCIsSGF0OlwiXlwiLGhiYXI6XCLihI9cIixIY2lyYzpcIsSkXCIsaGNpcmM6XCLEpVwiLGhlYXJ0czpcIuKZpVwiLGhlYXJ0c3VpdDpcIuKZpVwiLGhlbGxpcDpcIuKAplwiLGhlcmNvbjpcIuKKuVwiLEhmcjpcIuKEjFwiLGhmcjpcIvCdlKVcIixIaWxiZXJ0U3BhY2U6XCLihItcIixoa3NlYXJvdzpcIuKkpVwiLGhrc3dhcm93Olwi4qSmXCIsaG9hcnI6XCLih79cIixob210aHQ6XCLiiLtcIixob29rbGVmdGFycm93Olwi4oapXCIsaG9va3JpZ2h0YXJyb3c6XCLihqpcIixIb3BmOlwi4oSNXCIsaG9wZjpcIvCdlZlcIixob3JiYXI6XCLigJVcIixIb3Jpem9udGFsTGluZTpcIuKUgFwiLEhzY3I6XCLihItcIixoc2NyOlwi8J2SvVwiLGhzbGFzaDpcIuKEj1wiLEhzdHJvazpcIsSmXCIsaHN0cm9rOlwixKdcIixIdW1wRG93bkh1bXA6XCLiiY5cIixIdW1wRXF1YWw6XCLiiY9cIixoeWJ1bGw6XCLigYNcIixoeXBoZW46XCLigJBcIixJYWN1dGU6XCLDjVwiLGlhY3V0ZTpcIsOtXCIsaWM6XCLigaNcIixJY2lyYzpcIsOOXCIsaWNpcmM6XCLDrlwiLEljeTpcItCYXCIsaWN5Olwi0LhcIixJZG90OlwixLBcIixJRWN5Olwi0JVcIixpZWN5Olwi0LVcIixpZXhjbDpcIsKhXCIsaWZmOlwi4oeUXCIsSWZyOlwi4oSRXCIsaWZyOlwi8J2UplwiLElncmF2ZTpcIsOMXCIsaWdyYXZlOlwiw6xcIixpaTpcIuKFiFwiLGlpaWludDpcIuKojFwiLGlpaW50Olwi4oitXCIsaWluZmluOlwi4qecXCIsaWlvdGE6XCLihKlcIixJSmxpZzpcIsSyXCIsaWpsaWc6XCLEs1wiLEltOlwi4oSRXCIsSW1hY3I6XCLEqlwiLGltYWNyOlwixKtcIixpbWFnZTpcIuKEkVwiLEltYWdpbmFyeUk6XCLihYhcIixpbWFnbGluZTpcIuKEkFwiLGltYWdwYXJ0Olwi4oSRXCIsaW1hdGg6XCLEsVwiLGltb2Y6XCLiirdcIixpbXBlZDpcIsa1XCIsSW1wbGllczpcIuKHklwiLGluOlwi4oiIXCIsaW5jYXJlOlwi4oSFXCIsaW5maW46XCLiiJ5cIixpbmZpbnRpZTpcIuKnnVwiLGlub2RvdDpcIsSxXCIsSW50Olwi4oisXCIsaW50Olwi4oirXCIsaW50Y2FsOlwi4oq6XCIsaW50ZWdlcnM6XCLihKRcIixJbnRlZ3JhbDpcIuKIq1wiLGludGVyY2FsOlwi4oq6XCIsSW50ZXJzZWN0aW9uOlwi4ouCXCIsaW50bGFyaGs6XCLiqJdcIixpbnRwcm9kOlwi4qi8XCIsSW52aXNpYmxlQ29tbWE6XCLigaNcIixJbnZpc2libGVUaW1lczpcIuKBolwiLElPY3k6XCLQgVwiLGlvY3k6XCLRkVwiLElvZ29uOlwixK5cIixpb2dvbjpcIsSvXCIsSW9wZjpcIvCdlYBcIixpb3BmOlwi8J2VmlwiLElvdGE6XCLOmVwiLGlvdGE6XCLOuVwiLGlwcm9kOlwi4qi8XCIsaXF1ZXN0Olwiwr9cIixJc2NyOlwi4oSQXCIsaXNjcjpcIvCdkr5cIixpc2luOlwi4oiIXCIsaXNpbmRvdDpcIuKLtVwiLGlzaW5FOlwi4ou5XCIsaXNpbnM6XCLii7RcIixpc2luc3Y6XCLii7NcIixpc2ludjpcIuKIiFwiLGl0Olwi4oGiXCIsSXRpbGRlOlwixKhcIixpdGlsZGU6XCLEqVwiLEl1a2N5Olwi0IZcIixpdWtjeTpcItGWXCIsSXVtbDpcIsOPXCIsaXVtbDpcIsOvXCIsSmNpcmM6XCLEtFwiLGpjaXJjOlwixLVcIixKY3k6XCLQmVwiLGpjeTpcItC5XCIsSmZyOlwi8J2UjVwiLGpmcjpcIvCdlKdcIixqbWF0aDpcIsi3XCIsSm9wZjpcIvCdlYFcIixqb3BmOlwi8J2Vm1wiLEpzY3I6XCLwnZKlXCIsanNjcjpcIvCdkr9cIixKc2VyY3k6XCLQiFwiLGpzZXJjeTpcItGYXCIsSnVrY3k6XCLQhFwiLGp1a2N5Olwi0ZRcIixLYXBwYTpcIs6aXCIsa2FwcGE6XCLOulwiLGthcHBhdjpcIs+wXCIsS2NlZGlsOlwixLZcIixrY2VkaWw6XCLEt1wiLEtjeTpcItCaXCIsa2N5Olwi0LpcIixLZnI6XCLwnZSOXCIsa2ZyOlwi8J2UqFwiLGtncmVlbjpcIsS4XCIsS0hjeTpcItClXCIsa2hjeTpcItGFXCIsS0pjeTpcItCMXCIsa2pjeTpcItGcXCIsS29wZjpcIvCdlYJcIixrb3BmOlwi8J2VnFwiLEtzY3I6XCLwnZKmXCIsa3NjcjpcIvCdk4BcIixsQWFycjpcIuKHmlwiLExhY3V0ZTpcIsS5XCIsbGFjdXRlOlwixLpcIixsYWVtcHR5djpcIuKmtFwiLGxhZ3JhbjpcIuKEklwiLExhbWJkYTpcIs6bXCIsbGFtYmRhOlwizrtcIixMYW5nOlwi4p+qXCIsbGFuZzpcIuKfqFwiLGxhbmdkOlwi4qaRXCIsbGFuZ2xlOlwi4p+oXCIsbGFwOlwi4qqFXCIsTGFwbGFjZXRyZjpcIuKEklwiLGxhcXVvOlwiwqtcIixMYXJyOlwi4oaeXCIsbEFycjpcIuKHkFwiLGxhcnI6XCLihpBcIixsYXJyYjpcIuKHpFwiLGxhcnJiZnM6XCLipJ9cIixsYXJyZnM6XCLipJ1cIixsYXJyaGs6XCLihqlcIixsYXJybHA6XCLihqtcIixsYXJycGw6XCLipLlcIixsYXJyc2ltOlwi4qWzXCIsbGFycnRsOlwi4oaiXCIsbGF0Olwi4qqrXCIsbEF0YWlsOlwi4qSbXCIsbGF0YWlsOlwi4qSZXCIsbGF0ZTpcIuKqrVwiLGxhdGVzOlwi4qqt77iAXCIsbEJhcnI6XCLipI5cIixsYmFycjpcIuKkjFwiLGxiYnJrOlwi4p2yXCIsbGJyYWNlOlwie1wiLGxicmFjazpcIltcIixsYnJrZTpcIuKmi1wiLGxicmtzbGQ6XCLipo9cIixsYnJrc2x1Olwi4qaNXCIsTGNhcm9uOlwixL1cIixsY2Fyb246XCLEvlwiLExjZWRpbDpcIsS7XCIsbGNlZGlsOlwixLxcIixsY2VpbDpcIuKMiFwiLGxjdWI6XCJ7XCIsTGN5Olwi0JtcIixsY3k6XCLQu1wiLGxkY2E6XCLipLZcIixsZHF1bzpcIuKAnFwiLGxkcXVvcjpcIuKAnlwiLGxkcmRoYXI6XCLipadcIixsZHJ1c2hhcjpcIuKli1wiLGxkc2g6XCLihrJcIixsRTpcIuKJplwiLGxlOlwi4omkXCIsTGVmdEFuZ2xlQnJhY2tldDpcIuKfqFwiLExlZnRBcnJvdzpcIuKGkFwiLExlZnRhcnJvdzpcIuKHkFwiLGxlZnRhcnJvdzpcIuKGkFwiLExlZnRBcnJvd0JhcjpcIuKHpFwiLExlZnRBcnJvd1JpZ2h0QXJyb3c6XCLih4ZcIixsZWZ0YXJyb3d0YWlsOlwi4oaiXCIsTGVmdENlaWxpbmc6XCLijIhcIixMZWZ0RG91YmxlQnJhY2tldDpcIuKfplwiLExlZnREb3duVGVlVmVjdG9yOlwi4qWhXCIsTGVmdERvd25WZWN0b3I6XCLih4NcIixMZWZ0RG93blZlY3RvckJhcjpcIuKlmVwiLExlZnRGbG9vcjpcIuKMilwiLGxlZnRoYXJwb29uZG93bjpcIuKGvVwiLGxlZnRoYXJwb29udXA6XCLihrxcIixsZWZ0bGVmdGFycm93czpcIuKHh1wiLExlZnRSaWdodEFycm93Olwi4oaUXCIsTGVmdHJpZ2h0YXJyb3c6XCLih5RcIixsZWZ0cmlnaHRhcnJvdzpcIuKGlFwiLGxlZnRyaWdodGFycm93czpcIuKHhlwiLGxlZnRyaWdodGhhcnBvb25zOlwi4oeLXCIsbGVmdHJpZ2h0c3F1aWdhcnJvdzpcIuKGrVwiLExlZnRSaWdodFZlY3RvcjpcIuKljlwiLExlZnRUZWU6XCLiiqNcIixMZWZ0VGVlQXJyb3c6XCLihqRcIixMZWZ0VGVlVmVjdG9yOlwi4qWaXCIsbGVmdHRocmVldGltZXM6XCLii4tcIixMZWZ0VHJpYW5nbGU6XCLiirJcIixMZWZ0VHJpYW5nbGVCYXI6XCLip49cIixMZWZ0VHJpYW5nbGVFcXVhbDpcIuKKtFwiLExlZnRVcERvd25WZWN0b3I6XCLipZFcIixMZWZ0VXBUZWVWZWN0b3I6XCLipaBcIixMZWZ0VXBWZWN0b3I6XCLihr9cIixMZWZ0VXBWZWN0b3JCYXI6XCLipZhcIixMZWZ0VmVjdG9yOlwi4oa8XCIsTGVmdFZlY3RvckJhcjpcIuKlklwiLGxFZzpcIuKqi1wiLGxlZzpcIuKLmlwiLGxlcTpcIuKJpFwiLGxlcXE6XCLiiaZcIixsZXFzbGFudDpcIuKpvVwiLGxlczpcIuKpvVwiLGxlc2NjOlwi4qqoXCIsbGVzZG90Olwi4qm/XCIsbGVzZG90bzpcIuKqgVwiLGxlc2RvdG9yOlwi4qqDXCIsbGVzZzpcIuKLmu+4gFwiLGxlc2dlczpcIuKqk1wiLGxlc3NhcHByb3g6XCLiqoVcIixsZXNzZG90Olwi4ouWXCIsbGVzc2VxZ3RyOlwi4ouaXCIsbGVzc2VxcWd0cjpcIuKqi1wiLExlc3NFcXVhbEdyZWF0ZXI6XCLii5pcIixMZXNzRnVsbEVxdWFsOlwi4ommXCIsTGVzc0dyZWF0ZXI6XCLiibZcIixsZXNzZ3RyOlwi4om2XCIsTGVzc0xlc3M6XCLiqqFcIixsZXNzc2ltOlwi4omyXCIsTGVzc1NsYW50RXF1YWw6XCLiqb1cIixMZXNzVGlsZGU6XCLiibJcIixsZmlzaHQ6XCLipbxcIixsZmxvb3I6XCLijIpcIixMZnI6XCLwnZSPXCIsbGZyOlwi8J2UqVwiLGxnOlwi4om2XCIsbGdFOlwi4qqRXCIsbEhhcjpcIuKlolwiLGxoYXJkOlwi4oa9XCIsbGhhcnU6XCLihrxcIixsaGFydWw6XCLipapcIixsaGJsazpcIuKWhFwiLExKY3k6XCLQiVwiLGxqY3k6XCLRmVwiLExsOlwi4ouYXCIsbGw6XCLiiapcIixsbGFycjpcIuKHh1wiLGxsY29ybmVyOlwi4oyeXCIsTGxlZnRhcnJvdzpcIuKHmlwiLGxsaGFyZDpcIuKlq1wiLGxsdHJpOlwi4pe6XCIsTG1pZG90OlwixL9cIixsbWlkb3Q6XCLFgFwiLGxtb3VzdDpcIuKOsFwiLGxtb3VzdGFjaGU6XCLijrBcIixsbmFwOlwi4qqJXCIsbG5hcHByb3g6XCLiqolcIixsbkU6XCLiiahcIixsbmU6XCLiqodcIixsbmVxOlwi4qqHXCIsbG5lcXE6XCLiiahcIixsbnNpbTpcIuKLplwiLGxvYW5nOlwi4p+sXCIsbG9hcnI6XCLih71cIixsb2JyazpcIuKfplwiLExvbmdMZWZ0QXJyb3c6XCLin7VcIixMb25nbGVmdGFycm93Olwi4p+4XCIsbG9uZ2xlZnRhcnJvdzpcIuKftVwiLExvbmdMZWZ0UmlnaHRBcnJvdzpcIuKft1wiLExvbmdsZWZ0cmlnaHRhcnJvdzpcIuKfulwiLGxvbmdsZWZ0cmlnaHRhcnJvdzpcIuKft1wiLGxvbmdtYXBzdG86XCLin7xcIixMb25nUmlnaHRBcnJvdzpcIuKftlwiLExvbmdyaWdodGFycm93Olwi4p+5XCIsbG9uZ3JpZ2h0YXJyb3c6XCLin7ZcIixsb29wYXJyb3dsZWZ0Olwi4oarXCIsbG9vcGFycm93cmlnaHQ6XCLihqxcIixsb3BhcjpcIuKmhVwiLExvcGY6XCLwnZWDXCIsbG9wZjpcIvCdlZ1cIixsb3BsdXM6XCLiqK1cIixsb3RpbWVzOlwi4qi0XCIsbG93YXN0Olwi4oiXXCIsbG93YmFyOlwiX1wiLExvd2VyTGVmdEFycm93Olwi4oaZXCIsTG93ZXJSaWdodEFycm93Olwi4oaYXCIsbG96Olwi4peKXCIsbG96ZW5nZTpcIuKXilwiLGxvemY6XCLip6tcIixscGFyOlwiKFwiLGxwYXJsdDpcIuKmk1wiLGxyYXJyOlwi4oeGXCIsbHJjb3JuZXI6XCLijJ9cIixscmhhcjpcIuKHi1wiLGxyaGFyZDpcIuKlrVwiLGxybTpcIuKAjlwiLGxydHJpOlwi4oq/XCIsbHNhcXVvOlwi4oC5XCIsTHNjcjpcIuKEklwiLGxzY3I6XCLwnZOBXCIsTHNoOlwi4oawXCIsbHNoOlwi4oawXCIsbHNpbTpcIuKJslwiLGxzaW1lOlwi4qqNXCIsbHNpbWc6XCLiqo9cIixsc3FiOlwiW1wiLGxzcXVvOlwi4oCYXCIsbHNxdW9yOlwi4oCaXCIsTHN0cm9rOlwixYFcIixsc3Ryb2s6XCLFglwiLEx0Olwi4omqXCIsTFQ6XCI8XCIsbHQ6XCI8XCIsbHRjYzpcIuKqplwiLGx0Y2lyOlwi4qm5XCIsbHRkb3Q6XCLii5ZcIixsdGhyZWU6XCLii4tcIixsdGltZXM6XCLii4lcIixsdGxhcnI6XCLipbZcIixsdHF1ZXN0Olwi4qm7XCIsbHRyaTpcIuKXg1wiLGx0cmllOlwi4oq0XCIsbHRyaWY6XCLil4JcIixsdHJQYXI6XCLippZcIixsdXJkc2hhcjpcIuKlilwiLGx1cnVoYXI6XCLipaZcIixsdmVydG5lcXE6XCLiiajvuIBcIixsdm5FOlwi4omo77iAXCIsbWFjcjpcIsKvXCIsbWFsZTpcIuKZglwiLG1hbHQ6XCLinKBcIixtYWx0ZXNlOlwi4pygXCIsTWFwOlwi4qSFXCIsbWFwOlwi4oamXCIsbWFwc3RvOlwi4oamXCIsbWFwc3RvZG93bjpcIuKGp1wiLG1hcHN0b2xlZnQ6XCLihqRcIixtYXBzdG91cDpcIuKGpVwiLG1hcmtlcjpcIuKWrlwiLG1jb21tYTpcIuKoqVwiLE1jeTpcItCcXCIsbWN5Olwi0LxcIixtZGFzaDpcIuKAlFwiLG1ERG90Olwi4oi6XCIsbWVhc3VyZWRhbmdsZTpcIuKIoVwiLE1lZGl1bVNwYWNlOlwi4oGfXCIsTWVsbGludHJmOlwi4oSzXCIsTWZyOlwi8J2UkFwiLG1mcjpcIvCdlKpcIixtaG86XCLihKdcIixtaWNybzpcIsK1XCIsbWlkOlwi4oijXCIsbWlkYXN0OlwiKlwiLG1pZGNpcjpcIuKrsFwiLG1pZGRvdDpcIsK3XCIsbWludXM6XCLiiJJcIixtaW51c2I6XCLiip9cIixtaW51c2Q6XCLiiLhcIixtaW51c2R1Olwi4qiqXCIsTWludXNQbHVzOlwi4oiTXCIsbWxjcDpcIuKrm1wiLG1sZHI6XCLigKZcIixtbnBsdXM6XCLiiJNcIixtb2RlbHM6XCLiiqdcIixNb3BmOlwi8J2VhFwiLG1vcGY6XCLwnZWeXCIsbXA6XCLiiJNcIixNc2NyOlwi4oSzXCIsbXNjcjpcIvCdk4JcIixtc3Rwb3M6XCLiiL5cIixNdTpcIs6cXCIsbXU6XCLOvFwiLG11bHRpbWFwOlwi4oq4XCIsbXVtYXA6XCLiirhcIixuYWJsYTpcIuKIh1wiLE5hY3V0ZTpcIsWDXCIsbmFjdXRlOlwixYRcIixuYW5nOlwi4oig4oOSXCIsbmFwOlwi4omJXCIsbmFwRTpcIuKpsMy4XCIsbmFwaWQ6XCLiiYvMuFwiLG5hcG9zOlwixYlcIixuYXBwcm94Olwi4omJXCIsbmF0dXI6XCLima5cIixuYXR1cmFsOlwi4pmuXCIsbmF0dXJhbHM6XCLihJVcIixuYnNwOlwiwqBcIixuYnVtcDpcIuKJjsy4XCIsbmJ1bXBlOlwi4omPzLhcIixuY2FwOlwi4qmDXCIsTmNhcm9uOlwixYdcIixuY2Fyb246XCLFiFwiLE5jZWRpbDpcIsWFXCIsbmNlZGlsOlwixYZcIixuY29uZzpcIuKJh1wiLG5jb25nZG90Olwi4qmtzLhcIixuY3VwOlwi4qmCXCIsTmN5Olwi0J1cIixuY3k6XCLQvVwiLG5kYXNoOlwi4oCTXCIsbmU6XCLiiaBcIixuZWFyaGs6XCLipKRcIixuZUFycjpcIuKHl1wiLG5lYXJyOlwi4oaXXCIsbmVhcnJvdzpcIuKGl1wiLG5lZG90Olwi4omQzLhcIixOZWdhdGl2ZU1lZGl1bVNwYWNlOlwi4oCLXCIsTmVnYXRpdmVUaGlja1NwYWNlOlwi4oCLXCIsTmVnYXRpdmVUaGluU3BhY2U6XCLigItcIixOZWdhdGl2ZVZlcnlUaGluU3BhY2U6XCLigItcIixuZXF1aXY6XCLiiaJcIixuZXNlYXI6XCLipKhcIixuZXNpbTpcIuKJgsy4XCIsTmVzdGVkR3JlYXRlckdyZWF0ZXI6XCLiiatcIixOZXN0ZWRMZXNzTGVzczpcIuKJqlwiLE5ld0xpbmU6XCJcXG5cIixuZXhpc3Q6XCLiiIRcIixuZXhpc3RzOlwi4oiEXCIsTmZyOlwi8J2UkVwiLG5mcjpcIvCdlKtcIixuZ0U6XCLiiafMuFwiLG5nZTpcIuKJsVwiLG5nZXE6XCLiibFcIixuZ2VxcTpcIuKJp8y4XCIsbmdlcXNsYW50Olwi4qm+zLhcIixuZ2VzOlwi4qm+zLhcIixuR2c6XCLii5nMuFwiLG5nc2ltOlwi4om1XCIsbkd0Olwi4omr4oOSXCIsbmd0Olwi4omvXCIsbmd0cjpcIuKJr1wiLG5HdHY6XCLiiavMuFwiLG5oQXJyOlwi4oeOXCIsbmhhcnI6XCLihq5cIixuaHBhcjpcIuKrslwiLG5pOlwi4oiLXCIsbmlzOlwi4ou8XCIsbmlzZDpcIuKLulwiLG5pdjpcIuKIi1wiLE5KY3k6XCLQilwiLG5qY3k6XCLRmlwiLG5sQXJyOlwi4oeNXCIsbmxhcnI6XCLihppcIixubGRyOlwi4oClXCIsbmxFOlwi4ommzLhcIixubGU6XCLiibBcIixuTGVmdGFycm93Olwi4oeNXCIsbmxlZnRhcnJvdzpcIuKGmlwiLG5MZWZ0cmlnaHRhcnJvdzpcIuKHjlwiLG5sZWZ0cmlnaHRhcnJvdzpcIuKGrlwiLG5sZXE6XCLiibBcIixubGVxcTpcIuKJpsy4XCIsbmxlcXNsYW50Olwi4qm9zLhcIixubGVzOlwi4qm9zLhcIixubGVzczpcIuKJrlwiLG5MbDpcIuKLmMy4XCIsbmxzaW06XCLiibRcIixuTHQ6XCLiiarig5JcIixubHQ6XCLiia5cIixubHRyaTpcIuKLqlwiLG5sdHJpZTpcIuKLrFwiLG5MdHY6XCLiiarMuFwiLG5taWQ6XCLiiKRcIixOb0JyZWFrOlwi4oGgXCIsTm9uQnJlYWtpbmdTcGFjZTpcIsKgXCIsTm9wZjpcIuKElVwiLG5vcGY6XCLwnZWfXCIsTm90Olwi4qusXCIsbm90OlwiwqxcIixOb3RDb25ncnVlbnQ6XCLiiaJcIixOb3RDdXBDYXA6XCLiia1cIixOb3REb3VibGVWZXJ0aWNhbEJhcjpcIuKIplwiLE5vdEVsZW1lbnQ6XCLiiIlcIixOb3RFcXVhbDpcIuKJoFwiLE5vdEVxdWFsVGlsZGU6XCLiiYLMuFwiLE5vdEV4aXN0czpcIuKIhFwiLE5vdEdyZWF0ZXI6XCLiia9cIixOb3RHcmVhdGVyRXF1YWw6XCLiibFcIixOb3RHcmVhdGVyRnVsbEVxdWFsOlwi4omnzLhcIixOb3RHcmVhdGVyR3JlYXRlcjpcIuKJq8y4XCIsTm90R3JlYXRlckxlc3M6XCLiiblcIixOb3RHcmVhdGVyU2xhbnRFcXVhbDpcIuKpvsy4XCIsTm90R3JlYXRlclRpbGRlOlwi4om1XCIsTm90SHVtcERvd25IdW1wOlwi4omOzLhcIixOb3RIdW1wRXF1YWw6XCLiiY/MuFwiLG5vdGluOlwi4oiJXCIsbm90aW5kb3Q6XCLii7XMuFwiLG5vdGluRTpcIuKLucy4XCIsbm90aW52YTpcIuKIiVwiLG5vdGludmI6XCLii7dcIixub3RpbnZjOlwi4ou2XCIsTm90TGVmdFRyaWFuZ2xlOlwi4ouqXCIsTm90TGVmdFRyaWFuZ2xlQmFyOlwi4qePzLhcIixOb3RMZWZ0VHJpYW5nbGVFcXVhbDpcIuKLrFwiLE5vdExlc3M6XCLiia5cIixOb3RMZXNzRXF1YWw6XCLiibBcIixOb3RMZXNzR3JlYXRlcjpcIuKJuFwiLE5vdExlc3NMZXNzOlwi4omqzLhcIixOb3RMZXNzU2xhbnRFcXVhbDpcIuKpvcy4XCIsTm90TGVzc1RpbGRlOlwi4om0XCIsTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI6XCLiqqLMuFwiLE5vdE5lc3RlZExlc3NMZXNzOlwi4qqhzLhcIixub3RuaTpcIuKIjFwiLG5vdG5pdmE6XCLiiIxcIixub3RuaXZiOlwi4ou+XCIsbm90bml2YzpcIuKLvVwiLE5vdFByZWNlZGVzOlwi4oqAXCIsTm90UHJlY2VkZXNFcXVhbDpcIuKqr8y4XCIsTm90UHJlY2VkZXNTbGFudEVxdWFsOlwi4ougXCIsTm90UmV2ZXJzZUVsZW1lbnQ6XCLiiIxcIixOb3RSaWdodFRyaWFuZ2xlOlwi4ourXCIsTm90UmlnaHRUcmlhbmdsZUJhcjpcIuKnkMy4XCIsTm90UmlnaHRUcmlhbmdsZUVxdWFsOlwi4outXCIsTm90U3F1YXJlU3Vic2V0Olwi4oqPzLhcIixOb3RTcXVhcmVTdWJzZXRFcXVhbDpcIuKLolwiLE5vdFNxdWFyZVN1cGVyc2V0Olwi4oqQzLhcIixOb3RTcXVhcmVTdXBlcnNldEVxdWFsOlwi4oujXCIsTm90U3Vic2V0Olwi4oqC4oOSXCIsTm90U3Vic2V0RXF1YWw6XCLiiohcIixOb3RTdWNjZWVkczpcIuKKgVwiLE5vdFN1Y2NlZWRzRXF1YWw6XCLiqrDMuFwiLE5vdFN1Y2NlZWRzU2xhbnRFcXVhbDpcIuKLoVwiLE5vdFN1Y2NlZWRzVGlsZGU6XCLiib/MuFwiLE5vdFN1cGVyc2V0Olwi4oqD4oOSXCIsTm90U3VwZXJzZXRFcXVhbDpcIuKKiVwiLE5vdFRpbGRlOlwi4omBXCIsTm90VGlsZGVFcXVhbDpcIuKJhFwiLE5vdFRpbGRlRnVsbEVxdWFsOlwi4omHXCIsTm90VGlsZGVUaWxkZTpcIuKJiVwiLE5vdFZlcnRpY2FsQmFyOlwi4oikXCIsbnBhcjpcIuKIplwiLG5wYXJhbGxlbDpcIuKIplwiLG5wYXJzbDpcIuKrveKDpVwiLG5wYXJ0Olwi4oiCzLhcIixucG9saW50Olwi4qiUXCIsbnByOlwi4oqAXCIsbnByY3VlOlwi4ougXCIsbnByZTpcIuKqr8y4XCIsbnByZWM6XCLiioBcIixucHJlY2VxOlwi4qqvzLhcIixuckFycjpcIuKHj1wiLG5yYXJyOlwi4oabXCIsbnJhcnJjOlwi4qSzzLhcIixucmFycnc6XCLihp3MuFwiLG5SaWdodGFycm93Olwi4oePXCIsbnJpZ2h0YXJyb3c6XCLihptcIixucnRyaTpcIuKLq1wiLG5ydHJpZTpcIuKLrVwiLG5zYzpcIuKKgVwiLG5zY2N1ZTpcIuKLoVwiLG5zY2U6XCLiqrDMuFwiLE5zY3I6XCLwnZKpXCIsbnNjcjpcIvCdk4NcIixuc2hvcnRtaWQ6XCLiiKRcIixuc2hvcnRwYXJhbGxlbDpcIuKIplwiLG5zaW06XCLiiYFcIixuc2ltZTpcIuKJhFwiLG5zaW1lcTpcIuKJhFwiLG5zbWlkOlwi4oikXCIsbnNwYXI6XCLiiKZcIixuc3FzdWJlOlwi4ouiXCIsbnNxc3VwZTpcIuKLo1wiLG5zdWI6XCLiioRcIixuc3ViRTpcIuKrhcy4XCIsbnN1YmU6XCLiiohcIixuc3Vic2V0Olwi4oqC4oOSXCIsbnN1YnNldGVxOlwi4oqIXCIsbnN1YnNldGVxcTpcIuKrhcy4XCIsbnN1Y2M6XCLiioFcIixuc3VjY2VxOlwi4qqwzLhcIixuc3VwOlwi4oqFXCIsbnN1cEU6XCLiq4bMuFwiLG5zdXBlOlwi4oqJXCIsbnN1cHNldDpcIuKKg+KDklwiLG5zdXBzZXRlcTpcIuKKiVwiLG5zdXBzZXRlcXE6XCLiq4bMuFwiLG50Z2w6XCLiiblcIixOdGlsZGU6XCLDkVwiLG50aWxkZTpcIsOxXCIsbnRsZzpcIuKJuFwiLG50cmlhbmdsZWxlZnQ6XCLii6pcIixudHJpYW5nbGVsZWZ0ZXE6XCLii6xcIixudHJpYW5nbGVyaWdodDpcIuKLq1wiLG50cmlhbmdsZXJpZ2h0ZXE6XCLii61cIixOdTpcIs6dXCIsbnU6XCLOvVwiLG51bTpcIiNcIixudW1lcm86XCLihJZcIixudW1zcDpcIuKAh1wiLG52YXA6XCLiiY3ig5JcIixuVkRhc2g6XCLiiq9cIixuVmRhc2g6XCLiiq5cIixudkRhc2g6XCLiiq1cIixudmRhc2g6XCLiiqxcIixudmdlOlwi4oml4oOSXCIsbnZndDpcIj7ig5JcIixudkhhcnI6XCLipIRcIixudmluZmluOlwi4qeeXCIsbnZsQXJyOlwi4qSCXCIsbnZsZTpcIuKJpOKDklwiLG52bHQ6XCI84oOSXCIsbnZsdHJpZTpcIuKKtOKDklwiLG52ckFycjpcIuKkg1wiLG52cnRyaWU6XCLiirXig5JcIixudnNpbTpcIuKIvOKDklwiLG53YXJoazpcIuKko1wiLG53QXJyOlwi4oeWXCIsbndhcnI6XCLihpZcIixud2Fycm93Olwi4oaWXCIsbnduZWFyOlwi4qSnXCIsT2FjdXRlOlwiw5NcIixvYWN1dGU6XCLDs1wiLG9hc3Q6XCLiiptcIixvY2lyOlwi4oqaXCIsT2NpcmM6XCLDlFwiLG9jaXJjOlwiw7RcIixPY3k6XCLQnlwiLG9jeTpcItC+XCIsb2Rhc2g6XCLiip1cIixPZGJsYWM6XCLFkFwiLG9kYmxhYzpcIsWRXCIsb2RpdjpcIuKouFwiLG9kb3Q6XCLiiplcIixvZHNvbGQ6XCLiprxcIixPRWxpZzpcIsWSXCIsb2VsaWc6XCLFk1wiLG9mY2lyOlwi4qa/XCIsT2ZyOlwi8J2UklwiLG9mcjpcIvCdlKxcIixvZ29uOlwiy5tcIixPZ3JhdmU6XCLDklwiLG9ncmF2ZTpcIsOyXCIsb2d0Olwi4qeBXCIsb2hiYXI6XCLiprVcIixvaG06XCLOqVwiLG9pbnQ6XCLiiK5cIixvbGFycjpcIuKGulwiLG9sY2lyOlwi4qa+XCIsb2xjcm9zczpcIuKmu1wiLG9saW5lOlwi4oC+XCIsb2x0Olwi4qeAXCIsT21hY3I6XCLFjFwiLG9tYWNyOlwixY1cIixPbWVnYTpcIs6pXCIsb21lZ2E6XCLPiVwiLE9taWNyb246XCLOn1wiLG9taWNyb246XCLOv1wiLG9taWQ6XCLiprZcIixvbWludXM6XCLiipZcIixPb3BmOlwi8J2VhlwiLG9vcGY6XCLwnZWgXCIsb3BhcjpcIuKmt1wiLE9wZW5DdXJseURvdWJsZVF1b3RlOlwi4oCcXCIsT3BlbkN1cmx5UXVvdGU6XCLigJhcIixvcGVycDpcIuKmuVwiLG9wbHVzOlwi4oqVXCIsT3I6XCLiqZRcIixvcjpcIuKIqFwiLG9yYXJyOlwi4oa7XCIsb3JkOlwi4qmdXCIsb3JkZXI6XCLihLRcIixvcmRlcm9mOlwi4oS0XCIsb3JkZjpcIsKqXCIsb3JkbTpcIsK6XCIsb3JpZ29mOlwi4oq2XCIsb3JvcjpcIuKpllwiLG9yc2xvcGU6XCLiqZdcIixvcnY6XCLiqZtcIixvUzpcIuKTiFwiLE9zY3I6XCLwnZKqXCIsb3NjcjpcIuKEtFwiLE9zbGFzaDpcIsOYXCIsb3NsYXNoOlwiw7hcIixvc29sOlwi4oqYXCIsT3RpbGRlOlwiw5VcIixvdGlsZGU6XCLDtVwiLE90aW1lczpcIuKot1wiLG90aW1lczpcIuKKl1wiLG90aW1lc2FzOlwi4qi2XCIsT3VtbDpcIsOWXCIsb3VtbDpcIsO2XCIsb3ZiYXI6XCLijL1cIixPdmVyQmFyOlwi4oC+XCIsT3ZlckJyYWNlOlwi4o+eXCIsT3ZlckJyYWNrZXQ6XCLijrRcIixPdmVyUGFyZW50aGVzaXM6XCLij5xcIixwYXI6XCLiiKVcIixwYXJhOlwiwrZcIixwYXJhbGxlbDpcIuKIpVwiLHBhcnNpbTpcIuKrs1wiLHBhcnNsOlwi4qu9XCIscGFydDpcIuKIglwiLFBhcnRpYWxEOlwi4oiCXCIsUGN5Olwi0J9cIixwY3k6XCLQv1wiLHBlcmNudDpcIiVcIixwZXJpb2Q6XCIuXCIscGVybWlsOlwi4oCwXCIscGVycDpcIuKKpVwiLHBlcnRlbms6XCLigLFcIixQZnI6XCLwnZSTXCIscGZyOlwi8J2UrVwiLFBoaTpcIs6mXCIscGhpOlwiz4ZcIixwaGl2Olwiz5VcIixwaG1tYXQ6XCLihLNcIixwaG9uZTpcIuKYjlwiLFBpOlwizqBcIixwaTpcIs+AXCIscGl0Y2hmb3JrOlwi4ouUXCIscGl2Olwiz5ZcIixwbGFuY2s6XCLihI9cIixwbGFuY2toOlwi4oSOXCIscGxhbmt2Olwi4oSPXCIscGx1czpcIitcIixwbHVzYWNpcjpcIuKoo1wiLHBsdXNiOlwi4oqeXCIscGx1c2NpcjpcIuKoolwiLHBsdXNkbzpcIuKIlFwiLHBsdXNkdTpcIuKopVwiLHBsdXNlOlwi4qmyXCIsUGx1c01pbnVzOlwiwrFcIixwbHVzbW46XCLCsVwiLHBsdXNzaW06XCLiqKZcIixwbHVzdHdvOlwi4qinXCIscG06XCLCsVwiLFBvaW5jYXJlcGxhbmU6XCLihIxcIixwb2ludGludDpcIuKolVwiLFBvcGY6XCLihJlcIixwb3BmOlwi8J2VoVwiLHBvdW5kOlwiwqNcIixQcjpcIuKqu1wiLHByOlwi4om6XCIscHJhcDpcIuKqt1wiLHByY3VlOlwi4om8XCIscHJFOlwi4qqzXCIscHJlOlwi4qqvXCIscHJlYzpcIuKJulwiLHByZWNhcHByb3g6XCLiqrdcIixwcmVjY3VybHllcTpcIuKJvFwiLFByZWNlZGVzOlwi4om6XCIsUHJlY2VkZXNFcXVhbDpcIuKqr1wiLFByZWNlZGVzU2xhbnRFcXVhbDpcIuKJvFwiLFByZWNlZGVzVGlsZGU6XCLiib5cIixwcmVjZXE6XCLiqq9cIixwcmVjbmFwcHJveDpcIuKquVwiLHByZWNuZXFxOlwi4qq1XCIscHJlY25zaW06XCLii6hcIixwcmVjc2ltOlwi4om+XCIsUHJpbWU6XCLigLNcIixwcmltZTpcIuKAslwiLHByaW1lczpcIuKEmVwiLHBybmFwOlwi4qq5XCIscHJuRTpcIuKqtVwiLHBybnNpbTpcIuKLqFwiLHByb2Q6XCLiiI9cIixQcm9kdWN0Olwi4oiPXCIscHJvZmFsYXI6XCLijK5cIixwcm9mbGluZTpcIuKMklwiLHByb2ZzdXJmOlwi4oyTXCIscHJvcDpcIuKInVwiLFByb3BvcnRpb246XCLiiLdcIixQcm9wb3J0aW9uYWw6XCLiiJ1cIixwcm9wdG86XCLiiJ1cIixwcnNpbTpcIuKJvlwiLHBydXJlbDpcIuKKsFwiLFBzY3I6XCLwnZKrXCIscHNjcjpcIvCdk4VcIixQc2k6XCLOqFwiLHBzaTpcIs+IXCIscHVuY3NwOlwi4oCIXCIsUWZyOlwi8J2UlFwiLHFmcjpcIvCdlK5cIixxaW50Olwi4qiMXCIsUW9wZjpcIuKEmlwiLHFvcGY6XCLwnZWiXCIscXByaW1lOlwi4oGXXCIsUXNjcjpcIvCdkqxcIixxc2NyOlwi8J2ThlwiLHF1YXRlcm5pb25zOlwi4oSNXCIscXVhdGludDpcIuKollwiLHF1ZXN0OlwiP1wiLHF1ZXN0ZXE6XCLiiZ9cIixRVU9UOidcIicscXVvdDonXCInLHJBYXJyOlwi4oebXCIscmFjZTpcIuKIvcyxXCIsUmFjdXRlOlwixZRcIixyYWN1dGU6XCLFlVwiLHJhZGljOlwi4oiaXCIscmFlbXB0eXY6XCLiprNcIixSYW5nOlwi4p+rXCIscmFuZzpcIuKfqVwiLHJhbmdkOlwi4qaSXCIscmFuZ2U6XCLipqVcIixyYW5nbGU6XCLin6lcIixyYXF1bzpcIsK7XCIsUmFycjpcIuKGoFwiLHJBcnI6XCLih5JcIixyYXJyOlwi4oaSXCIscmFycmFwOlwi4qW1XCIscmFycmI6XCLih6VcIixyYXJyYmZzOlwi4qSgXCIscmFycmM6XCLipLNcIixyYXJyZnM6XCLipJ5cIixyYXJyaGs6XCLihqpcIixyYXJybHA6XCLihqxcIixyYXJycGw6XCLipYVcIixyYXJyc2ltOlwi4qW0XCIsUmFycnRsOlwi4qSWXCIscmFycnRsOlwi4oajXCIscmFycnc6XCLihp1cIixyQXRhaWw6XCLipJxcIixyYXRhaWw6XCLipJpcIixyYXRpbzpcIuKItlwiLHJhdGlvbmFsczpcIuKEmlwiLFJCYXJyOlwi4qSQXCIsckJhcnI6XCLipI9cIixyYmFycjpcIuKkjVwiLHJiYnJrOlwi4p2zXCIscmJyYWNlOlwifVwiLHJicmFjazpcIl1cIixyYnJrZTpcIuKmjFwiLHJicmtzbGQ6XCLipo5cIixyYnJrc2x1Olwi4qaQXCIsUmNhcm9uOlwixZhcIixyY2Fyb246XCLFmVwiLFJjZWRpbDpcIsWWXCIscmNlZGlsOlwixZdcIixyY2VpbDpcIuKMiVwiLHJjdWI6XCJ9XCIsUmN5Olwi0KBcIixyY3k6XCLRgFwiLHJkY2E6XCLipLdcIixyZGxkaGFyOlwi4qWpXCIscmRxdW86XCLigJ1cIixyZHF1b3I6XCLigJ1cIixyZHNoOlwi4oazXCIsUmU6XCLihJxcIixyZWFsOlwi4oScXCIscmVhbGluZTpcIuKEm1wiLHJlYWxwYXJ0Olwi4oScXCIscmVhbHM6XCLihJ1cIixyZWN0Olwi4patXCIsUkVHOlwiwq5cIixyZWc6XCLCrlwiLFJldmVyc2VFbGVtZW50Olwi4oiLXCIsUmV2ZXJzZUVxdWlsaWJyaXVtOlwi4oeLXCIsUmV2ZXJzZVVwRXF1aWxpYnJpdW06XCLipa9cIixyZmlzaHQ6XCLipb1cIixyZmxvb3I6XCLijItcIixSZnI6XCLihJxcIixyZnI6XCLwnZSvXCIsckhhcjpcIuKlpFwiLHJoYXJkOlwi4oeBXCIscmhhcnU6XCLih4BcIixyaGFydWw6XCLipaxcIixSaG86XCLOoVwiLHJobzpcIs+BXCIscmhvdjpcIs+xXCIsUmlnaHRBbmdsZUJyYWNrZXQ6XCLin6lcIixSaWdodEFycm93Olwi4oaSXCIsUmlnaHRhcnJvdzpcIuKHklwiLHJpZ2h0YXJyb3c6XCLihpJcIixSaWdodEFycm93QmFyOlwi4oelXCIsUmlnaHRBcnJvd0xlZnRBcnJvdzpcIuKHhFwiLHJpZ2h0YXJyb3d0YWlsOlwi4oajXCIsUmlnaHRDZWlsaW5nOlwi4oyJXCIsUmlnaHREb3VibGVCcmFja2V0Olwi4p+nXCIsUmlnaHREb3duVGVlVmVjdG9yOlwi4qWdXCIsUmlnaHREb3duVmVjdG9yOlwi4oeCXCIsUmlnaHREb3duVmVjdG9yQmFyOlwi4qWVXCIsUmlnaHRGbG9vcjpcIuKMi1wiLHJpZ2h0aGFycG9vbmRvd246XCLih4FcIixyaWdodGhhcnBvb251cDpcIuKHgFwiLHJpZ2h0bGVmdGFycm93czpcIuKHhFwiLHJpZ2h0bGVmdGhhcnBvb25zOlwi4oeMXCIscmlnaHRyaWdodGFycm93czpcIuKHiVwiLHJpZ2h0c3F1aWdhcnJvdzpcIuKGnVwiLFJpZ2h0VGVlOlwi4oqiXCIsUmlnaHRUZWVBcnJvdzpcIuKGplwiLFJpZ2h0VGVlVmVjdG9yOlwi4qWbXCIscmlnaHR0aHJlZXRpbWVzOlwi4ouMXCIsUmlnaHRUcmlhbmdsZTpcIuKKs1wiLFJpZ2h0VHJpYW5nbGVCYXI6XCLip5BcIixSaWdodFRyaWFuZ2xlRXF1YWw6XCLiirVcIixSaWdodFVwRG93blZlY3RvcjpcIuKlj1wiLFJpZ2h0VXBUZWVWZWN0b3I6XCLipZxcIixSaWdodFVwVmVjdG9yOlwi4oa+XCIsUmlnaHRVcFZlY3RvckJhcjpcIuKllFwiLFJpZ2h0VmVjdG9yOlwi4oeAXCIsUmlnaHRWZWN0b3JCYXI6XCLipZNcIixyaW5nOlwiy5pcIixyaXNpbmdkb3RzZXE6XCLiiZNcIixybGFycjpcIuKHhFwiLHJsaGFyOlwi4oeMXCIscmxtOlwi4oCPXCIscm1vdXN0Olwi4o6xXCIscm1vdXN0YWNoZTpcIuKOsVwiLHJubWlkOlwi4quuXCIscm9hbmc6XCLin61cIixyb2FycjpcIuKHvlwiLHJvYnJrOlwi4p+nXCIscm9wYXI6XCLipoZcIixSb3BmOlwi4oSdXCIscm9wZjpcIvCdlaNcIixyb3BsdXM6XCLiqK5cIixyb3RpbWVzOlwi4qi1XCIsUm91bmRJbXBsaWVzOlwi4qWwXCIscnBhcjpcIilcIixycGFyZ3Q6XCLippRcIixycHBvbGludDpcIuKoklwiLHJyYXJyOlwi4oeJXCIsUnJpZ2h0YXJyb3c6XCLih5tcIixyc2FxdW86XCLigLpcIixSc2NyOlwi4oSbXCIscnNjcjpcIvCdk4dcIixSc2g6XCLihrFcIixyc2g6XCLihrFcIixyc3FiOlwiXVwiLHJzcXVvOlwi4oCZXCIscnNxdW9yOlwi4oCZXCIscnRocmVlOlwi4ouMXCIscnRpbWVzOlwi4ouKXCIscnRyaTpcIuKWuVwiLHJ0cmllOlwi4oq1XCIscnRyaWY6XCLilrhcIixydHJpbHRyaTpcIuKnjlwiLFJ1bGVEZWxheWVkOlwi4qe0XCIscnVsdWhhcjpcIuKlqFwiLHJ4Olwi4oSeXCIsU2FjdXRlOlwixZpcIixzYWN1dGU6XCLFm1wiLHNicXVvOlwi4oCaXCIsU2M6XCLiqrxcIixzYzpcIuKJu1wiLHNjYXA6XCLiqrhcIixTY2Fyb246XCLFoFwiLHNjYXJvbjpcIsWhXCIsc2NjdWU6XCLiib1cIixzY0U6XCLiqrRcIixzY2U6XCLiqrBcIixTY2VkaWw6XCLFnlwiLHNjZWRpbDpcIsWfXCIsU2NpcmM6XCLFnFwiLHNjaXJjOlwixZ1cIixzY25hcDpcIuKqulwiLHNjbkU6XCLiqrZcIixzY25zaW06XCLii6lcIixzY3BvbGludDpcIuKok1wiLHNjc2ltOlwi4om/XCIsU2N5Olwi0KFcIixzY3k6XCLRgVwiLHNkb3Q6XCLii4VcIixzZG90YjpcIuKKoVwiLHNkb3RlOlwi4qmmXCIsc2VhcmhrOlwi4qSlXCIsc2VBcnI6XCLih5hcIixzZWFycjpcIuKGmFwiLHNlYXJyb3c6XCLihphcIixzZWN0OlwiwqdcIixzZW1pOlwiO1wiLHNlc3dhcjpcIuKkqVwiLHNldG1pbnVzOlwi4oiWXCIsc2V0bW46XCLiiJZcIixzZXh0Olwi4py2XCIsU2ZyOlwi8J2UllwiLHNmcjpcIvCdlLBcIixzZnJvd246XCLijKJcIixzaGFycDpcIuKZr1wiLFNIQ0hjeTpcItCpXCIsc2hjaGN5Olwi0YlcIixTSGN5Olwi0KhcIixzaGN5Olwi0YhcIixTaG9ydERvd25BcnJvdzpcIuKGk1wiLFNob3J0TGVmdEFycm93Olwi4oaQXCIsc2hvcnRtaWQ6XCLiiKNcIixzaG9ydHBhcmFsbGVsOlwi4oilXCIsU2hvcnRSaWdodEFycm93Olwi4oaSXCIsU2hvcnRVcEFycm93Olwi4oaRXCIsc2h5Olwiwq1cIixTaWdtYTpcIs6jXCIsc2lnbWE6XCLPg1wiLHNpZ21hZjpcIs+CXCIsc2lnbWF2Olwiz4JcIixzaW06XCLiiLxcIixzaW1kb3Q6XCLiqapcIixzaW1lOlwi4omDXCIsc2ltZXE6XCLiiYNcIixzaW1nOlwi4qqeXCIsc2ltZ0U6XCLiqqBcIixzaW1sOlwi4qqdXCIsc2ltbEU6XCLiqp9cIixzaW1uZTpcIuKJhlwiLHNpbXBsdXM6XCLiqKRcIixzaW1yYXJyOlwi4qWyXCIsc2xhcnI6XCLihpBcIixTbWFsbENpcmNsZTpcIuKImFwiLHNtYWxsc2V0bWludXM6XCLiiJZcIixzbWFzaHA6XCLiqLNcIixzbWVwYXJzbDpcIuKnpFwiLHNtaWQ6XCLiiKNcIixzbWlsZTpcIuKMo1wiLHNtdDpcIuKqqlwiLHNtdGU6XCLiqqxcIixzbXRlczpcIuKqrO+4gFwiLFNPRlRjeTpcItCsXCIsc29mdGN5Olwi0YxcIixzb2w6XCIvXCIsc29sYjpcIuKnhFwiLHNvbGJhcjpcIuKMv1wiLFNvcGY6XCLwnZWKXCIsc29wZjpcIvCdlaRcIixzcGFkZXM6XCLimaBcIixzcGFkZXN1aXQ6XCLimaBcIixzcGFyOlwi4oilXCIsc3FjYXA6XCLiipNcIixzcWNhcHM6XCLiipPvuIBcIixzcWN1cDpcIuKKlFwiLHNxY3VwczpcIuKKlO+4gFwiLFNxcnQ6XCLiiJpcIixzcXN1YjpcIuKKj1wiLHNxc3ViZTpcIuKKkVwiLHNxc3Vic2V0Olwi4oqPXCIsc3FzdWJzZXRlcTpcIuKKkVwiLHNxc3VwOlwi4oqQXCIsc3FzdXBlOlwi4oqSXCIsc3FzdXBzZXQ6XCLiipBcIixzcXN1cHNldGVxOlwi4oqSXCIsc3F1Olwi4pahXCIsU3F1YXJlOlwi4pahXCIsc3F1YXJlOlwi4pahXCIsU3F1YXJlSW50ZXJzZWN0aW9uOlwi4oqTXCIsU3F1YXJlU3Vic2V0Olwi4oqPXCIsU3F1YXJlU3Vic2V0RXF1YWw6XCLiipFcIixTcXVhcmVTdXBlcnNldDpcIuKKkFwiLFNxdWFyZVN1cGVyc2V0RXF1YWw6XCLiipJcIixTcXVhcmVVbmlvbjpcIuKKlFwiLHNxdWFyZjpcIuKWqlwiLHNxdWY6XCLilqpcIixzcmFycjpcIuKGklwiLFNzY3I6XCLwnZKuXCIsc3NjcjpcIvCdk4hcIixzc2V0bW46XCLiiJZcIixzc21pbGU6XCLijKNcIixzc3RhcmY6XCLii4ZcIixTdGFyOlwi4ouGXCIsc3RhcjpcIuKYhlwiLHN0YXJmOlwi4piFXCIsc3RyYWlnaHRlcHNpbG9uOlwiz7VcIixzdHJhaWdodHBoaTpcIs+VXCIsc3RybnM6XCLCr1wiLFN1YjpcIuKLkFwiLHN1YjpcIuKKglwiLHN1YmRvdDpcIuKqvVwiLHN1YkU6XCLiq4VcIixzdWJlOlwi4oqGXCIsc3ViZWRvdDpcIuKrg1wiLHN1Ym11bHQ6XCLiq4FcIixzdWJuRTpcIuKri1wiLHN1Ym5lOlwi4oqKXCIsc3VicGx1czpcIuKqv1wiLHN1YnJhcnI6XCLipblcIixTdWJzZXQ6XCLii5BcIixzdWJzZXQ6XCLiioJcIixzdWJzZXRlcTpcIuKKhlwiLHN1YnNldGVxcTpcIuKrhVwiLFN1YnNldEVxdWFsOlwi4oqGXCIsc3Vic2V0bmVxOlwi4oqKXCIsc3Vic2V0bmVxcTpcIuKri1wiLHN1YnNpbTpcIuKrh1wiLHN1YnN1YjpcIuKrlVwiLHN1YnN1cDpcIuKrk1wiLHN1Y2M6XCLiibtcIixzdWNjYXBwcm94Olwi4qq4XCIsc3VjY2N1cmx5ZXE6XCLiib1cIixTdWNjZWVkczpcIuKJu1wiLFN1Y2NlZWRzRXF1YWw6XCLiqrBcIixTdWNjZWVkc1NsYW50RXF1YWw6XCLiib1cIixTdWNjZWVkc1RpbGRlOlwi4om/XCIsc3VjY2VxOlwi4qqwXCIsc3VjY25hcHByb3g6XCLiqrpcIixzdWNjbmVxcTpcIuKqtlwiLHN1Y2Nuc2ltOlwi4oupXCIsc3VjY3NpbTpcIuKJv1wiLFN1Y2hUaGF0Olwi4oiLXCIsU3VtOlwi4oiRXCIsc3VtOlwi4oiRXCIsc3VuZzpcIuKZqlwiLFN1cDpcIuKLkVwiLHN1cDpcIuKKg1wiLHN1cDE6XCLCuVwiLHN1cDI6XCLCslwiLHN1cDM6XCLCs1wiLHN1cGRvdDpcIuKqvlwiLHN1cGRzdWI6XCLiq5hcIixzdXBFOlwi4quGXCIsc3VwZTpcIuKKh1wiLHN1cGVkb3Q6XCLiq4RcIixTdXBlcnNldDpcIuKKg1wiLFN1cGVyc2V0RXF1YWw6XCLiiodcIixzdXBoc29sOlwi4p+JXCIsc3VwaHN1YjpcIuKrl1wiLHN1cGxhcnI6XCLipbtcIixzdXBtdWx0Olwi4quCXCIsc3VwbkU6XCLiq4xcIixzdXBuZTpcIuKKi1wiLHN1cHBsdXM6XCLiq4BcIixTdXBzZXQ6XCLii5FcIixzdXBzZXQ6XCLiioNcIixzdXBzZXRlcTpcIuKKh1wiLHN1cHNldGVxcTpcIuKrhlwiLHN1cHNldG5lcTpcIuKKi1wiLHN1cHNldG5lcXE6XCLiq4xcIixzdXBzaW06XCLiq4hcIixzdXBzdWI6XCLiq5RcIixzdXBzdXA6XCLiq5ZcIixzd2FyaGs6XCLipKZcIixzd0FycjpcIuKHmVwiLHN3YXJyOlwi4oaZXCIsc3dhcnJvdzpcIuKGmVwiLHN3bndhcjpcIuKkqlwiLHN6bGlnOlwiw59cIixUYWI6XCJcXHRcIix0YXJnZXQ6XCLijJZcIixUYXU6XCLOpFwiLHRhdTpcIs+EXCIsdGJyazpcIuKOtFwiLFRjYXJvbjpcIsWkXCIsdGNhcm9uOlwixaVcIixUY2VkaWw6XCLFolwiLHRjZWRpbDpcIsWjXCIsVGN5Olwi0KJcIix0Y3k6XCLRglwiLHRkb3Q6XCLig5tcIix0ZWxyZWM6XCLijJVcIixUZnI6XCLwnZSXXCIsdGZyOlwi8J2UsVwiLHRoZXJlNDpcIuKItFwiLFRoZXJlZm9yZTpcIuKItFwiLHRoZXJlZm9yZTpcIuKItFwiLFRoZXRhOlwizphcIix0aGV0YTpcIs64XCIsdGhldGFzeW06XCLPkVwiLHRoZXRhdjpcIs+RXCIsdGhpY2thcHByb3g6XCLiiYhcIix0aGlja3NpbTpcIuKIvFwiLFRoaWNrU3BhY2U6XCLigZ/igIpcIix0aGluc3A6XCLigIlcIixUaGluU3BhY2U6XCLigIlcIix0aGthcDpcIuKJiFwiLHRoa3NpbTpcIuKIvFwiLFRIT1JOOlwiw55cIix0aG9ybjpcIsO+XCIsVGlsZGU6XCLiiLxcIix0aWxkZTpcIsucXCIsVGlsZGVFcXVhbDpcIuKJg1wiLFRpbGRlRnVsbEVxdWFsOlwi4omFXCIsVGlsZGVUaWxkZTpcIuKJiFwiLHRpbWVzOlwiw5dcIix0aW1lc2I6XCLiiqBcIix0aW1lc2JhcjpcIuKosVwiLHRpbWVzZDpcIuKosFwiLHRpbnQ6XCLiiK1cIix0b2VhOlwi4qSoXCIsdG9wOlwi4oqkXCIsdG9wYm90Olwi4oy2XCIsdG9wY2lyOlwi4quxXCIsVG9wZjpcIvCdlYtcIix0b3BmOlwi8J2VpVwiLHRvcGZvcms6XCLiq5pcIix0b3NhOlwi4qSpXCIsdHByaW1lOlwi4oC0XCIsVFJBREU6XCLihKJcIix0cmFkZTpcIuKEolwiLHRyaWFuZ2xlOlwi4pa1XCIsdHJpYW5nbGVkb3duOlwi4pa/XCIsdHJpYW5nbGVsZWZ0Olwi4peDXCIsdHJpYW5nbGVsZWZ0ZXE6XCLiirRcIix0cmlhbmdsZXE6XCLiiZxcIix0cmlhbmdsZXJpZ2h0Olwi4pa5XCIsdHJpYW5nbGVyaWdodGVxOlwi4oq1XCIsdHJpZG90Olwi4pesXCIsdHJpZTpcIuKJnFwiLHRyaW1pbnVzOlwi4qi6XCIsVHJpcGxlRG90Olwi4oObXCIsdHJpcGx1czpcIuKouVwiLHRyaXNiOlwi4qeNXCIsdHJpdGltZTpcIuKou1wiLHRycGV6aXVtOlwi4o+iXCIsVHNjcjpcIvCdkq9cIix0c2NyOlwi8J2TiVwiLFRTY3k6XCLQplwiLHRzY3k6XCLRhlwiLFRTSGN5Olwi0ItcIix0c2hjeTpcItGbXCIsVHN0cm9rOlwixaZcIix0c3Ryb2s6XCLFp1wiLHR3aXh0Olwi4omsXCIsdHdvaGVhZGxlZnRhcnJvdzpcIuKGnlwiLHR3b2hlYWRyaWdodGFycm93Olwi4oagXCIsVWFjdXRlOlwiw5pcIix1YWN1dGU6XCLDulwiLFVhcnI6XCLihp9cIix1QXJyOlwi4oeRXCIsdWFycjpcIuKGkVwiLFVhcnJvY2lyOlwi4qWJXCIsVWJyY3k6XCLQjlwiLHVicmN5Olwi0Z5cIixVYnJldmU6XCLFrFwiLHVicmV2ZTpcIsWtXCIsVWNpcmM6XCLDm1wiLHVjaXJjOlwiw7tcIixVY3k6XCLQo1wiLHVjeTpcItGDXCIsdWRhcnI6XCLih4VcIixVZGJsYWM6XCLFsFwiLHVkYmxhYzpcIsWxXCIsdWRoYXI6XCLipa5cIix1ZmlzaHQ6XCLipb5cIixVZnI6XCLwnZSYXCIsdWZyOlwi8J2UslwiLFVncmF2ZTpcIsOZXCIsdWdyYXZlOlwiw7lcIix1SGFyOlwi4qWjXCIsdWhhcmw6XCLihr9cIix1aGFycjpcIuKGvlwiLHVoYmxrOlwi4paAXCIsdWxjb3JuOlwi4oycXCIsdWxjb3JuZXI6XCLijJxcIix1bGNyb3A6XCLijI9cIix1bHRyaTpcIuKXuFwiLFVtYWNyOlwixapcIix1bWFjcjpcIsWrXCIsdW1sOlwiwqhcIixVbmRlckJhcjpcIl9cIixVbmRlckJyYWNlOlwi4o+fXCIsVW5kZXJCcmFja2V0Olwi4o61XCIsVW5kZXJQYXJlbnRoZXNpczpcIuKPnVwiLFVuaW9uOlwi4ouDXCIsVW5pb25QbHVzOlwi4oqOXCIsVW9nb246XCLFslwiLHVvZ29uOlwixbNcIixVb3BmOlwi8J2VjFwiLHVvcGY6XCLwnZWmXCIsVXBBcnJvdzpcIuKGkVwiLFVwYXJyb3c6XCLih5FcIix1cGFycm93Olwi4oaRXCIsVXBBcnJvd0JhcjpcIuKkklwiLFVwQXJyb3dEb3duQXJyb3c6XCLih4VcIixVcERvd25BcnJvdzpcIuKGlVwiLFVwZG93bmFycm93Olwi4oeVXCIsdXBkb3duYXJyb3c6XCLihpVcIixVcEVxdWlsaWJyaXVtOlwi4qWuXCIsdXBoYXJwb29ubGVmdDpcIuKGv1wiLHVwaGFycG9vbnJpZ2h0Olwi4oa+XCIsdXBsdXM6XCLiio5cIixVcHBlckxlZnRBcnJvdzpcIuKGllwiLFVwcGVyUmlnaHRBcnJvdzpcIuKGl1wiLFVwc2k6XCLPklwiLHVwc2k6XCLPhVwiLHVwc2loOlwiz5JcIixVcHNpbG9uOlwizqVcIix1cHNpbG9uOlwiz4VcIixVcFRlZTpcIuKKpVwiLFVwVGVlQXJyb3c6XCLihqVcIix1cHVwYXJyb3dzOlwi4oeIXCIsdXJjb3JuOlwi4oydXCIsdXJjb3JuZXI6XCLijJ1cIix1cmNyb3A6XCLijI5cIixVcmluZzpcIsWuXCIsdXJpbmc6XCLFr1wiLHVydHJpOlwi4pe5XCIsVXNjcjpcIvCdkrBcIix1c2NyOlwi8J2TilwiLHV0ZG90Olwi4ouwXCIsVXRpbGRlOlwixahcIix1dGlsZGU6XCLFqVwiLHV0cmk6XCLilrVcIix1dHJpZjpcIuKWtFwiLHV1YXJyOlwi4oeIXCIsVXVtbDpcIsOcXCIsdXVtbDpcIsO8XCIsdXdhbmdsZTpcIuKmp1wiLHZhbmdydDpcIuKmnFwiLHZhcmVwc2lsb246XCLPtVwiLHZhcmthcHBhOlwiz7BcIix2YXJub3RoaW5nOlwi4oiFXCIsdmFycGhpOlwiz5VcIix2YXJwaTpcIs+WXCIsdmFycHJvcHRvOlwi4oidXCIsdkFycjpcIuKHlVwiLHZhcnI6XCLihpVcIix2YXJyaG86XCLPsVwiLHZhcnNpZ21hOlwiz4JcIix2YXJzdWJzZXRuZXE6XCLiiorvuIBcIix2YXJzdWJzZXRuZXFxOlwi4quL77iAXCIsdmFyc3Vwc2V0bmVxOlwi4oqL77iAXCIsdmFyc3Vwc2V0bmVxcTpcIuKrjO+4gFwiLHZhcnRoZXRhOlwiz5FcIix2YXJ0cmlhbmdsZWxlZnQ6XCLiirJcIix2YXJ0cmlhbmdsZXJpZ2h0Olwi4oqzXCIsVmJhcjpcIuKrq1wiLHZCYXI6XCLiq6hcIix2QmFydjpcIuKrqVwiLFZjeTpcItCSXCIsdmN5Olwi0LJcIixWRGFzaDpcIuKKq1wiLFZkYXNoOlwi4oqpXCIsdkRhc2g6XCLiiqhcIix2ZGFzaDpcIuKKolwiLFZkYXNobDpcIuKrplwiLFZlZTpcIuKLgVwiLHZlZTpcIuKIqFwiLHZlZWJhcjpcIuKKu1wiLHZlZWVxOlwi4omaXCIsdmVsbGlwOlwi4ouuXCIsVmVyYmFyOlwi4oCWXCIsdmVyYmFyOlwifFwiLFZlcnQ6XCLigJZcIix2ZXJ0OlwifFwiLFZlcnRpY2FsQmFyOlwi4oijXCIsVmVydGljYWxMaW5lOlwifFwiLFZlcnRpY2FsU2VwYXJhdG9yOlwi4p2YXCIsVmVydGljYWxUaWxkZTpcIuKJgFwiLFZlcnlUaGluU3BhY2U6XCLigIpcIixWZnI6XCLwnZSZXCIsdmZyOlwi8J2Us1wiLHZsdHJpOlwi4oqyXCIsdm5zdWI6XCLiioLig5JcIix2bnN1cDpcIuKKg+KDklwiLFZvcGY6XCLwnZWNXCIsdm9wZjpcIvCdladcIix2cHJvcDpcIuKInVwiLHZydHJpOlwi4oqzXCIsVnNjcjpcIvCdkrFcIix2c2NyOlwi8J2Ti1wiLHZzdWJuRTpcIuKri++4gFwiLHZzdWJuZTpcIuKKiu+4gFwiLHZzdXBuRTpcIuKrjO+4gFwiLHZzdXBuZTpcIuKKi++4gFwiLFZ2ZGFzaDpcIuKKqlwiLHZ6aWd6YWc6XCLipppcIixXY2lyYzpcIsW0XCIsd2NpcmM6XCLFtVwiLHdlZGJhcjpcIuKpn1wiLFdlZGdlOlwi4ouAXCIsd2VkZ2U6XCLiiKdcIix3ZWRnZXE6XCLiiZlcIix3ZWllcnA6XCLihJhcIixXZnI6XCLwnZSaXCIsd2ZyOlwi8J2UtFwiLFdvcGY6XCLwnZWOXCIsd29wZjpcIvCdlahcIix3cDpcIuKEmFwiLHdyOlwi4omAXCIsd3JlYXRoOlwi4omAXCIsV3NjcjpcIvCdkrJcIix3c2NyOlwi8J2TjFwiLHhjYXA6XCLii4JcIix4Y2lyYzpcIuKXr1wiLHhjdXA6XCLii4NcIix4ZHRyaTpcIuKWvVwiLFhmcjpcIvCdlJtcIix4ZnI6XCLwnZS1XCIseGhBcnI6XCLin7pcIix4aGFycjpcIuKft1wiLFhpOlwizp5cIix4aTpcIs6+XCIseGxBcnI6XCLin7hcIix4bGFycjpcIuKftVwiLHhtYXA6XCLin7xcIix4bmlzOlwi4ou7XCIseG9kb3Q6XCLiqIBcIixYb3BmOlwi8J2Vj1wiLHhvcGY6XCLwnZWpXCIseG9wbHVzOlwi4qiBXCIseG90aW1lOlwi4qiCXCIseHJBcnI6XCLin7lcIix4cmFycjpcIuKftlwiLFhzY3I6XCLwnZKzXCIseHNjcjpcIvCdk41cIix4c3FjdXA6XCLiqIZcIix4dXBsdXM6XCLiqIRcIix4dXRyaTpcIuKWs1wiLHh2ZWU6XCLii4FcIix4d2VkZ2U6XCLii4BcIixZYWN1dGU6XCLDnVwiLHlhY3V0ZTpcIsO9XCIsWUFjeTpcItCvXCIseWFjeTpcItGPXCIsWWNpcmM6XCLFtlwiLHljaXJjOlwixbdcIixZY3k6XCLQq1wiLHljeTpcItGLXCIseWVuOlwiwqVcIixZZnI6XCLwnZScXCIseWZyOlwi8J2UtlwiLFlJY3k6XCLQh1wiLHlpY3k6XCLRl1wiLFlvcGY6XCLwnZWQXCIseW9wZjpcIvCdlapcIixZc2NyOlwi8J2StFwiLHlzY3I6XCLwnZOOXCIsWVVjeTpcItCuXCIseXVjeTpcItGOXCIsWXVtbDpcIsW4XCIseXVtbDpcIsO/XCIsWmFjdXRlOlwixblcIix6YWN1dGU6XCLFulwiLFpjYXJvbjpcIsW9XCIsemNhcm9uOlwixb5cIixaY3k6XCLQl1wiLHpjeTpcItC3XCIsWmRvdDpcIsW7XCIsemRvdDpcIsW8XCIsemVldHJmOlwi4oSoXCIsWmVyb1dpZHRoU3BhY2U6XCLigItcIixaZXRhOlwizpZcIix6ZXRhOlwizrZcIixaZnI6XCLihKhcIix6ZnI6XCLwnZS3XCIsWkhjeTpcItCWXCIsemhjeTpcItC2XCIsemlncmFycjpcIuKHnVwiLFpvcGY6XCLihKRcIix6b3BmOlwi8J2Vq1wiLFpzY3I6XCLwnZK1XCIsenNjcjpcIvCdk49cIix6d2o6XCLigI1cIix6d25qOlwi4oCMXCJ9KSx0LmVudGl0eU1hcD10LkhUTUxfRU5USVRJRVN9LDg5Nzg6KGUsdCxyKT0+e3ZhciBhPXIoNDcyMik7dC5ET01JbXBsZW1lbnRhdGlvbj1hLkRPTUltcGxlbWVudGF0aW9uLHQuWE1MU2VyaWFsaXplcj1hLlhNTFNlcmlhbGl6ZXIsdC5ET01QYXJzZXI9cig1NzUyKS5ET01QYXJzZXJ9LDQ0NjY6KGUsdCxyKT0+e3ZhciBhPXIoNDU4MikuTkFNRVNQQUNFLG49L1tBLVpfYS16XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF0vLG89bmV3IFJlZ0V4cChcIltcXFxcLVxcXFwuMC05XCIrbi5zb3VyY2Uuc2xpY2UoMSwtMSkrXCJcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF1cIiksaT1uZXcgUmVnRXhwKFwiXlwiK24uc291cmNlK28uc291cmNlK1wiKig/OjpcIituLnNvdXJjZStvLnNvdXJjZStcIiopPyRcIik7ZnVuY3Rpb24gcyhlLHQpe3RoaXMubWVzc2FnZT1lLHRoaXMubG9jYXRvcj10LEVycm9yLmNhcHR1cmVTdGFja1RyYWNlJiZFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHMpfWZ1bmN0aW9uIGwoKXt9ZnVuY3Rpb24gYyhlLHQpe3JldHVybiB0LmxpbmVOdW1iZXI9ZS5saW5lTnVtYmVyLHQuY29sdW1uTnVtYmVyPWUuY29sdW1uTnVtYmVyLHR9ZnVuY3Rpb24gdShlLHQscixuLG8saSl7ZnVuY3Rpb24gcyhlLHQsYSl7ci5hdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShlKSYmaS5mYXRhbEVycm9yKFwiQXR0cmlidXRlIFwiK2UrXCIgcmVkZWZpbmVkXCIpLHIuYWRkVmFsdWUoZSx0LnJlcGxhY2UoL1tcXHRcXG5cXHJdL2csXCIgXCIpLnJlcGxhY2UoLyYjP1xcdys7L2csbyksYSl9Zm9yKHZhciBsLGM9Kyt0LHU9MDs7KXt2YXIgaD1lLmNoYXJBdChjKTtzd2l0Y2goaCl7Y2FzZVwiPVwiOmlmKDE9PT11KWw9ZS5zbGljZSh0LGMpLHU9MztlbHNle2lmKDIhPT11KXRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBlcXVhbCBtdXN0IGFmdGVyIGF0dHJOYW1lXCIpO3U9M31icmVhaztjYXNlXCInXCI6Y2FzZSdcIic6aWYoMz09PXV8fDE9PT11KXtpZigxPT09dSYmKGkud2FybmluZygnYXR0cmlidXRlIHZhbHVlIG11c3QgYWZ0ZXIgXCI9XCInKSxsPWUuc2xpY2UodCxjKSksdD1jKzEsISgoYz1lLmluZGV4T2YoaCx0KSk+MCkpdGhyb3cgbmV3IEVycm9yKFwiYXR0cmlidXRlIHZhbHVlIG5vIGVuZCAnXCIraCtcIicgbWF0Y2hcIik7cyhsLGQ9ZS5zbGljZSh0LGMpLHQtMSksdT01fWVsc2V7aWYoNCE9dSl0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSB2YWx1ZSBtdXN0IGFmdGVyIFwiPVwiJyk7cyhsLGQ9ZS5zbGljZSh0LGMpLHQpLGkud2FybmluZygnYXR0cmlidXRlIFwiJytsKydcIiBtaXNzZWQgc3RhcnQgcXVvdCgnK2grXCIpISFcIiksdD1jKzEsdT01fWJyZWFrO2Nhc2VcIi9cIjpzd2l0Y2godSl7Y2FzZSAwOnIuc2V0VGFnTmFtZShlLnNsaWNlKHQsYykpO2Nhc2UgNTpjYXNlIDY6Y2FzZSA3OnU9NyxyLmNsb3NlZD0hMDtjYXNlIDQ6Y2FzZSAxOmJyZWFrO2Nhc2UgMjpyLmNsb3NlZD0hMDticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBpbnZhbGlkIGNsb3NlIGNoYXIoJy8nKVwiKX1icmVhaztjYXNlXCJcIjpyZXR1cm4gaS5lcnJvcihcInVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpLDA9PXUmJnIuc2V0VGFnTmFtZShlLnNsaWNlKHQsYykpLGM7Y2FzZVwiPlwiOnN3aXRjaCh1KXtjYXNlIDA6ci5zZXRUYWdOYW1lKGUuc2xpY2UodCxjKSk7Y2FzZSA1OmNhc2UgNjpjYXNlIDc6YnJlYWs7Y2FzZSA0OmNhc2UgMTpcIi9cIj09PShkPWUuc2xpY2UodCxjKSkuc2xpY2UoLTEpJiYoci5jbG9zZWQ9ITAsZD1kLnNsaWNlKDAsLTEpKTtjYXNlIDI6Mj09PXUmJihkPWwpLDQ9PXU/KGkud2FybmluZygnYXR0cmlidXRlIFwiJytkKydcIiBtaXNzZWQgcXVvdChcIikhJykscyhsLGQsdCkpOihhLmlzSFRNTChuW1wiXCJdKSYmZC5tYXRjaCgvXig/OmRpc2FibGVkfGNoZWNrZWR8c2VsZWN0ZWQpJC9pKXx8aS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2QrJ1wiIG1pc3NlZCB2YWx1ZSEhIFwiJytkKydcIiBpbnN0ZWFkISEnKSxzKGQsZCx0KSk7YnJlYWs7Y2FzZSAzOnRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSB2YWx1ZSBtaXNzZWQhIVwiKX1yZXR1cm4gYztjYXNlXCLCgFwiOmg9XCIgXCI7ZGVmYXVsdDppZihoPD1cIiBcIilzd2l0Y2godSl7Y2FzZSAwOnIuc2V0VGFnTmFtZShlLnNsaWNlKHQsYykpLHU9NjticmVhaztjYXNlIDE6bD1lLnNsaWNlKHQsYyksdT0yO2JyZWFrO2Nhc2UgNDp2YXIgZD1lLnNsaWNlKHQsYyk7aS53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2QrJ1wiIG1pc3NlZCBxdW90KFwiKSEhJykscyhsLGQsdCk7Y2FzZSA1OnU9Nn1lbHNlIHN3aXRjaCh1KXtjYXNlIDI6ci50YWdOYW1lLGEuaXNIVE1MKG5bXCJcIl0pJiZsLm1hdGNoKC9eKD86ZGlzYWJsZWR8Y2hlY2tlZHxzZWxlY3RlZCkkL2kpfHxpLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrbCsnXCIgbWlzc2VkIHZhbHVlISEgXCInK2wrJ1wiIGluc3RlYWQyISEnKSxzKGwsbCx0KSx0PWMsdT0xO2JyZWFrO2Nhc2UgNTppLndhcm5pbmcoJ2F0dHJpYnV0ZSBzcGFjZSBpcyByZXF1aXJlZFwiJytsKydcIiEhJyk7Y2FzZSA2OnU9MSx0PWM7YnJlYWs7Y2FzZSAzOnU9NCx0PWM7YnJlYWs7Y2FzZSA3OnRocm93IG5ldyBFcnJvcihcImVsZW1lbnRzIGNsb3NlZCBjaGFyYWN0ZXIgJy8nIGFuZCAnPicgbXVzdCBiZSBjb25uZWN0ZWQgdG9cIil9fWMrK319ZnVuY3Rpb24gaChlLHQscil7Zm9yKHZhciBuPWUudGFnTmFtZSxvPW51bGwsaT1lLmxlbmd0aDtpLS07KXt2YXIgcz1lW2ldLGw9cy5xTmFtZSxjPXMudmFsdWU7aWYoKG09bC5pbmRleE9mKFwiOlwiKSk+MCl2YXIgdT1zLnByZWZpeD1sLnNsaWNlKDAsbSksaD1sLnNsaWNlKG0rMSksZD1cInhtbG5zXCI9PT11JiZoO2Vsc2UgaD1sLHU9bnVsbCxkPVwieG1sbnNcIj09PWwmJlwiXCI7cy5sb2NhbE5hbWU9aCwhMSE9PWQmJihudWxsPT1vJiYobz17fSxwKHIscj17fSkpLHJbZF09b1tkXT1jLHMudXJpPWEuWE1MTlMsdC5zdGFydFByZWZpeE1hcHBpbmcoZCxjKSl9Zm9yKGk9ZS5sZW5ndGg7aS0tOykodT0ocz1lW2ldKS5wcmVmaXgpJiYoXCJ4bWxcIj09PXUmJihzLnVyaT1hLlhNTCksXCJ4bWxuc1wiIT09dSYmKHMudXJpPXJbdXx8XCJcIl0pKTt2YXIgbTsobT1uLmluZGV4T2YoXCI6XCIpKT4wPyh1PWUucHJlZml4PW4uc2xpY2UoMCxtKSxoPWUubG9jYWxOYW1lPW4uc2xpY2UobSsxKSk6KHU9bnVsbCxoPWUubG9jYWxOYW1lPW4pO3ZhciBmPWUudXJpPXJbdXx8XCJcIl07aWYodC5zdGFydEVsZW1lbnQoZixoLG4sZSksIWUuY2xvc2VkKXJldHVybiBlLmN1cnJlbnROU01hcD1yLGUubG9jYWxOU01hcD1vLCEwO2lmKHQuZW5kRWxlbWVudChmLGgsbiksbylmb3IodSBpbiBvKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLHUpJiZ0LmVuZFByZWZpeE1hcHBpbmcodSl9ZnVuY3Rpb24gZChlLHQscixhLG4pe2lmKC9eKD86c2NyaXB0fHRleHRhcmVhKSQvaS50ZXN0KHIpKXt2YXIgbz1lLmluZGV4T2YoXCI8L1wiK3IrXCI+XCIsdCksaT1lLnN1YnN0cmluZyh0KzEsbyk7aWYoL1smPF0vLnRlc3QoaSkpcmV0dXJuL15zY3JpcHQkL2kudGVzdChyKT8obi5jaGFyYWN0ZXJzKGksMCxpLmxlbmd0aCksbyk6KGk9aS5yZXBsYWNlKC8mIz9cXHcrOy9nLGEpLG4uY2hhcmFjdGVycyhpLDAsaS5sZW5ndGgpLG8pfXJldHVybiB0KzF9ZnVuY3Rpb24gbShlLHQscixhKXt2YXIgbj1hW3JdO3JldHVybiBudWxsPT1uJiYoKG49ZS5sYXN0SW5kZXhPZihcIjwvXCIrcitcIj5cIikpPHQmJihuPWUubGFzdEluZGV4T2YoXCI8L1wiK3IpKSxhW3JdPW4pLG48dH1mdW5jdGlvbiBwKGUsdCl7Zm9yKHZhciByIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscikmJih0W3JdPWVbcl0pfWZ1bmN0aW9uIGYoZSx0LHIsYSl7aWYoXCItXCI9PT1lLmNoYXJBdCh0KzIpKXJldHVyblwiLVwiPT09ZS5jaGFyQXQodCszKT8obj1lLmluZGV4T2YoXCItLVxceDNlXCIsdCs0KSk+dD8oci5jb21tZW50KGUsdCs0LG4tdC00KSxuKzMpOihhLmVycm9yKFwiVW5jbG9zZWQgY29tbWVudFwiKSwtMSk6LTE7aWYoXCJDREFUQVtcIj09ZS5zdWJzdHIodCszLDYpKXt2YXIgbj1lLmluZGV4T2YoXCJdXT5cIix0KzkpO3JldHVybiByLnN0YXJ0Q0RBVEEoKSxyLmNoYXJhY3RlcnMoZSx0Kzksbi10LTkpLHIuZW5kQ0RBVEEoKSxuKzN9dmFyIG89ZnVuY3Rpb24oZSx0KXt2YXIgcixhPVtdLG49LydbXiddKyd8XCJbXlwiXStcInxbXlxcczw+XFwvPV0rPT98KFxcLz9cXHMqPnw8KS9nO2ZvcihuLmxhc3RJbmRleD10LG4uZXhlYyhlKTtyPW4uZXhlYyhlKTspaWYoYS5wdXNoKHIpLHJbMV0pcmV0dXJuIGF9KGUsdCksaT1vLmxlbmd0aDtpZihpPjEmJi8hZG9jdHlwZS9pLnRlc3Qob1swXVswXSkpe3ZhciBzPW9bMV1bMF0sbD0hMSxjPSExO2k+MyYmKC9ecHVibGljJC9pLnRlc3Qob1syXVswXSk/KGw9b1szXVswXSxjPWk+NCYmb1s0XVswXSk6L15zeXN0ZW0kL2kudGVzdChvWzJdWzBdKSYmKGM9b1szXVswXSkpO3ZhciB1PW9baS0xXTtyZXR1cm4gci5zdGFydERURChzLGwsYyksci5lbmREVEQoKSx1LmluZGV4K3VbMF0ubGVuZ3RofXJldHVybi0xfWZ1bmN0aW9uIHgoZSx0LHIpe3ZhciBhPWUuaW5kZXhPZihcIj8+XCIsdCk7aWYoYSl7dmFyIG49ZS5zdWJzdHJpbmcodCxhKS5tYXRjaCgvXjxcXD8oXFxTKilcXHMqKFtcXHNcXFNdKj8pXFxzKiQvKTtyZXR1cm4gbj8oblswXS5sZW5ndGgsci5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oblsxXSxuWzJdKSxhKzIpOi0xfXJldHVybi0xfWZ1bmN0aW9uIGcoKXt0aGlzLmF0dHJpYnV0ZU5hbWVzPXt9fXMucHJvdG90eXBlPW5ldyBFcnJvcixzLnByb3RvdHlwZS5uYW1lPXMubmFtZSxsLnByb3RvdHlwZT17cGFyc2U6ZnVuY3Rpb24oZSx0LHIpe3ZhciBuPXRoaXMuZG9tQnVpbGRlcjtuLnN0YXJ0RG9jdW1lbnQoKSxwKHQsdD17fSksZnVuY3Rpb24oZSx0LHIsbixvKXtmdW5jdGlvbiBpKGUpe3ZhciB0PWUuc2xpY2UoMSwtMSk7cmV0dXJuIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHIsdCk/clt0XTpcIiNcIj09PXQuY2hhckF0KDApP2Z1bmN0aW9uKGUpe2lmKGU+NjU1MzUpe3ZhciB0PTU1Mjk2KygoZS09NjU1MzYpPj4xMCkscj01NjMyMCsoMTAyMyZlKTtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0LHIpfXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpfShwYXJzZUludCh0LnN1YnN0cigxKS5yZXBsYWNlKFwieFwiLFwiMHhcIikpKTooby5lcnJvcihcImVudGl0eSBub3QgZm91bmQ6XCIrZSksZSl9ZnVuY3Rpb24gbCh0KXtpZih0Pl8pe3ZhciByPWUuc3Vic3RyaW5nKF8sdCkucmVwbGFjZSgvJiM/XFx3KzsvZyxpKTtDJiZwKF8pLG4uY2hhcmFjdGVycyhyLDAsdC1fKSxfPXR9fWZ1bmN0aW9uIHAodCxyKXtmb3IoO3Q+PWImJihyPXYuZXhlYyhlKSk7KXc9ci5pbmRleCxiPXcrclswXS5sZW5ndGgsQy5saW5lTnVtYmVyKys7Qy5jb2x1bW5OdW1iZXI9dC13KzF9Zm9yKHZhciB3PTAsYj0wLHY9Ly4qKD86XFxyXFxuP3xcXG4pfC4qJC9nLEM9bi5sb2NhdG9yLEE9W3tjdXJyZW50TlNNYXA6dH1dLEU9e30sXz0wOzspe3RyeXt2YXIgeT1lLmluZGV4T2YoXCI8XCIsXyk7aWYoeTwwKXtpZighZS5zdWJzdHIoXykubWF0Y2goL15cXHMqJC8pKXt2YXIgcT1uLmRvYyxEPXEuY3JlYXRlVGV4dE5vZGUoZS5zdWJzdHIoXykpO3EuYXBwZW5kQ2hpbGQoRCksbi5jdXJyZW50RWxlbWVudD1EfXJldHVybn1zd2l0Y2goeT5fJiZsKHkpLGUuY2hhckF0KHkrMSkpe2Nhc2VcIi9cIjp2YXIgTT1lLmluZGV4T2YoXCI+XCIseSszKSxUPWUuc3Vic3RyaW5nKHkrMixNKS5yZXBsYWNlKC9bIFxcdFxcblxccl0rJC9nLFwiXCIpLE49QS5wb3AoKTtNPDA/KFQ9ZS5zdWJzdHJpbmcoeSsyKS5yZXBsYWNlKC9bXFxzPF0uKi8sXCJcIiksby5lcnJvcihcImVuZCB0YWcgbmFtZTogXCIrVCtcIiBpcyBub3QgY29tcGxldGU6XCIrTi50YWdOYW1lKSxNPXkrMStULmxlbmd0aCk6VC5tYXRjaCgvXFxzPC8pJiYoVD1ULnJlcGxhY2UoL1tcXHM8XS4qLyxcIlwiKSxvLmVycm9yKFwiZW5kIHRhZyBuYW1lOiBcIitUK1wiIG1heWJlIG5vdCBjb21wbGV0ZVwiKSxNPXkrMStULmxlbmd0aCk7dmFyIE89Ti5sb2NhbE5TTWFwLEw9Ti50YWdOYW1lPT1UO2lmKEx8fE4udGFnTmFtZSYmTi50YWdOYW1lLnRvTG93ZXJDYXNlKCk9PVQudG9Mb3dlckNhc2UoKSl7aWYobi5lbmRFbGVtZW50KE4udXJpLE4ubG9jYWxOYW1lLFQpLE8pZm9yKHZhciBCIGluIE8pT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE8sQikmJm4uZW5kUHJlZml4TWFwcGluZyhCKTtMfHxvLmZhdGFsRXJyb3IoXCJlbmQgdGFnIG5hbWU6IFwiK1QrXCIgaXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IHN0YXJ0IHRhZ05hbWU6XCIrTi50YWdOYW1lKX1lbHNlIEEucHVzaChOKTtNKys7YnJlYWs7Y2FzZVwiP1wiOkMmJnAoeSksTT14KGUseSxuKTticmVhaztjYXNlXCIhXCI6QyYmcCh5KSxNPWYoZSx5LG4sbyk7YnJlYWs7ZGVmYXVsdDpDJiZwKHkpO3ZhciBTPW5ldyBnLEY9QVtBLmxlbmd0aC0xXS5jdXJyZW50TlNNYXAsUD0oTT11KGUseSxTLEYsaSxvKSxTLmxlbmd0aCk7aWYoIVMuY2xvc2VkJiZtKGUsTSxTLnRhZ05hbWUsRSkmJihTLmNsb3NlZD0hMCxyLm5ic3B8fG8ud2FybmluZyhcInVuY2xvc2VkIHhtbCBhdHRyaWJ1dGVcIikpLEMmJlApe2Zvcih2YXIgaz1jKEMse30pLFI9MDtSPFA7UisrKXt2YXIgST1TW1JdO3AoSS5vZmZzZXQpLEkubG9jYXRvcj1jKEMse30pfW4ubG9jYXRvcj1rLGgoUyxuLEYpJiZBLnB1c2goUyksbi5sb2NhdG9yPUN9ZWxzZSBoKFMsbixGKSYmQS5wdXNoKFMpO2EuaXNIVE1MKFMudXJpKSYmIVMuY2xvc2VkP009ZChlLE0sUy50YWdOYW1lLGksbik6TSsrfX1jYXRjaChlKXtpZihlIGluc3RhbmNlb2Ygcyl0aHJvdyBlO28uZXJyb3IoXCJlbGVtZW50IHBhcnNlIGVycm9yOiBcIitlKSxNPS0xfU0+Xz9fPU06bChNYXRoLm1heCh5LF8pKzEpfX0oZSx0LHIsbix0aGlzLmVycm9ySGFuZGxlciksbi5lbmREb2N1bWVudCgpfX0sZy5wcm90b3R5cGU9e3NldFRhZ05hbWU6ZnVuY3Rpb24oZSl7aWYoIWkudGVzdChlKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRhZ05hbWU6XCIrZSk7dGhpcy50YWdOYW1lPWV9LGFkZFZhbHVlOmZ1bmN0aW9uKGUsdCxyKXtpZighaS50ZXN0KGUpKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYXR0cmlidXRlOlwiK2UpO3RoaXMuYXR0cmlidXRlTmFtZXNbZV09dGhpcy5sZW5ndGgsdGhpc1t0aGlzLmxlbmd0aCsrXT17cU5hbWU6ZSx2YWx1ZTp0LG9mZnNldDpyfX0sbGVuZ3RoOjAsZ2V0TG9jYWxOYW1lOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLmxvY2FsTmFtZX0sZ2V0TG9jYXRvcjpmdW5jdGlvbihlKXtyZXR1cm4gdGhpc1tlXS5sb2NhdG9yfSxnZXRRTmFtZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpc1tlXS5xTmFtZX0sZ2V0VVJJOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzW2VdLnVyaX0sZ2V0VmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXNbZV0udmFsdWV9fSx0LlhNTFJlYWRlcj1sLHQuUGFyc2VFcnJvcj1zfSw4OTE3OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3I9dm9pZCAwO3ZhciBhPXIoNjIwMCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJJbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcn19KX0sNjIwMDooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcj12b2lkIDA7Y2xhc3MgciBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGUsdCxyLGE9XCJleGFjdGx5XCIpe3N1cGVyKGAke2V9IHRhZyBtdXN0IGhhdmUgJHthfSAke3R9IGNoaWxkcmVuLiBJdCdzIGFjdHVhbGx5ICR7cn1gKSx0aGlzLm5hbWU9XCJJbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yXCJ9fXQuSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcj1yfSw0Mjc5OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocig4MjgpLHQpLG4ocig1OTc1KSx0KSxuKHIoNzk5KSx0KSxuKHIoMjQyNCksdCl9LDU5NzU6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkpvaW5XaXRoTWFueVNlcGFyYXRvcnM9dm9pZCAwO2NsYXNzIHJ7Y29uc3RydWN0b3IoZSl7dGhpcy5fc2VwYXJhdG9ycz1lfXN0YXRpYyBqb2luKGUsdCl7cmV0dXJuIG5ldyByKHQpLl9qb2luKGUpfV9qb2luKGUpe3JldHVybiBlLnJlZHVjZSgoKGUsdCxyLGEpPT5lK3QrKHI9PT1hLmxlbmd0aC0xP1wiXCI6dGhpcy5fZ2V0KHIpKSksXCJcIil9X2dldChlKXtyZXR1cm4gdGhpcy5fc2VwYXJhdG9yc1tlXT90aGlzLl9zZXBhcmF0b3JzW2VdOnRoaXMuX3NlcGFyYXRvcnMubGVuZ3RoPjA/dGhpcy5fc2VwYXJhdG9yc1t0aGlzLl9zZXBhcmF0b3JzLmxlbmd0aC0xXTpcIixcIn19dC5Kb2luV2l0aE1hbnlTZXBhcmF0b3JzPXJ9LDc5OTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcj12b2lkIDA7Y29uc3QgYT1yKDU0NDMpO3QubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXI9ZT0+bmV3IGEuTWF0aE1MRWxlbWVudFRvTGF0ZXhDb252ZXJ0ZXJBZGFwdGVyKGUpLnRvTGF0ZXhDb252ZXJ0ZXIoKX0sMjQyNDooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQubm9ybWFsaXplV2hpdGVTcGFjZXM9dm9pZCAwLHQubm9ybWFsaXplV2hpdGVTcGFjZXM9ZT0+ZS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpfSw3MTkyOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkJyYWNrZXRXcmFwcGVyPXZvaWQgMDtjb25zdCBhPXIoMTg1NSk7dC5CcmFja2V0V3JhcHBlcj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX29wZW49XCJ7XCIsdGhpcy5fY2xvc2U9XCJ9XCJ9d3JhcChlKXtyZXR1cm4gbmV3IGEuV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfX19LDUwMjU6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuR2VuZXJpY1dyYXBwZXI9dm9pZCAwO2NvbnN0IGE9cigxODU1KTt0LkdlbmVyaWNXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKGUsdCl7dGhpcy5fb3Blbj1cIlxcXFxsZWZ0XCIrZSx0aGlzLl9jbG9zZT1cIlxcXFxyaWdodFwiK3R9d3JhcChlKXtyZXR1cm4gbmV3IGEuV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfX19LDgyODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljV3JhcHBlcj10LlBhcmVudGhlc2lzV3JhcHBlcj10LkJyYWNrZXRXcmFwcGVyPXZvaWQgMDt2YXIgYT1yKDcxOTIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiQnJhY2tldFdyYXBwZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5CcmFja2V0V3JhcHBlcn19KTt2YXIgbj1yKDExNjgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiUGFyZW50aGVzaXNXcmFwcGVyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uUGFyZW50aGVzaXNXcmFwcGVyfX0pO3ZhciBvPXIoNTAyNSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJHZW5lcmljV3JhcHBlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBvLkdlbmVyaWNXcmFwcGVyfX0pfSwxMTY4OihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LlBhcmVudGhlc2lzV3JhcHBlcj12b2lkIDA7Y29uc3QgYT1yKDE4NTUpO3QuUGFyZW50aGVzaXNXcmFwcGVyPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5fb3Blbj1cIlxcXFxsZWZ0KFwiLHRoaXMuX2Nsb3NlPVwiXFxcXHJpZ2h0KVwifXdyYXAoZSl7cmV0dXJuIG5ldyBhLldyYXBwZXIodGhpcy5fb3Blbix0aGlzLl9jbG9zZSkud3JhcChlKX13cmFwSWZNb3JlVGhhbk9uZUNoYXIoZSl7cmV0dXJuIGUubGVuZ3RoPD0xP2U6dGhpcy53cmFwKGUpfX19LDE4NTU6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LldyYXBwZXI9dm9pZCAwLHQuV3JhcHBlcj1jbGFzc3tjb25zdHJ1Y3RvcihlLHQpe3RoaXMuX29wZW49ZSx0aGlzLl9jbG9zZT10fXdyYXAoZSl7cmV0dXJuIHRoaXMuX29wZW4rZSt0aGlzLl9jbG9zZX19fSwyNjk3OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5Wb2lkTWF0aE1MRWxlbWVudD12b2lkIDAsdC5Wb2lkTWF0aE1MRWxlbWVudD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMubmFtZT1cInZvaWRcIix0aGlzLnZhbHVlPVwiXCIsdGhpcy5jaGlsZHJlbj1bXSx0aGlzLmF0dHJpYnV0ZXM9e319fX0sNDc2MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljU3BhY2luZ1dyYXBwZXI9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0LkdlbmVyaWNTcGFjaW5nV3JhcHBlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe3JldHVybiB0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIiBcIil9fX0sOTM3NjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5HZW5lcmljVW5kZXJPdmVyPXZvaWQgMDtjb25zdCBhPXIoNzk5KSxuPXIoODkxNyksbz1yKDQ3Mik7dC5HZW5lcmljVW5kZXJPdmVyPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgbi5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKGUsMixyKTtjb25zdCBvPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMF0pLmNvbnZlcnQoKSxpPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKHRbMV0pLmNvbnZlcnQoKTtyZXR1cm4gdGhpcy5fYXBwbHlDb21tYW5kKG8saSl9X2FwcGx5Q29tbWFuZChlLHQpe2NvbnN0IHI9dGhpcy5fbWF0aG1sRWxlbWVudC5uYW1lLm1hdGNoKC91bmRlci8pP3MuVW5kZXI6cy5PdmVyO3JldHVybiBuZXcgaShyKS5hcHBseShlLHQpfX07Y2xhc3MgaXtjb25zdHJ1Y3RvcihlKXt0aGlzLl90eXBlPWV9YXBwbHkoZSx0KXtyZXR1cm4gby5sYXRleEFjY2VudHMuaW5jbHVkZXModCk/YCR7dH17JHtlfX1gOmAke3RoaXMuX2RlZmF1bHRDb21tYW5kfXske3R9fXske2V9fWB9Z2V0IF9kZWZhdWx0Q29tbWFuZCgpe3JldHVybiB0aGlzLl90eXBlPT09cy5VbmRlcj9cIlxcXFx1bmRlcnNldFwiOlwiXFxcXG92ZXJzZXRcIn19dmFyIHM7IWZ1bmN0aW9uKGUpe2VbZS5VbmRlcj0wXT1cIlVuZGVyXCIsZVtlLk92ZXI9MV09XCJPdmVyXCJ9KHN8fChzPXt9KSl9LDY5NTk6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVm9pZD10LkdlbmVyaWNVbmRlck92ZXI9dC5HZW5lcmljU3BhY2luZ1dyYXBwZXI9dC5NVHI9dC5NVGFibGU9dC5NVW5kZXJvdmVyPXQuTVRleHQ9dC5NTXVsdGlzY3JpcHRzPXQuTVN1YnN1cD10Lk1TdWI9dC5NU3VwPXQuTVBoYW50b209dC5NRXJyb3I9dC5NRW5jbG9zZT10Lk1BY3Rpb249dC5NUm9vdD10Lk1GcmFjPXQuTUZlbmNlZD10Lk1TcXJ0PXQuTU49dC5NTz10Lk1JPXQuTWF0aD12b2lkIDA7dmFyIGE9cigzOTMpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTWF0aFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhLk1hdGh9fSk7dmFyIG49cig3MDM3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1JXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG4uTUl9fSk7dmFyIG89cigzNDg3KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1PXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG8uTU99fSk7dmFyIGk9cig0NDY0KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1OXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGkuTU59fSk7dmFyIHM9cig4Njg2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1TcXJ0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuTVNxcnR9fSk7dmFyIGw9cig5NTExKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1GZW5jZWRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbC5NRmVuY2VkfX0pO3ZhciBjPXIoNjQ0MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNRnJhY1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLk1GcmFjfX0pO3ZhciB1PXIoNjA1Mik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNUm9vdFwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1Lk1Sb290fX0pO3ZhciBoPXIoMTY3OCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNQWN0aW9uXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGguTUFjdGlvbn19KTt2YXIgZD1yKDI2MzEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUVuY2xvc2VcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZC5NRW5jbG9zZX19KTt2YXIgbT1yKDE4NDApO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTUVycm9yXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG0uTUVycm9yfX0pO3ZhciBwPXIoNzQ0Myk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNUGhhbnRvbVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBwLk1QaGFudG9tfX0pO3ZhciBmPXIoNjkyNik7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNU3VwXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYuTVN1cH19KTt2YXIgeD1yKDI1NjQpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVN1YlwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB4Lk1TdWJ9fSk7dmFyIGc9cigxMzU4KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1TdWJzdXBcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZy5NU3Vic3VwfX0pO3ZhciB3PXIoODMwMyk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJNTXVsdGlzY3JpcHRzXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHcuTU11bHRpc2NyaXB0c319KTt2YXIgYj1yKDM5NTEpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVRleHRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYi5NVGV4dH19KTt2YXIgdj1yKDEyMjIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVVuZGVyb3ZlclwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB2Lk1VbmRlcm92ZXJ9fSk7dmFyIEM9cigyMzUwKTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIk1UYWJsZVwiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBDLk1UYWJsZX19KTt2YXIgQT1yKDE1ODYpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiTVRyXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEEuTVRyfX0pO3ZhciBFPXIoNDc2MCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJHZW5lcmljU3BhY2luZ1dyYXBwZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRS5HZW5lcmljU3BhY2luZ1dyYXBwZXJ9fSk7dmFyIF89cig5Mzc2KTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIkdlbmVyaWNVbmRlck92ZXJcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gXy5HZW5lcmljVW5kZXJPdmVyfX0pO3ZhciB5PXIoOTE2NSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJWb2lkXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHkuVm9pZH19KX0sMTY3ODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NQWN0aW9uPXZvaWQgMDtjb25zdCBhPXIoNzk5KTt0Lk1BY3Rpb249Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtjaGlsZHJlbjplfT10aGlzLl9tYXRobWxFbGVtZW50O3JldHVybiB0aGlzLl9pc1RvZ2dsZSgpP2UubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFxcXFxMb25ncmlnaHRhcnJvdyBcIik6KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZVswXSkuY29udmVydCgpfV9pc1RvZ2dsZSgpe2NvbnN0e2FjdGlvbnR5cGU6ZX09dGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzO3JldHVyblwidG9nZ2xlXCI9PT1lfHwhZX19fSwzOTM6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTWF0aD12b2lkIDA7Y29uc3QgYT1yKDc5OSksbj1yKDI0MjQpO3QuTWF0aD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0IGU9dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpO3JldHVybigwLG4ubm9ybWFsaXplV2hpdGVTcGFjZXMpKGUpfX19LDI2MzE6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTUVuY2xvc2U9dm9pZCAwO2NvbnN0IGE9cig3OTkpO3QuTUVuY2xvc2U9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdCBlPXRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFwiKTtyZXR1cm5cImFjdHVhcmlhbFwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxvdmVybGluZXtcXFxcbGVmdC4ke2V9XFxcXHJpZ2h0fH1gOlwicmFkaWNhbFwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxzcXJ0eyR7ZX19YDpbXCJib3hcIixcInJvdW5kZWRib3hcIixcImNpcmNsZVwiXS5pbmNsdWRlcyh0aGlzLl9ub3RhdGlvbik/YFxcXFxib3hlZHske2V9fWA6XCJsZWZ0XCI9PT10aGlzLl9ub3RhdGlvbj9gXFxcXGxlZnR8JHtlfWA6XCJyaWdodFwiPT09dGhpcy5fbm90YXRpb24/YCR7ZX1cXFxccmlnaHR8YDpcInRvcFwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxvdmVybGluZXske2V9fWA6XCJib3R0b21cIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcdW5kZXJsaW5leyR7ZX19YDpcInVwZGlhZ29uYWxzdHJpa2VcIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcY2FuY2VseyR7ZX19YDpcImRvd25kaWFnb25hbHN0cmlrZVwiPT09dGhpcy5fbm90YXRpb24/YFxcXFxiY2FuY2VseyR7ZX19YDpcInVwZGlhZ29uYWxhcnJvd1wiPT09dGhpcy5fbm90YXRpb24/YFxcXFxjYW5jZWx0b3t9eyR7ZX19YDpbXCJ2ZXJ0aWNhbHN0cmlrZVwiLFwiaG9yaXpvbnRhbHN0cmlrZVwiXS5pbmNsdWRlcyh0aGlzLl9ub3RhdGlvbik/YFxcXFxoY2FuY2VseyR7ZX19YDpcIm1hZHJ1d2JcIj09PXRoaXMuX25vdGF0aW9uP2BcXFxcdW5kZXJsaW5leyR7ZX1cXFxccmlnaHR8fWA6XCJwaGFzb3JhbmdsZVwiPT09dGhpcy5fbm90YXRpb24/YHtcXFxcYW5nbGUgXFxcXHVuZGVybGluZXske2V9fX1gOmBcXFxcb3ZlcmxpbmV7XFxcXGxlZnQuXFxcXHJpZ2h0KSR7ZX19YH1nZXQgX25vdGF0aW9uKCl7cmV0dXJuIHRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5ub3RhdGlvbnx8XCJsb25nZGl2XCJ9fX0sMTg0MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRXJyb3I9dm9pZCAwO2NvbnN0IGE9cig3OTkpO3QuTUVycm9yPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuYFxcXFxjb2xvcntyZWR9eyR7dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpfX1gfX19LDk1MTE6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTUZlbmNlZD12b2lkIDA7Y29uc3QgYT1yKDc5OSksbj1yKDQyNzkpO3QuTUZlbmNlZD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWUsdGhpcy5fb3Blbj10aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMub3Blbnx8XCJcIix0aGlzLl9jbG9zZT10aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMuY2xvc2V8fFwiXCIsdGhpcy5fc2VwYXJhdG9ycz1BcnJheS5mcm9tKHRoaXMuX21hdGhtbEVsZW1lbnQuYXR0cmlidXRlcy5zZXBhcmF0b3JzfHxcIlwiKX1jb252ZXJ0KCl7Y29uc3QgZT10aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLm1hcCgoZT0+KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkpKS5tYXAoKGU9PmUuY29udmVydCgpKSk7cmV0dXJuIHRoaXMuX2lzVGhlcmVSZWxhdGl2ZU9mTmFtZSh0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLFwibXRhYmxlXCIpP25ldyBpKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLmFwcGx5KGUpOm5ldyBvKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UsdGhpcy5fc2VwYXJhdG9ycykuYXBwbHkoZSl9X2lzVGhlcmVSZWxhdGl2ZU9mTmFtZShlLHQpe3JldHVybiBlLnNvbWUoKGU9PmUubmFtZT09PXR8fHRoaXMuX2lzVGhlcmVSZWxhdGl2ZU9mTmFtZShlLmNoaWxkcmVuLHQpKSl9fTtjbGFzcyBve2NvbnN0cnVjdG9yKGUsdCxyKXt0aGlzLl9vcGVuPWV8fFwiKFwiLHRoaXMuX2Nsb3NlPXR8fFwiKVwiLHRoaXMuX3NlcGFyYXRvcnM9cn1hcHBseShlKXtjb25zdCB0PW4uSm9pbldpdGhNYW55U2VwYXJhdG9ycy5qb2luKGUsdGhpcy5fc2VwYXJhdG9ycyk7cmV0dXJuIG5ldyBuLkdlbmVyaWNXcmFwcGVyKHRoaXMuX29wZW4sdGhpcy5fY2xvc2UpLndyYXAodCl9fWNsYXNzIGl7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9nZW5lcmljQ29tbWFuZD1cIm1hdHJpeFwiLHRoaXMuX3NlcGFyYXRvcnM9bmV3IHMoZSx0KX1hcHBseShlKXtjb25zdCB0PXRoaXMuX2NvbW1hbmQscj1gXFxcXGJlZ2lueyR7dH19XFxuJHtlLmpvaW4oXCJcIil9XFxuXFxcXGVuZHske3R9fWA7cmV0dXJuIHQ9PT10aGlzLl9nZW5lcmljQ29tbWFuZD90aGlzLl9zZXBhcmF0b3JzLndyYXAocik6cn1nZXQgX2NvbW1hbmQoKXtyZXR1cm4gdGhpcy5fc2VwYXJhdG9ycy5hcmVQYXJlbnRoZXNlcygpP1wicG1hdHJpeFwiOnRoaXMuX3NlcGFyYXRvcnMuYXJlU3F1YXJlQnJhY2tldHMoKT9cImJtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZUJyYWNrZXRzKCk/XCJCbWF0cml4XCI6dGhpcy5fc2VwYXJhdG9ycy5hcmVEaXZpZGVzKCk/XCJ2bWF0cml4XCI6dGhpcy5fc2VwYXJhdG9ycy5hcmVQYXJhbGxlbHMoKT9cIlZtYXRyaXhcIjp0aGlzLl9zZXBhcmF0b3JzLmFyZU5vdEVxdWFsKCk/dGhpcy5fZ2VuZXJpY0NvbW1hbmQ6XCJibWF0cml4XCJ9fWNsYXNzIHN7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl9vcGVuPWUsdGhpcy5fY2xvc2U9dH13cmFwKGUpe3JldHVybiBuZXcgbi5HZW5lcmljV3JhcHBlcih0aGlzLl9vcGVuLHRoaXMuX2Nsb3NlKS53cmFwKGUpfWFyZVBhcmVudGhlc2VzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCIoXCIsXCIpXCIpfWFyZVNxdWFyZUJyYWNrZXRzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCJbXCIsXCJdXCIpfWFyZUJyYWNrZXRzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCJ7XCIsXCJ9XCIpfWFyZURpdmlkZXMoKXtyZXR1cm4gdGhpcy5fY29tcGFyZShcInxcIixcInxcIil9YXJlUGFyYWxsZWxzKCl7cmV0dXJuIHRoaXMuX2NvbXBhcmUoXCJ8fFwiLFwifHxcIil9YXJlTm90RXF1YWwoKXtyZXR1cm4gdGhpcy5fb3BlbiE9PXRoaXMuX2Nsb3NlfV9jb21wYXJlKGUsdCl7cmV0dXJuIHRoaXMuX29wZW49PT1lJiZ0aGlzLl9jbG9zZT09PXR9fX0sNjQ0MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NRnJhYz12b2lkIDA7Y29uc3QgYT1yKDg5MTcpLG49cig0Mjc5KTt0Lk1GcmFjPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7Y2hpbGRyZW46ZSxuYW1lOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj1lLmxlbmd0aDtpZigyIT09cil0aHJvdyBuZXcgYS5JbnZhbGlkTnVtYmVyT2ZDaGlsZHJlbkVycm9yKHQsMixyKTtjb25zdCBvPSgwLG4ubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGVbMF0pLmNvbnZlcnQoKSxpPSgwLG4ubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGVbMV0pLmNvbnZlcnQoKTtyZXR1cm4gdGhpcy5faXNCZXZlbGxlZCgpP2Ake3RoaXMuX3dyYXBJZk1vcmVUaGFuT25lQ2hhcihvKX0vJHt0aGlzLl93cmFwSWZNb3JlVGhhbk9uZUNoYXIoaSl9YDpgXFxcXGZyYWN7JHtvfX17JHtpfX1gfV93cmFwSWZNb3JlVGhhbk9uZUNoYXIoZSl7cmV0dXJuKG5ldyBuLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcElmTW9yZVRoYW5PbmVDaGFyKGUpfV9pc0JldmVsbGVkKCl7cmV0dXJuISF0aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXMuYmV2ZWxsZWR9fX0sNzAzNzooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NST12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig1NDA2KSxvPXIoNjEyMik7dC5NST1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnV0ZjhDb252ZXJ0ZXI9bmV3IG8uSGFzaFVURjhUb0x0WENvbnZlcnRlcix0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0IGU9KDAsYS5ub3JtYWxpemVXaGl0ZVNwYWNlcykodGhpcy5fbWF0aG1sRWxlbWVudC52YWx1ZSk7aWYoXCIgXCI9PT1lKXJldHVybiBpLmFwcGx5KGUpO2NvbnN0IHQ9ZS50cmltKCkscj1pLmFwcGx5KHQpLG49dGhpcy51dGY4Q29udmVydGVyLmNvbnZlcnQocik7cmV0dXJuIG4hPT1yP246dGhpcy53cmFwSW5NYXRoVmFyaWFudChyLHRoaXMuZ2V0TWF0aFZhcmlhbnQodGhpcy5fbWF0aG1sRWxlbWVudC5hdHRyaWJ1dGVzKSl9Z2V0TWF0aFZhcmlhbnQoZSl7aWYoZSYmZS5tYXRodmFyaWFudClyZXR1cm4gZS5tYXRodmFyaWFudH13cmFwSW5NYXRoVmFyaWFudChlLHQpe3N3aXRjaCh0KXtjYXNlXCJib2xkXCI6cmV0dXJuYFxcXFxtYXRoYmZ7JHtlfX1gO2Nhc2VcIml0YWxpY1wiOnJldHVybmBcXFxcbWF0aGl0eyR7ZX19YDtjYXNlXCJib2xkLWl0YWxpY1wiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoaXR7JHtlfX19YDtjYXNlXCJkb3VibGUtc3RydWNrXCI6cmV0dXJuYFxcXFxtYXRoYmJ7JHtlfX1gO2Nhc2VcImJvbGQtZnJha3R1clwiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoZnJha3ske2V9fX1gO2Nhc2VcInNjcmlwdFwiOnJldHVybmBcXFxcbWF0aGNhbHske2V9fWA7Y2FzZVwiYm9sZC1zY3JpcHRcIjpyZXR1cm5gXFxcXG1hdGhiZntcXFxcbWF0aGNhbHske2V9fX1gO2Nhc2VcImZyYWt0dXJcIjpyZXR1cm5gXFxcXG1hdGhmcmFreyR7ZX19YDtjYXNlXCJzYW5zLXNlcmlmXCI6cmV0dXJuYFxcXFxtYXRoc2Z7JHtlfX1gO2Nhc2VcImJvbGQtc2Fucy1zZXJpZlwiOnJldHVybmBcXFxcbWF0aGJme1xcXFxtYXRoc2Z7JHtlfX19YDtjYXNlXCJzYW5zLXNlcmlmLWl0YWxpY1wiOnJldHVybmBcXFxcbWF0aHNme1xcXFxtYXRoaXR7JHtlfX19YDtjYXNlXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCI6cmV0dXJuYFxcXFxtYXRoYmZ7XFxcXG1hdGhzZntcXFxcbWF0aGl0eyR7ZX19fX1gO2Nhc2VcIm1vbm9zcGFjZVwiOnJldHVybmBcXFxcbWF0aHR0eyR7ZX19YDtkZWZhdWx0OnJldHVybiBlfX19O2NsYXNzIGl7Y29uc3RydWN0b3IoZSl7dGhpcy5fdmFsdWU9ZX1zdGF0aWMgYXBwbHkoZSl7cmV0dXJuIG5ldyBpKGUpLl9hcHBseSgpfV9hcHBseSgpe3JldHVybiB0aGlzLl9maW5kQnlDaGFyYWN0ZXIoKXx8dGhpcy5fZmluZEJ5R2x5cGgoKXx8dGhpcy5fZmluZEJ5TnVtYmVyKCl8fChuZXcgby5IYXNoVVRGOFRvTHRYQ29udmVydGVyKS5jb252ZXJ0KHRoaXMuX3ZhbHVlKX1fZmluZEJ5Q2hhcmFjdGVyKCl7cmV0dXJuIG4uYWxsTWF0aFN5bWJvbHNCeUNoYXJbdGhpcy5fdmFsdWVdfV9maW5kQnlHbHlwaCgpe3JldHVybiBuLmFsbE1hdGhTeW1ib2xzQnlHbHlwaFt0aGlzLl92YWx1ZV19X2ZpbmRCeU51bWJlcigpe3JldHVybiBuLm1hdGhOdW1iZXJCeUdseXBoW3RoaXMuX3ZhbHVlXX19fSw4MzAzOihlLHQscik9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1NdWx0aXNjcmlwdHM9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NTXVsdGlzY3JpcHRzPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3R7bmFtZTplLGNoaWxkcmVuOnR9PXRoaXMuX21hdGhtbEVsZW1lbnQscj10Lmxlbmd0aDtpZihyPDMpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDMscixcImF0IGxlYXN0XCIpO2NvbnN0IG89KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFswXSkuY29udmVydCgpO3JldHVybiB0aGlzLl9wcmVzY3JpcHRMYXRleCgpK3RoaXMuX3dyYXBJblBhcmVudGhlc2lzSWZUaGVyZUlzU3BhY2UobykrdGhpcy5fcG9zdHNjcmlwdExhdGV4KCl9X3ByZXNjcmlwdExhdGV4KCl7Y29uc3R7Y2hpbGRyZW46ZX09dGhpcy5fbWF0aG1sRWxlbWVudDtsZXQgdCxyO2lmKHRoaXMuX2lzUHJlc2NyaXB0cyhlWzFdKSl0PWVbMl0scj1lWzNdO2Vsc2V7aWYoIXRoaXMuX2lzUHJlc2NyaXB0cyhlWzNdKSlyZXR1cm5cIlwiO3Q9ZVs0XSxyPWVbNV19cmV0dXJuYFxcXFxfeyR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodCkuY29udmVydCgpfX1eeyR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikocikuY29udmVydCgpfX1gfV9wb3N0c2NyaXB0TGF0ZXgoKXtjb25zdHtjaGlsZHJlbjplfT10aGlzLl9tYXRobWxFbGVtZW50O2lmKHRoaXMuX2lzUHJlc2NyaXB0cyhlWzFdKSlyZXR1cm5cIlwiO2NvbnN0IHQ9ZVsxXSxyPWVbMl07cmV0dXJuYF97JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0KS5jb252ZXJ0KCl9fV57JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShyKS5jb252ZXJ0KCl9fWB9X3dyYXBJblBhcmVudGhlc2lzSWZUaGVyZUlzU3BhY2UoZSl7cmV0dXJuIGUubWF0Y2goL1xccysvZyk/KG5ldyBhLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcChlKTplfV9pc1ByZXNjcmlwdHMoZSl7cmV0dXJuXCJtcHJlc2NyaXB0c1wiPT09KG51bGw9PWU/dm9pZCAwOmUubmFtZSl9fX0sNDQ2NDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NTj12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig1NDA2KTt0Lk1OPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT0oMCxhLm5vcm1hbGl6ZVdoaXRlU3BhY2VzKSh0aGlzLl9tYXRobWxFbGVtZW50LnZhbHVlKS50cmltKCk7cmV0dXJuIG4ubWF0aE51bWJlckJ5R2x5cGhbZV18fGV9fX0sMzQ4NzooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NTz12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig1NDA2KTt0Lk1PPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7Y29uc3QgZT0oMCxhLm5vcm1hbGl6ZVdoaXRlU3BhY2VzKSh0aGlzLl9tYXRobWxFbGVtZW50LnZhbHVlKS50cmltKCk7cmV0dXJuIG8ub3BlcmF0ZShlKX19O2NsYXNzIG97Y29uc3RydWN0b3IoZSl7dGhpcy5fdmFsdWU9ZX1zdGF0aWMgb3BlcmF0ZShlKXtyZXR1cm4gbmV3IG8oZSkuX29wZXJhdGUoKX1fb3BlcmF0ZSgpe3JldHVybiB0aGlzLl9maW5kQnlDaGFyYWN0ZXIoKXx8dGhpcy5fZmluZEJ5R2x5cGgoKXx8dGhpcy5fZmluZEJ5TnVtYmVyKCl8fChuZXcgbi5IYXNoVVRGOFRvTHRYQ29udmVydGVyKS5jb252ZXJ0KHRoaXMuX3ZhbHVlKX1fZmluZEJ5Q2hhcmFjdGVyKCl7cmV0dXJuIG4uYWxsTWF0aE9wZXJhdG9yc0J5Q2hhclt0aGlzLl92YWx1ZV19X2ZpbmRCeUdseXBoKCl7cmV0dXJuIG4uYWxsTWF0aE9wZXJhdG9yc0J5R2x5cGhbdGhpcy5fdmFsdWVdfV9maW5kQnlOdW1iZXIoKXtyZXR1cm4gbi5tYXRoTnVtYmVyQnlHbHlwaFt0aGlzLl92YWx1ZV19fX0sNzQ0MzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVBoYW50b209dm9pZCAwLHQuTVBoYW50b209Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm5cIlwifX19LDYwNTI6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVJvb3Q9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KSxuPXIoODkxNyk7dC5NUm9vdD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMiE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDIscik7Y29uc3Qgbz0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzBdKS5jb252ZXJ0KCk7cmV0dXJuYFxcXFxzcXJ0WyR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFsxXSkuY29udmVydCgpfV17JHtvfX1gfX19LDg2ODY6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVNxcnQ9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0Lk1TcXJ0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuYFxcXFxzcXJ0eyR7dGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgXCIpfX1gfX19LDI1NjQ6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVN1Yj12b2lkIDA7Y29uc3QgYT1yKDQyNzkpLG49cig4OTE3KTt0Lk1TdWI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHtuYW1lOmUsY2hpbGRyZW46dH09dGhpcy5fbWF0aG1sRWxlbWVudCxyPXQubGVuZ3RoO2lmKDIhPT1yKXRocm93IG5ldyBuLkludmFsaWROdW1iZXJPZkNoaWxkcmVuRXJyb3IoZSwyLHIpO2NvbnN0IGE9dFswXSxvPXRbMV07cmV0dXJuYCR7dGhpcy5faGFuZGxlQmFzZUNoaWxkKGEpfV8ke3RoaXMuX2hhbmRsZVN1YnNjcmlwdENoaWxkKG8pfWB9X2hhbmRsZUJhc2VDaGlsZChlKXtjb25zdCB0PWUuY2hpbGRyZW4scj0oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKS5jb252ZXJ0KCk7cmV0dXJuIHQubGVuZ3RoPD0xP3I6KG5ldyBhLlBhcmVudGhlc2lzV3JhcHBlcikud3JhcElmTW9yZVRoYW5PbmVDaGFyKHIpfV9oYW5kbGVTdWJzY3JpcHRDaGlsZChlKXtjb25zdCB0PSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4obmV3IGEuQnJhY2tldFdyYXBwZXIpLndyYXAodCl9fX0sMTM1ODooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3Vic3VwPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVN1YnN1cD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMyE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDMscik7Y29uc3QgYT10WzBdLG89dFsxXSxpPXRbMl07cmV0dXJuYCR7dGhpcy5faGFuZGxlQmFzZUNoaWxkKGEpfV8ke3RoaXMuX2hhbmRsZVN1YnNjcmlwdENoaWxkKG8pfV4ke3RoaXMuX2hhbmRsZVN1cGVyc2NyaXB0Q2hpbGQoaSl9YH1faGFuZGxlQmFzZUNoaWxkKGUpe2NvbnN0IHQ9ZS5jaGlsZHJlbixyPSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4gdC5sZW5ndGg8PTE/cjoobmV3IGEuUGFyZW50aGVzaXNXcmFwcGVyKS53cmFwSWZNb3JlVGhhbk9uZUNoYXIocil9X2hhbmRsZVN1YnNjcmlwdENoaWxkKGUpe2NvbnN0IHQ9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybihuZXcgYS5CcmFja2V0V3JhcHBlcikud3JhcCh0KX1faGFuZGxlU3VwZXJzY3JpcHRDaGlsZChlKXtjb25zdCB0PSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4obmV3IGEuQnJhY2tldFdyYXBwZXIpLndyYXAodCl9fX0sNjkyNjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NU3VwPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVN1cD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMiE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDIscik7Y29uc3QgYT10WzBdLG89dFsxXTtyZXR1cm5gJHt0aGlzLl9oYW5kbGVCYXNlQ2hpbGQoYSl9XiR7dGhpcy5faGFuZGxlRXhwb25lbnRDaGlsZChvKX1gfV9oYW5kbGVCYXNlQ2hpbGQoZSl7Y29uc3QgdD1lLmNoaWxkcmVuLHI9KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikoZSkuY29udmVydCgpO3JldHVybiB0Lmxlbmd0aDw9MT9yOihuZXcgYS5QYXJlbnRoZXNpc1dyYXBwZXIpLndyYXBJZk1vcmVUaGFuT25lQ2hhcihyKX1faGFuZGxlRXhwb25lbnRDaGlsZChlKXtjb25zdCB0PSgwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpLmNvbnZlcnQoKTtyZXR1cm4obmV3IGEuQnJhY2tldFdyYXBwZXIpLndyYXAodCl9fX0sMjM1MDooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVGFibGU9dm9pZCAwO2NvbnN0IGE9cig0Mjc5KTt0Lk1UYWJsZT1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWUsdGhpcy5fYWRkRmxhZ1JlY3Vyc2l2ZUlmTmFtZSh0aGlzLl9tYXRobWxFbGVtZW50LmNoaWxkcmVuLFwibXRhYmxlXCIsXCJpbm5lclRhYmxlXCIpfWNvbnZlcnQoKXtjb25zdCBlPXRoaXMuX21hdGhtbEVsZW1lbnQuY2hpbGRyZW4ubWFwKChlPT4oMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKShlKSkpLm1hcCgoZT0+ZS5jb252ZXJ0KCkpKS5qb2luKFwiIFxcXFxcXFxcXFxuXCIpO3JldHVybiB0aGlzLl9oYXNGbGFnKFwiaW5uZXJUYWJsZVwiKT90aGlzLl93cmFwKGUpOmV9X3dyYXAoZSl7cmV0dXJuYFxcXFxiZWdpbnttYXRyaXh9JHtlfVxcXFxlbmR7bWF0cml4fWB9X2FkZEZsYWdSZWN1cnNpdmVJZk5hbWUoZSx0LHIpe2UuZm9yRWFjaCgoZT0+e2UubmFtZT09PXQmJihlLmF0dHJpYnV0ZXNbcl09ciksdGhpcy5fYWRkRmxhZ1JlY3Vyc2l2ZUlmTmFtZShlLmNoaWxkcmVuLHQscil9KSl9X2hhc0ZsYWcoZSl7cmV0dXJuISF0aGlzLl9tYXRobWxFbGVtZW50LmF0dHJpYnV0ZXNbZV19fX0sMzk1MTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVGV4dD12b2lkIDA7Y29uc3QgYT1yKDcwMzcpO3QuTVRleHQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtjb25zdHthdHRyaWJ1dGVzOmUsdmFsdWU6dH09dGhpcy5fbWF0aG1sRWxlbWVudDtyZXR1cm5bLi4udF0ubWFwKChlPT4vXlthLXpBLVowLTldJC8udGVzdChlKXx8XCIgXCI9PT1lP3t2YWx1ZTplLGlzQWxwaGFudW1lcmljOiEwfTp7dmFsdWU6ZSxpc0FscGhhbnVtZXJpYzohMX0pKS5yZWR1Y2UoKChlLHQpPT57aWYodC5pc0FscGhhbnVtZXJpYyl7Y29uc3Qgcj1lW2UubGVuZ3RoLTFdO2lmKHImJnIuaXNBbHBoYW51bWVyaWMpcmV0dXJuIHIudmFsdWUrPXQudmFsdWUsZX1yZXR1cm5bLi4uZSx0XX0pLFtdKS5tYXAoKHQ9PnQuaXNBbHBoYW51bWVyaWM/bmV3IG4oZS5tYXRodmFyaWFudCkuYXBwbHkodC52YWx1ZSk6bmV3IGEuTUkoe25hbWU6XCJtaVwiLGF0dHJpYnV0ZXM6e30sY2hpbGRyZW46W10sdmFsdWU6dC52YWx1ZX0pLmNvbnZlcnQoKSkpLmpvaW4oXCJcIil9fTtjbGFzcyBue2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGh2YXJpYW50PWV8fFwibm9ybWFsXCJ9YXBwbHkoZSl7cmV0dXJuIHRoaXMuX2NvbW1hbmRzLnJlZHVjZSgoKHQscixhKT0+MD09PWE/YCR7cn17JHtlfX1gOmAke3J9eyR7dH19YCksXCJcIil9Z2V0IF9jb21tYW5kcygpe3N3aXRjaCh0aGlzLl9tYXRodmFyaWFudCl7Y2FzZVwiYm9sZFwiOnJldHVybltcIlxcXFx0ZXh0YmZcIl07Y2FzZVwiaXRhbGljXCI6cmV0dXJuW1wiXFxcXHRleHRpdFwiXTtjYXNlXCJib2xkLWl0YWxpY1wiOnJldHVybltcIlxcXFx0ZXh0aXRcIixcIlxcXFx0ZXh0YmZcIl07Y2FzZVwiZG91YmxlLXN0cnVja1wiOnJldHVybltcIlxcXFxtYXRoYmJcIl07Y2FzZVwibW9ub3NwYWNlXCI6cmV0dXJuW1wiXFxcXG1hdGh0dFwiXTtjYXNlXCJib2xkLWZyYWt0dXJcIjpjYXNlXCJmcmFrdHVyXCI6cmV0dXJuW1wiXFxcXG1hdGhmcmFrXCJdO2RlZmF1bHQ6cmV0dXJuW1wiXFxcXHRleHRcIl19fX19LDE1ODY6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTVRyPXZvaWQgMDtjb25zdCBhPXIoNDI3OSk7dC5NVHI9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy5fbWF0aG1sRWxlbWVudD1lfWNvbnZlcnQoKXtyZXR1cm4gdGhpcy5fbWF0aG1sRWxlbWVudC5jaGlsZHJlbi5tYXAoKGU9PigwLGEubWF0aE1MRWxlbWVudFRvTGFUZVhDb252ZXJ0ZXIpKGUpKSkubWFwKChlPT5lLmNvbnZlcnQoKSkpLmpvaW4oXCIgJiBcIil9fX0sMTIyMjooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5NVW5kZXJvdmVyPXZvaWQgMDtjb25zdCBhPXIoNDI3OSksbj1yKDg5MTcpO3QuTVVuZGVyb3Zlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRobWxFbGVtZW50PWV9Y29udmVydCgpe2NvbnN0e25hbWU6ZSxjaGlsZHJlbjp0fT10aGlzLl9tYXRobWxFbGVtZW50LHI9dC5sZW5ndGg7aWYoMyE9PXIpdGhyb3cgbmV3IG4uSW52YWxpZE51bWJlck9mQ2hpbGRyZW5FcnJvcihlLDMscik7cmV0dXJuYCR7KDAsYS5tYXRoTUxFbGVtZW50VG9MYVRlWENvbnZlcnRlcikodFswXSkuY29udmVydCgpfV97JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzFdKS5jb252ZXJ0KCl9fV57JHsoMCxhLm1hdGhNTEVsZW1lbnRUb0xhVGVYQ29udmVydGVyKSh0WzJdKS5jb252ZXJ0KCl9fWB9fX0sOTE2NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuVm9pZD12b2lkIDAsdC5Wb2lkPWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMuX21hdGhtbEVsZW1lbnQ9ZX1jb252ZXJ0KCl7cmV0dXJuXCJcIn19fSw1NDQzOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX3NldE1vZHVsZURlZmF1bHR8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pfTpmdW5jdGlvbihlLHQpe2UuZGVmYXVsdD10fSksbz10aGlzJiZ0aGlzLl9faW1wb3J0U3Rhcnx8ZnVuY3Rpb24oZSl7aWYoZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciB0PXt9O2lmKG51bGwhPWUpZm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCIhPT1yJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxyKSYmYSh0LGUscik7cmV0dXJuIG4odCxlKSx0fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lk1hdGhNTEVsZW1lbnRUb0xhdGV4Q29udmVydGVyQWRhcHRlcj12b2lkIDA7Y29uc3QgaT1vKHIoNjk1OSkpLHM9cigyNjk3KTt0Lk1hdGhNTEVsZW1lbnRUb0xhdGV4Q29udmVydGVyQWRhcHRlcj1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLl9tYXRoTUxFbGVtZW50PW51bGwhPWU/ZTpuZXcgcy5Wb2lkTWF0aE1MRWxlbWVudH10b0xhdGV4Q29udmVydGVyKCl7Y29uc3R7bmFtZTplfT10aGlzLl9tYXRoTUxFbGVtZW50O3JldHVybiBuZXcobFtlXXx8aS5HZW5lcmljU3BhY2luZ1dyYXBwZXIpKHRoaXMuX21hdGhNTEVsZW1lbnQpfX07Y29uc3QgbD17bWF0aDppLk1hdGgsbWk6aS5NSSxtbzppLk1PLG1uOmkuTU4sbXNxcnQ6aS5NU3FydCxtZmVuY2VkOmkuTUZlbmNlZCxtZnJhYzppLk1GcmFjLG1yb290OmkuTVJvb3QsbWFjdGlvbjppLk1BY3Rpb24sbWVuY2xvc2U6aS5NRW5jbG9zZSxtZXJyb3I6aS5NRXJyb3IsbXBoYW50b206aS5NUGhhbnRvbSxtc3VwOmkuTVN1cCxtc3ViOmkuTVN1Yixtc3Vic3VwOmkuTVN1YnN1cCxtbXVsdGlzY3JpcHRzOmkuTU11bHRpc2NyaXB0cyxtdGV4dDppLk1UZXh0LG11bmRlcm92ZXI6aS5NVW5kZXJvdmVyLG10YWJsZTppLk1UYWJsZSxtdHI6aS5NVHIsbW92ZXI6aS5HZW5lcmljVW5kZXJPdmVyLG11bmRlcjppLkdlbmVyaWNVbmRlck92ZXIsbXJvdzppLkdlbmVyaWNTcGFjaW5nV3JhcHBlcixtcGFkZGVkOmkuR2VuZXJpY1NwYWNpbmdXcmFwcGVyLHZvaWQ6aS5Wb2lkfX0sNTI0MzooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuRXJyb3JIYW5kbGVyPXZvaWQgMCx0LkVycm9ySGFuZGxlcj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuX2Vycm9ycz1bXSx0aGlzLmVycm9yTG9jYXRvcj17fX1maXhFcnJvcihlLHQpe3JldHVybiB0aGlzLl9pc01pc3NpbmdBdHRyaWJ1dGVWYWx1ZUVycm9yKHQpPyh0aGlzLl9lcnJvcnMucHVzaCh0KSx0aGlzLl9maXhNaXNzaW5nQXR0cmlidXRlKHQsZSkpOmV9aXNUaGVyZUFueUVycm9ycygpe3JldHVybiB0aGlzLl9lcnJvcnMubGVuZ3RoPjB9Y2xlYW5FcnJvcnMoKXt0aGlzLl9lcnJvcnM9W119X2ZpeE1pc3NpbmdBdHRyaWJ1dGUoZSx0KXtjb25zdCByPWUuc3BsaXQoJ1wiJylbMV07aWYocilyZXR1cm4gdC5yZXBsYWNlKHRoaXMuX21hdGNoTWlzc2luZ1ZhbHVlRm9yQXR0cmlidXRlKHIpLFwiXCIpO2Zvcig7dGhpcy5fbWF0aEdlbmVyaWNNaXNzaW5nVmFsdWUoKS5leGVjKHQpOyl0PXQucmVwbGFjZSh0aGlzLl9tYXRoR2VuZXJpY01pc3NpbmdWYWx1ZSgpLFwiJDEkM1wiKTtyZXR1cm4gdH1fbWF0Y2hNaXNzaW5nVmFsdWVGb3JBdHRyaWJ1dGUoZSl7cmV0dXJuIG5ldyBSZWdFeHAoYCgke2V9PSg/IShcInwnKSkpfCgke2V9KD8hKFwifCcpKSlgLFwiZ21cIil9X21hdGhHZW5lcmljTWlzc2luZ1ZhbHVlKCl7cmV0dXJuLyhcXDwuKiApKFxcdys9KD8hXFxcInxcXCcpKSguKlxcPikvZ219X2lzTWlzc2luZ0F0dHJpYnV0ZVZhbHVlRXJyb3IoZSl7cmV0dXJuISFlLmluY2x1ZGVzKFwiYXR0cmlidXRlXCIpJiYhIWUuaW5jbHVkZXMoXCJtaXNzZWRcIil8fGUuaW5jbHVkZXMoXCJhdHRyaWJ1dGUgdmFsdWUgbWlzc2VkXCIpfX19LDkyMDg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19jcmVhdGVCaW5kaW5nfHwoT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKTt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7biYmIShcImdldFwiaW4gbj8hdC5fX2VzTW9kdWxlOm4ud3JpdGFibGV8fG4uY29uZmlndXJhYmxlKXx8KG49e2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRbcl19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsYSxuKX06ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9ciksZVthXT10W3JdfSksbj10aGlzJiZ0aGlzLl9fZXhwb3J0U3Rhcnx8ZnVuY3Rpb24oZSx0KXtmb3IodmFyIHIgaW4gZSlcImRlZmF1bHRcIj09PXJ8fE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpfHxhKHQsZSxyKX07T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbihyKDk1NDgpLHQpLG4ocig1MjQzKSx0KSxuKHIoMTEwMSksdCl9LDExMDE6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LkVsZW1lbnRzVG9NYXRoTUxBZGFwdGVyPXZvaWQgMCx0LkVsZW1lbnRzVG9NYXRoTUxBZGFwdGVyPWNsYXNze2NvbnZlcnQoZSl7cmV0dXJuIGUuZmlsdGVyKChlPT52b2lkIDAhPT1lLnRhZ05hbWUpKS5tYXAoKGU9PnRoaXMuX2NvbnZlcnRFbGVtZW50KGUpKSl9X2NvbnZlcnRFbGVtZW50KGUpe3JldHVybntuYW1lOmUudGFnTmFtZSxhdHRyaWJ1dGVzOnRoaXMuX2NvbnZlcnRFbGVtZW50QXR0cmlidXRlcyhlLmF0dHJpYnV0ZXMpLHZhbHVlOnRoaXMuX2hhc0VsZW1lbnRDaGlsZChlKT9cIlwiOmUudGV4dENvbnRlbnR8fFwiXCIsY2hpbGRyZW46dGhpcy5faGFzRWxlbWVudENoaWxkKGUpP3RoaXMuY29udmVydChBcnJheS5mcm9tKGUuY2hpbGROb2RlcykpOltdfX1fY29udmVydEVsZW1lbnRBdHRyaWJ1dGVzKGUpe3JldHVybiBBcnJheS5mcm9tKGUpLnJlZHVjZSgoKGUsdCk9Pk9iamVjdC5hc3NpZ24oe1t0Lm5vZGVOYW1lXTp0Lm5vZGVWYWx1ZT09PXQubm9kZU5hbWU/XCJcIjp0Lm5vZGVWYWx1ZX0sZSkpLHt9KX1faGFzRWxlbWVudENoaWxkKGUpe2NvbnN0IHQ9ZS5jaGlsZE5vZGVzO3JldHVybiEhdCYmMCE9PXQubGVuZ3RoJiZ0aGlzLl9pc1RoZXJlQW55Tm9UZXh0Tm9kZSh0KX1faXNUaGVyZUFueU5vVGV4dE5vZGUoZSl7cmV0dXJuIEFycmF5LmZyb20oZSkuc29tZSgoZT0+XCIjdGV4dFwiIT09ZS5ub2RlTmFtZSkpfX19LDk1NDg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXRoaXMmJnRoaXMuX19pbXBvcnREZWZhdWx0fHxmdW5jdGlvbihlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuWG1sVG9NYXRoTUxBZGFwdGVyPXZvaWQgMDtjb25zdCBuPWEocig4OTc4KSk7dC5YbWxUb01hdGhNTEFkYXB0ZXI9Y2xhc3N7Y29uc3RydWN0b3IoZSx0KXt0aGlzLl94bWw9XCJcIix0aGlzLl9lbGVtZW50c0NvbnZlcnRvcj1lLHRoaXMuX2Vycm9ySGFuZGxlcj10LHRoaXMuX3htbERPTT1uZXcgbi5kZWZhdWx0LkRPTVBhcnNlcih7bG9jYXRvcjp0aGlzLl9lcnJvckhhbmRsZXIuZXJyb3JMb2NhdG9yLGVycm9ySGFuZGxlcjp0aGlzLl9maXhFcnJvci5iaW5kKHRoaXMpfSl9Y29udmVydChlKXtyZXR1cm4gdGhpcy5feG1sPXRoaXMuX3JlbW92ZUxpbmVCcmVha3MoZSksdGhpcy5feG1sPXRoaXMuX3JlbW92ZU1zV29yZFByZWZpeGVzKHRoaXMuX3htbCksdGhpcy5fZWxlbWVudHNDb252ZXJ0b3IuY29udmVydCh0aGlzLl9tYXRoTUxFbGVtZW50cyl9X2ZpeEVycm9yKGUpe3RoaXMuX3htbD10aGlzLl9lcnJvckhhbmRsZXIuZml4RXJyb3IodGhpcy5feG1sLGUpfV9yZW1vdmVMaW5lQnJlYWtzKGUpe3JldHVybiBlLnJlcGxhY2UoL1xcbnxcXHJcXG58XFxyL2csXCJcIil9X3JlbW92ZU1zV29yZFByZWZpeGVzKGUpe3JldHVybiBlLnJlcGxhY2UoL21tbDovZyxcIlwiKX1nZXQgX21hdGhNTEVsZW1lbnRzKCl7bGV0IGU9dGhpcy5feG1sRE9NLnBhcnNlRnJvbVN0cmluZyh0aGlzLl94bWwpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibWF0aFwiKTtyZXR1cm4gdGhpcy5fZXJyb3JIYW5kbGVyLmlzVGhlcmVBbnlFcnJvcnMoKSYmKHRoaXMuX2Vycm9ySGFuZGxlci5jbGVhbkVycm9ycygpLGU9dGhpcy5feG1sRE9NLnBhcnNlRnJvbVN0cmluZyh0aGlzLl94bWwpLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibWF0aFwiKSksQXJyYXkuZnJvbShlKX19fSw3OTQxOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocig4NTg1KSx0KX0sODU4NTooZSx0LHIpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5tYWtlVG9NYXRoRWxlbWVudHNDb252ZXJ0ZXI9dm9pZCAwO2NvbnN0IGE9cig5MjA4KTt0Lm1ha2VUb01hdGhFbGVtZW50c0NvbnZlcnRlcj0oKT0+e2NvbnN0IGU9bmV3IGEuRWxlbWVudHNUb01hdGhNTEFkYXB0ZXIsdD1uZXcgYS5FcnJvckhhbmRsZXI7cmV0dXJuIG5ldyBhLlhtbFRvTWF0aE1MQWRhcHRlcihlLHQpfX0sODY3MjpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGE9dGhpcyYmdGhpcy5fX2NyZWF0ZUJpbmRpbmd8fChPYmplY3QuY3JlYXRlP2Z1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpO3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtuJiYhKFwiZ2V0XCJpbiBuPyF0Ll9fZXNNb2R1bGU6bi53cml0YWJsZXx8bi5jb25maWd1cmFibGUpfHwobj17ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdFtyXX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxhLG4pfTpmdW5jdGlvbihlLHQscixhKXt2b2lkIDA9PT1hJiYoYT1yKSxlW2FdPXRbcl19KSxuPXRoaXMmJnRoaXMuX19leHBvcnRTdGFyfHxmdW5jdGlvbihlLHQpe2Zvcih2YXIgciBpbiBlKVwiZGVmYXVsdFwiPT09cnx8T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscil8fGEodCxlLHIpfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuKHIoMzc5OCksdCl9LDM3OTg6KGUsdCxyKT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuTWF0aE1MVG9MYVRlWD12b2lkIDA7Y29uc3QgYT1yKDU0NDMpLG49cig3OTQxKTt0Lk1hdGhNTFRvTGFUZVg9Y2xhc3N7c3RhdGljIGNvbnZlcnQoZSl7cmV0dXJuKDAsbi5tYWtlVG9NYXRoRWxlbWVudHNDb252ZXJ0ZXIpKCkuY29udmVydChlKS5tYXAoKGU9Pm5ldyBhLk1hdGhNTEVsZW1lbnRUb0xhdGV4Q29udmVydGVyQWRhcHRlcihlKS50b0xhdGV4Q29udmVydGVyKCkpKS5tYXAoKGU9PmUuY29udmVydCgpKSkuam9pbihcIlwiKS50cmltKCl9fX0sMjk2NTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYWxsTWF0aE9wZXJhdG9yc0J5Q2hhcj12b2lkIDAsdC5hbGxNYXRoT3BlcmF0b3JzQnlDaGFyPXtfOlwiXFxcXHVuZGVybGluZVwiLFwiJiN4MjNFMTtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0UwO1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjNERjtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0RFO1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjNERDtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0RDO1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjNCNTtcIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCImI3gyM0I0O1wiOlwiXFxcXG92ZXJicmFjZVwiLFwiJiN4MjBEQztcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIwREI7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyMDY0O1wiOlwiXCIsXCImI3gyMDU3O1wiOlwiJycnJ1wiLFwiJiN4MjAzRTtcIjpcIlxcXFxiYXJcIixcIiYjeDIwMzc7XCI6XCJgYGBcIixcIiYjeDIwMzY7XCI6XCJgYFwiLFwiJiN4MjAzNTtcIjpcImBcIixcIiYjeDIwMzQ7XCI6XCInJydcIixcIiYjeDIwMzM7XCI6XCInJ1wiLFwiJiN4MjAxRjtcIjpcImBgXCIsXCImI3gyMDFFO1wiOlwiLCxcIixcIiYjeDIwMUI7XCI6XCJgXCIsXCImI3gyMDFBO1wiOlwiLFwiLFwiJiN4MzAyO1wiOlwiXFxcXGhhdFwiLFwiJiN4MkY3O1wiOlwiXFxcXHNpbVwiLFwiJiN4MkREO1wiOlwiXFxcXHNpbVwiLFwiJiN4MkRDO1wiOlwiXFxcXHNpbVwiLFwiJiN4MkRBO1wiOlwiXFxcXGNpcmNcIixcIiYjeDJEOTtcIjpcIlxcXFxjZG90XCIsXCImI3gyRDg7XCI6XCJcIixcIiYjeDJDRDtcIjpcIlxcXFxfXCIsXCImI3gyQ0I7XCI6XCLLi1wiLFwiJiN4MkNBO1wiOlwiy4pcIixcIiYjeDJDOTtcIjpcIsuJXCIsXCImI3gyQzc7XCI6XCJcIixcIiYjeDJDNjtcIjpcIlxcXFxoYXRcIixcIiYjeEJBO1wiOlwib1wiLFwiJiN4Qjk7XCI6XCIxXCIsXCImI3hCODtcIjpcIsK4XCIsXCImI3hCNDtcIjpcIsK0XCIsXCImI3hCMztcIjpcIjNcIixcIiYjeEIyO1wiOlwiMlwiLFwiJiN4QjA7XCI6XCJcXFxcY2lyY1wiLFwiJiN4QUY7XCI6XCJcXFxcYmFyXCIsXCImI3hBQTtcIjpcImFcIixcIiYjeEE4O1wiOlwiXFxcXGNkb3RcXFxcY2RvdFwiLFwiflwiOlwiXFxcXHNpbVwiLFwiYFwiOlwiYFwiLFwiXlwiOlwiXFxcXGhhdFwiLFwiLS1cIjpcIi0tXCIsXCIrK1wiOlwiKytcIixcIiZhbXA7XCI6XCJcXFxcJlwiLFwiJiN4MjA2MTtcIjpcIlwiLFwiJiN4MjIxQztcIjpcIlxcXFxzcXJ0WzRde31cIixcIiYjeDIyMUI7XCI6XCJcXFxcc3FydFszXXt9XCIsXCImI3gyMjFBO1wiOlwiXFxcXHNxcnR7fVwiLFwiJiN4MjE0NjtcIjpcImRcIixcIiYjeDIxNDU7XCI6XCJcXFxcbWF0aGJie0R9XCIsXCI/XCI6XCI/XCIsXCJAXCI6XCJAXCIsXCIvL1wiOlwiLy9cIixcIiEhXCI6XCIhIVwiLFwiIVwiOlwiIVwiLFwiJiN4MjY2RjtcIjpcIlxcXFwjXCIsXCImI3gyNjZFO1wiOlwiXCIsXCImI3gyNjZEO1wiOlwiXCIsXCImI3gyMDMyO1wiOlwiJ1wiLFwiJmx0Oz5cIjpcIjw+XCIsXCIqKlwiOlwiXFxcXHN0YXJcXFxcc3RhclwiLFwiJiN4MjIwNztcIjpcIlxcXFxuYWJsYVwiLFwiJiN4MjIwMjtcIjpcIlxcXFxwYXJ0aWFsXCIsXCImI3gyMjk5O1wiOlwiXFxcXGJpZ29kb3RcIixcIiYjeEFDO1wiOlwiXFxcXG5lZ1wiLFwiJiN4MjIyMjtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCImI3gyMjIxO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDIyMjA7XCI6XCJcXFxcYW5nbGVcIixcIiYjeEY3O1wiOlwiXFxcXGRpdlwiLFwiL1wiOlwiL1wiLFwiJiN4MjIxNjtcIjpcIlxcXFxiYWNrc2xhc2hcIixcIlxcXFxcIjpcIlxcXFxiYWNrc2xhc2hcIixcIiVcIjpcIlxcXFwlXCIsXCImI3gyMjk3O1wiOlwiXFxcXGJpZ290aW1lc1wiLFwiJiN4Qjc7XCI6XCJcXFxcY2RvdFwiLFwiJiN4MkEzRjtcIjpcIlxcXFxjb3Byb2RcIixcIiYjeDJBMkY7XCI6XCJcXFxcdGltZXNcIixcIiYjeDIyQzU7XCI6XCJcXFxcY2RvdFwiLFwiJiN4MjJBMTtcIjpcIlxcXFxib3hkb3RcIixcIiYjeDIyQTA7XCI6XCJcXFxcYm94dGltZXNcIixcIiYjeDIwNjI7XCI6XCJcIixcIiYjeDIwNDM7XCI6XCItXCIsXCImI3gyMDIyO1wiOlwiXFxcXGNkb3RcIixcIiYjeEQ3O1wiOlwiXFxcXHRpbWVzXCIsXCIuXCI6XCIuXCIsXCIqXCI6XCJcXFxcc3RhclwiLFwiJiN4MjIyQTtcIjpcIlxcXFxjdXBcIixcIiYjeDIyMjk7XCI6XCJcXFxcY2FwXCIsXCImI3gyMjEwO1wiOlwiXFxcXGNvcHJvZFwiLFwiJiN4MjIwRjtcIjpcIlxcXFxwcm9kXCIsXCImI3gyMjQwO1wiOlwiXCIsXCImI3gyQUZGO1wiOlwiXCIsXCImI3gyQUZDO1wiOlwiXFxcXG1pZFxcXFxtaWRcXFxcbWlkXCIsXCImI3gyQTA5O1wiOlwiXFxcXHRpbWVzXCIsXCImI3gyQTA4O1wiOlwiXCIsXCImI3gyQTA3O1wiOlwiXCIsXCImI3gyQTA2O1wiOlwiXFxcXHNxY3VwXCIsXCImI3gyQTA1O1wiOlwiXFxcXHNxY2FwXCIsXCImI3gyQTAyO1wiOlwiXFxcXG90aW1lc1wiLFwiJiN4MkEwMDtcIjpcIlxcXFxvZG90XCIsXCImI3gyMkMyO1wiOlwiXFxcXGNhcFwiLFwiJiN4MjJDMTtcIjpcIlxcXFx2ZWVcIixcIiYjeDIyQzA7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDJBMDQ7XCI6XCJcXFxcdXBsdXNcIixcIiYjeDJBMDM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMkMzO1wiOlwiXFxcXGN1cFwiLFwiJiN4MkExQztcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGludH1cIixcIiYjeDJBMUI7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGludH1cIixcIiYjeDJBMUE7XCI6XCJcXFxcaW50XCIsXCImI3gyQTE5O1wiOlwiXFxcXGludFwiLFwiJiN4MkExODtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTc7XCI6XCJcXFxcaW50XCIsXCImI3gyQTE2O1wiOlwiXFxcXG9pbnRcIixcIiYjeDJBMTU7XCI6XCJcXFxcb2ludFwiLFwiJiN4MkExNDtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTM7XCI6XCJcXFxcaW50XCIsXCImI3gyQTEyO1wiOlwiXFxcXGludFwiLFwiJiN4MkExMTtcIjpcIlxcXFxpbnRcIixcIiYjeDJBMTA7XCI6XCJcXFxcaW50XCIsXCImI3gyQTBGO1wiOlwiXFxcXGJjYW5jZWx7XFxcXGludH1cIixcIiYjeDJBMEU7XCI6XCJcIixcIiYjeDJBMEQ7XCI6XCJcXFxcaGNhbmNlbHtcXFxcaW50fVwiLFwiJiN4MkEwQztcIjpcIlxcXFxpaWlpbnRcIixcIiYjeDIyMzM7XCI6XCJcXFxcb2ludFwiLFwiJiN4MjIzMjtcIjpcIlxcXFxvaW50XCIsXCImI3gyMjMxO1wiOlwiXFxcXGludFwiLFwiJiN4MjIzMDtcIjpcIlxcXFxvaWludFwiLFwiJiN4MjIyRjtcIjpcIlxcXFxvaWludFwiLFwiJiN4MjIyRTtcIjpcIlxcXFxvaW50XCIsXCImI3gyMjJCO1wiOlwiXFxcXGludFwiLFwiJiN4MkEwMTtcIjpcIlxcXFxvcGx1c1wiLFwiJiN4MjI5ODtcIjpcIlxcXFxvc2xhc2hcIixcIiYjeDIyOTY7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyMjk1O1wiOlwiXFxcXG9wbHVzXCIsXCImI3gyMjJEO1wiOlwiXFxcXGlpaW50XCIsXCImI3gyMjJDO1wiOlwiXFxcXGlpbnRcIixcIiYjeDJBMEI7XCI6XCJcIixcIiYjeDJBMEE7XCI6XCJcIixcIiYjeDIyMTE7XCI6XCJcXFxcc3VtXCIsXCImI3gyMjlGO1wiOlwiXFxcXGJveG1pbnVzXCIsXCImI3gyMjlFO1wiOlwiXFxcXGJveHBsdXNcIixcIiYjeDIyMTQ7XCI6XCJcXFxcZG90eyt9XCIsXCImI3gyMjEzO1wiOlwiKy1cIixcIiYjeDIyMTI7XCI6XCItXCIsXCImI3hCMTtcIjpcIlxcXFxwbVwiLFwiLVwiOlwiLVwiLFwiK1wiOlwiK1wiLFwiJiN4MkI0NjtcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwiJiN4MkI0NTtcIjpcIlxcXFxMbGVmdGFycm93XCIsXCImI3gyOUY0O1wiOlwiOlxcXFxyaWdodGFycm93XCIsXCImI3gyOUVGO1wiOlwiXCIsXCImI3gyOURGO1wiOlwiXFxcXGJ1bGxldC1cXFxcYnVsbGV0XCIsXCImI3gyOTlGO1wiOlwiXFxcXGFuZ2xlXCIsXCImI3gyOTlFO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDI5OUQ7XCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiJiN4Mjk5QztcIjpcIlxcXFxwZXJwXCIsXCImI3gyOTlCO1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIiYjeDI5OUE7XCI6XCJcIixcIiYjeDI5OTk7XCI6XCJcXFxcdmRvdHNcIixcIiYjeDI5N0Y7XCI6XCJcIixcIiYjeDI5N0U7XCI6XCJcIixcIiYjeDI5N0Q7XCI6XCJcXFxccHJlY1wiLFwiJiN4Mjk3QztcIjpcIlxcXFxzdWNjXCIsXCImI3gyOTdCO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXtcXFxcc3Vwc2V0fVwiLFwiJiN4Mjk3QTtcIjpcIlwiLFwiJiN4Mjk3OTtcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317XFxcXHN1YnNldH1cIixcIiYjeDI5Nzg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHJpZ2h0YXJyb3d9ez59XCIsXCImI3gyOTc3O1wiOlwiXCIsXCImI3gyOTc2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxsZWZ0YXJyb3d9ezx9XCIsXCImI3gyOTc1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxyaWdodGFycm93fVwiLFwiJiN4Mjk3NDtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5NzM7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXGxlZnRhcnJvd31cIixcIiYjeDI5NzI7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5NzE7XCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5NzA7XCI6XCJcIixcIiYjeDI5NkY7XCI6XCJcIixcIiYjeDI5NkU7XCI6XCJcIixcIiYjeDI5NkQ7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHJpZ2h0aGFycG9vbmRvd259XCIsXCImI3gyOTZDO1wiOlwiXFxcXHVuZGVybGluZXtcXFxccmlnaHRoYXJwb29udXB9XCIsXCImI3gyOTZCO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxsZWZ0aGFycG9vbmRvd259XCIsXCImI3gyOTZBO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbGVmdGhhcnBvb251cH1cIixcIiYjeDI5Njk7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5Njg7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5Njc7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5NjY7XCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIiYjeDI5NjU7XCI6XCJcXFxcRG93bmFycm93XCIsXCImI3gyOTY0O1wiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIiYjeDI5NjM7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4Mjk2MjtcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIiYjeDI5NjE7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTYwO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NUY7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1RTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NUQ7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTVDO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NUI7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1QTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NTk7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTU4O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NTc7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1NjtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NTU7XCI6XCJcXFxcZG93bmFycm93XCIsXCImI3gyOTU0O1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDI5NTM7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4Mjk1MjtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5NTE7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NTA7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NEY7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NEU7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NEQ7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NEM7XCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIiYjeDI5NEI7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NEE7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NDk7XCI6XCJcIixcIiYjeDI5NDg7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI5NDc7XCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIiYjeDI5NDY7XCI6XCJcIixcIiYjeDI5NDU7XCI6XCJcIixcIiYjeDI5NDQ7XCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCImI3gyOTQzO1wiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwiJiN4Mjk0MjtcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIiYjeDI5NDE7XCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLFwiJiN4Mjk0MDtcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIiYjeDI5M0Y7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkzRTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5M0Q7XCI6XCJcIixcIiYjeDI5M0M7XCI6XCJcIixcIiYjeDI5M0I7XCI6XCJcIixcIiYjeDI5M0E7XCI6XCJcIixcIiYjeDI5Mzk7XCI6XCJcIixcIiYjeDI5Mzg7XCI6XCJcIixcIiYjeDI5Mzc7XCI6XCJcXFxcUnNoXCIsXCImI3gyOTM2O1wiOlwiXFxcXExzaFwiLFwiJiN4MjkzNTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDI5MzQ7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjkzMztcIjpcIlxcXFxsZWFkc3RvXCIsXCImI3gyOTMyO1wiOlwiXCIsXCImI3gyOTMxO1wiOlwiXCIsXCImI3gyOTMwO1wiOlwiXCIsXCImI3gyOTJGO1wiOlwiXCIsXCImI3gyOTJFO1wiOlwiXCIsXCImI3gyOTJEO1wiOlwiXCIsXCImI3gyOTJDO1wiOlwiXFxcXHRpbWVzXCIsXCImI3gyOTJCO1wiOlwiXFxcXHRpbWVzXCIsXCImI3gyOTJBO1wiOlwiXCIsXCImI3gyOTI5O1wiOlwiXCIsXCImI3gyOTI4O1wiOlwiXCIsXCImI3gyOTI3O1wiOlwiXCIsXCImI3gyOTI2O1wiOlwiXCIsXCImI3gyOTI1O1wiOlwiXCIsXCImI3gyOTI0O1wiOlwiXCIsXCImI3gyOTIzO1wiOlwiXCIsXCImI3gyOTIyO1wiOlwiXCIsXCImI3gyOTIxO1wiOlwiXCIsXCImI3gyOTIwO1wiOlwiXFxcXG1hcHN0b1xcXFxjZG90XCIsXCImI3gyOTFGO1wiOlwiXFxcXGNkb3RcXFxcbGVmdGFycm93XCIsXCImI3gyOTFFO1wiOlwiXFxcXHJpZ2h0YXJyb3dcXFxcY2RvdFwiLFwiJiN4MjkxRDtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MUM7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxQjtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MUE7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxOTtcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIiYjeDI5MTg7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxNztcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTE2O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTU7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkxNDtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTEzO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjkxMjtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyOTExO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDI5MTA7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjkwRjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTBFO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkwRDtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyOTBDO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjkwQjtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDI5MEE7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjkwOTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyOTA4O1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjkwNztcIjpcIlxcXFxSaWdodGFycm93XCIsXCImI3gyOTA2O1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjkwNTtcIjpcIlxcXFxtYXBzdG9cIixcIiYjeDI5MDQ7XCI6XCJcXFxcbkxlZnRyaWdodGFycm93XCIsXCImI3gyOTAzO1wiOlwiXFxcXG5SaWdodGFycm93XCIsXCImI3gyOTAyO1wiOlwiXFxcXG5MZWZ0YXJyb3dcIixcIiYjeDI5MDE7XCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCImI3gyOTAwO1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwiJiN4MjdGRjtcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIiYjeDI3RkU7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4MjdGRDtcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIiYjeDI3RkM7XCI6XCJcXFxcbWFwc3RvXCIsXCImI3gyN0ZCO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjdGQTtcIjpcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIixcIiYjeDI3Rjk7XCI6XCJcXFxcTG9uZ3JpZ2h0YXJyb3dcIixcIiYjeDI3Rjg7XCI6XCJcXFxcTG9uZ2xlZnRhcnJvd1wiLFwiJiN4MjdGNztcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjdGNjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyN0Y1O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjdGMTtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDI3RjA7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjJCODtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMUZGO1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCImI3gyMUZFO1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRkQ7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMUZDO1wiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFGQjtcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiJiN4MjFGQTtcIjpcIlxcXFxubGVmdGFycm93XCIsXCImI3gyMUY5O1wiOlwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFGODtcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwiJiN4MjFGNztcIjpcIlxcXFxubGVmdGFycm93XCIsXCImI3gyMUY2O1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCImI3gyMUY1O1wiOlwiXCIsXCImI3gyMUY0O1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIiYjeDIxRjM7XCI6XCJcXFxcVXBkb3duYXJyb3dcIixcIiYjeDIxRjI7XCI6XCJcXFxcc2VhcnJvd1wiLFwiJiN4MjFGMTtcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMUYwO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjFFRjtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUVFO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUQ7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFQztcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUVCO1wiOlwiXFxcXFVwYXJyb3dcIixcIiYjeDIxRUE7XCI6XCJcXFxcVXBhcnJvd1wiLFwiJiN4MjFFOTtcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDIxRTg7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4MjFFNztcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUU2O1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjFFNTtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMUU0O1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjFFMztcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDIxRTI7XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwiJiN4MjFFMTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMUUwO1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwiJiN4MjFERjtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDIxREU7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjFERDtcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIiYjeDIxREM7XCI6XCJcXFxcbGVmdGFycm93XCIsXCImI3gyMURCO1wiOlwiXFxcXFJyaWdodGFycm93XCIsXCImI3gyMURBO1wiOlwiXFxcXExsZWZ0YXJyb3dcIixcIiYjeDIxRDk7XCI6XCJcXFxcc3dhcnJvd1wiLFwiJiN4MjFEODtcIjpcIlxcXFxzZWFycm93XCIsXCImI3gyMUQ3O1wiOlwiXFxcXG5lYXJyb3dcIixcIiYjeDIxRDY7XCI6XCJcXFxcbndhcnJvd1wiLFwiJiN4MjFENTtcIjpcIlxcXFxVcGRvd25hcnJvd1wiLFwiJiN4MjFENDtcIjpcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiLFwiJiN4MjFEMztcIjpcIlxcXFxEb3duYXJyb3dcIixcIiYjeDIxRDI7XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwiJiN4MjFEMTtcIjpcIlxcXFxVcGFycm93XCIsXCImI3gyMUQwO1wiOlwiXFxcXExlZnRhcnJvd1wiLFwiJiN4MjFDRjtcIjpcIlxcXFxuUmlnaHRhcnJvd1wiLFwiJiN4MjFDRTtcIjpcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIixcIiYjeDIxQ0Q7XCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwiJiN4MjFDQztcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwiJiN4MjFDQjtcIjpcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiLFwiJiN4MjFDQTtcIjpcIlxcXFxkb3duZG93bmFycm93c1wiLFwiJiN4MjFDOTtcIjpcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIsXCImI3gyMUM4O1wiOlwiXFxcXHVwdXBhcnJvd3NcIixcIiYjeDIxQzc7XCI6XCJcXFxcbGVmdGxlZnRhcnJvd3NcIixcIiYjeDIxQzY7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCImI3gyMUM1O1wiOlwiXCIsXCImI3gyMUM0O1wiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwiJiN4MjFDMztcIjpcIlxcXFxkb3duaGFycG9vbmxlZnRcIixcIiYjeDIxQzI7XCI6XCJcXFxcZG93bmhhcnBvb25yaWdodFwiLFwiJiN4MjFDMTtcIjpcIlxcXFxyaWdodGhhcnBvb25kb3duXCIsXCImI3gyMUMwO1wiOlwiXFxcXHJpZ2h0aGFycG9vbnVwXCIsXCImI3gyMUJGO1wiOlwiXFxcXHVwaGFycG9vbmxlZnRcIixcIiYjeDIxQkU7XCI6XCJcXFxcdXBoYXJwb29ucmlnaHRcIixcIiYjeDIxQkQ7XCI6XCJcXFxcbGVmdGhhcnBvb25kb3duXCIsXCImI3gyMUJDO1wiOlwiXFxcXGxlZnRoYXJwb29udXBcIixcIiYjeDIxQkI7XCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLFwiJiN4MjFCQTtcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIiYjeDIxQjk7XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dzXCIsXCImI3gyMUI4O1wiOlwiXFxcXG92ZXJsaW5le1xcXFxud2Fycm93fVwiLFwiJiN4MjFCNztcIjpcIlxcXFxjdXJ2ZWFycm93cmlnaHRcIixcIiYjeDIxQjY7XCI6XCJcXFxcY3VydmVhcnJvd2xlZnRcIixcIiYjeDIxQjU7XCI6XCJcXFxcc3dhcnJvd1wiLFwiJiN4MjFCNDtcIjpcIlxcXFxzZWFycm93XCIsXCImI3gyMUIzO1wiOlwiXFxcXFJzaFwiLFwiJiN4MjFCMjtcIjpcIlxcXFxMc2hcIixcIiYjeDIxQjE7XCI6XCJcXFxcUnNoXCIsXCImI3gyMUIwO1wiOlwiXFxcXExzaFwiLFwiJiN4MjFBRjtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMUFFO1wiOlwiXCIsXCImI3gyMUFEO1wiOlwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIixcIiYjeDIxQUM7XCI6XCJcXFxcbG9vcGFycm93cmlnaHRcIixcIiYjeDIxQUI7XCI6XCJcXFxcbG9vcGFycm93bGVmdFwiLFwiJiN4MjFBQTtcIjpcIlxcXFxob29rcmlnaHRhcnJvd1wiLFwiJiN4MjFBOTtcIjpcIlxcXFxob29rbGVmdGFycm93XCIsXCImI3gyMUE4O1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdXBkb3duYXJyb3d9XCIsXCImI3gyMUE3O1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjFBNjtcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwiJiN4MjFBNTtcIjpcIlxcXFx1cGFycm93XCIsXCImI3gyMUE0O1wiOlwiXFxcXGxlZnRhcnJvd3RhaWxcIixcIiYjeDIxQTM7XCI6XCJcXFxccmlnaHRhcnJvd3RhaWxcIixcIiYjeDIxQTI7XCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwiJiN4MjFBMTtcIjpcIlxcXFxkb3duYXJyb3dcIixcIiYjeDIxQTA7XCI6XCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIixcIiYjeDIxOUY7XCI6XCJcXFxcdXBhcnJvd1wiLFwiJiN4MjE5RTtcIjpcIlxcXFx0d29oZWFkbGVmdGFycm93XCIsXCImI3gyMTlEO1wiOlwiXFxcXG5lYXJyb3dcIixcIiYjeDIxOUM7XCI6XCJcXFxcbndhcnJvd1wiLFwiJiN4MjE5QjtcIjpcIlwiLFwiJiN4MjE5QTtcIjpcIlwiLFwiJiN4MjE5OTtcIjpcIlxcXFxzd2Fycm93XCIsXCImI3gyMTk4O1wiOlwiXFxcXHNlYXJyb3dcIixcIiYjeDIxOTc7XCI6XCJcXFxcbmVhcnJvd1wiLFwiJiN4MjE5NjtcIjpcIlxcXFxud2Fycm93XCIsXCImI3gyMTk1O1wiOlwiXFxcXHVwZG93bmFycm93XCIsXCImI3gyMTk0O1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCImI3gyMTkzO1wiOlwiXFxcXGRvd25hcnJvd1wiLFwiJiN4MjE5MjtcIjpcIlxcXFxyaWdodGFycm93XCIsXCImI3gyMTkxO1wiOlwiXFxcXHVwYXJyb3dcIixcIiYjeDIxOTA7XCI6XCJcXFxcbGVmdGFycm93XCIsXCJ8fHxcIjpcIlxcXFxsZWZ0fHx8XFxcXHJpZ2h0LlwiLFwifHxcIjpcIlxcXFxsZWZ0fHxcXFxccmlnaHQuXCIsXCJ8XCI6XCJcXFxcbGVmdHxcXFxccmlnaHQuXCIsXCImI3gyQUZFO1wiOlwiXCIsXCImI3gyQUZEO1wiOlwiLy9cIixcIiYjeDJBRkI7XCI6XCIvLy9cIixcIiYjeDJBRkE7XCI6XCJcIixcIiYjeDJBRjk7XCI6XCJcIixcIiYjeDJBRjg7XCI6XCJcIixcIiYjeDJBRjc7XCI6XCJcIixcIiYjeDJBRjY7XCI6XCJcXFxcdmRvdHNcIixcIiYjeDJBRjU7XCI6XCJcIixcIiYjeDJBRjQ7XCI6XCJcIixcIiYjeDJBRjM7XCI6XCJcIixcIiYjeDJBRjI7XCI6XCJcXFxcbnBhcmFsbGVsXCIsXCImI3gyQUYxO1wiOlwiXCIsXCImI3gyQUYwO1wiOlwiXCIsXCImI3gyQUVGO1wiOlwiXCIsXCImI3gyQUVFO1wiOlwiXFxcXGJjYW5jZWx7XFxcXG1pZH1cIixcIiYjeDJBRUQ7XCI6XCJcIixcIiYjeDJBRUM7XCI6XCJcIixcIiYjeDJBRUI7XCI6XCJcIixcIiYjeDJBRUE7XCI6XCJcIixcIiYjeDJBRTk7XCI6XCJcIixcIiYjeDJBRTg7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxwZXJwfVwiLFwiJiN4MkFFNztcIjpcIlxcXFxvdmVybGluZXtcXFxcdG9wfVwiLFwiJiN4MkFFNjtcIjpcIlwiLFwiJiN4MkFFNTtcIjpcIlwiLFwiJiN4MkFFNDtcIjpcIlwiLFwiJiN4MkFFMztcIjpcIlwiLFwiJiN4MkFFMjtcIjpcIlwiLFwiJiN4MkFFMTtcIjpcIlwiLFwiJiN4MkFFMDtcIjpcIlxcXFxwZXJwXCIsXCImI3gyQURGO1wiOlwiXFxcXHRvcFwiLFwiJiN4MkFERTtcIjpcIlxcXFxkYXNodlwiLFwiJiN4MkFERDsmI3gzMzg7XCI6XCJcIixcIiYjeDJBREQ7XCI6XCJcIixcIiYjeDJBREI7XCI6XCJcXFxccGl0Y2hmb3JrXCIsXCImI3gyQURBO1wiOlwiXCIsXCImI3gyQUQ5O1wiOlwiXCIsXCImI3gyQUQ4O1wiOlwiXCIsXCImI3gyQUQ3O1wiOlwiXCIsXCImI3gyQUQ2O1wiOlwiXCIsXCImI3gyQUQ1O1wiOlwiXCIsXCImI3gyQUQ0O1wiOlwiXCIsXCImI3gyQUQzO1wiOlwiXCIsXCImI3gyQUQyO1wiOlwiXCIsXCImI3gyQUQxO1wiOlwiXCIsXCImI3gyQUQwO1wiOlwiXCIsXCImI3gyQUNGO1wiOlwiXCIsXCImI3gyQUNFO1wiOlwiXCIsXCImI3gyQUNEO1wiOlwiXCIsXCImI3gyQUNDO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUNCO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUNBO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUM5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUM4O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdXBzZXR9XCIsXCImI3gyQUM3O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxzdWJzZXR9XCIsXCImI3gyQUM2O1wiOlwiXFxcXHN1cHNldGVxcVwiLFwiJiN4MkFDNTtcIjpcIlxcXFxzdWJzZXRlcXFcIixcIiYjeDJBQzQ7XCI6XCJcXFxcZG90e1xcXFxzdXBzZXRlcX1cIixcIiYjeDJBQzM7XCI6XCJcXFxcZG90e1xcXFxzdWJzZXRlcX1cIixcIiYjeDJBQzI7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHRpbWVzfXtcXFxcc3Vwc2V0fVwiLFwiJiN4MkFDMTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcdGltZXN9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUMwO1wiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdXBzZXR9XCIsXCImI3gyQUJGO1wiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdWJzZXR9XCIsXCImI3gyQUJFO1wiOlwiXCIsXCImI3gyQUJEO1wiOlwiXCIsXCImI3gyQUJDO1wiOlwiXFxcXGdnIFwiLFwiJiN4MkFCQjtcIjpcIlxcXFxsbFwiLFwiJiN4MkFCQTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXtcXFxcc3VjY31cIixcIiYjeDJBQjk7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17XFxcXHByZWN9XCIsXCImI3gyQUI4O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdWNjfVwiLFwiJiN4MkFCNztcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxccHJlY31cIixcIiYjeDJBQjY7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHN1Y2N9XCIsXCImI3gyQUI1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7PX19e1xcXFxwcmVjfVwiLFwiJiN4MkFCNDtcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcc3VjY31cIixcIiYjeDJBQjM7XCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHByZWN9XCIsXCImI3gyQUIyO1wiOlwiXCIsXCImI3gyQUIxO1wiOlwiXCIsXCImI3gyQUFFO1wiOlwiXCIsXCImI3gyQUFEO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaGNhbmNlbHs+fX1cIixcIiYjeDJBQUM7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwiJiN4MkFBQjtcIjpcIlxcXFxoY2FuY2Vsez59XCIsXCImI3gyQUFBO1wiOlwiXFxcXGhjYW5jZWx7PH1cIixcIiYjeDJBQTk7XCI6XCJcIixcIiYjeDJBQTg7XCI6XCJcIixcIiYjeDJBQTc7XCI6XCJcXFxcdmFydHJpYW5nbGVyaWdodFwiLFwiJiN4MkFBNjtcIjpcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIixcIiYjeDJBQTU7XCI6XCI+PFwiLFwiJiN4MkFBNDtcIjpcIj48XCIsXCImI3gyQUEzO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbGx9XCIsXCImI3gyQUEyOyYjeDMzODtcIjpcIlxcXFxjYW5jZWx7XFxcXGdnfVwiLFwiJiN4MkFBMjtcIjpcIlxcXFxnZ1wiLFwiJiN4MkFBMTsmI3gzMzg7XCI6XCJcXFxcY2FuY2Vse1xcXFxsbH1cIixcIiYjeDJBQTE7XCI6XCJcXFxcbGxcIixcIiYjeDJBQTA7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxcZ2VxcX1cIixcIiYjeDJBOUY7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXtcXFxcbGVxcX1cIixcIiYjeDJBOUU7XCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXs+fVwiLFwiJiN4MkE5RDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19ezx9XCIsXCImI3gyQTlDO1wiOlwiXCIsXCImI3gyQTlCO1wiOlwiXCIsXCImI3gyQTlBO1wiOlwiXFxcXG92ZXJzZXR7PX17Pn1cIixcIiYjeDJBOTk7XCI6XCJcXFxcb3ZlcnNldHs9fXs8fVwiLFwiJiN4MkE5ODtcIjpcIlwiLFwiJiN4MkE5NztcIjpcIlwiLFwiJiN4MkE5NjtcIjpcIlwiLFwiJiN4MkE5NTtcIjpcIlwiLFwiJiN4MkE5NDtcIjpcIlwiLFwiJiN4MkE5MztcIjpcIlwiLFwiJiN4MkE5MjtcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcZ3RybGVzc31cIixcIiYjeDJBOTE7XCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXGxlc3NndHJ9XCIsXCImI3gyQTkwO1wiOlwiXFxcXHVuZGVyc2V0ezx9e1xcXFxndHJzaW19XCIsXCImI3gyQThGO1wiOlwiXFxcXHVuZGVyc2V0ez59e1xcXFxsZXNzc2ltfVwiLFwiJiN4MkE4RTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltZXF9ez59XCIsXCImI3gyQThEO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW1lcX17PH1cIixcIiYjeDJBOEM7XCI6XCJcXFxcZ3RyZXFxbGVzc1wiLFwiJiN4MkE4QjtcIjpcIlxcXFxsZXNzZXFxZ3RyXCIsXCImI3gyQThBO1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19ez59XCIsXCImI3gyQTg5O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ezx9XCIsXCImI3gyQTg2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ez59XCIsXCImI3gyQTg1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ezx9XCIsXCImI3gyQTg0O1wiOlwiXCIsXCImI3gyQTgzO1wiOlwiXCIsXCImI3gyQTgyO1wiOlwiXCIsXCImI3gyQTgxO1wiOlwiXCIsXCImI3gyQTgwO1wiOlwiXCIsXCImI3gyQTdGO1wiOlwiXCIsXCImI3gyQTdFOyYjeDMzODtcIjpcIlxcXFxiY2FuY2Vse1xcXFxnZXF9XCIsXCImI3gyQTdFO1wiOlwiXFxcXGdlcVwiLFwiJiN4MkE3RDsmI3gzMzg7XCI6XCJcXFxcYmNhbmNlbHtcXFxcbGVxfVwiLFwiJiN4MkE3RDtcIjpcIlxcXFxsZXFcIixcIiYjeDJBN0M7XCI6XCJcIixcIiYjeDJBN0I7XCI6XCJcIixcIiYjeDJBN0E7XCI6XCJcIixcIiYjeDJBNzk7XCI6XCJcIixcIiYjeDJBNzg7XCI6XCJcXFxcb3ZlcnNldHtcXFxcZG90c317XFxcXGVxdWl2fVwiLFwiJiN4MkE3NztcIjpcIlwiLFwiJiN4MkE3NjtcIjpcIj09PVwiLFwiJiN4MkE3NTtcIjpcIj09XCIsXCImI3gyQTc0O1wiOlwiOjo9XCIsXCImI3gyQTczO1wiOlwiXCIsXCImI3gyQTcyO1wiOlwiXFxcXHVuZGVyc2V0ez19eyt9XCIsXCImI3gyQTcxO1wiOlwiXFxcXG92ZXJzZXR7PX17K31cIixcIiYjeDJBNzA7XCI6XCJcXFxcb3ZlcnNldHtcXFxcYXBwcm94fXs9fVwiLFwiJiN4MkE2RjtcIjpcIlxcXFxvdmVyc2V0e1xcXFx3ZWRnZX17PX1cIixcIiYjeDJBNkU7XCI6XCJcXFxcb3ZlcnNldHsqfXs9fVwiLFwiJiN4MkE2RDtcIjpcIlxcXFxkb3R7XFxcXGFwcHJveH1cIixcIiYjeDJBNkM7XCI6XCJcIixcIiYjeDJBNkI7XCI6XCJcIixcIiYjeDJBNkE7XCI6XCJcXFxcZG90e1xcXFxzaW19XCIsXCImI3gyQTY5O1wiOlwiXCIsXCImI3gyQTY4O1wiOlwiXCIsXCImI3gyQTY3O1wiOlwiXFxcXGRvdHtcXFxcZXF1aXZ9XCIsXCImI3gyQTY2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjZG90fXs9fVwiLFwiJiN4MkE2NTtcIjpcIlwiLFwiJiN4MkE2NDtcIjpcIlwiLFwiJiN4MkE2MztcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcdmVlfVwiLFwiJiN4MkE2MjtcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFx2ZWV9XCIsXCImI3gyQTYxO1wiOlwidWwodnYpXCIsXCImI3gyQTYwO1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFx3ZWRnZX1cIixcIiYjeDJBNUY7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx3ZWRnZX1cIixcIiYjeDJBNUU7XCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxcd2VkZ2V9XCIsXCImI3gyQTVEO1wiOlwiXFxcXGhjYW5jZWx7XFxcXHZlZX1cIixcIiYjeDJBNUM7XCI6XCJcXFxcaGNhbmNlbHtcXFxcd2VkZ2V9XCIsXCImI3gyQTVCO1wiOlwiXCIsXCImI3gyQTVBO1wiOlwiXCIsXCImI3gyQTU5O1wiOlwiXCIsXCImI3gyQTU4O1wiOlwiXFxcXHZlZVwiLFwiJiN4MkE1NztcIjpcIlxcXFx3ZWRnZVwiLFwiJiN4MkE1NjtcIjpcIlwiLFwiJiN4MkE1NTtcIjpcIlwiLFwiJiN4MkE1NDtcIjpcIlwiLFwiJiN4MkE1MztcIjpcIlwiLFwiJiN4MkE1MjtcIjpcIlxcXFxkb3R7XFxcXHZlZX1cIixcIiYjeDJBNTE7XCI6XCJcXFxcZG90e1xcXFx3ZWRnZX1cIixcIiYjeDJBNTA7XCI6XCJcIixcIiYjeDJBNEY7XCI6XCJcIixcIiYjeDJBNEU7XCI6XCJcIixcIiYjeDJBNEQ7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGNhcH1cIixcIiYjeDJBNEM7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIiYjeDJBNEI7XCI6XCJcIixcIiYjeDJBNEE7XCI6XCJcIixcIiYjeDJBNDk7XCI6XCJcIixcIiYjeDJBNDg7XCI6XCJcIixcIiYjeDJBNDc7XCI6XCJcIixcIiYjeDJBNDY7XCI6XCJcIixcIiYjeDJBNDU7XCI6XCJcIixcIiYjeDJBNDQ7XCI6XCJcIixcIiYjeDJBNDM7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGNhcH1cIixcIiYjeDJBNDI7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIiYjeDJBNDE7XCI6XCJcIixcIiYjeDJBNDA7XCI6XCJcIixcIiYjeDJBM0U7XCI6XCJcIixcIiYjeDJBM0Q7XCI6XCJcXFxcbGxjb3JuZXJcIixcIiYjeDJBM0M7XCI6XCJcXFxcbHJjb3JuZXJcIixcIiYjeDJBM0I7XCI6XCJcIixcIiYjeDJBM0E7XCI6XCJcIixcIiYjeDJBMzk7XCI6XCJcIixcIiYjeDJBMzg7XCI6XCJcIixcIiYjeDJBMzc7XCI6XCJcIixcIiYjeDJBMzY7XCI6XCJcXFxcaGF0e1xcXFxvdGltZXN9XCIsXCImI3gyQTM1O1wiOlwiXCIsXCImI3gyQTM0O1wiOlwiXCIsXCImI3gyQTMzO1wiOlwiXCIsXCImI3gyQTMyO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdGltZXN9XCIsXCImI3gyQTMxO1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdGltZXN9XCIsXCImI3gyQTMwO1wiOlwiXFxcXGRvdHtcXFxcdGltZXN9XCIsXCImI3gyQTJFO1wiOlwiXCIsXCImI3gyQTJEO1wiOlwiXCIsXCImI3gyQTJDO1wiOlwiXCIsXCImI3gyQTJCO1wiOlwiXCIsXCImI3gyQTJBO1wiOlwiXCIsXCImI3gyQTI5O1wiOlwiXCIsXCImI3gyQTI4O1wiOlwiXCIsXCImI3gyQTI3O1wiOlwiXCIsXCImI3gyQTI2O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19eyt9XCIsXCImI3gyQTI1O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxjaXJjfXsrfVwiLFwiJiN4MkEyNDtcIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19eyt9XCIsXCImI3gyQTIzO1wiOlwiXFxcXGhhdHsrfVwiLFwiJiN4MkEyMjtcIjpcIlxcXFxkb3R7K31cIixcIiYjeDJBMjE7XCI6XCJcXFxcdXBoYXJwb29ucmlnaHRcIixcIiYjeDJBMjA7XCI6XCI+PlwiLFwiJiN4MkExRjtcIjpcIlwiLFwiJiN4MkExRTtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDJBMUQ7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUZGO1wiOlwiXCIsXCImI3gyOUZFO1wiOlwiK1wiLFwiJiN4MjlGQjtcIjpcIlxcXFxoY2FuY2Vse3x8fH1cIixcIiYjeDI5RkE7XCI6XCJcXFxcaGNhbmNlbHt8fH1cIixcIiYjeDI5Rjk7XCI6XCJcXFxcYmFja3NsYXNoXCIsXCImI3gyOUY4O1wiOlwiL1wiLFwiJiN4MjlGNztcIjpcImhjYW5jZWx7XFxiYWNrc2xhc2h9XCIsXCImI3gyOUY2O1wiOlwiXCIsXCImI3gyOUY1O1wiOlwiXFxcXGJhY2tzbGFzaFwiLFwiJiN4MjlGMjtcIjpcIlxcXFxQaGlcIixcIiYjeDI5RjE7XCI6XCJcIixcIiYjeDI5RjA7XCI6XCJcIixcIiYjeDI5RUU7XCI6XCJcIixcIiYjeDI5RUQ7XCI6XCJcIixcIiYjeDI5RUM7XCI6XCJcIixcIiYjeDI5RUI7XCI6XCJcXFxcbG96ZW5nZVwiLFwiJiN4MjlFQTtcIjpcIlwiLFwiJiN4MjlFOTtcIjpcIlwiLFwiJiN4MjlFODtcIjpcIlwiLFwiJiN4MjlFNztcIjpcIlxcXFxkZGFnZ2VyXCIsXCImI3gyOUUyO1wiOlwiXFxcXHNxY3VwXFxcXHNxY3VwXCIsXCImI3gyOUUxO1wiOlwiXCIsXCImI3gyOUUwO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjlERTtcIjpcIlwiLFwiJiN4MjlERDtcIjpcIlwiLFwiJiN4MjlEQztcIjpcIlwiLFwiJiN4MjlEQjtcIjpcIlxcXFx7XFxcXHtcIixcIiYjeDI5RDk7XCI6XCJcXFxce1wiLFwiJiN4MjlEODtcIjpcIlxcXFx9XCIsXCImI3gyOUQ3O1wiOlwiXCIsXCImI3gyOUQ2O1wiOlwiXCIsXCImI3gyOUQ1O1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlENDtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RDM7XCI6XCJcXFxcYm93dGllXCIsXCImI3gyOUQyO1wiOlwiXFxcXGJvd3RpZVwiLFwiJiN4MjlEMTtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDI5RDA7JiN4MzM4O1wiOlwifCBcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI5RDA7XCI6XCJ8IFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyOUNGOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0IHxcIixcIiYjeDI5Q0Y7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0IHxcIixcIiYjeDI5Q0U7XCI6XCJcIixcIiYjeDI5Q0Q7XCI6XCJcXFxcdHJpYW5nbGVcIixcIiYjeDI5Q0M7XCI6XCJcIixcIiYjeDI5Q0I7XCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0cmlhbmdsZX1cIixcIiYjeDI5Q0E7XCI6XCJcXFxcZG90e1xcXFx0cmlhbmdsZX1cIixcIiYjeDI5Qzk7XCI6XCJcIixcIiYjeDI5Qzg7XCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCImI3gyOUM3O1wiOlwiXFxcXGJveGVke1xcXFxjaXJjfVwiLFwiJiN4MjlDNjtcIjpcIlxcXFxib3hlZHtcXFxccmlnaHRhcnJvd31cIixcIiYjeDI5QzU7XCI6XCJcXFxcYmNhbmNlbHtcXFxcc3F1YXJlfVwiLFwiJiN4MjlDNDtcIjpcIlxcXFxjYW5jZWx7XFxcXHNxdWFyZX1cIixcIiYjeDI5QzM7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjlDMjtcIjpcIlxcXFxvZG90XCIsXCImI3gyOUJGO1wiOlwiXFxcXG9kb3RcIixcIiYjeDI5QkU7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjlCRDtcIjpcIlxcXFx2YXJub3RoaW5nXCIsXCImI3gyOUJDO1wiOlwiXFxcXG9wbHVzXCIsXCImI3gyOUJCO1wiOlwiXFxcXG90aW1lc1wiLFwiJiN4MjlCQTtcIjpcIlwiLFwiJiN4MjlCOTtcIjpcIlxcXFx2YXJub3RoaW5nXCIsXCImI3gyOUI4O1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5Qjc7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyOUI2O1wiOlwiXFxcXG9taW51c1wiLFwiJiN4MjlCNTtcIjpcIlxcXFxvbWludXNcIixcIiYjeDI5QjQ7XCI6XCJcXFxcdmVje1xcXFx2YXJub3RoaW5nfVwiLFwiJiN4MjlCMztcIjpcIlxcXFx2ZWN7XFxcXHZhcm5vdGhpbmd9XCIsXCImI3gyOUIyO1wiOlwiXFxcXGRvdHtcXFxcdmFybm90aGluZ31cIixcIiYjeDI5QjE7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHZhcm5vdGhpbmd9XCIsXCImI3gyOUIwO1wiOlwiXFxcXHZhcm5vdGhpbmdcIixcIiYjeDI5QUY7XCI6XCJcIixcIiYjeDI5QUU7XCI6XCJcIixcIiYjeDI5QUQ7XCI6XCJcIixcIiYjeDI5QUM7XCI6XCJcIixcIiYjeDI5QUI7XCI6XCJcIixcIiYjeDI5QUE7XCI6XCJcIixcIiYjeDI5QTk7XCI6XCJcIixcIiYjeDI5QTg7XCI6XCJcIixcIiYjeDI5QTc7XCI6XCJcIixcIiYjeDI5QTY7XCI6XCJcIixcIiYjeDI5QTU7XCI6XCJcIixcIiYjeDI5QTQ7XCI6XCJcIixcIiYjeDI5QTM7XCI6XCJcIixcIiYjeDI5QTI7XCI6XCJcIixcIiYjeDI5QTE7XCI6XCJcXFxcbm90XFxcXGxvclwiLFwiJiN4MjlBMDtcIjpcIlxcXFxiY2FuY2Vsez59XCIsXCImI3gyOTgyO1wiOlwiOlwiLFwiJiN4Mjk4MTtcIjpcIlxcXFxjaXJjXCIsXCImI3gyNzU4O1wiOlwifFwiLFwiJiN4MjVCMjtcIjpcIlxcXFxiaWd0cmlhbmdsZXVwXCIsXCImI3gyMkZGO1wiOlwiXFxcXEVwc2lsb25cIixcIiYjeDIyRkU7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG5pfVwiLFwiJiN4MjJGRDtcIjpcIlxcXFxvdmVybGluZXtcXFxcbml9XCIsXCImI3gyMkZDO1wiOlwiXFxcXGluXCIsXCImI3gyMkZCO1wiOlwiXFxcXGluXCIsXCImI3gyMkZBO1wiOlwiXFxcXGluXCIsXCImI3gyMkY5O1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaW59XCIsXCImI3gyMkY4O1wiOlwiXFxcXHVuZGVybGluZXtcXFxcaW59XCIsXCImI3gyMkY3O1wiOlwiXFxcXG92ZXJsaW5le1xcXFxpbn1cIixcIiYjeDIyRjY7XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGlufVwiLFwiJiN4MjJGNTtcIjpcIlxcXFxkb3R7XFxcXGlufVwiLFwiJiN4MjJGNDtcIjpcIlxcXFxpblwiLFwiJiN4MjJGMztcIjpcIlxcXFxpblwiLFwiJiN4MjJGMjtcIjpcIlxcXFxpblwiLFwiJiN4MjJGMDtcIjpcIlxcXFxkZG90c1wiLFwiJiN4MjJFOTtcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3VjY31cIixcIiYjeDIyRTg7XCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHByZWN9XCIsXCImI3gyMkU3O1wiOlwiXFxcXHVuZGVyc2V0e1xcXFxub3RcXFxcc2ltfXs+fVwiLFwiJiN4MjJFNjtcIjpcIlxcXFx1bmRlcnNldHtcXFxcbm90XFxcXHNpbX17PH1cIixcIiYjeDIyRTU7XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIiYjeDIyRTQ7XCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0ZXFcIixcIiYjeDIyRTM7XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIiYjeDIyRTI7XCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0ZXFcIixcIiYjeDIyRTE7XCI6XCJcXFxcbnN1Y2NcIixcIiYjeDIyRTA7XCI6XCJcXFxcbnByZWNcIixcIiYjeDIyREY7XCI6XCJcXFxcc3VjY1wiLFwiJiN4MjJERTtcIjpcIlxcXFxwcmVjXCIsXCImI3gyMkREO1wiOlwiXFxcXG92ZXJsaW5lez59XCIsXCImI3gyMkRDO1wiOlwiXFxcXG92ZXJsaW5lezx9XCIsXCImI3gyMkRCO1wiOlwiXFxcXHVuZGVyc2V0ez59e1xcXFxsZXF9XCIsXCImI3gyMkRBO1wiOlwiXFxcXHVuZGVyc2V0ezx9e1xcXFxnZXF9XCIsXCImI3gyMkQ1O1wiOlwiXFxcXCNcIixcIiYjeDIyRDM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMkQyO1wiOlwiXFxcXGNhcFwiLFwiJiN4MjJEMTtcIjpcIlxcXFxzdXBzZXRcIixcIiYjeDIyRDA7XCI6XCJcXFxcc3Vic2V0XCIsXCImI3gyMkNGO1wiOlwiXFxcXHdlZGdlXCIsXCImI3gyMkNFO1wiOlwiXFxcXHZlZVwiLFwiJiN4MjJDRDtcIjpcIlxcXFxzaW1lcVwiLFwiJiN4MjJDODtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDIyQzc7XCI6XCJcXFxcYXN0XCIsXCImI3gyMkM2O1wiOlwiXFxcXHN0YXJcIixcIiYjeDIyQzQ7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjJCRjtcIjpcIlxcXFx0cmlhbmdsZVwiLFwiJiN4MjJCRTtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCImI3gyMkJEO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxsb3J9XCIsXCImI3gyMkJDO1wiOlwiXFxcXG92ZXJsaW5le1xcXFxsYW5kfVwiLFwiJiN4MjJCQjtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGxvcn1cIixcIiYjeDIyQkE7XCI6XCJcXFxcdG9wXCIsXCImI3gyMkI5O1wiOlwiXCIsXCImI3gyMkI3O1wiOlwiXFxcXGNpcmNcXFxcbXVsdGltYXBcIixcIiYjeDIyQjY7XCI6XCJcXFxcY2lyY1xcXFxtdWx0aW1hcFwiLFwiJiN4MjJCMztcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyMkIyO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjJCMTtcIjpcIlxcXFxzdWNjXCIsXCImI3gyMkIwO1wiOlwiXFxcXHByZWNcIixcIiYjeDIyQUI7XCI6XCJ8XFxcXG1vZGVsc1wiLFwiJiN4MjJBQTtcIjpcInxcXFxcbW9kZWxzXCIsXCImI3gyMkE3O1wiOlwiXFxcXG1vZGVsc1wiLFwiJiN4MjJBNjtcIjpcIlxcXFx2ZGFzaFwiLFwiJiN4MjI5RDtcIjpcIlxcXFxvbWludXNcIixcIiYjeDIyOUM7XCI6XCJcXFxcb21pbnVzXCIsXCImI3gyMjlCO1wiOlwiXFxcXG9kb3RcIixcIiYjeDIyOUE7XCI6XCJcXFxcb2RvdFwiLFwiJiN4MjI5NDtcIjpcIlxcXFxzcWN1cFwiLFwiJiN4MjI5MztcIjpcIlxcXFxzcWNhcFwiLFwiJiN4MjI5MjtcIjpcIlxcXFxzcXN1cHNldGVxXCIsXCImI3gyMjkxO1wiOlwiXFxcXHNxc3Vic2V0ZXFcIixcIiYjeDIyOTA7JiN4MzM4O1wiOlwiXFxcXG5vdFxcXFxzcXN1cHNldFwiLFwiJiN4MjI5MDtcIjpcIlxcXFxzcXN1cHNldFwiLFwiJiN4MjI4RjsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXHNxc3Vic2V0XCIsXCImI3gyMjhGO1wiOlwiXFxcXHNxc3Vic2V0XCIsXCImI3gyMjhFO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjI4RDtcIjpcIlxcXFxjdXBcIixcIiYjeDIyOEM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMjdGOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcc3VjY3NpbVwiLFwiJiN4MjI3RjtcIjpcIlxcXFxzdWNjc2ltXCIsXCImI3gyMjdFO1wiOlwiXFxcXHByZWNzaW1cIixcIiYjeDIyNzk7XCI6XCJcXFxcbm90XFxcXG92ZXJzZXR7Pn17PH1cIixcIiYjeDIyNzg7XCI6XCJcXFxcbm90XFxcXG92ZXJzZXR7Pn17PH1cIixcIiYjeDIyNzc7XCI6XCJcXFxcb3ZlcnNldHs+fXs8fVwiLFwiJiN4MjI3NjtcIjpcIlxcXFxvdmVyc2V0ezx9ez59XCIsXCImI3gyMjc1O1wiOlwiXFxcXG5vdFxcXFxnZWdcIixcIiYjeDIyNzQ7XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwiJiN4MjI3MztcIjpcIlxcXFxnZWdcIixcIiYjeDIyNzI7XCI6XCJcXFxcbGVxXCIsXCImI3gyMjZDO1wiOlwiXCIsXCImI3gyMjY3O1wiOlwiXFxcXGdlZ1wiLFwiJiN4MjI2NjsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXGxlcVwiLFwiJiN4MjI2NjtcIjpcIlxcXFxsZXFcIixcIiYjeDIyNjM7XCI6XCJcXFxcb3ZlcnNldHs9fXs9fSBcIixcIiYjeDIyNUU7XCI6XCJcXFxcb3ZlcnNldHttfXs9fSBcIixcIiYjeDIyNUQ7XCI6XCJcXFxcb3ZlcnNldHtkZWZ9ez19XCIsXCImI3gyMjU4O1wiOlwiPVwiLFwiJiN4MjI1NjtcIjpcIj1cIixcIiYjeDIyNTU7XCI6XCI9OlwiLFwiJiN4MjI1MztcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1MjtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1MTtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1MDtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI0RjsmI3gzMzg7XCI6XCJcIixcIiYjeDIyNEY7XCI6XCJcIixcIiYjeDIyNEU7JiN4MzM4O1wiOlwiXCIsXCImI3gyMjRFO1wiOlwiXCIsXCImI3gyMjRDO1wiOlwiXFxcXGFwcHJveFwiLFwiJiN4MjI0QjtcIjpcIlxcXFxhcHByb3hcIixcIiYjeDIyNEE7XCI6XCJcXFxcYXBwcm94XCIsXCImI3gyMjQyOyYjeDMzODtcIjpcIlxcXFxuZXFcIixcIiYjeDIyNDI7XCI6XCI9XCIsXCImI3gyMjNGO1wiOlwiXFxcXHNpbVwiLFwiJiN4MjIzRTtcIjpcIlxcXFxpbmZ0eVwiLFwiJiN4MjIzRDsmI3gzMzE7XCI6XCJcXFxcc2ltXCIsXCImI3gyMjNEO1wiOlwiXFxcXHNpbVwiLFwiJiN4MjIzQjtcIjpcIlxcXFxzaW1cIixcIiYjeDIyM0E7XCI6XCI6LTpcIixcIiYjeDIyMzk7XCI6XCItOlwiLFwiJiN4MjIzODtcIjpcIlxcXFxib3RcIixcIiYjeDIyMzc7XCI6XCI6OlwiLFwiJiN4MjIzNjtcIjpcIjpcIixcIiYjeDIyMjM7XCI6XCJ8XCIsXCImI3gyMjFGO1wiOlwiXFxcXGxsY29ybmVyXCIsXCImI3gyMjE5O1wiOlwiXFxcXGNkb3RcIixcIiYjeDIyMTg7XCI6XCJcXFxcY2lyY1wiLFwiJiN4MjIxNztcIjpcIipcIixcIiYjeDIyMTU7XCI6XCIvXCIsXCImI3gyMjBFO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjIwRDtcIjpcIlxcXFxuaVwiLFwiJiN4MjIwQTtcIjpcIlxcXFxpblwiLFwiJiN4MjIwNjtcIjpcIlxcXFxEZWx0YVwiLFwiJiN4MjA0NDtcIjpcIi9cIixcIiYjeDJBQjA7JiN4MzM4O1wiOlwiXFxcXG5zdWNjZXFcIixcIiYjeDJBQjA7XCI6XCJcXFxcc3VjY2VxXCIsXCImI3gyQUFGOyYjeDMzODtcIjpcIlxcXFxucHJlY2VxXCIsXCImI3gyQUFGO1wiOlwiXFxcXHByZWNlcVwiLFwiJiN4MkE4ODtcIjpcIlxcXFxuZ2Vxc2xhbnRcIixcIiYjeDJBODc7XCI6XCJcXFxcbmxlcXNsYW50XCIsXCImI3gyOUYzO1wiOlwiXFxcXFBoaVwiLFwiJiN4MjlFNjtcIjpcIlxcXFxtb2RlbHNcIixcIiYjeDI5RTU7XCI6XCJcXFxcbm90XFxcXGVxdWl2XCIsXCImI3gyOUU0O1wiOlwiXFxcXGFwcHJveFxcXFxuZXFcIixcIiYjeDI5RTM7XCI6XCJcXFxcbmVxXCIsXCImI3gyOUMxO1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjlDMDtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1RTY7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyNUQ3O1wiOlwiXFxcXGNpcmNsZVwiLFwiJiN4MjVENjtcIjpcIlxcXFxjaXJjbGVcIixcIiYjeDI1Q0Y7XCI6XCJcXFxcY2lyY2xlXCIsXCImI3gyNUNFO1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUNEO1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUNDO1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUM5O1wiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCImI3gyNUM4O1wiOlwiXFxcXGRpYW1vbmRcIixcIiYjeDI1Qzc7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjVDNjtcIjpcIlxcXFxkaWFtb25kXCIsXCImI3gyNUM1O1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDNDtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QzM7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUMyO1wiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjVDMTtcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDI1QzA7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyNUJGO1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwiJiN4MjVCRTtcIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIiYjeDI1QkQ7XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCImI3gyNUJDO1wiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwiJiN4MjVCOTtcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyNUI4O1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI1Qjc7XCI6XCJcXFxcdHJpYW5nbGVyaWdodFwiLFwiJiN4MjVCNjtcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyNUI1O1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyNUI0O1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyNUIzO1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCImI3gyNUIxO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVCMDtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUY7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUFFO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBRDtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QUI7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyNUFBO1wiOlwiXFxcXHNxdWFyZVwiLFwiJiN4MjVBMTtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDI1QTA7XCI6XCJcXFxcc3F1YXJlXCIsXCImI3gyMkVEO1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyMkVDO1wiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnRcIixcIiYjeDIyRUI7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDIyRUE7XCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdFwiLFwiJiN4MjJEOTtcIjpcIlxcXFxnZ2dcIixcIiYjeDIyRDg7XCI6XCJcXFxcbGxsXCIsXCImI3gyMkQ3O1wiOlwiKj5cIixcIiYjeDIyRDY7XCI6XCI8KlwiLFwiJiN4MjJENDtcIjpcIlxcXFxwaXRjaGZvcmtcIixcIiYjeDIyQ0M7XCI6XCJcIixcIiYjeDIyQ0I7XCI6XCJcIixcIiYjeDIyQ0E7XCI6XCJcXFxccnRpbWVzXCIsXCImI3gyMkM5O1wiOlwiXFxcXGx0aW1lc1wiLFwiJiN4MjJCNTtcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCImI3gyMkI0O1wiOlwiXCIsXCImI3gyMkE1O1wiOlwiXFxcXGJvdFwiLFwiJiN4MjI4MTtcIjpcIlxcXFxuc3VjY1wiLFwiJiN4MjI4MDtcIjpcIlxcXFxwcmVjZXFcIixcIiYjeDIyN0Q7XCI6XCJcXFxcc3VjY2VxXCIsXCImI3gyMjdDO1wiOlwiXFxcXHByZWNlcVwiLFwiJiN4MjI3QjtcIjpcIlxcXFxzdWNjXCIsXCImI3gyMjdBO1wiOlwiXFxcXHByZWNcIixcIiYjeDIyNzE7XCI6XCJcXFxcZ2VxL1wiLFwiJiN4MjI3MDtcIjpcIlxcXFxsZXEvXCIsXCImI3gyMjZEO1wiOlwiXFxcXG5lcVwiLFwiJiN4MjI2QjsmI3gzMzg7XCI6XCJcXFxcbm90XFxcXGdnXCIsXCImI3gyMjZCO1wiOlwiXFxcXGdnXCIsXCImI3gyMjZBOyYjeDMzODtcIjpcIlxcXFxub3RcXFxcbGxcIixcIiYjeDIyNkE7XCI6XCJcXFxcbGxcIixcIiYjeDIyNjk7XCI6XCJcXFxcbmdlcXNsYW50XCIsXCImI3gyMjY4O1wiOlwiXFxcXG5sZXFzbGFudFwiLFwiJiN4MjI2MTtcIjpcIlxcXFxlcXVpdlwiLFwiJiN4MjI1RjtcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1QztcIjpcIlxcXFx0cmlhbmdsZXFcIixcIiYjeDIyNUI7XCI6XCJcXFxcZG90ZXFcIixcIiYjeDIyNUE7XCI6XCJcXFxcdHJpYW5nbGVxXCIsXCImI3gyMjU5O1wiOlwiXFxcXHRyaWFuZ2xlcVwiLFwiJiN4MjI1NztcIjpcIlxcXFxkb3RlcVwiLFwiJiN4MjI1NDtcIjpcIjo9XCIsXCImI3gyMjREO1wiOlwiXFxcXGFzeW1wXCIsXCImI3gyMjQ3O1wiOlwiXFxcXG5jb25nXCIsXCImI3gyMjQ2O1wiOlwiXFxcXG5jb25nXCIsXCImI3gyMjQ1O1wiOlwiXFxcXGNvbmdcIixcIiYjeDIyNDQ7XCI6XCJcXFxcbm90XFxcXHNpbWVxXCIsXCImI3gyMjQzO1wiOlwiXFxcXHNpbWVxXCIsXCImI3gyMjQxO1wiOlwiXFxcXG5vdFxcXFxzaW1cIixcIiYjeDIyMjY7XCI6XCJcXFxcbm90XFxcXHBhcmFsbGVsXCIsXCImI3gyMjI1O1wiOlwiXFxcXHBhcmFsbGVsXCIsXCImI3gyMjI0O1wiOlwiXFxcXG5vdHxcIixcIiYjeDIyMUQ7XCI6XCJcXFxccHJvcHRvXCIsXCI9PVwiOlwiPT1cIixcIj1cIjpcIj1cIixcIjo9XCI6XCI6PVwiLFwiLz1cIjpcIj1cIixcIi09XCI6XCItPVwiLFwiKz1cIjpcIis9XCIsXCIqPVwiOlwiKj1cIixcIiE9XCI6XCIhPVwiLFwiJiN4MjI2MDtcIjpcIlxcXFxuZXFcIixcIiYjeDIyNjI7XCI6XCJcXFxcZXF1aXYgL1wiLFwiJiN4MjI0OTtcIjpcIlxcXFxhcHByb3ggL1wiLFwiJiN4MjIzQztcIjpcInNpbVwiLFwiJiN4MjI0ODtcIjpcIlxcXFxhcHByb3hcIixcIiYjeDIyNkU7XCI6XCI8L1wiLFwiJmx0O1wiOlwiPFwiLFwiJiN4MjI2RjtcIjpcIj4vXCIsXCI+PVwiOlwiPj1cIixcIj5cIjpcIj5cIixcIiYjeDIyNjU7XCI6XCJcXFxcZ2VxXCIsXCImI3gyMjY0O1wiOlwiXFxcXGxlcVwiLFwiJmx0Oz1cIjpcIjw9XCIsXCImI3gyMjhCO1wiOlwiXFxcXHN1cHNldG5lcVwiLFwiJiN4MjI4QTtcIjpcIlxcXFxzdWJzZXRuZXFcIixcIiYjeDIyODk7XCI6XCJcXFxcbnN1cHNldGVxXCIsXCImI3gyMjg4O1wiOlwiXFxcXG5zdWJzZXRlcVwiLFwiJiN4MjI4NztcIjpcIlxcXFxzdXBzZXRlcVwiLFwiJiN4MjI4NjtcIjpcIlxcXFxzdWJzZXRlcVwiLFwiJiN4MjI4NTtcIjpcIlxcXFxub3RcXFxcc3Vwc2V0XCIsXCImI3gyMjg0O1wiOlwiXFxcXG5vdFxcXFxzdWJzZXRcIixcIiYjeDIyODM7JiN4MjBEMjtcIjpcIlxcXFxzdXBzZXQgfFwiLFwiJiN4MjI4MztcIjpcIlxcXFxzdXBzZXRcIixcIiYjeDIyODI7JiN4MjBEMjtcIjpcIlxcXFxzdWJzZXQgfFwiLFwiJiN4MjI4MjtcIjpcIlxcXFxzdWJzZXRcIixcIiYjeDIyMEM7XCI6XCJcXFxcbm90XFxcXGluXCIsXCImI3gyMjA5O1wiOlwiXFxcXG5vdGluXCIsXCImI3gyMjA4O1wiOlwiXFxcXGluXCIsXCImI3gyMjAxO1wiOlwiQ1wiLFwiJiN4MjIwNDtcIjpcIlxcXFxuZXhpc3RzXCIsXCImI3gyMjAzO1wiOlwiXFxcXGV4aXN0c1wiLFwiJiN4MjIwMDtcIjpcIlxcXFxmb3JhbGxcIixcIiYjeDIyMjc7XCI6XCJcXFxcbGFuZFwiLFwiJmFtcDsmYW1wO1wiOlwiXFxcXCZcXFxcJlwiLFwiJiN4MjIyODtcIjpcIlxcXFxsb3JcIixcIiYjeDIyQUY7XCI6XCJcXFxcY2FuY2Vse1xcXFx2RGFzaH1cIixcIiYjeDIyQUU7XCI6XCJcXFxcY2FuY2Vse1xcXFxWZGFzaH1cIixcIiYjeDIyQUQ7XCI6XCJcXFxcbnZEYXNoXCIsXCImI3gyMkFDO1wiOlwiXFxcXG52RGFzaFwiLFwiJiN4MjJBOTtcIjpcIlxcXFxWZGFzaFwiLFwiJiN4MjJBODtcIjpcIlxcXFx2RGFzaFwiLFwiJiN4MjJBNDtcIjpcIlxcXFx0b3BcIixcIiYjeDIyQTM7XCI6XCJcXFxcZGFzaHZcIixcIiYjeDIyQTI7XCI6XCJcXFxcdmRhc2hcIixcIiYjeDIyMEI7XCI6XCJcXFxcbmlcIixcIiYjeDIyRjE7XCI6XCJcXFxcZGRvdHNcIixcIiYjeDIyRUY7XCI6XCJcXFxcaGRvdHNcIixcIiYjeDIyRUU7XCI6XCJcXFxcdmRvdHNcIixcIiYjeDIwMjY7XCI6XCJcXFxcaGRvdHNcIixcIiYjeDNGNjtcIjpcIlxcXFxuaVwiLFwiOlwiOlwiOlwiLFwiLi4uXCI6XCJcXFxcY2RvdHNcIixcIi4uXCI6XCIuLlwiLFwiLT5cIjpcIi0+XCIsXCImI3gyMjM1O1wiOlwiXFxcXGJlY2F1c2VcIixcIiYjeDIyMzQ7XCI6XCJcXFxcdGhlcmVmb3JlIFwiLFwiJiN4MjA2MztcIjpcIlwiLFwiLFwiOlwiLFwiLFwiO1wiOlwiO1wiLFwiJiN4MjlGRDtcIjpcIlxcXFx9XCIsXCImI3gyOUZDO1wiOlwiXFxcXHtcIixcIiYjeDI5OTg7XCI6XCJcXFxcXVwiLFwiJiN4Mjk5NztcIjpcIlxcXFxbXCIsXCImI3gyOTk2O1wiOlwiXFxcXGxsXCIsXCImI3gyOTk1O1wiOlwiXFxcXGdnXCIsXCImI3gyOTk0O1wiOlwiXFxcXGdnXCIsXCImI3gyOTkzO1wiOlwiXFxcXGxsXCIsXCImI3gyOTkyO1wiOlwiXFxcXGdnXCIsXCImI3gyOTkxO1wiOlwiXFxcXGxsXCIsXCImI3gyOTkwO1wiOlwiXFxcXF1cIixcIiYjeDI5OEY7XCI6XCJcXFxcXVwiLFwiJiN4Mjk4RTtcIjpcIlxcXFxdXCIsXCImI3gyOThEO1wiOlwiXFxcXFtcIixcIiYjeDI5OEM7XCI6XCJcXFxcW1wiLFwiJiN4Mjk4QjtcIjpcIlxcXFxdXCIsXCImI3gyOThBO1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIiYjeDI5ODk7XCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCImI3gyOTg4O1wiOlwifFxcXFwpXCIsXCImI3gyOTg3O1wiOlwiXFxcXCh8XCIsXCImI3gyOTg2O1wiOlwifFxcXFwpXCIsXCImI3gyOTg1O1wiOlwiXFxcXChcXFxcKFwiLFwiJiN4Mjk4NDtcIjpcInxcXFxcfVwiLFwiJiN4Mjk4MztcIjpcIlxcXFx7fFwiLFwiJiN4Mjk4MDtcIjpcIlxcXFx8fFwiLFwiJiN4MjdFRjtcIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXCIsXCImI3gyN0VFO1wiOlwiXFxcXGxlZnRbIFxcXFxyaWdodC5cIixcIiYjeDI3RUQ7XCI6XCJcXFxcbGVmdC4gXFxcXHJpZ2h0XV1cIixcIiYjeDI3RUM7XCI6XCJcXFxcbGVmdFtbIFxcXFxyaWdodC5cIixcIiYjeDI3RUI7XCI6XCJcXFxcZ2dcIixcIiYjeDI3RUE7XCI6XCJcXFxcbGxcIixcIiYjeDI3RTk7XCI6XCJcXFxccmFuZ2xlXCIsXCImI3gyN0U4O1wiOlwiXFxcXGxhbmdsZVwiLFwiJiN4MjdFNztcIjpcIlxcXFxsZWZ0LiBcXFxccmlnaHRdXVwiLFwiJiN4MjdFNjtcIjpcIlxcXFxsZWZ0W1sgXFxcXHJpZ2h0LlwiLFwiJiN4Mjc3MztcIjpcIlxcXFxsZWZ0LlxcXFxyaWdodClcIixcIiYjeDI3NzI7XCI6XCJcXFxcbGVmdChcXFxccmlnaHQuXCIsXCImI3gyMzJBO1wiOlwiXFxcXHJhbmdsZVwiLFwiJiN4MjMyOTtcIjpcIlxcXFxsYW5nbGVcIixcIiYjeDIzMEI7XCI6XCJcXFxccmZsb29yXCIsXCImI3gyMzBBO1wiOlwiXFxcXGxmbG9vclwiLFwiJiN4MjMwOTtcIjpcIlxcXFxyY2VpbFwiLFwiJiN4MjMwODtcIjpcIlxcXFxsY2VpbFwiLFwiJiN4MjAxNjtcIjpcIlxcXFxwYXJhbGxlbFwiLFwifVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0fVwiLFwie1wiOlwiXFxcXGxlZnR7XFxcXHJpZ2h0LlwiLFwiXVwiOlwiXFxcXGxlZnRdXFxcXHJpZ2h0LlwiLFwiW1wiOlwiXFxcXGxlZnRbXFxcXHJpZ2h0LlwiLFwiKVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0KVwiLFwiKFwiOlwiXFxcXGxlZnQoXFxcXHJpZ2h0LlwiLFwiJiN4MjAxRDtcIjonXCInLFwiJiN4MjAxQztcIjpcImBgXCIsXCImI3gyMDE5O1wiOlwiJ1wiLFwiJiN4MjAxODtcIjpcImBcIixcIiVDRSVCMVwiOlwiXFxcXGFscGhhXCIsXCIlQ0UlQjJcIjpcIlxcXFxiZXRhXCIsXCIlQ0UlQjNcIjpcIlxcXFxnYW1tYVwiLFwiJUNFJTkzXCI6XCJcXFxcR2FtbWFcIixcIiVDRSVCNFwiOlwiXFxcXGRlbHRhXCIsXCIlQ0UlOTRcIjpcIlxcXFxEZWx0YVwiLFwiJUNGJUI1XCI6XCJcXFxcZXBzaWxvblwiLFwiJUNFJUI2XCI6XCJcXFxcemV0YVwiLFwiJUNFJUI3XCI6XCJcXFxcZXRhXCIsXCIlQ0UlQjhcIjpcIlxcXFx0aGV0YVwiLFwiJUNFJTk4XCI6XCJcXFxcVGhldGFcIixcIiVDRSVCOVwiOlwiXFxcXGlvdGFcIixcIiVDRSVCQVwiOlwiXFxcXGthcHBhXCIsXCIlQ0UlQkJcIjpcIlxcXFxsYW1iZGFcIixcIiVDRSVCQ1wiOlwiXFxcXG11XCIsXCIlQ0UlQkRcIjpcIlxcXFxudVwiLFwiJUNFJUJGXCI6XCJcXFxcb21pY3JvblwiLFwiJUNGJTgwXCI6XCJcXFxccGlcIixcIiVDRSVBMFwiOlwiXFxcXFBpXCIsXCIlQ0YlODFcIjpcIlxcXFxwaG9cIixcIiVDRiU4M1wiOlwiXFxcXHNpZ21hXCIsXCIlQ0UlQTNcIjpcIlxcXFxTaWdtYVwiLFwiJUNGJTg0XCI6XCJcXFxcdGF1XCIsXCIlQ0YlODVcIjpcIlxcXFx1cHNpbG9uXCIsXCIlQ0UlQTVcIjpcIlxcXFxVcHNpbG9uXCIsXCIlQ0YlOTVcIjpcIlxcXFxwaGlcIixcIiVDRSVBNlwiOlwiXFxcXFBoaVwiLFwiJUNGJTg3XCI6XCJcXFxcY2hpXCIsXCIlQ0YlODhcIjpcIlxcXFxwc2lcIixcIiVDRSVBOFwiOlwiXFxcXFBzaVwiLFwiJUNGJTg5XCI6XCJcXFxcb21lZ2FcIixcIiVDRSVBOVwiOlwiXFxcXE9tZWdhXCJ9fSw5MDM5OihlLHQpPT57XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5hbGxNYXRoT3BlcmF0b3JzQnlHbHlwaD12b2lkIDAsdC5hbGxNYXRoT3BlcmF0b3JzQnlHbHlwaD17XzpcIlxcXFx1bmRlcmxpbmVcIixcIuKPoVwiOlwiXFxcXHVuZGVyYnJhY2VcIixcIuKPoFwiOlwiXFxcXG92ZXJicmFjZVwiLFwi4o+fXCI6XCJcXFxcdW5kZXJicmFjZVwiLFwi4o+eXCI6XCJcXFxcb3ZlcmJyYWNlXCIsXCLij51cIjpcIlxcXFx1bmRlcmJyYWNlXCIsXCLij5xcIjpcIlxcXFxvdmVyYnJhY2VcIixcIuKOtVwiOlwiXFxcXHVuZGVyYnJhY2VcIixcIuKOtFwiOlwiXFxcXG92ZXJicmFjZVwiLFwi4oOcXCI6XCJcXFxcc3F1YXJlXCIsXCLig5tcIjpcIlxcXFxzcXVhcmVcIixcIuKBpFwiOlwiXCIsXCLigZdcIjpcIicnJydcIixcIuKAvlwiOlwiXFxcXG92ZXJsaW5lXCIsXCLigLdcIjpcImBgYFwiLFwi4oC2XCI6XCJgYFwiLFwi4oC1XCI6XCJgXCIsXCLigLRcIjpcIicnJ1wiLFwi4oCzXCI6XCInJ1wiLFwi4oCfXCI6XCJgYFwiLFwi4oCeXCI6XCIsLFwiLFwi4oCbXCI6XCJgXCIsXCLigJpcIjpcIixcIixcIl5cIjpcIlxcXFxoYXRcIixcIsu3XCI6XCJcXFxcc2ltXCIsXCLLnVwiOlwiXFxcXHNpbVwiLFwiy5xcIjpcIlxcXFxzaW1cIixcIsuaXCI6XCJcXFxcY2lyY1wiLFwiy5lcIjpcIlxcXFxjZG90XCIsXCLLmFwiOlwiIFwiLMuNOlwiXFxcXF9cIizLizpcIsuLXCIsy4o6XCLLilwiLMuJOlwiy4lcIizLhzpcIlwiLMuGOlwiXFxcXGhhdFwiLMK6Olwib1wiLFwiwrlcIjpcIjFcIixcIsK4XCI6XCIsXCIsXCLCtFwiOlwiwrRcIixcIsKzXCI6XCIzXCIsXCLCslwiOlwiMlwiLFwiwrBcIjpcIlxcXFxjaXJjXCIsXCLCr1wiOlwiXFxcXGJhclwiLMKqOlwiYVwiLFwi4oabXCI6XCJcXFxcbnJpZ2h0YXJyb3dcIixcIsKoXCI6XCJcXFxcY2RvdFxcXFxjZG90XCIsXCJ+XCI6XCJcXFxcc2ltXCIsXCJgXCI6XCJgXCIsXCItLVwiOlwiLS1cIixcIisrXCI6XCIrK1wiLFwiJlwiOlwiXFxcXCZcIixcIuKInFwiOlwiXFxcXHNxcnRbNF17fVwiLFwi4oibXCI6XCJcXFxcc3FydFszXXt9XCIsXCLiiJpcIjpcIlxcXFxzcXJ0e31cIizihYY6XCJkXCIs4oWFOlwiXFxcXG1hdGhiYntEfVwiLFwiP1wiOlwiP1wiLFwiQFwiOlwiQFwiLFwiLy9cIjpcIi8vXCIsXCIhIVwiOlwiISFcIixcIiFcIjpcIiFcIixcIuKZr1wiOlwiXFxcXCNcIixcIuKZrlwiOlwiXCIsXCLima1cIjpcIlwiLFwi4oCyXCI6XCInXCIsXCI8PlwiOlwiPD5cIixcIioqXCI6XCJcXFxcc3RhclxcXFxzdGFyXCIsXCLiiIdcIjpcIlxcXFxuYWJsYVwiLFwi4oiCXCI6XCJcXFxccGFydGlhbFwiLFwi4oqZXCI6XCJcXFxcYmlnb2RvdFwiLFwiwqxcIjpcIlxcXFxuZWdcIixcIuKIolwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKIoVwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKIoFwiOlwiXFxcXGFuZ2xlXCIsXCLDt1wiOlwiXFxcXGRpdlwiLFwiL1wiOlwiL1wiLFwi4oiWXCI6XCJcXFxcYmFja3NsYXNoXCIsXCJcXFxcXCI6XCJcXFxcYmFja3NsYXNoXCIsXCIlXCI6XCJcXFxcJVwiLFwi4oqXXCI6XCJcXFxcYmlnb3RpbWVzXCIsXCLCt1wiOlwiXFxcXGNkb3RcIixcIuKov1wiOlwiXFxcXGNvcHJvZFwiLFwi4qivXCI6XCJcXFxcdGltZXNcIixcIuKLhVwiOlwiXFxcXGNkb3RcIixcIuKKoVwiOlwiXFxcXGJveGRvdFwiLFwi4oqgXCI6XCJcXFxcYm94dGltZXNcIixcIuKBolwiOlwiXCIsXCLigYNcIjpcIi1cIixcIuKAolwiOlwiXFxcXGNkb3RcIixcIi5cIjpcIi5cIixcIipcIjpcIlxcXFxzdGFyXCIsXCLiiKpcIjpcIlxcXFxjdXBcIixcIuKIqVwiOlwiXFxcXGNhcFwiLFwi4oiQXCI6XCJcXFxcY29wcm9kXCIsXCLiiI9cIjpcIlxcXFxwcm9kXCIsXCLiiYBcIjpcIlwiLFwi4qu/XCI6XCJcIixcIuKrvFwiOlwiXFxcXG1pZFxcXFxtaWRcXFxcbWlkXCIsXCLiqIlcIjpcIlxcXFx0aW1lc1wiLFwi4qiIXCI6XCJcIixcIuKoh1wiOlwiXCIsXCLiqIZcIjpcIlxcXFxzcWN1cFwiLFwi4qiFXCI6XCJcXFxcc3FjYXBcIixcIuKoglwiOlwiXFxcXG90aW1lc1wiLFwi4qiAXCI6XCJcXFxcb2RvdFwiLFwi4ouCXCI6XCJcXFxcY2FwXCIsXCLii4FcIjpcIlxcXFx2ZWVcIixcIuKLgFwiOlwiXFxcXHdlZGdlXCIsXCLiqIRcIjpcIlxcXFx1cGx1c1wiLFwi4qiDXCI6XCJcXFxcY3VwXCIsXCLii4NcIjpcIlxcXFxjdXBcIixcIuKonFwiOlwiXFxcXHVuZGVybGluZXtcXFxcaW50fVwiLFwi4qibXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGludH1cIixcIuKomlwiOlwiXFxcXGludFwiLFwi4qiZXCI6XCJcXFxcaW50XCIsXCLiqJhcIjpcIlxcXFxpbnRcIixcIuKol1wiOlwiXFxcXGludFwiLFwi4qiWXCI6XCJcXFxcb2ludFwiLFwi4qiVXCI6XCJcXFxcb2ludFwiLFwi4qiUXCI6XCJcXFxcaW50XCIsXCLiqJNcIjpcIlxcXFxpbnRcIixcIuKoklwiOlwiXFxcXGludFwiLFwi4qiRXCI6XCJcXFxcaW50XCIsXCLiqJBcIjpcIlxcXFxpbnRcIixcIuKoj1wiOlwiXFxcXGJjYW5jZWx7XFxcXGludH1cIixcIuKojlwiOlwiXCIsXCLiqI1cIjpcIlxcXFxoY2FuY2Vse1xcXFxpbnR9XCIsXCLiqIxcIjpcIlxcXFxpaWlpbnRcIixcIuKIs1wiOlwiXFxcXG9pbnRcIixcIuKIslwiOlwiXFxcXG9pbnRcIixcIuKIsVwiOlwiXFxcXGludFwiLFwi4oiwXCI6XCJcXFxcb2lpbnRcIixcIuKIr1wiOlwiXFxcXG9paW50XCIsXCLiiK5cIjpcIlxcXFxvaW50XCIsXCLiiKtcIjpcIlxcXFxpbnRcIixcIuKogVwiOlwiXFxcXG9wbHVzXCIsXCLiiphcIjpcIlxcXFxvc2xhc2hcIixcIuKKllwiOlwiXFxcXG9taW51c1wiLFwi4oqVXCI6XCJcXFxcb3BsdXNcIixcIuKIrVwiOlwiXFxcXGlpaW50XCIsXCLiiKxcIjpcIlxcXFxpaW50XCIsXCLiqItcIjpcIlwiLFwi4qiKXCI6XCJcIixcIuKIkVwiOlwiXFxcXHN1bVwiLFwi4oqfXCI6XCJcXFxcYm94bWludXNcIixcIuKKnlwiOlwiXFxcXGJveHBsdXNcIixcIuKIlFwiOlwiXFxcXGRvdHsrfVwiLFwi4oiTXCI6XCIrLVwiLFwi4oiSXCI6XCItXCIsXCLCsVwiOlwiXFxcXHBtXCIsXCItXCI6XCItXCIsXCIrXCI6XCIrXCIsXCLirYZcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwi4q2FXCI6XCJcXFxcTGxlZnRhcnJvd1wiLFwi4qe0XCI6XCI6XFxcXHJpZ2h0YXJyb3dcIixcIuKnr1wiOlwiXCIsXCLip59cIjpcIlxcXFxidWxsZXQtXFxcXGJ1bGxldFwiLFwi4qafXCI6XCJcXFxcYW5nbGVcIixcIuKmnlwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmnVwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmnFwiOlwiXFxcXHBlcnBcIixcIuKmm1wiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIuKmmlwiOlwiXCIsXCLipplcIjpcIlxcXFx2ZG90c1wiLFwi4qW/XCI6XCJcIixcIuKlvlwiOlwiXCIsXCLipb1cIjpcIlxcXFxwcmVjXCIsXCLipbxcIjpcIlxcXFxzdWNjXCIsXCLipbtcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317XFxcXHN1cHNldH1cIixcIuKlulwiOlwiXCIsXCLipblcIjpcIlxcXFx1bmRlcnNldHtcXFxccmlnaHRhcnJvd317XFxcXHN1YnNldH1cIixcIuKluFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxyaWdodGFycm93fXs+fVwiLFwi4qW3XCI6XCJcIixcIuKltlwiOlwiXFxcXHVuZGVyc2V0e1xcXFxsZWZ0YXJyb3d9ezx9XCIsXCLipbVcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxccmlnaHRhcnJvd31cIixcIuKltFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxyaWdodGFycm93fVwiLFwi4qWzXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXGxlZnRhcnJvd31cIixcIuKlslwiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17XFxcXHJpZ2h0YXJyb3d9XCIsXCLipbFcIjpcIlxcXFxvdmVyc2V0ez19e1xcXFxyaWdodGFycm93fVwiLFwi4qWwXCI6XCJcIixcIuKlr1wiOlwiXCIsXCLipa5cIjpcIlwiLFwi4qWtXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXHJpZ2h0aGFycG9vbmRvd259XCIsXCLipaxcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHJpZ2h0aGFycG9vbnVwfVwiLFwi4qWrXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxlZnRoYXJwb29uZG93bn1cIixcIuKlqlwiOlwiXFxcXHVuZGVybGluZXtcXFxcbGVmdGhhcnBvb251cH1cIixcIuKlqVwiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCLipahcIjpcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLFwi4qWnXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKlplwiOlwiXFxcXHJpZ2h0bGVmdGhhcnBvb25zXCIsXCLipaVcIjpcIlxcXFxEb3duYXJyb3dcIixcIuKlpFwiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIuKlo1wiOlwiXFxcXFVwYXJyb3dcIixcIuKlolwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4qWhXCI6XCJcXFxcZG93bmFycm93XCIsXCLipaBcIjpcIlxcXFx1cGFycm93XCIsXCLipZ9cIjpcIlxcXFxyaWdodGFycm93XCIsXCLipZ5cIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKlnVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qWcXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qWbXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qWaXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipZlcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKlmFwiOlwiXFxcXHVwYXJyb3dcIixcIuKll1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKlllwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qWVXCI6XCJcXFxcZG93bmFycm93XCIsXCLipZRcIjpcIlxcXFx1cGFycm93XCIsXCLipZNcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipZJcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKlkVwiOlwiXFxcXHVwZG93bmFycm93XCIsXCLipZBcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4qWPXCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIuKljlwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipY1cIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4qWMXCI6XCJcXFxcdXBkb3duYXJyb3dcIixcIuKli1wiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipYpcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4qWJXCI6XCJcIixcIuKliFwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLipYdcIjpcIlxcXFxucmlnaHRhcnJvd1wiLFwi4qWGXCI6XCJcIixcIuKlhVwiOlwiXCIsXCLipYRcIjpcIlxcXFxyaWdodGxlZnRhcnJvd3NcIixcIuKlg1wiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwi4qWCXCI6XCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIsXCLipYFcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCLipYBcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKkv1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkvlwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qS9XCI6XCJcXFxcbGVmdGFycm93XCIsXCLipLxcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipLtcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipLpcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkuVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qS4XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLdcIjpcIlxcXFxSc2hcIixcIuKktlwiOlwiXFxcXExzaFwiLFwi4qS1XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLRcIjpcIlxcXFx1cGFycm93XCIsXCLipLNcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipLJcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKksVwiOlwiIFwiLFwi4qSwXCI6XCIgXCIsXCLipK9cIjpcIiBcIixcIuKkrlwiOlwiIFwiLFwi4qStXCI6XCIgXCIsXCLipKxcIjpcIlxcXFx0aW1lc1wiLFwi4qSrXCI6XCJcXFxcdGltZXNcIixcIuKkqlwiOlwiIFwiLFwi4qSpXCI6XCIgXCIsXCLipKhcIjpcIiBcIixcIuKkp1wiOlwiIFwiLFwi4qSmXCI6XCIgXCIsXCLipKVcIjpcIiBcIixcIuKkpFwiOlwiIFwiLFwi4qSjXCI6XCIgXCIsXCLipKJcIjpcIiBcIixcIuKkoVwiOlwiIFwiLFwi4qSgXCI6XCJcXFxcbWFwc3RvXFxcXGNkb3RcIixcIuKkn1wiOlwiXFxcXGNkb3RcXFxcbGVmdGFycm93XCIsXCLipJ5cIjpcIlxcXFxyaWdodGFycm93XFxcXGNkb3RcIixcIuKknVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4qScXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSbXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipJpcIjpcIlxcXFxyaWdodGFycm93XCIsXCLipJlcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKkmFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkl1wiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkllwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKklVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKklFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKkk1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qSSXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qSRXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSQXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSPXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4qSOXCI6XCJcXFxcbGVmdGFycm93XCIsXCLipI1cIjpcIlxcXFxyaWdodGFycm93XCIsXCLipIxcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKki1wiOlwiXFxcXERvd25hcnJvd1wiLFwi4qSKXCI6XCJcXFxcVXBhcnJvd1wiLFwi4qSJXCI6XCJcXFxcdXBhcnJvd1wiLFwi4qSIXCI6XCJcXFxcZG93bmFycm93XCIsXCLipIdcIjpcIlxcXFxSaWdodGFycm93XCIsXCLipIZcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKkhVwiOlwiXFxcXG1hcHN0b1wiLFwi4qSEXCI6XCJcXFxcbkxlZnRyaWdodGFycm93XCIsXCLipINcIjpcIlxcXFxuUmlnaHRhcnJvd1wiLFwi4qSCXCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwi4qSBXCI6XCJcXFxccmlnaHRzcXVpZ2Fycm93XCIsXCLipIBcIjpcIlxcXFxyaWdodHNxdWlnYXJyb3dcIixcIuKfv1wiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwi4p++XCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4p+9XCI6XCJcXFxcTGVmdGFycm93XCIsXCLin7xcIjpcIlxcXFxtYXBzdG9cIixcIuKfu1wiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4p+6XCI6XCJcXFxcTG9uZ2xlZnRyaWdodGFycm93XCIsXCLin7lcIjpcIlxcXFxMb25ncmlnaHRhcnJvd1wiLFwi4p+4XCI6XCJcXFxcTG9uZ2xlZnRhcnJvd1wiLFwi4p+3XCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKftlwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKftVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4p+xXCI6XCJcXFxcRG93bmFycm93XCIsXCLin7BcIjpcIlxcXFxVcGFycm93XCIsXCLiirhcIjpcIlxcXFxyaWdodGFycm93XCIsXCLih79cIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiLFwi4oe+XCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oe9XCI6XCJcXFxcbGVmdGFycm93XCIsXCLih7xcIjpcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIixcIuKHu1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCLih7pcIjpcIlxcXFxubGVmdGFycm93XCIsXCLih7lcIjpcIlxcXFxubGVmdHJpZ2h0YXJyb3dcIixcIuKHuFwiOlwiXFxcXG5yaWdodGFycm93XCIsXCLih7dcIjpcIlxcXFxubGVmdGFycm93XCIsXCLih7ZcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwi4oe1XCI6XCJcIixcIuKHtFwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKHs1wiOlwiXFxcXFVwZG93bmFycm93XCIsXCLih7JcIjpcIlxcXFxzZWFycm93XCIsXCLih7FcIjpcIlxcXFxud2Fycm93XCIsXCLih7BcIjpcIlxcXFxMZWZ0YXJyb3dcIixcIuKHr1wiOlwiXFxcXFVwYXJyb3dcIixcIuKHrlwiOlwiXFxcXFVwYXJyb3dcIixcIuKHrVwiOlwiXFxcXFVwYXJyb3dcIixcIuKHrFwiOlwiXFxcXFVwYXJyb3dcIixcIuKHq1wiOlwiXFxcXFVwYXJyb3dcIixcIuKHqlwiOlwiXFxcXFVwYXJyb3dcIixcIuKHqVwiOlwiXFxcXERvd25hcnJvd1wiLFwi4oeoXCI6XCJcXFxcUmlnaHRhcnJvd1wiLFwi4oenXCI6XCJcXFxcVXBhcnJvd1wiLFwi4oemXCI6XCJcXFxcTGVmdGFycm93XCIsXCLih6VcIjpcIlxcXFxyaWdodGFycm93XCIsXCLih6RcIjpcIlxcXFxsZWZ0YXJyb3dcIixcIuKHo1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oeiXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oehXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oegXCI6XCJcXFxcbGVmdGFycm93XCIsXCLih59cIjpcIlxcXFxkb3duYXJyb3dcIixcIuKHnlwiOlwiXFxcXHVwYXJyb3dcIixcIuKHnVwiOlwiXFxcXHJpZ2h0c3F1aWdhcnJvd1wiLFwi4oecXCI6XCJcXFxcbGVmdGFycm93XCIsXCLih5tcIjpcIlxcXFxScmlnaHRhcnJvd1wiLFwi4oeaXCI6XCJcXFxcTGxlZnRhcnJvd1wiLFwi4oeZXCI6XCJcXFxcc3dhcnJvd1wiLFwi4oeYXCI6XCJcXFxcc2VhcnJvd1wiLFwi4oeXXCI6XCJcXFxcbmVhcnJvd1wiLFwi4oeWXCI6XCJcXFxcbndhcnJvd1wiLFwi4oeVXCI6XCJcXFxcVXBkb3duYXJyb3dcIixcIuKHlFwiOlwiXFxcXExlZnRyaWdodGFycm93XCIsXCLih5NcIjpcIlxcXFxEb3duYXJyb3dcIixcIuKHklwiOlwiXFxcXFJpZ2h0YXJyb3dcIixcIuKHkVwiOlwiXFxcXFVwYXJyb3dcIixcIuKHkFwiOlwiXFxcXExlZnRhcnJvd1wiLFwi4oePXCI6XCJcXFxcblJpZ2h0YXJyb3dcIixcIuKHjlwiOlwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiLFwi4oeNXCI6XCJcXFxcbkxlZnRhcnJvd1wiLFwi4oeMXCI6XCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIixcIuKHi1wiOlwiXFxcXGxlZnRyaWdodGhhcnBvb25zXCIsXCLih4pcIjpcIlxcXFxkb3duZG93bmFycm93c1wiLFwi4oeJXCI6XCJcXFxccmlnaHRyaWdodGFycm93c1wiLFwi4oeIXCI6XCJcXFxcdXB1cGFycm93c1wiLFwi4oeHXCI6XCJcXFxcbGVmdGxlZnRhcnJvd3NcIixcIuKHhlwiOlwiXFxcXGxlZnRyaWdodGFycm93c1wiLFwi4oeFXCI6XCJcIixcIuKHhFwiOlwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLFwi4oeDXCI6XCJcXFxcZG93bmhhcnBvb25sZWZ0XCIsXCLih4JcIjpcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIsXCLih4FcIjpcIlxcXFxyaWdodGhhcnBvb25kb3duXCIsXCLih4BcIjpcIlxcXFxyaWdodGhhcnBvb251cFwiLFwi4oa/XCI6XCJcXFxcdXBoYXJwb29ubGVmdFwiLFwi4oa+XCI6XCJcXFxcdXBoYXJwb29ucmlnaHRcIixcIuKGvVwiOlwiXFxcXGxlZnRoYXJwb29uZG93blwiLFwi4oa8XCI6XCJcXFxcbGVmdGhhcnBvb251cFwiLFwi4oa7XCI6XCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLFwi4oa6XCI6XCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsXCLihrlcIjpcIlxcXFxsZWZ0cmlnaHRhcnJvd3NcIixcIuKGuFwiOlwiXFxcXG92ZXJsaW5le1xcXFxud2Fycm93fVwiLFwi4oa3XCI6XCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIsXCLihrZcIjpcIlxcXFxjdXJ2ZWFycm93bGVmdFwiLFwi4oa1XCI6XCJcXFxcc3dhcnJvd1wiLFwi4oa0XCI6XCJcXFxcc2VhcnJvd1wiLFwi4oazXCI6XCJcXFxcUnNoXCIsXCLihrJcIjpcIlxcXFxMc2hcIixcIuKGsVwiOlwiXFxcXFJzaFwiLFwi4oawXCI6XCJcXFxcTHNoXCIsXCLihq9cIjpcIlxcXFxzd2Fycm93XCIsXCLihq5cIjpcIlwiLFwi4oatXCI6XCJcXFxcbGVmdHJpZ2h0c3F1aWdhcnJvd1wiLFwi4oasXCI6XCJcXFxcbG9vcGFycm93cmlnaHRcIixcIuKGq1wiOlwiXFxcXGxvb3BhcnJvd2xlZnRcIixcIuKGqlwiOlwiXFxcXGhvb2tyaWdodGFycm93XCIsXCLihqlcIjpcIlxcXFxob29rbGVmdGFycm93XCIsXCLihqhcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHVwZG93bmFycm93fVwiLFwi4oanXCI6XCJcXFxcZG93bmFycm93XCIsXCLihqZcIjpcIlxcXFxyaWdodGFycm93dGFpbFwiLFwi4oalXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oakXCI6XCJcXFxcbGVmdGFycm93dGFpbFwiLFwi4oajXCI6XCJcXFxccmlnaHRhcnJvd3RhaWxcIixcIuKGolwiOlwiXFxcXGxlZnRhcnJvd3RhaWxcIixcIuKGoVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oagXCI6XCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIixcIuKGn1wiOlwiXFxcXHVwYXJyb3dcIixcIuKGnlwiOlwiXFxcXHR3b2hlYWRsZWZ0YXJyb3dcIixcIuKGnVwiOlwiXFxcXG5lYXJyb3dcIixcIuKGnFwiOlwiXFxcXG53YXJyb3dcIixcIuKGmlwiOlwiXCIsXCLihplcIjpcIlxcXFxzd2Fycm93XCIsXCLihphcIjpcIlxcXFxzZWFycm93XCIsXCLihpdcIjpcIlxcXFxuZWFycm93XCIsXCLihpZcIjpcIlxcXFxud2Fycm93XCIsXCLihpVcIjpcIlxcXFx1cGRvd25hcnJvd1wiLFwi4oaUXCI6XCJcXFxcbGVmdHJpZ2h0YXJyb3dcIixcIuKGk1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oaSXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4oaRXCI6XCJcXFxcdXBhcnJvd1wiLFwi4oaQXCI6XCJcXFxcbGVmdGFycm93XCIsXCJ8fHxcIjpcIlxcXFxsZWZ0fHx8XFxcXHJpZ2h0LlwiLFwifHxcIjpcIlxcXFxsZWZ0fHxcXFxccmlnaHQuXCIsXCJ8XCI6XCJcXFxcbWlkXCIsXCLiq75cIjpcIlwiLFwi4qu9XCI6XCIvL1wiLFwi4qu7XCI6XCIvLy9cIixcIuKrulwiOlwiXCIsXCLiq7lcIjpcIlwiLFwi4qu4XCI6XCJcIixcIuKrt1wiOlwiXCIsXCLiq7ZcIjpcIlxcXFx2ZG90c1wiLFwi4qu1XCI6XCJcIixcIuKrtFwiOlwiXCIsXCLiq7NcIjpcIlwiLFwi4quyXCI6XCJcXFxcbnBhcmFsbGVsXCIsXCLiq7FcIjpcIlwiLFwi4quwXCI6XCJcIixcIuKrr1wiOlwiXCIsXCLiq65cIjpcIlxcXFxiY2FuY2Vse1xcXFxtaWR9XCIsXCLiq61cIjpcIlwiLFwi4qusXCI6XCJcIixcIuKrq1wiOlwiXCIsXCLiq6pcIjpcIlwiLFwi4qupXCI6XCJcIixcIuKrqFwiOlwiXFxcXHVuZGVybGluZXtcXFxccGVycH1cIixcIuKrp1wiOlwiXFxcXG92ZXJsaW5le1xcXFx0b3B9XCIsXCLiq6ZcIjpcIlwiLFwi4qulXCI6XCJcIixcIuKrpFwiOlwiXCIsXCLiq6NcIjpcIlwiLFwi4quiXCI6XCJcIixcIuKroVwiOlwiXCIsXCLiq6BcIjpcIlxcXFxwZXJwXCIsXCLiq59cIjpcIlxcXFx0b3BcIixcIuKrnlwiOlwiXFxcXGRhc2h2XCIsXCLiq53MuFwiOlwiXCIsXCLiq51cIjpcIlwiLFwi4qubXCI6XCJcXFxccGl0Y2hmb3JrXCIsXCLiq5pcIjpcIlwiLFwi4quZXCI6XCJcIixcIuKrmFwiOlwiXCIsXCLiq5dcIjpcIlwiLFwi4quWXCI6XCJcIixcIuKrlVwiOlwiXCIsXCLiq5RcIjpcIlwiLFwi4quTXCI6XCJcIixcIuKrklwiOlwiXCIsXCLiq5FcIjpcIlwiLFwi4quQXCI6XCJcIixcIuKrj1wiOlwiXCIsXCLiq45cIjpcIlwiLFwi4quNXCI6XCJcIixcIuKrjFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxuZXF9e1xcXFxzdXBzZXR9XCIsXCLiq4tcIjpcIlxcXFx1bmRlcnNldHtcXFxcbmVxfXtcXFxcc3Vic2V0fVwiLFwi4quKXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1cHNldH1cIixcIuKriVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9e1xcXFxzdWJzZXR9XCIsXCLiq4hcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3Vwc2V0fVwiLFwi4quHXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbX17XFxcXHN1YnNldH1cIixcIuKrhlwiOlwiXFxcXHN1cHNldGVxcVwiLFwi4quFXCI6XCJcXFxcc3Vic2V0ZXFxXCIsXCLiq4RcIjpcIlxcXFxkb3R7XFxcXHN1cHNldGVxfVwiLFwi4quDXCI6XCJcXFxcZG90e1xcXFxzdWJzZXRlcX1cIixcIuKrglwiOlwiXFxcXHVuZGVyc2V0e1xcXFx0aW1lc317XFxcXHN1cHNldH1cIixcIuKrgVwiOlwiXFxcXHVuZGVyc2V0e1xcXFx0aW1lc317XFxcXHN1YnNldH1cIixcIuKrgFwiOlwiXFxcXHVuZGVyc2V0eyt9e1xcXFxzdXBzZXR9XCIsXCLiqr9cIjpcIlxcXFx1bmRlcnNldHsrfXtcXFxcc3Vic2V0fVwiLFwi4qq+XCI6XCJcIixcIuKqvVwiOlwiXCIsXCLiqrxcIjpcIlxcXFxnZyBcIixcIuKqu1wiOlwiXFxcXGxsXCIsXCLiqrpcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2FuY2Vse1xcXFxhcHByb3h9fXtcXFxcc3VjY31cIixcIuKquVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7XFxcXGFwcHJveH19e1xcXFxwcmVjfVwiLFwi4qq4XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17XFxcXHN1Y2N9XCIsXCLiqrdcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXtcXFxccHJlY31cIixcIuKqtlwiOlwiXFxcXHVuZGVyc2V0e1xcXFxjYW5jZWx7PX19e1xcXFxzdWNjfVwiLFwi4qq1XCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHs9fX17XFxcXHByZWN9XCIsXCLiqrRcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcc3VjY31cIixcIuKqs1wiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxwcmVjfVwiLFwi4qqyXCI6XCJcIixcIuKqsVwiOlwiXCIsXCLiqq5cIjpcIlwiLFwi4qqtXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwi4qqsXCI6XCJcXFxcdW5kZXJsaW5le1xcXFxoY2FuY2Vsez59fVwiLFwi4qqrXCI6XCJcXFxcaGNhbmNlbHs+fVwiLFwi4qqqXCI6XCJcXFxcaGNhbmNlbHs8fVwiLFwi4qqpXCI6XCJcIixcIuKqqFwiOlwiXCIsXCLiqqdcIjpcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIsXCLiqqZcIjpcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIixcIuKqpVwiOlwiPjxcIixcIuKqpFwiOlwiPjxcIixcIuKqo1wiOlwiXFxcXHVuZGVybGluZXtcXFxcbGx9XCIsXCLiqqLMuFwiOlwiXFxcXGNhbmNlbHtcXFxcZ2d9XCIsXCLiqqJcIjpcIlxcXFxnZ1wiLFwi4qqhzLhcIjpcIlxcXFxjYW5jZWx7XFxcXGxsfVwiLFwi4qqhXCI6XCJcXFxcbGxcIixcIuKqoFwiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17XFxcXGdlcXF9XCIsXCLiqp9cIjpcIlxcXFxvdmVyc2V0e1xcXFxzaW19e1xcXFxsZXFxfVwiLFwi4qqeXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXs+fVwiLFwi4qqdXCI6XCJcXFxcb3ZlcnNldHtcXFxcc2ltfXs8fVwiLFwi4qqcXCI6XCJcIixcIuKqm1wiOlwiXCIsXCLiqppcIjpcIlxcXFxvdmVyc2V0ez19ez59XCIsXCLiqplcIjpcIlxcXFxvdmVyc2V0ez19ezx9XCIsXCLiqphcIjpcIlwiLFwi4qqXXCI6XCJcIixcIuKqllwiOlwiXCIsXCLiqpVcIjpcIlwiLFwi4qqUXCI6XCJcIixcIuKqk1wiOlwiXCIsXCLiqpJcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcZ3RybGVzc31cIixcIuKqkVwiOlwiXFxcXHVuZGVyc2V0ez19e1xcXFxsZXNzZ3RyfVwiLFwi4qqQXCI6XCJcXFxcdW5kZXJzZXR7PH17XFxcXGd0cnNpbX1cIixcIuKqj1wiOlwiXFxcXHVuZGVyc2V0ez59e1xcXFxsZXNzc2ltfVwiLFwi4qqOXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbWVxfXs+fVwiLFwi4qqNXCI6XCJcXFxcdW5kZXJzZXR7XFxcXHNpbWVxfXs8fVwiLFwi4qqMXCI6XCJcXFxcZ3RyZXFxbGVzc1wiLFwi4qqLXCI6XCJcXFxcbGVzc2VxcWd0clwiLFwi4qqKXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGNhbmNlbHtcXFxcYXBwcm94fX17Pn1cIixcIuKqiVwiOlwiXFxcXHVuZGVyc2V0e1xcXFxhcHByb3h9ezx9XCIsXCLiqoZcIjpcIlxcXFx1bmRlcnNldHtcXFxcYXBwcm94fXs+fVwiLFwi4qqFXCI6XCJcXFxcdW5kZXJzZXR7XFxcXGFwcHJveH17PH1cIixcIuKqhFwiOlwiXCIsXCLiqoNcIjpcIlwiLFwi4qqCXCI6XCJcIixcIuKqgVwiOlwiXCIsXCLiqoBcIjpcIlwiLFwi4qm/XCI6XCJcIixcIuKpvsy4XCI6XCJcXFxcYmNhbmNlbHtcXFxcZ2VxfVwiLFwi4qm+XCI6XCJcXFxcZ2VxXCIsXCLiqb3MuFwiOlwiXFxcXGJjYW5jZWx7XFxcXGxlcX1cIixcIuKpvVwiOlwiXFxcXGxlcVwiLFwi4qm8XCI6XCJcIixcIuKpu1wiOlwiXCIsXCLiqbpcIjpcIlwiLFwi4qm5XCI6XCJcIixcIuKpuFwiOlwiXFxcXG92ZXJzZXR7XFxcXGRvdHN9e1xcXFxlcXVpdn1cIixcIuKpt1wiOlwiXCIsXCLiqbZcIjpcIj09PVwiLFwi4qm1XCI6XCI9PVwiLFwi4qm0XCI6XCI6Oj1cIixcIuKps1wiOlwiXCIsXCLiqbJcIjpcIlxcXFx1bmRlcnNldHs9fXsrfVwiLFwi4qmxXCI6XCJcXFxcb3ZlcnNldHs9fXsrfVwiLFwi4qmwXCI6XCJcXFxcb3ZlcnNldHtcXFxcYXBwcm94fXs9fVwiLFwi4qmvXCI6XCJcXFxcb3ZlcnNldHtcXFxcd2VkZ2V9ez19XCIsXCLiqa5cIjpcIlxcXFxvdmVyc2V0eyp9ez19XCIsXCLiqa1cIjpcIlxcXFxkb3R7XFxcXGFwcHJveH1cIixcIuKprFwiOlwiXCIsXCLiqatcIjpcIlwiLFwi4qmqXCI6XCJcXFxcZG90e1xcXFxzaW19XCIsXCLiqalcIjpcIlwiLFwi4qmoXCI6XCJcIixcIuKpp1wiOlwiXFxcXGRvdHtcXFxcZXF1aXZ9XCIsXCLiqaZcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2RvdH17PX1cIixcIuKppVwiOlwiXCIsXCLiqaRcIjpcIlwiLFwi4qmjXCI6XCJcXFxcdW5kZXJzZXR7PX17XFxcXHZlZX1cIixcIuKpolwiOlwiXFxcXG92ZXJzZXR7PX17XFxcXHZlZX1cIixcIuKpoVwiOlwidWwodnYpXCIsXCLiqaBcIjpcIlxcXFx1bmRlcnNldHs9fXtcXFxcd2VkZ2V9XCIsXCLiqZ9cIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHdlZGdlfVwiLFwi4qmeXCI6XCJcXFxcb3ZlcnNldHs9fXtcXFxcd2VkZ2V9XCIsXCLiqZ1cIjpcIlxcXFxoY2FuY2Vse1xcXFx2ZWV9XCIsXCLiqZxcIjpcIlxcXFxoY2FuY2Vse1xcXFx3ZWRnZX1cIixcIuKpm1wiOlwiXCIsXCLiqZpcIjpcIlwiLFwi4qmZXCI6XCJcIixcIuKpmFwiOlwiXFxcXHZlZVwiLFwi4qmXXCI6XCJcXFxcd2VkZ2VcIixcIuKpllwiOlwiXCIsXCLiqZVcIjpcIlwiLFwi4qmUXCI6XCJcIixcIuKpk1wiOlwiXCIsXCLiqZJcIjpcIlxcXFxkb3R7XFxcXHZlZX1cIixcIuKpkVwiOlwiXFxcXGRvdHtcXFxcd2VkZ2V9XCIsXCLiqZBcIjpcIlwiLFwi4qmPXCI6XCJcIixcIuKpjlwiOlwiXCIsXCLiqY1cIjpcIlxcXFxvdmVybGluZXtcXFxcY2FwfVwiLFwi4qmMXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGN1cH1cIixcIuKpi1wiOlwiXCIsXCLiqYpcIjpcIlwiLFwi4qmJXCI6XCJcIixcIuKpiFwiOlwiXCIsXCLiqYdcIjpcIlwiLFwi4qmGXCI6XCJcIixcIuKphVwiOlwiXCIsXCLiqYRcIjpcIlwiLFwi4qmDXCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGNhcH1cIixcIuKpglwiOlwiXFxcXG92ZXJsaW5le1xcXFxjdXB9XCIsXCLiqYFcIjpcIlwiLFwi4qmAXCI6XCJcIixcIuKovlwiOlwiXCIsXCLiqL1cIjpcIlxcXFxsbGNvcm5lclwiLFwi4qi8XCI6XCJcXFxcbHJjb3JuZXJcIixcIuKou1wiOlwiXCIsXCLiqLpcIjpcIlwiLFwi4qi5XCI6XCJcIixcIuKouFwiOlwiXCIsXCLiqLdcIjpcIlwiLFwi4qi2XCI6XCJcXFxcaGF0e1xcXFxvdGltZXN9XCIsXCLiqLVcIjpcIlwiLFwi4qi0XCI6XCJcIixcIuKos1wiOlwiXCIsXCLiqLJcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXHRpbWVzfVwiLFwi4qixXCI6XCJcXFxcdW5kZXJsaW5le1xcXFx0aW1lc31cIixcIuKosFwiOlwiXFxcXGRvdHtcXFxcdGltZXN9XCIsXCLiqK5cIjpcIlxcXFxiaWdvZG90XCIsXCLiqK1cIjpcIlxcXFxiaWdvZG90XCIsXCLiqKxcIjpcIlwiLFwi4qirXCI6XCJcIixcIuKoqlwiOlwiXCIsXCLiqKlcIjpcIlwiLFwi4qioXCI6XCJcIixcIuKop1wiOlwiXCIsXCLil7tcIjpcIlxcXFxCb3hcIixcIuKoplwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19eyt9XCIsXCLiqKVcIjpcIlxcXFx1bmRlcnNldHtcXFxcY2lyY317K31cIixcIuKopFwiOlwiXFxcXG92ZXJzZXR7XFxcXHNpbX17K31cIixcIuKoo1wiOlwiXFxcXGhhdHsrfVwiLFwi4qiiXCI6XCJcXFxcZG90eyt9XCIsXCLiqKFcIjpcIlxcXFx1cGhhcnBvb25yaWdodFwiLFwi4qigXCI6XCI+PlwiLFwi4qifXCI6XCJcIixcIuKonlwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4qidXCI6XCJcXFxcYm93dGllXCIsXCLip79cIjpcIlwiLFwi4qe+XCI6XCIrXCIsXCLip7tcIjpcIlxcXFxoY2FuY2Vse3x8fH1cIixcIuKnulwiOlwiXFxcXGhjYW5jZWx7fHx9XCIsXCLip7lcIjpcIlxcXFxiYWNrc2xhc2hcIixcIuKnuFwiOlwiL1wiLFwi4qe3XCI6XCJoY2FuY2Vse1xcYmFja3NsYXNofVwiLFwi4qe2XCI6XCJcIixcIuKntVwiOlwiXFxcXGJhY2tzbGFzaFwiLFwi4qeyXCI6XCJcXFxcUGhpXCIsXCLip7FcIjpcIlwiLFwi4qewXCI6XCJcIixcIuKnrlwiOlwiXCIsXCLip61cIjpcIlwiLFwi4qesXCI6XCJcIixcIuKnq1wiOlwiXFxcXGxvemVuZ2VcIixcIuKnqlwiOlwiXCIsXCLip6lcIjpcIlwiLFwi4qeoXCI6XCJcIixcIuKnp1wiOlwiXFxcXGRkYWdnZXJcIixcIuKnolwiOlwiXFxcXHNxY3VwXFxcXHNxY3VwXCIsXCLip6FcIjpcIlwiLFwi4qegXCI6XCJcXFxcc3F1YXJlXCIsXCLip55cIjpcIlwiLFwi4qedXCI6XCJcIixcIuKnnFwiOlwiXCIsXCLip5tcIjpcIlxcXFx7XFxcXHtcIixcIuKnmVwiOlwiXFxcXHtcIixcIuKnmFwiOlwiXFxcXH1cIixcIuKnl1wiOlwiXCIsXCLip5ZcIjpcIlwiLFwi4qeVXCI6XCJcXFxcYm93dGllXCIsXCLip5RcIjpcIlxcXFxib3d0aWVcIixcIuKnk1wiOlwiXFxcXGJvd3RpZVwiLFwi4qeSXCI6XCJcXFxcYm93dGllXCIsXCLip5FcIjpcIlxcXFxib3d0aWVcIixcIuKnkMy4XCI6XCJ8IFxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwi4qeQXCI6XCJ8IFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLip4/MuFwiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZWxlZnQgfFwiLFwi4qePXCI6XCJcXFxcdHJpYW5nbGVsZWZ0IHxcIixcIuKnjlwiOlwiXCIsXCLip41cIjpcIlxcXFx0cmlhbmdsZVwiLFwi4qeMXCI6XCJcIixcIuKni1wiOlwiXFxcXHVuZGVybGluZXtcXFxcdHJpYW5nbGV9XCIsXCLip4pcIjpcIlxcXFxkb3R7XFxcXHRyaWFuZ2xlfVwiLFwi4qeJXCI6XCJcIixcIuKniFwiOlwiXFxcXGJveGVke1xcXFxjaXJjfVwiLFwi4qeHXCI6XCJcXFxcYm94ZWR7XFxcXGNpcmN9XCIsXCLip4ZcIjpcIlxcXFxib3hlZHtcXFxccmlnaHRhcnJvd31cIixcIuKnhVwiOlwiXFxcXGJjYW5jZWx7XFxcXHNxdWFyZX1cIixcIuKnhFwiOlwiXFxcXGNhbmNlbHtcXFxcc3F1YXJlfVwiLFwi4qeDXCI6XCJcXFxcb2RvdFwiLFwi4qeCXCI6XCJcXFxcb2RvdFwiLFwi4qa/XCI6XCJcXFxcb2RvdFwiLFwi4qa+XCI6XCJcXFxcb2RvdFwiLFwi4qa9XCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qa8XCI6XCJcXFxcb3BsdXNcIixcIuKmu1wiOlwiXFxcXG90aW1lc1wiLFwi4qa6XCI6XCJcIixcIuKmuVwiOlwiXFxcXHZhcm5vdGhpbmdcIixcIuKmuFwiOlwiXFxcXHZhcm5vdGhpbmdcIixcIuKmt1wiOlwiXFxcXG9taW51c1wiLFwi4qa2XCI6XCJcXFxcb21pbnVzXCIsXCLiprVcIjpcIlxcXFxvbWludXNcIixcIuKmtFwiOlwiXFxcXHZlY3tcXFxcdmFybm90aGluZ31cIixcIuKms1wiOlwiXFxcXHZlY3tcXFxcdmFybm90aGluZ31cIixcIuKmslwiOlwiXFxcXGRvdHtcXFxcdmFybm90aGluZ31cIixcIuKmsVwiOlwiXFxcXG92ZXJsaW5le1xcXFx2YXJub3RoaW5nfVwiLFwi4qawXCI6XCJcXFxcdmFybm90aGluZ1wiLFwi4qavXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qauXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qatXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qasXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qarXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qaqXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qapXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qaoXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qanXCI6XCJcIixcIuKmplwiOlwiXCIsXCLipqVcIjpcIlwiLFwi4qakXCI6XCJcIixcIuKmo1wiOlwiXFxcXHVsY29ybmVyXCIsXCLipqJcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqFcIjpcIlxcXFxub3RcXFxcbG9yXCIsXCLipqBcIjpcIlxcXFxiY2FuY2Vsez59XCIsXCLipoJcIjpcIjpcIixcIuKmgVwiOlwiXFxcXGNkb3RcIixcIuKdmFwiOlwiXFxcXG1pZFwiLFwi4payXCI6XCJcXFxcYmlndHJpYW5nbGV1cFwiLFwi4ou/XCI6XCJcXFxcRXBzaWxvblwiLFwi4ou+XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG5pfVwiLFwi4ou9XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXG5pfVwiLFwi4ou8XCI6XCJcXFxcaW5cIixcIuKLu1wiOlwiXFxcXGluXCIsXCLii7pcIjpcIlxcXFxpblwiLFwi4ou5XCI6XCJcXFxcdW5kZXJsaW5le1xcXFxpbn1cIixcIuKLuFwiOlwiXFxcXHVuZGVybGluZXtcXFxcaW59XCIsXCLii7dcIjpcIlxcXFxvdmVybGluZXtcXFxcaW59XCIsXCLii7ZcIjpcIlxcXFxvdmVybGluZXtcXFxcaW59XCIsXCLii7VcIjpcIlxcXFxkb3R7XFxcXGlufVwiLFwi4ou0XCI6XCJcXFxcaW5cIixcIuKLs1wiOlwiXFxcXGluXCIsXCLii7JcIjpcIlxcXFxpblwiLFwi4ouwXCI6XCJcXFxcZGRvdHNcIixcItaJXCI6XCI6XCIsXCLii6lcIjpcIlxcXFx1bmRlcnNldHtcXFxcc2ltfXtcXFxcc3VjY31cIixcIuKLqFwiOlwiXFxcXHVuZGVyc2V0e1xcXFxzaW19e1xcXFxwcmVjfVwiLFwi4ounXCI6XCJcXFxcdW5kZXJzZXR7XFxcXG5vdFxcXFxzaW19ez59XCIsXCLii6ZcIjpcIlxcXFx1bmRlcnNldHtcXFxcbm90XFxcXHNpbX17PH1cIixcIuKLpVwiOlwiXFxcXG5vdFxcXFxzcXN1cHNldGVxXCIsXCLii6RcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRlcVwiLFwi4oujXCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0ZXFcIixcIuKLolwiOlwiXFxcXG5vdFxcXFxzcXN1YnNldGVxXCIsXCLii6FcIjpcIlxcXFxuc3VjY1wiLFwi4ougXCI6XCJcXFxcbnByZWNcIixcIuKLn1wiOlwiXFxcXHN1Y2NcIixcIuKLnlwiOlwiXFxcXHByZWNcIixcIuKLnVwiOlwiXFxcXG92ZXJsaW5lez59XCIsXCLii5xcIjpcIlxcXFxvdmVybGluZXs8fVwiLFwi4oubXCI6XCJcXFxcdW5kZXJzZXR7Pn17XFxcXGxlcX1cIixcIuKLmlwiOlwiXFxcXHVuZGVyc2V0ezx9e1xcXFxnZXF9XCIsXCLii5VcIjpcIlxcXFwjXCIsXCLii5NcIjpcIlxcXFxjdXBcIixcIuKLklwiOlwiXFxcXGNhcFwiLFwi4ouRXCI6XCJcXFxcc3Vwc2V0XCIsXCLii5BcIjpcIlxcXFxzdWJzZXRcIixcIuKLj1wiOlwiXFxcXHdlZGdlXCIsXCLii45cIjpcIlxcXFx2ZWVcIixcIuKLjVwiOlwiXFxcXHNpbWVxXCIsXCLii4hcIjpcIlxcXFxKb2luXCIsXCLii4dcIjpcIlxcXFxhc3RcIixcIuKLhlwiOlwiXFxcXHN0YXJcIixcIuKLhFwiOlwiXFxcXGRpYW1vbmRcIixcIuKKv1wiOlwiXFxcXHRyaWFuZ2xlXCIsXCLiir5cIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLiir1cIjpcIlxcXFxvdmVybGluZXtcXFxcbG9yfVwiLFwi4oq8XCI6XCJcXFxcb3ZlcmxpbmV7XFxcXGxhbmR9XCIsXCLiirtcIjpcIlxcXFx1bmRlcmxpbmV7XFxcXGxvcn1cIixcIuKKulwiOlwiXFxcXHRvcFwiLOWcnzpcIlxcXFxwbVwiLOWNgTpcIitcIixcIuKKuVwiOlwiXCIsXCLiirdcIjpcIlxcXFxjaXJjXFxcXG11bHRpbWFwXCIsXCLiirZcIjpcIlxcXFxjaXJjXFxcXG11bHRpbWFwXCIsXCLiirNcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLiirJcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKKsVwiOlwiXFxcXHN1Y2NcIixcIuKKsFwiOlwiXFxcXHByZWNcIixcIuKKq1wiOlwifFxcXFxtb2RlbHNcIixcIuKKqlwiOlwifFxcXFxtb2RlbHNcIixcIuKKp1wiOlwiXFxcXG1vZGVsc1wiLFwi4oqmXCI6XCJcXFxcdmRhc2hcIixcIuKKnVwiOlwiXFxcXG9taW51c1wiLFwi4oqcXCI6XCJcXFxcb21pbnVzXCIsXCLiiptcIjpcIlxcXFxvZG90XCIsXCLiippcIjpcIlxcXFxvZG90XCIsXCLiipRcIjpcIlxcXFxzcWN1cFwiLFwi4oqTXCI6XCJcXFxcc3FjYXBcIixcIuKKklwiOlwiXFxcXHNxc3Vwc2V0ZXFcIixcIuKKkVwiOlwiXFxcXHNxc3Vic2V0ZXFcIixcIuKKkMy4XCI6XCJcXFxcbm90XFxcXHNxc3Vwc2V0XCIsXCLiipBcIjpcIlxcXFxzcXN1cHNldFwiLFwi4oqPzLhcIjpcIlxcXFxub3RcXFxcc3FzdWJzZXRcIixcIuKKj1wiOlwiXFxcXHNxc3Vic2V0XCIsXCLiio5cIjpcIlxcXFxjdXBcIixcIuKKjVwiOlwiXFxcXGN1cFwiLFwi4oqMXCI6XCJcXFxcY3VwXCIsXCLiib/MuFwiOlwiXFxcXG5vdFxcXFxzdWNjc2ltXCIsXCLiib9cIjpcIlxcXFxzdWNjc2ltXCIsXCLiib5cIjpcIlxcXFxwcmVjc2ltXCIsXCLiiblcIjpcIlxcXFxub3RcXFxcb3ZlcnNldHs+fXs8fVwiLFwi4om4XCI6XCJcXFxcbm90XFxcXG92ZXJzZXR7Pn17PH1cIixcIuKJt1wiOlwiXFxcXG92ZXJzZXR7Pn17PH1cIixcIuKJtlwiOlwiXFxcXG92ZXJzZXR7PH17Pn1cIixcIuKJtVwiOlwiXFxcXG5vdFxcXFxnZWdcIixcIuKJtFwiOlwiXFxcXG5vdFxcXFxsZXFcIixcIuKJs1wiOlwiXFxcXGdlZ1wiLFwi4omyXCI6XCJcXFxcbGVxXCIsXCLiiaxcIjpcIlwiLFwi4omnXCI6XCJcXFxcZ2VnXCIsXCLiiabMuFwiOlwiXFxcXG5vdFxcXFxsZXFcIixcIuKJplwiOlwiXFxcXGxlcVwiLFwi4omjXCI6XCJcXFxcb3ZlcnNldHs9fXs9fSBcIixcIuKJnlwiOlwiXFxcXG92ZXJzZXR7bX17PX0gXCIsXCLiiZ1cIjpcIlxcXFxvdmVyc2V0e2RlZn17PX1cIixcIuKJmFwiOlwiPVwiLFwi4omWXCI6XCI9XCIsXCLiiZVcIjpcIj06XCIsXCLiiZNcIjpcIlxcXFxkb3RlcVwiLFwi4omSXCI6XCJcXFxcZG90ZXFcIixcIuKJkVwiOlwiXFxcXGRvdGVxXCIsXCLiiZBcIjpcIlxcXFxkb3RlcVwiLFwi4omPzLhcIjpcIlwiLFwi4omPXCI6XCJcIixcIuKJjsy4XCI6XCJcIixcIuKJjlwiOlwiXCIsXCLiiYxcIjpcIlxcXFxhcHByb3hcIixcIuKJi1wiOlwiXFxcXGFwcHJveFwiLFwi4omKXCI6XCJcXFxcYXBwcm94XCIsXCLiiYLMuFwiOlwiXFxcXG5lcVwiLFwi4omCXCI6XCI9XCIsXCLiiL9cIjpcIlxcXFxzaW1cIixcIuKIvlwiOlwiXFxcXGluZnR5XCIsXCLiiL3MsVwiOlwiXFxcXHNpbVwiLFwi4oi9XCI6XCJcXFxcc2ltXCIsXCLiiLtcIjpcIlxcXFxzaW1cIixcIuKIulwiOlwiOi06XCIsXCLiiLlcIjpcIi06XCIsXCLiiLhcIjpcIlxcXFxib3RcIixcIuKIt1wiOlwiOjpcIixcIuKItlwiOlwiOlwiLFwi4oijXCI6XCJcXFxcbWlkXCIsXCLiiJ9cIjpcIlxcXFxsbGNvcm5lclwiLFwi4oiYXCI6XCJcXFxcY2lyY1wiLFwi4oiXXCI6XCIqXCIsXCLiiJVcIjpcIi9cIixcIuKIjlwiOlwiXFxcXHNxdWFyZVwiLFwi4oiNXCI6XCJcXFxcbmlcIixcIuKIilwiOlwiXFxcXGluXCIsXCLiiIZcIjpcIlxcXFxEZWx0YVwiLFwi4oGEXCI6XCIvXCIsXCLiqrDMuFwiOlwiXFxcXG5zdWNjZXFcIixcIuKqsFwiOlwiXFxcXHN1Y2NlcVwiLFwi4qqvzLhcIjpcIlxcXFxucHJlY2VxXCIsXCLiqq9cIjpcIlxcXFxwcmVjZXFcIixcIuKqiFwiOlwiXFxcXG5nZXFzbGFudFwiLFwi4qqHXCI6XCJcXFxcbmxlcXNsYW50XCIsXCLip7NcIjpcIlxcXFxQaGlcIixcIuKnplwiOlwiXFxcXG1vZGVsc1wiLFwi4qelXCI6XCJcXFxcbm90XFxcXGVxdWl2XCIsXCLip6RcIjpcIlxcXFxhcHByb3hcXFxcbmVxXCIsXCLip6NcIjpcIlxcXFxuZXFcIixcIuKngVwiOlwiXFxcXGNpcmNsZVwiLFwi4qeAXCI6XCJcXFxcY2lyY2xlXCIsXCLil6ZcIjpcIlxcXFxjaXJjbGVcIixcIuKXl1wiOlwiXFxcXGNpcmNsZVwiLFwi4peWXCI6XCJcXFxcY2lyY2xlXCIsXCLil49cIjpcIlxcXFxjaXJjbGVcIixcIuKXjlwiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCLil41cIjpcIlxcXFxjaXJjbGVkY2lyY1wiLFwi4peMXCI6XCJcXFxcY2lyY2xlZGNpcmNcIixcIuKXiVwiOlwiXFxcXGNpcmNsZWRjaXJjXCIsXCLil4hcIjpcIlxcXFxkaWFtb25kXCIsXCLil4dcIjpcIlxcXFxkaWFtb25kXCIsXCLil4ZcIjpcIlxcXFxkaWFtb25kXCIsXCLil4VcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKXhFwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peDXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLil4JcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKXgVwiOlwiXFxcXHRyaWFuZ2xlbGVmdFwiLFwi4peAXCI6XCJcXFxcdHJpYW5nbGVsZWZ0XCIsXCLilr9cIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIuKWvlwiOlwiXFxcXHRyaWFuZ2xlZG93blwiLFwi4pa9XCI6XCJcXFxcdHJpYW5nbGVkb3duXCIsXCLilrxcIjpcIlxcXFx0cmlhbmdsZWRvd25cIixcIuKWuVwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWuFwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWt1wiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWtlwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIuKWtVwiOlwiXFxcXHRyaWFuZ2xlXCIsXCLilrRcIjpcIlxcXFx0cmlhbmdsZVwiLFwi4pazXCI6XCJcXFxcdHJpYW5nbGVcIixcIuKWsVwiOlwiXFxcXHNxdWFyZVwiLFwi4pawXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKWr1wiOlwiXFxcXHNxdWFyZVwiLFwi4pauXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKWrVwiOlwiXFxcXHNxdWFyZVwiLFwi4parXCI6XCJcXFxcc3F1YXJlXCIsXCLilqpcIjpcIlxcXFxzcXVhcmVcIixcIuKWoVwiOlwiXFxcXHNxdWFyZVwiLFwi4pagXCI6XCJcXFxcYmxhY2tzcXVhcmVcIixcIuKLrVwiOlwiXFxcXG5vdFxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLii6xcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVsZWZ0XCIsXCLii6tcIjpcIlxcXFxub3RcXFxcdHJpYW5nbGVyaWdodFwiLFwi4ouqXCI6XCJcXFxcbm90XFxcXHRyaWFuZ2xlbGVmdFwiLFwi4ouZXCI6XCJcXFxcZ2dnXCIsXCLii5hcIjpcIlxcXFxsbGxcIixcIuKLl1wiOlwiKj5cIixcIuKLllwiOlwiPCpcIixcIuKLlFwiOlwiXFxcXHBpdGNoZm9ya1wiLFwi4ouMXCI6XCJcIixcIuKLi1wiOlwiXFxcXGJvd3RpZVwiLFwi4ouKXCI6XCJcXFxcbHRpbWVzXCIsXCLii4lcIjpcIlxcXFxydGltZXNcIixcIuKKtVwiOlwiXFxcXHRyaWFuZ2xlcmlnaHRcIixcIlxcXFx0cmlhbmdsZWxlZnRcIjpcIlwiLFwi4oqlXCI6XCJcXFxcYm90XCIsXCLiioFcIjpcIlxcXFxuc3VjY1wiLFwi4oqAXCI6XCJcXFxccHJlY2VxXCIsXCLiib1cIjpcIlxcXFxzdWNjZXFcIixcIuKJvFwiOlwiXFxcXHByZWNlcVwiLFwi4om7XCI6XCJcXFxcc3VjY1wiLFwi4om6XCI6XCJcXFxccHJlY1wiLFwi4omxXCI6XCJcXFxcZ2VxL1wiLFwi4omwXCI6XCJcXFxcbGVxL1wiLFwi4omtXCI6XCJcXFxcbmVxXCIsXCLiiavMuFwiOlwiXFxcXG5vdFxcXFxnZ1wiLFwi4omrXCI6XCJcXFxcZ2dcIixcIuKJqsy4XCI6XCJcXFxcbm90XFxcXGxsXCIsXCLiiapcIjpcIlxcXFxsbFwiLFwi4ompXCI6XCJcXFxcbmdlcXNsYW50XCIsXCLiiahcIjpcIlxcXFxubGVxc2xhbnRcIixcIuKJoVwiOlwiXFxcXGVxdWl2XCIsXCLiiZ9cIjpcIlxcXFxkb3RlcVwiLFwi4omcXCI6XCJcXFxcdHJpYW5nbGVxXCIsXCLiiZtcIjpcIlxcXFxkb3RlcVwiLFwi4omaXCI6XCJcXFxcdHJpYW5nbGVxXCIsXCLiiZlcIjpcIlxcXFx0cmlhbmdsZXFcIixcIuKJl1wiOlwiXFxcXGRvdGVxXCIsXCLiiZRcIjpcIjo9XCIsXCLiiY1cIjpcIlxcXFxhc3ltcFwiLFwi4omHXCI6XCJcXFxcbmNvbmdcIixcIuKJhlwiOlwiXFxcXG5jb25nXCIsXCLiiYVcIjpcIlxcXFxjb25nXCIsXCLiiYRcIjpcIlxcXFxub3RcXFxcc2ltZXFcIixcIuKJg1wiOlwiXFxcXHNpbWVxXCIsXCLiiYFcIjpcIlxcXFxub3RcXFxcc2ltXCIsXCLiiKZcIjpcIlxcXFxub3RcXFxccGFyYWxsZWxcIixcIuKIpVwiOlwiXFxcXHBhcmFsbGVsXCIsXCLiiKRcIjpcIlxcXFxub3R8XCIsXCLiiJ1cIjpcIlxcXFxwcm9wdG9cIixcIj09XCI6XCI9PVwiLFwiPVwiOlwiPVwiLFwiOj1cIjpcIjo9XCIsXCIvPVwiOlwiPVwiLFwiLT1cIjpcIi09XCIsXCIrPVwiOlwiKz1cIixcIio9XCI6XCIqPVwiLFwiIT1cIjpcIiE9XCIsXCLiiaBcIjpcIlxcXFxuZXFcIixcIuKJolwiOlwiXFxcXGVxdWl2IC9cIixcIuKJiVwiOlwiXFxcXGFwcHJveCAvXCIsXCLiiLxcIjpcInNpbVwiLFwi4omIXCI6XCJcXFxcYXBwcm94XCIsXCLiia5cIjpcIjwvXCIsXCI8XCI6XCI8XCIsXCLiia9cIjpcIj4vXCIsXCI+PVwiOlwiPj1cIixcIj5cIjpcIj5cIixcIuKJpVwiOlwiXFxcXGdlcVwiLFwi4omkXCI6XCJcXFxcbGVxXCIsXCI8PVwiOlwiPD1cIixcIuKKi1wiOlwiXFxcXHN1cHNldG5lcVwiLFwi4oqKXCI6XCJcXFxcc3Vic2V0bmVxXCIsXCLiiolcIjpcIlxcXFxuc3Vwc2V0ZXFcIixcIuKKiFwiOlwiXFxcXG5zdWJzZXRlcVwiLFwi4oqHXCI6XCJcXFxcc3Vwc2V0ZXFcIixcIuKKhlwiOlwiXFxcXHN1YnNldGVxXCIsXCLiioVcIjpcIlxcXFxub3RcXFxcc3Vwc2V0XCIsXCLiioRcIjpcIlxcXFxub3RcXFxcc3Vic2V0XCIsXCLiioPig5JcIjpcIlxcXFxzdXBzZXQgfFwiLFwi4oqDXCI6XCJcXFxcc3Vwc2V0XCIsXCLiioLig5JcIjpcIlxcXFxzdWJzZXQgfFwiLFwi4oqCXCI6XCJcXFxcc3Vic2V0XCIsXCLiiIxcIjpcIlxcXFxub3RcXFxcaW5cIixcIuKIiVwiOlwiXFxcXG5vdGluXCIsXCLiiIhcIjpcIlxcXFxpblwiLFwi4oiBXCI6XCJDXCIsXCLiiIRcIjpcIlxcXFxuZXhpc3RzXCIsXCLiiINcIjpcIlxcXFxleGlzdHNcIixcIuKIgFwiOlwiXFxcXGZvcmFsbFwiLFwi4oinXCI6XCJcXFxcbGFuZFwiLFwiJiZcIjpcIlxcXFwmXFxcXCZcIixcIuKIqFwiOlwiXFxcXGxvclwiLFwi4oqvXCI6XCJcXFxcY2FuY2Vse1xcXFx2RGFzaH1cIixcIuKKrlwiOlwiXFxcXGNhbmNlbHtcXFxcVmRhc2h9XCIsXCLiiq1cIjpcIlxcXFxudkRhc2hcIixcIuKKrFwiOlwiXFxcXG52RGFzaFwiLFwi4oqpXCI6XCJcXFxcVmRhc2hcIixcIuKKqFwiOlwiXFxcXHZEYXNoXCIsXCLiiqRcIjpcIlxcXFx0b3BcIixcIuKKo1wiOlwiXFxcXGRhc2h2XCIsXCLiiqJcIjpcIlxcXFx2ZGFzaFwiLFwi4oiLXCI6XCJcXFxcbmlcIixcIuKLsVwiOlwiXFxcXGRkb3RzXCIsXCLii69cIjpcIlxcXFxoZG90c1wiLFwi4ouuXCI6XCJcXFxcdmRvdHNcIixcIs+2XCI6XCJcXFxcbmlcIixcIjpcIjpcIjpcIixcIi4uLlwiOlwiXFxcXGNkb3RzXCIsXCIuLlwiOlwiLi5cIixcIi0+XCI6XCItPlwiLFwi4oi1XCI6XCJcXFxcYmVjYXVzZVwiLFwi4oi0XCI6XCJcXFxcdGhlcmVmb3JlIFwiLFwi4oGjXCI6XCJcXFxcbGxicmFja2V0XCIsXCIsXCI6XCIsXCIsXCI7XCI6XCI7XCIsXCLip71cIjpcIlxcXFx9XCIsXCLip7xcIjpcIlxcXFx7XCIsXCLipphcIjpcIlxcXFxdXCIsXCLippdcIjpcIlxcXFxbXCIsXCLippZcIjpcIlxcXFxsbFwiLFwi4qaVXCI6XCJcXFxcZ2dcIixcIuKmlFwiOlwiXFxcXGdnXCIsXCLippNcIjpcIlxcXFxsbFwiLFwi4qaSXCI6XCJcXFxcZ2dcIixcIuKmkVwiOlwiXFxcXGxsXCIsXCLippBcIjpcIlxcXFxdXCIsXCLipo9cIjpcIlxcXFxdXCIsXCLipo5cIjpcIlxcXFxdXCIsXCLipo1cIjpcIlxcXFxbXCIsXCLipoxcIjpcIlxcXFxbXCIsXCLipotcIjpcIlxcXFxdXCIsXCLipopcIjpcIlxcXFx0cmlhbmdsZXJpZ2h0XCIsXCLipolcIjpcIlxcXFx0cmlhbmdsZWxlZnRcIixcIuKmiFwiOlwifFxcXFwpXCIsXCLipodcIjpcIlxcXFwofFwiLFwi4qaGXCI6XCJ8XFxcXClcIixcIuKmhVwiOlwiXFxcXChcXFxcKFwiLFwi4qaEXCI6XCJ8XFxcXH1cIixcIuKmg1wiOlwiXFxcXHt8XCIsXCLipoBcIjpcIlxcXFx8fFwiLFwi4p+vXCI6XCJcXFxcbGVmdC4gXFxcXHJpZ2h0XVwiLFwi4p+uXCI6XCJcXFxcbGVmdFsgXFxcXHJpZ2h0LlwiLFwi4p+tXCI6XCJcXFxcbGVmdC4gXFxcXHJpZ2h0XV1cIixcIuKfrFwiOlwiXFxcXGxlZnRbWyBcXFxccmlnaHQuXCIsXCLin6tcIjpcIlxcXFxnZ1wiLFwi4p+qXCI6XCJcXFxcbGxcIixcIuKfp1wiOlwiXFxcXCl8XCIsXCLin6ZcIjpcIlxcXFwofFwiLFwi4p2zXCI6XCJcXFxcbGVmdC5cXFxccmlnaHQpXCIsXCLinbJcIjpcIlxcXFxsZWZ0KFxcXFxyaWdodC5cIixcIuKMqlwiOlwiXFxcXHJhbmdsZVwiLFwi4oypXCI6XCJcXFxcbGFuZ2xlXCIsXCLijItcIjpcIlxcXFxyZmxvb3JcIixcIuKMilwiOlwiXFxcXGxmbG9vclwiLFwi4oyJXCI6XCJcXFxccmNlaWxcIixcIuKMiFwiOlwiXFxcXGxjZWlsXCIsXCLigJZcIjpcIlxcXFxwYXJhbGxlbFwiLFwifVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0fVwiLFwie1wiOlwiXFxcXGxlZnR7XFxcXHJpZ2h0LlwiLFwiXVwiOlwiXFxcXGxlZnRdXFxcXHJpZ2h0LlwiLFwiW1wiOlwiXFxcXGxlZnRbXFxcXHJpZ2h0LlwiLFwiKVwiOlwiXFxcXGxlZnQuXFxcXHJpZ2h0KVwiLFwiKFwiOlwiXFxcXGxlZnQoXFxcXHJpZ2h0LlwiLFwi4oCdXCI6J1xcXFxcIicsXCLigJxcIjpcIlxcXFx0ZXh0e2BgfVwiLFwi4oCZXCI6XCInXCIsXCLigJhcIjpcImBcIizOsTpcIlxcXFxhbHBoYVwiLM6yOlwiXFxcXGJldGFcIizOszpcIlxcXFxnYW1tYVwiLM6TOlwiXFxcXEdhbW1hXCIszrQ6XCJcXFxcZGVsdGFcIizOlDpcIlxcXFxEZWx0YVwiLM+1OlwiXFxcXGVwc2lsb25cIizOtjpcIlxcXFx6ZXRhXCIszrc6XCJcXFxcZXRhXCIszrg6XCJcXFxcdGhldGFcIizOmDpcIlxcXFxUaGV0YVwiLM65OlwiXFxcXGlvdGFcIizOujpcIlxcXFxrYXBwYVwiLM67OlwiXFxcXGxhbWJkYVwiLM69OlwiXFxcXG51XCIszr86XCJcXFxcb21pY3JvblwiLM+AOlwiXFxcXHBpXCIszqA6XCJcXFxcUGlcIizPgTpcIlxcXFxyaG9cIizPgzpcIlxcXFxzaWdtYVwiLM6jOlwiXFxcXFNpZ21hXCIsz4Q6XCJcXFxcdGF1XCIsz4U6XCJcXFxcdXBzaWxvblwiLM6lOlwiXFxcXFVwc2lsb25cIizPlTpcIlxcXFxwaGlcIizOpjpcIlxcXFxQaGlcIizPhzpcIlxcXFxjaGlcIizPiDpcIlxcXFxwc2lcIizOqDpcIlxcXFxQc2lcIizPiTpcIlxcXFxvbWVnYVwiLM6pOlwiXFxcXE9tZWdhXCIs4oSmOlwiXFxcXE9tZWdhXCIsXCLiiIVcIjpcIlxcXFxlbXB0eXNldFwiLFwi4p+yXCI6XCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIsXCLin7NcIjpcIlxcXFxjaXJjbGVhcnJvd3JpZ2h0XCIsXCLDl1wiOlwiXFxcXHRpbWVzXCIsXCLCvVwiOlwiXFxcXGRmcmFjezF9ezJ9XCIszrw6XCJcXFxcbXVcIizTqDpcIlxcXFx0aGV0YVwiLFwi4pyTXCI6XCJcXFxcY2hlY2ttYXJrXCIsXCLin6lcIjpcIlxcXFxyYW5nbGVcIixcIuKfqFwiOlwiXFxcXGxhbmdsZVwiLFwiwrxcIjpcIlxcXFxkZnJhY3sxfXs0fVwiLFwi4oCmXCI6XCJcXFxcbGRvdHNcIizihI86XCJcXFxcaGJhclwiLOKEnDpcIlxcXFxtYXRoZnJha3tSfVwiLNGyOlwiXFxcXHRoZXRhXCIsw5g6XCJcXFxcZW1wdHlzZXRcIizPsTpcIlxcXFx2YXJyaG9cIizRhDpcIlxcXFxwaGlcIizihIc6XCJcXFxcdmFyZXBzaWxvblwiLFQ6XCJUXCIsXCLiiJlcIjpcIlxcXFxjZG90XCIszqE6XCJQXCIsXCLiiJ5cIjpcIlxcXFxpbmZ0eVwiLOGQgTpcIlxcXFxuYWJsYVwiLMaeOlwiXFxcXGV0YVwiLFwi4oG6XCI6XCJeeyt9XCIsXCLigbtcIjpcIl57LX1cIixcIuKBvFwiOlwiXns9fVwiLFwi4oG9XCI6XCJeeyh9XCIsXCLigb5cIjpcIl57KX1cIixcIuOAl1wiOlwiXFxcXCl8XCIsXCLjgJZcIjpcIlxcXFxsYW5nbGVcIixcIs2+XCI6XCI7XCIsXCLgtaZcIjpcIlxcXFxjaXJjXCIsXCLilLRcIjpcIlxcXFxwZXJwXCIsXCLinJVcIjpcIlxcXFx0aW1lc1wiLFwi4o67XCI6XCItXCIsXCLCu1wiOlwiXFxcXGdnXCIsXCLirIZcIjpcIlxcXFx1cGFycm93XCIsXCLirIdcIjpcIlxcXFxkb3duYXJyb3dcIixcIuKshVwiOlwiXFxcXGxlZnRhcnJvd1wiLFwi4p6hXCI6XCJcXFxccmlnaHRhcnJvd1wiLFwi4o68XCI6XCItXCIsXCLijpxcIjpcIlxcXFxtaWRcIixcIuKOpVwiOlwiXFxcXG1pZFwiLMSnOlwiXFxcXGhiYXJcIixcIuKulVwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuODu1wiOlwiXFxcXGNkb3RcIixcIsKmXCI6XCJcXFxcbWlkXCIsXCLCo1wiOlwiXFxcXHBvdW5kc1wiLFwiwqVcIjpcIlxcXFx5ZW5cIixcIuKcl1wiOlwiXFxcXHRpbWVzXCIsXCLinJRcIjpcIlxcXFxjaGVja21hcmtcIizigb86XCJee259XCIsXCLCq1wiOlwiXFxcXGxsXCIs4LmAOlwiXFxcXHByaW1lXCIsXCLigKBcIjpcIlxcXFxkYWdnZXJcIixcIuKUglwiOlwiXFxcXG1pZFwiLCQ6XCJcXFxcJFwiLFwiI1wiOlwiXFxcXCNcIixcIuKEg1wiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgQ31cIixcIuKEiVwiOlwiXFxcXHRleHR7XFxcXHRleHRkZWdyZWUgRn1cIixcIuKWiFwiOlwiXFxcXGJsYWNrc3F1YXJlXCIsXCLihKdcIjpcIlxcXFxtaG9cIizihYc6XCJcXFxcdGV4dHtlfVwiLMm8OlwiclwiLFwi4oChXCI6XCJcXFxcZGRhZ2dlclwiLOG8sTpcImlcIizPkjpcIlxcXFxVcHNpbG9uXCIs8J2bvzpcIlxcXFxkZWx0YVwiLFwiy7NcIjpcIlxcXFxjZG90XCIs0bM6XCJcXFxcdGhldGFcIizwnZyZOlwiXFxcXHBoaVwiLNCfOlwiXFxcXHByb2RcIizQvjpcIm9cIizRkjpcIlxcXFxoYmFyXCIsyYU6XCJcXFxcTGFtYmRhXCIsXCLgpaRcIjpcIlxcXFxtaWRcIixcIuKCrFwiOlwiXFxcXGV1cm9cIizhv6E6XCJcXFxcYmFye3V9XCIsz4Y6XCJcXFxcdmFycGhpXCIsyLw6XCJjXCIs8J2erjpcIlxcXFxlcHNpbG9uXCIszqc6XCJcXFxcbWF0aHNme1h9XCIs4oKZOlwiX3tufVwifX0sODI0OTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYWxsTWF0aFN5bWJvbHNCeUNoYXI9dm9pZCAwLHQuYWxsTWF0aFN5bWJvbHNCeUNoYXI9e1wiJiN4QTA7XCI6XCJcXFxcdGV4dHJteyB9XCIsXCImI3gyMjAzO1wiOlwiXFxcXGV4aXN0c1wiLFwiJiN4MjIwMDtcIjpcIlxcXFxmb3JhbGxcIixcIiYjeDIxRDQ7XCI6XCJcXFxcaWZmXCIsXCImI3gyMUQyO1wiOlwiPT5cIixcIiYjeEFDO1wiOlwiXFxcXG5lZ1wiLFwiJiN4MjEyNDtcIjpcIlxcXFxtYXRoYmJ7Wn1cIixcIiYjeDIxMUQ7XCI6XCJcXFxcbWF0aGJie1J9XCIsXCImI3gyMTFBO1wiOlwiXFxcXG1hdGhiYntRfVwiLFwiJiN4MjExNTtcIjpcIlxcXFxtYXRoYmJ7Tn1cIixcIiYjeDIxMDI7XCI6XCJDQ1wiLFwiJiN4MjVBMTtcIjpcIlxcXFxzcXVhcmVcIixcIiYjeDIyQzQ7XCI6XCJcXFxcZGlhbW9uZFwiLFwiJiN4MjVCMztcIjpcIlxcXFx0cmlhbmdsZVwiLFwiJiN4MjMyMjtcIjpcIlxcXFxmcm93blwiLFwiJiN4MjIyMDtcIjpcIlxcXFxhbmdsZVwiLFwiJiN4MjJGMTtcIjpcIlxcXFxkZG90c1wiLFwiJiN4MjJFRTtcIjpcIlxcXFx2ZG90c1wiLFwiJiN4MjIzNTtcIjpcIlxcXFxiZWNhdXNlXCIsXCImI3gyMjM0O1wiOlwiXFxcXHRoZXJlZm9yZVwiLFwiJiN4MjEzNTtcIjpcIlxcXFxhbGVwaFwiLFwiJiN4MjIwNTtcIjpcIlxcXFxvc2xhc2hcIixcIiYjeEIxO1wiOlwiXFxcXHBtXCIsXCImI3gyMjA3O1wiOlwiXFxcXG5hYmxhXCIsXCImI3gyMjAyO1wiOlwiXFxcXHBhcnRpYWxcIixcIiYjeDIyMkU7XCI6XCJcXFxcb2ludFwiLFwiJiN4MjIyQjtcIjpcIlxcXFxpbnRcIixcIiYjeDIyQzM7XCI6XCJcXFxcY3VwXCIsXCImI3gyMjJBO1wiOlwiXFxcXGN1cFwiLFwiJiN4MjJDMjtcIjpcIlxcXFxjYXBcIixcIiYjeDIyMjk7XCI6XCJcXFxcY2FwXCIsXCImI3gyMkMxO1wiOlwiXFxcXHZlZVwiLFwiJiN4MjIyODtcIjpcIlxcXFx2ZWVcIixcIiYjeDIyQzA7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDIyMjc7XCI6XCJcXFxcd2VkZ2VcIixcIiYjeDIyMEY7XCI6XCJcXFxccHJvZFwiLFwiJiN4MjIxMTtcIjpcIlxcXFxzdW1cIixcIiYjeDIyOTk7XCI6XCJcXFxcYmlnb2RvdFwiLFwiJiN4MjI5NztcIjpcIlxcXFxiaWdvcGx1c1wiLFwiJiN4MjI5NTtcIjpcIm8rXCIsXCImI3gyMjE4O1wiOlwiQFwiLFwiJiN4MjJDODtcIjpcIlxcXFxib3d0aWVcIixcIiYjeDIyQ0E7XCI6XCJcXFxccnRpbWVzXCIsXCImI3gyMkM5O1wiOlwiXFxcXGx0aW1lc1wiLFwiJiN4Rjc7XCI6XCJcXFxcZGl2XCIsXCImI3hENztcIjpcIlxcXFx0aW1lc1wiLFwiXFxcXFwiOlwiXFxcXGJhY2tzbGFzaFwiLFwiJiN4MjJDNjtcIjpcIlxcXFxzdGFyXCIsXCImI3gyMjE3O1wiOlwiXFxcXHN0YXJcIixcIiYjeDIyQzU7XCI6XCJcXFxcY2RvdFwiLFwiJiN4M0E5O1wiOlwiXFxcXE9tZWdhXCIsXCImI3gzQzk7XCI6XCJcXFxcb21lZ2FcIixcIiYjeDNBODtcIjpcIlxcXFxQc2lcIixcIiYjeDNDODtcIjpcIlxcXFxwc2lcIixcIiYjeDNDNztcIjpcIlxcXFxjaGlcIixcIiYjeDNDNjtcIjpcIlxcXFx2YXJwaGlcIixcIiYjeDNBNjtcIjpcIlxcXFxQaGlcIixcIiYjeDNENTtcIjpcIlxcXFxwaGlcIixcIiYjeDNDNTtcIjpcIlxcXFx1cHNpbG9uXCIsXCImI3gzQzQ7XCI6XCJcXFxcdGF1XCIsXCImI3gzQTM7XCI6XCJcXFxcU2lnbWFcIixcIiYjeDNDMztcIjpcIlxcXFxzaWdtYVwiLFwiJiN4M0MxO1wiOlwiXFxcXHJob1wiLFwiJiN4M0EwO1wiOlwiXFxcXFBpXCIsXCImI3gzQzA7XCI6XCJcXFxccGlcIixcIiYjeDM5RTtcIjpcIlxcXFxYaVwiLFwiJiN4M0JFO1wiOlwiXFxcXHhpXCIsXCImI3gzQkQ7XCI6XCJcXFxcbnVcIixcIiYjeDNCQztcIjpcIlxcXFxtdVwiLFwiJiN4MzlCO1wiOlwiXFxcXExhbWJkYVwiLFwiJiN4M0JCO1wiOlwiXFxcXGxhbWJkYVwiLFwiJiN4M0JBO1wiOlwiXFxcXGthcHBhXCIsXCImI3gzQjk7XCI6XCJcXFxcaW90YVwiLFwiJiN4M0QxO1wiOlwiXFxcXHZhcnRoZXRhXCIsXCImI3gzOTg7XCI6XCJcXFxcVGhldGFcIixcIiYjeDNCODtcIjpcIlxcXFx0aGV0YVwiLFwiJiN4M0I3O1wiOlwiXFxcXGV0YVwiLFwiJiN4M0I2O1wiOlwiXFxcXHpldGFcIixcIiYjeDI1QjtcIjpcIlxcXFx2YXJlcHNpbG9uXCIsXCImI3gzQjU7XCI6XCJcXFxcZXBzaWxvblwiLFwiJiN4Mzk0O1wiOlwiXFxcXERlbHRhXCIsXCImI3gzQjQ7XCI6XCJcXFxcZGVsdGFcIixcIiYjeDM5MztcIjpcIlxcXFxHYW1tYVwiLFwiJiN4M0IzO1wiOlwiXFxcXGdhbW1hXCIsXCImI3gzQjI7XCI6XCJcXFxcYmV0YVwiLFwiJiN4M0IxO1wiOlwiXFxcXGFscGhhXCIsXCImI3gyMjFFO1wiOlwiXFxcXGluZnR5XCIsXCLigKxcIjpcIlxcXFx0ZXh0e1xcXFx0ZXh0ZGlyIFRSVH1cIixcIuKAjlwiOlwiXFxcXHRleHR7XFxcXHRleHRkaXIgTFRSfVwifX0sODE3MTooZSx0KT0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuYWxsTWF0aFN5bWJvbHNCeUdseXBoPXZvaWQgMCx0LmFsbE1hdGhTeW1ib2xzQnlHbHlwaD17XCIgXCI6XCJcXFxcdGV4dHJteyB9XCIsXCLiiINcIjpcIlxcXFxleGlzdHNcIixcIuKIgFwiOlwiXFxcXGZvcmFsbFwiLFwi4oeUXCI6XCJcXFxcaWZmXCIsXCLih5JcIjpcIlxcXFxSaWdodGFycm93XCIsXCLCrFwiOlwiXFxcXG5lZ1wiLFwi4pahXCI6XCJcXFxcc3F1YXJlXCIsXCLii4RcIjpcIlxcXFxkaWFtb25kXCIsXCLilrNcIjpcIlxcXFx0cmlhbmdsZVwiLFwi4oyiXCI6XCJcXFxcZnJvd25cIixcIuKIoFwiOlwiXFxcXGFuZ2xlXCIsXCLii7FcIjpcIlxcXFxkZG90c1wiLFwi4ouuXCI6XCJcXFxcdmRvdHNcIixcIuKItVwiOlwiXFxcXGJlY2F1c2VcIixcIuKItFwiOlwiXFxcXHRoZXJlZm9yZVwiLOKEtTpcIlxcXFxhbGVwaFwiLFwi4oiFXCI6XCJcXFxcZW1wdHlzZXRcIixcIsKxXCI6XCJcXFxccG1cIixcIuKIh1wiOlwiXFxcXG5hYmxhXCIsXCLiiIJcIjpcIlxcXFxwYXJ0aWFsXCIsXCLiiK5cIjpcIlxcXFxvaW50XCIsXCLiiKtcIjpcIlxcXFxpbnRcIixcIuKLg1wiOlwiXFxcXGN1cFwiLFwi4oiqXCI6XCJcXFxcY3VwXCIsXCLii4JcIjpcIlxcXFxjYXBcIixcIuKIqVwiOlwiXFxcXGNhcFwiLFwi4ouBXCI6XCJcXFxcdmVlXCIsXCLiiKhcIjpcIlxcXFx2ZWVcIixcIuKLgFwiOlwiXFxcXHdlZGdlXCIsXCLiiKdcIjpcIlxcXFx3ZWRnZVwiLFwi4oiPXCI6XCJcXFxccHJvZFwiLFwi4oiRXCI6XCJcXFxcc3VtXCIsXCLiiplcIjpcIlxcXFxiaWdvZG90XCIsXCLiipdcIjpcIlxcXFxiaWdvcGx1c1wiLFwi4oqVXCI6XCJvK1wiLFwi4oiYXCI6XCJAXCIsXCLii4hcIjpcIlxcXFxib3d0aWVcIixcIuKLilwiOlwiXFxcXHJ0aW1lc1wiLFwi4ouJXCI6XCJcXFxcbHRpbWVzXCIsXCLDt1wiOlwiXFxcXGRpdlwiLFwiw5dcIjpcIlxcXFx0aW1lc1wiLFwiXFxcXFwiOlwiXFxcXGJhY2tzbGFzaFwiLFwi4ouGXCI6XCJcXFxcc3RhclwiLFwi4oiXXCI6XCJcXFxcc3RhclwiLFwi4ouFXCI6XCJcXFxcY2RvdFwiLM6pOlwiXFxcXE9tZWdhXCIsz4k6XCJcXFxcb21lZ2FcIizOqDpcIlxcXFxQc2lcIizPiDpcIlxcXFxwc2lcIizPhzpcIlxcXFxjaGlcIizPhjpcIlxcXFx2YXJwaGlcIizOpjpcIlxcXFxQaGlcIizPlTpcIlxcXFxwaGlcIizPhTpcIlxcXFx1cHNpbG9uXCIsz4Q6XCJcXFxcdGF1XCIszqM6XCJcXFxcU2lnbWFcIizPgzpcIlxcXFxzaWdtYVwiLM+BOlwiXFxcXHJob1wiLM6gOlwiXFxcXFBpXCIsz4A6XCJcXFxccGlcIizOnjpcIlxcXFxYaVwiLM6+OlwiXFxcXHhpXCIszr06XCJcXFxcbnVcIizOvDpcIlxcXFxtdVwiLM6bOlwiXFxcXExhbWJkYVwiLM67OlwiXFxcXGxhbWJkYVwiLM66OlwiXFxcXGthcHBhXCIszrk6XCJcXFxcaW90YVwiLM+ROlwiXFxcXHZhcnRoZXRhXCIszpg6XCJcXFxcVGhldGFcIizOuDpcIlxcXFx0aGV0YVwiLM63OlwiXFxcXGV0YVwiLM62OlwiXFxcXHpldGFcIizJmzpcIlxcXFx2YXJlcHNpbG9uXCIszrU6XCJcXFxcZXBzaWxvblwiLM6UOlwiXFxcXERlbHRhXCIszrQ6XCJcXFxcZGVsdGFcIizOkzpcIlxcXFxHYW1tYVwiLM6zOlwiXFxcXGdhbW1hXCIszrI6XCJcXFxcYmV0YVwiLM6xOlwiXFxcXGFscGhhXCIsXCLiiJ5cIjpcIlxcXFxpbmZ0eVwiLM+1OlwiXFxcXGVwc2lsb25cIizCtTpcIlxcXFxtdVwiLFwiwrJcIjpcIl57Mn1cIizEsTpcIlxcXFxpbWF0aFwiLFwi4oiOXCI6XCJcXFxcYmxhY2tzcXVhcmVcIizguKE6XCJcXFxcbWF0aGJme219XCIs4oSmOlwiXFxcXE9tZWdhXCIsXCLin7JcIjpcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIixcIuKfs1wiOlwiXFxcXGNpcmNsZWFycm93cmlnaHRcIizgpKQ6XCIgXCIsXCLCpVwiOlwiXFxcXHllblwiLFwi4oG9XCI6XCJeeyh9XCIsXCLigb5cIjpcIl57KX1cIizDnzpcIlxcXFxzc1wiLNCLOlwiXFxcXGhiYXJcIixcIuKmtVwiOlwiXFxcXG9taW51c1wiLFwi4oq/XCI6XCJcXFxcYmlndHJpYW5nbGV1cFwiLFwi4oabJ1wiOlwiXFxcXG5yaWdodGFycm93XCIsXCLigKBcIjpcIlxcXFxkYWdnZXJcIizguYA6XCJcXFxccHJpbWVcIiznmb06XCIgXCIsXCLiv7FcIjpcIiBcIizihLg6XCJcXFxcd3BcIiztk7A6XCIgXCIs4oG/OlwiXntufVwiLFwi4pyUXCI6XCJcXFxcY2hlY2ttYXJrXCIsXCLinJdcIjpcIlxcXFx0aW1lc1wiLFwiwr1cIjpcIlxcXFxkZnJhY3sxfXsyfVwiLNOoOlwiXFxcXHRoZXRhXCIsXCLinJNcIjpcIlxcXFxjaGVja21hcmtcIixcIuKfqVwiOlwiXFxcXHJhbmdsZVwiLFwi4p+oXCI6XCJcXFxcbGFuZ2xlXCIsXCLijKlcIjpcIlxcXFxsYW5nbGVcIixcIsK8XCI6XCJcXFxcZGZyYWN7MX17NH1cIixcIuKAplwiOlwiXFxcXGxkb3RzXCIs4oSPOlwiXFxcXGhiYXJcIizihJw6XCJcXFxcbWF0aGZyYWt7Un1cIizRsjpcIlxcXFx0aGV0YVwiLMOYOlwiXFxcXGVtcHR5c2V0XCIsz7E6XCJcXFxcdmFycmhvXCIs0YQ6XCJcXFxccGhpXCIsVDpcIlRcIixcIuKImVwiOlwiXFxcXGNkb3RcIizOoTpcIlBcIizhkIE6XCJcXFxcbmFibGFcIizGnjpcIlxcXFxldGFcIizJozpcIlxcXFxnYW1tYVwiLNGbOlwiXFxcXGhiYXJcIizGkDpcIlxcXFx2YXJlcHNpbG9uXCIs4oWFOlwiXFxcXF97RH1cIizwnZyGOlwiXFxcXGxhbWJkYVwiLFwi44CXXCI6XCJcXFxccmFuZ2xlXCIsXCLjgJZcIjpcIlxcXFxsYW5nbGVcIixcIs2+XCI6XCI7XCIs8J2RpTpcInhcIizwnZGmOlwieVwiLPCdkac6XCJ6XCIs8J2RljpcImlcIizwnZGXOlwialwiLPCdkZg6XCJrXCIs8J2RmjpcIm1cIizwnZGSOlwiZVwiLPCdkZ86XCJyXCIsybM6XCJcXFxcZXRhXCIs8J2bvTpcIlxcXFxiZXRhXCIsXCLijbVcIjpcIlxcXFxvbWVnYVwiLOKEmDpcIlxcXFx3cFwiLPCdnIs6XCJcXFxccGlcIizQhDpcIlxcXFxlcHNpbG9uXCIs0ZQ6XCJcXFxcZXBzaWxvblwiLPCdnIA6XCJcXFxcZXBzaWxvblwiLNC/OlwiXFxcXHBpXCIszp06XCJcXFxcbnVcIizJtTpcIlxcXFx0aGV0YVwiLPCdnJM6XCJcXFxccHNpXCIsz7Q6XCJcXFxcdGhldGFcIizJuDpcIlxcXFxwaGlcIizTtjpcIlxcXFxHYW1tYVwiLMmtOlwiXFxcXGVsbFwiLMqLOlwiXFxcXHVwc2lsb25cIizwnZufOlwiXFxcXHZhcnBoaVwiLFwi4o2sXCI6XCJcXFxcdGhldGFcIizQpDpcIlxcXFxQaGlcIizwnZyROlwiXFxcXHZhcnBoaVwiLOKFiDpcImlcIizOvzpcIm9cIizGoTpcIm9cIizGkjpcImZcIixcIuKNtFwiOlwiXFxcXHJob1wiLFwi8J+HvVwiOlwieFwiLPCdkZ06XCJwXCIs8J2RnjpcInFcIizwnZGgOlwic1wiLPCdkaE6XCJ0XCIs8J2RojpcInVcIizwnZGjOlwidlwiLPCdkaQ6XCJ3XCIs8J2RjjpcImFcIizwnZGPOlwiYlwiLPCdkZA6XCJjXCIs8J2RkTpcImRcIizwnZGTOlwiZlwiLPCdkZQ6XCJnXCIs8J2RmTpcImxcIizwnZGbOlwiblwiLPCdkZw6XCJvXCIs8J2UgDpcIndcIizwnZqfOlwidlwiLOG5gTpcIm1cIixcIuC1plwiOlwiXFxcXGNpcmNcIixcIuKUtFwiOlwiXFxcXHBlcnBcIixcIuKclVwiOlwiXFxcXHRpbWVzXCIsXCLiiKNcIjpcIlxcXFxtaWRcIizVkzpcIlxcXFxQaGlcIixcIuKOnFwiOlwiXFxcXG1pZFwiLMSnOlwiXFxcXGhiYXJcIizhjYg6XCIgXCIsXCLipqhcIjpcIlxcXFxsbGJyYWNrZXRcIizhur86XCJcXFxcaGF0e2V9XCIsXCLColwiOlwiXFxcXGNlbnRcIixcIuKkuVwiOlwiXFxcXGRvd25hcnJvd1wiLFwi4qS4XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLdcIjpcIlxcXFxSc2hcIixcIuKktlwiOlwiXFxcXExzaFwiLFwi4qS1XCI6XCJcXFxcZG93bmFycm93XCIsXCLipLRcIjpcIlxcXFx1cGFycm93XCIsXCLipLNcIjpcIlxcXFxyaWdodGFycm93XCIsXCJ8XCI6XCJcXFxcbWlkXCIsXCLijqVcIjpcIlxcXFxtaWRcIixcIuKZpVwiOlwiXFxcXGhlYXJ0c3VpdFwiLNCeOlwiMFwiLM6lOlwiWVwiLNGFOlwieFwiLPCdk486XCJ6XCIs8J2TjjpcInlcIizwnZONOlwieFwiLNGAOlwicFwiLNCwOlwiYVwiLFwiwqNcIjpcIlxcXFxwb3VuZHNcIixtOlwibVwiLPCdmrU6XCJcXFxcWGlcIixcIuKTqlwiOlwiXFxcXHRleHRjaXJjbGVkezB9XCIsXCLikaBcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxfVwiLFwi4pGhXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mn1cIixcIuKRolwiOlwiXFxcXHRleHRjaXJjbGVkezN9XCIsXCLikaNcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0fVwiLFwi4pGkXCI6XCJcXFxcdGV4dGNpcmNsZWR7NX1cIixcIuKRpVwiOlwiXFxcXHRleHRjaXJjbGVkezZ9XCIsXCLikaZcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs3fVwiLFwi4pGnXCI6XCJcXFxcdGV4dGNpcmNsZWR7OH1cIixcIuKRqFwiOlwiXFxcXHRleHRjaXJjbGVkezl9XCIsXCLikalcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMH1cIixcIuKRqlwiOlwiXFxcXHRleHRjaXJjbGVkezExfVwiLFwi4pGrXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTJ9XCIsXCLikaxcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxM31cIixcIuKRrVwiOlwiXFxcXHRleHRjaXJjbGVkezE0fVwiLFwi4pGuXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTV9XCIsXCLika9cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNn1cIixcIuKRsFwiOlwiXFxcXHRleHRjaXJjbGVkezE3fVwiLFwi4pGxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTh9XCIsXCLikbJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOX1cIixcIuKRs1wiOlwiXFxcXHRleHRjaXJjbGVkezIwfVwiLFwi44mRXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjF9XCIsXCLjiZJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMn1cIixcIuOJk1wiOlwiXFxcXHRleHRjaXJjbGVkezIzfVwiLFwi44mUXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjR9XCIsXCLjiZVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNX1cIixcIuOJllwiOlwiXFxcXHRleHRjaXJjbGVkezI2fVwiLFwi44mXXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjd9XCIsXCLjiZhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyOH1cIixcIuOJmVwiOlwiXFxcXHRleHRjaXJjbGVkezI5fVwiLFwi44maXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzB9XCIsXCLjiZtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMX1cIixcIuOJnFwiOlwiXFxcXHRleHRjaXJjbGVkezMyfVwiLFwi44mdXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzN9XCIsXCLjiZ5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNH1cIixcIuOJn1wiOlwiXFxcXHRleHRjaXJjbGVkezM1fVwiLFwi44qxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzZ9XCIsXCLjirJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszN31cIixcIuOKs1wiOlwiXFxcXHRleHRjaXJjbGVkezM4fVwiLFwi44q0XCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzl9XCIsXCLjirVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0MH1cIixcIuOKtlwiOlwiXFxcXHRleHRjaXJjbGVkezQxfVwiLFwi44q3XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDJ9XCIsXCLjirhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0M31cIixcIuOKuVwiOlwiXFxcXHRleHRjaXJjbGVkezQ0fVwiLFwi44q6XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDV9XCIsXCLjirtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Nn1cIixcIuOKvFwiOlwiXFxcXHRleHRjaXJjbGVkezQ3fVwiLFwi44q9XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDh9XCIsXCLjir5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OX1cIixcIuOKv1wiOlwiXFxcXHRleHRjaXJjbGVkezUwfVwiLFwiJlwiOlwiXFxcXCZcIixcIuKAllwiOlwiXFxcXHBhcmFsbGVsXCIsXCIlXCI6XCJcXFxcJVwiLFwi4oCcXCI6XCJcXFxcdGV4dHtgYH1cIiwkOlwiXFxcXCRcIixcIiNcIjpcIlxcXFwjXCIsXCLihINcIjpcIlxcXFx0ZXh0e1xcXFx0ZXh0ZGVncmVlIEN9XCIsXCLihIlcIjpcIlxcXFx0ZXh0e1xcXFx0ZXh0ZGVncmVlIEZ9XCIsXCLilohcIjpcIlxcXFxibGFja3NxdWFyZVwiLFwi4oSnXCI6XCJcXFxcbWhvXCIsXCLijItcIjpcIlxcXFxyZmxvb3JcIixcIuKMilwiOlwiXFxcXGxmbG9vclwiLFwi4oyJXCI6XCJcXFxccmNlaWxcIixcIuKMiFwiOlwiXFxcXGxjZWlsXCIs4oSHOlwiXFxcXHZhcmVwc2lsb25cIizihYc6XCJcXFxcdGV4dHtlfVwiLMm8OlwiclwiLFwi4oabXCI6XCJcXFxcbnJpZ2h0YXJyb3dcIizLhjpcIlxcXFxoYXR7fVwiLFwi4oC+XCI6XCJcXFxcb3ZlcmxpbmVcIixcIuKGklwiOlwiXFxcXHJpZ2h0YXJyb3dcIixcIuKAoVwiOlwiXFxcXGRkYWdnZXJcIixcIuODu1wiOlwiXFxcXGNkb3RcIixcIuKWsVwiOlwiXFxcXHNxdWFyZVwiLFwi4oiGXCI6XCJcXFxcRGVsdGFcIizhvLE6XCJpXCIsXCLiiKFcIjpcIlxcXFxhbmdsZVwiLM+SOlwiXFxcXFVwc2lsb25cIixcIuKGk1wiOlwiXFxcXGRvd25hcnJvd1wiLFwi4oaRXCI6XCJcXFxcdXBhcnJvd1wiLFwiwrtcIjpcIlxcXFxnZ1wiLFwi4oqkXCI6XCJcXFxcdG9wXCIsXCLip7hcIjpcIi9cIizwnZu/OlwiXFxcXGRlbHRhXCIsXCLLs1wiOlwiXFxcXGNkb3RcIixcItaJXCI6XCI6XCIsXCLipqpcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqlcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipqtcIjpcIlxcXFxtZWFzdXJlZGFuZ2xlXCIsXCLipoFcIjpcIlxcXFxjZG90XCIs0bM6XCJcXFxcdGhldGFcIixcIuKmolwiOlwiXFxcXG1lYXN1cmVkYW5nbGVcIixcIsK4XCI6XCIsXCIsXCLijrtcIjpcIlxcXFxvdmVybGluZVwiLFwi4p+mXCI6XCJcXFxcbGxicmFja2V0XCIs8J2cmTpcIlxcXFxwaGlcIizQnzpcIlxcXFxwcm9kXCIs0L46XCJvXCIsXCLiiYhcIjpcIlxcXFxhcHByb3hcIixcIuKJpFwiOlwiXFxcXGxlcVwiLNGSOlwiXFxcXGhiYXJcIizJhTpcIlxcXFxMYW1iZGFcIizlnJ86XCJcXFxccG1cIixcIuKOvFwiOlwiLVwiLOWNgTpcIitcIixcIuKJoFwiOlwiXFxcXG5lcVwiLFwi4oaQXCI6XCJcXFxcbGVmdGFycm93XCIsXCLgpaRcIjpcIlxcXFxtaWRcIixcIuKCrFwiOlwiXFxcXGV1cm9cIixcIsuYXCI6XCIgXCIs4b+hOlwiXFxcXGJhcnt1fVwiLFwi4oilXCI6XCJcXFxccGFyYWxsZWxcIixcIuKGlFwiOlwiXFxcXGxlZnRyaWdodGFycm93XCIsXCLiiJpcIjpcIlxcXFxzcXJ0e31cIizIvDpcImNcIizwnZ6uOlwiXFxcXGVwc2lsb25cIixcIsK3XCI6XCJcXFxcY2RvdFwiLFwi4qasXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qauXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwi4qatXCI6XCJcXFxcbWVhc3VyZWRhbmdsZVwiLFwiwqtcIjpcIlxcXFxsbFwiLM6nOlwiXFxcXG1hdGhzZntYfVwiLFwi4pSCXCI6XCJcXFxcbWlkXCIsXCLijKpcIjpcIlxcXFxyYW5nbGVcIizigpk6XCJfe259XCIsXCLilqtcIjpcIlxcXFxzcXVhcmVcIixcIuKXj1wiOlwiXFxcXGNpcmNsZVwiLFwi4oCdXCI6J1xcXFxcIid9fSw1NDA2OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt2YXIgYT10aGlzJiZ0aGlzLl9fY3JlYXRlQmluZGluZ3x8KE9iamVjdC5jcmVhdGU/ZnVuY3Rpb24oZSx0LHIsYSl7dm9pZCAwPT09YSYmKGE9cik7dmFyIG49T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LHIpO24mJiEoXCJnZXRcImluIG4/IXQuX19lc01vZHVsZTpuLndyaXRhYmxlfHxuLmNvbmZpZ3VyYWJsZSl8fChuPXtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0W3JdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEsbil9OmZ1bmN0aW9uKGUsdCxyLGEpe3ZvaWQgMD09PWEmJihhPXIpLGVbYV09dFtyXX0pLG49dGhpcyYmdGhpcy5fX2V4cG9ydFN0YXJ8fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIGUpXCJkZWZhdWx0XCI9PT1yfHxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKXx8YSh0LGUscil9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4ocigyOTY1KSx0KSxuKHIoOTAzOSksdCksbihyKDgyNDkpLHQpLG4ocig4MTcxKSx0KSxuKHIoNDcyKSx0KSxuKHIoNDMyMCksdCksbihyKDYxMjIpLHQpfSw0NzI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmxhdGV4QWNjZW50cz12b2lkIDAsdC5sYXRleEFjY2VudHM9W1wiXFxcXGhhdFwiLFwiXFxcXGJhclwiLFwiXFxcXHVuZGVyYnJhY2VcIixcIlxcXFxvdmVyYnJhY2VcIl19LDQzMjA6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lm1hdGhOdW1iZXJCeUdseXBoPXZvaWQgMCx0Lm1hdGhOdW1iZXJCeUdseXBoPXtcIuKCgFwiOlwiX3swfVwiLFwi4oKBXCI6XCJfezF9XCIsXCLigoJcIjpcIl97Mn1cIixcIuKCg1wiOlwiX3szfVwiLFwi4oKEXCI6XCJfezR9XCIsXCLigoVcIjpcIl97NX1cIixcIuKChlwiOlwiX3s2fVwiLFwi4oKHXCI6XCJfezd9XCIsXCLigohcIjpcIl97OH1cIixcIuKCiVwiOlwiX3s5fVwiLFwi4oGwXCI6XCJeezB9XCIsXCLCuVwiOlwiXnsxfVwiLFwiwrJcIjpcIl57Mn1cIixcIsKzXCI6XCJeezN9XCIsXCLigbRcIjpcIl57NH1cIixcIuKBtVwiOlwiXns1fVwiLFwi4oG2XCI6XCJeezZ9XCIsXCLigbdcIjpcIl57N31cIixcIuKBuFwiOlwiXns4fVwiLFwi4oG5XCI6XCJeezl9XCIs4oG/OlwiXntufVwiLOKCmTpcIl97bn1cIixcIuKTqlwiOlwiXFxcXHRleHRjaXJjbGVkezB9XCIsXCLikaBcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxfVwiLFwi4pGhXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mn1cIixcIuKRolwiOlwiXFxcXHRleHRjaXJjbGVkezN9XCIsXCLikaNcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0fVwiLFwi4pGkXCI6XCJcXFxcdGV4dGNpcmNsZWR7NX1cIixcIuKRpVwiOlwiXFxcXHRleHRjaXJjbGVkezZ9XCIsXCLikaZcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs3fVwiLFwi4pGnXCI6XCJcXFxcdGV4dGNpcmNsZWR7OH1cIixcIuKRqFwiOlwiXFxcXHRleHRjaXJjbGVkezl9XCIsXCLikalcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxMH1cIixcIuKRqlwiOlwiXFxcXHRleHRjaXJjbGVkezExfVwiLFwi4pGrXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTJ9XCIsXCLikaxcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxM31cIixcIuKRrVwiOlwiXFxcXHRleHRjaXJjbGVkezE0fVwiLFwi4pGuXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTV9XCIsXCLika9cIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxNn1cIixcIuKRsFwiOlwiXFxcXHRleHRjaXJjbGVkezE3fVwiLFwi4pGxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MTh9XCIsXCLikbJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsxOX1cIixcIuKRs1wiOlwiXFxcXHRleHRjaXJjbGVkezIwfVwiLFwi44mRXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjF9XCIsXCLjiZJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyMn1cIixcIuOJk1wiOlwiXFxcXHRleHRjaXJjbGVkezIzfVwiLFwi44mUXCI6XCJcXFxcdGV4dGNpcmNsZWR7MjR9XCIsXCLjiZVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyNX1cIixcIuOJllwiOlwiXFxcXHRleHRjaXJjbGVkezI2fVwiLFwi44mXXCI6XCJcXFxcdGV4dGNpcmNsZWR7Mjd9XCIsXCLjiZhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHsyOH1cIixcIuOJmVwiOlwiXFxcXHRleHRjaXJjbGVkezI5fVwiLFwi44maXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzB9XCIsXCLjiZtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszMX1cIixcIuOJnFwiOlwiXFxcXHRleHRjaXJjbGVkezMyfVwiLFwi44mdXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzN9XCIsXCLjiZ5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHszNH1cIixcIuOJn1wiOlwiXFxcXHRleHRjaXJjbGVkezM1fVwiLFwi44qxXCI6XCJcXFxcdGV4dGNpcmNsZWR7MzZ9XCIsXCLjirJcIjpcIlxcXFx0ZXh0Y2lyY2xlZHszN31cIixcIuOKs1wiOlwiXFxcXHRleHRjaXJjbGVkezM4fVwiLFwi44q0XCI6XCJcXFxcdGV4dGNpcmNsZWR7Mzl9XCIsXCLjirVcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0MH1cIixcIuOKtlwiOlwiXFxcXHRleHRjaXJjbGVkezQxfVwiLFwi44q3XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDJ9XCIsXCLjirhcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0M31cIixcIuOKuVwiOlwiXFxcXHRleHRjaXJjbGVkezQ0fVwiLFwi44q6XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDV9XCIsXCLjirtcIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0Nn1cIixcIuOKvFwiOlwiXFxcXHRleHRjaXJjbGVkezQ3fVwiLFwi44q9XCI6XCJcXFxcdGV4dGNpcmNsZWR7NDh9XCIsXCLjir5cIjpcIlxcXFx0ZXh0Y2lyY2xlZHs0OX1cIixcIuOKv1wiOlwiXFxcXHRleHRjaXJjbGVkezUwfVwiLFwiwr1cIjpcIlxcXFxkZnJhY3sxfXsyfVwiLFwi4oWTXCI6XCJcXFxcZGZyYWN7MX17M31cIixcIuKFlFwiOlwiXFxcXGRmcmFjezJ9ezN9XCIsXCLCvFwiOlwiXFxcXGRmcmFjezF9ezR9XCIsXCLCvlwiOlwiXFxcXGRmcmFjezN9ezR9XCIsXCLihZVcIjpcIlxcXFxkZnJhY3sxfXs1fVwiLFwi4oWWXCI6XCJcXFxcZGZyYWN7Mn17NX1cIixcIuKFl1wiOlwiXFxcXGRmcmFjezN9ezV9XCIsXCLihZhcIjpcIlxcXFxkZnJhY3s0fXs1fVwiLFwi4oWZXCI6XCJcXFxcZGZyYWN7MX17Nn1cIixcIuKFmlwiOlwiXFxcXGRmcmFjezV9ezZ9XCIsXCLihZBcIjpcIlxcXFxkZnJhY3sxfXs3fVwiLFwi4oWbXCI6XCJcXFxcZGZyYWN7MX17OH1cIixcIuKFnFwiOlwiXFxcXGRmcmFjezN9ezh9XCIsXCLihZ1cIjpcIlxcXFxkZnJhY3s1fXs4fVwiLFwi4oWeXCI6XCJcXFxcZGZyYWN7N317OH1cIixcIuKFkVwiOlwiXFxcXGRmcmFjezF9ezl9XCIsXCLihZJcIjpcIlxcXFxkZnJhY3sxfXsxMH1cIn19LDYxMjI6KGUsdCk9PntcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0Lkhhc2hVVEY4VG9MdFhDb252ZXJ0ZXI9dm9pZCAwLHQuSGFzaFVURjhUb0x0WENvbnZlcnRlcj1jbGFzc3tjb252ZXJ0KGUpe2lmKGUubWF0Y2goL1thLXowLTldL2kpKXJldHVybiBlO2NvbnN0IHQ9cltlXTtpZih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0QWNjZW50Q2hhclRvTHRYKHQpfHxlfXJldHVybiB0aGlzLmNvbnZlcnRTcGVjaWFsQ2hhclRvTHRYKGUpfHxlfWNvbnZlcnRBY2NlbnRDaGFyVG9MdFgoZSl7Y29uc3R7Y2hhcjp0LGFjY2VudDpyfT1lLG49YVtyXTtyZXR1cm4gbj9gXFxcXCR7bn17JHt0fX1gOm51bGx9Y29udmVydFNwZWNpYWxDaGFyVG9MdFgoZSl7Y29uc3QgdD1uW2VdO2lmKCF0KXJldHVybiBudWxsO2NvbnN0e2xldHRlcjpyLGZvbnRDbWQ6YX09dDtyZXR1cm5gXFxcXCR7YX17JHtyfX1gfX07Y29uc3Qgcj17w6E6e2NoYXI6XCJhXCIsYWNjZW50OlwiwrRcIn0sw6A6e2NoYXI6XCJhXCIsYWNjZW50OlwiYFwifSzDojp7Y2hhcjpcImFcIixhY2NlbnQ6XCJeXCJ9LMOjOntjaGFyOlwiYVwiLGFjY2VudDpcIn5cIn0sw6Q6e2NoYXI6XCJhXCIsYWNjZW50OlwiwqhcIn0sw6U6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5pcIn0sxIU6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5lcIn0sxIM6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5hcIn0sx446e2NoYXI6XCJhXCIsYWNjZW50Olwiy4dcIn0sx586e2NoYXI6XCJhXCIsYWNjZW50Olwiy4ZcIn0sx7s6e2NoYXI6XCJhXCIsYWNjZW50Olwiy5lcIn0sx6E6e2NoYXI6XCJhXCIsYWNjZW50OlwiLVwifSzEgTp7Y2hhcjpcImFcIixhY2NlbnQ6XCItXCJ9LMOpOntjaGFyOlwiZVwiLGFjY2VudDpcIsK0XCJ9LMOoOntjaGFyOlwiZVwiLGFjY2VudDpcImBcIn0sw6o6e2NoYXI6XCJlXCIsYWNjZW50OlwiXlwifSzDqzp7Y2hhcjpcImVcIixhY2NlbnQ6XCLCqFwifSzEmTp7Y2hhcjpcImVcIixhY2NlbnQ6XCLLmVwifSzEmzp7Y2hhcjpcImVcIixhY2NlbnQ6XCLLh1wifSzIhzp7Y2hhcjpcImlcIixhY2NlbnQ6XCJeXCJ9LNGROntjaGFyOlwiZVwiLGFjY2VudDpcIsKoXCJ9LMSTOntjaGFyOlwiZVwiLGFjY2VudDpcIi1cIn0sw606e2NoYXI6XCJpXCIsYWNjZW50OlwiwrRcIn0sw6w6e2NoYXI6XCJpXCIsYWNjZW50OlwiYFwifSzDrjp7Y2hhcjpcImlcIixhY2NlbnQ6XCJeXCJ9LMOvOntjaGFyOlwiaVwiLGFjY2VudDpcIsKoXCJ9LMSvOntjaGFyOlwiaVwiLGFjY2VudDpcIsuZXCJ9LMeQOntjaGFyOlwiaVwiLGFjY2VudDpcIsuHXCJ9LMiJOntjaGFyOlwiaVwiLGFjY2VudDpcImBcIn0syIs6e2NoYXI6XCJpXCIsYWNjZW50OlwiwqhcIn0sxKs6e2NoYXI6XCJpXCIsYWNjZW50OlwiLVwifSzDszp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLCtFwifSzDsjp7Y2hhcjpcIm9cIixhY2NlbnQ6XCJgXCJ9LMO0OntjaGFyOlwib1wiLGFjY2VudDpcIl5cIn0sw7U6e2NoYXI6XCJvXCIsYWNjZW50OlwiflwifSzDtjp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLCqFwifSzFkTp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLLnVwifSzHkjp7Y2hhcjpcIm9cIixhY2NlbnQ6XCLLh1wifSzIjTp7Y2hhcjpcIm9cIixhY2NlbnQ6XCJgXCJ9LMiPOntjaGFyOlwib1wiLGFjY2VudDpcIsKoXCJ9LMirOntjaGFyOlwib1wiLGFjY2VudDpcIsuYXCJ9LMitOntjaGFyOlwib1wiLGFjY2VudDpcIsudXCJ9LMivOntjaGFyOlwib1wiLGFjY2VudDpcIsuZXCJ9LMWNOntjaGFyOlwib1wiLGFjY2VudDpcIi1cIn0sw7o6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwrRcIn0sw7k6e2NoYXI6XCJ1XCIsYWNjZW50OlwiYFwifSzDuzp7Y2hhcjpcInVcIixhY2NlbnQ6XCJeXCJ9LMO8OntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMWxOntjaGFyOlwidVwiLGFjY2VudDpcIsudXCJ9LMeUOntjaGFyOlwidVwiLGFjY2VudDpcIsuHXCJ9LMeWOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMeYOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMeaOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMecOntjaGFyOlwidVwiLGFjY2VudDpcIsKoXCJ9LMiVOntjaGFyOlwidVwiLGFjY2VudDpcImBcIn0syJc6e2NoYXI6XCJ1XCIsYWNjZW50OlwiwqhcIn0sxas6e2NoYXI6XCJ1XCIsYWNjZW50OlwiLVwifSzDvTp7Y2hhcjpcInlcIixhY2NlbnQ6XCLCtFwifSzhu7M6e2NoYXI6XCJ5XCIsYWNjZW50OlwiYFwifSzFtzp7Y2hhcjpcInlcIixhY2NlbnQ6XCJeXCJ9LMO/OntjaGFyOlwieVwiLGFjY2VudDpcIsKoXCJ9LMizOntjaGFyOlwieVwiLGFjY2VudDpcIi1cIn0sw4E6e2NoYXI6XCJBXCIsYWNjZW50OlwiwrRcIn0sw4A6e2NoYXI6XCJBXCIsYWNjZW50OlwiYFwifSzDgjp7Y2hhcjpcIkFcIixhY2NlbnQ6XCJeXCJ9LMODOntjaGFyOlwiQVwiLGFjY2VudDpcIn5cIn0sw4Q6e2NoYXI6XCJBXCIsYWNjZW50OlwiwqhcIn0sw4U6e2NoYXI6XCJBXCIsYWNjZW50Olwiy5pcIn0s4oSrOntjaGFyOlwiQVwiLGFjY2VudDpcIsuaXCJ9LMimOntjaGFyOlwiQVwiLGFjY2VudDpcIsuZXCJ9LMSCOntjaGFyOlwiQVwiLGFjY2VudDpcIsuYXCJ9LMeNOntjaGFyOlwiQVwiLGFjY2VudDpcIsuHXCJ9LMeeOntjaGFyOlwiQVwiLGFjY2VudDpcIsudXCJ9LMe6OntjaGFyOlwiQVwiLGFjY2VudDpcIsuaXCJ9LMegOntjaGFyOlwiQVwiLGFjY2VudDpcIi1cIn0sxIA6e2NoYXI6XCJBXCIsYWNjZW50OlwiLVwifSzDiTp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLCtFwifSzDiDp7Y2hhcjpcIkVcIixhY2NlbnQ6XCJgXCJ9LMSWOntjaGFyOlwiRVwiLGFjY2VudDpcIsuZXCJ9LMOKOntjaGFyOlwiRVwiLGFjY2VudDpcIl5cIn0sw4s6e2NoYXI6XCJFXCIsYWNjZW50OlwiwqhcIn0sxJo6e2NoYXI6XCJFXCIsYWNjZW50Olwiy4dcIn0syIQ6e2NoYXI6XCJFXCIsYWNjZW50OlwiYFwifSzIhjp7Y2hhcjpcIkVcIixhY2NlbnQ6XCLCqFwifSzEkjp7Y2hhcjpcIkVcIixhY2NlbnQ6XCItXCJ9LMONOntjaGFyOlwiSVwiLGFjY2VudDpcIsK0XCJ9LMOMOntjaGFyOlwiSVwiLGFjY2VudDpcImBcIn0sw446e2NoYXI6XCJJXCIsYWNjZW50OlwiXlwifSzDjzp7Y2hhcjpcIklcIixhY2NlbnQ6XCLCqFwifSzErDp7Y2hhcjpcIklcIixhY2NlbnQ6XCLLmFwifSzHjzp7Y2hhcjpcIklcIixhY2NlbnQ6XCLLh1wifSzIiDp7Y2hhcjpcIklcIixhY2NlbnQ6XCJgXCJ9LMiKOntjaGFyOlwiSVwiLGFjY2VudDpcIsKoXCJ9LMSqOntjaGFyOlwiSVwiLGFjY2VudDpcIi1cIn0sw5M6e2NoYXI6XCJPXCIsYWNjZW50OlwiwrRcIn0sw5I6e2NoYXI6XCJPXCIsYWNjZW50OlwiYFwifSzDlDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCJeXCJ9LMOVOntjaGFyOlwiT1wiLGFjY2VudDpcIn5cIn0sw5Y6e2NoYXI6XCJPXCIsYWNjZW50OlwiwqhcIn0sxZA6e2NoYXI6XCJPXCIsYWNjZW50Olwiy51cIn0sx5E6e2NoYXI6XCJPXCIsYWNjZW50Olwiy4dcIn0syIw6e2NoYXI6XCJPXCIsYWNjZW50OlwiYFwifSzIjjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLCqFwifSzIqjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLmFwifSzIrDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLnVwifSzIrjp7Y2hhcjpcIk9cIixhY2NlbnQ6XCLLmVwifSzFjDp7Y2hhcjpcIk9cIixhY2NlbnQ6XCItXCJ9LMOaOntjaGFyOlwiVVwiLGFjY2VudDpcIsK0XCJ9LMOZOntjaGFyOlwiVVwiLGFjY2VudDpcImBcIn0sw5s6e2NoYXI6XCJVXCIsYWNjZW50OlwiXlwifSzDnDp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLCqFwifSzFsDp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLLnVwifSzHkzp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLLh1wifSzHlTp7Y2hhcjpcIlVcIixhY2NlbnQ6XCLCqFwifSzIlDp7Y2hhcjpcIlVcIixhY2NlbnQ6XCJgXCJ9LMiWOntjaGFyOlwiVVwiLGFjY2VudDpcIsKoXCJ9LMWqOntjaGFyOlwiVVwiLGFjY2VudDpcIi1cIn0sw506e2NoYXI6XCJZXCIsYWNjZW50OlwiwrRcIn0s4buyOntjaGFyOlwiWVwiLGFjY2VudDpcImBcIn0sxbY6e2NoYXI6XCJZXCIsYWNjZW50OlwiXlwifSzFuDp7Y2hhcjpcIllcIixhY2NlbnQ6XCLCqFwifSzIsjp7Y2hhcjpcIllcIixhY2NlbnQ6XCItXCJ9LMOxOntjaGFyOlwiblwiLGFjY2VudDpcIn5cIn0sw5E6e2NoYXI6XCJOXCIsYWNjZW50OlwiflwifSzDpzp7Y2hhcjpcImNcIixhY2NlbnQ6XCLLmVwifSzDhzp7Y2hhcjpcIkNcIixhY2NlbnQ6XCLLmVwifSzhub06e2NoYXI6XCJ2XCIsYWNjZW50OlwiflwifSzhubw6e2NoYXI6XCJWXCIsYWNjZW50OlwiflwifSzEtTp7Y2hhcjpcImpcIixhY2NlbnQ6XCJeXCJ9LMS0OntjaGFyOlwiSlwiLGFjY2VudDpcIl5cIn0sxbo6e2NoYXI6XCJ6XCIsYWNjZW50OlwiwrRcIn0sxbk6e2NoYXI6XCJaXCIsYWNjZW50OlwiwrRcIn0sxbs6e2NoYXI6XCJaXCIsYWNjZW50OlwiXlwifSzFvDp7Y2hhcjpcInpcIixhY2NlbnQ6XCJeXCJ9LMW9OntjaGFyOlwiWlwiLGFjY2VudDpcIsuHXCJ9LMW+OntjaGFyOlwielwiLGFjY2VudDpcIsuHXCJ9LOG6kTp7Y2hhcjpcInpcIixhY2NlbnQ6XCLLhlwifX0sYT17XCLCtFwiOlwiZ3JhdmVcIixcImBcIjpcImFjdXRlXCIsXCJeXCI6XCJoYXRcIixcIn5cIjpcInRpbGRlXCIsXCLCqFwiOlwiZGRvdFwiLFwiy5pcIjpcIm1hdGhyaW5nXCIsXCLLmFwiOlwiYnJldmVcIizLhzpcImNoZWNrXCIsXCLLnVwiOlwiZGRvdFwiLFwiy5lcIjpcImRvdFwiLFwiLVwiOlwiYmFyXCIsy4Y6XCJoYXRcIixcIsucXCI6XCJ0aWxkZVwifSxuPXvwnZCAOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCBOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCCOntsZXR0ZXI6XCJDXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCDOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhiZlwifSzwnZCEOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGhiZlwifSzOlTp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QhTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qhjp7bGV0dGVyOlwiR1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qhzp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QiDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QiTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qijp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qizp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QjDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QjTp7bGV0dGVyOlwiTlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qjjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qjzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QkDp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QkTp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qkjp7bGV0dGVyOlwiU1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qkzp7bGV0dGVyOlwiVFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QlDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QlTp7bGV0dGVyOlwiVlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qljp7bGV0dGVyOlwiV1wiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2Qlzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2ehjp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QmDp7bGV0dGVyOlwiWVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0s8J2QmTp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+OXCI6e2xldHRlcjpcIjBcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fj1wiOntsZXR0ZXI6XCIxXCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5BcIjp7bGV0dGVyOlwiMlwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+RXCI6e2xldHRlcjpcIjNcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2fklwiOntsZXR0ZXI6XCI0XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5NcIjp7bGV0dGVyOlwiNVwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+UXCI6e2xldHRlcjpcIjZcIixmb250Q21kOlwibWF0aGJmXCJ9LFwi8J2flVwiOntsZXR0ZXI6XCI3XCIsZm9udENtZDpcIm1hdGhiZlwifSxcIvCdn5ZcIjp7bGV0dGVyOlwiOFwiLGZvbnRDbWQ6XCJtYXRoYmZcIn0sXCLwnZ+XXCI6e2xldHRlcjpcIjlcIixmb250Q21kOlwibWF0aGJmXCJ9LPCdkLQ6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLU6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLY6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLc6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLg6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLk6e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLo6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLs6e2xldHRlcjpcIkhcIixmb250Q21kOlwibWF0aGl0XCJ9LPCdkLw6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGl0XCJ9LM6ZOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZC9OntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZC+OntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZC/OntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGAOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGBOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGCOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGDOntsZXR0ZXI6XCJQXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGEOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGFOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGGOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGHOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGIOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGJOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGKOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGLOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGMOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZGNOntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhpdFwifSzwnZS4OntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZS5OntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhiYlwifSzihII6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlLs6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlLw6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlL06e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aGJiXCJ9LPCdlL46e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEjTp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2VgDp7bGV0dGVyOlwiSVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2VgTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Vgjp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2Vgzp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s8J2VhDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSVOntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWGOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhiYlwifSzihJk6e2xldHRlcjpcIlBcIixmb250Q21kOlwibWF0aGJiXCJ9LOKEmjp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0s4oSdOntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWKOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWLOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWMOntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWNOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWOOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWPOntsZXR0ZXI6XCJYXCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZWQOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhiYlwifSzihKQ6e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fmFwiOntsZXR0ZXI6XCIwXCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn5lcIjp7bGV0dGVyOlwiMVwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+aXCI6e2xldHRlcjpcIjJcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fm1wiOntsZXR0ZXI6XCIzXCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn5xcIjp7bGV0dGVyOlwiNFwiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+dXCI6e2xldHRlcjpcIjVcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2fnlwiOntsZXR0ZXI6XCI2XCIsZm9udENtZDpcIm1hdGhiYlwifSxcIvCdn59cIjp7bGV0dGVyOlwiN1wiLGZvbnRDbWQ6XCJtYXRoYmJcIn0sXCLwnZ+gXCI6e2xldHRlcjpcIjhcIixmb250Q21kOlwibWF0aGJiXCJ9LFwi8J2foVwiOntsZXR0ZXI6XCI5XCIsZm9udENtZDpcIm1hdGhiYlwifSzwnZKcOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2TkDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKErDp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkp46e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKfOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Tkzp7bGV0dGVyOlwiRFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEsDp7bGV0dGVyOlwiRVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LOKEsTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdk5U6e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKiOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSLOntsZXR0ZXI6XCJIXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSQOntsZXR0ZXI6XCJJXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SpTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqY6e2xldHRlcjpcIktcIixmb250Q21kOlwibWF0aGNhbFwifSzihJI6e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZObOntsZXR0ZXI6XCJMXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s4oSzOntsZXR0ZXI6XCJNXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SqTp7bGV0dGVyOlwiTlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqo6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGNhbFwifSzwnZOeOntsZXR0ZXI6XCJPXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Sqzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkqw6e2xldHRlcjpcIlFcIixmb250Q21kOlwibWF0aGNhbFwifSzihJs6e2xldHRlcjpcIlJcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZW9OntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGhjYWxcIn0sXCLihJ9cIjp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkq46e2xldHRlcjpcIlNcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKvOntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2SsDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrE6e2xldHRlcjpcIlZcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZKyOntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2Sszp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoY2FsXCJ9LPCdkrQ6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aGNhbFwifSzwnZK1OntsZXR0ZXI6XCJaXCIsZm9udENtZDpcIm1hdGhjYWxcIn0s8J2UhDp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSFOntsZXR0ZXI6XCJCXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKErTp7bGV0dGVyOlwiQ1wiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSHOntsZXR0ZXI6XCJEXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlIg6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UiTp7bGV0dGVyOlwiRlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSKOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEjDp7bGV0dGVyOlwiSFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzihJE6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UjTp7bGV0dGVyOlwiSlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSOOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlI86e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UkDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSROntsZXR0ZXI6XCJOXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJI6e2xldHRlcjpcIk9cIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Ukzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSUOntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEnDp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSWOntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJc6e2xldHRlcjpcIlRcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2UmDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZSZOntsZXR0ZXI6XCJWXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LPCdlJo6e2xldHRlcjpcIldcIixmb250Q21kOlwibWF0aGZyYWtcIn0s8J2Umzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZScOntsZXR0ZXI6XCJZXCIsZm9udENtZDpcIm1hdGhmcmFrXCJ9LOKEqDp7bGV0dGVyOlwiWlwiLGZvbnRDbWQ6XCJtYXRoZnJha1wifSzwnZagOntsZXR0ZXI6XCJBXCIsZm9udENtZDpcIm1hdGhzZlwifSzOkTp7bGV0dGVyOlwiQVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WoTp7bGV0dGVyOlwiQlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0szpI6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqI6e2xldHRlcjpcIkNcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqM6e2xldHRlcjpcIkRcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqQ6e2xldHRlcjpcIkVcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqU6e2xldHRlcjpcIkZcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqY6e2xldHRlcjpcIkdcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqc6e2xldHRlcjpcIkhcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqg6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlqk6e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aHNmXCJ9LMi3OntsZXR0ZXI6XCJKXCIsZm9udENtZDpcIm1hdGhzZlwifSzwnZaqOntsZXR0ZXI6XCJLXCIsZm9udENtZDpcIm1hdGhzZlwifSzOmjp7bGV0dGVyOlwiS1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wqzp7bGV0dGVyOlwiTFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WrDp7bGV0dGVyOlwiTVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WrTp7bGV0dGVyOlwiTlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wrjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wrzp7bGV0dGVyOlwiUFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WsDp7bGV0dGVyOlwiUVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WsTp7bGV0dGVyOlwiUlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wsjp7bGV0dGVyOlwiU1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wszp7bGV0dGVyOlwiVFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WtDp7bGV0dGVyOlwiVVwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2WtTp7bGV0dGVyOlwiVlwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wtjp7bGV0dGVyOlwiV1wiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0s8J2Wtzp7bGV0dGVyOlwiWFwiLGZvbnRDbWQ6XCJtYXRoc2ZcIn0szqc6e2xldHRlcjpcIlhcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlrg6e2xldHRlcjpcIllcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdlrk6e2xldHRlcjpcIlpcIixmb250Q21kOlwibWF0aHNmXCJ9LPCdmqg6e2xldHRlcjpcIkFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmqk6e2xldHRlcjpcIkJcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmqo6e2xldHRlcjpcIlxcXFxHYW1tYVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2aqzp7bGV0dGVyOlwiXFxcXERlbHRhXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqsOntsZXR0ZXI6XCJFXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqtOntsZXR0ZXI6XCJGXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZquOntsZXR0ZXI6XCJHXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZqvOntsZXR0ZXI6XCJcXFxcVGhldGFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrA6e2xldHRlcjpcIklcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrE6e2xldHRlcjpcIkpcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrI6e2xldHRlcjpcIlxcXFxMYW1iZGFcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrM6e2xldHRlcjpcIkxcIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrQ6e2xldHRlcjpcIk1cIixmb250Q21kOlwibWF0aHR0XCJ9LPCdmrU6e2xldHRlcjpcIlxcXFxQaVwiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atjp7bGV0dGVyOlwiT1wiLGZvbnRDbWQ6XCJtYXRodHRcIn0s8J2atzp7bGV0dGVyOlwiXFxcXFBpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq4OntsZXR0ZXI6XCJRXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq5OntsZXR0ZXI6XCJSXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq6OntsZXR0ZXI6XCJTXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq7OntsZXR0ZXI6XCJUXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq8OntsZXR0ZXI6XCJVXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq9OntsZXR0ZXI6XCJcXFxcUGhpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq+OntsZXR0ZXI6XCJXXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZq/OntsZXR0ZXI6XCJcXFxcUHNpXCIsZm9udENtZDpcIm1hdGh0dFwifSzwnZuAOntsZXR0ZXI6XCJcXFxcT21lZ2FcIixmb250Q21kOlwibWF0aHR0XCJ9fX19LHQ9e307ZnVuY3Rpb24gcihhKXt2YXIgbj10W2FdO2lmKHZvaWQgMCE9PW4pcmV0dXJuIG4uZXhwb3J0czt2YXIgbz10W2FdPXtleHBvcnRzOnt9fTtyZXR1cm4gZVthXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyxyKSxvLmV4cG9ydHN9dmFyIGE9e307cmV0dXJuKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9YTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLk1hdGhNTFRvTGFUZVg9dm9pZCAwO3ZhciB0PXIoODY3Mik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJNYXRoTUxUb0xhVGVYXCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQuTWF0aE1MVG9MYVRlWH19KX0pKCksYX0pKCkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1bmRsZS5taW4uanMubWFwIiwiaW1wb3J0IHsgRGVmdWRkbGVNZXRhZGF0YSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgY2xhc3MgTWV0YWRhdGFFeHRyYWN0b3Ige1xuXHRzdGF0aWMgZXh0cmFjdChkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBEZWZ1ZGRsZU1ldGFkYXRhIHtcblx0XHRsZXQgZG9tYWluID0gJyc7XG5cdFx0bGV0IHVybCA9ICcnO1xuXG5cdFx0dHJ5IHtcblx0XHRcdC8vIFRyeSB0byBnZXQgVVJMIGZyb20gZG9jdW1lbnQgbG9jYXRpb25cblx0XHRcdHVybCA9IGRvYy5sb2NhdGlvbj8uaHJlZiB8fCAnJztcblx0XHRcdFxuXHRcdFx0Ly8gSWYgbm8gVVJMIGZyb20gbG9jYXRpb24sIHRyeSBvdGhlciBzb3VyY2VzXG5cdFx0XHRpZiAoIXVybCkge1xuXHRcdFx0XHR1cmwgPSB0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOnVybFwiKSB8fFxuXHRcdFx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwidHdpdHRlcjp1cmxcIikgfHxcblx0XHRcdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ3VybCcpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdtYWluRW50aXR5T2ZQYWdlLnVybCcpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdtYWluRW50aXR5LnVybCcpIHx8XG5cdFx0XHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdXZWJTaXRlLnVybCcpIHx8XG5cdFx0XHRcdFx0ZG9jLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbcmVsPVwiY2Fub25pY2FsXCJdJyk/LmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodXJsKSB7XG5cdFx0XHRcdGRvbWFpbiA9IG5ldyBVUkwodXJsKS5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdC8vIElmIFVSTCBwYXJzaW5nIGZhaWxzLCB0cnkgdG8gZ2V0IGZyb20gYmFzZSB0YWdcblx0XHRcdGNvbnN0IGJhc2VUYWcgPSBkb2MucXVlcnlTZWxlY3RvcignYmFzZVtocmVmXScpO1xuXHRcdFx0aWYgKGJhc2VUYWcpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR1cmwgPSBiYXNlVGFnLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnO1xuXHRcdFx0XHRcdGRvbWFpbiA9IG5ldyBVUkwodXJsKS5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgJycpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdGYWlsZWQgdG8gcGFyc2UgYmFzZSBVUkw6JywgZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGl0bGU6IHRoaXMuZ2V0VGl0bGUoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdGRlc2NyaXB0aW9uOiB0aGlzLmdldERlc2NyaXB0aW9uKGRvYywgc2NoZW1hT3JnRGF0YSksXG5cdFx0XHRkb21haW4sXG5cdFx0XHRmYXZpY29uOiB0aGlzLmdldEZhdmljb24oZG9jLCB1cmwpLFxuXHRcdFx0aW1hZ2U6IHRoaXMuZ2V0SW1hZ2UoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdHB1Ymxpc2hlZDogdGhpcy5nZXRQdWJsaXNoZWQoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdGF1dGhvcjogdGhpcy5nZXRBdXRob3IoZG9jLCBzY2hlbWFPcmdEYXRhKSxcblx0XHRcdHNpdGU6IHRoaXMuZ2V0U2l0ZShkb2MsIHNjaGVtYU9yZ0RhdGEpLFxuXHRcdFx0c2NoZW1hT3JnRGF0YSxcblx0XHRcdHdvcmRDb3VudDogMCxcblx0XHRcdHBhcnNlVGltZTogMFxuXHRcdH07XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRBdXRob3IoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmF1dGhvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdhdXRob3IubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcImF1dGhvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImJ5bFwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImF1dGhvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImF1dGhvckxpc3RcIikgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJjb3B5cmlnaHRcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnY29weXJpZ2h0SG9sZGVyLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJvZzpzaXRlX25hbWVcIikgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAncHVibGlzaGVyLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdzb3VyY2VPcmdhbml6YXRpb24ubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2lzUGFydE9mLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInR3aXR0ZXI6Y3JlYXRvclwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcImFwcGxpY2F0aW9uLW5hbWVcIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldFNpdGUoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdwdWJsaXNoZXIubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOnNpdGVfbmFtZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdXZWJTaXRlLm5hbWUnKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdzb3VyY2VPcmdhbml6YXRpb24ubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiY29weXJpZ2h0XCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2NvcHlyaWdodEhvbGRlci5uYW1lJykgfHxcblx0XHRcdHRoaXMuZ2V0U2NoZW1hUHJvcGVydHkoZG9jLCBzY2hlbWFPcmdEYXRhLCAnaXNQYXJ0T2YubmFtZScpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwiYXBwbGljYXRpb24tbmFtZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRBdXRob3IoZG9jLCBzY2hlbWFPcmdEYXRhKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0VGl0bGUoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRjb25zdCByYXdUaXRsZSA9IChcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcInByb3BlcnR5XCIsIFwib2c6dGl0bGVcIikgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0d2l0dGVyOnRpdGxlXCIpIHx8XG5cdFx0XHR0aGlzLmdldFNjaGVtYVByb3BlcnR5KGRvYywgc2NoZW1hT3JnRGF0YSwgJ2hlYWRsaW5lJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJ0aXRsZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LnRpdGxlXCIpIHx8XG5cdFx0XHRkb2MucXVlcnlTZWxlY3RvcigndGl0bGUnKT8udGV4dENvbnRlbnQ/LnRyaW0oKSB8fFxuXHRcdFx0Jydcblx0XHQpO1xuXG5cdFx0cmV0dXJuIHRoaXMuY2xlYW5UaXRsZShyYXdUaXRsZSwgdGhpcy5nZXRTaXRlKGRvYywgc2NoZW1hT3JnRGF0YSkpO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgY2xlYW5UaXRsZSh0aXRsZTogc3RyaW5nLCBzaXRlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRpZiAoIXRpdGxlIHx8ICFzaXRlTmFtZSkgcmV0dXJuIHRpdGxlO1xuXG5cdFx0Ly8gUmVtb3ZlIHNpdGUgbmFtZSBpZiBpdCBleGlzdHNcblx0XHRjb25zdCBzaXRlTmFtZUVzY2FwZWQgPSBzaXRlTmFtZS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xuXHRcdGNvbnN0IHBhdHRlcm5zID0gW1xuXHRcdFx0YFxcXFxzKltcXFxcfFxcXFwt4oCT4oCUXVxcXFxzKiR7c2l0ZU5hbWVFc2NhcGVkfVxcXFxzKiRgLCAvLyBUaXRsZSB8IFNpdGUgTmFtZVxuXHRcdFx0YF5cXFxccyoke3NpdGVOYW1lRXNjYXBlZH1cXFxccypbXFxcXHxcXFxcLeKAk+KAlF1cXFxccypgLCAvLyBTaXRlIE5hbWUgfCBUaXRsZVxuXHRcdF07XG5cdFx0XG5cdFx0Zm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG5cdFx0XHRjb25zdCByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybiwgJ2knKTtcblx0XHRcdGlmIChyZWdleC50ZXN0KHRpdGxlKSkge1xuXHRcdFx0XHR0aXRsZSA9IHRpdGxlLnJlcGxhY2UocmVnZXgsICcnKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRpdGxlLnRyaW0oKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldERlc2NyaXB0aW9uKGRvYzogRG9jdW1lbnQsIHNjaGVtYU9yZ0RhdGE6IGFueSk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJvZzpkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdkZXNjcmlwdGlvbicpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwidHdpdHRlcjpkZXNjcmlwdGlvblwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmRlc2NyaXB0aW9uXCIpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRJbWFnZShkb2M6IERvY3VtZW50LCBzY2hlbWFPcmdEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOmltYWdlXCIpIHx8XG5cdFx0XHR0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJuYW1lXCIsIFwidHdpdHRlcjppbWFnZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdpbWFnZS51cmwnKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwibmFtZVwiLCBcInNhaWx0aHJ1LmltYWdlLmZ1bGxcIikgfHxcblx0XHRcdCcnXG5cdFx0KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldEZhdmljb24oZG9jOiBEb2N1bWVudCwgYmFzZVVybDogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRjb25zdCBpY29uRnJvbU1ldGEgPSB0aGlzLmdldE1ldGFDb250ZW50KGRvYywgXCJwcm9wZXJ0eVwiLCBcIm9nOmltYWdlOmZhdmljb25cIik7XG5cdFx0aWYgKGljb25Gcm9tTWV0YSkgcmV0dXJuIGljb25Gcm9tTWV0YTtcblxuXHRcdGNvbnN0IGljb25MaW5rID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCJsaW5rW3JlbD0naWNvbiddXCIpPy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuXHRcdGlmIChpY29uTGluaykgcmV0dXJuIGljb25MaW5rO1xuXG5cdFx0Y29uc3Qgc2hvcnRjdXRMaW5rID0gZG9jLnF1ZXJ5U2VsZWN0b3IoXCJsaW5rW3JlbD0nc2hvcnRjdXQgaWNvbiddXCIpPy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuXHRcdGlmIChzaG9ydGN1dExpbmspIHJldHVybiBzaG9ydGN1dExpbms7XG5cblx0XHQvLyBPbmx5IHRyeSB0byBjb25zdHJ1Y3QgZmF2aWNvbiBVUkwgaWYgd2UgaGF2ZSBhIHZhbGlkIGJhc2UgVVJMXG5cdFx0aWYgKGJhc2VVcmwpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVVJMKFwiL2Zhdmljb24uaWNvXCIsIGJhc2VVcmwpLmhyZWY7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNvbnN0cnVjdCBmYXZpY29uIFVSTDonLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gJyc7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRQdWJsaXNoZWQoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55KTogc3RyaW5nIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5nZXRTY2hlbWFQcm9wZXJ0eShkb2MsIHNjaGVtYU9yZ0RhdGEsICdkYXRlUHVibGlzaGVkJykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJwdWJsaXNoRGF0ZVwiKSB8fFxuXHRcdFx0dGhpcy5nZXRNZXRhQ29udGVudChkb2MsIFwicHJvcGVydHlcIiwgXCJhcnRpY2xlOnB1Ymxpc2hlZF90aW1lXCIpIHx8XG5cdFx0XHR0aGlzLmdldFRpbWVFbGVtZW50KGRvYykgfHxcblx0XHRcdHRoaXMuZ2V0TWV0YUNvbnRlbnQoZG9jLCBcIm5hbWVcIiwgXCJzYWlsdGhydS5kYXRlXCIpIHx8XG5cdFx0XHQnJ1xuXHRcdCk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBnZXRNZXRhQ29udGVudChkb2M6IERvY3VtZW50LCBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHNlbGVjdG9yID0gYG1ldGFbJHthdHRyfV1gO1xuXHRcdGNvbnN0IGVsZW1lbnQgPSBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcblx0XHRcdC5maW5kKGVsID0+IGVsLmdldEF0dHJpYnV0ZShhdHRyKT8udG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUudG9Mb3dlckNhc2UoKSk7XG5cdFx0Y29uc3QgY29udGVudCA9IGVsZW1lbnQgPyBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIik/LnRyaW0oKSA/PyBcIlwiIDogXCJcIjtcblx0XHRyZXR1cm4gdGhpcy5kZWNvZGVIVE1MRW50aXRpZXMoY29udGVudCwgZG9jKTtcblx0fVxuXG5cdHByaXZhdGUgc3RhdGljIGdldFRpbWVFbGVtZW50KGRvYzogRG9jdW1lbnQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHNlbGVjdG9yID0gYHRpbWVgO1xuXHRcdGNvbnN0IGVsZW1lbnQgPSBBcnJheS5mcm9tKGRvYy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlbMF07XG5cdFx0Y29uc3QgY29udGVudCA9IGVsZW1lbnQgPyAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRldGltZVwiKT8udHJpbSgpID8/IGVsZW1lbnQudGV4dENvbnRlbnQ/LnRyaW0oKSA/PyBcIlwiKSA6IFwiXCI7XG5cdFx0cmV0dXJuIHRoaXMuZGVjb2RlSFRNTEVudGl0aWVzKGNvbnRlbnQsIGRvYyk7XG5cdH1cblxuXHRwcml2YXRlIHN0YXRpYyBkZWNvZGVIVE1MRW50aXRpZXModGV4dDogc3RyaW5nLCBkb2M6IERvY3VtZW50KTogc3RyaW5nIHtcblx0XHRjb25zdCB0ZXh0YXJlYSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuXHRcdHRleHRhcmVhLmlubmVySFRNTCA9IHRleHQ7XG5cdFx0cmV0dXJuIHRleHRhcmVhLnZhbHVlO1xuXHR9XG5cblx0cHJpdmF0ZSBzdGF0aWMgZ2V0U2NoZW1hUHJvcGVydHkoZG9jOiBEb2N1bWVudCwgc2NoZW1hT3JnRGF0YTogYW55LCBwcm9wZXJ0eTogc3RyaW5nLCBkZWZhdWx0VmFsdWU6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcblx0XHRpZiAoIXNjaGVtYU9yZ0RhdGEpIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cblx0XHRjb25zdCBzZWFyY2hTY2hlbWEgPSAoZGF0YTogYW55LCBwcm9wczogc3RyaW5nW10sIGZ1bGxQYXRoOiBzdHJpbmcsIGlzRXhhY3RNYXRjaDogYm9vbGVhbiA9IHRydWUpOiBzdHJpbmdbXSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHJldHVybiBwcm9wcy5sZW5ndGggPT09IDAgPyBbZGF0YV0gOiBbXTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0aWYgKCFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRQcm9wID0gcHJvcHNbMF07XG5cdFx0XHRcdGlmICgvXlxcW1xcZCtcXF0kLy50ZXN0KGN1cnJlbnRQcm9wKSkge1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY3VycmVudFByb3Auc2xpY2UoMSwgLTEpKTtcblx0XHRcdFx0XHRpZiAoZGF0YVtpbmRleF0pIHtcblx0XHRcdFx0XHRcdHJldHVybiBzZWFyY2hTY2hlbWEoZGF0YVtpbmRleF0sIHByb3BzLnNsaWNlKDEpLCBmdWxsUGF0aCwgaXNFeGFjdE1hdGNoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAocHJvcHMubGVuZ3RoID09PSAwICYmIGRhdGEuZXZlcnkoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInKSkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhLm1hcChTdHJpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRyZXR1cm4gZGF0YS5mbGF0TWFwKGl0ZW0gPT4gc2VhcmNoU2NoZW1hKGl0ZW0sIHByb3BzLCBmdWxsUGF0aCwgaXNFeGFjdE1hdGNoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IFtjdXJyZW50UHJvcCwgLi4ucmVtYWluaW5nUHJvcHNdID0gcHJvcHM7XG5cdFx0XHRcblx0XHRcdGlmICghY3VycmVudFByb3ApIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgcmV0dXJuIFtkYXRhXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhLm5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gW2RhdGEubmFtZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShjdXJyZW50UHJvcCkpIHtcblx0XHRcdFx0cmV0dXJuIHNlYXJjaFNjaGVtYShkYXRhW2N1cnJlbnRQcm9wXSwgcmVtYWluaW5nUHJvcHMsIFxuXHRcdFx0XHRcdGZ1bGxQYXRoID8gYCR7ZnVsbFBhdGh9LiR7Y3VycmVudFByb3B9YCA6IGN1cnJlbnRQcm9wLCB0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc0V4YWN0TWF0Y2gpIHtcblx0XHRcdFx0Y29uc3QgbmVzdGVkUmVzdWx0czogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgZGF0YVtrZXldID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IHNlYXJjaFNjaGVtYShkYXRhW2tleV0sIHByb3BzLCBcblx0XHRcdFx0XHRcdFx0ZnVsbFBhdGggPyBgJHtmdWxsUGF0aH0uJHtrZXl9YCA6IGtleSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0bmVzdGVkUmVzdWx0cy5wdXNoKC4uLnJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmVzdGVkUmVzdWx0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5lc3RlZFJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH07XG5cblx0XHR0cnkge1xuXHRcdFx0bGV0IHJlc3VsdHMgPSBzZWFyY2hTY2hlbWEoc2NoZW1hT3JnRGF0YSwgcHJvcGVydHkuc3BsaXQoJy4nKSwgJycsIHRydWUpO1xuXHRcdFx0aWYgKHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJlc3VsdHMgPSBzZWFyY2hTY2hlbWEoc2NoZW1hT3JnRGF0YSwgcHJvcGVydHkuc3BsaXQoJy4nKSwgJycsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID4gMCA/IHJlc3VsdHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykgOiBkZWZhdWx0VmFsdWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5kZWNvZGVIVE1MRW50aXRpZXMocmVzdWx0LCBkb2MpO1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBFcnJvciBpbiBnZXRTY2hlbWFQcm9wZXJ0eSBmb3IgJHtwcm9wZXJ0eX06YCwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH1cblxuXHRzdGF0aWMgZXh0cmFjdFNjaGVtYU9yZ0RhdGEoZG9jOiBEb2N1bWVudCk6IGFueSB7XG5cdFx0Y29uc3Qgc2NoZW1hU2NyaXB0cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHRbdHlwZT1cImFwcGxpY2F0aW9uL2xkK2pzb25cIl0nKTtcblx0XHRjb25zdCBzY2hlbWFEYXRhOiBhbnlbXSA9IFtdO1xuXG5cdFx0c2NoZW1hU2NyaXB0cy5mb3JFYWNoKHNjcmlwdCA9PiB7XG5cdFx0XHRsZXQganNvbkNvbnRlbnQgPSBzY3JpcHQudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGpzb25Db250ZW50ID0ganNvbkNvbnRlbnRcblx0XHRcdFx0XHQucmVwbGFjZSgvXFwvXFwqW1xcc1xcU10qP1xcKlxcL3xeXFxzKlxcL1xcLy4qJC9nbSwgJycpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMqPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KVxcXVxcXT5cXHMqJC8sICckMScpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMqKFxcKlxcL3xcXC9cXCopXFxzKnxcXHMqKFxcKlxcL3xcXC9cXCopXFxzKiQvZywgJycpXG5cdFx0XHRcdFx0LnRyaW0oKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0Y29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGpzb25Db250ZW50KTtcblxuXHRcdFx0XHRpZiAoanNvbkRhdGFbJ0BncmFwaCddICYmIEFycmF5LmlzQXJyYXkoanNvbkRhdGFbJ0BncmFwaCddKSkge1xuXHRcdFx0XHRcdHNjaGVtYURhdGEucHVzaCguLi5qc29uRGF0YVsnQGdyYXBoJ10pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNjaGVtYURhdGEucHVzaChqc29uRGF0YSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgc2NoZW1hLm9yZyBkYXRhOicsIGVycm9yKTtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignUHJvYmxlbWF0aWMgSlNPTiBjb250ZW50OicsIGpzb25Db250ZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBzY2hlbWFEYXRhO1xuXHR9XG59IiwiaW1wb3J0IHsgTWV0YWRhdGFFeHRyYWN0b3IgfSBmcm9tICcuL21ldGFkYXRhJztcbmltcG9ydCB7IERlZnVkZGxlT3B0aW9ucywgRGVmdWRkbGVSZXNwb25zZSwgRGVmdWRkbGVNZXRhZGF0YSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgXG5cdEhJRERFTl9FTEVNRU5UX1NFTEVDVE9SUyxcblx0TU9CSUxFX1dJRFRILFxuXHRCTE9DS19FTEVNRU5UUyxcblx0UFJFU0VSVkVfRUxFTUVOVFMsXG5cdElOTElORV9FTEVNRU5UUyxcblx0U1VQUE9SVEVEX0xBTkdVQUdFUyxcblx0QUxMT1dFRF9BVFRSSUJVVEVTLFxuXHRBTExPV0VEX0FUVFJJQlVURVNfREVCVUcsXG5cdEVYQUNUX1NFTEVDVE9SUyxcblx0UEFSVElBTF9TRUxFQ1RPUlMsXG5cdEZPT1ROT1RFX0xJU1RfU0VMRUNUT1JTLFxuXHRGT09UTk9URV9JTkxJTkVfUkVGRVJFTkNFUyxcblx0RU5UUllfUE9JTlRfRUxFTUVOVFMsXG5cdEFMTE9XRURfRU1QVFlfRUxFTUVOVFNcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgbWF0aFN0YW5kYXJkaXphdGlvblJ1bGVzIH0gZnJvbSAnLi9tYXRoJztcblxuLy8gRWxlbWVudCBzdGFuZGFyZGl6YXRpb24gcnVsZXNcbi8vIE1hcHMgc2VsZWN0b3JzIHRvIHRoZWlyIHRhcmdldCBIVE1MIGVsZW1lbnQgbmFtZVxuaW50ZXJmYWNlIFN0YW5kYXJkaXphdGlvblJ1bGUge1xuXHRzZWxlY3Rvcjogc3RyaW5nO1xuXHRlbGVtZW50OiBzdHJpbmc7XG5cdHRyYW5zZm9ybT86IChlbDogRWxlbWVudCkgPT4gRWxlbWVudDtcbn1cblxuY29uc3QgRUxFTUVOVF9TVEFOREFSRElaQVRJT05fUlVMRVM6IFN0YW5kYXJkaXphdGlvblJ1bGVbXSA9IFtcblx0Ly8gTWF0aCBlbGVtZW50c1xuXHQuLi5tYXRoU3RhbmRhcmRpemF0aW9uUnVsZXMsXG5cdC8vIENvZGUgYmxvY2tzXG5cdHtcblx0XHRzZWxlY3RvcjogJ3ByZScsXG5cdFx0ZWxlbWVudDogJ3ByZScsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gZWw7XG5cblx0XHRcdC8vIEZ1bmN0aW9uIHRvIGdldCBsYW5ndWFnZSBmcm9tIGNsYXNzXG5cdFx0XHRjb25zdCBnZXRMYW5ndWFnZUZyb21DbGFzcyA9IChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHN0cmluZyA9PiB7XG5cdFx0XHRcdC8vIENoZWNrIGRhdGEtbGFuZyBhdHRyaWJ1dGUgZmlyc3Rcblx0XHRcdFx0Y29uc3QgZGF0YUxhbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1sYW5nJyk7XG5cdFx0XHRcdGlmIChkYXRhTGFuZykge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRGVmaW5lIGxhbmd1YWdlIHBhdHRlcm5zXG5cdFx0XHRcdGNvbnN0IGxhbmd1YWdlUGF0dGVybnMgPSBbXG5cdFx0XHRcdFx0L15sYW5ndWFnZS0oXFx3KykkLywgICAgICAgICAgLy8gbGFuZ3VhZ2UtamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9ebGFuZy0oXFx3KykkLywgICAgICAgICAgICAgIC8vIGxhbmctamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9eKFxcdyspLWNvZGUkLywgICAgICAgICAgICAgIC8vIGphdmFzY3JpcHQtY29kZVxuXHRcdFx0XHRcdC9eY29kZS0oXFx3KykkLywgICAgICAgICAgICAgIC8vIGNvZGUtamF2YXNjcmlwdFxuXHRcdFx0XHRcdC9ec3ludGF4LShcXHcrKSQvLCAgICAgICAgICAgIC8vIHN5bnRheC1qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15jb2RlLXNuaXBwZXRfXyhcXHcrKSQvLCAgICAgLy8gY29kZS1zbmlwcGV0X19qYXZhc2NyaXB0XG5cdFx0XHRcdFx0L15oaWdobGlnaHQtKFxcdyspJC8sICAgICAgICAgLy8gaGlnaGxpZ2h0LWphdmFzY3JpcHRcblx0XHRcdFx0XHQvXihcXHcrKS1zbmlwcGV0JC8gICAgICAgICAgICAvLyBqYXZhc2NyaXB0LXNuaXBwZXRcblx0XHRcdFx0XTtcblxuXHRcdFx0XHQvLyBUaGVuIGNoZWNrIHRoZSBjbGFzcyBhdHRyaWJ1dGUgZm9yIHBhdHRlcm5zXG5cdFx0XHRcdGlmIChlbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBwYXR0ZXJuIG9mIGxhbmd1YWdlUGF0dGVybnMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gZWxlbWVudC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKS5tYXRjaChwYXR0ZXJuKTtcblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gVGhlbiBjaGVjayBmb3Igc3VwcG9ydGVkIGxhbmd1YWdlXG5cdFx0XHRcdFx0aWYgKFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKGVsZW1lbnQuY2xhc3NOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBjbGFzc05hbWVzID0gQXJyYXkuZnJvbShlbGVtZW50LmNsYXNzTGlzdCk7XG5cdFx0XHRcdFxuXHRcdFx0XHRmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG5cdFx0XHRcdFx0Ly8gQ2hlY2sgcGF0dGVybnMgZmlyc3Rcblx0XHRcdFx0XHRmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ3VhZ2VQYXR0ZXJucykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBjbGFzc05hbWUubWF0Y2gocGF0dGVybik7XG5cdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT25seSBjaGVjayBiYXJlIGxhbmd1YWdlIG5hbWVzIGlmIG5vIHBhdHRlcm5zIHdlcmUgZm91bmRcblx0XHRcdFx0Zm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuXHRcdFx0XHRcdGlmIChTVVBQT1JURURfTEFOR1VBR0VTLmhhcyhjbGFzc05hbWUudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBjbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBUcnkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBmcm9tIHRoZSBlbGVtZW50IGFuZCBpdHMgYW5jZXN0b3JzXG5cdFx0XHRsZXQgbGFuZ3VhZ2UgPSAnJztcblx0XHRcdGxldCBjdXJyZW50RWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gZWw7XG5cdFx0XHRcblx0XHRcdHdoaWxlIChjdXJyZW50RWxlbWVudCAmJiAhbGFuZ3VhZ2UpIHtcblx0XHRcdFx0bGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZUZyb21DbGFzcyhjdXJyZW50RWxlbWVudCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBbHNvIGNoZWNrIGZvciBjb2RlIGVsZW1lbnRzIHdpdGhpbiB0aGUgY3VycmVudCBlbGVtZW50XG5cdFx0XHRcdGlmICghbGFuZ3VhZ2UgJiYgY3VycmVudEVsZW1lbnQucXVlcnlTZWxlY3RvcignY29kZScpKSB7XG5cdFx0XHRcdFx0bGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZUZyb21DbGFzcyhjdXJyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjb2RlJykhKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGdW5jdGlvbiB0byByZWN1cnNpdmVseSBleHRyYWN0IHRleHQgY29udGVudCB3aGlsZSBwcmVzZXJ2aW5nIHN0cnVjdHVyZVxuXHRcdFx0Y29uc3QgZXh0cmFjdFN0cnVjdHVyZWRUZXh0ID0gKGVsZW1lbnQ6IE5vZGUpOiBzdHJpbmcgPT4ge1xuXHRcdFx0XHRpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0bGV0IHRleHQgPSAnJztcblx0XHRcdFx0aWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuXHRcdFx0XHRcdC8vIEhhbmRsZSBsaW5lIGJyZWFrc1xuXHRcdFx0XHRcdGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdCUicpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnXFxuJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSGFuZGxlIGNvZGUgZWxlbWVudHMgYW5kIHRoZWlyIGNoaWxkcmVuXG5cdFx0XHRcdFx0ZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRcdFx0dGV4dCArPSBleHRyYWN0U3RydWN0dXJlZFRleHQoY2hpbGQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdC8vIEFkZCBuZXdsaW5lIGFmdGVyIGVhY2ggY29kZSBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0NPREUnKSB7XG5cdFx0XHRcdFx0XHR0ZXh0ICs9ICdcXG4nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGV4dDtcblx0XHRcdH07XG5cblx0XHRcdC8vIEV4dHJhY3QgYWxsIHRleHQgY29udGVudFxuXHRcdFx0bGV0IGNvZGVDb250ZW50ID0gZXh0cmFjdFN0cnVjdHVyZWRUZXh0KGVsKTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgdGhlIGNvbnRlbnRcblx0XHRcdGNvZGVDb250ZW50ID0gY29kZUNvbnRlbnRcblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSBleHRyYSBuZXdsaW5lcyBhdCB0aGUgc3RhcnRcblx0XHRcdFx0LnJlcGxhY2UoL15cXG4rLywgJycpXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgZXh0cmEgbmV3bGluZXMgYXQgdGhlIGVuZFxuXHRcdFx0XHQucmVwbGFjZSgvXFxuKyQvLCAnJylcblx0XHRcdFx0Ly8gUmVwbGFjZSBtdWx0aXBsZSBjb25zZWN1dGl2ZSBuZXdsaW5lcyB3aXRoIGEgc2luZ2xlIG5ld2xpbmVcblx0XHRcdFx0LnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpO1xuXG5cdFx0XHQvLyBDcmVhdGUgbmV3IHByZSBlbGVtZW50XG5cdFx0XHRjb25zdCBuZXdQcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcblx0XHRcdFxuXHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXNcblx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdG5ld1ByZS5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIENyZWF0ZSBjb2RlIGVsZW1lbnRcblx0XHRcdGNvbnN0IGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cdFx0XHRpZiAobGFuZ3VhZ2UpIHtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZycsIGxhbmd1YWdlKTtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYGxhbmd1YWdlLSR7bGFuZ3VhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0XHRjb2RlLnRleHRDb250ZW50ID0gY29kZUNvbnRlbnQ7XG5cdFx0XHRcblx0XHRcdG5ld1ByZS5hcHBlbmRDaGlsZChjb2RlKTtcblx0XHRcdHJldHVybiBuZXdQcmU7XG5cdFx0fVxuXHR9LFxuXHQvLyBTaW1wbGlmeSBoZWFkaW5ncyBieSByZW1vdmluZyBpbnRlcm5hbCBuYXZpZ2F0aW9uIGVsZW1lbnRzXG5cdHtcblx0XHRzZWxlY3RvcjogJ2gxLCBoMiwgaDMsIGg0LCBoNSwgaDYnLFxuXHRcdGVsZW1lbnQ6ICdrZWVwJyxcblx0XHR0cmFuc2Zvcm06IChlbDogRWxlbWVudCk6IEVsZW1lbnQgPT4ge1xuXHRcdFx0Ly8gSWYgaGVhZGluZyBvbmx5IGNvbnRhaW5zIGEgc2luZ2xlIGFuY2hvciB3aXRoIGludGVybmFsIGxpbmtcblx0XHRcdGlmIChlbC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgXG5cdFx0XHRcdGVsLmZpcnN0RWxlbWVudENoaWxkPy50YWdOYW1lID09PSAnQScgJiZcblx0XHRcdFx0KGVsLmZpcnN0RWxlbWVudENoaWxkLmdldEF0dHJpYnV0ZSgnaHJlZicpPy5pbmNsdWRlcygnIycpIHx8IFxuXHRcdFx0XHQgZWwuZmlyc3RFbGVtZW50Q2hpbGQuZ2V0QXR0cmlidXRlKCdocmVmJyk/LnN0YXJ0c1dpdGgoJyMnKSkpIHtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENyZWF0ZSBuZXcgaGVhZGluZyBvZiBzYW1lIGxldmVsXG5cdFx0XHRcdGNvbnN0IG5ld0hlYWRpbmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsLnRhZ05hbWUpO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXMgZnJvbSBvcmlnaW5hbCBoZWFkaW5nXG5cdFx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0XHRpZiAoQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdFx0XHRuZXdIZWFkaW5nLnNldEF0dHJpYnV0ZShhdHRyLm5hbWUsIGF0dHIudmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBKdXN0IHVzZSB0aGUgdGV4dCBjb250ZW50XG5cdFx0XHRcdG5ld0hlYWRpbmcudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRcblx0XHRcdFx0cmV0dXJuIG5ld0hlYWRpbmc7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIElmIGhlYWRpbmcgY29udGFpbnMgbmF2aWdhdGlvbiBidXR0b25zIG9yIG90aGVyIHV0aWxpdHkgZWxlbWVudHNcblx0XHRcdGNvbnN0IGJ1dHRvbnMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCdidXR0b24nKTtcblx0XHRcdGlmIChidXR0b25zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgbmV3SGVhZGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWwudGFnTmFtZSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBDb3B5IGFsbG93ZWQgYXR0cmlidXRlc1xuXHRcdFx0XHRBcnJheS5mcm9tKGVsLmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdFx0bmV3SGVhZGluZy5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Ly8gSnVzdCB1c2UgdGhlIHRleHQgY29udGVudFxuXHRcdFx0XHRuZXdIZWFkaW5nLnRleHRDb250ZW50ID0gZWwudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdFx0XG5cdFx0XHRcdHJldHVybiBuZXdIZWFkaW5nO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fVxuXHR9LFxuXHQvLyBDb252ZXJ0IGRpdnMgd2l0aCBwYXJhZ3JhcGggcm9sZSB0byBhY3R1YWwgcGFyYWdyYXBoc1xuXHR7IFxuXHRcdHNlbGVjdG9yOiAnZGl2W2RhdGEtdGVzdGlkXj1cInBhcmFncmFwaFwiXSwgZGl2W3JvbGU9XCJwYXJhZ3JhcGhcIl0nLCBcblx0XHRlbGVtZW50OiAncCcsXG5cdFx0dHJhbnNmb3JtOiAoZWw6IEVsZW1lbnQpOiBFbGVtZW50ID0+IHtcblx0XHRcdGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcblx0XHRcdC8vIENvcHkgaW5uZXJIVE1MXG5cdFx0XHRwLmlubmVySFRNTCA9IGVsLmlubmVySFRNTDtcblx0XHRcdFxuXHRcdFx0Ly8gQ29weSBhbGxvd2VkIGF0dHJpYnV0ZXNcblx0XHRcdEFycmF5LmZyb20oZWwuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ci5uYW1lKSkge1xuXHRcdFx0XHRcdHAuc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gcDtcblx0XHR9XG5cdH0sXG5cdC8vIENvbnZlcnQgZGl2cyB3aXRoIGxpc3Qgcm9sZXMgdG8gYWN0dWFsIGxpc3RzXG5cdHsgXG5cdFx0c2VsZWN0b3I6ICdkaXZbcm9sZT1cImxpc3RcIl0nLCBcblx0XHRlbGVtZW50OiAndWwnLFxuXHRcdC8vIEN1c3RvbSBoYW5kbGVyIGZvciBsaXN0IHR5cGUgZGV0ZWN0aW9uIGFuZCB0cmFuc2Zvcm1hdGlvblxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHQvLyBGaXJzdCBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhbiBvcmRlcmVkIGxpc3Rcblx0XHRcdGNvbnN0IGZpcnN0SXRlbSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0gLmxhYmVsJyk7XG5cdFx0XHRjb25zdCBsYWJlbCA9IGZpcnN0SXRlbT8udGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdGNvbnN0IGlzT3JkZXJlZCA9IGxhYmVsLm1hdGNoKC9eXFxkK1xcKS8pO1xuXHRcdFx0XG5cdFx0XHQvLyBDcmVhdGUgdGhlIGFwcHJvcHJpYXRlIGxpc3QgdHlwZVxuXHRcdFx0Y29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXNPcmRlcmVkID8gJ29sJyA6ICd1bCcpO1xuXHRcdFx0XG5cdFx0XHQvLyBQcm9jZXNzIGVhY2ggbGlzdCBpdGVtXG5cdFx0XHRjb25zdCBpdGVtcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0nKTtcblx0XHRcdGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGl0ZW0ucXVlcnlTZWxlY3RvcignLmNvbnRlbnQnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChjb250ZW50KSB7XG5cdFx0XHRcdFx0Ly8gQ29udmVydCBhbnkgcGFyYWdyYXBoIGRpdnMgaW5zaWRlIGNvbnRlbnRcblx0XHRcdFx0XHRjb25zdCBwYXJhZ3JhcGhEaXZzID0gY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cInBhcmFncmFwaFwiXScpO1xuXHRcdFx0XHRcdHBhcmFncmFwaERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0XHRcdHAuaW5uZXJIVE1MID0gZGl2LmlubmVySFRNTDtcblx0XHRcdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChwKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBDb252ZXJ0IGFueSBuZXN0ZWQgbGlzdHMgcmVjdXJzaXZlbHlcblx0XHRcdFx0XHRjb25zdCBuZXN0ZWRMaXN0cyA9IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJsaXN0XCJdJyk7XG5cdFx0XHRcdFx0bmVzdGVkTGlzdHMuZm9yRWFjaChuZXN0ZWRMaXN0ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGZpcnN0TmVzdGVkSXRlbSA9IG5lc3RlZExpc3QucXVlcnlTZWxlY3RvcignZGl2W3JvbGU9XCJsaXN0aXRlbVwiXSAubGFiZWwnKTtcblx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZExhYmVsID0gZmlyc3ROZXN0ZWRJdGVtPy50ZXh0Q29udGVudD8udHJpbSgpIHx8ICcnO1xuXHRcdFx0XHRcdFx0Y29uc3QgaXNOZXN0ZWRPcmRlcmVkID0gbmVzdGVkTGFiZWwubWF0Y2goL15cXGQrXFwpLyk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdGNvbnN0IG5ld05lc3RlZExpc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzTmVzdGVkT3JkZXJlZCA/ICdvbCcgOiAndWwnKTtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0Ly8gUHJvY2VzcyBuZXN0ZWQgaXRlbXNcblx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZEl0ZW1zID0gbmVzdGVkTGlzdC5xdWVyeVNlbGVjdG9yQWxsKCdkaXZbcm9sZT1cImxpc3RpdGVtXCJdJyk7XG5cdFx0XHRcdFx0XHRuZXN0ZWRJdGVtcy5mb3JFYWNoKG5lc3RlZEl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuZXN0ZWRMaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IG5lc3RlZENvbnRlbnQgPSBuZXN0ZWRJdGVtLnF1ZXJ5U2VsZWN0b3IoJy5jb250ZW50Jyk7XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRpZiAobmVzdGVkQ29udGVudCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIENvbnZlcnQgcGFyYWdyYXBoIGRpdnMgaW4gbmVzdGVkIGl0ZW1zXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbmVzdGVkUGFyYWdyYXBocyA9IG5lc3RlZENvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJwYXJhZ3JhcGhcIl0nKTtcblx0XHRcdFx0XHRcdFx0XHRuZXN0ZWRQYXJhZ3JhcGhzLmZvckVhY2goZGl2ID0+IHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRwLmlubmVySFRNTCA9IGRpdi5pbm5lckhUTUw7XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgocCk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0bmVzdGVkTGkuaW5uZXJIVE1MID0gbmVzdGVkQ29udGVudC5pbm5lckhUTUw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRcdG5ld05lc3RlZExpc3QuYXBwZW5kQ2hpbGQobmVzdGVkTGkpO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdG5lc3RlZExpc3QucmVwbGFjZVdpdGgobmV3TmVzdGVkTGlzdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0bGkuaW5uZXJIVE1MID0gY29udGVudC5pbm5lckhUTUw7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGxpc3QuYXBwZW5kQ2hpbGQobGkpO1xuXHRcdFx0fSk7XG5cdFx0XHRcblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH1cblx0fSxcblx0eyBcblx0XHRzZWxlY3RvcjogJ2Rpdltyb2xlPVwibGlzdGl0ZW1cIl0nLCBcblx0XHRlbGVtZW50OiAnbGknLFxuXHRcdC8vIEN1c3RvbSBoYW5kbGVyIGZvciBsaXN0IGl0ZW0gY29udGVudFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHRjb25zdCBjb250ZW50ID0gZWwucXVlcnlTZWxlY3RvcignLmNvbnRlbnQnKTtcblx0XHRcdGlmICghY29udGVudCkgcmV0dXJuIGVsO1xuXHRcdFx0XG5cdFx0XHQvLyBDb252ZXJ0IGFueSBwYXJhZ3JhcGggZGl2cyBpbnNpZGUgY29udGVudFxuXHRcdFx0Y29uc3QgcGFyYWdyYXBoRGl2cyA9IGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnZGl2W3JvbGU9XCJwYXJhZ3JhcGhcIl0nKTtcblx0XHRcdHBhcmFncmFwaERpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHRjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRwLmlubmVySFRNTCA9IGRpdi5pbm5lckhUTUw7XG5cdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChwKTtcblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHR9XG5cdH0sXG5cdC8vIENvZGUgYmxvY2tzIHdpdGggc3ludGF4IGhpZ2hsaWdodGluZ1xuXHR7XG5cdFx0c2VsZWN0b3I6ICcud3AtYmxvY2stc3ludGF4aGlnaGxpZ2h0ZXItY29kZSwgLnN5bnRheGhpZ2hsaWdodGVyLCAuaGlnaGxpZ2h0LCAuaGlnaGxpZ2h0LXNvdXJjZSwgLndwLWJsb2NrLWNvZGUsIHByZVtjbGFzcyo9XCJsYW5ndWFnZS1cIl0sIHByZVtjbGFzcyo9XCJicnVzaDpcIl0nLFxuXHRcdGVsZW1lbnQ6ICdwcmUnLFxuXHRcdHRyYW5zZm9ybTogKGVsOiBFbGVtZW50KTogRWxlbWVudCA9PiB7XG5cdFx0XHRpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuIGVsO1xuXG5cdFx0XHQvLyBDcmVhdGUgbmV3IHByZSBlbGVtZW50XG5cdFx0XHRjb25zdCBuZXdQcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwcmUnKTtcblx0XHRcdFxuXHRcdFx0Ly8gVHJ5IHRvIGRldGVjdCBsYW5ndWFnZVxuXHRcdFx0bGV0IGxhbmd1YWdlID0gJyc7XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBXb3JkUHJlc3Mgc3ludGF4IGhpZ2hsaWdodGVyIHNwZWNpZmljIGZvcm1hdFxuXHRcdFx0Y29uc3Qgc3ludGF4RWwgPSBlbC5xdWVyeVNlbGVjdG9yKCcuc3ludGF4aGlnaGxpZ2h0ZXInKTtcblx0XHRcdGlmIChzeW50YXhFbCkge1xuXHRcdFx0XHQvLyBHZXQgbGFuZ3VhZ2UgZnJvbSBzeW50YXhoaWdobGlnaHRlciBjbGFzc1xuXHRcdFx0XHRjb25zdCBjbGFzc2VzID0gQXJyYXkuZnJvbShzeW50YXhFbC5jbGFzc0xpc3QpO1xuXHRcdFx0XHRjb25zdCBsYW5nQ2xhc3MgPSBjbGFzc2VzLmZpbmQoYyA9PiAhWydzeW50YXhoaWdobGlnaHRlcicsICdub2d1dHRlciddLmluY2x1ZGVzKGMpKTtcblx0XHRcdFx0aWYgKGxhbmdDbGFzcyAmJiBTVVBQT1JURURfTEFOR1VBR0VTLmhhcyhsYW5nQ2xhc3MudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRsYW5ndWFnZSA9IGxhbmdDbGFzcy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vIGxhbmd1YWdlIGZvdW5kIHlldCwgY2hlY2sgb3RoZXIgY29tbW9uIHBhdHRlcm5zXG5cdFx0XHRpZiAoIWxhbmd1YWdlKSB7XG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZXMgPSBBcnJheS5mcm9tKGVsLmNsYXNzTGlzdCk7XG5cdFx0XHRcdGNvbnN0IGxhbmd1YWdlUGF0dGVybnMgPSBbXG5cdFx0XHRcdFx0Lyg/Ol58XFxzKSg/Omxhbmd1YWdlfGxhbmd8YnJ1c2h8c3ludGF4KS0oXFx3KykoPzpcXHN8JCkvaSxcblx0XHRcdFx0XHQvKD86XnxcXHMpKFxcdyspKD86XFxzfCQpL2lcblx0XHRcdFx0XTtcblxuXHRcdFx0XHRmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBwYXR0ZXJuIG9mIGxhbmd1YWdlUGF0dGVybnMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gY2xhc3NOYW1lLm1hdGNoKHBhdHRlcm4pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoICYmIG1hdGNoWzFdICYmIFNVUFBPUlRFRF9MQU5HVUFHRVMuaGFzKG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkpKSB7XG5cdFx0XHRcdFx0XHRcdGxhbmd1YWdlID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChsYW5ndWFnZSkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRXh0cmFjdCBjb2RlIGNvbnRlbnQsIGhhbmRsaW5nIHZhcmlvdXMgZm9ybWF0c1xuXHRcdFx0bGV0IGNvZGVDb250ZW50ID0gJyc7XG5cblx0XHRcdC8vIEhhbmRsZSBXb3JkUHJlc3Mgc3ludGF4IGhpZ2hsaWdodGVyIHRhYmxlIGZvcm1hdFxuXHRcdFx0Y29uc3QgY29kZUNvbnRhaW5lciA9IGVsLnF1ZXJ5U2VsZWN0b3IoJy5zeW50YXhoaWdobGlnaHRlciB0YWJsZSAuY29kZSAuY29udGFpbmVyJyk7XG5cdFx0XHRpZiAoY29kZUNvbnRhaW5lcikge1xuXHRcdFx0XHQvLyBQcm9jZXNzIGVhY2ggbGluZVxuXHRcdFx0XHRjb25zdCBsaW5lcyA9IEFycmF5LmZyb20oY29kZUNvbnRhaW5lci5jaGlsZHJlbik7XG5cdFx0XHRcdGNvZGVDb250ZW50ID0gbGluZXNcblx0XHRcdFx0XHQubWFwKGxpbmUgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gR2V0IGFsbCBjb2RlIGVsZW1lbnRzIGluIHRoaXMgbGluZVxuXHRcdFx0XHRcdFx0Y29uc3QgY29kZVBhcnRzID0gQXJyYXkuZnJvbShsaW5lLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NvZGUnKSlcblx0XHRcdFx0XHRcdFx0Lm1hcChjb2RlID0+IHtcblx0XHRcdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHRleHQgY29udGVudCwgcHJlc2VydmluZyBzcGFjZXNcblx0XHRcdFx0XHRcdFx0XHRsZXQgdGV4dCA9IGNvZGUudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhICdzcGFjZXMnIGNsYXNzIGVsZW1lbnQsIGNvbnZlcnQgdG8gYWN0dWFsIHNwYWNlc1xuXHRcdFx0XHRcdFx0XHRcdGlmIChjb2RlLmNsYXNzTGlzdC5jb250YWlucygnc3BhY2VzJykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRleHQgPSAnICcucmVwZWF0KHRleHQubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdC5qb2luKCcnKTtcblx0XHRcdFx0XHRcdHJldHVybiBjb2RlUGFydHMgfHwgbGluZS50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5qb2luKCdcXG4nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEhhbmRsZSBXb3JkUHJlc3Mgc3ludGF4IGhpZ2hsaWdodGVyIG5vbi10YWJsZSBmb3JtYXRcblx0XHRcdFx0Y29uc3QgY29kZUxpbmVzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnLmNvZGUgLmxpbmUnKTtcblx0XHRcdFx0aWYgKGNvZGVMaW5lcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29kZUNvbnRlbnQgPSBBcnJheS5mcm9tKGNvZGVMaW5lcylcblx0XHRcdFx0XHRcdC5tYXAobGluZSA9PiB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNvZGVQYXJ0cyA9IEFycmF5LmZyb20obGluZS5xdWVyeVNlbGVjdG9yQWxsKCdjb2RlJykpXG5cdFx0XHRcdFx0XHRcdFx0Lm1hcChjb2RlID0+IGNvZGUudGV4dENvbnRlbnQgfHwgJycpXG5cdFx0XHRcdFx0XHRcdFx0LmpvaW4oJycpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gY29kZVBhcnRzIHx8IGxpbmUudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LmpvaW4oJ1xcbicpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHJlZ3VsYXIgdGV4dCBjb250ZW50XG5cdFx0XHRcdFx0Y29kZUNvbnRlbnQgPSBlbC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgY29udGVudFxuXHRcdFx0Y29kZUNvbnRlbnQgPSBjb2RlQ29udGVudFxuXHRcdFx0XHQucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpIC8vIFRyaW0gc3RhcnQvZW5kIHdoaXRlc3BhY2Vcblx0XHRcdFx0LnJlcGxhY2UoL1xcdC9nLCAnICAgICcpIC8vIENvbnZlcnQgdGFicyB0byBzcGFjZXNcblx0XHRcdFx0LnJlcGxhY2UoL1xcbnszLH0vZywgJ1xcblxcbicpIC8vIE5vcm1hbGl6ZSBtdWx0aXBsZSBuZXdsaW5lc1xuXHRcdFx0XHQucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpOyAvLyBSZXBsYWNlIG5vbi1icmVha2luZyBzcGFjZXMgd2l0aCByZWd1bGFyIHNwYWNlc1xuXG5cdFx0XHQvLyBDcmVhdGUgY29kZSBlbGVtZW50IHdpdGggbGFuZ3VhZ2UgY2xhc3MgaWYgZGV0ZWN0ZWRcblx0XHRcdGNvbnN0IGNvZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2RlJyk7XG5cdFx0XHRpZiAobGFuZ3VhZ2UpIHtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGFuZycsIGxhbmd1YWdlKTtcblx0XHRcdFx0Y29kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYGxhbmd1YWdlLSR7bGFuZ3VhZ2V9YCk7XG5cdFx0XHR9XG5cdFx0XHRjb2RlLnRleHRDb250ZW50ID0gY29kZUNvbnRlbnQ7XG5cdFx0XHRcblx0XHRcdG5ld1ByZS5hcHBlbmRDaGlsZChjb2RlKTtcblx0XHRcdHJldHVybiBuZXdQcmU7XG5cdFx0fVxuXHR9XG5dO1xuXG5pbnRlcmZhY2UgRm9vdG5vdGVEYXRhIHtcblx0Y29udGVudDogRWxlbWVudCB8IHN0cmluZztcblx0b3JpZ2luYWxJZDogc3RyaW5nO1xuXHRyZWZzOiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIEZvb3Rub3RlQ29sbGVjdGlvbiB7XG5cdFtmb290bm90ZU51bWJlcjogbnVtYmVyXTogRm9vdG5vdGVEYXRhO1xufVxuXG5pbnRlcmZhY2UgQ29udGVudFNjb3JlIHtcblx0c2NvcmU6IG51bWJlcjtcblx0ZWxlbWVudDogRWxlbWVudDtcbn1cblxuaW50ZXJmYWNlIFN0eWxlQ2hhbmdlIHtcblx0c2VsZWN0b3I6IHN0cmluZztcblx0c3R5bGVzOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBEZWZ1ZGRsZSB7XG5cdHByaXZhdGUgZG9jOiBEb2N1bWVudDtcblx0cHJpdmF0ZSBvcHRpb25zOiBEZWZ1ZGRsZU9wdGlvbnM7XG5cdHByaXZhdGUgZGVidWc6IGJvb2xlYW47XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIG5ldyBEZWZ1ZGRsZSBpbnN0YW5jZVxuXHQgKiBAcGFyYW0gZG9jIC0gVGhlIGRvY3VtZW50IHRvIHBhcnNlXG5cdCAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgcGFyc2luZ1xuXHQgKi9cblx0Y29uc3RydWN0b3IoZG9jOiBEb2N1bWVudCwgb3B0aW9uczogRGVmdWRkbGVPcHRpb25zID0ge30pIHtcblx0XHR0aGlzLmRvYyA9IGRvYztcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuZGVidWcgPSBvcHRpb25zLmRlYnVnIHx8IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlIHRoZSBkb2N1bWVudCBhbmQgZXh0cmFjdCBpdHMgbWFpbiBjb250ZW50XG5cdCAqL1xuXHRwYXJzZSgpOiBEZWZ1ZGRsZVJlc3BvbnNlIHtcblx0XHRjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuXHRcdC8vIEV4dHJhY3QgbWV0YWRhdGEgZmlyc3Qgc2luY2Ugd2UnbGwgbmVlZCBpdCBpbiBtdWx0aXBsZSBwbGFjZXNcblx0XHRjb25zdCBzY2hlbWFPcmdEYXRhID0gTWV0YWRhdGFFeHRyYWN0b3IuZXh0cmFjdFNjaGVtYU9yZ0RhdGEodGhpcy5kb2MpO1xuXHRcdGNvbnN0IG1ldGFkYXRhID0gTWV0YWRhdGFFeHRyYWN0b3IuZXh0cmFjdCh0aGlzLmRvYywgc2NoZW1hT3JnRGF0YSk7XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gRXZhbHVhdGUgc3R5bGVzIGFuZCBzaXplcyBvbiBvcmlnaW5hbCBkb2N1bWVudFxuXHRcdFx0Y29uc3QgbW9iaWxlU3R5bGVzID0gdGhpcy5fZXZhbHVhdGVNZWRpYVF1ZXJpZXModGhpcy5kb2MpO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBmb3Igc21hbGwgaW1hZ2VzIGluIG9yaWdpbmFsIGRvY3VtZW50LCBleGNsdWRpbmcgbGF6eS1sb2FkZWQgb25lc1xuXHRcdFx0Y29uc3Qgc21hbGxJbWFnZXMgPSB0aGlzLmZpbmRTbWFsbEltYWdlcyh0aGlzLmRvYyk7XG5cdFx0XHRcblx0XHRcdC8vIENsb25lIGRvY3VtZW50XG5cdFx0XHRjb25zdCBjbG9uZSA9IHRoaXMuZG9jLmNsb25lTm9kZSh0cnVlKSBhcyBEb2N1bWVudDtcblx0XHRcdFxuXHRcdFx0Ly8gQXBwbHkgbW9iaWxlIHN0eWxlIHRvIGNsb25lXG5cdFx0XHR0aGlzLmFwcGx5TW9iaWxlU3R5bGVzKGNsb25lLCBtb2JpbGVTdHlsZXMpO1xuXG5cdFx0XHQvLyBGaW5kIG1haW4gY29udGVudFxuXHRcdFx0Y29uc3QgbWFpbkNvbnRlbnQgPSB0aGlzLmZpbmRNYWluQ29udGVudChjbG9uZSk7XG5cdFx0XHRpZiAoIW1haW5Db250ZW50KSB7XG5cdFx0XHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjb250ZW50OiB0aGlzLmRvYy5ib2R5LmlubmVySFRNTCxcblx0XHRcdFx0XHQuLi5tZXRhZGF0YSxcblx0XHRcdFx0XHR3b3JkQ291bnQ6IHRoaXMuY291bnRXb3Jkcyh0aGlzLmRvYy5ib2R5LmlubmVySFRNTCksXG5cdFx0XHRcdFx0cGFyc2VUaW1lOiBNYXRoLnJvdW5kKGVuZFRpbWUgLSBzdGFydFRpbWUpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBzbWFsbCBpbWFnZXMgaWRlbnRpZmllZCBmcm9tIG9yaWdpbmFsIGRvY3VtZW50XG5cdFx0XHR0aGlzLnJlbW92ZVNtYWxsSW1hZ2VzKGNsb25lLCBzbWFsbEltYWdlcyk7XG5cdFx0XHRcblx0XHRcdC8vIFBlcmZvcm0gb3RoZXIgZGVzdHJ1Y3RpdmUgb3BlcmF0aW9ucyBvbiB0aGUgY2xvbmVcblx0XHRcdHRoaXMucmVtb3ZlSGlkZGVuRWxlbWVudHMoY2xvbmUpO1xuXHRcdFx0dGhpcy5yZW1vdmVDbHV0dGVyKGNsb25lKTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgdGhlIG1haW4gY29udGVudFxuXHRcdFx0dGhpcy5jbGVhbkNvbnRlbnQobWFpbkNvbnRlbnQsIG1ldGFkYXRhKTtcblxuXHRcdFx0Y29uc3QgY29udGVudCA9IG1haW5Db250ZW50ID8gbWFpbkNvbnRlbnQub3V0ZXJIVE1MIDogdGhpcy5kb2MuYm9keS5pbm5lckhUTUw7XG5cdFx0XHRjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvbnRlbnQsXG5cdFx0XHRcdC4uLm1ldGFkYXRhLFxuXHRcdFx0XHR3b3JkQ291bnQ6IHRoaXMuY291bnRXb3Jkcyhjb250ZW50KSxcblx0XHRcdFx0cGFyc2VUaW1lOiBNYXRoLnJvdW5kKGVuZFRpbWUgLSBzdGFydFRpbWUpXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdEZWZ1ZGRsZScsICdFcnJvciBwcm9jZXNzaW5nIGRvY3VtZW50OicsIGVycm9yKTtcblx0XHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvbnRlbnQ6IHRoaXMuZG9jLmJvZHkuaW5uZXJIVE1MLFxuXHRcdFx0XHQuLi5tZXRhZGF0YSxcblx0XHRcdFx0d29yZENvdW50OiB0aGlzLmNvdW50V29yZHModGhpcy5kb2MuYm9keS5pbm5lckhUTUwpLFxuXHRcdFx0XHRwYXJzZVRpbWU6IE1hdGgucm91bmQoZW5kVGltZSAtIHN0YXJ0VGltZSlcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBjb3VudFdvcmRzKGNvbnRlbnQ6IHN0cmluZyk6IG51bWJlciB7XG5cdFx0Ly8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGRpdiB0byBwYXJzZSBIVE1MIGNvbnRlbnRcblx0XHRjb25zdCB0ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0dGVtcERpdi5pbm5lckhUTUwgPSBjb250ZW50O1xuXG5cdFx0Ly8gR2V0IHRleHQgY29udGVudCwgcmVtb3ZpbmcgZXh0cmEgd2hpdGVzcGFjZVxuXHRcdGNvbnN0IHRleHQgPSB0ZW1wRGl2LnRleHRDb250ZW50IHx8ICcnO1xuXHRcdGNvbnN0IHdvcmRzID0gdGV4dFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL1xccysvZywgJyAnKSAvLyBSZXBsYWNlIG11bHRpcGxlIHNwYWNlcyB3aXRoIHNpbmdsZSBzcGFjZVxuXHRcdFx0LnNwbGl0KCcgJylcblx0XHRcdC5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDApOyAvLyBGaWx0ZXIgb3V0IGVtcHR5IHN0cmluZ3NcblxuXHRcdHJldHVybiB3b3Jkcy5sZW5ndGg7XG5cdH1cblxuXHQvLyBNYWtlIGFsbCBvdGhlciBtZXRob2RzIHByaXZhdGUgYnkgcmVtb3ZpbmcgdGhlIHN0YXRpYyBrZXl3b3JkIGFuZCB1c2luZyBwcml2YXRlXG5cdHByaXZhdGUgX2xvZyguLi5hcmdzOiBhbnlbXSk6IHZvaWQge1xuXHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRjb25zb2xlLmxvZygnRGVmdWRkbGU6JywgLi4uYXJncyk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBfZXZhbHVhdGVNZWRpYVF1ZXJpZXMoZG9jOiBEb2N1bWVudCk6IFN0eWxlQ2hhbmdlW10ge1xuXHRcdGNvbnN0IG1vYmlsZVN0eWxlczogU3R5bGVDaGFuZ2VbXSA9IFtdO1xuXHRcdGNvbnN0IG1heFdpZHRoUmVnZXggPSAvbWF4LXdpZHRoW146XSo6XFxzKihcXGQrKS87XG5cblx0XHR0cnkge1xuXHRcdFx0Ly8gR2V0IGFsbCBzdHlsZXMsIGluY2x1ZGluZyBpbmxpbmUgc3R5bGVzXG5cdFx0XHRjb25zdCBzaGVldHMgPSBBcnJheS5mcm9tKGRvYy5zdHlsZVNoZWV0cykuZmlsdGVyKHNoZWV0ID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBBY2Nlc3MgcnVsZXMgb25jZSB0byBjaGVjayB2YWxpZGl0eVxuXHRcdFx0XHRcdHNoZWV0LmNzc1J1bGVzO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0Ly8gRXhwZWN0ZWQgZXJyb3IgZm9yIGNyb3NzLW9yaWdpbiBzdHlsZXNoZWV0c1xuXHRcdFx0XHRcdGlmIChlIGluc3RhbmNlb2YgRE9NRXhjZXB0aW9uICYmIGUubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0XG5cdFx0XHQvLyBQcm9jZXNzIGFsbCBzaGVldHMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdFx0Y29uc3QgbWVkaWFSdWxlcyA9IHNoZWV0cy5mbGF0TWFwKHNoZWV0ID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRyZXR1cm4gQXJyYXkuZnJvbShzaGVldC5jc3NSdWxlcylcblx0XHRcdFx0XHRcdC5maWx0ZXIoKHJ1bGUpOiBydWxlIGlzIENTU01lZGlhUnVsZSA9PiBcblx0XHRcdFx0XHRcdFx0cnVsZSBpbnN0YW5jZW9mIENTU01lZGlhUnVsZSAmJlxuXHRcdFx0XHRcdFx0XHRydWxlLmNvbmRpdGlvblRleHQuaW5jbHVkZXMoJ21heC13aWR0aCcpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIHN0eWxlc2hlZXQ6JywgZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIFByb2Nlc3MgYWxsIG1lZGlhIHJ1bGVzIGluIGEgc2luZ2xlIHBhc3Ncblx0XHRcdG1lZGlhUnVsZXMuZm9yRWFjaChydWxlID0+IHtcblx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBydWxlLmNvbmRpdGlvblRleHQubWF0Y2gobWF4V2lkdGhSZWdleCk7XG5cdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdGNvbnN0IG1heFdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmIChNT0JJTEVfV0lEVEggPD0gbWF4V2lkdGgpIHtcblx0XHRcdFx0XHRcdC8vIEJhdGNoIHByb2Nlc3MgYWxsIHN0eWxlIHJ1bGVzXG5cdFx0XHRcdFx0XHRjb25zdCBzdHlsZVJ1bGVzID0gQXJyYXkuZnJvbShydWxlLmNzc1J1bGVzKVxuXHRcdFx0XHRcdFx0XHQuZmlsdGVyKChyKTogciBpcyBDU1NTdHlsZVJ1bGUgPT4gciBpbnN0YW5jZW9mIENTU1N0eWxlUnVsZSk7XG5cblx0XHRcdFx0XHRcdHN0eWxlUnVsZXMuZm9yRWFjaChjc3NSdWxlID0+IHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRtb2JpbGVTdHlsZXMucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RvcjogY3NzUnVsZS5zZWxlY3RvclRleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZXM6IGNzc1J1bGUuc3R5bGUuY3NzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignRGVmdWRkbGU6IEZhaWxlZCB0byBwcm9jZXNzIENTUyBydWxlOicsIGUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdEZWZ1ZGRsZTogRXJyb3IgZXZhbHVhdGluZyBtZWRpYSBxdWVyaWVzOicsIGUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtb2JpbGVTdHlsZXM7XG5cdH1cblxuXHRwcml2YXRlIGFwcGx5TW9iaWxlU3R5bGVzKGRvYzogRG9jdW1lbnQsIG1vYmlsZVN0eWxlczogU3R5bGVDaGFuZ2VbXSkge1xuXHRcdGxldCBhcHBsaWVkQ291bnQgPSAwO1xuXG5cdFx0bW9iaWxlU3R5bGVzLmZvckVhY2goKHtzZWxlY3Rvciwgc3R5bGVzfSkgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG5cdFx0XHRcdGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG5cdFx0XHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgXG5cdFx0XHRcdFx0XHQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykgfHwgJycpICsgc3R5bGVzXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRhcHBsaWVkQ291bnQrKztcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0RlZnVkZGxlJywgJ0Vycm9yIGFwcGx5aW5nIHN0eWxlcyBmb3Igc2VsZWN0b3I6Jywgc2VsZWN0b3IsIGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUhpZGRlbkVsZW1lbnRzKGRvYzogRG9jdW1lbnQpIHtcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGNvbnN0IGVsZW1lbnRzVG9SZW1vdmUgPSBuZXcgU2V0PEVsZW1lbnQ+KCk7XG5cblx0XHQvLyBGaXJzdCBwYXNzOiBHZXQgYWxsIGVsZW1lbnRzIG1hdGNoaW5nIGhpZGRlbiBzZWxlY3RvcnNcblx0XHRjb25zdCBoaWRkZW5FbGVtZW50cyA9IGRvYy5xdWVyeVNlbGVjdG9yQWxsKEhJRERFTl9FTEVNRU5UX1NFTEVDVE9SUyk7XG5cdFx0aGlkZGVuRWxlbWVudHMuZm9yRWFjaChlbCA9PiBlbGVtZW50c1RvUmVtb3ZlLmFkZChlbCkpO1xuXHRcdGNvdW50ICs9IGhpZGRlbkVsZW1lbnRzLmxlbmd0aDtcblxuXHRcdC8vIFNlY29uZCBwYXNzOiBVc2UgVHJlZVdhbGtlciBmb3IgZWZmaWNpZW50IHRyYXZlcnNhbFxuXHRcdGNvbnN0IHRyZWVXYWxrZXIgPSBkb2MuY3JlYXRlVHJlZVdhbGtlcihcblx0XHRcdGRvYy5ib2R5LFxuXHRcdFx0Tm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXG5cdFx0XHR7XG5cdFx0XHRcdGFjY2VwdE5vZGU6IChub2RlOiBFbGVtZW50KSA9PiB7XG5cdFx0XHRcdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IG1hcmtlZCBmb3IgcmVtb3ZhbFxuXHRcdFx0XHRcdGlmIChlbGVtZW50c1RvUmVtb3ZlLmhhcyhub2RlKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHQvLyBCYXRjaCBzdHlsZSBjb21wdXRhdGlvbnNcblx0XHRjb25zdCBlbGVtZW50czogRWxlbWVudFtdID0gW107XG5cdFx0bGV0IGN1cnJlbnROb2RlOiBFbGVtZW50IHwgbnVsbDtcblx0XHR3aGlsZSAoY3VycmVudE5vZGUgPSB0cmVlV2Fsa2VyLm5leHROb2RlKCkgYXMgRWxlbWVudCkge1xuXHRcdFx0ZWxlbWVudHMucHVzaChjdXJyZW50Tm9kZSk7XG5cdFx0fVxuXG5cdFx0Ly8gUHJvY2VzcyBzdHlsZXMgaW4gYmF0Y2hlcyB0byBtaW5pbWl6ZSBsYXlvdXQgdGhyYXNoaW5nXG5cdFx0Y29uc3QgQkFUQ0hfU0laRSA9IDEwMDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XG5cdFx0XHRjb25zdCBiYXRjaCA9IGVsZW1lbnRzLnNsaWNlKGksIGkgKyBCQVRDSF9TSVpFKTtcblx0XHRcdFxuXHRcdFx0Ly8gUmVhZCBwaGFzZSAtIGdhdGhlciBhbGwgY29tcHV0ZWRTdHlsZXNcblx0XHRcdGNvbnN0IHN0eWxlcyA9IGJhdGNoLm1hcChlbCA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkpO1xuXHRcdFx0XG5cdFx0XHQvLyBXcml0ZSBwaGFzZSAtIG1hcmsgZWxlbWVudHMgZm9yIHJlbW92YWxcblx0XHRcdGJhdGNoLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBzdHlsZXNbaW5kZXhdO1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgfHxcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nIHx8XG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZS5vcGFjaXR5ID09PSAnMCdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZWxlbWVudHNUb1JlbW92ZS5hZGQoZWxlbWVudCk7XG5cdFx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gRmluYWwgcGFzczogQmF0Y2ggcmVtb3ZlIGFsbCBoaWRkZW4gZWxlbWVudHNcblx0XHRlbGVtZW50c1RvUmVtb3ZlLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuXG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIGhpZGRlbiBlbGVtZW50czonLCBjb3VudCk7XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUNsdXR0ZXIoZG9jOiBEb2N1bWVudCkge1xuXHRcdGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdGxldCBleGFjdFNlbGVjdG9yQ291bnQgPSAwO1xuXHRcdGxldCBwYXJ0aWFsU2VsZWN0b3JDb3VudCA9IDA7XG5cblx0XHQvLyBUcmFjayBhbGwgZWxlbWVudHMgdG8gYmUgcmVtb3ZlZFxuXHRcdGNvbnN0IGVsZW1lbnRzVG9SZW1vdmUgPSBuZXcgU2V0PEVsZW1lbnQ+KCk7XG5cblx0XHQvLyBGaXJzdCBjb2xsZWN0IGVsZW1lbnRzIG1hdGNoaW5nIGV4YWN0IHNlbGVjdG9yc1xuXHRcdGNvbnN0IGV4YWN0RWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChFWEFDVF9TRUxFQ1RPUlMuam9pbignLCcpKTtcblx0XHRleGFjdEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0aWYgKGVsPy5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdGVsZW1lbnRzVG9SZW1vdmUuYWRkKGVsKTtcblx0XHRcdFx0ZXhhY3RTZWxlY3RvckNvdW50Kys7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBQcmUtY29tcGlsZSByZWdleGVzIGFuZCBjb21iaW5lIGludG8gYSBzaW5nbGUgcmVnZXggZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuXHRcdGNvbnN0IGNvbWJpbmVkUGF0dGVybiA9IFBBUlRJQUxfU0VMRUNUT1JTLmpvaW4oJ3wnKTtcblx0XHRjb25zdCBwYXJ0aWFsUmVnZXggPSBuZXcgUmVnRXhwKGNvbWJpbmVkUGF0dGVybiwgJ2knKTtcblxuXHRcdC8vIENyZWF0ZSBhbiBlZmZpY2llbnQgYXR0cmlidXRlIHNlbGVjdG9yIGZvciBlbGVtZW50cyB3ZSBjYXJlIGFib3V0XG5cdFx0Y29uc3QgYXR0cmlidXRlU2VsZWN0b3IgPSAnW2NsYXNzXSxbaWRdLFtkYXRhLXRlc3RpZF0sW2RhdGEtcWFdLFtkYXRhLWN5XSc7XG5cdFx0Y29uc3QgYWxsRWxlbWVudHMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChhdHRyaWJ1dGVTZWxlY3Rvcik7XG5cblx0XHQvLyBQcm9jZXNzIGVsZW1lbnRzIGZvciBwYXJ0aWFsIG1hdGNoZXNcblx0XHRhbGxFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcblx0XHRcdC8vIFNraXAgaWYgYWxyZWFkeSBtYXJrZWQgZm9yIHJlbW92YWxcblx0XHRcdGlmIChlbGVtZW50c1RvUmVtb3ZlLmhhcyhlbCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBHZXQgYWxsIHJlbGV2YW50IGF0dHJpYnV0ZXMgYW5kIGNvbWJpbmUgaW50byBhIHNpbmdsZSBzdHJpbmdcblx0XHRcdGNvbnN0IGF0dHJzID0gW1xuXHRcdFx0XHRlbC5jbGFzc05hbWUgJiYgdHlwZW9mIGVsLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycgPyBlbC5jbGFzc05hbWUgOiAnJyxcblx0XHRcdFx0ZWwuaWQgfHwgJycsXG5cdFx0XHRcdGVsLmdldEF0dHJpYnV0ZSgnZGF0YS10ZXN0aWQnKSB8fCAnJyxcblx0XHRcdFx0ZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXFhJykgfHwgJycsXG5cdFx0XHRcdGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1jeScpIHx8ICcnXG5cdFx0XHRdLmpvaW4oJyAnKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHQvLyBTa2lwIGlmIG5vIGF0dHJpYnV0ZXMgdG8gY2hlY2tcblx0XHRcdGlmICghYXR0cnMudHJpbSgpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hlY2sgZm9yIHBhcnRpYWwgbWF0Y2ggdXNpbmcgc2luZ2xlIHJlZ2V4IHRlc3Rcblx0XHRcdGlmIChwYXJ0aWFsUmVnZXgudGVzdChhdHRycykpIHtcblx0XHRcdFx0ZWxlbWVudHNUb1JlbW92ZS5hZGQoZWwpO1xuXHRcdFx0XHRwYXJ0aWFsU2VsZWN0b3JDb3VudCsrO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gUmVtb3ZlIGFsbCBjb2xsZWN0ZWQgZWxlbWVudHMgaW4gYSBzaW5nbGUgcGFzc1xuXHRcdGVsZW1lbnRzVG9SZW1vdmUuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG5cblx0XHRjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIGNsdXR0ZXIgZWxlbWVudHM6Jywge1xuXHRcdFx0ZXhhY3RTZWxlY3RvcnM6IGV4YWN0U2VsZWN0b3JDb3VudCxcblx0XHRcdHBhcnRpYWxTZWxlY3RvcnM6IHBhcnRpYWxTZWxlY3RvckNvdW50LFxuXHRcdFx0dG90YWw6IGVsZW1lbnRzVG9SZW1vdmUuc2l6ZSxcblx0XHRcdHByb2Nlc3NpbmdUaW1lOiBgJHsoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgyKX1tc2Bcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgZmxhdHRlbkRpdnMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCBwcm9jZXNzZWRDb3VudCA9IDA7XG5cdFx0Y29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cblx0XHQvLyBQcm9jZXNzIGluIGJhdGNoZXMgdG8gbWFpbnRhaW4gcGVyZm9ybWFuY2Vcblx0XHRsZXQga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXG5cdFx0Y29uc3Qgc2hvdWxkUHJlc2VydmVFbGVtZW50ID0gKGVsOiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHRjb25zdCB0YWdOYW1lID0gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBpZiBlbGVtZW50IHNob3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdGlmIChQUkVTRVJWRV9FTEVNRU5UUy5oYXModGFnTmFtZSkpIHJldHVybiB0cnVlO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBmb3Igc2VtYW50aWMgcm9sZXNcblx0XHRcdGNvbnN0IHJvbGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKTtcblx0XHRcdGlmIChyb2xlICYmIFsnYXJ0aWNsZScsICdtYWluJywgJ25hdmlnYXRpb24nLCAnYmFubmVyJywgJ2NvbnRlbnRpbmZvJ10uaW5jbHVkZXMocm9sZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdC8vIENoZWNrIGZvciBzZW1hbnRpYyBjbGFzc2VzXG5cdFx0XHRjb25zdCBjbGFzc05hbWUgPSBlbC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChjbGFzc05hbWUubWF0Y2goLyg/OmFydGljbGV8bWFpbnxjb250ZW50fGZvb3Rub3RlfHJlZmVyZW5jZXxiaWJsaW9ncmFwaHkpLykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENoZWNrIGlmIGRpdiBjb250YWlucyBtaXhlZCBjb250ZW50IHR5cGVzIHRoYXQgc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0aWYgKHRhZ05hbWUgPT09ICdkaXYnKSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbik7XG5cdFx0XHRcdGNvbnN0IGhhc1ByZXNlcnZlZEVsZW1lbnRzID0gY2hpbGRyZW4uc29tZShjaGlsZCA9PiBcblx0XHRcdFx0XHRQUkVTRVJWRV9FTEVNRU5UUy5oYXMoY2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSB8fFxuXHRcdFx0XHRcdGNoaWxkLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnYXJ0aWNsZScgfHxcblx0XHRcdFx0XHRjaGlsZC5jbGFzc05hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnYXJ0aWNsZScpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGlmIChoYXNQcmVzZXJ2ZWRFbGVtZW50cykgcmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Y29uc3QgaXNXcmFwcGVyRGl2ID0gKGRpdjogRWxlbWVudCk6IGJvb2xlYW4gPT4ge1xuXHRcdFx0Ly8gQ2hlY2sgaWYgaXQncyBqdXN0IGVtcHR5IHNwYWNlXG5cdFx0XHRpZiAoIWRpdi50ZXh0Q29udGVudD8udHJpbSgpKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaXQgb25seSBjb250YWlucyBvdGhlciBkaXZzIG9yIGJsb2NrIGVsZW1lbnRzXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IEFycmF5LmZyb20oZGl2LmNoaWxkcmVuKTtcblx0XHRcdGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuXHRcdFx0XG5cdFx0XHQvLyBDaGVjayBpZiBhbGwgY2hpbGRyZW4gYXJlIGJsb2NrIGVsZW1lbnRzXG5cdFx0XHRjb25zdCBhbGxCbG9ja0VsZW1lbnRzID0gY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4ge1xuXHRcdFx0XHRjb25zdCB0YWcgPSBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHJldHVybiB0YWcgPT09ICdkaXYnIHx8IHRhZyA9PT0gJ3AnIHx8IHRhZyA9PT0gJ2gxJyB8fCB0YWcgPT09ICdoMicgfHwgXG5cdFx0XHRcdFx0ICAgdGFnID09PSAnaDMnIHx8IHRhZyA9PT0gJ2g0JyB8fCB0YWcgPT09ICdoNScgfHwgdGFnID09PSAnaDYnIHx8XG5cdFx0XHRcdFx0ICAgdGFnID09PSAndWwnIHx8IHRhZyA9PT0gJ29sJyB8fCB0YWcgPT09ICdwcmUnIHx8IHRhZyA9PT0gJ2Jsb2NrcXVvdGUnIHx8XG5cdFx0XHRcdFx0ICAgdGFnID09PSAnZmlndXJlJztcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGFsbEJsb2NrRWxlbWVudHMpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgY29tbW9uIHdyYXBwZXIgcGF0dGVybnNcblx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9IGRpdi5jbGFzc05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvbnN0IGlzV3JhcHBlciA9IC8oPzp3cmFwcGVyfGNvbnRhaW5lcnxsYXlvdXR8cm93fGNvbHxncmlkfGZsZXh8b3V0ZXJ8aW5uZXJ8Y29udGVudC1hcmVhKS9pLnRlc3QoY2xhc3NOYW1lKTtcblx0XHRcdGlmIChpc1dyYXBwZXIpIHJldHVybiB0cnVlO1xuXG5cdFx0XHQvLyBDaGVjayBpZiBpdCBoYXMgZXhjZXNzaXZlIHdoaXRlc3BhY2Ugb3IgZW1wdHkgdGV4dCBub2Rlc1xuXHRcdFx0Y29uc3QgdGV4dE5vZGVzID0gQXJyYXkuZnJvbShkaXYuY2hpbGROb2RlcykuZmlsdGVyKG5vZGUgPT4gXG5cdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIG5vZGUudGV4dENvbnRlbnQ/LnRyaW0oKVxuXHRcdFx0KTtcblx0XHRcdGlmICh0ZXh0Tm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaXQncyBhIGRpdiB0aGF0IG9ubHkgY29udGFpbnMgYmxvY2sgZWxlbWVudHNcblx0XHRcdGNvbnN0IGhhc09ubHlCbG9ja0VsZW1lbnRzID0gY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhY2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0cmV0dXJuIElOTElORV9FTEVNRU5UUy5oYXModGFnKTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGhhc09ubHlCbG9ja0VsZW1lbnRzKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBGdW5jdGlvbiB0byBwcm9jZXNzIGEgc2luZ2xlIGRpdlxuXHRcdGNvbnN0IHByb2Nlc3NEaXYgPSAoZGl2OiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHQvLyBTa2lwIHByb2Nlc3NpbmcgaWYgZGl2IGhhcyBiZWVuIHJlbW92ZWQgb3Igc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0aWYgKCFkaXYuaXNDb25uZWN0ZWQgfHwgc2hvdWxkUHJlc2VydmVFbGVtZW50KGRpdikpIHJldHVybiBmYWxzZTtcblxuXHRcdFx0Ly8gQ2FzZSAxOiBFbXB0eSBkaXYgb3IgZGl2IHdpdGggb25seSB3aGl0ZXNwYWNlXG5cdFx0XHRpZiAoIWRpdi5oYXNDaGlsZE5vZGVzKCkgfHwgIWRpdi50ZXh0Q29udGVudD8udHJpbSgpKSB7XG5cdFx0XHRcdGRpdi5yZW1vdmUoKTtcblx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgMjogVG9wLWxldmVsIGRpdiAtIGJlIG1vcmUgYWdncmVzc2l2ZVxuXHRcdFx0aWYgKGRpdi5wYXJlbnRFbGVtZW50ID09PSBlbGVtZW50KSB7XG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0XHRjb25zdCBoYXNPbmx5QmxvY2tFbGVtZW50cyA9IGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgIWNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRyZXR1cm4gSU5MSU5FX0VMRU1FTlRTLmhhcyh0YWcpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoaGFzT25seUJsb2NrRWxlbWVudHMpIHtcblx0XHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XHR3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdi5maXJzdENoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgMzogV3JhcHBlciBkaXYgLSBtZXJnZSB1cCBhZ2dyZXNzaXZlbHlcblx0XHRcdGlmIChpc1dyYXBwZXJEaXYoZGl2KSkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2U6IGlmIGRpdiBvbmx5IGNvbnRhaW5zIGJsb2NrIGVsZW1lbnRzLCBtZXJnZSB0aGVtIHVwXG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0XHRjb25zdCBvbmx5QmxvY2tFbGVtZW50cyA9ICFjaGlsZHJlbi5zb21lKGNoaWxkID0+IHtcblx0XHRcdFx0XHRjb25zdCB0YWcgPSBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0cmV0dXJuIElOTElORV9FTEVNRU5UUy5oYXModGFnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAob25seUJsb2NrRWxlbWVudHMpIHtcblx0XHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0XHR3aGlsZSAoZGl2LmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdi5maXJzdENoaWxkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGhhbmRsZSBhcyBub3JtYWwgd3JhcHBlclxuXHRcdFx0XHRjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdFx0d2hpbGUgKGRpdi5maXJzdENoaWxkKSB7XG5cdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRpdi5yZXBsYWNlV2l0aChmcmFnbWVudCk7XG5cdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYXNlIDQ6IERpdiBvbmx5IGNvbnRhaW5zIHRleHQgY29udGVudCAtIGNvbnZlcnQgdG8gcGFyYWdyYXBoXG5cdFx0XHRpZiAoIWRpdi5jaGlsZHJlbi5sZW5ndGggJiYgZGl2LnRleHRDb250ZW50Py50cmltKCkpIHtcblx0XHRcdFx0Y29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdFx0cC50ZXh0Q29udGVudCA9IGRpdi50ZXh0Q29udGVudDtcblx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKHApO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FzZSA1OiBEaXYgaGFzIHNpbmdsZSBjaGlsZFxuXHRcdFx0aWYgKGRpdi5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0Y29uc3QgY2hpbGQgPSBkaXYuZmlyc3RFbGVtZW50Q2hpbGQhO1xuXHRcdFx0XHRjb25zdCBjaGlsZFRhZyA9IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIERvbid0IHVud3JhcCBpZiBjaGlsZCBpcyBpbmxpbmUgb3Igc2hvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRpZiAoIUlOTElORV9FTEVNRU5UUy5oYXMoY2hpbGRUYWcpICYmICFzaG91bGRQcmVzZXJ2ZUVsZW1lbnQoY2hpbGQpKSB7XG5cdFx0XHRcdFx0ZGl2LnJlcGxhY2VXaXRoKGNoaWxkKTtcblx0XHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhc2UgNjogRGVlcGx5IG5lc3RlZCBkaXYgLSBtZXJnZSB1cFxuXHRcdFx0bGV0IG5lc3RpbmdEZXB0aCA9IDA7XG5cdFx0XHRsZXQgcGFyZW50ID0gZGl2LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2Jykge1xuXHRcdFx0XHRcdG5lc3RpbmdEZXB0aCsrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobmVzdGluZ0RlcHRoID4gMCkgeyAvLyBDaGFuZ2VkIGZyb20gPiAxIHRvID4gMCB0byBiZSBtb3JlIGFnZ3Jlc3NpdmVcblx0XHRcdFx0Y29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdi5maXJzdENoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0XHQvLyBGaXJzdCBwYXNzOiBQcm9jZXNzIHRvcC1sZXZlbCBkaXZzXG5cdFx0Y29uc3QgcHJvY2Vzc1RvcExldmVsRGl2cyA9ICgpID0+IHtcblx0XHRcdGNvbnN0IHRvcERpdnMgPSBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGRyZW4pLmZpbHRlcihcblx0XHRcdFx0ZWwgPT4gZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2J1xuXHRcdFx0KTtcblx0XHRcdFxuXHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cdFx0XHR0b3BEaXZzLmZvckVhY2goZGl2ID0+IHtcblx0XHRcdFx0aWYgKHByb2Nlc3NEaXYoZGl2KSkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbW9kaWZpZWQ7XG5cdFx0fTtcblxuXHRcdC8vIFNlY29uZCBwYXNzOiBQcm9jZXNzIHJlbWFpbmluZyBkaXZzIGZyb20gZGVlcGVzdCB0byBzaGFsbG93ZXN0XG5cdFx0Y29uc3QgcHJvY2Vzc1JlbWFpbmluZ0RpdnMgPSAoKSA9PiB7XG5cdFx0XHRjb25zdCBhbGxEaXZzID0gQXJyYXkuZnJvbShlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkaXYnKSlcblx0XHRcdFx0LnNvcnQoKGEsIGIpID0+IHtcblx0XHRcdFx0XHQvLyBDb3VudCBuZXN0aW5nIGRlcHRoXG5cdFx0XHRcdFx0Y29uc3QgZ2V0RGVwdGggPSAoZWw6IEVsZW1lbnQpOiBudW1iZXIgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IGRlcHRoID0gMDtcblx0XHRcdFx0XHRcdGxldCBwYXJlbnQgPSBlbC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdFx0d2hpbGUgKHBhcmVudCkge1xuXHRcdFx0XHRcdFx0XHRpZiAocGFyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RpdicpIGRlcHRoKys7XG5cdFx0XHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIGRlcHRoO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuIGdldERlcHRoKGIpIC0gZ2V0RGVwdGgoYSk7IC8vIFByb2Nlc3MgZGVlcGVzdCBmaXJzdFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cdFx0XHRhbGxEaXZzLmZvckVhY2goZGl2ID0+IHtcblx0XHRcdFx0aWYgKHByb2Nlc3NEaXYoZGl2KSkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbW9kaWZpZWQ7XG5cdFx0fTtcblxuXHRcdC8vIEZpbmFsIGNsZWFudXAgcGFzcyAtIGFnZ3Jlc3NpdmVseSBmbGF0dGVuIHJlbWFpbmluZyBkaXZzXG5cdFx0Y29uc3QgZmluYWxDbGVhbnVwID0gKCkgPT4ge1xuXHRcdFx0Y29uc3QgcmVtYWluaW5nRGl2cyA9IEFycmF5LmZyb20oZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZGl2JykpO1xuXHRcdFx0bGV0IG1vZGlmaWVkID0gZmFsc2U7XG5cdFx0XHRcblx0XHRcdHJlbWFpbmluZ0RpdnMuZm9yRWFjaChkaXYgPT4ge1xuXHRcdFx0XHQvLyBDaGVjayBpZiBkaXYgb25seSBjb250YWlucyBwYXJhZ3JhcGhzXG5cdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShkaXYuY2hpbGRyZW4pO1xuXHRcdFx0XHRjb25zdCBvbmx5UGFyYWdyYXBocyA9IGNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3AnKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChvbmx5UGFyYWdyYXBocyB8fCAoIXNob3VsZFByZXNlcnZlRWxlbWVudChkaXYpICYmIGlzV3JhcHBlckRpdihkaXYpKSkge1xuXHRcdFx0XHRcdGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0XHRcdHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkaXYucmVwbGFjZVdpdGgoZnJhZ21lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBtb2RpZmllZDtcblx0XHR9O1xuXG5cdFx0Ly8gRXhlY3V0ZSBhbGwgcGFzc2VzIHVudGlsIG5vIG1vcmUgY2hhbmdlc1xuXHRcdGRvIHtcblx0XHRcdFx0a2VlcFByb2Nlc3NpbmcgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHByb2Nlc3NUb3BMZXZlbERpdnMoKSkga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAocHJvY2Vzc1JlbWFpbmluZ0RpdnMoKSkga2VlcFByb2Nlc3NpbmcgPSB0cnVlO1xuXHRcdFx0XHRpZiAoZmluYWxDbGVhbnVwKCkpIGtlZXBQcm9jZXNzaW5nID0gdHJ1ZTtcblx0XHRcdH0gd2hpbGUgKGtlZXBQcm9jZXNzaW5nKTtcblxuXHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHR0aGlzLl9sb2coJ0ZsYXR0ZW5lZCBkaXZzOicsIHtcblx0XHRcdGNvdW50OiBwcm9jZXNzZWRDb3VudCxcblx0XHRcdHByb2Nlc3NpbmdUaW1lOiBgJHsoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgyKX1tc2Bcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgY2xlYW5Db250ZW50KGVsZW1lbnQ6IEVsZW1lbnQsIG1ldGFkYXRhOiBEZWZ1ZGRsZU1ldGFkYXRhKSB7XG5cdFx0Ly8gUmVtb3ZlIEhUTUwgY29tbWVudHNcblx0XHR0aGlzLnJlbW92ZUh0bWxDb21tZW50cyhlbGVtZW50KTtcblx0XHRcblx0XHQvLyBIYW5kbGUgSDEgZWxlbWVudHMgLSByZW1vdmUgZmlyc3Qgb25lIGFuZCBjb252ZXJ0IG90aGVycyB0byBIMlxuXHRcdHRoaXMuaGFuZGxlSGVhZGluZ3MoZWxlbWVudCwgbWV0YWRhdGEudGl0bGUpO1xuXHRcdFxuXHRcdC8vIFN0YW5kYXJkaXplIGZvb3Rub3RlcyBhbmQgY2l0YXRpb25zXG5cdFx0dGhpcy5zdGFuZGFyZGl6ZUZvb3Rub3RlcyhlbGVtZW50KTtcblxuXHRcdC8vIEhhbmRsZSBsYXp5LWxvYWRlZCBpbWFnZXNcblx0XHR0aGlzLmhhbmRsZUxhenlJbWFnZXMoZWxlbWVudCk7XG5cblx0XHQvLyBDb252ZXJ0IGVtYmVkZGVkIGNvbnRlbnQgdG8gc3RhbmRhcmQgZm9ybWF0c1xuXHRcdHRoaXMuc3RhbmRhcmRpemVFbGVtZW50cyhlbGVtZW50KTtcblxuXHRcdC8vIFNraXAgZGl2IGZsYXR0ZW5pbmcgaW4gZGVidWcgbW9kZVxuXHRcdGlmICghdGhpcy5kZWJ1Zykge1xuXHRcdFx0Ly8gRmlyc3QgcGFzcyBvZiBkaXYgZmxhdHRlbmluZ1xuXHRcdFx0dGhpcy5mbGF0dGVuRGl2cyhlbGVtZW50KTtcblx0XHRcdFxuXHRcdFx0Ly8gU3RyaXAgdW53YW50ZWQgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5zdHJpcFVud2FudGVkQXR0cmlidXRlcyhlbGVtZW50KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGVtcHR5IGVsZW1lbnRzXG5cdFx0XHR0aGlzLnJlbW92ZUVtcHR5RWxlbWVudHMoZWxlbWVudCk7XG5cblx0XHRcdC8vIFJlbW92ZSB0cmFpbGluZyBoZWFkaW5nc1xuXHRcdFx0dGhpcy5yZW1vdmVUcmFpbGluZ0hlYWRpbmdzKGVsZW1lbnQpO1xuXG5cdFx0XHQvLyBGaW5hbCBwYXNzIG9mIGRpdiBmbGF0dGVuaW5nIGFmdGVyIGNsZWFudXAgb3BlcmF0aW9uc1xuXHRcdFx0dGhpcy5mbGF0dGVuRGl2cyhlbGVtZW50KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gSW4gZGVidWcgbW9kZSwgc3RpbGwgZG8gYmFzaWMgY2xlYW51cCBidXQgcHJlc2VydmUgc3RydWN0dXJlXG5cdFx0XHR0aGlzLnN0cmlwVW53YW50ZWRBdHRyaWJ1dGVzKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5yZW1vdmVFbXB0eUVsZW1lbnRzKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5yZW1vdmVUcmFpbGluZ0hlYWRpbmdzKGVsZW1lbnQpO1xuXHRcdFx0dGhpcy5fbG9nKCdEZWJ1ZyBtb2RlOiBTa2lwcGluZyBkaXYgZmxhdHRlbmluZyB0byBwcmVzZXJ2ZSBzdHJ1Y3R1cmUnKTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZVRyYWlsaW5nSGVhZGluZ3MoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGxldCByZW1vdmVkQ291bnQgPSAwO1xuXG5cdFx0Y29uc3QgaGFzQ29udGVudEFmdGVyID0gKGVsOiBFbGVtZW50KTogYm9vbGVhbiA9PiB7XG5cdFx0XHQvLyBDaGVjayBpZiB0aGVyZSdzIGFueSBtZWFuaW5nZnVsIGNvbnRlbnQgYWZ0ZXIgdGhpcyBlbGVtZW50XG5cdFx0XHRsZXQgbmV4dENvbnRlbnQgPSAnJztcblx0XHRcdGxldCBzaWJsaW5nID0gZWwubmV4dFNpYmxpbmc7XG5cblx0XHRcdC8vIEZpcnN0IGNoZWNrIGRpcmVjdCBzaWJsaW5nc1xuXHRcdFx0d2hpbGUgKHNpYmxpbmcpIHtcblx0XHRcdFx0aWYgKHNpYmxpbmcubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG5cdFx0XHRcdFx0bmV4dENvbnRlbnQgKz0gc2libGluZy50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0fSBlbHNlIGlmIChzaWJsaW5nLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuXHRcdFx0XHRcdC8vIElmIHdlIGZpbmQgYW4gZWxlbWVudCBzaWJsaW5nLCBjaGVjayBpdHMgY29udGVudFxuXHRcdFx0XHRcdG5leHRDb250ZW50ICs9IChzaWJsaW5nIGFzIEVsZW1lbnQpLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB3ZSBmb3VuZCBtZWFuaW5nZnVsIGNvbnRlbnQgYXQgdGhpcyBsZXZlbCwgcmV0dXJuIHRydWVcblx0XHRcdGlmIChuZXh0Q29udGVudC50cmltKCkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vIGNvbnRlbnQgZm91bmQgYXQgdGhpcyBsZXZlbCBhbmQgd2UgaGF2ZSBhIHBhcmVudCxcblx0XHRcdC8vIGNoZWNrIGZvciBjb250ZW50IGFmdGVyIHRoZSBwYXJlbnRcblx0XHRcdGNvbnN0IHBhcmVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gZWxlbWVudCkge1xuXHRcdFx0XHRyZXR1cm4gaGFzQ29udGVudEFmdGVyKHBhcmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdFx0Ly8gUHJvY2VzcyBhbGwgaGVhZGluZ3MgZnJvbSBib3R0b20gdG8gdG9wXG5cdFx0Y29uc3QgaGVhZGluZ3MgPSBBcnJheS5mcm9tKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaDEsIGgyLCBoMywgaDQsIGg1LCBoNicpKVxuXHRcdFx0LnJldmVyc2UoKTtcblxuXHRcdGhlYWRpbmdzLmZvckVhY2goaGVhZGluZyA9PiB7XG5cdFx0XHRpZiAoIWhhc0NvbnRlbnRBZnRlcihoZWFkaW5nKSkge1xuXHRcdFx0XHRoZWFkaW5nLnJlbW92ZSgpO1xuXHRcdFx0XHRyZW1vdmVkQ291bnQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFN0b3AgcHJvY2Vzc2luZyBvbmNlIHdlIGZpbmQgYSBoZWFkaW5nIHdpdGggY29udGVudCBhZnRlciBpdFxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAocmVtb3ZlZENvdW50ID4gMCkge1xuXHRcdFx0dGhpcy5fbG9nKCdSZW1vdmVkIHRyYWlsaW5nIGhlYWRpbmdzOicsIHJlbW92ZWRDb3VudCk7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSBoYW5kbGVIZWFkaW5ncyhlbGVtZW50OiBFbGVtZW50LCB0aXRsZTogc3RyaW5nKSB7XG5cdFx0Y29uc3QgaDFzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDEnKTtcblxuXHRcdEFycmF5LmZyb20oaDFzKS5mb3JFYWNoKGgxID0+IHtcblx0XHRcdGNvbnN0IGgyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcblx0XHRcdGgyLmlubmVySFRNTCA9IGgxLmlubmVySFRNTDtcblx0XHRcdC8vIENvcHkgYWxsb3dlZCBhdHRyaWJ1dGVzXG5cdFx0XHRBcnJheS5mcm9tKGgxLmF0dHJpYnV0ZXMpLmZvckVhY2goYXR0ciA9PiB7XG5cdFx0XHRcdGlmIChBTExPV0VEX0FUVFJJQlVURVMuaGFzKGF0dHIubmFtZSkpIHtcblx0XHRcdFx0XHRoMi5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRoMS5wYXJlbnROb2RlPy5yZXBsYWNlQ2hpbGQoaDIsIGgxKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlbW92ZSBmaXJzdCBIMiBpZiBpdCBtYXRjaGVzIHRpdGxlXG5cdFx0Y29uc3QgaDJzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDInKTtcblx0XHRpZiAoaDJzLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnN0IGZpcnN0SDIgPSBoMnNbMF07XG5cdFx0XHRjb25zdCBmaXJzdEgyVGV4dCA9IGZpcnN0SDIudGV4dENvbnRlbnQ/LnRyaW0oKS50b0xvd2VyQ2FzZSgpIHx8ICcnO1xuXHRcdFx0Y29uc3Qgbm9ybWFsaXplZFRpdGxlID0gdGl0bGUudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cdFx0XHRpZiAobm9ybWFsaXplZFRpdGxlICYmIG5vcm1hbGl6ZWRUaXRsZSA9PT0gZmlyc3RIMlRleHQpIHtcblx0XHRcdFx0Zmlyc3RIMi5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHJlbW92ZUh0bWxDb21tZW50cyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0Y29uc3QgY29tbWVudHM6IENvbW1lbnRbXSA9IFtdO1xuXHRcdGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG5cdFx0XHRlbGVtZW50LFxuXHRcdFx0Tm9kZUZpbHRlci5TSE9XX0NPTU1FTlQsXG5cdFx0XHRudWxsXG5cdFx0KTtcblxuXHRcdGxldCBub2RlO1xuXHRcdHdoaWxlIChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkpIHtcblx0XHRcdGNvbW1lbnRzLnB1c2gobm9kZSBhcyBDb21tZW50KTtcblx0XHR9XG5cblx0XHRjb21tZW50cy5mb3JFYWNoKGNvbW1lbnQgPT4ge1xuXHRcdFx0Y29tbWVudC5yZW1vdmUoKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2xvZygnUmVtb3ZlZCBIVE1MIGNvbW1lbnRzOicsIGNvbW1lbnRzLmxlbmd0aCk7XG5cdH1cblxuXHRwcml2YXRlIHN0cmlwVW53YW50ZWRBdHRyaWJ1dGVzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgYXR0cmlidXRlQ291bnQgPSAwO1xuXG5cdFx0Y29uc3QgcHJvY2Vzc0VsZW1lbnQgPSAoZWw6IEVsZW1lbnQpID0+IHtcblx0XHRcdC8vIFNraXAgU1ZHIGVsZW1lbnRzIC0gcHJlc2VydmUgYWxsIHRoZWlyIGF0dHJpYnV0ZXNcblx0XHRcdGlmIChlbCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBhdHRyaWJ1dGVzID0gQXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKTtcblx0XHRcdFxuXHRcdFx0YXR0cmlidXRlcy5mb3JFYWNoKGF0dHIgPT4ge1xuXHRcdFx0XHRjb25zdCBhdHRyTmFtZSA9IGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHQvLyBJbiBkZWJ1ZyBtb2RlLCBhbGxvdyBkZWJ1ZyBhdHRyaWJ1dGVzIGFuZCBkYXRhLSBhdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICh0aGlzLmRlYnVnKSB7XG5cdFx0XHRcdFx0aWYgKCFBTExPV0VEX0FUVFJJQlVURVMuaGFzKGF0dHJOYW1lKSAmJiBcblx0XHRcdFx0XHRcdCFBTExPV0VEX0FUVFJJQlVURVNfREVCVUcuaGFzKGF0dHJOYW1lKSAmJiBcblx0XHRcdFx0XHRcdCFhdHRyTmFtZS5zdGFydHNXaXRoKCdkYXRhLScpKSB7XG5cdFx0XHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKTtcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZUNvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEluIG5vcm1hbCBtb2RlLCBvbmx5IGFsbG93IHN0YW5kYXJkIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRpZiAoIUFMTE9XRURfQVRUUklCVVRFUy5oYXMoYXR0ck5hbWUpKSB7XG5cdFx0XHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5uYW1lKTtcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZUNvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0cHJvY2Vzc0VsZW1lbnQoZWxlbWVudCk7XG5cdFx0ZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykuZm9yRWFjaChwcm9jZXNzRWxlbWVudCk7XG5cblx0XHR0aGlzLl9sb2coJ1N0cmlwcGVkIGF0dHJpYnV0ZXM6JywgYXR0cmlidXRlQ291bnQpO1xuXHR9XG5cblx0cHJpdmF0ZSByZW1vdmVFbXB0eUVsZW1lbnRzKGVsZW1lbnQ6IEVsZW1lbnQpIHtcblx0XHRsZXQgcmVtb3ZlZENvdW50ID0gMDtcblx0XHRsZXQgaXRlcmF0aW9ucyA9IDA7XG5cdFx0bGV0IGtlZXBSZW1vdmluZyA9IHRydWU7XG5cblx0XHR3aGlsZSAoa2VlcFJlbW92aW5nKSB7XG5cdFx0XHRpdGVyYXRpb25zKys7XG5cdFx0XHRrZWVwUmVtb3ZpbmcgPSBmYWxzZTtcblx0XHRcdC8vIEdldCBhbGwgZWxlbWVudHMgd2l0aG91dCBjaGlsZHJlbiwgd29ya2luZyBmcm9tIGRlZXBlc3QgZmlyc3Rcblx0XHRcdGNvbnN0IGVtcHR5RWxlbWVudHMgPSBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKSkuZmlsdGVyKGVsID0+IHtcblx0XHRcdFx0aWYgKEFMTE9XRURfRU1QVFlfRUxFTUVOVFMuaGFzKGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnQgaGFzIG9ubHkgd2hpdGVzcGFjZSBvciAmbmJzcDtcblx0XHRcdFx0Y29uc3QgdGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudCB8fCAnJztcblx0XHRcdFx0Y29uc3QgaGFzT25seVdoaXRlc3BhY2UgPSB0ZXh0Q29udGVudC50cmltKCkubGVuZ3RoID09PSAwO1xuXHRcdFx0XHRjb25zdCBoYXNOYnNwID0gdGV4dENvbnRlbnQuaW5jbHVkZXMoJ1xcdTAwQTAnKTsgLy8gVW5pY29kZSBub24tYnJlYWtpbmcgc3BhY2Vcblx0XHRcdFx0XG5cdFx0XHRcdC8vIENoZWNrIGlmIGVsZW1lbnQgaGFzIG5vIG1lYW5pbmdmdWwgY2hpbGRyZW5cblx0XHRcdFx0Y29uc3QgaGFzTm9DaGlsZHJlbiA9ICFlbC5oYXNDaGlsZE5vZGVzKCkgfHwgXG5cdFx0XHRcdFx0KEFycmF5LmZyb20oZWwuY2hpbGROb2RlcykuZXZlcnkobm9kZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgbm9kZVRleHQgPSBub2RlLnRleHRDb250ZW50IHx8ICcnO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbm9kZVRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCAmJiAhbm9kZVRleHQuaW5jbHVkZXMoJ1xcdTAwQTAnKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9KSk7XG5cblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlOiBDaGVjayBmb3IgZGl2cyB0aGF0IG9ubHkgY29udGFpbiBzcGFucyB3aXRoIGNvbW1hc1xuXHRcdFx0XHRpZiAoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnZGl2Jykge1xuXHRcdFx0XHRcdGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbik7XG5cdFx0XHRcdFx0Y29uc3QgaGFzT25seUNvbW1hU3BhbnMgPSBjaGlsZHJlbi5sZW5ndGggPiAwICYmIGNoaWxkcmVuLmV2ZXJ5KGNoaWxkID0+IHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdzcGFuJykgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGNoaWxkLnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY29udGVudCA9PT0gJywnIHx8IGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICcgJztcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoaGFzT25seUNvbW1hU3BhbnMpIHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGhhc09ubHlXaGl0ZXNwYWNlICYmICFoYXNOYnNwICYmIGhhc05vQ2hpbGRyZW47XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKGVtcHR5RWxlbWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRlbXB0eUVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0XHRcdGVsLnJlbW92ZSgpO1xuXHRcdFx0XHRcdHJlbW92ZWRDb3VudCsrO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0a2VlcFJlbW92aW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9sb2coJ1JlbW92ZWQgZW1wdHkgZWxlbWVudHM6Jywge1xuXHRcdFx0Y291bnQ6IHJlbW92ZWRDb3VudCxcblx0XHRcdGl0ZXJhdGlvbnNcblx0XHR9KTtcblx0fVxuXG5cdHByaXZhdGUgY3JlYXRlRm9vdG5vdGVJdGVtKFxuXHRcdGZvb3Rub3RlTnVtYmVyOiBudW1iZXIsXG5cdFx0Y29udGVudDogc3RyaW5nIHwgRWxlbWVudCxcblx0XHRyZWZzOiBzdHJpbmdbXVxuXHQpOiBIVE1MTElFbGVtZW50IHtcblx0XHRjb25zdCBuZXdJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcblx0XHRuZXdJdGVtLmNsYXNzTmFtZSA9ICdmb290bm90ZSc7XG5cdFx0bmV3SXRlbS5pZCA9IGBmbjoke2Zvb3Rub3RlTnVtYmVyfWA7XG5cblx0XHQvLyBIYW5kbGUgY29udGVudFxuXHRcdGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdGNvbnN0IHBhcmFncmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcblx0XHRcdHBhcmFncmFwaC5pbm5lckhUTUwgPSBjb250ZW50O1xuXHRcdFx0bmV3SXRlbS5hcHBlbmRDaGlsZChwYXJhZ3JhcGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBHZXQgYWxsIHBhcmFncmFwaHMgZnJvbSB0aGUgY29udGVudFxuXHRcdFx0Y29uc3QgcGFyYWdyYXBocyA9IEFycmF5LmZyb20oY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdwJykpO1xuXHRcdFx0aWYgKHBhcmFncmFwaHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdC8vIElmIG5vIHBhcmFncmFwaHMsIHdyYXAgY29udGVudCBpbiBhIHBhcmFncmFwaFxuXHRcdFx0XHRjb25zdCBwYXJhZ3JhcGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG5cdFx0XHRcdHBhcmFncmFwaC5pbm5lckhUTUwgPSBjb250ZW50LmlubmVySFRNTDtcblx0XHRcdFx0bmV3SXRlbS5hcHBlbmRDaGlsZChwYXJhZ3JhcGgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gQ29weSBleGlzdGluZyBwYXJhZ3JhcGhzXG5cdFx0XHRcdHBhcmFncmFwaHMuZm9yRWFjaChwID0+IHtcblx0XHRcdFx0XHRjb25zdCBuZXdQID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuXHRcdFx0XHRcdG5ld1AuaW5uZXJIVE1MID0gcC5pbm5lckhUTUw7XG5cdFx0XHRcdFx0bmV3SXRlbS5hcHBlbmRDaGlsZChuZXdQKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIGJhY2tsaW5rKHMpIHRvIHRoZSBsYXN0IHBhcmFncmFwaFxuXHRcdGNvbnN0IGxhc3RQYXJhZ3JhcGggPSBuZXdJdGVtLnF1ZXJ5U2VsZWN0b3IoJ3A6bGFzdC1vZi10eXBlJykgfHwgbmV3SXRlbTtcblx0XHRyZWZzLmZvckVhY2goKHJlZklkLCBpbmRleCkgPT4ge1xuXHRcdFx0Y29uc3QgYmFja2xpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0XHRiYWNrbGluay5ocmVmID0gYCMke3JlZklkfWA7XG5cdFx0XHRiYWNrbGluay50aXRsZSA9ICdyZXR1cm4gdG8gYXJ0aWNsZSc7XG5cdFx0XHRiYWNrbGluay5jbGFzc05hbWUgPSAnZm9vdG5vdGUtYmFja3JlZic7XG5cdFx0XHRiYWNrbGluay5pbm5lckhUTUwgPSAn4oapJztcblx0XHRcdGlmIChpbmRleCA8IHJlZnMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRiYWNrbGluay5pbm5lckhUTUwgKz0gJyAnO1xuXHRcdFx0fVxuXHRcdFx0bGFzdFBhcmFncmFwaC5hcHBlbmRDaGlsZChiYWNrbGluayk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gbmV3SXRlbTtcblx0fVxuXG5cdHByaXZhdGUgY29sbGVjdEZvb3Rub3RlcyhlbGVtZW50OiBFbGVtZW50KTogRm9vdG5vdGVDb2xsZWN0aW9uIHtcblx0XHRjb25zdCBmb290bm90ZXM6IEZvb3Rub3RlQ29sbGVjdGlvbiA9IHt9O1xuXHRcdGxldCBmb290bm90ZUNvdW50ID0gMTtcblx0XHRjb25zdCBwcm9jZXNzZWRJZHMgPSBuZXcgU2V0PHN0cmluZz4oKTsgLy8gVHJhY2sgcHJvY2Vzc2VkIElEc1xuXG5cdFx0Ly8gQ29sbGVjdCBhbGwgZm9vdG5vdGVzIGFuZCB0aGVpciBJRHMgZnJvbSBmb290bm90ZSBsaXN0c1xuXHRcdGNvbnN0IGZvb3Rub3RlTGlzdHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMpO1xuXHRcdGZvb3Rub3RlTGlzdHMuZm9yRWFjaChsaXN0ID0+IHtcblx0XHRcdC8vIFN1YnN0YWNrIGhhcyBpbmRpdmlkdWFsIGZvb3Rub3RlIGRpdnMgd2l0aCBubyBwYXJlbnRcblx0XHRcdGlmIChsaXN0Lm1hdGNoZXMoJ2Rpdi5mb290bm90ZVtkYXRhLWNvbXBvbmVudC1uYW1lPVwiRm9vdG5vdGVUb0RPTVwiXScpKSB7XG5cdFx0XHRcdGNvbnN0IGFuY2hvciA9IGxpc3QucXVlcnlTZWxlY3RvcignYS5mb290bm90ZS1udW1iZXInKTtcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGxpc3QucXVlcnlTZWxlY3RvcignLmZvb3Rub3RlLWNvbnRlbnQnKTtcblx0XHRcdFx0aWYgKGFuY2hvciAmJiBjb250ZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgaWQgPSBhbmNob3IuaWQucmVwbGFjZSgnZm9vdG5vdGUtJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKGlkICYmICFwcm9jZXNzZWRJZHMuaGFzKGlkKSkge1xuXHRcdFx0XHRcdFx0Zm9vdG5vdGVzW2Zvb3Rub3RlQ291bnRdID0ge1xuXHRcdFx0XHRcdFx0XHRjb250ZW50OiBjb250ZW50LFxuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbElkOiBpZCxcblx0XHRcdFx0XHRcdFx0cmVmczogW11cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRwcm9jZXNzZWRJZHMuYWRkKGlkKTtcblx0XHRcdFx0XHRcdGZvb3Rub3RlQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21tb24gZm9ybWF0IHVzaW5nIE9ML1VMIGFuZCBMSSBlbGVtZW50c1xuXHRcdFx0Y29uc3QgaXRlbXMgPSBsaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpLCBkaXZbcm9sZT1cImxpc3RpdGVtXCJdJyk7XG5cdFx0XHRpdGVtcy5mb3JFYWNoKGxpID0+IHtcblx0XHRcdFx0bGV0IGlkID0gJyc7XG5cdFx0XHRcdGxldCBjb250ZW50OiBFbGVtZW50IHwgbnVsbCA9IG51bGw7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIGNpdGF0aW9ucyB3aXRoIC5jaXRhdGlvbnMgY2xhc3Ncblx0XHRcdFx0Y29uc3QgY2l0YXRpb25zRGl2ID0gbGkucXVlcnlTZWxlY3RvcignLmNpdGF0aW9ucycpO1xuXHRcdFx0XHRpZiAoY2l0YXRpb25zRGl2Py5pZD8udG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdyJykpIHtcblx0XHRcdFx0XHRpZCA9IGNpdGF0aW9uc0Rpdi5pZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdC8vIExvb2sgZm9yIGNpdGF0aW9uIGNvbnRlbnQgd2l0aGluIHRoZSBjaXRhdGlvbnMgZGl2XG5cdFx0XHRcdFx0Y29uc3QgY2l0YXRpb25Db250ZW50ID0gY2l0YXRpb25zRGl2LnF1ZXJ5U2VsZWN0b3IoJy5jaXRhdGlvbi1jb250ZW50Jyk7XG5cdFx0XHRcdFx0aWYgKGNpdGF0aW9uQ29udGVudCkge1xuXHRcdFx0XHRcdFx0Y29udGVudCA9IGNpdGF0aW9uQ29udGVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gRXh0cmFjdCBJRCBmcm9tIHZhcmlvdXMgZm9ybWF0c1xuXHRcdFx0XHRcdGlmIChsaS5pZC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2JpYi5iaWInKSkge1xuXHRcdFx0XHRcdFx0aWQgPSBsaS5pZC5yZXBsYWNlKCdiaWIuYmliJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChsaS5pZC50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2ZuOicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmlkLnJlcGxhY2UoJ2ZuOicsICcnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGkuaWQudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKCdmbicpKSB7XG5cdFx0XHRcdFx0XHRpZCA9IGxpLmlkLnJlcGxhY2UoJ2ZuJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0Ly8gTmF0dXJlLmNvbVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobGkuaGFzQXR0cmlidXRlKCdkYXRhLWNvdW50ZXInKSkge1xuXHRcdFx0XHRcdFx0aWQgPSBsaS5nZXRBdHRyaWJ1dGUoJ2RhdGEtY291bnRlcicpPy5yZXBsYWNlKC9cXC4kLywgJycpPy50b0xvd2VyQ2FzZSgpIHx8ICcnO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGxpLmlkLnNwbGl0KCcvJykucG9wKCk/Lm1hdGNoKC9jaXRlX25vdGUtKC4rKS8pO1xuXHRcdFx0XHRcdFx0aWQgPSBtYXRjaCA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiBsaS5pZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZW50ID0gbGk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoaWQgJiYgIXByb2Nlc3NlZElkcy5oYXMoaWQpKSB7XG5cdFx0XHRcdFx0Zm9vdG5vdGVzW2Zvb3Rub3RlQ291bnRdID0ge1xuXHRcdFx0XHRcdFx0Y29udGVudDogY29udGVudCB8fCBsaSxcblx0XHRcdFx0XHRcdG9yaWdpbmFsSWQ6IGlkLFxuXHRcdFx0XHRcdFx0cmVmczogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHByb2Nlc3NlZElkcy5hZGQoaWQpO1xuXHRcdFx0XHRcdGZvb3Rub3RlQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gZm9vdG5vdGVzO1xuXHR9XG5cblx0cHJpdmF0ZSBmaW5kT3V0ZXJGb290bm90ZUNvbnRhaW5lcihlbDogRWxlbWVudCk6IEVsZW1lbnQge1xuXHRcdGxldCBjdXJyZW50OiBFbGVtZW50IHwgbnVsbCA9IGVsO1xuXHRcdGxldCBwYXJlbnQ6IEVsZW1lbnQgfCBudWxsID0gZWwucGFyZW50RWxlbWVudDtcblx0XHRcblx0XHQvLyBLZWVwIGdvaW5nIHVwIHVudGlsIHdlIGZpbmQgYW4gZWxlbWVudCB0aGF0J3Mgbm90IGEgc3BhbiBvciBzdXBcblx0XHR3aGlsZSAocGFyZW50ICYmIChcblx0XHRcdHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzcGFuJyB8fCBcblx0XHRcdHBhcmVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdXAnXG5cdFx0KSkge1xuXHRcdFx0Y3VycmVudCA9IHBhcmVudDtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gY3VycmVudDtcblx0fVxuXG5cdC8vIEV2ZXJ5IGZvb3Rub3RlIHJlZmVyZW5jZSBzaG91bGQgYmUgYSBzdXAgZWxlbWVudCB3aXRoIGFuIGFuY2hvciBpbnNpZGVcblx0Ly8gZS5nLiA8c3VwIGlkPVwiZm5yZWY6MVwiPjxhIGhyZWY9XCIjZm46MVwiPjE8L2E+PC9zdXA+XG5cdHByaXZhdGUgY3JlYXRlRm9vdG5vdGVSZWZlcmVuY2UoZm9vdG5vdGVOdW1iZXI6IHN0cmluZywgcmVmSWQ6IHN0cmluZyk6IEhUTUxFbGVtZW50IHtcblx0XHRjb25zdCBzdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdXAnKTtcblx0XHRzdXAuaWQgPSByZWZJZDtcblx0XHRjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdGxpbmsuaHJlZiA9IGAjZm46JHtmb290bm90ZU51bWJlcn1gO1xuXHRcdGxpbmsudGV4dENvbnRlbnQgPSBmb290bm90ZU51bWJlcjtcblx0XHRzdXAuYXBwZW5kQ2hpbGQobGluayk7XG5cdFx0cmV0dXJuIHN1cDtcblx0fVxuXG5cdHByaXZhdGUgc3RhbmRhcmRpemVGb290bm90ZXMoZWxlbWVudDogRWxlbWVudCkge1xuXHRcdGNvbnN0IGZvb3Rub3RlcyA9IHRoaXMuY29sbGVjdEZvb3Rub3RlcyhlbGVtZW50KTtcblxuXHRcdC8vIFN0YW5kYXJkaXplIGlubGluZSBmb290bm90ZXMgdXNpbmcgdGhlIGNvbGxlY3RlZCBJRHNcblx0XHRjb25zdCBmb290bm90ZUlubGluZVJlZmVyZW5jZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoRk9PVE5PVEVfSU5MSU5FX1JFRkVSRU5DRVMpO1xuXHRcdFxuXHRcdC8vIEdyb3VwIHJlZmVyZW5jZXMgYnkgdGhlaXIgcGFyZW50IHN1cCBlbGVtZW50XG5cdFx0Y29uc3Qgc3VwR3JvdXBzID0gbmV3IE1hcDxFbGVtZW50LCBFbGVtZW50W10+KCk7XG5cdFx0XG5cdFx0Zm9vdG5vdGVJbmxpbmVSZWZlcmVuY2VzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0aWYgKCEoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybjtcblxuXHRcdFx0bGV0IGZvb3Rub3RlSWQgPSAnJztcblx0XHRcdGxldCBmb290bm90ZUNvbnRlbnQgPSAnJztcblxuXHRcdFx0Ly8gRXh0cmFjdCBmb290bm90ZSBJRCBiYXNlZCBvbiBlbGVtZW50IHR5cGVcblx0XHRcdC8vIE5hdHVyZS5jb21cblx0XHRcdGlmIChlbC5tYXRjaGVzKCdhW2lkXj1cInJlZi1saW5rXCJdJykpIHtcblx0XHRcdFx0Zm9vdG5vdGVJZCA9IGVsLnRleHRDb250ZW50Py50cmltKCkgfHwgJyc7XG5cdFx0XHQvLyBTY2llbmNlLm9yZ1xuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdhW3JvbGU9XCJkb2MtYmlibGlvcmVmXCJdJykpIHtcblx0XHRcdFx0Y29uc3QgeG1sUmlkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXhtbC1yaWQnKTtcblx0XHRcdFx0aWYgKHhtbFJpZCkge1xuXHRcdFx0XHRcdGZvb3Rub3RlSWQgPSB4bWxSaWQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3QgaHJlZiA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRcdGlmIChocmVmPy5zdGFydHNXaXRoKCcjY29yZS1SJykpIHtcblx0XHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBocmVmLnJlcGxhY2UoJyNjb3JlLScsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdC8vIFN1YnN0YWNrXG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2EuZm9vdG5vdGUtYW5jaG9yLCBzcGFuLmZvb3Rub3RlLWhvdmVyY2FyZC10YXJnZXQgYScpKSB7XG5cdFx0XHRcdGNvbnN0IGlkID0gZWwuaWQ/LnJlcGxhY2UoJ2Zvb3Rub3RlLWFuY2hvci0nLCAnJykgfHwgJyc7XG5cdFx0XHRcdGlmIChpZCkge1xuXHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHQvLyBBcnhpdlxuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdjaXRlLmx0eF9jaXRlJykpIHtcblx0XHRcdFx0Y29uc3QgbGluayA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2EnKTtcblx0XHRcdFx0aWYgKGxpbmspIHtcblx0XHRcdFx0XHRjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblx0XHRcdFx0XHRpZiAoaHJlZikge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBocmVmLnNwbGl0KCcvJykucG9wKCk/Lm1hdGNoKC9iaWJcXC5iaWIoXFxkKykvKTtcblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRmb290bm90ZUlkID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZWwubWF0Y2hlcygnc3VwLnJlZmVyZW5jZScpKSB7XG5cdFx0XHRcdGNvbnN0IGxpbmtzID0gZWwucXVlcnlTZWxlY3RvckFsbCgnYScpO1xuXHRcdFx0XHRBcnJheS5mcm9tKGxpbmtzKS5mb3JFYWNoKGxpbmsgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGhyZWYgPSBsaW5rLmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuXHRcdFx0XHRcdGlmIChocmVmKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IGhyZWYuc3BsaXQoJy8nKS5wb3AoKT8ubWF0Y2goLyg/OmNpdGVfbm90ZXxjaXRlX3JlZiktKC4rKS8pO1xuXHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGZvb3Rub3RlSWQgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3N1cFtpZF49XCJmbnJlZjpcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuaWQucmVwbGFjZSgnZm5yZWY6JywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3N1cFtpZF49XCJmbnJcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuaWQucmVwbGFjZSgnZm5yJywgJycpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ3NwYW4uZm9vdG5vdGUtcmVmZXJlbmNlJykpIHtcblx0XHRcdFx0Zm9vdG5vdGVJZCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1mb290bm90ZS1pZCcpIHx8ICcnO1xuXHRcdFx0fSBlbHNlIGlmIChlbC5tYXRjaGVzKCdzcGFuLmZvb3Rub3RlLWxpbmsnKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLWZvb3Rub3RlLWlkJykgfHwgJyc7XG5cdFx0XHRcdGZvb3Rub3RlQ29udGVudCA9IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1mb290bm90ZS1jb250ZW50JykgfHwgJyc7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2EuY2l0YXRpb24nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwudGV4dENvbnRlbnQ/LnRyaW0oKSB8fCAnJztcblx0XHRcdFx0Zm9vdG5vdGVDb250ZW50ID0gZWwuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJyc7XG5cdFx0XHR9IGVsc2UgaWYgKGVsLm1hdGNoZXMoJ2FbaWRePVwiZm5yZWZcIl0nKSkge1xuXHRcdFx0XHRmb290bm90ZUlkID0gZWwuaWQucmVwbGFjZSgnZm5yZWYnLCAnJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE90aGVyIGNpdGF0aW9uIHR5cGVzXG5cdFx0XHRcdGNvbnN0IGhyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcblx0XHRcdFx0aWYgKGhyZWYpIHtcblx0XHRcdFx0XHRjb25zdCBpZCA9IGhyZWYucmVwbGFjZSgvXlsjXS8sICcnKTtcblx0XHRcdFx0XHRmb290bm90ZUlkID0gaWQudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZm9vdG5vdGVJZCkge1xuXHRcdFx0XHQvLyBGaW5kIHRoZSBmb290bm90ZSBudW1iZXIgYnkgbWF0Y2hpbmcgdGhlIG9yaWdpbmFsIElEXG5cdFx0XHRcdGNvbnN0IGZvb3Rub3RlRW50cnkgPSBPYmplY3QuZW50cmllcyhmb290bm90ZXMpLmZpbmQoXG5cdFx0XHRcdFx0KFtfLCBkYXRhXSkgPT4gZGF0YS5vcmlnaW5hbElkID09PSBmb290bm90ZUlkLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoZm9vdG5vdGVFbnRyeSkge1xuXHRcdFx0XHRcdGNvbnN0IFtmb290bm90ZU51bWJlciwgZm9vdG5vdGVEYXRhXSA9IGZvb3Rub3RlRW50cnk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGZvb3Rub3RlIHJlZmVyZW5jZSBJRFxuXHRcdFx0XHRcdGNvbnN0IHJlZklkID0gZm9vdG5vdGVEYXRhLnJlZnMubGVuZ3RoID4gMCA/IFxuXHRcdFx0XHRcdFx0YGZucmVmOiR7Zm9vdG5vdGVOdW1iZXJ9LSR7Zm9vdG5vdGVEYXRhLnJlZnMubGVuZ3RoICsgMX1gIDogXG5cdFx0XHRcdFx0XHRgZm5yZWY6JHtmb290bm90ZU51bWJlcn1gO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGZvb3Rub3RlRGF0YS5yZWZzLnB1c2gocmVmSWQpO1xuXG5cdFx0XHRcdFx0Ly8gRmluZCB0aGUgb3V0ZXJtb3N0IGNvbnRhaW5lciAoc3BhbiBvciBzdXApXG5cdFx0XHRcdFx0Y29uc3QgY29udGFpbmVyID0gdGhpcy5maW5kT3V0ZXJGb290bm90ZUNvbnRhaW5lcihlbCk7XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Ly8gSWYgY29udGFpbmVyIGlzIGEgc3VwLCBncm91cCByZWZlcmVuY2VzXG5cdFx0XHRcdFx0aWYgKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdXAnKSB7XG5cdFx0XHRcdFx0XHRpZiAoIXN1cEdyb3Vwcy5oYXMoY29udGFpbmVyKSkge1xuXHRcdFx0XHRcdFx0XHRzdXBHcm91cHMuc2V0KGNvbnRhaW5lciwgW10pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29uc3QgZ3JvdXAgPSBzdXBHcm91cHMuZ2V0KGNvbnRhaW5lcikhO1xuXHRcdFx0XHRcdFx0Z3JvdXAucHVzaCh0aGlzLmNyZWF0ZUZvb3Rub3RlUmVmZXJlbmNlKGZvb3Rub3RlTnVtYmVyLCByZWZJZCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBSZXBsYWNlIHRoZSBjb250YWluZXIgZGlyZWN0bHlcblx0XHRcdFx0XHRcdGNvbnRhaW5lci5yZXBsYWNlV2l0aCh0aGlzLmNyZWF0ZUZvb3Rub3RlUmVmZXJlbmNlKGZvb3Rub3RlTnVtYmVyLCByZWZJZCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gSGFuZGxlIGdyb3VwZWQgcmVmZXJlbmNlc1xuXHRcdHN1cEdyb3Vwcy5mb3JFYWNoKChyZWZlcmVuY2VzLCBjb250YWluZXIpID0+IHtcblx0XHRcdGlmIChyZWZlcmVuY2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gQ3JlYXRlIGEgZG9jdW1lbnQgZnJhZ21lbnQgdG8gaG9sZCBhbGwgdGhlIHJlZmVyZW5jZXNcblx0XHRcdFx0Y29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgZWFjaCByZWZlcmVuY2UgYXMgaXRzIG93biBzdXAgZWxlbWVudFxuXHRcdFx0XHRyZWZlcmVuY2VzLmZvckVhY2goKHJlZiwgaW5kZXgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBsaW5rID0gcmVmLnF1ZXJ5U2VsZWN0b3IoJ2EnKTtcblx0XHRcdFx0XHRpZiAobGluaykge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3VwJyk7XG5cdFx0XHRcdFx0XHRzdXAuaWQgPSByZWYuaWQ7XG5cdFx0XHRcdFx0XHRzdXAuYXBwZW5kQ2hpbGQobGluay5jbG9uZU5vZGUodHJ1ZSkpO1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3VwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29udGFpbmVyLnJlcGxhY2VXaXRoKGZyYWdtZW50KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIENyZWF0ZSB0aGUgc3RhbmRhcmRpemVkIGZvb3Rub3RlIGxpc3Rcblx0XHRjb25zdCBuZXdMaXN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9vdG5vdGVzJyk7XG5cdFx0bmV3TGlzdC5jbGFzc05hbWUgPSAnZm9vdG5vdGVzJztcblx0XHRjb25zdCBvcmRlcmVkTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyk7XG5cblx0XHQvLyBDcmVhdGUgZm9vdG5vdGUgaXRlbXMgaW4gb3JkZXJcblx0XHRPYmplY3QuZW50cmllcyhmb290bm90ZXMpLmZvckVhY2goKFtudW1iZXIsIGRhdGFdKSA9PiB7XG5cdFx0XHRjb25zdCBuZXdJdGVtID0gdGhpcy5jcmVhdGVGb290bm90ZUl0ZW0oXG5cdFx0XHRcdHBhcnNlSW50KG51bWJlciksXG5cdFx0XHRcdGRhdGEuY29udGVudCxcblx0XHRcdFx0ZGF0YS5yZWZzXG5cdFx0XHQpO1xuXHRcdFx0b3JkZXJlZExpc3QuYXBwZW5kQ2hpbGQobmV3SXRlbSk7XG5cdFx0fSk7XG5cblx0XHQvLyBSZW1vdmUgb3JpZ2luYWwgZm9vdG5vdGUgbGlzdHNcblx0XHRjb25zdCBmb290bm90ZUxpc3RzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKEZPT1ROT1RFX0xJU1RfU0VMRUNUT1JTKTtcblx0XHRmb290bm90ZUxpc3RzLmZvckVhY2gobGlzdCA9PiBsaXN0LnJlbW92ZSgpKTtcblxuXHRcdC8vIElmIHdlIGhhdmUgYW55IGZvb3Rub3RlcywgYWRkIHRoZSBuZXcgbGlzdCB0byB0aGUgZG9jdW1lbnRcblx0XHRpZiAob3JkZXJlZExpc3QuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0bmV3TGlzdC5hcHBlbmRDaGlsZChvcmRlcmVkTGlzdCk7XG5cdFx0XHRlbGVtZW50LmFwcGVuZENoaWxkKG5ld0xpc3QpO1xuXHRcdH1cblx0fVxuXG5cdHByaXZhdGUgaGFuZGxlTGF6eUltYWdlcyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblx0XHRjb25zdCBsYXp5SW1hZ2VzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbWdbZGF0YS1zcmNdLCBpbWdbZGF0YS1zcmNzZXRdJyk7XG5cblx0XHRsYXp5SW1hZ2VzLmZvckVhY2goaW1nID0+IHtcblx0XHRcdGlmICghKGltZyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpKSByZXR1cm47XG5cblx0XHRcdC8vIEhhbmRsZSBkYXRhLXNyY1xuXHRcdFx0Y29uc3QgZGF0YVNyYyA9IGltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyk7XG5cdFx0XHRpZiAoZGF0YVNyYyAmJiAhaW1nLnNyYykge1xuXHRcdFx0XHRpbWcuc3JjID0gZGF0YVNyYztcblx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIGRhdGEtc3Jjc2V0XG5cdFx0XHRjb25zdCBkYXRhU3Jjc2V0ID0gaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmNzZXQnKTtcblx0XHRcdGlmIChkYXRhU3Jjc2V0ICYmICFpbWcuc3Jjc2V0KSB7XG5cdFx0XHRcdGltZy5zcmNzZXQgPSBkYXRhU3Jjc2V0O1xuXHRcdFx0XHRwcm9jZXNzZWRDb3VudCsrO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgbGF6eSBsb2FkaW5nIHJlbGF0ZWQgY2xhc3NlcyBhbmQgYXR0cmlidXRlc1xuXHRcdFx0aW1nLmNsYXNzTGlzdC5yZW1vdmUoJ2xhenknLCAnbGF6eWxvYWQnKTtcblx0XHRcdGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbGwtc3RhdHVzJyk7XG5cdFx0XHRpbWcucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXNyYycpO1xuXHRcdFx0aW1nLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zcmNzZXQnKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX2xvZygnUHJvY2Vzc2VkIGxhenkgaW1hZ2VzOicsIHByb2Nlc3NlZENvdW50KTtcblx0fVxuXG5cdHByaXZhdGUgc3RhbmRhcmRpemVFbGVtZW50cyhlbGVtZW50OiBFbGVtZW50KSB7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblxuXHRcdC8vIENvbnZlcnQgZWxlbWVudHMgYmFzZWQgb24gc3RhbmRhcmRpemF0aW9uIHJ1bGVzXG5cdFx0RUxFTUVOVF9TVEFOREFSRElaQVRJT05fUlVMRVMuZm9yRWFjaChydWxlID0+IHtcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHJ1bGUuc2VsZWN0b3IpO1xuXHRcdFx0ZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG5cdFx0XHRcdGlmIChydWxlLnRyYW5zZm9ybSkge1xuXHRcdFx0XHRcdC8vIElmIHRoZXJlJ3MgYSB0cmFuc2Zvcm0gZnVuY3Rpb24sIHVzZSBpdCB0byBjcmVhdGUgdGhlIG5ldyBlbGVtZW50XG5cdFx0XHRcdFx0Y29uc3QgdHJhbnNmb3JtZWQgPSBydWxlLnRyYW5zZm9ybShlbCk7XG5cdFx0XHRcdFx0ZWwucmVwbGFjZVdpdGgodHJhbnNmb3JtZWQpO1xuXHRcdFx0XHRcdHByb2Nlc3NlZENvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gQ29udmVydCBsaXRlLXlvdXR1YmUgZWxlbWVudHNcblx0XHRjb25zdCBsaXRlWW91dHViZUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaXRlLXlvdXR1YmUnKTtcblx0XHRsaXRlWW91dHViZUVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuXHRcdFx0Y29uc3QgdmlkZW9JZCA9IGVsLmdldEF0dHJpYnV0ZSgndmlkZW9pZCcpO1xuXHRcdFx0aWYgKCF2aWRlb0lkKSByZXR1cm47XG5cblx0XHRcdGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLndpZHRoID0gJzU2MCc7XG5cdFx0XHRpZnJhbWUuaGVpZ2h0ID0gJzMxNSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkLyR7dmlkZW9JZH1gO1xuXHRcdFx0aWZyYW1lLnRpdGxlID0gZWwuZ2V0QXR0cmlidXRlKCd2aWRlb3RpdGxlJykgfHwgJ1lvdVR1YmUgdmlkZW8gcGxheWVyJztcblx0XHRcdGlmcmFtZS5mcmFtZUJvcmRlciA9ICcwJztcblx0XHRcdGlmcmFtZS5hbGxvdyA9ICdhY2NlbGVyb21ldGVyOyBhdXRvcGxheTsgY2xpcGJvYXJkLXdyaXRlOyBlbmNyeXB0ZWQtbWVkaWE7IGd5cm9zY29wZTsgcGljdHVyZS1pbi1waWN0dXJlOyB3ZWItc2hhcmUnO1xuXHRcdFx0aWZyYW1lLnNldEF0dHJpYnV0ZSgnYWxsb3dmdWxsc2NyZWVuJywgJycpO1xuXG5cdFx0XHRlbC5yZXBsYWNlV2l0aChpZnJhbWUpO1xuXHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHR9KTtcblxuXHRcdC8vIEFkZCBmdXR1cmUgZW1iZWQgY29udmVyc2lvbnMgKFR3aXR0ZXIsIEluc3RhZ3JhbSwgZXRjLilcblxuXHRcdHRoaXMuX2xvZygnQ29udmVydGVkIGVtYmVkZGVkIGVsZW1lbnRzOicsIHByb2Nlc3NlZENvdW50KTtcblx0fVxuXG5cdC8vIEZpbmQgc21hbGwgSU1HIGFuZCBTVkcgZWxlbWVudHNcblx0cHJpdmF0ZSBmaW5kU21hbGxJbWFnZXMoZG9jOiBEb2N1bWVudCk6IFNldDxzdHJpbmc+IHtcblx0XHRjb25zdCBNSU5fRElNRU5TSU9OID0gMzM7XG5cdFx0Y29uc3Qgc21hbGxJbWFnZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblx0XHRjb25zdCB0cmFuc2Zvcm1SZWdleCA9IC9zY2FsZVxcKChbXFxkLl0rKVxcKS87XG5cdFx0Y29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0bGV0IHByb2Nlc3NlZENvdW50ID0gMDtcblxuXHRcdC8vIDEuIFJlYWQgcGhhc2UgLSBHYXRoZXIgYWxsIGVsZW1lbnRzIGluIGEgc2luZ2xlIHBhc3Ncblx0XHRjb25zdCBlbGVtZW50cyA9IFtcblx0XHRcdC4uLkFycmF5LmZyb20oZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSksXG5cdFx0XHQuLi5BcnJheS5mcm9tKGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3ZnJykpXG5cdFx0XS5maWx0ZXIoZWxlbWVudCA9PiB7XG5cdFx0XHQvLyBTa2lwIGxhenktbG9hZGVkIGltYWdlcyB0aGF0IGhhdmVuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0XG5cdFx0XHQvLyBhbmQgbWF0aCBpbWFnZXMgd2hpY2ggbWF5IGJlIHNtYWxsXG5cdFx0XHRpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0Y29uc3QgaWdub3JlZEltYWdlID0gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2xhenknKSB8fCBcblx0XHRcdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnbGF6eWxvYWQnKSB8fFxuXHRcdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdsYXRleCcpIHx8XG5cdFx0XHRcdFx0ZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RlY29kaW5nJykgfHxcblx0XHRcdFx0XHRlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zcmMnKSB8fFxuXHRcdFx0XHRcdGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXNyY3NldCcpO1xuXHRcdFx0XHRyZXR1cm4gIWlnbm9yZWRJbWFnZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0aWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHNtYWxsSW1hZ2VzO1xuXHRcdH1cblxuXHRcdC8vIDIuIEJhdGNoIHByb2Nlc3MgLSBDb2xsZWN0IGFsbCBtZWFzdXJlbWVudHMgaW4gb25lIGdvXG5cdFx0Y29uc3QgbWVhc3VyZW1lbnRzID0gZWxlbWVudHMubWFwKGVsZW1lbnQgPT4gKHtcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHQvLyBTdGF0aWMgYXR0cmlidXRlcyAobm8gcmVmbG93KVxuXHRcdFx0bmF0dXJhbFdpZHRoOiBlbGVtZW50IGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCA/IGVsZW1lbnQubmF0dXJhbFdpZHRoIDogMCxcblx0XHRcdG5hdHVyYWxIZWlnaHQ6IGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50ID8gZWxlbWVudC5uYXR1cmFsSGVpZ2h0IDogMCxcblx0XHRcdGF0dHJXaWR0aDogcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJzAnKSxcblx0XHRcdGF0dHJIZWlnaHQ6IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnMCcpXG5cdFx0fSkpO1xuXG5cdFx0Ly8gMy4gQmF0Y2ggY29tcHV0ZSBzdHlsZXMgLSBQcm9jZXNzIGluIGNodW5rcyB0byBhdm9pZCBsb25nIHRhc2tzXG5cdFx0Y29uc3QgQkFUQ0hfU0laRSA9IDUwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSArPSBCQVRDSF9TSVpFKSB7XG5cdFx0XHRjb25zdCBiYXRjaCA9IG1lYXN1cmVtZW50cy5zbGljZShpLCBpICsgQkFUQ0hfU0laRSk7XG5cdFx0XHRcblx0XHRcdHRyeSB7XG5cdFx0XHRcdC8vIFJlYWQgcGhhc2UgLSBjb21wdXRlIGFsbCBzdHlsZXMgYXQgb25jZVxuXHRcdFx0XHRjb25zdCBzdHlsZXMgPSBiYXRjaC5tYXAoKHsgZWxlbWVudCB9KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSk7XG5cdFx0XHRcdGNvbnN0IHJlY3RzID0gYmF0Y2gubWFwKCh7IGVsZW1lbnQgfSkgPT4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBQcm9jZXNzIHBoYXNlIC0gbm8gRE9NIG9wZXJhdGlvbnNcblx0XHRcdFx0YmF0Y2guZm9yRWFjaCgobWVhc3VyZW1lbnQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNvbnN0IHN0eWxlID0gc3R5bGVzW2luZGV4XTtcblx0XHRcdFx0XHRcdGNvbnN0IHJlY3QgPSByZWN0c1tpbmRleF07XG5cdFx0XHRcdFx0XHRcblx0XHRcdFx0XHRcdC8vIEdldCB0cmFuc2Zvcm0gc2NhbGUgaW4gdGhlIHNhbWUgYmF0Y2hcblx0XHRcdFx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybTtcblx0XHRcdFx0XHRcdGNvbnN0IHNjYWxlID0gdHJhbnNmb3JtID8gXG5cdFx0XHRcdFx0XHRcdHBhcnNlRmxvYXQodHJhbnNmb3JtLm1hdGNoKHRyYW5zZm9ybVJlZ2V4KT8uWzFdIHx8ICcxJykgOiAxO1xuXG5cdFx0XHRcdFx0XHQvLyBDYWxjdWxhdGUgZWZmZWN0aXZlIGRpbWVuc2lvbnNcblx0XHRcdFx0XHRcdGNvbnN0IHdpZHRocyA9IFtcblx0XHRcdFx0XHRcdFx0bWVhc3VyZW1lbnQubmF0dXJhbFdpZHRoLFxuXHRcdFx0XHRcdFx0XHRtZWFzdXJlbWVudC5hdHRyV2lkdGgsXG5cdFx0XHRcdFx0XHRcdHBhcnNlSW50KHN0eWxlLndpZHRoKSB8fCAwLFxuXHRcdFx0XHRcdFx0XHRyZWN0LndpZHRoICogc2NhbGVcblx0XHRcdFx0XHRcdF0uZmlsdGVyKGRpbSA9PiB0eXBlb2YgZGltID09PSAnbnVtYmVyJyAmJiBkaW0gPiAwKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaGVpZ2h0cyA9IFtcblx0XHRcdFx0XHRcdFx0bWVhc3VyZW1lbnQubmF0dXJhbEhlaWdodCxcblx0XHRcdFx0XHRcdFx0bWVhc3VyZW1lbnQuYXR0ckhlaWdodCxcblx0XHRcdFx0XHRcdFx0cGFyc2VJbnQoc3R5bGUuaGVpZ2h0KSB8fCAwLFxuXHRcdFx0XHRcdFx0XHRyZWN0LmhlaWdodCAqIHNjYWxlXG5cdFx0XHRcdFx0XHRdLmZpbHRlcihkaW0gPT4gdHlwZW9mIGRpbSA9PT0gJ251bWJlcicgJiYgZGltID4gMCk7XG5cblx0XHRcdFx0XHRcdC8vIERlY2lzaW9uIHBoYXNlIC0gbm8gRE9NIG9wZXJhdGlvbnNcblx0XHRcdFx0XHRcdGlmICh3aWR0aHMubGVuZ3RoID4gMCAmJiBoZWlnaHRzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZWZmZWN0aXZlV2lkdGggPSBNYXRoLm1pbiguLi53aWR0aHMpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBlZmZlY3RpdmVIZWlnaHQgPSBNYXRoLm1pbiguLi5oZWlnaHRzKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoZWZmZWN0aXZlV2lkdGggPCBNSU5fRElNRU5TSU9OIHx8IGVmZmVjdGl2ZUhlaWdodCA8IE1JTl9ESU1FTlNJT04pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBpZGVudGlmaWVyID0gdGhpcy5nZXRFbGVtZW50SWRlbnRpZmllcihtZWFzdXJlbWVudC5lbGVtZW50KTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaWRlbnRpZmllcikge1xuXHRcdFx0XHRcdFx0XHRcdFx0c21hbGxJbWFnZXMuYWRkKGlkZW50aWZpZXIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzc2VkQ291bnQrKztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5kZWJ1Zykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0RlZnVkZGxlOiBGYWlsZWQgdG8gcHJvY2VzcyBlbGVtZW50IGRpbWVuc2lvbnM6JywgZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0RlZnVkZGxlOiBGYWlsZWQgdG8gcHJvY2VzcyBiYXRjaDonLCBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcblx0XHR0aGlzLl9sb2coJ0ZvdW5kIHNtYWxsIGVsZW1lbnRzOicsIHtcblx0XHRcdGNvdW50OiBwcm9jZXNzZWRDb3VudCxcblx0XHRcdHRvdGFsRWxlbWVudHM6IGVsZW1lbnRzLmxlbmd0aCxcblx0XHRcdHByb2Nlc3NpbmdUaW1lOiBgJHsoZW5kVGltZSAtIHN0YXJ0VGltZSkudG9GaXhlZCgyKX1tc2Bcblx0XHR9KTtcblxuXHRcdHJldHVybiBzbWFsbEltYWdlcztcblx0fVxuXG5cdHByaXZhdGUgcmVtb3ZlU21hbGxJbWFnZXMoZG9jOiBEb2N1bWVudCwgc21hbGxJbWFnZXM6IFNldDxzdHJpbmc+KSB7XG5cdFx0bGV0IHJlbW92ZWRDb3VudCA9IDA7XG5cblx0XHRbJ2ltZycsICdzdmcnXS5mb3JFYWNoKHRhZyA9PiB7XG5cdFx0XHRjb25zdCBlbGVtZW50cyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuXHRcdFx0QXJyYXkuZnJvbShlbGVtZW50cykuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdFx0Y29uc3QgaWRlbnRpZmllciA9IHRoaXMuZ2V0RWxlbWVudElkZW50aWZpZXIoZWxlbWVudCk7XG5cdFx0XHRcdGlmIChpZGVudGlmaWVyICYmIHNtYWxsSW1hZ2VzLmhhcyhpZGVudGlmaWVyKSkge1xuXHRcdFx0XHRcdGVsZW1lbnQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0cmVtb3ZlZENvdW50Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fbG9nKCdSZW1vdmVkIHNtYWxsIGVsZW1lbnRzOicsIHJlbW92ZWRDb3VudCk7XG5cdH1cblxuXHRwcml2YXRlIGdldEVsZW1lbnRJZGVudGlmaWVyKGVsZW1lbnQ6IEVsZW1lbnQpOiBzdHJpbmcgfCBudWxsIHtcblx0XHQvLyBUcnkgdG8gY3JlYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIgdXNpbmcgdmFyaW91cyBhdHRyaWJ1dGVzXG5cdFx0aWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XG5cdFx0XHQvLyBGb3IgbGF6eS1sb2FkZWQgaW1hZ2VzLCB1c2UgZGF0YS1zcmMgYXMgaWRlbnRpZmllciBpZiBhdmFpbGFibGVcblx0XHRcdGNvbnN0IGRhdGFTcmMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblx0XHRcdGlmIChkYXRhU3JjKSByZXR1cm4gYHNyYzoke2RhdGFTcmN9YDtcblx0XHRcdFxuXHRcdFx0Y29uc3Qgc3JjID0gZWxlbWVudC5zcmMgfHwgJyc7XG5cdFx0XHRjb25zdCBzcmNzZXQgPSBlbGVtZW50LnNyY3NldCB8fCAnJztcblx0XHRcdGNvbnN0IGRhdGFTcmNzZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmNzZXQnKTtcblx0XHRcdFxuXHRcdFx0aWYgKHNyYykgcmV0dXJuIGBzcmM6JHtzcmN9YDtcblx0XHRcdGlmIChzcmNzZXQpIHJldHVybiBgc3Jjc2V0OiR7c3Jjc2V0fWA7XG5cdFx0XHRpZiAoZGF0YVNyY3NldCkgcmV0dXJuIGBzcmNzZXQ6JHtkYXRhU3Jjc2V0fWA7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaWQgPSBlbGVtZW50LmlkIHx8ICcnO1xuXHRcdGNvbnN0IGNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lIHx8ICcnO1xuXHRcdGNvbnN0IHZpZXdCb3ggPSBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCA/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJycgOiAnJztcblx0XHRcblx0XHRpZiAoaWQpIHJldHVybiBgaWQ6JHtpZH1gO1xuXHRcdGlmICh2aWV3Qm94KSByZXR1cm4gYHZpZXdCb3g6JHt2aWV3Qm94fWA7XG5cdFx0aWYgKGNsYXNzTmFtZSkgcmV0dXJuIGBjbGFzczoke2NsYXNzTmFtZX1gO1xuXHRcdFxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cHJpdmF0ZSBmaW5kTWFpbkNvbnRlbnQoZG9jOiBEb2N1bWVudCk6IEVsZW1lbnQgfCBudWxsIHtcblxuXHRcdC8vIEZpbmQgYWxsIHBvdGVudGlhbCBjb250ZW50IGNvbnRhaW5lcnNcblx0XHRjb25zdCBjYW5kaWRhdGVzOiB7IGVsZW1lbnQ6IEVsZW1lbnQ7IHNjb3JlOiBudW1iZXIgfVtdID0gW107XG5cblx0XHRFTlRSWV9QT0lOVF9FTEVNRU5UUy5mb3JFYWNoKChzZWxlY3RvciwgaW5kZXgpID0+IHtcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdFx0ZWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcblx0XHRcdFx0Ly8gQmFzZSBzY29yZSBmcm9tIHNlbGVjdG9yIHByaW9yaXR5IChlYXJsaWVyID0gaGlnaGVyKVxuXHRcdFx0XHRsZXQgc2NvcmUgPSAoRU5UUllfUE9JTlRfRUxFTUVOVFMubGVuZ3RoIC0gaW5kZXgpICogMTA7XG5cdFx0XHRcdFxuXHRcdFx0XHQvLyBBZGQgc2NvcmUgYmFzZWQgb24gY29udGVudCBhbmFseXNpc1xuXHRcdFx0XHRzY29yZSArPSB0aGlzLnNjb3JlRWxlbWVudChlbGVtZW50KTtcblx0XHRcdFx0XG5cdFx0XHRcdGNhbmRpZGF0ZXMucHVzaCh7IGVsZW1lbnQsIHNjb3JlIH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRpZiAoY2FuZGlkYXRlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdC8vIEZhbGwgYmFjayB0byBzY29yaW5nIGJsb2NrIGVsZW1lbnRzXG5cdFx0XHQvLyBDdXJyZW50bHkgPGJvZHk+IGVsZW1lbnQgaXMgdXNlZCBhcyB0aGUgZmFsbGJhY2ssIHNvIHRoaXMgaXMgbm90IHVzZWRcblx0XHRcdHJldHVybiB0aGlzLmZpbmRDb250ZW50QnlTY29yaW5nKGRvYyk7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBieSBzY29yZSBkZXNjZW5kaW5nXG5cdFx0Y2FuZGlkYXRlcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG5cdFx0XG5cdFx0aWYgKHRoaXMuZGVidWcpIHtcblx0XHRcdHRoaXMuX2xvZygnQ29udGVudCBjYW5kaWRhdGVzOicsIGNhbmRpZGF0ZXMubWFwKGMgPT4gKHtcblx0XHRcdFx0ZWxlbWVudDogYy5lbGVtZW50LnRhZ05hbWUsXG5cdFx0XHRcdHNlbGVjdG9yOiB0aGlzLmdldEVsZW1lbnRTZWxlY3RvcihjLmVsZW1lbnQpLFxuXHRcdFx0XHRzY29yZTogYy5zY29yZVxuXHRcdFx0fSkpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2FuZGlkYXRlc1swXS5lbGVtZW50O1xuXHR9XG5cblx0cHJpdmF0ZSBmaW5kQ29udGVudEJ5U2NvcmluZyhkb2M6IERvY3VtZW50KTogRWxlbWVudCB8IG51bGwge1xuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSB0aGlzLnNjb3JlRWxlbWVudHMoZG9jKTtcblx0XHRyZXR1cm4gY2FuZGlkYXRlcy5sZW5ndGggPiAwID8gY2FuZGlkYXRlc1swXS5lbGVtZW50IDogbnVsbDtcblx0fVxuXG5cdHByaXZhdGUgZ2V0RWxlbWVudFNlbGVjdG9yKGVsZW1lbnQ6IEVsZW1lbnQpOiBzdHJpbmcge1xuXHRcdGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdGxldCBjdXJyZW50OiBFbGVtZW50IHwgbnVsbCA9IGVsZW1lbnQ7XG5cdFx0XG5cdFx0d2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gdGhpcy5kb2MuZG9jdW1lbnRFbGVtZW50KSB7XG5cdFx0XHRsZXQgc2VsZWN0b3IgPSBjdXJyZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChjdXJyZW50LmlkKSB7XG5cdFx0XHRcdHNlbGVjdG9yICs9ICcjJyArIGN1cnJlbnQuaWQ7XG5cdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnQuY2xhc3NOYW1lICYmIHR5cGVvZiBjdXJyZW50LmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0c2VsZWN0b3IgKz0gJy4nICsgY3VycmVudC5jbGFzc05hbWUudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbignLicpO1xuXHRcdFx0fVxuXHRcdFx0cGFydHMudW5zaGlmdChzZWxlY3Rvcik7XG5cdFx0XHRjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50O1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gcGFydHMuam9pbignID4gJyk7XG5cdH1cblxuXHRwcml2YXRlIHNjb3JlRWxlbWVudHMoZG9jOiBEb2N1bWVudCk6IENvbnRlbnRTY29yZVtdIHtcblx0XHRjb25zdCBjYW5kaWRhdGVzOiBDb250ZW50U2NvcmVbXSA9IFtdO1xuXG5cdFx0QkxPQ0tfRUxFTUVOVFMuZm9yRWFjaCgodGFnOiBzdHJpbmcpID0+IHtcblx0XHRcdEFycmF5LmZyb20oZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZykpLmZvckVhY2goKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2NvcmUgPSB0aGlzLnNjb3JlRWxlbWVudChlbGVtZW50KTtcblx0XHRcdFx0aWYgKHNjb3JlID4gMCkge1xuXHRcdFx0XHRcdGNhbmRpZGF0ZXMucHVzaCh7IHNjb3JlLCBlbGVtZW50IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjYW5kaWRhdGVzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcblx0fVxuXG5cdHByaXZhdGUgc2NvcmVFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiBudW1iZXIge1xuXHRcdGxldCBzY29yZSA9IDA7XG5cblx0XHQvLyBTY29yZSBiYXNlZCBvbiBlbGVtZW50IHByb3BlcnRpZXNcblx0XHRjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnID8gXG5cdFx0XHRlbGVtZW50LmNsYXNzTmFtZS50b0xvd2VyQ2FzZSgpIDogJyc7XG5cdFx0Y29uc3QgaWQgPSBlbGVtZW50LmlkID8gZWxlbWVudC5pZC50b0xvd2VyQ2FzZSgpIDogJyc7XG5cblx0XHQvLyBTY29yZSBiYXNlZCBvbiBjb250ZW50XG5cdFx0Y29uc3QgdGV4dCA9IGVsZW1lbnQudGV4dENvbnRlbnQgfHwgJyc7XG5cdFx0Y29uc3Qgd29yZHMgPSB0ZXh0LnNwbGl0KC9cXHMrLykubGVuZ3RoO1xuXHRcdHNjb3JlICs9IE1hdGgubWluKE1hdGguZmxvb3Iod29yZHMgLyAxMDApLCAzKTtcblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIGxpbmsgZGVuc2l0eVxuXHRcdGNvbnN0IGxpbmtzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXHRcdGNvbnN0IGxpbmtUZXh0ID0gQXJyYXkuZnJvbShsaW5rcykucmVkdWNlKChhY2MsIGxpbmspID0+IGFjYyArIChsaW5rLnRleHRDb250ZW50Py5sZW5ndGggfHwgMCksIDApO1xuXHRcdGNvbnN0IGxpbmtEZW5zaXR5ID0gdGV4dC5sZW5ndGggPyBsaW5rVGV4dCAvIHRleHQubGVuZ3RoIDogMDtcblx0XHRpZiAobGlua0RlbnNpdHkgPiAwLjUpIHtcblx0XHRcdHNjb3JlIC09IDEwO1xuXHRcdH1cblxuXHRcdC8vIFNjb3JlIGJhc2VkIG9uIHByZXNlbmNlIG9mIG1lYW5pbmdmdWwgZWxlbWVudHNcblx0XHRjb25zdCBwYXJhZ3JhcGhzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncCcpLmxlbmd0aDtcblx0XHRzY29yZSArPSBwYXJhZ3JhcGhzO1xuXG5cdFx0Y29uc3QgaW1hZ2VzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJykubGVuZ3RoO1xuXHRcdHNjb3JlICs9IE1hdGgubWluKGltYWdlcyAqIDMsIDkpO1xuXG5cdFx0cmV0dXJuIHNjb3JlO1xuXHR9XG59ICIsIi8vIEVudHJ5IHBvaW50IGVsZW1lbnRzXG4vLyBUaGVzZSBhcmUgdGhlIGVsZW1lbnRzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgdGhlIG1haW4gY29udGVudFxuZXhwb3J0IGNvbnN0IEVOVFJZX1BPSU5UX0VMRU1FTlRTID0gW1xuXHQnYXJ0aWNsZScsXG5cdCdbcm9sZT1cImFydGljbGVcIl0nLFxuXHQnLnBvc3QtY29udGVudCcsXG5cdCcuYXJ0aWNsZS1jb250ZW50Jyxcblx0JyNhcnRpY2xlLWNvbnRlbnQnLFxuXHQnLmNvbnRlbnQtYXJ0aWNsZScsXG5cdCdtYWluJyxcblx0J1tyb2xlPVwibWFpblwiXScsXG5cdCdib2R5JyAvLyBlbnN1cmVzIHRoZXJlIGlzIGFsd2F5cyBhIG1hdGNoXG5dO1xuXG5leHBvcnQgY29uc3QgTU9CSUxFX1dJRFRIID0gNjAwO1xuZXhwb3J0IGNvbnN0IEJMT0NLX0VMRU1FTlRTID0gWydkaXYnLCAnc2VjdGlvbicsICdhcnRpY2xlJywgJ21haW4nXTtcblxuLy8gRWxlbWVudHMgdGhhdCBzaG91bGQgbm90IGJlIHVud3JhcHBlZFxuZXhwb3J0IGNvbnN0IFBSRVNFUlZFX0VMRU1FTlRTID0gbmV3IFNldChbXG5cdCdwcmUnLCAnY29kZScsICd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0cicsICd0ZCcsICd0aCcsXG5cdCd1bCcsICdvbCcsICdsaScsICdkbCcsICdkdCcsICdkZCcsXG5cdCdmaWd1cmUnLCAnZmlnY2FwdGlvbicsICdwaWN0dXJlJyxcblx0J2RldGFpbHMnLCAnc3VtbWFyeScsXG5cdCdibG9ja3F1b3RlJyxcblx0J2Zvcm0nLCAnZmllbGRzZXQnXG5dKTtcblxuLy8gSW5saW5lIGVsZW1lbnRzIHRoYXQgc2hvdWxkIG5vdCBiZSB1bndyYXBwZWRcbmV4cG9ydCBjb25zdCBJTkxJTkVfRUxFTUVOVFMgPSBuZXcgU2V0KFtcblx0J2EnLCAnc3BhbicsICdzdHJvbmcnLCAnZW0nLCAnaScsICdiJywgJ3UnLCAnY29kZScsICdicicsICdzbWFsbCcsXG5cdCdzdWInLCAnc3VwJywgJ21hcmsnLCAnZGVsJywgJ2lucycsICdxJywgJ2FiYnInLCAnY2l0ZScsICd0aW1lJ1xuXSk7XG5cbi8vIEhpZGRlbiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSByZW1vdmVkXG5leHBvcnQgY29uc3QgSElEREVOX0VMRU1FTlRfU0VMRUNUT1JTID0gW1xuXHQnW2hpZGRlbl0nLFxuLy9cdCdbYXJpYS1oaWRkZW49XCJ0cnVlXCJdJywgbmVlZGVkIGZvciBtYXRoIGZvcm11bGFzXG4vL1x0J1tzdHlsZSo9XCJkaXNwbGF5OiBub25lXCJdJywgbmVlZGVkIGZvciBmb3IgbWF0aCBmb3JtdWxhc1xuLy9cdCdbc3R5bGUqPVwiZGlzcGxheTpub25lXCJdJyxcblx0J1tzdHlsZSo9XCJ2aXNpYmlsaXR5OiBoaWRkZW5cIl0nLFxuXHQnW3N0eWxlKj1cInZpc2liaWxpdHk6aGlkZGVuXCJdJyxcblx0Jy5oaWRkZW4nLFxuXHQnLmludmlzaWJsZSdcbl0uam9pbignLCcpO1xuXG4vLyBTZWxlY3RvcnMgdG8gYmUgcmVtb3ZlZFxuZXhwb3J0IGNvbnN0IEVYQUNUX1NFTEVDVE9SUyA9IFtcblx0Ly8gc2NyaXB0cywgc3R5bGVzXG5cdCdub3NjcmlwdCcsXG5cdCdzY3JpcHQnLFxuXHQnc3R5bGUnLFxuXG5cdC8vIGFkc1xuXHQnLmFkOm5vdChbY2xhc3MqPVwiZ3JhZGllbnRcIl0pJyxcblx0J1tjbGFzc149XCJhZC1cIiBpXScsXG5cdCdbY2xhc3MkPVwiLWFkXCIgaV0nLFxuXHQnW2lkXj1cImFkLVwiIGldJyxcblx0J1tpZCQ9XCItYWRcIiBpXScsXG5cdCdbcm9sZT1cImJhbm5lclwiIGldJyxcblx0Jy5wcm9tbycsXG5cdCcuUHJvbW8nLFxuXHQnI2JhcnJpZXItcGFnZScsIC8vIGZ0LmNvbVxuXG5cdC8vIGNvbW1lbnRzXG5cdCdbaWQ9XCJjb21tZW50c1wiIGldJyxcblxuXHQvLyBoZWFkZXIsIG5hdlxuXHQnaGVhZGVyJyxcblx0Jy5oZWFkZXInLFxuXHQnI2hlYWRlcicsXG5cdCduYXYnLFxuXHQnLm5hdmlnYXRpb24nLFxuXHQnI25hdmlnYXRpb24nLFxuXHQnW3JvbGU9XCJuYXZpZ2F0aW9uXCIgaV0nLFxuXHQnW3JvbGU9XCJkaWFsb2dcIiBpXScsXG5cdCdbcm9sZSo9XCJjb21wbGVtZW50YXJ5XCIgaV0nLFxuXHQnW2NsYXNzKj1cInBhZ2luYXRpb25cIiBpXScsXG5cdCcubWVudScsXG5cdCcjbWVudScsXG5cdCcjc2l0ZVN1YicsXG5cblx0Ly8gbWV0YWRhdGFcblx0Jy5hdXRob3InLFxuXHQnLkF1dGhvcicsXG5cdCcuY29udHJpYnV0b3InLFxuXHQnLmRhdGUnLFxuXHQnLm1ldGEnLFxuXHQnLnRhZ3MnLFxuXHQnLnRvYycsXG5cdCcuVG9jJyxcblx0JyN0b2MnLFxuXHQnI3RpdGxlJyxcblx0JyNUaXRsZScsXG5cdCdbaHJlZio9XCIvY2F0ZWdvcnlcIl0nLFxuXHQnW2hyZWYqPVwiL2NhdGVnb3JpZXNcIl0nLFxuXHQnW2hyZWYqPVwiL3RhZy9cIl0nLFxuXHQnW2hyZWYqPVwiL3RhZ3MvXCJdJyxcblx0J1tocmVmKj1cIi90b3BpY3NcIl0nLFxuXHQnW2hyZWYqPVwiYXV0aG9yXCJdJyxcblx0J1tocmVmPVwiI3NpdGUtY29udGVudFwiXScsXG5cdCdbc3JjKj1cImF1dGhvclwiXScsXG5cblx0Ly8gZm9vdGVyXG5cdCdmb290ZXInLFxuXG5cdC8vIGlucHV0cywgZm9ybXMsIGVsZW1lbnRzXG5cdCdhc2lkZScsXG5cdCdidXR0b24nLFxuXHRcdC8vICdbcm9sZT1cImJ1dHRvblwiXScsIE1lZGl1bSBpbWFnZXNcblx0J2NhbnZhcycsXG5cdCdkaWFsb2cnLFxuXHQnZmllbGRzZXQnLFxuXHQnZm9ybScsXG5cdCdpbnB1dDpub3QoW3R5cGU9XCJjaGVja2JveFwiXSknLFxuXHQnbGFiZWwnLFxuXHQnbGluaycsXG5cdCdvcHRpb24nLFxuXHQnc2VsZWN0Jyxcblx0J3RleHRhcmVhJyxcblx0J3RpbWUnLFxuXG5cdC8vIGlmcmFtZXNcblx0J2luc3RhcmVhZC1wbGF5ZXInLFxuXHQnaWZyYW1lOm5vdChbc3JjKj1cInlvdXR1YmVcIl0pOm5vdChbc3JjKj1cInlvdXR1LmJlXCJdKTpub3QoW3NyYyo9XCJ2aW1lb1wiXSk6bm90KFtzcmMqPVwidHdpdHRlclwiXSknLFxuXG5cdC8vIGxvZ29zXG5cdCdbY2xhc3M9XCJsb2dvXCIgaV0nLFxuXHQnI2xvZ28nLFxuXHQnI0xvZ28nLFxuXG5cdC8vIG5ld3NsZXR0ZXJcblx0JyNuZXdzbGV0dGVyJyxcblx0JyNOZXdzbGV0dGVyJyxcblxuXHQvLyBoaWRkZW4gZm9yIHByaW50XG5cdCcubm9wcmludCcsXG5cdCdbZGF0YS1saW5rLW5hbWUqPVwic2tpcFwiIGldJyxcblx0J1tkYXRhLXByaW50LWxheW91dD1cImhpZGVcIiBpXScsXG5cdCdbZGF0YS1ibG9jaz1cImRvbm90cHJpbnRcIiBpXScsXG5cblx0Ly8gZm9vdG5vdGVzLCBjaXRhdGlvbnNcblx0J1tjbGFzcyo9XCJjbGlja2FibGUtaWNvblwiIGldJyxcblx0J2xpIHNwYW5bY2xhc3MqPVwibHR4X3RhZ1wiIGldW2NsYXNzKj1cImx0eF90YWdfaXRlbVwiIGldJyxcblx0J2FbaHJlZl49XCIjXCJdW2NsYXNzKj1cImFuY2hvclwiIGldJyxcblx0J2FbaHJlZl49XCIjXCJdW2NsYXNzKj1cInJlZlwiIGldJyxcblxuXHQvLyBsaW5rIGxpc3RzXG5cdCdbZGF0YS1jb250YWluZXIqPVwibW9zdC12aWV3ZWRcIiBpXScsXG5cblx0Ly8gc2lkZWJhclxuXHQnLnNpZGViYXInLFxuXHQnLlNpZGViYXInLFxuXHQnI3NpZGViYXInLFxuXHQnI1NpZGViYXInLFxuXHQnI3NpdGVzdWInLFxuXHRcblx0Ly8gb3RoZXJcblx0JyNwcmltYXJ5YXVkaW8nLCAvLyBOUFJcblx0JyNOWVRfQUJPVkVfTUFJTl9DT05URU5UX1JFR0lPTicsXG5cdCdbZGF0YS10ZXN0aWQ9XCJwaG90b3ZpZXdlci1jaGlsZHJlbi1maWd1cmVcIl0gPiBzcGFuJywgLy8gTmV3IFlvcmsgVGltZXNcblx0J3RhYmxlLmluZm9ib3gnLFxuXHQnLnBlbmNyYWZ0Om5vdCgucGMtZGlzcGxheS1jb250ZW50cyknLCAvLyBTdWJzdGFja1xuXHQnW2RhdGEtb3B0aW1pemVseT1cInJlbGF0ZWQtYXJ0aWNsZXMtc2VjdGlvblwiIGldJyAvLyBUaGUgRWNvbm9taXN0XG5dO1xuXG4vLyBSZW1vdmFsIHBhdHRlcm5zIHRlc3RlZCBhZ2FpbnN0IGF0dHJpYnV0ZXM6IGNsYXNzLCBpZCwgZGF0YS10ZXN0aWQsIGFuZCBkYXRhLXFhXG4vLyBDYXNlIGluc2Vuc2l0aXZlLCBwYXJ0aWFsIG1hdGNoZXMgYWxsb3dlZFxuZXhwb3J0IGNvbnN0IFBBUlRJQUxfU0VMRUNUT1JTID0gW1xuXHQnYWNjZXNzLXdhbGwnLFxuXHQnYWN0aXZpdHlwdWInLFxuXHQnYWN0aW9uY2FsbCcsXG5cdCdhcHBlbmRpeCcsXG5cdCdhdmF0YXInLFxuXHQnYWR2ZXJ0Jyxcblx0Jy1hZC0nLFxuXHQnX2FkXycsXG5cdCdhbGx0ZXJtcycsXG5cdCdhcm91bmQtdGhlLXdlYicsXG5cdCdhcnRpY2xlLWJvdHRvbS1zZWN0aW9uJyxcblx0J2FydGljbGVfX2NvcHknLFxuXHQnYXJ0aWNsZV9kYXRlJyxcblx0J2FydGljbGUtZW5kICcsXG5cdCdhcnRpY2xlX2hlYWRlcicsXG5cdCdhcnRpY2xlX19oZWFkZXInLFxuXHQnYXJ0aWNsZV9faW5mbycsXG5cdCdhcnRpY2xlLWluZm8nLFxuXHQnYXJ0aWNsZV9fbWV0YScsXG5cdCdhcnRpY2xlLXN1YmplY3QnLFxuXHQnYXJ0aWNsZV9zdWJqZWN0Jyxcblx0J2FydGljbGUtc25pcHBldCcsXG5cdCdhcnRpY2xlLXNlcGFyYXRvcicsXG5cdCdhcnRpY2xlLS1zaGFyZScsXG5cdCdhcnRpY2xlLS10b3BpY3MnLFxuXHQnYXJ0aWNsZXRhZ3MnLFxuXHQnYXJ0aWNsZS10YWdzJyxcblx0J2FydGljbGVfdGFncycsXG5cdCdhcnRpY2xlLXRpdGxlJyxcblx0J2FydGljbGVfdGl0bGUnLFxuXHQnYXJ0aWNsZXRvcGljcycsXG5cdCdhcnRpY2xlLXRvcGljcycsXG5cdCdhcnRpY2xlLXR5cGUnLFxuXHQnYXJ0aWNsZS0tbGVkZScsIC8vIFRoZSBWZXJnZVxuXHQnYXJ0aWNsZXdlbGwnLFxuXHQnYXNzb2NpYXRlZC1wZW9wbGUnLFxuXHQnYXVkaW8tY2FyZCcsXG4vL1x0J2F1dGhvcicsIEd3ZXJuXG5cdCdhdXRob3JlZC1ieScsXG5cdCdhdXRob3ItYm94Jyxcblx0J2F1dGhvci1uYW1lJyxcblx0J2F1dGhvci1iaW8nLFxuXHQnYXV0aG9yLW1pbmktYmlvJyxcblx0J2JhY2stdG8tdG9wJyxcblx0J2JhY2tsaW5rcy1zZWN0aW9uJyxcblx0J2Jhbm5lcicsXG5cdCdiaW8tYmxvY2snLFxuXHQnYmxvZy1wYWdlcicsXG5cdCdib29rbWFyay0nLFxuXHQnLWJvb2ttYXJrJyxcblx0J2JvdHRvbS1vZi1hcnRpY2xlJyxcblx0J2JyYW5kLWJhcicsXG5cdCdicmVhZGNydW1iJyxcblx0J2J1dHRvbi13cmFwcGVyJyxcblx0J2J0bi0nLFxuXHQnLWJ0bicsXG5cdCdieWxpbmUnLFxuXHQnY2FwdGNoYScsXG5cdCdjYXJkLXRleHQnLFxuXHQnY2FyZC1tZWRpYScsXG5cdCdjYXRfaGVhZGVyJyxcblx0J2NhdGxpbmtzJyxcblx0J2NoYXB0ZXItbGlzdCcsIC8vIFRoZSBFY29ub21pc3Rcblx0J2NvbGxlY3Rpb25zJyxcblx0J2NvbW1lbnRzJyxcbi8vXHQnLWNvbW1lbnQnLCBTeW50YXggaGlnaGxpZ2h0aW5nXG5cdCdjb21tZW50Ym94Jyxcblx0J2NvbW1lbnQtY291bnQnLFxuXHQnY29tbWVudC1jb250ZW50Jyxcblx0J2NvbW1lbnQtZm9ybScsXG5cdCdjb21tZW50LW51bWJlcicsXG5cdCdjb21tZW50LXJlc3BvbmQnLFxuXHQnY29tbWVudC10aHJlYWQnLFxuXHQnY29tcGxlbWVudGFyeScsXG5cdCdjb25zZW50Jyxcblx0J2NvbnRlbnQtY2FyZCcsIC8vIFRoZSBWZXJnZVxuXHQnY29udGVudC10b3BpY3MnLFxuXHQnY29udGVudHByb21vJyxcblx0J2NvbnRleHQtd2lkZ2V0JywgLy8gUmV1dGVyc1xuXHQnY29yZS1jb2xsYXRlcmFsJyxcblx0J19jdGEnLFxuXHQnLWN0YScsXG5cdCdjdGEtJyxcblx0J2N0YV8nLFxuXHQnY3VycmVudC1pc3N1ZScsIC8vIFRoZSBOYXRpb25cblx0J2N1c3RvbS1saXN0LW51bWJlcicsXG5cdCdkYXRlbGluZScsXG5cdCdkYXRlaGVhZGVyJyxcblx0J2RhdGUtaGVhZGVyJyxcblx0J2RhdGVfaGVhZGVyLScsXG4vL1x0J2RpYWxvZycsXG5cdCdkaXNjbGFpbWVyJyxcblx0J2Rpc2Nsb3N1cmUnLFxuXHQnZGlzY3Vzc2lvbicsXG5cdCdkaXNjdXNzXycsXG5cdCdkaXNxdXMnLFxuXHQnZG9uYXRlJyxcblx0J2Ryb3Bkb3duJywgLy8gQXJzIFRlY2huaWNhXG5cdCdlbGV0dGVycycsXG5cdCdlbWFpbHNpZ251cCcsXG5cdCdlbmdhZ2VtZW50LXdpZGdldCcsXG5cdCdlbnRyeS1hdXRob3ItaW5mbycsXG5cdCdlbnRyeS1jYXRlZ29yaWVzJyxcblx0J2VudHJ5LWRhdGUnLFxuXHQnZW50cnktbWV0YScsXG5cdCdlbnRyeS10aXRsZScsXG5cdCdlbnRyeS11dGlsaXR5Jyxcblx0J2V5ZWJyb3cnLFxuXHQnZXhwYW5kLXJlZHVjZScsXG5cdCdleHRlcm5hbGxpbmtlbWJlZHdyYXBwZXInLCAvLyBUaGUgTmV3IFlvcmtlclxuXHQnZXh0cmEtc2VydmljZXMnLFxuXHQnZXh0cmEtdGl0bGUnLFxuXHQnZmFjZWJvb2snLFxuXHQnZmF2b3JpdGUnLFxuXHQnZmVlZGJhY2snLFxuXHQnZmVlZC1saW5rcycsXG5cdCdmaWVsZC1zaXRlLXNlY3Rpb25zJyxcblx0J2ZpeGVkJyxcblx0J2Zsb2F0aW5nLXZpZCcsXG5cdCdmb2xsb3cnLFxuXHQnZm9vdGVyJyxcblx0J2Zvb3Rub3RlLWJhY2snLFxuXHQnZm9vdG5vdGViYWNrJyxcblx0J2Zvci15b3UnLFxuXHQnZnJvbnRtYXR0ZXInLFxuXHQnZnVydGhlci1yZWFkaW5nJyxcblx0J2dpc3QtbWV0YScsXG4vL1x0J2dsb2JhbCcsXG5cdCdnb29nbGUnLFxuXHQnZ29vZy0nLFxuXHQnZ3JhcGgtdmlldycsXG5cdCdoZWFkZXItbG9nbycsXG5cdCdoZWFkZXItcGF0dGVybicsIC8vIFRoZSBWZXJnZVxuXHQnaGVyby1saXN0Jyxcblx0J2hpZGUtZm9yLXByaW50Jyxcblx0J2hpZGUtcHJpbnQnLFxuXHQnaGlkZS13aGVuLW5vLXNjcmlwdCcsXG5cdCdoaWRkZW4tc2lkZW5vdGUnLFxuXHQnaW50ZXJsdWRlJyxcblx0J2ludGVyYWN0aW9uJyxcblx0J2p1bXBsaW5rJyxcblx0J2p1bXAtdG8tJyxcbi8vXHQna2V5d29yZCcsIC8vIHVzZWQgaW4gc3ludGF4IGhpZ2hsaWdodGluZ1xuXHQna2lja2VyJyxcblx0J2xhYnN0YWInLCAvLyBBcnhpdlxuXHQnLWxhYmVscycsXG5cdCdsYW5ndWFnZS1uYW1lJyxcblx0J2xhdGVzdC1jb250ZW50Jyxcblx0Jy1sZWRlcy0nLCAvLyBUaGUgVmVyZ2Vcblx0Jy1saWNlbnNlJyxcblx0J2xpbmstYm94Jyxcblx0J2xpbmtzLWdyaWQnLCAvLyBCQkNcblx0J2xpbmtzLXRpdGxlJywgLy8gQkJDXG5cdCdsaXN0aW5nLWR5bmFtaWMtdGVybXMnLCAvLyBCb3N0b24gUmV2aWV3XG5cdCdsaXN0LXRhZ3MnLFxuXHQnbG9hZGluZycsXG5cdCdsb2EtaW5mbycsXG5cdCdsb2dvX2NvbnRhaW5lcicsXG5cdCdsdHhfcm9sZV9yZWZudW0nLCAvLyBBcnhpdlxuXHQnbHR4X3RhZ19iaWJpdGVtJyxcblx0J2x0eF9lcnJvcicsXG5cdCdtYXJrZXRpbmcnLFxuXHQnbWVkaWEtaW5xdWlyeScsXG5cdCdtZW51LScsXG5cdCdtZXRhLScsXG5cdCdtZXRhZGF0YScsXG5cdCdtaWdodC1saWtlJyxcblx0J19tb2RhbCcsXG5cdCctbW9kYWwnLFxuXHQnbW9yZS0nLFxuXHQnbW9yZW5ld3MnLFxuXHQnbW9yZXN0b3JpZXMnLFxuXHQnbW92ZS1oZWxwZXInLFxuXHQnbXctZWRpdHNlY3Rpb24nLFxuXHQnbXctY2l0ZS1iYWNrbGluaycsXG5cdCdtdy1pbmRpY2F0b3JzJyxcblx0J213LWp1bXAtbGluaycsXG5cdCduYXYtJyxcblx0J25hdl8nLFxuXHQnbmF2YmFyJyxcbi8vXHQnbmF2aWdhdGlvbicsXG5cdCduZXh0LScsXG5cdCduZXdzLXN0b3J5LXRpdGxlJyxcbi8vXHQnbmV3c2xldHRlcicsIHVzZWQgb24gU3Vic3RhY2tcblx0J25ld3NsZXR0ZXJfJyxcblx0J25ld3NsZXR0ZXItc2lnbnVwJyxcblx0J25ld3NsZXR0ZXJzaWdudXAnLFxuXHQnbmV3c2xldHRlcndpZGdldCcsXG5cdCduZXdzbGV0dGVyd3JhcHBlcicsXG5cdCdub3QtZm91bmQnLFxuXHQnbm9tb2JpbGUnLFxuXHQnbm9wcmludCcsXG5cdCdvcmlnaW5hbGx5LXB1Ymxpc2hlZCcsIC8vIE1lcmN1cnkgTmV3c1xuXHQnb3V0bGluZS12aWV3Jyxcblx0J292ZXJsYXknLFxuXHQncGFnZS10aXRsZScsXG5cdCctcGFydG5lcnMnLFxuXHQncGxlYScsXG5cdCdwb3B1bGFyJyxcbi8vXHQncG9wdXAnLCBHd2VyblxuXHQncG9wLXVwJyxcblx0J3BvcG92ZXInLFxuXHQncG9zdC1ib3R0b20nLFxuXHQncG9zdF9fY2F0ZWdvcnknLFxuXHQncG9zdGNvbW1lbnQnLFxuXHQncG9zdGRhdGUnLFxuXHQncG9zdC1hdXRob3InLFxuXHQncG9zdC1kYXRlJyxcblx0J3Bvc3RfZGF0ZScsXG5cdCdwb3N0LWZlZWRzJyxcblx0J3Bvc3RpbmZvJyxcblx0J3Bvc3QtaW5mbycsXG5cdCdwb3N0X2luZm8nLFxuXHQncG9zdC1pbmxpbmUtZGF0ZScsXG5cdCdwb3N0LWxpbmtzJyxcblx0J3Bvc3QtbWV0YScsXG5cdCdwb3N0bWV0YScsXG5cdCdwb3N0c25pcHBldCcsXG5cdCdwb3N0X3NuaXBwZXQnLFxuXHQncG9zdC1zbmlwcGV0Jyxcblx0J3Bvc3R0aXRsZScsXG5cdCdwb3N0LXRpdGxlJyxcblx0J3Bvc3RfdGl0bGUnLFxuXHQncG9zdHRheCcsXG5cdCdwb3N0LXRheCcsXG5cdCdwb3N0X3RheCcsXG5cdCdwb3N0dGFnJyxcblx0J3Bvc3RfdGFnJyxcblx0J3Bvc3QtdGFnJyxcbi8vXHQncHJldmlldycsIHVzZWQgb24gT2JzaWRpYW4gUHVibGlzaFxuXHQncHJldm5leHQnLFxuXHQncHJldmlvdXNuZXh0Jyxcblx0J3ByZXNzLWlucXVpcmllcycsXG5cdCdwcmludC1ub25lJyxcblx0J3ByaW50LWhlYWRlcicsXG5cdCdwcm9maWxlJyxcbi8vXHQncHJvbW8nLFxuXHQncHJvbW8tYm94Jyxcblx0J3B1YmRhdGUnLFxuXHQncHViX2RhdGUnLFxuXHQncHViLWRhdGUnLFxuXHQncHVibGljYXRpb24tZGF0ZScsXG5cdCdwdWJsaWNhdGlvbk5hbWUnLCAvLyBNZWRpdW1cblx0J3FyLWNvZGUnLFxuXHQncXJfY29kZScsXG5cdCdfcmFpbCcsXG5cdCdyZWFkbW9yZScsXG5cdCdyZWFkLW5leHQnLFxuXHQncmVhZF9uZXh0Jyxcblx0J3JlYWRfdGltZScsXG5cdCdyZWFkLXRpbWUnLFxuXHQncmVhZGluZ190aW1lJyxcblx0J3JlYWRpbmctdGltZScsXG5cdCdyZWFkaW5nLWxpc3QnLFxuXHQncmVjZW50cG9zdCcsXG5cdCdyZWNlbnRfcG9zdCcsXG5cdCdyZWNlbnQtcG9zdCcsXG5cdCdyZWNvbW1lbmQnLFxuXHQncmVkaXJlY3RlZGZyb20nLFxuXHQncmVjaXJjJyxcblx0J3JlZ2lzdGVyJyxcblx0J3JlbGF0ZWQnLFxuXHQncmVsZXZhbnQnLFxuXHQncmV2ZXJzZWZvb3Rub3RlJyxcblx0J3NjcmVlbi1yZWFkZXItdGV4dCcsXG4vL1x0J3NoYXJlJyxcbi8vXHQnLXNoYXJlJywgc2NpdGVjaGRhaWx5LmNvbVxuXHQnc2hhcmUtYm94Jyxcblx0J3NoYXJlZGFkZHknLFxuXHQnc2hhcmUtaWNvbnMnLFxuXHQnc2hhcmVsaW5rcycsXG5cdCdzaGFyZS1zZWN0aW9uJyxcblx0J3NpZGViYXJ0aXRsZScsXG5cdCdzaWRlYmFyXycsXG5cdCdzaWRlYmFyLWNvbnRlbnQnLFxuXHQnc2ltaWxhci0nLFxuXHQnc2ltaWxhcl8nLFxuXHQnc2ltaWxhcnMtJyxcblx0J3NpZGVpdGVtcycsXG5cdCdzaWRlLWJveCcsXG5cdCdzaXRlLWluZGV4Jyxcblx0J3NpdGUtaGVhZGVyJyxcblx0J3NpdGUtbG9nbycsXG5cdCdzaXRlLW5hbWUnLFxuLy9cdCdza2lwLScsXG4vL1x0J3NraXAtbGluaycsIFRlY2hDcnVuY2hcblx0J19za2lwLWxpbmsnLFxuXHQnc2x1Zy13cmFwJyxcblx0J3NvY2lhbCcsXG5cdCdzcGVlY2hpZnktaWdub3JlJyxcblx0J3Nwb25zb3InLFxuXHQnc3ByaW5nZXJjaXRhdGlvbicsXG4vL1x0Jy1zdGF0cycsXG5cdCdfc3RhdHMnLFxuXHQnc3RpY2t5Jyxcblx0J3N0b3J5cmVhZHRpbWUnLCAvLyBNZWRpdW1cblx0J3N0b3J5cHVibGlzaGRhdGUnLCAvLyBNZWRpdW1cblx0J3N1YmplY3QtbGFiZWwnLFxuXHQnc3Vic2NyaWJlJyxcblx0J190YWdzJyxcblx0J3RhZ3NfX2l0ZW0nLFxuXHQndGFnX2xpc3QnLFxuXHQndGF4b25vbXknLFxuXHQndGFibGUtb2YtY29udGVudHMnLFxuXHQndGFicy0nLFxuLy9cdCd0ZWFzZXInLCBOYXR1cmVcblx0J3Rlcm1pbmFsdG91dCcsXG5cdCd0aW1lLXJ1YnJpYycsXG5cdCd0aW1lc3RhbXAnLFxuXHQndGlwX29mZicsXG5cdCd0aXB0b3V0Jyxcblx0Jy10b3V0LScsXG5cdCctdG9jJyxcblx0J3RvZ2dsZS1jYXB0aW9uJyxcblx0J3RvcGljLWxpc3QnLFxuXHQndG9vbGJhcicsXG5cdCd0b29sdGlwJyxcblx0J3RvcC13cmFwcGVyJyxcblx0J3RyZWUtaXRlbScsXG5cdCd0cmVuZGluZycsXG5cdCd0cnVzdC1mZWF0Jyxcblx0J3RydXN0LWJhZGdlJyxcblx0J3R3aXR0ZXInLFxuXHQndmlzdWFsbHktaGlkZGVuJyxcblx0J3dlbGNvbWVib3gnXG4vL1x0J3dpZGdldC0nXG5dO1xuXG4vLyBTZWxlY3RvcnMgZm9yIGZvb3Rub3RlcyBhbmQgY2l0YXRpb25zXG5leHBvcnQgY29uc3QgRk9PVE5PVEVfSU5MSU5FX1JFRkVSRU5DRVMgPSBbXG5cdCdzdXAucmVmZXJlbmNlJyxcblx0J2NpdGUubHR4X2NpdGUnLFxuXHQnc3VwW2lkXj1cImZuclwiXScsXG5cdCdzdXBbaWRePVwiZm5yZWY6XCJdJyxcblx0J3NwYW4uZm9vdG5vdGUtbGluaycsXG5cdCdhLmNpdGF0aW9uJyxcblx0J2FbaWRePVwicmVmLWxpbmtcIl0nLFxuXHQnYVtocmVmXj1cIiNmblwiXScsXG5cdCdhW2hyZWZePVwiI2NpdGVcIl0nLFxuXHQnYVtocmVmXj1cIiNyZWZlcmVuY2VcIl0nLFxuXHQnYVtocmVmXj1cIiNmb290bm90ZVwiXScsXG5cdCdhW2hyZWZePVwiI3JcIl0nLCAvLyBDb21tb24gaW4gYWNhZGVtaWMgcGFwZXJzXG5cdCdhW2hyZWZePVwiI2JcIl0nLCAvLyBDb21tb24gZm9yIGJpYmxpb2dyYXBoeSByZWZlcmVuY2VzXG5cdCdhW2hyZWYqPVwiY2l0ZV9ub3RlXCJdJyxcblx0J2FbaHJlZio9XCJjaXRlX3JlZlwiXScsXG5cdCdhLmZvb3Rub3RlLWFuY2hvcicsIC8vIFN1YnN0YWNrXG5cdCdzcGFuLmZvb3Rub3RlLWhvdmVyY2FyZC10YXJnZXQgYScsIC8vIFN1YnN0YWNrXG5cdCdhW3JvbGU9XCJkb2MtYmlibGlvcmVmXCJdJywgLy8gU2NpZW5jZS5vcmdcblx0J2FbaWRePVwiZm5yZWZcIl0nLFxuXHQnYVtpZF49XCJyZWYtbGlua1wiXScsIC8vIE5hdHVyZS5jb21cbl0uam9pbignLCcpO1xuXG5leHBvcnQgY29uc3QgRk9PVE5PVEVfTElTVF9TRUxFQ1RPUlMgPSBbXG5cdCdkaXYuZm9vdG5vdGUgb2wnLFxuXHQnZGl2LmZvb3Rub3RlcyBvbCcsXG5cdCdkaXZbcm9sZT1cImRvYy1lbmRub3Rlc1wiXScsXG5cdCdkaXZbcm9sZT1cImRvYy1mb290bm90ZXNcIl0nLFxuXHQnb2wuZm9vdG5vdGVzLWxpc3QnLFxuXHQnb2wuZm9vdG5vdGVzJyxcblx0J29sLnJlZmVyZW5jZXMnLFxuXHQnb2xbY2xhc3MqPVwiYXJ0aWNsZS1yZWZlcmVuY2VzXCJdJyxcblx0J3NlY3Rpb24uZm9vdG5vdGVzIG9sJyxcblx0J3NlY3Rpb25bcm9sZT1cImRvYy1lbmRub3Rlc1wiXScsXG5cdCdzZWN0aW9uW3JvbGU9XCJkb2MtZm9vdG5vdGVzXCJdJyxcblx0J3NlY3Rpb25bcm9sZT1cImRvYy1iaWJsaW9ncmFwaHlcIl0nLFxuXHQndWwuZm9vdG5vdGVzLWxpc3QnLFxuXHQndWwubHR4X2JpYmxpc3QnLFxuXHQnZGl2LmZvb3Rub3RlW2RhdGEtY29tcG9uZW50LW5hbWU9XCJGb290bm90ZVRvRE9NXCJdJyAvLyBTdWJzdGFja1xuXS5qb2luKCcsJyk7XG5cbi8vIEVsZW1lbnRzIHRoYXQgYXJlIGFsbG93ZWQgdG8gYmUgZW1wdHlcbi8vIFRoZXNlIGFyZSBub3QgcmVtb3ZlZCBldmVuIGlmIHRoZXkgaGF2ZSBubyBjb250ZW50XG5leHBvcnQgY29uc3QgQUxMT1dFRF9FTVBUWV9FTEVNRU5UUyA9IG5ldyBTZXQoW1xuXHQnYXJlYScsXG5cdCdhdWRpbycsXG5cdCdiYXNlJyxcblx0J2JyJyxcblx0J2NpcmNsZScsXG5cdCdjb2wnLFxuXHQnZGVmcycsXG5cdCdlbGxpcHNlJyxcblx0J2VtYmVkJyxcblx0J2ZpZ3VyZScsXG5cdCdnJyxcblx0J2hyJyxcblx0J2lmcmFtZScsXG5cdCdpbWcnLFxuXHQnaW5wdXQnLFxuXHQnbGluZScsXG5cdCdsaW5rJyxcblx0J21hc2snLFxuXHQnbWV0YScsXG5cdCdvYmplY3QnLFxuXHQncGFyYW0nLFxuXHQncGF0aCcsXG5cdCdwYXR0ZXJuJyxcblx0J3BpY3R1cmUnLFxuXHQncG9seWdvbicsXG5cdCdwb2x5bGluZScsXG5cdCdyZWN0Jyxcblx0J3NvdXJjZScsXG5cdCdzdG9wJyxcblx0J3N2ZycsXG5cdCd0ZCcsXG5cdCd0aCcsXG5cdCd0cmFjaycsXG5cdCd1c2UnLFxuXHQndmlkZW8nLFxuXHQnd2JyJ1xuXSk7XG5cbi8vIEF0dHJpYnV0ZXMgdG8ga2VlcFxuZXhwb3J0IGNvbnN0IEFMTE9XRURfQVRUUklCVVRFUyA9IG5ldyBTZXQoW1xuXHQnYWx0Jyxcblx0J2FsbG93Jyxcblx0J2FsbG93ZnVsbHNjcmVlbicsXG5cdCdhcmlhLWxhYmVsJyxcblx0J2NoZWNrZWQnLFxuXHQnY29sc3BhbicsXG5cdCdjb250cm9scycsXG5cdCdkYXRhLWxhdGV4Jyxcblx0J2RhdGEtc3JjJyxcblx0J2RhdGEtc3Jjc2V0Jyxcblx0J2RhdGEtbGFuZycsXG5cdCdkaXInLFxuXHQnZGlzcGxheScsXG5cdCdmcmFtZWJvcmRlcicsXG5cdCdoZWFkZXJzJyxcblx0J2hlaWdodCcsXG5cdCdocmVmJyxcblx0J2xhbmcnLFxuXHQncm9sZScsXG5cdCdyb3dzcGFuJyxcblx0J3NyYycsXG5cdCdzcmNzZXQnLFxuXHQndGl0bGUnLFxuXHQndHlwZScsXG5cdCd3aWR0aCcsXG5cblx0Ly8gTWF0aE1MIGF0dHJpYnV0ZXNcblx0J2FjY2VudCcsXG5cdCdhY2NlbnR1bmRlcicsXG5cdCdhbGlnbicsXG5cdCdjb2x1bW5hbGlnbicsXG5cdCdjb2x1bW5saW5lcycsXG5cdCdjb2x1bW5zcGFjaW5nJyxcblx0J2NvbHVtbnNwYW4nLFxuXHQnZGF0YS1tangtdGV4Y2xhc3MnLFxuXHQnZGVwdGgnLFxuXHQnZGlzcGxheXN0eWxlJyxcblx0J2ZlbmNlJyxcblx0J2ZyYW1lJyxcblx0J2ZyYW1lc3BhY2luZycsXG5cdCdsaW5ldGhpY2tuZXNzJyxcblx0J2xzcGFjZScsXG5cdCdtYXRoYmFja2dyb3VuZCcsXG5cdCdtYXRoY29sb3InLFxuXHQnbWF0aHNpemUnLFxuXHQnbWF0aHZhcmlhbnQnLFxuXHQnbWF4c2l6ZScsXG5cdCdtaW5zaXplJyxcblx0J21vdmFibGVsaW1pdHMnLFxuXHQnbm90YXRpb24nLFxuXHQncm93YWxpZ24nLFxuXHQncm93bGluZXMnLFxuXHQncm93c3BhY2luZycsXG5cdCdyb3dzcGFuJyxcblx0J3JzcGFjZScsXG5cdCdzY3JpcHRsZXZlbCcsXG5cdCdzZXBhcmF0b3InLFxuXHQnc3RyZXRjaHknLFxuXHQnc3ltbWV0cmljJyxcblx0J3ZvZmZzZXQnLFxuXHQneG1sbnMnXG5dKTtcbmV4cG9ydCBjb25zdCBBTExPV0VEX0FUVFJJQlVURVNfREVCVUcgPSBuZXcgU2V0KFtcblx0J2NsYXNzJyxcblx0J2lkJyxcbl0pO1xuXG4vLyBTdXBwb3J0ZWQgbGFuZ3VhZ2VzIGZvciBjb2RlIGJsb2Nrc1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9MQU5HVUFHRVMgPSBuZXcgU2V0KFtcblx0Ly8gTWFya3VwICYgV2ViXG5cdCdtYXJrdXAnLCAnaHRtbCcsICd4bWwnLCAnc3ZnJywgJ21hdGhtbCcsICdzc21sJywgJ2F0b20nLCAncnNzJyxcblx0J2phdmFzY3JpcHQnLCAnanMnLCAnanN4JywgJ3R5cGVzY3JpcHQnLCAndHMnLCAndHN4Jyxcblx0J3dlYmFzc2VtYmx5JywgJ3dhc20nLFxuXHRcblx0Ly8gQ29tbW9uIFByb2dyYW1taW5nIExhbmd1YWdlc1xuXHQncHl0aG9uJyxcblx0J2phdmEnLFxuXHQnY3NoYXJwJywgJ2NzJywgJ2RvdG5ldCcsICdhc3BuZXQnLFxuXHQnY3BwJywgJ2MrKycsICdjJywgJ29iamMnLFxuXHQncnVieScsICdyYicsXG5cdCdwaHAnLFxuXHQnZ29sYW5nJyxcblx0J3J1c3QnLFxuXHQnc3dpZnQnLFxuXHQna290bGluJyxcblx0J3NjYWxhJyxcblx0J2RhcnQnLFxuXHRcblx0Ly8gU2hlbGwgJiBTY3JpcHRpbmdcblx0J2Jhc2gnLCAnc2hlbGwnLCAnc2gnLFxuXHQncG93ZXJzaGVsbCcsXG5cdCdiYXRjaCcsXG5cdFxuXHQvLyBEYXRhICYgQ29uZmlnXG5cdCdqc29uJywgJ2pzb25wJyxcblx0J3lhbWwnLCAneW1sJyxcblx0J3RvbWwnLFxuXHQnZG9ja2VyZmlsZScsXG5cdCdnaXRpZ25vcmUnLFxuXHRcblx0Ly8gUXVlcnkgTGFuZ3VhZ2VzXG5cdCdzcWwnLCAnbXlzcWwnLCAncG9zdGdyZXNxbCcsXG5cdCdncmFwaHFsJyxcblx0J21vbmdvZGInLFxuXHQnc3BhcnFsJyxcblx0XG5cdC8vIE1hcmt1cCAmIERvY3VtZW50YXRpb25cblx0J21hcmtkb3duJywgJ21kJyxcblx0J2xhdGV4JywgJ3RleCcsXG5cdCdhc2NpaWRvYycsICdhZG9jJyxcblx0J2pzZG9jJyxcblx0XG5cdC8vIEZ1bmN0aW9uYWwgTGFuZ3VhZ2VzXG5cdCdoYXNrZWxsJywgJ2hzJyxcblx0J2VsbScsXG5cdCdlbGl4aXInLFxuXHQnZXJsYW5nJyxcblx0J29jYW1sJyxcblx0J2ZzaGFycCcsXG5cdCdzY2hlbWUnLFxuXHQnbGlzcCcsICdlbGlzcCcsXG5cdCdjbG9qdXJlJyxcblx0XG5cdC8vIE90aGVyIExhbmd1YWdlc1xuXHQnbWF0bGFiJyxcblx0J2ZvcnRyYW4nLFxuXHQnY29ib2wnLFxuXHQncGFzY2FsJyxcblx0J3BlcmwnLFxuXHQnbHVhJyxcblx0J2p1bGlhJyxcblx0J2dyb292eScsXG5cdCdjcnlzdGFsJyxcblx0J25pbScsXG5cdCd6aWcnLFxuXHRcblx0Ly8gRG9tYWluIFNwZWNpZmljXG5cdCdyZWdleCcsXG5cdCdncmFkbGUnLFxuXHQnY21ha2UnLFxuXHQnbWFrZWZpbGUnLFxuXHQnbml4Jyxcblx0J3RlcnJhZm9ybScsXG5cdCdzb2xpZGl0eScsXG5cdCdnbHNsJyxcblx0J2hsc2wnLFxuXHRcblx0Ly8gQXNzZW1ibHlcblx0J25hc20nLFxuXHQnbWFzbScsXG5cdCdhcm1hc20nLFxuXHRcblx0Ly8gR2FtZSBEZXZlbG9wbWVudFxuXHQnZ2RzY3JpcHQnLFxuXHQndW5yZWFsc2NyaXB0Jyxcblx0XG5cdC8vIE90aGVyc1xuXHQnYWJhcCcsXG5cdCdhY3Rpb25zY3JpcHQnLFxuXHQnYWRhJyxcblx0J2FnZGEnLFxuXHQnYW50bHI0Jyxcblx0J2FwcGxlc2NyaXB0Jyxcblx0J2FyZHVpbm8nLFxuXHQnY29mZmVlc2NyaXB0Jyxcblx0J2RqYW5nbycsXG5cdCdlcmxhbmcnLFxuXHQnZm9ydHJhbicsXG5cdCdoYXhlJyxcblx0J2lkcmlzJyxcblx0J2tvdGxpbicsXG5cdCdsaXZlc2NyaXB0Jyxcblx0J21hdGxhYicsXG5cdCduZ2lueCcsXG5cdCdwYXNjYWwnLFxuXHQncHJvbG9nJyxcblx0J3B1cHBldCcsXG5cdCdzY2FsYScsXG5cdCdzY2hlbWUnLFxuXHQndGNsJyxcblx0J3Zlcmlsb2cnLFxuXHQndmhkbCdcbl0pO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgUGFyc2VFcnJvciBjbGFzcywgd2hpY2ggaXMgdGhlIG1haW4gZXJyb3IgdGhyb3duIGJ5IFRlbW1sXG4gKiBmdW5jdGlvbnMgd2hlbiBzb21ldGhpbmcgaGFzIGdvbmUgd3JvbmcuIFRoaXMgaXMgdXNlZCB0byBkaXN0aW5ndWlzaCBpbnRlcm5hbFxuICogZXJyb3JzIGZyb20gZXJyb3JzIGluIHRoZSBleHByZXNzaW9uIHRoYXQgdGhlIHVzZXIgcHJvdmlkZWQuXG4gKlxuICogSWYgcG9zc2libGUsIGEgY2FsbGVyIHNob3VsZCBwcm92aWRlIGEgVG9rZW4gb3IgUGFyc2VOb2RlIHdpdGggaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXJlIGluIHRoZSBzb3VyY2Ugc3RyaW5nIHRoZSBwcm9ibGVtIG9jY3VycmVkLlxuICovXG5jbGFzcyBQYXJzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbWVzc2FnZSwgLy8gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICB0b2tlbiAvLyBBbiBvYmplY3QgcHJvdmlkaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uXG4gICkge1xuICAgIGxldCBlcnJvciA9IFwiIFwiICsgbWVzc2FnZTtcbiAgICBsZXQgc3RhcnQ7XG5cbiAgICBjb25zdCBsb2MgPSB0b2tlbiAmJiB0b2tlbi5sb2M7XG4gICAgaWYgKGxvYyAmJiBsb2Muc3RhcnQgPD0gbG9jLmVuZCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgaW5wdXQgYW5kIGEgcG9zaXRpb24sIG1ha2UgdGhlIGVycm9yIGEgYml0IGZhbmNpZXJcblxuICAgICAgLy8gR2V0IHRoZSBpbnB1dFxuICAgICAgY29uc3QgaW5wdXQgPSBsb2MubGV4ZXIuaW5wdXQ7XG5cbiAgICAgIC8vIFByZXBlbmQgc29tZSBpbmZvcm1hdGlvblxuICAgICAgc3RhcnQgPSBsb2Muc3RhcnQ7XG4gICAgICBjb25zdCBlbmQgPSBsb2MuZW5kO1xuICAgICAgaWYgKHN0YXJ0ID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgZXJyb3IgKz0gXCIgYXQgZW5kIG9mIGlucHV0OiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yICs9IFwiIGF0IHBvc2l0aW9uIFwiICsgKHN0YXJ0ICsgMSkgKyBcIjogXFxuXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcbiAgICAgIGNvbnN0IHVuZGVybGluZWQgPSBpbnB1dC5zbGljZShzdGFydCwgZW5kKS5yZXBsYWNlKC9bXl0vZywgXCIkJlxcdTAzMzJcIik7XG5cbiAgICAgIC8vIEV4dHJhY3Qgc29tZSBjb250ZXh0IGZyb20gdGhlIGlucHV0IGFuZCBhZGQgaXQgdG8gdGhlIGVycm9yXG4gICAgICBsZXQgbGVmdDtcbiAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgIGxlZnQgPSBcIuKAplwiICsgaW5wdXQuc2xpY2Uoc3RhcnQgLSAxNSwgc3RhcnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVmdCA9IGlucHV0LnNsaWNlKDAsIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGxldCByaWdodDtcbiAgICAgIGlmIChlbmQgKyAxNSA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCwgZW5kICsgMTUpICsgXCLigKZcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kKTtcbiAgICAgIH1cbiAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gU29tZSBoYWNrZXJ5IHRvIG1ha2UgUGFyc2VFcnJvciBhIHByb3RvdHlwZSBvZiBFcnJvclxuICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NDYwNzUzXG4gICAgY29uc3Qgc2VsZiA9IG5ldyBFcnJvcihlcnJvcik7XG4gICAgc2VsZi5uYW1lID0gXCJQYXJzZUVycm9yXCI7XG4gICAgc2VsZi5fX3Byb3RvX18gPSBQYXJzZUVycm9yLnByb3RvdHlwZTtcbiAgICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbn1cblxuUGFyc2VFcnJvci5wcm90b3R5cGUuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vL1xuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsaXN0IG9mIHV0aWxpdHkgZnVuY3Rpb25zIHdoaWNoIGFyZSB1c2VmdWwgaW4gb3RoZXJcbiAqIGZpbGVzLlxuICovXG5cbi8qKlxuICogUHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaWYgYSBzZXR0aW5nIGlzIHVuZGVmaW5lZFxuICovXG5jb25zdCBkZWZsdCA9IGZ1bmN0aW9uKHNldHRpbmcsIGRlZmF1bHRJZlVuZGVmaW5lZCkge1xuICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07XG5cbi8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxuY29uc3QgdXBwZXJjYXNlID0gLyhbQS1aXSkvZztcbmNvbnN0IGh5cGhlbmF0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UodXBwZXJjYXNlLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpO1xufTtcblxuY29uc3QgRVNDQVBFX0xPT0tVUCA9IHtcbiAgXCImXCI6IFwiJmFtcDtcIixcbiAgXCI+XCI6IFwiJmd0O1wiLFxuICBcIjxcIjogXCImbHQ7XCIsXG4gICdcIic6IFwiJnF1b3Q7XCIsXG4gIFwiJ1wiOiBcIiYjeDI3O1wiXG59O1xuXG5jb25zdCBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuLyoqXG4gKiBFc2NhcGVzIHRleHQgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKHRleHQpIHtcbiAgcmV0dXJuIFN0cmluZyh0ZXh0KS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQW21hdGNoXSk7XG59XG5cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cbmNvbnN0IGdldEJhc2VFbGVtID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgaWYgKGdyb3VwLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHlbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiY29sb3JcIikge1xuICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHlbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiZm9udFwiKSB7XG4gICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLmJvZHkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBncm91cDtcbiAgfVxufTtcblxuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cbmNvbnN0IGlzQ2hhcmFjdGVyQm94ID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgY29uc3QgYmFzZUVsZW0gPSBnZXRCYXNlRWxlbShncm91cCk7XG5cbiAgLy8gVGhlc2UgYXJlIGFsbCB0aGUgdHlwZXMgb2YgZ3JvdXBzIHdoaWNoIGhvbGQgc2luZ2xlIGNoYXJhY3RlcnNcbiAgcmV0dXJuIGJhc2VFbGVtLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8IGJhc2VFbGVtLnR5cGUgPT09IFwidGV4dG9yZFwiIHx8IGJhc2VFbGVtLnR5cGUgPT09IFwiYXRvbVwiXG59O1xuXG5jb25zdCBhc3NlcnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbm9uLW51bGwsIGJ1dCBnb3QgXCIgKyBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgcHJvdG9jb2wgb2YgYSBVUkwsIG9yIFwiX3JlbGF0aXZlXCIgaWYgdGhlIFVSTCBkb2VzIG5vdCBzcGVjaWZ5IGFcbiAqIHByb3RvY29sIChhbmQgdGh1cyBpcyByZWxhdGl2ZSksIG9yIGBudWxsYCBpZiBVUkwgaGFzIGludmFsaWQgcHJvdG9jb2xcbiAqIChzbyBzaG91bGQgYmUgb3V0cmlnaHQgcmVqZWN0ZWQpLlxuICovXG5jb25zdCBwcm90b2NvbEZyb21VcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgLy8gQ2hlY2sgZm9yIHBvc3NpYmxlIGxlYWRpbmcgcHJvdG9jb2wuXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXBhcnNpbmcgc3RyaXBzIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAvLyAoXFx4MDApIG9yIEMwIGNvbnRyb2wgKFxceDAwLVxceDFGKSBjaGFyYWN0ZXJzLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICBjb25zdCBwcm90b2NvbCA9IC9eW1xceDAwLVxceDIwXSooW15cXFxcLyM/XSo/KSg6fCYjMCo1OHwmI3gwKjNhfCZjb2xvbikvaS5leGVjKHVybCk7XG4gIGlmICghcHJvdG9jb2wpIHtcbiAgICByZXR1cm4gXCJfcmVsYXRpdmVcIjtcbiAgfVxuICAvLyBSZWplY3Qgd2VpcmQgY29sb25zXG4gIGlmIChwcm90b2NvbFsyXSAhPT0gXCI6XCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBSZWplY3QgaW52YWxpZCBjaGFyYWN0ZXJzIGluIHNjaGVtZSBhY2NvcmRpbmcgdG9cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4gIGlmICghL15bYS16QS1aXVthLXpBLVowLTkrXFwtLl0qJC8udGVzdChwcm90b2NvbFsxXSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBMb3dlcmNhc2UgdGhlIHByb3RvY29sXG4gIHJldHVybiBwcm90b2NvbFsxXS50b0xvd2VyQ2FzZSgpO1xufTtcblxuLyoqXG4gKiBSb3VuZCBgbmAgdG8gNCBkZWNpbWFsIHBsYWNlcywgb3IgdG8gdGhlIG5lYXJlc3QgMS8xMCwwMDB0aCBlbS4gVGhlIFRlWGJvb2tcbiAqIGdpdmVzIGFuIGFjY2VwdGFibGUgcm91bmRpbmcgZXJyb3Igb2YgMTAwc3AgKHdoaWNoIHdvdWxkIGJlIHRoZSBuZWFyZXN0XG4gKiAxLzY1NTEuNmVtIHdpdGggb3VyIHB0UGVyRW0gPSAxMCk6XG4gKiBodHRwOi8vd3d3LmN0ZXgub3JnL2RvY3VtZW50cy9zaHJlZGRlci9zcmMvdGV4Ym9vay5wZGYjcGFnZT02OVxuICovXG5jb25zdCByb3VuZCA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuICtuLnRvRml4ZWQoNCk7XG59O1xuXG52YXIgdXRpbHMgPSB7XG4gIGRlZmx0LFxuICBlc2NhcGUsXG4gIGh5cGhlbmF0ZSxcbiAgZ2V0QmFzZUVsZW0sXG4gIGlzQ2hhcmFjdGVyQm94LFxuICBwcm90b2NvbEZyb21VcmwsXG4gIHJvdW5kXG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtb2R1bGUgZm9yIHN0b3Jpbmcgc2V0dGluZ3MgcGFzc2VkIGludG8gVGVtbWwuIEl0IGNvcnJlY3RseSBoYW5kbGVzXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICovXG5cblxuLyoqXG4gKiBUaGUgbWFpbiBTZXR0aW5ncyBvYmplY3RcbiAqL1xuY2xhc3MgU2V0dGluZ3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLy8gYWxsb3cgbnVsbCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5kaXNwbGF5TW9kZSA9IHV0aWxzLmRlZmx0KG9wdGlvbnMuZGlzcGxheU1vZGUsIGZhbHNlKTsgICAgLy8gYm9vbGVhblxuICAgIHRoaXMuYW5ub3RhdGUgPSB1dGlscy5kZWZsdChvcHRpb25zLmFubm90YXRlLCBmYWxzZSk7ICAgICAgICAgICAvLyBib29sZWFuXG4gICAgdGhpcy5sZXFubyA9IHV0aWxzLmRlZmx0KG9wdGlvbnMubGVxbm8sIGZhbHNlKTsgICAgICAgICAgICAgICAgLy8gYm9vbGVhblxuICAgIHRoaXMudGhyb3dPbkVycm9yID0gdXRpbHMuZGVmbHQob3B0aW9ucy50aHJvd09uRXJyb3IsIGZhbHNlKTsgIC8vIGJvb2xlYW5cbiAgICB0aGlzLmVycm9yQ29sb3IgPSB1dGlscy5kZWZsdChvcHRpb25zLmVycm9yQ29sb3IsIFwiI2IyMjIyMlwiKTsgIC8vIHN0cmluZ1xuICAgIHRoaXMubWFjcm9zID0gb3B0aW9ucy5tYWNyb3MgfHwge307XG4gICAgdGhpcy53cmFwID0gdXRpbHMuZGVmbHQob3B0aW9ucy53cmFwLCBcInRleFwiKTsgICAgICAgICAgICAgICAgICAgIC8vIFwidGV4XCIgfCBcIj1cIlxuICAgIHRoaXMueG1sID0gdXRpbHMuZGVmbHQob3B0aW9ucy54bWwsIGZhbHNlKTsgICAgICAgICAgICAgICAgICAgICAvLyBib29sZWFuXG4gICAgdGhpcy5jb2xvcklzVGV4dENvbG9yID0gdXRpbHMuZGVmbHQob3B0aW9ucy5jb2xvcklzVGV4dENvbG9yLCBmYWxzZSk7ICAvLyBib29lbGVhblxuICAgIHRoaXMuc3RyaWN0ID0gdXRpbHMuZGVmbHQob3B0aW9ucy5zdHJpY3QsIGZhbHNlKTsgICAgLy8gYm9vbGVhblxuICAgIHRoaXMudHJ1c3QgPSB1dGlscy5kZWZsdChvcHRpb25zLnRydXN0LCBmYWxzZSk7ICAvLyB0cnVzdCBjb250ZXh0LiBTZWUgaHRtbC5qcy5cbiAgICB0aGlzLm1heFNpemUgPSAob3B0aW9ucy5tYXhTaXplID09PSB1bmRlZmluZWRcbiAgICAgID8gW0luZmluaXR5LCBJbmZpbml0eV1cbiAgICAgIDogQXJyYXkuaXNBcnJheShvcHRpb25zLm1heFNpemUpXG4gICAgICA/IG9wdGlvbnMubWF4U2l6ZVxuICAgICAgOiBbSW5maW5pdHksIEluZmluaXR5XVxuICAgICk7XG4gICAgdGhpcy5tYXhFeHBhbmQgPSBNYXRoLm1heCgwLCB1dGlscy5kZWZsdChvcHRpb25zLm1heEV4cGFuZCwgMTAwMCkpOyAvLyBudW1iZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRvIHRlc3QgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGlucHV0LCBhbmQgcmV0dXJuXG4gICAqIGB0cnVlYCAodHJ1c3RlZCkgb3IgYGZhbHNlYCAodW50cnVzdGVkKS4gIFRoZSBzb2xlIGFyZ3VtZW50IGBjb250ZXh0YFxuICAgKiBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggYGNvbW1hbmRgIGZpZWxkIHNwZWNpZnlpbmcgdGhlIHJlbGV2YW50IExhVGVYXG4gICAqIGNvbW1hbmQgKGFzIGEgc3RyaW5nIHN0YXJ0aW5nIHdpdGggYFxcYCksIGFuZCBhbnkgb3RoZXIgYXJndW1lbnRzLCBldGMuXG4gICAqIElmIGBjb250ZXh0YCBoYXMgYSBgdXJsYCBmaWVsZCwgYSBgcHJvdG9jb2xgIGZpZWxkIHdpbGwgYXV0b21hdGljYWxseVxuICAgKiBnZXQgYWRkZWQgYnkgdGhpcyBmdW5jdGlvbiAoY2hhbmdpbmcgdGhlIHNwZWNpZmllZCBvYmplY3QpLlxuICAgKi9cbiAgaXNUcnVzdGVkKGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC51cmwgJiYgIWNvbnRleHQucHJvdG9jb2wpIHtcbiAgICAgIGNvbnN0IHByb3RvY29sID0gdXRpbHMucHJvdG9jb2xGcm9tVXJsKGNvbnRleHQudXJsKTtcbiAgICAgIGlmIChwcm90b2NvbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgY29udGV4dC5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgIH1cbiAgICBjb25zdCB0cnVzdCA9IHR5cGVvZiB0aGlzLnRydXN0ID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLnRydXN0KGNvbnRleHQpIDogdGhpcy50cnVzdDtcbiAgICByZXR1cm4gQm9vbGVhbih0cnVzdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbGwgcmVnaXN0ZXJlZCBmdW5jdGlvbnMuXG4gKiBgZnVuY3Rpb25zLmpzYCBqdXN0IGV4cG9ydHMgdGhpcyBzYW1lIGRpY3Rpb25hcnkgYWdhaW4gYW5kIG1ha2VzIGl0IHB1YmxpYy5cbiAqIGBQYXJzZXIuanNgIHJlcXVpcmVzIHRoaXMgZGljdGlvbmFyeS5cbiAqL1xuY29uc3QgX2Z1bmN0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEFsbCBNYXRoTUwgYnVpbGRlcnMuIFNob3VsZCBiZSBvbmx5IHVzZWQgaW4gdGhlIGBkZWZpbmUqYCBhbmQgdGhlIGBidWlsZCpNTGBcbiAqIGZ1bmN0aW9ucy5cbiAqL1xuY29uc3QgX21hdGhtbEdyb3VwQnVpbGRlcnMgPSB7fTtcblxuZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlLFxuICBuYW1lcyxcbiAgcHJvcHMsXG4gIGhhbmRsZXIsXG4gIG1hdGhtbEJ1aWxkZXJcbn0pIHtcbiAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGZ1bmN0aW9uc1xuICBjb25zdCBkYXRhID0ge1xuICAgIHR5cGUsXG4gICAgbnVtQXJnczogcHJvcHMubnVtQXJncyxcbiAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6ICEhcHJvcHMuYWxsb3dlZEluQXJndW1lbnQsXG4gICAgYWxsb3dlZEluVGV4dDogISFwcm9wcy5hbGxvd2VkSW5UZXh0LFxuICAgIGFsbG93ZWRJbk1hdGg6IHByb3BzLmFsbG93ZWRJbk1hdGggPT09IHVuZGVmaW5lZCA/IHRydWUgOiBwcm9wcy5hbGxvd2VkSW5NYXRoLFxuICAgIG51bU9wdGlvbmFsQXJnczogcHJvcHMubnVtT3B0aW9uYWxBcmdzIHx8IDAsXG4gICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgcHJpbWl0aXZlOiAhIXByb3BzLnByaW1pdGl2ZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICBfZnVuY3Rpb25zW25hbWVzW2ldXSA9IGRhdGE7XG4gIH1cbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAobWF0aG1sQnVpbGRlcikge1xuICAgICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVzZSB0aGlzIHRvIHJlZ2lzdGVyIG9ubHkgdGhlIE1hdGhNTCBidWlsZGVyIGZvciBhIGZ1bmN0aW9uKGUuZy5cbiAqIGlmIHRoZSBmdW5jdGlvbidzIFBhcnNlTm9kZSBpcyBnZW5lcmF0ZWQgaW4gUGFyc2VyLmpzIHJhdGhlciB0aGFuIHZpYSBhXG4gKiBzdGFuZC1hbG9uZSBoYW5kbGVyIHByb3ZpZGVkIHRvIGBkZWZpbmVGdW5jdGlvbmApLlxuICovXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHsgdHlwZSwgbWF0aG1sQnVpbGRlciB9KSB7XG4gIGRlZmluZUZ1bmN0aW9uKHtcbiAgICB0eXBlLFxuICAgIG5hbWVzOiBbXSxcbiAgICBwcm9wczogeyBudW1BcmdzOiAwIH0sXG4gICAgaGFuZGxlcigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciBiZSBjYWxsZWQuXCIpXG4gICAgfSxcbiAgICBtYXRobWxCdWlsZGVyXG4gIH0pO1xufVxuXG5jb25zdCBub3JtYWxpemVBcmd1bWVudCA9IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gYXJnLnR5cGUgPT09IFwib3JkZ3JvdXBcIiAmJiBhcmcuYm9keS5sZW5ndGggPT09IDEgPyBhcmcuYm9keVswXSA6IGFyZ1xufTtcblxuLy8gU2luY2UgdGhlIGNvcnJlc3BvbmRpbmcgYnVpbGRNYXRoTUwgZnVuY3Rpb24gZXhwZWN0cyBhXG4vLyBsaXN0IG9mIGVsZW1lbnRzLCB3ZSBub3JtYWxpemUgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBhcmd1bWVudHNcbmNvbnN0IG9yZGFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiID8gYXJnLmJvZHkgOiBbYXJnXVxufTtcblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIGRvY3VtZW50IGZyYWdtZW50LCB3aGljaCBjb250YWlucyBlbGVtZW50cywgYnV0IHdoZW5cbiAqIHBsYWNlZCBpbnRvIHRoZSBET00gZG9lc24ndCBoYXZlIGFueSByZXByZXNlbnRhdGlvbiBpdHNlbGYuIEl0IG9ubHkgY29udGFpbnNcbiAqIGNoaWxkcmVuIGFuZCBkb2Vzbid0IGhhdmUgYW55IERPTSBub2RlIHByb3BlcnRpZXMuXG4gKi9cbmNsYXNzIERvY3VtZW50RnJhZ21lbnQge1xuICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmNsYXNzZXMgPSBbXTtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gIH1cblxuICBoYXNDbGFzcyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmluY2x1ZGVzKGNsYXNzTmFtZSk7XG4gIH1cblxuICAvKiogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGUuICovXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBmcmFnO1xuICB9XG5cbiAgLyoqIENvbnZlcnQgdGhlIGZyYWdtZW50IGludG8gSFRNTCBtYXJrdXAuICovXG4gIHRvTWFya3VwKCkge1xuICAgIGxldCBtYXJrdXAgPSBcIlwiO1xuXG4gICAgLy8gU2ltcGx5IGNvbmNhdGVuYXRlIHRoZSBtYXJrdXAgZm9yIHRoZSBjaGlsZHJlbiB0b2dldGhlci5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcmt1cCArPSB0aGlzLmNoaWxkcmVuW2ldLnRvTWFya3VwKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LiBBcHBsaWVzIHRvXG4gICAqIE1hdGhEb21Ob2RlJ3Mgb25seS5cbiAgICovXG4gIHRvVGV4dCgpIHtcbiAgICAvLyBUbyBhdm9pZCB0aGlzLCB3ZSB3b3VsZCBzdWJjbGFzcyBkb2N1bWVudEZyYWdtZW50IHNlcGFyYXRlbHkgZm9yXG4gICAgLy8gTWF0aE1MLCBidXQgcG9seWZpbGxzIGZvciBzdWJjbGFzc2luZyBpcyBleHBlbnNpdmUgcGVyIFBSIDE0NjkuXG4gICAgY29uc3QgdG9UZXh0ID0gKGNoaWxkKSA9PiBjaGlsZC50b1RleHQoKTtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAodG9UZXh0KS5qb2luKFwiXCIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSB0aGUgZGF0YSBhYm91dCB0aGUgRE9NIG5vZGVzIHdlIGNyZWF0ZSwgYXMgd2VsbCBhcyBzb21lXG4gKiBleHRyYSBkYXRhLiBUaGV5IGNhbiB0aGVuIGJlIHRyYW5zZm9ybWVkIGludG8gcmVhbCBET00gbm9kZXMgd2l0aCB0aGVcbiAqIGB0b05vZGVgIGZ1bmN0aW9uIG9yIEhUTUwgbWFya3VwIHVzaW5nIGB0b01hcmt1cGAuIFRoZXkgYXJlIHVzZWZ1bCBmb3IgYm90aFxuICogc3RvcmluZyBleHRyYSBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcywgYXMgd2VsbCBhcyBwcm92aWRpbmcgYSB3YXkgdG8gZWFzaWx5XG4gKiB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBTaW1pbGFyIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIE1hdGhNTCBub2RlcyBleGlzdCBpbiBtYXRoTUxUcmVlLmpzLlxuICpcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGNsYXNzTmFtZSBiYXNlZCBvbiBhIGxpc3Qgb2YgY2xhc3Nlcy4gSW4gYWRkaXRpb24gdG8gam9pbmluZ1xuICogd2l0aCBzcGFjZXMsIHdlIGFsc28gcmVtb3ZlIGVtcHR5IGNsYXNzZXMuXG4gKi9cbmNvbnN0IGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24oY2xhc3Nlcykge1xuICByZXR1cm4gY2xhc3Nlcy5maWx0ZXIoKGNscykgPT4gY2xzKS5qb2luKFwiIFwiKTtcbn07XG5cbmNvbnN0IGluaXROb2RlID0gZnVuY3Rpb24oY2xhc3Nlcywgc3R5bGUpIHtcbiAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTtcbn07XG5cbi8qKlxuICogQ29udmVydCBpbnRvIGFuIEhUTUwgbm9kZVxuICovXG5jb25zdCB0b05vZGUgPSBmdW5jdGlvbih0YWdOYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXG4gIC8vIEFwcGx5IHRoZSBjbGFzc1xuICBub2RlLmNsYXNzTmFtZSA9IGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3Nlcyk7XG5cbiAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgfVxuICB9XG5cbiAgLy8gQXBwbHkgYXR0cmlidXRlc1xuICBmb3IgKGNvbnN0IGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIgKSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICB9XG4gIH1cblxuICAvLyBBcHBlbmQgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIEhUTUwgbm9kZXNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGludG8gYW4gSFRNTCBtYXJrdXAgc3RyaW5nXG4gKi9cbmNvbnN0IHRvTWFya3VwID0gZnVuY3Rpb24odGFnTmFtZSkge1xuICBsZXQgbWFya3VwID0gYDwke3RhZ05hbWV9YDtcblxuICAvLyBBZGQgdGhlIGNsYXNzXG4gIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgbWFya3VwICs9IGAgY2xhc3M9XCIke3V0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKX1cImA7XG4gIH1cblxuICBsZXQgc3R5bGVzID0gXCJcIjtcblxuICAvLyBBZGQgdGhlIHN0eWxlcywgYWZ0ZXIgaHlwaGVuYXRpb25cbiAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICBzdHlsZXMgKz0gYCR7dXRpbHMuaHlwaGVuYXRlKHN0eWxlKX06JHt0aGlzLnN0eWxlW3N0eWxlXX07YDtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVzKSB7XG4gICAgbWFya3VwICs9IGAgc3R5bGU9XCIke3N0eWxlc31cImA7XG4gIH1cblxuICAvLyBBZGQgdGhlIGF0dHJpYnV0ZXNcbiAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyICkpIHtcbiAgICAgIG1hcmt1cCArPSBgICR7YXR0cn09XCIke3V0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pfVwiYDtcbiAgICB9XG4gIH1cblxuICBtYXJrdXAgKz0gXCI+XCI7XG5cbiAgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICB9XG5cbiAgbWFya3VwICs9IGA8LyR7dGFnTmFtZX0+YDtcblxuICByZXR1cm4gbWFya3VwO1xufTtcblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS5cbiAqXG4gKi9cbmNsYXNzIFNwYW4ge1xuICBjb25zdHJ1Y3RvcihjbGFzc2VzLCBjaGlsZHJlbiwgc3R5bGUpIHtcbiAgICBpbml0Tm9kZS5jYWxsKHRoaXMsIGNsYXNzZXMsIHN0eWxlKTtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gIH1cblxuICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgcmV0dXJuIHRvTm9kZS5jYWxsKHRoaXMsIFwic3BhblwiKTtcbiAgfVxuXG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB0b01hcmt1cC5jYWxsKHRoaXMsIFwic3BhblwiKTtcbiAgfVxufVxuXG5sZXQgVGV4dE5vZGUkMSA9IGNsYXNzIFRleHROb2RlIHtcbiAgY29uc3RydWN0b3IodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cbiAgdG9Ob2RlKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xuICB9XG4gIHRvTWFya3VwKCkge1xuICAgIHJldHVybiB1dGlscy5lc2NhcGUodGhpcy50ZXh0KTtcbiAgfVxufTtcblxuLy8gQ3JlYXRlIGFuIDxhIGhyZWY9XCLigKZcIj4gbm9kZS5cbmNsYXNzIEFuY2hvck5vZGUge1xuICBjb25zdHJ1Y3RvcihocmVmLCBjbGFzc2VzLCBjaGlsZHJlbikge1xuICAgIHRoaXMuaHJlZiA9IGhyZWY7XG4gICAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcztcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gIH1cblxuICB0b05vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCB0aGlzLmhyZWYpO1xuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cblxuICB0b01hcmt1cCgpIHtcbiAgICBsZXQgbWFya3VwID0gYDxhIGhyZWY9JyR7dXRpbHMuZXNjYXBlKHRoaXMuaHJlZil9J2A7XG4gICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7XG4gICAgICBtYXJrdXAgKz0gYCBjbGFzcz1cIiR7dXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpfVwiYDtcbiAgICB9XG4gICAgbWFya3VwICs9IFwiPlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTtcbiAgICB9XG4gICAgbWFya3VwICs9IFwiPC9hPlwiO1xuICAgIHJldHVybiBtYXJrdXBcbiAgfVxufVxuXG4vKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYW4gaW1hZ2UgZW1iZWQgKDxpbWc+KSBlbGVtZW50LlxuICovXG5jbGFzcyBJbWcge1xuICBjb25zdHJ1Y3RvcihzcmMsIGFsdCwgc3R5bGUpIHtcbiAgICB0aGlzLmFsdCA9IGFsdDtcbiAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB0aGlzLmNsYXNzZXMgPSBbXCJtb3JkXCJdO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgfVxuXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHJldHVybiB0aGlzLmNsYXNzZXMuaW5jbHVkZXMoY2xhc3NOYW1lKTtcbiAgfVxuXG4gIHRvTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBub2RlLnNyYyA9IHRoaXMuc3JjO1xuICAgIG5vZGUuYWx0ID0gdGhpcy5hbHQ7XG4gICAgbm9kZS5jbGFzc05hbWUgPSBcIm1vcmRcIjtcblxuICAgIC8vIEFwcGx5IGlubGluZSBzdHlsZXNcbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdG9NYXJrdXAoKSB7XG4gICAgbGV0IG1hcmt1cCA9IGA8aW1nIHNyYz0nJHt0aGlzLnNyY30nIGFsdD0nJHt0aGlzLmFsdH0nYDtcblxuICAgIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICAgIGxldCBzdHlsZXMgPSBcIlwiO1xuICAgIGZvciAoY29uc3Qgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSApKSB7XG4gICAgICAgIHN0eWxlcyArPSBgJHt1dGlscy5oeXBoZW5hdGUoc3R5bGUpfToke3RoaXMuc3R5bGVbc3R5bGVdfTtgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICBtYXJrdXAgKz0gYCBzdHlsZT1cIiR7dXRpbHMuZXNjYXBlKHN0eWxlcyl9XCJgO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9XG59XG5cbi8vXG4vKipcbiAqIFRoZXNlIG9iamVjdHMgc3RvcmUgZGF0YSBhYm91dCBNYXRoTUwgbm9kZXMuXG4gKiBUaGUgYHRvTm9kZWAgYW5kIGB0b01hcmt1cGAgZnVuY3Rpb25zICBjcmVhdGUgbmFtZXNwYWNlZCBET00gbm9kZXMgYW5kXG4gKiBIVE1MIHRleHQgbWFya3VwIHJlc3BlY3RpdmVseS5cbiAqL1xuXG5cbmZ1bmN0aW9uIG5ld0RvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKTtcbn1cblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIGdlbmVyYWwgcHVycG9zZSBNYXRoTUwgbm9kZSBvZiBhbnkgdHlwZSxcbiAqIGZvciBleGFtcGxlLCBgXCJtb1wiYCBvciBgXCJtc3BhY2VcImAsIGNvcnJlc3BvbmRpbmcgdG8gYDxtbz5gIGFuZFxuICogYDxtc3BhY2U+YCB0YWdzKS5cbiAqL1xuY2xhc3MgTWF0aE5vZGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjaGlsZHJlbiwgY2xhc3Nlcywgc3R5bGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZSB8fCB7fTsgICAvLyBVc2VkIGZvciA8bXN0eWxlPiBlbGVtZW50c1xuICAgIHRoaXMubGFiZWwgPSBcIlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIG9uIGEgTWF0aE1MIG5vZGUuIE1hdGhNTCBkZXBlbmRzIG9uIGF0dHJpYnV0ZXMgdG8gY29udmV5IGFcbiAgICogc2VtYW50aWMgY29udGVudCwgc28gdGhpcyBpcyB1c2VkIGhlYXZpbHkuXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLlxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xuICB9XG5cbiAgc2V0TGFiZWwodmFsdWUpIHtcbiAgICB0aGlzLmxhYmVsID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgTWF0aE1MLW5hbWVzcGFjZWQgRE9NIGVsZW1lbnQuXG4gICAqL1xuICB0b05vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIiwgdGhpcy50eXBlKTtcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IGlubGluZSBzdHlsZXNcbiAgICBmb3IgKGNvbnN0IHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5zdHlsZSwgc3R5bGUgKSkge1xuICAgICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYW4gSFRNTCBtYXJrdXAgc3RyaW5nLlxuICAgKi9cbiAgdG9NYXJrdXAoKSB7XG4gICAgbGV0IG1hcmt1cCA9IFwiPFwiICsgdGhpcy50eXBlO1xuXG4gICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG4gICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBcIiArIGF0dHIgKyAnPVwiJztcbiAgICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICBtYXJrdXAgKz0gJ1wiJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1hcmt1cCArPSBgIGNsYXNzPVwiJHt1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSl9XCJgO1xuICAgIH1cblxuICAgIGxldCBzdHlsZXMgPSBcIlwiO1xuXG4gICAgLy8gQWRkIHRoZSBzdHlsZXMsIGFmdGVyIGh5cGhlbmF0aW9uXG4gICAgZm9yIChjb25zdCBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuc3R5bGUsIHN0eWxlICkpIHtcbiAgICAgICAgc3R5bGVzICs9IGAke3V0aWxzLmh5cGhlbmF0ZShzdHlsZSl9OiR7dGhpcy5zdHlsZVtzdHlsZV19O2A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgbWFya3VwICs9IGAgc3R5bGU9XCIke3N0eWxlc31cImA7XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgc3RyaW5nLCBzaW1pbGFyIHRvIGlubmVyVGV4dCwgYnV0IGVzY2FwZWQuXG4gICAqL1xuICB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQudG9UZXh0KCkpLmpvaW4oXCJcIik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHBpZWNlIG9mIHRleHQuXG4gKi9cbmNsYXNzIFRleHROb2RlIHtcbiAgY29uc3RydWN0b3IodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgRE9NIHRleHQgbm9kZS5cbiAgICovXG4gIHRvTm9kZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gZXNjYXBlZCBIVE1MIG1hcmt1cFxuICAgKiAocmVwcmVzZW50aW5nIHRoZSB0ZXh0IGl0c2VsZikuXG4gICAqL1xuICB0b01hcmt1cCgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXNjYXBlKHRoaXMudG9UZXh0KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIHN0cmluZ1xuICAgKiAocmVwcmVzZW50aW5nIHRoZSB0ZXh0IGl0c2VsZikuXG4gICAqL1xuICB0b1RleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgfVxufVxuXG4vLyBEbyBub3QgbWFrZSBhbiA8bXJvdz4gdGhlIG9ubHkgY2hpbGQgb2YgYSA8bXN0eWxlPi5cbi8vIEFuIDxtc3R5bGU+IGFjdHMgYXMgaXRzIG93biBpbXBsaWNpdCA8bXJvdz4uXG5jb25zdCB3cmFwV2l0aE1zdHlsZSA9IGV4cHJlc3Npb24gPT4ge1xuICBsZXQgbm9kZTtcbiAgaWYgKGV4cHJlc3Npb24ubGVuZ3RoID09PSAxICYmIGV4cHJlc3Npb25bMF0udHlwZSA9PT0gXCJtcm93XCIpIHtcbiAgICBub2RlID0gZXhwcmVzc2lvbi5wb3AoKTtcbiAgICBub2RlLnR5cGUgPSBcIm1zdHlsZVwiO1xuICB9IGVsc2Uge1xuICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtc3R5bGVcIiwgZXhwcmVzc2lvbik7XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnZhciBtYXRoTUxUcmVlID0ge1xuICBNYXRoTm9kZSxcbiAgVGV4dE5vZGUsXG4gIG5ld0RvY3VtZW50RnJhZ21lbnRcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIHByb3ZpZGVzIHN1cHBvcnQgZm9yIGJ1aWxkaW5nIGhvcml6b250YWwgc3RyZXRjaHkgZWxlbWVudHMuXG4gKi9cblxuXG4vLyBUT0RPOiBSZW1vdmUgd2hlbiBDaHJvbWl1bSBzdHJldGNoZXMgXFx3aWRldGlsZGUgJiBcXHdpZGVoYXRcbmNvbnN0IGVzdGltYXRlZFdpZHRoID0gbm9kZSA9PiB7XG4gIGxldCB3aWR0aCA9IDA7XG4gIGlmIChub2RlLmJvZHkpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygbm9kZS5ib2R5KSB7XG4gICAgICB3aWR0aCArPSBlc3RpbWF0ZWRXaWR0aChpdGVtKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgd2lkdGggKz0gZXN0aW1hdGVkV2lkdGgobm9kZS5iYXNlKTtcbiAgICBpZiAobm9kZS5zdWIpIHsgd2lkdGggKz0gMC43ICogZXN0aW1hdGVkV2lkdGgobm9kZS5zdWIpOyB9XG4gICAgaWYgKG5vZGUuc3VwKSB7IHdpZHRoICs9IDAuNyAqIGVzdGltYXRlZFdpZHRoKG5vZGUuc3VwKTsgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJtYXRob3JkXCIgfHwgbm9kZS50eXBlID09PSBcInRleHRvcmRcIikge1xuICAgIGZvciAoY29uc3QgY2ggb2Ygbm9kZS50ZXh0LnNwbGl0KCcnKSkge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gY2guY29kZVBvaW50QXQoMCk7XG4gICAgICBpZiAoKDB4NjAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHg3QikgfHwgKDB4MDNCMCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDNDQSkpIHtcbiAgICAgICAgd2lkdGggKz0gMC41NjsgLy8gbG93ZXIgY2FzZSBsYXRpbiBvciBncmVlay4gVXNlIGFkdmFuY2Ugd2lkdGggb2YgbGV0dGVyIG5cbiAgICAgIH0gZWxzZSBpZiAoMHgyRiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDNBKSB7XG4gICAgICAgIHdpZHRoICs9IDAuNTA7IC8vIG51bWVyYWxzLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggKz0gMC45MjsgLy8gYWR2YW5jZSB3aWR0aCBvZiBsZXR0ZXIgTVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aWR0aCArPSAxLjA7XG4gIH1cbiAgcmV0dXJuIHdpZHRoXG59O1xuXG5jb25zdCBzdHJldGNoeUNvZGVQb2ludCA9IHtcbiAgd2lkZWhhdDogXCJeXCIsXG4gIHdpZGVjaGVjazogXCLLh1wiLFxuICB3aWRldGlsZGU6IFwiflwiLFxuICB3aWRlcGFyZW46IFwi4o+cXCIsIC8vIFxcdTIzZGNcbiAgdXRpbGRlOiBcIn5cIixcbiAgb3ZlcmxlZnRhcnJvdzogXCJcXHUyMTkwXCIsXG4gIHVuZGVybGVmdGFycm93OiBcIlxcdTIxOTBcIixcbiAgeGxlZnRhcnJvdzogXCJcXHUyMTkwXCIsXG4gIG92ZXJyaWdodGFycm93OiBcIlxcdTIxOTJcIixcbiAgdW5kZXJyaWdodGFycm93OiBcIlxcdTIxOTJcIixcbiAgeHJpZ2h0YXJyb3c6IFwiXFx1MjE5MlwiLFxuICB1bmRlcmJyYWNlOiBcIlxcdTIzZGZcIixcbiAgb3ZlcmJyYWNlOiBcIlxcdTIzZGVcIixcbiAgb3Zlcmdyb3VwOiBcIlxcdTIzZTBcIixcbiAgb3ZlcnBhcmVuOiBcIuKPnFwiLFxuICB1bmRlcmdyb3VwOiBcIlxcdTIzZTFcIixcbiAgdW5kZXJwYXJlbjogXCJcXHUyM2RkXCIsXG4gIG92ZXJsZWZ0cmlnaHRhcnJvdzogXCJcXHUyMTk0XCIsXG4gIHVuZGVybGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjE5NFwiLFxuICB4bGVmdHJpZ2h0YXJyb3c6IFwiXFx1MjE5NFwiLFxuICBPdmVycmlnaHRhcnJvdzogXCJcXHUyMWQyXCIsXG4gIHhSaWdodGFycm93OiBcIlxcdTIxZDJcIixcbiAgb3ZlcmxlZnRoYXJwb29uOiBcIlxcdTIxYmNcIixcbiAgeGxlZnRoYXJwb29udXA6IFwiXFx1MjFiY1wiLFxuICBvdmVycmlnaHRoYXJwb29uOiBcIlxcdTIxYzBcIixcbiAgeHJpZ2h0aGFycG9vbnVwOiBcIlxcdTIxYzBcIixcbiAgeExlZnRhcnJvdzogXCJcXHUyMWQwXCIsXG4gIHhMZWZ0cmlnaHRhcnJvdzogXCJcXHUyMWQ0XCIsXG4gIHhob29rbGVmdGFycm93OiBcIlxcdTIxYTlcIixcbiAgeGhvb2tyaWdodGFycm93OiBcIlxcdTIxYWFcIixcbiAgeG1hcHN0bzogXCJcXHUyMWE2XCIsXG4gIHhyaWdodGhhcnBvb25kb3duOiBcIlxcdTIxYzFcIixcbiAgeGxlZnRoYXJwb29uZG93bjogXCJcXHUyMWJkXCIsXG4gIHh0d29oZWFkbGVmdGFycm93OiBcIlxcdTIxOWVcIixcbiAgeHR3b2hlYWRyaWdodGFycm93OiBcIlxcdTIxYTBcIixcbiAgeGxvbmdlcXVhbDogXCI9XCIsXG4gIHhyaWdodGxlZnRhcnJvd3M6IFwiXFx1MjFjNFwiLFxuICB5aWVsZHM6IFwiXFx1MjE5MlwiLFxuICB5aWVsZHNMZWZ0OiBcIlxcdTIxOTBcIixcbiAgbWVzb21lcmlzbTogXCJcXHUyMTk0XCIsXG4gIGxvbmdyaWdodGhhcnBvb251cDogXCJcXHUyMWMwXCIsXG4gIGxvbmdsZWZ0aGFycG9vbmRvd246IFwiXFx1MjFiZFwiLFxuICBlcXJpZ2h0aGFycG9vbnVwOiBcIlxcdTIxYzBcIixcbiAgZXFsZWZ0aGFycG9vbmRvd246IFwiXFx1MjFiZFwiLFxuICBcIlxcXFxjZHJpZ2h0YXJyb3dcIjogXCJcXHUyMTkyXCIsXG4gIFwiXFxcXGNkbGVmdGFycm93XCI6IFwiXFx1MjE5MFwiLFxuICBcIlxcXFxjZGxvbmdlcXVhbFwiOiBcIj1cIlxufTtcblxuY29uc3QgbWF0aE1Mbm9kZSA9IGZ1bmN0aW9uKGxhYmVsKSB7XG4gIGNvbnN0IGNoaWxkID0gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoc3RyZXRjaHlDb2RlUG9pbnRbbGFiZWwuc2xpY2UoMSldKTtcbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW2NoaWxkXSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICByZXR1cm4gbm9kZVxufTtcblxuY29uc3QgY3Jvb2tlZFdpZGVzID0gW1wiXFxcXHdpZGV0aWxkZVwiLCBcIlxcXFx3aWRlaGF0XCIsIFwiXFxcXHdpZGVjaGVja1wiLCBcIlxcXFx1dGlsZGVcIl07XG5cbi8vIFRPRE86IFJlbW92ZSB3aGVuIENocm9taXVtIHN0cmV0Y2hlcyBcXHdpZGV0aWxkZSAmIFxcd2lkZWhhdFxuY29uc3QgYWNjZW50Tm9kZSA9IChncm91cCkgPT4ge1xuICBjb25zdCBtbyA9IG1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICBpZiAoY3Jvb2tlZFdpZGVzLmluY2x1ZGVzKGdyb3VwLmxhYmVsKSkge1xuICAgIGNvbnN0IHdpZHRoID0gZXN0aW1hdGVkV2lkdGgoZ3JvdXAuYmFzZSk7XG4gICAgaWYgKDEgPCB3aWR0aCAmJiB3aWR0aCA8IDEuNikge1xuICAgICAgbW8uY2xhc3Nlcy5wdXNoKFwidG1sLWNyb29rZWQtMlwiKTtcbiAgICB9IGVsc2UgaWYgKDEuNiA8PSB3aWR0aCAmJiB3aWR0aCA8IDIuNSkge1xuICAgICAgbW8uY2xhc3Nlcy5wdXNoKFwidG1sLWNyb29rZWQtM1wiKTtcbiAgICB9IGVsc2UgaWYgKDIuNSA8PSB3aWR0aCkge1xuICAgICAgbW8uY2xhc3Nlcy5wdXNoKFwidG1sLWNyb29rZWQtNFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vXG59O1xuXG52YXIgc3RyZXRjaHkgPSB7XG4gIG1hdGhNTG5vZGUsXG4gIGFjY2VudE5vZGVcbn07XG5cbi8qKlxuICogVGhpcyBmaWxlIGhvbGRzIGEgbGlzdCBvZiBhbGwgbm8tYXJndW1lbnQgZnVuY3Rpb25zIGFuZCBzaW5nbGUtY2hhcmFjdGVyXG4gKiBzeW1ib2xzIChsaWtlICdhJyBvciAnOycpLlxuICpcbiAqIEZvciBlYWNoIG9mIHRoZSBzeW1ib2xzLCB0aGVyZSBhcmUgdHdvIHByb3BlcnRpZXMgdGhleSBjYW4gaGF2ZTpcbiAqIC0gZ3JvdXAgKHJlcXVpcmVkKTogdGhlIFBhcnNlTm9kZSBncm91cCB0eXBlIHRoZSBzeW1ib2wgc2hvdWxkIGhhdmUgKGkuZS5cbiAgICAgXCJ0ZXh0b3JkXCIsIFwibWF0aG9yZFwiLCBldGMpLlxuICogLSByZXBsYWNlOiB0aGUgY2hhcmFjdGVyIHRoYXQgdGhpcyBzeW1ib2wgb3IgZnVuY3Rpb24gc2hvdWxkIGJlXG4gKiAgIHJlcGxhY2VkIHdpdGggKGkuZS4gXCJcXHBoaVwiIGhhcyBhIHJlcGxhY2UgdmFsdWUgb2YgXCJcXHUwM2Q1XCIsIHRoZSBwaGlcbiAqICAgY2hhcmFjdGVyIGluIHRoZSBtYWluIGZvbnQpLlxuICpcbiAqIFRoZSBvdXRlcm1vc3QgbWFwIGluIHRoZSB0YWJsZSBpbmRpY2F0ZXMgd2hhdCBtb2RlIHRoZSBzeW1ib2xzIHNob3VsZCBiZVxuICogYWNjZXB0ZWQgaW4gKGUuZy4gXCJtYXRoXCIgb3IgXCJ0ZXh0XCIpLlxuICovXG5cbi8vIFNvbWUgb2YgdGhlc2UgaGF2ZSBhIFwiLXRva2VuXCIgc3VmZml4IHNpbmNlIHRoZXNlIGFyZSBhbHNvIHVzZWQgYXMgYFBhcnNlTm9kZWBcbi8vIHR5cGVzIGZvciByYXcgdGV4dCB0b2tlbnMsIGFuZCB3ZSB3YW50IHRvIGF2b2lkIGNvbmZsaWN0cyB3aXRoIGhpZ2hlci1sZXZlbFxuLy8gYFBhcnNlTm9kZWAgdHlwZXMuIFRoZXNlIGBQYXJzZU5vZGVgcyBhcmUgY29uc3RydWN0ZWQgd2l0aGluIGBQYXJzZXJgIGJ5XG4vLyBsb29raW5nIHVwIHRoZSBgc3ltYm9sc2AgbWFwLlxuY29uc3QgQVRPTVMgPSB7XG4gIGJpbjogMSxcbiAgY2xvc2U6IDEsXG4gIGlubmVyOiAxLFxuICBvcGVuOiAxLFxuICBwdW5jdDogMSxcbiAgcmVsOiAxXG59O1xuY29uc3QgTk9OX0FUT01TID0ge1xuICBcImFjY2VudC10b2tlblwiOiAxLFxuICBtYXRob3JkOiAxLFxuICBcIm9wLXRva2VuXCI6IDEsXG4gIHNwYWNpbmc6IDEsXG4gIHRleHRvcmQ6IDFcbn07XG5cbmNvbnN0IHN5bWJvbHMgPSB7XG4gIG1hdGg6IHt9LFxuICB0ZXh0OiB7fVxufTtcblxuLyoqIGBhY2NlcHRVbmljb2RlQ2hhciA9IHRydWVgIGlzIG9ubHkgYXBwbGljYWJsZSBpZiBgcmVwbGFjZWAgaXMgc2V0LiAqL1xuZnVuY3Rpb24gZGVmaW5lU3ltYm9sKG1vZGUsIGdyb3VwLCByZXBsYWNlLCBuYW1lLCBhY2NlcHRVbmljb2RlQ2hhcikge1xuICBzeW1ib2xzW21vZGVdW25hbWVdID0geyBncm91cCwgcmVwbGFjZSB9O1xuXG4gIGlmIChhY2NlcHRVbmljb2RlQ2hhciAmJiByZXBsYWNlKSB7XG4gICAgc3ltYm9sc1ttb2RlXVtyZXBsYWNlXSA9IHN5bWJvbHNbbW9kZV1bbmFtZV07XG4gIH1cbn1cblxuLy8gU29tZSBhYmJyZXZpYXRpb25zIGZvciBjb21tb25seSB1c2VkIHN0cmluZ3MuXG4vLyBUaGlzIGhlbHBzIG1pbmlmeSB0aGUgY29kZSwgYW5kIGFsc28gc3BvdHRpbmcgdHlwb3MgdXNpbmcganNoaW50LlxuXG4vLyBtb2RlczpcbmNvbnN0IG1hdGggPSBcIm1hdGhcIjtcbmNvbnN0IHRleHQgPSBcInRleHRcIjtcblxuLy8gZ3JvdXBzOlxuY29uc3QgYWNjZW50ID0gXCJhY2NlbnQtdG9rZW5cIjtcbmNvbnN0IGJpbiA9IFwiYmluXCI7XG5jb25zdCBjbG9zZSA9IFwiY2xvc2VcIjtcbmNvbnN0IGlubmVyID0gXCJpbm5lclwiO1xuY29uc3QgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xuY29uc3Qgb3AgPSBcIm9wLXRva2VuXCI7XG5jb25zdCBvcGVuID0gXCJvcGVuXCI7XG5jb25zdCBwdW5jdCA9IFwicHVuY3RcIjtcbmNvbnN0IHJlbCA9IFwicmVsXCI7XG5jb25zdCBzcGFjaW5nID0gXCJzcGFjaW5nXCI7XG5jb25zdCB0ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7XG5cbi8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG5cbi8vIFJlbGF0aW9uIFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2MVwiLCBcIlxcXFxlcXVpdlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3YVwiLCBcIlxcXFxwcmVjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjdiXCIsIFwiXFxcXHN1Y2NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2MyXCIsIFwiXFxcXHBlcnBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYWZcIiwgXCJcXFxccHJlY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWIwXCIsIFwiXFxcXHN1Y2NlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0M1wiLCBcIlxcXFxzaW1lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0Y1wiLCBcIlxcXFxiYWNrY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwifFwiLCBcIlxcXFxtaWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNmFcIiwgXCJcXFxcbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNmJcIiwgXCJcXFxcZ2dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNGRcIiwgXCJcXFxcYXN5bXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjVcIiwgXCJcXFxccGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21pbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOTFcIiwgXCJcXFxcc3FzdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI5MlwiLCBcIlxcXFxzcXN1cHNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjUwXCIsIFwiXFxcXGRvdGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXGZyb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjBiXCIsIFwiXFxcXG5pXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjBjXCIsIFwiXFxcXG5vdG5pXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjFkXCIsIFwiXFxcXHByb3B0b1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhMlwiLCBcIlxcXFx2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhM1wiLCBcIlxcXFxkYXNodlwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxvd25zXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU4XCIsIFwiXFxcXGFyY2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU5XCIsIFwiXFxcXHdlZGdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1YVwiLCBcIlxcXFx2ZWVlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1YlwiLCBcIlxcXFxzdGFyZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNWRcIiwgXCJcXFxcZXFkZWZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNWVcIiwgXCJcXFxcbWVhc2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjVmXCIsIFwiXFxcXHF1ZXN0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjBcIiwgXCJcXFxcbmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjBcIiwgXCJcXFxcbmVxXCIpO1xuLy8gdW5pY29kZW1hdGhcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE3NVwiLCBcIlxcXFxlcWVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTc2XCIsIFwiXFxcXGVxZXFlcVwiLCB0cnVlKTtcbi8vIG1hdGh0b29scy5zdHlcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzN1wiLCBcIlxcXFxkYmxjb2xvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1NFwiLCBcIlxcXFxjb2xvbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1NVwiLCBcIlxcXFxlcXFjb2xvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzOVwiLCBcIlxcXFxlcWNvbG9uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyQTc0XCIsIFwiXFxcXENvbG9uZXFxXCIsIHRydWUpO1xuXG4vLyBQdW5jdHVhdGlvblxuZGVmaW5lU3ltYm9sKG1hdGgsIHB1bmN0LCBcIlxcdTAwMmVcIiwgXCJcXFxcbGRvdHBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcHVuY3QsIFwiXFx1MDBiN1wiLCBcIlxcXFxjZG90cFwiKTtcblxuLy8gTWlzYyBTeW1ib2xzXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMDIzXCIsIFwiXFxcXCNcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMDIzXCIsIFwiXFxcXCNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMDI2XCIsIFwiXFxcXCZcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMDI2XCIsIFwiXFxcXCZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTM1XCIsIFwiXFxcXGFsZXBoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwMFwiLCBcIlxcXFxmb3JhbGxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhiYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjAzXCIsIFwiXFxcXGV4aXN0c1wiLCB0cnVlKTtcbi8vIOKIhyBpcyBhY3R1YWxseSBhIHVuYXJ5IG9wZXJhdG9yLCBub3QgYmluYXJ5LiBCdXQgdGhpcyB3b3Jrcy5cbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIwN1wiLCBcIlxcXFxuYWJsYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NmRcIiwgXCJcXFxcZmxhdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMTNcIiwgXCJcXFxcZWxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2ZVwiLCBcIlxcXFxuYXR1cmFsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi4oSrXCIsIFwiXFxcXEFuZ3N0cm9tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi4oSrXCIsIFwiXFxcXEFuZ3N0cm9tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2M1wiLCBcIlxcXFxjbHVic3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjdcIiwgXCJcXFxcdmFyY2x1YnN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTE4XCIsIFwiXFxcXHdwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2ZlwiLCBcIlxcXFxzaGFycFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjJcIiwgXCJcXFxcZGlhbW9uZHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjY2XCIsIFwiXFxcXHZhcmRpYW1vbmRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2NVwiLCBcIlxcXFx2YXJoZWFydHN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTExXCIsIFwiXFxcXEltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY2MFwiLCBcIlxcXFxzcGFkZXN1aXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjY0XCIsIFwiXFxcXHZhcnNwYWRlc3VpdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2NDBcIiwgXCJcXFxcZmVtYWxlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjY0MlwiLCBcIlxcXFxtYWxlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhN1wiLCBcIlxcXFxTXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhN1wiLCBcIlxcXFxTXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBiNlwiLCBcIlxcXFxQXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBiNlwiLCBcIlxcXFxQXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjYzYVwiLCBcIlxcXFxzbWlsZXlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNjNhXCIsIFwiXFxcXHNtaWxleVwiLCB0cnVlKTtcblxuLy8gTWF0aCBhbmQgVGV4dFxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAyMFwiLCBcIlxcXFxkYWdcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMjBcIiwgXCJcXFxcdGV4dGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcdGV4dGRhZ2dlcmRibFwiKTtcblxuLy8gTGFyZ2UgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIzYjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTIzYjBcIiwgXCJcXFxcbG1vdXN0YWNoZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI3ZWVcIiwgXCJcXFxcbGdyb3VwXCIsIHRydWUpO1xuXG4vLyBCaW5hcnkgT3BlcmF0b3JzXG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTNcIiwgXCJcXFxcbXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjhlXCIsIFwiXFxcXHVwbHVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjkzXCIsIFwiXFxcXHNxY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5NFwiLCBcIlxcXFxzcWN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjVlZlwiLCBcIlxcXFxiaWdjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjQwXCIsIFwiXFxcXHdyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyYTNmXCIsIFwiXFxcXGFtYWxnXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUwMDI2XCIsIFwiXFxcXEFuZFwiKTsgLy8gZnJvbSBhbXNtYXRoXG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBRkRcIiwgXCJcXFxcc3NsYXNoXCIsIHRydWUpOyAvLyBmcm9tIHN0bWFyeXJkXG5cbi8vIEFycm93IFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmNVwiLCBcIlxcXFxsb25nbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWQwXCIsIFwiXFxcXExlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjdmOFwiLCBcIlxcXFxMb25nbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2Y2XCIsIFwiXFxcXGxvbmdyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWQyXCIsIFwiXFxcXFJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZjlcIiwgXCJcXFxcTG9uZ3JpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTRcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZjdcIiwgXCJcXFxcbG9uZ2xlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWQ0XCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyN2ZhXCIsIFwiXFxcXExvbmdsZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhNFwiLCBcIlxcXFxtYXBzZnJvbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhNlwiLCBcIlxcXFxtYXBzdG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI3ZmNcIiwgXCJcXFxcbG9uZ21hcHN0b1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5N1wiLCBcIlxcXFxuZWFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWE5XCIsIFwiXFxcXGhvb2tsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYWFcIiwgXCJcXFxcaG9va3JpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOThcIiwgXCJcXFxcc2VhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiY1wiLCBcIlxcXFxsZWZ0aGFycG9vbnVwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWMwXCIsIFwiXFxcXHJpZ2h0aGFycG9vbnVwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTk5XCIsIFwiXFxcXHN3YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYmRcIiwgXCJcXFxcbGVmdGhhcnBvb25kb3duXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWMxXCIsIFwiXFxcXHJpZ2h0aGFycG9vbmRvd25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTZcIiwgXCJcXFxcbndhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjY1wiLCBcIlxcXFxyaWdodGxlZnRoYXJwb29uc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTIxYWZcIiwgXCJcXFxcbGlnaHRuaW5nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjIwRVwiLCBcIlxcXFxRRURcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyMDMwXCIsIFwiXFxcXHBlcm1pbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMzBcIiwgXCJcXFxccGVybWlsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjYwOVwiLCBcIlxcXFxhc3Ryb3N1blwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTI2M2NcIiwgXCJcXFxcc3VuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjYzZVwiLCBcIlxcXFxsZWZ0bW9vblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTI2M2RcIiwgXCJcXFxccmlnaHRtb29uXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MjI5NVwiLCBcIlxcXFxFYXJ0aFwiKTtcblxuLy8gQU1TIE5lZ2F0ZWQgQmluYXJ5IFJlbGF0aW9uc1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjZlXCIsIFwiXFxcXG5sZXNzXCIsIHRydWUpO1xuLy8gU3ltYm9sIG5hbWVzIHByZWNlZWRlZCBieSBcIkBcIiBlYWNoIGhhdmUgYSBjb3JyZXNwb25kaW5nIG1hY3JvLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg3XCIsIFwiXFxcXGxuZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjhcIiwgXCJcXFxcbG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjhcXHVmZTAwXCIsIFwiXFxcXGx2ZXJ0bmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlNlwiLCBcIlxcXFxsbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4OVwiLCBcIlxcXFxsbmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4MFwiLCBcIlxcXFxucHJlY1wiLCB0cnVlKTtcbi8vIHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIyZTAgdG8gXFxucHJlY2N1cmx5ZXEuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZTBcIiwgXCJcXFxcbnByZWNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlOFwiLCBcIlxcXFxwcmVjbnNpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiOVwiLCBcIlxcXFxwcmVjbmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0MVwiLCBcIlxcXFxuc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjI0XCIsIFwiXFxcXG5taWRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjRcIiwgXCJcXFxcbnNob3J0bWlkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmFjXCIsIFwiXFxcXG52ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJhZFwiLCBcIlxcXFxudkRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZWFcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJlY1wiLCBcIlxcXFxudHJpYW5nbGVsZWZ0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODRcIiwgXCJcXFxcbnN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4NVwiLCBcIlxcXFxuc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjhhXCIsIFwiXFxcXHN1YnNldG5lcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4YVxcdWZlMDBcIiwgXCJcXFxcdmFyc3Vic2V0bmVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhY2JcXHVmZTAwXCIsIFwiXFxcXHZhcnN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNmZcIiwgXCJcXFxcbmd0clwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4OFwiLCBcIlxcXFxnbmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY5XFx1ZmUwMFwiLCBcIlxcXFxndmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZTdcIiwgXCJcXFxcZ25zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOGFcIiwgXCJcXFxcZ25hcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODFcIiwgXCJcXFxcbnN1Y2NcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMmUxIHRvIFxcbnN1Y2NjdXJseWVxLiBXZSdsbCB1c2UgdGhlIEFNUyBzeW5vbnltLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmUxXCIsIFwiXFxcXG5zdWNjZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZTlcIiwgXCJcXFxcc3VjY25zaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMjQ2IHRvIFxcc2ltbmVxcS4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIyNlwiLCBcIlxcXFxucGFyYWxsZWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjZcIiwgXCJcXFxcbnNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYWZcIiwgXCJcXFxcblZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmViXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmVkXCIsIFwiXFxcXG50cmlhbmdsZXJpZ2h0ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyOGJcIiwgXCJcXFxcc3Vwc2V0bmVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjhiXCIsIFwiXFxcXHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFjY1wiLCBcIlxcXFxzdXBzZXRuZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWNjXFx1ZmUwMFwiLCBcIlxcXFx2YXJzdXBzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmFlXCIsIFwiXFxcXG5WZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiNVwiLCBcIlxcXFxwcmVjbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmFiNlwiLCBcIlxcXFxzdWNjbmVxcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiNFwiLCBcIlxcXFx1bmxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiNVwiLCBcIlxcXFx1bnJoZFwiKTtcblxuLy8gQU1TIE5lZ2F0ZWQgQXJyb3dzXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOWFcIiwgXCJcXFxcbmxlZnRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5YlwiLCBcIlxcXFxucmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjZFwiLCBcIlxcXFxuTGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNmXCIsIFwiXFxcXG5SaWdodGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWFlXCIsIFwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjZVwiLCBcIlxcXFxuTGVmdHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5cbi8vIEFNUyBNaXNjXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI1YjNcIiwgXCJcXFxcdmFydHJpYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1YmRcIiwgXCJcXFxcdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjVjYVwiLCBcIlxcXFxsb3plbmdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYWVcIiwgXCJcXFxcY2lyY2xlZFJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGFlXCIsIFwiXFxcXGNpcmNsZWRSXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFx0ZXh0cmVnaXN0ZXJlZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMjFcIiwgXCJcXFxcbWVhc3VyZWRhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDRcIiwgXCJcXFxcbmV4aXN0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEzMlwiLCBcIlxcXFxGaW52XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjE0MVwiLCBcIlxcXFxHYW1lXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAzNVwiLCBcIlxcXFxiYWNrcHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDM2XCIsIFwiXFxcXGJhY2tkcHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDM3XCIsIFwiXFxcXGJhY2t0cnByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjViMlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjViY1wiLCBcIlxcXFxibGFja3RyaWFuZ2xlZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1YTBcIiwgXCJcXFxcYmxhY2tzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyOWViXCIsIFwiXFxcXGJsYWNrbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI2MDVcIiwgXCJcXFxcYmlnc3RhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMjJcIiwgXCJcXFxcc3BoZXJpY2FsYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjAxXCIsIFwiXFxcXGNvbXBsZW1lbnRcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBVK0YwIHRvIFxcbWF0aGV0aC4gV2UgbWFwIHRvIEFNUyBmdW5jdGlvbiBcXGV0aFxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBmMFwiLCBcIlxcXFxldGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGYwXCIsIFwiXFx1MDBmMFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1NzFcIiwgXCJcXFxcZGlhZ3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxCb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBVK0E1IHRvIFxcbWF0aHllbi4gV2UgbWFwIHRvIEFNUyBmdW5jdGlvbiBcXHllblxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhNVwiLCBcIlxcXFx5ZW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGE1XCIsIFwiXFxcXHllblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTI3MTNcIiwgXCJcXFxcY2hlY2ttYXJrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjcxM1wiLCBcIlxcXFxjaGVja21hcmtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyNzE3XCIsIFwiXFxcXGJhbGxvdHhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNzE3XCIsIFwiXFxcXGJhbGxvdHhcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDIyXCIsIFwiXFxcXHRleHRidWxsZXRcIik7XG5cbi8vIEFNUyBIZWJyZXdcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMzZcIiwgXCJcXFxcYmV0aFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjEzN1wiLCBcIlxcXFxnaW1lbFwiLCB0cnVlKTtcblxuLy8gQU1TIEdyZWVrXG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwM2RkXCIsIFwiXFxcXGRpZ2FtbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwM2YwXCIsIFwiXFxcXHZhcmthcHBhXCIpO1xuXG4vLyBBTVMgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjMxQ1wiLCBcIlxcXFx1bGNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyMzFEXCIsIFwiXFxcXHVyY29ybmVyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjMxRVwiLCBcIlxcXFxsbGNvcm5lclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyMzFGXCIsIFwiXFxcXGxyY29ybmVyXCIsIHRydWUpO1xuXG4vLyBBTVMgQmluYXJ5IFJlbGF0aW9uc1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjY2XCIsIFwiXFxcXGxlcXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhN2RcIiwgXCJcXFxcbGVxc2xhbnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhOTVcIiwgXCJcXFxcZXFzbGFudGxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzJcIiwgXCJcXFxcbGVzc3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MmE4NVwiLCBcIlxcXFxsZXNzYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjRhXCIsIFwiXFxcXGFwcHJveGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQ2XCIsIFwiXFxcXGxlc3Nkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjc2XCIsIFwiXFxcXGxlc3NndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZGFcIiwgXCJcXFxcbGVzc2VxZ3RyXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYThiXCIsIFwiXFxcXGxlc3NlcXFndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcZG90ZXFkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTNcIiwgXCJcXFxccmlzaW5nZG90c2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjUyXCIsIFwiXFxcXGZhbGxpbmdkb3RzZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyM2RcIiwgXCJcXFxcYmFja3NpbVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJjZFwiLCBcIlxcXFxiYWNrc2ltZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYzVcIiwgXCJcXFxcc3Vic2V0ZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmQwXCIsIFwiXFxcXFN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4ZlwiLCBcIlxcXFxzcXN1YnNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3Y1wiLCBcIlxcXFxwcmVjY3VybHllcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkZVwiLCBcIlxcXFxjdXJseWVxcHJlY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3ZVwiLCBcIlxcXFxwcmVjc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI3XCIsIFwiXFxcXHByZWNhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjJcIiwgXCJcXFxcdmFydHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmI0XCIsIFwiXFxcXHRyaWFuZ2xlbGVmdGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXHZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmFiXCIsIFwiXFxcXFZEYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmFhXCIsIFwiXFxcXFZ2ZGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjMyM1wiLCBcIlxcXFxzbWFsbHNtaWxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXHNtYWxsZnJvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNGZcIiwgXCJcXFxcYnVtcGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjRlXCIsIFwiXFxcXEJ1bXBlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2N1wiLCBcIlxcXFxnZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTdlXCIsIFwiXFxcXGdlcXNsYW50XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTk2XCIsIFwiXFxcXGVxc2xhbnRndHJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzNcIiwgXCJcXFxcZ3Ryc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYTg2XCIsIFwiXFxcXGd0cmFwcHJveFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJkN1wiLCBcIlxcXFxndHJkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjc3XCIsIFwiXFxcXGd0cmxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZGJcIiwgXCJcXFxcZ3RyZXFsZXNzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYThjXCIsIFwiXFxcXGd0cmVxcWxlc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTZcIiwgXCJcXFxcZXFjaXJjXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjU3XCIsIFwiXFxcXGNpcmNlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI1Y1wiLCBcIlxcXFx0cmlhbmdsZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcdGhpY2tzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDhcIiwgXCJcXFxcdGhpY2thcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhYzZcIiwgXCJcXFxcc3Vwc2V0ZXFxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmQxXCIsIFwiXFxcXFN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI5MFwiLCBcIlxcXFxzcXN1cHNldFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3ZFwiLCBcIlxcXFxzdWNjY3VybHllcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJkZlwiLCBcIlxcXFxjdXJseWVxc3VjY1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3ZlwiLCBcIlxcXFxzdWNjc2ltXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyYWI4XCIsIFwiXFxcXHN1Y2NhcHByb3hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjNcIiwgXCJcXFxcdmFydHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjJiNVwiLCBcIlxcXFx0cmlhbmdsZXJpZ2h0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYTlcIiwgXCJcXFxcVmRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjNcIiwgXCJcXFxcc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMjVcIiwgXCJcXFxcc2hvcnRwYXJhbGxlbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI2Y1wiLCBcIlxcXFxiZXR3ZWVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmQ0XCIsIFwiXFxcXHBpdGNoZm9ya1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIxZFwiLCBcIlxcXFx2YXJwcm9wdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI1YzBcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWxlZnRcIik7XG4vLyB1bmljb2RlLW1hdGggc2F5cyB0aGF0IFxcdGhlcmVmb3JlIGlzIGEgbWF0aG9yZCBhdG9tLlxuLy8gV2Uga2VwdCB0aGUgYW1zc3ltYiBhdG9tIHR5cGUsIHdoaWNoIGlzIHJlbC5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjIzNFwiLCBcIlxcXFx0aGVyZWZvcmVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMGRcIiwgXCJcXFxcYmFja2Vwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI1YjZcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZXJpZ2h0XCIpO1xuLy8gdW5pY29kZS1tYXRoIHNheXMgdGhhdCBcXGJlY2F1c2UgaXMgYSBtYXRob3JkIGF0b20uXG4vLyBXZSBrZXB0IHRoZSBhbXNzeW1iIGF0b20gdHlwZSwgd2hpY2ggaXMgcmVsLlxuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjM1XCIsIFwiXFxcXGJlY2F1c2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsZXNzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmQ5XCIsIFwiXFxcXGdnZ3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmIyXCIsIFwiXFxcXGxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiM1wiLCBcIlxcXFxyaGRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDJcIiwgXCJcXFxcZXFzaW1cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNTFcIiwgXCJcXFxcRG90ZXFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI5N2RcIiwgXCJcXFxcc3RyaWN0aWZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTI5N2NcIiwgXCJcXFxcc3RyaWN0ZmlcIiwgdHJ1ZSk7XG5cbi8vIEFNUyBCaW5hcnkgT3BlcmF0b3JzXG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTRcIiwgXCJcXFxcZG90cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzbWFsbHNldG1pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXENhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJkM1wiLCBcIlxcXFxDdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJhNWVcIiwgXCJcXFxcZG91YmxlYmFyd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOWZcIiwgXCJcXFxcYm94bWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOWVcIiwgXCJcXFxcYm94cGx1c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDNFwiLCBcIlxcXFxib3hzbGFzaFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjN1wiLCBcIlxcXFxkaXZpZGVvbnRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM5XCIsIFwiXFxcXGx0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjYVwiLCBcIlxcXFxydGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyY2JcIiwgXCJcXFxcbGVmdHRocmVldGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyY2NcIiwgXCJcXFxccmlnaHR0aHJlZXRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmNmXCIsIFwiXFxcXGN1cmx5d2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyY2VcIiwgXCJcXFxcY3VybHl2ZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOWRcIiwgXCJcXFxcY2lyY2xlZGRhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOWJcIiwgXCJcXFxcY2lyY2xlZGFzdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJiYVwiLCBcIlxcXFxpbnRlcmNhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJkMlwiLCBcIlxcXFxkb3VibGVjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyZDNcIiwgXCJcXFxcZG91YmxlY3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmEwXCIsIFwiXFxcXGJveHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMmM4XCIsIFwiXFxcXGJvd3RpZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjOFwiLCBcIlxcXFxKb2luXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN2Q1XCIsIFwiXFxcXGxlZnRvdXRlcmpvaW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3ZDZcIiwgXCJcXFxccmlnaHRvdXRlcmpvaW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3ZDdcIiwgXCJcXFxcZnVsbG91dGVyam9pblwiLCB0cnVlKTtcblxuLy8gc3RpeCBCaW5hcnkgT3BlcmF0b3JzXG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMzhcIiwgXCJcXFxcZG90bWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RDFcIiwgXCJcXFxcd2VkZ2Vkb3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3QzdcIiwgXCJcXFxcdmVlZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTYyXCIsIFwiXFxcXGRvdWJsZWJhcnZlZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE2M1wiLCBcIlxcXFx2ZWVkb3VibGViYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNUZcIiwgXCJcXFxcd2VkZ2ViYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNjBcIiwgXCJcXFxcd2VkZ2Vkb3VibGViYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNTRcIiwgXCJcXFxcVmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTUzXCIsIFwiXFxcXFdlZGdlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQzXCIsIFwiXFxcXGJhcmNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0MlwiLCBcIlxcXFxiYXJjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNDhcIiwgXCJcXFxcY2FwYmFyY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQwXCIsIFwiXFxcXGNhcGRvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0N1wiLCBcIlxcXFxjYXBvdmVyY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTQ2XCIsIFwiXFxcXGN1cG92ZXJjYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNERcIiwgXCJcXFxcY2xvc2VkdmFyY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTRDXCIsIFwiXFxcXGNsb3NlZHZhcmN1cFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEyQVwiLCBcIlxcXFxtaW51c2RvdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEyQlwiLCBcIlxcXFxtaW51c2Zkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTJDXCIsIFwiXFxcXG1pbnVzcmRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQkJcIiwgXCJcXFxcWG9yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMkJDXCIsIFwiXFxcXE5hbmRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyQkRcIiwgXCJcXFxcTm9yXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMkJEXCIsIFwiXFxcXGJhcnZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkFGNFwiLCBcIlxcXFxpbnRlcmxlYXZlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUUyXCIsIFwiXFxcXHNodWZmbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBRjZcIiwgXCJcXFxcdGhyZWVkb3Rjb2xvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1Mjk4MlwiLCBcIlxcXFx0eXBlY29sb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyM0VcIiwgXCJcXFxcaW52bGF6eXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBNEJcIiwgXCJcXFxcdHdvY2Fwc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkE0QVwiLCBcIlxcXFx0d29jdXBzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTRFXCIsIFwiXFxcXFNxY2FwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTRGXCIsIFwiXFxcXFNxY3VwXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTU2XCIsIFwiXFxcXHZlZW9udmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTU1XCIsIFwiXFxcXHdlZGdlb253ZWRnZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlEN1wiLCBcIlxcXFxibGFja2hvdXJnbGFzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlDNlwiLCBcIlxcXFxib3hhc3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzhcIiwgXCJcXFxcYm94Ym94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUM3XCIsIFwiXFxcXGJveGNpcmNsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5Q1wiLCBcIlxcXFxjaXJjbGVkZXF1YWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QjdcIiwgXCJcXFxcY2lyY2xlZHBhcmFsbGVsXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUI2XCIsIFwiXFxcXGNpcmNsZWR2ZXJ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUI1XCIsIFwiXFxcXGNpcmNsZWhiYXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RTFcIiwgXCJcXFxcY29uY2F2ZWRpYW1vbmRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI3RTJcIiwgXCJcXFxcY29uY2F2ZWRpYW1vbmR0aWNrbGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFM1wiLCBcIlxcXFxjb25jYXZlZGlhbW9uZHRpY2tyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJDNFwiLCBcIlxcXFxkaWFtb25kXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUQ2XCIsIFwiXFxcXGhvdXJnbGFzc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFMFwiLCBcIlxcXFxsb3plbmdlbWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIzM0RcIiwgXCJcXFxcb2JhclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlCOFwiLCBcIlxcXFxvYnNsYXNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTM4XCIsIFwiXFxcXG9kaXZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI5QzFcIiwgXCJcXFxcb2dyZWF0ZXJ0aGFuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyOUMwXCIsIFwiXFxcXG9sZXNzdGhhblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjlCOVwiLCBcIlxcXFxvcGVycFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzN1wiLCBcIlxcXFxPdGltZXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBMzZcIiwgXCJcXFxcb3RpbWVzaGF0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMkM2XCIsIFwiXFxcXHN0YXJcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1QjNcIiwgXCJcXFxcdHJpYW5nbGVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBM0FcIiwgXCJcXFxcdHJpYW5nbGVtaW51c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MkEzOVwiLCBcIlxcXFx0cmlhbmdsZXBsdXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTJBM0JcIiwgXCJcXFxcdHJpYW5nbGV0aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjdFNFwiLCBcIlxcXFx3aGl0ZXNxdWFyZXRpY2tsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyN0U1XCIsIFwiXFxcXHdoaXRlc3F1YXJldGlja3JpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyQTMzXCIsIFwiXFxcXHNtYXNodGltZXNcIiwgdHJ1ZSk7XG5cbi8vIEFNUyBBcnJvd3Ncbi8vIE5vdGU6IHVuaWNvZGUtbWF0aCBtYXBzIFxcdTIxZTIgdG8gdGhlaXIgb3duIGZ1bmN0aW9uIFxccmlnaHRkYXNoYXJyb3cuXG4vLyBXZSdsbCBtYXAgaXQgdG8gQU1TIGZ1bmN0aW9uIFxcZGFzaHJpZ2h0YXJyb3cuIEl0IHByb2R1Y2VzIHRoZSBzYW1lIGF0b20uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZTJcIiwgXCJcXFxcZGFzaHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWUwIHRvIFxcbGVmdGRhc2hhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFlMFwiLCBcIlxcXFxkYXNobGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWM3XCIsIFwiXFxcXGxlZnRsZWZ0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWM2XCIsIFwiXFxcXGxlZnRyaWdodGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkYVwiLCBcIlxcXFxMbGVmdGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTllXCIsIFwiXFxcXHR3b2hlYWRsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYTJcIiwgXCJcXFxcbGVmdGFycm93dGFpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhYlwiLCBcIlxcXFxsb29wYXJyb3dsZWZ0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWNiXCIsIFwiXFxcXGxlZnRyaWdodGhhcnBvb25zXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWI2XCIsIFwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIsIHRydWUpO1xuLy8gdW5pY29kZS1tYXRoIG1hcHMgXFx1MjFiYSB0byBcXGFjd29wZW5jaXJjbGVhcnJvdy4gV2UnbGwgdXNlIHRoZSBBTVMgc3lub255bS5cbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiYVwiLCBcIlxcXFxjaXJjbGVhcnJvd2xlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWM4XCIsIFwiXFxcXHVwdXBhcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYmZcIiwgXCJcXFxcdXBoYXJwb29ubGVmdFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjZcIiwgXCJcXFxcb3JpZ29mXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmI3XCIsIFwiXFxcXGltYWdlb2ZcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyYjhcIiwgXCJcXFxcbXVsdGltYXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYWRcIiwgXCJcXFxcbGVmdHJpZ2h0c3F1aWdhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFjOVwiLCBcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWM0XCIsIFwiXFxcXHJpZ2h0bGVmdGFycm93c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhMFwiLCBcIlxcXFx0d29oZWFkcmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhM1wiLCBcIlxcXFxyaWdodGFycm93dGFpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFhY1wiLCBcIlxcXFxsb29wYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiN1wiLCBcIlxcXFxjdXJ2ZWFycm93cmlnaHRcIiwgdHJ1ZSk7XG4vLyB1bmljb2RlLW1hdGggbWFwcyBcXHUyMWJiIHRvIFxcY3dvcGVuY2lyY2xlYXJyb3cuIFdlJ2xsIHVzZSB0aGUgQU1TIHN5bm9ueW0uXG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYmJcIiwgXCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiMVwiLCBcIlxcXFxSc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxY2FcIiwgXCJcXFxcZG93bmRvd25hcnJvd3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxcdXBoYXJwb29ucmlnaHRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxYzJcIiwgXCJcXFxcZG93bmhhcnBvb25yaWdodFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkZFwiLCBcIlxcXFxyaWdodHNxdWlnYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxcbGVhZHN0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkYlwiLCBcIlxcXFxScmlnaHRhcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFiZVwiLCBcIlxcXFxyZXN0cmljdGlvblwiKTtcblxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXCRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCIkXCIsIFwiXFxcXHRleHRkb2xsYXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLColwiLCBcIlxcXFxjZW50XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiwqJcIiwgXCJcXFxcY2VudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIiVcIiwgXCJcXFxcJVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIiVcIiwgXCJcXFxcJVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIl9cIiwgXCJcXFxcX1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIl9cIiwgXCJcXFxcX1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIl9cIiwgXCJcXFxcdGV4dHVuZGVyc2NvcmVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyNDIzXCIsIFwiXFxcXHRleHR2aXNpYmxlc3BhY2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMjIwXCIsIFwiXFxcXGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIxZVwiLCBcIlxcXFxpbmZ0eVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzJcIiwgXCJcXFxccHJpbWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMDMzXCIsIFwiXFxcXGRwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMzRcIiwgXCJcXFxcdHJwcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwNTdcIiwgXCJcXFxccXByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjViM1wiLCBcIlxcXFx0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTFcIiwgXCJcXFxcQWxwaGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzkyXCIsIFwiXFxcXEJldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzkzXCIsIFwiXFxcXEdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5NFwiLCBcIlxcXFxEZWx0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTVcIiwgXCJcXFxcRXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTZcIiwgXCJcXFxcWmV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTdcIiwgXCJcXFxcRXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOTlcIiwgXCJcXFxcSW90YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWFcIiwgXCJcXFxcS2FwcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzliXCIsIFwiXFxcXExhbWJkYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWNcIiwgXCJcXFxcTXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMzlkXCIsIFwiXFxcXE51XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzOWZcIiwgXCJcXFxcT21pY3JvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2ExXCIsIFwiXFxcXFJob1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTNcIiwgXCJcXFxcU2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2E0XCIsIFwiXFxcXFRhdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTVcIiwgXCJcXFxcVXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTZcIiwgXCJcXFxcUGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDNhN1wiLCBcIlxcXFxDaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzkxXCIsIFwiXFxcXEFscGhhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5MlwiLCBcIlxcXFxCZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5M1wiLCBcIlxcXFxHYW1tYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOTRcIiwgXCJcXFxcRGVsdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzk1XCIsIFwiXFxcXEVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzk2XCIsIFwiXFxcXFpldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzk3XCIsIFwiXFxcXEV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOThcIiwgXCJcXFxcVGhldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzk5XCIsIFwiXFxcXElvdGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzlhXCIsIFwiXFxcXEthcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5YlwiLCBcIlxcXFxMYW1iZGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzljXCIsIFwiXFxcXE11XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDM5ZFwiLCBcIlxcXFxOdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzOWVcIiwgXCJcXFxcWGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMzlmXCIsIFwiXFxcXE9taWNyb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2EwXCIsIFwiXFxcXFBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhMVwiLCBcIlxcXFxSaG9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2EzXCIsIFwiXFxcXFNpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhNFwiLCBcIlxcXFxUYXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E1XCIsIFwiXFxcXFVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E2XCIsIFwiXFxcXFBoaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYTdcIiwgXCJcXFxcQ2hpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNhOFwiLCBcIlxcXFxQc2lcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2E5XCIsIFwiXFxcXE9tZWdhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MDBhY1wiLCBcIlxcXFxuZWdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUwMGFjXCIsIFwiXFxcXGxub3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMmE0XCIsIFwiXFxcXHRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyYTVcIiwgXCJcXFxcYm90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjIwNVwiLCBcIlxcXFxlbXB0eXNldFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIzMDBcIiwgXCJcXFxcdmFybm90aGluZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjFcIiwgXCJcXFxcYWxwaGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2IyXCIsIFwiXFxcXGJldGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2IzXCIsIFwiXFxcXGdhbW1hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiNFwiLCBcIlxcXFxkZWx0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZjVcIiwgXCJcXFxcZXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjZcIiwgXCJcXFxcemV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjdcIiwgXCJcXFxcZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiOFwiLCBcIlxcXFx0aGV0YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYjlcIiwgXCJcXFxcaW90YVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmFcIiwgXCJcXFxca2FwcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2JiXCIsIFwiXFxcXGxhbWJkYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmNcIiwgXCJcXFxcbXVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2JkXCIsIFwiXFxcXG51XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNiZVwiLCBcIlxcXFx4aVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYmZcIiwgXCJcXFxcb21pY3JvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzBcIiwgXCJcXFxccGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2MxXCIsIFwiXFxcXHJob1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzNcIiwgXCJcXFxcc2lnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2M0XCIsIFwiXFxcXHRhdVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzVcIiwgXCJcXFxcdXBzaWxvblwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDVcIiwgXCJcXFxccGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjN1wiLCBcIlxcXFxjaGlcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2M4XCIsIFwiXFxcXHBzaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzlcIiwgXCJcXFxcb21lZ2FcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2I1XCIsIFwiXFxcXHZhcmVwc2lsb25cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2QxXCIsIFwiXFxcXHZhcnRoZXRhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkNlwiLCBcIlxcXFx2YXJwaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZjFcIiwgXCJcXFxcdmFycmhvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNjMlwiLCBcIlxcXFx2YXJzaWdtYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzYzZcIiwgXCJcXFxcdmFycGhpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkOFwiLCBcIlxcXFxDb3BwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZDlcIiwgXCJcXFxcY29wcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2Q5XCIsIFwiXFxcXHZhcmNvcHBhXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkZVwiLCBcIlxcXFxLb3BwYVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZGZcIiwgXCJcXFxca29wcGFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwM2UwXCIsIFwiXFxcXFNhbXBpXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNlMVwiLCBcIlxcXFxzYW1waVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAzZGFcIiwgXCJcXFxcU3RpZ21hXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDNkYlwiLCBcIlxcXFxzdGlnbWFcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUyYWViXCIsIFwiXFxcXEJvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIxN1wiLCBcIlxcdTIyMTdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE3XCIsIFwiKlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjA0NFwiLCBcIi9cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIwNDRcIiwgXCJcXHUyMDQ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjEyXCIsIFwiLVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTAwZjdcIiwgXCJcXFxcZGl2XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUwMGIxXCIsIFwiXFxcXHBtXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUwMGQ3XCIsIFwiXFxcXHRpbWVzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjI5XCIsIFwiXFxcXGNhcFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyYVwiLCBcIlxcXFxjdXBcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcbGFuZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFxsb3JcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcdmVlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1MjdlNlwiLCBcIlxcXFxsbGJyYWNrZXRcIiwgdHJ1ZSk7IC8vIHN0bWFyeXJkL3NlbWFudGljIHBhY2thZ2VzXG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjdlN1wiLCBcIlxcXFxycmJyYWNrZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyN2U4XCIsIFwiXFxcXGxhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTI3ZWFcIiwgXCJcXFxcbEFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwiXFx1Mjk4OVwiLCBcIlxcXFxsbGFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwifFwiLCBcIlxcXFxsdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTIwMTZcIiwgXCJcXFxcbFZlcnRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCIhXCIsIFwiXFxcXG9jXCIpOyAvLyBjbWxsIHBhY2thZ2VcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIj9cIiwgXCJcXFxcd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMTkzXCIsIFwiXFxcXHNocG9zXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjE5NVwiLCBcIlxcXFxzaGlmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIxOTFcIiwgXCJcXFxcc2huZWdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiP1wiLCBcIj9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiIVwiLCBcIiFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwi4oC8XCIsIFwi4oC8XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI3ZTlcIiwgXCJcXFxccmFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI3ZWJcIiwgXCJcXFxcckFuZ2xlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTI5OGFcIiwgXCJcXFxccnJhbmdsZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJ8XCIsIFwiXFxcXHJ2ZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIlxcdTIwMTZcIiwgXCJcXFxcclZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyOTgzXCIsIFwiXFxcXGxCcmFjZVwiLCB0cnVlKTsgLy8gc3RtYXJ5cmQvc2VtYW50aWMgcGFja2FnZXNcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyOTg0XCIsIFwiXFxcXHJCcmFjZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiPVwiLCBcIlxcXFxlcXVhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiOlwiLCBcIjpcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNDhcIiwgXCJcXFxcYXBwcm94XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjQ1XCIsIFwiXFxcXGNvbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjVcIiwgXCJcXFxcZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjVcIiwgXCJcXFxcZ2VxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkwXCIsIFwiXFxcXGdldHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIj5cIiwgXCJcXFxcZ3RcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMDhcIiwgXCJcXFxcaW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyMDlcIiwgXCJcXFxcbm90aW5cIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdWUwMjBcIiwgXCJcXFxcQG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4MlwiLCBcIlxcXFxzdWJzZXRcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyODNcIiwgXCJcXFxcc3Vwc2V0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg2XCIsIFwiXFxcXHN1YnNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg3XCIsIFwiXFxcXHN1cHNldGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg4XCIsIFwiXFxcXG5zdWJzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4OFwiLCBcIlxcXFxuc3Vic2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMjg5XCIsIFwiXFxcXG5zdXBzZXRlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI4OVwiLCBcIlxcXFxuc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXG1vZGVsc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxsZWZ0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVxXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCI8XCIsIFwiXFxcXGx0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHJpZ2h0YXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTJcIiwgXCJcXFxcdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MVwiLCBcIlxcXFxuZ2VxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MVwiLCBcIlxcXFxuZ2Vxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIyNzBcIiwgXCJcXFxcbmxlcVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MFwiLCBcIlxcXFxubGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjI3MFwiLCBcIlxcXFxubGVxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTJhZWJcIiwgXCJcXFxcUGVycFwiLCB0cnVlKTsgLy9jbWxsIHBhY2thZ2VcbmRlZmluZVN5bWJvbChtYXRoLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcc3BhY2VcIik7XG4vLyBSZWY6IExhVGVYIFNvdXJjZSAyZTogXFxEZWNsYXJlUm9idXN0Q29tbWFuZHtcXG5vYnJlYWtzcGFjZX17JVxuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIlxcXFxub2JyZWFrc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXCBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgc3BhY2luZywgXCJcXHUwMGEwXCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBzcGFjaW5nLCBudWxsLCBcIlxcXFxub2JyZWFrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHNwYWNpbmcsIG51bGwsIFwiXFxcXGFsbG93YnJlYWtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcHVuY3QsIFwiLFwiLCBcIixcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgcHVuY3QsIFwiOlwiLCBcIjpcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYmNcIiwgXCJcXFxcYmFyd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYmJcIiwgXCJcXFxcdmVlYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk5XCIsIFwiXFxcXG9kb3RcIiwgdHJ1ZSk7XG4vLyBGaXJlZm94IHR1cm5zIOKKlSBpbnRvIGFuIGVtb2ppLiBTbyBhcHBlbmQgXFx1RkUwRS4gRGVmaW5lIFVuaWNvZGUgY2hhcmFjdGVyIGluIG1hY3Jvcywgbm90IGhlcmUuXG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOTVcXHVGRTBFXCIsIFwiXFxcXG9wbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMjk3XCIsIFwiXFxcXG90aW1lc1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIyMDJcIiwgXCJcXFxccGFydGlhbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjI5OFwiLCBcIlxcXFxvc2xhc2hcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyOWFcIiwgXCJcXFxcY2lyY2xlZGNpcmNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTIyYTFcIiwgXCJcXFxcYm94ZG90XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNWIzXCIsIFwiXFxcXGJpZ3RyaWFuZ2xldXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYmluLCBcIlxcdTI1YmRcIiwgXCJcXFxcYmlndHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjJjNFwiLCBcIlxcXFxkaWFtb25kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGJpbiwgXCJcXHUyNWMzXCIsIFwiXFxcXHRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBiaW4sIFwiXFx1MjViOVwiLCBcIlxcXFx0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwie1wiLCBcIlxcXFx7XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwie1wiLCBcIlxcXFx0ZXh0YnJhY2VsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIn1cIiwgXCJcXFxcfVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIn1cIiwgXCJcXFxcdGV4dGJyYWNlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJ7XCIsIFwiXFxcXGxicmFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJ9XCIsIFwiXFxcXHJicmFjZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIltcIiwgXCJcXFxcbGJyYWNrXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXVwiLCBcIlxcXFxyYnJhY2tcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJdXCIsIFwiXFxcXHJicmFja1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIihcIiwgXCJcXFxcbHBhcmVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGNsb3NlLCBcIilcIiwgXCJcXFxccnBhcmVuXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wZW4sIFwi4qaHXCIsIFwiXFxcXGxscGFyZW50aGVzaXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwi4qaIXCIsIFwiXFxcXHJycGFyZW50aGVzaXNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCI8XCIsIFwiXFxcXHRleHRsZXNzXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCI+XCIsIFwiXFxcXHRleHRncmVhdGVyXCIsIHRydWUpOyAvLyBpbiBUMSBmb250ZW5jXG5kZWZpbmVTeW1ib2wobWF0aCwgb3BlbiwgXCJcXHUyMzBhXCIsIFwiXFxcXGxmbG9vclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBjbG9zZSwgXCJcXHUyMzBiXCIsIFwiXFxcXHJmbG9vclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcGVuLCBcIlxcdTIzMDhcIiwgXCJcXFxcbGNlaWxcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgY2xvc2UsIFwiXFx1MjMwOVwiLCBcIlxcXFxyY2VpbFwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcXFxcIiwgXCJcXFxcYmFja3NsYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwifFwiLCBcInxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJ8XCIsIFwiXFxcXHZlcnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJ8XCIsIFwiXFxcXHRleHRiYXJcIiwgdHJ1ZSk7IC8vIGluIFQxIGZvbnRlbmNcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMTZcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTIwMTZcIiwgXCJcXFxcVmVydFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTZcIiwgXCJcXFxcdGV4dGJhcmRibFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIn5cIiwgXCJcXFxcdGV4dGFzY2lpdGlsZGVcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXFxcXCIsIFwiXFxcXHRleHRiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJeXCIsIFwiXFxcXHRleHRhc2NpaWNpcmN1bVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5MVwiLCBcIlxcXFx1cGFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWQxXCIsIFwiXFxcXFVwYXJyb3dcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgcmVsLCBcIlxcdTIxOTNcIiwgXCJcXFxcZG93bmFycm93XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHJlbCwgXCJcXHUyMWQzXCIsIFwiXFxcXERvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCByZWwsIFwiXFx1MjFkNVwiLCBcIlxcXFxVcGRvd25hcnJvd1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjEwXCIsIFwiXFxcXGNvcHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMmMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMmMwXCIsIFwiXFxcXGJpZ3dlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDRcIiwgXCJcXFxcYmlndXBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwNFwiLCBcIlxcXFxiaWdjdXBwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDNcIiwgXCJcXFxcYmlnY3VwZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDdcIiwgXCJcXFxcYmlnZG91YmxldmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMDhcIiwgXCJcXFxcYmlnZG91Ymxld2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjJjMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjJjM1wiLCBcIlxcXFxiaWdjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJjXCIsIFwiXFxcXGlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyZFwiLCBcIlxcXFxpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjBmXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIxMVwiLCBcIlxcXFxzdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwMlwiLCBcIlxcXFxiaWdvdGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTAwXCIsIFwiXFxcXGJpZ29kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwOVwiLCBcIlxcXFxiaWd0aW1lc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjJlXCIsIFwiXFxcXG9pbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MjIyZlwiLCBcIlxcXFxvaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjMwXCIsIFwiXFxcXG9paWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjMxXCIsIFwiXFxcXGludGNsb2Nrd2lzZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyMjMyXCIsIFwiXFxcXHZhcm9pbnRjbG9ja3dpc2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwY1wiLCBcIlxcXFxpaWlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwZFwiLCBcIlxcXFxpbnRiYXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwZVwiLCBcIlxcXFxpbnRCYXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwZlwiLCBcIlxcXFxmaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMTJcIiwgXCJcXFxccnBwb2xpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExM1wiLCBcIlxcXFxzY3BvbGludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTE1XCIsIFwiXFxcXHBvaW50aW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTJhMTZcIiwgXCJcXFxcc3FpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExN1wiLCBcIlxcXFxpbnRsYXJoa1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTE4XCIsIFwiXFxcXGludHhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExOVwiLCBcIlxcXFxpbnRjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmExYVwiLCBcIlxcXFxpbnRjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgb3AsIFwiXFx1MmEwNVwiLCBcIlxcXFxiaWdzcWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBvcCwgXCJcXHUyYTA2XCIsIFwiXFxcXGJpZ3NxY3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG9wLCBcIlxcdTIyMmJcIiwgXCJcXFxcc21hbGxpbnRcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFx0ZXh0ZWxsaXBzaXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxtYXRoZWxsaXBzaXNcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgaW5uZXIsIFwiXFx1MjAyNlwiLCBcIlxcXFxsZG90c1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGlubmVyLCBcIlxcdTIyZjBcIiwgXCJcXFxcaWRkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGlubmVyLCBcIlxcdTIyZWZcIiwgXCJcXFxcQGNkb3RzXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGlubmVyLCBcIlxcdTIyZjFcIiwgXCJcXFxcZGRvdHNcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUyMmVlXCIsIFwiXFxcXHZhcnZkb3RzXCIpOyAvLyBcXHZkb3RzIGlzIGEgbWFjcm9cbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIyZWVcIiwgXCJcXFxcdmFydmRvdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyY2FcIiwgXCJcXFxcYWN1dGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwNjBcIiwgXCJcXFxcZ3JhdmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAwYThcIiwgXCJcXFxcZGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MjAyNlwiLCBcIlxcXFxkZGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MjAyNlxcdTAwMmVcIiwgXCJcXFxcZGRkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMDdlXCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUyMDNlXCIsIFwiXFxcXGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFxicmV2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDA1ZVwiLCBcIlxcXFxoYXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTIxOTJcIiwgXCJcXFxcdmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkYVwiLCBcIlxcXFxtYXRocmluZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaW1hdGhcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgXCJcXHUwMjM3XCIsIFwiXFxcXGptYXRoXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDEzMVwiLCBcIlxcdTAxMzFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCJcXHUwMjM3XCIsIFwiXFx1MDIzN1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAyMzdcIiwgXCJcXFxcalwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwZGZcIiwgXCJcXFxcc3NcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGU2XCIsIFwiXFxcXGFlXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDE1M1wiLCBcIlxcXFxvZVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwZjhcIiwgXCJcXFxcb1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBcIlxcdTAwZjhcIiwgXCJcXFxcb1wiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYzZcIiwgXCJcXFxcQUVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMTUyXCIsIFwiXFxcXE9FXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBkOFwiLCBcIlxcXFxPXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIFwiXFx1MDBkOFwiLCBcIlxcXFxPXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmNhXCIsIFwiXFxcXCdcIik7IC8vIGFjdXRlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyY2JcIiwgXCJcXFxcYFwiKTsgLy8gZ3JhdmVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJjNlwiLCBcIlxcXFxeXCIpOyAvLyBjaXJjdW1mbGV4XG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyZGNcIiwgXCJcXFxcflwiKTsgLy8gdGlsZGVcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJjOVwiLCBcIlxcXFw9XCIpOyAvLyBtYWNyb25cbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFx1XCIpOyAvLyBicmV2ZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXC5cIik7IC8vIGRvdCBhYm92ZVxuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMGI4XCIsIFwiXFxcXGNcIik7IC8vIGNlZGlsbGFcbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDJkYVwiLCBcIlxcXFxyXCIpOyAvLyByaW5nIGFib3ZlXG5kZWZpbmVTeW1ib2wodGV4dCwgYWNjZW50LCBcIlxcdTAyYzdcIiwgXCJcXFxcdlwiKTsgLy8gY2Fyb25cbmRlZmluZVN5bWJvbCh0ZXh0LCBhY2NlbnQsIFwiXFx1MDBhOFwiLCAnXFxcXFwiJyk7IC8vIGRpYWVyZXNpc1xuZGVmaW5lU3ltYm9sKHRleHQsIGFjY2VudCwgXCJcXHUwMmRkXCIsIFwiXFxcXEhcIik7IC8vIGRvdWJsZSBhY3V0ZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmNhXCIsIFwiXFxcXCdcIik7IC8vIGFjdXRlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyY2JcIiwgXCJcXFxcYFwiKTsgLy8gZ3JhdmVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjNlwiLCBcIlxcXFxeXCIpOyAvLyBjaXJjdW1mbGV4XG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyZGNcIiwgXCJcXFxcflwiKTsgLy8gdGlsZGVcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJjOVwiLCBcIlxcXFw9XCIpOyAvLyBtYWNyb25cbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFx1XCIpOyAvLyBicmV2ZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXC5cIik7IC8vIGRvdCBhYm92ZVxuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMGI4XCIsIFwiXFxcXGNcIik7IC8vIGNlZGlsbGFcbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDJkYVwiLCBcIlxcXFxyXCIpOyAvLyByaW5nIGFib3ZlXG5kZWZpbmVTeW1ib2wobWF0aCwgYWNjZW50LCBcIlxcdTAyYzdcIiwgXCJcXFxcdlwiKTsgLy8gY2Fyb25cbmRlZmluZVN5bWJvbChtYXRoLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCAnXFxcXFwiJyk7IC8vIGRpYWVyZXNpc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFjY2VudCwgXCJcXHUwMmRkXCIsIFwiXFxcXEhcIik7IC8vIGRvdWJsZSBhY3V0ZVxuXG4vLyBUaGVzZSBsaWdhdHVyZXMgYXJlIGRldGVjdGVkIGFuZCBjcmVhdGVkIGluIFBhcnNlci5qcydzIGBmb3JtTGlnYXR1cmVzYC5cbmNvbnN0IGxpZ2F0dXJlcyA9IHtcbiAgXCItLVwiOiB0cnVlLFxuICBcIi0tLVwiOiB0cnVlLFxuICBcImBgXCI6IHRydWUsXG4gIFwiJydcIjogdHJ1ZVxufTtcblxuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxM1wiLCBcIi0tXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxM1wiLCBcIlxcXFx0ZXh0ZW5kYXNoXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIi0tLVwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMTRcIiwgXCJcXFxcdGV4dGVtZGFzaFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcIlxcXFx0ZXh0cXVvdGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxOVwiLCBcIidcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiXFxcXHRleHRxdW90ZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxY1wiLCBcImBgXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxY1wiLCBcIlxcXFx0ZXh0cXVvdGVkYmxsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxZFwiLCBcIicnXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjAxZFwiLCBcIlxcXFx0ZXh0cXVvdGVkYmxyaWdodFwiKTtcbi8vICBcXGRlZ3JlZSBmcm9tIGdlbnN5bWIgcGFja2FnZVxuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGIwXCIsIFwiXFxcXGRlZ3JlZVwiKTtcbi8vIFxcdGV4dGRlZ3JlZSBmcm9tIGlucHV0ZW5jIHBhY2thZ2VcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcdGV4dGRlZ3JlZVwiLCB0cnVlKTtcbi8vIFRPRE86IEluIExhVGVYLCBcXHBvdW5kcyBjYW4gZ2VuZXJhdGUgYSBkaWZmZXJlbnQgY2hhcmFjdGVyIGluIHRleHQgYW5kIG1hdGhcbi8vIG1vZGUsIGJ1dCBhbW9uZyBvdXIgZm9udHMsIG9ubHkgTWFpbi1SZWd1bGFyIGRlZmluZXMgdGhpcyBjaGFyYWN0ZXIgXCIxNjNcIi5cbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxccG91bmRzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MDBhM1wiLCBcIlxcXFxtYXRoc3RlcmxpbmdcIiwgdHJ1ZSk7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHBvdW5kc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTAwYTNcIiwgXCJcXFxcdGV4dHN0ZXJsaW5nXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjBhY1wiLCBcIlxcXFxldXJvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjBhY1wiLCBcIlxcXFxldXJvXCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MjBhY1wiLCBcIlxcXFx0ZXh0ZXVyb1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIlxcdTAwYTlcIiwgXCJcXFxcY29weXJpZ2h0XCIsIHRydWUpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwiXFx1MDBhOVwiLCBcIlxcXFx0ZXh0Y29weXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwiXFx1MjMwMFwiLCBcIlxcXFxkaWFtZXRlclwiLCB0cnVlKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIlxcdTIzMDBcIiwgXCJcXFxcZGlhbWV0ZXJcIik7XG5cbi8vIEl0YWxpYyBHcmVla1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2bpFwiLCBcIlxcXFx2YXJHYW1tYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm6VcIiwgXCJcXFxcdmFyRGVsdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZupXCIsIFwiXFxcXHZhclRoZXRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2brFwiLCBcIlxcXFx2YXJMYW1iZGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZuvXCIsIFwiXFxcXHZhclhpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2bsVwiLCBcIlxcXFx2YXJQaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7RcIiwgXCJcXFxcdmFyU2lnbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZu2XCIsIFwiXFxcXHZhclVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgdGV4dG9yZCwgXCLwnZu3XCIsIFwiXFxcXHZhclBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBcIvCdm7lcIiwgXCJcXFxcdmFyUHNpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIHRleHRvcmQsIFwi8J2bulwiLCBcIlxcXFx2YXJPbWVnYVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm6RcIiwgXCJcXFxcdmFyR2FtbWFcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZulXCIsIFwiXFxcXHZhckRlbHRhXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bqVwiLCBcIlxcXFx2YXJUaGV0YVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm6xcIiwgXCJcXFxcdmFyTGFtYmRhXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2br1wiLCBcIlxcXFx2YXJYaVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7FcIiwgXCJcXFxcdmFyUGlcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZu0XCIsIFwiXFxcXHZhclNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2btlwiLCBcIlxcXFx2YXJVcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIFwi8J2bt1wiLCBcIlxcXFx2YXJQaGlcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgXCLwnZu5XCIsIFwiXFxcXHZhclBzaVwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBcIvCdm7pcIiwgXCJcXFxcdmFyT21lZ2FcIik7XG5cblxuLy8gVGhlcmUgYXJlIGxvdHMgb2Ygc3ltYm9scyB3aGljaCBhcmUgdGhlIHNhbWUsIHNvIHdlIGFkZCB0aGVtIGluIGFmdGVyd2FyZHMuXG4vLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIG1hdGggbW9kZVxuY29uc3QgbWF0aFRleHRTeW1ib2xzID0gJzAxMjM0NTY3ODkvQC5cIic7XG5mb3IgKGxldCBpID0gMDsgaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IG1hdGhUZXh0U3ltYm9scy5jaGFyQXQoaSk7XG4gIGRlZmluZVN5bWJvbChtYXRoLCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG4vLyBBbGwgb2YgdGhlc2UgYXJlIHRleHRvcmRzIGluIHRleHQgbW9kZVxuY29uc3QgdGV4dFN5bWJvbHMgPSAnMDEyMzQ1Njc4OSFAKigpLT0rXCI7Oj8vLiwnO1xuZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICBjb25zdCBjaCA9IHRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gdGV4dCBtb2RlLCBhbmQgbWF0aG9yZHMgaW4gbWF0aCBtb2RlXG5jb25zdCBsZXR0ZXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5mb3IgKGxldCBpID0gMDsgaSA8IGxldHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSBsZXR0ZXJzLmNoYXJBdChpKTtcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIGNoLCBjaCk7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG4vLyBTb21lIG1vcmUgbGV0dGVycyBpbiBVbmljb2RlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZS5cbmNvbnN0IG5hcnJvdyA9IFwiw4fDkMOew6fDvuKEguKEjeKEleKEmeKEmuKEneKEpOKEjuKEj+KEiuKEi+KEjOKEkOKEkeKEkuKEk+KEmOKEm+KEnOKErOKEsOKEseKEs+KEreKEqFwiO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBuYXJyb3cubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY2ggPSBuYXJyb3cuY2hhckF0KGkpO1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgY2gsIGNoKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIFRoZSBuZXh0IGxvb3AgbG9hZHMgd2lkZSAoc3Vycm9nYXRlIHBhaXIpIGNoYXJhY3RlcnMuXG4vLyBXZSBzdXBwb3J0IHNvbWUgbGV0dGVycyBpbiB0aGUgVW5pY29kZSByYW5nZSBVKzFENDAwIHRvIFUrMUQ3RkYsXG4vLyBNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHMuXG5sZXQgd2lkZUNoYXIgPSBcIlwiO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBsZXR0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gIC8vIFRoZSBoZXggbnVtYmVycyBpbiB0aGUgbmV4dCBsaW5lIGFyZSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAvLyAweEQ4MzUgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIGZvciBhbGwgbGV0dGVycyBpbiB0aGUgcmFuZ2Ugd2Ugc3VwcG9ydC5cbiAgLy8gMHhEQzAwIGlzIHRoZSBsb3cgc3Vycm9nYXRlIGZvciBib2xkIEEuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGMwMCArIGkpOyAvLyBBLVogYS16IGJvbGRcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGMzNCArIGkpOyAvLyBBLVogYS16IGl0YWxpY1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkYzY4ICsgaSk7IC8vIEEtWiBhLXogYm9sZCBpdGFsaWNcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGQwNCArIGkpOyAvLyBBLVogYS16IEZyYWN0dXJcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGRhMCArIGkpOyAvLyBBLVogYS16IHNhbnMtc2VyaWZcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGRkNCArIGkpOyAvLyBBLVogYS16IHNhbnMgYm9sZFxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZTA4ICsgaSk7IC8vIEEtWiBhLXogc2FucyBpdGFsaWNcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuXG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGU3MCArIGkpOyAvLyBBLVogYS16IG1vbm9zcGFjZVxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZDM4ICsgaSk7IC8vIEEtWiBhLXogZG91YmxlIHN0cnVja1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgY29uc3QgY2ggPSBsZXR0ZXJzLmNoYXJBdChpKTtcbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkYzljICsgaSk7IC8vIEEtWiBhLXogY2FsbGlncmFwaGljXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCBjaCwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgY2gsIHdpZGVDaGFyKTtcbn1cblxuLy8gTmV4dCwgc29tZSB3aWRlIGNoYXJhY3RlciBudW1lcmFsc1xuZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MzUsIDB4ZGZjZSArIGkpOyAvLyAwLTkgYm9sZFxuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZmUyICsgaSk7IC8vIDAtOSBzYW5zIHNlcmlmXG4gIGRlZmluZVN5bWJvbChtYXRoLCBtYXRob3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xuICBkZWZpbmVTeW1ib2wodGV4dCwgdGV4dG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcblxuICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODM1LCAweGRmZWMgKyBpKTsgLy8gMC05IGJvbGQgc2Fuc1xuICBkZWZpbmVTeW1ib2wobWF0aCwgbWF0aG9yZCwgd2lkZUNoYXIsIHdpZGVDaGFyKTtcbiAgZGVmaW5lU3ltYm9sKHRleHQsIHRleHRvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG5cbiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZDgzNSwgMHhkZmY2ICsgaSk7IC8vIDAtOSBtb25vc3BhY2VcbiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGhvcmQsIHdpZGVDaGFyLCB3aWRlQ2hhcik7XG4gIGRlZmluZVN5bWJvbCh0ZXh0LCB0ZXh0b3JkLCB3aWRlQ2hhciwgd2lkZUNoYXIpO1xufVxuXG4vKlxuICogTmVpdGhlciBGaXJlZm94IG5vciBDaHJvbWUgc3VwcG9ydCBoYXJkIGxpbmUgYnJlYWtzIG9yIHNvZnQgbGluZSBicmVha3MuXG4gKiAoRGVzcGl0ZSBodHRwczovL3d3dy53My5vcmcvTWF0aC9kcmFmdC1zcGVjL21hdGhtbC5odG1sI2NoYXB0ZXIzX3ByZXNtLmxiYXR0cnMpXG4gKiBTbyBUZW1tbCBoYXMgd29yay1hcm91bmRzIGZvciBib3RoIGhhcmQgYW5kIHNvZnQgYnJlYWtzLlxuICogVGhlIHdvcmstYXJvdW5kcyBzYWRseSBkbyBub3Qgd29yayBzaW11bHRhbmVvdXNseS4gQW55IHRvcC1sZXZlbCBoYXJkXG4gKiBicmVhayBtYWtlcyBzb2Z0IGxpbmUgYnJlYWtzIGltcG9zc2libGUuXG4gKlxuICogSGFyZCBicmVha3MgYXJlIHNpbXVsYXRlZCBieSBjcmVhdGluZyBhIDxtdGFibGU+IGFuZCBwdXR0aW5nIGVhY2ggbGluZSBpbiBpdHMgb3duIDxtdHI+LlxuICpcbiAqIFRvIGNyZWF0ZSBzb2Z0IGxpbmUgYnJlYWtzLCBUZW1tbCBhdm9pZHMgdXNpbmcgdGhlIDxzZW1hbnRpY3M+IGFuZCA8YW5ub3RhdGlvbj4gdGFncy5cbiAqIFRoZW4gdGhlIHRvcCBsZXZlbCBvZiBhIDxtYXRoPiBlbGVtZW50IGNhbiBiZSBvY2N1cGllZCBieSA8bXJvdz4gZWxlbWVudHMsIGFuZCB0aGUgYnJvd3NlclxuICogd2lsbCBicmVhayBhZnRlciBhIDxtcm93PiBpZiB0aGUgZXhwcmVzc2lvbiBleHRlbmRzIGJleW9uZCB0aGUgY29udGFpbmVyIGxpbWl0LlxuICpcbiAqIFRoZSBkZWZhdWx0IGlzIGZvciBzb2Z0IGxpbmUgYnJlYWtzIGFmdGVyIGVhY2ggdG9wLWxldmVsIGJpbmFyeSBvclxuICogcmVsYXRpb25hbCBvcGVyYXRvciwgcGVyIFRlWGJvb2sgcC4gMTczLiBTbyB3ZSBnYXRoZXIgdGhlIGV4cHJlc3Npb24gaW50byA8bXJvdz5zIHNvIHRoYXRcbiAqIGVhY2ggPG1yb3c+IGVuZHMgaW4gYSBiaW5hcnkgb3IgcmVsYXRpb25hbCBvcGVyYXRvci5cbiAqXG4gKiBBbiBvcHRpb24gaXMgZm9yIHNvZnQgbGluZSBicmVha3MgYmVmb3JlIGFuIFwiPVwiIHNpZ24uIFRoYXQgY2hhbmdlcyB0aGUgPG1yb3c+cy5cbiAqXG4gKiBTb2Z0IGxpbmUgYnJlYWtzIHdpbGwgbm90IHdvcmsgaW4gQ2hyb21pdW0gYW5kIFNhZmFyaSwgb25seSBGaXJlZm94LlxuICpcbiAqIEhvcGVmdWxseSBicm93c2VycyB3aWxsIHNvbWVkYXkgZG8gdGhlaXIgb3duIGxpbmVicmVha2luZyBhbmQgd2Ugd2lsbCBiZSBhYmxlIHRvIGRlbGV0ZVxuICogbXVjaCBvZiB0aGlzIG1vZHVsZS5cbiAqL1xuXG5jb25zdCBvcGVuRGVsaW1zID0gXCIoW3vijIrijIjin6jin67ijrDin6bipoNcIjtcbmNvbnN0IGNsb3NlRGVsaW1zID0gXCIpXX3ijIvijInin6nin6/ijrHin6bipoRcIjtcblxuZnVuY3Rpb24gc2V0TGluZUJyZWFrcyhleHByZXNzaW9uLCB3cmFwTW9kZSwgaXNEaXNwbGF5TW9kZSkge1xuICBjb25zdCBtdHJzID0gW107XG4gIGxldCBtcm93cyA9IFtdO1xuICBsZXQgYmxvY2sgPSBbXTtcbiAgbGV0IG51bVRvcExldmVsRXF1YWxzID0gMDtcbiAgbGV0IGkgPSAwO1xuICBsZXQgbGV2ZWwgPSAwO1xuICB3aGlsZSAoaSA8IGV4cHJlc3Npb24ubGVuZ3RoKSB7XG4gICAgd2hpbGUgKGV4cHJlc3Npb25baV0gaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICBleHByZXNzaW9uLnNwbGljZShpLCAxLCAuLi5leHByZXNzaW9uW2ldLmNoaWxkcmVuKTsgLy8gRXhwYW5kIHRoZSBmcmFnbWVudC5cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IGV4cHJlc3Npb25baV07XG4gICAgaWYgKG5vZGUuYXR0cmlidXRlcyAmJiBub2RlLmF0dHJpYnV0ZXMubGluZWJyZWFrICYmXG4gICAgICBub2RlLmF0dHJpYnV0ZXMubGluZWJyZWFrID09PSBcIm5ld2xpbmVcIikge1xuICAgICAgLy8gQSBoYXJkIGxpbmUgYnJlYWsuIENyZWF0ZSBhIDxtdHI+IGZvciB0aGUgY3VycmVudCBibG9jay5cbiAgICAgIGlmIChibG9jay5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1yb3dzLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJsb2NrKSk7XG4gICAgICB9XG4gICAgICBtcm93cy5wdXNoKG5vZGUpO1xuICAgICAgYmxvY2sgPSBbXTtcbiAgICAgIGNvbnN0IG10ZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIG1yb3dzKTtcbiAgICAgIG10ZC5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgIG10cnMucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbbXRkXSkpO1xuICAgICAgbXJvd3MgPSBbXTtcbiAgICAgIGkgKz0gMTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGJsb2NrLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUudHlwZSAmJiBub2RlLnR5cGUgPT09IFwibW9cIiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUuYXR0cmlidXRlcywgXCJtb3ZhYmxlbGltaXRzXCIpKSB7XG4gICAgICBjb25zdCBjaCA9IG5vZGUuY2hpbGRyZW5bMF0udGV4dDtcbiAgICAgIGlmIChvcGVuRGVsaW1zLmluZGV4T2YoY2gpID4gLTEpIHtcbiAgICAgICAgbGV2ZWwgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAoY2xvc2VEZWxpbXMuaW5kZXhPZihjaCkgPiAtMSkge1xuICAgICAgICBsZXZlbCAtPSAxO1xuICAgICAgfSBlbHNlIGlmIChsZXZlbCA9PT0gMCAmJiB3cmFwTW9kZSA9PT0gXCI9XCIgJiYgY2ggPT09IFwiPVwiKSB7XG4gICAgICAgIG51bVRvcExldmVsRXF1YWxzICs9IDE7XG4gICAgICAgIGlmIChudW1Ub3BMZXZlbEVxdWFscyA+IDEpIHtcbiAgICAgICAgICBibG9jay5wb3AoKTtcbiAgICAgICAgICAvLyBTdGFydCBhIG5ldyBibG9jay4gKEluc2VydCBhIHNvZnQgbGluZWJyZWFrLilcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJsb2NrKTtcbiAgICAgICAgICBtcm93cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGJsb2NrID0gW25vZGVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxldmVsID09PSAwICYmIHdyYXBNb2RlID09PSBcInRleFwiICYmIGNoICE9PSBcIuKIh1wiKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBmb2xsb3dpbmcgbm9kZSBpcyBhIFxcbm9icmVhayB0ZXh0IG5vZGUsIGUuZy4gXCJ+XCJcIlxuICAgICAgICBjb25zdCBuZXh0ID0gaSA8IGV4cHJlc3Npb24ubGVuZ3RoIC0gMSA/IGV4cHJlc3Npb25baSArIDFdIDogbnVsbDtcbiAgICAgICAgbGV0IGdsdWVJc0ZyZWVPZk5vYnJlYWsgPSB0cnVlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIShcbiAgICAgICAgICAgIG5leHQgJiZcbiAgICAgICAgICAgIG5leHQudHlwZSA9PT0gXCJtdGV4dFwiICYmXG4gICAgICAgICAgICBuZXh0LmF0dHJpYnV0ZXMubGluZWJyZWFrICYmXG4gICAgICAgICAgICBuZXh0LmF0dHJpYnV0ZXMubGluZWJyZWFrID09PSBcIm5vYnJlYWtcIlxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gV2UgbWF5IG5lZWQgdG8gc3RhcnQgYSBuZXcgYmxvY2suXG4gICAgICAgICAgLy8gRmlyc3QsIHB1dCBhbnkgcG9zdC1vcGVyYXRvciBnbHVlIG9uIHNhbWUgbGluZSBhcyBvcGVyYXRvci5cbiAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBleHByZXNzaW9uLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBuZCA9IGV4cHJlc3Npb25bal07XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5kLnR5cGUgJiZcbiAgICAgICAgICAgICAgbmQudHlwZSA9PT0gXCJtc3BhY2VcIiAmJlxuICAgICAgICAgICAgICAhKG5kLmF0dHJpYnV0ZXMubGluZWJyZWFrICYmIG5kLmF0dHJpYnV0ZXMubGluZWJyZWFrID09PSBcIm5ld2xpbmVcIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBibG9jay5wdXNoKG5kKTtcbiAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbmQuYXR0cmlidXRlcyAmJlxuICAgICAgICAgICAgICAgIG5kLmF0dHJpYnV0ZXMubGluZWJyZWFrICYmXG4gICAgICAgICAgICAgICAgbmQuYXR0cmlidXRlcy5saW5lYnJlYWsgPT09IFwibm9icmVha1wiXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGdsdWVJc0ZyZWVPZk5vYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChnbHVlSXNGcmVlT2ZOb2JyZWFrKSB7XG4gICAgICAgICAgLy8gU3RhcnQgYSBuZXcgYmxvY2suIChJbnNlcnQgYSBzb2Z0IGxpbmVicmVhay4pXG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBibG9jayk7XG4gICAgICAgICAgbXJvd3MucHVzaChlbGVtZW50KTtcbiAgICAgICAgICBibG9jayA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgfVxuICBpZiAoYmxvY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgYmxvY2spO1xuICAgIG1yb3dzLnB1c2goZWxlbWVudCk7XG4gIH1cbiAgaWYgKG10cnMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG10ZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIG1yb3dzKTtcbiAgICBtdGQuc3R5bGUudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgY29uc3QgbXRyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdHJcIiwgW210ZF0pO1xuICAgIG10cnMucHVzaChtdHIpO1xuICAgIGNvbnN0IG10YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIG10cnMpO1xuICAgIGlmICghaXNEaXNwbGF5TW9kZSkge1xuICAgICAgbXRhYmxlLnNldEF0dHJpYnV0ZShcImNvbHVtbmFsaWduXCIsIFwibGVmdFwiKTtcbiAgICAgIG10YWJsZS5zZXRBdHRyaWJ1dGUoXCJyb3dzcGFjaW5nXCIsIFwiMGVtXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbXRhYmxlXG4gIH1cbiAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChtcm93cyk7XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29ycmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG5cbi8qKlxuICogVGFrZXMgYSBzeW1ib2wgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBNYXRoTUwgdGV4dCBub2RlIGFmdGVyIHBlcmZvcm1pbmdcbiAqIG9wdGlvbmFsIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcy5cbiAqL1xuY29uc3QgbWFrZVRleHQgPSBmdW5jdGlvbih0ZXh0LCBtb2RlLCBzdHlsZSkge1xuICBpZiAoXG4gICAgc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJlxuICAgIHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZSAmJlxuICAgIHRleHQuY2hhckNvZGVBdCgwKSAhPT0gMHhkODM1ICYmXG4gICAgIShcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaWdhdHVyZXMsIHRleHQpICYmXG4gICAgICBzdHlsZSAmJlxuICAgICAgKChzdHlsZS5mb250RmFtaWx5ICYmIHN0eWxlLmZvbnRGYW1pbHkuc2xpY2UoNCwgNikgPT09IFwidHRcIikgfHxcbiAgICAgICAgKHN0eWxlLmZvbnQgJiYgc3R5bGUuZm9udC5zbGljZSg0LCA2KSA9PT0gXCJ0dFwiKSlcbiAgICApXG4gICkge1xuICAgIHRleHQgPSBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2U7XG4gIH1cblxuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4dCk7XG59O1xuXG5jb25zdCBjb3B5Q2hhciA9IChuZXdSb3csIGNoaWxkKSA9PiB7XG4gIGlmIChuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8XG4gICAgICBuZXdSb3cuY2hpbGRyZW5bbmV3Um93LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnR5cGUgIT09IFwibXRleHRcIikge1xuICAgIGNvbnN0IG10ZXh0ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICBcIm10ZXh0XCIsXG4gICAgICBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoY2hpbGQuY2hpbGRyZW5bMF0udGV4dCldXG4gICAgKTtcbiAgICBuZXdSb3cuY2hpbGRyZW4ucHVzaChtdGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgbmV3Um93LmNoaWxkcmVuW25ld1Jvdy5jaGlsZHJlbi5sZW5ndGggLSAxXS5jaGlsZHJlblswXS50ZXh0ICs9IGNoaWxkLmNoaWxkcmVuWzBdLnRleHQ7XG4gIH1cbn07XG5cbmNvbnN0IGNvbnNvbGlkYXRlVGV4dCA9IG1yb3cgPT4ge1xuICAvLyBJZiBwb3NzaWJsZSwgY29uc29saWRhdGUgYWRqYWNlbnQgPG10ZXh0PiBlbGVtZW50cyBpbnRvIGEgc2luZ2xlIGVsZW1lbnQuXG4gIGlmIChtcm93LnR5cGUgIT09IFwibXJvd1wiICYmIG1yb3cudHlwZSAhPT0gXCJtc3R5bGVcIikgeyByZXR1cm4gbXJvdyB9XG4gIGlmIChtcm93LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbXJvdyB9IC8vIGVtcHR5IGdyb3VwLCBlLmcuLCBcXHRleHR7fVxuICBjb25zdCBuZXdSb3cgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbXJvdy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gbXJvdy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJtdGV4dFwiICYmIE9iamVjdC5rZXlzKGNoaWxkLmF0dHJpYnV0ZXMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29weUNoYXIobmV3Um93LCBjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZC50eXBlID09PSBcIm1yb3dcIikge1xuICAgICAgLy8gV2UnbGwgYWxzbyBjaGVjayB0aGUgY2hpbGRyZW4gb2YgYW4gbXJvdy4gT25lIGxldmVsIG9ubHkuIE5vIHJlY3Vyc2lvbi5cbiAgICAgIGxldCBjYW5Db25zb2xpZGF0ZSA9IHRydWU7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGdyYW5kQ2hpbGQgPSBjaGlsZC5jaGlsZHJlbltqXTtcbiAgICAgICAgaWYgKGdyYW5kQ2hpbGQudHlwZSAhPT0gXCJtdGV4dFwiIHx8IE9iamVjdC5rZXlzKGNoaWxkLmF0dHJpYnV0ZXMpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNhbkNvbnNvbGlkYXRlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhbkNvbnNvbGlkYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBncmFuZENoaWxkID0gY2hpbGQuY2hpbGRyZW5bal07XG4gICAgICAgICAgY29weUNoYXIobmV3Um93LCBncmFuZENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Um93LmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdSb3cuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3Um93LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5ld1Jvdy5jaGlsZHJlbltpXS50eXBlID09PSBcIm10ZXh0XCIpIHtcbiAgICAgIGNvbnN0IG10ZXh0ID0gbmV3Um93LmNoaWxkcmVuW2ldO1xuICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCByZW5kZXIgYSBzcGFjZSBhdCBlaXRoZXIgZW5kIG9mIGFuIDxtdGV4dD4gc3RyaW5nLlxuICAgICAgLy8gVG8gZ2V0IHByb3BlciByZW5kZXJpbmcsIHdlIHJlcGxhY2UgbGVhZGluZyBvciB0cmFpbGluZyBzcGFjZXMgd2l0aCBuby1icmVhayBzcGFjZXMuXG4gICAgICBpZiAobXRleHQuY2hpbGRyZW5bMF0udGV4dC5jaGFyQXQoMCkgPT09IFwiIFwiKSB7XG4gICAgICAgIG10ZXh0LmNoaWxkcmVuWzBdLnRleHQgPSBcIlxcdTAwYTBcIiArIG10ZXh0LmNoaWxkcmVuWzBdLnRleHQuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBjb25zdCBMID0gbXRleHQuY2hpbGRyZW5bMF0udGV4dC5sZW5ndGg7XG4gICAgICBpZiAoTCA+IDAgJiYgbXRleHQuY2hpbGRyZW5bMF0udGV4dC5jaGFyQXQoTCAtIDEpID09PSBcIiBcIikge1xuICAgICAgICBtdGV4dC5jaGlsZHJlblswXS50ZXh0ID0gbXRleHQuY2hpbGRyZW5bMF0udGV4dC5zbGljZSgwLCAtMSkgKyBcIlxcdTAwYTBcIjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1yb3cuYXR0cmlidXRlcykpIHtcbiAgICAgICAgbXRleHQuYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChuZXdSb3cuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5ld1Jvdy5jaGlsZHJlblswXS50eXBlID09PSBcIm10ZXh0XCIpIHtcbiAgICByZXR1cm4gbmV3Um93LmNoaWxkcmVuWzBdOyAvLyBBIGNvbnNvbGlkYXRlZCA8bXRleHQ+XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ld1Jvd1xuICB9XG59O1xuXG4vKipcbiAqIFdyYXAgdGhlIGdpdmVuIGFycmF5IG9mIG5vZGVzIGluIGFuIDxtcm93PiBub2RlIGlmIG5lZWRlZCwgaS5lLixcbiAqIHVubGVzcyB0aGUgYXJyYXkgaGFzIGxlbmd0aCAxLiAgQWx3YXlzIHJldHVybnMgYSBzaW5nbGUgbm9kZS5cbiAqL1xuY29uc3QgbWFrZVJvdyA9IGZ1bmN0aW9uKGJvZHksIHNlbWlzaW1wbGUgPSBmYWxzZSkge1xuICBpZiAoYm9keS5sZW5ndGggPT09IDEgJiYgIShib2R5WzBdIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkpIHtcbiAgICByZXR1cm4gYm9keVswXTtcbiAgfSBlbHNlIGlmICghc2VtaXNpbXBsZSkge1xuICAgIC8vIFN1cHByZXNzIHNwYWNpbmcgb24gPG1vPiBub2RlcyBhdCBib3RoIGVuZHMgb2YgdGhlIHJvdy5cbiAgICBpZiAoYm9keVswXSBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGJvZHlbMF0udHlwZSA9PT0gXCJtb1wiICYmICFib2R5WzBdLmF0dHJpYnV0ZXMuZmVuY2UpIHtcbiAgICAgIGJvZHlbMF0uYXR0cmlidXRlcy5sc3BhY2UgPSBcIjBlbVwiO1xuICAgICAgYm9keVswXS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMGVtXCI7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IGJvZHkubGVuZ3RoIC0gMTtcbiAgICBpZiAoYm9keVtlbmRdIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgYm9keVtlbmRdLnR5cGUgPT09IFwibW9cIiAmJiAhYm9keVtlbmRdLmF0dHJpYnV0ZXMuZmVuY2UpIHtcbiAgICAgIGJvZHlbZW5kXS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMGVtXCI7XG4gICAgICBib2R5W2VuZF0uYXR0cmlidXRlcy5yc3BhY2UgPSBcIjBlbVwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGJvZHkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBmb3IgPG1pPi48L21pPiB3aGljaCBpcyBob3cgYSBkb3QgcmVuZGVycyBpbiBNYXRoTUwsXG4gKiBvciA8bW8gc2VwYXJhdG9yPVwidHJ1ZVwiIGxzcGFjZT1cIjBlbVwiIHJzcGFjZT1cIjBlbVwiPiw8L21vPlxuICogd2hpY2ggaXMgaG93IGEgYnJhY2VkIGNvbW1hIHssfSByZW5kZXJzIGluIE1hdGhNTFxuICovXG5mdW5jdGlvbiBpc051bWJlclB1bmN0dWF0aW9uKGdyb3VwKSB7XG4gIGlmICghZ3JvdXApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAoZ3JvdXAudHlwZSA9PT0gJ21pJyAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlICYmIGNoaWxkLnRleHQgPT09ICcuJ1xuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwibXRleHRcIiAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiBjaGlsZCBpbnN0YW5jZW9mIFRleHROb2RlICYmIGNoaWxkLnRleHQgPT09ICdcXHUyMDA4JyAvLyBwdW5jdHVhdGlvbiBzcGFjZVxuICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09ICdtbycgJiYgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgZ3JvdXAuZ2V0QXR0cmlidXRlKCdzZXBhcmF0b3InKSA9PT0gJ3RydWUnICYmXG4gICAgZ3JvdXAuZ2V0QXR0cmlidXRlKCdsc3BhY2UnKSA9PT0gJzBlbScgJiZcbiAgICBncm91cC5nZXRBdHRyaWJ1dGUoJ3JzcGFjZScpID09PSAnMGVtJykge1xuICAgIGNvbnN0IGNoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gJywnXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbmNvbnN0IGlzQ29tbWEgPSAoZXhwcmVzc2lvbiwgaSkgPT4ge1xuICBjb25zdCBub2RlID0gZXhwcmVzc2lvbltpXTtcbiAgY29uc3QgZm9sbG93aW5nTm9kZSA9IGV4cHJlc3Npb25baSArIDFdO1xuICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJhdG9tXCIgJiYgbm9kZS50ZXh0ID09PSBcIixcIikgJiZcbiAgICAvLyBEb24ndCBjb25zb2xpZGF0ZSBpZiB0aGVyZSBpcyBhIHNwYWNlIGFmdGVyIHRoZSBjb21tYS5cbiAgICBub2RlLmxvYyAmJiBmb2xsb3dpbmdOb2RlLmxvYyAmJiBub2RlLmxvYy5lbmQgPT09IGZvbGxvd2luZ05vZGUubG9jLnN0YXJ0XG59O1xuXG5jb25zdCBpc1JlbCA9IGl0ZW0gPT4ge1xuICByZXR1cm4gKGl0ZW0udHlwZSA9PT0gXCJhdG9tXCIgJiYgaXRlbS5mYW1pbHkgPT09IFwicmVsXCIpIHx8XG4gICAgICAoaXRlbS50eXBlID09PSBcIm1jbGFzc1wiICYmIGl0ZW0ubWNsYXNzID09PSBcIm1yZWxcIilcbn07XG5cbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIG5vZGVzLCBidWlsZHMgdGhlbSwgYW5kIHJldHVybnMgYSBsaXN0IG9mIHRoZSBnZW5lcmF0ZWRcbiAqIE1hdGhNTCBub2Rlcy4gIEFsc28gZG8gYSBjb3VwbGUgY2hvcmVzIGFsb25nIHRoZSB3YXk6XG4gKiAoMSkgU3VwcHJlc3Mgc3BhY2luZyB3aGVuIGFuIGF1dGhvciB3cmFwcyBhbiBvcGVyYXRvciB3L2JyYWNlcywgYXMgaW4gez19LlxuICogKDIpIFN1cHByZXNzIHNwYWNpbmcgYmV0d2VlbiB0d28gYWRqYWNlbnQgcmVsYXRpb25zLlxuICovXG5jb25zdCBidWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByZXNzaW9uLCBzdHlsZSwgc2VtaXNpbXBsZSA9IGZhbHNlKSB7XG4gIGlmICghc2VtaXNpbXBsZSAmJiBleHByZXNzaW9uLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGdyb3VwID0gYnVpbGRHcm91cCQxKGV4cHJlc3Npb25bMF0sIHN0eWxlKTtcbiAgICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBNYXRoTm9kZSAmJiBncm91cC50eXBlID09PSBcIm1vXCIpIHtcbiAgICAgIC8vIFdoZW4gVGVYIHdyaXRlcnMgd2FudCB0byBzdXBwcmVzcyBzcGFjaW5nIG9uIGFuIG9wZXJhdG9yLFxuICAgICAgLy8gdGhleSBvZnRlbiBwdXQgdGhlIG9wZXJhdG9yIGJ5IGl0c2VsZiBpbnNpZGUgYnJhY2VzLlxuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMGVtXCIpO1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwicnNwYWNlXCIsIFwiMGVtXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW2dyb3VwXTtcbiAgfVxuXG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuICBjb25zdCBncm91cEFycmF5ID0gW107XG4gIGxldCBsYXN0R3JvdXA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgIGdyb3VwQXJyYXkucHVzaChidWlsZEdyb3VwJDEoZXhwcmVzc2lvbltpXSwgc3R5bGUpKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGdyb3VwID0gZ3JvdXBBcnJheVtpXTtcblxuICAgIC8vIFN1cHByZXNzIHNwYWNpbmcgYmV0d2VlbiBhZGphY2VudCByZWxhdGlvbnNcbiAgICBpZiAoaSA8IGV4cHJlc3Npb24ubGVuZ3RoIC0gMSAmJiBpc1JlbChleHByZXNzaW9uW2ldKSAmJiBpc1JlbChleHByZXNzaW9uW2kgKyAxXSkpIHtcbiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjBlbVwiKTtcbiAgICB9XG4gICAgaWYgKGkgPiAwICYmIGlzUmVsKGV4cHJlc3Npb25baV0pICYmIGlzUmVsKGV4cHJlc3Npb25baSAtIDFdKSkge1xuICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiMGVtXCIpO1xuICAgIH1cblxuICAgIC8vIENvbmNhdGVuYXRlIG51bWJlcnNcbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gJ21uJyAmJiBsYXN0R3JvdXAgJiYgbGFzdEdyb3VwLnR5cGUgPT09ICdtbicpIHtcbiAgICAgIC8vIENvbmNhdGVuYXRlIDxtbj4uLi48L21uPiBmb2xsb3dlZCBieSA8bWk+LjwvbWk+XG4gICAgICBsYXN0R3JvdXAuY2hpbGRyZW4ucHVzaCguLi5ncm91cC5jaGlsZHJlbik7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXJQdW5jdHVhdGlvbihncm91cCkgJiYgbGFzdEdyb3VwICYmIGxhc3RHcm91cC50eXBlID09PSAnbW4nKSB7XG4gICAgICAvLyBDb25jYXRlbmF0ZSA8bW4+Li4uPC9tbj4gZm9sbG93ZWQgYnkgPG1pPi48L21pPlxuICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uZ3JvdXAuY2hpbGRyZW4pO1xuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKGxhc3RHcm91cCAmJiBsYXN0R3JvdXAudHlwZSA9PT0gXCJtblwiICYmIGkgPCBncm91cEFycmF5Lmxlbmd0aCAtIDEgJiZcbiAgICAgIGdyb3VwQXJyYXlbaSArIDFdLnR5cGUgPT09IFwibW5cIiAmJiBpc0NvbW1hKGV4cHJlc3Npb24sIGkpKSB7XG4gICAgICBsYXN0R3JvdXAuY2hpbGRyZW4ucHVzaCguLi5ncm91cC5jaGlsZHJlbik7XG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gJ21uJyAmJiBpc051bWJlclB1bmN0dWF0aW9uKGxhc3RHcm91cCkpIHtcbiAgICAgIC8vIENvbmNhdGVuYXRlIDxtaT4uPC9taT4gZm9sbG93ZWQgYnkgPG1uPi4uLjwvbW4+XG4gICAgICBncm91cC5jaGlsZHJlbiA9IFsuLi5sYXN0R3JvdXAuY2hpbGRyZW4sIC4uLmdyb3VwLmNoaWxkcmVuXTtcbiAgICAgIGdyb3Vwcy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKChncm91cC50eXBlID09PSAnbXN1cCcgfHwgZ3JvdXAudHlwZSA9PT0gJ21zdWInKSAmJlxuICAgICAgICBncm91cC5jaGlsZHJlbi5sZW5ndGggPj0gMSAmJiBsYXN0R3JvdXAgJiZcbiAgICAgICAgKGxhc3RHcm91cC50eXBlID09PSAnbW4nIHx8IGlzTnVtYmVyUHVuY3R1YXRpb24obGFzdEdyb3VwKSkpIHtcbiAgICAgIC8vIFB1dCBwcmVjZWRpbmcgPG1uPi4uLjwvbW4+IG9yIDxtaT4uPC9taT4gaW5zaWRlIGJhc2Ugb2ZcbiAgICAgIC8vIDxtc3VwPjxtbj4uLi5iYXNlLi4uPC9tbj4uLi5leHBvbmVudC4uLjwvbXN1cD4gKG9yIDxtc3ViPilcbiAgICAgIGNvbnN0IGJhc2UgPSBncm91cC5jaGlsZHJlblswXTtcbiAgICAgIGlmIChiYXNlIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgYmFzZS50eXBlID09PSAnbW4nICYmIGxhc3RHcm91cCkge1xuICAgICAgICBiYXNlLmNoaWxkcmVuID0gWy4uLmxhc3RHcm91cC5jaGlsZHJlbiwgLi4uYmFzZS5jaGlsZHJlbl07XG4gICAgICAgIGdyb3Vwcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgIGxhc3RHcm91cCA9IGdyb3VwO1xuICB9XG4gIHJldHVybiBncm91cHNcbn07XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBidWlsZEV4cHJlc3Npb24sIGJ1dCB3cmFwcyB0aGUgZWxlbWVudHMgaW4gYW4gPG1yb3c+XG4gKiBpZiB0aGVyZSdzIG1vcmUgdGhhbiBvbmUuICBSZXR1cm5zIGEgc2luZ2xlIG5vZGUgaW5zdGVhZCBvZiBhbiBhcnJheS5cbiAqL1xuY29uc3QgYnVpbGRFeHByZXNzaW9uUm93ID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgc3R5bGUsIHNlbWlzaW1wbGUgPSBmYWxzZSkge1xuICByZXR1cm4gbWFrZVJvdyhidWlsZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgc3R5bGUsIHNlbWlzaW1wbGUpLCBzZW1pc2ltcGxlKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBncm91cCBmcm9tIHRoZSBwYXJzZXIgYW5kIGNhbGxzIHRoZSBhcHByb3ByaWF0ZSBncm91cEJ1aWxkZXJzIGZ1bmN0aW9uXG4gKiBvbiBpdCB0byBwcm9kdWNlIGEgTWF0aE1MIG5vZGUuXG4gKi9cbmNvbnN0IGJ1aWxkR3JvdXAkMSA9IGZ1bmN0aW9uKGdyb3VwLCBzdHlsZSkge1xuICBpZiAoIWdyb3VwKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgfVxuXG4gIGlmIChfbWF0aG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXSkge1xuICAgIC8vIENhbGwgdGhlIGdyb3VwQnVpbGRlcnMgZnVuY3Rpb25cbiAgICBjb25zdCByZXN1bHQgPSBfbWF0aG1sR3JvdXBCdWlsZGVyc1tncm91cC50eXBlXShncm91cCwgc3R5bGUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICB9XG59O1xuXG5jb25zdCBnbHVlJDEgPSBfID0+IHtcbiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdLCBbXSwgeyBwYWRkaW5nOiBcIjBcIiwgd2lkdGg6IFwiNTAlXCIgfSlcbn07XG5cbmNvbnN0IGxhYmVsQ29udGFpbmVycyA9IFtcIm1yb3dcIiwgXCJtdGRcIiwgXCJtdGFibGVcIiwgXCJtdHJcIl07XG5jb25zdCBnZXRMYWJlbCA9IHBhcmVudCA9PiB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICBpZiAobm9kZS50eXBlICYmIGxhYmVsQ29udGFpbmVycy5pbmNsdWRlcyhub2RlLnR5cGUpKSB7XG4gICAgICBpZiAobm9kZS5jbGFzc2VzICYmIG5vZGUuY2xhc3Nlc1swXSA9PT0gXCJ0bWwtbGFiZWxcIikge1xuICAgICAgICBjb25zdCBsYWJlbCA9IG5vZGUubGFiZWw7XG4gICAgICAgIHJldHVybiBsYWJlbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBnZXRMYWJlbChub2RlKTtcbiAgICAgICAgaWYgKGxhYmVsKSB7IHJldHVybiBsYWJlbCB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbm9kZS50eXBlKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IGdldExhYmVsKG5vZGUpO1xuICAgICAgaWYgKGxhYmVsKSB7IHJldHVybiBsYWJlbCB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCB0YWdnZWRFeHByZXNzaW9uID0gKGV4cHJlc3Npb24sIHRhZywgc3R5bGUsIGxlcW5vKSA9PiB7XG4gIHRhZyA9IGJ1aWxkRXhwcmVzc2lvblJvdyh0YWdbMF0uYm9keSwgc3R5bGUpO1xuICB0YWcgPSBjb25zb2xpZGF0ZVRleHQodGFnKTtcbiAgdGFnLmNsYXNzZXMucHVzaChcInRtbC10YWdcIik7XG5cbiAgY29uc3QgbGFiZWwgPSBnZXRMYWJlbChleHByZXNzaW9uKTsgLy8gZnJvbSBhIFxcbGFiZWx7fSBmdW5jdGlvbi5cbiAgZXhwcmVzc2lvbiA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtleHByZXNzaW9uXSk7XG4gIGNvbnN0IHJvd0FycmF5ID0gW2dsdWUkMSgpLCBleHByZXNzaW9uLCBnbHVlJDEoKV07XG4gIHJvd0FycmF5W2xlcW5vID8gMCA6IDJdLmNsYXNzZXMucHVzaChsZXFubyA/IFwidG1sLWxlZnRcIiA6IFwidG1sLXJpZ2h0XCIpO1xuICByb3dBcnJheVtsZXFubyA/IDAgOiAyXS5jaGlsZHJlbi5wdXNoKHRhZyk7XG4gIGNvbnN0IG10ciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIHJvd0FycmF5LCBbXCJ0bWwtdGFnZXFuXCJdKTtcbiAgaWYgKGxhYmVsKSB7IG10ci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBsYWJlbCk7IH1cbiAgY29uc3QgdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCBbbXRyXSk7XG4gIHRhYmxlLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gIHRhYmxlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBcInRydWVcIik7XG4gIHJldHVybiB0YWJsZVxufTtcblxuLyoqXG4gKiBUYWtlcyBhIGZ1bGwgcGFyc2UgdHJlZSBhbmQgc2V0dGluZ3MgYW5kIGJ1aWxkcyBhIE1hdGhNTCByZXByZXNlbnRhdGlvbiBvZlxuICogaXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTWF0aE1MKHRyZWUsIHRleEV4cHJlc3Npb24sIHN0eWxlLCBzZXR0aW5ncykge1xuICAvLyBTdHJpcCBvZmYgb3V0ZXIgdGFnIHdyYXBwZXIgZm9yIHByb2Nlc3NpbmcgYmVsb3cuXG4gIGxldCB0YWcgPSBudWxsO1xuICBpZiAodHJlZS5sZW5ndGggPT09IDEgJiYgdHJlZVswXS50eXBlID09PSBcInRhZ1wiKSB7XG4gICAgdGFnID0gdHJlZVswXS50YWc7XG4gICAgdHJlZSA9IHRyZWVbMF0uYm9keTtcbiAgfVxuXG4gIGNvbnN0IGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24odHJlZSwgc3R5bGUpO1xuXG4gIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSAmJiBleHByZXNzaW9uWzBdIGluc3RhbmNlb2YgQW5jaG9yTm9kZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uWzBdXG4gIH1cblxuICBjb25zdCB3cmFwID0gKHNldHRpbmdzLmRpc3BsYXlNb2RlIHx8IHNldHRpbmdzLmFubm90YXRlKSA/IFwibm9uZVwiIDogc2V0dGluZ3Mud3JhcDtcblxuICBjb25zdCBuMSA9IGV4cHJlc3Npb24ubGVuZ3RoID09PSAwID8gbnVsbCA6IGV4cHJlc3Npb25bMF07XG4gIGxldCB3cmFwcGVyID0gZXhwcmVzc2lvbi5sZW5ndGggPT09IDEgJiYgdGFnID09PSBudWxsICYmIChuMSBpbnN0YW5jZW9mIE1hdGhOb2RlKVxuICAgICAgPyBleHByZXNzaW9uWzBdXG4gICAgICA6IHNldExpbmVCcmVha3MoZXhwcmVzc2lvbiwgd3JhcCwgc2V0dGluZ3MuZGlzcGxheU1vZGUpO1xuXG4gIGlmICh0YWcpIHtcbiAgICB3cmFwcGVyID0gdGFnZ2VkRXhwcmVzc2lvbih3cmFwcGVyLCB0YWcsIHN0eWxlLCBzZXR0aW5ncy5sZXFubyk7XG4gIH1cblxuICBpZiAoc2V0dGluZ3MuYW5ub3RhdGUpIHtcbiAgICAvLyBCdWlsZCBhIFRlWCBhbm5vdGF0aW9uIG9mIHRoZSBzb3VyY2VcbiAgICBjb25zdCBhbm5vdGF0aW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICBcImFubm90YXRpb25cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleEV4cHJlc3Npb24pXSk7XG4gICAgYW5ub3RhdGlvbi5zZXRBdHRyaWJ1dGUoXCJlbmNvZGluZ1wiLCBcImFwcGxpY2F0aW9uL3gtdGV4XCIpO1xuICAgIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcInNlbWFudGljc1wiLCBbd3JhcHBlciwgYW5ub3RhdGlvbl0pO1xuICB9XG5cbiAgY29uc3QgbWF0aCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWF0aFwiLCBbd3JhcHBlcl0pO1xuXG4gIGlmIChzZXR0aW5ncy54bWwpIHtcbiAgICBtYXRoLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiKTtcbiAgfVxuICBpZiAod3JhcHBlci5zdHlsZS53aWR0aCkge1xuICAgIG1hdGguc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgfVxuICBpZiAoc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICBtYXRoLnNldEF0dHJpYnV0ZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcbiAgICBtYXRoLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrIG1hdGhcIjsgLy8gbmVjZXNzYXJ5IGluIENocm9taXVtLlxuICAgIC8vIEZpcmVmb3ggYW5kIFNhZmFyaSBkbyBub3QgcmVjb2duaXplIGRpc3BsYXk6IFwiYmxvY2sgbWF0aFwiLlxuICAgIC8vIFNldCBhIGNsYXNzIHNvIHRoYXQgdGhlIENTUyBmaWxlIGNhbiBzZXQgZGlzcGxheTogYmxvY2suXG4gICAgbWF0aC5jbGFzc2VzID0gW1widG1sLWRpc3BsYXlcIl07XG4gIH1cbiAgcmV0dXJuIG1hdGg7XG59XG5cbmNvbnN0IHNtYWxscyA9IFwiYWNlZ8SxyLdtbm9wcXJzdXZ3eHl6zrHOs861zrfOuc66zrzOvc6/z4DPgc+Cz4PPhM+Fz4fPic+V8J2QmvCdkJzwnZCe8J2QoPCdkKbwnZCn8J2QqPCdkKnwnZCq8J2Qq/CdkKzwnZCu8J2Qr/CdkLDwnZCx8J2QsvCdkLNcIjtcbmNvbnN0IHRhbGxzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmJkZmhrbHTOkc6SzpPOlM6VzpbOl86YzpnOms6bzpzOnc6ezp/OoM6hzqPOpM6lzqbOp86ozqnOss60zrvOts+GzrjPiFwiXG4gICAgICAgICAgICAgKyBcIvCdkIDwnZCB8J2QgvCdkIPwnZCE8J2QhfCdkIbwnZCH8J2QiPCdkInwnZCK8J2Qi/CdkIzwnZCN8J2QjvCdkI/wnZCQ8J2QkfCdkJLwnZCT8J2QlPCdkJXwnZCW8J2Ql/CdkJjwnZCZ8J2Qm/CdkJ3wnZCf8J2QofCdkKTwnZCl8J2QrVwiO1xuY29uc3QgbG9uZ1NtYWxscyA9IG5ldyBTZXQoW1wiXFxcXGFscGhhXCIsIFwiXFxcXGdhbW1hXCIsIFwiXFxcXGRlbHRhXCIsIFwiXFxcXGVwc2lsb25cIiwgXCJcXFxcZXRhXCIsIFwiXFxcXGlvdGFcIixcbiAgXCJcXFxca2FwcGFcIiwgXCJcXFxcbXVcIiwgXCJcXFxcbnVcIiwgXCJcXFxccGlcIiwgXCJcXFxccmhvXCIsIFwiXFxcXHNpZ21hXCIsIFwiXFxcXHRhdVwiLCBcIlxcXFx1cHNpbG9uXCIsIFwiXFxcXGNoaVwiLCBcIlxcXFxwc2lcIixcbiAgXCJcXFxcb21lZ2FcIiwgXCJcXFxcaW1hdGhcIiwgXCJcXFxcam1hdGhcIl0pO1xuY29uc3QgbG9uZ1RhbGxzID0gbmV3IFNldChbXCJcXFxcR2FtbWFcIiwgXCJcXFxcRGVsdGFcIiwgXCJcXFxcU2lnbWFcIiwgXCJcXFxcT21lZ2FcIiwgXCJcXFxcYmV0YVwiLCBcIlxcXFxkZWx0YVwiLFxuICBcIlxcXFxsYW1iZGFcIiwgXCJcXFxcdGhldGFcIiwgXCJcXFxccHNpXCJdKTtcblxuY29uc3QgbWF0aG1sQnVpbGRlciRhID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBjb25zdCBhY2NlbnROb2RlID0gZ3JvdXAuaXNTdHJldGNoeVxuICAgID8gc3RyZXRjaHkuYWNjZW50Tm9kZShncm91cClcbiAgICA6IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLmxhYmVsLCBncm91cC5tb2RlKV0pO1xuXG4gIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcdmVjXCIpIHtcbiAgICBhY2NlbnROb2RlLnN0eWxlLnRyYW5zZm9ybSA9IFwic2NhbGUoMC43NSkgdHJhbnNsYXRlKDEwJSwgMzAlKVwiO1xuICB9IGVsc2Uge1xuICAgIGFjY2VudE5vZGUuc3R5bGUubWF0aFN0eWxlID0gXCJub3JtYWxcIjtcbiAgICBhY2NlbnROb2RlLnN0eWxlLm1hdGhEZXB0aCA9IFwiMFwiO1xuICAgIGlmIChuZWVkV2Via2l0U2hpZnQuaGFzKGdyb3VwLmxhYmVsKSAmJiAgdXRpbHMuaXNDaGFyYWN0ZXJCb3goZ3JvdXAuYmFzZSkpIHtcbiAgICAgIGxldCBzaGlmdCA9IFwiXCI7XG4gICAgICBjb25zdCBjaCA9IGdyb3VwLmJhc2UudGV4dDtcbiAgICAgIGlmIChzbWFsbHMuaW5kZXhPZihjaCkgPiAtMSB8fCBsb25nU21hbGxzLmhhcyhjaCkpIHsgc2hpZnQgPSBcInRtbC14c2hpZnRcIjsgfVxuICAgICAgaWYgKHRhbGxzLmluZGV4T2YoY2gpID4gLTEgIHx8IGxvbmdUYWxscy5oYXMoY2gpKSAgeyBzaGlmdCA9IFwidG1sLWNhcHNoaWZ0XCI7IH1cbiAgICAgIGlmIChzaGlmdCkgeyBhY2NlbnROb2RlLmNsYXNzZXMucHVzaChzaGlmdCk7IH1cbiAgICB9XG4gIH1cbiAgaWYgKCFncm91cC5pc1N0cmV0Y2h5KSB7XG4gICAgYWNjZW50Tm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKChncm91cC5sYWJlbCA9PT0gXCJcXFxcY1wiID8gXCJtdW5kZXJcIiA6IFwibW92ZXJcIiksXG4gICAgW2J1aWxkR3JvdXAkMShncm91cC5iYXNlLCBzdHlsZSksIGFjY2VudE5vZGVdXG4gICk7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBub25TdHJldGNoeUFjY2VudHMgPSBuZXcgU2V0KFtcbiAgXCJcXFxcYWN1dGVcIixcbiAgXCJcXFxcZ3JhdmVcIixcbiAgXCJcXFxcZGRvdFwiLFxuICBcIlxcXFxkZGRvdFwiLFxuICBcIlxcXFxkZGRkb3RcIixcbiAgXCJcXFxcdGlsZGVcIixcbiAgXCJcXFxcYmFyXCIsXG4gIFwiXFxcXGJyZXZlXCIsXG4gIFwiXFxcXGNoZWNrXCIsXG4gIFwiXFxcXGhhdFwiLFxuICBcIlxcXFx2ZWNcIixcbiAgXCJcXFxcZG90XCIsXG4gIFwiXFxcXG1hdGhyaW5nXCJcbl0pO1xuXG5jb25zdCBuZWVkV2Via2l0U2hpZnQgPSBuZXcgU2V0KFtcbiAgXCJcXFxcYWN1dGVcIixcbiAgXCJcXFxcYmFyXCIsXG4gIFwiXFxcXGJyZXZlXCIsXG4gIFwiXFxcXGNoZWNrXCIsXG4gIFwiXFxcXGRvdFwiLFxuICBcIlxcXFxkZG90XCIsXG4gIFwiXFxcXGdyYXZlXCIsXG4gIFwiXFxcXGhhdFwiLFxuICBcIlxcXFxtYXRocmluZ1wiLFxuICBcIlxcXFwnXCIsIFwiXFxcXF5cIiwgXCJcXFxcflwiLCBcIlxcXFw9XCIsIFwiXFxcXHVcIiwgXCJcXFxcLlwiLCAnXFxcXFwiJywgXCJcXFxcclwiLCBcIlxcXFxIXCIsIFwiXFxcXHZcIlxuXSk7XG5cbmNvbnN0IGNvbWJpbmluZ0NoYXIgPSB7XG4gIFwiXFxcXGBcIjogXCJcXHUwMzAwXCIsXG4gIFwiXFxcXCdcIjogXCJcXHUwMzAxXCIsXG4gIFwiXFxcXF5cIjogXCJcXHUwMzAyXCIsXG4gIFwiXFxcXH5cIjogXCJcXHUwMzAzXCIsXG4gIFwiXFxcXD1cIjogXCJcXHUwMzA0XCIsXG4gIFwiXFxcXHVcIjogXCJcXHUwMzA2XCIsXG4gIFwiXFxcXC5cIjogXCJcXHUwMzA3XCIsXG4gICdcXFxcXCInOiBcIlxcdTAzMDhcIixcbiAgXCJcXFxcclwiOiBcIlxcdTAzMEFcIixcbiAgXCJcXFxcSFwiOiBcIlxcdTAzMEJcIixcbiAgXCJcXFxcdlwiOiBcIlxcdTAzMENcIlxufTtcblxuLy8gQWNjZW50c1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImFjY2VudFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGFjdXRlXCIsXG4gICAgXCJcXFxcZ3JhdmVcIixcbiAgICBcIlxcXFxkZG90XCIsXG4gICAgXCJcXFxcZGRkb3RcIixcbiAgICBcIlxcXFxkZGRkb3RcIixcbiAgICBcIlxcXFx0aWxkZVwiLFxuICAgIFwiXFxcXGJhclwiLFxuICAgIFwiXFxcXGJyZXZlXCIsXG4gICAgXCJcXFxcY2hlY2tcIixcbiAgICBcIlxcXFxoYXRcIixcbiAgICBcIlxcXFx2ZWNcIixcbiAgICBcIlxcXFxkb3RcIixcbiAgICBcIlxcXFxtYXRocmluZ1wiLFxuICAgIFwiXFxcXG92ZXJwYXJlblwiLFxuICAgIFwiXFxcXHdpZGVjaGVja1wiLFxuICAgIFwiXFxcXHdpZGVoYXRcIixcbiAgICBcIlxcXFx3aWRlcGFyZW5cIixcbiAgICBcIlxcXFx3aWRldGlsZGVcIixcbiAgICBcIlxcXFxvdmVycmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXG92ZXJsZWZ0YXJyb3dcIixcbiAgICBcIlxcXFxPdmVycmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXG92ZXJsZWZ0cmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXG92ZXJncm91cFwiLFxuICAgIFwiXFxcXG92ZXJsZWZ0aGFycG9vblwiLFxuICAgIFwiXFxcXG92ZXJyaWdodGhhcnBvb25cIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICBjb25zdCBiYXNlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG5cbiAgICBjb25zdCBpc1N0cmV0Y2h5ID0gIW5vblN0cmV0Y2h5QWNjZW50cy5oYXMoY29udGV4dC5mdW5jTmFtZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSxcbiAgICAgIGlzU3RyZXRjaHk6IGlzU3RyZXRjaHksXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciRhXG59KTtcblxuLy8gVGV4dC1tb2RlIGFjY2VudHNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJhY2NlbnRcIixcbiAgbmFtZXM6IFtcIlxcXFwnXCIsIFwiXFxcXGBcIiwgXCJcXFxcXlwiLCBcIlxcXFx+XCIsIFwiXFxcXD1cIiwgXCJcXFxcY1wiLCBcIlxcXFx1XCIsIFwiXFxcXC5cIiwgJ1xcXFxcIicsIFwiXFxcXHJcIiwgXCJcXFxcSFwiLCBcIlxcXFx2XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICBjb25zdCBiYXNlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7XG4gICAgY29uc3QgbW9kZSA9IGNvbnRleHQucGFyc2VyLm1vZGU7XG5cbiAgICBpZiAobW9kZSA9PT0gXCJtYXRoXCIgJiYgY29udGV4dC5wYXJzZXIuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAvLyBMYVRlWCBvbmx5IHdyaXRlcyBhIHdhcm5pbmcuIEl0IGRvZXNuJ3Qgc3RvcC4gV2UnbGwgaXNzdWUgdGhlIHNhbWUgd2FybmluZy5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyhgVGVtbWwgcGFyc2UgZXJyb3I6IENvbW1hbmQgJHtjb250ZXh0LmZ1bmNOYW1lfSBpcyBpbnZhbGlkIGluIG1hdGggbW9kZS5gKTtcbiAgICB9XG5cbiAgICBpZiAobW9kZSA9PT0gXCJ0ZXh0XCIgJiYgYmFzZS50ZXh0ICYmIGJhc2UudGV4dC5sZW5ndGggPT09IDFcbiAgICAgICAgJiYgY29udGV4dC5mdW5jTmFtZSBpbiBjb21iaW5pbmdDaGFyICAmJiBzbWFsbHMuaW5kZXhPZihiYXNlLnRleHQpID4gLTEpIHtcbiAgICAgIC8vIFJldHVybiBhIGNvbWJpbmluZyBhY2NlbnQgY2hhcmFjdGVyXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIHRleHQ6IGJhc2UudGV4dCArIGNvbWJpbmluZ0NoYXJbY29udGV4dC5mdW5jTmFtZV1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnVpbGQgdXAgdGhlIGFjY2VudFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJhY2NlbnRcIixcbiAgICAgICAgbW9kZTogbW9kZSxcbiAgICAgICAgbGFiZWw6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICAgIGlzU3RyZXRjaHk6IGZhbHNlLFxuICAgICAgICBiYXNlOiBiYXNlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJGFcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYWNjZW50VW5kZXJcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFx1bmRlcmxlZnRhcnJvd1wiLFxuICAgIFwiXFxcXHVuZGVycmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHVuZGVybGVmdHJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx1bmRlcmdyb3VwXCIsXG4gICAgXCJcXFxcdW5kZXJwYXJlblwiLFxuICAgIFwiXFxcXHV0aWxkZVwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhY2NlbnRVbmRlclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBiYXNlOiBiYXNlXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGFjY2VudE5vZGUgPSBzdHJldGNoeS5hY2NlbnROb2RlKGdyb3VwKTtcbiAgICBhY2NlbnROb2RlLnN0eWxlW1wibWF0aC1kZXB0aFwiXSA9IDA7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXVuZGVyXCIsIFtcbiAgICAgIGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBzdHlsZSksXG4gICAgICBhY2NlbnROb2RlXG4gICAgXSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRoaXMgZmlsZSBkb2VzIGNvbnZlcnNpb24gYmV0d2VlbiB1bml0cy4gIEluIHBhcnRpY3VsYXIsIGl0IHByb3ZpZGVzXG4gKiBjYWxjdWxhdGVTaXplIHRvIGNvbnZlcnQgb3RoZXIgdW5pdHMgaW50byBDU1MgdW5pdHMuXG4gKi9cblxuXG5jb25zdCBwdFBlclVuaXQgPSB7XG4gIC8vIENvbnZlcnQgdG8gQ1NTIChQb3N0c2NpcHQpIHBvaW50cywgbm90IFRlWCBwb2ludHNcbiAgLy8gaHR0cHM6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvTGFUZVgvTGVuZ3RocyBhbmRcbiAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vYS84MjYzXG4gIHB0OiA4MDAgLyA4MDMsIC8vIGNvbnZlcnQgVGVYIHBvaW50IHRvIENTUyAoUG9zdHNjcmlwdCkgcG9pbnRcbiAgcGM6ICgxMiAqIDgwMCkgLyA4MDMsIC8vIHBpY2FcbiAgZGQ6ICgoMTIzOCAvIDExNTcpICogODAwKSAvIDgwMywgLy8gZGlkb3RcbiAgY2M6ICgoMTQ4NTYgLyAxMTU3KSAqIDgwMCkgLyA4MDMsIC8vIGNpY2VybyAoMTIgZGlkb3QpXG4gIG5kOiAoKDY4NSAvIDY0MikgKiA4MDApIC8gODAzLCAvLyBuZXcgZGlkb3RcbiAgbmM6ICgoMTM3MCAvIDEwNykgKiA4MDApIC8gODAzLCAvLyBuZXcgY2ljZXJvICgxMiBuZXcgZGlkb3QpXG4gIHNwOiAoKDEgLyA2NTUzNikgKiA4MDApIC8gODAzLCAvLyBzY2FsZWQgcG9pbnQgKFRlWCdzIGludGVybmFsIHNtYWxsZXN0IHVuaXQpXG4gIG1tOiAoMjUuNCAvIDcyKSxcbiAgY206ICgyLjU0IC8gNzIpLFxuICBpbjogKDEgLyA3MiksXG4gIHB4OiAoOTYgLyA3Milcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNwZWNpZmllZCB1bml0IChlaXRoZXIgYSBzdHJpbmcgZGVmaW5pbmcgdGhlIHVuaXRcbiAqIG9yIGEgXCJzaXplXCIgcGFyc2Ugbm9kZSBjb250YWluaW5nIGEgdW5pdCBmaWVsZCkgaXMgdmFsaWQuXG4gKi9cbmNvbnN0IHZhbGlkVW5pdHMgPSBbXG4gIFwiZW1cIixcbiAgXCJleFwiLFxuICBcIm11XCIsXG4gIFwicHRcIixcbiAgXCJtbVwiLFxuICBcImNtXCIsXG4gIFwiaW5cIixcbiAgXCJweFwiLFxuICBcImJwXCIsXG4gIFwicGNcIixcbiAgXCJkZFwiLFxuICBcImNjXCIsXG4gIFwibmRcIixcbiAgXCJuY1wiLFxuICBcInNwXCJcbl07XG5cbmNvbnN0IHZhbGlkVW5pdCA9IGZ1bmN0aW9uKHVuaXQpIHtcbiAgaWYgKHR5cGVvZiB1bml0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5pdCA9IHVuaXQudW5pdDtcbiAgfVxuICByZXR1cm4gdmFsaWRVbml0cy5pbmRleE9mKHVuaXQpID4gLTFcbn07XG5cbmNvbnN0IGVtU2NhbGUgPSBzdHlsZUxldmVsID0+IHtcbiAgY29uc3Qgc2NyaXB0TGV2ZWwgPSBNYXRoLm1heChzdHlsZUxldmVsIC0gMSwgMCk7XG4gIHJldHVybiBbMSwgMC43LCAwLjVdW3NjcmlwdExldmVsXVxufTtcblxuLypcbiAqIENvbnZlcnQgYSBcInNpemVcIiBwYXJzZSBub2RlICh3aXRoIG51bWVyaWMgXCJudW1iZXJcIiBhbmQgc3RyaW5nIFwidW5pdFwiIGZpZWxkcyxcbiAqIGFzIHBhcnNlZCBieSBmdW5jdGlvbnMuanMgYXJnVHlwZSBcInNpemVcIikgaW50byBhIENTUyB2YWx1ZS5cbiAqL1xuY29uc3QgY2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uKHNpemVWYWx1ZSwgc3R5bGUpIHtcbiAgbGV0IG51bWJlciA9IHNpemVWYWx1ZS5udW1iZXI7XG4gIGlmIChzdHlsZS5tYXhTaXplWzBdIDwgMCAmJiBudW1iZXIgPiAwKSB7XG4gICAgcmV0dXJuIHsgbnVtYmVyOiAwLCB1bml0OiBcImVtXCIgfVxuICB9XG4gIGNvbnN0IHVuaXQgPSBzaXplVmFsdWUudW5pdDtcbiAgc3dpdGNoICh1bml0KSB7XG4gICAgY2FzZSBcIm1tXCI6XG4gICAgY2FzZSBcImNtXCI6XG4gICAgY2FzZSBcImluXCI6XG4gICAgY2FzZSBcInB4XCI6IHtcbiAgICAgIGNvbnN0IG51bUluQ3NzUHRzID0gbnVtYmVyICogcHRQZXJVbml0W3VuaXRdO1xuICAgICAgaWYgKG51bUluQ3NzUHRzID4gc3R5bGUubWF4U2l6ZVsxXSkge1xuICAgICAgICByZXR1cm4geyBudW1iZXI6IHN0eWxlLm1heFNpemVbMV0sIHVuaXQ6IFwicHRcIiB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBudW1iZXIsIHVuaXQgfTsgLy8gYWJzb2x1dGUgQ1NTIHVuaXRzLlxuICAgIH1cbiAgICBjYXNlIFwiZW1cIjpcbiAgICBjYXNlIFwiZXhcIjoge1xuICAgICAgLy8gSW4gVGVYLCBlbSBhbmQgZXggZG8gbm90IGNoYW5nZSBzaXplIGluIFxcc2NyaXB0c3R5bGUuXG4gICAgICBpZiAodW5pdCA9PT0gXCJleFwiKSB7IG51bWJlciAqPSAwLjQzMTsgfVxuICAgICAgbnVtYmVyID0gTWF0aC5taW4obnVtYmVyIC8gZW1TY2FsZShzdHlsZS5sZXZlbCksIHN0eWxlLm1heFNpemVbMF0pO1xuICAgICAgcmV0dXJuIHsgbnVtYmVyOiB1dGlscy5yb3VuZChudW1iZXIpLCB1bml0OiBcImVtXCIgfTtcbiAgICB9XG4gICAgY2FzZSBcImJwXCI6IHtcbiAgICAgIGlmIChudW1iZXIgPiBzdHlsZS5tYXhTaXplWzFdKSB7IG51bWJlciA9IHN0eWxlLm1heFNpemVbMV07IH1cbiAgICAgIHJldHVybiB7IG51bWJlciwgdW5pdDogXCJwdFwiIH07IC8vIFRlWCBicCBpcyBhIENTUyBwdC4gKDEvNzIgaW5jaCkuXG4gICAgfVxuICAgIGNhc2UgXCJwdFwiOlxuICAgIGNhc2UgXCJwY1wiOlxuICAgIGNhc2UgXCJkZFwiOlxuICAgIGNhc2UgXCJjY1wiOlxuICAgIGNhc2UgXCJuZFwiOlxuICAgIGNhc2UgXCJuY1wiOlxuICAgIGNhc2UgXCJzcFwiOiB7XG4gICAgICBudW1iZXIgPSBNYXRoLm1pbihudW1iZXIgKiBwdFBlclVuaXRbdW5pdF0sIHN0eWxlLm1heFNpemVbMV0pO1xuICAgICAgcmV0dXJuIHsgbnVtYmVyOiB1dGlscy5yb3VuZChudW1iZXIpLCB1bml0OiBcInB0XCIgfVxuICAgIH1cbiAgICBjYXNlIFwibXVcIjoge1xuICAgICAgbnVtYmVyID0gTWF0aC5taW4obnVtYmVyIC8gMTgsIHN0eWxlLm1heFNpemVbMF0pO1xuICAgICAgcmV0dXJuIHsgbnVtYmVyOiB1dGlscy5yb3VuZChudW1iZXIpLCB1bml0OiBcImVtXCIgfVxuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIHVuaXQgKyBcIidcIilcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG5jb25zdCBwYWRkaW5nJDEgPSB3aWR0aCA9PiB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCArIFwiZW1cIik7XG4gIHJldHVybiBub2RlXG59O1xuXG5jb25zdCBwYWRkZWROb2RlID0gKGdyb3VwLCBsc3BhY2UgPSAwLjMsIHJzcGFjZSA9IDAsIG11c3RTbWFzaCA9IGZhbHNlKSA9PiB7XG4gIGlmIChncm91cCA9PSBudWxsICYmIHJzcGFjZSA9PT0gMCkgeyByZXR1cm4gcGFkZGluZyQxKGxzcGFjZSkgfVxuICBjb25zdCByb3cgPSBncm91cCA/IFtncm91cF0gOiBbXTtcbiAgaWYgKGxzcGFjZSAhPT0gMCkgICB7IHJvdy51bnNoaWZ0KHBhZGRpbmckMShsc3BhY2UpKTsgfVxuICBpZiAocnNwYWNlID4gMCkgeyByb3cucHVzaChwYWRkaW5nJDEocnNwYWNlKSk7IH1cbiAgaWYgKG11c3RTbWFzaCkge1xuICAgIC8vIFVzZWQgZm9yIHRoZSBib3R0b20gYXJyb3cgaW4gYSB7Q0R9IGVudmlyb25tZW50XG4gICAgY29uc3QgbXBhZGRlZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCByb3cpO1xuICAgIG1wYWRkZWQuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMFwiKTtcbiAgICByZXR1cm4gbXBhZGRlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgcm93KVxuICB9XG59O1xuXG5jb25zdCBsYWJlbFNpemUgPSAoc2l6ZSwgc2NyaXB0TGV2ZWwpID0+ICBOdW1iZXIoc2l6ZSkgLyBlbVNjYWxlKHNjcmlwdExldmVsKTtcblxuY29uc3QgbXVuZGVyb3Zlck5vZGUgPSAoZk5hbWUsIGJvZHksIGJlbG93LCBzdHlsZSkgPT4ge1xuICBjb25zdCBhcnJvd05vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGZOYW1lKTtcbiAgLy8gSXMgdGhpcyB0aGUgc2hvcnQgcGFydCBvZiBhIG1oY2hlbSBlcXVpbGlicml1bSBhcnJvdz9cbiAgY29uc3QgaXNFcSA9IGZOYW1lLnNsaWNlKDEsIDMpID09PSBcImVxXCI7XG4gIGNvbnN0IG1pbldpZHRoID0gZk5hbWUuY2hhckF0KDEpID09PSBcInhcIlxuICAgID8gXCIxLjc1XCIgIC8vIG1hdGh0b29scyBleHRlbnNpYmxlIGFycm93cyBhcmUg4omlIDEuNzVlbSBsb25nXG4gICAgOiBmTmFtZS5zbGljZSgyLCA0KSA9PT0gXCJjZFwiXG4gICAgPyBcIjMuMFwiICAvLyBjZCBwYWNrYWdlIGFycm93c1xuICAgIDogaXNFcVxuICAgID8gXCIxLjBcIiAgLy8gVGhlIHNob3J0ZXIgaGFycG9vbiBvZiBhIG1oY2hlbSBlcXVpbGlicml1bSBhcnJvd1xuICAgIDogXCIyLjBcIjsgLy8gb3RoZXIgbWhjaGVtIGFycm93c1xuICAvLyBUT0RPOiBXaGVuIEZpcmVmb3ggc3VwcG9ydHMgbWluc2l6ZSwgdXNlIHRoZSBuZXh0IGxpbmUuXG4gIC8vYXJyb3dOb2RlLnNldEF0dHJpYnV0ZShcIm1pbnNpemVcIiwgU3RyaW5nKG1pbldpZHRoKSArIFwiZW1cIilcbiAgYXJyb3dOb2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjBcIik7XG4gIGFycm93Tm9kZS5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgKGlzRXEgPyBcIjAuNWVtXCIgOiBcIjBcIikpO1xuXG4gIC8vIDxtdW5kZXJvdmVyPiB1cHBlciBhbmQgbG93ZXIgbGFiZWxzIGFyZSBzZXQgdG8gc2NyaXB0bGV2ZWwgYnkgTWF0aE1MXG4gIC8vIFNvIHdlIGhhdmUgdG8gYWRqdXN0IG91ciBsYWJlbCBkaW1lbnNpb25zIGFjY29yZGluZ2x5LlxuICBjb25zdCBsYWJlbFN0eWxlID0gc3R5bGUud2l0aExldmVsKHN0eWxlLmxldmVsIDwgMiA/IDIgOiAzKTtcbiAgY29uc3QgbWluQXJyb3dXaWR0aCA9IGxhYmVsU2l6ZShtaW5XaWR0aCwgbGFiZWxTdHlsZS5sZXZlbCk7XG4gIC8vIFRoZSBkdW1teU5vZGUgd2lsbCBiZSBpbnNpZGUgYSA8bW92ZXI+IGluc2lkZSBhIDxtb3Zlcj5cbiAgLy8gU28gaXQgd2lsbCBiZSBhdCBzY3JpcHRsZXZlbCAzXG4gIGNvbnN0IGR1bW15V2lkdGggPSBsYWJlbFNpemUobWluV2lkdGgsIDMpO1xuICBjb25zdCBlbXB0eUxhYmVsID0gcGFkZGVkTm9kZShudWxsLCBtaW5BcnJvd1dpZHRoLnRvRml4ZWQoNCksIDApO1xuICBjb25zdCBkdW1teU5vZGUgPSBwYWRkZWROb2RlKG51bGwsIGR1bW15V2lkdGgudG9GaXhlZCg0KSwgMCk7XG4gIC8vIFRoZSBhcnJvdyBpcyBhIGxpdHRsZSBsb25nZXIgdGhhbiB0aGUgbGFiZWwuIFNldCBhIHNwYWNlciBsZW5ndGguXG4gIGNvbnN0IHNwYWNlID0gbGFiZWxTaXplKChpc0VxID8gMCA6IDAuMyksIGxhYmVsU3R5bGUubGV2ZWwpLnRvRml4ZWQoNCk7XG4gIGxldCB1cHBlck5vZGU7XG4gIGxldCBsb3dlck5vZGU7XG5cbiAgY29uc3QgZ290VXBwZXIgPSAoYm9keSAmJiBib2R5LmJvZHkgJiZcbiAgICAvLyBcXGhwaGFudG9tICAgICAgICB2aXNpYmxlIGNvbnRlbnRcbiAgICAoYm9keS5ib2R5LmJvZHkgfHwgYm9keS5ib2R5Lmxlbmd0aCA+IDApKTtcbiAgaWYgKGdvdFVwcGVyKSB7XG4gICAgbGV0IGxhYmVsID0gIGJ1aWxkR3JvdXAkMShib2R5LCBsYWJlbFN0eWxlKTtcbiAgICBjb25zdCBtdXN0U21hc2ggPSAoZk5hbWUgPT09IFwiXFxcXFxcXFxjZHJpZ2h0YXJyb3dcIiB8fCBmTmFtZSA9PT0gXCJcXFxcXFxcXGNkbGVmdGFycm93XCIpO1xuICAgIGxhYmVsID0gcGFkZGVkTm9kZShsYWJlbCwgc3BhY2UsIHNwYWNlLCBtdXN0U21hc2gpO1xuICAgIC8vIFNpbmNlIEZpcmVmb3ggZG9lcyBub3Qgc3VwcG9ydCBtaW5zaXplLCBzdGFjayBhIGludmlzaWJsZSBub2RlXG4gICAgLy8gb24gdG9wIG9mIHRoZSBsYWJlbC4gSXRzIHdpZHRoIHdpbGwgc2VydmUgYXMgYSBtaW4td2lkdGguXG4gICAgLy8gVE9ETzogUmVmYWN0b3IgdGhpcyBhZnRlciBGaXJlZm94IHN1cHBvcnRzIG1pbnNpemUuXG4gICAgdXBwZXJOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb3ZlclwiLCBbbGFiZWwsIGR1bW15Tm9kZV0pO1xuICB9XG4gIGNvbnN0IGdvdExvd2VyID0gKGJlbG93ICYmIGJlbG93LmJvZHkgJiZcbiAgICAoYmVsb3cuYm9keS5ib2R5IHx8IGJlbG93LmJvZHkubGVuZ3RoID4gMCkpO1xuICBpZiAoZ290TG93ZXIpIHtcbiAgICBsZXQgbGFiZWwgPSAgYnVpbGRHcm91cCQxKGJlbG93LCBsYWJlbFN0eWxlKTtcbiAgICBsYWJlbCA9IHBhZGRlZE5vZGUobGFiZWwsIHNwYWNlLCBzcGFjZSk7XG4gICAgbG93ZXJOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdW5kZXJcIiwgW2xhYmVsLCBkdW1teU5vZGVdKTtcbiAgfVxuXG4gIGxldCBub2RlO1xuICBpZiAoIWdvdFVwcGVyICYmICFnb3RMb3dlcikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFthcnJvd05vZGUsIGVtcHR5TGFiZWxdKTtcbiAgfSBlbHNlIGlmIChnb3RVcHBlciAmJiBnb3RMb3dlcikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlcm92ZXJcIiwgW2Fycm93Tm9kZSwgbG93ZXJOb2RlLCB1cHBlck5vZGVdKTtcbiAgfSBlbHNlIGlmIChnb3RVcHBlcikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vdmVyXCIsIFthcnJvd05vZGUsIHVwcGVyTm9kZV0pO1xuICB9IGVsc2Uge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm11bmRlclwiLCBbYXJyb3dOb2RlLCBsb3dlck5vZGVdKTtcbiAgfVxuICBpZiAobWluV2lkdGggPT09IFwiMy4wXCIpIHsgbm9kZS5zdHlsZS5oZWlnaHQgPSBcIjFlbVwiOyB9IC8vIENEIGVudmlyb25tZW50XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwiYWNjZW50XCIsIFwiZmFsc2VcIik7IC8vIE5lY2Vzc2FyeSBmb3IgTVMgV29yZFxuICByZXR1cm4gbm9kZVxufTtcblxuLy8gU3RyZXRjaHkgYXJyb3dzIHdpdGggYW4gb3B0aW9uYWwgYXJndW1lbnRcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ4QXJyb3dcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFx4bGVmdGFycm93XCIsXG4gICAgXCJcXFxceHJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx4TGVmdGFycm93XCIsXG4gICAgXCJcXFxceFJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx4bGVmdHJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx4TGVmdHJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx4aG9va2xlZnRhcnJvd1wiLFxuICAgIFwiXFxcXHhob29rcmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXHhtYXBzdG9cIixcbiAgICBcIlxcXFx4cmlnaHRoYXJwb29uZG93blwiLFxuICAgIFwiXFxcXHhyaWdodGhhcnBvb251cFwiLFxuICAgIFwiXFxcXHhsZWZ0aGFycG9vbmRvd25cIixcbiAgICBcIlxcXFx4bGVmdGhhcnBvb251cFwiLFxuICAgIFwiXFxcXHhsb25nZXF1YWxcIixcbiAgICBcIlxcXFx4dHdvaGVhZHJpZ2h0YXJyb3dcIixcbiAgICBcIlxcXFx4dHdvaGVhZGxlZnRhcnJvd1wiLFxuICAgIC8vIFRoZSBuZXh0IDUgZnVuY3Rpb25zIGFyZSBoZXJlIG9ubHkgdG8gc3VwcG9ydCBtaGNoZW1cbiAgICBcIlxcXFx5aWVsZHNcIixcbiAgICBcIlxcXFx5aWVsZHNMZWZ0XCIsXG4gICAgXCJcXFxcbWVzb21lcmlzbVwiLFxuICAgIFwiXFxcXGxvbmdyaWdodGhhcnBvb251cFwiLFxuICAgIFwiXFxcXGxvbmdsZWZ0aGFycG9vbmRvd25cIixcbiAgICAvLyBUaGUgbmV4dCAzIGZ1bmN0aW9ucyBhcmUgaGVyZSBvbmx5IHRvIHN1cHBvcnQgdGhlIHtDRH0gZW52aXJvbm1lbnQuXG4gICAgXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiLFxuICAgIFwiXFxcXFxcXFxjZGxlZnRhcnJvd1wiLFxuICAgIFwiXFxcXFxcXFxjZGxvbmdlcXVhbFwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncywgb3B0QXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInhBcnJvd1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuYW1lOiBmdW5jTmFtZSxcbiAgICAgIGJvZHk6IGFyZ3NbMF0sXG4gICAgICBiZWxvdzogb3B0QXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgLy8gQnVpbGQgdGhlIGFycm93IGFuZCBpdHMgbGFiZWxzLlxuICAgIGNvbnN0IG5vZGUgPSBtdW5kZXJvdmVyTm9kZShncm91cC5uYW1lLCBncm91cC5ib2R5LCBncm91cC5iZWxvdywgc3R5bGUpO1xuICAgIC8vIENyZWF0ZSBvcGVyYXRvciBzcGFjaW5nIGZvciBhIHJlbGF0aW9uLlxuICAgIGNvbnN0IHJvdyA9IFtub2RlXTtcbiAgICByb3cudW5zaGlmdChwYWRkaW5nJDEoMC4yNzc4KSk7XG4gICAgcm93LnB1c2gocGFkZGluZyQxKDAuMjc3OCkpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgcm93KVxuICB9XG59KTtcblxuY29uc3QgYXJyb3dDb21wb25lbnQgPSB7XG4gIFwiXFxcXHh0b2Zyb21cIjogW1wiXFxcXHhyaWdodGFycm93XCIsIFwiXFxcXHhsZWZ0YXJyb3dcIl0sXG4gIFwiXFxcXHhsZWZ0cmlnaHRoYXJwb29uc1wiOiBbXCJcXFxceGxlZnRoYXJwb29udXBcIiwgXCJcXFxceHJpZ2h0aGFycG9vbmRvd25cIl0sXG4gIFwiXFxcXHhyaWdodGxlZnRoYXJwb29uc1wiOiBbXCJcXFxceHJpZ2h0aGFycG9vbnVwXCIsIFwiXFxcXHhsZWZ0aGFycG9vbmRvd25cIl0sXG4gIFwiXFxcXHlpZWxkc0xlZnRSaWdodFwiOiBbXCJcXFxceWllbGRzXCIsIFwiXFxcXHlpZWxkc0xlZnRcIl0sXG4gIC8vIFRoZSBuZXh0IHRocmVlIGFsbCBnZXQgdGhlIHNhbWUgaGFycG9vbiBnbHlwaHMuIE9ubHkgdGhlIGxlbmd0aHMgYW5kIHBhZGRpbmdzIGRpZmZlci5cbiAgXCJcXFxcZXF1aWxpYnJpdW1cIjogW1wiXFxcXGxvbmdyaWdodGhhcnBvb251cFwiLCBcIlxcXFxsb25nbGVmdGhhcnBvb25kb3duXCJdLFxuICBcIlxcXFxlcXVpbGlicml1bVJpZ2h0XCI6IFtcIlxcXFxsb25ncmlnaHRoYXJwb29udXBcIiwgXCJcXFxcZXFsZWZ0aGFycG9vbmRvd25cIl0sXG4gIFwiXFxcXGVxdWlsaWJyaXVtTGVmdFwiOiBbXCJcXFxcZXFyaWdodGhhcnBvb251cFwiLCBcIlxcXFxsb25nbGVmdGhhcnBvb25kb3duXCJdXG59O1xuXG4vLyBCcm93c2VycyBhcmUgbm90IGdvb2QgYXQgc3RyZXRjaGluZyBhIGdseXBoIHRoYXQgY29udGFpbnMgYSBwYWlyIG9mIHN0YWNrZWQgYXJyb3dzIHN1Y2ggYXMg4oeELlxuLy8gU28gd2Ugc3RhY2sgYSBwYWlyIG9mIHNpbmdsZSBhcnJvd3MuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwic3RhY2tlZEFycm93XCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxceHRvZnJvbVwiLCAgICAgICAgICAgICAgLy8gZXhwZmVpbFxuICAgIFwiXFxcXHhsZWZ0cmlnaHRoYXJwb29uc1wiLCAgIC8vIG1hdGh0b29sc1xuICAgIFwiXFxcXHhyaWdodGxlZnRoYXJwb29uc1wiLCAgIC8vIG1hdGh0b29sc1xuICAgIFwiXFxcXHlpZWxkc0xlZnRSaWdodFwiLCAgICAgIC8vIG1oY2hlbVxuICAgIFwiXFxcXGVxdWlsaWJyaXVtXCIsICAgICAgICAgIC8vIG1oY2hlbVxuICAgIFwiXFxcXGVxdWlsaWJyaXVtUmlnaHRcIixcbiAgICBcIlxcXFxlcXVpbGlicml1bUxlZnRcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBsb3dlckFycm93Qm9keSA9IGFyZ3NbMF1cbiAgICAgID8ge1xuICAgICAgICB0eXBlOiBcImhwaGFudG9tXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBib2R5OiBhcmdzWzBdXG4gICAgICB9XG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgdXBwZXJBcnJvd0JlbG93ID0gb3B0QXJnc1swXVxuICAgICAgPyB7XG4gICAgICAgIHR5cGU6IFwiaHBoYW50b21cIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGJvZHk6IG9wdEFyZ3NbMF1cbiAgICAgIH1cbiAgICAgIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdGFja2VkQXJyb3dcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbmFtZTogZnVuY05hbWUsXG4gICAgICBib2R5OiBhcmdzWzBdLFxuICAgICAgdXBwZXJBcnJvd0JlbG93LFxuICAgICAgbG93ZXJBcnJvd0JvZHksXG4gICAgICBiZWxvdzogb3B0QXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgdG9wTGFiZWwgPSBhcnJvd0NvbXBvbmVudFtncm91cC5uYW1lXVswXTtcbiAgICBjb25zdCBib3RMYWJlbCA9IGFycm93Q29tcG9uZW50W2dyb3VwLm5hbWVdWzFdO1xuICAgIGNvbnN0IHRvcEFycm93ID0gbXVuZGVyb3Zlck5vZGUodG9wTGFiZWwsIGdyb3VwLmJvZHksIGdyb3VwLnVwcGVyQXJyb3dCZWxvdywgc3R5bGUpO1xuICAgIGNvbnN0IGJvdEFycm93ID0gbXVuZGVyb3Zlck5vZGUoYm90TGFiZWwsIGdyb3VwLmxvd2VyQXJyb3dCb2R5LCBncm91cC5iZWxvdywgc3R5bGUpO1xuICAgIGxldCB3cmFwcGVyO1xuXG4gICAgY29uc3QgcmFpc2VOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFt0b3BBcnJvd10pO1xuICAgIHJhaXNlTm9kZS5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIFwiMC4zZW1cIik7XG4gICAgcmFpc2VOb2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIiswLjNlbVwiKTtcbiAgICByYWlzZU5vZGUuc2V0QXR0cmlidXRlKFwiZGVwdGhcIiwgXCItMC4zZW1cIik7XG4gICAgLy8gT25lIG9mIHRoZSBhcnJvd3MgaXMgZ2l2ZW4gfnplcm8gd2lkdGguIHNvIHRoZSBvdGhlciBoYXMgdGhlIHNhbWUgaG9yem9udGFsIGFsaWdubWVudC5cbiAgICBpZiAoZ3JvdXAubmFtZSA9PT0gXCJcXFxcZXF1aWxpYnJpdW1MZWZ0XCIpIHtcbiAgICAgIGNvbnN0IGJvdE5vZGUgPSAgbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtib3RBcnJvd10pO1xuICAgICAgYm90Tm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjAuNWVtXCIpO1xuICAgICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1wYWRkZWRcIixcbiAgICAgICAgW3BhZGRpbmckMSgwLjI3NzgpLCBib3ROb2RlLCByYWlzZU5vZGUsIHBhZGRpbmckMSgwLjI3NzgpXVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFpc2VOb2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIChncm91cC5uYW1lID09PSBcIlxcXFxlcXVpbGlicml1bVJpZ2h0XCIgPyBcIjAuNWVtXCIgOiBcIjBcIikpO1xuICAgICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1wYWRkZWRcIixcbiAgICAgICAgW3BhZGRpbmckMSgwLjI3NzgpLCByYWlzZU5vZGUsIGJvdEFycm93LCBwYWRkaW5nJDEoMC4yNzc4KV1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIFwiLTAuMThlbVwiKTtcbiAgICB3cmFwcGVyLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIi0wLjE4ZW1cIik7XG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIiswLjE4ZW1cIik7XG4gICAgcmV0dXJuIHdyYXBwZXJcbiAgfVxufSk7XG5cbi8qKlxuICogQWxsIHJlZ2lzdGVyZWQgZW52aXJvbm1lbnRzLlxuICogYGVudmlyb25tZW50cy5qc2AgZXhwb3J0cyB0aGlzIHNhbWUgZGljdGlvbmFyeSBhZ2FpbiBhbmQgbWFrZXMgaXQgcHVibGljLlxuICogYFBhcnNlci5qc2AgcmVxdWlyZXMgdGhpcyBkaWN0aW9uYXJ5IHZpYSBgZW52aXJvbm1lbnRzLmpzYC5cbiAqL1xuY29uc3QgX2Vudmlyb25tZW50cyA9IHt9O1xuXG5mdW5jdGlvbiBkZWZpbmVFbnZpcm9ubWVudCh7IHR5cGUsIG5hbWVzLCBwcm9wcywgaGFuZGxlciwgbWF0aG1sQnVpbGRlciB9KSB7XG4gIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBlbnZpcm9ubWVudHMuXG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgdHlwZSxcbiAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzIHx8IDAsXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2UsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAwLFxuICAgIGhhbmRsZXJcbiAgfTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgIF9lbnZpcm9ubWVudHNbbmFtZXNbaV1dID0gZGF0YTtcbiAgfVxuICBpZiAobWF0aG1sQnVpbGRlcikge1xuICAgIF9tYXRobWxHcm91cEJ1aWxkZXJzW3R5cGVdID0gbWF0aG1sQnVpbGRlcjtcbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgbm9kZSBpcyBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgcmV0dXJucyBpdCB3aXRoIHN0cmljdGVyXG4gKiB0eXBpbmcuIFRocm93cyBpZiB0aGUgbm9kZSdzIHR5cGUgZG9lcyBub3QgbWF0Y2guXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5vZGVUeXBlKG5vZGUsIHR5cGUpIHtcbiAgaWYgKCFub2RlIHx8IG5vZGUudHlwZSAhPT0gdHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBub2RlIG9mIHR5cGUgJHt0eXBlfSwgYnV0IGdvdCBgICtcbiAgICAgICAgKG5vZGUgPyBgbm9kZSBvZiB0eXBlICR7bm9kZS50eXBlfWAgOiBTdHJpbmcobm9kZSkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlIG1vcmUgc3RyaWN0bHkgdHlwZWQgaWZmIGl0IGlzIG9mIHRoZSBnaXZlbiB0eXBlLiBPdGhlcndpc2UsXG4gKiByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN5bWJvbE5vZGVUeXBlKG5vZGUpIHtcbiAgY29uc3QgdHlwZWROb2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShub2RlKTtcbiAgaWYgKCF0eXBlZE5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgbm9kZSBvZiBzeW1ib2wgZ3JvdXAgdHlwZSwgYnV0IGdvdCBgICtcbiAgICAgICAgKG5vZGUgPyBgbm9kZSBvZiB0eXBlICR7bm9kZS50eXBlfWAgOiBTdHJpbmcobm9kZSkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdHlwZWROb2RlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5vZGUgbW9yZSBzdHJpY3RseSB0eXBlZCBpZmYgaXQgaXMgb2YgdGhlIGdpdmVuIHR5cGUuIE90aGVyd2lzZSxcbiAqIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tTeW1ib2xOb2RlVHlwZShub2RlKSB7XG4gIGlmIChub2RlICYmIChub2RlLnR5cGUgPT09IFwiYXRvbVwiIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTk9OX0FUT01TLCBub2RlLnR5cGUpKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBjZEFycm93RnVuY3Rpb25OYW1lID0ge1xuICBcIj5cIjogXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiLFxuICBcIjxcIjogXCJcXFxcXFxcXGNkbGVmdGFycm93XCIsXG4gIFwiPVwiOiBcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIixcbiAgQTogXCJcXFxcdXBhcnJvd1wiLFxuICBWOiBcIlxcXFxkb3duYXJyb3dcIixcbiAgXCJ8XCI6IFwiXFxcXFZlcnRcIixcbiAgXCIuXCI6IFwibm8gYXJyb3dcIlxufTtcblxuY29uc3QgbmV3Q2VsbCA9ICgpID0+IHtcbiAgLy8gQ3JlYXRlIGFuIGVtcHR5IGNlbGwsIHRvIGJlIGZpbGxlZCBiZWxvdyB3aXRoIHBhcnNlIG5vZGVzLlxuICByZXR1cm4geyB0eXBlOiBcInN0eWxpbmdcIiwgYm9keTogW10sIG1vZGU6IFwibWF0aFwiLCBzY3JpcHRMZXZlbDogXCJkaXNwbGF5XCIgfTtcbn07XG5cbmNvbnN0IGlzU3RhcnRPZkFycm93ID0gKG5vZGUpID0+IHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ0ZXh0b3JkXCIgJiYgbm9kZS50ZXh0ID09PSBcIkBcIjtcbn07XG5cbmNvbnN0IGlzTGFiZWxFbmQgPSAobm9kZSwgZW5kQ2hhcikgPT4ge1xuICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJtYXRob3JkXCIgfHwgbm9kZS50eXBlID09PSBcImF0b21cIikgJiYgbm9kZS50ZXh0ID09PSBlbmRDaGFyO1xufTtcblxuZnVuY3Rpb24gY2RBcnJvdyhhcnJvd0NoYXIsIGxhYmVscywgcGFyc2VyKSB7XG4gIC8vIFJldHVybiBhIHBhcnNlIHRyZWUgb2YgYW4gYXJyb3cgYW5kIGl0cyBsYWJlbHMuXG4gIC8vIFRoaXMgYWN0cyBpbiBhIHdheSBzaW1pbGFyIHRvIGEgbWFjcm8gZXhwYW5zaW9uLlxuICBjb25zdCBmdW5jTmFtZSA9IGNkQXJyb3dGdW5jdGlvbk5hbWVbYXJyb3dDaGFyXTtcbiAgc3dpdGNoIChmdW5jTmFtZSkge1xuICAgIGNhc2UgXCJcXFxcXFxcXGNkcmlnaHRhcnJvd1wiOlxuICAgIGNhc2UgXCJcXFxcXFxcXGNkbGVmdGFycm93XCI6XG4gICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW2xhYmVsc1swXV0sIFtsYWJlbHNbMV1dKTtcbiAgICBjYXNlIFwiXFxcXHVwYXJyb3dcIjpcbiAgICBjYXNlIFwiXFxcXGRvd25hcnJvd1wiOiB7XG4gICAgICBjb25zdCBsZWZ0TGFiZWwgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKFwiXFxcXFxcXFxjZGxlZnRcIiwgW2xhYmVsc1swXV0sIFtdKTtcbiAgICAgIGNvbnN0IGJhcmVBcnJvdyA9IHtcbiAgICAgICAgdHlwZTogXCJhdG9tXCIsXG4gICAgICAgIHRleHQ6IGZ1bmNOYW1lLFxuICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgZmFtaWx5OiBcInJlbFwiXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2l6ZWRBcnJvdyA9IHBhcnNlci5jYWxsRnVuY3Rpb24oXCJcXFxcQmlnXCIsIFtiYXJlQXJyb3ddLCBbXSk7XG4gICAgICBjb25zdCByaWdodExhYmVsID0gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2RyaWdodFwiLCBbbGFiZWxzWzFdXSwgW10pO1xuICAgICAgY29uc3QgYXJyb3dHcm91cCA9IHtcbiAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICBtb2RlOiBcIm1hdGhcIixcbiAgICAgICAgYm9keTogW2xlZnRMYWJlbCwgc2l6ZWRBcnJvdywgcmlnaHRMYWJlbF0sXG4gICAgICAgIHNlbWlzaW1wbGU6IHRydWVcbiAgICAgIH07XG4gICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2RwYXJlbnRcIiwgW2Fycm93R3JvdXBdLCBbXSk7XG4gICAgfVxuICAgIGNhc2UgXCJcXFxcXFxcXGNkbG9uZ2VxdWFsXCI6XG4gICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxcXFxcY2Rsb25nZXF1YWxcIiwgW10sIFtdKTtcbiAgICBjYXNlIFwiXFxcXFZlcnRcIjoge1xuICAgICAgY29uc3QgYXJyb3cgPSB7IHR5cGU6IFwidGV4dG9yZFwiLCB0ZXh0OiBcIlxcXFxWZXJ0XCIsIG1vZGU6IFwibWF0aFwiIH07XG4gICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihcIlxcXFxCaWdcIiwgW2Fycm93XSwgW10pO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0b3JkXCIsIHRleHQ6IFwiIFwiLCBtb2RlOiBcIm1hdGhcIiB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0QocGFyc2VyKSB7XG4gIC8vIEdldCB0aGUgYXJyYXkncyBwYXJzZSBub2RlcyB3aXRoIFxcXFwgdGVtcG9yYXJpbHkgbWFwcGVkIHRvIFxcY3IuXG4gIGNvbnN0IHBhcnNlZFJvd3MgPSBbXTtcbiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7XG4gIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChcIlxcXFxjclwiLCBcIlxcXFxcXFxcXFxcXHJlbGF4XCIpO1xuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBHZXQgdGhlIHBhcnNlIG5vZGVzIGZvciB0aGUgbmV4dCByb3cuXG4gICAgcGFyc2VkUm93cy5wdXNoKHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIFwiXFxcXFxcXFxcIikpO1xuICAgIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICBjb25zdCBuZXh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDtcbiAgICBpZiAobmV4dCA9PT0gXCImXCIgfHwgbmV4dCA9PT0gXCJcXFxcXFxcXFwiKSB7XG4gICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcZW5kXCIpIHtcbiAgICAgIGlmIChwYXJzZWRSb3dzW3BhcnNlZFJvd3MubGVuZ3RoIC0gMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHBhcnNlZFJvd3MucG9wKCk7IC8vIGZpbmFsIHJvdyBlbmRlZCBpbiBcXFxcXG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBcXFxcXFxcXCBvciBcXFxcY3Igb3IgXFxcXGVuZFwiLCBwYXJzZXIubmV4dFRva2VuKTtcbiAgICB9XG4gIH1cblxuICBsZXQgcm93ID0gW107XG4gIGNvbnN0IGJvZHkgPSBbcm93XTtcblxuICAvLyBMb29wIHRocnUgdGhlIHBhcnNlIG5vZGVzLiBDb2xsZWN0IHRoZW0gaW50byBjZWxscyBhbmQgYXJyb3dzLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZFJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBTdGFydCBhIG5ldyByb3cuXG4gICAgY29uc3Qgcm93Tm9kZXMgPSBwYXJzZWRSb3dzW2ldO1xuICAgIC8vIENyZWF0ZSB0aGUgZmlyc3QgY2VsbC5cbiAgICBsZXQgY2VsbCA9IG5ld0NlbGwoKTtcblxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93Tm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICghaXNTdGFydE9mQXJyb3cocm93Tm9kZXNbal0pKSB7XG4gICAgICAgIC8vIElmIGEgcGFyc2VOb2RlIGlzIG5vdCBhbiBhcnJvdywgaXQgZ29lcyBpbnRvIGEgY2VsbC5cbiAgICAgICAgY2VsbC5ib2R5LnB1c2gocm93Tm9kZXNbal0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUGFyc2Ugbm9kZSBqIGlzIGFuIFwiQFwiLCB0aGUgc3RhcnQgb2YgYW4gYXJyb3cuXG4gICAgICAgIC8vIEJlZm9yZSBzdGFydGluZyBvbiB0aGUgYXJyb3csIHB1c2ggdGhlIGNlbGwgaW50byBgcm93YC5cbiAgICAgICAgcm93LnB1c2goY2VsbCk7XG5cbiAgICAgICAgLy8gTm93IGNvbGxlY3QgcGFyc2VOb2RlcyBpbnRvIGFuIGFycm93LlxuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGFmdGVyIFwiQFwiIGRlZmluZXMgdGhlIGFycm93IHR5cGUuXG4gICAgICAgIGogKz0gMTtcbiAgICAgICAgY29uc3QgYXJyb3dDaGFyID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUocm93Tm9kZXNbal0pLnRleHQ7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHR3byBlbXB0eSBsYWJlbCBub2Rlcy4gV2UgbWF5IG9yIG1heSBub3QgdXNlIHRoZW0uXG4gICAgICAgIGNvbnN0IGxhYmVscyA9IG5ldyBBcnJheSgyKTtcbiAgICAgICAgbGFiZWxzWzBdID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IFwibWF0aFwiLCBib2R5OiBbXSB9O1xuICAgICAgICBsYWJlbHNbMV0gPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogXCJtYXRoXCIsIGJvZHk6IFtdIH07XG5cbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYXJyb3cuXG4gICAgICAgIGlmIChcIj18LlwiLmluZGV4T2YoYXJyb3dDaGFyKSA+IC0xKSA7IGVsc2UgaWYgKFwiPD5BVlwiLmluZGV4T2YoYXJyb3dDaGFyKSA+IC0xKSB7XG4gICAgICAgICAgLy8gRm91ciBhcnJvd3MsIGBAPj4+YCwgYEA8PDxgLCBgQEFBQWAsIGFuZCBgQFZWVmAsIGVhY2ggdGFrZVxuICAgICAgICAgIC8vIHR3byBvcHRpb25hbCBsYWJlbHMuIEUuZy4gdGhlIHJpZ2h0LXBvaW50IGFycm93IHN5bnRheCBpc1xuICAgICAgICAgIC8vIHJlYWxseTogIEA+e29wdGlvbmFsIGxhYmVsfT57b3B0aW9uYWwgbGFiZWx9PlxuICAgICAgICAgIC8vIENvbGxlY3QgcGFyc2VOb2RlcyBpbnRvIGxhYmVscy5cbiAgICAgICAgICBmb3IgKGxldCBsYWJlbE51bSA9IDA7IGxhYmVsTnVtIDwgMjsgbGFiZWxOdW0rKykge1xuICAgICAgICAgICAgbGV0IGluTGFiZWwgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgayA9IGogKyAxOyBrIDwgcm93Tm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgaWYgKGlzTGFiZWxFbmQocm93Tm9kZXNba10sIGFycm93Q2hhcikpIHtcbiAgICAgICAgICAgICAgICBpbkxhYmVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaiA9IGs7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzU3RhcnRPZkFycm93KHJvd05vZGVzW2tdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJNaXNzaW5nIGEgXCIgKyBhcnJvd0NoYXIgKyBcIiBjaGFyYWN0ZXIgdG8gY29tcGxldGUgYSBDRCBhcnJvdy5cIixcbiAgICAgICAgICAgICAgICAgIHJvd05vZGVzW2tdXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxhYmVsc1tsYWJlbE51bV0uYm9keS5wdXNoKHJvd05vZGVzW2tdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbkxhYmVsKSB7XG4gICAgICAgICAgICAgIC8vIGlzTGFiZWxFbmQgbmV2ZXIgcmV0dXJuZWQgYSB0cnVlLlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIk1pc3NpbmcgYSBcIiArIGFycm93Q2hhciArIFwiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LlwiLFxuICAgICAgICAgICAgICAgIHJvd05vZGVzW2pdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBFeHBlY3RlZCBvbmUgb2YgXCI8PkFWPXwuXCIgYWZ0ZXIgQC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBqb2luIHRoZSBhcnJvdyB0byBpdHMgbGFiZWxzLlxuICAgICAgICBjb25zdCBhcnJvdyA9IGNkQXJyb3coYXJyb3dDaGFyLCBsYWJlbHMsIHBhcnNlcik7XG5cbiAgICAgICAgLy8gV3JhcCB0aGUgYXJyb3cgaW4gYSBzdHlsaW5nIG5vZGVcbiAgICAgICAgcm93LnB1c2goYXJyb3cpO1xuICAgICAgICAvLyBJbiBDRCdzIHN5bnRheCwgY2VsbHMgYXJlIGltcGxpY2l0LiBUaGF0IGlzLCBldmVyeXRoaW5nIHRoYXRcbiAgICAgICAgLy8gaXMgbm90IGFuIGFycm93IGdldHMgY29sbGVjdGVkIGludG8gYSBjZWxsLiBTbyBjcmVhdGUgYW4gZW1wdHlcbiAgICAgICAgLy8gY2VsbCBub3cuIEl0IHdpbGwgY29sbGVjdCB1cGNvbWluZyBwYXJzZU5vZGVzLlxuICAgICAgICBjZWxsID0gbmV3Q2VsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSAlIDIgPT09IDApIHtcbiAgICAgIC8vIEV2ZW4tbnVtYmVyZWQgcm93cyBjb25zaXN0IG9mOiBjZWxsLCBhcnJvdywgY2VsbCwgYXJyb3csIC4uLiBjZWxsXG4gICAgICAvLyBUaGUgbGFzdCBjZWxsIGlzIG5vdCB5ZXQgcHVzaGVkIGludG8gYHJvd2AsIHNvOlxuICAgICAgcm93LnB1c2goY2VsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9kZC1udW1iZXJlZCByb3dzIGNvbnNpc3Qgb2Y6IHZlcnQgYXJyb3csIGVtcHR5IGNlbGwsIC4uLiB2ZXJ0IGFycm93XG4gICAgICAvLyBSZW1vdmUgdGhlIGVtcHR5IGNlbGwgdGhhdCB3YXMgcGxhY2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgYHJvd2AuXG4gICAgICByb3cuc2hpZnQoKTtcbiAgICB9XG4gICAgcm93ID0gW107XG4gICAgYm9keS5wdXNoKHJvdyk7XG4gIH1cbiAgYm9keS5wb3AoKTtcblxuICAvLyBFbmQgcm93IGdyb3VwXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcbiAgLy8gRW5kIGFycmF5IGdyb3VwIGRlZmluaW5nIFxcXFxcbiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGJvZHksXG4gICAgdGFnczogbnVsbCxcbiAgICBsYWJlbHM6IG5ldyBBcnJheShib2R5Lmxlbmd0aCArIDEpLmZpbGwoXCJcIiksXG4gICAgZW52Q2xhc3NlczogW1wiam90XCIsIFwiY2RcIl0sXG4gICAgY29sczogW10sXG4gICAgaExpbmVzQmVmb3JlUm93OiBuZXcgQXJyYXkoYm9keS5sZW5ndGggKyAxKS5maWxsKFtdKVxuICB9O1xufVxuXG4vLyBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBub3QgYXZhaWxhYmxlIGZvciBnZW5lcmFsIHVzZS5cbi8vIFRoZXkgYXJlIGhlcmUgb25seSBmb3IgaW50ZXJuYWwgdXNlIGJ5IHRoZSB7Q0R9IGVudmlyb25tZW50IGluIHBsYWNpbmcgbGFiZWxzXG4vLyBuZXh0IHRvIHZlcnRpY2FsIGFycm93cy5cblxuLy8gV2UgZG9uJ3QgbmVlZCBhbnkgc3VjaCBmdW5jdGlvbnMgZm9yIGhvcml6b250YWwgYXJyb3dzIGJlY2F1c2Ugd2UgY2FuIHJldXNlXG4vLyB0aGUgZnVuY3Rpb25hbGl0eSB0aGF0IGFscmVhZHkgZXhpc3RzIGZvciBleHRlbnNpYmxlIGFycm93cy5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNkbGFiZWxcIixcbiAgbmFtZXM6IFtcIlxcXFxcXFxcY2RsZWZ0XCIsIFwiXFxcXFxcXFxjZHJpZ2h0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImNkbGFiZWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc2lkZTogZnVuY05hbWUuc2xpY2UoNCksXG4gICAgICBsYWJlbDogYXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgaWYgKGdyb3VwLmxhYmVsLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIHN0eWxlKSAgLy8gZW1wdHkgbGFiZWxcbiAgICB9XG4gICAgLy8gQWJ1c2UgYW4gPG10YWJsZT4gdG8gY3JlYXRlIHZlcnRpY2FsbHkgY2VudGVyZWQgY29udGVudC5cbiAgICBjb25zdCBtdGQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZFwiLCBbYnVpbGRHcm91cCQxKGdyb3VwLmxhYmVsLCBzdHlsZSldKTtcbiAgICBtdGQuc3R5bGUucGFkZGluZyA9IFwiMFwiO1xuICAgIGNvbnN0IG10ciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRyXCIsIFttdGRdKTtcbiAgICBjb25zdCBtdGFibGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10YWJsZVwiLCBbbXRyXSk7XG4gICAgY29uc3QgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW210YWJsZV0pO1xuICAgIC8vIFNldCB0aGUgbGFiZWwgd2lkdGggdG8gemVybyBzbyB0aGF0IHRoZSBhcnJvdyB3aWxsIGJlIGNlbnRlcmVkIHVuZGVyIHRoZSBjb3JuZXIgY2VsbC5cbiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBcIik7XG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIFwiZmFsc2VcIik7XG4gICAgbGFiZWwuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIxXCIpO1xuICAgIGlmIChncm91cC5zaWRlID09PSBcImxlZnRcIikge1xuICAgICAgbGFiZWwuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgbGFiZWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcImZsZXgtZW5kXCI7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbDtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjZGxhYmVscGFyZW50XCIsXG4gIG5hbWVzOiBbXCJcXFxcXFxcXGNkcGFyZW50XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY2RsYWJlbHBhcmVudFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmcmFnbWVudDogYXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbYnVpbGRHcm91cCQxKGdyb3VwLmZyYWdtZW50LCBzdHlsZSldKTtcbiAgfVxufSk7XG5cbmNvbnN0IG9yZEdyb3VwID0gKGJvZHkpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBcInR5cGVcIjogXCJvcmRncm91cFwiLFxuICAgIFwibW9kZVwiOiBcIm1hdGhcIixcbiAgICBcImJvZHlcIjogYm9keSxcbiAgICBcInNlbWlzaW1wbGVcIjogdHJ1ZVxuICB9XG59O1xuXG5jb25zdCBwaGFudG9tID0gKGJvZHksIHR5cGUpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBcInR5cGVcIjogdHlwZSxcbiAgICBcIm1vZGVcIjogXCJtYXRoXCIsXG4gICAgXCJib2R5XCI6IG9yZEdyb3VwKGJvZHkpXG4gIH1cbn07XG5cbi8qXG4gKiBBIGhlbHBlciBmb3IgXFxib3JkZXJtYXRyaXguXG4gKiBwYXJzZUFycmF5KCkgaGFzIHBhcnNlZCB0aGUgdG9rZW5zIGFzIGlmIHRoZSBlbnZpcm9ubWVudFxuICogd2FzIFxcYmVnaW57bWF0cml4fS4gVGhhdCBwYXJzZSB0cmVlIGlzIHRoaXMgZnVuY3Rpb27igJlzIGlucHV0LlxuICogSGVyZSwgd2UgcmVhcnJhbmdlIHRoZSBwYXJzZSB0cmVlIHRvIGdldCBvbmUgdGhhdCB3aWxsXG4gKiByZXN1bHQgaW4gVGVYIFxcYm9yZGVybWF0cml4LlxuICogVGhlIGZpbmFsIHJlc3VsdCBpbmNsdWRlcyBhIHtwbWF0cml4fSwgd2hpY2ggaXMgdGhlIGJvdHRvbVxuICogaGFsZiBvZiBhIDxtb3Zlcj4gZWxlbWVudC4gVGhlIHRvcCBvZiB0aGUgPG1vdmVyPiBjb250YWluc1xuICogdGhlIFxcYm9yZGVybWF0cml4IGhlYWRpbmdzLiBUaGUgdG9wIHNlY3Rpb24gYWxzbyBjb250YWlucyB0aGVcbiAqIGNvbnRlbnRzIG9mIHRoZSBib3R0b20ge3BtYXRyaXh9LiBUaG9zZSBlbGVtZW50cyBhcmUgaGlkZGVuIHZpYVxuICogXFxocGhhbnRvbSwgYnV0IHRoZXkgZW5zdXJlIHRoYXQgY29sdW1uIHdpZHRocyBhcmUgdGhlIHNhbWUgdG9wIGFuZFxuICogYm90dG9tLlxuICpcbiAqIFdlIGFsc28gY3JlYXRlIGEgbGVmdCB7bWF0cml4fSB3aXRoIGEgc2luZ2xlIGNvbHVtbiB0aGF0IGNvbnRhaW5zXG4gKiBlbGVtZW50cyBzaGlmdGVkIG91dCBvZiB0aGUgbWF0cml4LiBUaGUgbGVmdCB7bWF0cml4fSBhbHNvXG4gKiBjb250YWlucyBcXHZwaGFudG9tIGNvcGllcyBvZiB0aGUgb3RoZXIge3BtYXRyaXh9IGVsZW1lbnRzLlxuICogQXMgYmVmb3JlLCB0aGlzIGVuc3VyZXMgY29uc2lzdGVudCByb3cgaGVpZ2h0cyBvZiBsZWZ0IGFuZCBtYWluLlxuICovXG5cbmNvbnN0IGJvcmRlcm1hdHJpeFBhcnNlVHJlZSA9IChtYXRyaXgsIGRlbGltaXRlcnMpID0+IHtcbiAgY29uc3QgYm9keSA9IG1hdHJpeC5ib2R5O1xuICBib2R5WzBdLnNoaWZ0KCk7IC8vIGRpc3Bvc2Ugb2YgdG9wIGxlZnQgY2VsbFxuXG4gIC8vIENyZWF0ZSBhbiBhcnJheSBmb3IgdGhlIGxlZnQgY29sdW1uXG4gIGNvbnN0IGxlZnRDb2x1bW5Cb2R5ID0gbmV3IEFycmF5KGJvZHkubGVuZ3RoIC0gMSkuZmlsbCgpLm1hcCgoKSA9PiBbXSk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlIGNlbGxcbiAgICBsZWZ0Q29sdW1uQm9keVtpIC0gMV0ucHVzaChib2R5W2ldLnNoaWZ0KCkpO1xuICAgIC8vIEEgdnBoYW50b20gd2l0aCBjb250ZW50cyBmcm9tIHRoZSBwbWF0cml4LCB0byBzZXQgbWluaW11bSBjZWxsIGhlaWdodFxuICAgIGNvbnN0IHBoYW50b21Cb2R5ID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBib2R5W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICBwaGFudG9tQm9keS5wdXNoKHN0cnVjdHVyZWRDbG9uZShib2R5W2ldW2pdKSk7XG4gICAgfVxuICAgIGxlZnRDb2x1bW5Cb2R5W2kgLSAxXS5wdXNoKHBoYW50b20ocGhhbnRvbUJvZHksIFwidnBoYW50b21cIikpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIGFuIGFycmF5IGZvciB0aGUgdG9wIHJvd1xuICBjb25zdCB0b3BSb3dCb2R5ID0gbmV3IEFycmF5KGJvZHkubGVuZ3RoKS5maWxsKCkubWFwKCgpID0+IFtdKTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBib2R5WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgdG9wUm93Qm9keVswXS5wdXNoKHN0cnVjdHVyZWRDbG9uZShib2R5WzBdW2pdKSk7XG4gIH1cbiAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgcG1hdHJpeCwgYnV0IHNxdWFzaGVkIHZpYSBcXGhwaGFudG9tXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgYm9keVswXS5sZW5ndGg7IGorKykge1xuICAgICAgdG9wUm93Qm9keVtpXS5wdXNoKHBoYW50b20oc3RydWN0dXJlZENsb25lKGJvZHlbaV1bal0pLmJvZHksIFwiaHBoYW50b21cIikpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNxdWFzaCB0aGUgdG9wIHJvdyBvZiB0aGUgbWFpbiB7cG1hdHJpeH1cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBib2R5WzBdLmxlbmd0aDsgaisrKSB7XG4gICAgYm9keVswXVtqXSA9IHBoYW50b20oc3RydWN0dXJlZENsb25lKGJvZHlbMF1bal0pLmJvZHksIFwiaHBoYW50b21cIik7XG4gIH1cblxuICAvLyBOb3cgd3JhcCB0aGUgYXJyYXlzIGluIHRoZSBwcm9wZXIgcGFyc2Ugbm9kZXMuXG5cbiAgY29uc3QgbGVmdENvbHVtbiA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbW9kZTogXCJtYXRoXCIsXG4gICAgYm9keTogbGVmdENvbHVtbkJvZHksXG4gICAgY29sczogW3sgdHlwZTogXCJhbGlnblwiLCBhbGlnbjogXCJjXCIgfV0sXG4gICAgcm93R2FwczogbmV3IEFycmF5KGxlZnRDb2x1bW5Cb2R5Lmxlbmd0aCAtIDEpLmZpbGwobnVsbCksXG4gICAgaExpbmVzQmVmb3JlUm93OiBuZXcgQXJyYXkobGVmdENvbHVtbkJvZHkubGVuZ3RoICsgMSkuZmlsbCgpLm1hcCgoKSA9PiBbXSksXG4gICAgZW52Q2xhc3NlczogW10sXG4gICAgc2NyaXB0TGV2ZWw6IFwidGV4dFwiLFxuICAgIGFycmF5c3RyZXRjaDogMSxcbiAgICBsYWJlbHM6IG5ldyBBcnJheShsZWZ0Q29sdW1uQm9keS5sZW5ndGgpLmZpbGwoXCJcIiksXG4gICAgYXJyYXljb2xzZXA6IHsgXCJudW1iZXJcIjogMC4wNCwgdW5pdDogXCJlbVwiIH1cbiAgfTtcblxuICBjb25zdCB0b3BSb3cgPSB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGJvZHk6IHRvcFJvd0JvZHksXG4gICAgY29sczogbmV3IEFycmF5KHRvcFJvd0JvZHkubGVuZ3RoKS5maWxsKHsgdHlwZTogXCJhbGlnblwiLCBhbGlnbjogXCJjXCIgfSksXG4gICAgcm93R2FwczogbmV3IEFycmF5KHRvcFJvd0JvZHkubGVuZ3RoIC0gMSkuZmlsbChudWxsKSxcbiAgICBoTGluZXNCZWZvcmVSb3c6IG5ldyBBcnJheSh0b3BSb3dCb2R5Lmxlbmd0aCArIDEpLmZpbGwoKS5tYXAoKCkgPT4gW10pLFxuICAgIGVudkNsYXNzZXM6IFtdLFxuICAgIHNjcmlwdExldmVsOiBcInRleHRcIixcbiAgICBhcnJheXN0cmV0Y2g6IDEsXG4gICAgbGFiZWxzOiBuZXcgQXJyYXkodG9wUm93Qm9keS5sZW5ndGgpLmZpbGwoXCJcIiksXG4gICAgYXJyYXljb2xzZXA6IG51bGxcbiAgfTtcblxuICBjb25zdCB0b3BXcmFwcGVyID0ge1xuICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIHNjcmlwdExldmVsOiBcInRleHRcIiwgLy8gTXVzdCBzZXQgdGhpcyBleHBsaWNpdGx5LlxuICAgIGJvZHk6IFt0b3BSb3ddICAgICAgIC8vIERlZmF1bHQgbGV2ZWwgaXMgXCJzY3JpcHRcIi5cbiAgfTtcblxuICBjb25zdCBjb250YWluZXIgPSB7XG4gICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICBtb2RlOiBcIm1hdGhcIixcbiAgICBib2R5OiBbbWF0cml4XSxcbiAgICBsZWZ0OiBkZWxpbWl0ZXJzID8gZGVsaW1pdGVyc1swXSA6IFwiKFwiLFxuICAgIHJpZ2h0OiBkZWxpbWl0ZXJzID8gZGVsaW1pdGVyc1sxXSA6IFwiKVwiLFxuICAgIHJpZ2h0Q29sb3I6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGNvbnN0IGJhc2UgPSB7XG4gICAgdHlwZTogXCJvcFwiLCAgIC8vIFRoZSBiYXNlIG9mIGEgVGVYIFxcb3ZlcnNldFxuICAgIG1vZGU6IFwibWF0aFwiLFxuICAgIGxpbWl0czogdHJ1ZSxcbiAgICBhbHdheXNIYW5kbGVTdXBTdWI6IHRydWUsXG4gICAgcGFyZW50SXNTdXBTdWI6IHRydWUsXG4gICAgc3ltYm9sOiBmYWxzZSxcbiAgICBzdGFjazogdHJ1ZSxcbiAgICBzdXBwcmVzc0Jhc2VTaGlmdDogdHJ1ZSxcbiAgICBib2R5OiBbY29udGFpbmVyXVxuICB9O1xuXG4gIGNvbnN0IG1vdmVyID0ge1xuICAgIHR5cGU6IFwic3Vwc3ViXCIsICAvLyBXZSdyZSB1c2luZyB0aGUgTWF0aE1MIGVxdWl2YWxlbnRcbiAgICBtb2RlOiBcIm1hdGhcIiwgICAgLy8gb2YgVGVYIFxcb3ZlcnNldC5cbiAgICBiYXNlOiBiYXNlLCAgICAgIC8vIFRoYXQga2VlcHMgdGhlIHtwbWF0cml4fSBhbGlnbmVkIHdpdGhcbiAgICBzdXA6IHRvcFdyYXBwZXIsIC8vIHRoZSBtYXRoIGNlbnRlcmxpbmUuXG4gICAgc3ViOiBudWxsXG4gIH07XG5cbiAgcmV0dXJuIG9yZEdyb3VwKFtsZWZ0Q29sdW1uLCBtb3Zlcl0pXG59O1xuXG4vKipcbiAqIExleGluZyBvciBwYXJzaW5nIHBvc2l0aW9uYWwgaW5mb3JtYXRpb24gZm9yIGVycm9yIHJlcG9ydGluZy5cbiAqIFRoaXMgb2JqZWN0IGlzIGltbXV0YWJsZS5cbiAqL1xuY2xhc3MgU291cmNlTG9jYXRpb24ge1xuICBjb25zdHJ1Y3RvcihsZXhlciwgc3RhcnQsIGVuZCkge1xuICAgIHRoaXMubGV4ZXIgPSBsZXhlcjsgLy8gTGV4ZXIgaG9sZGluZyB0aGUgaW5wdXQgc3RyaW5nLlxuICAgIHRoaXMuc3RhcnQgPSBzdGFydDsgLy8gU3RhcnQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGluY2x1c2l2ZS5cbiAgICB0aGlzLmVuZCA9IGVuZDsgICAgIC8vIEVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlLlxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlcyB0d28gYFNvdXJjZUxvY2F0aW9uYHMgZnJvbSBsb2NhdGlvbiBwcm92aWRlcnMsIGdpdmVuIHRoZXkgYXJlXG4gICAqIHByb3ZpZGVkIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gICAqIC0gUmV0dXJucyB0aGUgZmlyc3Qgb25lJ3MgbG9jYXRpb24gaWYgb25seSB0aGUgZmlyc3QgaXMgcHJvdmlkZWQuXG4gICAqIC0gUmV0dXJucyBhIG1lcmdlZCByYW5nZSBvZiB0aGUgZmlyc3QgYW5kIHRoZSBsYXN0IGlmIGJvdGggYXJlIHByb3ZpZGVkXG4gICAqICAgYW5kIHRoZWlyIGxleGVycyBtYXRjaC5cbiAgICogLSBPdGhlcndpc2UsIHJldHVybnMgbnVsbC5cbiAgICovXG4gIHN0YXRpYyByYW5nZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgaWYgKCFzZWNvbmQpIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5sb2M7XG4gICAgfSBlbHNlIGlmICghZmlyc3QgfHwgIWZpcnN0LmxvYyB8fCAhc2Vjb25kLmxvYyB8fCBmaXJzdC5sb2MubGV4ZXIgIT09IHNlY29uZC5sb2MubGV4ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFNvdXJjZUxvY2F0aW9uKGZpcnN0LmxvYy5sZXhlciwgZmlyc3QubG9jLnN0YXJ0LCBzZWNvbmQubG9jLmVuZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIHJlcXVpcmVkIHRvIGJyZWFrIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBUb2tlbiwgTGV4ZXIsIGFuZFxuICogUGFyc2VFcnJvci5cbiAqL1xuXG4vKipcbiAqIFRoZSByZXN1bHRpbmcgdG9rZW4gcmV0dXJuZWQgZnJvbSBgbGV4YC5cbiAqXG4gKiBJdCBjb25zaXN0cyBvZiB0aGUgdG9rZW4gdGV4dCBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uXG4gKiBUaGUgcG9zaXRpb24gaW5mb3JtYXRpb24gaXMgZXNzZW50aWFsbHkgYSByYW5nZSBpbiBhbiBpbnB1dCBzdHJpbmcsXG4gKiBidXQgaW5zdGVhZCBvZiByZWZlcmVuY2luZyB0aGUgYmFyZSBpbnB1dCBzdHJpbmcsIHdlIHJlZmVyIHRvIHRoZSBsZXhlci5cbiAqIFRoYXQgd2F5IGl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBleHRyYSBtZXRhZGF0YSB0byB0aGUgaW5wdXQgc3RyaW5nLFxuICogbGlrZSBmb3IgZXhhbXBsZSBhIGZpbGUgbmFtZSBvciBzaW1pbGFyLlxuICpcbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBvcHRpb25hbCwgc28gaXQgaXMgT0sgdG8gY29uc3RydWN0IHN5bnRoZXRpY1xuICogdG9rZW5zIGlmIGFwcHJvcHJpYXRlLiBOb3QgcHJvdmlkaW5nIGF2YWlsYWJsZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBtYXlcbiAqIGxlYWQgdG8gZGVncmFkZWQgZXJyb3IgcmVwb3J0aW5nLCB0aG91Z2guXG4gKi9cbmNsYXNzIFRva2VuIHtcbiAgY29uc3RydWN0b3IoXG4gICAgdGV4dCwgLy8gdGhlIHRleHQgb2YgdGhpcyB0b2tlblxuICAgIGxvY1xuICApIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMubG9jID0gbG9jO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgcGFpciBvZiB0b2tlbnMgKHRoaXMgYW5kIGVuZFRva2VuKSwgY29tcHV0ZSBhIGBUb2tlbmAgZW5jb21wYXNzaW5nXG4gICAqIHRoZSB3aG9sZSBpbnB1dCByYW5nZSBlbmNsb3NlZCBieSB0aGVzZSB0d28uXG4gICAqL1xuICByYW5nZShcbiAgICBlbmRUb2tlbiwgLy8gbGFzdCB0b2tlbiBvZiB0aGUgcmFuZ2UsIGluY2x1c2l2ZVxuICAgIHRleHQgLy8gdGhlIHRleHQgb2YgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHRva2VuXG4gICkge1xuICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCwgU291cmNlTG9jYXRpb24ucmFuZ2UodGhpcywgZW5kVG9rZW4pKTtcbiAgfVxufVxuXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlLiAgVGhlc2UgYXJlXG4vLyBwcm92aWRlZCBpbiB0aGUgdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG5cbi8vIE1hdGggc3R5bGUgaXMgbm90IHF1aXRlIHRoZSBzYW1lIHRoaW5nIGFzIHNjcmlwdCBsZXZlbC5cbmNvbnN0IFN0eWxlTGV2ZWwgPSB7XG4gIERJU1BMQVk6IDAsXG4gIFRFWFQ6IDEsXG4gIFNDUklQVDogMixcbiAgU0NSSVBUU0NSSVBUOiAzXG59O1xuXG4vKipcbiAqIEFsbCByZWdpc3RlcmVkIGdsb2JhbC9idWlsdC1pbiBtYWNyb3MuXG4gKiBgbWFjcm9zLmpzYCBleHBvcnRzIHRoaXMgc2FtZSBkaWN0aW9uYXJ5IGFnYWluIGFuZCBtYWtlcyBpdCBwdWJsaWMuXG4gKiBgUGFyc2VyLmpzYCByZXF1aXJlcyB0aGlzIGRpY3Rpb25hcnkgdmlhIGBtYWNyb3MuanNgLlxuICovXG5jb25zdCBfbWFjcm9zID0ge307XG5cbi8vIFRoaXMgZnVuY3Rpb24gbWlnaHQgb25lIGRheSBhY2NlcHQgYW4gYWRkaXRpb25hbCBhcmd1bWVudCBhbmQgZG8gbW9yZSB0aGluZ3MuXG5mdW5jdGlvbiBkZWZpbmVNYWNybyhuYW1lLCBib2R5KSB7XG4gIF9tYWNyb3NbbmFtZV0gPSBib2R5O1xufVxuXG4vKipcbiAqIFByZWRlZmluZWQgbWFjcm9zIGZvciBUZW1tbC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGVmaW5lIHNvbWUgY29tbWFuZHMgaW4gdGVybXMgb2Ygb3RoZXJzLlxuICovXG5cbmNvbnN0IG1hY3JvcyA9IF9tYWNyb3M7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIG1hY3JvIHRvb2xzXG5cbmRlZmluZU1hY3JvKFwiXFxcXG5vZXhwYW5kXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgLy8gVGhlIGV4cGFuc2lvbiBpcyB0aGUgdG9rZW4gaXRzZWxmOyBidXQgdGhhdCB0b2tlbiBpcyBpbnRlcnByZXRlZFxuICAvLyBhcyBpZiBpdHMgbWVhbmluZyB3ZXJlIOKAmFxccmVsYXjigJkgaWYgaXQgaXMgYSBjb250cm9sIHNlcXVlbmNlIHRoYXRcbiAgLy8gd291bGQgb3JkaW5hcmlseSBiZSBleHBhbmRlZCBieSBUZVjigJlzIGV4cGFuc2lvbiBydWxlcy5cbiAgY29uc3QgdCA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgaWYgKGNvbnRleHQuaXNFeHBhbmRhYmxlKHQudGV4dCkpIHtcbiAgICB0Lm5vZXhwYW5kID0gdHJ1ZTtcbiAgICB0LnRyZWF0QXNSZWxheCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHsgdG9rZW5zOiBbdF0sIG51bUFyZ3M6IDAgfTtcbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxleHBhbmRhZnRlclwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIC8vIFRlWCBmaXJzdCByZWFkcyB0aGUgdG9rZW4gdGhhdCBjb21lcyBpbW1lZGlhdGVseSBhZnRlciBcXGV4cGFuZGFmdGVyLFxuICAvLyB3aXRob3V0IGV4cGFuZGluZyBpdDsgbGV04oCZcyBjYWxsIHRoaXMgdG9rZW4gdC4gVGhlbiBUZVggcmVhZHMgdGhlXG4gIC8vIHRva2VuIHRoYXQgY29tZXMgYWZ0ZXIgdCAoYW5kIHBvc3NpYmx5IG1vcmUgdG9rZW5zLCBpZiB0aGF0IHRva2VuXG4gIC8vIGhhcyBhbiBhcmd1bWVudCksIHJlcGxhY2luZyBpdCBieSBpdHMgZXhwYW5zaW9uLiBGaW5hbGx5IFRlWCBwdXRzXG4gIC8vIHQgYmFjayBpbiBmcm9udCBvZiB0aGF0IGV4cGFuc2lvbi5cbiAgY29uc3QgdCA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgY29udGV4dC5leHBhbmRPbmNlKHRydWUpOyAvLyBleHBhbmQgb25seSBhbiBleHBhbmRhYmxlIHRva2VuXG4gIHJldHVybiB7IHRva2VuczogW3RdLCBudW1BcmdzOiAwIH07XG59KTtcblxuLy8gTGFUZVgncyBcXEBmaXJzdG9mdHdveyMxfXsjMn0gZXhwYW5kcyB0byAjMSwgc2tpcHBpbmcgIzJcbi8vIFRlWCBzb3VyY2U6IFxcbG9uZ1xcZGVmXFxAZmlyc3RvZnR3byMxIzJ7IzF9XG5kZWZpbmVNYWNybyhcIlxcXFxAZmlyc3RvZnR3b1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICByZXR1cm4geyB0b2tlbnM6IGFyZ3NbMF0sIG51bUFyZ3M6IDAgfTtcbn0pO1xuXG4vLyBMYVRlWCdzIFxcQHNlY29uZG9mdHdveyMxfXsjMn0gZXhwYW5kcyB0byAjMiwgc2tpcHBpbmcgIzFcbi8vIFRlWCBzb3VyY2U6IFxcbG9uZ1xcZGVmXFxAc2Vjb25kb2Z0d28jMSMyeyMyfVxuZGVmaW5lTWFjcm8oXCJcXFxcQHNlY29uZG9mdHdvXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMik7XG4gIHJldHVybiB7IHRva2VuczogYXJnc1sxXSwgbnVtQXJnczogMCB9O1xufSk7XG5cbi8vIExhVGVYJ3MgXFxAaWZuZXh0Y2hhcnsjMX17IzJ9eyMzfSBsb29rcyBhaGVhZCB0byB0aGUgbmV4dCAodW5leHBhbmRlZClcbi8vIHN5bWJvbCB0aGF0IGlzbid0IGEgc3BhY2UsIGNvbnN1bWluZyBhbnkgc3BhY2VzIGJ1dCBub3QgY29uc3VtaW5nIHRoZVxuLy8gZmlyc3Qgbm9uc3BhY2UgY2hhcmFjdGVyLiAgSWYgdGhhdCBub25zcGFjZSBjaGFyYWN0ZXIgbWF0Y2hlcyAjMSwgdGhlblxuLy8gdGhlIG1hY3JvIGV4cGFuZHMgdG8gIzI7IG90aGVyd2lzZSwgaXQgZXhwYW5kcyB0byAjMy5cbmRlZmluZU1hY3JvKFwiXFxcXEBpZm5leHRjaGFyXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgYXJncyA9IGNvbnRleHQuY29uc3VtZUFyZ3MoMyk7IC8vIHN5bWJvbCwgaWYsIGVsc2VcbiAgY29udGV4dC5jb25zdW1lU3BhY2VzKCk7XG4gIGNvbnN0IG5leHRUb2tlbiA9IGNvbnRleHQuZnV0dXJlKCk7XG4gIGlmIChhcmdzWzBdLmxlbmd0aCA9PT0gMSAmJiBhcmdzWzBdWzBdLnRleHQgPT09IG5leHRUb2tlbi50ZXh0KSB7XG4gICAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzFdLCBudW1BcmdzOiAwIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdG9rZW5zOiBhcmdzWzJdLCBudW1BcmdzOiAwIH07XG4gIH1cbn0pO1xuXG4vLyBMYVRlWCdzIFxcQGlmc3RhcnsjMX17IzJ9IGxvb2tzIGFoZWFkIHRvIHRoZSBuZXh0ICh1bmV4cGFuZGVkKSBzeW1ib2wuXG4vLyBJZiBpdCBpcyBgKmAsIHRoZW4gaXQgY29uc3VtZXMgdGhlIHN5bWJvbCwgYW5kIHRoZSBtYWNybyBleHBhbmRzIHRvICMxO1xuLy8gb3RoZXJ3aXNlLCB0aGUgbWFjcm8gZXhwYW5kcyB0byAjMiAod2l0aG91dCBjb25zdW1pbmcgdGhlIHN5bWJvbCkuXG4vLyBUZVggc291cmNlOiBcXGRlZlxcQGlmc3RhciMxe1xcQGlmbmV4dGNoYXIgKntcXEBmaXJzdG9mdHdveyMxfX19XG5kZWZpbmVNYWNybyhcIlxcXFxAaWZzdGFyXCIsIFwiXFxcXEBpZm5leHRjaGFyICp7XFxcXEBmaXJzdG9mdHdveyMxfX1cIik7XG5cbi8vIExhVGVYJ3MgXFxUZXh0T3JNYXRoeyMxfXsjMn0gZXhwYW5kcyB0byAjMSBpbiB0ZXh0IG1vZGUsICMyIGluIG1hdGggbW9kZVxuZGVmaW5lTWFjcm8oXCJcXFxcVGV4dE9yTWF0aFwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpO1xuICBpZiAoY29udGV4dC5tb2RlID09PSBcInRleHRcIikge1xuICAgIHJldHVybiB7IHRva2VuczogYXJnc1swXSwgbnVtQXJnczogMCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHRva2VuczogYXJnc1sxXSwgbnVtQXJnczogMCB9O1xuICB9XG59KTtcblxuY29uc3Qgc3RyaW5nRnJvbUFyZyA9IGFyZyA9PiB7XG4gIC8vIFJldmVyc2UgdGhlIG9yZGVyIG9mIHRoZSBhcmcgYW5kIHJldHVybiBhIHN0cmluZy5cbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSBhcmcubGVuZ3RoIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICBzdHIgKz0gYXJnW2ldLnRleHQ7XG4gIH1cbiAgcmV0dXJuIHN0clxufTtcblxuLy8gTG9va3VwIHRhYmxlIGZvciBwYXJzaW5nIG51bWJlcnMgaW4gYmFzZSA4IHRocm91Z2ggMTZcbmNvbnN0IGRpZ2l0VG9OdW1iZXIgPSB7XG4gIDA6IDAsXG4gIDE6IDEsXG4gIDI6IDIsXG4gIDM6IDMsXG4gIDQ6IDQsXG4gIDU6IDUsXG4gIDY6IDYsXG4gIDc6IDcsXG4gIDg6IDgsXG4gIDk6IDksXG4gIGE6IDEwLFxuICBBOiAxMCxcbiAgYjogMTEsXG4gIEI6IDExLFxuICBjOiAxMixcbiAgQzogMTIsXG4gIGQ6IDEzLFxuICBEOiAxMyxcbiAgZTogMTQsXG4gIEU6IDE0LFxuICBmOiAxNSxcbiAgRjogMTVcbn07XG5cbmNvbnN0IG5leHRDaGFyTnVtYmVyID0gY29udGV4dCA9PiB7XG4gIGNvbnN0IG51bVN0ciA9IGNvbnRleHQuZnV0dXJlKCkudGV4dDtcbiAgaWYgKG51bVN0ciA9PT0gXCJFT0ZcIikgeyByZXR1cm4gW251bGwsIFwiXCJdIH1cbiAgcmV0dXJuIFtkaWdpdFRvTnVtYmVyW251bVN0ci5jaGFyQXQoMCldLCBudW1TdHJdXG59O1xuXG5jb25zdCBhcHBlbmRDaGFyTnVtYmVycyA9IChudW1iZXIsIG51bVN0ciwgYmFzZSkgPT4ge1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG51bVN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRUb051bWJlcltudW1TdHIuY2hhckF0KGkpXTtcbiAgICBudW1iZXIgKj0gYmFzZTtcbiAgICBudW1iZXIgKz0gZGlnaXQ7XG4gIH1cbiAgcmV0dXJuIG51bWJlclxufTtcblxuLy8gVGVYIFxcY2hhciBtYWtlcyBhIGxpdGVyYWwgY2hhcmFjdGVyIChjYXRjb2RlIDEyKSB1c2luZyB0aGUgZm9sbG93aW5nIGZvcm1zOlxuLy8gKHNlZSBUaGUgVGVYQm9vaywgcC4gNDMpXG4vLyAgIFxcY2hhcjEyMyAgLS0gZGVjaW1hbFxuLy8gICBcXGNoYXInMTIzIC0tIG9jdGFsXG4vLyAgIFxcY2hhclwiMTIzIC0tIGhleFxuLy8gICBcXGNoYXJgeCAgIC0tIGNoYXJhY3RlciB0aGF0IGNhbiBiZSB3cml0dGVuIChpLmUuIGlzbid0IGFjdGl2ZSlcbi8vICAgXFxjaGFyYFxceCAgLS0gY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIHdyaXR0ZW4gKGUuZy4gJSlcbi8vIFRoZXNlIGFsbCByZWZlciB0byBjaGFyYWN0ZXJzIGZyb20gdGhlIGZvbnQsIHNvIHdlIHR1cm4gdGhlbSBpbnRvIHNwZWNpYWxcbi8vIGNhbGxzIHRvIGEgZnVuY3Rpb24gXFxAY2hhciBkZWFsdCB3aXRoIGluIHRoZSBQYXJzZXIuXG5kZWZpbmVNYWNybyhcIlxcXFxjaGFyXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgbGV0IHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICBsZXQgYmFzZTtcbiAgbGV0IG51bWJlciA9IFwiXCI7XG4gIGlmICh0b2tlbi50ZXh0ID09PSBcIidcIikge1xuICAgIGJhc2UgPSA4O1xuICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpO1xuICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09ICdcIicpIHtcbiAgICBiYXNlID0gMTY7XG4gICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7XG4gIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gXCJgXCIpIHtcbiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTtcbiAgICBpZiAodG9rZW4udGV4dFswXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIG51bWJlciA9IHRva2VuLnRleHQuY2hhckNvZGVBdCgxKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09IFwiRU9GXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiXFxcXGNoYXJgIG1pc3NpbmcgYXJndW1lbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlciA9IHRva2VuLnRleHQuY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IDEwO1xuICB9XG4gIGlmIChiYXNlKSB7XG4gICAgLy8gUGFyc2UgYSBudW1iZXIgaW4gdGhlIGdpdmVuIGJhc2UsIHN0YXJ0aW5nIHdpdGggZmlyc3QgYHRva2VuYC5cbiAgICBsZXQgbnVtU3RyID0gdG9rZW4udGV4dDtcbiAgICBudW1iZXIgPSBkaWdpdFRvTnVtYmVyW251bVN0ci5jaGFyQXQoMCldO1xuICAgIGlmIChudW1iZXIgPT0gbnVsbCB8fCBudW1iZXIgPj0gYmFzZSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgYmFzZS0ke2Jhc2V9IGRpZ2l0ICR7dG9rZW4udGV4dH1gKTtcbiAgICB9XG4gICAgbnVtYmVyID0gYXBwZW5kQ2hhck51bWJlcnMobnVtYmVyLCBudW1TdHIsIGJhc2UpO1xuICAgIGxldCBkaWdpdDtcbiAgICBbZGlnaXQsIG51bVN0cl0gPSBuZXh0Q2hhck51bWJlcihjb250ZXh0KTtcbiAgICB3aGlsZSAoZGlnaXQgIT0gbnVsbCAmJiBkaWdpdCA8IGJhc2UpIHtcbiAgICAgIG51bWJlciAqPSBiYXNlO1xuICAgICAgbnVtYmVyICs9IGRpZ2l0O1xuICAgICAgbnVtYmVyID0gYXBwZW5kQ2hhck51bWJlcnMobnVtYmVyLCBudW1TdHIsIGJhc2UpO1xuICAgICAgY29udGV4dC5wb3BUb2tlbigpO1xuICAgICAgW2RpZ2l0LCBudW1TdHJdID0gbmV4dENoYXJOdW1iZXIoY29udGV4dCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBgXFxcXEBjaGFyeyR7bnVtYmVyfX1gO1xufSk7XG5cbmZ1bmN0aW9uIHJlY3JlYXRlQXJnU3RyKGNvbnRleHQpIHtcbiAgLy8gUmVjcmVhdGUgdGhlIG1hY3JvJ3Mgb3JpZ2luYWwgYXJndW1lbnQgc3RyaW5nIGZyb20gdGhlIGFycmF5IG9mIHBhcnNlIHRva2Vucy5cbiAgY29uc3QgdG9rZW5zID0gY29udGV4dC5jb25zdW1lQXJncygxKVswXTtcbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGxldCBleHBlY3RlZExvYyA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ubG9jLnN0YXJ0O1xuICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgYWN0dWFsTG9jID0gdG9rZW5zW2ldLmxvYy5zdGFydDtcbiAgICBpZiAoYWN0dWFsTG9jID4gZXhwZWN0ZWRMb2MpIHtcbiAgICAgIC8vIGNvbnRleHQuY29uc3VtZUFyZ3MgaGFzIGVhdGVuIGEgc3BhY2UuXG4gICAgICBzdHIgKz0gXCIgXCI7XG4gICAgICBleHBlY3RlZExvYyA9IGFjdHVhbExvYztcbiAgICB9XG4gICAgc3RyICs9IHRva2Vuc1tpXS50ZXh0O1xuICAgIGV4cGVjdGVkTG9jICs9IHRva2Vuc1tpXS50ZXh0Lmxlbmd0aDtcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbi8vIFRoZSBMYXRpbiBNb2Rlcm4gZm9udCByZW5kZXJzIDxtaT7iiJo8L21pPiBhdCB0aGUgd3JvbmcgdmVydGljYWwgYWxpZ25tZW50LlxuLy8gVGhpcyBtYWNybyBwcm92aWRlcyBhIGJldHRlciByZW5kZXJpbmcuXG5kZWZpbmVNYWNybyhcIlxcXFxzdXJkXCIsICdcXFxcc3FydHtcXFxcdnBoYW50b217fH19Jyk7XG5cbi8vIFNlZSBjb21tZW50IGZvciBcXG9wbHVzIGluIHN5bWJvbHMuanMuXG5kZWZpbmVNYWNybyhcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIik7XG5cbi8vIFNpbmNlIFRlbW1sIGhhcyBubyBcXHBhciwgaWdub3JlIFxcbG9uZy5cbmRlZmluZU1hY3JvKFwiXFxcXGxvbmdcIiwgXCJcIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEdyb3VwaW5nXG4vLyBcXGxldFxcYmdyb3VwPXsgXFxsZXRcXGVncm91cD19XG5kZWZpbmVNYWNybyhcIlxcXFxiZ3JvdXBcIiwgXCJ7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZWdyb3VwXCIsIFwifVwiKTtcblxuLy8gU3ltYm9scyBmcm9tIGxhdGV4Lmx0eDpcbi8vIFxcZGVmfntcXG5vYnJlYWtzcGFjZXt9fVxuLy8gXFxkZWZcXGxxe2B9XG4vLyBcXGRlZlxccnF7J31cbi8vIFxcZGVmIFxcYWEge1xcciBhfVxuZGVmaW5lTWFjcm8oXCJ+XCIsIFwiXFxcXG5vYnJlYWtzcGFjZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGxxXCIsIFwiYFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHJxXCIsIFwiJ1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFhXCIsIFwiXFxcXHIgYVwiKTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcQmJia1wiLCBcIlxcXFxCYmJ7a31cIik7XG5cbi8vIFxcbWF0aHN0cnV0IGZyb20gdGhlIFRlWGJvb2ssIHAgMzYwXG5kZWZpbmVNYWNybyhcIlxcXFxtYXRoc3RydXRcIiwgXCJcXFxcdnBoYW50b217KH1cIik7XG5cbi8vIFxcdW5kZXJiYXIgZnJvbSBUZVhib29rIHAgMzUzXG5kZWZpbmVNYWNybyhcIlxcXFx1bmRlcmJhclwiLCBcIlxcXFx1bmRlcmxpbmV7XFxcXHRleHR7IzF9fVwiKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTGFUZVhfMs61XG5cbi8vIFxcdmRvdHN7XFx2Ym94e1xcYmFzZWxpbmVza2lwNFxccEAgIFxcbGluZXNraXBsaW1pdFxcekBcbi8vIFxca2VybjZcXHBAXFxoYm94ey59XFxoYm94ey59XFxoYm94ey59fX1cbi8vIFdlJ2xsIGNhbGwgXFx2YXJ2ZG90cywgd2hpY2ggZ2V0cyBhIGdseXBoIGZyb20gc3ltYm9scy5qcy5cbi8vIFRoZSB6ZXJvLXdpZHRoIHJ1bGUgZ2V0cyB1cyBhbiBlcXVpdmFsZW50IHRvIHRoZSB2ZXJ0aWNhbCA2cHQga2Vybi5cbmRlZmluZU1hY3JvKFwiXFxcXHZkb3RzXCIsIFwie1xcXFx2YXJ2ZG90c1xcXFxydWxlezBwdH17MTVwdH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXHUyMmVlXCIsIFwiXFxcXHZkb3RzXCIpO1xuXG4vLyB7YXJyYXl9IGVudmlyb25tZW50IGdhcHNcbmRlZmluZU1hY3JvKFwiXFxcXGFycmF5c3RyZXRjaFwiLCBcIjFcIik7ICAgICAvLyBsaW5lIHNwYWNpbmcgZmFjdG9yIHRpbWVzIDEycHRcbmRlZmluZU1hY3JvKFwiXFxcXGFycmF5Y29sc2VwXCIsIFwiNnB0XCIpOyAgICAvLyBoYWxmIHRoZSB3aWR0aCBzZXBhcmF0aW5nIGNvbHVtbnNcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gYW1zbWF0aC5zdHlcbi8vIGh0dHA6Ly9taXJyb3JzLmNvbmNlcnRwYXNzLmNvbS90ZXgtYXJjaGl2ZS9tYWNyb3MvbGF0ZXgvcmVxdWlyZWQvYW1zbWF0aC9hbXNtYXRoLnBkZlxuXG4vL1xcbmV3Y29tbWFuZHtcXHN1YnN0YWNrfVsxXXtcXHN1YmFycmF5e2N9IzFcXGVuZHN1YmFycmF5fVxuZGVmaW5lTWFjcm8oXCJcXFxcc3Vic3RhY2tcIiwgXCJcXFxcYmVnaW57c3ViYXJyYXl9e2N9IzFcXFxcZW5ke3N1YmFycmF5fVwiKTtcblxuLy8gXFxkZWZcXGlmZntcXERPVFNCXFw7XFxMb25nbGVmdHJpZ2h0YXJyb3dcXDt9XG4vLyBcXGRlZlxcaW1wbGllc3tcXERPVFNCXFw7XFxMb25ncmlnaHRhcnJvd1xcO31cbi8vIFxcZGVmXFxpbXBsaWVkYnl7XFxET1RTQlxcO1xcTG9uZ2xlZnRhcnJvd1xcO31cbmRlZmluZU1hY3JvKFwiXFxcXGlmZlwiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdsZWZ0cmlnaHRhcnJvd1xcXFw7XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW1wbGllc1wiLCBcIlxcXFxET1RTQlxcXFw7XFxcXExvbmdyaWdodGFycm93XFxcXDtcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbXBsaWVkYnlcIiwgXCJcXFxcRE9UU0JcXFxcO1xcXFxMb25nbGVmdGFycm93XFxcXDtcIik7XG5cbi8vIEFNU01hdGgncyBhdXRvbWF0aWMgXFxkb3RzLCBiYXNlZCBvbiBcXG1kb3RzQEAgbWFjcm8uXG5jb25zdCBkb3RzQnlUb2tlbiA9IHtcbiAgXCIsXCI6IFwiXFxcXGRvdHNjXCIsXG4gIFwiXFxcXG5vdFwiOiBcIlxcXFxkb3RzYlwiLFxuICAvLyBcXGtleWJpbkAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOlxuICBcIitcIjogXCJcXFxcZG90c2JcIixcbiAgXCI9XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiPFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIj5cIjogXCJcXFxcZG90c2JcIixcbiAgXCItXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiKlwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIjpcIjogXCJcXFxcZG90c2JcIixcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcRE9UU0I6XG4gIFwiXFxcXERPVFNCXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGNvcHJvZFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWd2ZWVcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnd2VkZ2VcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlndXBsdXNcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnY2FwXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGJpZ2N1cFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxwcm9kXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXHN1bVwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdvdGltZXNcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnb3BsdXNcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcYmlnb2RvdFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdzcWNhcFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWdzcWN1cFwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxiaWd0aW1lc1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxBbmRcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcbG9uZ3JpZ2h0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcTG9uZ3JpZ2h0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxMb25nbGVmdGFycm93XCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcbWFwc3RvXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXGxvbmdtYXBzdG9cIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcaG9va3JpZ2h0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxcZG90ZXFcIjogXCJcXFxcZG90c2JcIixcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcbWF0aGJpbjpcbiAgXCJcXFxcbWF0aGJpblwiOiBcIlxcXFxkb3RzYlwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxtYXRocmVsOlxuICBcIlxcXFxtYXRocmVsXCI6IFwiXFxcXGRvdHNiXCIsXG4gIFwiXFxcXHJlbGJhclwiOiBcIlxcXFxkb3RzYlwiLFxuICBcIlxcXFxSZWxiYXJcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxceHJpZ2h0YXJyb3dcIjogXCJcXFxcZG90c2JcIixcbiAgXCJcXFxceGxlZnRhcnJvd1wiOiBcIlxcXFxkb3RzYlwiLFxuICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXFxET1RTSTpcbiAgXCJcXFxcRE9UU0lcIjogXCJcXFxcZG90c2lcIixcbiAgXCJcXFxcaW50XCI6IFwiXFxcXGRvdHNpXCIsXG4gIFwiXFxcXG9pbnRcIjogXCJcXFxcZG90c2lcIixcbiAgXCJcXFxcaWludFwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpaWludFwiOiBcIlxcXFxkb3RzaVwiLFxuICBcIlxcXFxpaWlpbnRcIjogXCJcXFxcZG90c2lcIixcbiAgXCJcXFxcaWRvdHNpbnRcIjogXCJcXFxcZG90c2lcIixcbiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxcRE9UU1g6XG4gIFwiXFxcXERPVFNYXCI6IFwiXFxcXGRvdHN4XCJcbn07XG5cbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICAvLyBUT0RPOiBJZiB1c2VkIGluIHRleHQgbW9kZSwgc2hvdWxkIGV4cGFuZCB0byBcXHRleHRlbGxpcHNpcy5cbiAgLy8gSG93ZXZlciwgaW4gVGVtbWwsIFxcdGV4dGVsbGlwc2lzIGFuZCBcXGxkb3RzIGJlaGF2ZSB0aGUgc2FtZVxuICAvLyAoaW4gdGV4dCBtb2RlKSwgYW5kIGl0J3MgdW5saWtlbHkgd2UnZCBzZWUgYW55IG9mIHRoZSBtYXRoIGNvbW1hbmRzXG4gIC8vIHRoYXQgYWZmZWN0IHRoZSBiZWhhdmlvciBvZiBcXGRvdHMgd2hlbiBpbiB0ZXh0IG1vZGUuICBTbyBmaW5lIGZvciBub3dcbiAgLy8gKHVudGlsIHdlIHN1cHBvcnQgXFxpZm1tb2RlIC4uLiBcXGVsc2UgLi4uIFxcZmkpLlxuICBsZXQgdGhlZG90cyA9IFwiXFxcXGRvdHNvXCI7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmV4cGFuZEFmdGVyRnV0dXJlKCkudGV4dDtcbiAgaWYgKG5leHQgaW4gZG90c0J5VG9rZW4pIHtcbiAgICB0aGVkb3RzID0gZG90c0J5VG9rZW5bbmV4dF07XG4gIH0gZWxzZSBpZiAobmV4dC5zbGljZSgwLCA0KSA9PT0gXCJcXFxcbm90XCIpIHtcbiAgICB0aGVkb3RzID0gXCJcXFxcZG90c2JcIjtcbiAgfSBlbHNlIGlmIChuZXh0IGluIHN5bWJvbHMubWF0aCkge1xuICAgIGlmIChbXCJiaW5cIiwgXCJyZWxcIl0uaW5jbHVkZXMoc3ltYm9scy5tYXRoW25leHRdLmdyb3VwKSkge1xuICAgICAgdGhlZG90cyA9IFwiXFxcXGRvdHNiXCI7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGVkb3RzO1xufSk7XG5cbmNvbnN0IHNwYWNlQWZ0ZXJEb3RzID0ge1xuICAvLyBcXHJpZ2h0ZGVsaW1AIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgXCIpXCI6IHRydWUsXG4gIFwiXVwiOiB0cnVlLFxuICBcIlxcXFxyYnJhY2tcIjogdHJ1ZSxcbiAgXCJcXFxcfVwiOiB0cnVlLFxuICBcIlxcXFxyYnJhY2VcIjogdHJ1ZSxcbiAgXCJcXFxccmFuZ2xlXCI6IHRydWUsXG4gIFwiXFxcXHJjZWlsXCI6IHRydWUsXG4gIFwiXFxcXHJmbG9vclwiOiB0cnVlLFxuICBcIlxcXFxyZ3JvdXBcIjogdHJ1ZSxcbiAgXCJcXFxccm1vdXN0YWNoZVwiOiB0cnVlLFxuICBcIlxcXFxyaWdodFwiOiB0cnVlLFxuICBcIlxcXFxiaWdyXCI6IHRydWUsXG4gIFwiXFxcXGJpZ2dyXCI6IHRydWUsXG4gIFwiXFxcXEJpZ3JcIjogdHJ1ZSxcbiAgXCJcXFxcQmlnZ3JcIjogdHJ1ZSxcbiAgLy8gXFxleHRyYUAgYWxzbyB0ZXN0cyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgJDogdHJ1ZSxcbiAgLy8gXFxleHRyYXBAIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzpcbiAgXCI7XCI6IHRydWUsXG4gIFwiLlwiOiB0cnVlLFxuICBcIixcIjogdHJ1ZVxufTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c29cIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0O1xuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cykge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1xcXFwsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXCI7XG4gIH1cbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzY1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG4gIC8vIFxcZG90c2MgdXNlcyBcXGV4dHJhQCBidXQgbm90IFxcZXh0cmFwQCwgaW5zdGVhZCBzcGVjaWFsbHkgY2hlY2tpbmcgZm9yXG4gIC8vICc7JyBhbmQgJy4nLCBidXQgZG9lc24ndCBjaGVjayBmb3IgJywnLlxuICBpZiAobmV4dCBpbiBzcGFjZUFmdGVyRG90cyAmJiBuZXh0ICE9PSBcIixcIikge1xuICAgIHJldHVybiBcIlxcXFxsZG90c1xcXFwsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXFxcXGxkb3RzXCI7XG4gIH1cbn0pO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxjZG90c1wiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7XG4gIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7XG4gICAgcmV0dXJuIFwiXFxcXEBjZG90c1xcXFwsXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXFxcXEBjZG90c1wiO1xuICB9XG59KTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcZG90c2JcIiwgXCJcXFxcY2RvdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzbVwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHNpXCIsIFwiXFxcXCFcXFxcY2RvdHNcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpZG90c2ludFwiLCBcIlxcXFxkb3RzaVwiKTtcbi8vIGFtc21hdGggZG9lc24ndCBhY3R1YWxseSBkZWZpbmUgXFxkb3RzeCwgYnV0IFxcZG90cyBmb2xsb3dlZCBieSBhIG1hY3JvXG4vLyBzdGFydGluZyB3aXRoIFxcRE9UU1ggaW1wbGllcyBcXGRvdHNvLCBhbmQgdGhlbiBcXGV4dHJhQCBkZXRlY3RzIHRoaXMgY2FzZVxuLy8gYW5kIGZvcmNlcyB0aGUgYWRkZWQgYFxcLGAuXG5kZWZpbmVNYWNybyhcIlxcXFxkb3RzeFwiLCBcIlxcXFxsZG90c1xcXFwsXCIpO1xuXG4vLyBcXGxldFxcRE9UU0lcXHJlbGF4XG4vLyBcXGxldFxcRE9UU0JcXHJlbGF4XG4vLyBcXGxldFxcRE9UU1hcXHJlbGF4XG5kZWZpbmVNYWNybyhcIlxcXFxET1RTSVwiLCBcIlxcXFxyZWxheFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERPVFNCXCIsIFwiXFxcXHJlbGF4XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRE9UU1hcIiwgXCJcXFxccmVsYXhcIik7XG5cbi8vIFNwYWNpbmcsIGJhc2VkIG9uIGFtc21hdGguc3R5J3Mgb3ZlcnJpZGUgb2YgTGFUZVggZGVmYXVsdHNcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmR7XFx0bXNwYWNlfVszXXslXG4vLyAgIFxcaWZtbW9kZVxcbXNraXAjMSMyXFxlbHNlXFxrZXJuIzEjM1xcZmlcXHJlbGF4fVxuZGVmaW5lTWFjcm8oXCJcXFxcdG1zcGFjZVwiLCBcIlxcXFxUZXh0T3JNYXRoe1xcXFxrZXJuIzEjM317XFxcXG1za2lwIzEjMn1cXFxccmVsYXhcIik7XG4vLyBcXHJlbmV3Y29tbWFuZHtcXCx9e1xcdG1zcGFjZStcXHRoaW5tdXNraXB7LjE2NjdlbX19XG4vLyBUT0RPOiBtYXRoIG1vZGUgc2hvdWxkIHVzZSBcXHRoaW5tdXNraXBcbmRlZmluZU1hY3JvKFwiXFxcXCxcIiwgXCJ7XFxcXHRtc3BhY2UrezNtdX17LjE2NjdlbX19XCIpO1xuLy8gXFxsZXRcXHRoaW5zcGFjZVxcLFxuZGVmaW5lTWFjcm8oXCJcXFxcdGhpbnNwYWNlXCIsIFwiXFxcXCxcIik7XG4vLyBcXGRlZlxcPntcXG1za2lwXFxtZWRtdXNraXB9XG4vLyBcXHJlbmV3Y29tbWFuZHtcXDp9e1xcdG1zcGFjZStcXG1lZG11c2tpcHsuMjIyMmVtfX1cbi8vIFRPRE86IFxcPiBhbmQgbWF0aCBtb2RlIG9mIFxcOiBzaG91bGQgdXNlIFxcbWVkbXVza2lwID0gNG11IHBsdXMgMm11IG1pbnVzIDRtdVxuZGVmaW5lTWFjcm8oXCJcXFxcPlwiLCBcIlxcXFxtc2tpcHs0bXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcOlwiLCBcIntcXFxcdG1zcGFjZSt7NG11fXsuMjIyMmVtfX1cIik7XG4vLyBcXGxldFxcbWVkc3BhY2VcXDpcbmRlZmluZU1hY3JvKFwiXFxcXG1lZHNwYWNlXCIsIFwiXFxcXDpcIik7XG4vLyBcXHJlbmV3Y29tbWFuZHtcXDt9e1xcdG1zcGFjZStcXHRoaWNrbXVza2lwey4yNzc3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlja211c2tpcCA9IDVtdSBwbHVzIDVtdVxuZGVmaW5lTWFjcm8oXCJcXFxcO1wiLCBcIntcXFxcdG1zcGFjZSt7NW11fXsuMjc3N2VtfX1cIik7XG4vLyBcXGxldFxcdGhpY2tzcGFjZVxcO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGhpY2tzcGFjZVwiLCBcIlxcXFw7XCIpO1xuLy8gXFxyZW5ld2NvbW1hbmR7XFwhfXtcXHRtc3BhY2UtXFx0aGlubXVza2lwey4xNjY3ZW19fVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFx0aGlubXVza2lwXG5kZWZpbmVNYWNybyhcIlxcXFwhXCIsIFwie1xcXFx0bXNwYWNlLXszbXV9ey4xNjY3ZW19fVwiKTtcbi8vIFxcbGV0XFxuZWd0aGluc3BhY2VcXCFcbmRlZmluZU1hY3JvKFwiXFxcXG5lZ3RoaW5zcGFjZVwiLCBcIlxcXFwhXCIpO1xuLy8gXFxuZXdjb21tYW5ke1xcbmVnbWVkc3BhY2V9e1xcdG1zcGFjZS1cXG1lZG11c2tpcHsuMjIyMmVtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcbWVkbXVza2lwXG5kZWZpbmVNYWNybyhcIlxcXFxuZWdtZWRzcGFjZVwiLCBcIntcXFxcdG1zcGFjZS17NG11fXsuMjIyMmVtfX1cIik7XG4vLyBcXG5ld2NvbW1hbmR7XFxuZWd0aGlja3NwYWNlfXtcXHRtc3BhY2UtXFx0aGlja211c2tpcHsuMjc3N2VtfX1cbi8vIFRPRE86IG1hdGggbW9kZSBzaG91bGQgdXNlIFxcdGhpY2ttdXNraXBcbmRlZmluZU1hY3JvKFwiXFxcXG5lZ3RoaWNrc3BhY2VcIiwgXCJ7XFxcXHRtc3BhY2UtezVtdX17LjI3N2VtfX1cIik7XG4vLyBcXGRlZlxcZW5zcGFjZXtcXGtlcm4uNWVtIH1cbmRlZmluZU1hY3JvKFwiXFxcXGVuc3BhY2VcIiwgXCJcXFxca2Vybi41ZW0gXCIpO1xuLy8gXFxkZWZcXGVuc2tpcHtcXGhza2lwLjVlbVxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFxlbnNraXBcIiwgXCJcXFxcaHNraXAuNWVtXFxcXHJlbGF4XCIpO1xuLy8gXFxkZWZcXHF1YWR7XFxoc2tpcDFlbVxccmVsYXh9XG5kZWZpbmVNYWNybyhcIlxcXFxxdWFkXCIsIFwiXFxcXGhza2lwMWVtXFxcXHJlbGF4XCIpO1xuLy8gXFxkZWZcXHFxdWFke1xcaHNraXAyZW1cXHJlbGF4fVxuZGVmaW5lTWFjcm8oXCJcXFxccXF1YWRcIiwgXCJcXFxcaHNraXAyZW1cXFxccmVsYXhcIik7XG5cbmRlZmluZU1hY3JvKFwiXFxcXEFBXCIsIFwiXFxcXFRleHRPck1hdGh7XFxcXEFuZ3N0cm9tfXtcXFxcbWF0aHJpbmd7QX19XFxcXHJlbGF4XCIpO1xuXG4vLyBcXHRhZ0BpbkBkaXNwbGF5IGZvcm0gb2YgXFx0YWdcbmRlZmluZU1hY3JvKFwiXFxcXHRhZ1wiLCBcIlxcXFxAaWZzdGFyXFxcXHRhZ0BsaXRlcmFsXFxcXHRhZ0BwYXJlblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRhZ0BwYXJlblwiLCBcIlxcXFx0YWdAbGl0ZXJhbHsoeyMxfSl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdGFnQGxpdGVyYWxcIiwgKGNvbnRleHQpID0+IHtcbiAgaWYgKGNvbnRleHQubWFjcm9zLmdldChcIlxcXFxkZkB0YWdcIikpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk11bHRpcGxlIFxcXFx0YWdcIik7XG4gIH1cbiAgcmV0dXJuIFwiXFxcXGdkZWZcXFxcZGZAdGFne1xcXFx0ZXh0eyMxfX1cIjtcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcbm90YWdcIiwgXCJcXFxcbm9udW1iZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxub251bWJlclwiLCBcIlxcXFxnZGVmXFxcXEBlcW5zd3swfVwiKTtcblxuLy8gXFxyZW5ld2NvbW1hbmR7XFxibW9kfXtcXG5vbnNjcmlwdFxcbXNraXAtXFxtZWRtdXNraXBcXG1rZXJuNW11XFxtYXRoYmluXG4vLyAgIHtcXG9wZXJhdG9yQGZvbnQgbW9kfVxccGVuYWx0eTkwMFxuLy8gICBcXG1rZXJuNW11XFxub25zY3JpcHRcXG1za2lwLVxcbWVkbXVza2lwfVxuLy8gXFxuZXdjb21tYW5ke1xccG9kfVsxXXtcXGFsbG93YnJlYWtcbi8vICAgXFxpZkBkaXNwbGF5XFxta2VybjE4bXVcXGVsc2VcXG1rZXJuOG11XFxmaSgjMSl9XG4vLyBcXHJlbmV3Y29tbWFuZHtcXHBtb2R9WzFde1xccG9ke3tcXG9wZXJhdG9yQGZvbnQgbW9kfVxcbWtlcm42bXUjMX19XG4vLyBcXG5ld2NvbW1hbmR7XFxtb2R9WzFde1xcYWxsb3dicmVha1xcaWZAZGlzcGxheVxcbWtlcm4xOG11XG4vLyAgIFxcZWxzZVxcbWtlcm4xMm11XFxmaXtcXG9wZXJhdG9yQGZvbnQgbW9kfVxcLFxcLCMxfVxuLy8gVE9ETzogbWF0aCBtb2RlIHNob3VsZCB1c2UgXFxtZWRtdXNraXAgPSA0bXUgcGx1cyAybXUgbWludXMgNG11XG5kZWZpbmVNYWNybyhcIlxcXFxibW9kXCIsIFwiXFxcXG1hdGhiaW57XFxcXHRleHR7bW9kfX1cIik7XG5kZWZpbmVNYWNybyhcbiAgXCJcXFxccG9kXCIsXG4gIFwiXFxcXGFsbG93YnJlYWtcIiArIFwiXFxcXG1hdGhjaG9pY2V7XFxcXG1rZXJuMThtdX17XFxcXG1rZXJuOG11fXtcXFxcbWtlcm44bXV9e1xcXFxta2VybjhtdX0oIzEpXCJcbik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbW9kXCIsIFwiXFxcXHBvZHt7XFxcXHJtIG1vZH1cXFxcbWtlcm42bXUjMX1cIik7XG5kZWZpbmVNYWNybyhcbiAgXCJcXFxcbW9kXCIsXG4gIFwiXFxcXGFsbG93YnJlYWtcIiArXG4gICAgXCJcXFxcbWF0aGNob2ljZXtcXFxcbWtlcm4xOG11fXtcXFxcbWtlcm4xMm11fXtcXFxcbWtlcm4xMm11fXtcXFxcbWtlcm4xMm11fVwiICtcbiAgICBcIntcXFxccm0gbW9kfVxcXFwsXFxcXCwjMVwiXG4pO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBMYVRlWCBzb3VyY2UyZVxuXG4vLyBcXGV4cGFuZGFmdGVyXFxsZXRcXGV4cGFuZGFmdGVyXFxAbm9ybWFsY3Jcbi8vICAgICBcXGNzbmFtZVxcZXhwYW5kYWZ0ZXJcXEBnb2JibGVcXHN0cmluZ1xcXFwgXFxlbmRjc25hbWVcbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXG5ld2xpbmV7XFxAbm9ybWFsY3JcXHJlbGF4fVxuZGVmaW5lTWFjcm8oXCJcXFxcbmV3bGluZVwiLCBcIlxcXFxcXFxcXFxcXHJlbGF4XCIpO1xuXG4vLyBcXGRlZlxcVGVYe1RcXGtlcm4tLjE2NjdlbVxcbG93ZXIuNWV4XFxoYm94e0V9XFxrZXJuLS4xMjVlbVhcXEB9XG4vLyBUT0RPOiBEb2Vzbid0IG5vcm1hbGx5IHdvcmsgaW4gbWF0aCBtb2RlIGJlY2F1c2UgXFxAIGZhaWxzLlxuZGVmaW5lTWFjcm8oXCJcXFxcVGVYXCIsIFwiXFxcXHRleHRybXtUfVxcXFxrZXJuLS4xNjY3ZW1cXFxccmFpc2Vib3h7LS41ZXh9e0V9XFxcXGtlcm4tLjEyNWVtXFxcXHRleHRybXtYfVwiKTtcblxuZGVmaW5lTWFjcm8oXG4gIFwiXFxcXExhVGVYXCIsXG4gICAgXCJcXFxcdGV4dHJte0x9XFxcXGtlcm4tLjM1ZW1cXFxccmFpc2Vib3h7MC4yZW19e1xcXFxzY3JpcHRzdHlsZSBBfVxcXFxrZXJuLS4xNWVtXFxcXFRlWFwiXG4pO1xuXG5kZWZpbmVNYWNybyhcbiAgXCJcXFxcVGVtbWxcIixcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgXCJcXFxcdGV4dHJte1R9XFxcXGtlcm4tMC4yZW1cXFxcbG93ZXJ7MC4yZW19e1xcXFx0ZXh0cm17RX19XFxcXGtlcm4tMC4wOGVte1xcXFx0ZXh0cm17TX1cXFxca2Vybi0wLjA4ZW1cXFxccmFpc2V7MC4yZW19XFxcXHRleHRybXtNfVxcXFxrZXJuLTAuMDhlbVxcXFx0ZXh0cm17TH19XCJcbik7XG5cbi8vIFxcRGVjbGFyZVJvYnVzdENvbW1hbmRcXGhzcGFjZXtcXEBpZnN0YXJcXEBoc3BhY2VyXFxAaHNwYWNlfVxuLy8gXFxkZWZcXEBoc3BhY2UjMXtcXGhza2lwICAjMVxccmVsYXh9XG4vLyBcXGRlZlxcQGhzcGFjZXIjMXtcXHZydWxlIFxcQHdpZHRoXFx6QFxcbm9icmVha1xuLy8gICAgICAgICAgICAgICAgIFxcaHNraXAgIzFcXGhza2lwIFxcekBza2lwfVxuZGVmaW5lTWFjcm8oXCJcXFxcaHNwYWNlXCIsIFwiXFxcXEBpZnN0YXJcXFxcQGhzcGFjZXJcXFxcQGhzcGFjZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXEBoc3BhY2VcIiwgXCJcXFxcaHNraXAgIzFcXFxccmVsYXhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxAaHNwYWNlclwiLCBcIlxcXFxydWxlezBwdH17MHB0fVxcXFxoc2tpcCAjMVxcXFxyZWxheFwiKTtcblxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25cIiwgYFxcXFxtYXRocHVuY3R7XFxcXGNoYXJcIjNhfWApO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtYXRodG9vbHMuc3R5XG5cbmRlZmluZU1hY3JvKFwiXFxcXHByZXNjcmlwdFwiLCBcIlxcXFxwcmVzQGNyaXB0e197IzF9XnsjMn19e317IzN9XCIpO1xuXG4vL1xccHJvdmlkZWNvbW1hbmRcXG9yZGluYXJ5Y29sb257On1cbmRlZmluZU1hY3JvKFwiXFxcXG9yZGluYXJ5Y29sb25cIiwgYFxcXFxjaGFyXCIzYWApO1xuLy8gUmFpc2UgdG8gY2VudGVyIG9uIHRoZSBtYXRoIGF4aXMsIGFzIGNsb3NlbHkgYXMgcG9zc2libGUuXG5kZWZpbmVNYWNybyhcIlxcXFx2Y2VudGNvbG9uXCIsIFwiXFxcXG1hdGhyZWx7XFxcXHJhaXNlYm94ezAuMDM1ZW19e1xcXFxvcmRpbmFyeWNvbG9ufX1cIik7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcY29sb25lcXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXG1hdGhyZWx7LX19XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxXCIsICdcXFxcbWF0aHJlbHtcXFxccmFpc2Vib3h7MC4wMzVlbX17XFxcXG9yZGluYXJ5Y29sb259XFxcXGNoYXJcIjIyMTJ9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25lcXtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fVxuZGVmaW5lTWFjcm8oXCJcXFxcQ29sb25lcVwiLCAnXFxcXG1hdGhyZWx7XFxcXGNoYXJcIjIyMzdcXFxcY2hhclwiMjIxMn0nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxFcXFjb2xvbns9XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn1cbmRlZmluZU1hY3JvKFwiXFxcXEVxcWNvbG9uXCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiM2RcXFxcY2hhclwiMjIzN30nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxFcWNvbG9ue1xcbWF0aHJlbHstfVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcZGJsY29sb259XG5kZWZpbmVNYWNybyhcIlxcXFxFcWNvbG9uXCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjIxMlxcXFxjaGFyXCIyMjM3fScpO1xuLy8gXFxwcm92aWRlY29tbWFuZCpcXGNvbG9uYXBwcm94e1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fVxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25hcHByb3hcIiwgJ1xcXFxtYXRocmVse1xcXFxyYWlzZWJveHswLjAzNWVtfXtcXFxcb3JkaW5hcnljb2xvbn1cXFxcY2hhclwiMjI0OH0nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxDb2xvbmFwcHJveHtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9XG5kZWZpbmVNYWNybyhcIlxcXFxDb2xvbmFwcHJveFwiLCAnXFxcXG1hdGhyZWx7XFxcXGNoYXJcIjIyMzdcXFxcY2hhclwiMjI0OH0nKTtcbi8vIFxccHJvdmlkZWNvbW1hbmQqXFxjb2xvbnNpbXtcXHZjZW50Y29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHNpbX1cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uc2ltXCIsICdcXFxcbWF0aHJlbHtcXFxccmFpc2Vib3h7MC4wMzVlbX17XFxcXG9yZGluYXJ5Y29sb259XFxcXGNoYXJcIjIyM2N9Jyk7XG4vLyBcXHByb3ZpZGVjb21tYW5kKlxcQ29sb25zaW17XFxkYmxjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcc2ltfVxuZGVmaW5lTWFjcm8oXCJcXFxcQ29sb25zaW1cIiwgJ1xcXFxtYXRocmVse1xcXFxyYWlzZWJveHswLjAzNWVtfXtcXFxcb3JkaW5hcnljb2xvbn1cXFxcY2hhclwiMjIzY30nKTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29sb25lcXVhbHMuc3R5XG5cbi8vIEFsdGVybmF0ZSBuYW1lcyBmb3IgbWF0aHRvb2xzJ3MgbWFjcm9zOlxuZGVmaW5lTWFjcm8oXCJcXFxccmF0aW9cIiwgXCJcXFxcdmNlbnRjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25cIiwgXCJcXFxcZGJsY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmVxdWFsc1wiLCBcIlxcXFxjb2xvbmVxcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25lcXVhbHNcIiwgXCJcXFxcQ29sb25lcXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxlcXVhbHNjb2xvblwiLCBcIlxcXFxlcXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVxdWFsc2NvbG9uY29sb25cIiwgXCJcXFxcRXFxY29sb25cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbm1pbnVzXCIsIFwiXFxcXGNvbG9uZXFcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb2xvbmNvbG9ubWludXNcIiwgXCJcXFxcQ29sb25lcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnVzY29sb25cIiwgXCJcXFxcZXFjb2xvblwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1pbnVzY29sb25jb2xvblwiLCBcIlxcXFxFcWNvbG9uXCIpO1xuLy8gXFxjb2xvbmFwcHJveCBuYW1lIGlzIHNhbWUgaW4gbWF0aHRvb2xzIGFuZCBjb2xvbmVxdWFscy5cbmRlZmluZU1hY3JvKFwiXFxcXGNvbG9uY29sb25hcHByb3hcIiwgXCJcXFxcQ29sb25hcHByb3hcIik7XG4vLyBcXGNvbG9uc2ltIG5hbWUgaXMgc2FtZSBpbiBtYXRodG9vbHMgYW5kIGNvbG9uZXF1YWxzLlxuZGVmaW5lTWFjcm8oXCJcXFxcY29sb25jb2xvbnNpbVwiLCBcIlxcXFxDb2xvbnNpbVwiKTtcblxuLy8gUHJlc2VudCBpbiBuZXd0eG1hdGgsIHB4Zm9udHMgYW5kIHR4Zm9udHNcbmRlZmluZU1hY3JvKFwiXFxcXG5vdG5pXCIsIFwiXFxcXG1hdGhyZWx7XFxcXGNoYXJgXFx1MjIwQ31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsaW1zdXBcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntsaW1cXFxcLHN1cH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsaW1pbmZcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntsaW1cXFxcLGluZn1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEZyb20gYW1zb3BuLnN0eVxuZGVmaW5lTWFjcm8oXCJcXFxcaW5qbGltXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7aW5qXFxcXCxsaW19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHJvamxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe3Byb2pcXFxcLGxpbX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJsaW1zdXBcIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcb3ZlcmxpbmV7XFxcXHRleHR7bGltfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFybGltaW5mXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7XFxcXHVuZGVybGluZXtcXFxcdGV4dHtsaW19fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2YXJpbmpsaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJyaWdodGFycm93e1xcXFx0ZXh0e2xpbX19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcnByb2psaW1cIiwgXCJcXFxcRE9UU0JcXFxcb3BlcmF0b3JuYW1lKntcXFxcdW5kZXJsZWZ0YXJyb3d7XFxcXHRleHR7bGltfX19XCIpO1xuXG5kZWZpbmVNYWNybyhcIlxcXFxjZW50ZXJkb3RcIiwgXCJ7XFxcXG1lZHNwYWNlXFxcXHJ1bGV7MC4xNjdlbX17MC4xODllbX1cXFxcbWVkc3BhY2V9XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBzdGF0bWF0aC5zdHlcbi8vIGh0dHBzOi8vY3Rhbi5tYXRoLmlsbGlub2lzLmVkdS9tYWNyb3MvbGF0ZXgvY29udHJpYi9zdGF0bWF0aC9zdGF0bWF0aC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWluXCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtaW59XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYXJnbWF4XCIsIFwiXFxcXERPVFNCXFxcXG9wZXJhdG9ybmFtZSp7YXJnXFxcXCxtYXh9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGxpbVwiLCBcIlxcXFxET1RTQlxcXFxvcGVyYXRvcm5hbWUqe3BsaW19XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNblN5bWJvbC5zdHlcblxuZGVmaW5lTWFjcm8oXCJcXFxcbGVmdG1vZGVsc1wiLCBcIlxcXFxtYXRob3B7XFxcXHJlZmxlY3Rib3h7JFxcXFxtb2RlbHMkfX1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGJyYWtldC5zdHlcbi8vIGh0dHA6Ly9jdGFuLm1hdGgud2FzaGluZ3Rvbi5lZHUvdGV4LWFyY2hpdmUvbWFjcm9zL2xhdGV4L2NvbnRyaWIvYnJha2V0L2JyYWtldC5wZGZcblxuZGVmaW5lTWFjcm8oXCJcXFxcYnJhXCIsIFwiXFxcXG1hdGhpbm5lcntcXFxcbGFuZ2xleyMxfXx9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxca2V0XCIsIFwiXFxcXG1hdGhpbm5lcnt8eyMxfVxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnJha2V0XCIsIFwiXFxcXG1hdGhpbm5lcntcXFxcbGFuZ2xleyMxfVxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcQnJhXCIsIFwiXFxcXGxlZnRcXFxcbGFuZ2xlIzFcXFxccmlnaHR8XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcS2V0XCIsIFwiXFxcXGxlZnR8IzFcXFxccmlnaHRcXFxccmFuZ2xlXCIpO1xuLy8gQSBoZWxwZXIgZm9yIFxcQnJha2V0IGFuZCBcXFNldFxuY29uc3QgcmVwbGFjZVZlcnQgPSAoYXJnU3RyLCBtYXRjaCkgPT4ge1xuICBjb25zdCBjaCA9IG1hdGNoWzBdID09PSBcInxcIiA/IFwiXFxcXHZlcnRcIiA6IFwiXFxcXFZlcnRcIjtcbiAgY29uc3QgcmVwbGFjZVN0ciA9IGB9XFxcXCxcXFxcbWlkZGxlJHtjaH1cXFxcLHtgO1xuICByZXR1cm4gYXJnU3RyLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIHJlcGxhY2VTdHIgKyBhcmdTdHIuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpXG59O1xuZGVmaW5lTWFjcm8oXCJcXFxcQnJha2V0XCIsICBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGxldCBhcmdTdHIgPSByZWNyZWF0ZUFyZ1N0cihjb250ZXh0KTtcbiAgY29uc3QgcmVnRXggPSAvXFx8XFx8fFxcfHxcXFxcXFx8L2c7XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHJlZ0V4LmV4ZWMoYXJnU3RyKSkgIT09IG51bGwpIHtcbiAgICBhcmdTdHIgPSByZXBsYWNlVmVydChhcmdTdHIsIG1hdGNoKTtcbiAgfVxuICByZXR1cm4gXCJcXFxcbGVmdFxcXFxsYW5nbGV7XCIgKyBhcmdTdHIgKyBcIn1cXFxccmlnaHRcXFxccmFuZ2xlXCJcbn0pO1xuZGVmaW5lTWFjcm8oXCJcXFxcU2V0XCIsICBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGxldCBhcmdTdHIgPSByZWNyZWF0ZUFyZ1N0cihjb250ZXh0KTtcbiAgY29uc3QgbWF0Y2ggPSAvXFx8XFx8fFxcfHxcXFxcXFx8Ly5leGVjKGFyZ1N0cik7XG4gIGlmIChtYXRjaCkge1xuICAgIGFyZ1N0ciA9IHJlcGxhY2VWZXJ0KGFyZ1N0ciwgbWF0Y2gpO1xuICB9XG4gIHJldHVybiBcIlxcXFxsZWZ0XFxcXHtcXFxcOntcIiArIGFyZ1N0ciArIFwifVxcXFw6XFxcXHJpZ2h0XFxcXH1cIlxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxzZXRcIiwgIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgY29uc3QgYXJnU3RyID0gcmVjcmVhdGVBcmdTdHIoY29udGV4dCk7XG4gIHJldHVybiBcIlxcXFx7e1wiICsgYXJnU3RyLnJlcGxhY2UoL1xcfC8sIFwifVxcXFxtaWR7XCIpICsgXCJ9XFxcXH1cIlxufSk7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGFjdHVhcmlhbGFuZ2xlLmR0eFxuZGVmaW5lTWFjcm8oXCJcXFxcYW5nbG5cIiwgXCJ7XFxcXGFuZ2wgbn1cIik7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGRlcml2YXRpdmUuc3R5XG5kZWZpbmVNYWNybyhcIlxcXFxvZHZcIiwgXCJcXFxcQGlmc3RhclxcXFxvZHZAbmV4dFxcXFxvZHZAbnVtZXJhdG9yXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcb2R2QG51bWVyYXRvclwiLCBcIlxcXFxmcmFje1xcXFxtYXRocm17ZH0jMX17XFxcXG1hdGhybXtkfSMyfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG9kdkBuZXh0XCIsIFwiXFxcXGZyYWN7XFxcXG1hdGhybXtkfX17XFxcXG1hdGhybXtkfSMyfSMxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccGR2XCIsIFwiXFxcXEBpZnN0YXJcXFxccGR2QG5leHRcXFxccGR2QG51bWVyYXRvclwiKTtcblxuY29uc3QgcGR2SGVscGVyID0gYXJncyA9PiB7XG4gIGNvbnN0IG51bWVyYXRvciA9IGFyZ3NbMF1bMF0udGV4dDtcbiAgY29uc3QgZGVub21zID0gc3RyaW5nRnJvbUFyZyhhcmdzWzFdKS5zcGxpdChcIixcIik7XG4gIGNvbnN0IHBvd2VyID0gU3RyaW5nKGRlbm9tcy5sZW5ndGgpO1xuICBjb25zdCBudW1PcCA9IHBvd2VyID09PSBcIjFcIiA/IFwiXFxcXHBhcnRpYWxcIiA6IGBcXFxccGFydGlhbF4ke3Bvd2VyfWA7XG4gIGxldCBkZW5vbWluYXRvciA9IFwiXCI7XG4gIGRlbm9tcy5tYXAoZSA9PiB7IGRlbm9taW5hdG9yICs9IFwiXFxcXHBhcnRpYWwgXCIgKyBlLnRyaW0oKSArICBcIlxcXFwsXCI7fSk7XG4gIHJldHVybiBbbnVtZXJhdG9yLCBudW1PcCwgIGRlbm9taW5hdG9yLnJlcGxhY2UoL1xcXFwsJC8sIFwiXCIpXVxufTtcbmRlZmluZU1hY3JvKFwiXFxcXHBkdkBudW1lcmF0b3JcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICBjb25zdCBbbnVtZXJhdG9yLCBudW1PcCwgZGVub21pbmF0b3JdID0gcGR2SGVscGVyKGNvbnRleHQuY29uc3VtZUFyZ3MoMikpO1xuICByZXR1cm4gYFxcXFxmcmFjeyR7bnVtT3B9ICR7bnVtZXJhdG9yfX17JHtkZW5vbWluYXRvcn19YFxufSk7XG5kZWZpbmVNYWNybyhcIlxcXFxwZHZAbmV4dFwiLCBmdW5jdGlvbihjb250ZXh0KSB7XG4gIGNvbnN0IFtudW1lcmF0b3IsIG51bU9wLCBkZW5vbWluYXRvcl0gPSBwZHZIZWxwZXIoY29udGV4dC5jb25zdW1lQXJncygyKSk7XG4gIHJldHVybiBgXFxcXGZyYWN7JHtudW1PcH19eyR7ZGVub21pbmF0b3J9fSAke251bWVyYXRvcn1gXG59KTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdXBncmVlay5kdHhcbmRlZmluZU1hY3JvKFwiXFxcXHVwYWxwaGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGFscGhhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwYmV0YVwiLCBcIlxcXFx1cEBncmVla3tcXFxcYmV0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGdhbW1hXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxnYW1tYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGRlbHRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxkZWx0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGVwc2lsb25cIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGVwc2lsb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXB6ZXRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFx6ZXRhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwZXRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxldGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXB0aGV0YVwiLCBcIlxcXFx1cEBncmVla3tcXFxcdGhldGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBpb3RhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxpb3RhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwa2FwcGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGthcHBhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwbGFtYmRhXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxsYW1iZGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBtdVwiLCBcIlxcXFx1cEBncmVla3tcXFxcbXV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBudVwiLCBcIlxcXFx1cEBncmVla3tcXFxcbnV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXB4aVwiLCBcIlxcXFx1cEBncmVla3tcXFxceGl9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBvbWljcm9uXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxvbWljcm9ufVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwcGlcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHBpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwYWxwaGFcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXGFscGhhfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwcmhvXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxyaG99XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBzaWdtYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcc2lnbWF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXB0YXVcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHRhdX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cHVwc2lsb25cIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHVwc2lsb259XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBwaGlcIiwgXCJcXFxcdXBAZ3JlZWt7XFxcXHBoaX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx1cGNoaVwiLCBcIlxcXFx1cEBncmVla3tcXFxcY2hpfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVwcHNpXCIsIFwiXFxcXHVwQGdyZWVre1xcXFxwc2l9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdXBvbWVnYVwiLCBcIlxcXFx1cEBncmVla3tcXFxcb21lZ2F9XCIpO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjbWxsIHBhY2thZ2VcbmRlZmluZU1hY3JvKFwiXFxcXGludmFtcFwiLCAnXFxcXG1hdGhiaW57XFxcXGNoYXJcIjIxNGJ9Jyk7XG5kZWZpbmVNYWNybyhcIlxcXFxwYXJyXCIsICdcXFxcbWF0aGJpbntcXFxcY2hhclwiMjE0Yn0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXHdpdGhcIiwgJ1xcXFxtYXRoYmlue1xcXFxjaGFyXCIyNn0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXG11bHRpbWFwaW52XCIsICdcXFxcbWF0aHJlbHtcXFxcY2hhclwiMjdkY30nKTtcbmRlZmluZU1hY3JvKFwiXFxcXG11bHRpbWFwYm90aFwiLCAnXFxcXG1hdGhyZWx7XFxcXGNoYXJcIjI5ZGZ9Jyk7XG5kZWZpbmVNYWNybyhcIlxcXFxzY29oXCIsICd7XFxcXG1rZXJuNW11XFxcXGNoYXJcIjIzMjJcXFxcbWtlcm41bXV9Jyk7XG5kZWZpbmVNYWNybyhcIlxcXFxzaW5jb2hcIiwgJ3tcXFxcbWtlcm41bXVcXFxcY2hhclwiMjMyM1xcXFxta2VybjVtdX0nKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNvaFwiLCBge1xcXFxta2VybjVtdVxcXFxydWxle317MC43ZW19XFxcXG1hdGhybGFwe1xcXFxzbWFzaHtcXFxccmFpc2UybXV7XFxcXGNoYXJcIjIzMjJ9fX1cbntcXFxcc21hc2h7XFxcXGxvd2VyNG11e1xcXFxjaGFyXCIyMzIzfX19XFxcXG1rZXJuNW11fWApO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW5jb2hcIiwgYHtcXFxcbWtlcm41bXVcXFxccnVsZXt9ezAuN2VtfVxcXFxtYXRocmxhcHtcXFxcc21hc2h7XFxcXHJhaXNlMm11e1xcXFxjaGFyXCIyMzIzfX19XG57XFxcXHNtYXNoe1xcXFxsb3dlcjRtdXtcXFxcY2hhclwiMjMyMn19fVxcXFxta2VybjVtdX1gKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjaGVtc3R5bGUgcGFja2FnZVxuZGVmaW5lTWFjcm8oXCJcXFxcc3RhbmRhcmRzdGF0ZVwiLCBcIlxcXFx0ZXh0e1xcXFx0aW55XFxcXGNoYXJg4qa1fVwiKTtcblxu77u/LyogZXNsaW50LWRpc2FibGUgKi9cbi8qIC0qLSBNb2RlOiBKYXZhU2NyaXB0OyBpbmRlbnQtdGFicy1tb2RlOm5pbDsganMtaW5kZW50LWxldmVsOiAyIC0qLSAqL1xuLyogdmltOiBzZXQgdHM9MiBldCBzdz0yIHR3PTgwOiAqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcbiAqICBUZW1tbCBtaGNoZW0uanNcbiAqXG4gKiAgVGhpcyBmaWxlIGltcGxlbWVudHMgYSBUZW1tbCB2ZXJzaW9uIG9mIG1oY2hlbSB2ZXJzaW9uIDMuMy4wLlxuICogIEl0IGlzIGFkYXB0ZWQgZnJvbSBNYXRoSmF4L2V4dGVuc2lvbnMvVGVYL21oY2hlbS5qc1xuICogIEl0IGRpZmZlcnMgZnJvbSB0aGUgTWF0aEpheCB2ZXJzaW9uIGFzIGZvbGxvd3M6XG4gKiAgICAxLiBUaGUgaW50ZXJmYWNlIGlzIGNoYW5nZWQgc28gdGhhdCBpdCBjYW4gYmUgY2FsbGVkIGZyb20gVGVtbWwsIG5vdCBNYXRoSmF4LlxuICogICAgMi4gXFxybGFwIGFuZCBcXGxsYXAgYXJlIHJlcGxhY2VkIHdpdGggXFxtYXRocmxhcCBhbmQgXFxtYXRobGxhcC5cbiAqICAgIDMuIFRoZSByZWFjdGlvbiBhcnJvdyBjb2RlIGlzIHNpbXBsaWZpZWQuIEFsbCByZWFjdGlvbiBhcnJvd3MgYXJlIHJlbmRlcmVkXG4gKiAgICAgICB1c2luZyBUZW1tbCBleHRlbnNpYmxlIGFycm93cyBpbnN0ZWFkIG9mIGJ1aWxkaW5nIG5vbi1leHRlbnNpYmxlIGFycm93cy5cbiAqICAgIDQuIFRoZSB+Ym9uZCBmb3JtcyBhcmUgY29tcG9zZWQgZW50aXJlbHkgb2YgXFxydWxlIGVsZW1lbnRzLlxuICogICAgNS4gVHdvIGRhc2hlcyBpbiBfZ2V0Qm9uZCBhcmUgd3JhcHBlZCBpbiBicmFjZXMgdG8gc3VwcHJlc3Mgc3BhY2luZy4gaS5lLiwgey19XG4gKiAgICA2LiBUaGUgZWxlY3Ryb24gZG90IHVzZXMgXFx0ZXh0YnVsbGV0IGluc3RlYWQgb2YgXFxidWxsZXQuXG4gKiAgICA3LiBcXHNtYXNoW1RdIGhhcyBiZWVuIHJlbW92ZWQuIChXZWJLaXQgaGlkZXMgYW55dGhpbmcgaW5zaWRlIFxcc21hc2h74oCmfSlcbiAqXG4gKiAgICBUaGlzIGNvZGUsIGFzIG90aGVyIFRlbW1sIGNvZGUsIGlzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIFxuICogLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqXG4gKiAgTWF0aEpheC9leHRlbnNpb25zL1RlWC9taGNoZW0uanNcbiAqXG4gKiAgSW1wbGVtZW50cyB0aGUgXFxjZSBjb21tYW5kIGZvciBoYW5kbGluZyBjaGVtaWNhbCBmb3JtdWxhc1xuICogIGZyb20gdGhlIG1oY2hlbSBMYVRlWCBwYWNrYWdlLlxuICpcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgQ29weXJpZ2h0IChjKSAyMDExLTIwMTUgVGhlIE1hdGhKYXggQ29uc29ydGl1bVxuICogIENvcHlyaWdodCAoYykgMjAxNS0yMDE4IE1hcnRpbiBIZW5zZWxcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy9cbi8vIENvZGluZyBTdHlsZVxuLy8gICAtIHVzZSAnJyBmb3IgaWRlbnRpZmllcnMgdGhhdCBjYW4gYnkgbWluaWZpZWQvdWdsaWZpZWRcbi8vICAgLSB1c2UgXCJcIiBmb3Igc3RyaW5ncyB0aGF0IG5lZWQgdG8gc3RheSB1bnRvdWNoZWRcblxuLy8gdmVyc2lvbjogXCIzLjMuMFwiIGZvciBNYXRoSmF4IGFuZCBUZW1tbFxuXG5cbi8vIEFkZCBcXGNlLCBcXHB1LCBhbmQgXFx0cmlwbGVEYXNoIHRvIHRoZSBUZW1tbCBtYWNyb3MuXG5cbmRlZmluZU1hY3JvKFwiXFxcXGNlXCIsIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIGNoZW1QYXJzZShjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdLCBcImNlXCIpXG59KTtcblxuZGVmaW5lTWFjcm8oXCJcXFxccHVcIiwgZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gY2hlbVBhcnNlKGNvbnRleHQuY29uc3VtZUFyZ3MoMSlbMF0sIFwicHVcIik7XG59KTtcblxuLy8gTWF0aCBmb250cyBkbyBub3QgaW5jbHVkZSBnbHlwaHMgZm9yIHRoZSB+IGZvcm0gb2YgYm9uZHMuIFNvIHdlJ2xsIHNlbmQgcGF0aCBnZW9tZXRyeVxuLy8gU28gd2UnbGwgY29tcG9zZSBjaGFyYWN0ZXJzIGJ1aWx0IGZyb20gXFxydWxlIGVsZW1lbnRzLlxuZGVmaW5lTWFjcm8oXCJcXFxcdW5pRGFzaFwiLCBge1xcXFxydWxlezAuNjcyZW19ezAuMDZlbX19YClcbmRlZmluZU1hY3JvKFwiXFxcXHRyaURhc2hcIiwgYHtcXFxccnVsZXswLjE1ZW19ezAuMDZlbX1cXFxca2VybjJtdVxcXFxydWxlezAuMTVlbX17MC4wNmVtfVxcXFxrZXJuMm11XFxcXHJ1bGV7MC4xNWVtfXswLjA2ZW19fWApXG5kZWZpbmVNYWNybyhcIlxcXFx0cmlwbGVEYXNoXCIsIGBcXFxca2VybjAuMDc1ZW1cXFxccmFpc2UwLjI1ZW17XFxcXHRyaURhc2h9XFxcXGtlcm4wLjA3NWVtYClcbmRlZmluZU1hY3JvKFwiXFxcXHRyaXBsZURhc2hPdmVyTGluZVwiLCBgXFxcXGtlcm4wLjA3NWVtXFxcXG1hdGhybGFwe1xcXFxyYWlzZTAuMTI1ZW17XFxcXHVuaURhc2h9fVxcXFxyYWlzZTAuMzRlbXtcXFxcdHJpRGFzaH1cXFxca2VybjAuMDc1ZW1gKVxuZGVmaW5lTWFjcm8oXCJcXFxcdHJpcGxlRGFzaE92ZXJEb3VibGVMaW5lXCIsIGBcXFxca2VybjAuMDc1ZW1cXFxcbWF0aHJsYXB7XFxcXG1hdGhybGFwe1xcXFxyYWlzZTAuNDhlbXtcXFxcdHJpRGFzaH19XFxcXHJhaXNlMC4yN2Vte1xcXFx1bmlEYXNofX17XFxcXHJhaXNlMC4wNWVte1xcXFx1bmlEYXNofX1cXFxca2VybjAuMDc1ZW1gKVxuZGVmaW5lTWFjcm8oXCJcXFxcdHJpcGxlRGFzaEJldHdlZW5Eb3VibGVMaW5lXCIsIGBcXFxca2VybjAuMDc1ZW1cXFxcbWF0aHJsYXB7XFxcXG1hdGhybGFwe1xcXFxyYWlzZTAuNDhlbXtcXFxcdW5pRGFzaH19XFxcXHJhaXNlMC4yN2Vte1xcXFx0cmlEYXNofX17XFxcXHJhaXNlMC4wNWVte1xcXFx1bmlEYXNofX1cXFxca2VybjAuMDc1ZW1gKVxuXG4gIC8vXG4gIC8vICBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciBoYW5kaW5nIHRoZSBcXGNlIGFuZCBcXHB1IGNvbW1hbmRzLlxuICAvLyAgSXQgdGFrZXMgdGhlIGFyZ3VtZW50IHRvIFxcY2Ugb3IgXFxwdSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBUZVggc3RyaW5nLlxuICAvL1xuXG4gIHZhciBjaGVtUGFyc2UgPSBmdW5jdGlvbiAodG9rZW5zLCBzdGF0ZU1hY2hpbmUpIHtcbiAgICAvLyBSZWNyZWF0ZSB0aGUgYXJndW1lbnQgc3RyaW5nIGZyb20gVGVtbWwncyBhcnJheSBvZiB0b2tlbnMuXG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGV4cGVjdGVkTG9jID0gdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLmxvYy5zdGFydFxuICAgIGZvciAodmFyIGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmKHRva2Vuc1tpXS5sb2Muc3RhcnQgPiBleHBlY3RlZExvYykge1xuICAgICAgICAvLyBjb250ZXh0LmNvbnN1bWVBcmdzIGhhcyBlYXRlbiBhIHNwYWNlLlxuICAgICAgICBzdHIgKz0gXCIgXCI7XG4gICAgICAgIGV4cGVjdGVkTG9jID0gdG9rZW5zW2ldLmxvYy5zdGFydDtcbiAgICAgIH1cbiAgICAgIHN0ciArPSB0b2tlbnNbaV0udGV4dDtcbiAgICAgIGV4cGVjdGVkTG9jICs9IHRva2Vuc1tpXS50ZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgLy8gQ2FsbCB0aGUgbWhjaGVtIGNvcmUgcGFyc2VyLlxuICAgIHZhciB0ZXggPSB0ZXhpZnkuZ28obWhjaGVtUGFyc2VyLmdvKHN0ciwgc3RhdGVNYWNoaW5lKSk7XG4gICAgcmV0dXJuIHRleDtcbiAgfTtcblxuICAvL1xuICAvLyBDb3JlIHBhcnNlciBmb3IgbWhjaGVtIHN5bnRheCAgKHJlY3Vyc2l2ZSlcbiAgLy9cbiAgLyoqIEB0eXBlIHtNaGNoZW1QYXJzZXJ9ICovXG4gIHZhciBtaGNoZW1QYXJzZXIgPSB7XG4gICAgLy9cbiAgICAvLyBQYXJzZXMgbWNoZW0gXFxjZSBzeW50YXhcbiAgICAvL1xuICAgIC8vIENhbGwgbGlrZVxuICAgIC8vICAgZ28oXCJIMk9cIik7XG4gICAgLy9cbiAgICBnbzogZnVuY3Rpb24gKGlucHV0LCBzdGF0ZU1hY2hpbmUpIHtcbiAgICAgIGlmICghaW5wdXQpIHsgcmV0dXJuIFtdOyB9XG4gICAgICBpZiAoc3RhdGVNYWNoaW5lID09PSB1bmRlZmluZWQpIHsgc3RhdGVNYWNoaW5lID0gJ2NlJzsgfVxuICAgICAgdmFyIHN0YXRlID0gJzAnO1xuXG4gICAgICAvL1xuICAgICAgLy8gU3RyaW5nIGJ1ZmZlcnMgZm9yIHBhcnNpbmc6XG4gICAgICAvL1xuICAgICAgLy8gYnVmZmVyLmEgPT0gYW1vdW50XG4gICAgICAvLyBidWZmZXIubyA9PSBlbGVtZW50XG4gICAgICAvLyBidWZmZXIuYiA9PSBsZWZ0LXNpZGUgc3VwZXJzY3JpcHRcbiAgICAgIC8vIGJ1ZmZlci5wID09IGxlZnQtc2lkZSBzdWJzY3JpcHRcbiAgICAgIC8vIGJ1ZmZlci5xID09IHJpZ2h0LXNpZGUgc3Vic2NyaXB0XG4gICAgICAvLyBidWZmZXIuZCA9PSByaWdodC1zaWRlIHN1cGVyc2NyaXB0XG4gICAgICAvL1xuICAgICAgLy8gYnVmZmVyLnIgPT0gYXJyb3dcbiAgICAgIC8vIGJ1ZmZlci5yZHQgPT0gYXJyb3csIHNjcmlwdCBhYm92ZSwgdHlwZVxuICAgICAgLy8gYnVmZmVyLnJkID09IGFycm93LCBzY3JpcHQgYWJvdmUsIGNvbnRlbnRcbiAgICAgIC8vIGJ1ZmZlci5ycXQgPT0gYXJyb3csIHNjcmlwdCBiZWxvdywgdHlwZVxuICAgICAgLy8gYnVmZmVyLnJxID09IGFycm93LCBzY3JpcHQgYmVsb3csIGNvbnRlbnRcbiAgICAgIC8vXG4gICAgICAvLyBidWZmZXIudGV4dF9cbiAgICAgIC8vIGJ1ZmZlci5ybVxuICAgICAgLy8gZXRjLlxuICAgICAgLy9cbiAgICAgIC8vIGJ1ZmZlci5wYXJlbnRoZXNpc0xldmVsID09IGludCwgc3RhcnRpbmcgYXQgMFxuICAgICAgLy8gYnVmZmVyLnNiID09IGJvb2wsIHNwYWNlIGJlZm9yZVxuICAgICAgLy8gYnVmZmVyLmJlZ2luc1dpdGhCb25kID09IGJvb2xcbiAgICAgIC8vXG4gICAgICAvLyBUaGVzZSBsZXR0ZXJzIGFyZSBhbHNvIHVzZWQgYXMgc3RhdGUgbmFtZXMuXG4gICAgICAvL1xuICAgICAgLy8gT3RoZXIgc3RhdGVzOlxuICAgICAgLy8gMCA9PSBiZWdpbiBvZiBtYWluIHBhcnQgKGFycm93L29wZXJhdG9yIHVubGlrZWx5KVxuICAgICAgLy8gMSA9PSBuZXh0IGVudGl0eVxuICAgICAgLy8gMiA9PSBuZXh0IGVudGl0eSAoYXJyb3cvb3BlcmF0b3IgdW5saWtlbHkpXG4gICAgICAvLyAzID09IG5leHQgYXRvbVxuICAgICAgLy8gYyA9PSBtYWNyb1xuICAgICAgLy9cbiAgICAgIC8qKiBAdHlwZSB7QnVmZmVyfSAqL1xuICAgICAgdmFyIGJ1ZmZlciA9IHt9O1xuICAgICAgYnVmZmVyWydwYXJlbnRoZXNpc0xldmVsJ10gPSAwO1xuXG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1xcbi9nLCBcIiBcIik7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1tcXHUyMjEyXFx1MjAxM1xcdTIwMTRcXHUyMDEwXS9nLCBcIi1cIik7XG4gICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1tcXHUyMDI2XS9nLCBcIi4uLlwiKTtcblxuICAgICAgLy9cbiAgICAgIC8vIExvb2tzIHRocm91Z2ggbWhjaGVtUGFyc2VyLnRyYW5zaXRpb25zLCB0byBleGVjdXRlIGEgbWF0Y2hpbmcgYWN0aW9uXG4gICAgICAvLyAocmVjdXJzaXZlKVxuICAgICAgLy9cbiAgICAgIHZhciBsYXN0SW5wdXQ7XG4gICAgICB2YXIgd2F0Y2hkb2cgPSAxMDtcbiAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAobGFzdElucHV0ICE9PSBpbnB1dCkge1xuICAgICAgICAgIHdhdGNoZG9nID0gMTA7XG4gICAgICAgICAgbGFzdElucHV0ID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2F0Y2hkb2ctLTtcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyBGaW5kIGFjdGlvbnMgaW4gdHJhbnNpdGlvbiB0YWJsZVxuICAgICAgICAvL1xuICAgICAgICB2YXIgbWFjaGluZSA9IG1oY2hlbVBhcnNlci5zdGF0ZU1hY2hpbmVzW3N0YXRlTWFjaGluZV07XG4gICAgICAgIHZhciB0ID0gbWFjaGluZS50cmFuc2l0aW9uc1tzdGF0ZV0gfHwgbWFjaGluZS50cmFuc2l0aW9uc1snKiddO1xuICAgICAgICBpdGVyYXRlVHJhbnNpdGlvbnM6XG4gICAgICAgIGZvciAodmFyIGk9MDsgaTx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG1hdGNoZXMgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKHRbaV0ucGF0dGVybiwgaW5wdXQpO1xuICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSBhY3Rpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0W2ldLnRhc2s7XG4gICAgICAgICAgICBmb3IgKHZhciBpQT0wOyBpQTx0YXNrLmFjdGlvbl8ubGVuZ3RoOyBpQSsrKSB7XG4gICAgICAgICAgICAgIHZhciBvO1xuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBGaW5kIGFuZCBleGVjdXRlIGFjdGlvblxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICBpZiAobWFjaGluZS5hY3Rpb25zW3Rhc2suYWN0aW9uX1tpQV0udHlwZV9dKSB7XG4gICAgICAgICAgICAgICAgbyA9IG1hY2hpbmUuYWN0aW9uc1t0YXNrLmFjdGlvbl9baUFdLnR5cGVfXShidWZmZXIsIG1hdGNoZXMubWF0Y2hfLCB0YXNrLmFjdGlvbl9baUFdLm9wdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobWhjaGVtUGFyc2VyLmFjdGlvbnNbdGFzay5hY3Rpb25fW2lBXS50eXBlX10pIHtcbiAgICAgICAgICAgICAgICBvID0gbWhjaGVtUGFyc2VyLmFjdGlvbnNbdGFzay5hY3Rpb25fW2lBXS50eXBlX10oYnVmZmVyLCBtYXRjaGVzLm1hdGNoXywgdGFzay5hY3Rpb25fW2lBXS5vcHRpb24pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z0FcIiwgXCJtaGNoZW0gYnVnIEEuIFBsZWFzZSByZXBvcnQuIChcIiArIHRhc2suYWN0aW9uX1tpQV0udHlwZV8gKyBcIilcIl07ICAvLyBUcnlpbmcgdG8gdXNlIG5vbi1leGlzdGluZyBhY3Rpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBBZGQgb3V0cHV0XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIG1oY2hlbVBhcnNlci5jb25jYXRBcnJheShvdXRwdXQsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFNldCBuZXh0IHN0YXRlLFxuICAgICAgICAgICAgLy8gU2hvcnRlbiBpbnB1dCxcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGggbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIC8vICAgKD0gYXBwbHkgb25seSBvbmUgdHJhbnNpdGlvbiBwZXIgcG9zaXRpb24pXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgc3RhdGUgPSB0YXNrLm5leHRTdGF0ZSB8fCBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGlmICghdGFzay5yZXZpc2l0KSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBtYXRjaGVzLnJlbWFpbmRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXRhc2sudG9Db250aW51ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrIGl0ZXJhdGVUcmFuc2l0aW9ucztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wXG4gICAgICAgIC8vXG4gICAgICAgIGlmICh3YXRjaGRvZyA8PSAwKSB7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnVVwiLCBcIm1oY2hlbSBidWcgVS4gUGxlYXNlIHJlcG9ydC5cIl07ICAvLyBVbmV4cGVjdGVkIGNoYXJhY3RlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25jYXRBcnJheTogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaUI9MDsgaUI8Yi5sZW5ndGg7IGlCKyspIHtcbiAgICAgICAgICAgIGEucHVzaChiW2lCXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEucHVzaChiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwYXR0ZXJuczoge1xuICAgICAgLy9cbiAgICAgIC8vIE1hdGNoaW5nIHBhdHRlcm5zXG4gICAgICAvLyBlaXRoZXIgcmVnZXhwcyBvciBmdW5jdGlvbiB0aGF0IHJldHVybiBudWxsIG9yIHttYXRjaF86XCJhXCIsIHJlbWFpbmRlcjpcImJjXCJ9XG4gICAgICAvL1xuICAgICAgcGF0dGVybnM6IHtcbiAgICAgICAgLy8gcHJvcGVydHkgbmFtZXMgbXVzdCBub3QgbG9vayBsaWtlIGludGVnZXJzIChcIjJcIikgZm9yIGNvcnJlY3QgcHJvcGVydHkgdHJhdmVyc2FsIG9yZGVyLCBsYXRlciBvblxuICAgICAgICAnZW1wdHknOiAvXiQvLFxuICAgICAgICAnZWxzZSc6IC9eLi8sXG4gICAgICAgICdlbHNlMic6IC9eLi8sXG4gICAgICAgICdzcGFjZSc6IC9eXFxzLyxcbiAgICAgICAgJ3NwYWNlIEEnOiAvXlxccyg/PVtBLVpcXFxcJF0pLyxcbiAgICAgICAgJ3NwYWNlJCc6IC9eXFxzJC8sXG4gICAgICAgICdhLXonOiAvXlthLXpdLyxcbiAgICAgICAgJ3gnOiAvXngvLFxuICAgICAgICAneCQnOiAvXngkLyxcbiAgICAgICAgJ2kkJzogL15pJC8sXG4gICAgICAgICdsZXR0ZXJzJzogL14oPzpbYS16QS1aXFx1MDNCMS1cXHUwM0M5XFx1MDM5MS1cXHUwM0E5P0BdfCg/OlxcXFwoPzphbHBoYXxiZXRhfGdhbW1hfGRlbHRhfGVwc2lsb258emV0YXxldGF8dGhldGF8aW90YXxrYXBwYXxsYW1iZGF8bXV8bnV8eGl8b21pY3JvbnxwaXxyaG98c2lnbWF8dGF1fHVwc2lsb258cGhpfGNoaXxwc2l8b21lZ2F8R2FtbWF8RGVsdGF8VGhldGF8TGFtYmRhfFhpfFBpfFNpZ21hfFVwc2lsb258UGhpfFBzaXxPbWVnYSkoPzpcXHMrfFxce1xcfXwoPyFbYS16QS1aXSkpKSkrLyxcbiAgICAgICAgJ1xcXFxncmVlayc6IC9eXFxcXCg/OmFscGhhfGJldGF8Z2FtbWF8ZGVsdGF8ZXBzaWxvbnx6ZXRhfGV0YXx0aGV0YXxpb3RhfGthcHBhfGxhbWJkYXxtdXxudXx4aXxvbWljcm9ufHBpfHJob3xzaWdtYXx0YXV8dXBzaWxvbnxwaGl8Y2hpfHBzaXxvbWVnYXxHYW1tYXxEZWx0YXxUaGV0YXxMYW1iZGF8WGl8UGl8U2lnbWF8VXBzaWxvbnxQaGl8UHNpfE9tZWdhKSg/Olxccyt8XFx7XFx9fCg/IVthLXpBLVpdKSkvLFxuICAgICAgICAnb25lIGxvd2VyY2FzZSBsYXRpbiBsZXR0ZXIgJCc6IC9eKD86KFthLXpdKSg/OiR8W15hLXpBLVpdKSkkLyxcbiAgICAgICAgJyRvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciQgJCc6IC9eXFwkKD86KFthLXpdKSg/OiR8W15hLXpBLVpdKSlcXCQkLyxcbiAgICAgICAgJ29uZSBsb3dlcmNhc2UgZ3JlZWsgbGV0dGVyICQnOiAvXig/OlxcJD9bXFx1MDNCMS1cXHUwM0M5XVxcJD98XFwkP1xcXFwoPzphbHBoYXxiZXRhfGdhbW1hfGRlbHRhfGVwc2lsb258emV0YXxldGF8dGhldGF8aW90YXxrYXBwYXxsYW1iZGF8bXV8bnV8eGl8b21pY3JvbnxwaXxyaG98c2lnbWF8dGF1fHVwc2lsb258cGhpfGNoaXxwc2l8b21lZ2EpXFxzKlxcJD8pKD86XFxzK3xcXHtcXH18KD8hW2EtekEtWl0pKSQvLFxuICAgICAgICAnZGlnaXRzJzogL15bMC05XSsvLFxuICAgICAgICAnLTkuLDknOiAvXlsrXFwtXT8oPzpbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKSkvLFxuICAgICAgICAnLTkuLDkgbm8gbWlzc2luZyAwJzogL15bK1xcLV0/WzAtOV0rKD86Wy4sXVswLTldKyk/LyxcbiAgICAgICAgJygtKSg5Liw5KShlKSg5OSknOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKFxcK1xcLXxcXCtcXC9cXC18XFwrfFxcLXxcXFxccG1cXHM/KT8oWzAtOV0rKD86WywuXVswLTldKyk/fFswLTldKig/OlxcLlswLTldKykpPyhcXCgoPzpbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKSlcXCkpPyg/OihbZUVdfFxccyooXFwqfHh8XFxcXHRpbWVzfFxcdTAwRDcpXFxzKjEwXFxeKShbK1xcLV0/WzAtOV0rfFxce1srXFwtXT9bMC05XStcXH0pKT8vKTtcbiAgICAgICAgICBpZiAobSAmJiBtWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG0uc3BsaWNlKDEpLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgICcoLSkoOSleKC05KSc6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgIHZhciBtID0gaW5wdXQubWF0Y2goL14oXFwrXFwtfFxcK1xcL1xcLXxcXCt8XFwtfFxcXFxwbVxccz8pPyhbMC05XSsoPzpbLC5dWzAtOV0rKT98WzAtOV0qKD86XFwuWzAtOV0rKT8pXFxeKFsrXFwtXT9bMC05XSt8XFx7WytcXC1dP1swLTldK1xcfSkvKTtcbiAgICAgICAgICBpZiAobSAmJiBtWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG0uc3BsaWNlKDEpLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbiAkJzogZnVuY3Rpb24gKGlucHV0KSB7ICAvLyAuLi4gb3IgY3J5c3RhbCBzeXN0ZW1cbiAgICAgICAgICB2YXIgYSA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgL15cXChbYS16XXsxLDN9KD89W1xcKSxdKS8sIFwiKVwiLCBcIlwiKTsgIC8vIChhcSksIChhcSwkXFxpbmZ0eSQpLCAoYXEsIHNhdClcbiAgICAgICAgICBpZiAoYSAgJiYgIGEucmVtYWluZGVyLm1hdGNoKC9eKCR8W1xccyw7XFwpXFxdXFx9XSkvKSkgeyByZXR1cm4gYTsgfSAgLy8gIEFORCBlbmQgb2YgJ3BocmFzZSdcbiAgICAgICAgICB2YXIgbSA9IGlucHV0Lm1hdGNoKC9eKD86XFwoKD86XFxcXGNhXFxzPyk/XFwkW2Ftb3RoY11cXCRcXCkpLyk7ICAvLyBPUiBjcnlzdGFsIHN5c3RlbSAoJG8kKSAoXFxjYSRjJClcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtWzBdLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgICdfeyhzdGF0ZSBvZiBhZ2dyZWdhdGlvbil9JCc6IC9eX1xceyhcXChbYS16XXsxLDN9XFwpKVxcfS8sXG4gICAgICAgICd7WygnOiAvXig/OlxcXFxcXHt8XFxbfFxcKCkvLFxuICAgICAgICAnKV19JzogL14oPzpcXCl8XFxdfFxcXFxcXH0pLyxcbiAgICAgICAgJywgJzogL15bLDtdXFxzKi8sXG4gICAgICAgICcsJzogL15bLDtdLyxcbiAgICAgICAgJy4nOiAvXlsuXS8sXG4gICAgICAgICcuICc6IC9eKFsuXFx1MjJDNVxcdTAwQjdcXHUyMDIyXSlcXHMqLyxcbiAgICAgICAgJy4uLic6IC9eXFwuXFwuXFwuKD89JHxbXi5dKS8sXG4gICAgICAgICcqICc6IC9eKFsqXSlcXHMqLyxcbiAgICAgICAgJ157KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXigkLi4uJCknOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJeXCIsIFwiJFwiLCBcIiRcIiwgXCJcIik7IH0sXG4gICAgICAgICdeYSc6IC9eXFxeKFswLTldK3xbXlxcXFxfXSkvLFxuICAgICAgICAnXlxcXFx4e317fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl5cIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIsIFwiXCIsIFwie1wiLCBcIn1cIiwgXCJcIiwgdHJ1ZSk7IH0sXG4gICAgICAgICdeXFxcXHh7fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl5cIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIpOyB9LFxuICAgICAgICAnXlxcXFx4JzogL15cXF4oXFxcXFthLXpBLVpdKylcXHMqLyxcbiAgICAgICAgJ14oLTEpJzogL15cXF4oLT9cXGQrKS8sXG4gICAgICAgICdcXCcnOiAvXicvLFxuICAgICAgICAnX3soLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJfe1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdfKCQuLi4kKSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl9cIiwgXCIkXCIsIFwiJFwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ185JzogL15fKFsrXFwtXT9bMC05XSt8W15cXFxcXSkvLFxuICAgICAgICAnX1xcXFx4e317fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl9cIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIsIFwiXCIsIFwie1wiLCBcIn1cIiwgXCJcIiwgdHJ1ZSk7IH0sXG4gICAgICAgICdfXFxcXHh7fSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIl9cIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIpOyB9LFxuICAgICAgICAnX1xcXFx4JzogL15fKFxcXFxbYS16QS1aXSspXFxzKi8sXG4gICAgICAgICdeXyc6IC9eKD86XFxeKD89Xyl8XFxfKD89XFxeKXxbXFxeX10kKS8sXG4gICAgICAgICd7fSc6IC9eXFx7XFx9LyxcbiAgICAgICAgJ3suLi59JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIFwie1wiLCBcIn1cIiwgXCJcIik7IH0sXG4gICAgICAgICd7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICckLi4uJCc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCBcIiRcIiwgXCIkXCIsIFwiXCIpOyB9LFxuICAgICAgICAnJHsoLi4uKX0kJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiJHtcIiwgXCJcIiwgXCJcIiwgXCJ9JFwiKTsgfSxcbiAgICAgICAgJyQoLi4uKSQnOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCIkXCIsIFwiXCIsIFwiXCIsIFwiJFwiKTsgfSxcbiAgICAgICAgJz08Pic6IC9eWz08Pl0vLFxuICAgICAgICAnIyc6IC9eWyNcXHUyMjYxXS8sXG4gICAgICAgICcrJzogL15cXCsvLFxuICAgICAgICAnLSQnOiAvXi0oPz1bXFxzX30sO1xcXS9dfCR8XFwoW2Etel0rXFwpKS8sICAvLyAtc3BhY2UgLSwgLTsgLV0gLS8gLSQgLXN0YXRlLW9mLWFnZ3JlZ2F0aW9uXG4gICAgICAgICctOSc6IC9eLSg/PVswLTldKS8sXG4gICAgICAgICctIG9yYml0YWwgb3ZlcmxhcCc6IC9eLSg/PSg/OltzcGRdfHNwKSg/OiR8W1xccyw7XFwpXFxdXFx9XSkpLyxcbiAgICAgICAgJy0nOiAvXi0vLFxuICAgICAgICAncG0tb3BlcmF0b3InOiAvXig/OlxcXFxwbXxcXCRcXFxccG1cXCR8XFwrLXxcXCtcXC8tKS8sXG4gICAgICAgICdvcGVyYXRvcic6IC9eKD86XFwrfCg/OltcXC09PD5dfDw8fD4+fFxcXFxhcHByb3h8XFwkXFxcXGFwcHJveFxcJCkoPz1cXHN8JHwtP1swLTldKSkvLFxuICAgICAgICAnYXJyb3dVcERvd24nOiAvXig/OnZ8XFwodlxcKXxcXF58XFwoXFxeXFwpKSg/PSR8W1xccyw7XFwpXFxdXFx9XSkvLFxuICAgICAgICAnXFxcXGJvbmR7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGJvbmR7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJy0+JzogL14oPzo8LT58PC0tPnwtPnw8LXw8PT4+fDw8PT58PD0+fFtcXHUyMTkyXFx1MjdGNlxcdTIxQ0NdKS8sXG4gICAgICAgICdDTVQnOiAvXltDTVRdKD89XFxbKS8sXG4gICAgICAgICdbKC4uLildJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiW1wiLCBcIlwiLCBcIlwiLCBcIl1cIik7IH0sXG4gICAgICAgICcxc3QtbGV2ZWwgZXNjYXBlJzogL14oJnxcXFxcXFxcXHxcXFxcaGxpbmUpXFxzKi8sXG4gICAgICAgICdcXFxcLCc6IC9eKD86XFxcXFssXFwgOzpdKS8sICAvLyBcXFxceCAtIGJ1dCBvdXRwdXQgbm8gc3BhY2UgYmVmb3JlXG4gICAgICAgICdcXFxceHt9e30nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcIiwgL15cXFxcW2EtekEtWl0rXFx7LywgXCJ9XCIsIFwiXCIsIFwiXCIsIFwie1wiLCBcIn1cIiwgXCJcIiwgdHJ1ZSk7IH0sXG4gICAgICAgICdcXFxceHt9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXCIsIC9eXFxcXFthLXpBLVpdK1xcey8sIFwifVwiLCBcIlwiKTsgfSxcbiAgICAgICAgJ1xcXFxjYSc6IC9eXFxcXGNhKD86XFxzK3woPyFbYS16QS1aXSkpLyxcbiAgICAgICAgJ1xcXFx4JzogL14oPzpcXFxcW2EtekEtWl0rXFxzKnxcXFxcW18me30lXSkvLFxuICAgICAgICAnb3JiaXRhbCc6IC9eKD86WzAtOV17MSwyfVtzcGRmZ2hdfFswLTldezAsMn1zcCkoPz0kfFteYS16QS1aXSkvLCAgLy8gb25seSB0aG9zZSB3aXRoIG51bWJlcnMgaW4gZnJvbnQsIGJlY2F1c2UgdGhlIG90aGVycyB3aWxsIGJlIGZvcm1hdHRlZCBjb3JyZWN0bHkgYW55d2F5XG4gICAgICAgICdvdGhlcnMnOiAvXltcXC9+fF0vLFxuICAgICAgICAnXFxcXGZyYWN7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGZyYWN7XCIsIFwiXCIsIFwiXCIsIFwifVwiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXG92ZXJzZXR7KC4uLil9JzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXG92ZXJzZXR7XCIsIFwiXCIsIFwiXCIsIFwifVwiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXHVuZGVyc2V0eyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFx1bmRlcnNldHtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcdW5kZXJicmFjZXsoLi4uKX0nOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcdW5kZXJicmFjZXtcIiwgXCJcIiwgXCJcIiwgXCJ9X1wiLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfTAnOiBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgXCJcXFxcY29sb3J7XCIsIFwiXCIsIFwiXCIsIFwifVwiKTsgfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX17KC4uLil9MSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxjb2xvcntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIsIFwie1wiLCBcIlwiLCBcIlwiLCBcIn1cIik7IH0sXG4gICAgICAgICdcXFxcY29sb3IoLi4uKXsoLi4uKX0yJzogZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBtaGNoZW1QYXJzZXIucGF0dGVybnMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQsIFwiXFxcXGNvbG9yXCIsIFwiXFxcXFwiLCBcIlwiLCAvXig/PVxceykvLCBcIntcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlxcXFxjZXtcIiwgXCJcIiwgXCJcIiwgXCJ9XCIpOyB9LFxuICAgICAgICAnb3hpZGF0aW9uJCc6IC9eKD86WystXVtJVlhdK3xcXFxccG1cXHMqMHxcXCRcXFxccG1cXCRcXHMqMCkkLyxcbiAgICAgICAgJ2Qtb3hpZGF0aW9uJCc6IC9eKD86WystXT9cXHM/W0lWWF0rfFxcXFxwbVxccyowfFxcJFxcXFxwbVxcJFxccyowKSQvLCAgLy8gMCBjb3VsZCBiZSBveGlkYXRpb24gb3IgY2hhcmdlXG4gICAgICAgICdyb21hbiBudW1lcmFsJzogL15bSVZYXSsvLFxuICAgICAgICAnMS8yJCc6IC9eWytcXC1dPyg/OlswLTldK3xcXCRbYS16XVxcJHxbYS16XSlcXC9bMC05XSsoPzpcXCRbYS16XVxcJHxbYS16XSk/JC8sXG4gICAgICAgICdhbW91bnQnOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgLy8gZS5nLiAyLCAwLjUsIDEvMiwgLTIsIG4vMiwgKzsgICRhJCBjb3VsZCBiZSBhZGRlZCBsYXRlciBpbiBwYXJzaW5nXG4gICAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaCgvXig/Oig/Oig/OlxcKFsrXFwtXT9bMC05XStcXC9bMC05XStcXCl8WytcXC1dPyg/OlswLTldK3xcXCRbYS16XVxcJHxbYS16XSlcXC9bMC05XSt8WytcXC1dP1swLTldK1suLF1bMC05XSt8WytcXC1dP1xcLlswLTldK3xbK1xcLV0/WzAtOV0rKSg/OlthLXpdKD89XFxzKltBLVpdKSk/KXxbK1xcLV0/W2Etel0oPz1cXHMqW0EtWl0pfFxcKyg/IVxccykpLyk7XG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1hdGNoWzBdLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLmZpbmRPYnNlcnZlR3JvdXBzKGlucHV0LCBcIlwiLCBcIiRcIiwgXCIkXCIsIFwiXCIpO1xuICAgICAgICAgIGlmIChhKSB7ICAvLyBlLmcuICQybi0xJCwgJC0kXG4gICAgICAgICAgICBtYXRjaCA9IGEubWF0Y2hfLm1hdGNoKC9eXFwkKD86XFwoP1srXFwtXT8oPzpbMC05XSpbYS16XT9bK1xcLV0pP1swLTldKlthLXpdKD86WytcXC1dWzAtOV0qW2Etel0/KT9cXCk/fFxcK3wtKVxcJCQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICByZXR1cm4geyBtYXRjaF86IG1hdGNoWzBdLCByZW1haW5kZXI6IGlucHV0LnN1YnN0cihtYXRjaFswXS5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAnYW1vdW50Mic6IGZ1bmN0aW9uIChpbnB1dCkgeyByZXR1cm4gdGhpc1snYW1vdW50J10oaW5wdXQpOyB9LFxuICAgICAgICAnKEtWIGxldHRlcnMpLCc6IC9eKD86W0EtWl1bYS16XXswLDJ9fGkpKD89LCkvLFxuICAgICAgICAnZm9ybXVsYSQnOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubWF0Y2goL15cXChbYS16XStcXCkkLykpIHsgcmV0dXJuIG51bGw7IH0gIC8vIHN0YXRlIG9mIGFnZ3JlZ2F0aW9uID0gbm8gZm9ybXVsYVxuICAgICAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKC9eKD86W2Etel18KD86WzAtOVxcIFxcK1xcLVxcLFxcLlxcKFxcKV0rW2Etel0pK1swLTlcXCBcXCtcXC1cXCxcXC5cXChcXCldKnwoPzpbYS16XVswLTlcXCBcXCtcXC1cXCxcXC5cXChcXCldKykrW2Etel0/KSQvKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1hdGNoXzogbWF0Y2hbMF0sIHJlbWFpbmRlcjogaW5wdXQuc3Vic3RyKG1hdGNoWzBdLmxlbmd0aCkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgICd1cHJpZ2h0RW50aXRpZXMnOiAvXig/OnBIfHBPSHxwQ3xwS3xpUHJ8aUJ1KSg/PSR8W15hLXpBLVpdKS8sXG4gICAgICAgICcvJzogL15cXHMqKFxcLylcXHMqLyxcbiAgICAgICAgJy8vJzogL15cXHMqKFxcL1xcLylcXHMqLyxcbiAgICAgICAgJyonOiAvXlxccypbKi5dXFxzKi9cbiAgICAgIH0sXG4gICAgICBmaW5kT2JzZXJ2ZUdyb3VwczogZnVuY3Rpb24gKGlucHV0LCBiZWdFeGNsLCBiZWdJbmNsLCBlbmRJbmNsLCBlbmRFeGNsLCBiZWcyRXhjbCwgYmVnMkluY2wsIGVuZDJJbmNsLCBlbmQyRXhjbCwgY29tYmluZSkge1xuICAgICAgICAvKiogQHR5cGUge3soaW5wdXQ6IHN0cmluZywgcGF0dGVybjogc3RyaW5nIHwgUmVnRXhwKTogc3RyaW5nIHwgc3RyaW5nW10gfCBudWxsO319ICovXG4gICAgICAgIHZhciBfbWF0Y2ggPSBmdW5jdGlvbiAoaW5wdXQsIHBhdHRlcm4pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5pbmRleE9mKHBhdHRlcm4pICE9PSAwKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gaW5wdXQubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQHR5cGUge3soaW5wdXQ6IHN0cmluZywgaTogbnVtYmVyLCBlbmRDaGFyczogc3RyaW5nIHwgUmVnRXhwKToge2VuZE1hdGNoQmVnaW46IG51bWJlciwgZW5kTWF0Y2hFbmQ6IG51bWJlcn0gfCBudWxsO319ICovXG4gICAgICAgIHZhciBfZmluZE9ic2VydmVHcm91cHMgPSBmdW5jdGlvbiAoaW5wdXQsIGksIGVuZENoYXJzKSB7XG4gICAgICAgICAgdmFyIGJyYWNlcyA9IDA7XG4gICAgICAgICAgd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gX21hdGNoKGlucHV0LnN1YnN0cihpKSwgZW5kQ2hhcnMpO1xuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsICAmJiAgYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVuZE1hdGNoQmVnaW46IGksIGVuZE1hdGNoRW5kOiBpICsgbWF0Y2gubGVuZ3RoIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgIGJyYWNlcysrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhID09PSBcIn1cIikge1xuICAgICAgICAgICAgICBpZiAoYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgW1wiRXh0cmFDbG9zZU1pc3NpbmdPcGVuXCIsIFwiRXh0cmEgY2xvc2UgYnJhY2Ugb3IgbWlzc2luZyBvcGVuIGJyYWNlXCJdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyYWNlcy0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChicmFjZXMgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYXRjaCA9IF9tYXRjaChpbnB1dCwgYmVnRXhjbCk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cihtYXRjaC5sZW5ndGgpO1xuICAgICAgICBtYXRjaCA9IF9tYXRjaChpbnB1dCwgYmVnSW5jbCk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgZSA9IF9maW5kT2JzZXJ2ZUdyb3VwcyhpbnB1dCwgbWF0Y2gubGVuZ3RoLCBlbmRJbmNsIHx8IGVuZEV4Y2wpO1xuICAgICAgICBpZiAoZSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICB2YXIgbWF0Y2gxID0gaW5wdXQuc3Vic3RyaW5nKDAsIChlbmRJbmNsID8gZS5lbmRNYXRjaEVuZCA6IGUuZW5kTWF0Y2hCZWdpbikpO1xuICAgICAgICBpZiAoIShiZWcyRXhjbCB8fCBiZWcySW5jbCkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWF0Y2hfOiBtYXRjaDEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnN1YnN0cihlLmVuZE1hdGNoRW5kKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGdyb3VwMiA9IHRoaXMuZmluZE9ic2VydmVHcm91cHMoaW5wdXQuc3Vic3RyKGUuZW5kTWF0Y2hFbmQpLCBiZWcyRXhjbCwgYmVnMkluY2wsIGVuZDJJbmNsLCBlbmQyRXhjbCk7XG4gICAgICAgICAgaWYgKGdyb3VwMiA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgICAgICAgdmFyIG1hdGNoUmV0ID0gW21hdGNoMSwgZ3JvdXAyLm1hdGNoX107XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hdGNoXzogKGNvbWJpbmUgPyBtYXRjaFJldC5qb2luKFwiXCIpIDogbWF0Y2hSZXQpLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBncm91cDIucmVtYWluZGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy9cbiAgICAgIC8vIE1hdGNoaW5nIGZ1bmN0aW9uXG4gICAgICAvLyBlLmcuIG1hdGNoKFwiYVwiLCBpbnB1dCkgd2lsbCBsb29rIGZvciB0aGUgcmVnZXhwIGNhbGxlZCBcImFcIiBhbmQgc2VlIGlmIGl0IG1hdGNoZXNcbiAgICAgIC8vIHJldHVybnMgbnVsbCBvciB7bWF0Y2hfOlwiYVwiLCByZW1haW5kZXI6XCJiY1wifVxuICAgICAgLy9cbiAgICAgIG1hdGNoXzogZnVuY3Rpb24gKG0sIGlucHV0KSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLnBhdHRlcm5zW21dO1xuICAgICAgICBpZiAocGF0dGVybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgW1wiTWhjaGVtQnVnUFwiLCBcIm1oY2hlbSBidWcgUC4gUGxlYXNlIHJlcG9ydC4gKFwiICsgbSArIFwiKVwiXTsgIC8vIFRyeWluZyB0byB1c2Ugbm9uLWV4aXN0aW5nIHBhdHRlcm5cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIG1oY2hlbVBhcnNlci5wYXR0ZXJucy5wYXR0ZXJuc1ttXShpbnB1dCk7ICAvLyBjYW5ub3QgdXNlIGNhY2hlZCB2YXIgcGF0dGVybiBoZXJlLCBiZWNhdXNlIHNvbWUgcGF0dGVybiBmdW5jdGlvbnMgbmVlZCB0aGlzPT09bWhjaGVtUGFyc2VyXG4gICAgICAgIH0gZWxzZSB7ICAvLyBSZWdFeHBcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBpbnB1dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBtbTtcbiAgICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICBtbSA9IFsgbWF0Y2hbMV0sIG1hdGNoWzJdIF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgIG1tID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtbSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbWF0Y2hfOiBtbSwgcmVtYWluZGVyOiBpbnB1dC5zdWJzdHIobWF0Y2hbMF0ubGVuZ3RoKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvL1xuICAgIC8vIEdlbmVyaWMgc3RhdGUgbWFjaGluZSBhY3Rpb25zXG4gICAgLy9cbiAgICBhY3Rpb25zOiB7XG4gICAgICAnYT0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5hID0gKGJ1ZmZlci5hIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdiPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLmIgPSAoYnVmZmVyLmIgfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ3A9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucCA9IChidWZmZXIucCB8fCBcIlwiKSArIG07IH0sXG4gICAgICAnbz0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5vID0gKGJ1ZmZlci5vIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICdxPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnEgPSAoYnVmZmVyLnEgfHwgXCJcIikgKyBtOyB9LFxuICAgICAgJ2Q9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIuZCA9IChidWZmZXIuZCB8fCBcIlwiKSArIG07IH0sXG4gICAgICAncm09JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucm0gPSAoYnVmZmVyLnJtIHx8IFwiXCIpICsgbTsgfSxcbiAgICAgICd0ZXh0PSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnRleHRfID0gKGJ1ZmZlci50ZXh0XyB8fCBcIlwiKSArIG07IH0sXG4gICAgICAnaW5zZXJ0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgYSkgeyByZXR1cm4geyB0eXBlXzogYSB9OyB9LFxuICAgICAgJ2luc2VydCtwMSc6IGZ1bmN0aW9uIChidWZmZXIsIG0sIGEpIHsgcmV0dXJuIHsgdHlwZV86IGEsIHAxOiBtIH07IH0sXG4gICAgICAnaW5zZXJ0K3AxK3AyJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgYSkgeyByZXR1cm4geyB0eXBlXzogYSwgcDE6IG1bMF0sIHAyOiBtWzFdIH07IH0sXG4gICAgICAnY29weSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG07IH0sXG4gICAgICAncm0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiB7IHR5cGVfOiAncm0nLCBwMTogbSB8fCBcIlwifTsgfSxcbiAgICAgICd0ZXh0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4gbWhjaGVtUGFyc2VyLmdvKG0sICd0ZXh0Jyk7IH0sXG4gICAgICAne3RleHR9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICB2YXIgcmV0ID0gWyBcIntcIiBdO1xuICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuZ28obSwgJ3RleHQnKSk7XG4gICAgICAgIHJldC5wdXNoKFwifVwiKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0sXG4gICAgICAndGV4LW1hdGgnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiBtaGNoZW1QYXJzZXIuZ28obSwgJ3RleC1tYXRoJyk7IH0sXG4gICAgICAndGV4LW1hdGggdGlnaHQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiBtaGNoZW1QYXJzZXIuZ28obSwgJ3RleC1tYXRoIHRpZ2h0Jyk7IH0sXG4gICAgICAnYm9uZCc6IGZ1bmN0aW9uIChidWZmZXIsIG0sIGspIHsgcmV0dXJuIHsgdHlwZV86ICdib25kJywga2luZF86IGsgfHwgbSB9OyB9LFxuICAgICAgJ2NvbG9yMC1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiB7IHR5cGVfOiAnY29sb3IwJywgY29sb3I6IG1bMF0gfTsgfSxcbiAgICAgICdjZSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgcmV0dXJuIG1oY2hlbVBhcnNlci5nbyhtKTsgfSxcbiAgICAgICcxLzInOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgaWYgKG0ubWF0Y2goL15bK1xcLV0vKSkge1xuICAgICAgICAgIHJldC5wdXNoKG0uc3Vic3RyKDAsIDEpKTtcbiAgICAgICAgICBtID0gbS5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4gPSBtLm1hdGNoKC9eKFswLTldK3xcXCRbYS16XVxcJHxbYS16XSlcXC8oWzAtOV0rKShcXCRbYS16XVxcJHxbYS16XSk/JC8pO1xuICAgICAgICBuWzFdID0gblsxXS5yZXBsYWNlKC9cXCQvZywgXCJcIik7XG4gICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICdmcmFjJywgcDE6IG5bMV0sIHAyOiBuWzJdIH0pO1xuICAgICAgICBpZiAoblszXSkge1xuICAgICAgICAgIG5bM10gPSBuWzNdLnJlcGxhY2UoL1xcJC9nLCBcIlwiKTtcbiAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAndGV4LW1hdGgnLCBwMTogblszXSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfSxcbiAgICAgICc5LDknOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IHJldHVybiBtaGNoZW1QYXJzZXIuZ28obSwgJzksOScpOyB9XG4gICAgfSxcbiAgICAvL1xuICAgIC8vIGNyZWF0ZVRyYW5zaXRpb25zXG4gICAgLy8gY29udmVydCAgeyAnbGV0dGVyJzogeyAnc3RhdGUnOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSB9ICB0byAgeyAnc3RhdGUnID0+IFsgeyBwYXR0ZXJuOiAnbGV0dGVyJywgdGFzazogeyBhY3Rpb25fOiBbe3R5cGVfOiAnb3V0cHV0J31dIH0gfSBdIH1cbiAgICAvLyB3aXRoIGV4cGFuc2lvbiBvZiAnYXxiJyB0byAnYScgYW5kICdiJyAoYXQgMiBwbGFjZXMpXG4gICAgLy9cbiAgICBjcmVhdGVUcmFuc2l0aW9uczogZnVuY3Rpb24gKG8pIHtcbiAgICAgIHZhciBwYXR0ZXJuLCBzdGF0ZTtcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgICB2YXIgc3RhdGVBcnJheTtcbiAgICAgIHZhciBpO1xuICAgICAgLy9cbiAgICAgIC8vIDEuIENvbGxlY3QgYWxsIHN0YXRlc1xuICAgICAgLy9cbiAgICAgIC8qKiBAdHlwZSB7VHJhbnNpdGlvbnN9ICovXG4gICAgICB2YXIgdHJhbnNpdGlvbnMgPSB7fTtcbiAgICAgIGZvciAocGF0dGVybiBpbiBvKSB7XG4gICAgICAgIGZvciAoc3RhdGUgaW4gb1twYXR0ZXJuXSkge1xuICAgICAgICAgIHN0YXRlQXJyYXkgPSBzdGF0ZS5zcGxpdChcInxcIik7XG4gICAgICAgICAgb1twYXR0ZXJuXVtzdGF0ZV0uc3RhdGVBcnJheSA9IHN0YXRlQXJyYXk7XG4gICAgICAgICAgZm9yIChpPTA7IGk8c3RhdGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJhbnNpdGlvbnNbc3RhdGVBcnJheVtpXV0gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vXG4gICAgICAvLyAyLiBGaWxsIHN0YXRlc1xuICAgICAgLy9cbiAgICAgIGZvciAocGF0dGVybiBpbiBvKSB7XG4gICAgICAgIGZvciAoc3RhdGUgaW4gb1twYXR0ZXJuXSkge1xuICAgICAgICAgIHN0YXRlQXJyYXkgPSBvW3BhdHRlcm5dW3N0YXRlXS5zdGF0ZUFycmF5IHx8IFtdO1xuICAgICAgICAgIGZvciAoaT0wOyBpPHN0YXRlQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAyYS4gTm9ybWFsaXplIGFjdGlvbnMgaW50byBhcnJheTogICd0ZXh0PScgPT0+IFt7dHlwZV86J3RleHQ9J31dXG4gICAgICAgICAgICAvLyAoTm90ZSB0byBteXNlbGY6IFJlc29sdmluZyB0aGUgZnVuY3Rpb24gaGVyZSB3b3VsZCBiZSBwcm9ibGVtYXRpYy4gSXQgd291bGQgbmVlZCAuYmluZCAoZm9yICp0aGlzKikgYW5kIGN1cnJ5aW5nIChmb3IgKm9wdGlvbiopLilcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICAgICAgICAgIHZhciBwID0gb1twYXR0ZXJuXVtzdGF0ZV07XG4gICAgICAgICAgICBpZiAocC5hY3Rpb25fKSB7XG4gICAgICAgICAgICAgIHAuYWN0aW9uXyA9IFtdLmNvbmNhdChwLmFjdGlvbl8pO1xuICAgICAgICAgICAgICBmb3IgKHZhciBrPTA7IGs8cC5hY3Rpb25fLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwLmFjdGlvbl9ba10gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIHAuYWN0aW9uX1trXSA9IHsgdHlwZV86IHAuYWN0aW9uX1trXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcC5hY3Rpb25fID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gMi5iIE11bHRpLWluc2VydFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhciBwYXR0ZXJuQXJyYXkgPSBwYXR0ZXJuLnNwbGl0KFwifFwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxwYXR0ZXJuQXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlQXJyYXlbaV0gPT09ICcqJykgeyAgLy8gaW5zZXJ0IGludG8gYWxsXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCBpbiB0cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnNbdF0ucHVzaCh7IHBhdHRlcm46IHBhdHRlcm5BcnJheVtqXSwgdGFzazogcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnNbc3RhdGVBcnJheVtpXV0ucHVzaCh7IHBhdHRlcm46IHBhdHRlcm5BcnJheVtqXSwgdGFzazogcCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYW5zaXRpb25zO1xuICAgIH0sXG4gICAgc3RhdGVNYWNoaW5lczoge31cbiAgfTtcblxuICAvL1xuICAvLyBEZWZpbml0aW9uIG9mIHN0YXRlIG1hY2hpbmVzXG4gIC8vXG4gIG1oY2hlbVBhcnNlci5zdGF0ZU1hY2hpbmVzID0ge1xuICAgIC8vXG4gICAgLy8gXFxjZSBzdGF0ZSBtYWNoaW5lc1xuICAgIC8vXG4gICAgLy8jcmVnaW9uIGNlXG4gICAgJ2NlJzogeyAgLy8gbWFpbiBwYXJzZXJcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiAge1xuICAgICAgICAgICcwfDF8Mic6IHsgYWN0aW9uXzogJ2JlZ2luc1dpdGhCb25kPWZhbHNlJywgcmV2aXNpdDogdHJ1ZSwgdG9Db250aW51ZTogdHJ1ZSB9IH0sXG4gICAgICAgICdveGlkYXRpb24kJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnb3hpZGF0aW9uLW91dHB1dCcgfSB9LFxuICAgICAgICAnQ01UJzoge1xuICAgICAgICAgICdyJzogeyBhY3Rpb25fOiAncmR0PScsIG5leHRTdGF0ZTogJ3J0JyB9LFxuICAgICAgICAgICdyZCc6IHsgYWN0aW9uXzogJ3JxdD0nLCBuZXh0U3RhdGU6ICdyZHQnIH0gfSxcbiAgICAgICAgJ2Fycm93VXBEb3duJzoge1xuICAgICAgICAgICcwfDF8Mnxhcyc6IHsgYWN0aW9uXzogWyAnc2I9ZmFsc2UnLCAnb3V0cHV0JywgJ29wZXJhdG9yJyBdLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICd1cHJpZ2h0RW50aXRpZXMnOiB7XG4gICAgICAgICAgJzB8MXwyJzogeyBhY3Rpb25fOiBbICdvPScsICdvdXRwdXQnIF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJ29yYml0YWwnOiB7XG4gICAgICAgICAgJzB8MXwyfDMnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJy0+Jzoge1xuICAgICAgICAgICcwfDF8MnwzJzogeyBhY3Rpb25fOiAncj0nLCBuZXh0U3RhdGU6ICdyJyB9LFxuICAgICAgICAgICdhfGFzJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAncj0nIF0sIG5leHRTdGF0ZTogJ3InIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdyPScgXSwgbmV4dFN0YXRlOiAncicgfSB9LFxuICAgICAgICAnKyc6IHtcbiAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogJ2Q9IGt2JywgIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJ2R8RCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogJ2Q9JywgIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdxZHxxRCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ2RxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnZD0nIF0sIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJzMnOiB7IGFjdGlvbl86IFsgJ3NiPWZhbHNlJywgJ291dHB1dCcsICdvcGVyYXRvcicgXSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnYW1vdW50Jzoge1xuICAgICAgICAgICcwfDInOiB7IGFjdGlvbl86ICdhPScsIG5leHRTdGF0ZTogJ2EnIH0gfSxcbiAgICAgICAgJ3BtLW9wZXJhdG9yJzoge1xuICAgICAgICAgICcwfDF8MnxhfGFzJzogeyBhY3Rpb25fOiBbICdzYj1mYWxzZScsICdvdXRwdXQnLCB7IHR5cGVfOiAnb3BlcmF0b3InLCBvcHRpb246ICdcXFxccG0nIH0gXSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnb3BlcmF0b3InOiB7XG4gICAgICAgICAgJzB8MXwyfGF8YXMnOiB7IGFjdGlvbl86IFsgJ3NiPWZhbHNlJywgJ291dHB1dCcsICdvcGVyYXRvcicgXSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnLSQnOiB7XG4gICAgICAgICAgJ298cSc6IHsgYWN0aW9uXzogWyAnY2hhcmdlIG9yIGJvbmQnLCAnb3V0cHV0JyBdLCAgbmV4dFN0YXRlOiAncWQnIH0sXG4gICAgICAgICAgJ2QnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJ0QnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIi1cIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgJ3EnOiB7IGFjdGlvbl86ICdkPScsICBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAncWQnOiB7IGFjdGlvbl86ICdkPScsIG5leHRTdGF0ZTogJ3FkJyB9LFxuICAgICAgICAgICdxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnLTknOiB7XG4gICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2h5cGhlbicgfSBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICctIG9yYml0YWwgb3ZlcmxhcCc6IHtcbiAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2h5cGhlbicgfSBdLCBuZXh0U3RhdGU6ICcyJyB9LFxuICAgICAgICAgICdkJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9IF0sIG5leHRTdGF0ZTogJzInIH0gfSxcbiAgICAgICAgJy0nOiB7XG4gICAgICAgICAgJzB8MXwyJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgJ2JlZ2luc1dpdGhCb25kPXRydWUnLCB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICczJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnYm9uZCcsIG9wdGlvbjogXCItXCIgfSB9LFxuICAgICAgICAgICdhJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnaHlwaGVuJyB9IF0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJ2FzJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSxcbiAgICAgICAgICAnYic6IHsgYWN0aW9uXzogJ2I9JyB9LFxuICAgICAgICAgICdvJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnLSBhZnRlciBvL2QnLCBvcHRpb246IGZhbHNlIH0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJ3EnOiB7IGFjdGlvbl86IHsgdHlwZV86ICctIGFmdGVyIG8vZCcsIG9wdGlvbjogZmFsc2UgfSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnZHxxZHxkcSc6IHsgYWN0aW9uXzogeyB0eXBlXzogJy0gYWZ0ZXIgby9kJywgb3B0aW9uOiB0cnVlIH0sIG5leHRTdGF0ZTogJzInIH0sXG4gICAgICAgICAgJ0R8cUR8cCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLVwiIH0gXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnYW1vdW50Mic6IHtcbiAgICAgICAgICAnMXwzJzogeyBhY3Rpb25fOiAnYT0nLCBuZXh0U3RhdGU6ICdhJyB9IH0sXG4gICAgICAgICdsZXR0ZXJzJzoge1xuICAgICAgICAgICcwfDF8MnwzfGF8YXN8YnxwfGJwfG8nOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgJ3F8ZHEnOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ289J10sIG5leHRTdGF0ZTogJ28nIH0sXG4gICAgICAgICAgJ2R8RHxxZHxxRCc6IHsgYWN0aW9uXzogJ28gYWZ0ZXIgZCcsIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJ2RpZ2l0cyc6IHtcbiAgICAgICAgICAnbyc6IHsgYWN0aW9uXzogJ3E9JywgbmV4dFN0YXRlOiAncScgfSxcbiAgICAgICAgICAnZHxEJzogeyBhY3Rpb25fOiAncT0nLCBuZXh0U3RhdGU6ICdkcScgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ289JyBdLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICdhJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICdzcGFjZSBBJzoge1xuICAgICAgICAgICdifHB8YnAnOiB7fSB9LFxuICAgICAgICAnc3BhY2UnOiB7XG4gICAgICAgICAgJ2EnOiB7IG5leHRTdGF0ZTogJ2FzJyB9LFxuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnc2I9ZmFsc2UnIH0sXG4gICAgICAgICAgJzF8Mic6IHsgYWN0aW9uXzogJ3NiPXRydWUnIH0sXG4gICAgICAgICAgJ3J8cnR8cmR8cmR0fHJkcSc6IHsgYWN0aW9uXzogJ291dHB1dCcsIG5leHRTdGF0ZTogJzAnIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdzYj10cnVlJyBdLCBuZXh0U3RhdGU6ICcxJ30gfSxcbiAgICAgICAgJzFzdC1sZXZlbCBlc2NhcGUnOiB7XG4gICAgICAgICAgJzF8Mic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2luc2VydCtwMScsIG9wdGlvbjogJzFzdC1sZXZlbCBlc2NhcGUnIH0gXSB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0K3AxJywgb3B0aW9uOiAnMXN0LWxldmVsIGVzY2FwZScgfSBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdbKC4uLildJzoge1xuICAgICAgICAgICdyfHJ0JzogeyBhY3Rpb25fOiAncmQ9JywgbmV4dFN0YXRlOiAncmQnIH0sXG4gICAgICAgICAgJ3JkfHJkdCc6IHsgYWN0aW9uXzogJ3JxPScsIG5leHRTdGF0ZTogJ3JkcScgfSB9LFxuICAgICAgICAnLi4uJzoge1xuICAgICAgICAgICdvfGR8RHxkcXxxZHxxRCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgeyB0eXBlXzogJ2JvbmQnLCBvcHRpb246IFwiLi4uXCIgfSBdLCBuZXh0U3RhdGU6ICczJyB9LFxuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2VsbGlwc2lzJyB9IF0sIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJy4gfCogJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCB7IHR5cGVfOiAnaW5zZXJ0Jywgb3B0aW9uOiAnYWRkaXRpb24gY29tcG91bmQnIH0gXSwgbmV4dFN0YXRlOiAnMScgfSB9LFxuICAgICAgICAnc3RhdGUgb2YgYWdncmVnYXRpb24gJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uJyBdLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICd7WygnOiB7XG4gICAgICAgICAgJ2F8YXN8byc6IHsgYWN0aW9uXzogWyAnbz0nLCAnb3V0cHV0JywgJ3BhcmVudGhlc2lzTGV2ZWwrKycgXSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnMHwxfDJ8Myc6IHsgYWN0aW9uXzogWyAnbz0nLCAnb3V0cHV0JywgJ3BhcmVudGhlc2lzTGV2ZWwrKycgXSwgbmV4dFN0YXRlOiAnMicgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ289JywgJ291dHB1dCcsICdwYXJlbnRoZXNpc0xldmVsKysnIF0sIG5leHRTdGF0ZTogJzInIH0gfSxcbiAgICAgICAgJyldfSc6IHtcbiAgICAgICAgICAnMHwxfDJ8M3xifHB8YnB8byc6IHsgYWN0aW9uXzogWyAnbz0nLCAncGFyZW50aGVzaXNMZXZlbC0tJyBdLCBuZXh0U3RhdGU6ICdvJyB9LFxuICAgICAgICAgICdhfGFzfGR8RHxxfHFkfHFEfGRxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnbz0nLCAncGFyZW50aGVzaXNMZXZlbC0tJyBdLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICcsICc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2NvbW1hJyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdeXyc6IHsgIC8vIF4gYW5kIF8gd2l0aG91dCBhIHNlbnNpYmxlIGFyZ3VtZW50XG4gICAgICAgICAgJyonOiB7IH0gfSxcbiAgICAgICAgJ157KC4uLil9fF4oJC4uLiQpJzoge1xuICAgICAgICAgICcwfDF8Mnxhcyc6IHsgYWN0aW9uXzogJ2I9JywgbmV4dFN0YXRlOiAnYicgfSxcbiAgICAgICAgICAncCc6IHsgYWN0aW9uXzogJ2I9JywgbmV4dFN0YXRlOiAnYnAnIH0sXG4gICAgICAgICAgJzN8byc6IHsgYWN0aW9uXzogJ2Q9IGt2JywgbmV4dFN0YXRlOiAnRCcgfSxcbiAgICAgICAgICAncSc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAncUQnIH0sXG4gICAgICAgICAgJ2R8RHxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2Q9JyBdLCBuZXh0U3RhdGU6ICdEJyB9IH0sXG4gICAgICAgICdeYXxeXFxcXHh7fXt9fF5cXFxceHt9fF5cXFxceHxcXCcnOiB7XG4gICAgICAgICAgJzB8MXwyfGFzJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdiJyB9LFxuICAgICAgICAgICdwJzogeyBhY3Rpb25fOiAnYj0nLCBuZXh0U3RhdGU6ICdicCcgfSxcbiAgICAgICAgICAnM3xvJzogeyBhY3Rpb25fOiAnZD0ga3YnLCBuZXh0U3RhdGU6ICdkJyB9LFxuICAgICAgICAgICdxJzogeyBhY3Rpb25fOiAnZD0nLCBuZXh0U3RhdGU6ICdxZCcgfSxcbiAgICAgICAgICAnZHxxZHxEfHFEJzogeyBhY3Rpb25fOiAnZD0nIH0sXG4gICAgICAgICAgJ2RxJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnZD0nIF0sIG5leHRTdGF0ZTogJ2QnIH0gfSxcbiAgICAgICAgJ197KHN0YXRlIG9mIGFnZ3JlZ2F0aW9uKX0kJzoge1xuICAgICAgICAgICdkfER8cXxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3E9JyBdLCBuZXh0U3RhdGU6ICdxJyB9IH0sXG4gICAgICAgICdfeyguLi4pfXxfKCQuLi4kKXxfOXxfXFxcXHh7fXt9fF9cXFxceHt9fF9cXFxceCc6IHtcbiAgICAgICAgICAnMHwxfDJ8YXMnOiB7IGFjdGlvbl86ICdwPScsIG5leHRTdGF0ZTogJ3AnIH0sXG4gICAgICAgICAgJ2InOiB7IGFjdGlvbl86ICdwPScsIG5leHRTdGF0ZTogJ2JwJyB9LFxuICAgICAgICAgICczfG8nOiB7IGFjdGlvbl86ICdxPScsIG5leHRTdGF0ZTogJ3EnIH0sXG4gICAgICAgICAgJ2R8RCc6IHsgYWN0aW9uXzogJ3E9JywgbmV4dFN0YXRlOiAnZHEnIH0sXG4gICAgICAgICAgJ3F8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdxPScgXSwgbmV4dFN0YXRlOiAncScgfSB9LFxuICAgICAgICAnPTw+Jzoge1xuICAgICAgICAgICcwfDF8MnwzfGF8YXN8b3xxfGR8RHxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sICdib25kJyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICcjJzoge1xuICAgICAgICAgICcwfDF8MnwzfGF8YXN8byc6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAyIH0sIHsgdHlwZV86ICdib25kJywgb3B0aW9uOiBcIiNcIiB9IF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ3t9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sICBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICd7Li4ufSc6IHtcbiAgICAgICAgICAnMHwxfDJ8M3xhfGFzfGJ8cHxicCc6IHsgYWN0aW9uXzogJ289JywgbmV4dFN0YXRlOiAnbycgfSxcbiAgICAgICAgICAnb3xkfER8cXxxZHxxRHxkcSc6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ289JyBdLCBuZXh0U3RhdGU6ICdvJyB9IH0sXG4gICAgICAgICckLi4uJCc6IHtcbiAgICAgICAgICAnYSc6IHsgYWN0aW9uXzogJ2E9JyB9LCAgLy8gMiRuJFxuICAgICAgICAgICcwfDF8MnwzfGFzfGJ8cHxicHxvJzogeyBhY3Rpb25fOiAnbz0nLCBuZXh0U3RhdGU6ICdvJyB9LCAgLy8gbm90ICdhbW91bnQnXG4gICAgICAgICAgJ2FzfG8nOiB7IGFjdGlvbl86ICdvPScgfSxcbiAgICAgICAgICAncXxkfER8cWR8cUR8ZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdvPScgXSwgbmV4dFN0YXRlOiAnbycgfSB9LFxuICAgICAgICAnXFxcXGJvbmR7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ2JvbmQnIF0sIG5leHRTdGF0ZTogXCIzXCIgfSB9LFxuICAgICAgICAnXFxcXGZyYWN7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgJ2ZyYWMtb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdcXFxcb3ZlcnNldHsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnb3ZlcnNldC1vdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFx1bmRlcnNldHsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAndW5kZXJzZXQtb3V0cHV0JyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdcXFxcdW5kZXJicmFjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAndW5kZXJicmFjZS1vdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX17KC4uLil9MXxcXFxcY29sb3IoLi4uKXsoLi4uKX0yJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ2NvbG9yLW91dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfTAnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgeyB0eXBlXzogJ291dHB1dCcsIG9wdGlvbjogMiB9LCAnY29sb3IwLW91dHB1dCcgXSB9IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDIgfSwgJ2NlJyBdLCBuZXh0U3RhdGU6ICczJyB9IH0sXG4gICAgICAgICdcXFxcLCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyB7IHR5cGVfOiAnb3V0cHV0Jywgb3B0aW9uOiAxIH0sICdjb3B5JyBdLCBuZXh0U3RhdGU6ICcxJyB9IH0sXG4gICAgICAgICdcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnMHwxfDJ8M3xhfGFzfGJ8cHxicHxvfGMwJzogeyBhY3Rpb25fOiBbICdvPScsICdvdXRwdXQnIF0sIG5leHRTdGF0ZTogJzMnIH0sXG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsnb3V0cHV0JywgJ289JywgJ291dHB1dCcgXSwgbmV4dFN0YXRlOiAnMycgfSB9LFxuICAgICAgICAnb3RoZXJzJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbIHsgdHlwZV86ICdvdXRwdXQnLCBvcHRpb246IDEgfSwgJ2NvcHknIF0sIG5leHRTdGF0ZTogJzMnIH0gfSxcbiAgICAgICAgJ2Vsc2UyJzoge1xuICAgICAgICAgICdhJzogeyBhY3Rpb25fOiAnYSB0byBvJywgbmV4dFN0YXRlOiAnbycsIHJldmlzaXQ6IHRydWUgfSxcbiAgICAgICAgICAnYXMnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdzYj10cnVlJyBdLCBuZXh0U3RhdGU6ICcxJywgcmV2aXNpdDogdHJ1ZSB9LFxuICAgICAgICAgICdyfHJ0fHJkfHJkdHxyZHEnOiB7IGFjdGlvbl86IFsgJ291dHB1dCcgXSwgbmV4dFN0YXRlOiAnMCcsIHJldmlzaXQ6IHRydWUgfSxcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ2NvcHknIF0sIG5leHRTdGF0ZTogJzMnIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdvIGFmdGVyIGQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICBpZiAoKGJ1ZmZlci5kIHx8IFwiXCIpLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gYnVmZmVyLmQ7XG4gICAgICAgICAgICBidWZmZXIuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldCA9IHRoaXNbJ291dHB1dCddKGJ1ZmZlcik7XG4gICAgICAgICAgICBidWZmZXIuYiA9IHRtcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gdGhpc1snb3V0cHV0J10oYnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWhjaGVtUGFyc2VyLmFjdGlvbnNbJ289J10oYnVmZmVyLCBtKTtcbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICAnZD0ga3YnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgYnVmZmVyLmQgPSBtO1xuICAgICAgICAgIGJ1ZmZlci5kVHlwZSA9ICdrdic7XG4gICAgICAgIH0sXG4gICAgICAgICdjaGFyZ2Ugb3IgYm9uZCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICBpZiAoYnVmZmVyWydiZWdpbnNXaXRoQm9uZCddKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgdGhpc1snb3V0cHV0J10oYnVmZmVyKSk7XG4gICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuYWN0aW9uc1snYm9uZCddKGJ1ZmZlciwgbSwgXCItXCIpKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlci5kID0gbTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICctIGFmdGVyIG8vZCc6IGZ1bmN0aW9uIChidWZmZXIsIG0sIGlzQWZ0ZXJEKSB7XG4gICAgICAgICAgdmFyIGMxID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnb3JiaXRhbCcsIGJ1ZmZlci5vIHx8IFwiXCIpO1xuICAgICAgICAgIHZhciBjMiA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ29uZSBsb3dlcmNhc2UgZ3JlZWsgbGV0dGVyICQnLCBidWZmZXIubyB8fCBcIlwiKTtcbiAgICAgICAgICB2YXIgYzMgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdvbmUgbG93ZXJjYXNlIGxhdGluIGxldHRlciAkJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgdmFyIGM0ID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnJG9uZSBsb3dlcmNhc2UgbGF0aW4gbGV0dGVyJCAkJywgYnVmZmVyLm8gfHwgXCJcIik7XG4gICAgICAgICAgdmFyIGh5cGhlbkZvbGxvd3MgPSAgbT09PVwiLVwiICYmICggYzEgJiYgYzEucmVtYWluZGVyPT09XCJcIiAgfHwgIGMyICB8fCAgYzMgIHx8ICBjNCApO1xuICAgICAgICAgIGlmIChoeXBoZW5Gb2xsb3dzICYmICFidWZmZXIuYSAmJiAhYnVmZmVyLmIgJiYgIWJ1ZmZlci5wICYmICFidWZmZXIuZCAmJiAhYnVmZmVyLnEgJiYgIWMxICYmIGMzKSB7XG4gICAgICAgICAgICBidWZmZXIubyA9ICckJyArIGJ1ZmZlci5vICsgJyQnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgICAgICBpZiAoaHlwaGVuRm9sbG93cykge1xuICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgdGhpc1snb3V0cHV0J10oYnVmZmVyKSk7XG4gICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnaHlwaGVuJyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYzEgPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCdkaWdpdHMnLCBidWZmZXIuZCB8fCBcIlwiKTtcbiAgICAgICAgICAgIGlmIChpc0FmdGVyRCAmJiBjMSAmJiBjMS5yZW1haW5kZXI9PT0nJykge1xuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuYWN0aW9uc1snZD0nXShidWZmZXIsIG0pKTtcbiAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgdGhpc1snb3V0cHV0J10oYnVmZmVyKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCB0aGlzWydvdXRwdXQnXShidWZmZXIpKTtcbiAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmFjdGlvbnNbJ2JvbmQnXShidWZmZXIsIG0sIFwiLVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgICdhIHRvIG8nOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgYnVmZmVyLm8gPSBidWZmZXIuYTtcbiAgICAgICAgICBidWZmZXIuYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgJ3NiPXRydWUnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlci5zYiA9IHRydWU7IH0sXG4gICAgICAgICdzYj1mYWxzZSc6IGZ1bmN0aW9uIChidWZmZXIpIHsgYnVmZmVyLnNiID0gZmFsc2U7IH0sXG4gICAgICAgICdiZWdpbnNXaXRoQm9uZD10cnVlJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXJbJ2JlZ2luc1dpdGhCb25kJ10gPSB0cnVlOyB9LFxuICAgICAgICAnYmVnaW5zV2l0aEJvbmQ9ZmFsc2UnOiBmdW5jdGlvbiAoYnVmZmVyKSB7IGJ1ZmZlclsnYmVnaW5zV2l0aEJvbmQnXSA9IGZhbHNlOyB9LFxuICAgICAgICAncGFyZW50aGVzaXNMZXZlbCsrJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXSsrOyB9LFxuICAgICAgICAncGFyZW50aGVzaXNMZXZlbC0tJzogZnVuY3Rpb24gKGJ1ZmZlcikgeyBidWZmZXJbJ3BhcmVudGhlc2lzTGV2ZWwnXS0tOyB9LFxuICAgICAgICAnc3RhdGUgb2YgYWdncmVnYXRpb24nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbicsIHAxOiBtaGNoZW1QYXJzZXIuZ28obSwgJ28nKSB9O1xuICAgICAgICB9LFxuICAgICAgICAnY29tbWEnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgdmFyIGEgPSBtLnJlcGxhY2UoL1xccyokLywgJycpO1xuICAgICAgICAgIHZhciB3aXRoU3BhY2UgPSAoYSAhPT0gbSk7XG4gICAgICAgICAgaWYgKHdpdGhTcGFjZSAgJiYgIGJ1ZmZlclsncGFyZW50aGVzaXNMZXZlbCddID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2NvbW1hIGVudW1lcmF0aW9uIEwnLCBwMTogYSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2NvbW1hIGVudW1lcmF0aW9uIE0nLCBwMTogYSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0sIGVudGl0eUZvbGxvd3MpIHtcbiAgICAgICAgICAvLyBlbnRpdHlGb2xsb3dzOlxuICAgICAgICAgIC8vICAgdW5kZWZpbmVkID0gaWYgd2UgaGF2ZSBub3RoaW5nIGVsc2UgdG8gb3V0cHV0LCBhbHNvIGlnbm9yZSB0aGUganVzdCByZWFkIHNwYWNlIChidWZmZXIuc2IpXG4gICAgICAgICAgLy8gICAxID0gYW4gZW50aXR5IGZvbGxvd3MsIG5ldmVyIG9taXQgdGhlIHNwYWNlIGlmIHRoZXJlIHdhcyBvbmUganVzdCByZWFkIGJlZm9yZSAoY2FuIG9ubHkgYXBwbHkgdG8gc3RhdGUgMSlcbiAgICAgICAgICAvLyAgIDIgPSAxICsgdGhlIGVudGl0eSBjYW4gaGF2ZSBhbiBhbW91bnQsIHNvIG91dHB1dCBhXFwsIGluc3RlYWQgb2YgY29udmVydGluZyBpdCB0byBvIChjYW4gb25seSBhcHBseSB0byBzdGF0ZXMgYXxhcylcbiAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dCB8IFBhcnNlck91dHB1dFtdfSAqL1xuICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgaWYgKCFidWZmZXIucikge1xuICAgICAgICAgICAgcmV0ID0gW107XG4gICAgICAgICAgICBpZiAoIWJ1ZmZlci5hICYmICFidWZmZXIuYiAmJiAhYnVmZmVyLnAgJiYgIWJ1ZmZlci5vICYmICFidWZmZXIucSAmJiAhYnVmZmVyLmQgJiYgIWVudGl0eUZvbGxvd3MpIHtcbiAgICAgICAgICAgICAgLy9yZXQgPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChidWZmZXIuc2IpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnZW50aXR5U2tpcCcgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFidWZmZXIubyAmJiAhYnVmZmVyLnEgJiYgIWJ1ZmZlci5kICYmICFidWZmZXIuYiAmJiAhYnVmZmVyLnAgJiYgZW50aXR5Rm9sbG93cyE9PTIpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIubyA9IGJ1ZmZlci5hO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5hID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFidWZmZXIubyAmJiAhYnVmZmVyLnEgJiYgIWJ1ZmZlci5kICYmIChidWZmZXIuYiB8fCBidWZmZXIucCkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIubyA9IGJ1ZmZlci5hO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5kID0gYnVmZmVyLmI7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnEgPSBidWZmZXIucDtcbiAgICAgICAgICAgICAgICBidWZmZXIuYSA9IGJ1ZmZlci5iID0gYnVmZmVyLnAgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5vICYmIGJ1ZmZlci5kVHlwZT09PSdrdicgJiYgbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygnZC1veGlkYXRpb24kJywgYnVmZmVyLmQgfHwgXCJcIikpIHtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlci5kVHlwZSA9ICdveGlkYXRpb24nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYnVmZmVyLm8gJiYgYnVmZmVyLmRUeXBlPT09J2t2JyAmJiAhYnVmZmVyLnEpIHtcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlci5kVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGVfOiAnY2hlbWZpdmUnLFxuICAgICAgICAgICAgICAgIGE6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIuYSwgJ2EnKSxcbiAgICAgICAgICAgICAgICBiOiBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLmIsICdiZCcpLFxuICAgICAgICAgICAgICAgIHA6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucCwgJ3BxJyksXG4gICAgICAgICAgICAgICAgbzogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5vLCAnbycpLFxuICAgICAgICAgICAgICAgIHE6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucSwgJ3BxJyksXG4gICAgICAgICAgICAgICAgZDogbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5kLCAoYnVmZmVyLmRUeXBlID09PSAnb3hpZGF0aW9uJyA/ICdveGlkYXRpb24nIDogJ2JkJykpLFxuICAgICAgICAgICAgICAgIGRUeXBlOiBidWZmZXIuZFR5cGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHsgIC8vIHJcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgICB2YXIgcmQ7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLnJkdCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgIHJkID0gbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5yZCwgJ3RleC1tYXRoJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5yZHQgPT09ICdUJykge1xuICAgICAgICAgICAgICByZCA9IFsgeyB0eXBlXzogJ3RleHQnLCBwMTogYnVmZmVyLnJkIHx8IFwiXCIgfSBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmQgPSBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLnJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgICB2YXIgcnE7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLnJxdCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgIHJxID0gbWhjaGVtUGFyc2VyLmdvKGJ1ZmZlci5ycSwgJ3RleC1tYXRoJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlci5ycXQgPT09ICdUJykge1xuICAgICAgICAgICAgICBycSA9IFsgeyB0eXBlXzogJ3RleHQnLCBwMTogYnVmZmVyLnJxIHx8IFwiXCJ9IF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBycSA9IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucnEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0ID0ge1xuICAgICAgICAgICAgICB0eXBlXzogJ2Fycm93JyxcbiAgICAgICAgICAgICAgcjogYnVmZmVyLnIsXG4gICAgICAgICAgICAgIHJkOiByZCxcbiAgICAgICAgICAgICAgcnE6IHJxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikge1xuICAgICAgICAgICAgaWYgKHAgIT09ICdwYXJlbnRoZXNpc0xldmVsJyAgJiYgIHAgIT09ICdiZWdpbnNXaXRoQm9uZCcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGJ1ZmZlcltwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ294aWRhdGlvbi1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgdmFyIHJldCA9IFsgXCJ7XCIgXTtcbiAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuZ28obSwgJ294aWRhdGlvbicpKTtcbiAgICAgICAgICByZXQucHVzaChcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ2ZyYWMtb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnZnJhYy1jZScsIHAxOiBtaGNoZW1QYXJzZXIuZ28obVswXSksIHAyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ292ZXJzZXQtb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnb3ZlcnNldCcsIHAxOiBtaGNoZW1QYXJzZXIuZ28obVswXSksIHAyOiBtaGNoZW1QYXJzZXIuZ28obVsxXSkgfTtcbiAgICAgICAgfSxcbiAgICAgICAgJ3VuZGVyc2V0LW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ3VuZGVyc2V0JywgcDE6IG1oY2hlbVBhcnNlci5nbyhtWzBdKSwgcDI6IG1oY2hlbVBhcnNlci5nbyhtWzFdKSB9O1xuICAgICAgICB9LFxuICAgICAgICAndW5kZXJicmFjZS1vdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgcmV0dXJuIHsgdHlwZV86ICd1bmRlcmJyYWNlJywgcDE6IG1oY2hlbVBhcnNlci5nbyhtWzBdKSwgcDI6IG1oY2hlbVBhcnNlci5nbyhtWzFdKSB9O1xuICAgICAgICB9LFxuICAgICAgICAnY29sb3Itb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29sb3InLCBjb2xvcjE6IG1bMF0sIGNvbG9yMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0pIH07XG4gICAgICAgIH0sXG4gICAgICAgICdyPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnIgPSBtOyB9LFxuICAgICAgICAncmR0PSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJkdCA9IG07IH0sXG4gICAgICAgICdyZD0nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7IGJ1ZmZlci5yZCA9IG07IH0sXG4gICAgICAgICdycXQ9JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucnF0ID0gbTsgfSxcbiAgICAgICAgJ3JxPSc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHsgYnVmZmVyLnJxID0gbTsgfSxcbiAgICAgICAgJ29wZXJhdG9yJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgcDEpIHsgcmV0dXJuIHsgdHlwZV86ICdvcGVyYXRvcicsIGtpbmRfOiAocDEgfHwgbSkgfTsgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2EnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJzEvMiQnOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICcxLzInIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJzEnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJyQoLi4uKSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCB0aWdodCcsIG5leHRTdGF0ZTogJzEnIH0gfSxcbiAgICAgICAgJywnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdjb21tYURlY2ltYWwnIH0gfSB9LFxuICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge31cbiAgICB9LFxuICAgICdvJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHt9IH0sXG4gICAgICAgICcxLzIkJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnMS8yJyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcwJzogeyBuZXh0U3RhdGU6ICcxJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICdsZXR0ZXJzJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm0nIH0gfSxcbiAgICAgICAgJ1xcXFxjYSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2NpcmNhJyB9IH0gfSxcbiAgICAgICAgJ1xcXFx4e317fXxcXFxceHt9fFxcXFx4Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9LFxuICAgICAgICAnJHsoLi4uKX0kfCQoLi4uKSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAneyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3t0ZXh0fScgfSB9LFxuICAgICAgICAnZWxzZTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge31cbiAgICB9LFxuICAgICd0ZXh0Jzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ291dHB1dCcgfSB9LFxuICAgICAgICAney4uLn0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0PScgfSB9LFxuICAgICAgICAnJHsoLi4uKX0kfCQoLi4uKSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAnXFxcXGdyZWVrJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAncm0nIF0gfSB9LFxuICAgICAgICAnXFxcXCx8XFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdjb3B5JyBdIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0PScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ291dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICBpZiAoYnVmZmVyLnRleHRfKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dH0gKi9cbiAgICAgICAgICAgIHZhciByZXQgPSB7IHR5cGVfOiAndGV4dCcsIHAxOiBidWZmZXIudGV4dF8gfTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAncHEnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzoge30gfSxcbiAgICAgICAgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uICQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbicgfSB9LFxuICAgICAgICAnaSQnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJyFmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICcoS1YgbGV0dGVycyksJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAncm0nLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdmb3JtdWxhJCc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnMS8yJCc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogJzEvMicgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnIWYnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJyR7KC4uLil9JHwkKC4uLikkJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4LW1hdGgnIH0gfSxcbiAgICAgICAgJ3soLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0JyB9IH0sXG4gICAgICAgICdhLXonOiB7XG4gICAgICAgICAgJ2YnOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAnbGV0dGVycyc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JtJyB9IH0sXG4gICAgICAgICctOS4sOSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJzksOScgIH0gfSxcbiAgICAgICAgJywnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQrcDEnLCBvcHRpb246ICdjb21tYSBlbnVtZXJhdGlvbiBTJyB9IH0gfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX17KC4uLil9MXxcXFxcY29sb3IoLi4uKXsoLi4uKX0yJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29sb3Itb3V0cHV0JyB9IH0sXG4gICAgICAgICdcXFxcY29sb3J7KC4uLil9MCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvbG9yMC1vdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjZScgfSB9LFxuICAgICAgICAnXFxcXCx8XFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH0sXG4gICAgICAgICdlbHNlMic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbic6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uIHN1YnNjcmlwdCcsIHAxOiBtaGNoZW1QYXJzZXIuZ28obSwgJ28nKSB9O1xuICAgICAgICB9LFxuICAgICAgICAnY29sb3Itb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkge1xuICAgICAgICAgIHJldHVybiB7IHR5cGVfOiAnY29sb3InLCBjb2xvcjE6IG1bMF0sIGNvbG9yMjogbWhjaGVtUGFyc2VyLmdvKG1bMV0sICdwcScpIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdiZCc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7fSB9LFxuICAgICAgICAneCQnOiB7XG4gICAgICAgICAgJzAnOiB7IG5leHRTdGF0ZTogJyFmJywgcmV2aXNpdDogdHJ1ZSB9IH0sXG4gICAgICAgICdmb3JtdWxhJCc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnZicsIHJldmlzaXQ6IHRydWUgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnMCc6IHsgbmV4dFN0YXRlOiAnIWYnLCByZXZpc2l0OiB0cnVlIH0gfSxcbiAgICAgICAgJy05Liw5IG5vIG1pc3NpbmcgMCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJzksOScgfSB9LFxuICAgICAgICAnLic6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ2VsZWN0cm9uIGRvdCcgfSB9IH0sXG4gICAgICAgICdhLXonOiB7XG4gICAgICAgICAgJ2YnOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAneCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogeyB0eXBlXzogJ2luc2VydCcsIG9wdGlvbjogJ0tWIHgnIH0gfSB9LFxuICAgICAgICAnbGV0dGVycyc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JtJyB9IH0sXG4gICAgICAgICdcXCcnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IHsgdHlwZV86ICdpbnNlcnQnLCBvcHRpb246ICdwcmltZScgfSB9IH0sXG4gICAgICAgICckeyguLi4pfSR8JCguLi4pJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3RleC1tYXRoJyB9IH0sXG4gICAgICAgICd7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGV4dCcgfSB9LFxuICAgICAgICAnXFxcXGNvbG9yeyguLi4pfXsoLi4uKX0xfFxcXFxjb2xvciguLi4peyguLi4pfTInOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb2xvci1vdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjb2xvcnsoLi4uKX0wJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29sb3IwLW91dHB1dCcgfSB9LFxuICAgICAgICAnXFxcXGNleyguLi4pfSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NlJyB9IH0sXG4gICAgICAgICdcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfSxcbiAgICAgICAgJ2Vsc2UyJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29weScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ2NvbG9yLW91dHB1dCc6IGZ1bmN0aW9uIChidWZmZXIsIG0pIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlXzogJ2NvbG9yJywgY29sb3IxOiBtWzBdLCBjb2xvcjI6IG1oY2hlbVBhcnNlci5nbyhtWzFdLCAnYmQnKSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnb3hpZGF0aW9uJzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHt9IH0sXG4gICAgICAgICdyb21hbiBudW1lcmFsJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm9tYW4tbnVtZXJhbCcgfSB9LFxuICAgICAgICAnJHsoLi4uKX0kfCQoLi4uKSQnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXgtbWF0aCcgfSB9LFxuICAgICAgICAnZWxzZSc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ2NvcHknIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdyb21hbi1udW1lcmFsJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyByZXR1cm4geyB0eXBlXzogJ3JvbWFuIG51bWVyYWwnLCBwMTogbSB8fCBcIlwiIH07IH1cbiAgICAgIH1cbiAgICB9LFxuICAgICd0ZXgtbWF0aCc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSxcbiAgICAgICAgJ1xcXFxjZXsoLi4uKX0nOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdjZScgXSB9IH0sXG4gICAgICAgICd7Li4ufXxcXFxcLHxcXFxceHt9e318XFxcXHh7fXxcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ289JyB9IH0sXG4gICAgICAgICdlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnbz0nIH0gfVxuICAgICAgfSksXG4gICAgICBhY3Rpb25zOiB7XG4gICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci5vKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dH0gKi9cbiAgICAgICAgICAgIHZhciByZXQgPSB7IHR5cGVfOiAndGV4LW1hdGgnLCBwMTogYnVmZmVyLm8gfTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAndGV4LW1hdGggdGlnaHQnOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnb3V0cHV0JyB9IH0sXG4gICAgICAgICdcXFxcY2V7KC4uLil9Jzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiBbICdvdXRwdXQnLCAnY2UnIF0gfSB9LFxuICAgICAgICAney4uLn18XFxcXCx8XFxcXHh7fXt9fFxcXFx4e318XFxcXHgnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvPScgfSB9LFxuICAgICAgICAnLXwrJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAndGlnaHQgb3BlcmF0b3InIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvPScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ3RpZ2h0IG9wZXJhdG9yJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIubyA9IChidWZmZXIubyB8fCBcIlwiKSArIFwie1wiK20rXCJ9XCI7IH0sXG4gICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlci5vKSB7XG4gICAgICAgICAgICAvKiogQHR5cGUge1BhcnNlck91dHB1dH0gKi9cbiAgICAgICAgICAgIHZhciByZXQgPSB7IHR5cGVfOiAndGV4LW1hdGgnLCBwMTogYnVmZmVyLm8gfTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnOSw5Jzoge1xuICAgICAgdHJhbnNpdGlvbnM6IG1oY2hlbVBhcnNlci5jcmVhdGVUcmFuc2l0aW9ucyh7XG4gICAgICAgICdlbXB0eSc6IHtcbiAgICAgICAgICAnKic6IHt9IH0sXG4gICAgICAgICcsJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAnY29tbWEnIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdjb3B5JyB9IH1cbiAgICAgIH0pLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICAnY29tbWEnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAnY29tbWFEZWNpbWFsJyB9OyB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyNlbmRyZWdpb25cbiAgICAvL1xuICAgIC8vIFxccHUgc3RhdGUgbWFjaGluZXNcbiAgICAvL1xuICAgIC8vI3JlZ2lvbiBwdVxuICAgICdwdSc6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSxcbiAgICAgICAgJ3NwYWNlJCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogWyAnb3V0cHV0JywgJ3NwYWNlJyBdIH0gfSxcbiAgICAgICAgJ3tbKHwpXX0nOiB7XG4gICAgICAgICAgJzB8YSc6IHsgYWN0aW9uXzogJ2NvcHknIH0gfSxcbiAgICAgICAgJygtKSg5KV4oLTkpJzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnbnVtYmVyXicsIG5leHRTdGF0ZTogJ2EnIH0gfSxcbiAgICAgICAgJygtKSg5Liw5KShlKSg5OSknOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdlbnVtYmVyJywgbmV4dFN0YXRlOiAnYScgfSB9LFxuICAgICAgICAnc3BhY2UnOiB7XG4gICAgICAgICAgJzB8YSc6IHt9IH0sXG4gICAgICAgICdwbS1vcGVyYXRvcic6IHtcbiAgICAgICAgICAnMHxhJzogeyBhY3Rpb25fOiB7IHR5cGVfOiAnb3BlcmF0b3InLCBvcHRpb246ICdcXFxccG0nIH0sIG5leHRTdGF0ZTogJzAnIH0gfSxcbiAgICAgICAgJ29wZXJhdG9yJzoge1xuICAgICAgICAgICcwfGEnOiB7IGFjdGlvbl86ICdjb3B5JywgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnLy8nOiB7XG4gICAgICAgICAgJ2QnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJy8nIH0gfSxcbiAgICAgICAgJy8nOiB7XG4gICAgICAgICAgJ2QnOiB7IGFjdGlvbl86ICdvPScsIG5leHRTdGF0ZTogJy8nIH0gfSxcbiAgICAgICAgJ3suLi59fGVsc2UnOiB7XG4gICAgICAgICAgJzB8ZCc6IHsgYWN0aW9uXzogJ2Q9JywgbmV4dFN0YXRlOiAnZCcgfSxcbiAgICAgICAgICAnYSc6IHsgYWN0aW9uXzogWyAnc3BhY2UnLCAnZD0nIF0sIG5leHRTdGF0ZTogJ2QnIH0sXG4gICAgICAgICAgJy98cSc6IHsgYWN0aW9uXzogJ3E9JywgbmV4dFN0YXRlOiAncScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ2VudW1iZXInOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgaWYgKG1bMF0gPT09IFwiKy1cIiAgfHwgIG1bMF0gPT09IFwiKy8tXCIpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKFwiXFxcXHBtIFwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1bMF0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKG1bMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobVsxXSkge1xuICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmdvKG1bMV0sICdwdS05LDknKSk7XG4gICAgICAgICAgICBpZiAobVsyXSkge1xuICAgICAgICAgICAgICBpZiAobVsyXS5tYXRjaCgvWywuXS8pKSB7XG4gICAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgbWhjaGVtUGFyc2VyLmdvKG1bMl0sICdwdS05LDknKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2gobVsyXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1bM10gPSBtWzRdIHx8IG1bM107XG4gICAgICAgICAgICBpZiAobVszXSkge1xuICAgICAgICAgICAgICBtWzNdID0gbVszXS50cmltKCk7XG4gICAgICAgICAgICAgIGlmIChtWzNdID09PSBcImVcIiAgfHwgIG1bM10uc3Vic3RyKDAsIDEpID09PSBcIipcIikge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHsgdHlwZV86ICdjZG90JyB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAndGltZXMnIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtWzNdKSB7XG4gICAgICAgICAgICByZXQucHVzaChcIjEwXntcIittWzVdK1wifVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ251bWJlcl4nOiBmdW5jdGlvbiAoYnVmZmVyLCBtKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0ID0gW107XG4gICAgICAgICAgaWYgKG1bMF0gPT09IFwiKy1cIiAgfHwgIG1bMF0gPT09IFwiKy8tXCIpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKFwiXFxcXHBtIFwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1bMF0pIHtcbiAgICAgICAgICAgIHJldC5wdXNoKG1bMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtaGNoZW1QYXJzZXIuY29uY2F0QXJyYXkocmV0LCBtaGNoZW1QYXJzZXIuZ28obVsxXSwgJ3B1LTksOScpKTtcbiAgICAgICAgICByZXQucHVzaChcIl57XCIrbVsyXStcIn1cIik7XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ29wZXJhdG9yJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSwgcDEpIHsgcmV0dXJuIHsgdHlwZV86ICdvcGVyYXRvcicsIGtpbmRfOiAocDEgfHwgbSkgfTsgfSxcbiAgICAgICAgJ3NwYWNlJzogZnVuY3Rpb24gKCkgeyByZXR1cm4geyB0eXBlXzogJ3B1LXNwYWNlLTEnIH07IH0sXG4gICAgICAgICdvdXRwdXQnOiBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtQYXJzZXJPdXRwdXQgfCBQYXJzZXJPdXRwdXRbXX0gKi9cbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIHZhciBtZCA9IG1oY2hlbVBhcnNlci5wYXR0ZXJucy5tYXRjaF8oJ3soLi4uKX0nLCBidWZmZXIuZCB8fCBcIlwiKTtcbiAgICAgICAgICBpZiAobWQgICYmICBtZC5yZW1haW5kZXIgPT09ICcnKSB7IGJ1ZmZlci5kID0gbWQubWF0Y2hfOyB9XG4gICAgICAgICAgdmFyIG1xID0gbWhjaGVtUGFyc2VyLnBhdHRlcm5zLm1hdGNoXygneyguLi4pfScsIGJ1ZmZlci5xIHx8IFwiXCIpO1xuICAgICAgICAgIGlmIChtcSAgJiYgIG1xLnJlbWFpbmRlciA9PT0gJycpIHsgYnVmZmVyLnEgPSBtcS5tYXRjaF87IH1cbiAgICAgICAgICBpZiAoYnVmZmVyLmQpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5kID0gYnVmZmVyLmQucmVwbGFjZSgvXFx1MDBCMEN8XFxeb0N8XFxee299Qy9nLCBcInt9XntcXFxcY2lyY31DXCIpO1xuICAgICAgICAgICAgYnVmZmVyLmQgPSBidWZmZXIuZC5yZXBsYWNlKC9cXHUwMEIwRnxcXF5vRnxcXF57b31GL2csIFwie31ee1xcXFxjaXJjfUZcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChidWZmZXIucSkgeyAgLy8gZnJhY3Rpb25cbiAgICAgICAgICAgIGJ1ZmZlci5xID0gYnVmZmVyLnEucmVwbGFjZSgvXFx1MDBCMEN8XFxeb0N8XFxee299Qy9nLCBcInt9XntcXFxcY2lyY31DXCIpO1xuICAgICAgICAgICAgYnVmZmVyLnEgPSBidWZmZXIucS5yZXBsYWNlKC9cXHUwMEIwRnxcXF5vRnxcXF57b31GL2csIFwie31ee1xcXFxjaXJjfUZcIik7XG4gICAgICAgICAgICB2YXIgYjUgPSB7XG4gICAgICAgICAgICAgIGQ6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIuZCwgJ3B1JyksXG4gICAgICAgICAgICAgIHE6IG1oY2hlbVBhcnNlci5nbyhidWZmZXIucSwgJ3B1JylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoYnVmZmVyLm8gPT09ICcvLycpIHtcbiAgICAgICAgICAgICAgcmV0ID0geyB0eXBlXzogJ3B1LWZyYWMnLCBwMTogYjUuZCwgcDI6IGI1LnEgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldCA9IGI1LmQ7XG4gICAgICAgICAgICAgIGlmIChiNS5kLmxlbmd0aCA+IDEgIHx8ICBiNS5xLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnIC8gJyB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnLycgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWhjaGVtUGFyc2VyLmNvbmNhdEFycmF5KHJldCwgYjUucSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHsgIC8vIG5vIGZyYWN0aW9uXG4gICAgICAgICAgICByZXQgPSBtaGNoZW1QYXJzZXIuZ28oYnVmZmVyLmQsICdwdS0yJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAncHUtMic6IHtcbiAgICAgIHRyYW5zaXRpb25zOiBtaGNoZW1QYXJzZXIuY3JlYXRlVHJhbnNpdGlvbnMoe1xuICAgICAgICAnZW1wdHknOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICdvdXRwdXQnIH0gfSxcbiAgICAgICAgJyonOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdjZG90JyBdLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICdcXFxceCc6IHtcbiAgICAgICAgICAnKic6IHsgYWN0aW9uXzogJ3JtPScgfSB9LFxuICAgICAgICAnc3BhY2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86IFsgJ291dHB1dCcsICdzcGFjZScgXSwgbmV4dFN0YXRlOiAnMCcgfSB9LFxuICAgICAgICAnXnsoLi4uKX18XigtMSknOiB7XG4gICAgICAgICAgJzEnOiB7IGFjdGlvbl86ICdeKC0xKScgfSB9LFxuICAgICAgICAnLTkuLDknOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86ICdybT0nLCBuZXh0U3RhdGU6ICcwJyB9LFxuICAgICAgICAgICcxJzogeyBhY3Rpb25fOiAnXigtMSknLCBuZXh0U3RhdGU6ICcwJyB9IH0sXG4gICAgICAgICd7Li4ufXxlbHNlJzoge1xuICAgICAgICAgICcqJzogeyBhY3Rpb25fOiAncm09JywgbmV4dFN0YXRlOiAnMScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ2Nkb3QnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB7IHR5cGVfOiAndGlnaHQgY2RvdCcgfTsgfSxcbiAgICAgICAgJ14oLTEpJzogZnVuY3Rpb24gKGJ1ZmZlciwgbSkgeyBidWZmZXIucm0gKz0gXCJee1wiK20rXCJ9XCI7IH0sXG4gICAgICAgICdzcGFjZSc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgdHlwZV86ICdwdS1zcGFjZS0yJyB9OyB9LFxuICAgICAgICAnb3V0cHV0JzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0IHwgUGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgIGlmIChidWZmZXIucm0pIHtcbiAgICAgICAgICAgIHZhciBtcm0gPSBtaGNoZW1QYXJzZXIucGF0dGVybnMubWF0Y2hfKCd7KC4uLil9JywgYnVmZmVyLnJtIHx8IFwiXCIpO1xuICAgICAgICAgICAgaWYgKG1ybSAgJiYgIG1ybS5yZW1haW5kZXIgPT09ICcnKSB7XG4gICAgICAgICAgICAgIHJldCA9IG1oY2hlbVBhcnNlci5nbyhtcm0ubWF0Y2hfLCAncHUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldCA9IHsgdHlwZV86ICdybScsIHAxOiBidWZmZXIucm0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgcCBpbiBidWZmZXIpIHsgZGVsZXRlIGJ1ZmZlcltwXTsgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdwdS05LDknOiB7XG4gICAgICB0cmFuc2l0aW9uczogbWhjaGVtUGFyc2VyLmNyZWF0ZVRyYW5zaXRpb25zKHtcbiAgICAgICAgJ2VtcHR5Jzoge1xuICAgICAgICAgICcwJzogeyBhY3Rpb25fOiAnb3V0cHV0LTAnIH0sXG4gICAgICAgICAgJ28nOiB7IGFjdGlvbl86ICdvdXRwdXQtbycgfSB9LFxuICAgICAgICAnLCc6IHtcbiAgICAgICAgICAnMCc6IHsgYWN0aW9uXzogWyAnb3V0cHV0LTAnLCAnY29tbWEnIF0sIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJy4nOiB7XG4gICAgICAgICAgJzAnOiB7IGFjdGlvbl86IFsgJ291dHB1dC0wJywgJ2NvcHknIF0sIG5leHRTdGF0ZTogJ28nIH0gfSxcbiAgICAgICAgJ2Vsc2UnOiB7XG4gICAgICAgICAgJyonOiB7IGFjdGlvbl86ICd0ZXh0PScgfSB9XG4gICAgICB9KSxcbiAgICAgIGFjdGlvbnM6IHtcbiAgICAgICAgJ2NvbW1hJzogZnVuY3Rpb24gKCkgeyByZXR1cm4geyB0eXBlXzogJ2NvbW1hRGVjaW1hbCcgfTsgfSxcbiAgICAgICAgJ291dHB1dC0wJzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgIGJ1ZmZlci50ZXh0XyA9IGJ1ZmZlci50ZXh0XyB8fCBcIlwiO1xuICAgICAgICAgIGlmIChidWZmZXIudGV4dF8ubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgdmFyIGEgPSBidWZmZXIudGV4dF8ubGVuZ3RoICUgMztcbiAgICAgICAgICAgIGlmIChhID09PSAwKSB7IGEgPSAzOyB9XG4gICAgICAgICAgICBmb3IgKHZhciBpPWJ1ZmZlci50ZXh0Xy5sZW5ndGgtMzsgaT4wOyBpLT0zKSB7XG4gICAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xy5zdWJzdHIoaSwgMykpO1xuICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnMTAwMCBzZXBhcmF0b3InIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfLnN1YnN0cigwLCBhKSk7XG4gICAgICAgICAgICByZXQucmV2ZXJzZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQucHVzaChidWZmZXIudGV4dF8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBwIGluIGJ1ZmZlcikgeyBkZWxldGUgYnVmZmVyW3BdOyB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgJ291dHB1dC1vJzogZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICAgIC8qKiBAdHlwZSB7UGFyc2VyT3V0cHV0W119ICovXG4gICAgICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgICAgIGJ1ZmZlci50ZXh0XyA9IGJ1ZmZlci50ZXh0XyB8fCBcIlwiO1xuICAgICAgICAgIGlmIChidWZmZXIudGV4dF8ubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgdmFyIGEgPSBidWZmZXIudGV4dF8ubGVuZ3RoIC0gMztcbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxhOyBpKz0zKSB7XG4gICAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xy5zdWJzdHIoaSwgMykpO1xuICAgICAgICAgICAgICByZXQucHVzaCh7IHR5cGVfOiAnMTAwMCBzZXBhcmF0b3InIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0LnB1c2goYnVmZmVyLnRleHRfLnN1YnN0cihpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGJ1ZmZlci50ZXh0Xyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHAgaW4gYnVmZmVyKSB7IGRlbGV0ZSBidWZmZXJbcF07IH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICB9O1xuXG4gIC8vXG4gIC8vIHRleGlmeTogVGFrZSBNaGNoZW1QYXJzZXIgb3V0cHV0IGFuZCBjb252ZXJ0IGl0IHRvIFRlWFxuICAvL1xuICAvKiogQHR5cGUge1RleGlmeX0gKi9cbiAgdmFyIHRleGlmeSA9IHtcbiAgICBnbzogZnVuY3Rpb24gKGlucHV0LCBpc0lubmVyKSB7ICAvLyAocmVjdXJzaXZlLCBtYXggNCBsZXZlbHMpXG4gICAgICBpZiAoIWlucHV0KSB7IHJldHVybiBcIlwiOyB9XG4gICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgIHZhciBjZWUgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGk9MDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dGkgPSBpbnB1dFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dGkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXMgKz0gaW5wdXRpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyArPSB0ZXhpZnkuX2dvMihpbnB1dGkpO1xuICAgICAgICAgIGlmIChpbnB1dGkudHlwZV8gPT09ICcxc3QtbGV2ZWwgZXNjYXBlJykgeyBjZWUgPSB0cnVlOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNJbm5lciAmJiAhY2VlICYmIHJlcykge1xuICAgICAgICByZXMgPSBcIntcIiArIHJlcyArIFwifVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIF9nb0lubmVyOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgIGlmICghaW5wdXQpIHsgcmV0dXJuIGlucHV0OyB9XG4gICAgICByZXR1cm4gdGV4aWZ5LmdvKGlucHV0LCB0cnVlKTtcbiAgICB9LFxuICAgIF9nbzI6IGZ1bmN0aW9uIChidWYpIHtcbiAgICAgIC8qKiBAdHlwZSB7dW5kZWZpbmVkIHwgc3RyaW5nfSAqL1xuICAgICAgdmFyIHJlcztcbiAgICAgIHN3aXRjaCAoYnVmLnR5cGVfKSB7XG4gICAgICAgIGNhc2UgJ2NoZW1maXZlJzpcbiAgICAgICAgICByZXMgPSBcIlwiO1xuICAgICAgICAgIHZhciBiNSA9IHtcbiAgICAgICAgICAgIGE6IHRleGlmeS5fZ29Jbm5lcihidWYuYSksXG4gICAgICAgICAgICBiOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLmIpLFxuICAgICAgICAgICAgcDogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wKSxcbiAgICAgICAgICAgIG86IHRleGlmeS5fZ29Jbm5lcihidWYubyksXG4gICAgICAgICAgICBxOiB0ZXhpZnkuX2dvSW5uZXIoYnVmLnEpLFxuICAgICAgICAgICAgZDogdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5kKVxuICAgICAgICAgIH07XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBhXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoYjUuYSkge1xuICAgICAgICAgICAgaWYgKGI1LmEubWF0Y2goL15bK1xcLV0vKSkgeyBiNS5hID0gXCJ7XCIrYjUuYStcIn1cIjsgfVxuICAgICAgICAgICAgcmVzICs9IGI1LmEgKyBcIlxcXFwsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gYiBhbmQgcFxuICAgICAgICAgIC8vXG4gICAgICAgICAgaWYgKGI1LmIgfHwgYjUucCkge1xuICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgIHJlcyArPSBcIl57XFxcXGhwaGFudG9te1wiKyhiNS5ifHxcIlwiKStcIn19X3tcXFxcaHBoYW50b217XCIrKGI1LnB8fFwiXCIpK1wifX1cIjtcbiAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICAvLyBJbiB0aGUgbmV4dCB0d28gbGluZXMsIEkndmUgcmVtb3ZlZCBcXHNtYXNoW3RdIChyb24pXG4gICAgICAgICAgICAvLyBUT0RPOiBSZXZlcnQgXFxzbWFzaFt0XSB3aGVuIFdlYktpdCBwcm9wZXJseSByZW5kZXJzIDxtcGFkZGVkPiB3L2hlaWdodD1cIjBcIlxuICAgICAgICAgICAgLy9yZXMgKz0gXCJee1xcXFxzbWFzaFt0XXtcXFxcdnBoYW50b217Mn19XFxcXG1hdGhsbGFwe1wiKyhiNS5ifHxcIlwiKStcIn19XCI7XG4gICAgICAgICAgICByZXMgKz0gXCJee1xcXFx2cGhhbnRvbXsyfVxcXFxtYXRobGxhcHtcIisoYjUuYnx8XCJcIikrXCJ9fVwiO1xuICAgICAgICAgICAgLy9yZXMgKz0gXCJfe1xcXFx2cGhhbnRvbXsyfVxcXFxtYXRobGxhcHtcXFxcc21hc2hbdF17XCIrKGI1LnB8fFwiXCIpK1wifX19XCI7XG4gICAgICAgICAgICByZXMgKz0gXCJfe1xcXFx2cGhhbnRvbXsyfVxcXFxtYXRobGxhcHtcIisoYjUucHx8XCJcIikrXCJ9fVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIG9cbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChiNS5vKSB7XG4gICAgICAgICAgICBpZiAoYjUuby5tYXRjaCgvXlsrXFwtXS8pKSB7IGI1Lm8gPSBcIntcIitiNS5vK1wifVwiOyB9XG4gICAgICAgICAgICByZXMgKz0gYjUubztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBxIGFuZCBkXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoYnVmLmRUeXBlID09PSAna3YnKSB7XG4gICAgICAgICAgICBpZiAoYjUuZCB8fCBiNS5xKSB7XG4gICAgICAgICAgICAgIHJlcyArPSBcIntcXFxcdnBoYW50b217WH19XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYjUuZCkge1xuICAgICAgICAgICAgICByZXMgKz0gXCJee1wiK2I1LmQrXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYjUucSkge1xuICAgICAgICAgICAgICAvLyBJbiB0aGUgbmV4dCBsaW5lLCBJJ3ZlIHJlbW92ZWQgXFxzbWFzaFt0XSAocm9uKVxuICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZlcnQgXFxzbWFzaFt0XSB3aGVuIFdlYktpdCBwcm9wZXJseSByZW5kZXJzIDxtcGFkZGVkPiB3L2hlaWdodD1cIjBcIlxuICAgICAgICAgICAgICAvL3JlcyArPSBcIl97XFxcXHNtYXNoW3Rde1wiK2I1LnErXCJ9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJfe1wiK2I1LnErXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChidWYuZFR5cGUgPT09ICdveGlkYXRpb24nKSB7XG4gICAgICAgICAgICBpZiAoYjUuZCkge1xuICAgICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJee1wiK2I1LmQrXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYjUucSkge1xuICAgICAgICAgICAgICAvLyBBIEZpcmVmb3ggYnVnIGFkZHMgYSBib2d1cyBkZXB0aCB0byA8bXBoYW50b20+LCBzbyB3ZSBjaGFuZ2UgXFx2cGhhbnRvbXtYfSB0byB7fVxuICAgICAgICAgICAgICAvLyBUT0RPOiBSZWluc3RhdGUgXFx2cGhhbnRvbXtYfSB3aGVuIHRoZSBGaXJlZm94IGJ1ZyBpcyBmaXhlZC5cbi8vICAgICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJ7e319XCI7XG4gICAgICAgICAgICAgIC8vIEluIHRoZSBuZXh0IGxpbmUsIEkndmUgcmVtb3ZlZCBcXHNtYXNoW3RdIChyb24pXG4gICAgICAgICAgICAgIC8vIFRPRE86IFJldmVydCBcXHNtYXNoW3RdIHdoZW4gV2ViS2l0IHByb3Blcmx5IHJlbmRlcnMgPG1wYWRkZWQ+IHcvaGVpZ2h0PVwiMFwiXG4gICAgICAgICAgICAgIC8vcmVzICs9IFwiX3tcXFxcc21hc2hbdF17XCIrYjUucStcIn19XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl97XCIrYjUucStcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGI1LnEpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogUmVpbnN0YXRlIFxcdnBoYW50b217WH0gd2hlbiB0aGUgRmlyZWZveCBidWcgaXMgZml4ZWQuXG4vLyAgICAgICAgICAgICAgcmVzICs9IFwie1xcXFx2cGhhbnRvbXtYfX1cIjtcbiAgICAgICAgICAgICAgcmVzICs9IFwie3t9fVwiO1xuICAgICAgICAgICAgICAvLyBJbiB0aGUgbmV4dCBsaW5lLCBJJ3ZlIHJlbW92ZWQgXFxzbWFzaFt0XSAocm9uKVxuICAgICAgICAgICAgICAvLyBUT0RPOiBSZXZlcnQgXFxzbWFzaFt0XSB3aGVuIFdlYktpdCBwcm9wZXJseSByZW5kZXJzIDxtcGFkZGVkPiB3L2hlaWdodD1cIjBcIlxuICAgICAgICAgICAgICAvL3JlcyArPSBcIl97XFxcXHNtYXNoW3Rde1wiK2I1LnErXCJ9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJfe1wiK2I1LnErXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYjUuZCkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBSZWluc3RhdGUgXFx2cGhhbnRvbXtYfSB3aGVuIHRoZSBGaXJlZm94IGJ1ZyBpcyBmaXhlZC5cbi8vICAgICAgICAgICAgICByZXMgKz0gXCJ7XFxcXHZwaGFudG9te1h9fVwiO1xuICAgICAgICAgICAgICByZXMgKz0gXCJ7e319XCI7XG4gICAgICAgICAgICAgIHJlcyArPSBcIl57XCIrYjUuZCtcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JtJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxtYXRocm17XCIrYnVmLnAxK1wifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICBpZiAoYnVmLnAxLm1hdGNoKC9bXFxeX10vKSkge1xuICAgICAgICAgICAgYnVmLnAxID0gYnVmLnAxLnJlcGxhY2UoXCIgXCIsIFwiflwiKS5yZXBsYWNlKFwiLVwiLCBcIlxcXFx0ZXh0ey19XCIpO1xuICAgICAgICAgICAgcmVzID0gXCJcXFxcbWF0aHJte1wiK2J1Zi5wMStcIn1cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gXCJcXFxcdGV4dHtcIitidWYucDErXCJ9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyb21hbiBudW1lcmFsJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxtYXRocm17XCIrYnVmLnAxK1wifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdGF0ZSBvZiBhZ2dyZWdhdGlvbic6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbXNraXAybXUgXCIrdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0YXRlIG9mIGFnZ3JlZ2F0aW9uIHN1YnNjcmlwdCc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbXNraXAxbXUgXCIrdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvbmQnOlxuICAgICAgICAgIHJlcyA9IHRleGlmeS5fZ2V0Qm9uZChidWYua2luZF8pO1xuICAgICAgICAgIGlmICghcmVzKSB7XG4gICAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1FcnJvckJvbmRcIiwgXCJtaGNoZW0gRXJyb3IuIFVua25vd24gYm9uZCB0eXBlIChcIiArIGJ1Zi5raW5kXyArIFwiKVwiXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZyYWMnOlxuICAgICAgICAgIHZhciBjID0gXCJcXFxcZnJhY3tcIiArIGJ1Zi5wMSArIFwifXtcIiArIGJ1Zi5wMiArIFwifVwiO1xuICAgICAgICAgIHJlcyA9IFwiXFxcXG1hdGhjaG9pY2V7XFxcXHRleHRzdHlsZVwiK2MrXCJ9e1wiK2MrXCJ9e1wiK2MrXCJ9e1wiK2MrXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3B1LWZyYWMnOlxuICAgICAgICAgIHZhciBkID0gXCJcXFxcZnJhY3tcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICByZXMgPSBcIlxcXFxtYXRoY2hvaWNle1xcXFx0ZXh0c3R5bGVcIitkK1wifXtcIitkK1wifXtcIitkK1wifXtcIitkK1wifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0ZXgtbWF0aCc6XG4gICAgICAgICAgcmVzID0gYnVmLnAxICsgXCIgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZyYWMtY2UnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXGZyYWN7XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKSArIFwifXtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDIpICsgXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ292ZXJzZXQnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG92ZXJzZXR7XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKSArIFwifXtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDIpICsgXCJ9XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3VuZGVyc2V0JzpcbiAgICAgICAgICByZXMgPSBcIlxcXFx1bmRlcnNldHtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYucDEpICsgXCJ9e1wiICsgdGV4aWZ5Ll9nb0lubmVyKGJ1Zi5wMikgKyBcIn1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndW5kZXJicmFjZSc6XG4gICAgICAgICAgcmVzID0gIFwiXFxcXHVuZGVyYnJhY2V7XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAxKSArIFwifV97XCIgKyB0ZXhpZnkuX2dvSW5uZXIoYnVmLnAyKSArIFwifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb2xvcic6XG4gICAgICAgICAgcmVzID0gXCJ7XFxcXGNvbG9ye1wiICsgYnVmLmNvbG9yMSArIFwifXtcIiArIHRleGlmeS5fZ29Jbm5lcihidWYuY29sb3IyKSArIFwifX1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY29sb3IwJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxjb2xvcntcIiArIGJ1Zi5jb2xvciArIFwifVwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdhcnJvdyc6XG4gICAgICAgICAgdmFyIGI2ID0ge1xuICAgICAgICAgICAgcmQ6IHRleGlmeS5fZ29Jbm5lcihidWYucmQpLFxuICAgICAgICAgICAgcnE6IHRleGlmeS5fZ29Jbm5lcihidWYucnEpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB2YXIgYXJyb3cgPSB0ZXhpZnkuX2dldEFycm93KGJ1Zi5yKTtcbiAgICAgICAgICBpZiAoYjYucnEpIHsgYXJyb3cgKz0gXCJbe1xcXFxybSBcIiArIGI2LnJxICsgXCJ9XVwiOyB9XG4gICAgICAgICAgaWYgKGI2LnJkKSB7XG4gICAgICAgICAgICBhcnJvdyArPSBcIntcXFxccm0gXCIgKyBiNi5yZCArIFwifVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJvdyArPSBcInt9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcyA9IGFycm93O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvcGVyYXRvcic6XG4gICAgICAgICAgcmVzID0gdGV4aWZ5Ll9nZXRPcGVyYXRvcihidWYua2luZF8pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcxc3QtbGV2ZWwgZXNjYXBlJzpcbiAgICAgICAgICByZXMgPSBidWYucDErXCIgXCI7ICAvLyAmLCBcXFxcXFxcXCwgXFxcXGhsaW5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgIHJlcyA9IFwiIFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbnRpdHlTa2lwJzpcbiAgICAgICAgICByZXMgPSBcIn5cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHUtc3BhY2UtMSc6XG4gICAgICAgICAgcmVzID0gXCJ+XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3B1LXNwYWNlLTInOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXG1rZXJuM211IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcxMDAwIHNlcGFyYXRvcic6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbWtlcm4ybXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbW1hRGVjaW1hbCc6XG4gICAgICAgICAgcmVzID0gXCJ7LH1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjb21tYSBlbnVtZXJhdGlvbiBMJzpcbiAgICAgICAgICByZXMgPSBcIntcIitidWYucDErXCJ9XFxcXG1rZXJuNm11IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb21tYSBlbnVtZXJhdGlvbiBNJzpcbiAgICAgICAgICByZXMgPSBcIntcIitidWYucDErXCJ9XFxcXG1rZXJuM211IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb21tYSBlbnVtZXJhdGlvbiBTJzpcbiAgICAgICAgICByZXMgPSBcIntcIitidWYucDErXCJ9XFxcXG1rZXJuMW11IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdoeXBoZW4nOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXHRleHR7LX1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYWRkaXRpb24gY29tcG91bmQnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXCx7XFxcXGNkb3R9XFxcXCxcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZWxlY3Ryb24gZG90JzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjFtdSBcXFxcdGV4dHtcXFxcdGV4dGJ1bGxldH1cXFxcbWtlcm4xbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0tWIHgnOlxuICAgICAgICAgIHJlcyA9IFwie1xcXFx0aW1lc31cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHJpbWUnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXHByaW1lIFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjZG90JzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxjZG90IFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0aWdodCBjZG90JzpcbiAgICAgICAgICByZXMgPSBcIlxcXFxta2VybjFtdXtcXFxcY2RvdH1cXFxcbWtlcm4xbXUgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RpbWVzJzpcbiAgICAgICAgICByZXMgPSBcIlxcXFx0aW1lcyBcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2lyY2EnOlxuICAgICAgICAgIHJlcyA9IFwie1xcXFxzaW19XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIHJlcyA9IFwidXBhcnJvd1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICByZXMgPSBcImRvd25hcnJvd1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdlbGxpcHNpcyc6XG4gICAgICAgICAgcmVzID0gXCJcXFxcbGRvdHMgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgIHJlcyA9IFwiL1wiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcgLyAnOlxuICAgICAgICAgIHJlcyA9IFwiXFxcXCwvXFxcXCxcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhc3NlcnROZXZlcihidWYpO1xuICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1RcIiwgXCJtaGNoZW0gYnVnIFQuIFBsZWFzZSByZXBvcnQuXCJdOyAgLy8gTWlzc2luZyB0ZXhpZnkgcnVsZSBvciB1bmtub3duIE1oY2hlbVBhcnNlciBvdXRwdXRcbiAgICAgIH1cbiAgICAgIGFzc2VydFN0cmluZyhyZXMpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIF9nZXRBcnJvdzogZnVuY3Rpb24gKGEpIHtcbiAgICAgIHN3aXRjaCAoYSkge1xuICAgICAgICBjYXNlIFwiLT5cIjogcmV0dXJuIFwiXFxcXHlpZWxkc1wiO1xuICAgICAgICBjYXNlIFwiXFx1MjE5MlwiOiByZXR1cm4gXCJcXFxceWllbGRzXCI7XG4gICAgICAgIGNhc2UgXCJcXHUyN0Y2XCI6IHJldHVybiBcIlxcXFx5aWVsZHNcIjtcbiAgICAgICAgY2FzZSBcIjwtXCI6IHJldHVybiBcIlxcXFx5aWVsZHNMZWZ0XCI7XG4gICAgICAgIGNhc2UgXCI8LT5cIjogcmV0dXJuIFwiXFxcXG1lc29tZXJpc21cIjtcbiAgICAgICAgY2FzZSBcIjwtLT5cIjogcmV0dXJuIFwiXFxcXHlpZWxkc0xlZnRSaWdodFwiO1xuICAgICAgICBjYXNlIFwiPD0+XCI6IHJldHVybiBcIlxcXFxlcXVpbGlicml1bVwiO1xuICAgICAgICBjYXNlIFwiXFx1MjFDQ1wiOiByZXR1cm4gXCJcXFxcZXF1aWxpYnJpdW1cIjtcbiAgICAgICAgY2FzZSBcIjw9Pj5cIjogcmV0dXJuIFwiXFxcXGVxdWlsaWJyaXVtUmlnaHRcIjtcbiAgICAgICAgY2FzZSBcIjw8PT5cIjogcmV0dXJuIFwiXFxcXGVxdWlsaWJyaXVtTGVmdFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydE5ldmVyKGEpO1xuICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1RcIiwgXCJtaGNoZW0gYnVnIFQuIFBsZWFzZSByZXBvcnQuXCJdO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldEJvbmQ6IGZ1bmN0aW9uIChhKSB7XG4gICAgICBzd2l0Y2ggKGEpIHtcbiAgICAgICAgY2FzZSBcIi1cIjogcmV0dXJuIFwiey19XCI7XG4gICAgICAgIGNhc2UgXCIxXCI6IHJldHVybiBcInstfVwiO1xuICAgICAgICBjYXNlIFwiPVwiOiByZXR1cm4gXCJ7PX1cIjtcbiAgICAgICAgY2FzZSBcIjJcIjogcmV0dXJuIFwiez19XCI7XG4gICAgICAgIGNhc2UgXCIjXCI6IHJldHVybiBcIntcXFxcZXF1aXZ9XCI7XG4gICAgICAgIGNhc2UgXCIzXCI6IHJldHVybiBcIntcXFxcZXF1aXZ9XCI7XG4gICAgICAgIGNhc2UgXCJ+XCI6IHJldHVybiBcIntcXFxcdHJpcGxlRGFzaH1cIjtcbiAgICAgICAgY2FzZSBcIn4tXCI6IHJldHVybiBcIntcXFxcdHJpcGxlRGFzaE92ZXJMaW5lfVwiO1xuICAgICAgICBjYXNlIFwifj1cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVEYXNoT3ZlckRvdWJsZUxpbmV9XCI7XG4gICAgICAgIGNhc2UgXCJ+LS1cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVEYXNoT3ZlckRvdWJsZUxpbmV9XCI7XG4gICAgICAgIGNhc2UgXCItfi1cIjogcmV0dXJuIFwie1xcXFx0cmlwbGVEYXNoQmV0d2VlbkRvdWJsZUxpbmV9XCI7XG4gICAgICAgIGNhc2UgXCIuLi5cIjogcmV0dXJuIFwie3tcXFxcY2RvdH17XFxcXGNkb3R9e1xcXFxjZG90fX1cIjtcbiAgICAgICAgY2FzZSBcIi4uLi5cIjogcmV0dXJuIFwie3tcXFxcY2RvdH17XFxcXGNkb3R9e1xcXFxjZG90fXtcXFxcY2RvdH19XCI7XG4gICAgICAgIGNhc2UgXCItPlwiOiByZXR1cm4gXCJ7XFxcXHJpZ2h0YXJyb3d9XCI7XG4gICAgICAgIGNhc2UgXCI8LVwiOiByZXR1cm4gXCJ7XFxcXGxlZnRhcnJvd31cIjtcbiAgICAgICAgY2FzZSBcIjxcIjogcmV0dXJuIFwiezx9XCI7XG4gICAgICAgIGNhc2UgXCI+XCI6IHJldHVybiBcIns+fVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFzc2VydE5ldmVyKGEpO1xuICAgICAgICAgIHRocm93IFtcIk1oY2hlbUJ1Z1RcIiwgXCJtaGNoZW0gYnVnIFQuIFBsZWFzZSByZXBvcnQuXCJdO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldE9wZXJhdG9yOiBmdW5jdGlvbiAoYSkge1xuICAgICAgc3dpdGNoIChhKSB7XG4gICAgICAgIGNhc2UgXCIrXCI6IHJldHVybiBcIiB7fSt7fSBcIjtcbiAgICAgICAgY2FzZSBcIi1cIjogcmV0dXJuIFwiIHt9LXt9IFwiO1xuICAgICAgICBjYXNlIFwiPVwiOiByZXR1cm4gXCIge309e30gXCI7XG4gICAgICAgIGNhc2UgXCI8XCI6IHJldHVybiBcIiB7fTx7fSBcIjtcbiAgICAgICAgY2FzZSBcIj5cIjogcmV0dXJuIFwiIHt9Pnt9IFwiO1xuICAgICAgICBjYXNlIFwiPDxcIjogcmV0dXJuIFwiIHt9XFxcXGxse30gXCI7XG4gICAgICAgIGNhc2UgXCI+PlwiOiByZXR1cm4gXCIge31cXFxcZ2d7fSBcIjtcbiAgICAgICAgY2FzZSBcIlxcXFxwbVwiOiByZXR1cm4gXCIge31cXFxccG17fSBcIjtcbiAgICAgICAgY2FzZSBcIlxcXFxhcHByb3hcIjogcmV0dXJuIFwiIHt9XFxcXGFwcHJveHt9IFwiO1xuICAgICAgICBjYXNlIFwiJFxcXFxhcHByb3gkXCI6IHJldHVybiBcIiB7fVxcXFxhcHByb3h7fSBcIjtcbiAgICAgICAgY2FzZSBcInZcIjogcmV0dXJuIFwiIFxcXFxkb3duYXJyb3d7fSBcIjtcbiAgICAgICAgY2FzZSBcIih2KVwiOiByZXR1cm4gXCIgXFxcXGRvd25hcnJvd3t9IFwiO1xuICAgICAgICBjYXNlIFwiXlwiOiByZXR1cm4gXCIgXFxcXHVwYXJyb3d7fSBcIjtcbiAgICAgICAgY2FzZSBcIiheKVwiOiByZXR1cm4gXCIgXFxcXHVwYXJyb3d7fSBcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhc3NlcnROZXZlcihhKTtcbiAgICAgICAgICB0aHJvdyBbXCJNaGNoZW1CdWdUXCIsIFwibWhjaGVtIGJ1ZyBULiBQbGVhc2UgcmVwb3J0LlwiXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy9cbiAgLy8gSGVscGVycyBmb3IgY29kZSBhbmFseXNpc1xuICAvLyBXaWxsIHNob3cgdHlwZSBlcnJvciBhdCBjYWxsaW5nIHBvc2l0aW9uXG4gIC8vXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gYSAqL1xuICBmdW5jdGlvbiBhc3NlcnROZXZlcihhKSB7fVxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGEgKi9cbiAgZnVuY3Rpb24gYXNzZXJ0U3RyaW5nKGEpIHt9XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIHRleHZjLnN0eVxuXG4vLyBUaGUgdGV4dmMgcGFja2FnZSBjb250YWlucyBtYWNyb3MgYXZhaWxhYmxlIGluIG1lZGlhd2lraSBwYWdlcy5cbi8vIFdlIG9taXQgdGhlIGZ1bmN0aW9ucyBkZXByZWNhdGVkIGF0XG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWxwOkRpc3BsYXlpbmdfYV9mb3JtdWxhI0RlcHJlY2F0ZWRfc3ludGF4XG5cbi8vIFdlIGFsc28gb21pdCB0ZXh2YydzIFxcTywgd2hpY2ggY29uZmxpY3RzIHdpdGggXFx0ZXh0e1xcT31cblxuZGVmaW5lTWFjcm8oXCJcXFxcZGFyclwiLCBcIlxcXFxkb3duYXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkQXJyXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXERhcnJcIiwgXCJcXFxcRG93bmFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFuZ1wiLCBcIlxcXFxsYW5nbGVcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyYW5nXCIsIFwiXFxcXHJhbmdsZVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVhcnJcIiwgXCJcXFxcdXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHVBcnJcIiwgXCJcXFxcVXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFVhcnJcIiwgXCJcXFxcVXBhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXE5cIiwgXCJcXFxcbWF0aGJie059XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUlwiLCBcIlxcXFxtYXRoYmJ7Un1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxaXCIsIFwiXFxcXG1hdGhiYntafVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFsZWZcIiwgXCJcXFxcYWxlcGhcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhbGVmc3ltXCIsIFwiXFxcXGFsZXBoXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYnVsbFwiLCBcIlxcXFxidWxsZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjbHVic1wiLCBcIlxcXFxjbHVic3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNudW1zXCIsIFwiXFxcXG1hdGhiYntDfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXENvbXBsZXhcIiwgXCJcXFxcbWF0aGJie0N9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcRGFnZ2VyXCIsIFwiXFxcXGRkYWdnZXJcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkaWFtb25kc1wiLCBcIlxcXFxkaWFtb25kc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGVtcHR5XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXhpc3RcIiwgXCJcXFxcZXhpc3RzXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaGFyclwiLCBcIlxcXFxsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGhBcnJcIiwgXCJcXFxcTGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxIYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaGVhcnRzXCIsIFwiXFxcXGhlYXJ0c3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGltYWdlXCIsIFwiXFxcXEltXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcaW5maW5cIiwgXCJcXFxcaW5mdHlcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpc2luXCIsIFwiXFxcXGluXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFyclwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsQXJyXCIsIFwiXFxcXExlZnRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExhcnJcIiwgXCJcXFxcTGVmdGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbHJhcnJcIiwgXCJcXFxcbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxsckFyclwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZU1hY3JvKFwiXFxcXExyYXJyXCIsIFwiXFxcXExlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbmF0bnVtc1wiLCBcIlxcXFxtYXRoYmJ7Tn1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwbHVzbW5cIiwgXCJcXFxccG1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyYXJyXCIsIFwiXFxcXHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyQXJyXCIsIFwiXFxcXFJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSYXJyXCIsIFwiXFxcXFJpZ2h0YXJyb3dcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyZWFsXCIsIFwiXFxcXFJlXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccmVhbHNcIiwgXCJcXFxcbWF0aGJie1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcUmVhbHNcIiwgXCJcXFxcbWF0aGJie1J9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2RvdFwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc2VjdFwiLCBcIlxcXFxTXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3BhZGVzXCIsIFwiXFxcXHNwYWRlc3VpdFwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHN1YlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVNYWNybyhcIlxcXFxzdWJlXCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcc3VwZVwiLCBcIlxcXFxzdXBzZXRlcVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHRoZXRhc3ltXCIsIFwiXFxcXHZhcnRoZXRhXCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcd2VpZXJwXCIsIFwiXFxcXHdwXCIpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICpcbiAqICBwaHlzaWNzLmpzXG4gKlxuICogIEltcGxlbWVudHMgdGhlIFBoeXNpY3MgUGFja2FnZSBmb3IgTGFUZVggaW5wdXQuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICBUaGUgb3JpZ2luYWwgdmVyc2lvbiBvZiB0aGlzIGZpbGUgaXMgbGljZW5zZWQgYXMgZm9sbG93czpcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNiBLb2xlbiBDaGV1bmcgPGh0dHBzOi8vZ2l0aHViLmNvbS9pY2tjL01hdGhKYXgtdGhpcmQtcGFydHktZXh0ZW5zaW9ucz4uXG4gKlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgVGhpcyBmaWxlIGhhcyBiZWVuIHJldmlzZWQgZnJvbSB0aGUgb3JpZ2luYWwgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogIDEuIFRoZSBpbnRlcmZhY2UgaXMgY2hhbmdlZCBzbyB0aGF0IGl0IGNhbiBiZSBjYWxsZWQgZnJvbSBUZW1tbCwgbm90IE1hdGhKYXguXG4gKiAgMi4gXFxSZSBhbmQgXFxJbSBhcmUgbm90IHVzZWQsIHRvIGF2b2lkIGNvbmZsaWN0IHdpdGggZXhpc3RpbmcgTGFUZVggbGV0dGVycy5cbiAqXG4gKiAgVGhpcyByZXZpc2lvbiBvZiB0aGUgZmlsZSBpcyByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiAgaHR0cHM6Ly9taXQtbGljZW5zZS5vcmcvXG4gKi9cbmRlZmluZU1hY3JvKFwiXFxcXHF1YW50aXR5XCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXR5XCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccHF0eVwiLCBcIntcXFxcbGVmdCggIzEgXFxcXHJpZ2h0KX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxicXR5XCIsIFwie1xcXFxsZWZ0WyAjMSBcXFxccmlnaHRdfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZxdHlcIiwgXCJ7XFxcXGxlZnRcXFxcdmVydCAjMSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxCcXR5XCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcYWJzb2x1dGV2YWx1ZVwiLCBcIntcXFxcbGVmdFxcXFx2ZXJ0ICMxIFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFic1wiLCBcIntcXFxcbGVmdFxcXFx2ZXJ0ICMxIFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG5vcm1cIiwgXCJ7XFxcXGxlZnRcXFxcVmVydCAjMSBcXFxccmlnaHRcXFxcVmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxldmFsdWF0ZWRcIiwgXCJ7XFxcXGxlZnQuIzEgXFxcXHJpZ2h0XFxcXHZlcnR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXZhbFwiLCBcIntcXFxcbGVmdC4jMSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxvcmRlclwiLCBcIntcXFxcbWF0aGNhbHtPfSBcXFxcbGVmdCggIzEgXFxcXHJpZ2h0KX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjb21tdXRhdG9yXCIsIFwie1xcXFxsZWZ0WyAjMSAsICMyIFxcXFxyaWdodF19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcY29tbVwiLCBcIntcXFxcbGVmdFsgIzEgLCAjMiBcXFxccmlnaHRdfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGFudGljb21tdXRhdG9yXCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgLCAjMiBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxhY29tbVwiLCBcIntcXFxcbGVmdFxcXFx7ICMxICwgIzIgXFxcXHJpZ2h0XFxcXH19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccG9pc3NvbmJyYWNrZXRcIiwgXCJ7XFxcXGxlZnRcXFxceyAjMSAsICMyIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHBiXCIsIFwie1xcXFxsZWZ0XFxcXHsgIzEgLCAjMiBcXFxccmlnaHRcXFxcfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2ZWN0b3Jib2xkXCIsIFwie1xcXFxib2xkc3ltYm9seyAjMSB9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZiXCIsIFwie1xcXFxib2xkc3ltYm9seyAjMSB9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZlY3RvcmFycm93XCIsIFwie1xcXFx2ZWN7XFxcXGJvbGRzeW1ib2x7ICMxIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhXCIsIFwie1xcXFx2ZWN7XFxcXGJvbGRzeW1ib2x7ICMxIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZlY3RvcnVuaXRcIiwgXCJ7e1xcXFxib2xkc3ltYm9se1xcXFxoYXR7ICMxIH19fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFx2dVwiLCBcInt7XFxcXGJvbGRzeW1ib2x7XFxcXGhhdHsgIzEgfX19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRvdHByb2R1Y3RcIiwgXCJcXFxcbWF0aGJpbntcXFxcYm9sZHN5bWJvbFxcXFxjZG90fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZkb3RcIiwgXCJ7XFxcXGJvbGRzeW1ib2xcXFxcY2RvdH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjcm9zc3Byb2R1Y3RcIiwgXCJcXFxcbWF0aGJpbntcXFxcYm9sZHN5bWJvbFxcXFx0aW1lc31cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxjcm9zc1wiLCBcIlxcXFxtYXRoYmlue1xcXFxib2xkc3ltYm9sXFxcXHRpbWVzfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGNwXCIsIFwiXFxcXG1hdGhiaW57XFxcXGJvbGRzeW1ib2xcXFxcdGltZXN9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JhZGllbnRcIiwgXCJ7XFxcXGJvbGRzeW1ib2xcXFxcbmFibGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZ3JhZFwiLCBcIntcXFxcYm9sZHN5bWJvbFxcXFxuYWJsYX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkaXZlcmdlbmNlXCIsIFwie1xcXFxncmFkXFxcXHZkb3R9XCIpO1xuLy9kZWZpbmVNYWNybyhcIlxcXFxkaXZcIiwgXCJ7XFxcXGdyYWRcXFxcdmRvdH1cIik7IE5vdCBpbmNsdWRlZCBpbiBUZW1tbC4gQ29uZmxpY3RzIHcvTGFUZVggXFxkaXZcbmRlZmluZU1hY3JvKFwiXFxcXGN1cmxcIiwgXCJ7XFxcXGdyYWRcXFxcY3Jvc3N9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbGFwbGFjaWFuXCIsIFwiXFxcXG5hYmxhXjJcIik7XG5kZWZpbmVNYWNybyhcIlxcXFx0clwiLCBcIntcXFxcb3BlcmF0b3JuYW1le3RyfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxUclwiLCBcIntcXFxcb3BlcmF0b3JuYW1le1RyfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxyYW5rXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7cmFua319XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXJmXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7ZXJmfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxSZXNcIiwgXCJ7XFxcXG9wZXJhdG9ybmFtZXtSZXN9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHByaW5jaXBhbHZhbHVlXCIsIFwie1xcXFxtYXRoY2Fse1B9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHB2XCIsIFwie1xcXFxtYXRoY2Fse1B9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXFBWXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7UC5WLn19XCIpO1xuLy8gVGVtbWwgZG9lcyBub3QgdXNlIHRoZSBuZXh0IHR3byBsaW5lcy4gVGhleSBjb25mbGljdCB3aXRoIExhVGVYIGxldHRlcnMuXG4vL2RlZmluZU1hY3JvKFwiXFxcXFJlXCIsIFwie1xcXFxvcGVyYXRvcm5hbWV7UmV9IFxcXFxsZWZ0XFxcXHsgIzEgXFxcXHJpZ2h0XFxcXH19XCIpO1xuLy9kZWZpbmVNYWNybyhcIlxcXFxJbVwiLCBcIntcXFxcb3BlcmF0b3JuYW1le0ltfSBcXFxcbGVmdFxcXFx7ICMxIFxcXFxyaWdodFxcXFx9fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFxdGV4dFwiLCBcIntcXFxccXVhZFxcXFx0ZXh0eyAjMSB9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXFcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHsgIzEgfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFjb21tYVwiLCBcIntcXFxcdGV4dHssfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFjXCIsIFwie1xcXFx0ZXh0eyx9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWNjXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7Yy5jLn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxaWZcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtpZn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxdGhlblwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e3RoZW59XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWVsc2VcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtlbHNlfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFvdGhlcndpc2VcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtvdGhlcndpc2V9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccXVubGVzc1wiLCBcIntcXFxccXVhZFxcXFx0ZXh0e3VubGVzc31cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxZ2l2ZW5cIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtnaXZlbn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxdXNpbmdcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHt1c2luZ31cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxYXNzdW1lXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7YXNzdW1lfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFzaW5jZVwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e3NpbmNlfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFsZXRcIiwgXCJ7XFxcXHF1YWRcXFxcdGV4dHtsZXR9XFxcXHF1YWR9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxccWZvclwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2Zvcn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxYWxsXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7YWxsfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFldmVuXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7ZXZlbn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxb2RkXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7b2RkfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFpbnRlZ2VyXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7aW50ZWdlcn1cXFxccXVhZH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxxYW5kXCIsIFwie1xcXFxxdWFkXFxcXHRleHR7YW5kfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFvclwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e29yfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFhc1wiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2FzfVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHFpblwiLCBcIntcXFxccXVhZFxcXFx0ZXh0e2lufVxcXFxxdWFkfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGRpZmZlcmVudGlhbFwiLCBcIntcXFxcdGV4dHtkfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkZFwiLCBcIntcXFxcdGV4dHtkfX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxkZXJpdmF0aXZlXCIsIFwie1xcXFxmcmFje1xcXFx0ZXh0e2R9eyAjMSB9fXtcXFxcdGV4dHtkfXsgIzIgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZHZcIiwgXCJ7XFxcXGZyYWN7XFxcXHRleHR7ZH17ICMxIH19e1xcXFx0ZXh0e2R9eyAjMiB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxwYXJ0aWFsZGVyaXZhdGl2ZVwiLCBcIntcXFxcZnJhY3tcXFxccGFydGlhbHsgIzEgfX17XFxcXHBhcnRpYWx7ICMyIH19fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXHZhcmlhdGlvblwiLCBcIntcXFxcZGVsdGF9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcdmFyXCIsIFwie1xcXFxkZWx0YX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxmdW5jdGlvbmFsZGVyaXZhdGl2ZVwiLCBcIntcXFxcZnJhY3tcXFxcZGVsdGF7ICMxIH19e1xcXFxkZWx0YXsgIzIgfX19XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZmR2XCIsIFwie1xcXFxmcmFje1xcXFxkZWx0YXsgIzEgfX17XFxcXGRlbHRheyAjMiB9fX1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxpbm5lcnByb2R1Y3RcIiwgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xlIHsjMX0gXFxcXG1pZCB7ICMyfSBcXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG91dGVycHJvZHVjdFwiLFxuICBcIntcXFxcbGVmdFxcXFx2ZXJ0IHsgIzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlXFxcXGxlZnRcXFxcbGFuZ2xlIHsgIzJ9IFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGR5YWRcIixcbiAgXCJ7XFxcXGxlZnRcXFxcdmVydCB7ICMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZVxcXFxsZWZ0XFxcXGxhbmdsZSB7ICMyfSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxrZXRicmFcIixcbiAgXCJ7XFxcXGxlZnRcXFxcdmVydCB7ICMxIH0gXFxcXHJpZ2h0XFxcXHJhbmdsZVxcXFxsZWZ0XFxcXGxhbmdsZSB7ICMyfSBcXFxccmlnaHRcXFxcdmVydH1cIik7XG5kZWZpbmVNYWNybyhcIlxcXFxvcFwiLFxuICBcIntcXFxcbGVmdFxcXFx2ZXJ0IHsgIzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlXFxcXGxlZnRcXFxcbGFuZ2xlIHsgIzJ9IFxcXFxyaWdodFxcXFx2ZXJ0fVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV4cGVjdGF0aW9udmFsdWVcIiwgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xlIHsjMSB9IFxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcZXhwdmFsXCIsIFwie1xcXFxsZWZ0XFxcXGxhbmdsZSB7IzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXGV2XCIsIFwie1xcXFxsZWZ0XFxcXGxhbmdsZSB7IzEgfSBcXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcbmRlZmluZU1hY3JvKFwiXFxcXG1hdHJpeGVsZW1lbnRcIixcbiAgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xleyAjMSB9XFxcXHJpZ2h0XFxcXHZlcnR7ICMyIH1cXFxcbGVmdFxcXFx2ZXJ0eyMzfVxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWF0cml4ZWxcIixcbiAgXCJ7XFxcXGxlZnRcXFxcbGFuZ2xleyAjMSB9XFxcXHJpZ2h0XFxcXHZlcnR7ICMyIH1cXFxcbGVmdFxcXFx2ZXJ0eyMzfVxcXFxyaWdodFxcXFxyYW5nbGV9XCIpO1xuZGVmaW5lTWFjcm8oXCJcXFxcbWVsXCIsXG4gIFwie1xcXFxsZWZ0XFxcXGxhbmdsZXsgIzEgfVxcXFxyaWdodFxcXFx2ZXJ0eyAjMiB9XFxcXGxlZnRcXFxcdmVydHsjM31cXFxccmlnaHRcXFxccmFuZ2xlfVwiKTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0SExpbmVzKHBhcnNlcikge1xuICAvLyBSZXR1cm4gYW4gYXJyYXkuIFRoZSBhcnJheSBsZW5ndGggPSBudW1iZXIgb2YgaGxpbmVzLlxuICAvLyBFYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5IHRlbGxzIGlmIHRoZSBsaW5lIGlzIGRhc2hlZC5cbiAgY29uc3QgaGxpbmVJbmZvID0gW107XG4gIHBhcnNlci5jb25zdW1lU3BhY2VzKCk7XG4gIGxldCBueHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICBpZiAobnh0ID09PSBcIlxcXFxyZWxheFwiKSB7XG4gICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gIH1cbiAgd2hpbGUgKG54dCA9PT0gXCJcXFxcaGxpbmVcIiB8fCBueHQgPT09IFwiXFxcXGhkYXNobGluZVwiKSB7XG4gICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICBobGluZUluZm8ucHVzaChueHQgPT09IFwiXFxcXGhkYXNobGluZVwiKTtcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIG54dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gIH1cbiAgcmV0dXJuIGhsaW5lSW5mbztcbn1cblxuY29uc3QgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBjb250ZXh0LnBhcnNlci5zZXR0aW5ncztcbiAgaWYgKCFzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGB7JHtjb250ZXh0LmVudk5hbWV9fSBjYW4gYmUgdXNlZCBvbmx5IGluIGRpc3BsYXkgbW9kZS5gKTtcbiAgfVxufTtcblxuY29uc3Qgc2l6ZVJlZ0V4JDEgPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvO1xuY29uc3QgYXJyYXlHYXBzID0gbWFjcm9zID0+IHtcbiAgbGV0IGFycmF5c3RyZXRjaCA9IG1hY3Jvcy5nZXQoXCJcXFxcYXJyYXlzdHJldGNoXCIpO1xuICBpZiAodHlwZW9mIGFycmF5c3RyZXRjaCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGFycmF5c3RyZXRjaCA9IHN0cmluZ0Zyb21BcmcoYXJyYXlzdHJldGNoLnRva2Vucyk7XG4gIH1cbiAgYXJyYXlzdHJldGNoID0gaXNOYU4oYXJyYXlzdHJldGNoKSA/IG51bGwgOiBOdW1iZXIoYXJyYXlzdHJldGNoKTtcbiAgbGV0IGFycmF5Y29sc2VwU3RyID0gbWFjcm9zLmdldChcIlxcXFxhcnJheWNvbHNlcFwiKTtcbiAgaWYgKHR5cGVvZiBhcnJheWNvbHNlcFN0ciAhPT0gXCJzdHJpbmdcIikge1xuICAgIGFycmF5Y29sc2VwU3RyID0gc3RyaW5nRnJvbUFyZyhhcnJheWNvbHNlcFN0ci50b2tlbnMpO1xuICB9XG4gIGNvbnN0IG1hdGNoID0gc2l6ZVJlZ0V4JDEuZXhlYyhhcnJheWNvbHNlcFN0cik7XG4gIGNvbnN0IGFycmF5Y29sc2VwID0gbWF0Y2hcbiAgICA/IHsgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCB1bml0OiBtYXRjaFszXSB9XG4gICAgOiBudWxsO1xuICByZXR1cm4gW2FycmF5c3RyZXRjaCwgYXJyYXljb2xzZXBdXG59O1xuXG5jb25zdCBjaGVja0NlbGxGb3JMYWJlbHMgPSBjZWxsID0+IHtcbiAgLy8gQ2hlY2sgaWYgdGhlIGF1dGhvciB3cm90ZSBhIFxcdGFne30gaW5zaWRlIHRoaXMgY2VsbC5cbiAgbGV0IHJvd0xhYmVsID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNlbGxbaV0udHlwZSA9PT0gXCJsYWJlbFwiKSB7XG4gICAgICBpZiAocm93TGFiZWwpIHsgdGhyb3cgbmV3IFBhcnNlRXJyb3IoKFwiTXVsdGlwbGUgXFxcXGxhYmVscyBpbiBvbmUgcm93XCIpKSB9XG4gICAgICByb3dMYWJlbCA9IGNlbGxbaV0uc3RyaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcm93TGFiZWxcbn07XG5cbi8vIGF1dG9UYWcgKGFuIGFyZ3VtZW50IHRvIHBhcnNlQXJyYXkpIGNhbiBiZSBvbmUgb2YgdGhyZWUgdmFsdWVzOlxuLy8gKiB1bmRlZmluZWQ6IFJlZ3VsYXIgKG5vdC10b3AtbGV2ZWwpIGFycmF5OyBubyB0YWdzIG9uIGVhY2ggcm93XG4vLyAqIHRydWU6IEF1dG9tYXRpYyBlcXVhdGlvbiBudW1iZXJpbmcsIG92ZXJyaWRhYmxlIGJ5IFxcdGFnXG4vLyAqIGZhbHNlOiBUYWdzIGFsbG93ZWQgb24gZWFjaCByb3csIGJ1dCBubyBhdXRvbWF0aWMgbnVtYmVyaW5nXG4vLyBUaGlzIGZ1bmN0aW9uICpkb2Vzbid0KiB3b3JrIHdpdGggdGhlIFwic3BsaXRcIiBlbnZpcm9ubWVudCBuYW1lLlxuZnVuY3Rpb24gZ2V0QXV0b1RhZyhuYW1lKSB7XG4gIGlmIChuYW1lLmluZGV4T2YoXCJlZFwiKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gbmFtZS5pbmRleE9mKFwiKlwiKSA9PT0gLTE7XG4gIH1cbiAgLy8gcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLiAgSWYgZ2l2ZW4gYW4gb3B0aW9uYWwgYXJndW1lbnQgc2NyaXB0TGV2ZWxcbiAqIChcInRleHRcIiwgXCJkaXNwbGF5XCIsIGV0Yy4pLCB0aGVuIGVhY2ggY2VsbCBpcyBjYXN0IGludG8gdGhhdCBzY3JpcHRMZXZlbC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBcnJheShcbiAgcGFyc2VyLFxuICB7XG4gICAgY29scywgLy8gW3sgdHlwZTogc3RyaW5nICwgYWxpZ246IGx8Y3xyfG51bGwgfV1cbiAgICBlbnZDbGFzc2VzLCAvLyBhbGlnbihlZHxhdHxlZGF0KSB8IGFycmF5IHwgY2FzZXMgfCBjZCB8IHNtYWxsIHwgbXVsdGxpbmVcbiAgICBhdXRvVGFnLCAgICAgICAgLy8gYm9vbGVhblxuICAgIHNpbmdsZVJvdywgICAgICAvLyBib29sZWFuXG4gICAgZW1wdHlTaW5nbGVSb3csIC8vIGJvb2xlYW5cbiAgICBtYXhOdW1Db2xzLCAgICAgLy8gbnVtYmVyXG4gICAgbGVxbm8sICAgICAgICAgIC8vIGJvb2xlYW5cbiAgICBhcnJheXN0cmV0Y2gsICAgLy8gbnVtYmVyICB8IG51bGxcbiAgICBhcnJheWNvbHNlcCAgICAgLy8gc2l6ZSB2YWx1ZSB8IG51bGxcbn0sXG4gIHNjcmlwdExldmVsXG4pIHtcbiAgY29uc3QgZW5kVG9rZW4gPSBlbnZDbGFzc2VzICYmIGVudkNsYXNzZXMuaW5jbHVkZXMoXCJib3JkZXJtYXRyaXhcIikgPyBcIn1cIiA6IFwiXFxcXGVuZFwiO1xuICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgaWYgKCFzaW5nbGVSb3cpIHtcbiAgICAvLyBcXGNyIGlzIGVxdWl2YWxlbnQgdG8gXFxcXCB3aXRob3V0IHRoZSBvcHRpb25hbCBzaXplIGFyZ3VtZW50IChzZWUgYmVsb3cpXG4gICAgLy8gVE9ETzogcHJvdmlkZSBoZWxwZnVsIGVycm9yIHdoZW4gXFxjciBpcyB1c2VkIG91dHNpZGUgYXJyYXkgZW52aXJvbm1lbnRcbiAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY3JcIiwgXCJcXFxcXFxcXFxcXFxyZWxheFwiKTtcbiAgfVxuXG4gIC8vIFN0YXJ0IGdyb3VwIGZvciBmaXJzdCBjZWxsXG4gIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuXG4gIGxldCByb3cgPSBbXTtcbiAgY29uc3QgYm9keSA9IFtyb3ddO1xuICBjb25zdCByb3dHYXBzID0gW107XG4gIGNvbnN0IGxhYmVscyA9IFtdO1xuXG4gIGNvbnN0IGhMaW5lc0JlZm9yZVJvdyA9IFtdO1xuXG4gIGNvbnN0IHRhZ3MgPSAoYXV0b1RhZyAhPSBudWxsID8gW10gOiB1bmRlZmluZWQpO1xuXG4gIC8vIGFtc21hdGggdXNlcyBcXGdsb2JhbFxcQGVxbnN3dHJ1ZSBhbmQgXFxnbG9iYWxcXEBlcW5zd2ZhbHNlIHRvIHJlcHJlc2VudFxuICAvLyB3aGV0aGVyIHRoaXMgcm93IHNob3VsZCBoYXZlIGFuIGVxdWF0aW9uIG51bWJlci4gIFNpbXVsYXRlIHRoaXMgd2l0aFxuICAvLyBhIFxcQGVxbnN3IG1hY3JvIHNldCB0byAxIG9yIDAuXG4gIGZ1bmN0aW9uIGJlZ2luUm93KCkge1xuICAgIGlmIChhdXRvVGFnKSB7XG4gICAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcQGVxbnN3XCIsIFwiMVwiLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW5kUm93KCkge1xuICAgIGlmICh0YWdzKSB7XG4gICAgICBpZiAocGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgICAgICB0YWdzLnB1c2gocGFyc2VyLnN1YnBhcnNlKFtuZXcgVG9rZW4oXCJcXFxcZGZAdGFnXCIpXSkpO1xuICAgICAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcZGZAdGFnXCIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdzLnB1c2goQm9vbGVhbihhdXRvVGFnKSAmJlxuICAgICAgICAgICAgcGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXEBlcW5zd1wiKSA9PT0gXCIxXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBiZWdpblJvdygpO1xuXG4gIC8vIFRlc3QgZm9yIFxcaGxpbmUgYXQgdGhlIHRvcCBvZiB0aGUgYXJyYXkuXG4gIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFBhcnNlIGVhY2ggY2VsbCBpbiBpdHMgb3duIGdyb3VwIChuYW1lc3BhY2UpXG4gICAgbGV0IGNlbGwgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBzaW5nbGVSb3cgPyBcIlxcXFxlbmRcIiA6IFwiXFxcXFxcXFxcIik7XG4gICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpO1xuICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuXG4gICAgY2VsbCA9IHtcbiAgICAgIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogY2VsbCxcbiAgICAgIHNlbWlzaW1wbGU6IHRydWVcbiAgICB9O1xuICAgIHJvdy5wdXNoKGNlbGwpO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgaWYgKG1heE51bUNvbHMgJiYgcm93Lmxlbmd0aCA9PT0gbWF4TnVtQ29scykge1xuICAgICAgICBpZiAoZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImFycmF5XCIpKSB7XG4gICAgICAgICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVG9vIGZldyBjb2x1bW5zIFwiICsgXCJzcGVjaWZpZWQgaW4gdGhlIHthcnJheX0gY29sdW1uIGFyZ3VtZW50LlwiLFxuICAgICAgICAgICAgICBwYXJzZXIubmV4dFRva2VuKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXhOdW1Db2xzID09PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUaGUgc3BsaXQgZW52aXJvbm1lbnQgYWNjZXB0cyBubyBtb3JlIHRoYW4gdHdvIGNvbHVtbnNcIixcbiAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVGhlIGVxdWF0aW9uIGVudmlyb25tZW50IGFjY2VwdHMgb25seSBvbmUgY29sdW1uXCIsXG4gICAgICAgICAgICBwYXJzZXIubmV4dFRva2VuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gZW5kVG9rZW4pIHtcbiAgICAgIGVuZFJvdygpO1xuICAgICAgLy8gQXJyYXlzIHRlcm1pbmF0ZSBuZXdsaW5lcyB3aXRoIGBcXGNyY3JgIHdoaWNoIGNvbnN1bWVzIGEgYFxcY3JgIGlmXG4gICAgICAvLyB0aGUgbGFzdCBsaW5lIGlzIGVtcHR5LiAgSG93ZXZlciwgQU1TIGVudmlyb25tZW50cyBrZWVwIHRoZVxuICAgICAgLy8gZW1wdHkgcm93IGlmIGl0J3MgdGhlIG9ubHkgb25lLlxuICAgICAgLy8gTk9URTogQ3VycmVudGx5LCBgY2VsbGAgaXMgdGhlIGxhc3QgaXRlbSBhZGRlZCBpbnRvIGByb3dgLlxuICAgICAgaWYgKHJvdy5sZW5ndGggPT09IDEgJiYgY2VsbC5ib2R5Lmxlbmd0aCA9PT0gMCAmJiAoYm9keS5sZW5ndGggPiAxIHx8ICFlbXB0eVNpbmdsZVJvdykpIHtcbiAgICAgICAgYm9keS5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGxhYmVscy5wdXNoKGNoZWNrQ2VsbEZvckxhYmVscyhjZWxsLmJvZHkpKTtcbiAgICAgIGlmIChoTGluZXNCZWZvcmVSb3cubGVuZ3RoIDwgYm9keS5sZW5ndGggKyAxKSB7XG4gICAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKFtdKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcXFxcXFwiKSB7XG4gICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgbGV0IHNpemU7XG4gICAgICAvLyBcXGRlZlxcTGV0QHtcXGxldFxcXFxcXG1hdGhAY3J9XG4gICAgICAvLyBcXGRlZlxcbWF0aEBjcnsuLi5cXG1hdGhAY3JAfVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAe1xcbmV3QGlmbmV4dGNoYXJbXFxtYXRoQGNyQEB7XFxtYXRoQGNyQEBbXFx6QF19fVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAQFsjMV17Li4uXFxtYXRoQGNyQEBALi4ufVxuICAgICAgLy8gXFxkZWZcXG1hdGhAY3JAQEB7XFxjcn1cbiAgICAgIGlmIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwiIFwiKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZXIucGFyc2VTaXplR3JvdXAodHJ1ZSk7XG4gICAgICB9XG4gICAgICByb3dHYXBzLnB1c2goc2l6ZSA/IHNpemUudmFsdWUgOiBudWxsKTtcbiAgICAgIGVuZFJvdygpO1xuXG4gICAgICBsYWJlbHMucHVzaChjaGVja0NlbGxGb3JMYWJlbHMoY2VsbC5ib2R5KSk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBcXGhsaW5lKHMpIGZvbGxvd2luZyB0aGUgcm93IHNlcGFyYXRvclxuICAgICAgaExpbmVzQmVmb3JlUm93LnB1c2goZ2V0SExpbmVzKHBhcnNlcikpO1xuXG4gICAgICByb3cgPSBbXTtcbiAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgYmVnaW5Sb3coKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCAmIG9yIFxcXFxcXFxcIG9yIFxcXFxjciBvciBcIiArIGVuZFRva2VuLCBwYXJzZXIubmV4dFRva2VuKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmQgY2VsbCBncm91cFxuICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gIC8vIEVuZCBhcnJheSBncm91cCBkZWZpbmluZyBcXGNyXG4gIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTtcblxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICBib2R5LFxuICAgIGNvbHMsXG4gICAgcm93R2FwcyxcbiAgICBoTGluZXNCZWZvcmVSb3csXG4gICAgZW52Q2xhc3NlcyxcbiAgICBhdXRvVGFnLFxuICAgIHNjcmlwdExldmVsLFxuICAgIHRhZ3MsXG4gICAgbGFiZWxzLFxuICAgIGxlcW5vLFxuICAgIGFycmF5c3RyZXRjaCxcbiAgICBhcnJheWNvbHNlcFxuICB9O1xufVxuXG4vLyBEZWNpZGVzIG9uIGEgc2NyaXB0TGV2ZWwgZm9yIGNlbGxzIGluIGFuIGFycmF5IGFjY29yZGluZyB0byB3aGV0aGVyIHRoZSBnaXZlblxuLy8gZW52aXJvbm1lbnQgbmFtZSBzdGFydHMgd2l0aCB0aGUgbGV0dGVyICdkJy5cbmZ1bmN0aW9uIGRDZWxsU3R5bGUoZW52TmFtZSkge1xuICByZXR1cm4gZW52TmFtZS5zbGljZSgwLCAxKSA9PT0gXCJkXCIgPyBcImRpc3BsYXlcIiA6IFwidGV4dFwiXG59XG5cbmNvbnN0IGFsaWduTWFwID0ge1xuICBjOiBcImNlbnRlciBcIixcbiAgbDogXCJsZWZ0IFwiLFxuICByOiBcInJpZ2h0IFwiXG59O1xuXG5jb25zdCBnbHVlID0gZ3JvdXAgPT4ge1xuICBjb25zdCBnbHVlTm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdKTtcbiAgZ2x1ZU5vZGUuc3R5bGUgPSB7IHBhZGRpbmc6IFwiMFwiLCB3aWR0aDogXCI1MCVcIiB9O1xuICBpZiAoZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcIm11bHRsaW5lXCIpKSB7XG4gICAgZ2x1ZU5vZGUuc3R5bGUud2lkdGggPSBcIjcuNSVcIjtcbiAgfVxuICByZXR1cm4gZ2x1ZU5vZGVcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkOSA9IGZ1bmN0aW9uKGdyb3VwLCBzdHlsZSkge1xuICBjb25zdCB0YmwgPSBbXTtcbiAgY29uc3QgbnVtUm93cyA9IGdyb3VwLmJvZHkubGVuZ3RoO1xuICBjb25zdCBobGluZXMgPSBncm91cC5oTGluZXNCZWZvcmVSb3c7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Sb3dzOyBpKyspIHtcbiAgICBjb25zdCBydyA9IGdyb3VwLmJvZHlbaV07XG4gICAgY29uc3Qgcm93ID0gW107XG4gICAgY29uc3QgY2VsbExldmVsID0gZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwidGV4dFwiXG4gICAgICA/IFN0eWxlTGV2ZWwuVEVYVFxuICAgICAgOiBncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJzY3JpcHRcIlxuICAgICAgPyBTdHlsZUxldmVsLlNDUklQVFxuICAgICAgOiBTdHlsZUxldmVsLkRJU1BMQVk7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJ3Lmxlbmd0aDsgaisrKSB7XG4gICAgICBjb25zdCBtdGQgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtdGRcIixcbiAgICAgICAgW2J1aWxkR3JvdXAkMShyd1tqXSwgc3R5bGUud2l0aExldmVsKGNlbGxMZXZlbCkpXVxuICAgICAgKTtcblxuICAgICAgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJtdWx0bGluZVwiKSkge1xuICAgICAgICBjb25zdCBhbGlnbiA9IGkgPT09IDAgPyBcImxlZnRcIiA6IGkgPT09IG51bVJvd3MgLSAxID8gXCJyaWdodFwiIDogXCJjZW50ZXJcIjtcbiAgICAgICAgbXRkLnNldEF0dHJpYnV0ZShcImNvbHVtbmFsaWduXCIsIGFsaWduKTtcbiAgICAgICAgaWYgKGFsaWduICE9PSBcImNlbnRlclwiKSB7XG4gICAgICAgICAgbXRkLmNsYXNzZXMucHVzaChcInRtbC1cIiArIGFsaWduKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcm93LnB1c2gobXRkKTtcbiAgICB9XG4gICAgY29uc3QgbnVtQ29sdW1ucyA9IGdyb3VwLmJvZHlbMF0ubGVuZ3RoO1xuICAgIC8vIEZpbGwgb3V0IGEgc2hvcnQgcm93IHdpdGggZW1wdHkgPG10ZD4gZWxlbWVudHMuXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBudW1Db2x1bW5zIC0gcncubGVuZ3RoOyBrKyspIHtcbiAgICAgIHJvdy5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtdLCBzdHlsZSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAuYXV0b1RhZykge1xuICAgICAgY29uc3QgdGFnID0gZ3JvdXAudGFnc1tpXTtcbiAgICAgIGxldCB0YWdFbGVtZW50O1xuICAgICAgaWYgKHRhZyA9PT0gdHJ1ZSkgeyAgLy8gYXV0b21hdGljIG51bWJlcmluZ1xuICAgICAgICB0YWdFbGVtZW50ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbbmV3IFNwYW4oW1widG1sLWVxblwiXSldKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnID09PSBmYWxzZSkge1xuICAgICAgICAvLyBcXG5vbnVtYmVyL1xcbm90YWcgb3Igc3RhcnJlZCBlbnZpcm9ubWVudFxuICAgICAgICB0YWdFbGVtZW50ID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbXSwgW10pO1xuICAgICAgfSBlbHNlIHsgIC8vIG1hbnVhbCBcXHRhZ1xuICAgICAgICB0YWdFbGVtZW50ID0gYnVpbGRFeHByZXNzaW9uUm93KHRhZ1swXS5ib2R5LCBzdHlsZS53aXRoTGV2ZWwoY2VsbExldmVsKSwgdHJ1ZSk7XG4gICAgICAgIHRhZ0VsZW1lbnQgPSBjb25zb2xpZGF0ZVRleHQodGFnRWxlbWVudCk7XG4gICAgICAgIHRhZ0VsZW1lbnQuY2xhc3NlcyA9IFtcInRtbC10YWdcIl07XG4gICAgICB9XG4gICAgICBpZiAodGFnRWxlbWVudCkge1xuICAgICAgICByb3cudW5zaGlmdChnbHVlKGdyb3VwKSk7XG4gICAgICAgIHJvdy5wdXNoKGdsdWUoZ3JvdXApKTtcbiAgICAgICAgaWYgKGdyb3VwLmxlcW5vKSB7XG4gICAgICAgICAgcm93WzBdLmNoaWxkcmVuLnB1c2godGFnRWxlbWVudCk7XG4gICAgICAgICAgcm93WzBdLmNsYXNzZXMucHVzaChcInRtbC1sZWZ0XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvd1tyb3cubGVuZ3RoIC0gMV0uY2hpbGRyZW4ucHVzaCh0YWdFbGVtZW50KTtcbiAgICAgICAgICByb3dbcm93Lmxlbmd0aCAtIDFdLmNsYXNzZXMucHVzaChcInRtbC1yaWdodFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtdHIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCByb3csIFtdKTtcbiAgICBjb25zdCBsYWJlbCA9IGdyb3VwLmxhYmVscy5zaGlmdCgpO1xuICAgIGlmIChsYWJlbCAmJiBncm91cC50YWdzICYmIGdyb3VwLnRhZ3NbaV0pIHtcbiAgICAgIG10ci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBsYWJlbCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShncm91cC50YWdzW2ldKSkgeyBtdHIuY2xhc3Nlcy5wdXNoKFwidG1sLXRhZ2VxblwiKTsgfVxuICAgIH1cblxuICAgIC8vIFdyaXRlIGhvcml6b250YWwgcnVsZXNcbiAgICBpZiAoaSA9PT0gMCAmJiBobGluZXNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKGhsaW5lc1swXS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbXRyLmNoaWxkcmVuLmZvckVhY2goY2VsbCA9PiB7IGNlbGwuc3R5bGUuYm9yZGVyVG9wID0gXCIwLjE1ZW0gZG91YmxlXCI7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXRyLmNoaWxkcmVuLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgY2VsbC5zdHlsZS5ib3JkZXJUb3AgPSBobGluZXNbMF1bMF0gPyBcIjAuMDZlbSBkYXNoZWRcIiA6IFwiMC4wNmVtIHNvbGlkXCI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGxpbmVzW2kgKyAxXS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAoaGxpbmVzW2kgKyAxXS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgbXRyLmNoaWxkcmVuLmZvckVhY2goY2VsbCA9PiB7IGNlbGwuc3R5bGUuYm9yZGVyQm90dG9tID0gXCIwLjE1ZW0gZG91YmxlXCI7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXRyLmNoaWxkcmVuLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgY2VsbC5zdHlsZS5ib3JkZXJCb3R0b20gPSBobGluZXNbaSArIDFdWzBdID8gXCIwLjA2ZW0gZGFzaGVkXCIgOiBcIjAuMDZlbSBzb2xpZFwiO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgXFxocGhhbnRvbSBcXGZyb20gXFxib3JkZXJtYXRyaXhcbiAgICBsZXQgbXVzdFNxdWFzaFJvdyA9IHRydWU7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtdHIuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbXRyLmNoaWxkcmVuW2pdLmNoaWxkcmVuWzBdO1xuICAgICAgaWYgKCEoY2hpbGQgJiYgY2hpbGQudHlwZSA9PT0gXCJtcGFkZGVkXCIgJiYgY2hpbGQuYXR0cmlidXRlcy5oZWlnaHQgPT09IFwiMHB4XCIpKSB7XG4gICAgICAgIG11c3RTcXVhc2hSb3cgPSBmYWxzZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG11c3RTcXVhc2hSb3cpIHtcbiAgICAgIC8vIEFsbCB0aGUgY2VsbCBjb250ZW50cyBhcmUgXFxocGhhbnRvbS4gU3F1YXNoIHRoZSBwYWRkaW5nLlxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtdHIuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbXRyLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdUb3AgPSBcIjBcIjtcbiAgICAgICAgbXRyLmNoaWxkcmVuW2pdLnN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YmwucHVzaChtdHIpO1xuICB9XG5cbiAgaWYgKGdyb3VwLmFycmF5c3RyZXRjaCAmJiBncm91cC5hcnJheXN0cmV0Y2ggIT09IDEpIHtcbiAgICAvLyBJbiBMYVRlWCwgXFxhcnJheXN0cmV0Y2ggaXMgYSBmYWN0b3IgYXBwbGllZCB0byBhIDEycHQgc3RydXQgaGVpZ2h0LlxuICAgIC8vIEl0IGRlZmluZXMgYSBiYXNlbGluZSB0byBiYXNlbGluZSBkaXN0YW5jZS5cbiAgICAvLyBIZXJlLCB3ZSBkbyBhbiBhcHByb3hpbWF0aW9uIG9mIHRoYXQgYXBwcm9hY2guXG4gICAgY29uc3QgcGFkID0gU3RyaW5nKDEuNCAqIGdyb3VwLmFycmF5c3RyZXRjaCAtIDAuOCkgKyBcImV4XCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YmwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGJsW2ldLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nVG9wID0gcGFkO1xuICAgICAgICB0YmxbaV0uY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ0JvdHRvbSA9IHBhZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgc2lkZVBhZGRpbmc7XG4gIGxldCBzaWRlUGFkVW5pdDtcbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgIHNpZGVQYWRkaW5nID0gZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImFidXRcIilcbiAgICAgID8gXCIwXCJcbiAgICAgIDogZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImNhc2VzXCIpXG4gICAgICA/IFwiMFwiXG4gICAgICA6IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJzbWFsbFwiKVxuICAgICAgPyBcIjAuMTM4OVwiXG4gICAgICA6IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJjZFwiKVxuICAgICAgPyBcIjAuMjVcIlxuICAgICAgOiBcIjAuNFwiOyAvLyBkZWZhdWx0IHNpZGUgcGFkZGluZ1xuICAgIHNpZGVQYWRVbml0ID0gXCJlbVwiO1xuICB9XG4gIGlmIChncm91cC5hcnJheWNvbHNlcCkge1xuICAgIGNvbnN0IGFycmF5U2lkZVBhZCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuYXJyYXljb2xzZXAsIHN0eWxlKTtcbiAgICBzaWRlUGFkZGluZyA9IGFycmF5U2lkZVBhZC5udW1iZXIudG9GaXhlZCg0KTtcbiAgICBzaWRlUGFkVW5pdCA9IGFycmF5U2lkZVBhZC51bml0O1xuICB9XG4gIGlmIChzaWRlUGFkZGluZykge1xuICAgIGNvbnN0IG51bUNvbHMgPSB0YmwubGVuZ3RoID09PSAwID8gMCA6IHRibFswXS5jaGlsZHJlbi5sZW5ndGg7XG5cbiAgICBjb25zdCBzaWRlUGFkID0gKGosIGhhbmQpID0+IHtcbiAgICAgIGlmIChqID09PSAwICYmIGhhbmQgPT09IDApIHsgcmV0dXJuIFwiMFwiIH1cbiAgICAgIGlmIChqID09PSBudW1Db2xzIC0gMSAmJiBoYW5kID09PSAxKSB7IHJldHVybiBcIjBcIiB9XG4gICAgICBpZiAoZ3JvdXAuZW52Q2xhc3Nlc1swXSAhPT0gXCJhbGlnblwiKSB7IHJldHVybiBzaWRlUGFkZGluZyB9XG4gICAgICBpZiAoaGFuZCA9PT0gMSkgeyByZXR1cm4gXCIwXCIgfVxuICAgICAgaWYgKGdyb3VwLmF1dG9UYWcpIHtcbiAgICAgICAgcmV0dXJuIChqICUgMikgPyBcIjFcIiA6IFwiMFwiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKGogJSAyKSA/IFwiMFwiIDogXCIxXCJcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gU2lkZSBwYWRkaW5nXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YmwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGJsW2ldLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRibFtpXS5jaGlsZHJlbltqXS5zdHlsZS5wYWRkaW5nTGVmdCA9IGAke3NpZGVQYWQoaiwgMCl9JHtzaWRlUGFkVW5pdH1gO1xuICAgICAgICB0YmxbaV0uY2hpbGRyZW5bal0uc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7c2lkZVBhZChqLCAxKX0ke3NpZGVQYWRVbml0fWA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChncm91cC5lbnZDbGFzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIFNldCB6ZXJvIHBhZGRpbmcgb24gc2lkZSBvZiB0aGUgbWF0cml4XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YmwubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRibFtpXS5jaGlsZHJlblswXS5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiMGVtXCI7XG4gICAgICBpZiAodGJsW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gdGJsWzBdLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0YmxbaV0uY2hpbGRyZW5bdGJsW2ldLmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMGVtXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgIC8vIEp1c3RpZmljYXRpb25cbiAgICBjb25zdCBhbGlnbiA9IGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJhbGlnblwiKSB8fCBncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiYWxpZ25hdFwiKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRibC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgcm93ID0gdGJsW2ldO1xuICAgICAgaWYgKGFsaWduKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93LmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgLy8gQ2hyb21pdW0gZG9lcyBub3QgcmVjb2duaXplIHRleHQtYWxpZ246IGxlZnQuIFVzZSAtd2Via2l0LVxuICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSAtd2Via2l0LSB3aGVuIENocm9taXVtIG5vIGxvbmdlciBuZWVkcyBpdC5cbiAgICAgICAgICByb3cuY2hpbGRyZW5bal0uY2xhc3NlcyA9IFtcInRtbC1cIiArIChqICUgMiA/IFwibGVmdFwiIDogXCJyaWdodFwiKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwLmF1dG9UYWcpIHtcbiAgICAgICAgICBjb25zdCBrID0gZ3JvdXAubGVxbm8gPyAwIDogcm93LmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgICAgcm93LmNoaWxkcmVuW2tdLmNsYXNzZXMgPSBbXCJ0bWwtXCIgKyAoZ3JvdXAubGVxbm8gPyBcImxlZnRcIiA6IFwicmlnaHRcIildO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocm93LmNoaWxkcmVuLmxlbmd0aCA+IDEgJiYgZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcImNhc2VzXCIpKSB7XG4gICAgICAgIHJvdy5jaGlsZHJlblsxXS5zdHlsZS5wYWRkaW5nTGVmdCA9IFwiMWVtXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwiY2FzZXNcIikgfHwgZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcInN1YmFycmF5XCIpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2VsbCBvZiByb3cuY2hpbGRyZW4pIHtcbiAgICAgICAgICBjZWxsLmNsYXNzZXMucHVzaChcInRtbC1sZWZ0XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGFibGVcIiwgdGJsKTtcbiAgaWYgKGdyb3VwLmVudkNsYXNzZXMubGVuZ3RoID4gMCkge1xuICAgIC8vIFRvcCAmIGJvdHRvbSBwYWRkaW5nXG4gICAgaWYgKGdyb3VwLmVudkNsYXNzZXMuaW5jbHVkZXMoXCJqb3RcIikpIHtcbiAgICAgIHRhYmxlLmNsYXNzZXMucHVzaChcInRtbC1qb3RcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwic21hbGxcIikpIHtcbiAgICAgIHRhYmxlLmNsYXNzZXMucHVzaChcInRtbC1zbWFsbFwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKGdyb3VwLnNjcmlwdExldmVsID09PSBcImRpc3BsYXlcIikgeyB0YWJsZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgXCJ0cnVlXCIpOyB9XG5cbiAgaWYgKGdyb3VwLmF1dG9UYWcgfHwgZ3JvdXAuZW52Q2xhc3Nlcy5pbmNsdWRlcyhcIm11bHRsaW5lXCIpKSB7XG4gICAgdGFibGUuc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgfVxuXG4gIC8vIENvbHVtbiBzZXBhcmF0b3IgbGluZXMgYW5kIGNvbHVtbiBhbGlnbm1lbnRcbiAgbGV0IGFsaWduID0gXCJcIjtcblxuICBpZiAoZ3JvdXAuY29scyAmJiBncm91cC5jb2xzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb2xzID0gZ3JvdXAuY29scztcbiAgICBsZXQgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgIGxldCBpU3RhcnQgPSAwO1xuICAgIGxldCBpRW5kID0gY29scy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoY29sc1tpU3RhcnRdLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgIGlTdGFydCArPSAxO1xuICAgIH1cbiAgICB3aGlsZSAoY29sc1tpRW5kIC0gMV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgaUVuZCAtPSAxO1xuICAgIH1cblxuICAgIGlmIChjb2xzWzBdLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgIGNvbnN0IHNlcCA9IGNvbHNbMV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIlxuICAgICAgICA/IFwiMC4xNWVtIGRvdWJsZVwiXG4gICAgICAgIDogY29sc1swXS5zZXBhcmF0b3IgPT09IFwifFwiXG4gICAgICAgID8gXCIwLjA2ZW0gc29saWQgXCJcbiAgICAgICAgOiBcIjAuMDZlbSBkYXNoZWQgXCI7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZS5jaGlsZHJlbikge1xuICAgICAgICByb3cuY2hpbGRyZW5bMF0uc3R5bGUuYm9yZGVyTGVmdCA9IHNlcDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGlDb2wgPSBncm91cC5hdXRvVGFnID8gMCA6IC0xO1xuICAgIGZvciAobGV0IGkgPSBpU3RhcnQ7IGkgPCBpRW5kOyBpKyspIHtcbiAgICAgIGlmIChjb2xzW2ldLnR5cGUgPT09IFwiYWxpZ25cIikge1xuICAgICAgICBjb25zdCBjb2xBbGlnbiA9IGFsaWduTWFwW2NvbHNbaV0uYWxpZ25dO1xuICAgICAgICBhbGlnbiArPSBjb2xBbGlnbjtcbiAgICAgICAgaUNvbCArPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZS5jaGlsZHJlbikge1xuICAgICAgICAgIGlmIChjb2xBbGlnbi50cmltKCkgIT09IFwiY2VudGVyXCIgJiYgaUNvbCA8IHJvdy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJvdy5jaGlsZHJlbltpQ29sXS5jbGFzc2VzID0gW1widG1sLVwiICsgY29sQWxpZ24udHJpbSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldlR5cGVXYXNBbGlnbiA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGNvbHNbaV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIikge1xuICAgICAgICAvLyBNYXRoTUwgYWNjZXB0cyBvbmx5IHNpbmdsZSBsaW5lcyBiZXR3ZWVuIGNlbGxzLlxuICAgICAgICAvLyBTbyB3ZSByZWFkIG9ubHkgdGhlIGZpcnN0IG9mIGNvbnNlY3V0aXZlIHNlcGFyYXRvcnMuXG4gICAgICAgIGlmIChwcmV2VHlwZVdhc0FsaWduKSB7XG4gICAgICAgICAgY29uc3Qgc2VwID0gY29sc1tpICsgMV0udHlwZSA9PT0gXCJzZXBhcmF0b3JcIlxuICAgICAgICAgICAgPyBcIjAuMTVlbSBkb3VibGVcIlxuICAgICAgICAgICAgOiBjb2xzW2ldLnNlcGFyYXRvciA9PT0gXCJ8XCJcbiAgICAgICAgICAgID8gXCIwLjA2ZW0gc29saWRcIlxuICAgICAgICAgICAgOiBcIjAuMDZlbSBkYXNoZWRcIjtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0YWJsZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGlDb2wgPCByb3cuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJvdy5jaGlsZHJlbltpQ29sXS5zdHlsZS5ib3JkZXJSaWdodCA9IHNlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldlR5cGVXYXNBbGlnbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sc1tjb2xzLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwic2VwYXJhdG9yXCIpIHtcbiAgICAgIGNvbnN0IHNlcCA9IGNvbHNbY29scy5sZW5ndGggLSAyXS50eXBlID09PSBcInNlcGFyYXRvclwiXG4gICAgICAgID8gXCIwLjE1ZW0gZG91YmxlXCJcbiAgICAgICAgOiBjb2xzW2NvbHMubGVuZ3RoIC0gMV0uc2VwYXJhdG9yID09PSBcInxcIlxuICAgICAgICA/IFwiMC4wNmVtIHNvbGlkXCJcbiAgICAgICAgOiBcIjAuMDZlbSBkYXNoZWRcIjtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJvdy5jaGlsZHJlbltyb3cuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3R5bGUuYm9yZGVyUmlnaHQgPSBzZXA7XG4gICAgICAgIHJvdy5jaGlsZHJlbltyb3cuY2hpbGRyZW4ubGVuZ3RoIC0gMV0uc3R5bGUucGFkZGluZ1JpZ2h0ID0gXCIwLjRlbVwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZ3JvdXAuYXV0b1RhZykge1xuICAgICAvLyBhbGxvdyBmb3IgZ2x1ZSBjZWxscyBvbiBlYWNoIHNpZGVcbiAgICBhbGlnbiA9IFwibGVmdCBcIiArIChhbGlnbi5sZW5ndGggPiAwID8gYWxpZ24gOiBcImNlbnRlciBcIikgKyBcInJpZ2h0IFwiO1xuICB9XG4gIGlmIChhbGlnbikge1xuICAgIC8vIEZpcmVmb3ggcmVhZHMgdGhpcyBhdHRyaWJ1dGUsIG5vdCB0aGUgLXdlYmtpdC1sZWZ0fHJpZ2h0IHdyaXR0ZW4gYWJvdmUuXG4gICAgLy8gVE9ETzogV2hlbiBDaHJvbWUgbm8gbG9uZ2VyIG5lZWRzIFwiLXdlYmtpdC1cIiwgdXNlIENTUyBhbmQgZGVsZXRlIHRoZSBuZXh0IGxpbmUuXG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwiY29sdW1uYWxpZ25cIiwgYWxpZ24udHJpbSgpKTtcbiAgfVxuXG4gIGlmIChncm91cC5lbnZDbGFzc2VzLmluY2x1ZGVzKFwic21hbGxcIikpIHtcbiAgICAvLyBBIHNtYWxsIGFycmF5LiBXcmFwIGluIHNjcmlwdHN0eWxlLlxuICAgIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW3RhYmxlXSk7XG4gICAgdGFibGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIxXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRhYmxlXG59O1xuXG4vLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgYWxpZ24sIGFsaWduKiwgYWxpZ25lZCwgYWxpZ25hdCwgYWxpZ25hdCosIGFsaWduZWRhdCwgc3BsaXQuXG5jb25zdCBhbGlnbmVkSGFuZGxlciA9IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgaWYgKGNvbnRleHQuZW52TmFtZS5pbmRleE9mKFwiZWRcIikgPT09IC0xKSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gIH1cbiAgY29uc3QgaXNTcGxpdCA9IGNvbnRleHQuZW52TmFtZSA9PT0gXCJzcGxpdFwiO1xuICBjb25zdCBjb2xzID0gW107XG4gIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoXG4gICAgY29udGV4dC5wYXJzZXIsXG4gICAge1xuICAgICAgY29scyxcbiAgICAgIGVtcHR5U2luZ2xlUm93OiB0cnVlLFxuICAgICAgYXV0b1RhZzogaXNTcGxpdCA/IHVuZGVmaW5lZCA6IGdldEF1dG9UYWcoY29udGV4dC5lbnZOYW1lKSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImFidXRcIiwgXCJqb3RcIl0sIC8vIHNldCByb3cgc3BhY2luZyAmIHByb3Zpc2lvbmFsIGNvbHVtbiBzcGFjaW5nXG4gICAgICBtYXhOdW1Db2xzOiBjb250ZXh0LmVudk5hbWUgPT09IFwic3BsaXRcIiA/IDIgOiB1bmRlZmluZWQsXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9LFxuICAgIFwiZGlzcGxheVwiXG4gICk7XG5cbiAgLy8gRGV0ZXJtaW5pbmcgbnVtYmVyIG9mIGNvbHVtbnMuXG4gIC8vIDEuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBnaXZlbiwgd2UgdXNlIGl0IGFzIGEgbnVtYmVyIG9mIGNvbHVtbnMsXG4gIC8vICAgIGFuZCBtYWtlcyBzdXJlIHRoYXQgZWFjaCByb3cgZG9lc24ndCBleGNlZWQgdGhhdCBudW1iZXIuXG4gIC8vIDIuIE90aGVyd2lzZSwganVzdCBjb3VudCBudW1iZXIgb2YgY29sdW1ucyA9IG1heGltdW0gbnVtYmVyXG4gIC8vICAgIG9mIGNlbGxzIGluIGVhY2ggcm93IChcImFsaWduZWRcIiBtb2RlIC0tIGlzQWxpZ25lZCB3aWxsIGJlIHRydWUpLlxuICAvL1xuICAvLyBBdCB0aGUgc2FtZSB0aW1lLCBwcmVwZW5kIGVtcHR5IGdyb3VwIHt9IGF0IGJlZ2lubmluZyBvZiBldmVyeSBzZWNvbmRcbiAgLy8gY2VsbCBpbiBlYWNoIHJvdyAoc3RhcnRpbmcgd2l0aCBzZWNvbmQgY2VsbCkgc28gdGhhdCBvcGVyYXRvcnMgYmVjb21lXG4gIC8vIGJpbmFyeS4gIFRoaXMgYmVoYXZpb3IgaXMgaW1wbGVtZW50ZWQgaW4gYW1zbWF0aCdzIFxcc3RhcnRAYWxpZ25lZC5cbiAgbGV0IG51bU1hdGhzO1xuICBsZXQgbnVtQ29scyA9IDA7XG4gIGNvbnN0IGlzQWxpZ25lZEF0ID0gY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJhdFwiKSA+IC0xO1xuICBpZiAoYXJnc1swXSAmJiBpc0FsaWduZWRBdCkge1xuICAgIC8vIGFsaWduYXQgZW52aXJvbm1lbnQgdGFrZXMgYW4gYXJndW1lbnQgdy8gbnVtYmVyIG9mIGNvbHVtbnNcbiAgICBsZXQgYXJnMCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzWzBdLmJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHRvcmQgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLmJvZHlbaV0sIFwidGV4dG9yZFwiKTtcbiAgICAgIGFyZzAgKz0gdGV4dG9yZC50ZXh0O1xuICAgIH1cbiAgICBpZiAoaXNOYU4oYXJnMCkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVGhlIGFsaWduYXQgZW52aXJvbWVudCByZXF1aXJlcyBhIG51bWVyaWMgZmlyc3QgYXJndW1lbnQuXCIpXG4gICAgfVxuICAgIG51bU1hdGhzID0gTnVtYmVyKGFyZzApO1xuICAgIG51bUNvbHMgPSBudW1NYXRocyAqIDI7XG4gIH1cbiAgcmVzLmJvZHkuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBpZiAoaXNBbGlnbmVkQXQpIHtcbiAgICAgIC8vIENhc2UgMVxuICAgICAgY29uc3QgY3VyTWF0aHMgPSByb3cubGVuZ3RoIC8gMjtcbiAgICAgIGlmIChudW1NYXRocyA8IGN1ck1hdGhzKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgIFwiVG9vIG1hbnkgbWF0aCBpbiBhIHJvdzogXCIgKyBgZXhwZWN0ZWQgJHtudW1NYXRoc30sIGJ1dCBnb3QgJHtjdXJNYXRoc31gLFxuICAgICAgICAgIHJvd1swXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobnVtQ29scyA8IHJvdy5sZW5ndGgpIHtcbiAgICAgIC8vIENhc2UgMlxuICAgICAgbnVtQ29scyA9IHJvdy5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICAvLyBBZGp1c3RpbmcgYWxpZ25tZW50LlxuICAvLyBJbiBhbGlnbmVkIG1vZGUsIHdlIGFkZCBvbmUgXFxxcXVhZCBiZXR3ZWVuIGNvbHVtbnM7XG4gIC8vIG90aGVyd2lzZSB3ZSBhZGQgbm90aGluZy5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db2xzOyArK2kpIHtcbiAgICBsZXQgYWxpZ24gPSBcInJcIjtcbiAgICBpZiAoaSAlIDIgPT09IDEpIHtcbiAgICAgIGFsaWduID0gXCJsXCI7XG4gICAgfVxuICAgIGNvbHNbaV0gPSB7XG4gICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICBhbGlnbjogYWxpZ25cbiAgICB9O1xuICB9XG4gIGlmIChjb250ZXh0LmVudk5hbWUgPT09IFwic3BsaXRcIikgOyBlbHNlIGlmIChpc0FsaWduZWRBdCkge1xuICAgIHJlcy5lbnZDbGFzc2VzLnB1c2goXCJhbGlnbmF0XCIpOyAvLyBTZXRzIGp1c3RpZmljYXRpb25cbiAgfSBlbHNlIHtcbiAgICByZXMuZW52Q2xhc3Nlc1swXSA9IFwiYWxpZ25cIjsgLy8gU2V0cyBjb2x1bW4gc3BhY2luZyAmIGp1c3RpZmljYXRpb25cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuLy8gQXJyYXlzIGFyZSBwYXJ0IG9mIExhVGVYLCBkZWZpbmVkIGluIGx0dGFiLmR0eCBzbyBpdHMgZG9jdW1lbnRhdGlvblxuLy8gaXMgcGFydCBvZiB0aGUgc291cmNlMmUucGRmIGZpbGUgb2YgTGFUZVgyZSBzb3VyY2UgZG9jdW1lbnRhdGlvbi5cbi8vIHtkYXJyYXl9IGlzIGFuIHthcnJheX0gZW52aXJvbm1lbnQgd2hlcmUgY2VsbHMgYXJlIHNldCBpbiBcXGRpc3BsYXlzdHlsZSxcbi8vIGFzIGRlZmluZWQgaW4gbmNjbWF0aC5zdHkuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcImFycmF5XCIsIFwiZGFycmF5XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgLy8gU2luY2Ugbm8gdHlwZXMgYXJlIHNwZWNpZmllZCBhYm92ZSwgdGhlIHR3byBwb3NzaWJpbGl0aWVzIGFyZVxuICAgIC8vIC0gVGhlIGFyZ3VtZW50IGlzIHdyYXBwZWQgaW4ge30gb3IgW10sIGluIHdoaWNoIGNhc2UgUGFyc2VyJ3NcbiAgICAvLyAgIHBhcnNlR3JvdXAoKSByZXR1cm5zIGFuIFwib3JkZ3JvdXBcIiB3cmFwcGluZyBzb21lIHN5bWJvbCBub2RlLlxuICAgIC8vIC0gVGhlIGFyZ3VtZW50IGlzIGEgYmFyZSBzeW1ib2wgbm9kZS5cbiAgICBjb25zdCBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTtcbiAgICBjb25zdCBjb2xhbGlnbiA9IHN5bU5vZGUgPyBbYXJnc1swXV0gOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcIm9yZGdyb3VwXCIpLmJvZHk7XG4gICAgY29uc3QgY29scyA9IGNvbGFsaWduLm1hcChmdW5jdGlvbihuZGUpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBhc3NlcnRTeW1ib2xOb2RlVHlwZShuZGUpO1xuICAgICAgY29uc3QgY2EgPSBub2RlLnRleHQ7XG4gICAgICBpZiAoXCJsY3JcIi5pbmRleE9mKGNhKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgYWxpZ246IGNhXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGNhID09PSBcInxcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgc2VwYXJhdG9yOiBcInxcIlxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjYSA9PT0gXCI6XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcInNlcGFyYXRvclwiLFxuICAgICAgICAgIHNlcGFyYXRvcjogXCI6XCJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIGNhLCBuZGUpO1xuICAgIH0pO1xuICAgIGNvbnN0IFthcnJheXN0cmV0Y2gsIGFycmF5Y29sc2VwXSA9IGFycmF5R2Fwcyhjb250ZXh0LnBhcnNlci5ndWxsZXQubWFjcm9zKTtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBjb2xzLFxuICAgICAgZW52Q2xhc3NlczogW1wiYXJyYXlcIl0sXG4gICAgICBtYXhOdW1Db2xzOiBjb2xzLmxlbmd0aCxcbiAgICAgIGFycmF5c3RyZXRjaCxcbiAgICAgIGFycmF5Y29sc2VwXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBUaGUgbWF0cml4IGVudmlyb25tZW50cyBvZiBhbXNtYXRoIGJ1aWxkIG9uIHRoZSBhcnJheSBlbnZpcm9ubWVudFxuLy8gb2YgTGFUZVgsIHdoaWNoIGlzIGRpc2N1c3NlZCBhYm92ZS5cbi8vIFRoZSBtYXRodG9vbHMgcGFja2FnZSBhZGRzIHN0YXJyZWQgdmVyc2lvbnMgb2YgdGhlIHNhbWUgZW52aXJvbm1lbnRzLlxuLy8gVGhlc2UgaGF2ZSBhbiBvcHRpb25hbCBhcmd1bWVudCB0byBjaG9vc2UgbGVmdHxjZW50ZXJ8cmlnaHQganVzdGlmaWNhdGlvbi5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1xuICAgIFwibWF0cml4XCIsXG4gICAgXCJwbWF0cml4XCIsXG4gICAgXCJibWF0cml4XCIsXG4gICAgXCJCbWF0cml4XCIsXG4gICAgXCJ2bWF0cml4XCIsXG4gICAgXCJWbWF0cml4XCIsXG4gICAgXCJtYXRyaXgqXCIsXG4gICAgXCJwbWF0cml4KlwiLFxuICAgIFwiYm1hdHJpeCpcIixcbiAgICBcIkJtYXRyaXgqXCIsXG4gICAgXCJ2bWF0cml4KlwiLFxuICAgIFwiVm1hdHJpeCpcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgY29uc3QgZGVsaW1pdGVycyA9IHtcbiAgICAgIG1hdHJpeDogbnVsbCxcbiAgICAgIHBtYXRyaXg6IFtcIihcIiwgXCIpXCJdLFxuICAgICAgYm1hdHJpeDogW1wiW1wiLCBcIl1cIl0sXG4gICAgICBCbWF0cml4OiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgdm1hdHJpeDogW1wifFwiLCBcInxcIl0sXG4gICAgICBWbWF0cml4OiBbXCJcXFxcVmVydFwiLCBcIlxcXFxWZXJ0XCJdXG4gICAgfVtjb250ZXh0LmVudk5hbWUucmVwbGFjZShcIipcIiwgXCJcIildO1xuICAgIC8vIFxcaHNraXAgLVxcYXJyYXljb2xzZXAgaW4gYW1zbWF0aFxuICAgIGxldCBjb2xBbGlnbiA9IFwiY1wiO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBlbnZDbGFzc2VzOiBbXSxcbiAgICAgIGNvbHM6IFtdXG4gICAgfTtcbiAgICBpZiAoY29udGV4dC5lbnZOYW1lLmNoYXJBdChjb250ZXh0LmVudk5hbWUubGVuZ3RoIC0gMSkgPT09IFwiKlwiKSB7XG4gICAgICAvLyBJdCdzIG9uZSBvZiB0aGUgbWF0aHRvb2xzIHN0YXJyZWQgZnVuY3Rpb25zLlxuICAgICAgLy8gUGFyc2UgdGhlIG9wdGlvbmFsIGFsaWdubWVudCBhcmd1bWVudC5cbiAgICAgIGNvbnN0IHBhcnNlciA9IGNvbnRleHQucGFyc2VyO1xuICAgICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgIGlmIChwYXJzZXIuZmV0Y2goKS50ZXh0ID09PSBcIltcIikge1xuICAgICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgICAgICBjb2xBbGlnbiA9IHBhcnNlci5mZXRjaCgpLnRleHQ7XG4gICAgICAgIGlmIChcImxjclwiLmluZGV4T2YoY29sQWxpZ24pID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRXhwZWN0ZWQgbCBvciBjIG9yIHJcIiwgcGFyc2VyLm5leHRUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgICAgcGFyc2VyLmV4cGVjdChcIl1cIik7XG4gICAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICAgIHBheWxvYWQuY29scyA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBcInRleHRcIik7XG4gICAgcmVzLmNvbHMgPSBuZXcgQXJyYXkocmVzLmJvZHlbMF0ubGVuZ3RoKS5maWxsKHsgdHlwZTogXCJhbGlnblwiLCBhbGlnbjogY29sQWxpZ24gfSk7XG4gICAgY29uc3QgW2FycmF5c3RyZXRjaCwgYXJyYXljb2xzZXBdID0gYXJyYXlHYXBzKGNvbnRleHQucGFyc2VyLmd1bGxldC5tYWNyb3MpO1xuICAgIHJlcy5hcnJheXN0cmV0Y2ggPSBhcnJheXN0cmV0Y2g7XG4gICAgaWYgKGFycmF5Y29sc2VwICYmICEoYXJyYXljb2xzZXAgPT09IDYgJiYgYXJyYXljb2xzZXAgPT09IFwicHRcIikpIHtcbiAgICAgIHJlcy5hcnJheWNvbHNlcCA9IGFycmF5Y29sc2VwO1xuICAgIH1cbiAgICByZXR1cm4gZGVsaW1pdGVyc1xuICAgICAgPyB7XG4gICAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICAgICAgYm9keTogW3Jlc10sXG4gICAgICAgIGxlZnQ6IGRlbGltaXRlcnNbMF0sXG4gICAgICAgIHJpZ2h0OiBkZWxpbWl0ZXJzWzFdLFxuICAgICAgICByaWdodENvbG9yOiB1bmRlZmluZWQgLy8gXFxyaWdodCB1bmluZmx1ZW5jZWQgYnkgXFxjb2xvciBpbiBhcnJheVxuICAgICAgfVxuICAgICAgOiByZXM7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYm9yZGVybWF0cml4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgY29sczogW10sIGVudkNsYXNzZXM6IFtcImJvcmRlcm1hdHJpeFwiXSB9O1xuICAgIGNvbnN0IHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsIFwidGV4dFwiKTtcbiAgICByZXMuY29scyA9IG5ldyBBcnJheShyZXMuYm9keVswXS5sZW5ndGgpLmZpbGwoeyB0eXBlOiBcImFsaWduXCIsIGFsaWduOiBcImNcIiB9KTtcbiAgICByZXMuZW52Q2xhc3NlcyA9IFtdO1xuICAgIHJlcy5hcnJheXN0cmV0Y2ggPSAxO1xuICAgIGlmIChjb250ZXh0LmVudk5hbWUgPT09IFwibWF0cml4XCIpIHsgcmV0dXJuIHJlc31cbiAgICByZXR1cm4gYm9yZGVybWF0cml4UGFyc2VUcmVlKHJlcywgY29udGV4dC5kZWxpbWl0ZXJzKVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcInNtYWxsbWF0cml4XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHsgdHlwZTogXCJzbWFsbFwiIH07XG4gICAgY29uc3QgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgXCJzY3JpcHRcIik7XG4gICAgcmVzLmVudkNsYXNzZXMgPSBbXCJzbWFsbFwiXTtcbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcInN1YmFycmF5XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgLy8gUGFyc2luZyBvZiB7c3ViYXJyYXl9IGlzIHNpbWlsYXIgdG8ge2FycmF5fVxuICAgIGNvbnN0IHN5bU5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKGFyZ3NbMF0pO1xuICAgIGNvbnN0IGNvbGFsaWduID0gc3ltTm9kZSA/IFthcmdzWzBdXSA6IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwib3JkZ3JvdXBcIikuYm9keTtcbiAgICBjb25zdCBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5kZSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7XG4gICAgICBjb25zdCBjYSA9IG5vZGUudGV4dDtcbiAgICAgIC8vIHtzdWJhcnJheX0gb25seSByZWNvZ25pemVzIFwibFwiICYgXCJjXCJcbiAgICAgIGlmIChcImxjXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJhbGlnblwiLFxuICAgICAgICAgIGFsaWduOiBjYVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmtub3duIGNvbHVtbiBhbGlnbm1lbnQ6IFwiICsgY2EsIG5kZSk7XG4gICAgfSk7XG4gICAgaWYgKGNvbHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtblwiKTtcbiAgICB9XG4gICAgbGV0IHJlcyA9IHtcbiAgICAgIGNvbHMsXG4gICAgICBlbnZDbGFzc2VzOiBbXCJzbWFsbFwiXVxuICAgIH07XG4gICAgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcInNjcmlwdFwiKTtcbiAgICBpZiAocmVzLmJvZHkubGVuZ3RoID4gMCAmJiByZXMuYm9keVswXS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIntzdWJhcnJheX0gY2FuIGNvbnRhaW4gb25seSBvbmUgY29sdW1uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBBIGNhc2VzIGVudmlyb25tZW50IChpbiBhbXNtYXRoLnN0eSkgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG9cbi8vIFxcZGVmXG4vLyBcXGxlZnRcXHtcXGJlZ2lue2FycmF5fXtAe31sQHtcXHF1YWR9bEB7fX0g4oCmIFxcZW5ke2FycmF5fVxccmlnaHQuXG4vLyB7ZGNhc2VzfSBpcyBhIHtjYXNlc30gZW52aXJvbm1lbnQgd2hlcmUgY2VsbHMgYXJlIHNldCBpbiBcXGRpc3BsYXlzdHlsZSxcbi8vIGFzIGRlZmluZWQgaW4gbWF0aHRvb2xzLnN0eS5cbi8vIHtyY2FzZXN9IGlzIGFub3RoZXIgbWF0aHRvb2xzIGVudmlyb25tZW50LiBJdCdzIGJyYWNlIGlzIG9uIHRoZSByaWdodCBzaWRlLlxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJjYXNlc1wiLCBcImRjYXNlc1wiLCBcInJjYXNlc1wiLCBcImRyY2FzZXNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgY29sczogW10sXG4gICAgICBlbnZDbGFzc2VzOiBbXCJjYXNlc1wiXVxuICAgIH07XG4gICAgY29uc3QgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgZENlbGxTdHlsZShjb250ZXh0LmVudk5hbWUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgICAgIG1vZGU6IGNvbnRleHQubW9kZSxcbiAgICAgIGJvZHk6IFtyZXNdLFxuICAgICAgbGVmdDogY29udGV4dC5lbnZOYW1lLmluZGV4T2YoXCJyXCIpID4gLTEgPyBcIi5cIiA6IFwiXFxcXHtcIixcbiAgICAgIHJpZ2h0OiBjb250ZXh0LmVudk5hbWUuaW5kZXhPZihcInJcIikgPiAtMSA/IFwiXFxcXH1cIiA6IFwiLlwiLFxuICAgICAgcmlnaHRDb2xvcjogdW5kZWZpbmVkXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gSW4gdGhlIGFsaWduIGVudmlyb25tZW50LCBvbmUgdXNlcyBhbXBlcnNhbmRzLCAmLCB0byBzcGVjaWZ5IG51bWJlciBvZlxuLy8gY29sdW1ucyBpbiBlYWNoIHJvdywgYW5kIHRvIGxvY2F0ZSBzcGFjaW5nIGJldHdlZW4gZWFjaCBjb2x1bW4uXG4vLyBhbGlnbiBnZXRzIGF1dG9tYXRpYyBudW1iZXJpbmcuIGFsaWduKiBhbmQgYWxpZ25lZCBkbyBub3QuXG4vLyBUaGUgYWxpZ25lZGF0IGVudmlyb25tZW50IGNhbiBiZSB1c2VkIGluIG1hdGggbW9kZS5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYWxpZ25cIiwgXCJhbGlnbipcIiwgXCJhbGlnbmVkXCIsIFwic3BsaXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiBhbGlnbmVkSGFuZGxlcixcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuLy8gYWxpZ25hdCBlbnZpcm9ubWVudCBpcyBsaWtlIGFuIGFsaWduIGVudmlyb25tZW50LCBidXQgb25lIG11c3QgZXhwbGljaXRseVxuLy8gc3BlY2lmeSBtYXhpbXVtIG51bWJlciBvZiBjb2x1bW5zIGluIGVhY2ggcm93LCBhbmQgY2FuIGFkanVzdCB3aGVyZSBzcGFjaW5nIG9jY3Vycy5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiYWxpZ25hdFwiLCBcImFsaWduYXQqXCIsIFwiYWxpZ25lZGF0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDFcbiAgfSxcbiAgaGFuZGxlcjogYWxpZ25lZEhhbmRsZXIsXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbi8vIEEgZ2F0aGVyZWQgZW52aXJvbm1lbnQgaXMgbGlrZSBhbiBhcnJheSBlbnZpcm9ubWVudCB3aXRoIG9uZSBjZW50ZXJlZFxuLy8gY29sdW1uLCBidXQgd2hlcmUgcm93cyBhcmUgY29uc2lkZXJlZCBsaW5lcyBzbyBnZXQgXFxqb3QgbGluZSBzcGFjaW5nXG4vLyBhbmQgY29udGVudHMgYXJlIHNldCBpbiBcXGRpc3BsYXlzdHlsZS5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wiZ2F0aGVyZWRcIiwgXCJnYXRoZXJcIiwgXCJnYXRoZXIqXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQuZW52TmFtZSAhPT0gXCJnYXRoZXJlZFwiKSB7XG4gICAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgY29sczogW10sXG4gICAgICBlbnZDbGFzc2VzOiBbXCJhYnV0XCIsIFwiam90XCJdLFxuICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLFxuICAgICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsXG4gICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm9cbiAgICB9O1xuICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIFwiZGlzcGxheVwiKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ5XG59KTtcblxuZGVmaW5lRW52aXJvbm1lbnQoe1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG5hbWVzOiBbXCJlcXVhdGlvblwiLCBcImVxdWF0aW9uKlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoY29udGV4dCkge1xuICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpO1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgIGF1dG9UYWc6IGdldEF1dG9UYWcoY29udGV4dC5lbnZOYW1lKSxcbiAgICAgIGVtcHR5U2luZ2xlUm93OiB0cnVlLFxuICAgICAgc2luZ2xlUm93OiB0cnVlLFxuICAgICAgbWF4TnVtQ29sczogMSxcbiAgICAgIGVudkNsYXNzZXM6IFtcImFsaWduXCJdLFxuICAgICAgbGVxbm86IGNvbnRleHQucGFyc2VyLnNldHRpbmdzLmxlcW5vXG4gICAgfTtcbiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCBcImRpc3BsYXlcIik7XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOVxufSk7XG5cbmRlZmluZUVudmlyb25tZW50KHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICBuYW1lczogW1wibXVsdGxpbmVcIiwgXCJtdWx0bGluZSpcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQpIHtcbiAgICB2YWxpZGF0ZUFtc0Vudmlyb25tZW50Q29udGV4dChjb250ZXh0KTtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICBhdXRvVGFnOiBjb250ZXh0LmVudk5hbWUgPT09IFwibXVsdGxpbmVcIixcbiAgICAgIG1heE51bUNvbHM6IDEsXG4gICAgICBlbnZDbGFzc2VzOiBbXCJqb3RcIiwgXCJtdWx0bGluZVwiXSxcbiAgICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFub1xuICAgIH07XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHJlcywgXCJkaXNwbGF5XCIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG5kZWZpbmVFbnZpcm9ubWVudCh7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbmFtZXM6IFtcIkNEXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDBcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0KSB7XG4gICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlQ0QoY29udGV4dC5wYXJzZXIpO1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDlcbn0pO1xuXG4vLyBDYXRjaCBcXGhsaW5lIG91dHNpZGUgYXJyYXkgZW52aXJvbm1lbnRcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0XCIsIC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhpcyBpcy5cbiAgbmFtZXM6IFtcIlxcXFxobGluZVwiLCBcIlxcXFxoZGFzaGxpbmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFsbG93ZWRJbk1hdGg6IHRydWVcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYCR7Y29udGV4dC5mdW5jTmFtZX0gdmFsaWQgb25seSB3aXRoaW4gYXJyYXkgZW52aXJvbm1lbnRgKTtcbiAgfVxufSk7XG5cbmNvbnN0IGVudmlyb25tZW50cyA9IF9lbnZpcm9ubWVudHM7XG5cbi8vIFxcYm9yZGVybWF0cml4ICBmcm9tIFRlWGJvb2sgcHAgMTc3ICYgMzYxXG4vLyBPcHRpb25hbCBhcmd1bWVudCBmcm9tIEhlcmJlcnQgVm/DnywgTWF0aCBtb2RlLCBwIDIwXG4vLyBSZWY6IGh0dHBzOi8vdHVnLmN0YW4ub3JnL29ic29sZXRlL2luZm8vbWF0aC92b3NzL21hdGhtb2RlL01hdGhtb2RlLnBkZlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiYm9yZGVybWF0cml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcYm9yZGVybWF0cml4XCIsIFwiXFxcXG1hdHJpeFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MsIG9wdEFyZ3MpID0+IHtcbiAgICAvLyBGaW5kIG91dCBpZiB0aGUgYXV0aG9yIGhhcyBkZWZpbmVkIGN1c3RvbSBkZWxpbWl0ZXJzXG4gICAgbGV0IGRlbGltaXRlcnMgPSBbXCIoXCIsIFwiKVwiXTtcbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGJvcmRlcm1hdHJpeFwiICYmIG9wdEFyZ3NbMF0gJiYgb3B0QXJnc1swXS5ib2R5KSB7XG4gICAgICBjb25zdCBib2R5ID0gb3B0QXJnc1swXS5ib2R5O1xuICAgICAgaWYgKGJvZHkubGVuZ3RoID09PSAyICYmIGJvZHlbMF0udHlwZSA9PT0gXCJhdG9tXCIgJiYgYm9keVsxXS50eXBlID09PSBcImF0b21cIikge1xuICAgICAgICBpZiAoYm9keVswXS5mYW1pbHkgPT09IFwib3BlblwiICYmIGJvZHlbMV0uZmFtaWx5ID09PSBcImNsb3NlXCIpIHtcbiAgICAgICAgICBkZWxpbWl0ZXJzID0gW2JvZHlbMF0udGV4dCwgYm9keVsxXS50ZXh0XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zdW1lIHRoZSBvcGVuaW5nIGJyYWNlXG4gICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTtcbiAgICBwYXJzZXIuY29uc3VtZSgpO1xuXG4gICAgLy8gUGFzcyBjb250cm9sIHRvIHRoZSBlbnZpcm9ubWVudCBoYW5kbGVyIGluIGFycmF5LmpzLlxuICAgIGNvbnN0IGVudiA9IGVudmlyb25tZW50c1tcImJvcmRlcm1hdHJpeFwiXTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBlbnZOYW1lOiBmdW5jTmFtZS5zbGljZSgxKSxcbiAgICAgIGRlbGltaXRlcnMsXG4gICAgICBwYXJzZXJcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IGVudi5oYW5kbGVyKGNvbnRleHQpO1xuICAgIHBhcnNlci5leHBlY3QoXCJ9XCIsIHRydWUpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxufSk7XG5cbi8vIFxcQGNoYXIgaXMgYW4gaW50ZXJuYWwgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwZWQgZGVjaW1hbCBhcmd1bWVudCBsaWtlXG4vLyB7MTIzfSBhbmQgY29udmVydHMgaW50byBzeW1ib2wgd2l0aCBjb2RlIDEyMy4gIEl0IGlzIHVzZWQgYnkgdGhlICptYWNybypcbi8vIFxcY2hhciBkZWZpbmVkIGluIG1hY3Jvcy5qcy5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gIG5hbWVzOiBbXCJcXFxcQGNoYXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIHRva2VuIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBhcmcgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcIm9yZGdyb3VwXCIpO1xuICAgIGNvbnN0IGdyb3VwID0gYXJnLmJvZHk7XG4gICAgbGV0IG51bWJlciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IGFzc2VydE5vZGVUeXBlKGdyb3VwW2ldLCBcInRleHRvcmRcIik7XG4gICAgICBudW1iZXIgKz0gbm9kZS50ZXh0O1xuICAgIH1cbiAgICBjb25zdCBjb2RlID0gcGFyc2VJbnQobnVtYmVyKTtcbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBcXFxcQGNoYXIgaGFzIG5vbi1udW1lcmljIGFyZ3VtZW50ICR7bnVtYmVyfWAsIHRva2VuKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHRleHQ6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpXG4gICAgfVxuICB9XG59KTtcblxuLy8gSGVscGVyc1xuY29uc3QgaHRtbFJlZ0V4ID0gL14oI1thLWYwLTldezN9fCM/W2EtZjAtOV17Nn0pJC9pO1xuY29uc3QgaHRtbE9yTmFtZVJlZ0V4ID0gL14oI1thLWYwLTldezN9fCM/W2EtZjAtOV17Nn18W2Etel0rKSQvaTtcbmNvbnN0IFJHQnJlZ0V4ID0gL14gKlxcZHsxLDN9ICooPzosICpcXGR7MSwzfSAqKXsyfSQvO1xuY29uc3QgcmdiUmVnRXggPSAvXiAqWzEwXSg/OlxcLlxcZCopPyAqKD86LCAqWzEwXSg/OlxcLlxcZCopPyAqKXsyfSQvO1xuY29uc3QgeGNvbG9ySHRtbFJlZ0V4ID0gL15bYS1mMC05XXs2fSQvaTtcbmNvbnN0IHRvSGV4ID0gbnVtID0+IHtcbiAgbGV0IHN0ciA9IG51bS50b1N0cmluZygxNik7XG4gIGlmIChzdHIubGVuZ3RoID09PSAxKSB7IHN0ciA9IFwiMFwiICsgc3RyOyB9XG4gIHJldHVybiBzdHJcbn07XG5cbi8vIENvbG9ycyBmcm9tIFRhYmxlcyA0LjEgYW5kIDQuMiBvZiB0aGUgeGNvbG9yIHBhY2thZ2UuXG4vLyBUYWJsZSA0LjEgKGxvd2VyIGNhc2UpIFJHQiB2YWx1ZXMgYXJlIHRha2VuIGZyb20gY2hyb21hIGFuZCB4Y29sb3IuZHR4LlxuLy8gVGFibGUgNC4yIChDYXBpdGFsaXp6ZWQpIHZhbHVlcyB3ZXJlIHNhbXBsZWQsIGJlY2F1c2UgQ2hyb21hIGNvbnRhaW5zIGEgdW5yZWxpYWJsZVxuLy8gY29udmVyc2lvbiBmcm9tIGNteWsgdG8gUkdCLiBTZWUgaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vYS81MzcyNzQuXG5jb25zdCB4Y29sb3JzID0gSlNPTi5wYXJzZShge1xuICBcIkFwcmljb3RcIjogXCIjZmZiNDg0XCIsXG4gIFwiQXF1YW1hcmluZVwiOiBcIiMwOGI0YmNcIixcbiAgXCJCaXR0ZXJzd2VldFwiOiBcIiNjODRjMTRcIixcbiAgXCJibHVlXCI6IFwiIzAwMDBGRlwiLFxuICBcIkJsdWVcIjogXCIjMzAzNDk0XCIsXG4gIFwiQmx1ZUdyZWVuXCI6IFwiIzA4YjRiY1wiLFxuICBcIkJsdWVWaW9sZXRcIjogXCIjNTAzYzk0XCIsXG4gIFwiQnJpY2tSZWRcIjogXCIjYjgzNDFjXCIsXG4gIFwiYnJvd25cIjogXCIjQkY4MDQwXCIsXG4gIFwiQnJvd25cIjogXCIjODAyNDA0XCIsXG4gIFwiQnVybnRPcmFuZ2VcIjogXCIjZjg5NDFjXCIsXG4gIFwiQ2FkZXRCbHVlXCI6IFwiIzc4NzQ5Y1wiLFxuICBcIkNhcm5hdGlvblBpbmtcIjogXCIjZjg4NGI0XCIsXG4gIFwiQ2VydWxlYW5cIjogXCIjMDhhNGU0XCIsXG4gIFwiQ29ybmZsb3dlckJsdWVcIjogXCIjNDBhY2U0XCIsXG4gIFwiY3lhblwiOiBcIiMwMEZGRkZcIixcbiAgXCJDeWFuXCI6IFwiIzA4YWNlY1wiLFxuICBcIkRhbmRlbGlvblwiOiBcIiNmZmJjNDRcIixcbiAgXCJkYXJrZ3JheVwiOiBcIiM0MDQwNDBcIixcbiAgXCJEYXJrT3JjaGlkXCI6IFwiI2E4NTQ4Y1wiLFxuICBcIkVtZXJhbGRcIjogXCIjMDhhYzljXCIsXG4gIFwiRm9yZXN0R3JlZW5cIjogXCIjMDg5YzU0XCIsXG4gIFwiRnVjaHNpYVwiOiBcIiM5MDM0OGNcIixcbiAgXCJHb2xkZW5yb2RcIjogXCIjZmZkYzQ0XCIsXG4gIFwiZ3JheVwiOiBcIiM4MDgwODBcIixcbiAgXCJHcmF5XCI6IFwiIzk4OTQ5Y1wiLFxuICBcImdyZWVuXCI6IFwiIzAwRkYwMFwiLFxuICBcIkdyZWVuXCI6IFwiIzA4YTQ0Y1wiLFxuICBcIkdyZWVuWWVsbG93XCI6IFwiI2UwZTQ3NFwiLFxuICBcIkp1bmdsZUdyZWVuXCI6IFwiIzA4YWM5Y1wiLFxuICBcIkxhdmVuZGVyXCI6IFwiI2Y4OWNjNFwiLFxuICBcImxpZ2h0Z3JheVwiOiBcIiNjMGMwYzBcIixcbiAgXCJsaW1lXCI6IFwiI0JGRkYwMFwiLFxuICBcIkxpbWVHcmVlblwiOiBcIiM5MGM0M2NcIixcbiAgXCJtYWdlbnRhXCI6IFwiI0ZGMDBGRlwiLFxuICBcIk1hZ2VudGFcIjogXCIjZjAwNDhjXCIsXG4gIFwiTWFob2dhbnlcIjogXCIjYjAzNDFjXCIsXG4gIFwiTWFyb29uXCI6IFwiI2IwMzQzNFwiLFxuICBcIk1lbG9uXCI6IFwiI2Y4OWM3Y1wiLFxuICBcIk1pZG5pZ2h0Qmx1ZVwiOiBcIiMwODY0OTRcIixcbiAgXCJNdWxiZXJyeVwiOiBcIiNiMDNjOTRcIixcbiAgXCJOYXZ5Qmx1ZVwiOiBcIiMwODZjYmNcIixcbiAgXCJvbGl2ZVwiOiBcIiM3RjdGMDBcIixcbiAgXCJPbGl2ZUdyZWVuXCI6IFwiIzQwN2MzNFwiLFxuICBcIm9yYW5nZVwiOiBcIiNGRjgwMDBcIixcbiAgXCJPcmFuZ2VcIjogXCIjZjg4NDNjXCIsXG4gIFwiT3JhbmdlUmVkXCI6IFwiI2YwMTQ1Y1wiLFxuICBcIk9yY2hpZFwiOiBcIiNiMDc0YWNcIixcbiAgXCJQZWFjaFwiOiBcIiNmODk0NWNcIixcbiAgXCJQZXJpd2lua2xlXCI6IFwiIzgwNzRiY1wiLFxuICBcIlBpbmVHcmVlblwiOiBcIiMwODhjNzRcIixcbiAgXCJwaW5rXCI6IFwiI2ZmN2Y3ZlwiLFxuICBcIlBsdW1cIjogXCIjOTgyNDhjXCIsXG4gIFwiUHJvY2Vzc0JsdWVcIjogXCIjMDhiNGVjXCIsXG4gIFwicHVycGxlXCI6IFwiI0JGMDA0MFwiLFxuICBcIlB1cnBsZVwiOiBcIiNhMDQ0OWNcIixcbiAgXCJSYXdTaWVubmFcIjogXCIjOTgzYzA0XCIsXG4gIFwicmVkXCI6IFwiI2ZmMDAwMFwiLFxuICBcIlJlZFwiOiBcIiNmMDFjMjRcIixcbiAgXCJSZWRPcmFuZ2VcIjogXCIjZjg2NDM0XCIsXG4gIFwiUmVkVmlvbGV0XCI6IFwiI2EwMjQ2Y1wiLFxuICBcIlJob2RhbWluZVwiOiBcIiNmMDU0OWNcIixcbiAgXCJSb3lhbGx1ZVwiOiBcIiMwODc0YmNcIixcbiAgXCJSb3lhbFB1cnBsZVwiOiBcIiM2ODNjOWNcIixcbiAgXCJSdWJpbmVSZWRcIjogXCIjZjAwNDdjXCIsXG4gIFwiU2FsbW9uXCI6IFwiI2Y4OTQ4Y1wiLFxuICBcIlNlYUdyZWVuXCI6IFwiIzMwYmM5Y1wiLFxuICBcIlNlcGlhXCI6IFwiIzcwMTQwNFwiLFxuICBcIlNreUJsdWVcIjogXCIjNDhjNGRjXCIsXG4gIFwiU3ByaW5nR3JlZW5cIjogXCIjYzhkYzY0XCIsXG4gIFwiVGFuXCI6IFwiI2UwOWM3NFwiLFxuICBcInRlYWxcIjogXCIjMDA3RjdGXCIsXG4gIFwiVGVhbEJsdWVcIjogXCIjMDhhY2I0XCIsXG4gIFwiVGhpc3RsZVwiOiBcIiNkODg0YjRcIixcbiAgXCJUdXJxdW9pc2VcIjogXCIjMDhiNGNjXCIsXG4gIFwidmlvbGV0XCI6IFwiIzgwMDA4MFwiLFxuICBcIlZpb2xldFwiOiBcIiM2MDQ0OWNcIixcbiAgXCJWaW9sZXRSZWRcIjogXCIjZjA1NGE0XCIsXG4gIFwiV2lsZFN0cmF3YmVycnlcIjogXCIjZjAyNDZjXCIsXG4gIFwieWVsbG93XCI6IFwiI0ZGRkYwMFwiLFxuICBcIlllbGxvd1wiOiBcIiNmZmY0MDRcIixcbiAgXCJZZWxsb3dHcmVlblwiOiBcIiM5OGNjNmNcIixcbiAgXCJZZWxsb3dPcmFuZ2VcIjogXCIjZmZhNDFjXCJcbn1gKTtcblxuY29uc3QgY29sb3JGcm9tU3BlYyA9IChtb2RlbCwgc3BlYykgPT4ge1xuICBsZXQgY29sb3IgPSBcIlwiO1xuICBpZiAobW9kZWwgPT09IFwiSFRNTFwiKSB7XG4gICAgaWYgKCFodG1sUmVnRXgudGVzdChzcGVjKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIEhUTUwgaW5wdXQuXCIpXG4gICAgfVxuICAgIGNvbG9yID0gc3BlYztcbiAgfSBlbHNlIGlmIChtb2RlbCA9PT0gXCJSR0JcIikge1xuICAgIGlmICghUkdCcmVnRXgudGVzdChzcGVjKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIFJHQiBpbnB1dC5cIilcbiAgICB9XG4gICAgc3BlYy5zcGxpdChcIixcIikubWFwKGUgPT4geyBjb2xvciArPSB0b0hleChOdW1iZXIoZS50cmltKCkpKTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFyZ2JSZWdFeC50ZXN0KHNwZWMpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgcmJnIGlucHV0LlwiKVxuICAgIH1cbiAgICBzcGVjLnNwbGl0KFwiLFwiKS5tYXAoZSA9PiB7XG4gICAgICBjb25zdCBudW0gPSBOdW1iZXIoZS50cmltKCkpO1xuICAgICAgaWYgKG51bSA+IDEpIHsgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJDb2xvciByZ2IgaW5wdXQgbXVzdCBiZSA8IDEuXCIpIH1cbiAgICAgIGNvbG9yICs9IHRvSGV4KE51bWJlcigobnVtICogMjU1KS50b0ZpeGVkKDApKSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGNvbG9yLmNoYXJBdCgwKSAhPT0gXCIjXCIpIHsgY29sb3IgPSBcIiNcIiArIGNvbG9yOyB9XG4gIHJldHVybiBjb2xvclxufTtcblxuY29uc3QgdmFsaWRhdGVDb2xvciA9IChjb2xvciwgbWFjcm9zLCB0b2tlbikgPT4ge1xuICBjb25zdCBtYWNyb05hbWUgPSBgXFxcXFxcXFxjb2xvckAke2NvbG9yfWA7IC8vIGZyb20gXFxkZWZpbmVDb2xvci5cbiAgY29uc3QgbWF0Y2ggPSBodG1sT3JOYW1lUmVnRXguZXhlYyhjb2xvcik7XG4gIGlmICghbWF0Y2gpIHsgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGNvbG9yOiAnXCIgKyBjb2xvciArIFwiJ1wiLCB0b2tlbikgfVxuICAvLyBXZSBhbGxvdyBhIDYtZGlnaXQgSFRNTCBjb2xvciBzcGVjIHdpdGhvdXQgYSBsZWFkaW5nIFwiI1wiLlxuICAvLyBUaGlzIGZvbGxvd3MgdGhlIHhjb2xvciBwYWNrYWdlJ3MgSFRNTCBjb2xvciBtb2RlbC5cbiAgLy8gUHJlZGVmaW5lZCBjb2xvciBuYW1lcyBhcmUgYWxsIG1pc3NlZCBieSB0aGlzIFJlZ0V4IHBhdHRlcm4uXG4gIGlmICh4Y29sb3JIdG1sUmVnRXgudGVzdChjb2xvcikpIHtcbiAgICByZXR1cm4gXCIjXCIgKyBjb2xvclxuICB9IGVsc2UgaWYgKGNvbG9yLmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICByZXR1cm4gY29sb3JcbiAgfSBlbHNlIGlmIChtYWNyb3MuaGFzKG1hY3JvTmFtZSkpIHtcbiAgICBjb2xvciA9IG1hY3Jvcy5nZXQobWFjcm9OYW1lKS50b2tlbnNbMF0udGV4dDtcbiAgfSBlbHNlIGlmICh4Y29sb3JzW2NvbG9yXSkge1xuICAgIGNvbG9yID0geGNvbG9yc1tjb2xvcl07XG4gIH1cbiAgcmV0dXJuIGNvbG9yXG59O1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJDggPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIC8vIEluIExhVGVYLCBjb2xvciBpcyBub3Qgc3VwcG9zZWQgdG8gY2hhbmdlIHRoZSBzcGFjaW5nIG9mIGFueSBub2RlLlxuICAvLyBTbyBpbnN0ZWFkIG9mIHdyYXBwaW5nIHRoZSBncm91cCBpbiBhbiA8bXN0eWxlPiwgd2UgYXBwbHlcbiAgLy8gdGhlIGNvbG9yIGluZGl2aWR1YWxseSB0byBlYWNoIG5vZGUgYW5kIHJldHVybiBhIGRvY3VtZW50IGZyYWdtZW50LlxuICBsZXQgZXhwciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZS53aXRoQ29sb3IoZ3JvdXAuY29sb3IpKTtcbiAgZXhwciA9IGV4cHIubWFwKGUgPT4ge1xuICAgIGUuc3R5bGUuY29sb3IgPSBncm91cC5jb2xvcjtcbiAgICByZXR1cm4gZVxuICB9KTtcbiAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChleHByKVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImNvbG9yXCIsXG4gIG5hbWVzOiBbXCJcXFxcdGV4dGNvbG9yXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInJhd1wiLCBcIm9yaWdpbmFsXCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIHRva2VuIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBtb2RlbCA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGxldCBjb2xvciA9IFwiXCI7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBjb25zdCBzcGVjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgICAgY29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBzcGVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSB2YWxpZGF0ZUNvbG9yKGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZywgcGFyc2VyLmd1bGxldC5tYWNyb3MsIHRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29sb3IsXG4gICAgICBpc1RleHRDb2xvcjogdHJ1ZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDhcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFxjb2xvclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJyYXdcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgYnJlYWtPblRva2VuVGV4dCwgdG9rZW4gfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IG1vZGVsID0gb3B0QXJnc1swXSAmJiBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgbGV0IGNvbG9yID0gXCJcIjtcbiAgICBpZiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IHNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBjb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIHNwZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3JvcywgdG9rZW4pO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIG91dCB0aGUgaW1wbGljaXQgYm9keSB0aGF0IHNob3VsZCBiZSBjb2xvcmVkLlxuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQsIHRydWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgY29sb3IsXG4gICAgICBpc1RleHRDb2xvcjogZmFsc2UsXG4gICAgICBib2R5XG4gICAgfVxuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDhcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiY29sb3JcIixcbiAgbmFtZXM6IFtcIlxcXFxkZWZpbmVjb2xvclwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAzLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYXJnVHlwZXM6IFtcInJhd1wiLCBcInJhd1wiLCBcInJhd1wiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykge1xuICAgIGNvbnN0IG5hbWUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgaWYgKCEvXltBLVphLXpdKyQvLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiQ29sb3IgbmFtZSBtdXN0IGJlIGxhdGluIGxldHRlcnMuXCIsIHRva2VuKVxuICAgIH1cbiAgICBjb25zdCBtb2RlbCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sIFwicmF3XCIpLnN0cmluZztcbiAgICBpZiAoIVtcIkhUTUxcIiwgXCJSR0JcIiwgXCJyZ2JcIl0uaW5jbHVkZXMobW9kZWwpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNvbG9yIG1vZGVsIG11c3QgYmUgSFRNTCwgUkdCLCBvciByZ2IuXCIsIHRva2VuKVxuICAgIH1cbiAgICBjb25zdCBzcGVjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1syXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGNvbnN0IGNvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgc3BlYyk7XG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KGBcXFxcXFxcXGNvbG9yQCR7bmFtZX1gLCB7IHRva2VuczogW3sgdGV4dDogY29sb3IgfV0sIG51bUFyZ3M6IDAgfSk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcm5hbFwiLCBtb2RlOiBwYXJzZXIubW9kZSB9XG4gIH1cbiAgLy8gTm8gbWF0aG1sQnVpbGRlci4gVGhlIHBvaW50IG9mIFxcZGVmaW5lY29sb3IgaXMgdG8gc2V0IGEgbWFjcm8uXG59KTtcblxuLy8gUm93IGJyZWFrcyB3aXRoaW4gdGFidWxhciBlbnZpcm9ubWVudHMsIGFuZCBsaW5lIGJyZWFrcyBhdCB0b3AgbGV2ZWxcblxuXG4vLyBcXERlY2xhcmVSb2J1c3RDb21tYW5kXFxcXHsuLi5cXEB4bmV3bGluZX1cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJjclwiLFxuICBuYW1lczogW1wiXFxcXFxcXFxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncywgb3B0QXJncykge1xuICAgIGNvbnN0IHNpemUgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgPT09IFwiW1wiID8gcGFyc2VyLnBhcnNlU2l6ZUdyb3VwKHRydWUpIDogbnVsbDtcbiAgICBjb25zdCBuZXdMaW5lID0gIXBhcnNlci5zZXR0aW5ncy5kaXNwbGF5TW9kZTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjclwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBuZXdMaW5lLFxuICAgICAgc2l6ZTogc2l6ZSAmJiBhc3NlcnROb2RlVHlwZShzaXplLCBcInNpemVcIikudmFsdWVcbiAgICB9XG4gIH0sXG5cbiAgLy8gVGhlIGZvbGxvd2luZyBidWlsZGVyIGlzIGNhbGxlZCBvbmx5IGF0IHRoZSB0b3AgbGV2ZWwsXG4gIC8vIG5vdCB3aXRoaW4gdGFidWxhci9hcnJheSBlbnZpcm9ubWVudHMuXG5cbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBNYXRoTUwgMy4wIGNhbGxzIGZvciBuZXdsaW5lIHRvIG9jY3VyIGluIGFuIDxtbz4gb3IgYW4gPG1zcGFjZT4uXG4gICAgLy8gUmVmOiBodHRwczovL3d3dy53My5vcmcvVFIvTWF0aE1MMy9jaGFwdGVyMy5odG1sI3ByZXNtLmxpbmVicmVha2luZ1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIpO1xuICAgIGlmIChncm91cC5uZXdMaW5lKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxpbmVicmVha1wiLCBcIm5ld2xpbmVcIik7XG4gICAgICBpZiAoZ3JvdXAuc2l6ZSkge1xuICAgICAgICBjb25zdCBzaXplID0gY2FsY3VsYXRlU2l6ZShncm91cC5zaXplLCBzdHlsZSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHNpemUubnVtYmVyICsgc2l6ZS51bml0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbmNvbnN0IGdsb2JhbE1hcCA9IHtcbiAgXCJcXFxcZ2xvYmFsXCI6IFwiXFxcXGdsb2JhbFwiLFxuICBcIlxcXFxsb25nXCI6IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIsXG4gIFwiXFxcXFxcXFxnbG9iYWxsb25nXCI6IFwiXFxcXFxcXFxnbG9iYWxsb25nXCIsXG4gIFwiXFxcXGRlZlwiOiBcIlxcXFxnZGVmXCIsXG4gIFwiXFxcXGdkZWZcIjogXCJcXFxcZ2RlZlwiLFxuICBcIlxcXFxlZGVmXCI6IFwiXFxcXHhkZWZcIixcbiAgXCJcXFxceGRlZlwiOiBcIlxcXFx4ZGVmXCIsXG4gIFwiXFxcXGxldFwiOiBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIsXG4gIFwiXFxcXGZ1dHVyZWxldFwiOiBcIlxcXFxcXFxcZ2xvYmFsZnV0dXJlXCJcbn07XG5cbmNvbnN0IGNoZWNrQ29udHJvbFNlcXVlbmNlID0gKHRvaykgPT4ge1xuICBjb25zdCBuYW1lID0gdG9rLnRleHQ7XG4gIGlmICgvXig/OltcXFxce30kJiNeX118RU9GKSQvLnRlc3QobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGEgY29udHJvbCBzZXF1ZW5jZVwiLCB0b2spO1xuICB9XG4gIHJldHVybiBuYW1lO1xufTtcblxuY29uc3QgZ2V0UkhTID0gKHBhcnNlcikgPT4ge1xuICBsZXQgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpO1xuICBpZiAodG9rLnRleHQgPT09IFwiPVwiKSB7XG4gICAgLy8gY29uc3VtZSBvcHRpb25hbCBlcXVhbHNcbiAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgaWYgKHRvay50ZXh0ID09PSBcIiBcIikge1xuICAgICAgLy8gY29uc3VtZSBvbmUgb3B0aW9uYWwgc3BhY2VcbiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRvaztcbn07XG5cbmNvbnN0IGxldENvbW1hbmQgPSAocGFyc2VyLCBuYW1lLCB0b2ssIGdsb2JhbCkgPT4ge1xuICBsZXQgbWFjcm8gPSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQodG9rLnRleHQpO1xuICBpZiAobWFjcm8gPT0gbnVsbCkge1xuICAgIC8vIGRvbid0IGV4cGFuZCBpdCBsYXRlciBldmVuIGlmIGEgbWFjcm8gd2l0aCB0aGUgc2FtZSBuYW1lIGlzIGRlZmluZWRcbiAgICAvLyBlLmcuLCBcXGxldFxcZm9vPVxcZnJhYyBcXGRlZlxcZnJhY3tcXHJlbGF4fSBcXGZyYWMxMlxuICAgIHRvay5ub2V4cGFuZCA9IHRydWU7XG4gICAgbWFjcm8gPSB7XG4gICAgICB0b2tlbnM6IFt0b2tdLFxuICAgICAgbnVtQXJnczogMCxcbiAgICAgIC8vIHJlcHJvZHVjZSB0aGUgc2FtZSBiZWhhdmlvciBpbiBleHBhbnNpb25cbiAgICAgIHVuZXhwYW5kYWJsZTogIXBhcnNlci5ndWxsZXQuaXNFeHBhbmRhYmxlKHRvay50ZXh0KVxuICAgIH07XG4gIH1cbiAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KG5hbWUsIG1hY3JvLCBnbG9iYWwpO1xufTtcblxuLy8gPGFzc2lnbm1lbnQ+IC0+IDxub24tbWFjcm8gYXNzaWdubWVudD58PG1hY3JvIGFzc2lnbm1lbnQ+XG4vLyA8bm9uLW1hY3JvIGFzc2lnbm1lbnQ+IC0+IDxzaW1wbGUgYXNzaWdubWVudD58XFxnbG9iYWw8bm9uLW1hY3JvIGFzc2lnbm1lbnQ+XG4vLyA8bWFjcm8gYXNzaWdubWVudD4gLT4gPGRlZmluaXRpb24+fDxwcmVmaXg+PG1hY3JvIGFzc2lnbm1lbnQ+XG4vLyA8cHJlZml4PiAtPiBcXGdsb2JhbHxcXGxvbmd8XFxvdXRlclxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcZ2xvYmFsXCIsXG4gICAgXCJcXFxcbG9uZ1wiLFxuICAgIFwiXFxcXFxcXFxnbG9iYWxsb25nXCIgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpO1xuICAgIGNvbnN0IHRva2VuID0gcGFyc2VyLmZldGNoKCk7XG4gICAgaWYgKGdsb2JhbE1hcFt0b2tlbi50ZXh0XSkge1xuICAgICAgLy8gVGVtbWwgZG9lc24ndCBoYXZlIFxccGFyLCBzbyBpZ25vcmUgXFxsb25nXG4gICAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGdsb2JhbFwiIHx8IGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcZ2xvYmFsbG9uZ1wiKSB7XG4gICAgICAgIHRva2VuLnRleHQgPSBnbG9iYWxNYXBbdG9rZW4udGV4dF07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJpbnRlcm5hbFwiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgbWFjcm8gcHJlZml4YCwgdG9rZW4pO1xuICB9XG59KTtcblxuLy8gQmFzaWMgc3VwcG9ydCBmb3IgbWFjcm8gZGVmaW5pdGlvbnM6IFxcZGVmLCBcXGdkZWYsIFxcZWRlZiwgXFx4ZGVmXG4vLyA8ZGVmaW5pdGlvbj4gLT4gPGRlZj48Y29udHJvbCBzZXF1ZW5jZT48ZGVmaW5pdGlvbiB0ZXh0PlxuLy8gPGRlZj4gLT4gXFxkZWZ8XFxnZGVmfFxcZWRlZnxcXHhkZWZcbi8vIDxkZWZpbml0aW9uIHRleHQ+IC0+IDxwYXJhbWV0ZXIgdGV4dD48bGVmdCBicmFjZT48YmFsYW5jZWQgdGV4dD48cmlnaHQgYnJhY2U+XG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW50ZXJuYWxcIixcbiAgbmFtZXM6IFtcIlxcXFxkZWZcIiwgXCJcXFxcZ2RlZlwiLCBcIlxcXFxlZGVmXCIsIFwiXFxcXHhkZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIHByaW1pdGl2ZTogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9KSB7XG4gICAgbGV0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBjb25zdCBuYW1lID0gdG9rLnRleHQ7XG4gICAgaWYgKC9eKD86W1xcXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCBhIGNvbnRyb2wgc2VxdWVuY2VcIiwgdG9rKTtcbiAgICB9XG5cbiAgICBsZXQgbnVtQXJncyA9IDA7XG4gICAgbGV0IGluc2VydDtcbiAgICBjb25zdCBkZWxpbWl0ZXJzID0gW1tdXTtcbiAgICAvLyA8cGFyYW1ldGVyIHRleHQ+IGNvbnRhaW5zIG5vIGJyYWNlc1xuICAgIHdoaWxlIChwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQgIT09IFwie1wiKSB7XG4gICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgICBpZiAodG9rLnRleHQgPT09IFwiI1wiKSB7XG4gICAgICAgIC8vIElmIHRoZSB2ZXJ5IGxhc3QgY2hhcmFjdGVyIG9mIHRoZSA8cGFyYW1ldGVyIHRleHQ+IGlzICMsIHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyAjIGlzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHssIFRlWCB3aWxsIGJlaGF2ZSBhcyBpZiB0aGUge1xuICAgICAgICAvLyBoYWQgYmVlbiBpbnNlcnRlZCBhdCB0aGUgcmlnaHQgZW5kIG9mIGJvdGggdGhlIHBhcmFtZXRlciB0ZXh0XG4gICAgICAgIC8vIGFuZCB0aGUgcmVwbGFjZW1lbnQgdGV4dC5cbiAgICAgICAgaWYgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICBpbnNlcnQgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpO1xuICAgICAgICAgIGRlbGltaXRlcnNbbnVtQXJnc10ucHVzaChcIntcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIHBhcmFtZXRlciwgdGhlIGZpcnN0IGFwcGVhcmFuY2Ugb2YgIyBtdXN0IGJlIGZvbGxvd2VkIGJ5IDEsXG4gICAgICAgIC8vIHRoZSBuZXh0IGJ5IDIsIGFuZCBzbyBvbjsgdXAgdG8gbmluZSAj4oCZcyBhcmUgYWxsb3dlZFxuICAgICAgICB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgICAgIGlmICghL15bMS05XSQvLnRlc3QodG9rLnRleHQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgYXJndW1lbnQgbnVtYmVyIFwiJHt0b2sudGV4dH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZUludCh0b2sudGV4dCkgIT09IG51bUFyZ3MgKyAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEFyZ3VtZW50IG51bWJlciBcIiR7dG9rLnRleHR9XCIgb3V0IG9mIG9yZGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtQXJncysrO1xuICAgICAgICBkZWxpbWl0ZXJzLnB1c2goW10pO1xuICAgICAgfSBlbHNlIGlmICh0b2sudGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGEgbWFjcm8gZGVmaW5pdGlvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGltaXRlcnNbbnVtQXJnc10ucHVzaCh0b2sudGV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlcGxhY2VtZW50IHRleHQsIGVuY2xvc2VkIGluICd7JyBhbmQgJ30nIGFuZCBwcm9wZXJseSBuZXN0ZWRcbiAgICBsZXQgeyB0b2tlbnMgfSA9IHBhcnNlci5ndWxsZXQuY29uc3VtZUFyZygpO1xuICAgIGlmIChpbnNlcnQpIHtcbiAgICAgIHRva2Vucy51bnNoaWZ0KGluc2VydCk7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxlZGVmXCIgfHwgZnVuY05hbWUgPT09IFwiXFxcXHhkZWZcIikge1xuICAgICAgdG9rZW5zID0gcGFyc2VyLmd1bGxldC5leHBhbmRUb2tlbnModG9rZW5zKTtcbiAgICAgIGlmICh0b2tlbnMubGVuZ3RoID4gcGFyc2VyLmd1bGxldC5zZXR0aW5ncy5tYXhFeHBhbmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJUb28gbWFueSBleHBhbnNpb25zIGluIGFuIFwiICsgZnVuY05hbWUpO1xuICAgICAgfVxuICAgICAgdG9rZW5zLnJldmVyc2UoKTsgLy8gdG8gZml0IGluIHdpdGggc3RhY2sgb3JkZXJcbiAgICB9XG4gICAgLy8gRmluYWwgYXJnIGlzIHRoZSBleHBhbnNpb24gb2YgdGhlIG1hY3JvXG4gICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KFxuICAgICAgbmFtZSxcbiAgICAgIHsgdG9rZW5zLCBudW1BcmdzLCBkZWxpbWl0ZXJzIH0sXG4gICAgICBmdW5jTmFtZSA9PT0gZ2xvYmFsTWFwW2Z1bmNOYW1lXVxuICAgICk7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcm5hbFwiLCBtb2RlOiBwYXJzZXIubW9kZSB9O1xuICB9XG59KTtcblxuLy8gPHNpbXBsZSBhc3NpZ25tZW50PiAtPiA8bGV0IGFzc2lnbm1lbnQ+XG4vLyA8bGV0IGFzc2lnbm1lbnQ+IC0+IFxcZnV0dXJlbGV0PGNvbnRyb2wgc2VxdWVuY2U+PHRva2VuPjx0b2tlbj5cbi8vICAgICB8IFxcbGV0PGNvbnRyb2wgc2VxdWVuY2U+PGVxdWFscz48b25lIG9wdGlvbmFsIHNwYWNlPjx0b2tlbj5cbi8vIDxlcXVhbHM+IC0+IDxvcHRpb25hbCBzcGFjZXM+fDxvcHRpb25hbCBzcGFjZXM+PVxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcbGV0XCIsXG4gICAgXCJcXFxcXFxcXGdsb2JhbGxldFwiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGNvbnN0IG5hbWUgPSBjaGVja0NvbnRyb2xTZXF1ZW5jZShwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCkpO1xuICAgIHBhcnNlci5ndWxsZXQuY29uc3VtZVNwYWNlcygpO1xuICAgIGNvbnN0IHRvayA9IGdldFJIUyhwYXJzZXIpO1xuICAgIGxldENvbW1hbmQocGFyc2VyLCBuYW1lLCB0b2ssIGZ1bmNOYW1lID09PSBcIlxcXFxcXFxcZ2xvYmFsbGV0XCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJuYWxcIiwgbW9kZTogcGFyc2VyLm1vZGUgfTtcbiAgfVxufSk7XG5cbi8vIHJlZjogaHR0cHM6Ly93d3cudHVnLm9yZy9UVUdib2F0L3RiMDktMy90YjIyYmVjaHRvbHNoZWltLnBkZlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcZnV0dXJlbGV0XCIsXG4gICAgXCJcXFxcXFxcXGdsb2JhbGZ1dHVyZVwiIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseVxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGNvbnN0IG5hbWUgPSBjaGVja0NvbnRyb2xTZXF1ZW5jZShwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCkpO1xuICAgIGNvbnN0IG1pZGRsZSA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICBjb25zdCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgbGV0Q29tbWFuZChwYXJzZXIsIG5hbWUsIHRvaywgZnVuY05hbWUgPT09IFwiXFxcXFxcXFxnbG9iYWxmdXR1cmVcIik7XG4gICAgcGFyc2VyLmd1bGxldC5wdXNoVG9rZW4odG9rKTtcbiAgICBwYXJzZXIuZ3VsbGV0LnB1c2hUb2tlbihtaWRkbGUpO1xuICAgIHJldHVybiB7IHR5cGU6IFwiaW50ZXJuYWxcIiwgbW9kZTogcGFyc2VyLm1vZGUgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbnRlcm5hbFwiLFxuICBuYW1lczogW1wiXFxcXG5ld2NvbW1hbmRcIiwgXCJcXFxccmVuZXdjb21tYW5kXCIsIFwiXFxcXHByb3ZpZGVjb21tYW5kXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSkge1xuICAgIGxldCBuYW1lID0gXCJcIjtcbiAgICBjb25zdCB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgaWYgKHRvay50ZXh0ID09PSBcIntcIikge1xuICAgICAgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7XG4gICAgICBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBjaGVja0NvbnRyb2xTZXF1ZW5jZSh0b2spO1xuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0cyA9IHBhcnNlci5ndWxsZXQuaXNEZWZpbmVkKG5hbWUpO1xuICAgIGlmIChleGlzdHMgJiYgZnVuY05hbWUgPT09IFwiXFxcXG5ld2NvbW1hbmRcIikge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIGBcXFxcbmV3Y29tbWFuZHske25hbWV9fSBhdHRlbXB0aW5nIHRvIHJlZGVmaW5lICR7bmFtZX07IHVzZSBcXFxccmVuZXdjb21tYW5kYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFleGlzdHMgJiYgZnVuY05hbWUgPT09IFwiXFxcXHJlbmV3Y29tbWFuZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgYFxcXFxyZW5ld2NvbW1hbmR7JHtuYW1lfX0gd2hlbiBjb21tYW5kICR7bmFtZX0gZG9lcyBub3QgeWV0IGV4aXN0OyB1c2UgXFxcXG5ld2NvbW1hbmRgXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBudW1BcmdzID0gMDtcbiAgICBpZiAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ID09PSBcIltcIikge1xuICAgICAgbGV0IHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICAgIGlmICghL15bMC05XSQvLnRlc3QodG9rLnRleHQpKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHM6IFwiJHt0b2sudGV4dH1cImApO1xuICAgICAgfVxuICAgICAgbnVtQXJncyA9IHBhcnNlSW50KHRvay50ZXh0KTtcbiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTtcbiAgICAgIGlmICh0b2sudGV4dCAhPT0gXCJdXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEludmFsaWQgYXJndW1lbnQgXCIke3Rvay50ZXh0fVwiYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZW1lbnQgdGV4dCwgZW5jbG9zZWQgaW4gJ3snIGFuZCAnfScgYW5kIHByb3Blcmx5IG5lc3RlZFxuICAgIGNvbnN0IHsgdG9rZW5zIH0gPSBwYXJzZXIuZ3VsbGV0LmNvbnN1bWVBcmcoKTtcblxuICAgIGlmICghKGZ1bmNOYW1lID09PSBcIlxcXFxwcm92aWRlY29tbWFuZFwiICYmIHBhcnNlci5ndWxsZXQubWFjcm9zLmhhcyhuYW1lKSkpIHtcbiAgICAgIC8vIElnbm9yZSBcXHByb3ZpZGVjb21tYW5kXG4gICAgICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHsgdG9rZW5zLCBudW1BcmdzIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHlwZTogXCJpbnRlcm5hbFwiLCBtb2RlOiBwYXJzZXIubW9kZSB9O1xuXG4gIH1cbn0pO1xuXG4vLyBFeHRyYSBkYXRhIG5lZWRlZCBmb3IgdGhlIGRlbGltaXRlciBoYW5kbGVyIGRvd24gYmVsb3dcbmNvbnN0IGRlbGltaXRlclNpemVzID0ge1xuICBcIlxcXFxiaWdsXCI6IHsgbWNsYXNzOiBcIm1vcGVuXCIsIHNpemU6IDEgfSxcbiAgXCJcXFxcQmlnbFwiOiB7IG1jbGFzczogXCJtb3BlblwiLCBzaXplOiAyIH0sXG4gIFwiXFxcXGJpZ2dsXCI6IHsgbWNsYXNzOiBcIm1vcGVuXCIsIHNpemU6IDMgfSxcbiAgXCJcXFxcQmlnZ2xcIjogeyBtY2xhc3M6IFwibW9wZW5cIiwgc2l6ZTogNCB9LFxuICBcIlxcXFxiaWdyXCI6IHsgbWNsYXNzOiBcIm1jbG9zZVwiLCBzaXplOiAxIH0sXG4gIFwiXFxcXEJpZ3JcIjogeyBtY2xhc3M6IFwibWNsb3NlXCIsIHNpemU6IDIgfSxcbiAgXCJcXFxcYmlnZ3JcIjogeyBtY2xhc3M6IFwibWNsb3NlXCIsIHNpemU6IDMgfSxcbiAgXCJcXFxcQmlnZ3JcIjogeyBtY2xhc3M6IFwibWNsb3NlXCIsIHNpemU6IDQgfSxcbiAgXCJcXFxcYmlnbVwiOiB7IG1jbGFzczogXCJtcmVsXCIsIHNpemU6IDEgfSxcbiAgXCJcXFxcQmlnbVwiOiB7IG1jbGFzczogXCJtcmVsXCIsIHNpemU6IDIgfSxcbiAgXCJcXFxcYmlnZ21cIjogeyBtY2xhc3M6IFwibXJlbFwiLCBzaXplOiAzIH0sXG4gIFwiXFxcXEJpZ2dtXCI6IHsgbWNsYXNzOiBcIm1yZWxcIiwgc2l6ZTogNCB9LFxuICBcIlxcXFxiaWdcIjogeyBtY2xhc3M6IFwibW9yZFwiLCBzaXplOiAxIH0sXG4gIFwiXFxcXEJpZ1wiOiB7IG1jbGFzczogXCJtb3JkXCIsIHNpemU6IDIgfSxcbiAgXCJcXFxcYmlnZ1wiOiB7IG1jbGFzczogXCJtb3JkXCIsIHNpemU6IDMgfSxcbiAgXCJcXFxcQmlnZ1wiOiB7IG1jbGFzczogXCJtb3JkXCIsIHNpemU6IDQgfVxufTtcblxuY29uc3QgZGVsaW1pdGVycyA9IFtcbiAgXCIoXCIsXG4gIFwiXFxcXGxwYXJlblwiLFxuICBcIilcIixcbiAgXCJcXFxccnBhcmVuXCIsXG4gIFwiW1wiLFxuICBcIlxcXFxsYnJhY2tcIixcbiAgXCJdXCIsXG4gIFwiXFxcXHJicmFja1wiLFxuICBcIlxcXFx7XCIsXG4gIFwiXFxcXGxicmFjZVwiLFxuICBcIlxcXFx9XCIsXG4gIFwiXFxcXHJicmFjZVwiLFxuICBcIuKmh1wiLFxuICBcIlxcXFxsbHBhcmVudGhlc2lzXCIsXG4gIFwi4qaIXCIsXG4gIFwiXFxcXHJycGFyZW50aGVzaXNcIixcbiAgXCJcXFxcbGZsb29yXCIsXG4gIFwiXFxcXHJmbG9vclwiLFxuICBcIlxcdTIzMGFcIixcbiAgXCJcXHUyMzBiXCIsXG4gIFwiXFxcXGxjZWlsXCIsXG4gIFwiXFxcXHJjZWlsXCIsXG4gIFwiXFx1MjMwOFwiLFxuICBcIlxcdTIzMDlcIixcbiAgXCI8XCIsXG4gIFwiPlwiLFxuICBcIlxcXFxsYW5nbGVcIixcbiAgXCJcXHUyN2U4XCIsXG4gIFwiXFxcXHJhbmdsZVwiLFxuICBcIlxcdTI3ZTlcIixcbiAgXCJcXFxcbEFuZ2xlXCIsXG4gIFwiXFx1MjdlYVwiLFxuICBcIlxcXFxyQW5nbGVcIixcbiAgXCJcXHUyN2ViXCIsXG4gIFwiXFxcXGxsYW5nbGVcIixcbiAgXCLipolcIixcbiAgXCJcXFxccnJhbmdsZVwiLFxuICBcIuKmilwiLFxuICBcIlxcXFxsdFwiLFxuICBcIlxcXFxndFwiLFxuICBcIlxcXFxsdmVydFwiLFxuICBcIlxcXFxydmVydFwiLFxuICBcIlxcXFxsVmVydFwiLFxuICBcIlxcXFxyVmVydFwiLFxuICBcIlxcXFxsZ3JvdXBcIixcbiAgXCJcXFxccmdyb3VwXCIsXG4gIFwiXFx1MjdlZVwiLFxuICBcIlxcdTI3ZWZcIixcbiAgXCJcXFxcbG1vdXN0YWNoZVwiLFxuICBcIlxcXFxybW91c3RhY2hlXCIsXG4gIFwiXFx1MjNiMFwiLFxuICBcIlxcdTIzYjFcIixcbiAgXCJcXFxcbGxicmFja2V0XCIsXG4gIFwiXFxcXHJyYnJhY2tldFwiLFxuICBcIlxcdTI3ZTZcIixcbiAgXCJcXHUyN2U2XCIsXG4gIFwiXFxcXGxCcmFjZVwiLFxuICBcIlxcXFxyQnJhY2VcIixcbiAgXCJcXHUyOTgzXCIsXG4gIFwiXFx1Mjk4NFwiLFxuICBcIi9cIixcbiAgXCJcXFxcYmFja3NsYXNoXCIsXG4gIFwifFwiLFxuICBcIlxcXFx2ZXJ0XCIsXG4gIFwiXFxcXHxcIixcbiAgXCJcXFxcVmVydFwiLFxuICBcIlxcdTIwMTZcIixcbiAgXCJcXFxcdXBhcnJvd1wiLFxuICBcIlxcXFxVcGFycm93XCIsXG4gIFwiXFxcXGRvd25hcnJvd1wiLFxuICBcIlxcXFxEb3duYXJyb3dcIixcbiAgXCJcXFxcdXBkb3duYXJyb3dcIixcbiAgXCJcXFxcVXBkb3duYXJyb3dcIixcbiAgXCIuXCJcbl07XG5cbi8vIEV4cG9ydCBpc0RlbGltaXRlciBmb3IgYmVuZWZpdCBvZiBwYXJzZXIuXG5jb25zdCBkZWxzID0gW1wifVwiLCBcIlxcXFxsZWZ0XCIsIFwiXFxcXG1pZGRsZVwiLCBcIlxcXFxyaWdodFwiXTtcbmNvbnN0IGlzRGVsaW1pdGVyID0gc3RyID0+IHN0ci5sZW5ndGggPiAwICYmXG4gIChkZWxpbWl0ZXJzLmluY2x1ZGVzKHN0cikgfHwgZGVsaW1pdGVyU2l6ZXNbc3RyXSB8fCBkZWxzLmluY2x1ZGVzKHN0cikpO1xuXG4vLyBNZXRyaWNzIG9mIHRoZSBkaWZmZXJlbnQgc2l6ZXMuIEZvdW5kIGJ5IGxvb2tpbmcgYXQgVGVYJ3Mgb3V0cHV0IG9mXG4vLyAkXFxiaWdsfCAvLyBcXEJpZ2x8IFxcYmlnZ2x8IFxcQmlnZ2x8IFxcc2hvd2xpc3RzJFxuLy8gVXNlZCB0byBjcmVhdGUgc3RhY2tlZCBkZWxpbWl0ZXJzIG9mIGFwcHJvcHJpYXRlIHNpemVzIGluIG1ha2VTaXplZERlbGltLlxuY29uc3Qgc2l6ZVRvTWF4SGVpZ2h0ID0gWzAsIDEuMiwgMS44LCAyLjQsIDMuMF07XG5cbi8vIERlbGltaXRlciBmdW5jdGlvbnNcbmZ1bmN0aW9uIGNoZWNrRGVsaW1pdGVyKGRlbGltLCBjb250ZXh0KSB7XG4gIGNvbnN0IHN5bURlbGltID0gY2hlY2tTeW1ib2xOb2RlVHlwZShkZWxpbSk7XG4gIGlmIChzeW1EZWxpbSAmJiBkZWxpbWl0ZXJzLmluY2x1ZGVzKHN5bURlbGltLnRleHQpKSB7XG4gICAgLy8gSWYgYSBjaGFyYWN0ZXIgaXMgbm90IGluIHRoZSBNYXRoTUwgb3BlcmF0b3IgZGljdGlvbmFyeSwgaXQgd2lsbCBub3Qgc3RyZXRjaC5cbiAgICAvLyBSZXBsYWNlIHN1Y2ggY2hhcmFjdGVycyB3L2NoYXJhY3RlcnMgdGhhdCB3aWxsIHN0cmV0Y2guXG4gICAgaWYgKFtcIjxcIiwgXCJcXFxcbHRcIl0uaW5jbHVkZXMoc3ltRGVsaW0udGV4dCkpIHsgc3ltRGVsaW0udGV4dCA9IFwi4p+oXCI7IH1cbiAgICBpZiAoW1wiPlwiLCBcIlxcXFxndFwiXS5pbmNsdWRlcyhzeW1EZWxpbS50ZXh0KSkgeyBzeW1EZWxpbS50ZXh0ID0gXCLin6lcIjsgfVxuICAgIHJldHVybiBzeW1EZWxpbTtcbiAgfSBlbHNlIGlmIChzeW1EZWxpbSkge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIGRlbGltaXRlciAnJHtzeW1EZWxpbS50ZXh0fScgYWZ0ZXIgJyR7Y29udGV4dC5mdW5jTmFtZX0nYCwgZGVsaW0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBJbnZhbGlkIGRlbGltaXRlciB0eXBlICcke2RlbGltLnR5cGV9J2AsIGRlbGltKTtcbiAgfVxufVxuXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgXFxcbmNvbnN0IG5lZWRFeHBsaWNpdFN0cmV0Y2ggPSBbXCJcXHUwMDJGXCIsIFwiXFx1MDA1Q1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJcXFxcdmVydFwiLCBcInxcIl07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJkZWxpbXNpemluZ1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGJpZ2xcIixcbiAgICBcIlxcXFxCaWdsXCIsXG4gICAgXCJcXFxcYmlnZ2xcIixcbiAgICBcIlxcXFxCaWdnbFwiLFxuICAgIFwiXFxcXGJpZ3JcIixcbiAgICBcIlxcXFxCaWdyXCIsXG4gICAgXCJcXFxcYmlnZ3JcIixcbiAgICBcIlxcXFxCaWdnclwiLFxuICAgIFwiXFxcXGJpZ21cIixcbiAgICBcIlxcXFxCaWdtXCIsXG4gICAgXCJcXFxcYmlnZ21cIixcbiAgICBcIlxcXFxCaWdnbVwiLFxuICAgIFwiXFxcXGJpZ1wiLFxuICAgIFwiXFxcXEJpZ1wiLFxuICAgIFwiXFxcXGJpZ2dcIixcbiAgICBcIlxcXFxCaWdnXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJwcmltaXRpdmVcIl1cbiAgfSxcbiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHtcbiAgICBjb25zdCBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGVsaW1zaXppbmdcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBzaXplOiBkZWxpbWl0ZXJTaXplc1tjb250ZXh0LmZ1bmNOYW1lXS5zaXplLFxuICAgICAgbWNsYXNzOiBkZWxpbWl0ZXJTaXplc1tjb250ZXh0LmZ1bmNOYW1lXS5tY2xhc3MsXG4gICAgICBkZWxpbTogZGVsaW0udGV4dFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG5cbiAgICBpZiAoZ3JvdXAuZGVsaW0gPT09IFwiLlwiKSB7IGdyb3VwLmRlbGltID0gXCJcIjsgfVxuICAgIGNoaWxkcmVuLnB1c2gobWFrZVRleHQoZ3JvdXAuZGVsaW0sIGdyb3VwLm1vZGUpKTtcblxuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIGNoaWxkcmVuKTtcblxuICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibW9wZW5cIiB8fCBncm91cC5tY2xhc3MgPT09IFwibWNsb3NlXCIpIHtcbiAgICAgIC8vIE9ubHkgc29tZSBvZiB0aGUgZGVsaW1zaXppbmcgZnVuY3Rpb25zIGFjdCBhcyBmZW5jZXMsIGFuZCB0aGV5XG4gICAgICAvLyByZXR1cm4gXCJtb3BlblwiIG9yIFwibWNsb3NlXCIgbWNsYXNzLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZSBmZW5jaW5nIGlmIGl0J3Mgbm90IGEgZmVuY2UsIHRvIG92ZXJyaWRlIHRoZVxuICAgICAgLy8gZGVmYXVsdHMuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwiZmFsc2VcIik7XG4gICAgfVxuICAgIGlmIChuZWVkRXhwbGljaXRTdHJldGNoLmluY2x1ZGVzKGdyb3VwLmRlbGltKSB8fCBncm91cC5kZWxpbS5pbmRleE9mKFwiYXJyb3dcIikgPiAtMSkge1xuICAgICAgLy8gV2UgaGF2ZSB0byBleHBsaWNpdGx5IHNldCBzdHJldGNoeSB0byB0cnVlLlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3ltbWV0cmljXCIsIFwidHJ1ZVwiKTsgLy8gTmVlZGVkIGZvciB0YWxsIGFycm93cyBpbiBGaXJlZm94LlxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWluc2l6ZVwiLCBzaXplVG9NYXhIZWlnaHRbZ3JvdXAuc2l6ZV0gKyBcImVtXCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF4c2l6ZVwiLCBzaXplVG9NYXhIZWlnaHRbZ3JvdXAuc2l6ZV0gKyBcImVtXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYXNzZXJ0UGFyc2VkKGdyb3VwKSB7XG4gIGlmICghZ3JvdXAuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZzogVGhlIGxlZnRyaWdodCBQYXJzZU5vZGUgd2Fzbid0IGZ1bGx5IHBhcnNlZC5cIik7XG4gIH1cbn1cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxlZnRyaWdodC1yaWdodFwiLFxuICBuYW1lczogW1wiXFxcXHJpZ2h0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxlZnRyaWdodC1yaWdodFwiLFxuICAgICAgbW9kZTogY29udGV4dC5wYXJzZXIubW9kZSxcbiAgICAgIGRlbGltOiBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KS50ZXh0XG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJsZWZ0cmlnaHRcIixcbiAgbmFtZXM6IFtcIlxcXFxsZWZ0XCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICBjb25zdCBwYXJzZXIgPSBjb250ZXh0LnBhcnNlcjtcbiAgICAvLyBQYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcbiAgICArK3BhcnNlci5sZWZ0cmlnaHREZXB0aDtcbiAgICAvLyBwYXJzZUV4cHJlc3Npb24gc3RvcHMgYmVmb3JlICdcXFxccmlnaHQnIG9yIGBcXFxcbWlkZGxlYFxuICAgIGxldCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgbnVsbCwgdHJ1ZSk7XG4gICAgbGV0IG5leHRUb2tlbiA9IHBhcnNlci5mZXRjaCgpO1xuICAgIHdoaWxlIChuZXh0VG9rZW4udGV4dCA9PT0gXCJcXFxcbWlkZGxlXCIpIHtcbiAgICAgIC8vIGBcXG1pZGRsZWAsIGZyb20gdGhlIM61LVRlWCBwYWNrYWdlLCBlbmRzIG9uZSBncm91cCBhbmQgc3RhcnRzIGFub3RoZXIgZ3JvdXAuXG4gICAgICAvLyBXZSBoYWQgdG8gcGFyc2UgdGhpcyBleHByZXNzaW9uIHdpdGggYGJyZWFrT25NaWRkbGVgIGVuYWJsZWQgaW4gb3JkZXJcbiAgICAgIC8vIHRvIGdldCBUZVgtY29tcGxpYW50IHBhcnNpbmcgb2YgXFxvdmVyLlxuICAgICAgLy8gQnV0IHdlIGRvIG5vdCB3YW50LCBhdCB0aGlzIHBvaW50LCB0byBlbmQgb24gXFxtaWRkbGUsIHNvIGNvbnRpbnVlXG4gICAgICAvLyB0byBwYXJzZSB1bnRpbCB3ZSBmZXRjaCBhIGBcXHJpZ2h0YC5cbiAgICAgIHBhcnNlci5jb25zdW1lKCk7XG4gICAgICBjb25zdCBtaWRkbGUgPSBwYXJzZXIuZmV0Y2goKS50ZXh0O1xuICAgICAgaWYgKCFzeW1ib2xzLm1hdGhbbWlkZGxlXSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgSW52YWxpZCBkZWxpbWl0ZXIgJyR7bWlkZGxlfScgYWZ0ZXIgJ1xcXFxtaWRkbGUnYCk7XG4gICAgICB9XG4gICAgICBjaGVja0RlbGltaXRlcih7IHR5cGU6IFwiYXRvbVwiLCBtb2RlOiBcIm1hdGhcIiwgdGV4dDogbWlkZGxlIH0sIHsgZnVuY05hbWU6IFwiXFxcXG1pZGRsZVwiIH0pO1xuICAgICAgYm9keS5wdXNoKHsgdHlwZTogXCJtaWRkbGVcIiwgbW9kZTogXCJtYXRoXCIsIGRlbGltOiBtaWRkbGUgfSk7XG4gICAgICBwYXJzZXIuY29uc3VtZSgpO1xuICAgICAgYm9keSA9IGJvZHkuY29uY2F0KHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG51bGwsIHRydWUpKTtcbiAgICAgIG5leHRUb2tlbiA9IHBhcnNlci5mZXRjaCgpO1xuICAgIH1cbiAgICAtLXBhcnNlci5sZWZ0cmlnaHREZXB0aDtcbiAgICAvLyBDaGVjayB0aGUgbmV4dCB0b2tlblxuICAgIHBhcnNlci5leHBlY3QoXCJcXFxccmlnaHRcIiwgZmFsc2UpO1xuICAgIGNvbnN0IHJpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUocGFyc2VyLnBhcnNlRnVuY3Rpb24oKSwgXCJsZWZ0cmlnaHQtcmlnaHRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGVmdHJpZ2h0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBsZWZ0OiBkZWxpbS50ZXh0LFxuICAgICAgcmlnaHQ6IHJpZ2h0LmRlbGltXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGFzc2VydFBhcnNlZChncm91cCk7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUpO1xuXG4gICAgaWYgKGdyb3VwLmxlZnQgPT09IFwiLlwiKSB7IGdyb3VwLmxlZnQgPSBcIlwiOyB9XG4gICAgY29uc3QgbGVmdE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5sZWZ0LCBncm91cC5tb2RlKV0pO1xuICAgIGxlZnROb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIFwicHJlZml4XCIpO1xuICAgIGlmIChncm91cC5sZWZ0ID09PSBcIi9cIiB8fCBncm91cC5sZWZ0ID09PSBcIlxcdTAwNUNcIiB8fCBncm91cC5sZWZ0LmluZGV4T2YoXCJhcnJvd1wiKSA+IC0xKSB7XG4gICAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcInRydWVcIik7XG4gICAgfVxuICAgIGlubmVyLnVuc2hpZnQobGVmdE5vZGUpO1xuXG4gICAgaWYgKGdyb3VwLnJpZ2h0ID09PSBcIi5cIikgeyBncm91cC5yaWdodCA9IFwiXCI7IH1cbiAgICBjb25zdCByaWdodE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChncm91cC5yaWdodCwgZ3JvdXAubW9kZSldKTtcbiAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIFwicG9zdGZpeFwiKTtcbiAgICBpZiAoZ3JvdXAucmlnaHQgPT09IFwiXFx1MjIxNlwiIHx8IGdyb3VwLnJpZ2h0LmluZGV4T2YoXCJhcnJvd1wiKSA+IC0xKSB7XG4gICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAuYm9keS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGdyb3VwLmJvZHlbZ3JvdXAuYm9keS5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0RWxlbWVudC50eXBlID09PSBcImNvbG9yXCIgJiYgIWxhc3RFbGVtZW50LmlzVGV4dENvbG9yKSB7XG4gICAgICAgIC8vIFxcY29sb3IgaXMgYSBzd2l0Y2guIElmIHRoZSBsYXN0IGVsZW1lbnQgaXMgb2YgdHlwZSBcImNvbG9yXCIgdGhlblxuICAgICAgICAvLyB0aGUgdXNlciBzZXQgdGhlIFxcY29sb3Igc3dpdGNoIGFuZCBsZWZ0IGl0IG9uLlxuICAgICAgICAvLyBBIFxccmlnaHQgZGVsaW1pdGVyIHR1cm5zIHRoZSBzd2l0Y2ggb2ZmLCBidXQgdGhlIGRlbGltaXRlciBpdHNlbGYgZ2V0cyB0aGUgY29sb3IuXG4gICAgICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoY29sb3JcIiwgbGFzdEVsZW1lbnQuY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbm5lci5wdXNoKHJpZ2h0Tm9kZSk7XG5cbiAgICByZXR1cm4gbWFrZVJvdyhpbm5lcik7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWlkZGxlXCIsXG4gIG5hbWVzOiBbXCJcXFxcbWlkZGxlXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInByaW1pdGl2ZVwiXVxuICB9LFxuICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4ge1xuICAgIGNvbnN0IGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG4gICAgaWYgKCFjb250ZXh0LnBhcnNlci5sZWZ0cmlnaHREZXB0aCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcbWlkZGxlIHdpdGhvdXQgcHJlY2VkaW5nIFxcXFxsZWZ0XCIsIGRlbGltKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtaWRkbGVcIixcbiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsXG4gICAgICBkZWxpbTogZGVsaW0udGV4dFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCB0ZXh0Tm9kZSA9IG1ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKTtcbiAgICBjb25zdCBtaWRkbGVOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbdGV4dE5vZGVdKTtcbiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICBpZiAoZ3JvdXAuZGVsaW0uaW5kZXhPZihcImFycm93XCIpID4gLTEpIHtcbiAgICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuICAgIH1cbiAgICAvLyBUaGUgbmV4dCBsaW5lIGlzIG5vdCBzZW1hbnRpY2FsbHkgY29ycmVjdCwgYnV0XG4gICAgLy8gQ2hyb21pdW0gZmFpbHMgdG8gc3RyZXRjaCBpZiBpdCBpcyBub3QgdGhlcmUuXG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIFwicHJlZml4XCIpO1xuICAgIC8vIE1hdGhNTCBnaXZlcyA1LzE4ZW0gc3BhY2luZyB0byBlYWNoIDxtbz4gZWxlbWVudC5cbiAgICAvLyBcXG1pZGRsZSBzaG91bGQgZ2V0IGRlbGltaXRlciBzcGFjaW5nIGluc3RlYWQuXG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoXCJyc3BhY2VcIiwgXCIwLjA1ZW1cIik7XG4gICAgcmV0dXJuIG1pZGRsZU5vZGU7XG4gIH1cbn0pO1xuXG5jb25zdCBwYWRkaW5nID0gXyA9PiB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjNwdFwiKTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkNyA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgbGV0IG5vZGU7XG4gIGlmIChncm91cC5sYWJlbC5pbmRleE9mKFwiY29sb3Jib3hcIikgPiAtMSB8fCBncm91cC5sYWJlbCA9PT0gXCJcXFxcYm94ZWRcIikge1xuICAgIC8vIE1hdGhNTCBjb3JlIGRvZXMgbm90IHN1cHBvcnQgK3dpZHRoIGF0dHJpYnV0ZSBpbiA8bXBhZGRlZD4uXG4gICAgLy8gRmlyZWZveCBkb2VzIG5vdCByZWxpYWJseSBhZGQgc2lkZSBwYWRkaW5nLlxuICAgIC8vIEluc2VydCA8bXNwYWNlPlxuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW1xuICAgICAgcGFkZGluZygpLFxuICAgICAgYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIHN0eWxlKSxcbiAgICAgIHBhZGRpbmcoKVxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1lbmNsb3NlXCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpXSk7XG4gIH1cbiAgc3dpdGNoIChncm91cC5sYWJlbCkge1xuICAgIGNhc2UgXCJcXFxcb3ZlcmxpbmVcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJ0b3BcIik7IC8vIGZvciBGaXJlZm94ICYgV2ViS2l0XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC1vdmVybGluZVwiKTsgICAgLy8gZm9yIENocm9taXVtXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcdW5kZXJsaW5lXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYm90dG9tXCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJ0bWwtdW5kZXJsaW5lXCIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGNhbmNlbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInVwZGlhZ29uYWxzdHJpa2VcIik7XG4gICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJ0bWwtY2FuY2VsXCIsIFwidXBzdHJpa2VcIl0pKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxiY2FuY2VsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiZG93bmRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbXSwgW1widG1sLWNhbmNlbFwiLCBcImRvd25zdHJpa2VcIl0pKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxzb3V0XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiaG9yaXpvbnRhbHN0cmlrZVwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInRtbC1jYW5jZWxcIiwgXCJzb3V0XCJdKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxceGNhbmNlbFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcInVwZGlhZ29uYWxzdHJpa2UgZG93bmRpYWdvbmFsc3RyaWtlXCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJ0bWwteGNhbmNlbFwiKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxsb25nZGl2XCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwibG9uZ2RpdlwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwibG9uZ2Rpdi10b3BcIik7XG4gICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJsb25nZGl2LWFyY1wiXSkpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXHBoYXNlXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwicGhhc29yYW5nbGVcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInBoYXNvci1ib3R0b21cIik7XG4gICAgICBub2RlLmNoaWxkcmVuLnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJwaGFzb3ItYW5nbGVcIl0pKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFx0ZXh0Y2lyY2xlZFwiOlxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImNpcmNsZVwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwiY2lyY2xlLXBhZFwiKTtcbiAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW10sIFtcInRleHRjaXJjbGVcIl0pKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIlxcXFxhbmdsXCI6XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm5vdGF0aW9uXCIsIFwiYWN0dWFyaWFsXCIpO1xuICAgICAgbm9kZS5jbGFzc2VzLnB1c2goXCJhY3R1YXJpYWxcIik7XG4gICAgICBicmVha1xuICAgIGNhc2UgXCJcXFxcYm94ZWRcIjpcbiAgICAgIC8vIFxcbmV3Y29tbWFuZHtcXGJveGVkfVsxXXtcXGZib3h7XFxtQHRoJFxcZGlzcGxheXN0eWxlIzEkfX0gZnJvbSBhbXNtYXRoLnN0eVxuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJub3RhdGlvblwiLCBcImJveFwiKTtcbiAgICAgIG5vZGUuY2xhc3Nlcy5wdXNoKFwidG1sLWJveFwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIwXCIpO1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgXCJ0cnVlXCIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGZib3hcIjpcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibm90YXRpb25cIiwgXCJib3hcIik7XG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC1mYm94XCIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiXFxcXGZjb2xvcmJveFwiOlxuICAgIGNhc2UgXCJcXFxcY29sb3Jib3hcIjoge1xuICAgICAgLy8gPG1lbmNsb3NlPiBkb2Vzbid0IGhhdmUgYSBnb29kIG5vdGF0aW9uIG9wdGlvbiBmb3IgXFxjb2xvcmJveC5cbiAgICAgIC8vIFNvIHVzZSA8bXBhZGRlZD4gaW5zdGVhZC4gU2V0IHNvbWUgYXR0cmlidXRlcyB0aGF0IGNvbWVcbiAgICAgIC8vIGluY2x1ZGVkIHdpdGggPG1lbmNsb3NlPi5cbiAgICAgIC8vY29uc3QgZmJveHNlcCA9IDM7IC8vIDMgcHQgZnJvbSBMYVRlWCBzb3VyY2UyZVxuICAgICAgLy9ub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgKyR7MiAqIGZib3hzZXB9cHRgKVxuICAgICAgLy9ub2RlLnNldEF0dHJpYnV0ZShcInZvZmZzZXRcIiwgYCR7ZmJveHNlcH1wdGApXG4gICAgICBjb25zdCBzdHlsZSA9IHsgcGFkZGluZzogXCIzcHQgMCAzcHQgMFwiIH07XG5cbiAgICAgIGlmIChncm91cC5sYWJlbCA9PT0gXCJcXFxcZmNvbG9yYm94XCIpIHtcbiAgICAgICAgc3R5bGUuYm9yZGVyID0gXCIwLjA2NjdlbSBzb2xpZCBcIiArIFN0cmluZyhncm91cC5ib3JkZXJDb2xvcik7XG4gICAgICB9XG4gICAgICBub2RlLnN0eWxlID0gc3R5bGU7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBncm91cC5iYWNrZ3JvdW5kQ29sb3IpO1xuICB9XG4gIHJldHVybiBub2RlO1xufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxjb2xvcmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJyYXdcIiwgXCJ0ZXh0XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBtb2RlbCA9IG9wdEFyZ3NbMF0gJiYgYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgIGxldCBjb2xvciA9IFwiXCI7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBjb25zdCBzcGVjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgICAgY29sb3IgPSBjb2xvckZyb21TcGVjKG1vZGVsLCBzcGVjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sb3IgPSB2YWxpZGF0ZUNvbG9yKGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZywgcGFyc2VyLmd1bGxldC5tYWNyb3MpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ3XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFxmY29sb3Jib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMyxcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhcmdUeXBlczogW1wicmF3XCIsIFwicmF3XCIsIFwicmF3XCIsIFwidGV4dFwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3QgbW9kZWwgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBsZXQgYm9yZGVyQ29sb3IgPSBcIlwiO1xuICAgIGxldCBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICBjb25zdCBib3JkZXJTcGVjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFNwZWMgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInJhd1wiKS5zdHJpbmc7XG4gICAgICBib3JkZXJDb2xvciA9IGNvbG9yRnJvbVNwZWMobW9kZWwsIGJvcmRlclNwZWMpO1xuICAgICAgYmFja2dyb3VuZENvbG9yID0gY29sb3JGcm9tU3BlYyhtb2RlbCwgYmFja2dyb3VuZFNwZWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3JkZXJDb2xvciA9IHZhbGlkYXRlQ29sb3IoYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJyYXdcIikuc3RyaW5nLCBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcyk7XG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSB2YWxpZGF0ZUNvbG9yKGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sIFwicmF3XCIpLnN0cmluZywgcGFyc2VyLmd1bGxldC5tYWNyb3MpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYXJnc1syXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlckNvbG9yLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkN1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbmNsb3NlXCIsXG4gIG5hbWVzOiBbXCJcXFxcZmJveFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJoYm94XCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW5jbG9zZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogXCJcXFxcZmJveFwiLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXGFuZ2xcIiwgXCJcXFxcY2FuY2VsXCIsIFwiXFxcXGJjYW5jZWxcIiwgXCJcXFxceGNhbmNlbFwiLCBcIlxcXFxzb3V0XCIsIFwiXFxcXG92ZXJsaW5lXCIsXG4gICAgXCJcXFxcYm94ZWRcIiwgXCJcXFxcbG9uZ2RpdlwiLCBcIlxcXFxwaGFzZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbmNsb3NlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGxhYmVsOiBmdW5jTmFtZSxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDdcbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZW5jbG9zZVwiLFxuICBuYW1lczogW1wiXFxcXHVuZGVybGluZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkN1xufSk7XG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVuY2xvc2VcIixcbiAgbmFtZXM6IFtcIlxcXFx0ZXh0Y2lyY2xlZFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdLFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVuY2xvc2VcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGFiZWw6IGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkN1xufSk7XG5cbi8vIEVudmlyb25tZW50IGRlbGltaXRlcnMuIEhUTUwvTWF0aE1MIHJlbmRlcmluZyBpcyBkZWZpbmVkIGluIHRoZSBjb3JyZXNwb25kaW5nXG4vLyBkZWZpbmVFbnZpcm9ubWVudCBkZWZpbml0aW9ucy5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJlbnZpcm9ubWVudFwiLFxuICBuYW1lczogW1wiXFxcXGJlZ2luXCIsIFwiXFxcXGVuZFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBuYW1lR3JvdXAgPSBhcmdzWzBdO1xuICAgIGlmIChuYW1lR3JvdXAudHlwZSAhPT0gXCJvcmRncm91cFwiKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgZW52aXJvbm1lbnQgbmFtZVwiLCBuYW1lR3JvdXApO1xuICAgIH1cbiAgICBsZXQgZW52TmFtZSA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lR3JvdXAuYm9keS5sZW5ndGg7ICsraSkge1xuICAgICAgZW52TmFtZSArPSBhc3NlcnROb2RlVHlwZShuYW1lR3JvdXAuYm9keVtpXSwgXCJ0ZXh0b3JkXCIpLnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmNOYW1lID09PSBcIlxcXFxiZWdpblwiKSB7XG4gICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZW52aXJvbm1lbnRzLCBlbnZOYW1lICkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJObyBzdWNoIGVudmlyb25tZW50OiBcIiArIGVudk5hbWUsIG5hbWVHcm91cCk7XG4gICAgICB9XG4gICAgICAvLyBCdWlsZCB0aGUgZW52aXJvbm1lbnQgb2JqZWN0LiBBcmd1bWVudHMgYW5kIG90aGVyIGluZm9ybWF0aW9uIHdpbGxcbiAgICAgIC8vIGJlIG1hZGUgYXZhaWxhYmxlIHRvIHRoZSBiZWdpbiBhbmQgZW5kIG1ldGhvZHMgdXNpbmcgcHJvcGVydGllcy5cbiAgICAgIGNvbnN0IGVudiA9IGVudmlyb25tZW50c1tlbnZOYW1lXTtcbiAgICAgIGNvbnN0IHsgYXJncywgb3B0QXJncyB9ID0gcGFyc2VyLnBhcnNlQXJndW1lbnRzKFwiXFxcXGJlZ2lue1wiICsgZW52TmFtZSArIFwifVwiLCBlbnYpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGVudk5hbWUsXG4gICAgICAgIHBhcnNlclxuICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGVudi5oYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpO1xuICAgICAgcGFyc2VyLmV4cGVjdChcIlxcXFxlbmRcIiwgZmFsc2UpO1xuICAgICAgY29uc3QgZW5kTmFtZVRva2VuID0gcGFyc2VyLm5leHRUb2tlbjtcbiAgICAgIGNvbnN0IGVuZCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksIFwiZW52aXJvbm1lbnRcIik7XG4gICAgICBpZiAoZW5kLm5hbWUgIT09IGVudk5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgYE1pc21hdGNoOiBcXFxcYmVnaW57JHtlbnZOYW1lfX0gbWF0Y2hlZCBieSBcXFxcZW5keyR7ZW5kLm5hbWV9fWAsXG4gICAgICAgICAgZW5kTmFtZVRva2VuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG5hbWU6IGVudk5hbWUsXG4gICAgICBuYW1lR3JvdXBcbiAgICB9O1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImVudlRhZ1wiLFxuICBuYW1lczogW1wiXFxcXGVudkB0YWdcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wibWF0aFwiXVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJlbnZUYWdcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJub1RhZ1wiLFxuICBuYW1lczogW1wiXFxcXGVudkBub3RhZ1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm5vVGFnXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgfVxufSk7XG5cbmNvbnN0IGlzTG9uZ1ZhcmlhYmxlTmFtZSA9IChncm91cCwgZm9udCkgPT4ge1xuICBpZiAoZm9udCAhPT0gXCJtYXRocm1cIiB8fCBncm91cC5ib2R5LnR5cGUgIT09IFwib3JkZ3JvdXBcIiB8fCBncm91cC5ib2R5LmJvZHkubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGdyb3VwLmJvZHkuYm9keVswXS50eXBlICE9PSBcIm1hdGhvcmRcIikgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGdyb3VwLmJvZHkuYm9keS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcnNlTm9kZVR5cGUgPSBncm91cC5ib2R5LmJvZHlbaV0udHlwZTtcbiAgICBpZiAoIShwYXJzZU5vZGVUeXBlID09PSAgXCJtYXRob3JkXCIgfHxcbiAgICAocGFyc2VOb2RlVHlwZSA9PT0gIFwidGV4dG9yZFwiICYmICFpc05hTihncm91cC5ib2R5LmJvZHlbaV0udGV4dCkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJDYgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IGZvbnQgPSBncm91cC5mb250O1xuICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlLndpdGhGb250KGZvbnQpO1xuICBjb25zdCBtYXRoR3JvdXAgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgbmV3U3R5bGUpO1xuXG4gIGlmIChtYXRoR3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7IHJldHVybiBtYXRoR3JvdXAgfSAvLyBlbXB0eSBncm91cCwgZS5nLiwgXFxtYXRocm17fVxuICBpZiAoZm9udCA9PT0gXCJib2xkc3ltYm9sXCIgJiYgW1wibW9cIiwgXCJtcGFkZGVkXCIsIFwibXJvd1wiXS5pbmNsdWRlcyhtYXRoR3JvdXAudHlwZSkpIHtcbiAgICBtYXRoR3JvdXAuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgIHJldHVybiBtYXRoR3JvdXBcbiAgfVxuICAvLyBDaGVjayBpZiBpdCBpcyBwb3NzaWJsZSB0byBjb25zb2xpZGF0ZSBlbGVtZW50cyBpbnRvIGEgc2luZ2xlIDxtaT4gZWxlbWVudC5cbiAgaWYgKGlzTG9uZ1ZhcmlhYmxlTmFtZShncm91cCwgZm9udCkpIHtcbiAgICAvLyBUaGlzIGlzIGEgXFxtYXRocm174oCmfSBncm91cC4gSXQgZ2V0cyBzcGVjaWFsIHRyZWF0bWVudCBiZWNhdXNlIHN5bWJvbHNPcmQuanNcbiAgICAvLyB3cmFwcyA8bWk+IGVsZW1lbnRzIHdpdGggPG1yb3c+cyB0byB3b3JrIGFyb3VuZCBhIEZpcmVmb3ggYnVnLlxuICAgIGNvbnN0IG1pID0gbWF0aEdyb3VwLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdO1xuICAgIGRlbGV0ZSBtaS5hdHRyaWJ1dGVzLm1hdGh2YXJpYW50O1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbWF0aEdyb3VwLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtaS5jaGlsZHJlblswXS50ZXh0ICs9IG1hdGhHcm91cC5jaGlsZHJlbltpXS50eXBlID09PSBcIm1uXCJcbiAgICAgICAgPyBtYXRoR3JvdXAuY2hpbGRyZW5baV0uY2hpbGRyZW5bMF0udGV4dFxuICAgICAgICA6IG1hdGhHcm91cC5jaGlsZHJlbltpXS5jaGlsZHJlblswXS5jaGlsZHJlblswXS50ZXh0O1xuICAgIH1cbiAgICAvLyBXcmFwIGluIGEgPG1yb3c+IHRvIHByZXZlbnQgdGhlIHNhbWUgRmlyZWZveCBidWcuXG4gICAgY29uc3QgYm9ndXMgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAwYlwiKSk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbYm9ndXMsIG1pXSlcbiAgfVxuICBsZXQgY2FuQ29uc29saWRhdGUgPSBtYXRoR3JvdXAuY2hpbGRyZW5bMF0udHlwZSA9PT0gXCJtb1wiO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG1hdGhHcm91cC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChtYXRoR3JvdXAuY2hpbGRyZW5baV0udHlwZSA9PT0gXCJtb1wiICYmIGZvbnQgPT09IFwiYm9sZHN5bWJvbFwiKSB7XG4gICAgICBtYXRoR3JvdXAuY2hpbGRyZW5baV0uc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBpZiAobWF0aEdyb3VwLmNoaWxkcmVuW2ldLnR5cGUgIT09IFwibWlcIikgeyBjYW5Db25zb2xpZGF0ZSA9IGZhbHNlOyB9XG4gICAgY29uc3QgbG9jYWxWYXJpYW50ID0gbWF0aEdyb3VwLmNoaWxkcmVuW2ldLmF0dHJpYnV0ZXMgJiZcbiAgICAgIG1hdGhHcm91cC5jaGlsZHJlbltpXS5hdHRyaWJ1dGVzLm1hdGh2YXJpYW50IHx8IFwiXCI7XG4gICAgaWYgKGxvY2FsVmFyaWFudCAhPT0gXCJub3JtYWxcIikgeyBjYW5Db25zb2xpZGF0ZSA9IGZhbHNlOyB9XG4gIH1cbiAgaWYgKCFjYW5Db25zb2xpZGF0ZSkgeyByZXR1cm4gbWF0aEdyb3VwIH1cbiAgLy8gQ29uc29saWRhdGUgdGhlIDxtaT4gZWxlbWVudHMuXG4gIGNvbnN0IG1pID0gbWF0aEdyb3VwLmNoaWxkcmVuWzBdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IG1hdGhHcm91cC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIG1pLmNoaWxkcmVuLnB1c2gobWF0aEdyb3VwLmNoaWxkcmVuW2ldLmNoaWxkcmVuWzBdKTtcbiAgfVxuICBpZiAobWkuYXR0cmlidXRlcy5tYXRodmFyaWFudCAmJiBtaS5hdHRyaWJ1dGVzLm1hdGh2YXJpYW50ID09PSBcIm5vcm1hbFwiKSB7XG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgYSBGaXJlZm94IGJ1ZyB0aGF0IHJlbmRlcnMgc3B1cmlvdXMgc3BhY2UgYXJvdW5kXG4gICAgLy8gYSA8bWkgbWF0aHZhcmlhbnQ9XCJub3JtYWxcIj5cbiAgICAvLyBSZWY6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjkwOTdcbiAgICAvLyBXZSBpbnNlcnQgYSB0ZXh0IG5vZGUgdGhhdCBjb250YWlucyBhIHplcm8td2lkdGggc3BhY2UgYW5kIHdyYXAgaW4gYW4gbXJvdy5cbiAgICAvLyBUT0RPOiBHZXQgcmlkIG9mIHRoaXMgPG1pPiB3b3JrYXJvdW5kIHdoZW4gdGhlIEZpcmVmb3ggYnVnIGlzIGZpeGVkLlxuICAgIGNvbnN0IGJvZ3VzID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShcIlxcdTIwMGJcIikpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgW2JvZ3VzLCBtaV0pXG4gIH1cbiAgcmV0dXJuIG1pXG59O1xuXG5jb25zdCBmb250QWxpYXNlcyA9IHtcbiAgXCJcXFxcQmJiXCI6IFwiXFxcXG1hdGhiYlwiLFxuICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICBcIlxcXFxmcmFrXCI6IFwiXFxcXG1hdGhmcmFrXCIsXG4gIFwiXFxcXGJtXCI6IFwiXFxcXGJvbGRzeW1ib2xcIlxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImZvbnRcIixcbiAgbmFtZXM6IFtcbiAgICAvLyBzdHlsZXNcbiAgICBcIlxcXFxtYXRocm1cIixcbiAgICBcIlxcXFxtYXRoaXRcIixcbiAgICBcIlxcXFxtYXRoYmZcIixcbiAgICBcIlxcXFxtYXRobm9ybWFsXCIsXG4gICAgXCJcXFxcdXBAZ3JlZWtcIixcbiAgICBcIlxcXFxib2xkc3ltYm9sXCIsXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwiXFxcXG1hdGhiYlwiLFxuICAgIFwiXFxcXG1hdGhjYWxcIixcbiAgICBcIlxcXFxtYXRoZnJha1wiLFxuICAgIFwiXFxcXG1hdGhzY3JcIixcbiAgICBcIlxcXFxtYXRoc2ZcIixcbiAgICBcIlxcXFxtYXRoc2ZpdFwiLFxuICAgIFwiXFxcXG1hdGh0dFwiLFxuXG4gICAgLy8gYWxpYXNlc1xuICAgIFwiXFxcXEJiYlwiLFxuICAgIFwiXFxcXGJtXCIsXG4gICAgXCJcXFxcYm9sZFwiLFxuICAgIFwiXFxcXGZyYWtcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pO1xuICAgIGxldCBmdW5jID0gZnVuY05hbWU7XG4gICAgaWYgKGZ1bmMgaW4gZm9udEFsaWFzZXMpIHtcbiAgICAgIGZ1bmMgPSBmb250QWxpYXNlc1tmdW5jXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNlxufSk7XG5cbi8vIE9sZCBmb250IGNoYW5naW5nIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImZvbnRcIixcbiAgbmFtZXM6IFtcIlxcXFxybVwiLCBcIlxcXFxzZlwiLCBcIlxcXFx0dFwiLCBcIlxcXFxiZlwiLCBcIlxcXFxpdFwiLCBcIlxcXFxjYWxcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUsIGJyZWFrT25Ub2tlblRleHQgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IHsgbW9kZSB9ID0gcGFyc2VyO1xuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKHRydWUsIGJyZWFrT25Ub2tlblRleHQsIHRydWUpO1xuICAgIGNvbnN0IGZvbnRTdHlsZSA9IGBtYXRoJHtmdW5jTmFtZS5zbGljZSgxKX1gO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgbW9kZTogbW9kZSxcbiAgICAgIGZvbnQ6IGZvbnRTdHlsZSxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgYm9keVxuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNlxufSk7XG5cbmNvbnN0IHN0eWxBcnJheSA9IFtcImRpc3BsYXlcIiwgXCJ0ZXh0XCIsIFwic2NyaXB0XCIsIFwic2NyaXB0c2NyaXB0XCJdO1xuY29uc3Qgc2NyaXB0TGV2ZWwgPSB7IGF1dG86IC0xLCBkaXNwbGF5OiAwLCB0ZXh0OiAwLCBzY3JpcHQ6IDEsIHNjcmlwdHNjcmlwdDogMiB9O1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJDUgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIC8vIFRyYWNrIHRoZSBzY3JpcHRMZXZlbCBvZiB0aGUgbnVtZXJhdG9yIGFuZCBkZW5vbWluYXRvci5cbiAgLy8gV2UgbWF5IG5lZWQgdGhhdCBpbmZvIGZvciBcXG1hdGhjaG9pY2Ugb3IgZm9yIGFkanVzdGluZyBlbSBkaW1lbnNpb25zLlxuICBjb25zdCBjaGlsZE9wdGlvbnMgPSBncm91cC5zY3JpcHRMZXZlbCA9PT0gXCJhdXRvXCJcbiAgICA/IHN0eWxlLmluY3JlbWVudExldmVsKClcbiAgICA6IGdyb3VwLnNjcmlwdExldmVsID09PSBcImRpc3BsYXlcIlxuICAgID8gc3R5bGUud2l0aExldmVsKFN0eWxlTGV2ZWwuVEVYVClcbiAgICA6IGdyb3VwLnNjcmlwdExldmVsID09PSBcInRleHRcIlxuICAgID8gc3R5bGUud2l0aExldmVsKFN0eWxlTGV2ZWwuU0NSSVBUKVxuICAgIDogc3R5bGUud2l0aExldmVsKFN0eWxlTGV2ZWwuU0NSSVBUU0NSSVBUKTtcblxuICAvLyBDaHJvbWl1bSAod3JvbmdseSkgY29udGludWVzIHRvIHNocmluayBmcmFjdGlvbnMgYmV5b25kIHNjcmlwdHNjcmlwdGxldmVsLlxuICAvLyBTbyB3ZSBjaGVjayBmb3IgbGV2ZWxzIHRoYXQgQ2hyb21pdW0gc2hyaW5rcyB0b28gc21hbGwuXG4gIC8vIElmIG5lY2Vzc2FyeSwgc2V0IGFuIGV4cGxpY2l0IGZyYWN0aW9uIGRlcHRoLlxuICBjb25zdCBudW1lciA9IGJ1aWxkR3JvdXAkMShncm91cC5udW1lciwgY2hpbGRPcHRpb25zKTtcbiAgY29uc3QgZGVub20gPSBidWlsZEdyb3VwJDEoZ3JvdXAuZGVub20sIGNoaWxkT3B0aW9ucyk7XG4gIGlmIChzdHlsZS5sZXZlbCA9PT0gMykge1xuICAgIG51bWVyLnN0eWxlLm1hdGhEZXB0aCA9IFwiMlwiO1xuICAgIG51bWVyLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMlwiKTtcbiAgICBkZW5vbS5zdHlsZS5tYXRoRGVwdGggPSBcIjJcIjtcbiAgICBkZW5vbS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBcIjJcIik7XG4gIH1cblxuICBsZXQgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWZyYWNcIiwgW251bWVyLCBkZW5vbV0pO1xuXG4gIGlmICghZ3JvdXAuaGFzQmFyTGluZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZXRoaWNrbmVzc1wiLCBcIjBweFwiKTtcbiAgfSBlbHNlIGlmIChncm91cC5iYXJTaXplKSB7XG4gICAgY29uc3QgcnVsZVdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC5iYXJTaXplLCBzdHlsZSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIHJ1bGVXaWR0aC5udW1iZXIgKyBydWxlV2lkdGgudW5pdCk7XG4gIH1cblxuICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwgfHwgZ3JvdXAucmlnaHREZWxpbSAhPSBudWxsKSB7XG4gICAgY29uc3Qgd2l0aERlbGltcyA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLmxlZnREZWxpbSAhPSBudWxsKSB7XG4gICAgICBjb25zdCBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFtcbiAgICAgICAgbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAubGVmdERlbGltLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKVxuICAgICAgXSk7XG4gICAgICBsZWZ0T3Auc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgICAgd2l0aERlbGltcy5wdXNoKGxlZnRPcCk7XG4gICAgfVxuXG4gICAgd2l0aERlbGltcy5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkge1xuICAgICAgY29uc3QgcmlnaHRPcCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW1xuICAgICAgICBuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5yaWdodERlbGltLnJlcGxhY2UoXCJcXFxcXCIsIFwiXCIpKVxuICAgICAgXSk7XG4gICAgICByaWdodE9wLnNldEF0dHJpYnV0ZShcImZlbmNlXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHdpdGhEZWxpbXMucHVzaChyaWdodE9wKTtcbiAgICB9XG5cbiAgICBub2RlID0gbWFrZVJvdyh3aXRoRGVsaW1zKTtcbiAgfVxuXG4gIGlmIChncm91cC5zY3JpcHRMZXZlbCAhPT0gXCJhdXRvXCIpIHtcbiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3R5bGVcIiwgW25vZGVdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRpc3BsYXlzdHlsZVwiLCBTdHJpbmcoZ3JvdXAuc2NyaXB0TGV2ZWwgPT09IFwiZGlzcGxheVwiKSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzY3JpcHRsZXZlbFwiLCBzY3JpcHRMZXZlbFtncm91cC5zY3JpcHRMZXZlbF0pO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGRmcmFjXCIsXG4gICAgXCJcXFxcZnJhY1wiLFxuICAgIFwiXFxcXHRmcmFjXCIsXG4gICAgXCJcXFxcZGJpbm9tXCIsXG4gICAgXCJcXFxcYmlub21cIixcbiAgICBcIlxcXFx0Ymlub21cIixcbiAgICBcIlxcXFxcXFxcYXRvcGZyYWNcIiwgLy8gY2Fu4oCZdCBiZSBlbnRlcmVkIGRpcmVjdGx5XG4gICAgXCJcXFxcXFxcXGJyYWNlZnJhY1wiLFxuICAgIFwiXFxcXFxcXFxicmFja2ZyYWNcIiAvLyBkaXR0b1xuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDIsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzBdO1xuICAgIGNvbnN0IGRlbm9tID0gYXJnc1sxXTtcbiAgICBsZXQgaGFzQmFyTGluZSA9IGZhbHNlO1xuICAgIGxldCBsZWZ0RGVsaW0gPSBudWxsO1xuICAgIGxldCByaWdodERlbGltID0gbnVsbDtcbiAgICBsZXQgc2NyaXB0TGV2ZWwgPSBcImF1dG9cIjtcblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcZGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXFxcXFxhdG9wZnJhY1wiOlxuICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxkYmlub21cIjpcbiAgICAgIGNhc2UgXCJcXFxcYmlub21cIjpcbiAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgIGxlZnREZWxpbSA9IFwiKFwiO1xuICAgICAgICByaWdodERlbGltID0gXCIpXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI6XG4gICAgICAgIGxlZnREZWxpbSA9IFwiXFxcXHtcIjtcbiAgICAgICAgcmlnaHREZWxpbSA9IFwiXFxcXH1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXFxcXFxicmFja2ZyYWNcIjpcbiAgICAgICAgbGVmdERlbGltID0gXCJbXCI7XG4gICAgICAgIHJpZ2h0RGVsaW0gPSBcIl1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoZnVuY05hbWUpIHtcbiAgICAgIGNhc2UgXCJcXFxcZGZyYWNcIjpcbiAgICAgIGNhc2UgXCJcXFxcZGJpbm9tXCI6XG4gICAgICAgIHNjcmlwdExldmVsID0gXCJkaXNwbGF5XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgc2NyaXB0TGV2ZWwgPSBcInRleHRcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgbnVtZXIsXG4gICAgICBkZW5vbSxcbiAgICAgIGhhc0JhckxpbmUsXG4gICAgICBsZWZ0RGVsaW0sXG4gICAgICByaWdodERlbGltLFxuICAgICAgc2NyaXB0TGV2ZWwsXG4gICAgICBiYXJTaXplOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImdlbmZyYWNcIixcbiAgbmFtZXM6IFtcIlxcXFxjZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IG51bWVyID0gYXJnc1swXTtcbiAgICBjb25zdCBkZW5vbSA9IGFyZ3NbMV07XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGNvbnRpbnVlZDogdHJ1ZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBoYXNCYXJMaW5lOiB0cnVlLFxuICAgICAgbGVmdERlbGltOiBudWxsLFxuICAgICAgcmlnaHREZWxpbTogbnVsbCxcbiAgICAgIHNjcmlwdExldmVsOiBcImRpc3BsYXlcIixcbiAgICAgIGJhclNpemU6IG51bGxcbiAgICB9O1xuICB9XG59KTtcblxuLy8gSW5maXggZ2VuZXJhbGl6ZWQgZnJhY3Rpb25zIC0tIHRoZXNlIGFyZSBub3QgcmVuZGVyZWQgZGlyZWN0bHksIGJ1dCByZXBsYWNlZFxuLy8gaW1tZWRpYXRlbHkgYnkgb25lIG9mIHRoZSB2YXJpYW50cyBhYm92ZS5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJpbmZpeFwiLFxuICBuYW1lczogW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIiwgXCJcXFxcYnJhY2VcIiwgXCJcXFxcYnJhY2tcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSkge1xuICAgIGxldCByZXBsYWNlV2l0aDtcbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxjaG9vc2VcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxiaW5vbVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcYXRvcFwiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcYnJhY2VcIjpcbiAgICAgICAgcmVwbGFjZVdpdGggPSBcIlxcXFxcXFxcYnJhY2VmcmFjXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxicmFja1wiOlxuICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxicmFja2ZyYWNcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmZpeFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICByZXBsYWNlV2l0aCxcbiAgICAgIHRva2VuXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IGRlbGltRnJvbVZhbHVlID0gZnVuY3Rpb24oZGVsaW1TdHJpbmcpIHtcbiAgbGV0IGRlbGltID0gbnVsbDtcbiAgaWYgKGRlbGltU3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICBkZWxpbSA9IGRlbGltU3RyaW5nO1xuICAgIGRlbGltID0gZGVsaW0gPT09IFwiLlwiID8gbnVsbCA6IGRlbGltO1xuICB9XG4gIHJldHVybiBkZWxpbTtcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJnZW5mcmFjXCIsXG4gIG5hbWVzOiBbXCJcXFxcZ2VuZnJhY1wiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiA2LFxuICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJtYXRoXCIsIFwibWF0aFwiLCBcInNpemVcIiwgXCJ0ZXh0XCIsIFwibWF0aFwiLCBcIm1hdGhcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgY29uc3QgbnVtZXIgPSBhcmdzWzRdO1xuICAgIGNvbnN0IGRlbm9tID0gYXJnc1s1XTtcblxuICAgIC8vIExvb2sgaW50byB0aGUgcGFyc2Ugbm9kZXMgdG8gZ2V0IHRoZSBkZXNpcmVkIGRlbGltaXRlcnMuXG4gICAgY29uc3QgbGVmdE5vZGUgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTtcbiAgICBjb25zdCBsZWZ0RGVsaW0gPSBsZWZ0Tm9kZS50eXBlID09PSBcImF0b21cIiAmJiBsZWZ0Tm9kZS5mYW1pbHkgPT09IFwib3BlblwiXG4gICAgICA/IGRlbGltRnJvbVZhbHVlKGxlZnROb2RlLnRleHQpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgcmlnaHROb2RlID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1sxXSk7XG4gICAgY29uc3QgcmlnaHREZWxpbSA9XG4gICAgICByaWdodE5vZGUudHlwZSA9PT0gXCJhdG9tXCIgJiYgcmlnaHROb2RlLmZhbWlseSA9PT0gXCJjbG9zZVwiXG4gICAgICAgID8gZGVsaW1Gcm9tVmFsdWUocmlnaHROb2RlLnRleHQpXG4gICAgICAgIDogbnVsbDtcblxuICAgIGNvbnN0IGJhck5vZGUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzJdLCBcInNpemVcIik7XG4gICAgbGV0IGhhc0JhckxpbmU7XG4gICAgbGV0IGJhclNpemUgPSBudWxsO1xuICAgIGlmIChiYXJOb2RlLmlzQmxhbmspIHtcbiAgICAgIC8vIFxcZ2VuZnJhYyBhY3RzIGRpZmZlcmVudGx5IHRoYW4gXFxhYm92ZS5cbiAgICAgIC8vIFxcZ2VuZnJhYyB0cmVhdHMgYW4gZW1wdHkgc2l6ZSBncm91cCBhcyBhIHNpZ25hbCB0byB1c2UgYVxuICAgICAgLy8gc3RhbmRhcmQgYmFyIHNpemUuIFxcYWJvdmUgd291bGQgc2VlIHNpemUgPSAwIGFuZCBvbWl0IHRoZSBiYXIuXG4gICAgICBoYXNCYXJMaW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyU2l6ZSA9IGJhck5vZGUudmFsdWU7XG4gICAgICBoYXNCYXJMaW5lID0gYmFyU2l6ZS5udW1iZXIgPiAwO1xuICAgIH1cblxuICAgIC8vIEZpbmQgb3V0IGlmIHdlIHdhbnQgZGlzcGxheXN0eWxlLCB0ZXh0c3R5bGUsIGV0Yy5cbiAgICBsZXQgc2NyaXB0TGV2ZWwgPSBcImF1dG9cIjtcbiAgICBsZXQgc3R5bCA9IGFyZ3NbM107XG4gICAgaWYgKHN0eWwudHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICBpZiAoc3R5bC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdGV4dE9yZCA9IGFzc2VydE5vZGVUeXBlKHN0eWwuYm9keVswXSwgXCJ0ZXh0b3JkXCIpO1xuICAgICAgICBzY3JpcHRMZXZlbCA9IHN0eWxBcnJheVtOdW1iZXIodGV4dE9yZC50ZXh0KV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWwgPSBhc3NlcnROb2RlVHlwZShzdHlsLCBcInRleHRvcmRcIik7XG4gICAgICBzY3JpcHRMZXZlbCA9IHN0eWxBcnJheVtOdW1iZXIoc3R5bC50ZXh0KV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBudW1lcixcbiAgICAgIGRlbm9tLFxuICAgICAgY29udGludWVkOiBmYWxzZSxcbiAgICAgIGhhc0JhckxpbmUsXG4gICAgICBiYXJTaXplLFxuICAgICAgbGVmdERlbGltLFxuICAgICAgcmlnaHREZWxpbSxcbiAgICAgIHNjcmlwdExldmVsXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1XG59KTtcblxuLy8gXFxhYm92ZSBpcyBhbiBpbmZpeCBmcmFjdGlvbiB0aGF0IGFsc28gZGVmaW5lcyBhIGZyYWN0aW9uIGJhciBzaXplLlxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImluZml4XCIsXG4gIG5hbWVzOiBbXCJcXFxcYWJvdmVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXSxcbiAgICBpbmZpeDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSwgdG9rZW4gfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHJlcGxhY2VXaXRoOiBcIlxcXFxcXFxcYWJvdmVmcmFjXCIsXG4gICAgICBiYXJTaXplOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInNpemVcIikudmFsdWUsXG4gICAgICB0b2tlblxuICAgIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICBuYW1lczogW1wiXFxcXFxcXFxhYm92ZWZyYWNcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMyxcbiAgICBhcmdUeXBlczogW1wibWF0aFwiLCBcInNpemVcIiwgXCJtYXRoXCJdXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IG51bWVyID0gYXJnc1swXTtcbiAgICBjb25zdCBiYXJTaXplID0gYXNzZXJ0KGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sIFwiaW5maXhcIikuYmFyU2l6ZSk7XG4gICAgY29uc3QgZGVub20gPSBhcmdzWzJdO1xuXG4gICAgY29uc3QgaGFzQmFyTGluZSA9IGJhclNpemUubnVtYmVyID4gMDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJnZW5mcmFjXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIG51bWVyLFxuICAgICAgZGVub20sXG4gICAgICBjb250aW51ZWQ6IGZhbHNlLFxuICAgICAgaGFzQmFyTGluZSxcbiAgICAgIGJhclNpemUsXG4gICAgICBsZWZ0RGVsaW06IG51bGwsXG4gICAgICByaWdodERlbGltOiBudWxsLFxuICAgICAgc2NyaXB0TGV2ZWw6IFwiYXV0b1wiXG4gICAgfTtcbiAgfSxcblxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDVcbn0pO1xuXG4vLyBcXGhib3ggaXMgcHJvdmlkZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBMYVRlWCBmdW5jdGlvbnMgdGhhdCBhY3Qgb24gYSBib3guXG4vLyBUaGlzIGZ1bmN0aW9uIGJ5IGl0c2VsZiBkb2Vzbid0IGRvIGFueXRoaW5nIGJ1dCBzZXQgc2NyaXB0bGV2ZWwgdG8gXFx0ZXh0c3R5bGVcbi8vIGFuZCBwcmV2ZW50IGEgc29mdCBsaW5lIGJyZWFrLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaGJveFwiLFxuICBuYW1lczogW1wiXFxcXGhib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoYm94XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlLndpdGhMZXZlbChTdHlsZUxldmVsLlRFWFQpO1xuICAgIGNvbnN0IG1yb3cgPSBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgbmV3U3R5bGUpO1xuICAgIHJldHVybiBjb25zb2xpZGF0ZVRleHQobXJvdylcbiAgfVxufSk7XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIkNCA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgY29uc3QgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpO1xuICBhY2NlbnROb2RlLnN0eWxlW1wibWF0aC1kZXB0aFwiXSA9IDA7XG4gIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShncm91cC5pc092ZXIgPyBcIm1vdmVyXCIgOiBcIm11bmRlclwiLCBbXG4gICAgYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UsIHN0eWxlKSxcbiAgICBhY2NlbnROb2RlXG4gIF0pO1xufTtcblxuLy8gSG9yaXpvbnRhbCBzdHJldGNoeSBicmFjZXNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJob3JpekJyYWNlXCIsXG4gIG5hbWVzOiBbXCJcXFxcb3ZlcmJyYWNlXCIsIFwiXFxcXHVuZGVyYnJhY2VcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaG9yaXpCcmFjZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsYWJlbDogZnVuY05hbWUsXG4gICAgICBpc092ZXI6IC9eXFxcXG92ZXIvLnRlc3QoZnVuY05hbWUpLFxuICAgICAgYmFzZTogYXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNFxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJocmVmXCIsXG4gIG5hbWVzOiBbXCJcXFxcaHJlZlwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJ1cmxcIiwgXCJvcmlnaW5hbFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgdG9rZW4gfSwgYXJncykgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuICAgIGNvbnN0IGhyZWYgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCBcInVybFwiKS51cmw7XG5cbiAgICBpZiAoXG4gICAgICAhcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICAgIGNvbW1hbmQ6IFwiXFxcXGhyZWZcIixcbiAgICAgICAgdXJsOiBocmVmXG4gICAgICB9KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEZ1bmN0aW9uIFwiXFxcXGhyZWZcIiBpcyBub3QgdHJ1c3RlZGAsIHRva2VuKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhyZWZcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgaHJlZixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IG1hdGggPSBuZXcgTWF0aE5vZGUoXCJtYXRoXCIsIFtidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgc3R5bGUpXSk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IG5ldyBBbmNob3JOb2RlKGdyb3VwLmhyZWYsIFtdLCBbbWF0aF0pO1xuICAgIHJldHVybiBhbmNob3JOb2RlXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHJlZlwiLFxuICBuYW1lczogW1wiXFxcXHVybFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ1cmxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIHRva2VuIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBocmVmID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJ1cmxcIikudXJsO1xuXG4gICAgaWYgKFxuICAgICAgIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoe1xuICAgICAgICBjb21tYW5kOiBcIlxcXFx1cmxcIixcbiAgICAgICAgdXJsOiBocmVmXG4gICAgICB9KVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEZ1bmN0aW9uIFwiXFxcXHVybFwiIGlzIG5vdCB0cnVzdGVkYCwgdG9rZW4pXG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhyZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gaHJlZltpXTtcbiAgICAgIGlmIChjID09PSBcIn5cIikge1xuICAgICAgICBjID0gXCJcXFxcdGV4dGFzY2lpdGlsZGVcIjtcbiAgICAgIH1cbiAgICAgIGNoYXJzLnB1c2goe1xuICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgIHRleHQ6IGNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZvbnQ6IFwiXFxcXHRleHR0dFwiLFxuICAgICAgYm9keTogY2hhcnNcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhyZWZcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgaHJlZixcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJodG1sXCIsXG4gIG5hbWVzOiBbXCJcXFxcY2xhc3NcIiwgXCJcXFxcaWRcIiwgXCJcXFxcc3R5bGVcIiwgXCJcXFxcZGF0YVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJvcmlnaW5hbFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwicmF3XCIpLnN0cmluZztcbiAgICBjb25zdCBib2R5ID0gYXJnc1sxXTtcblxuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgRnVuY3Rpb24gXCIke2Z1bmNOYW1lfVwiIGlzIGRpc2FibGVkIGluIHN0cmljdCBtb2RlYCwgdG9rZW4pXG4gICAgfVxuXG4gICAgbGV0IHRydXN0Q29udGV4dDtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XG5cbiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7XG4gICAgICBjYXNlIFwiXFxcXGNsYXNzXCI6XG4gICAgICAgIGF0dHJpYnV0ZXMuY2xhc3MgPSB2YWx1ZTtcbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGNsYXNzXCIsXG4gICAgICAgICAgY2xhc3M6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlxcXFxpZFwiOlxuICAgICAgICBhdHRyaWJ1dGVzLmlkID0gdmFsdWU7XG4gICAgICAgIHRydXN0Q29udGV4dCA9IHtcbiAgICAgICAgICBjb21tYW5kOiBcIlxcXFxpZFwiLFxuICAgICAgICAgIGlkOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJcXFxcc3R5bGVcIjpcbiAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHZhbHVlO1xuICAgICAgICB0cnVzdENvbnRleHQgPSB7XG4gICAgICAgICAgY29tbWFuZDogXCJcXFxcc3R5bGVcIixcbiAgICAgICAgICBzdHlsZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiXFxcXGRhdGFcIjoge1xuICAgICAgICBjb25zdCBkYXRhID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXlWYWwgPSBkYXRhW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFcnJvciBwYXJzaW5nIGtleS12YWx1ZSBmb3IgXFxcXGRhdGFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJpYnV0ZXNbXCJkYXRhLVwiICsga2V5VmFsWzBdLnRyaW0oKV0gPSBrZXlWYWxbMV0udHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ1c3RDb250ZXh0ID0ge1xuICAgICAgICAgIGNvbW1hbmQ6IFwiXFxcXGRhdGFcIixcbiAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGh0bWwgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQodHJ1c3RDb250ZXh0KSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEZ1bmN0aW9uIFwiJHtmdW5jTmFtZX1cIiBpcyBub3QgdHJ1c3RlZGAsIHRva2VuKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJodG1sXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBzdHlsZSk7XG5cbiAgICBjb25zdCBjbGFzc2VzID0gW107XG4gICAgaWYgKGdyb3VwLmF0dHJpYnV0ZXMuY2xhc3MpIHtcbiAgICAgIGNsYXNzZXMucHVzaCguLi5ncm91cC5hdHRyaWJ1dGVzLmNsYXNzLnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc2VzID0gY2xhc3NlcztcblxuICAgIGZvciAoY29uc3QgYXR0ciBpbiBncm91cC5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoYXR0ciAhPT0gXCJjbGFzc1wiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChncm91cC5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCBncm91cC5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSk7XG5cbmNvbnN0IHNpemVEYXRhID0gZnVuY3Rpb24oc3RyKSB7XG4gIGlmICgvXlstK10/ICooXFxkKyhcXC5cXGQqKT98XFwuXFxkKykkLy50ZXN0KHN0cikpIHtcbiAgICAvLyBzdHIgaXMgYSBudW1iZXIgd2l0aCBubyB1bml0IHNwZWNpZmllZC5cbiAgICAvLyBkZWZhdWx0IHVuaXQgaXMgYnAsIHBlciBncmFwaGl4IHBhY2thZ2UuXG4gICAgcmV0dXJuIHsgbnVtYmVyOiArc3RyLCB1bml0OiBcImJwXCIgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoID0gLyhbLStdPykgKihcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspICooW2Etel17Mn0pLy5leGVjKHN0cik7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHNpemU6ICdcIiArIHN0ciArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzXCIpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgdW5pdDogbWF0Y2hbM11cbiAgICB9O1xuICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgdW5pdDogJ1wiICsgZGF0YS51bml0ICsgXCInIGluIFxcXFxpbmNsdWRlZ3JhcGhpY3MuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaW5jbHVkZWdyYXBoaWNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcaW5jbHVkZWdyYXBoaWNzXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIiwgXCJ1cmxcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCB0b2tlbiB9LCBhcmdzLCBvcHRBcmdzKSA9PiB7XG4gICAgbGV0IHdpZHRoID0geyBudW1iZXI6IDAsIHVuaXQ6IFwiZW1cIiB9O1xuICAgIGxldCBoZWlnaHQgPSB7IG51bWJlcjogMC45LCB1bml0OiBcImVtXCIgfTsgIC8vIHNvcnRhIGNoYXJhY3RlciBzaXplZC5cbiAgICBsZXQgdG90YWxoZWlnaHQgPSB7IG51bWJlcjogMCwgdW5pdDogXCJlbVwiIH07XG4gICAgbGV0IGFsdCA9IFwiXCI7XG5cbiAgICBpZiAob3B0QXJnc1swXSkge1xuICAgICAgY29uc3QgYXR0cmlidXRlU3RyID0gYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgXCJyYXdcIikuc3RyaW5nO1xuXG4gICAgICAvLyBQYXJzZXIuanMgZG9lcyBub3QgcGFyc2Uga2V5L3ZhbHVlIHBhaXJzLiBXZSBnZXQgYSBzdHJpbmcuXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gYXR0cmlidXRlU3RyLnNwbGl0KFwiLFwiKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXlWYWwgPSBhdHRyaWJ1dGVzW2ldLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgaWYgKGtleVZhbC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBjb25zdCBzdHIgPSBrZXlWYWxbMV0udHJpbSgpO1xuICAgICAgICAgIHN3aXRjaCAoa2V5VmFsWzBdLnRyaW0oKSkge1xuICAgICAgICAgICAgY2FzZSBcImFsdFwiOlxuICAgICAgICAgICAgICBhbHQgPSBzdHI7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIFwid2lkdGhcIjpcbiAgICAgICAgICAgICAgd2lkdGggPSBzaXplRGF0YShzdHIpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICAgICAgICBoZWlnaHQgPSBzaXplRGF0YShzdHIpO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBcInRvdGFsaGVpZ2h0XCI6XG4gICAgICAgICAgICAgIHRvdGFsaGVpZ2h0ID0gc2l6ZURhdGEoc3RyKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBrZXk6ICdcIiArIGtleVZhbFswXSArIFwiJyBpbiBcXFxcaW5jbHVkZWdyYXBoaWNzLlwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNyYyA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwidXJsXCIpLnVybDtcblxuICAgIGlmIChhbHQgPT09IFwiXCIpIHtcbiAgICAgIC8vIE5vIGFsdCBnaXZlbi4gVXNlIHRoZSBmaWxlIG5hbWUuIFN0cmlwIGF3YXkgdGhlIHBhdGguXG4gICAgICBhbHQgPSBzcmM7XG4gICAgICBhbHQgPSBhbHQucmVwbGFjZSgvXi4qW1xcXFwvXS8sIFwiXCIpO1xuICAgICAgYWx0ID0gYWx0LnN1YnN0cmluZygwLCBhbHQubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7XG4gICAgICAgIGNvbW1hbmQ6IFwiXFxcXGluY2x1ZGVncmFwaGljc1wiLFxuICAgICAgICB1cmw6IHNyY1xuICAgICAgfSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBGdW5jdGlvbiBcIlxcXFxpbmNsdWRlZ3JhcGhpY3NcIiBpcyBub3QgdHJ1c3RlZGAsIHRva2VuKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImluY2x1ZGVncmFwaGljc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBhbHQ6IGFsdCxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdG90YWxoZWlnaHQ6IHRvdGFsaGVpZ2h0LFxuICAgICAgc3JjOiBzcmNcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmhlaWdodCwgc3R5bGUpO1xuICAgIGNvbnN0IGRlcHRoID0geyBudW1iZXI6IDAsIHVuaXQ6IFwiZW1cIiB9O1xuXG4gICAgaWYgKGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciA+IDApIHtcbiAgICAgIGlmIChncm91cC50b3RhbGhlaWdodC51bml0ID09PSBoZWlnaHQudW5pdCAmJlxuICAgICAgICBncm91cC50b3RhbGhlaWdodC5udW1iZXIgPiBoZWlnaHQubnVtYmVyKSB7XG4gICAgICAgIGRlcHRoLm51bWJlciA9IGdyb3VwLnRvdGFsaGVpZ2h0Lm51bWJlciAtIGhlaWdodC5udW1iZXI7XG4gICAgICAgIGRlcHRoLnVuaXQgPSBoZWlnaHQudW5pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd2lkdGggPSAwO1xuICAgIGlmIChncm91cC53aWR0aC5udW1iZXIgPiAwKSB7XG4gICAgICB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIHN0eWxlKTtcbiAgICB9XG5cbiAgICBjb25zdCBncmFwaGljU3R5bGUgPSB7IGhlaWdodDogaGVpZ2h0Lm51bWJlciArIGRlcHRoLm51bWJlciArIFwiZW1cIiB9O1xuICAgIGlmICh3aWR0aC5udW1iZXIgPiAwKSB7XG4gICAgICBncmFwaGljU3R5bGUud2lkdGggPSB3aWR0aC5udW1iZXIgKyB3aWR0aC51bml0O1xuICAgIH1cbiAgICBpZiAoZGVwdGgubnVtYmVyID4gMCkge1xuICAgICAgZ3JhcGhpY1N0eWxlLnZlcnRpY2FsQWxpZ24gPSAtZGVwdGgubnVtYmVyICsgZGVwdGgudW5pdDtcbiAgICB9XG5cbiAgICBjb25zdCBub2RlID0gbmV3IEltZyhncm91cC5zcmMsIGdyb3VwLmFsdCwgZ3JhcGhpY1N0eWxlKTtcbiAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcbiAgICBub2RlLmRlcHRoID0gZGVwdGg7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW25vZGVdKVxuICB9XG59KTtcblxuLy8gSG9yaXpvbnRhbCBzcGFjaW5nIGNvbW1hbmRzXG5cblxuLy8gVE9ETzogXFxoc2tpcCBhbmQgXFxtc2tpcCBzaG91bGQgc3VwcG9ydCBwbHVzIGFuZCBtaW51cyBpbiBsZW5ndGhzXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJrZXJuXCIsXG4gIG5hbWVzOiBbXCJcXFxca2VyblwiLCBcIlxcXFxta2VyblwiLCBcIlxcXFxoc2tpcFwiLCBcIlxcXFxtc2tpcFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCJdLFxuICAgIHByaW1pdGl2ZTogdHJ1ZSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSB7XG4gICAgY29uc3Qgc2l6ZSA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKTtcbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCkge1xuICAgICAgY29uc3QgbWF0aEZ1bmN0aW9uID0gZnVuY05hbWVbMV0gPT09IFwibVwiOyAvLyBcXG1rZXJuLCBcXG1za2lwXG4gICAgICBjb25zdCBtdVVuaXQgPSBzaXplLnZhbHVlLnVuaXQgPT09IFwibXVcIjtcbiAgICAgIGlmIChtYXRoRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKCFtdVVuaXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgTGFUZVgncyAke2Z1bmNOYW1lfSBzdXBwb3J0cyBvbmx5IG11IHVuaXRzLCBgICtcbiAgICAgICAgICAgIGBub3QgJHtzaXplLnZhbHVlLnVuaXR9IHVuaXRzYCwgdG9rZW4pXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlci5tb2RlICE9PSBcIm1hdGhcIikge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBMYVRlWCdzICR7ZnVuY05hbWV9IHdvcmtzIG9ubHkgaW4gbWF0aCBtb2RlYCwgdG9rZW4pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICFtYXRoRnVuY3Rpb25cbiAgICAgICAgaWYgKG11VW5pdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBMYVRlWCdzICR7ZnVuY05hbWV9IGRvZXNuJ3Qgc3VwcG9ydCBtdSB1bml0c2AsIHRva2VuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImtlcm5cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZGltZW5zaW9uOiBzaXplLnZhbHVlXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBkaW1lbnNpb24gPSBjYWxjdWxhdGVTaXplKGdyb3VwLmRpbWVuc2lvbiwgc3R5bGUpO1xuICAgIGNvbnN0IGNoID0gZGltZW5zaW9uLnVuaXQgPT09IFwiZW1cIiA/IHNwYWNlQ2hhcmFjdGVyKGRpbWVuc2lvbi5udW1iZXIpIDogXCJcIjtcbiAgICBpZiAoZ3JvdXAubW9kZSA9PT0gXCJ0ZXh0XCIgJiYgY2gubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoY2gpO1xuICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW2NoYXJhY3Rlcl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGRpbWVuc2lvbi5udW1iZXIgKyBkaW1lbnNpb24udW5pdCk7XG4gICAgICBpZiAoZGltZW5zaW9uLm51bWJlciA8IDApIHtcbiAgICAgICAgbm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gZGltZW5zaW9uLm51bWJlciArIGRpbWVuc2lvbi51bml0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG59KTtcblxuY29uc3Qgc3BhY2VDaGFyYWN0ZXIgPSBmdW5jdGlvbih3aWR0aCkge1xuICBpZiAod2lkdGggPj0gMC4wNTU1NSAmJiB3aWR0aCA8PSAwLjA1NTU2KSB7XG4gICAgcmV0dXJuIFwiXFx1MjAwYVwiOyAvLyAmVmVyeVRoaW5TcGFjZTtcbiAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjE2NjYgJiYgd2lkdGggPD0gMC4xNjY3KSB7XG4gICAgcmV0dXJuIFwiXFx1MjAwOVwiOyAvLyAmVGhpblNwYWNlO1xuICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMjIyMiAmJiB3aWR0aCA8PSAwLjIyMjMpIHtcbiAgICByZXR1cm4gXCJcXHUyMDA1XCI7IC8vICZNZWRpdW1TcGFjZTtcbiAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjI3NzcgJiYgd2lkdGggPD0gMC4yNzc4KSB7XG4gICAgcmV0dXJuIFwiXFx1MjAwNVxcdTIwMGFcIjsgLy8gJlRoaWNrU3BhY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn07XG5cbi8vIExpbWl0IHZhbGlkIGNoYXJhY3RlcnMgdG8gYSBzbWFsbCBzZXQsIGZvciBzYWZldHkuXG5jb25zdCBpbnZhbGlkSWRSZWdFeCA9IC9bXkEtWmEtel8wLTktXS9nO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibGFiZWxcIixcbiAgbmFtZXM6IFtcIlxcXFxsYWJlbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJyYXdcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGFiZWxcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgc3RyaW5nOiBhcmdzWzBdLnN0cmluZy5yZXBsYWNlKGludmFsaWRJZFJlZ0V4LCBcIlwiKVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgLy8gUmV0dXJuIGEgbm8td2lkdGgsIG5vLWluayBlbGVtZW50IHdpdGggYW4gSFRNTCBpZC5cbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtdLCBbXCJ0bWwtbGFiZWxcIl0pO1xuICAgIGlmIChncm91cC5zdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZS5zZXRMYWJlbChncm91cC5zdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuLy8gSG9yaXpvbnRhbCBvdmVybGFwIGZ1bmN0aW9uc1xuXG5jb25zdCB0ZXh0TW9kZUxhcCA9IFtcIlxcXFxjbGFwXCIsIFwiXFxcXGxsYXBcIiwgXCJcXFxccmxhcFwiXTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImxhcFwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhsbGFwXCIsIFwiXFxcXG1hdGhybGFwXCIsIFwiXFxcXG1hdGhjbGFwXCIsIFwiXFxcXGNsYXBcIiwgXCJcXFxcbGxhcFwiLCBcIlxcXFxybGFwXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lLCB0b2tlbiB9LCBhcmdzKSA9PiB7XG4gICAgaWYgKHRleHRNb2RlTGFwLmluY2x1ZGVzKGZ1bmNOYW1lKSkge1xuICAgICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QgJiYgcGFyc2VyLm1vZGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGB7JHtmdW5jTmFtZX19IGNhbiBiZSB1c2VkIG9ubHkgaW4gdGV4dCBtb2RlLlxuIFRyeSBcXFxcbWF0aCR7ZnVuY05hbWUuc2xpY2UoMSl9YCwgdG9rZW4pXG4gICAgICB9XG4gICAgICBmdW5jTmFtZSA9IGZ1bmNOYW1lLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmdW5jTmFtZSA9IGZ1bmNOYW1lLnNsaWNlKDUpO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsYXBcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYWxpZ25tZW50OiBmdW5jTmFtZSxcbiAgICAgIGJvZHlcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICAvLyBtYXRobGxhcCwgbWF0aHJsYXAsIG1hdGhjbGFwXG4gICAgbGV0IHN0cnV0O1xuICAgIGlmIChncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiKSB7XG4gICAgICAvLyBXZSBuZWVkIGFuIGludmlzaWJsZSBzdHJ1dCB3aXRoIHRoZSBzYW1lIGRlcHRoIGFzIHRoZSBncm91cC5cbiAgICAgIC8vIFdlIGNhbid0IGp1c3QgcmVhZCB0aGUgZGVwdGgsIHNvIHdlIHVzZSBcXHZwaGFudG9tIG1ldGhvZHMuXG4gICAgICBjb25zdCBwaGFudG9tSW5uZXIgPSBidWlsZEV4cHJlc3Npb24ob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIHN0eWxlKTtcbiAgICAgIGNvbnN0IHBoYW50b20gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIHBoYW50b21Jbm5lcik7XG4gICAgICBzdHJ1dCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbcGhhbnRvbV0pO1xuICAgICAgc3RydXQuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwcHhcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpO1xuICAgIGxldCBub2RlO1xuICAgIGlmIChncm91cC5hbGlnbm1lbnQgPT09IFwibGxhcFwiKSB7XG4gICAgICBpbm5lci5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGlubmVyLnN0eWxlLnJpZ2h0ID0gXCIwXCI7XG4gICAgICBpbm5lci5zdHlsZS5ib3R0b20gPSBgMGA7IC8vIElmIHdlIGNvdWxkIGhhdmUgcmVhZCB0aGUgaW5rIGRlcHRoLCBpdCB3b3VsZCBnbyBoZXJlLlxuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbc3RydXQsIGlubmVyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2lubmVyXSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLmFsaWdubWVudCA9PT0gXCJybGFwXCIpIHtcbiAgICAgIGlmIChncm91cC5ib2R5LmJvZHkubGVuZ3RoID4gMCAmJiBncm91cC5ib2R5LmJvZHlbMF0udHlwZSA9PT0gXCJnZW5mcmFjXCIpIHtcbiAgICAgICAgLy8gSW4gRmlyZWZveCwgYSA8bXBhZGRlZD4gc3F1YXNoZXMgdGhlIDMvMThlbSBwYWRkaW5nIG9mIGEgY2hpbGQgXFxmcmFjLiBQdXQgaXQgYmFjay5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwLjE2NjY3ZW1cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGdyb3VwLmFsaWdubWVudCA9PT0gXCJsbGFwXCIgPyBcIi0xXCIgOiBcIi0wLjVcIjtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIG9mZnNldCArIFwid2lkdGhcIik7XG4gICAgICBpZiAoZ3JvdXAuYWxpZ25tZW50ID09PSBcImxsYXBcIikge1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICAgIG5vZGUuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcImNlbnRlclwiO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG4vLyBTd2l0Y2hpbmcgZnJvbSB0ZXh0IG1vZGUgYmFjayB0byBtYXRoIG1vZGVcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcmRncm91cFwiLFxuICBuYW1lczogW1wiXFxcXChcIiwgXCIkXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiBmYWxzZVxuICB9LFxuICBoYW5kbGVyKHsgZnVuY05hbWUsIHBhcnNlciB9LCBhcmdzKSB7XG4gICAgY29uc3Qgb3V0ZXJNb2RlID0gcGFyc2VyLm1vZGU7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUoXCJtYXRoXCIpO1xuICAgIGNvbnN0IGNsb3NlID0gZnVuY05hbWUgPT09IFwiXFxcXChcIiA/IFwiXFxcXClcIiA6IFwiJFwiO1xuICAgIGNvbnN0IGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBjbG9zZSk7XG4gICAgcGFyc2VyLmV4cGVjdChjbG9zZSk7XG4gICAgcGFyc2VyLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIENoZWNrIGZvciBleHRyYSBjbG9zaW5nIG1hdGggZGVsaW1pdGVyc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIiwgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLlxuICBuYW1lczogW1wiXFxcXClcIiwgXCJcXFxcXVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgYWxsb3dlZEluTWF0aDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcihjb250ZXh0LCB0b2tlbikge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBNaXNtYXRjaGVkICR7Y29udGV4dC5mdW5jTmFtZX1gLCB0b2tlbik7XG4gIH1cbn0pO1xuXG5jb25zdCBjaG9vc2VTdHlsZSA9IChncm91cCwgc3R5bGUpID0+IHtcbiAgc3dpdGNoIChzdHlsZS5sZXZlbCkge1xuICAgIGNhc2UgU3R5bGVMZXZlbC5ESVNQTEFZOiAgICAgICAvLyAwXG4gICAgICByZXR1cm4gZ3JvdXAuZGlzcGxheTtcbiAgICBjYXNlIFN0eWxlTGV2ZWwuVEVYVDogICAgICAgICAgLy8gMVxuICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7XG4gICAgY2FzZSBTdHlsZUxldmVsLlNDUklQVDogICAgICAgIC8vIDJcbiAgICAgIHJldHVybiBncm91cC5zY3JpcHQ7XG4gICAgY2FzZSBTdHlsZUxldmVsLlNDUklQVFNDUklQVDogIC8vIDNcbiAgICAgIHJldHVybiBncm91cC5zY3JpcHRzY3JpcHQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBncm91cC50ZXh0O1xuICB9XG59O1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWF0aGNob2ljZVwiLFxuICBuYW1lczogW1wiXFxcXG1hdGhjaG9pY2VcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogNCxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyIH0sIGFyZ3MpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtYXRoY2hvaWNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGRpc3BsYXk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pLFxuICAgICAgdGV4dDogb3JkYXJndW1lbnQoYXJnc1sxXSksXG4gICAgICBzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbMl0pLFxuICAgICAgc2NyaXB0c2NyaXB0OiBvcmRhcmd1bWVudChhcmdzWzNdKVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBib2R5ID0gY2hvb3NlU3R5bGUoZ3JvdXAsIHN0eWxlKTtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGJvZHksIHN0eWxlKTtcbiAgfVxufSk7XG5cbmNvbnN0IHRleHRBdG9tVHlwZXMgPSBbXCJ0ZXh0XCIsIFwidGV4dG9yZFwiLCBcIm1hdGhvcmRcIiwgXCJhdG9tXCJdO1xuXG5mdW5jdGlvbiBtYXRobWxCdWlsZGVyJDMoZ3JvdXAsIHN0eWxlKSB7XG4gIGxldCBub2RlO1xuICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSk7XG5cbiAgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgaW5uZXIpO1xuICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3JkXCIpIHtcbiAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3ggfHwgaW5uZXJbMF0udHlwZSA9PT0gXCJtYXRob3JkXCIpIHtcbiAgICAgIG5vZGUgPSBpbm5lclswXTtcbiAgICAgIG5vZGUudHlwZSA9IFwibWlcIjtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBub2RlLmNoaWxkcmVuWzBdLnRleHQgJiYgbm9kZS5jaGlsZHJlblswXS50ZXh0ID09PSBcIuKIh1wiKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJub3JtYWxcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIGlubmVyKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBpbm5lcik7XG4gICAgaWYgKGdyb3VwLm11c3RQcm9tb3RlKSB7XG4gICAgICBub2RlID0gaW5uZXJbMF07XG4gICAgICBub2RlLnR5cGUgPSBcIm1vXCI7XG4gICAgICBpZiAoZ3JvdXAuaXNDaGFyYWN0ZXJCb3ggJiYgZ3JvdXAuYm9keVswXS50ZXh0ICYmIC9bQS1aYS16XS8udGVzdChncm91cC5ib2R5WzBdLnRleHQpKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJpdGFsaWNcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgaW5uZXIpO1xuICAgIH1cblxuICAgIC8vIFNldCBzcGFjaW5nIGJhc2VkIG9uIHdoYXQgaXMgdGhlIG1vc3QgbGlrZWx5IGFkamFjZW50IGF0b20gdHlwZS5cbiAgICAvLyBTZWUgVGVYYm9vayBwMTcwLlxuICAgIGNvbnN0IGRvU3BhY2luZyA9IHN0eWxlLmxldmVsIDwgMjsgLy8gT3BlcmF0b3Igc3BhY2luZyBpcyB6ZXJvIGluc2lkZSBhIChzdWJ8c3VwZXIpc2NyaXB0LlxuICAgIGlmIChub2RlLnR5cGUgPT09IFwibXJvd1wiKSB7XG4gICAgICBpZiAoZG9TcGFjaW5nICkge1xuICAgICAgICBpZiAoZ3JvdXAubWNsYXNzID09PSBcIm1iaW5cIikge1xuICAgICAgICAgIC8vIG1lZGl1bSBzcGFjZVxuICAgICAgICAgIG5vZGUuY2hpbGRyZW4udW5zaGlmdChwYWRkaW5nJDEoMC4yMjIyKSk7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHBhZGRpbmckMSgwLjIyMjIpKTtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibXJlbFwiKSB7XG4gICAgICAgICAgLy8gdGhpY2tzcGFjZVxuICAgICAgICAgIG5vZGUuY2hpbGRyZW4udW5zaGlmdChwYWRkaW5nJDEoMC4yNzc4KSk7XG4gICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHBhZGRpbmckMSgwLjI3NzgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09IFwibXB1bmN0XCIpIHtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gocGFkZGluZyQxKDAuMTY2NykpO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIikge1xuICAgICAgICAgIG5vZGUuY2hpbGRyZW4udW5zaGlmdChwYWRkaW5nJDEoMC4wNTU2KSk7ICAvLyAxIG11IGlzIHRoZSBtb3N0IGxpa2VseSBvcHRpb25cbiAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2gocGFkZGluZyQxKDAuMDU1NikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChncm91cC5tY2xhc3MgPT09IFwibWJpblwiKSB7XG4gICAgICAgIC8vIG1lZGl1bSBzcGFjZVxuICAgICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4yMjIyZW1cIiA6IFwiMFwiKTtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IChkb1NwYWNpbmcgPyBcIjAuMjIyMmVtXCIgOiBcIjBcIik7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtcmVsXCIpIHtcbiAgICAgICAgLy8gdGhpY2tzcGFjZVxuICAgICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gKGRvU3BhY2luZyA/IFwiMC4yNzc4ZW1cIiA6IFwiMFwiKTtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IChkb1NwYWNpbmcgPyBcIjAuMjc3OGVtXCIgOiBcIjBcIik7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtcHVuY3RcIikge1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IChkb1NwYWNpbmcgPyBcIjAuMTY2N2VtXCIgOiBcIjBcIik7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtb3BlblwiIHx8IGdyb3VwLm1jbGFzcyA9PT0gXCJtY2xvc2VcIikge1xuICAgICAgICBub2RlLmF0dHJpYnV0ZXMubHNwYWNlID0gXCIwZW1cIjtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9IFwiMGVtXCI7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gXCJtaW5uZXJcIiAmJiBkb1NwYWNpbmcpIHtcbiAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4wNTU2ZW1cIjsgLy8gMSBtdSBpcyB0aGUgbW9zdCBsaWtlbHkgb3B0aW9uXG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy53aWR0aCA9IFwiKzAuMTExMWVtXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEoZ3JvdXAubWNsYXNzID09PSBcIm1vcGVuXCIgfHwgZ3JvdXAubWNsYXNzID09PSBcIm1jbG9zZVwiKSkge1xuICAgICAgZGVsZXRlIG5vZGUuYXR0cmlidXRlcy5zdHJldGNoeTtcbiAgICAgIGRlbGV0ZSBub2RlLmF0dHJpYnV0ZXMuZm9ybTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIE1hdGggY2xhc3MgY29tbWFuZHMgZXhjZXB0IFxcbWF0aG9wXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcbWF0aG9yZFwiLFxuICAgIFwiXFxcXG1hdGhiaW5cIixcbiAgICBcIlxcXFxtYXRocmVsXCIsXG4gICAgXCJcXFxcbWF0aG9wZW5cIixcbiAgICBcIlxcXFxtYXRoY2xvc2VcIixcbiAgICBcIlxcXFxtYXRocHVuY3RcIixcbiAgICBcIlxcXFxtYXRoaW5uZXJcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICBjb25zdCBpc0NoYXJhY3RlckJveCA9IHV0aWxzLmlzQ2hhcmFjdGVyQm94KGJvZHkpO1xuICAgIC8vIFdlIHNob3VsZCBub3Qgd3JhcCBhIDxtbz4gYXJvdW5kIGEgPG1pPiBvciA8bW9yZD4uIFRoYXQgd291bGQgYmUgaW52YWxpZCBNYXRoTUwuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBpbnN0ZWFkIHByb21vdGUgdGhlIHRleHQgY29udGVudHMgb2YgdGhlIGJvZHkgdG8gdGhlIHBhcmVudC5cbiAgICBsZXQgbXVzdFByb21vdGUgPSB0cnVlO1xuICAgIGNvbnN0IG1vcmQgPSB7IHR5cGU6IFwibWF0aG9yZFwiLCB0ZXh0OiBcIlwiLCBtb2RlOiBwYXJzZXIubW9kZSB9O1xuICAgIGNvbnN0IGFyciA9IChib2R5LmJvZHkpID8gYm9keS5ib2R5IDogW2JvZHldO1xuICAgIGZvciAoY29uc3QgYXJnIG9mIGFycikge1xuICAgICAgaWYgKHRleHRBdG9tVHlwZXMuaW5jbHVkZXMoYXJnLnR5cGUpKSB7XG4gICAgICAgIGlmIChzeW1ib2xzW3BhcnNlci5tb2RlXVthcmcudGV4dF0pIHtcbiAgICAgICAgICBtb3JkLnRleHQgKz0gc3ltYm9sc1twYXJzZXIubW9kZV1bYXJnLnRleHRdLnJlcGxhY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnLnRleHQpIHtcbiAgICAgICAgICBtb3JkLnRleHQgKz0gYXJnLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoYXJnLmJvZHkpIHtcbiAgICAgICAgICBhcmcuYm9keS5tYXAoZSA9PiB7IG1vcmQudGV4dCArPSBlLnRleHQ7IH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdXN0UHJvbW90ZSA9IGZhbHNlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobXVzdFByb21vdGUgJiYgZnVuY05hbWUgPT09IFwiXFxcXG1hdGhvcmRcIiAmJiBtb3JkLnR5cGUgPT09IFwibWF0aG9yZFwiXG4gICAgICAgICAgICAgICAgICAgICYmIG1vcmQudGV4dC5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gbW9yZFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgbWNsYXNzOiBcIm1cIiArIGZ1bmNOYW1lLnNsaWNlKDUpLFxuICAgICAgICBib2R5OiBvcmRhcmd1bWVudChtdXN0UHJvbW90ZSA/IG1vcmQgOiBib2R5KSxcbiAgICAgICAgaXNDaGFyYWN0ZXJCb3gsXG4gICAgICAgIG11c3RQcm9tb3RlXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQzXG59KTtcblxuY29uc3QgYmlucmVsQ2xhc3MgPSAoYXJnKSA9PiB7XG4gIC8vIFxcYmlucmVsQCBzcGFjaW5nIHZhcmllcyB3aXRoIChiaW58cmVsfG9yZCkgb2YgdGhlIGF0b20gaW4gdGhlIGFyZ3VtZW50LlxuICAvLyAoYnkgcmVuZGVyaW5nIHNlcGFyYXRlbHkgYW5kIHdpdGgge31zIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZCBtZWFzdXJpbmdcbiAgLy8gdGhlIGNoYW5nZSBpbiBzcGFjaW5nKS4gIFdlJ2xsIGRvIHJvdWdobHkgdGhlIHNhbWUgYnkgZGV0ZWN0aW5nIHRoZVxuICAvLyBhdG9tIHR5cGUgZGlyZWN0bHkuXG4gIGNvbnN0IGF0b20gPSBhcmcudHlwZSA9PT0gXCJvcmRncm91cFwiICYmIGFyZy5ib2R5Lmxlbmd0aCA/IGFyZy5ib2R5WzBdIDogYXJnO1xuICBpZiAoYXRvbS50eXBlID09PSBcImF0b21cIiAmJiAoYXRvbS5mYW1pbHkgPT09IFwiYmluXCIgfHwgYXRvbS5mYW1pbHkgPT09IFwicmVsXCIpKSB7XG4gICAgcmV0dXJuIFwibVwiICsgYXRvbS5mYW1pbHk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwibW9yZFwiO1xuICB9XG59O1xuXG4vLyBcXEBiaW5yZWx7eH17eX0gcmVuZGVycyBsaWtlIHkgYnV0IGFzIG1iaW4vbXJlbC9tb3JkIGlmIHggaXMgbWJpbi9tcmVsL21vcmQuXG4vLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gXFxiaW5yZWxAe3h9XFxiaW5yZWxAQHt5fSBpbiBBTVNUZVguXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwibWNsYXNzXCIsXG4gIG5hbWVzOiBbXCJcXFxcQGJpbnJlbFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAyXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm1jbGFzc1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBtY2xhc3M6IGJpbnJlbENsYXNzKGFyZ3NbMF0pLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1sxXSksXG4gICAgICBpc0NoYXJhY3RlckJveDogdXRpbHMuaXNDaGFyYWN0ZXJCb3goYXJnc1sxXSlcbiAgICB9O1xuICB9XG59KTtcblxuLy8gQnVpbGQgYSByZWxhdGlvbiBvciBzdGFja2VkIG9wIGJ5IHBsYWNpbmcgb25lIHN5bWJvbCBvbiB0b3Agb2YgYW5vdGhlclxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm1jbGFzc1wiLFxuICBuYW1lczogW1wiXFxcXHN0YWNrcmVsXCIsIFwiXFxcXG92ZXJzZXRcIiwgXCJcXFxcdW5kZXJzZXRcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMlxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYmFzZUFyZyA9IGFyZ3NbMV07XG4gICAgY29uc3Qgc2hpZnRlZEFyZyA9IGFyZ3NbMF07XG5cbiAgICBjb25zdCBiYXNlT3AgPSB7XG4gICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICBtb2RlOiBiYXNlQXJnLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IGZhbHNlLFxuICAgICAgc3RhY2s6IHRydWUsXG4gICAgICBzdXBwcmVzc0Jhc2VTaGlmdDogZnVuY05hbWUgIT09IFwiXFxcXHN0YWNrcmVsXCIsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChiYXNlQXJnKVxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdXBzdWJcIixcbiAgICAgIG1vZGU6IHNoaWZ0ZWRBcmcubW9kZSxcbiAgICAgIGJhc2U6IGJhc2VPcCxcbiAgICAgIHN1cDogZnVuY05hbWUgPT09IFwiXFxcXHVuZGVyc2V0XCIgPyBudWxsIDogc2hpZnRlZEFyZyxcbiAgICAgIHN1YjogZnVuY05hbWUgPT09IFwiXFxcXHVuZGVyc2V0XCIgPyBzaGlmdGVkQXJnIDogbnVsbFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkM1xufSk7XG5cbi8vIEhlbHBlciBmdW5jdGlvblxuY29uc3QgYnVpbGRHcm91cCA9IChlbCwgc3R5bGUsIG5vbmVOb2RlKSA9PiB7XG4gIGlmICghZWwpIHsgcmV0dXJuIG5vbmVOb2RlIH1cbiAgY29uc3Qgbm9kZSA9IGJ1aWxkR3JvdXAkMShlbCwgc3R5bGUpO1xuICBpZiAobm9kZS50eXBlID09PSBcIm1yb3dcIiAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbm9uZU5vZGUgfVxuICByZXR1cm4gbm9kZVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm11bHRpc2NyaXB0XCIsXG4gIG5hbWVzOiBbXCJcXFxcc2lkZXNldFwiLCBcIlxcXFxwcmVzQGNyaXB0XCJdLCAvLyBTZWUgbWFjcm9zLmpzIGZvciBcXHByZXNjcmlwdFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDNcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUsIHRva2VuIH0sIGFyZ3MpIHtcbiAgICBpZiAoYXJnc1syXS5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoZnVuY05hbWUgKyBgY2Fubm90IHBhcnNlIGFuIGVtcHR5IGJhc2UuYClcbiAgICB9XG4gICAgY29uc3QgYmFzZSA9IGFyZ3NbMl0uYm9keVswXTtcbiAgICBpZiAocGFyc2VyLnNldHRpbmdzLnN0cmljdCAmJiBmdW5jTmFtZSA9PT0gXCJcXFxcc2lkZXNldFwiICYmICFiYXNlLnN5bWJvbCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFRoZSBiYXNlIG9mIFxcXFxzaWRlc2V0IG11c3QgYmUgYSBiaWcgb3BlcmF0b3IuIFRyeSBcXFxccHJlc2NyaXB0LmApXG4gICAgfVxuXG4gICAgaWYgKChhcmdzWzBdLmJvZHkubGVuZ3RoID4gMCAmJiBhcmdzWzBdLmJvZHlbMF0udHlwZSAhPT0gXCJzdXBzdWJcIikgfHxcbiAgICAgICAgKGFyZ3NbMV0uYm9keS5sZW5ndGggPiAwICYmIGFyZ3NbMV0uYm9keVswXS50eXBlICE9PSBcInN1cHN1YlwiKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcc2lkZXNldCBjYW4gcGFyc2Ugb25seSBzdWJzY3JpcHRzIGFuZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdXBlcnNjcmlwdHMgaW4gaXRzIGZpcnN0IHR3byBhcmd1bWVudHNcIiwgdG9rZW4pXG4gICAgfVxuXG4gICAgLy8gVGhlIHByZXNjcmlwdHMgYW5kIHBvc3RzY3JpcHRzIGNvbWUgd3JhcHBlZCBpbiBhIHN1cHN1Yi5cbiAgICBjb25zdCBwcmVzY3JpcHRzID0gYXJnc1swXS5ib2R5Lmxlbmd0aCA+IDAgPyBhcmdzWzBdLmJvZHlbMF0gOiBudWxsO1xuICAgIGNvbnN0IHBvc3RzY3JpcHRzID0gYXJnc1sxXS5ib2R5Lmxlbmd0aCA+IDAgPyBhcmdzWzFdLmJvZHlbMF0gOiBudWxsO1xuXG4gICAgaWYgKCFwcmVzY3JpcHRzICYmICFwb3N0c2NyaXB0cykge1xuICAgICAgcmV0dXJuIGJhc2VcbiAgICB9IGVsc2UgaWYgKCFwcmVzY3JpcHRzKSB7XG4gICAgICAvLyBJdCdzIG5vdCBhIG11bHRpLXNjcmlwdC4gR2V0IGEgXFx0ZXh0c3R5bGUgc3Vwc3ViLlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgICBzY3JpcHRMZXZlbDogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IFt7XG4gICAgICAgICAgdHlwZTogXCJzdXBzdWJcIixcbiAgICAgICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgICAgICBiYXNlLFxuICAgICAgICAgIHN1cDogcG9zdHNjcmlwdHMuc3VwLFxuICAgICAgICAgIHN1YjogcG9zdHNjcmlwdHMuc3ViXG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibXVsdGlzY3JpcHRcIixcbiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAgIGlzU2lkZXNldDogZnVuY05hbWUgPT09IFwiXFxcXHNpZGVzZXRcIixcbiAgICAgICAgcHJlc2NyaXB0cyxcbiAgICAgICAgcG9zdHNjcmlwdHMsXG4gICAgICAgIGJhc2VcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgYmFzZSA9ICBidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgc3R5bGUpO1xuXG4gICAgY29uc3QgcHJlc2NyaXB0c05vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wcmVzY3JpcHRzXCIpO1xuICAgIGNvbnN0IG5vbmVOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJub25lXCIpO1xuICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuXG4gICAgY29uc3QgcHJlU3ViID0gYnVpbGRHcm91cChncm91cC5wcmVzY3JpcHRzLnN1Yiwgc3R5bGUsIG5vbmVOb2RlKTtcbiAgICBjb25zdCBwcmVTdXAgPSBidWlsZEdyb3VwKGdyb3VwLnByZXNjcmlwdHMuc3VwLCBzdHlsZSwgbm9uZU5vZGUpO1xuICAgIGlmIChncm91cC5pc1NpZGVzZXQpIHtcbiAgICAgIC8vIFRoaXMgc2VlbXMgc2lsbHksIGJ1dCBMYVRlWCBkb2VzIHRoaXMuIEZpcmVmb3ggaWdub3JlcyBpdCwgd2hpY2ggZG9lcyBub3QgbWFrZSBtZSBzYWQuXG4gICAgICBwcmVTdWIuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgXCJ0ZXh0LWFsaWduOiBsZWZ0O1wiKTtcbiAgICAgIHByZVN1cC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcInRleHQtYWxpZ246IGxlZnQ7XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC5wb3N0c2NyaXB0cykge1xuICAgICAgY29uc3QgcG9zdFN1YiA9IGJ1aWxkR3JvdXAoZ3JvdXAucG9zdHNjcmlwdHMuc3ViLCBzdHlsZSwgbm9uZU5vZGUpO1xuICAgICAgY29uc3QgcG9zdFN1cCA9IGJ1aWxkR3JvdXAoZ3JvdXAucG9zdHNjcmlwdHMuc3VwLCBzdHlsZSwgbm9uZU5vZGUpO1xuICAgICAgY2hpbGRyZW4gPSBbYmFzZSwgcG9zdFN1YiwgcG9zdFN1cCwgcHJlc2NyaXB0c05vZGUsIHByZVN1YiwgcHJlU3VwXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW4gPSBbYmFzZSwgcHJlc2NyaXB0c05vZGUsIHByZVN1YiwgcHJlU3VwXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtbXVsdGlzY3JpcHRzXCIsIGNoaWxkcmVuKTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJub3RcIixcbiAgbmFtZXM6IFtcIlxcXFxub3RcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogZmFsc2VcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzKSB7XG4gICAgY29uc3QgaXNDaGFyYWN0ZXJCb3ggPSB1dGlscy5pc0NoYXJhY3RlckJveChhcmdzWzBdKTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAoaXNDaGFyYWN0ZXJCb3gpIHtcbiAgICAgIGJvZHkgPSBvcmRhcmd1bWVudChhcmdzWzBdKTtcbiAgICAgIGlmIChib2R5WzBdLnRleHQuY2hhckF0KDApID09PSBcIlxcXFxcIikge1xuICAgICAgICBib2R5WzBdLnRleHQgPSBzeW1ib2xzLm1hdGhbYm9keVswXS50ZXh0XS5yZXBsYWNlO1xuICAgICAgfVxuICAgICAgLy8gXFx1MDMzOCBpcyB0aGUgVW5pY29kZSBDb21iaW5pbmcgTG9uZyBTb2xpZHVzIE92ZXJsYXlcbiAgICAgIGJvZHlbMF0udGV4dCA9IGJvZHlbMF0udGV4dC5zbGljZSgwLCAxKSArIFwiXFx1MDMzOFwiICsgYm9keVswXS50ZXh0LnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIHRoZSBhcmd1bWVudCBpcyBub3QgYSBjaGFyYWN0ZXIgYm94LCBUZVggZG9lcyBhbiBhd2t3YXJkLCBwb29ybHkgcGxhY2VkIG92ZXJsYXkuXG4gICAgICAvLyBXZSdsbCBkbyB0aGUgc2FtZS5cbiAgICAgIGNvbnN0IG5vdE5vZGUgPSB7IHR5cGU6IFwidGV4dG9yZFwiLCBtb2RlOiBcIm1hdGhcIiwgdGV4dDogXCJcXHUwMzM4XCIgfTtcbiAgICAgIGNvbnN0IGtlcm5Ob2RlID0geyB0eXBlOiBcImtlcm5cIiwgbW9kZTogXCJtYXRoXCIsIGRpbWVuc2lvbjogeyBudW1iZXI6IC0wLjYsIHVuaXQ6IFwiZW1cIiB9IH07XG4gICAgICBib2R5ID0gW25vdE5vZGUsIGtlcm5Ob2RlLCBhcmdzWzBdXTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibm90XCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBpc0NoYXJhY3RlckJveFxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgaWYgKGdyb3VwLmlzQ2hhcmFjdGVyQm94KSB7XG4gICAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gaW5uZXJbMF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBzdHlsZSlcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBMaW1pdHMsIHN5bWJvbHNcblxuLy8gU29tZSBoZWxwZXJzXG5cbmNvbnN0IG9yZEF0b21UeXBlcyA9IFtcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIFwiYXRvbVwiXTtcblxuLy8gTW9zdCBvcGVyYXRvcnMgaGF2ZSBhIGxhcmdlIHN1Y2Nlc3NvciBzeW1ib2wsIGJ1dCB0aGVzZSBkb24ndC5cbmNvbnN0IG5vU3VjY2Vzc29yID0gW1wiXFxcXHNtYWxsaW50XCJdO1xuXG4vLyBNYXRoIG9wZXJhdG9ycyAoZS5nLiBcXHNpbikgbmVlZCBhIHNwYWNlIGJldHdlZW4gdGhlc2UgdHlwZXMgYW5kIHRoZW1zZWx2ZXM6XG5jb25zdCBvcmRUeXBlcyA9IFtcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIFwib3JkZ3JvdXBcIiwgXCJjbG9zZVwiLCBcImxlZnRyaWdodFwiLCBcImZvbnRcIl07XG5cbi8vIE5PVEU6IFVubGlrZSBtb3N0IGBidWlsZGVyc2BzLCB0aGlzIG9uZSBoYW5kbGVzIG5vdCBvbmx5IFwib3BcIiwgYnV0IGFsc29cbi8vIFwic3Vwc3ViXCIgc2luY2Ugc29tZSBvZiB0aGVtIChsaWtlIFxcaW50KSBjYW4gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cblxuY29uc3Qgc2V0U3BhY2luZyA9IG5vZGUgPT4ge1xuICAvLyBUaGUgdXNlciB3cm90ZSBhIFxcbWF0aG9we+KApn0gZnVuY3Rpb24uIENoYW5nZSBzcGFjaW5nIGZyb20gZGVmYXVsdCB0byBPUCBzcGFjaW5nLlxuICAvLyBUaGUgbW9zdCBsaWtlbHkgc3BhY2luZyBmb3IgYW4gT1AgaXMgYSB0aGluIHNwYWNlIHBlciBUZVhib29rIHAxNzAuXG4gIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSBcIjAuMTY2N2VtXCI7XG4gIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMTY2N2VtXCI7XG59O1xuXG5jb25zdCBtYXRobWxCdWlsZGVyJDIgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGxldCBub2RlO1xuXG4gIGlmIChncm91cC5zeW1ib2wpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3ltYm9sLiBKdXN0IGFkZCB0aGUgc3ltYm9sLlxuICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAubmFtZSwgZ3JvdXAubW9kZSldKTtcbiAgICBpZiAobm9TdWNjZXNzb3IuaW5jbHVkZXMoZ3JvdXAubmFtZSkpIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGFyZ2VvcFwiLCBcImZhbHNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1vdmFibGVsaW1pdHNcIiwgXCJmYWxzZVwiKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLmZyb21NYXRoT3ApIHsgc2V0U3BhY2luZyhub2RlKTsgfVxuICB9IGVsc2UgaWYgKGdyb3VwLmJvZHkpIHtcbiAgICAvLyBUaGlzIGlzIGFuIG9wZXJhdG9yIHdpdGggY2hpbGRyZW4uIEFkZCB0aGVtLlxuICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtb1wiLCBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUpKTtcbiAgICBpZiAoZ3JvdXAuZnJvbU1hdGhPcCkgeyBzZXRTcGFjaW5nKG5vZGUpOyB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHRleHQgb3BlcmF0b3IuIEFkZCBhbGwgb2YgdGhlIGNoYXJhY3RlcnMgZnJvbSB0aGUgb3BlcmF0b3IncyBuYW1lLlxuICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtaVwiLCBbbmV3IFRleHROb2RlKGdyb3VwLm5hbWUuc2xpY2UoMSkpXSk7XG5cbiAgICBpZiAoIWdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgICAvLyBBcHBlbmQgYW4gaW52aXNpYmxlIDxtbz4mQXBwbHlGdW5jdGlvbjs8L21vPi5cbiAgICAgIC8vIHJlZjogaHR0cHM6Ly93d3cudzMub3JnL1RSL1JFQy1NYXRoTUwvY2hhcDNfMi5odG1sI3NlYzMuMi40XG4gICAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBNYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG4gICAgICBjb25zdCByb3cgPSBbbm9kZSwgb3BlcmF0b3JdO1xuICAgICAgLy8gU2V0IHNwYWNpbmdcbiAgICAgIGlmIChncm91cC5uZWVkc0xlYWRpbmdTcGFjZSkge1xuICAgICAgICBjb25zdCBsZWFkID0gbmV3IE1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgICBsZWFkLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4xNjY3ZW1cIik7IC8vIHRoaW4gc3BhY2UuXG4gICAgICAgIHJvdy51bnNoaWZ0KGxlYWQpO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cC5pc0ZvbGxvd2VkQnlEZWxpbWl0ZXIpIHtcbiAgICAgICAgY29uc3QgdHJhaWwgPSBuZXcgTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIHRyYWlsLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4xNjY3ZW1cIik7IC8vIHRoaW4gc3BhY2UuXG4gICAgICAgIHJvdy5wdXNoKHRyYWlsKTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBuZXcgTWF0aE5vZGUoXCJtcm93XCIsIHJvdyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5jb25zdCBzaW5nbGVDaGFyQmlnT3BzID0ge1xuICBcIlxcdTIyMEZcIjogXCJcXFxccHJvZFwiLFxuICBcIlxcdTIyMTBcIjogXCJcXFxcY29wcm9kXCIsXG4gIFwiXFx1MjIxMVwiOiBcIlxcXFxzdW1cIixcbiAgXCJcXHUyMmMwXCI6IFwiXFxcXGJpZ3dlZGdlXCIsXG4gIFwiXFx1MjJjMVwiOiBcIlxcXFxiaWd2ZWVcIixcbiAgXCJcXHUyMmMyXCI6IFwiXFxcXGJpZ2NhcFwiLFxuICBcIlxcdTIyYzNcIjogXCJcXFxcYmlnY3VwXCIsXG4gIFwiXFx1MmEwMFwiOiBcIlxcXFxiaWdvZG90XCIsXG4gIFwiXFx1MmEwMVwiOiBcIlxcXFxiaWdvcGx1c1wiLFxuICBcIlxcdTJhMDJcIjogXCJcXFxcYmlnb3RpbWVzXCIsXG4gIFwiXFx1MmEwNFwiOiBcIlxcXFxiaWd1cGx1c1wiLFxuICBcIlxcdTJhMDVcIjogXCJcXFxcYmlnc3FjYXBcIixcbiAgXCJcXHUyYTA2XCI6IFwiXFxcXGJpZ3NxY3VwXCIsXG4gIFwiXFx1MmEwM1wiOiBcIlxcXFxiaWdjdXBkb3RcIixcbiAgXCJcXHUyYTA3XCI6IFwiXFxcXGJpZ2RvdWJsZXZlZVwiLFxuICBcIlxcdTJhMDhcIjogXCJcXFxcYmlnZG91Ymxld2VkZ2VcIixcbiAgXCJcXHUyYTA5XCI6IFwiXFxcXGJpZ3RpbWVzXCJcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1xuICAgIFwiXFxcXGNvcHJvZFwiLFxuICAgIFwiXFxcXGJpZ3ZlZVwiLFxuICAgIFwiXFxcXGJpZ3dlZGdlXCIsXG4gICAgXCJcXFxcYmlndXBsdXNcIixcbiAgICBcIlxcXFxiaWdjdXBwbHVzXCIsXG4gICAgXCJcXFxcYmlnY3VwZG90XCIsXG4gICAgXCJcXFxcYmlnY2FwXCIsXG4gICAgXCJcXFxcYmlnY3VwXCIsXG4gICAgXCJcXFxcYmlnZG91YmxldmVlXCIsXG4gICAgXCJcXFxcYmlnZG91Ymxld2VkZ2VcIixcbiAgICBcIlxcXFxpbnRvcFwiLFxuICAgIFwiXFxcXHByb2RcIixcbiAgICBcIlxcXFxzdW1cIixcbiAgICBcIlxcXFxiaWdvdGltZXNcIixcbiAgICBcIlxcXFxiaWdvcGx1c1wiLFxuICAgIFwiXFxcXGJpZ29kb3RcIixcbiAgICBcIlxcXFxiaWdzcWNhcFwiLFxuICAgIFwiXFxcXGJpZ3NxY3VwXCIsXG4gICAgXCJcXFxcYmlndGltZXNcIixcbiAgICBcIlxcXFxzbWFsbGludFwiLFxuICAgIFwiXFx1MjIwRlwiLFxuICAgIFwiXFx1MjIxMFwiLFxuICAgIFwiXFx1MjIxMVwiLFxuICAgIFwiXFx1MjJjMFwiLFxuICAgIFwiXFx1MjJjMVwiLFxuICAgIFwiXFx1MjJjMlwiLFxuICAgIFwiXFx1MjJjM1wiLFxuICAgIFwiXFx1MmEwMFwiLFxuICAgIFwiXFx1MmEwMVwiLFxuICAgIFwiXFx1MmEwMlwiLFxuICAgIFwiXFx1MmEwNFwiLFxuICAgIFwiXFx1MmEwNlwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMFxuICB9LFxuICBoYW5kbGVyOiAoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpID0+IHtcbiAgICBsZXQgZk5hbWUgPSBmdW5jTmFtZTtcbiAgICBpZiAoZk5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBmTmFtZSA9IHNpbmdsZUNoYXJCaWdPcHNbZk5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IHRydWUsXG4gICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsXG4gICAgICBzeW1ib2w6IHRydWUsXG4gICAgICBzdGFjazogZmFsc2UsIC8vIFRoaXMgaXMgdHJ1ZSBmb3IgXFxzdGFja3JlbHt9LCBub3QgaGVyZS5cbiAgICAgIG5hbWU6IGZOYW1lXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQyXG59KTtcblxuLy8gTm90ZTogY2FsbGluZyBkZWZpbmVGdW5jdGlvbiB3aXRoIGEgdHlwZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGRlZmluZWQgb25seVxuLy8gd29ya3MgYmVjYXVzZSB0aGUgc2FtZSBtYXRobWxCdWlsZGVyIGlzIGJlaW5nIHVzZWQuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcIlxcXFxtYXRob3BcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICAvLyBJdCB3b3VsZCBiZSBjb252aWVuaWVudCB0byBqdXN0IHdyYXAgYSA8bW8+IGFyb3VuZCB0aGUgYXJndW1lbnQuXG4gICAgLy8gQnV0IGlmIHRoZSBhcmd1bWVudCBpcyBhIDxtaT4gb3IgPG1vcmQ+LCB0aGF0IHdvdWxkIGJlIGludmFsaWQgTWF0aE1MLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgaW5zdGVhZCBwcm9tb3RlIHRoZSB0ZXh0IGNvbnRlbnRzIG9mIHRoZSBib2R5IHRvIHRoZSBwYXJlbnQuXG4gICAgY29uc3QgYXJyID0gKGJvZHkuYm9keSkgPyBib2R5LmJvZHkgOiBbYm9keV07XG4gICAgY29uc3QgaXNTeW1ib2wgPSBhcnIubGVuZ3RoID09PSAxICYmIG9yZEF0b21UeXBlcy5pbmNsdWRlcyhhcnJbMF0udHlwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBpc1N5bWJvbCxcbiAgICAgIGZyb21NYXRoT3A6IHRydWUsXG4gICAgICBzdGFjazogZmFsc2UsXG4gICAgICBuYW1lOiBpc1N5bWJvbCA/IGFyclswXS50ZXh0IDogbnVsbCxcbiAgICAgIGJvZHk6IGlzU3ltYm9sID8gbnVsbCA6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQyXG59KTtcblxuLy8gVGhlcmUgYXJlIDIgZmxhZ3MgZm9yIG9wZXJhdG9yczsgd2hldGhlciB0aGV5IHByb2R1Y2UgbGltaXRzIGluXG4vLyBkaXNwbGF5c3R5bGUsIGFuZCB3aGV0aGVyIHRoZXkgYXJlIHN5bWJvbHMgYW5kIHNob3VsZCBncm93IGluXG4vLyBkaXNwbGF5c3R5bGUuIFRoZXNlIGZvdXIgZ3JvdXBzIGNvdmVyIHRoZSBmb3VyIHBvc3NpYmxlIGNob2ljZXMuXG5cbmNvbnN0IHNpbmdsZUNoYXJJbnRlZ3JhbHMgPSB7XG4gIFwiXFx1MjIyYlwiOiBcIlxcXFxpbnRcIixcbiAgXCJcXHUyMjJjXCI6IFwiXFxcXGlpbnRcIixcbiAgXCJcXHUyMjJkXCI6IFwiXFxcXGlpaW50XCIsXG4gIFwiXFx1MjIyZVwiOiBcIlxcXFxvaW50XCIsXG4gIFwiXFx1MjIyZlwiOiBcIlxcXFxvaWludFwiLFxuICBcIlxcdTIyMzBcIjogXCJcXFxcb2lpaW50XCIsXG4gIFwiXFx1MjIzMVwiOiBcIlxcXFxpbnRjbG9ja3dpc2VcIixcbiAgXCJcXHUyMjMyXCI6IFwiXFxcXHZhcm9pbnRjbG9ja3dpc2VcIixcbiAgXCJcXHUyYTBjXCI6IFwiXFxcXGlpaWludFwiLFxuICBcIlxcdTJhMGRcIjogXCJcXFxcaW50YmFyXCIsXG4gIFwiXFx1MmEwZVwiOiBcIlxcXFxpbnRCYXJcIixcbiAgXCJcXHUyYTBmXCI6IFwiXFxcXGZpbnRcIixcbiAgXCJcXHUyYTEyXCI6IFwiXFxcXHJwcG9saW50XCIsXG4gIFwiXFx1MmExM1wiOiBcIlxcXFxzY3BvbGludFwiLFxuICBcIlxcdTJhMTVcIjogXCJcXFxccG9pbnRpbnRcIixcbiAgXCJcXHUyYTE2XCI6IFwiXFxcXHNxaW50XCIsXG4gIFwiXFx1MmExN1wiOiBcIlxcXFxpbnRsYXJoa1wiLFxuICBcIlxcdTJhMThcIjogXCJcXFxcaW50eFwiLFxuICBcIlxcdTJhMTlcIjogXCJcXFxcaW50Y2FwXCIsXG4gIFwiXFx1MmExYVwiOiBcIlxcXFxpbnRjdXBcIlxufTtcblxuLy8gTm8gbGltaXRzLCBub3Qgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcIm9wXCIsXG4gIG5hbWVzOiBbXG4gICAgXCJcXFxcYXJjc2luXCIsXG4gICAgXCJcXFxcYXJjY29zXCIsXG4gICAgXCJcXFxcYXJjdGFuXCIsXG4gICAgXCJcXFxcYXJjdGdcIixcbiAgICBcIlxcXFxhcmNjdGdcIixcbiAgICBcIlxcXFxhcmdcIixcbiAgICBcIlxcXFxjaFwiLFxuICAgIFwiXFxcXGNvc1wiLFxuICAgIFwiXFxcXGNvc2VjXCIsXG4gICAgXCJcXFxcY29zaFwiLFxuICAgIFwiXFxcXGNvdFwiLFxuICAgIFwiXFxcXGNvdGdcIixcbiAgICBcIlxcXFxjb3RoXCIsXG4gICAgXCJcXFxcY3NjXCIsXG4gICAgXCJcXFxcY3RnXCIsXG4gICAgXCJcXFxcY3RoXCIsXG4gICAgXCJcXFxcZGVnXCIsXG4gICAgXCJcXFxcZGltXCIsXG4gICAgXCJcXFxcZXhwXCIsXG4gICAgXCJcXFxcaG9tXCIsXG4gICAgXCJcXFxca2VyXCIsXG4gICAgXCJcXFxcbGdcIixcbiAgICBcIlxcXFxsblwiLFxuICAgIFwiXFxcXGxvZ1wiLFxuICAgIFwiXFxcXHNlY1wiLFxuICAgIFwiXFxcXHNpblwiLFxuICAgIFwiXFxcXHNpbmhcIixcbiAgICBcIlxcXFxzaFwiLFxuICAgIFwiXFxcXHNnblwiLFxuICAgIFwiXFxcXHRhblwiLFxuICAgIFwiXFxcXHRhbmhcIixcbiAgICBcIlxcXFx0Z1wiLFxuICAgIFwiXFxcXHRoXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBjb25zdCBwcmV2QXRvbVR5cGUgPSBwYXJzZXIucHJldkF0b21UeXBlO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICBzdGFjazogZmFsc2UsXG4gICAgICBpc0ZvbGxvd2VkQnlEZWxpbWl0ZXI6IGlzRGVsaW1pdGVyKG5leHQpLFxuICAgICAgbmVlZHNMZWFkaW5nU3BhY2U6IHByZXZBdG9tVHlwZS5sZW5ndGggPiAwICYmIG9yZFR5cGVzLmluY2x1ZGVzKHByZXZBdG9tVHlwZSksXG4gICAgICBuYW1lOiBmdW5jTmFtZVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMlxufSk7XG5cbi8vIExpbWl0cywgbm90IHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJvcFwiLFxuICBuYW1lczogW1wiXFxcXGRldFwiLCBcIlxcXFxnY2RcIiwgXCJcXFxcaW5mXCIsIFwiXFxcXGxpbVwiLCBcIlxcXFxtYXhcIiwgXCJcXFxcbWluXCIsIFwiXFxcXFByXCIsIFwiXFxcXHN1cFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBjb25zdCBwcmV2QXRvbVR5cGUgPSBwYXJzZXIucHJldkF0b21UeXBlO1xuICAgIGNvbnN0IG5leHQgPSBwYXJzZXIuZ3VsbGV0LmZ1dHVyZSgpLnRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiBmYWxzZSxcbiAgICAgIHN0YWNrOiBmYWxzZSxcbiAgICAgIGlzRm9sbG93ZWRCeURlbGltaXRlcjogaXNEZWxpbWl0ZXIobmV4dCksXG4gICAgICBuZWVkc0xlYWRpbmdTcGFjZTogcHJldkF0b21UeXBlLmxlbmd0aCA+IDAgJiYgb3JkVHlwZXMuaW5jbHVkZXMocHJldkF0b21UeXBlKSxcbiAgICAgIG5hbWU6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQyXG59KTtcblxuLy8gTm8gbGltaXRzLCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFxpbnRcIixcbiAgICBcIlxcXFxpaW50XCIsXG4gICAgXCJcXFxcaWlpbnRcIixcbiAgICBcIlxcXFxpaWlpbnRcIixcbiAgICBcIlxcXFxvaW50XCIsXG4gICAgXCJcXFxcb2lpbnRcIixcbiAgICBcIlxcXFxvaWlpbnRcIixcbiAgICBcIlxcXFxpbnRjbG9ja3dpc2VcIixcbiAgICBcIlxcXFx2YXJvaW50Y2xvY2t3aXNlXCIsXG4gICAgXCJcXFxcaW50YmFyXCIsXG4gICAgXCJcXFxcaW50QmFyXCIsXG4gICAgXCJcXFxcZmludFwiLFxuICAgIFwiXFxcXHJwcG9saW50XCIsXG4gICAgXCJcXFxcc2Nwb2xpbnRcIixcbiAgICBcIlxcXFxwb2ludGludFwiLFxuICAgIFwiXFxcXHNxaW50XCIsXG4gICAgXCJcXFxcaW50bGFyaGtcIixcbiAgICBcIlxcXFxpbnR4XCIsXG4gICAgXCJcXFxcaW50Y2FwXCIsXG4gICAgXCJcXFxcaW50Y3VwXCIsXG4gICAgXCJcXHUyMjJiXCIsXG4gICAgXCJcXHUyMjJjXCIsXG4gICAgXCJcXHUyMjJkXCIsXG4gICAgXCJcXHUyMjJlXCIsXG4gICAgXCJcXHUyMjJmXCIsXG4gICAgXCJcXHUyMjMwXCIsXG4gICAgXCJcXHUyMjMxXCIsXG4gICAgXCJcXHUyMjMyXCIsXG4gICAgXCJcXHUyYTBjXCIsXG4gICAgXCJcXHUyYTBkXCIsXG4gICAgXCJcXHUyYTBlXCIsXG4gICAgXCJcXHUyYTBmXCIsXG4gICAgXCJcXHUyYTEyXCIsXG4gICAgXCJcXHUyYTEzXCIsXG4gICAgXCJcXHUyYTE1XCIsXG4gICAgXCJcXHUyYTE2XCIsXG4gICAgXCJcXHUyYTE3XCIsXG4gICAgXCJcXHUyYTE4XCIsXG4gICAgXCJcXHUyYTE5XCIsXG4gICAgXCJcXHUyYTFhXCJcbiAgXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0pIHtcbiAgICBsZXQgZk5hbWUgPSBmdW5jTmFtZTtcbiAgICBpZiAoZk5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICBmTmFtZSA9IHNpbmdsZUNoYXJJbnRlZ3JhbHNbZk5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBsaW1pdHM6IGZhbHNlLFxuICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLFxuICAgICAgc3ltYm9sOiB0cnVlLFxuICAgICAgc3RhY2s6IGZhbHNlLFxuICAgICAgbmFtZTogZk5hbWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDJcbn0pO1xuXG4vLyBOT1RFOiBVbmxpa2UgbW9zdCBidWlsZGVycywgdGhpcyBvbmUgaGFuZGxlcyBub3Qgb25seVxuLy8gXCJvcGVyYXRvcm5hbWVcIiwgYnV0IGFsc28gIFwic3Vwc3ViXCIgc2luY2UgXFxvcGVyYXRvcm5hbWUqIGNhblxuLy8gYWZmZWN0IHN1cGVyL3N1YnNjcmlwdGluZy5cblxuY29uc3QgbWF0aG1sQnVpbGRlciQxID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBsZXQgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC5ib2R5LCBzdHlsZS53aXRoRm9udChcIm1hdGhybVwiKSk7XG5cbiAgLy8gSXMgZXhwcmVzc2lvbiBhIHN0cmluZyBvciBoYXMgaXQgc29tZXRoaW5nIGxpa2UgYSBmcmFjdGlvbj9cbiAgbGV0IGlzQWxsU3RyaW5nID0gdHJ1ZTsgLy8gZGVmYXVsdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbm9kZSA9IGV4cHJlc3Npb25baV07XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLk1hdGhOb2RlKSB7XG4gICAgICBpZiAoKG5vZGUudHlwZSA9PT0gXCJtcm93XCIgfHwgbm9kZS50eXBlID09PSBcIm1wYWRkZWRcIikgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICBub2RlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5NYXRoTm9kZSkge1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJtaVwiOlxuICAgICAgICBjYXNlIFwibW5cIjpcbiAgICAgICAgY2FzZSBcIm1zXCI6XG4gICAgICAgIGNhc2UgXCJtdGV4dFwiOlxuICAgICAgICAgIGJyZWFrOyAvLyBEbyBub3RoaW5nIHlldC5cbiAgICAgICAgY2FzZSBcIm1zcGFjZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChub2RlLmF0dHJpYnV0ZXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBub2RlLmF0dHJpYnV0ZXMud2lkdGgucmVwbGFjZShcImVtXCIsIFwiXCIpO1xuICAgICAgICAgICAgICBjb25zdCBjaCA9IHNwYWNlQ2hhcmFjdGVyKE51bWJlcih3aWR0aCkpO1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cHJlc3Npb25baV0gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10ZXh0XCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShjaCldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIFwibW9cIjoge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgY2hpbGQgaW5zdGFuY2VvZiBtYXRoTUxUcmVlLlRleHROb2RlKSB7XG4gICAgICAgICAgICBjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9cXHUyMjEyLywgXCItXCIpLnJlcGxhY2UoL1xcdTIyMTcvLCBcIipcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzQWxsU3RyaW5nID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpc0FsbFN0cmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0FsbFN0cmluZykge1xuICAgIC8vIFdyaXRlIGEgc2luZ2xlIFRleHROb2RlIGluc3RlYWQgb2YgbXVsdGlwbGUgbmVzdGVkIHRhZ3MuXG4gICAgY29uc3Qgd29yZCA9IGV4cHJlc3Npb24ubWFwKChub2RlKSA9PiBub2RlLnRvVGV4dCgpKS5qb2luKFwiXCIpO1xuICAgIGV4cHJlc3Npb24gPSBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUod29yZCldO1xuICB9IGVsc2UgaWYgKFxuICAgIGV4cHJlc3Npb24ubGVuZ3RoID09PSAxXG4gICAgJiYgW1wibW92ZXJcIiwgXCJtdW5kZXJcIl0uaW5jbHVkZXMoZXhwcmVzc2lvblswXS50eXBlKSAmJlxuICAgIChleHByZXNzaW9uWzBdLmNoaWxkcmVuWzBdLnR5cGUgPT09IFwibWlcIiB8fCBleHByZXNzaW9uWzBdLmNoaWxkcmVuWzBdLnR5cGUgPT09IFwibXRleHRcIilcbiAgKSB7XG4gICAgZXhwcmVzc2lvblswXS5jaGlsZHJlblswXS50eXBlID0gXCJtaVwiO1xuICAgIGlmIChncm91cC5wYXJlbnRJc1N1cFN1Yikge1xuICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KFwiXFx1MjA2MVwiLCBcInRleHRcIildKTtcbiAgICAgIHJldHVybiBtYXRoTUxUcmVlLm5ld0RvY3VtZW50RnJhZ21lbnQoW2V4cHJlc3Npb25bMF0sIG9wZXJhdG9yXSlcbiAgICB9XG4gIH1cblxuICBsZXQgd3JhcHBlcjtcbiAgaWYgKGlzQWxsU3RyaW5nKSB7XG4gICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgZXhwcmVzc2lvbik7XG4gICAgaWYgKGV4cHJlc3Npb25bMF0udGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJub3JtYWxcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgZXhwcmVzc2lvbik7XG4gIH1cblxuICBpZiAoIWdyb3VwLnBhcmVudElzU3VwU3ViKSB7XG4gICAgLy8gQXBwZW5kIGFuIDxtbz4mQXBwbHlGdW5jdGlvbjs8L21vPi5cbiAgICAvLyByZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMtTWF0aE1ML2NoYXAzXzIuaHRtbCNzZWMzLjIuNFxuICAgIGNvbnN0IG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBbbWFrZVRleHQoXCJcXHUyMDYxXCIsIFwidGV4dFwiKV0pO1xuICAgIGNvbnN0IGZyYWdtZW50ID0gW3dyYXBwZXIsIG9wZXJhdG9yXTtcbiAgICBpZiAoZ3JvdXAubmVlZHNMZWFkaW5nU3BhY2UpIHtcbiAgICAgIC8vIExhVGVYIGdpdmVzIG9wZXJhdG9yIHNwYWNpbmcsIGJ1dCBhIDxtaT4gZ2V0cyBvcmQgc3BhY2luZy5cbiAgICAgIC8vIFNvIGFkZCBhIGxlYWRpbmcgc3BhY2UuXG4gICAgICBjb25zdCBzcGFjZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNwYWNlXCIpO1xuICAgICAgc3BhY2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgIGZyYWdtZW50LnVuc2hpZnQoc3BhY2UpO1xuICAgIH1cbiAgICBpZiAoIWdyb3VwLmlzRm9sbG93ZWRCeURlbGltaXRlcikge1xuICAgICAgY29uc3QgdHJhaWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgIHRyYWlsLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4xNjY3ZW1cIik7IC8vIHRoaW4gc3BhY2UuXG4gICAgICBmcmFnbWVudC5wdXNoKHRyYWlsKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChmcmFnbWVudClcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyXG59O1xuXG4vLyBcXG9wZXJhdG9ybmFtZVxuLy8gYW1zb3BuLmR0eDogXFxtYXRob3B7IzFcXGtlcm5cXHpAXFxvcGVyYXRvckBmb250IzN9XFxuZXdtY29kZXNAXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwib3BlcmF0b3JuYW1lXCIsXG4gIG5hbWVzOiBbXCJcXFxcb3BlcmF0b3JuYW1lQFwiLCBcIlxcXFxvcGVyYXRvcm5hbWV3aXRobGltaXRzXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgY29uc3QgcHJldkF0b21UeXBlID0gcGFyc2VyLnByZXZBdG9tVHlwZTtcbiAgICBjb25zdCBuZXh0ID0gcGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9wZXJhdG9ybmFtZVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogKGZ1bmNOYW1lID09PSBcIlxcXFxvcGVyYXRvcm5hbWV3aXRobGltaXRzXCIpLFxuICAgICAgbGltaXRzOiBmYWxzZSxcbiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSxcbiAgICAgIGlzRm9sbG93ZWRCeURlbGltaXRlcjogaXNEZWxpbWl0ZXIobmV4dCksXG4gICAgICBuZWVkc0xlYWRpbmdTcGFjZTogcHJldkF0b21UeXBlLmxlbmd0aCA+IDAgJiYgb3JkVHlwZXMuaW5jbHVkZXMocHJldkF0b21UeXBlKVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMVxufSk7XG5cbmRlZmluZU1hY3JvKFwiXFxcXG9wZXJhdG9ybmFtZVwiLFxuICBcIlxcXFxAaWZzdGFyXFxcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHNcXFxcb3BlcmF0b3JuYW1lQFwiKTtcblxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwib3JkZ3JvdXBcIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIHN0eWxlLCBncm91cC5zZW1pc2ltcGxlKTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxccGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwaGFudG9tXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIHN0eWxlKTtcbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGhhbnRvbVwiLCBpbm5lcik7XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwiaHBoYW50b21cIixcbiAgbmFtZXM6IFtcIlxcXFxocGhhbnRvbVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyIH0sIGFyZ3MpID0+IHtcbiAgICBjb25zdCBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJocGhhbnRvbVwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBzdHlsZSkgPT4ge1xuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKG9yZGFyZ3VtZW50KGdyb3VwLmJvZHkpLCBzdHlsZSk7XG4gICAgY29uc3QgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBoYW50b21cIiwgaW5uZXIpO1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3BoYW50b21dKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBweFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImRlcHRoXCIsIFwiMHB4XCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInZwaGFudG9tXCIsXG4gIG5hbWVzOiBbXCJcXFxcdnBoYW50b21cIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IHBhcnNlciB9LCBhcmdzKSA9PiB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidnBoYW50b21cIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgc3R5bGUpO1xuICAgIGNvbnN0IHBoYW50b20gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcGFkZGVkXCIsIFtwaGFudG9tXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8vIEluIExhVGVYLCBcXHBtYiBpcyBhIHNpbXVsYXRpb24gb2YgYm9sZCBmb250LlxuLy8gVGhlIHZlcnNpb24gb2YgXFxwbWIgaW4gYW1ic3kuc3R5IHdvcmtzIGJ5IHR5cGVzZXR0aW5nIHRocmVlIGNvcGllcyBvZiB0aGUgYXJndW1lbnRcbi8vIHdpdGggc21hbGwgb2Zmc2V0cy4gV2UgdXNlIENTUyBmb250LXdlaWdodDpib2xkLlxuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicG1iXCIsXG4gIG5hbWVzOiBbXCJcXFxccG1iXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwbWJcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1swXSlcbiAgICB9XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgc3R5bGUpO1xuICAgIC8vIFdyYXAgd2l0aCBhbiA8bXN0eWxlPiBlbGVtZW50LlxuICAgIGNvbnN0IG5vZGUgPSB3cmFwV2l0aE1zdHlsZShpbm5lcik7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBcImZvbnQtd2VpZ2h0OmJvbGRcIik7XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbi8vIFxccmFpc2UsIFxcbG93ZXIsIGFuZCBcXHJhaXNlYm94XG5cbmNvbnN0IG1hdGhtbEJ1aWxkZXIgPSAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUud2l0aExldmVsKFN0eWxlTGV2ZWwuVEVYVCk7XG4gIGNvbnN0IG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBuZXdTdHlsZSldKTtcbiAgY29uc3QgZHkgPSBjYWxjdWxhdGVTaXplKGdyb3VwLmR5LCBzdHlsZSk7XG4gIG5vZGUuc2V0QXR0cmlidXRlKFwidm9mZnNldFwiLCBkeS5udW1iZXIgKyBkeS51bml0KTtcbiAgLy8gQWRkIHBhZGRpbmcsIHdoaWNoIGFjdHMgdG8gaW5jcmVhc2UgaGVpZ2h0IGluIENocm9taXVtLlxuICAvLyBUT0RPOiBGaWd1cmUgb3V0IHNvbWUgd2F5IHRvIGNoYW5nZSBoZWlnaHQgaW4gRmlyZWZveCB3L28gYnJlYWtpbmcgQ2hyb21pdW0uXG4gIGlmIChkeS5udW1iZXIgPiAwKSB7XG4gICAgbm9kZS5zdHlsZS5wYWRkaW5nID0gZHkubnVtYmVyICsgZHkudW5pdCArIFwiIDAgMCAwXCI7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zdHlsZS5wYWRkaW5nID0gXCIwIDAgXCIgKyBNYXRoLmFicyhkeS5udW1iZXIpICsgZHkudW5pdCArIFwiIDBcIjtcbiAgfVxuICByZXR1cm4gbm9kZVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJhaXNlXCIsXG4gIG5hbWVzOiBbXCJcXFxccmFpc2VcIiwgXCJcXFxcbG93ZXJcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInByaW1pdGl2ZVwiXSxcbiAgICBwcmltaXRpdmU6IHRydWVcbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciwgZnVuY05hbWUgfSwgYXJncykge1xuICAgIGNvbnN0IGFtb3VudCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sIFwic2l6ZVwiKS52YWx1ZTtcbiAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXGxvd2VyXCIpIHsgYW1vdW50Lm51bWJlciAqPSAtMTsgfVxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJhaXNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGR5OiBhbW91bnQsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlclxufSk7XG5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInJhaXNlXCIsXG4gIG5hbWVzOiBbXCJcXFxccmFpc2Vib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcImhib3hcIl0sXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYW1vdW50ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpLnZhbHVlO1xuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJhaXNlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGR5OiBhbW91bnQsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlclxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJyZWZcIixcbiAgbmFtZXM6IFtcIlxcXFxyZWZcIiwgXCJcXFxcZXFyZWZcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wicmF3XCJdXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIsIGZ1bmNOYW1lIH0sIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJyZWZcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgZnVuY05hbWUsXG4gICAgICBzdHJpbmc6IGFyZ3NbMF0uc3RyaW5nLnJlcGxhY2UoaW52YWxpZElkUmVnRXgsIFwiXCIpXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBDcmVhdGUgYW4gZW1wdHkgPGE+IG5vZGUuIFNldCBhIGNsYXNzIGFuZCBhbiBocmVmIGF0dHJpYnV0ZS5cbiAgICAvLyBUaGUgcG9zdC1wcm9jZXNzb3Igd2lsbCBwb3B1bGF0ZSB3aXRoIHRoZSB0YXJnZXQncyB0YWcgb3IgZXF1YXRpb24gbnVtYmVyLlxuICAgIGNvbnN0IGNsYXNzZXMgPSBncm91cC5mdW5jTmFtZSA9PT0gXCJcXFxccmVmXCIgPyBbXCJ0bWwtcmVmXCJdIDogW1widG1sLXJlZlwiLCBcInRtbC1lcXJlZlwiXTtcbiAgICByZXR1cm4gbmV3IEFuY2hvck5vZGUoXCIjXCIgKyBncm91cC5zdHJpbmcsIGNsYXNzZXMsIG51bGwpXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicmVmbGVjdFwiLFxuICBuYW1lczogW1wiXFxcXHJlZmxlY3Rib3hcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wiaGJveFwiXSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInJlZmxlY3RcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3Qgbm9kZSA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBzdHlsZSk7XG4gICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBcInNjYWxlWCgtMSlcIjtcbiAgICByZXR1cm4gbm9kZVxuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcImludGVybmFsXCIsXG4gIG5hbWVzOiBbXCJcXFxccmVsYXhcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImludGVybmFsXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZVxuICAgIH07XG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbih7XG4gIHR5cGU6IFwicnVsZVwiLFxuICBuYW1lczogW1wiXFxcXHJ1bGVcIl0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMixcbiAgICBudW1PcHRpb25hbEFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlLFxuICAgIGFyZ1R5cGVzOiBbXCJzaXplXCIsIFwic2l6ZVwiLCBcInNpemVcIl1cbiAgfSxcbiAgaGFuZGxlcih7IHBhcnNlciB9LCBhcmdzLCBvcHRBcmdzKSB7XG4gICAgY29uc3Qgc2hpZnQgPSBvcHRBcmdzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgXCJzaXplXCIpO1xuICAgIGNvbnN0IGhlaWdodCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sIFwic2l6ZVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJydWxlXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIHNoaWZ0OiBzaGlmdCAmJiBhc3NlcnROb2RlVHlwZShzaGlmdCwgXCJzaXplXCIpLnZhbHVlLFxuICAgICAgd2lkdGg6IHdpZHRoLnZhbHVlLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQudmFsdWVcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IHdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgc3R5bGUpO1xuICAgIGNvbnN0IGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBzdHlsZSk7XG4gICAgY29uc3Qgc2hpZnQgPSBncm91cC5zaGlmdFxuICAgICAgPyBjYWxjdWxhdGVTaXplKGdyb3VwLnNoaWZ0LCBzdHlsZSlcbiAgICAgIDogeyBudW1iZXI6IDAsIHVuaXQ6IFwiZW1cIiB9O1xuICAgIGNvbnN0IGNvbG9yID0gKHN0eWxlLmNvbG9yICYmIHN0eWxlLmdldENvbG9yKCkpIHx8IFwiYmxhY2tcIjtcblxuICAgIGNvbnN0IHJ1bGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICBpZiAod2lkdGgubnVtYmVyID4gMCAmJiBoZWlnaHQubnVtYmVyID4gMCkge1xuICAgICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJtYXRoYmFja2dyb3VuZFwiLCBjb2xvcik7XG4gICAgfVxuICAgIHJ1bGUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGgubnVtYmVyICsgd2lkdGgudW5pdCk7XG4gICAgcnVsZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0Lm51bWJlciArIGhlaWdodC51bml0KTtcbiAgICBpZiAoc2hpZnQubnVtYmVyID09PSAwKSB7IHJldHVybiBydWxlIH1cblxuICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW3J1bGVdKTtcbiAgICBpZiAoc2hpZnQubnVtYmVyID49IDApIHtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiK1wiICsgc2hpZnQubnVtYmVyICsgc2hpZnQudW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHNoaWZ0Lm51bWJlciArIHNoaWZ0LnVuaXQpO1xuICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIitcIiArIC1zaGlmdC5udW1iZXIgKyBzaGlmdC51bml0KTtcbiAgICB9XG4gICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoXCJ2b2Zmc2V0XCIsIHNoaWZ0Lm51bWJlciArIHNoaWZ0LnVuaXQpO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG59KTtcblxuLy8gVGhlIHNpemUgbWFwcGluZ3MgYXJlIHRha2VuIGZyb20gVGVYIHdpdGggXFxub3JtYWxzaXplPTEwcHQuXG4vLyBXZSBkb24ndCBoYXZlIHRvIHRyYWNrIHNjcmlwdCBsZXZlbC4gTWF0aE1MIGRvZXMgdGhhdC5cbmNvbnN0IHNpemVNYXAgPSB7XG4gIFwiXFxcXHRpbnlcIjogMC41LFxuICBcIlxcXFxzaXhwdHNpemVcIjogMC42LFxuICBcIlxcXFxUaW55XCI6IDAuNixcbiAgXCJcXFxcc2NyaXB0c2l6ZVwiOiAwLjcsXG4gIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiOiAwLjgsXG4gIFwiXFxcXHNtYWxsXCI6IDAuOSxcbiAgXCJcXFxcbm9ybWFsc2l6ZVwiOiAxLjAsXG4gIFwiXFxcXGxhcmdlXCI6IDEuMixcbiAgXCJcXFxcTGFyZ2VcIjogMS40NCxcbiAgXCJcXFxcTEFSR0VcIjogMS43MjgsXG4gIFwiXFxcXGh1Z2VcIjogMi4wNzQsXG4gIFwiXFxcXEh1Z2VcIjogMi40ODhcbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzaXppbmdcIixcbiAgbmFtZXM6IFtcbiAgICBcIlxcXFx0aW55XCIsXG4gICAgXCJcXFxcc2l4cHRzaXplXCIsXG4gICAgXCJcXFxcVGlueVwiLFxuICAgIFwiXFxcXHNjcmlwdHNpemVcIixcbiAgICBcIlxcXFxmb290bm90ZXNpemVcIixcbiAgICBcIlxcXFxzbWFsbFwiLFxuICAgIFwiXFxcXG5vcm1hbHNpemVcIixcbiAgICBcIlxcXFxsYXJnZVwiLFxuICAgIFwiXFxcXExhcmdlXCIsXG4gICAgXCJcXFxcTEFSR0VcIixcbiAgICBcIlxcXFxodWdlXCIsXG4gICAgXCJcXFxcSHVnZVwiXG4gIF0sXG4gIHByb3BzOiB7XG4gICAgbnVtQXJnczogMCxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG4gIH0sXG4gIGhhbmRsZXI6ICh7IGJyZWFrT25Ub2tlblRleHQsIGZ1bmNOYW1lLCBwYXJzZXIgfSwgYXJncykgPT4ge1xuICAgIGlmIChwYXJzZXIuc2V0dGluZ3Muc3RyaWN0ICYmIHBhcnNlci5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUubG9nKGBUZW1tbCBzdHJpY3QtbW9kZSB3YXJuaW5nOiBDb21tYW5kICR7ZnVuY05hbWV9IGlzIGludmFsaWQgaW4gbWF0aCBtb2RlLmApO1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgYnJlYWtPblRva2VuVGV4dCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic2l6aW5nXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGZ1bmNOYW1lLFxuICAgICAgYm9keVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgc3R5bGUpID0+IHtcbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlLndpdGhGb250U2l6ZShzaXplTWFwW2dyb3VwLmZ1bmNOYW1lXSk7XG4gICAgY29uc3QgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAuYm9keSwgbmV3U3R5bGUpO1xuICAgIC8vIFdyYXAgd2l0aCBhbiA8bXN0eWxlPiBlbGVtZW50LlxuICAgIGNvbnN0IG5vZGUgPSB3cmFwV2l0aE1zdHlsZShpbm5lcik7XG4gICAgY29uc3QgZmFjdG9yID0gKHNpemVNYXBbZ3JvdXAuZnVuY05hbWVdIC8gc3R5bGUuZm9udFNpemUpLnRvRml4ZWQoNCk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoc2l6ZVwiLCBmYWN0b3IgKyBcImVtXCIpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG59KTtcblxuLy8gc21hc2gsIHdpdGggb3B0aW9uYWwgW3RiXSwgYXMgaW4gQU1TXG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzbWFzaFwiLFxuICBuYW1lczogW1wiXFxcXHNtYXNoXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbiAgfSxcbiAgaGFuZGxlcjogKHsgcGFyc2VyIH0sIGFyZ3MsIG9wdEFyZ3MpID0+IHtcbiAgICBsZXQgc21hc2hIZWlnaHQgPSBmYWxzZTtcbiAgICBsZXQgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgIGNvbnN0IHRiQXJnID0gb3B0QXJnc1swXSAmJiBhc3NlcnROb2RlVHlwZShvcHRBcmdzWzBdLCBcIm9yZGdyb3VwXCIpO1xuICAgIGlmICh0YkFyZykge1xuICAgICAgLy8gT3B0aW9uYWwgW3RiXSBhcmd1bWVudCBpcyBlbmdhZ2VkLlxuICAgICAgLy8gcmVmOiBhbXNtYXRoOiBcXHJlbmV3Y29tbWFuZHtcXHNtYXNofVsxXVt0Yl17JVxuICAgICAgLy8gICAgICAgICAgICAgICBkZWZcXG1iQHR7XFxodH1cXGRlZlxcbWJAYntcXGRwfVxcZGVmXFxtYkB0YntcXGh0XFx6QFxcekBcXGRwfSVcbiAgICAgIGxldCBsZXR0ZXIgPSBcIlwiO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YkFyZy5ib2R5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0YkFyZy5ib2R5W2ldO1xuICAgICAgICAvLyBUT0RPOiBXcml0ZSBhbiBBc3NlcnRTeW1ib2xOb2RlXG4gICAgICAgIGxldHRlciA9IG5vZGUudGV4dDtcbiAgICAgICAgaWYgKGxldHRlciA9PT0gXCJ0XCIpIHtcbiAgICAgICAgICBzbWFzaEhlaWdodCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcImJcIikge1xuICAgICAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgc21hc2hEZXB0aCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTtcbiAgICAgIHNtYXNoRGVwdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInNtYXNoXCIsXG4gICAgICBtb2RlOiBwYXJzZXIubW9kZSxcbiAgICAgIGJvZHksXG4gICAgICBzbWFzaEhlaWdodCxcbiAgICAgIHNtYXNoRGVwdGhcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIHN0eWxlKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIHN0eWxlKV0pO1xuXG4gICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkZXB0aFwiLCBcIjBweFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzcXJ0XCIsXG4gIG5hbWVzOiBbXCJcXFxcc3FydFwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAxLFxuICAgIG51bU9wdGlvbmFsQXJnczogMVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyIH0sIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICBjb25zdCBpbmRleCA9IG9wdEFyZ3NbMF07XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3FydFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5LFxuICAgICAgaW5kZXhcbiAgICB9O1xuICB9LFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGNvbnN0IHsgYm9keSwgaW5kZXggfSA9IGdyb3VwO1xuICAgIHJldHVybiBpbmRleFxuICAgICAgPyBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb290XCIsIFtcbiAgICAgICAgYnVpbGRHcm91cCQxKGJvZHksIHN0eWxlKSxcbiAgICAgICAgYnVpbGRHcm91cCQxKGluZGV4LCBzdHlsZS5pbmNyZW1lbnRMZXZlbCgpKVxuICAgICAgXSlcbiAgICA6IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXNxcnRcIiwgW2J1aWxkR3JvdXAkMShib2R5LCBzdHlsZSldKTtcbiAgfVxufSk7XG5cbmNvbnN0IHN0eWxlTWFwID0ge1xuICBkaXNwbGF5OiAwLFxuICB0ZXh0OiAxLFxuICBzY3JpcHQ6IDIsXG4gIHNjcmlwdHNjcmlwdDogM1xufTtcblxuY29uc3Qgc3R5bGVBdHRyaWJ1dGVzID0ge1xuICBkaXNwbGF5OiBbXCIwXCIsIFwidHJ1ZVwiXSxcbiAgdGV4dDogW1wiMFwiLCBcImZhbHNlXCJdLFxuICBzY3JpcHQ6IFtcIjFcIiwgXCJmYWxzZVwiXSxcbiAgc2NyaXB0c2NyaXB0OiBbXCIyXCIsIFwiZmFsc2VcIl1cbn07XG5cbmRlZmluZUZ1bmN0aW9uKHtcbiAgdHlwZTogXCJzdHlsaW5nXCIsXG4gIG5hbWVzOiBbXCJcXFxcZGlzcGxheXN0eWxlXCIsIFwiXFxcXHRleHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXSxcbiAgcHJvcHM6IHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgcHJpbWl0aXZlOiB0cnVlXG4gIH0sXG4gIGhhbmRsZXIoeyBicmVha09uVG9rZW5UZXh0LCBmdW5jTmFtZSwgcGFyc2VyIH0sIGFyZ3MpIHtcbiAgICAvLyBwYXJzZSBvdXQgdGhlIGltcGxpY2l0IGJvZHlcbiAgICBjb25zdCBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0LCB0cnVlKTtcblxuICAgIGNvbnN0IHNjcmlwdExldmVsID0gZnVuY05hbWUuc2xpY2UoMSwgZnVuY05hbWUubGVuZ3RoIC0gNSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3R5bGluZ1wiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2NyaXB0TGV2ZWwgdG8gdXNlIGJ5IHB1bGxpbmcgb3V0IHRoZSBzY3JpcHRMZXZlbCBmcm9tXG4gICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgc2NyaXB0TGV2ZWwsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2NyaXB0TGV2ZWwgd2UncmUgY2hhbmdpbmcgdG8uXG4gICAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS53aXRoTGV2ZWwoc3R5bGVNYXBbZ3JvdXAuc2NyaXB0TGV2ZWxdKTtcbiAgICAvLyBUaGUgc3R5bGUgYXJndW1lbnQgaW4gdGhlIG5leHQgbGluZSBkb2VzIE5PVCBkaXJlY3RseSBzZXQgYSBNYXRoTUwgc2NyaXB0IGxldmVsLlxuICAgIC8vIEl0IGp1c3QgdHJhY2tzIHRoZSBzdHlsZSBsZXZlbCwgaW4gY2FzZSB3ZSBuZWVkIHRvIGtub3cgaXQgZm9yIHN1cHN1YiBvciBtYXRoY2hvaWNlLlxuICAgIGNvbnN0IGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLmJvZHksIG5ld1N0eWxlKTtcbiAgICAvLyBXcmFwIHdpdGggYW4gPG1zdHlsZT4gZWxlbWVudC5cbiAgICBjb25zdCBub2RlID0gd3JhcFdpdGhNc3R5bGUoaW5uZXIpO1xuXG4gICAgY29uc3QgYXR0ciA9IHN0eWxlQXR0cmlidXRlc1tncm91cC5zY3JpcHRMZXZlbF07XG5cbiAgICAvLyBIZXJlIGlzIHdoZXJlIHdlIHNldCB0aGUgTWF0aE1MIHNjcmlwdCBsZXZlbC5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIGF0dHJbMF0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZGlzcGxheXN0eWxlXCIsIGF0dHJbMV0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFNvbWV0aW1lcywgZ3JvdXBzIHBlcmZvcm0gc3BlY2lhbCBydWxlcyB3aGVuIHRoZXkgaGF2ZSBzdXBlcnNjcmlwdHMgb3JcbiAqIHN1YnNjcmlwdHMgYXR0YWNoZWQgdG8gdGhlbS4gVGhpcyBmdW5jdGlvbiBsZXRzIHRoZSBgc3Vwc3ViYCBncm91cCBrbm93IHRoYXRcbiAqIFNvbWV0aW1lcywgZ3JvdXBzIHBlcmZvcm0gc3BlY2lhbCBydWxlcyB3aGVuIHRoZXkgaGF2ZSBzdXBlcnNjcmlwdHMgb3JcbiAqIGl0cyBpbm5lciBlbGVtZW50IHNob3VsZCBoYW5kbGUgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cyBpbnN0ZWFkIG9mXG4gKiBoYW5kbGluZyB0aGVtIGl0c2VsZi5cbiAqL1xuXG4vLyBIZWxwZXJzXG5jb25zdCBzeW1ib2xSZWdFeCA9IC9ebShvdmVyfHVuZGVyfHVuZGVyb3ZlcikkLztcblxuLy8gU3VwZXIgc2NyaXB0cyBhbmQgc3Vic2NyaXB0cywgd2hvc2UgcHJlY2lzZSBwbGFjZW1lbnQgY2FuIGRlcGVuZCBvbiBvdGhlclxuLy8gZnVuY3Rpb25zIHRoYXQgcHJlY2VkZSB0aGVtLlxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwic3Vwc3ViXCIsXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgLy8gSXMgdGhlIGlubmVyIGdyb3VwIGEgcmVsZXZhbnQgaG9yaXpvbnRhbCBicmFjZT9cbiAgICBsZXQgaXNCcmFjZSA9IGZhbHNlO1xuICAgIGxldCBpc092ZXI7XG4gICAgbGV0IGlzU3VwO1xuICAgIGxldCBhcHBlbmRBcHBseUZ1bmN0aW9uID0gZmFsc2U7XG4gICAgbGV0IGFwcGVuZFNwYWNlID0gZmFsc2U7XG4gICAgbGV0IG5lZWRzTGVhZGluZ1NwYWNlID0gZmFsc2U7XG5cbiAgICBpZiAoZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09IFwiaG9yaXpCcmFjZVwiKSB7XG4gICAgICBpc1N1cCA9ICEhZ3JvdXAuc3VwO1xuICAgICAgaWYgKGlzU3VwID09PSBncm91cC5iYXNlLmlzT3Zlcikge1xuICAgICAgICBpc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgaXNPdmVyID0gZ3JvdXAuYmFzZS5pc092ZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLmJhc2UgJiYgIWdyb3VwLmJhc2Uuc3RhY2sgJiZcbiAgICAgIChncm91cC5iYXNlLnR5cGUgPT09IFwib3BcIiB8fCBncm91cC5iYXNlLnR5cGUgPT09IFwib3BlcmF0b3JuYW1lXCIpKSB7XG4gICAgICBncm91cC5iYXNlLnBhcmVudElzU3VwU3ViID0gdHJ1ZTtcbiAgICAgIGFwcGVuZEFwcGx5RnVuY3Rpb24gPSAhZ3JvdXAuYmFzZS5zeW1ib2w7XG4gICAgICBhcHBlbmRTcGFjZSA9IGFwcGVuZEFwcGx5RnVuY3Rpb24gJiYgIWdyb3VwLmlzRm9sbG93ZWRCeURlbGltaXRlcjtcbiAgICAgIG5lZWRzTGVhZGluZ1NwYWNlID0gZ3JvdXAuYmFzZS5uZWVkc0xlYWRpbmdTcGFjZTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IGdyb3VwLmJhc2UgJiYgZ3JvdXAuYmFzZS5zdGFja1xuICAgICAgPyBbYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UuYm9keVswXSwgc3R5bGUpXVxuICAgICAgOiBbYnVpbGRHcm91cCQxKGdyb3VwLmJhc2UsIHN0eWxlKV07XG5cbiAgICAvLyBOb3RlIHJlZ2FyZGluZyBzY3JpcHRzdHlsZSBsZXZlbC5cbiAgICAvLyAoU3VifHN1cGVyKXNjcmlwdHMgc2hvdWxkIG5vdCBzaHJpbmsgYmV5b25kIE1hdGhNTCBzY3JpcHRsZXZlbCAyIGFrYSBcXHNjcmlwdHNjcmlwdHN0eWxlXG4gICAgLy8gUmVmOiBodHRwczovL3czYy5naXRodWIuaW8vbWF0aG1sLWNvcmUvI3RoZS1kaXNwbGF5c3R5bGUtYW5kLXNjcmlwdGxldmVsLWF0dHJpYnV0ZXNcbiAgICAvLyAoQlRXLCBNYXRoTUwgc2NyaXB0bGV2ZWwgMiBpcyBlcXVhbCB0byBUZW1tbCBsZXZlbCAzLilcbiAgICAvLyBCdXQgQ2hyb21pdW0gY29udGludWVzIHRvIHNocmluayB0aGUgKHN1YnxzdXBlcilzY3JpcHRzLiBTbyB3ZSBleHBsaWNpdGx5IHNldCBzY3JpcHRsZXZlbCAyLlxuXG4gICAgY29uc3QgY2hpbGRTdHlsZSA9IHN0eWxlLmluU3ViT3JTdXAoKTtcbiAgICBpZiAoZ3JvdXAuc3ViKSB7XG4gICAgICBjb25zdCBzdWIgPSBidWlsZEdyb3VwJDEoZ3JvdXAuc3ViLCBjaGlsZFN0eWxlKTtcbiAgICAgIGlmIChzdHlsZS5sZXZlbCA9PT0gMykgeyBzdWIuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgXCIyXCIpOyB9XG4gICAgICBjaGlsZHJlbi5wdXNoKHN1Yik7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnN1cCkge1xuICAgICAgY29uc3Qgc3VwID0gYnVpbGRHcm91cCQxKGdyb3VwLnN1cCwgY2hpbGRTdHlsZSk7XG4gICAgICBpZiAoc3R5bGUubGV2ZWwgPT09IDMpIHsgc3VwLnNldEF0dHJpYnV0ZShcInNjcmlwdGxldmVsXCIsIFwiMlwiKTsgfVxuICAgICAgY29uc3QgdGVzdE5vZGUgPSBzdXAudHlwZSA9PT0gXCJtcm93XCIgPyBzdXAuY2hpbGRyZW5bMF0gOiBzdXA7XG4gICAgICBpZiAoKHRlc3ROb2RlICYmIHRlc3ROb2RlLnR5cGUgPT09IFwibW9cIiAmJiB0ZXN0Tm9kZS5jbGFzc2VzLmluY2x1ZGVzKFwidG1sLXByaW1lXCIpKVxuICAgICAgICAmJiBncm91cC5iYXNlICYmIGdyb3VwLmJhc2UudGV4dCAmJiBcImZGXCIuaW5kZXhPZihncm91cC5iYXNlLnRleHQpID4gLTEpIHtcbiAgICAgICAgLy8gQ2hyb21pdW0gZG9lcyBub3QgYWRkcmVzcyBpdGFsaWMgY29ycmVjdGlvbiBvbiBwcmltZS4gIFByZXZlbnQgZuKAsiBmcm9tIG92ZXJsYXBwaW5nLlxuICAgICAgICB0ZXN0Tm9kZS5jbGFzc2VzLnB1c2goXCJwcmltZS1wYWRcIik7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbi5wdXNoKHN1cCk7XG4gICAgfVxuXG4gICAgbGV0IG5vZGVUeXBlO1xuICAgIGlmIChpc0JyYWNlKSB7XG4gICAgICBub2RlVHlwZSA9IGlzT3ZlciA/IFwibW92ZXJcIiA6IFwibXVuZGVyXCI7XG4gICAgfSBlbHNlIGlmICghZ3JvdXAuc3ViKSB7XG4gICAgICBjb25zdCBiYXNlID0gZ3JvdXAuYmFzZTtcbiAgICAgIGlmIChcbiAgICAgICAgYmFzZSAmJlxuICAgICAgICBiYXNlLnR5cGUgPT09IFwib3BcIiAmJlxuICAgICAgICBiYXNlLmxpbWl0cyAmJlxuICAgICAgICAoc3R5bGUubGV2ZWwgPT09IFN0eWxlTGV2ZWwuRElTUExBWSB8fCBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YilcbiAgICAgICkge1xuICAgICAgICBub2RlVHlwZSA9IFwibW92ZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGJhc2UgJiZcbiAgICAgICAgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmXG4gICAgICAgIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmXG4gICAgICAgIChiYXNlLmxpbWl0cyB8fCBzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtb3ZlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdXBcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFncm91cC5zdXApIHtcbiAgICAgIGNvbnN0IGJhc2UgPSBncm91cC5iYXNlO1xuICAgICAgaWYgKFxuICAgICAgICBiYXNlICYmXG4gICAgICAgIGJhc2UudHlwZSA9PT0gXCJvcFwiICYmXG4gICAgICAgIGJhc2UubGltaXRzICYmXG4gICAgICAgIChzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJcIjtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGJhc2UgJiZcbiAgICAgICAgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiICYmXG4gICAgICAgIGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmXG4gICAgICAgIChiYXNlLmxpbWl0cyB8fCBzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtc3ViXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJhc2UgPSBncm91cC5iYXNlO1xuICAgICAgaWYgKGJhc2UgJiYgKChiYXNlLnR5cGUgPT09IFwib3BcIiAmJiBiYXNlLmxpbWl0cykgfHwgYmFzZS50eXBlID09PSBcIm11bHRpc2NyaXB0XCIpICYmXG4gICAgICAgIChzdHlsZS5sZXZlbCA9PT0gU3R5bGVMZXZlbC5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVUeXBlID0gXCJtdW5kZXJvdmVyXCI7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBiYXNlICYmXG4gICAgICAgIGJhc2UudHlwZSA9PT0gXCJvcGVyYXRvcm5hbWVcIiAmJlxuICAgICAgICBiYXNlLmFsd2F5c0hhbmRsZVN1cFN1YiAmJlxuICAgICAgICAoc3R5bGUubGV2ZWwgPT09IFN0eWxlTGV2ZWwuRElTUExBWSB8fCBiYXNlLmxpbWl0cylcbiAgICAgICkge1xuICAgICAgICBub2RlVHlwZSA9IFwibXVuZGVyb3ZlclwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJzdXBcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKG5vZGVUeXBlLCBjaGlsZHJlbik7XG4gICAgaWYgKGFwcGVuZEFwcGx5RnVuY3Rpb24pIHtcbiAgICAgIC8vIEFwcGVuZCBhbiA8bW8+JkFwcGx5RnVuY3Rpb247PC9tbz4uXG4gICAgICAvLyByZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9SRUMtTWF0aE1ML2NoYXAzXzIuaHRtbCNzZWMzLjIuNFxuICAgICAgY29uc3Qgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFttYWtlVGV4dChcIlxcdTIwNjFcIiwgXCJ0ZXh0XCIpXSk7XG4gICAgICBpZiAobmVlZHNMZWFkaW5nU3BhY2UpIHtcbiAgICAgICAgY29uc3Qgc3BhY2UgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcbiAgICAgICAgc3BhY2Uuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIwLjE2NjdlbVwiKTsgLy8gdGhpbiBzcGFjZS5cbiAgICAgICAgbm9kZSA9IG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChbc3BhY2UsIG5vZGUsIG9wZXJhdG9yXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbWF0aE1MVHJlZS5uZXdEb2N1bWVudEZyYWdtZW50KFtub2RlLCBvcGVyYXRvcl0pO1xuICAgICAgfVxuICAgICAgaWYgKGFwcGVuZFNwYWNlKSB7XG4gICAgICAgIGNvbnN0IHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIHNwYWNlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4xNjY3ZW1cIik7IC8vIHRoaW4gc3BhY2UuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChzcGFjZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzeW1ib2xSZWdFeC50ZXN0KG5vZGVUeXBlKSkge1xuICAgICAgLy8gV3JhcCBpbiBhIDxtcm93Pi4gT3RoZXJ3aXNlIEZpcmVmb3ggc3RyZXRjaHkgcGFyZW5zIHdpbGwgbm90IHN0cmV0Y2ggdG8gaW5jbHVkZSBsaW1pdHMuXG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtub2RlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbi8vIE9wZXJhdG9yIFBhcnNlTm9kZXMgY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSBzeW1ib2wgR3JvdXBzIGluIHNyYy9zeW1ib2xzLmpzLlxuXG5jb25zdCBzaG9ydCA9IFtcIlxcXFxzaG9ydG1pZFwiLCBcIlxcXFxuc2hvcnRtaWRcIiwgXCJcXFxcc2hvcnRwYXJhbGxlbFwiLFxuICBcIlxcXFxuc2hvcnRwYXJhbGxlbFwiLCBcIlxcXFxzbWFsbHNldG1pbnVzXCJdO1xuXG5jb25zdCBhcnJvd3MgPSBbXCJcXFxcUnNoXCIsIFwiXFxcXExzaFwiLCBcIlxcXFxyZXN0cmljdGlvblwiXTtcblxuY29uc3QgaXNBcnJvdyA9IHN0ciA9PiB7XG4gIGlmIChzdHIubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgY29kZVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KDApO1xuICAgIHJldHVybiAoMHgyMThmIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MjIwMClcbiAgfVxuICByZXR1cm4gc3RyLmluZGV4T2YoXCJhcnJvd1wiKSA+IC0xIHx8IHN0ci5pbmRleE9mKFwiaGFycG9vblwiKSA+IC0xIHx8IGFycm93cy5pbmNsdWRlcyhzdHIpXG59O1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJhdG9tXCIsXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnRleHQsIGdyb3VwLm1vZGUpXSk7XG4gICAgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJwdW5jdFwiKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInNlcGFyYXRvclwiLCBcInRydWVcIik7XG4gICAgfSBlbHNlIGlmIChncm91cC5mYW1pbHkgPT09IFwib3BlblwiIHx8IGdyb3VwLmZhbWlseSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAvLyBEZWxpbXMgYnVpbHQgaGVyZSBzaG91bGQgbm90IHN0cmV0Y2ggdmVydGljYWxseS5cbiAgICAgIC8vIFNlZSBkZWxpbXNpemluZy5qcyBmb3Igc3RyZXRjaHkgZGVsaW1zLlxuICAgICAgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIFwicHJlZml4XCIpO1xuICAgICAgICAvLyBTZXQgYW4gZXhwbGljaXQgYXR0cmlidXRlIGZvciBzdHJldGNoLiBPdGhlcndpc2UgRmlyZWZveCBtYXkgZG8gaXQgd3JvbmcuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJmYWxzZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAuZmFtaWx5ID09PSBcImNsb3NlXCIpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIFwicG9zdGZpeFwiKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJzdHJldGNoeVwiLCBcImZhbHNlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAudGV4dCA9PT0gXCJcXFxcbWlkXCIpIHtcbiAgICAgIC8vIEZpcmVmb3ggbWVzc2VzIHVwIHRoaXMgc3BhY2luZyBpZiBhdCB0aGUgZW5kIG9mIGFuIDxtcm93Pi4gU2VlIGl0IGV4cGxpY2l0bHkuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcImxzcGFjZVwiLCBcIjAuMjJlbVwiKTsgLy8gbWVkaXVtIHNwYWNlXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjAuMjJlbVwiKTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJmYWxzZVwiKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gXCJyZWxcIiAmJiBpc0Fycm93KGdyb3VwLnRleHQpKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwiZmFsc2VcIik7XG4gICAgfSBlbHNlIGlmIChzaG9ydC5pbmNsdWRlcyhncm91cC50ZXh0KSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRoc2l6ZVwiLCBcIjcwJVwiKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnRleHQgPT09IFwiOlwiKSB7XG4gICAgICAvLyBcIjpcIiBpcyBub3QgaW4gdGhlIE1hdGhNTCBvcGVyYXRvciBkaWN0aW9uYXJ5LiBHaXZlIGl0IEJJTiBzcGFjaW5nLlxuICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9IFwiMC4yMjIyZW1cIjtcbiAgICAgIG5vZGUuYXR0cmlidXRlcy5yc3BhY2UgPSBcIjAuMjIyMmVtXCI7XG4gICAgfSBlbHNlIGlmIChncm91cC5uZWVkc1NwYWNpbmcpIHtcbiAgICAgIC8vIEZpeCBhIE1hdGhNTCBidWcgdGhhdCBvY2N1cnMgd2hlbiBhIDxtbz4gaXMgYmV0d2VlbiB0d28gPG10ZXh0PiBlbGVtZW50cy5cbiAgICAgIGlmIChncm91cC5mYW1pbHkgPT09IFwiYmluXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBbcGFkZGluZyQxKDAuMjIyKSwgbm9kZSwgcGFkZGluZyQxKDAuMjIyKV0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSRUwgc3BhY2luZ1xuICAgICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIFtwYWRkaW5nJDEoMC4yNzc4KSwgbm9kZSwgcGFkZGluZyQxKDAuMjc3OCldKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxufSk7XG5cbi8qKlxuICogTWFwcyBUZVggZm9udCBjb21tYW5kcyB0byBcIm1hdGh2YXJpYW50XCIgYXR0cmlidXRlIGluIGJ1aWxkTWF0aE1MLmpzXG4gKi9cbmNvbnN0IGZvbnRNYXAgPSB7XG4gIC8vIHN0eWxlc1xuICBtYXRoYmY6IFwiYm9sZFwiLFxuICBtYXRocm06IFwibm9ybWFsXCIsXG4gIHRleHRpdDogXCJpdGFsaWNcIixcbiAgbWF0aGl0OiBcIml0YWxpY1wiLFxuICBtYXRobm9ybWFsOiBcIml0YWxpY1wiLFxuXG4gIC8vIGZhbWlsaWVzXG4gIG1hdGhiYjogXCJkb3VibGUtc3RydWNrXCIsXG4gIG1hdGhjYWw6IFwic2NyaXB0XCIsXG4gIG1hdGhmcmFrOiBcImZyYWt0dXJcIixcbiAgbWF0aHNjcjogXCJzY3JpcHRcIixcbiAgbWF0aHNmOiBcInNhbnMtc2VyaWZcIixcbiAgbWF0aHR0OiBcIm1vbm9zcGFjZVwiXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1hdGggdmFyaWFudCBhcyBhIHN0cmluZyBvciBudWxsIGlmIG5vbmUgaXMgcmVxdWlyZWQuXG4gKi9cbmNvbnN0IGdldFZhcmlhbnQgPSBmdW5jdGlvbihncm91cCwgc3R5bGUpIHtcbiAgLy8gSGFuZGxlIGZvbnQgc3BlY2lmaWVycyBhcyBiZXN0IHdlIGNhbi5cbiAgLy8gQ2hyb21pdW0gZG9lcyBub3Qgc3VwcG9ydCB0aGUgTWF0aE1MIG1hdGh2YXJpYW50IGF0dHJpYnV0ZS5cbiAgLy8gU28gd2UnbGwgdXNlIFVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpbnN0ZWFkLlxuICAvLyBCdXQgZmlyc3QsIGRldGVybWluZSB0aGUgbWF0aCB2YXJpYW50LlxuXG4gIC8vIERlYWwgd2l0aCB0aGUgXFx0ZXh0aXQsIFxcdGV4dGJmLCBldGMuLCBmdW5jdGlvbnMuXG4gIGlmIChzdHlsZS5mb250RmFtaWx5ID09PSBcInRleHR0dFwiKSB7XG4gICAgcmV0dXJuIFwibW9ub3NwYWNlXCJcbiAgfSBlbHNlIGlmIChzdHlsZS5mb250RmFtaWx5ID09PSBcInRleHRzY1wiKSB7XG4gICAgcmV0dXJuIFwibm9ybWFsXCI7IC8vIGhhbmRsZWQgdmlhIGNoYXJhY3RlciBzdWJzdGl0dXRpb24gaW4gc3ltYm9sc09yZC5qcy5cbiAgfSBlbHNlIGlmIChzdHlsZS5mb250RmFtaWx5ID09PSBcInRleHRzZlwiKSB7XG4gICAgaWYgKHN0eWxlLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBzdHlsZS5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmLWJvbGQtaXRhbGljXCJcbiAgICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIikge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1pdGFsaWNcIlxuICAgIH0gZWxzZSBpZiAoc3R5bGUuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZi1ib2xkXCJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwic2Fucy1zZXJpZlwiXG4gICAgfVxuICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIiAmJiBzdHlsZS5mb250V2VpZ2h0ID09PSBcInRleHRiZlwiKSB7XG4gICAgcmV0dXJuIFwiYm9sZC1pdGFsaWNcIlxuICB9IGVsc2UgaWYgKHN0eWxlLmZvbnRTaGFwZSA9PT0gXCJ0ZXh0aXRcIikge1xuICAgIHJldHVybiBcIml0YWxpY1wiXG4gIH0gZWxzZSBpZiAoc3R5bGUuZm9udFdlaWdodCA9PT0gXCJ0ZXh0YmZcIikge1xuICAgIHJldHVybiBcImJvbGRcIlxuICB9XG5cbiAgLy8gRGVhbCB3aXRoIHRoZSBcXG1hdGhpdCwgbWF0aGJmLCBldGMsIGZ1bmN0aW9ucy5cbiAgY29uc3QgZm9udCA9IHN0eWxlLmZvbnQ7XG4gIGlmICghZm9udCB8fCBmb250ID09PSBcIm1hdGhub3JtYWxcIikge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBtb2RlID0gZ3JvdXAubW9kZTtcbiAgc3dpdGNoIChmb250KSB7XG4gICAgY2FzZSBcIm1hdGhpdFwiOlxuICAgICAgcmV0dXJuIFwiaXRhbGljXCJcbiAgICBjYXNlIFwibWF0aHJtXCI6IHtcbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGdyb3VwLnRleHQuY29kZVBvaW50QXQoMCk7XG4gICAgICAvLyBMYVRlWCBcXG1hdGhybSByZXR1cm5zIGl0YWxpYyBmb3IgR3JlZWsgY2hhcmFjdGVycy5cbiAgICAgIHJldHVybiAgKDB4MDNhYiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDAzY2YpID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCJcbiAgICB9XG4gICAgY2FzZSBcImdyZWVrSXRhbGljXCI6XG4gICAgICByZXR1cm4gXCJpdGFsaWNcIlxuICAgIGNhc2UgXCJ1cEBncmVla1wiOlxuICAgICAgcmV0dXJuIFwibm9ybWFsXCJcbiAgICBjYXNlIFwiYm9sZHN5bWJvbFwiOlxuICAgIGNhc2UgXCJtYXRoYm9sZHN5bWJvbFwiOlxuICAgICAgcmV0dXJuIFwiYm9sZC1pdGFsaWNcIlxuICAgIGNhc2UgXCJtYXRoYmZcIjpcbiAgICAgIHJldHVybiBcImJvbGRcIlxuICAgIGNhc2UgXCJtYXRoYmJcIjpcbiAgICAgIHJldHVybiBcImRvdWJsZS1zdHJ1Y2tcIlxuICAgIGNhc2UgXCJtYXRoZnJha1wiOlxuICAgICAgcmV0dXJuIFwiZnJha3R1clwiXG4gICAgY2FzZSBcIm1hdGhzY3JcIjpcbiAgICBjYXNlIFwibWF0aGNhbFwiOlxuICAgICAgcmV0dXJuIFwic2NyaXB0XCJcbiAgICBjYXNlIFwibWF0aHNmXCI6XG4gICAgICByZXR1cm4gXCJzYW5zLXNlcmlmXCJcbiAgICBjYXNlIFwibWF0aHNmaXRcIjpcbiAgICAgIHJldHVybiBcInNhbnMtc2VyaWYtaXRhbGljXCJcbiAgICBjYXNlIFwibWF0aHR0XCI6XG4gICAgICByZXR1cm4gXCJtb25vc3BhY2VcIlxuICB9XG5cbiAgbGV0IHRleHQgPSBncm91cC50ZXh0O1xuICBpZiAoc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UpIHtcbiAgICB0ZXh0ID0gc3ltYm9sc1ttb2RlXVt0ZXh0XS5yZXBsYWNlO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmb250TWFwLCBmb250KSA/IGZvbnRNYXBbZm9udF0gOiBudWxsXG59O1xuXG4vLyBDaHJvbWl1bSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBNYXRoTUwgYG1hdGh2YXJpYW50YCBhdHRyaWJ1dGUuXG4vLyBJbnN0ZWFkLCB3ZSByZXBsYWNlIEFTQ0lJIGNoYXJhY3RlcnMgd2l0aCBVbmljb2RlIGNoYXJhY3RlcnMgdGhhdFxuLy8gYXJlIGRlZmluZWQgaW4gdGhlIGZvbnQgYXMgYm9sZCwgaXRhbGljLCBkb3VibGUtc3RydWNrLCBldGMuXG4vLyBUaGlzIG1vZHVsZSBpZGVudGlmaWVzIHRob3NlIFVuaWNvZGUgY29kZSBwb2ludHMuXG5cbi8vIEZpcnN0LCBhIGZldyBoZWxwZXJzLlxuY29uc3Qgc2NyaXB0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEI6IDB4MjBFQSwgLy8gT2Zmc2V0IGZyb20gQVNDSUkgQiB0byBVbmljb2RlIHNjcmlwdCBCXG4gIEU6IDB4MjBFQixcbiAgRjogMHgyMEVCLFxuICBIOiAweDIwQzMsXG4gIEk6IDB4MjBDNyxcbiAgTDogMHgyMEM2LFxuICBNOiAweDIwRTYsXG4gIFI6IDB4MjBDOSxcbiAgZTogMHgyMENBLFxuICBnOiAweDIwQTMsXG4gIG86IDB4MjBDNVxufSk7XG5cbmNvbnN0IGZyYWsgPSBPYmplY3QuZnJlZXplKHtcbiAgQzogMHgyMEVBLFxuICBIOiAweDIwQzQsXG4gIEk6IDB4MjBDOCxcbiAgUjogMHgyMENBLFxuICBaOiAweDIwQ0Vcbn0pO1xuXG5jb25zdCBiYmIgPSBPYmplY3QuZnJlZXplKHtcbiAgQzogMHgyMEJGLCAvLyBibGFja2JvYXJkIGJvbGRcbiAgSDogMHgyMEM1LFxuICBOOiAweDIwQzcsXG4gIFA6IDB4MjBDOSxcbiAgUTogMHgyMEM5LFxuICBSOiAweDIwQ0IsXG4gIFo6IDB4MjBDQVxufSk7XG5cbmNvbnN0IGJvbGQgPSBPYmplY3QuZnJlZXplKHtcbiAgXCJcXHUwM2Y1XCI6IDB4MUQyRTcsIC8vIGx1bmF0ZSBlcHNpbG9uXG4gIFwiXFx1MDNkMVwiOiAweDFEMzBDLCAvLyB2YXJ0aGV0YVxuICBcIlxcdTAzZjBcIjogMHgxRDJFRSwgLy8gdmFya2FwcGFcbiAgXCJcXHUwM2M2XCI6IDB4MUQzMTksIC8vIHZhcnBoaVxuICBcIlxcdTAzZjFcIjogMHgxRDJFRiwgLy8gdmFycmhvXG4gIFwiXFx1MDNkNlwiOiAweDFEMzBCICAvLyB2YXJwaVxufSk7XG5cbmNvbnN0IGJvbGRJdGFsaWMgPSBPYmplY3QuZnJlZXplKHtcbiAgXCJcXHUwM2Y1XCI6IDB4MUQzNUIsIC8vIGx1bmF0ZSBlcHNpbG9uXG4gIFwiXFx1MDNkMVwiOiAweDFEMzgwLCAvLyB2YXJ0aGV0YVxuICBcIlxcdTAzZjBcIjogMHgxRDM2MiwgLy8gdmFya2FwcGFcbiAgXCJcXHUwM2M2XCI6IDB4MUQzOEQsIC8vIHZhcnBoaVxuICBcIlxcdTAzZjFcIjogMHgxRDM2MywgLy8gdmFycmhvXG4gIFwiXFx1MDNkNlwiOiAweDFEMzdGICAvLyB2YXJwaVxufSk7XG5cbmNvbnN0IGJvbGRzZiA9IE9iamVjdC5mcmVlemUoe1xuICBcIlxcdTAzZjVcIjogMHgxRDM5NSwgLy8gbHVuYXRlIGVwc2lsb25cbiAgXCJcXHUwM2QxXCI6IDB4MUQzQkEsIC8vIHZhcnRoZXRhXG4gIFwiXFx1MDNmMFwiOiAweDFEMzlDLCAvLyB2YXJrYXBwYVxuICBcIlxcdTAzYzZcIjogMHgxRDNDNywgLy8gdmFycGhpXG4gIFwiXFx1MDNmMVwiOiAweDFEMzlELCAvLyB2YXJyaG9cbiAgXCJcXHUwM2Q2XCI6IDB4MUQzQjkgIC8vIHZhcnBpXG59KTtcblxuY29uc3QgYmlzZiA9IE9iamVjdC5mcmVlemUoe1xuICBcIlxcdTAzZjVcIjogMHgxRDNDRiwgLy8gbHVuYXRlIGVwc2lsb25cbiAgXCJcXHUwM2QxXCI6IDB4MUQzRjQsIC8vIHZhcnRoZXRhXG4gIFwiXFx1MDNmMFwiOiAweDFEM0Q2LCAvLyB2YXJrYXBwYVxuICBcIlxcdTAzYzZcIjogMHgxRDQwMSwgLy8gdmFycGhpXG4gIFwiXFx1MDNmMVwiOiAweDFEM0Q3LCAvLyB2YXJyaG9cbiAgXCJcXHUwM2Q2XCI6IDB4MUQzRjMgIC8vIHZhcnBpXG59KTtcblxuLy8gQ29kZSBwb2ludCBvZmZzZXRzIGJlbG93IGFyZSBkZXJpdmVkIGZyb20gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG5jb25zdCBvZmZzZXQgPSBPYmplY3QuZnJlZXplKHtcbiAgdXBwZXJDYXNlTGF0aW46IHsgLy8gQS1aXG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDNCRiB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEM0YzIH0sXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ0MjcgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gc2NyaXB0W2NoXSB8fCAweDFENDVCIH0sXG4gICAgXCJzY3JpcHQtYm9sZFwiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ0OEYgfSxcbiAgICBcImZyYWt0dXJcIjogY2ggPT4gICAgICAgICAgICAgICAgeyByZXR1cm4gZnJha1tjaF0gfHwgMHgxRDRDMyB9LFxuICAgIFwiZnJha3R1ci1ib2xkXCI6IGNoID0+ICAgICAgICAgICB7IHJldHVybiAweDFENTJCIH0sXG4gICAgXCJkb3VibGUtc3RydWNrXCI6IGNoID0+ICAgICAgICAgIHsgcmV0dXJuIGJiYltjaF0gfHwgMHgxRDRGNyB9LFxuICAgIFwic2Fucy1zZXJpZlwiOiBjaCA9PiAgICAgICAgICAgICB7IHJldHVybiAweDFENTVGIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIDB4MUQ1OTMgfSxcbiAgICBcInNhbnMtc2VyaWYtaXRhbGljXCI6IGNoID0+ICAgICAgeyByZXR1cm4gMHgxRDVDNyB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiOiBjaCA9PiB7IHJldHVybiAweDFENjNDIH0sXG4gICAgXCJtb25vc3BhY2VcIjogY2ggPT4gICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ2MkYgfVxuICB9LFxuICBsb3dlckNhc2VMYXRpbjogeyAvLyBhLXpcbiAgICBcIm5vcm1hbFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEM0I5IH0sXG4gICAgXCJpdGFsaWNcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIGNoID09PSBcImhcIiA/IDB4MjBBNiA6IDB4MUQzRUQgfSxcbiAgICBcImJvbGQtaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMHgxRDQyMSB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiBzY3JpcHRbY2hdIHx8IDB4MUQ0NTUgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMHgxRDQ4OSB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiAweDFENEJEIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDB4MUQ1MjUgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gMHgxRDRGMSB9LFxuICAgIFwic2Fucy1zZXJpZlwiOiBjaCA9PiAgICAgICAgICAgICB7IHJldHVybiAweDFENTU5IH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIDB4MUQ1OEQgfSxcbiAgICBcInNhbnMtc2VyaWYtaXRhbGljXCI6IGNoID0+ICAgICAgeyByZXR1cm4gMHgxRDVDMSB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiOiBjaCA9PiB7IHJldHVybiAweDFENUY1IH0sXG4gICAgXCJtb25vc3BhY2VcIjogY2ggPT4gICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ2MjkgfVxuICB9LFxuICB1cHBlckNhc2VHcmVlazogeyAvLyBBLc6pXG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDMxNyB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAweDFEMzUxIH0sXG4gICAgLy8gXFxib2xkc3ltYm9sIGFjdHVhbGx5IHJldHVybnMgdXByaWdodCBib2xkIGZvciB1cHBlckNhc2VHcmVla1xuICAgIFwiYm9sZC1pdGFsaWNcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAweDFEMzE3IH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIC8vIFVuaWNvZGUgaGFzIG5vIGNvZGUgcG9pbnRzIGZvciByZWd1bGFyLXdlaWdodCBzYW4tc2VyaWYgR3JlZWsuIFVzZSBib2xkLlxuICAgIFwic2Fucy1zZXJpZlwiOiBjaCA9PiAgICAgICAgICAgICB7IHJldHVybiAweDFEM0M1IH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIDB4MUQzQzUgfSxcbiAgICBcInNhbnMtc2VyaWYtaXRhbGljXCI6IGNoID0+ICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiOiBjaCA9PiB7IHJldHVybiAweDFEM0ZGIH0sXG4gICAgXCJtb25vc3BhY2VcIjogY2ggPT4gICAgICAgICAgICAgIHsgcmV0dXJuIDAgfVxuICB9LFxuICBsb3dlckNhc2VHcmVlazogeyAvLyDOsS3PiVxuICAgIFwibm9ybWFsXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkXCI6IGNoID0+ICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQzMTEgfSxcbiAgICBcIml0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMHgxRDM0QiB9LFxuICAgIFwiYm9sZC1pdGFsaWNcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiBjaCA9PT0gXCJcXHUwM2Q1XCIgPyAweDFEMzdFIDogMHgxRDM4NSB9LFxuICAgIFwic2NyaXB0XCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzY3JpcHQtYm9sZFwiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXJcIjogY2ggPT4gICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1ci1ib2xkXCI6IGNoID0+ICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJkb3VibGUtc3RydWNrXCI6IGNoID0+ICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICAvLyBVbmljb2RlIGhhcyBubyBjb2RlIHBvaW50cyBmb3IgcmVndWxhci13ZWlnaHQgc2FuLXNlcmlmIEdyZWVrLiBVc2UgYm9sZC5cbiAgICBcInNhbnMtc2VyaWZcIjogY2ggPT4gICAgICAgICAgICAgeyByZXR1cm4gMHgxRDNCRiB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkXCI6IGNoID0+ICAgICAgICB7IHJldHVybiAweDFEM0JGIH0sXG4gICAgXCJzYW5zLXNlcmlmLWl0YWxpY1wiOiBjaCA9PiAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNhbnMtc2VyaWYtYm9sZC1pdGFsaWNcIjogY2ggPT4geyByZXR1cm4gMHgxRDNGOSB9LFxuICAgIFwibW9ub3NwYWNlXCI6IGNoID0+ICAgICAgICAgICAgICB7IHJldHVybiAwIH1cbiAgfSxcbiAgdmFyR3JlZWs6IHsgLy8gXFx2YXJHYW1tYSwgZXRjXG4gICAgXCJub3JtYWxcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImJvbGRcIjogY2ggPT4gICAgICAgICAgICAgICAgICAgeyByZXR1cm4gIGJvbGRbY2hdIHx8IC01MSB9LFxuICAgIFwiaXRhbGljXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkLWl0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgIHsgcmV0dXJuIGJvbGRJdGFsaWNbY2hdIHx8IDB4M0EgfSxcbiAgICBcInNjcmlwdFwiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2NyaXB0LWJvbGRcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyXCI6IGNoID0+ICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImZyYWt0dXItYm9sZFwiOiBjaCA9PiAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZG91YmxlLXN0cnVja1wiOiBjaCA9PiAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzYW5zLXNlcmlmXCI6IGNoID0+ICAgICAgICAgICAgIHsgcmV0dXJuIGJvbGRzZltjaF0gfHwgMHg3NCB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkXCI6IGNoID0+ICAgICAgICB7IHJldHVybiBib2xkc2ZbY2hdIHx8IDB4NzQgfSxcbiAgICBcInNhbnMtc2VyaWYtaXRhbGljXCI6IGNoID0+ICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiOiBjaCA9PiB7IHJldHVybiBiaXNmW2NoXSB8fCAweEFFIH0sXG4gICAgXCJtb25vc3BhY2VcIjogY2ggPT4gICAgICAgICAgICAgIHsgcmV0dXJuIDAgfVxuICB9LFxuICBudW1lcmFsOiB7IC8vIDAtOVxuICAgIFwibm9ybWFsXCI6IGNoID0+ICAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJib2xkXCI6IGNoID0+ICAgICAgICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ3OUUgfSxcbiAgICBcIml0YWxpY1wiOiBjaCA9PiAgICAgICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiYm9sZC1pdGFsaWNcIjogY2ggPT4gICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJzY3JpcHRcIjogY2ggPT4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcInNjcmlwdC1ib2xkXCI6IGNoID0+ICAgICAgICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwiZnJha3R1clwiOiBjaCA9PiAgICAgICAgICAgICAgICB7IHJldHVybiAwIH0sXG4gICAgXCJmcmFrdHVyLWJvbGRcIjogY2ggPT4gICAgICAgICAgIHsgcmV0dXJuIDAgfSxcbiAgICBcImRvdWJsZS1zdHJ1Y2tcIjogY2ggPT4gICAgICAgICAgeyByZXR1cm4gMHgxRDdBOCB9LFxuICAgIFwic2Fucy1zZXJpZlwiOiBjaCA9PiAgICAgICAgICAgICB7IHJldHVybiAweDFEN0IyIH0sXG4gICAgXCJzYW5zLXNlcmlmLWJvbGRcIjogY2ggPT4gICAgICAgIHsgcmV0dXJuIDB4MUQ3QkMgfSxcbiAgICBcInNhbnMtc2VyaWYtaXRhbGljXCI6IGNoID0+ICAgICAgeyByZXR1cm4gMCB9LFxuICAgIFwic2Fucy1zZXJpZi1ib2xkLWl0YWxpY1wiOiBjaCA9PiB7IHJldHVybiAwIH0sXG4gICAgXCJtb25vc3BhY2VcIjogY2ggPT4gICAgICAgICAgICAgIHsgcmV0dXJuIDB4MUQ3QzYgfVxuICB9XG59KTtcblxuY29uc3QgdmFyaWFudENoYXIgPSAoY2gsIHZhcmlhbnQpID0+IHtcbiAgY29uc3QgY29kZVBvaW50ID0gY2guY29kZVBvaW50QXQoMCk7XG4gIGNvbnN0IGJsb2NrID0gMHg0MCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDViXG4gICAgPyBcInVwcGVyQ2FzZUxhdGluXCJcbiAgICA6IDB4NjAgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMHg3YlxuICAgID8gXCJsb3dlckNhc2VMYXRpblwiXG4gICAgOiAoMHgzOTAgIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4M0FBKVxuICAgID8gXCJ1cHBlckNhc2VHcmVla1wiXG4gICAgOiAweDNCMCA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDNDQSB8fCBjaCA9PT0gXCJcXHUwM2Q1XCJcbiAgICA/IFwibG93ZXJDYXNlR3JlZWtcIlxuICAgIDogMHgxRDZFMSA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAweDFENkZDICB8fCBib2xkW2NoXVxuICAgID8gXCJ2YXJHcmVla1wiXG4gICAgOiAoMHgyRiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAgMHgzQSlcbiAgICA/IFwibnVtZXJhbFwiXG4gICAgOiBcIm90aGVyXCI7XG4gIHJldHVybiBibG9jayA9PT0gXCJvdGhlclwiXG4gICAgPyBjaFxuICAgIDogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50ICsgb2Zmc2V0W2Jsb2NrXVt2YXJpYW50XShjaCkpXG59O1xuXG5jb25zdCBzbWFsbENhcHMgPSBPYmplY3QuZnJlZXplKHtcbiAgYTogXCLhtIBcIixcbiAgYjogXCLKmVwiLFxuICBjOiBcIuG0hFwiLFxuICBkOiBcIuG0hVwiLFxuICBlOiBcIuG0h1wiLFxuICBmOiBcIuqcsFwiLFxuICBnOiBcIsmiXCIsXG4gIGg6IFwiypxcIixcbiAgaTogXCLJqlwiLFxuICBqOiBcIuG0ilwiLFxuICBrOiBcIuG0i1wiLFxuICBsOiBcIsqfXCIsXG4gIG06IFwi4bSNXCIsXG4gIG46IFwiybRcIixcbiAgbzogXCLhtI9cIixcbiAgcDogXCLhtJhcIixcbiAgcTogXCLHq1wiLFxuICByOiBcIsqAXCIsXG4gIHM6IFwic1wiLFxuICB0OiBcIuG0m1wiLFxuICB1OiBcIuG0nFwiLFxuICB2OiBcIuG0oFwiLFxuICB3OiBcIuG0oVwiLFxuICB4OiBcInhcIixcbiAgeTogXCLKj1wiLFxuICB6OiBcIuG0olwiXG59KTtcblxuLy8gXCJtYXRob3JkXCIgYW5kIFwidGV4dG9yZFwiIFBhcnNlTm9kZXMgY3JlYXRlZCBpbiBQYXJzZXIuanMgZnJvbSBzeW1ib2wgR3JvdXBzIGluXG4vLyBzcmMvc3ltYm9scy5qcy5cblxuY29uc3QgbnVtYmVyUmVnRXggPSAvXlxcZCg/OltcXGQsLl0qXFxkKT8kLztcbmNvbnN0IGxhdGluUmVnRXggPSAvW0EtQmEtel0vO1xuY29uc3QgcHJpbWVzID0gbmV3IFNldChbXCJcXFxccHJpbWVcIiwgXCJcXFxcZHByaW1lXCIsIFwiXFxcXHRycHJpbWVcIiwgXCJcXFxccXByaW1lXCIsXG4gIFwiXFxcXGJhY2twcmltZVwiLCBcIlxcXFxiYWNrZHByaW1lXCIsIFwiXFxcXGJhY2t0cnByaW1lXCJdKTtcblxuY29uc3QgaXRhbGljTnVtYmVyID0gKHRleHQsIHZhcmlhbnQsIHRhZykgPT4ge1xuICBjb25zdCBtbiA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKHRhZywgW3RleHRdKTtcbiAgY29uc3Qgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXN0eWxlXCIsIFttbl0pO1xuICB3cmFwcGVyLnN0eWxlW1wiZm9udC1zdHlsZVwiXSA9IFwiaXRhbGljXCI7XG4gIHdyYXBwZXIuc3R5bGVbXCJmb250LWZhbWlseVwiXSA9IFwiQ2FtYnJpYSwgJ1RpbWVzIE5ldyBSb21hbicsIHNlcmlmXCI7XG4gIGlmICh2YXJpYW50ID09PSBcImJvbGQtaXRhbGljXCIpIHsgd3JhcHBlci5zdHlsZVtcImZvbnQtd2VpZ2h0XCJdID0gXCJib2xkXCI7IH1cbiAgcmV0dXJuIHdyYXBwZXJcbn07XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcIm1hdGhvcmRcIixcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0ID0gbWFrZVRleHQoZ3JvdXAudGV4dCwgZ3JvdXAubW9kZSwgc3R5bGUpO1xuICAgIGNvbnN0IGNvZGVQb2ludCA9IHRleHQudGV4dC5jb2RlUG9pbnRBdCgwKTtcbiAgICAvLyBUZXN0IGZvciB1cHBlci1jYXNlIEdyZWVrXG4gICAgY29uc3QgZGVmYXVsdFZhcmlhbnQgPSAoMHgwMzkwIDwgY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDB4MDNhYSkgPyBcIm5vcm1hbFwiIDogXCJpdGFsaWNcIjtcbiAgICBjb25zdCB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgc3R5bGUpIHx8IGRlZmF1bHRWYXJpYW50O1xuICAgIGlmICh2YXJpYW50ID09PSBcInNjcmlwdFwiKSB7XG4gICAgICB0ZXh0LnRleHQgPSB2YXJpYW50Q2hhcih0ZXh0LnRleHQsIHZhcmlhbnQpO1xuICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW3RleHRdLCBbc3R5bGUuZm9udF0pXG4gICAgfSBlbHNlIGlmICh2YXJpYW50ICE9PSBcIml0YWxpY1wiKSB7XG4gICAgICB0ZXh0LnRleHQgPSB2YXJpYW50Q2hhcih0ZXh0LnRleHQsIHZhcmlhbnQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW3RleHRdKTtcbiAgICAvLyBUT0RPOiBIYW5kbGUgVSsxRDQ5QyAtIFUrMUQ0Q0YgcGVyIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL2NoYXJ0cy9QREYvVTFENDAwLnBkZlxuICAgIGlmICh2YXJpYW50ID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGh2YXJpYW50XCIsIFwibm9ybWFsXCIpO1xuICAgICAgaWYgKHRleHQudGV4dC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gQSBGaXJlZm94IGJ1ZyB3aWxsIGFwcGx5IHNwYWNpbmcgaGVyZSwgYnV0IHRoZXJlIHNob3VsZCBiZSBub25lLiBGaXggaXQuXG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1wYWRkZWRcIiwgW25vZGVdKTtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsc3BhY2VcIiwgXCIwXCIpO1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcInJzcGFjZVwiLCBcIjBcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlXG4gIH1cbn0pO1xuXG5kZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHtcbiAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgbGV0IGNoID0gZ3JvdXAudGV4dDtcbiAgICBjb25zdCBjb2RlUG9pbnQgPSBjaC5jb2RlUG9pbnRBdCgwKTtcbiAgICBpZiAoc3R5bGUuZm9udEZhbWlseSA9PT0gXCJ0ZXh0c2NcIikge1xuICAgICAgLy8gQ29udmVydCBzbWFsbCBsYXRpbiBsZXR0ZXJzIHRvIHNtYWxsIGNhcHMuXG4gICAgICBpZiAoOTYgPCBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDwgMTIzKSB7XG4gICAgICAgIGNoID0gc21hbGxDYXBzW2NoXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IG1ha2VUZXh0KGNoLCBncm91cC5tb2RlLCBzdHlsZSk7XG4gICAgY29uc3QgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIHN0eWxlKSB8fCBcIm5vcm1hbFwiO1xuXG4gICAgbGV0IG5vZGU7XG4gICAgaWYgKG51bWJlclJlZ0V4LnRlc3QoZ3JvdXAudGV4dCkpIHtcbiAgICAgIGNvbnN0IHRhZyA9IGdyb3VwLm1vZGUgPT09IFwidGV4dFwiID8gXCJtdGV4dFwiIDogXCJtblwiO1xuICAgICAgaWYgKHZhcmlhbnQgPT09IFwiaXRhbGljXCIgfHwgdmFyaWFudCA9PT0gXCJib2xkLWl0YWxpY1wiKSB7XG4gICAgICAgIHJldHVybiBpdGFsaWNOdW1iZXIodGV4dCwgdmFyaWFudCwgdGFnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHZhcmlhbnQgIT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICB0ZXh0LnRleHQgPSB0ZXh0LnRleHQuc3BsaXQoXCJcIikubWFwKGMgPT4gdmFyaWFudENoYXIoYywgdmFyaWFudCkpLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKHRhZywgW3RleHRdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICBpZiAodmFyaWFudCAhPT0gXCJub3JtYWxcIikge1xuICAgICAgICB0ZXh0LnRleHQgPSB2YXJpYW50Q2hhcih0ZXh0LnRleHQsIHZhcmlhbnQpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgW3RleHRdKTtcbiAgICB9IGVsc2UgaWYgKHByaW1lcy5oYXMoZ3JvdXAudGV4dCkpIHtcbiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIFt0ZXh0XSk7XG4gICAgICAvLyBUT0RPOiBJZi93aGVuIENocm9taXVtIHVzZXMgc3N0eSB2YXJpYW50IGZvciBwcmltZSwgcmVtb3ZlIHRoZSBuZXh0IGxpbmUuXG4gICAgICBub2RlLmNsYXNzZXMucHVzaChcInRtbC1wcmltZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3JpZ1RleHQgPSB0ZXh0LnRleHQ7XG4gICAgICBpZiAodmFyaWFudCAhPT0gXCJpdGFsaWNcIikge1xuICAgICAgICB0ZXh0LnRleHQgPSB2YXJpYW50Q2hhcih0ZXh0LnRleHQsIHZhcmlhbnQpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibWlcIiwgW3RleHRdKTtcbiAgICAgIGlmICh0ZXh0LnRleHQgPT09IG9yaWdUZXh0ICYmIGxhdGluUmVnRXgudGVzdChvcmlnVGV4dCkpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCBcIml0YWxpY1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbi8vIEEgbWFwIG9mIENTUy1iYXNlZCBzcGFjaW5nIGZ1bmN0aW9ucyB0byB0aGVpciBDU1MgY2xhc3MuXG5jb25zdCBjc3NTcGFjZSA9IHtcbiAgXCJcXFxcbm9icmVha1wiOiBcIm5vYnJlYWtcIixcbiAgXCJcXFxcYWxsb3dicmVha1wiOiBcImFsbG93YnJlYWtcIlxufTtcblxuLy8gQSBsb29rdXAgdGFibGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzcGFjaW5nIGZ1bmN0aW9uL3N5bWJvbCBzaG91bGQgYmVcbi8vIHRyZWF0ZWQgbGlrZSBhIHJlZ3VsYXIgc3BhY2UgY2hhcmFjdGVyLiAgSWYgYSBzeW1ib2wgb3IgY29tbWFuZCBpcyBhIGtleVxuLy8gaW4gdGhpcyB0YWJsZSwgdGhlbiBpdCBzaG91bGQgYmUgYSByZWd1bGFyIHNwYWNlIGNoYXJhY3Rlci4gIEZ1cnRoZXJtb3JlLFxuLy8gdGhlIGFzc29jaWF0ZWQgdmFsdWUgbWF5IGhhdmUgYSBgY2xhc3NOYW1lYCBzcGVjaWZ5aW5nIGFuIGV4dHJhIENTUyBjbGFzc1xuLy8gdG8gYWRkIHRvIHRoZSBjcmVhdGVkIGBzcGFuYC5cbmNvbnN0IHJlZ3VsYXJTcGFjZSA9IHtcbiAgXCIgXCI6IHt9LFxuICBcIlxcXFwgXCI6IHt9LFxuICBcIn5cIjoge1xuICAgIGNsYXNzTmFtZTogXCJub2JyZWFrXCJcbiAgfSxcbiAgXCJcXFxcc3BhY2VcIjoge30sXG4gIFwiXFxcXG5vYnJlYWtzcGFjZVwiOiB7XG4gICAgY2xhc3NOYW1lOiBcIm5vYnJlYWtcIlxuICB9XG59O1xuXG4vLyBQYXJzZU5vZGU8XCJzcGFjaW5nXCI+IGNyZWF0ZWQgaW4gUGFyc2VyLmpzIGZyb20gdGhlIFwic3BhY2luZ1wiIHN5bWJvbCBHcm91cHMgaW5cbi8vIHNyYy9zeW1ib2xzLmpzLlxuZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7XG4gIHR5cGU6IFwic3BhY2luZ1wiLFxuICBtYXRobWxCdWlsZGVyKGdyb3VwLCBzdHlsZSkge1xuICAgIGxldCBub2RlO1xuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWd1bGFyU3BhY2UsIGdyb3VwLnRleHQpKSB7XG4gICAgICAvLyBGaXJlZm94IGRvZXMgbm90IHJlbmRlciBhIHNwYWNlIGluIGEgPG10ZXh0PiA8L210ZXh0Pi4gU28gd3JpdGUgYSBuby1icmVhayBzcGFjZS5cbiAgICAgIC8vIFRPRE86IElmIEZpcmVmb3ggZml4ZXMgdGhhdCBidWcsIHVuY29tbWVudCB0aGUgbmV4dCBsaW5lIGFuZCB3cml0ZSBjaCBpbnRvIHRoZSBub2RlLlxuICAgICAgLy9jb25zdCBjaCA9IChyZWd1bGFyU3BhY2VbZ3JvdXAudGV4dF0uY2xhc3NOYW1lID09PSBcIm5vYnJlYWtcIikgPyBcIlxcdTAwYTBcIiA6IFwiIFwiXG4gICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUwMGEwXCIpXSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3NzU3BhY2UsIGdyb3VwLnRleHQpKSB7XG4gICAgICAvLyBNYXRoTUwgMy4wIGNhbGxzIGZvciBub2JyZWFrIHRvIG9jY3VyIGluIGFuIDxtbz4sIG5vdCBhbiA8bXRleHQ+XG4gICAgICAvLyBSZWY6IGh0dHBzOi8vd3d3LnczLm9yZy9NYXRoL2RyYWZ0LXNwZWMvbWF0aG1sLmh0bWwjY2hhcHRlcjNfcHJlc20ubGJhdHRyc1xuICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW9cIik7XG4gICAgICBpZiAoZ3JvdXAudGV4dCA9PT0gXCJcXFxcbm9icmVha1wiKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibGluZWJyZWFrXCIsIFwibm9icmVha1wiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFVua25vd24gdHlwZSBvZiBzcGFjZSBcIiR7Z3JvdXAudGV4dH1cImApXG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGVcbiAgfVxufSk7XG5cbmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoe1xuICB0eXBlOiBcInRhZ1wiXG59KTtcblxuLy8gRm9yIGEgXFx0YWcsIHRoZSB3b3JrIHVzdWFsbHkgZG9uZSBpbiBhIG1hdGhtbEJ1aWxkZXIgaXMgaW5zdGVhZCBkb25lIGluIGJ1aWxkTWF0aE1MLmpzLlxuLy8gVGhhdCB3YXksIGEgXFx0YWcgY2FuIGJlIHB1bGxlZCBvdXQgb2YgdGhlIHBhcnNlIHRyZWUgYW5kIHdyYXBwZWQgYXJvdW5kIHRoZSBvdXRlciBub2RlLlxuXG4vLyBOb24tbWF0aHkgdGV4dCwgcG9zc2libHkgaW4gYSBmb250XG5jb25zdCB0ZXh0Rm9udEZhbWlsaWVzID0ge1xuICBcIlxcXFx0ZXh0XCI6IHVuZGVmaW5lZCxcbiAgXCJcXFxcdGV4dHJtXCI6IFwidGV4dHJtXCIsXG4gIFwiXFxcXHRleHRzZlwiOiBcInRleHRzZlwiLFxuICBcIlxcXFx0ZXh0dHRcIjogXCJ0ZXh0dHRcIixcbiAgXCJcXFxcdGV4dG5vcm1hbFwiOiBcInRleHRybVwiLFxuICBcIlxcXFx0ZXh0c2NcIjogXCJ0ZXh0c2NcIiAgICAgIC8vIHNtYWxsIGNhcHNcbn07XG5cbmNvbnN0IHRleHRGb250V2VpZ2h0cyA9IHtcbiAgXCJcXFxcdGV4dGJmXCI6IFwidGV4dGJmXCIsXG4gIFwiXFxcXHRleHRtZFwiOiBcInRleHRtZFwiXG59O1xuXG5jb25zdCB0ZXh0Rm9udFNoYXBlcyA9IHtcbiAgXCJcXFxcdGV4dGl0XCI6IFwidGV4dGl0XCIsXG4gIFwiXFxcXHRleHR1cFwiOiBcInRleHR1cFwiXG59O1xuXG5jb25zdCBzdHlsZVdpdGhGb250ID0gKGdyb3VwLCBzdHlsZSkgPT4ge1xuICBjb25zdCBmb250ID0gZ3JvdXAuZm9udDtcbiAgLy8gQ2hlY2tzIGlmIHRoZSBhcmd1bWVudCBpcyBhIGZvbnQgZmFtaWx5IG9yIGEgZm9udCBzdHlsZS5cbiAgaWYgKCFmb250KSB7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9IGVsc2UgaWYgKHRleHRGb250RmFtaWxpZXNbZm9udF0pIHtcbiAgICByZXR1cm4gc3R5bGUud2l0aFRleHRGb250RmFtaWx5KHRleHRGb250RmFtaWxpZXNbZm9udF0pO1xuICB9IGVsc2UgaWYgKHRleHRGb250V2VpZ2h0c1tmb250XSkge1xuICAgIHJldHVybiBzdHlsZS53aXRoVGV4dEZvbnRXZWlnaHQodGV4dEZvbnRXZWlnaHRzW2ZvbnRdKTtcbiAgfSBlbHNlIGlmIChmb250ID09PSBcIlxcXFxlbXBoXCIpIHtcbiAgICByZXR1cm4gc3R5bGUuZm9udFNoYXBlID09PSBcInRleHRpdFwiXG4gICAgICA/IHN0eWxlLndpdGhUZXh0Rm9udFNoYXBlKFwidGV4dHVwXCIpXG4gICAgICA6IHN0eWxlLndpdGhUZXh0Rm9udFNoYXBlKFwidGV4dGl0XCIpXG4gIH1cbiAgcmV0dXJuIHN0eWxlLndpdGhUZXh0Rm9udFNoYXBlKHRleHRGb250U2hhcGVzW2ZvbnRdKVxufTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInRleHRcIixcbiAgbmFtZXM6IFtcbiAgICAvLyBGb250IGZhbWlsaWVzXG4gICAgXCJcXFxcdGV4dFwiLFxuICAgIFwiXFxcXHRleHRybVwiLFxuICAgIFwiXFxcXHRleHRzZlwiLFxuICAgIFwiXFxcXHRleHR0dFwiLFxuICAgIFwiXFxcXHRleHRub3JtYWxcIixcbiAgICBcIlxcXFx0ZXh0c2NcIixcbiAgICAvLyBGb250IHdlaWdodHNcbiAgICBcIlxcXFx0ZXh0YmZcIixcbiAgICBcIlxcXFx0ZXh0bWRcIixcbiAgICAvLyBGb250IFNoYXBlc1xuICAgIFwiXFxcXHRleHRpdFwiLFxuICAgIFwiXFxcXHRleHR1cFwiLFxuICAgIFwiXFxcXGVtcGhcIlxuICBdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcInRleHRcIl0sXG4gICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKHsgcGFyc2VyLCBmdW5jTmFtZSB9LCBhcmdzKSB7XG4gICAgY29uc3QgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgbW9kZTogcGFyc2VyLm1vZGUsXG4gICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KSxcbiAgICAgIGZvbnQ6IGZ1bmNOYW1lXG4gICAgfTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlV2l0aEZvbnQoZ3JvdXAsIHN0eWxlKTtcbiAgICBjb25zdCBtcm93ID0gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG5ld1N0eWxlKTtcbiAgICByZXR1cm4gY29uc29saWRhdGVUZXh0KG1yb3cpXG4gIH1cbn0pO1xuXG4vLyBcXHZjZW50ZXI6ICBWZXJ0aWNhbGx5IGNlbnRlciB0aGUgYXJndW1lbnQgZ3JvdXAgb24gdGhlIG1hdGggYXhpcy5cblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInZjZW50ZXJcIixcbiAgbmFtZXM6IFtcIlxcXFx2Y2VudGVyXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYXJnVHlwZXM6IFtcIm9yaWdpbmFsXCJdLFxuICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIoeyBwYXJzZXIgfSwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInZjZW50ZXJcIixcbiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLFxuICAgICAgYm9keTogYXJnc1swXVxuICAgIH07XG4gIH0sXG4gIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIHN0eWxlKSB7XG4gICAgLy8gVXNlIGEgbWF0aCB0YWJsZSB0byBjcmVhdGUgdmVydGljYWxseSBjZW50ZXJlZCBjb250ZW50LlxuICAgIGNvbnN0IG10ZCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRkXCIsIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgc3R5bGUpXSk7XG4gICAgbXRkLnN0eWxlLnBhZGRpbmcgPSBcIjBcIjtcbiAgICBjb25zdCBtdHIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm10clwiLCBbbXRkXSk7XG4gICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRhYmxlXCIsIFttdHJdKVxuICB9XG59KTtcblxuZGVmaW5lRnVuY3Rpb24oe1xuICB0eXBlOiBcInZlcmJcIixcbiAgbmFtZXM6IFtcIlxcXFx2ZXJiXCJdLFxuICBwcm9wczoge1xuICAgIG51bUFyZ3M6IDAsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZVxuICB9LFxuICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpIHtcbiAgICAvLyBcXHZlcmIgYW5kIFxcdmVyYiogYXJlIGRlYWx0IHdpdGggZGlyZWN0bHkgaW4gUGFyc2VyLmpzLlxuICAgIC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdCdzIGJlY2F1c2Ugb2YgYSBmYWlsdXJlIHRvIG1hdGNoIHRoZSB0d28gZGVsaW1pdGVyc1xuICAgIC8vIGluIHRoZSByZWdleCBpbiBMZXhlci5qcy4gIExhVGVYIHJhaXNlcyB0aGUgZm9sbG93aW5nIGVycm9yIHdoZW4gXFx2ZXJiIGlzXG4gICAgLy8gdGVybWluYXRlZCBieSBlbmQgb2YgbGluZSAob3IgZmlsZSkuXG4gICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcdmVyYiBlbmRlZCBieSBlbmQgb2YgbGluZSBpbnN0ZWFkIG9mIG1hdGNoaW5nIGRlbGltaXRlclwiKTtcbiAgfSxcbiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUobWFrZVZlcmIoZ3JvdXApKTtcbiAgICBjb25zdCBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtdGV4dFwiLCBbdGV4dF0pO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgXCJtb25vc3BhY2VcIik7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIHZlcmIgZ3JvdXAgaW50byBib2R5IHN0cmluZy5cbiAqXG4gKiBcXHZlcmIqIHJlcGxhY2VzIGVhY2ggc3BhY2Ugd2l0aCBhbiBvcGVuIGJveCBcXHUyNDIzXG4gKiBcXHZlcmIgcmVwbGFjZXMgZWFjaCBzcGFjZSB3aXRoIGEgbm8tYnJlYWsgc3BhY2UgXFx4QTBcbiAqL1xuY29uc3QgbWFrZVZlcmIgPSAoZ3JvdXApID0+IGdyb3VwLmJvZHkucmVwbGFjZSgvIC9nLCBncm91cC5zdGFyID8gXCJcXHUyNDIzXCIgOiBcIlxceEEwXCIpO1xuXG4vKiogSW5jbHVkZSB0aGlzIHRvIGVuc3VyZSB0aGF0IGFsbCBmdW5jdGlvbnMgYXJlIGRlZmluZWQuICovXG5cbmNvbnN0IGZ1bmN0aW9ucyA9IF9mdW5jdGlvbnM7XG5cbi8qKlxuICogVGhlIExleGVyIGNsYXNzIGhhbmRsZXMgdG9rZW5pemluZyB0aGUgaW5wdXQgaW4gdmFyaW91cyB3YXlzLiBTaW5jZSBvdXJcbiAqIHBhcnNlciBleHBlY3RzIHVzIHRvIGJlIGFibGUgdG8gYmFja3RyYWNrLCB0aGUgbGV4ZXIgYWxsb3dzIGxleGluZyBmcm9tIGFueVxuICogZ2l2ZW4gc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogSXRzIG1haW4gZXhwb3NlZCBmdW5jdGlvbiBpcyB0aGUgYGxleGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcG9zaXRpb24gdG9cbiAqIGxleCBmcm9tIGFuZCBhIHR5cGUgb2YgdG9rZW4gdG8gbGV4LiBJdCBkZWZlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGBfaW5uZXJMZXhgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgdmFyaW91cyBgX2lubmVyTGV4YCBmdW5jdGlvbnMgcGVyZm9ybSB0aGUgYWN0dWFsIGxleGluZyBvZiBkaWZmZXJlbnRcbiAqIGtpbmRzLlxuICovXG5cblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IHR3byBncm91cHNcbiAqIC0gZG9lcyBub3QgbWF0Y2ggYW55IGNvbnRyb2wgY2hhcmFjdGVyIFxceDAwLVxceDFmIGV4Y2VwdCB3aGl0ZXNwYWNlXG4gKiAtIGRvZXMgbm90IG1hdGNoIGEgYmFyZSBiYWNrc2xhc2hcbiAqIC0gbWF0Y2hlcyBhbnkgQVNDSUkgY2hhcmFjdGVyIGV4Y2VwdCB0aG9zZSBqdXN0IG1lbnRpb25lZFxuICogLSBkb2VzIG5vdCBtYXRjaCB0aGUgQk1QIHByaXZhdGUgdXNlIGFyZWEgXFx1RTAwMC1cXHVGOEZGXG4gKiAtIGRvZXMgbm90IG1hdGNoIGJhcmUgc3Vycm9nYXRlIGNvZGUgdW5pdHNcbiAqIC0gbWF0Y2hlcyBhbnkgQk1QIGNoYXJhY3RlciBleGNlcHQgZm9yIHRob3NlIGp1c3QgZGVzY3JpYmVkXG4gKiAtIG1hdGNoZXMgYW55IHZhbGlkIFVuaWNvZGUgc3Vycm9nYXRlIHBhaXJcbiAqIC0gbWF0aGNoZXMgbnVtZXJhbHNcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAqIC0gbWF0Y2hlcyBhIGJhY2tzbGFzaCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBsZXR0ZXJzIHRoZW4gd2hpdGVzcGFjZVxuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBCTVAgY2hhcmFjdGVyXG4gKiBDYXB0dXJpbmcgZ3JvdXBzOlxuICogICBbMV0gcmVndWxhciB3aGl0ZXNwYWNlXG4gKiAgIFsyXSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgd2hpdGVzcGFjZVxuICogICBbM10gYW55dGhpbmcgZWxzZSwgd2hpY2ggbWF5IGluY2x1ZGU6XG4gKiAgICAgWzRdIGxlZnQgY2hhcmFjdGVyIG9mIFxcdmVyYipcbiAqICAgICBbNV0gbGVmdCBjaGFyYWN0ZXIgb2YgXFx2ZXJiXG4gKiAgICAgWzZdIGJhY2tzbGFzaCBmb2xsb3dlZCBieSB3b3JkLCBleGNsdWRpbmcgYW55IHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAqIEp1c3QgYmVjYXVzZSB0aGUgTGV4ZXIgbWF0Y2hlcyBzb21ldGhpbmcgZG9lc24ndCBtZWFuIGl0J3MgdmFsaWQgaW5wdXQ6XG4gKiBJZiB0aGVyZSBpcyBubyBtYXRjaGluZyBmdW5jdGlvbiBvciBzeW1ib2wgZGVmaW5pdGlvbiwgdGhlIFBhcnNlciB3aWxsXG4gKiBzdGlsbCByZWplY3QgdGhlIGlucHV0LlxuICovXG5jb25zdCBzcGFjZVJlZ2V4U3RyaW5nID0gXCJbIFxcclxcblxcdF1cIjtcbmNvbnN0IGNvbnRyb2xXb3JkUmVnZXhTdHJpbmcgPSBcIlxcXFxcXFxcW2EtekEtWkBdK1wiO1xuY29uc3QgY29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nID0gXCJcXFxcXFxcXFteXFx1RDgwMC1cXHVERkZGXVwiO1xuY29uc3QgY29udHJvbFdvcmRXaGl0ZXNwYWNlUmVnZXhTdHJpbmcgPSBgKCR7Y29udHJvbFdvcmRSZWdleFN0cmluZ30pJHtzcGFjZVJlZ2V4U3RyaW5nfSpgO1xuY29uc3QgY29udHJvbFNwYWNlUmVnZXhTdHJpbmcgPSBcIlxcXFxcXFxcKFxcbnxbIFxcclxcdF0rXFxuPylbIFxcclxcdF0qXCI7XG5jb25zdCBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgPSBcIltcXHUwMzAwLVxcdTAzNmZdXCI7XG5jb25zdCBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtzRW5kUmVnZXggPSBuZXcgUmVnRXhwKGAke2NvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZ30rJGApO1xuY29uc3QgdG9rZW5SZWdleFN0cmluZyA9XG4gIGAoJHtzcGFjZVJlZ2V4U3RyaW5nfSspfGAgKyAvLyB3aGl0ZXNwYWNlXG4gIGAke2NvbnRyb2xTcGFjZVJlZ2V4U3RyaW5nfXxgICsgIC8vIHdoaXRlc3BhY2VcbiAgXCIoWyEtXFxcXFtcXFxcXS1cXHUyMDI3XFx1MjAyQS1cXHVEN0ZGXFx1RjkwMC1cXHVGRkZGXVwiICsgLy8gc2luZ2xlIGNvZGVwb2ludFxuICBgJHtjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmd9KmAgKyAvLyAuLi5wbHVzIGFjY2VudHNcbiAgXCJ8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiICsgLy8gc3Vycm9nYXRlIHBhaXJcbiAgYCR7Y29tYmluaW5nRGlhY3JpdGljYWxNYXJrU3RyaW5nfSpgICsgLy8gLi4ucGx1cyBhY2NlbnRzXG4gIFwifFxcXFxcXFxcdmVyYlxcXFwqKFteXSkuKj9cXFxcNFwiICsgLy8gXFx2ZXJiKlxuICBcInxcXFxcXFxcXHZlcmIoW14qYS16QS1aXSkuKj9cXFxcNVwiICsgLy8gXFx2ZXJiIHVuc3RhcnJlZFxuICBgfCR7Y29udHJvbFdvcmRXaGl0ZXNwYWNlUmVnZXhTdHJpbmd9YCArIC8vIFxcbWFjcm9OYW1lICsgc3BhY2VzXG4gIGB8JHtjb250cm9sU3ltYm9sUmVnZXhTdHJpbmd9KWA7IC8vIFxcXFwsIFxcJywgZXRjLlxuXG4vKiogTWFpbiBMZXhlciBjbGFzcyAqL1xuY2xhc3MgTGV4ZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MpIHtcbiAgICAvLyBTZXBhcmF0ZSBhY2NlbnRzIGZyb20gY2hhcmFjdGVyc1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy50b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cCh0b2tlblJlZ2V4U3RyaW5nLCAnZycpO1xuICAgIC8vIENhdGVnb3J5IGNvZGVzLiBUaGUgbGV4ZXIgb25seSBzdXBwb3J0cyBjb21tZW50IGNoYXJhY3RlcnMgKDE0KSBmb3Igbm93LlxuICAgIC8vIE1hY3JvRXhwYW5kZXIgYWRkaXRpb25hbGx5IGRpc3Rpbmd1aXNoZXMgYWN0aXZlICgxMykuXG4gICAgdGhpcy5jYXRjb2RlcyA9IHtcbiAgICAgIFwiJVwiOiAxNCwgLy8gY29tbWVudCBjaGFyYWN0ZXJcbiAgICAgIFwiflwiOiAxMyAgLy8gYWN0aXZlIGNoYXJhY3RlclxuICAgIH07XG4gIH1cblxuICBzZXRDYXRjb2RlKGNoYXIsIGNvZGUpIHtcbiAgICB0aGlzLmNhdGNvZGVzW2NoYXJdID0gY29kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGxleGVzIGEgc2luZ2xlIHRva2VuLlxuICAgKi9cbiAgbGV4KCkge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pbnB1dDtcbiAgICBjb25zdCBwb3MgPSB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4O1xuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ldyBUb2tlbihcIkVPRlwiLCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCBwb3MpKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLnRva2VuUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmluZGV4ICE9PSBwb3MpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBjaGFyYWN0ZXI6ICcke2lucHV0W3Bvc119J2AsXG4gICAgICAgIG5ldyBUb2tlbihpbnB1dFtwb3NdLCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCBwb3MgKyAxKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBtYXRjaFs2XSB8fCBtYXRjaFszXSB8fCAobWF0Y2hbMl0gPyBcIlxcXFwgXCIgOiBcIiBcIik7XG5cbiAgICBpZiAodGhpcy5jYXRjb2Rlc1t0ZXh0XSA9PT0gMTQpIHtcbiAgICAgIC8vIGNvbW1lbnQgY2hhcmFjdGVyXG4gICAgICBjb25zdCBubEluZGV4ID0gaW5wdXQuaW5kZXhPZihcIlxcblwiLCB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4KTtcbiAgICAgIGlmIChubEluZGV4ID09PSAtMSkge1xuICAgICAgICB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4ID0gaW5wdXQubGVuZ3RoOyAvLyBFT0ZcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCIlIGNvbW1lbnQgaGFzIG5vIHRlcm1pbmF0aW5nIG5ld2xpbmU7IExhVGVYIHdvdWxkIFwiICtcbiAgICAgICAgICAgICAgXCJmYWlsIGJlY2F1c2Ugb2YgY29tbWVudGluZyB0aGUgZW5kIG9mIG1hdGggbW9kZVwiKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4ID0gbmxJbmRleCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYE5hbWVzcGFjZWAgcmVmZXJzIHRvIGEgc3BhY2Ugb2YgbmFtZWFibGUgdGhpbmdzIGxpa2UgbWFjcm9zIG9yIGxlbmd0aHMsXG4gKiB3aGljaCBjYW4gYmUgYHNldGAgZWl0aGVyIGdsb2JhbGx5IG9yIGxvY2FsIHRvIGEgbmVzdGVkIGdyb3VwLCB1c2luZyBhblxuICogdW5kbyBzdGFjayBzaW1pbGFyIHRvIGhvdyBUZVggaW1wbGVtZW50cyB0aGlzIGZ1bmN0aW9uYWxpdHkuXG4gKiBQZXJmb3JtYW5jZS13aXNlLCBgZ2V0YCBhbmQgbG9jYWwgYHNldGAgdGFrZSBjb25zdGFudCB0aW1lLCB3aGlsZSBnbG9iYWxcbiAqIGBzZXRgIHRha2VzIHRpbWUgcHJvcG9ydGlvbmFsIHRvIHRoZSBkZXB0aCBvZiBncm91cCBuZXN0aW5nLlxuICovXG5cblxuY2xhc3MgTmFtZXNwYWNlIHtcbiAgLyoqXG4gICAqIEJvdGggYXJndW1lbnRzIGFyZSBvcHRpb25hbC4gIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhbiBvYmplY3Qgb2ZcbiAgICogYnVpbHQtaW4gbWFwcGluZ3Mgd2hpY2ggbmV2ZXIgY2hhbmdlLiAgVGhlIHNlY29uZCBhcmd1bWVudCBpcyBhbiBvYmplY3RcbiAgICogb2YgaW5pdGlhbCAoZ2xvYmFsLWxldmVsKSBtYXBwaW5ncywgd2hpY2ggd2lsbCBjb25zdGFudGx5IGNoYW5nZVxuICAgKiBhY2NvcmRpbmcgdG8gYW55IGdsb2JhbC90b3AtbGV2ZWwgYHNldGBzIGRvbmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihidWlsdGlucyA9IHt9LCBnbG9iYWxNYWNyb3MgPSB7fSkge1xuICAgIHRoaXMuY3VycmVudCA9IGdsb2JhbE1hY3JvcztcbiAgICB0aGlzLmJ1aWx0aW5zID0gYnVpbHRpbnM7XG4gICAgdGhpcy51bmRlZlN0YWNrID0gW107XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgbmVzdGVkIGdyb3VwLCBhZmZlY3RpbmcgZnV0dXJlIGxvY2FsIGBzZXRgcy5cbiAgICovXG4gIGJlZ2luR3JvdXAoKSB7XG4gICAgdGhpcy51bmRlZlN0YWNrLnB1c2goe30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuZCBjdXJyZW50IG5lc3RlZCBncm91cCwgcmVzdG9yaW5nIHZhbHVlcyBiZWZvcmUgdGhlIGdyb3VwIGJlZ2FuLlxuICAgKi9cbiAgZW5kR3JvdXAoKSB7XG4gICAgaWYgKHRoaXMudW5kZWZTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICBcIlVuYmFsYW5jZWQgbmFtZXNwYWNlIGRlc3RydWN0aW9uOiBhdHRlbXB0IFwiICtcbiAgICAgICAgICBcInRvIHBvcCBnbG9iYWwgbmFtZXNwYWNlOyBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWdcIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgdW5kZWZzID0gdGhpcy51bmRlZlN0YWNrLnBvcCgpO1xuICAgIGZvciAoY29uc3QgdW5kZWYgaW4gdW5kZWZzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHVuZGVmcywgdW5kZWYgKSkge1xuICAgICAgICBpZiAodW5kZWZzW3VuZGVmXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuY3VycmVudFt1bmRlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50W3VuZGVmXSA9IHVuZGVmc1t1bmRlZl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IHdoZXRoZXIgYG5hbWVgIGhhcyBhIGRlZmluaXRpb24uICBFcXVpdmFsZW50IHRvXG4gICAqIGBnZXQobmFtZSkgIT0gbnVsbGAuXG4gICAqL1xuICBoYXMobmFtZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJyZW50LCBuYW1lICkgfHxcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5idWlsdGlucywgbmFtZSApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIG5hbWUsIG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgKlxuICAgKiBOb3RlOiBEbyBub3QgdXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pKWAgdG8gZGV0ZWN0IHdoZXRoZXIgYSBtYWNyb1xuICAgKiBpcyBkZWZpbmVkLCBhcyB0aGUgZGVmaW5pdGlvbiBtYXkgYmUgdGhlIGVtcHR5IHN0cmluZyB3aGljaCBldmFsdWF0ZXNcbiAgICogdG8gYGZhbHNlYCBpbiBKYXZhU2NyaXB0LiAgVXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pICE9IG51bGwpYCBvclxuICAgKiBgaWYgKG5hbWVzcGFjZS5oYXMoLi4uKSlgLlxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY3VycmVudCwgbmFtZSApKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50W25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5idWlsdGluc1tuYW1lXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgbmFtZSwgYW5kIG9wdGlvbmFsbHkgc2V0IGl0IGdsb2JhbGx5IHRvby5cbiAgICogTG9jYWwgc2V0KCkgc2V0cyB0aGUgY3VycmVudCB2YWx1ZSBhbmQgKHdoZW4gYXBwcm9wcmlhdGUpIGFkZHMgYW4gdW5kb1xuICAgKiBvcGVyYXRpb24gdG8gdGhlIHVuZG8gc3RhY2suICBHbG9iYWwgc2V0KCkgbWF5IGNoYW5nZSB0aGUgdW5kb1xuICAgKiBvcGVyYXRpb24gYXQgZXZlcnkgbGV2ZWwsIHNvIHRha2VzIHRpbWUgbGluZWFyIGluIHRoZWlyIG51bWJlci5cbiAgICovXG4gIHNldChuYW1lLCB2YWx1ZSwgZ2xvYmFsID0gZmFsc2UpIHtcbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAvLyBHbG9iYWwgc2V0IGlzIGVxdWl2YWxlbnQgdG8gc2V0dGluZyBpbiBhbGwgZ3JvdXBzLiAgU2ltdWxhdGUgdGhpc1xuICAgICAgLy8gYnkgZGVzdHJveWluZyBhbnkgdW5kb3MgY3VycmVudGx5IHNjaGVkdWxlZCBmb3IgdGhpcyBuYW1lLFxuICAgICAgLy8gYW5kIGFkZGluZyBhbiB1bmRvIHdpdGggdGhlICpuZXcqIHZhbHVlIChpbiBjYXNlIGl0IGxhdGVyIGdldHNcbiAgICAgIC8vIGxvY2FsbHkgcmVzZXQgd2l0aGluIHRoaXMgZW52aXJvbm1lbnQpLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnVuZGVmU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudW5kZWZTdGFja1tpXVtuYW1lXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnVuZGVmU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnVuZGVmU3RhY2tbdGhpcy51bmRlZlN0YWNrLmxlbmd0aCAtIDFdW25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuZG8gdGhpcyBzZXQgYXQgZW5kIG9mIHRoaXMgZ3JvdXAgKHBvc3NpYmx5IHRvIGB1bmRlZmluZWRgKSxcbiAgICAgIC8vIHVubGVzcyBhbiB1bmRvIGlzIGFscmVhZHkgaW4gcGxhY2UsIGluIHdoaWNoIGNhc2UgdGhhdCBvbGRlclxuICAgICAgLy8gdmFsdWUgaXMgdGhlIGNvcnJlY3Qgb25lLlxuICAgICAgY29uc3QgdG9wID0gdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmICh0b3AgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0b3AsIG5hbWUgKSkge1xuICAgICAgICB0b3BbbmFtZV0gPSB0aGlzLmN1cnJlbnRbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFtuYW1lXSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSDigJxndWxsZXTigJ0gd2hlcmUgbWFjcm9zIGFyZSBleHBhbmRlZFxuICogdW50aWwgb25seSBub24tbWFjcm8gdG9rZW5zIHJlbWFpbi5cbiAqL1xuXG5cbi8vIExpc3Qgb2YgY29tbWFuZHMgdGhhdCBhY3QgbGlrZSBtYWNyb3MgYnV0IGFyZW4ndCBkZWZpbmVkIGFzIGEgbWFjcm8sXG4vLyBmdW5jdGlvbiwgb3Igc3ltYm9sLiAgVXNlZCBpbiBgaXNEZWZpbmVkYC5cbmNvbnN0IGltcGxpY2l0Q29tbWFuZHMgPSB7XG4gIFwiXlwiOiB0cnVlLCAvLyBQYXJzZXIuanNcbiAgXzogdHJ1ZSwgLy8gUGFyc2VyLmpzXG4gIFwiXFxcXGxpbWl0c1wiOiB0cnVlLCAvLyBQYXJzZXIuanNcbiAgXCJcXFxcbm9saW1pdHNcIjogdHJ1ZSAvLyBQYXJzZXIuanNcbn07XG5cbmNsYXNzIE1hY3JvRXhwYW5kZXIge1xuICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MsIG1vZGUpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5leHBhbnNpb25Db3VudCA9IDA7XG4gICAgdGhpcy5mZWVkKGlucHV0KTtcbiAgICAvLyBNYWtlIG5ldyBnbG9iYWwgbmFtZXNwYWNlXG4gICAgdGhpcy5tYWNyb3MgPSBuZXcgTmFtZXNwYWNlKG1hY3Jvcywgc2V0dGluZ3MubWFjcm9zKTtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuc3RhY2sgPSBbXTsgLy8gY29udGFpbnMgdG9rZW5zIGluIFJFVkVSU0Ugb3JkZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBGZWVkIGEgbmV3IGlucHV0IHN0cmluZyB0byB0aGUgc2FtZSBNYWNyb0V4cGFuZGVyXG4gICAqICh3aXRoIGV4aXN0aW5nIG1hY3JvcyBldGMuKS5cbiAgICovXG4gIGZlZWQoaW5wdXQpIHtcbiAgICB0aGlzLmxleGVyID0gbmV3IExleGVyKGlucHV0LCB0aGlzLnNldHRpbmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIFwidGV4dFwiIGFuZCBcIm1hdGhcIiBtb2Rlcy5cbiAgICovXG4gIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBuZXcgZ3JvdXAgbmVzdGluZyB3aXRoaW4gYWxsIG5hbWVzcGFjZXMuXG4gICAqL1xuICBiZWdpbkdyb3VwKCkge1xuICAgIHRoaXMubWFjcm9zLmJlZ2luR3JvdXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmQgY3VycmVudCBncm91cCBuZXN0aW5nIHdpdGhpbiBhbGwgbmFtZXNwYWNlcy5cbiAgICovXG4gIGVuZEdyb3VwKCkge1xuICAgIHRoaXMubWFjcm9zLmVuZEdyb3VwKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9wbW9zdCB0b2tlbiBvbiB0aGUgc3RhY2ssIHdpdGhvdXQgZXhwYW5kaW5nIGl0LlxuICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcXGZ1dHVyZWxldGAuXG4gICAqL1xuICBmdXR1cmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnB1c2hUb2tlbih0aGlzLmxleGVyLmxleCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHVuZXhwYW5kZWQgdG9rZW4uXG4gICAqL1xuICBwb3BUb2tlbigpIHtcbiAgICB0aGlzLmZ1dHVyZSgpOyAvLyBlbnN1cmUgbm9uLWVtcHR5IHN0YWNrXG4gICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgZ2l2ZW4gdG9rZW4gdG8gdGhlIHRva2VuIHN0YWNrLiAgSW4gcGFydGljdWxhciwgdGhpcyBnZXQgYmUgdXNlZFxuICAgKiB0byBwdXQgYmFjayBhIHRva2VuIHJldHVybmVkIGZyb20gb25lIG9mIHRoZSBvdGhlciBtZXRob2RzLlxuICAgKi9cbiAgcHVzaFRva2VuKHRva2VuKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmQgYW4gYXJyYXkgb2YgdG9rZW5zIHRvIHRoZSB0b2tlbiBzdGFjay5cbiAgICovXG4gIHB1c2hUb2tlbnModG9rZW5zKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKC4uLnRva2Vucyk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCBhbiBtYWNybyBhcmd1bWVudCB3aXRob3V0IGV4cGFuZGluZyB0b2tlbnMgYW5kIGFwcGVuZCB0aGUgYXJyYXkgb2ZcbiAgICogdG9rZW5zIHRvIHRoZSB0b2tlbiBzdGFjay4gVXNlcyBUb2tlbiBhcyBhIGNvbnRhaW5lciBmb3IgdGhlIHJlc3VsdC5cbiAgICovXG4gIHNjYW5Bcmd1bWVudChpc09wdGlvbmFsKSB7XG4gICAgbGV0IHN0YXJ0O1xuICAgIGxldCBlbmQ7XG4gICAgbGV0IHRva2VucztcbiAgICBpZiAoaXNPcHRpb25hbCkge1xuICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7IC8vIFxcQGlmbmV4dGNoYXIgZ29iYmxlcyBhbnkgc3BhY2UgZm9sbG93aW5nIGl0XG4gICAgICBpZiAodGhpcy5mdXR1cmUoKS50ZXh0ICE9PSBcIltcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gdGhpcy5wb3BUb2tlbigpOyAvLyBkb24ndCBpbmNsdWRlIFsgaW4gdG9rZW5zXG4gICAgICAoeyB0b2tlbnMsIGVuZCB9ID0gdGhpcy5jb25zdW1lQXJnKFtcIl1cIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgKHsgdG9rZW5zLCBzdGFydCwgZW5kIH0gPSB0aGlzLmNvbnN1bWVBcmcoKSk7XG4gICAgfVxuXG4gICAgLy8gaW5kaWNhdGUgdGhlIGVuZCBvZiBhbiBhcmd1bWVudFxuICAgIHRoaXMucHVzaFRva2VuKG5ldyBUb2tlbihcIkVPRlwiLCBlbmQubG9jKSk7XG5cbiAgICB0aGlzLnB1c2hUb2tlbnModG9rZW5zKTtcbiAgICByZXR1cm4gc3RhcnQucmFuZ2UoZW5kLCBcIlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lIGFsbCBmb2xsb3dpbmcgc3BhY2UgdG9rZW5zLCB3aXRob3V0IGV4cGFuc2lvbi5cbiAgICovXG4gIGNvbnN1bWVTcGFjZXMoKSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmZ1dHVyZSgpO1xuICAgICAgaWYgKHRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uc3VtZSBhbiBhcmd1bWVudCBmcm9tIHRoZSB0b2tlbiBzdHJlYW0sIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheVxuICAgKiBvZiB0b2tlbnMgYW5kIHN0YXJ0L2VuZCB0b2tlbi5cbiAgICovXG4gIGNvbnN1bWVBcmcoZGVsaW1zKSB7XG4gICAgLy8gVGhlIGFyZ3VtZW50IGZvciBhIGRlbGltaXRlZCBwYXJhbWV0ZXIgaXMgdGhlIHNob3J0ZXN0IChwb3NzaWJseVxuICAgIC8vIGVtcHR5KSBzZXF1ZW5jZSBvZiB0b2tlbnMgd2l0aCBwcm9wZXJseSBuZXN0ZWQgey4uLn0gZ3JvdXBzIHRoYXQgaXNcbiAgICAvLyBmb2xsb3dlZCAuLi4gYnkgdGhpcyBwYXJ0aWN1bGFyIGxpc3Qgb2Ygbm9uLXBhcmFtZXRlciB0b2tlbnMuXG4gICAgLy8gVGhlIGFyZ3VtZW50IGZvciBhbiB1bmRlbGltaXRlZCBwYXJhbWV0ZXIgaXMgdGhlIG5leHQgbm9uYmxhbmtcbiAgICAvLyB0b2tlbiwgdW5sZXNzIHRoYXQgdG9rZW4gaXMg4oCYe+KAmSwgd2hlbiB0aGUgYXJndW1lbnQgd2lsbCBiZSB0aGVcbiAgICAvLyBlbnRpcmUgey4uLn0gZ3JvdXAgdGhhdCBmb2xsb3dzLlxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgIGNvbnN0IGlzRGVsaW1pdGVkID0gZGVsaW1zICYmIGRlbGltcy5sZW5ndGggPiAwO1xuICAgIGlmICghaXNEZWxpbWl0ZWQpIHtcbiAgICAgIC8vIElnbm9yZSBzcGFjZXMgYmV0d2VlbiBhcmd1bWVudHMuICBBcyB0aGUgVGVYYm9vayBzYXlzOlxuICAgICAgLy8gXCJBZnRlciB5b3UgaGF2ZSBzYWlkIOKAmFxcZGVmXFxyb3cjMSMyey4uLn3igJksIHlvdSBhcmUgYWxsb3dlZCB0b1xuICAgICAgLy8gIHB1dCBzcGFjZXMgYmV0d2VlbiB0aGUgYXJndW1lbnRzIChlLmcuLCDigJhcXHJvdyB4IG7igJkpLCBiZWNhdXNlXG4gICAgICAvLyAgVGVYIGRvZXNu4oCZdCB1c2Ugc2luZ2xlIHNwYWNlcyBhcyB1bmRlbGltaXRlZCBhcmd1bWVudHMuXCJcbiAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IHRoaXMuZnV0dXJlKCk7XG4gICAgbGV0IHRvaztcbiAgICBsZXQgZGVwdGggPSAwO1xuICAgIGxldCBtYXRjaCA9IDA7XG4gICAgZG8ge1xuICAgICAgdG9rID0gdGhpcy5wb3BUb2tlbigpO1xuICAgICAgdG9rZW5zLnB1c2godG9rKTtcbiAgICAgIGlmICh0b2sudGV4dCA9PT0gXCJ7XCIpIHtcbiAgICAgICAgKytkZXB0aDtcbiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09IFwifVwiKSB7XG4gICAgICAgIC0tZGVwdGg7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4dHJhIH1cIiwgdG9rKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2sudGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICBcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0IGluIGEgbWFjcm8gYXJndW1lbnRcIiArXG4gICAgICAgICAgICBcIiwgZXhwZWN0ZWQgJ1wiICtcbiAgICAgICAgICAgIChkZWxpbXMgJiYgaXNEZWxpbWl0ZWQgPyBkZWxpbXNbbWF0Y2hdIDogXCJ9XCIpICtcbiAgICAgICAgICAgIFwiJ1wiLFxuICAgICAgICAgIHRva1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGltcyAmJiBpc0RlbGltaXRlZCkge1xuICAgICAgICBpZiAoKGRlcHRoID09PSAwIHx8IChkZXB0aCA9PT0gMSAmJiBkZWxpbXNbbWF0Y2hdID09PSBcIntcIikpICYmIHRvay50ZXh0ID09PSBkZWxpbXNbbWF0Y2hdKSB7XG4gICAgICAgICAgKyttYXRjaDtcbiAgICAgICAgICBpZiAobWF0Y2ggPT09IGRlbGltcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGluY2x1ZGUgZGVsaW1zIGluIHRva2Vuc1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZSgtbWF0Y2gsIG1hdGNoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRjaCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChkZXB0aCAhPT0gMCB8fCBpc0RlbGltaXRlZCk7XG4gICAgLy8gSWYgdGhlIGFyZ3VtZW50IGZvdW5kIC4uLiBoYXMgdGhlIGZvcm0g4oCYezxuZXN0ZWQgdG9rZW5zPn3igJksXG4gICAgLy8gLi4uIHRoZSBvdXRlcm1vc3QgYnJhY2VzIGVuY2xvc2luZyB0aGUgYXJndW1lbnQgYXJlIHJlbW92ZWRcbiAgICBpZiAoc3RhcnQudGV4dCA9PT0gXCJ7XCIgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50ZXh0ID09PSBcIn1cIikge1xuICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgdG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuICAgIHRva2Vucy5yZXZlcnNlKCk7IC8vIHRvIGZpdCBpbiB3aXRoIHN0YWNrIG9yZGVyXG4gICAgcmV0dXJuIHsgdG9rZW5zLCBzdGFydCwgZW5kOiB0b2sgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIChkZWxpbWl0ZWQpIGFyZ3VtZW50cyBmcm9tIHRoZSB0b2tlblxuICAgKiBzdHJlYW0gYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5IG9mIGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN1bWVBcmdzKG51bUFyZ3MsIGRlbGltaXRlcnMpIHtcbiAgICBpZiAoZGVsaW1pdGVycykge1xuICAgICAgaWYgKGRlbGltaXRlcnMubGVuZ3RoICE9PSBudW1BcmdzICsgMSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlRoZSBsZW5ndGggb2YgZGVsaW1pdGVycyBkb2Vzbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgYXJncyFcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkZWxpbXMgPSBkZWxpbWl0ZXJzWzBdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWxpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdG9rID0gdGhpcy5wb3BUb2tlbigpO1xuICAgICAgICBpZiAoZGVsaW1zW2ldICE9PSB0b2sudGV4dCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVXNlIG9mIHRoZSBtYWNybyBkb2Vzbid0IG1hdGNoIGl0cyBkZWZpbml0aW9uXCIsIHRvayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BcmdzOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaCh0aGlzLmNvbnN1bWVBcmcoZGVsaW1pdGVycyAmJiBkZWxpbWl0ZXJzW2kgKyAxXSkudG9rZW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogSWYgdGhlIHRva2VuIGlzIGV4cGFuZGVkLCB0aGUgcmVzdWx0aW5nIHRva2VucyB3aWxsIGJlIHB1c2hlZCBvbnRvXG4gICAqIHRoZSBzdGFjayBpbiByZXZlcnNlIG9yZGVyLCBhbmQgdGhlIG51bWJlciBvZiBzdWNoIHRva2VucyB3aWxsIGJlXG4gICAqIHJldHVybmVkLiAgVGhpcyBudW1iZXIgbWlnaHQgYmUgemVybyBvciBwb3NpdGl2ZS5cbiAgICpcbiAgICogSWYgbm90LCB0aGUgcmV0dXJuIHZhbHVlIGlzIGBmYWxzZWAsIGFuZCB0aGUgbmV4dCB0b2tlbiByZW1haW5zIGF0IHRoZVxuICAgKiB0b3Agb2YgdGhlIHN0YWNrLlxuICAgKlxuICAgKiBJbiBlaXRoZXIgY2FzZSwgdGhlIG5leHQgdG9rZW4gd2lsbCBiZSBvbiB0aGUgdG9wIG9mIHRoZSBzdGFjayxcbiAgICogb3IgdGhlIHN0YWNrIHdpbGwgYmUgZW1wdHkgKGluIGNhc2Ugb2YgZW1wdHkgZXhwYW5zaW9uXG4gICAqIGFuZCBubyBvdGhlciB0b2tlbnMpLlxuICAgKlxuICAgKiBVc2VkIHRvIGltcGxlbWVudCBgZXhwYW5kQWZ0ZXJGdXR1cmVgIGFuZCBgZXhwYW5kTmV4dFRva2VuYC5cbiAgICpcbiAgICogSWYgZXhwYW5kYWJsZU9ubHksIG9ubHkgZXhwYW5kYWJsZSB0b2tlbnMgYXJlIGV4cGFuZGVkIGFuZFxuICAgKiBhbiB1bmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZSByZXN1bHRzIGluIGFuIGVycm9yLlxuICAgKi9cbiAgZXhwYW5kT25jZShleHBhbmRhYmxlT25seSkge1xuICAgIGNvbnN0IHRvcFRva2VuID0gdGhpcy5wb3BUb2tlbigpO1xuICAgIGNvbnN0IG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgIGNvbnN0IGV4cGFuc2lvbiA9ICF0b3BUb2tlbi5ub2V4cGFuZCA/IHRoaXMuX2dldEV4cGFuc2lvbihuYW1lKSA6IG51bGw7XG4gICAgaWYgKGV4cGFuc2lvbiA9PSBudWxsIHx8IChleHBhbmRhYmxlT25seSAmJiBleHBhbnNpb24udW5leHBhbmRhYmxlKSkge1xuICAgICAgaWYgKGV4cGFuZGFibGVPbmx5ICYmIGV4cGFuc2lvbiA9PSBudWxsICYmIG5hbWVbMF0gPT09IFwiXFxcXFwiICYmICF0aGlzLmlzRGVmaW5lZChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlVuZGVmaW5lZCBjb250cm9sIHNlcXVlbmNlOiBcIiArIG5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wdXNoVG9rZW4odG9wVG9rZW4pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmV4cGFuc2lvbkNvdW50Kys7XG4gICAgaWYgKHRoaXMuZXhwYW5zaW9uQ291bnQgPiB0aGlzLnNldHRpbmdzLm1heEV4cGFuZCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgIFwiVG9vIG1hbnkgZXhwYW5zaW9uczogaW5maW5pdGUgbG9vcCBvciBcIiArIFwibmVlZCB0byBpbmNyZWFzZSBtYXhFeHBhbmQgc2V0dGluZ1wiXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgdG9rZW5zID0gZXhwYW5zaW9uLnRva2VucztcbiAgICBjb25zdCBhcmdzID0gdGhpcy5jb25zdW1lQXJncyhleHBhbnNpb24ubnVtQXJncywgZXhwYW5zaW9uLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHBhbnNpb24ubnVtQXJncykge1xuICAgICAgLy8gcGFzdGUgYXJndW1lbnRzIGluIHBsYWNlIG9mIHRoZSBwbGFjZWhvbGRlcnNcbiAgICAgIHRva2VucyA9IHRva2Vucy5zbGljZSgpOyAvLyBtYWtlIGEgc2hhbGxvdyBjb3B5XG4gICAgICBmb3IgKGxldCBpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGxldCB0b2sgPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0b2sudGV4dCA9PT0gXCIjXCIpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbmNvbXBsZXRlIHBsYWNlaG9sZGVyIGF0IGVuZCBvZiBtYWNybyBib2R5XCIsIHRvayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvayA9IHRva2Vuc1stLWldOyAvLyBuZXh0IHRva2VuIG9uIHN0YWNrXG4gICAgICAgICAgaWYgKHRvay50ZXh0ID09PSBcIiNcIikge1xuICAgICAgICAgICAgLy8gIyMg4oaSICNcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDEpOyAvLyBkcm9wIGZpcnN0ICNcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eWzEtOV0kLy50ZXN0KHRvay50ZXh0KSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgcGxhY2Vob2xkZXIgd2l0aCB0aGUgaW5kaWNhdGVkIGFyZ3VtZW50XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDIsIC4uLmFyZ3NbK3Rvay50ZXh0IC0gMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk5vdCBhIHZhbGlkIGFyZ3VtZW50IG51bWJlclwiLCB0b2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBDb25jYXRlbmF0ZSBleHBhbnNpb24gb250byB0b3Agb2Ygc3RhY2suXG4gICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgcmV0dXJuIHRva2Vucy5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSAoaWYgcG9zc2libGUpLCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmdcbiAgICogdG9wIHRva2VuIG9uIHRoZSBzdGFjayAod2l0aG91dCByZW1vdmluZyBhbnl0aGluZyBmcm9tIHRoZSBzdGFjaykuXG4gICAqIFNpbWlsYXIgaW4gYmVoYXZpb3IgdG8gVGVYJ3MgYFxcZXhwYW5kYWZ0ZXJcXGZ1dHVyZWxldGAuXG4gICAqIEVxdWl2YWxlbnQgdG8gZXhwYW5kT25jZSgpIGZvbGxvd2VkIGJ5IGZ1dHVyZSgpLlxuICAgKi9cbiAgZXhwYW5kQWZ0ZXJGdXR1cmUoKSB7XG4gICAgdGhpcy5leHBhbmRPbmNlKCk7XG4gICAgcmV0dXJuIHRoaXMuZnV0dXJlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVjdXJzaXZlbHkgZXhwYW5kIGZpcnN0IHRva2VuLCB0aGVuIHJldHVybiBmaXJzdCBub24tZXhwYW5kYWJsZSB0b2tlbi5cbiAgICovXG4gIGV4cGFuZE5leHRUb2tlbigpIHtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5leHBhbmRPbmNlKCkgPT09IGZhbHNlKSB7IC8vIGZ1bGx5IGV4cGFuZGVkXG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgLy8gVGhlIHRva2VuIGFmdGVyIFxcbm9leHBhbmQgaXMgaW50ZXJwcmV0ZWQgYXMgaWYgaXRzIG1lYW5pbmcgd2VyZSDigJhcXHJlbGF44oCZXG4gICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHtcbiAgICAgICAgICB0b2tlbi50ZXh0ID0gXCJcXFxccmVsYXhcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIHBhdGh3YXkgaXMgaW1wb3NzaWJsZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnJlYWNoYWJsZVxuICB9XG5cbiAgLyoqXG4gICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZlxuICAgKiB0b2tlbnMsIG9yIHJldHVybiBgdW5kZWZpbmVkYCBpZiBubyBzdWNoIG1hY3JvIGlzIGRlZmluZWQuXG4gICAqL1xuICBleHBhbmRNYWNybyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFjcm9zLmhhcyhuYW1lKSA/IHRoaXMuZXhwYW5kVG9rZW5zKFtuZXcgVG9rZW4obmFtZSldKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIHRva2VuIHN0cmVhbSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZlxuICAgKiB0b2tlbnMuICBOb3RlIHRoYXQgdGhlIGlucHV0IHRva2VucyBhcmUgaW4gcmV2ZXJzZSBvcmRlciwgYnV0IHRoZVxuICAgKiBvdXRwdXQgdG9rZW5zIGFyZSBpbiBmb3J3YXJkIG9yZGVyLlxuICAgKi9cbiAgZXhwYW5kVG9rZW5zKHRva2Vucykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IG9sZFN0YWNrTGVuZ3RoID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7XG4gICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gb2xkU3RhY2tMZW5ndGgpIHtcbiAgICAgIC8vIEV4cGFuZCBvbmx5IGV4cGFuZGFibGUgdG9rZW5zXG4gICAgICBpZiAodGhpcy5leHBhbmRPbmNlKHRydWUpID09PSBmYWxzZSkgeyAgLy8gZnVsbHkgZXhwYW5kZWRcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAodG9rZW4udHJlYXRBc1JlbGF4KSB7XG4gICAgICAgICAgLy8gdGhlIGV4cGFuc2lvbiBvZiBcXG5vZXhwYW5kIGlzIHRoZSB0b2tlbiBpdHNlbGZcbiAgICAgICAgICB0b2tlbi5ub2V4cGFuZCA9IGZhbHNlO1xuICAgICAgICAgIHRva2VuLnRyZWF0QXNSZWxheCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIG1hY3JvIG5hbWUgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgc3RyaW5nLFxuICAgKiBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLlxuICAgKi9cbiAgZXhwYW5kTWFjcm9Bc1RleHQobmFtZSkge1xuICAgIGNvbnN0IHRva2VucyA9IHRoaXMuZXhwYW5kTWFjcm8obmFtZSk7XG4gICAgaWYgKHRva2Vucykge1xuICAgICAgcmV0dXJuIHRva2Vucy5tYXAoKHRva2VuKSA9PiB0b2tlbi50ZXh0KS5qb2luKFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBleHBhbmRlZCBtYWNybyBhcyBhIHJldmVyc2VkIGFycmF5IG9mIHRva2VucyBhbmQgYSBtYWNyb1xuICAgKiBhcmd1bWVudCBjb3VudC4gIE9yIHJldHVybnMgYG51bGxgIGlmIG5vIHN1Y2ggbWFjcm8uXG4gICAqL1xuICBfZ2V0RXhwYW5zaW9uKG5hbWUpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5tYWNyb3MuZ2V0KG5hbWUpO1xuICAgIGlmIChkZWZpbml0aW9uID09IG51bGwpIHtcbiAgICAgIC8vIG1haW5seSBjaGVja2luZyBmb3IgdW5kZWZpbmVkIGhlcmVcbiAgICAgIHJldHVybiBkZWZpbml0aW9uO1xuICAgIH1cbiAgICAvLyBJZiBhIHNpbmdsZSBjaGFyYWN0ZXIgaGFzIGFuIGFzc29jaWF0ZWQgY2F0Y29kZSBvdGhlciB0aGFuIDEzXG4gICAgLy8gKGFjdGl2ZSBjaGFyYWN0ZXIpLCB0aGVuIGRvbid0IGV4cGFuZCBpdC5cbiAgICBpZiAobmFtZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNhdGNvZGUgPSB0aGlzLmxleGVyLmNhdGNvZGVzW25hbWVdO1xuICAgICAgaWYgKGNhdGNvZGUgIT0gbnVsbCAmJiBjYXRjb2RlICE9PSAxMykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwYW5zaW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIiA/IGRlZmluaXRpb24odGhpcykgOiBkZWZpbml0aW9uO1xuICAgIGlmICh0eXBlb2YgZXhwYW5zaW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsZXQgbnVtQXJncyA9IDA7XG4gICAgICBpZiAoZXhwYW5zaW9uLmluZGV4T2YoXCIjXCIpICE9PSAtMSkge1xuICAgICAgICBjb25zdCBzdHJpcHBlZCA9IGV4cGFuc2lvbi5yZXBsYWNlKC8jIy9nLCBcIlwiKTtcbiAgICAgICAgd2hpbGUgKHN0cmlwcGVkLmluZGV4T2YoXCIjXCIgKyAobnVtQXJncyArIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgICArK251bUFyZ3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvZHlMZXhlciA9IG5ldyBMZXhlcihleHBhbnNpb24sIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgICBsZXQgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgd2hpbGUgKHRvay50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHRvayk7XG4gICAgICAgIHRvayA9IGJvZHlMZXhlci5sZXgoKTtcbiAgICAgIH1cbiAgICAgIHRva2Vucy5yZXZlcnNlKCk7IC8vIHRvIGZpdCBpbiB3aXRoIHN0YWNrIHVzaW5nIHB1c2ggYW5kIHBvcFxuICAgICAgY29uc3QgZXhwYW5kZWQgPSB7IHRva2VucywgbnVtQXJncyB9O1xuICAgICAgcmV0dXJuIGV4cGFuZGVkO1xuICAgIH1cblxuICAgIHJldHVybiBleHBhbnNpb247XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tYW5kIGlzIGN1cnJlbnRseSBcImRlZmluZWRcIiAoaGFzIHNvbWVcbiAgICogZnVuY3Rpb25hbGl0eSksIG1lYW5pbmcgdGhhdCBpdCdzIGEgbWFjcm8gKGluIHRoZSBjdXJyZW50IGdyb3VwKSxcbiAgICogYSBmdW5jdGlvbiwgYSBzeW1ib2wsIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBjb21tYW5kcyBsaXN0ZWQgaW5cbiAgICogYGltcGxpY2l0Q29tbWFuZHNgLlxuICAgKi9cbiAgaXNEZWZpbmVkKG5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5tYWNyb3MuaGFzKG5hbWUpIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZnVuY3Rpb25zLCBuYW1lICkgfHxcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzeW1ib2xzLm1hdGgsIG5hbWUgKSB8fFxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHN5bWJvbHMudGV4dCwgbmFtZSApIHx8XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW1wbGljaXRDb21tYW5kcywgbmFtZSApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBhIGNvbW1hbmQgaXMgZXhwYW5kYWJsZS5cbiAgICovXG4gIGlzRXhwYW5kYWJsZShuYW1lKSB7XG4gICAgY29uc3QgbWFjcm8gPSB0aGlzLm1hY3Jvcy5nZXQobmFtZSk7XG4gICAgcmV0dXJuIG1hY3JvICE9IG51bGxcbiAgICAgID8gdHlwZW9mIG1hY3JvID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtYWNybyA9PT0gXCJmdW5jdGlvblwiIHx8ICFtYWNyby51bmV4cGFuZGFibGVcbiAgICAgIDogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZ1bmN0aW9ucywgbmFtZSApICYmICFmdW5jdGlvbnNbbmFtZV0ucHJpbWl0aXZlO1xuICB9XG59XG5cbi8vIEhlbHBlcnMgZm9yIFBhcnNlci5qcyBoYW5kbGluZyBvZiBVbmljb2RlIChzdWJ8c3VwZXIpc2NyaXB0IGNoYXJhY3RlcnMuXG5cbmNvbnN0IHVuaWNvZGVTdWJSZWdFeCA9IC9eW+KCiuKCi+KCjOKCjeKCjuKCgOKCgeKCguKCg+KChOKCheKChuKCh+KCiOKCieKCkOKCkeKCleG1ouKxvOKCluKCl+KCmOKCmeKCkuKCmuG1o+KCm+KCnOG1pOG1peKCk+G1puG1p+G1qOG1qeG1ql0vO1xuXG5jb25zdCB1U3Vic0FuZFN1cHMgPSBPYmplY3QuZnJlZXplKHtcbiAgJ+KCiic6ICcrJyxcbiAgJ+KCiyc6ICctJyxcbiAgJ+KCjCc6ICc9JyxcbiAgJ+KCjSc6ICcoJyxcbiAgJ+KCjic6ICcpJyxcbiAgJ+KCgCc6ICcwJyxcbiAgJ+KCgSc6ICcxJyxcbiAgJ+KCgic6ICcyJyxcbiAgJ+KCgyc6ICczJyxcbiAgJ+KChCc6ICc0JyxcbiAgJ+KChSc6ICc1JyxcbiAgJ+KChic6ICc2JyxcbiAgJ+KChyc6ICc3JyxcbiAgJ+KCiCc6ICc4JyxcbiAgJ+KCiSc6ICc5JyxcbiAgJ1xcdTIwOTAnOiAnYScsXG4gICdcXHUyMDkxJzogJ2UnLFxuICAnXFx1MjA5NSc6ICdoJyxcbiAgJ1xcdTFENjInOiAnaScsXG4gICdcXHUyQzdDJzogJ2onLFxuICAnXFx1MjA5Nic6ICdrJyxcbiAgJ1xcdTIwOTcnOiAnbCcsXG4gICdcXHUyMDk4JzogJ20nLFxuICAnXFx1MjA5OSc6ICduJyxcbiAgJ1xcdTIwOTInOiAnbycsXG4gICdcXHUyMDlBJzogJ3AnLFxuICAnXFx1MUQ2Myc6ICdyJyxcbiAgJ1xcdTIwOUInOiAncycsXG4gICdcXHUyMDlDJzogJ3QnLFxuICAnXFx1MUQ2NCc6ICd1JyxcbiAgJ1xcdTFENjUnOiAndicsXG4gICdcXHUyMDkzJzogJ3gnLFxuICAnXFx1MUQ2Nic6ICfOsicsXG4gICdcXHUxRDY3JzogJ86zJyxcbiAgJ1xcdTFENjgnOiAnz4EnLFxuICAnXFx1MUQ2OSc6ICdcXHUwM2Q1JyxcbiAgJ1xcdTFENkEnOiAnz4cnLFxuICAn4oG6JzogJysnLFxuICAn4oG7JzogJy0nLFxuICAn4oG8JzogJz0nLFxuICAn4oG9JzogJygnLFxuICAn4oG+JzogJyknLFxuICAn4oGwJzogJzAnLFxuICAnwrknOiAnMScsXG4gICfCsic6ICcyJyxcbiAgJ8KzJzogJzMnLFxuICAn4oG0JzogJzQnLFxuICAn4oG1JzogJzUnLFxuICAn4oG2JzogJzYnLFxuICAn4oG3JzogJzcnLFxuICAn4oG4JzogJzgnLFxuICAn4oG5JzogJzknLFxuICAnXFx1MUQyQyc6ICdBJyxcbiAgJ1xcdTFEMkUnOiAnQicsXG4gICdcXHUxRDMwJzogJ0QnLFxuICAnXFx1MUQzMSc6ICdFJyxcbiAgJ1xcdTFEMzMnOiAnRycsXG4gICdcXHUxRDM0JzogJ0gnLFxuICAnXFx1MUQzNSc6ICdJJyxcbiAgJ1xcdTFEMzYnOiAnSicsXG4gICdcXHUxRDM3JzogJ0snLFxuICAnXFx1MUQzOCc6ICdMJyxcbiAgJ1xcdTFEMzknOiAnTScsXG4gICdcXHUxRDNBJzogJ04nLFxuICAnXFx1MUQzQyc6ICdPJyxcbiAgJ1xcdTFEM0UnOiAnUCcsXG4gICdcXHUxRDNGJzogJ1InLFxuICAnXFx1MUQ0MCc6ICdUJyxcbiAgJ1xcdTFENDEnOiAnVScsXG4gICdcXHUyQzdEJzogJ1YnLFxuICAnXFx1MUQ0Mic6ICdXJyxcbiAgJ1xcdTFENDMnOiAnYScsXG4gICdcXHUxRDQ3JzogJ2InLFxuICAnXFx1MUQ5Qyc6ICdjJyxcbiAgJ1xcdTFENDgnOiAnZCcsXG4gICdcXHUxRDQ5JzogJ2UnLFxuICAnXFx1MURBMCc6ICdmJyxcbiAgJ1xcdTFENEQnOiAnZycsXG4gICdcXHUwMkIwJzogJ2gnLFxuICAnXFx1MjA3MSc6ICdpJyxcbiAgJ1xcdTAyQjInOiAnaicsXG4gICdcXHUxRDRGJzogJ2snLFxuICAnXFx1MDJFMSc6ICdsJyxcbiAgJ1xcdTFENTAnOiAnbScsXG4gICdcXHUyMDdGJzogJ24nLFxuICAnXFx1MUQ1Mic6ICdvJyxcbiAgJ1xcdTFENTYnOiAncCcsXG4gICdcXHUwMkIzJzogJ3InLFxuICAnXFx1MDJFMic6ICdzJyxcbiAgJ1xcdTFENTcnOiAndCcsXG4gICdcXHUxRDU4JzogJ3UnLFxuICAnXFx1MUQ1Qic6ICd2JyxcbiAgJ1xcdTAyQjcnOiAndycsXG4gICdcXHUwMkUzJzogJ3gnLFxuICAnXFx1MDJCOCc6ICd5JyxcbiAgJ1xcdTFEQkInOiAneicsXG4gICdcXHUxRDVEJzogJ86yJyxcbiAgJ1xcdTFENUUnOiAnzrMnLFxuICAnXFx1MUQ1Ric6ICfOtCcsXG4gICdcXHUxRDYwJzogJ1xcdTAzZDUnLFxuICAnXFx1MUQ2MSc6ICfPhycsXG4gICdcXHUxREJGJzogJ864J1xufSk7XG5cbi8vIFVzZWQgZm9yIFVuaWNvZGUgaW5wdXQgb2YgY2FsbGlncmFwaGljIGFuZCBzY3JpcHQgbGV0dGVyc1xuY29uc3QgYXNjaWlGcm9tU2NyaXB0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFwiXFx1ZDgzNVxcdWRjOWNcIjogXCJBXCIsXG4gIFwiXFx1MjEyY1wiOiBcIkJcIixcbiAgXCJcXHVkODM1XFx1ZGM5ZVwiOiBcIkNcIixcbiAgXCJcXHVkODM1XFx1ZGM5ZlwiOiBcIkRcIixcbiAgXCJcXHUyMTMwXCI6IFwiRVwiLFxuICBcIlxcdTIxMzFcIjogXCJGXCIsXG4gIFwiXFx1ZDgzNVxcdWRjYTJcIjogXCJHXCIsXG4gIFwiXFx1MjEwQlwiOiBcIkhcIixcbiAgXCJcXHUyMTEwXCI6IFwiSVwiLFxuICBcIlxcdWQ4MzVcXHVkY2E1XCI6IFwiSlwiLFxuICBcIlxcdWQ4MzVcXHVkY2E2XCI6IFwiS1wiLFxuICBcIlxcdTIxMTJcIjogXCJMXCIsXG4gIFwiXFx1MjEzM1wiOiBcIk1cIixcbiAgXCJcXHVkODM1XFx1ZGNhOVwiOiBcIk5cIixcbiAgXCJcXHVkODM1XFx1ZGNhYVwiOiBcIk9cIixcbiAgXCJcXHVkODM1XFx1ZGNhYlwiOiBcIlBcIixcbiAgXCJcXHVkODM1XFx1ZGNhY1wiOiBcIlFcIixcbiAgXCJcXHUyMTFCXCI6IFwiUlwiLFxuICBcIlxcdWQ4MzVcXHVkY2FlXCI6IFwiU1wiLFxuICBcIlxcdWQ4MzVcXHVkY2FmXCI6IFwiVFwiLFxuICBcIlxcdWQ4MzVcXHVkY2IwXCI6IFwiVVwiLFxuICBcIlxcdWQ4MzVcXHVkY2IxXCI6IFwiVlwiLFxuICBcIlxcdWQ4MzVcXHVkY2IyXCI6IFwiV1wiLFxuICBcIlxcdWQ4MzVcXHVkY2IzXCI6IFwiWFwiLFxuICBcIlxcdWQ4MzVcXHVkY2I0XCI6IFwiWVwiLFxuICBcIlxcdWQ4MzVcXHVkY2I1XCI6IFwiWlwiXG59KTtcblxuLy8gTWFwcGluZyBvZiBVbmljb2RlIGFjY2VudCBjaGFyYWN0ZXJzIHRvIHRoZWlyIExhVGVYIGVxdWl2YWxlbnQgaW4gdGV4dCBhbmRcbi8vIG1hdGggbW9kZSAod2hlbiB0aGV5IGV4aXN0KS5cbnZhciB1bmljb2RlQWNjZW50cyA9IHtcbiAgXCJcXHUwMzAxXCI6IHsgdGV4dDogXCJcXFxcJ1wiLCBtYXRoOiBcIlxcXFxhY3V0ZVwiIH0sXG4gIFwiXFx1MDMwMFwiOiB7IHRleHQ6IFwiXFxcXGBcIiwgbWF0aDogXCJcXFxcZ3JhdmVcIiB9LFxuICBcIlxcdTAzMDhcIjogeyB0ZXh0OiAnXFxcXFwiJywgbWF0aDogXCJcXFxcZGRvdFwiIH0sXG4gIFwiXFx1MDMwM1wiOiB7IHRleHQ6IFwiXFxcXH5cIiwgbWF0aDogXCJcXFxcdGlsZGVcIiB9LFxuICBcIlxcdTAzMDRcIjogeyB0ZXh0OiBcIlxcXFw9XCIsIG1hdGg6IFwiXFxcXGJhclwiIH0sXG4gIFwiXFx1MDMwNlwiOiB7IHRleHQ6IFwiXFxcXHVcIiwgbWF0aDogXCJcXFxcYnJldmVcIiB9LFxuICBcIlxcdTAzMGNcIjogeyB0ZXh0OiBcIlxcXFx2XCIsIG1hdGg6IFwiXFxcXGNoZWNrXCIgfSxcbiAgXCJcXHUwMzAyXCI6IHsgdGV4dDogXCJcXFxcXlwiLCBtYXRoOiBcIlxcXFxoYXRcIiB9LFxuICBcIlxcdTAzMDdcIjogeyB0ZXh0OiBcIlxcXFwuXCIsIG1hdGg6IFwiXFxcXGRvdFwiIH0sXG4gIFwiXFx1MDMwYVwiOiB7IHRleHQ6IFwiXFxcXHJcIiwgbWF0aDogXCJcXFxcbWF0aHJpbmdcIiB9LFxuICBcIlxcdTAzMGJcIjogeyB0ZXh0OiBcIlxcXFxIXCIgfSxcbiAgJ1xcdTAzMjcnOiB7IHRleHQ6ICdcXFxcYycgfVxufTtcblxudmFyIHVuaWNvZGVTeW1ib2xzID0ge1xuICBcIsOhXCI6IFwiYcyBXCIsXG4gIFwiw6BcIjogXCJhzIBcIixcbiAgXCLDpFwiOiBcImHMiFwiLFxuICBcIsefXCI6IFwiYcyIzIRcIixcbiAgXCLDo1wiOiBcImHMg1wiLFxuICBcIsSBXCI6IFwiYcyEXCIsXG4gIFwixINcIjogXCJhzIZcIixcbiAgXCLhuq9cIjogXCJhzIbMgVwiLFxuICBcIuG6sVwiOiBcImHMhsyAXCIsXG4gIFwi4bq1XCI6IFwiYcyGzINcIixcbiAgXCLHjlwiOiBcImHMjFwiLFxuICBcIsOiXCI6IFwiYcyCXCIsXG4gIFwi4bqlXCI6IFwiYcyCzIFcIixcbiAgXCLhuqdcIjogXCJhzILMgFwiLFxuICBcIuG6q1wiOiBcImHMgsyDXCIsXG4gIFwiyKdcIjogXCJhzIdcIixcbiAgXCLHoVwiOiBcImHMh8yEXCIsXG4gIFwiw6VcIjogXCJhzIpcIixcbiAgXCLHu1wiOiBcImHMisyBXCIsXG4gIFwi4biDXCI6IFwiYsyHXCIsXG4gIFwixIdcIjogXCJjzIFcIixcbiAgXCLEjVwiOiBcImPMjFwiLFxuICBcIsSJXCI6IFwiY8yCXCIsXG4gIFwixItcIjogXCJjzIdcIixcbiAgXCLEj1wiOiBcImTMjFwiLFxuICBcIuG4i1wiOiBcImTMh1wiLFxuICBcIsOpXCI6IFwiZcyBXCIsXG4gIFwiw6hcIjogXCJlzIBcIixcbiAgXCLDq1wiOiBcImXMiFwiLFxuICBcIuG6vVwiOiBcImXMg1wiLFxuICBcIsSTXCI6IFwiZcyEXCIsXG4gIFwi4biXXCI6IFwiZcyEzIFcIixcbiAgXCLhuJVcIjogXCJlzITMgFwiLFxuICBcIsSVXCI6IFwiZcyGXCIsXG4gIFwixJtcIjogXCJlzIxcIixcbiAgXCLDqlwiOiBcImXMglwiLFxuICBcIuG6v1wiOiBcImXMgsyBXCIsXG4gIFwi4buBXCI6IFwiZcyCzIBcIixcbiAgXCLhu4VcIjogXCJlzILMg1wiLFxuICBcIsSXXCI6IFwiZcyHXCIsXG4gIFwi4bifXCI6IFwiZsyHXCIsXG4gIFwix7VcIjogXCJnzIFcIixcbiAgXCLhuKFcIjogXCJnzIRcIixcbiAgXCLEn1wiOiBcImfMhlwiLFxuICBcIsenXCI6IFwiZ8yMXCIsXG4gIFwixJ1cIjogXCJnzIJcIixcbiAgXCLEoVwiOiBcImfMh1wiLFxuICBcIuG4p1wiOiBcImjMiFwiLFxuICBcIsifXCI6IFwiaMyMXCIsXG4gIFwixKVcIjogXCJozIJcIixcbiAgXCLhuKNcIjogXCJozIdcIixcbiAgXCLDrVwiOiBcImnMgVwiLFxuICBcIsOsXCI6IFwiacyAXCIsXG4gIFwiw69cIjogXCJpzIhcIixcbiAgXCLhuK9cIjogXCJpzIjMgVwiLFxuICBcIsSpXCI6IFwiacyDXCIsXG4gIFwixKtcIjogXCJpzIRcIixcbiAgXCLErVwiOiBcImnMhlwiLFxuICBcIseQXCI6IFwiacyMXCIsXG4gIFwiw65cIjogXCJpzIJcIixcbiAgXCLHsFwiOiBcImrMjFwiLFxuICBcIsS1XCI6IFwiasyCXCIsXG4gIFwi4bixXCI6IFwia8yBXCIsXG4gIFwix6lcIjogXCJrzIxcIixcbiAgXCLEulwiOiBcImzMgVwiLFxuICBcIsS+XCI6IFwibMyMXCIsXG4gIFwi4bi/XCI6IFwibcyBXCIsXG4gIFwi4bmBXCI6IFwibcyHXCIsXG4gIFwixYRcIjogXCJuzIFcIixcbiAgXCLHuVwiOiBcIm7MgFwiLFxuICBcIsOxXCI6IFwibsyDXCIsXG4gIFwixYhcIjogXCJuzIxcIixcbiAgXCLhuYVcIjogXCJuzIdcIixcbiAgXCLDs1wiOiBcIm/MgVwiLFxuICBcIsOyXCI6IFwib8yAXCIsXG4gIFwiw7ZcIjogXCJvzIhcIixcbiAgXCLIq1wiOiBcIm/MiMyEXCIsXG4gIFwiw7VcIjogXCJvzINcIixcbiAgXCLhuY1cIjogXCJvzIPMgVwiLFxuICBcIuG5j1wiOiBcIm/Mg8yIXCIsXG4gIFwiyK1cIjogXCJvzIPMhFwiLFxuICBcIsWNXCI6IFwib8yEXCIsXG4gIFwi4bmTXCI6IFwib8yEzIFcIixcbiAgXCLhuZFcIjogXCJvzITMgFwiLFxuICBcIsWPXCI6IFwib8yGXCIsXG4gIFwix5JcIjogXCJvzIxcIixcbiAgXCLDtFwiOiBcIm/MglwiLFxuICBcIuG7kVwiOiBcIm/MgsyBXCIsXG4gIFwi4buTXCI6IFwib8yCzIBcIixcbiAgXCLhu5dcIjogXCJvzILMg1wiLFxuICBcIsivXCI6IFwib8yHXCIsXG4gIFwiyLFcIjogXCJvzIfMhFwiLFxuICBcIsWRXCI6IFwib8yLXCIsXG4gIFwi4bmVXCI6IFwicMyBXCIsXG4gIFwi4bmXXCI6IFwicMyHXCIsXG4gIFwixZVcIjogXCJyzIFcIixcbiAgXCLFmVwiOiBcInLMjFwiLFxuICBcIuG5mVwiOiBcInLMh1wiLFxuICBcIsWbXCI6IFwic8yBXCIsXG4gIFwi4bmlXCI6IFwic8yBzIdcIixcbiAgXCLFoVwiOiBcInPMjFwiLFxuICBcIuG5p1wiOiBcInPMjMyHXCIsXG4gIFwixZ1cIjogXCJzzIJcIixcbiAgXCLhuaFcIjogXCJzzIdcIixcbiAgXCLhupdcIjogXCJ0zIhcIixcbiAgXCLFpVwiOiBcInTMjFwiLFxuICBcIuG5q1wiOiBcInTMh1wiLFxuICBcIsO6XCI6IFwidcyBXCIsXG4gIFwiw7lcIjogXCJ1zIBcIixcbiAgXCLDvFwiOiBcInXMiFwiLFxuICBcIseYXCI6IFwidcyIzIFcIixcbiAgXCLHnFwiOiBcInXMiMyAXCIsXG4gIFwix5ZcIjogXCJ1zIjMhFwiLFxuICBcIseaXCI6IFwidcyIzIxcIixcbiAgXCLFqVwiOiBcInXMg1wiLFxuICBcIuG5uVwiOiBcInXMg8yBXCIsXG4gIFwixatcIjogXCJ1zIRcIixcbiAgXCLhubtcIjogXCJ1zITMiFwiLFxuICBcIsWtXCI6IFwidcyGXCIsXG4gIFwix5RcIjogXCJ1zIxcIixcbiAgXCLDu1wiOiBcInXMglwiLFxuICBcIsWvXCI6IFwidcyKXCIsXG4gIFwixbFcIjogXCJ1zItcIixcbiAgXCLhub1cIjogXCJ2zINcIixcbiAgXCLhuoNcIjogXCJ3zIFcIixcbiAgXCLhuoFcIjogXCJ3zIBcIixcbiAgXCLhuoVcIjogXCJ3zIhcIixcbiAgXCLFtVwiOiBcInfMglwiLFxuICBcIuG6h1wiOiBcInfMh1wiLFxuICBcIuG6mFwiOiBcInfMilwiLFxuICBcIuG6jVwiOiBcInjMiFwiLFxuICBcIuG6i1wiOiBcInjMh1wiLFxuICBcIsO9XCI6IFwiecyBXCIsXG4gIFwi4buzXCI6IFwiecyAXCIsXG4gIFwiw79cIjogXCJ5zIhcIixcbiAgXCLhu7lcIjogXCJ5zINcIixcbiAgXCLIs1wiOiBcInnMhFwiLFxuICBcIsW3XCI6IFwiecyCXCIsXG4gIFwi4bqPXCI6IFwiecyHXCIsXG4gIFwi4bqZXCI6IFwiecyKXCIsXG4gIFwixbpcIjogXCJ6zIFcIixcbiAgXCLFvlwiOiBcInrMjFwiLFxuICBcIuG6kVwiOiBcInrMglwiLFxuICBcIsW8XCI6IFwiesyHXCIsXG4gIFwiw4FcIjogXCJBzIFcIixcbiAgXCLDgFwiOiBcIkHMgFwiLFxuICBcIsOEXCI6IFwiQcyIXCIsXG4gIFwix55cIjogXCJBzIjMhFwiLFxuICBcIsODXCI6IFwiQcyDXCIsXG4gIFwixIBcIjogXCJBzIRcIixcbiAgXCLEglwiOiBcIkHMhlwiLFxuICBcIuG6rlwiOiBcIkHMhsyBXCIsXG4gIFwi4bqwXCI6IFwiQcyGzIBcIixcbiAgXCLhurRcIjogXCJBzIbMg1wiLFxuICBcIseNXCI6IFwiQcyMXCIsXG4gIFwiw4JcIjogXCJBzIJcIixcbiAgXCLhuqRcIjogXCJBzILMgVwiLFxuICBcIuG6plwiOiBcIkHMgsyAXCIsXG4gIFwi4bqqXCI6IFwiQcyCzINcIixcbiAgXCLIplwiOiBcIkHMh1wiLFxuICBcIsegXCI6IFwiQcyHzIRcIixcbiAgXCLDhVwiOiBcIkHMilwiLFxuICBcIse6XCI6IFwiQcyKzIFcIixcbiAgXCLhuIJcIjogXCJCzIdcIixcbiAgXCLEhlwiOiBcIkPMgVwiLFxuICBcIsSMXCI6IFwiQ8yMXCIsXG4gIFwixIhcIjogXCJDzIJcIixcbiAgXCLEilwiOiBcIkPMh1wiLFxuICBcIsSOXCI6IFwiRMyMXCIsXG4gIFwi4biKXCI6IFwiRMyHXCIsXG4gIFwiw4lcIjogXCJFzIFcIixcbiAgXCLDiFwiOiBcIkXMgFwiLFxuICBcIsOLXCI6IFwiRcyIXCIsXG4gIFwi4bq8XCI6IFwiRcyDXCIsXG4gIFwixJJcIjogXCJFzIRcIixcbiAgXCLhuJZcIjogXCJFzITMgVwiLFxuICBcIuG4lFwiOiBcIkXMhMyAXCIsXG4gIFwixJRcIjogXCJFzIZcIixcbiAgXCLEmlwiOiBcIkXMjFwiLFxuICBcIsOKXCI6IFwiRcyCXCIsXG4gIFwi4bq+XCI6IFwiRcyCzIFcIixcbiAgXCLhu4BcIjogXCJFzILMgFwiLFxuICBcIuG7hFwiOiBcIkXMgsyDXCIsXG4gIFwixJZcIjogXCJFzIdcIixcbiAgXCLhuJ5cIjogXCJGzIdcIixcbiAgXCLHtFwiOiBcIkfMgVwiLFxuICBcIuG4oFwiOiBcIkfMhFwiLFxuICBcIsSeXCI6IFwiR8yGXCIsXG4gIFwix6ZcIjogXCJHzIxcIixcbiAgXCLEnFwiOiBcIkfMglwiLFxuICBcIsSgXCI6IFwiR8yHXCIsXG4gIFwi4bimXCI6IFwiSMyIXCIsXG4gIFwiyJ5cIjogXCJIzIxcIixcbiAgXCLEpFwiOiBcIkjMglwiLFxuICBcIuG4olwiOiBcIkjMh1wiLFxuICBcIsONXCI6IFwiScyBXCIsXG4gIFwiw4xcIjogXCJJzIBcIixcbiAgXCLDj1wiOiBcIknMiFwiLFxuICBcIuG4rlwiOiBcIknMiMyBXCIsXG4gIFwixKhcIjogXCJJzINcIixcbiAgXCLEqlwiOiBcIknMhFwiLFxuICBcIsSsXCI6IFwiScyGXCIsXG4gIFwix49cIjogXCJJzIxcIixcbiAgXCLDjlwiOiBcIknMglwiLFxuICBcIsSwXCI6IFwiScyHXCIsXG4gIFwixLRcIjogXCJKzIJcIixcbiAgXCLhuLBcIjogXCJLzIFcIixcbiAgXCLHqFwiOiBcIkvMjFwiLFxuICBcIsS5XCI6IFwiTMyBXCIsXG4gIFwixL1cIjogXCJMzIxcIixcbiAgXCLhuL5cIjogXCJNzIFcIixcbiAgXCLhuYBcIjogXCJNzIdcIixcbiAgXCLFg1wiOiBcIk7MgVwiLFxuICBcIse4XCI6IFwiTsyAXCIsXG4gIFwiw5FcIjogXCJOzINcIixcbiAgXCLFh1wiOiBcIk7MjFwiLFxuICBcIuG5hFwiOiBcIk7Mh1wiLFxuICBcIsOTXCI6IFwiT8yBXCIsXG4gIFwiw5JcIjogXCJPzIBcIixcbiAgXCLDllwiOiBcIk/MiFwiLFxuICBcIsiqXCI6IFwiT8yIzIRcIixcbiAgXCLDlVwiOiBcIk/Mg1wiLFxuICBcIuG5jFwiOiBcIk/Mg8yBXCIsXG4gIFwi4bmOXCI6IFwiT8yDzIhcIixcbiAgXCLIrFwiOiBcIk/Mg8yEXCIsXG4gIFwixYxcIjogXCJPzIRcIixcbiAgXCLhuZJcIjogXCJPzITMgVwiLFxuICBcIuG5kFwiOiBcIk/MhMyAXCIsXG4gIFwixY5cIjogXCJPzIZcIixcbiAgXCLHkVwiOiBcIk/MjFwiLFxuICBcIsOUXCI6IFwiT8yCXCIsXG4gIFwi4buQXCI6IFwiT8yCzIFcIixcbiAgXCLhu5JcIjogXCJPzILMgFwiLFxuICBcIuG7llwiOiBcIk/MgsyDXCIsXG4gIFwiyK5cIjogXCJPzIdcIixcbiAgXCLIsFwiOiBcIk/Mh8yEXCIsXG4gIFwixZBcIjogXCJPzItcIixcbiAgXCLhuZRcIjogXCJQzIFcIixcbiAgXCLhuZZcIjogXCJQzIdcIixcbiAgXCLFlFwiOiBcIlLMgVwiLFxuICBcIsWYXCI6IFwiUsyMXCIsXG4gIFwi4bmYXCI6IFwiUsyHXCIsXG4gIFwixZpcIjogXCJTzIFcIixcbiAgXCLhuaRcIjogXCJTzIHMh1wiLFxuICBcIsWgXCI6IFwiU8yMXCIsXG4gIFwi4bmmXCI6IFwiU8yMzIdcIixcbiAgXCLFnFwiOiBcIlPMglwiLFxuICBcIuG5oFwiOiBcIlPMh1wiLFxuICBcIsWkXCI6IFwiVMyMXCIsXG4gIFwi4bmqXCI6IFwiVMyHXCIsXG4gIFwiw5pcIjogXCJVzIFcIixcbiAgXCLDmVwiOiBcIlXMgFwiLFxuICBcIsOcXCI6IFwiVcyIXCIsXG4gIFwix5dcIjogXCJVzIjMgVwiLFxuICBcIsebXCI6IFwiVcyIzIBcIixcbiAgXCLHlVwiOiBcIlXMiMyEXCIsXG4gIFwix5lcIjogXCJVzIjMjFwiLFxuICBcIsWoXCI6IFwiVcyDXCIsXG4gIFwi4bm4XCI6IFwiVcyDzIFcIixcbiAgXCLFqlwiOiBcIlXMhFwiLFxuICBcIuG5ulwiOiBcIlXMhMyIXCIsXG4gIFwixaxcIjogXCJVzIZcIixcbiAgXCLHk1wiOiBcIlXMjFwiLFxuICBcIsObXCI6IFwiVcyCXCIsXG4gIFwixa5cIjogXCJVzIpcIixcbiAgXCLFsFwiOiBcIlXMi1wiLFxuICBcIuG5vFwiOiBcIlbMg1wiLFxuICBcIuG6glwiOiBcIlfMgVwiLFxuICBcIuG6gFwiOiBcIlfMgFwiLFxuICBcIuG6hFwiOiBcIlfMiFwiLFxuICBcIsW0XCI6IFwiV8yCXCIsXG4gIFwi4bqGXCI6IFwiV8yHXCIsXG4gIFwi4bqMXCI6IFwiWMyIXCIsXG4gIFwi4bqKXCI6IFwiWMyHXCIsXG4gIFwiw51cIjogXCJZzIFcIixcbiAgXCLhu7JcIjogXCJZzIBcIixcbiAgXCLFuFwiOiBcIlnMiFwiLFxuICBcIuG7uFwiOiBcIlnMg1wiLFxuICBcIsiyXCI6IFwiWcyEXCIsXG4gIFwixbZcIjogXCJZzIJcIixcbiAgXCLhuo5cIjogXCJZzIdcIixcbiAgXCLFuVwiOiBcIlrMgVwiLFxuICBcIsW9XCI6IFwiWsyMXCIsXG4gIFwi4bqQXCI6IFwiWsyCXCIsXG4gIFwixbtcIjogXCJazIdcIixcbiAgXCLOrFwiOiBcIs6xzIFcIixcbiAgXCLhvbBcIjogXCLOscyAXCIsXG4gIFwi4b6xXCI6IFwizrHMhFwiLFxuICBcIuG+sFwiOiBcIs6xzIZcIixcbiAgXCLOrVwiOiBcIs61zIFcIixcbiAgXCLhvbJcIjogXCLOtcyAXCIsXG4gIFwizq5cIjogXCLOt8yBXCIsXG4gIFwi4b20XCI6IFwizrfMgFwiLFxuICBcIs6vXCI6IFwizrnMgVwiLFxuICBcIuG9tlwiOiBcIs65zIBcIixcbiAgXCLPilwiOiBcIs65zIhcIixcbiAgXCLOkFwiOiBcIs65zIjMgVwiLFxuICBcIuG/klwiOiBcIs65zIjMgFwiLFxuICBcIuG/kVwiOiBcIs65zIRcIixcbiAgXCLhv5BcIjogXCLOucyGXCIsXG4gIFwiz4xcIjogXCLOv8yBXCIsXG4gIFwi4b24XCI6IFwizr/MgFwiLFxuICBcIs+NXCI6IFwiz4XMgVwiLFxuICBcIuG9ulwiOiBcIs+FzIBcIixcbiAgXCLPi1wiOiBcIs+FzIhcIixcbiAgXCLOsFwiOiBcIs+FzIjMgVwiLFxuICBcIuG/olwiOiBcIs+FzIjMgFwiLFxuICBcIuG/oVwiOiBcIs+FzIRcIixcbiAgXCLhv6BcIjogXCLPhcyGXCIsXG4gIFwiz45cIjogXCLPicyBXCIsXG4gIFwi4b28XCI6IFwiz4nMgFwiLFxuICBcIs6OXCI6IFwizqXMgVwiLFxuICBcIuG/qlwiOiBcIs6lzIBcIixcbiAgXCLOq1wiOiBcIs6lzIhcIixcbiAgXCLhv6lcIjogXCLOpcyEXCIsXG4gIFwi4b+oXCI6IFwizqXMhlwiLFxuICBcIs6PXCI6IFwizqnMgVwiLFxuICBcIuG/ulwiOiBcIs6pzIBcIlxufTtcblxuLyogZXNsaW50IG5vLWNvbnN0YW50LWNvbmRpdGlvbjowICovXG5cbmNvbnN0IGJpbkxlZnRDYW5jZWxsZXJzID0gW1wiYmluXCIsIFwib3BcIiwgXCJvcGVuXCIsIFwicHVuY3RcIiwgXCJyZWxcIl07XG5jb25zdCBzaXplUmVnRXggPSAvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvO1xuY29uc3QgdGV4dFJlZ0V4ID0gL14gKlxcXFx0ZXh0LztcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmd1bGxldC5sZXhlcikgYWxzbyBzdXBwb3J0cyBwdWxsaW5nIG91dCB0b2tlbnMgYXQgYXJiaXRyYXJ5IHBsYWNlcy4gV2hlblxuICogaW5kaXZpZHVhbCB0b2tlbnMgYXJlIG5lZWRlZCBhdCBhIHBvc2l0aW9uLCB0aGUgbGV4ZXIgaXMgY2FsbGVkIHRvIHB1bGwgb3V0IGFcbiAqIHRva2VuLCB3aGljaCBpcyB0aGVuIHVzZWQuXG4gKlxuICogVGhlIHBhcnNlciBoYXMgYSBwcm9wZXJ0eSBjYWxsZWQgXCJtb2RlXCIgaW5kaWNhdGluZyB0aGUgbW9kZSB0aGF0XG4gKiB0aGUgcGFyc2VyIGlzIGN1cnJlbnRseSBpbi4gQ3VycmVudGx5IGl0IGhhcyB0byBiZSBvbmUgb2YgXCJtYXRoXCIgb3JcbiAqIFwidGV4dFwiLCB3aGljaCBkZW5vdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgaXMgYSBtYXRoLXlcbiAqIG9uZSBvciBhIHRleHQteSBvbmUgKGUuZy4gaW5zaWRlIFxcdGV4dCkuIEN1cnJlbnRseSwgdGhpcyBzZXJ2ZXMgdG9cbiAqIGxpbWl0IHRoZSBmdW5jdGlvbnMgd2hpY2ggY2FuIGJlIHVzZWQgaW4gdGV4dCBtb2RlLlxuICpcbiAqIFRoZSBtYWluIGZ1bmN0aW9ucyB0aGVuIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIHVzZWZ1bCBkYXRhIHRoYXRcbiAqIHdhcyBwYXJzZWQgYXQgaXRzIGdpdmVuIHBvaW50LCBhbmQgYSBuZXcgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgcGFyc2VkXG4gKiBkYXRhLiBUaGUgbWFpbiBmdW5jdGlvbnMgY2FuIGNhbGwgZWFjaCBvdGhlciBhbmQgY29udGludWUgdGhlIHBhcnNpbmcgYnlcbiAqIHVzaW5nIHRoZSByZXR1cm5lZCBwb3NpdGlvbiBhcyBhIG5ldyBzdGFydGluZyBwb2ludC5cbiAqXG4gKiBUaGVyZSBhcmUgYWxzbyBleHRyYSBgLmhhbmRsZS4uLmAgZnVuY3Rpb25zLCB3aGljaCBwdWxsIG91dCBzb21lIHJldXNlZFxuICogZnVuY3Rpb25hbGl0eSBpbnRvIHNlbGYtY29udGFpbmVkIGZ1bmN0aW9ucy5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIHJldHVybiBQYXJzZU5vZGVzLlxuICovXG5cbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncywgaXNQcmVhbWJsZSA9IGZhbHNlKSB7XG4gICAgLy8gU3RhcnQgaW4gbWF0aCBtb2RlXG4gICAgdGhpcy5tb2RlID0gXCJtYXRoXCI7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1hY3JvIGV4cGFuZGVyIChndWxsZXQpIGFuZCAoaW5kaXJlY3RseSB2aWEgdGhhdCkgYWxzbyBhXG4gICAgLy8gbmV3IGxleGVyIChtb3V0aCkgZm9yIHRoaXMgcGFyc2VyIChzdG9tYWNoLCBpbiB0aGUgbGFuZ3VhZ2Ugb2YgVGVYKVxuICAgIHRoaXMuZ3VsbGV0ID0gbmV3IE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLCB0aGlzLm1vZGUpO1xuICAgIC8vIFN0b3JlIHRoZSBzZXR0aW5ncyBmb3IgdXNlIGluIHBhcnNpbmdcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgLy8gQXJlIHdlIGRlZmluaW5nIGEgcHJlYW1ibGU/XG4gICAgdGhpcy5pc1ByZWFtYmxlID0gaXNQcmVhbWJsZTtcbiAgICAvLyBDb3VudCBsZWZ0cmlnaHQgZGVwdGggKGZvciBcXG1pZGRsZSBlcnJvcnMpXG4gICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IDA7XG4gICAgdGhpcy5wcmV2QXRvbVR5cGUgPSBcIlwiO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBhIHJlc3VsdCB0byBtYWtlIHN1cmUgaXQgaGFzIHRoZSByaWdodCB0eXBlLCBhbmQgdGhyb3dzIGFuXG4gICAqIGFwcHJvcHJpYXRlIGVycm9yIG90aGVyd2lzZS5cbiAgICovXG4gIGV4cGVjdCh0ZXh0LCBjb25zdW1lID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmZldGNoKCkudGV4dCAhPT0gdGV4dCkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYEV4cGVjdGVkICcke3RleHR9JywgZ290ICcke3RoaXMuZmV0Y2goKS50ZXh0fSdgLCB0aGlzLmZldGNoKCkpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZSkge1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2NhcmRzIHRoZSBjdXJyZW50IGxvb2thaGVhZCB0b2tlbiwgY29uc2lkZXJpbmcgaXQgY29uc3VtZWQuXG4gICAqL1xuICBjb25zdW1lKCkge1xuICAgIHRoaXMubmV4dFRva2VuID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBvciBpZiB0aGVyZSBpc24ndCBvbmUgKGF0IHRoZVxuICAgKiBiZWdpbm5pbmcsIG9yIGlmIHRoZSBwcmV2aW91cyBsb29rYWhlYWQgdG9rZW4gd2FzIGNvbnN1bWUoKWQpLFxuICAgKiBmZXRjaCB0aGUgbmV4dCB0b2tlbiBhcyB0aGUgbmV3IGxvb2thaGVhZCB0b2tlbiBhbmQgcmV0dXJuIGl0LlxuICAgKi9cbiAgZmV0Y2goKSB7XG4gICAgaWYgKHRoaXMubmV4dFRva2VuID09IG51bGwpIHtcbiAgICAgIHRoaXMubmV4dFRva2VuID0gdGhpcy5ndWxsZXQuZXhwYW5kTmV4dFRva2VuKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5leHRUb2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTd2l0Y2hlcyBiZXR3ZWVuIFwidGV4dFwiIGFuZCBcIm1hdGhcIiBtb2Rlcy5cbiAgICovXG4gIHN3aXRjaE1vZGUobmV3TW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5ndWxsZXQuc3dpdGNoTW9kZShuZXdNb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWluIHBhcnNpbmcgZnVuY3Rpb24sIHdoaWNoIHBhcnNlcyBhbiBlbnRpcmUgaW5wdXQuXG4gICAqL1xuICBwYXJzZSgpIHtcbiAgICAvLyBDcmVhdGUgYSBncm91cCBuYW1lc3BhY2UgZm9yIGV2ZXJ5ICQuLi4kLCAkJC4uLiQkLCBcXFsuLi5cXF0uKVxuICAgIC8vIEEgXFxkZWYgaXMgdGhlbiB2YWxpZCBvbmx5IHdpdGhpbiB0aGF0IHBhaXIgb2YgZGVsaW1pdGVycy5cbiAgICB0aGlzLmd1bGxldC5iZWdpbkdyb3VwKCk7XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5jb2xvcklzVGV4dENvbG9yKSB7XG4gICAgICAvLyBVc2Ugb2xkIFxcY29sb3IgYmVoYXZpb3IgKHNhbWUgYXMgTGFUZVgncyBcXHRleHRjb2xvcikgaWYgcmVxdWVzdGVkLlxuICAgICAgLy8gV2UgZG8gdGhpcyB3aXRoaW4gdGhlIGdyb3VwIGZvciB0aGUgbWF0aCBleHByZXNzaW9uLCBzbyBpdCBkb2Vzbid0XG4gICAgICAvLyBwb2xsdXRlIHNldHRpbmdzLm1hY3Jvcy5cbiAgICAgIHRoaXMuZ3VsbGV0Lm1hY3Jvcy5zZXQoXCJcXFxcY29sb3JcIiwgXCJcXFxcdGV4dGNvbG9yXCIpO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgaW5wdXRcbiAgICBjb25zdCBwYXJzZSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcblxuICAgIC8vIElmIHdlIHN1Y2NlZWRlZCwgbWFrZSBzdXJlIHRoZXJlJ3MgYW4gRU9GIGF0IHRoZSBlbmRcbiAgICB0aGlzLmV4cGVjdChcIkVPRlwiKTtcblxuICAgIGlmICh0aGlzLmlzUHJlYW1ibGUpIHtcbiAgICAgIGNvbnN0IG1hY3JvcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBPYmplY3QuZW50cmllcyh0aGlzLmd1bGxldC5tYWNyb3MuY3VycmVudCkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIG1hY3Jvc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgICByZXR1cm4gbWFjcm9zXG4gICAgfVxuXG4gICAgLy8gVGhlIG9ubHkgbG9jYWwgbWFjcm8gdGhhdCB3ZSB3YW50IHRvIHNhdmUgaXMgZnJvbSBcXHRhZy5cbiAgICBjb25zdCB0YWcgPSB0aGlzLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKTtcblxuICAgIC8vIEVuZCB0aGUgZ3JvdXAgbmFtZXNwYWNlIGZvciB0aGUgZXhwcmVzc2lvblxuICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG5cbiAgICBpZiAodGFnKSB7IHRoaXMuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50W1wiXFxcXGRmQHRhZ1wiXSA9IHRhZzsgfVxuXG4gICAgcmV0dXJuIHBhcnNlO1xuICB9XG5cbiAgc3RhdGljIGdldCBlbmRPZkV4cHJlc3Npb24oKSB7XG4gICAgcmV0dXJuIFtcIn1cIiwgXCJcXFxcZW5kZ3JvdXBcIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiXFxcXGVuZHRvZ2dsZVwiLCBcIiZcIl07XG4gIH1cblxuICAvKipcbiAgICogRnVsbHkgcGFyc2UgYSBzZXBhcmF0ZSBzZXF1ZW5jZSBvZiB0b2tlbnMgYXMgYSBzZXBhcmF0ZSBqb2IuXG4gICAqIFRva2VucyBzaG91bGQgYmUgc3BlY2lmaWVkIGluIHJldmVyc2Ugb3JkZXIsIGFzIGluIGEgTWFjcm9EZWZpbml0aW9uLlxuICAgKi9cbiAgc3VicGFyc2UodG9rZW5zKSB7XG4gICAgLy8gU2F2ZSB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBjdXJyZW50IGpvYi5cbiAgICBjb25zdCBvbGRUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIHRoaXMuY29uc3VtZSgpO1xuXG4gICAgLy8gUnVuIHRoZSBuZXcgam9iLCB0ZXJtaW5hdGluZyBpdCB3aXRoIGFuIGV4Y2VzcyAnfSdcbiAgICB0aGlzLmd1bGxldC5wdXNoVG9rZW4obmV3IFRva2VuKFwifVwiKSk7XG4gICAgdGhpcy5ndWxsZXQucHVzaFRva2Vucyh0b2tlbnMpO1xuICAgIGNvbnN0IHBhcnNlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuICAgIHRoaXMuZXhwZWN0KFwifVwiKTtcblxuICAgIC8vIFJlc3RvcmUgdGhlIG5leHQgdG9rZW4gZnJvbSB0aGUgY3VycmVudCBqb2IuXG4gICAgdGhpcy5uZXh0VG9rZW4gPSBvbGRUb2tlbjtcblxuICAgIHJldHVybiBwYXJzZTtcbiAgfVxuXG4vKipcbiAgICogUGFyc2VzIGFuIFwiZXhwcmVzc2lvblwiLCB3aGljaCBpcyBhIGxpc3Qgb2YgYXRvbXMuXG4gICAqXG4gICAqIGBicmVha09uSW5maXhgOiBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeCBub2Rlcz8gVGhpc1xuICAgKiAgICAgICAgICAgICAgICAgaGFwcGVucyB3aGVuIGZ1bmN0aW9ucyBoYXZlIGhpZ2hlciBwcmVjZWRlbmNlIGhhbiBpbmZpeFxuICAgKiAgICAgICAgICAgICAgICAgbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLlxuICAgKlxuICAgKiBgYnJlYWtPblRva2VuVGV4dGA6IFRoZSB0ZXh0IG9mIHRoZSB0b2tlbiB0aGF0IHRoZSBleHByZXNzaW9uIHNob3VsZCBlbmRcbiAgICogICAgICAgICAgICAgICAgICAgICB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uLlxuICAgKlxuICAgKiBgYnJlYWtPbk1pZGRsZWA6IFxcY29sb3IsIFxcb3ZlciwgYW5kIG9sZCBzdHlsaW5nIGZ1bmN0aW9ucyB3b3JrIG9uIGFuIGltcGxpY2l0IGdyb3VwLlxuICAgKiAgICAgICAgICAgICAgICAgIFRoZXNlIGdyb3VwcyBlbmQganVzdCBiZWZvcmUgdGhlIHVzdWFsIHRva2VucywgYnV0IHRoZXkgYWxzb1xuICAgKiAgICAgICAgICAgICAgICAgIGVuZCBqdXN0IGJlZm9yZSBgXFxtaWRkbGVgLlxuICAgKi9cbiAgcGFyc2VFeHByZXNzaW9uKGJyZWFrT25JbmZpeCwgYnJlYWtPblRva2VuVGV4dCwgYnJlYWtPbk1pZGRsZSkge1xuICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICB0aGlzLnByZXZBdG9tVHlwZSA9IFwiXCI7XG4gICAgLy8gS2VlcCBhZGRpbmcgYXRvbXMgdG8gdGhlIGJvZHkgdW50aWwgd2UgY2FuJ3QgcGFyc2UgYW55IG1vcmUgYXRvbXMgKGVpdGhlclxuICAgIC8vIHdlIHJlYWNoZWQgdGhlIGVuZCwgYSB9LCBvciBhIFxccmlnaHQpXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIElnbm9yZSBzcGFjZXMgaW4gbWF0aCBtb2RlXG4gICAgICBpZiAodGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxleCA9IHRoaXMuZmV0Y2goKTtcbiAgICAgIGlmIChQYXJzZXIuZW5kT2ZFeHByZXNzaW9uLmluZGV4T2YobGV4LnRleHQpICE9PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChicmVha09uVG9rZW5UZXh0ICYmIGxleC50ZXh0ID09PSBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGJyZWFrT25NaWRkbGUgJiYgbGV4LnRleHQgPT09IFwiXFxcXG1pZGRsZVwiKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoYnJlYWtPbkluZml4ICYmIGZ1bmN0aW9uc1tsZXgudGV4dF0gJiYgZnVuY3Rpb25zW2xleC50ZXh0XS5pbmZpeCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0b20gPSB0aGlzLnBhcnNlQXRvbShicmVha09uVG9rZW5UZXh0KTtcbiAgICAgIGlmICghYXRvbSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoYXRvbS50eXBlID09PSBcImludGVybmFsXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBib2R5LnB1c2goYXRvbSk7XG4gICAgICAvLyBLZWVwIGEgcmVjb3JkIG9mIHRoZSBhdG9tIHR5cGUsIHNvIHRoYXQgb3AuanMgY2FuIHNldCBjb3JyZWN0IHNwYWNpbmcuXG4gICAgICB0aGlzLnByZXZBdG9tVHlwZSA9IGF0b20udHlwZSA9PT0gXCJhdG9tXCIgPyBhdG9tLmZhbWlseSA6IGF0b20udHlwZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXdyaXRlcyBpbmZpeCBvcGVyYXRvcnMgc3VjaCBhcyBcXG92ZXIgd2l0aCBjb3JyZXNwb25kaW5nIGNvbW1hbmRzIHN1Y2hcbiAgICogYXMgXFxmcmFjLlxuICAgKlxuICAgKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgaW5maXggb3BlcmF0b3IgcGVyIGdyb3VwLiAgSWYgdGhlcmUncyBtb3JlIHRoYW4gb25lXG4gICAqIHRoZW4gdGhlIGV4cHJlc3Npb24gaXMgYW1iaWd1b3VzLiAgVGhpcyBjYW4gYmUgcmVzb2x2ZWQgYnkgYWRkaW5nIHt9LlxuICAgKi9cbiAgaGFuZGxlSW5maXhOb2Rlcyhib2R5KSB7XG4gICAgbGV0IG92ZXJJbmRleCA9IC0xO1xuICAgIGxldCBmdW5jTmFtZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGJvZHlbaV0udHlwZSA9PT0gXCJpbmZpeFwiKSB7XG4gICAgICAgIGlmIChvdmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJvbmx5IG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXBcIiwgYm9keVtpXS50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgb3ZlckluZGV4ID0gaTtcbiAgICAgICAgZnVuY05hbWUgPSBib2R5W2ldLnJlcGxhY2VXaXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdmVySW5kZXggIT09IC0xICYmIGZ1bmNOYW1lKSB7XG4gICAgICBsZXQgbnVtZXJOb2RlO1xuICAgICAgbGV0IGRlbm9tTm9kZTtcblxuICAgICAgY29uc3QgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgY29uc3QgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTtcblxuICAgICAgaWYgKG51bWVyQm9keS5sZW5ndGggPT09IDEgJiYgbnVtZXJCb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1lck5vZGUgPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogdGhpcy5tb2RlLCBib2R5OiBudW1lckJvZHkgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICBkZW5vbU5vZGUgPSBkZW5vbUJvZHlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZW5vbU5vZGUgPSB7IHR5cGU6IFwib3JkZ3JvdXBcIiwgbW9kZTogdGhpcy5tb2RlLCBib2R5OiBkZW5vbUJvZHkgfTtcbiAgICAgIH1cblxuICAgICAgbGV0IG5vZGU7XG4gICAgICBpZiAoZnVuY05hbWUgPT09IFwiXFxcXFxcXFxhYm92ZWZyYWNcIikge1xuICAgICAgICBub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGJvZHlbb3ZlckluZGV4XSwgZGVub21Ob2RlXSwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbnVtZXJOb2RlLCBkZW5vbU5vZGVdLCBbXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25vZGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgc3Vic2NyaXB0IG9yIHN1cGVyc2NyaXB0IHdpdGggbmljZSBlcnJvcnMuXG4gICAqL1xuICBoYW5kbGVTdXBTdWJzY3JpcHQoXG4gICAgbmFtZSAvLyBGb3IgZXJyb3IgcmVwb3J0aW5nLlxuICApIHtcbiAgICBjb25zdCBzeW1ib2xUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBjb25zdCBzeW1ib2wgPSBzeW1ib2xUb2tlbi50ZXh0O1xuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOyAvLyBpZ25vcmUgc3BhY2VzIGJlZm9yZSBzdXAvc3Vic2NyaXB0IGFyZ3VtZW50XG4gICAgY29uc3QgZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAobmFtZSk7XG5cbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGdyb3VwIGFmdGVyICdcIiArIHN5bWJvbCArIFwiJ1wiLCBzeW1ib2xUb2tlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICAgKiBjb250YWluZWQgd2l0aGluIGEgY29sb3Igbm9kZSB3aG9zZSBjb2xvciBpcyBkZXRlcm1pbmVkIGJ5IGVycm9yQ29sb3JcbiAgICovXG4gIGZvcm1hdFVuc3VwcG9ydGVkQ21kKHRleHQpIHtcbiAgICBjb25zdCB0ZXh0b3JkQXJyYXkgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgdGV4dG9yZEFycmF5LnB1c2goeyB0eXBlOiBcInRleHRvcmRcIiwgbW9kZTogXCJ0ZXh0XCIsIHRleHQ6IHRleHRbaV0gfSk7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dE5vZGUgPSB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgIGJvZHk6IHRleHRvcmRBcnJheVxuICAgIH07XG5cbiAgICBjb25zdCBjb2xvck5vZGUgPSB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgYm9keTogW3RleHROb2RlXVxuICAgIH07XG5cbiAgICByZXR1cm4gY29sb3JOb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIGdyb3VwIHdpdGggb3B0aW9uYWwgc3VwZXIvc3Vic2NyaXB0cy5cbiAgICovXG4gIHBhcnNlQXRvbShicmVha09uVG9rZW5UZXh0KSB7XG4gICAgLy8gVGhlIGJvZHkgb2YgYW4gYXRvbSBpcyBhbiBpbXBsaWNpdCBncm91cCwgc28gdGhhdCB0aGluZ3MgbGlrZVxuICAgIC8vIFxcbGVmdCh4XFxyaWdodCleMiB3b3JrIGNvcnJlY3RseS5cbiAgICBjb25zdCBiYXNlID0gdGhpcy5wYXJzZUdyb3VwKFwiYXRvbVwiLCBicmVha09uVG9rZW5UZXh0KTtcblxuICAgIC8vIEluIHRleHQgbW9kZSwgd2UgZG9uJ3QgaGF2ZSBzdXBlcnNjcmlwdHMgb3Igc3Vic2NyaXB0c1xuICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG5cbiAgICAvLyBOb3RlIHRoYXQgYmFzZSBtYXkgYmUgZW1wdHkgKGkuZS4gbnVsbCkgYXQgdGhpcyBwb2ludC5cblxuICAgIGxldCBzdXBlcnNjcmlwdDtcbiAgICBsZXQgc3Vic2NyaXB0O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBHdWFyYW50ZWVkIGluIG1hdGggbW9kZSwgc28gZWF0IGFueSBzcGFjZXMgZmlyc3QuXG4gICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTtcblxuICAgICAgLy8gTGV4IHRoZSBmaXJzdCB0b2tlblxuICAgICAgY29uc3QgbGV4ID0gdGhpcy5mZXRjaCgpO1xuXG4gICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIGxpbWl0IGNvbnRyb2xcbiAgICAgICAgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wXCIpIHtcbiAgICAgICAgICBjb25zdCBsaW1pdHMgPSBsZXgudGV4dCA9PT0gXCJcXFxcbGltaXRzXCI7XG4gICAgICAgICAgYmFzZS5saW1pdHMgPSBsaW1pdHM7XG4gICAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2UgJiYgYmFzZS50eXBlID09PSBcIm9wZXJhdG9ybmFtZVwiKSB7XG4gICAgICAgICAgaWYgKGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSB7XG4gICAgICAgICAgICBiYXNlLmxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJMaW1pdCBjb250cm9scyBtdXN0IGZvbGxvdyBhIG1hdGggb3BlcmF0b3JcIiwgbGV4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiXlwiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHN1cGVyc2NyaXB0IHN0YXJ0XG4gICAgICAgIGlmIChzdXBlcnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRG91YmxlIHN1cGVyc2NyaXB0XCIsIGxleCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpO1xuICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJfXCIpIHtcbiAgICAgICAgLy8gV2UgZ290IGEgc3Vic2NyaXB0IHN0YXJ0XG4gICAgICAgIGlmIChzdWJzY3JpcHQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdWJzY3JpcHRcIiwgbGV4KTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1YnNjcmlwdFwiKTtcbiAgICAgIH0gZWxzZSBpZiAobGV4LnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIHByaW1lXG4gICAgICAgIGlmIChzdXBlcnNjcmlwdCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiRG91YmxlIHN1cGVyc2NyaXB0XCIsIGxleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJpbWUgPSB7IHR5cGU6IFwidGV4dG9yZFwiLCBtb2RlOiB0aGlzLm1vZGUsIHRleHQ6IFwiXFxcXHByaW1lXCIgfTtcblxuICAgICAgICAvLyBNYW55IHByaW1lcyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciwgc28gd2UgaGFuZGxlIHRoaXMgaGVyZVxuICAgICAgICBjb25zdCBwcmltZXMgPSBbcHJpbWVdO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgLy8gS2VlcCBsZXhpbmcgdG9rZW5zIHVudGlsIHdlIGdldCBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHByaW1lXG4gICAgICAgIHdoaWxlICh0aGlzLmZldGNoKCkudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAvLyBGb3IgZWFjaCBvbmUsIGFkZCBhbm90aGVyIHByaW1lIHRvIHRoZSBsaXN0XG4gICAgICAgICAgcHJpbWVzLnB1c2gocHJpbWUpO1xuICAgICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlJ3MgYSBzdXBlcnNjcmlwdCBmb2xsb3dpbmcgdGhlIHByaW1lcywgY29tYmluZSB0aGF0XG4gICAgICAgIC8vIHN1cGVyc2NyaXB0IGluIHdpdGggdGhlIHByaW1lcy5cbiAgICAgICAgaWYgKHRoaXMuZmV0Y2goKS50ZXh0ID09PSBcIl5cIikge1xuICAgICAgICAgIHByaW1lcy5wdXNoKHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KFwic3VwZXJzY3JpcHRcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1dCBldmVyeXRoaW5nIGludG8gYW4gb3JkZ3JvdXAgYXMgdGhlIHN1cGVyc2NyaXB0XG4gICAgICAgIHN1cGVyc2NyaXB0ID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IHRoaXMubW9kZSwgYm9keTogcHJpbWVzIH07XG4gICAgICB9IGVsc2UgaWYgKHVTdWJzQW5kU3Vwc1tsZXgudGV4dF0pIHtcbiAgICAgICAgLy8gQSBVbmljb2RlIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIFdlIHRyZWF0IHRoZXNlIHNpbWlsYXJseSB0byB0aGUgdW5pY29kZS1tYXRoIHBhY2thZ2UuXG4gICAgICAgIC8vIFNvIHdlIHJlbmRlciBhIHN0cmluZyBvZiBVbmljb2RlIChzdWJ8c3VwZXIpc2NyaXB0cyB0aGVcbiAgICAgICAgLy8gc2FtZSBhcyBhIChzdWJ8c3VwZXIpc2NyaXB0IG9mIHJlZ3VsYXIgY2hhcmFjdGVycy5cbiAgICAgICAgY29uc3QgaXNTdWIgPSB1bmljb2RlU3ViUmVnRXgudGVzdChsZXgudGV4dCk7XG4gICAgICAgIGNvbnN0IHN1YnN1cFRva2VucyA9IFtdO1xuICAgICAgICBzdWJzdXBUb2tlbnMucHVzaChuZXcgVG9rZW4odVN1YnNBbmRTdXBzW2xleC50ZXh0XSkpO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgLy8gQ29udGludWUgZmV0Y2hpbmcgdG9rZW5zIHRvIGZpbGwgb3V0IHRoZSBncm91cC5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMuZmV0Y2goKS50ZXh0O1xuICAgICAgICAgIGlmICghKHVTdWJzQW5kU3Vwc1t0b2tlbl0pKSB7IGJyZWFrIH1cbiAgICAgICAgICBpZiAodW5pY29kZVN1YlJlZ0V4LnRlc3QodG9rZW4pICE9PSBpc1N1YikgeyBicmVhayB9XG4gICAgICAgICAgc3Vic3VwVG9rZW5zLnVuc2hpZnQobmV3IFRva2VuKHVTdWJzQW5kU3Vwc1t0b2tlbl0pKTtcbiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgY3JlYXRlIGEgKHN1YnxzdXBlcilzY3JpcHQuXG4gICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLnN1YnBhcnNlKHN1YnN1cFRva2Vucyk7XG4gICAgICAgIGlmIChpc1N1Yikge1xuICAgICAgICAgIHN1YnNjcmlwdCA9IHsgdHlwZTogXCJvcmRncm91cFwiLCBtb2RlOiBcIm1hdGhcIiwgYm9keSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1cGVyc2NyaXB0ID0geyB0eXBlOiBcIm9yZGdyb3VwXCIsIG1vZGU6IFwibWF0aFwiLCBib2R5IH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0IHdhc24ndCBeLCBfLCBhIFVuaWNvZGUgKHN1YnxzdXBlcilzY3JpcHQsIG9yICcsIHN0b3AgcGFyc2luZyBzdXBlci9zdWJzY3JpcHRzXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdXBlcnNjcmlwdCB8fCBzdWJzY3JpcHQpIHtcbiAgICAgIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gXCJtdWx0aXNjcmlwdFwiICYmICFiYXNlLnBvc3RzY3JpcHRzKSB7XG4gICAgICAgIC8vIGJhc2UgaXMgdGhlIHJlc3VsdCBvZiBhIFxccHJlc2NyaXB0IGZ1bmN0aW9uLlxuICAgICAgICAvLyBXcml0ZSB0aGUgc3ViLSAmIHN1cGVyc2NyaXB0cyBpbnRvIHRoZSBtdWx0aXNjcmlwdCBlbGVtZW50LlxuICAgICAgICBiYXNlLnBvc3RzY3JpcHRzID0geyBzdXA6IHN1cGVyc2NyaXB0LCBzdWI6IHN1YnNjcmlwdCB9O1xuICAgICAgICByZXR1cm4gYmFzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgZ290IGVpdGhlciBhIHN1cGVyc2NyaXB0IG9yIHN1YnNjcmlwdCwgY3JlYXRlIGEgc3Vwc3ViXG4gICAgICAgIGNvbnN0IGlzRm9sbG93ZWRCeURlbGltaXRlciA9ICghYmFzZSB8fCBiYXNlLnR5cGUgIT09IFwib3BcIiAmJiBiYXNlLnR5cGUgIT09IFwib3BlcmF0b3JuYW1lXCIpXG4gICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICA6IGlzRGVsaW1pdGVyKHRoaXMubmV4dFRva2VuLnRleHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwic3Vwc3ViXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGJhc2U6IGJhc2UsXG4gICAgICAgICAgc3VwOiBzdXBlcnNjcmlwdCxcbiAgICAgICAgICBzdWI6IHN1YnNjcmlwdCxcbiAgICAgICAgICBpc0ZvbGxvd2VkQnlEZWxpbWl0ZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgcmV0dXJuIHRoZSBvcmlnaW5hbCBib2R5XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGFuIGVudGlyZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGl0cyBiYXNlIGFuZCBhbGwgb2YgaXRzIGFyZ3VtZW50cy5cbiAgICovXG4gIHBhcnNlRnVuY3Rpb24oXG4gICAgYnJlYWtPblRva2VuVGV4dCxcbiAgICBuYW1lIC8vIEZvciBkZXRlcm1pbmluZyBpdHMgY29udGV4dFxuICApIHtcbiAgICBjb25zdCB0b2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBjb25zdCBmdW5jID0gdG9rZW4udGV4dDtcbiAgICBjb25zdCBmdW5jRGF0YSA9IGZ1bmN0aW9uc1tmdW5jXTtcbiAgICBpZiAoIWZ1bmNEYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lKCk7IC8vIGNvbnN1bWUgY29tbWFuZCB0b2tlblxuXG4gICAgaWYgKG5hbWUgJiYgbmFtZSAhPT0gXCJhdG9tXCIgJiYgIWZ1bmNEYXRhLmFsbG93ZWRJbkFyZ3VtZW50KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgXCJHb3QgZnVuY3Rpb24gJ1wiICsgZnVuYyArIFwiJyB3aXRoIG5vIGFyZ3VtZW50c1wiICsgKG5hbWUgPyBcIiBhcyBcIiArIG5hbWUgOiBcIlwiKSxcbiAgICAgICAgdG9rZW5cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5UZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNhbid0IHVzZSBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIGluIHRleHQgbW9kZVwiLCB0b2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IFwibWF0aFwiICYmIGZ1bmNEYXRhLmFsbG93ZWRJbk1hdGggPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkNhbid0IHVzZSBmdW5jdGlvbiAnXCIgKyBmdW5jICsgXCInIGluIG1hdGggbW9kZVwiLCB0b2tlbik7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldkF0b21UeXBlID0gdGhpcy5wcmV2QXRvbVR5cGU7XG4gICAgY29uc3QgeyBhcmdzLCBvcHRBcmdzIH0gPSB0aGlzLnBhcnNlQXJndW1lbnRzKGZ1bmMsIGZ1bmNEYXRhKTtcbiAgICB0aGlzLnByZXZBdG9tVHlwZSA9IHByZXZBdG9tVHlwZTtcbiAgICByZXR1cm4gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgb3B0QXJncywgdG9rZW4sIGJyZWFrT25Ub2tlblRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiBoYW5kbGVyIHdpdGggYSBzdWl0YWJsZSBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gICAqL1xuICBjYWxsRnVuY3Rpb24obmFtZSwgYXJncywgb3B0QXJncywgdG9rZW4sIGJyZWFrT25Ub2tlblRleHQpIHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgZnVuY05hbWU6IG5hbWUsXG4gICAgICBwYXJzZXI6IHRoaXMsXG4gICAgICB0b2tlbixcbiAgICAgIGJyZWFrT25Ub2tlblRleHRcbiAgICB9O1xuICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbnNbbmFtZV07XG4gICAgaWYgKGZ1bmMgJiYgZnVuYy5oYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZnVuYy5oYW5kbGVyKGNvbnRleHQsIGFyZ3MsIG9wdEFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgTm8gZnVuY3Rpb24gaGFuZGxlciBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gICAqL1xuICBwYXJzZUFyZ3VtZW50cyhcbiAgICBmdW5jLCAvLyBTaG91bGQgbG9vayBsaWtlIFwiXFxuYW1lXCIgb3IgXCJcXGJlZ2lue25hbWV9XCIuXG4gICAgZnVuY0RhdGFcbiAgKSB7XG4gICAgY29uc3QgdG90YWxBcmdzID0gZnVuY0RhdGEubnVtQXJncyArIGZ1bmNEYXRhLm51bU9wdGlvbmFsQXJncztcbiAgICBpZiAodG90YWxBcmdzID09PSAwKSB7XG4gICAgICByZXR1cm4geyBhcmdzOiBbXSwgb3B0QXJnczogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgY29uc3Qgb3B0QXJncyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbEFyZ3M7IGkrKykge1xuICAgICAgbGV0IGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBpIDwgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuXG4gICAgICBpZiAoXG4gICAgICAgIChmdW5jRGF0YS5wcmltaXRpdmUgJiYgYXJnVHlwZSA9PSBudWxsKSB8fFxuICAgICAgICAvLyBcXHNxcnQgZXhwYW5kcyBpbnRvIHByaW1pdGl2ZSBpZiBvcHRpb25hbCBhcmd1bWVudCBkb2Vzbid0IGV4aXN0XG4gICAgICAgIChmdW5jRGF0YS50eXBlID09PSBcInNxcnRcIiAmJiBpID09PSAxICYmIG9wdEFyZ3NbMF0gPT0gbnVsbClcbiAgICAgICkge1xuICAgICAgICBhcmdUeXBlID0gXCJwcmltaXRpdmVcIjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKGBhcmd1bWVudCB0byAnJHtmdW5jfSdgLCBhcmdUeXBlLCBpc09wdGlvbmFsKTtcbiAgICAgIGlmIChpc09wdGlvbmFsKSB7XG4gICAgICAgIG9wdEFyZ3MucHVzaChhcmcpO1xuICAgICAgfSBlbHNlIGlmIChhcmcgIT0gbnVsbCkge1xuICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIk51bGwgYXJndW1lbnQsIHBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1Z1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBhcmdzLCBvcHRBcmdzIH07XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGEgZ3JvdXAgd2hlbiB0aGUgbW9kZSBpcyBjaGFuZ2luZy5cbiAgICovXG4gIHBhcnNlR3JvdXBPZlR5cGUobmFtZSwgdHlwZSwgb3B0aW9uYWwpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJzaXplXCI6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2l6ZUdyb3VwKG9wdGlvbmFsKTtcbiAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVcmxHcm91cChvcHRpb25hbCk7XG4gICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCB0eXBlKTtcbiAgICAgIGNhc2UgXCJoYm94XCI6IHtcbiAgICAgICAgLy8gaGJveCBhcmd1bWVudCB0eXBlIHdyYXBzIHRoZSBhcmd1bWVudCBpbiB0aGUgZXF1aXZhbGVudCBvZlxuICAgICAgICAvLyBcXGhib3gsIHdoaWNoIGlzIGxpa2UgXFx0ZXh0IGJ1dCBzd2l0Y2hpbmcgdG8gXFx0ZXh0c3R5bGUgc2l6ZS5cbiAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgXCJ0ZXh0XCIpO1xuICAgICAgICByZXR1cm4gZ3JvdXAgIT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogXCJzdHlsaW5nXCIsXG4gICAgICAgICAgICBtb2RlOiBncm91cC5tb2RlLFxuICAgICAgICAgICAgYm9keTogW2dyb3VwXSxcbiAgICAgICAgICAgIHNjcmlwdExldmVsOiBcInRleHRcIiAvLyBzaW11bGF0ZSBcXHRleHRzdHlsZVxuICAgICAgICAgIH1cbiAgICAgICAgICA6IG51bGw7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmF3XCI6IHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJyYXdcIiwgb3B0aW9uYWwpO1xuICAgICAgICByZXR1cm4gdG9rZW4gIT0gbnVsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgdHlwZTogXCJyYXdcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgc3RyaW5nOiB0b2tlbi50ZXh0XG4gICAgICAgICAgfVxuICAgICAgICAgIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJwcmltaXRpdmVcIjoge1xuICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkEgcHJpbWl0aXZlIGFyZ3VtZW50IGNhbm5vdCBiZSBvcHRpb25hbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMucGFyc2VHcm91cChuYW1lKTtcbiAgICAgICAgaWYgKGdyb3VwID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkV4cGVjdGVkIGdyb3VwIGFzIFwiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICB9XG4gICAgICBjYXNlIFwib3JpZ2luYWxcIjpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJVbmtub3duIGdyb3VwIHR5cGUgYXMgXCIgKyBuYW1lLCB0aGlzLmZldGNoKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjYXJkIGFueSBzcGFjZSB0b2tlbnMsIGZldGNoaW5nIHRoZSBuZXh0IG5vbi1zcGFjZSB0b2tlbi5cbiAgICovXG4gIGNvbnN1bWVTcGFjZXMoKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5mZXRjaCgpLnRleHQ7XG4gICAgICAvLyBcXHVmZTBlIGlzIHRoZSBVbmljb2RlIHZhcmlhdGlvbiBzZWxlY3RvciB0byBzdXByZXNzIGVtb2ppLiBJZ25vcmUgaXQuXG4gICAgICBpZiAoY2ggPT09IFwiIFwiIHx8IGNoID09PSBcIlxcdTAwYTBcIiB8fCBjaCA9PT0gXCJcXHVmZTBlXCIpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSBncm91cCwgZXNzZW50aWFsbHkgcmV0dXJuaW5nIHRoZSBzdHJpbmcgZm9ybWVkIGJ5IHRoZVxuICAgKiBicmFjZS1lbmNsb3NlZCB0b2tlbnMgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcGFyc2VTdHJpbmdHcm91cChcbiAgICBtb2RlTmFtZSwgLy8gVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlcy5cbiAgICBvcHRpb25hbFxuICApIHtcbiAgICBjb25zdCBhcmdUb2tlbiA9IHRoaXMuZ3VsbGV0LnNjYW5Bcmd1bWVudChvcHRpb25hbCk7XG4gICAgaWYgKGFyZ1Rva2VuID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBsZXQgbmV4dFRva2VuO1xuICAgIHdoaWxlICgobmV4dFRva2VuID0gdGhpcy5mZXRjaCgpKS50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICBzdHIgKz0gbmV4dFRva2VuLnRleHQ7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG4gICAgdGhpcy5jb25zdW1lKCk7IC8vIGNvbnN1bWUgdGhlIGVuZCBvZiB0aGUgYXJndW1lbnRcbiAgICBhcmdUb2tlbi50ZXh0ID0gc3RyO1xuICAgIHJldHVybiBhcmdUb2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYSByZWdleC1kZWxpbWl0ZWQgZ3JvdXA6IHRoZSBsYXJnZXN0IHNlcXVlbmNlIG9mIHRva2Vuc1xuICAgKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAgICogZm9ybWVkIGJ5IHRoZSB0b2tlbnMgcGx1cyBzb21lIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgcGFyc2VSZWdleEdyb3VwKFxuICAgIHJlZ2V4LFxuICAgIG1vZGVOYW1lIC8vIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXMuXG4gICkge1xuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSB0aGlzLmZldGNoKCk7XG4gICAgbGV0IGxhc3RUb2tlbiA9IGZpcnN0VG9rZW47XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgbGV0IG5leHRUb2tlbjtcbiAgICB3aGlsZSAoKG5leHRUb2tlbiA9IHRoaXMuZmV0Y2goKSkudGV4dCAhPT0gXCJFT0ZcIiAmJiByZWdleC50ZXN0KHN0ciArIG5leHRUb2tlbi50ZXh0KSkge1xuICAgICAgbGFzdFRva2VuID0gbmV4dFRva2VuO1xuICAgICAgc3RyICs9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgfVxuICAgIGlmIChzdHIgPT09IFwiXCIpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBcIiArIG1vZGVOYW1lICsgXCI6ICdcIiArIGZpcnN0VG9rZW4udGV4dCArIFwiJ1wiLCBmaXJzdFRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0VG9rZW4ucmFuZ2UobGFzdFRva2VuLCBzdHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHNpemUgc3BlY2lmaWNhdGlvbiwgY29uc2lzdGluZyBvZiBtYWduaXR1ZGUgYW5kIHVuaXQuXG4gICAqL1xuICBwYXJzZVNpemVHcm91cChvcHRpb25hbCkge1xuICAgIGxldCByZXM7XG4gICAgbGV0IGlzQmxhbmsgPSBmYWxzZTtcbiAgICAvLyBkb24ndCBleHBhbmQgYmVmb3JlIHBhcnNlU3RyaW5nR3JvdXBcbiAgICB0aGlzLmd1bGxldC5jb25zdW1lU3BhY2VzKCk7XG4gICAgaWYgKCFvcHRpb25hbCAmJiB0aGlzLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSBcIntcIikge1xuICAgICAgcmVzID0gdGhpcy5wYXJzZVJlZ2V4R3JvdXAoL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9ICokLywgXCJzaXplXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbmFsICYmIHJlcy50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gQmVjYXVzZSB3ZSd2ZSB0ZXN0ZWQgZm9yIHdoYXQgaXMgIW9wdGlvbmFsLCB0aGlzIGJsb2NrIHdvbid0XG4gICAgICAvLyBhZmZlY3QgXFxrZXJuLCBcXGhzcGFjZSwgZXRjLiBJdCB3aWxsIGNhcHR1cmUgdGhlIG1hbmRhdG9yeSBhcmd1bWVudHNcbiAgICAgIC8vIHRvIFxcZ2VuZnJhYyBhbmQgXFxhYm92ZS5cbiAgICAgIHJlcy50ZXh0ID0gXCIwcHRcIjsgLy8gRW5hYmxlIFxcYWJvdmV7fVxuICAgICAgaXNCbGFuayA9IHRydWU7IC8vIFRoaXMgaXMgaGVyZSBzcGVjaWZpY2FsbHkgZm9yIFxcZ2VuZnJhY1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IHNpemVSZWdFeC5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkludmFsaWQgc2l6ZTogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgIG51bWJlcjogKyhtYXRjaFsxXSArIG1hdGNoWzJdKSwgLy8gc2lnbiArIG1hZ25pdHVkZSwgY2FzdCB0byBudW1iZXJcbiAgICAgIHVuaXQ6IG1hdGNoWzNdXG4gICAgfTtcbiAgICBpZiAoIXZhbGlkVW5pdChkYXRhKSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIHVuaXQ6ICdcIiArIGRhdGEudW5pdCArIFwiJ1wiLCByZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzaXplXCIsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICAgIGlzQmxhbmtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBVUkwsIGNoZWNraW5nIGVzY2FwZWQgbGV0dGVycyBhbmQgYWxsb3dlZCBwcm90b2NvbHMsXG4gICAqIGFuZCBzZXR0aW5nIHRoZSBjYXRjb2RlIG9mICUgYXMgYW4gYWN0aXZlIGNoYXJhY3RlciAoYXMgaW4gXFxoeXBlcnJlZikuXG4gICAqL1xuICBwYXJzZVVybEdyb3VwKG9wdGlvbmFsKSB7XG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIiVcIiwgMTMpOyAvLyBhY3RpdmUgY2hhcmFjdGVyXG4gICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZShcIn5cIiwgMTIpOyAvLyBvdGhlciBjaGFyYWN0ZXJcbiAgICBjb25zdCByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJ1cmxcIiwgb3B0aW9uYWwpO1xuICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoXCIlXCIsIDE0KTsgLy8gY29tbWVudCBjaGFyYWN0ZXJcbiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKFwiflwiLCAxMyk7IC8vIGFjdGl2ZSBjaGFyYWN0ZXJcbiAgICBpZiAocmVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBoeXBlcnJlZiBwYWNrYWdlIGFsbG93cyBiYWNrc2xhc2hlcyBhbG9uZSBpbiBocmVmLCBidXQgZG9lc24ndFxuICAgIC8vIGdlbmVyYXRlIHZhbGlkIGxpbmtzIGluIHN1Y2ggY2FzZXM7IHdlIGludGVycHJldCB0aGlzIGFzXG4gICAgLy8gXCJ1bmRlZmluZWRcIiBiZWhhdmlvdXIsIGFuZCBrZWVwIHRoZW0gYXMtaXMuIFNvbWUgYnJvd3NlciB3aWxsXG4gICAgLy8gcmVwbGFjZSBiYWNrc2xhc2hlcyB3aXRoIGZvcndhcmQgc2xhc2hlcy5cbiAgICBsZXQgdXJsID0gcmVzLnRleHQucmVwbGFjZSgvXFxcXChbIyQlJn5fXnt9XSkvZywgXCIkMVwiKTtcbiAgICB1cmwgPSByZXMudGV4dC5yZXBsYWNlKC97XFx1MjA0NH0vZywgXCIvXCIpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVybFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgdXJsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gYXJndW1lbnQgd2l0aCB0aGUgbW9kZSBzcGVjaWZpZWQuXG4gICAqL1xuICBwYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIG1vZGUpIHtcbiAgICBjb25zdCBhcmdUb2tlbiA9IHRoaXMuZ3VsbGV0LnNjYW5Bcmd1bWVudChvcHRpb25hbCk7XG4gICAgaWYgKGFyZ1Rva2VuID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgaWYgKG1vZGUpIHtcbiAgICAgIC8vIFN3aXRjaCB0byBzcGVjaWZpZWQgbW9kZVxuICAgICAgdGhpcy5zd2l0Y2hNb2RlKG1vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTtcbiAgICBjb25zdCBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIFwiRU9GXCIpO1xuICAgIC8vIFRPRE86IGZpbmQgYW4gYWx0ZXJuYXRpdmUgd2F5IHRvIGRlbm90ZSB0aGUgZW5kXG4gICAgdGhpcy5leHBlY3QoXCJFT0ZcIik7IC8vIGV4cGVjdCB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudFxuICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgdHlwZTogXCJvcmRncm91cFwiLFxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgbG9jOiBhcmdUb2tlbi5sb2MsXG4gICAgICBib2R5OiBleHByZXNzaW9uXG4gICAgfTtcblxuICAgIGlmIChtb2RlKSB7XG4gICAgICAvLyBTd2l0Y2ggbW9kZSBiYWNrXG4gICAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW4gb3JkaW5hcnkgZ3JvdXAsIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBudWNsZXVzIChsaWtlIFwieFwiKVxuICAgKiBvciBhbiBleHByZXNzaW9uIGluIGJyYWNlcyAobGlrZSBcInt4K3l9XCIpIG9yIGFuIGltcGxpY2l0IGdyb3VwLCBhIGdyb3VwXG4gICAqIHRoYXQgc3RhcnRzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgZW5kcyByaWdodCBiZWZvcmUgYSBoaWdoZXIgZXhwbGljaXRcbiAgICogZ3JvdXAgZW5kcywgb3IgYXQgRU9GLlxuICAgKi9cbiAgcGFyc2VHcm91cChcbiAgICBuYW1lLCAvLyBGb3IgZXJyb3IgcmVwb3J0aW5nLlxuICAgIGJyZWFrT25Ub2tlblRleHRcbiAgKSB7XG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTtcbiAgICBjb25zdCB0ZXh0ID0gZmlyc3RUb2tlbi50ZXh0O1xuXG4gICAgbGV0IHJlc3VsdDtcbiAgICAvLyBUcnkgdG8gcGFyc2UgYW4gb3BlbiBicmFjZSBvciBcXGJlZ2luZ3JvdXBcbiAgICBpZiAodGV4dCA9PT0gXCJ7XCIgfHwgdGV4dCA9PT0gXCJcXFxcYmVnaW5ncm91cFwiIHx8IHRleHQgPT09IFwiXFxcXHRvZ2dsZVwiKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIGNvbnN0IGdyb3VwRW5kID0gdGV4dCA9PT0gXCJ7XCJcbiAgICAgICAgPyBcIn1cIlxuICAgICAgICA6IHRleHQgPT09IFwiXFxcXGJlZ2luZ3JvdXBcIlxuICAgICAgICA/IFwiXFxcXGVuZGdyb3VwXCJcbiAgICAgICAgOiBcIlxcXFxlbmR0b2dnbGVcIjtcblxuICAgICAgdGhpcy5ndWxsZXQuYmVnaW5Hcm91cCgpO1xuICAgICAgLy8gSWYgd2UgZ2V0IGEgYnJhY2UsIHBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgZ3JvdXBFbmQpO1xuICAgICAgY29uc3QgbGFzdFRva2VuID0gdGhpcy5mZXRjaCgpO1xuICAgICAgdGhpcy5leHBlY3QoZ3JvdXBFbmQpOyAvLyBDaGVjayB0aGF0IHdlIGdvdCBhIG1hdGNoaW5nIGNsb3NpbmcgYnJhY2VcbiAgICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IChsYXN0VG9rZW4udGV4dCA9PT0gXCJcXFxcZW5kdG9nZ2xlXCIgPyBcInRvZ2dsZVwiIDogXCJvcmRncm91cFwiKSxcbiAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGZpcnN0VG9rZW4sIGxhc3RUb2tlbiksXG4gICAgICAgIGJvZHk6IGV4cHJlc3Npb24sXG4gICAgICAgIC8vIEEgZ3JvdXAgZm9ybWVkIGJ5IFxcYmVnaW5ncm91cC4uLlxcZW5kZ3JvdXAgaXMgYSBzZW1pLXNpbXBsZSBncm91cFxuICAgICAgICAvLyB3aGljaCBkb2Vzbid0IGFmZmVjdCBzcGFjaW5nIGluIG1hdGggbW9kZSwgaS5lLiwgaXMgdHJhbnNwYXJlbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xOTMwL1xuICAgICAgICBzZW1pc2ltcGxlOiB0ZXh0ID09PSBcIlxcXFxiZWdpbmdyb3VwXCIgfHwgdW5kZWZpbmVkXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSBleGlzdHMgYSBmdW5jdGlvbiB3aXRoIHRoaXMgbmFtZSwgcGFyc2UgdGhlIGZ1bmN0aW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHJldHVybiBhIG51Y2xldXNcbiAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VGdW5jdGlvbihicmVha09uVG9rZW5UZXh0LCBuYW1lKSB8fCB0aGlzLnBhcnNlU3ltYm9sKCk7XG4gICAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgdGV4dFswXSA9PT0gXCJcXFxcXCIgJiZcbiAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGltcGxpY2l0Q29tbWFuZHMsIHRleHQgKSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmZvcm1hdFVuc3VwcG9ydGVkQ21kKHRleHQpO1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtIGxpZ2F0dXJlLWxpa2UgY29tYmluYXRpb25zIG9mIGNoYXJhY3RlcnMgZm9yIHRleHQgbW9kZS5cbiAgICogVGhpcyBpbmNsdWRlcyBpbnB1dHMgbGlrZSBcIi0tXCIsIFwiLS0tXCIsIFwiYGBcIiBhbmQgXCInJ1wiLlxuICAgKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gICAqIGNoYXJhY3RlciBpbiBlYWNoIHZhbHVlIGJ5IGEgc2luZ2xlIHRleHRvcmQgbm9kZSBoYXZpbmcgbXVsdGlwbGVcbiAgICogY2hhcmFjdGVycyBpbiBpdHMgdmFsdWUuICBUaGUgcmVwcmVzZW50YXRpb24gaXMgc3RpbGwgQVNDSUkgc291cmNlLlxuICAgKiBUaGUgZ3JvdXAgd2lsbCBiZSBtb2RpZmllZCBpbiBwbGFjZS5cbiAgICovXG4gIGZvcm1MaWdhdHVyZXMoZ3JvdXApIHtcbiAgICBsZXQgbiA9IGdyb3VwLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGEgPSBncm91cFtpXTtcbiAgICAgIGNvbnN0IHYgPSBhLnRleHQ7XG4gICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgIGlmIChpICsgMSA8IG4gJiYgZ3JvdXBbaSArIDJdLnRleHQgPT09IFwiLVwiKSB7XG4gICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgICAgbW9kZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAyXSksXG4gICAgICAgICAgICB0ZXh0OiBcIi0tLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRvcmRcIixcbiAgICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLFxuICAgICAgICAgICAgdGV4dDogXCItLVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKHYgPT09IFwiJ1wiIHx8IHYgPT09IFwiYFwiKSAmJiBncm91cFtpICsgMV0udGV4dCA9PT0gdikge1xuICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwge1xuICAgICAgICAgIHR5cGU6IFwidGV4dG9yZFwiLFxuICAgICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDFdKSxcbiAgICAgICAgICB0ZXh0OiB2ICsgdlxuICAgICAgICB9KTtcbiAgICAgICAgbiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBzaW5nbGUgY2hhcmFjdGVyXG4gICAqIHN5bWJvbHMgYW5kIHNwZWNpYWwgZnVuY3Rpb25zIGxpa2UgXFx2ZXJiLlxuICAgKi9cbiAgcGFyc2VTeW1ib2woKSB7XG4gICAgY29uc3QgbnVjbGV1cyA9IHRoaXMuZmV0Y2goKTtcbiAgICBsZXQgdGV4dCA9IG51Y2xldXMudGV4dDtcblxuICAgIGlmICgvXlxcXFx2ZXJiW15hLXpBLVpdLy50ZXN0KHRleHQpKSB7XG4gICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgIGxldCBhcmcgPSB0ZXh0LnNsaWNlKDUpO1xuICAgICAgY29uc3Qgc3RhciA9IGFyZy5jaGFyQXQoMCkgPT09IFwiKlwiO1xuICAgICAgaWYgKHN0YXIpIHtcbiAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEpO1xuICAgICAgfVxuICAgICAgLy8gTGV4ZXIncyB0b2tlblJlZ2V4IGlzIGNvbnN0cnVjdGVkIHRvIGFsd2F5cyBoYXZlIG1hdGNoaW5nXG4gICAgICAvLyBmaXJzdC9sYXN0IGNoYXJhY3RlcnMuXG4gICAgICBpZiAoYXJnLmxlbmd0aCA8IDIgfHwgYXJnLmNoYXJBdCgwKSAhPT0gYXJnLnNsaWNlKC0xKSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgXFxcXHZlcmIgYXNzZXJ0aW9uIGZhaWxlZCAtLVxuICAgICAgICAgICAgICAgICAgICBwbGVhc2UgcmVwb3J0IHdoYXQgaW5wdXQgY2F1c2VkIHRoaXMgYnVnYCk7XG4gICAgICB9XG4gICAgICBhcmcgPSBhcmcuc2xpY2UoMSwgLTEpOyAvLyByZW1vdmUgZmlyc3QgYW5kIGxhc3QgY2hhclxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ2ZXJiXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICBib2R5OiBhcmcsXG4gICAgICAgIHN0YXJcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIHNob3VsZCBoYXZlIGEgc3ltYm9sLCBwb3NzaWJseSB3aXRoIGFjY2VudHMuXG4gICAgLy8gRmlyc3QgZXhwYW5kIGFueSBhY2NlbnRlZCBiYXNlIHN5bWJvbCBhY2NvcmRpbmcgdG8gdW5pY29kZVN5bWJvbHMuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1bmljb2RlU3ltYm9scywgdGV4dFswXSkgJiZcbiAgICAgIHRoaXMubW9kZSA9PT0gXCJtYXRoXCIgJiYgIXN5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0WzBdXSkge1xuICAgICAgLy8gVGhpcyBiZWhhdmlvciBpcyBub3Qgc3RyaWN0IChYZVRlWC1jb21wYXRpYmxlKSBpbiBtYXRoIG1vZGUuXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QgJiYgdGhpcy5tb2RlID09PSBcIm1hdGhcIikge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgQWNjZW50ZWQgVW5pY29kZSB0ZXh0IGNoYXJhY3RlciBcIiR7dGV4dFswXX1cIiB1c2VkIGluIGAgKyBgbWF0aCBtb2RlYCxcbiAgICAgICAgICBudWNsZXVzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0ZXh0ID0gdW5pY29kZVN5bWJvbHNbdGV4dFswXV0gKyB0ZXh0LnNsaWNlKDEpO1xuICAgIH1cbiAgICAvLyBTdHJpcCBvZmYgYW55IGNvbWJpbmluZyBjaGFyYWN0ZXJzXG4gICAgY29uc3QgbWF0Y2ggPSB0aGlzLm1vZGUgPT09IFwibWF0aFwiXG4gICAgICA/IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleC5leGVjKHRleHQpXG4gICAgICA6IG51bGw7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgaWYgKHRleHQgPT09IFwiaVwiKSB7XG4gICAgICAgIHRleHQgPSBcIlxcdTAxMzFcIjsgLy8gZG90bGVzcyBpLCBpbiBtYXRoIGFuZCB0ZXh0IG1vZGVcbiAgICAgIH0gZWxzZSBpZiAodGV4dCA9PT0gXCJqXCIpIHtcbiAgICAgICAgdGV4dCA9IFwiXFx1MDIzN1wiOyAvLyBkb3RsZXNzIGosIGluIG1hdGggYW5kIHRleHQgbW9kZVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZWNvZ25pemUgYmFzZSBzeW1ib2xcbiAgICBsZXQgc3ltYm9sO1xuICAgIGlmIChzeW1ib2xzW3RoaXMubW9kZV1bdGV4dF0pIHtcbiAgICAgIGxldCBncm91cCA9IHN5bWJvbHNbdGhpcy5tb2RlXVt0ZXh0XS5ncm91cDtcbiAgICAgIGlmIChncm91cCA9PT0gXCJiaW5cIiAmJiBiaW5MZWZ0Q2FuY2VsbGVycy5pbmNsdWRlcyh0aGlzLnByZXZBdG9tVHlwZSkpIHtcbiAgICAgICAgLy8gQ2hhbmdlIGZyb20gYSBiaW5hcnkgb3BlcmF0b3IgdG8gYSB1bmFyeSAocHJlZml4KSBvcGVyYXRvclxuICAgICAgICBncm91cCA9IFwib3BlblwiO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9jID0gU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyk7XG4gICAgICBsZXQgcztcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoQVRPTVMsIGdyb3VwICkpIHtcbiAgICAgICAgY29uc3QgZmFtaWx5ID0gZ3JvdXA7XG4gICAgICAgIHMgPSB7XG4gICAgICAgICAgdHlwZTogXCJhdG9tXCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGZhbWlseSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgICBpZiAoKGZhbWlseSA9PT0gXCJyZWxcIiB8fCBmYW1pbHkgPT09IFwiYmluXCIpICYmIHRoaXMucHJldkF0b21UeXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgIGlmICh0ZXh0UmVnRXgudGVzdChsb2MubGV4ZXIuaW5wdXQuc2xpY2UobG9jLmVuZCkpKSB7XG4gICAgICAgICAgICBzLm5lZWRzU3BhY2luZyA9IHRydWU7ICAvLyBGaXggYSBNYXRoTUwgYnVnLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFzY2lpRnJvbVNjcmlwdFt0ZXh0XSkge1xuICAgICAgICAgIC8vIFVuaWNvZGUgMTQgZGlzYW1iaWd1YXRlcyBjaGFuY2VyeSBmcm9tIHJvdW5kaGFuZC5cbiAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvY2hhcnRzL1BERi9VMUQ0MDAucGRmXG4gICAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgICAgY29uc3QgbmV4dENvZGUgPSB0aGlzLmZldGNoKCkudGV4dC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIC8vIG1hdGhjYWwgaXMgVGVtbWwgZGVmYXVsdC4gVXNlIG1hdGhzY3JpcHQgaWYgY2FsbGVkIGZvci5cbiAgICAgICAgICBjb25zdCBmb250ID0gbmV4dENvZGUgPT09IDB4ZmUwMSA/IFwibWF0aHNjclwiIDogXCJtYXRoY2FsXCI7XG4gICAgICAgICAgaWYgKG5leHRDb2RlID09PSAweGZlMDAgfHwgbmV4dENvZGUgPT09IDB4ZmUwMSkgeyB0aGlzLmNvbnN1bWUoKTsgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZvbnRcIixcbiAgICAgICAgICAgIG1vZGU6IFwibWF0aFwiLFxuICAgICAgICAgICAgZm9udCxcbiAgICAgICAgICAgIGJvZHk6IHsgdHlwZTogXCJtYXRob3JkXCIsIG1vZGU6IFwibWF0aFwiLCBsb2MsIHRleHQ6IGFzY2lpRnJvbVNjcmlwdFt0ZXh0XSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERlZmF1bHQgb3JkIGNoYXJhY3Rlci4gTm8gZGlzYW1iaWd1YXRpb24gbmVjZXNzYXJ5LlxuICAgICAgICBzID0ge1xuICAgICAgICAgIHR5cGU6IGdyb3VwLFxuICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSxcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3ltYm9sID0gcztcbiAgICB9IGVsc2UgaWYgKHRleHQuY2hhckNvZGVBdCgwKSA+PSAweDgwIHx8IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleC5leGVjKHRleHQpKSB7XG4gICAgICAvLyBubyBzeW1ib2wgZm9yIGUuZy4gXlxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RyaWN0ICYmIHRoaXMubW9kZSA9PT0gXCJtYXRoXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoYFVuaWNvZGUgdGV4dCBjaGFyYWN0ZXIgXCIke3RleHRbMF19XCIgdXNlZCBpbiBtYXRoIG1vZGVgLCBudWNsZXVzKVxuICAgICAgfVxuICAgICAgLy8gQWxsIG5vbm1hdGhlbWF0aWNhbCBVbmljb2RlIGNoYXJhY3RlcnMgYXJlIHJlbmRlcmVkIGFzIGlmIHRoZXlcbiAgICAgIC8vIGFyZSBpbiB0ZXh0IG1vZGUgKHdyYXBwZWQgaW4gXFx0ZXh0KSBiZWNhdXNlIHRoYXQncyB3aGF0IGl0XG4gICAgICAvLyB0YWtlcyB0byByZW5kZXIgdGhlbSBpbiBMYVRlWC5cbiAgICAgIHN5bWJvbCA9IHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0b3JkXCIsXG4gICAgICAgIG1vZGU6IFwidGV4dFwiLFxuICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpLFxuICAgICAgICB0ZXh0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gRU9GLCBeLCBfLCB7LCB9LCBldGMuXG4gICAgfVxuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIC8vIFRyYW5zZm9ybSBjb21iaW5pbmcgY2hhcmFjdGVycyBpbnRvIGFjY2VudHNcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2hbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYWNjZW50ID0gbWF0Y2hbMF1baV07XG4gICAgICAgIGlmICghdW5pY29kZUFjY2VudHNbYWNjZW50XSkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBVbmtub3duIGFjY2VudCAnICR7YWNjZW50fSdgLCBudWNsZXVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21tYW5kID0gdW5pY29kZUFjY2VudHNbYWNjZW50XVt0aGlzLm1vZGVdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmljb2RlQWNjZW50c1thY2NlbnRdLnRleHQ7XG4gICAgICAgIGlmICghY29tbWFuZCkge1xuICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGBBY2NlbnQgJHthY2NlbnR9IHVuc3VwcG9ydGVkIGluICR7dGhpcy5tb2RlfSBtb2RlYCwgbnVjbGV1cyk7XG4gICAgICAgIH1cbiAgICAgICAgc3ltYm9sID0ge1xuICAgICAgICAgIHR5cGU6IFwiYWNjZW50XCIsXG4gICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksXG4gICAgICAgICAgbGFiZWw6IGNvbW1hbmQsXG4gICAgICAgICAgaXNTdHJldGNoeTogZmFsc2UsXG4gICAgICAgICAgYmFzZTogc3ltYm9sXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzeW1ib2w7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gZXhwcmVzc2lvbiB1c2luZyBhIFBhcnNlciwgdGhlbiByZXR1cm5zIHRoZSBwYXJzZWQgcmVzdWx0LlxuICovXG5jb25zdCBwYXJzZVRyZWUgPSBmdW5jdGlvbih0b1BhcnNlLCBzZXR0aW5ncykge1xuICBpZiAoISh0eXBlb2YgdG9QYXJzZSA9PT0gXCJzdHJpbmdcIiB8fCB0b1BhcnNlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUZW1tbCBjYW4gb25seSBwYXJzZSBzdHJpbmcgdHlwZWQgZXhwcmVzc2lvblwiKVxuICB9XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIodG9QYXJzZSwgc2V0dGluZ3MpO1xuICAvLyBCbGFuayBvdXQgYW55IFxcZGZAdGFnIHRvIGF2b2lkIHNwdXJpb3VzIFwiRHVwbGljYXRlIFxcdGFnXCIgZXJyb3JzXG4gIGRlbGV0ZSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50W1wiXFxcXGRmQHRhZ1wiXTtcblxuICBsZXQgdHJlZSA9IHBhcnNlci5wYXJzZSgpO1xuXG4gIC8vIExhVGVYIGlnbm9yZXMgYSBcXHRhZyBwbGFjZWQgb3V0c2lkZSBhbiBBTVMgZW52aXJvbm1lbnQuXG4gIGlmICghKHRyZWUubGVuZ3RoID4gMCAmJiAgdHJlZVswXS50eXBlICYmIHRyZWVbMF0udHlwZSA9PT0gXCJhcnJheVwiICYmIHRyZWVbMF0uYWRkRXFuTnVtKSkge1xuICAgIC8vIElmIHRoZSBpbnB1dCB1c2VkIFxcdGFnLCBpdCB3aWxsIHNldCB0aGUgXFxkZkB0YWcgbWFjcm8gdG8gdGhlIHRhZy5cbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIHNlcGFyYXRlbHkgcGFyc2UgdGhlIHRhZyBhbmQgd3JhcCB0aGUgdHJlZS5cbiAgICBpZiAocGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KFwiXFxcXGRmQHRhZ1wiKSkge1xuICAgICAgaWYgKCFzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIlxcXFx0YWcgd29ya3Mgb25seSBpbiBkaXNwbGF5IG1vZGVcIilcbiAgICAgIH1cbiAgICAgIHBhcnNlci5ndWxsZXQuZmVlZChcIlxcXFxkZkB0YWdcIik7XG4gICAgICB0cmVlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJ0YWdcIixcbiAgICAgICAgICBtb2RlOiBcInRleHRcIixcbiAgICAgICAgICBib2R5OiB0cmVlLFxuICAgICAgICAgIHRhZzogcGFyc2VyLnBhcnNlKClcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJlZVxufTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHN0eWxlIHRoYXQgdGhlIG1hdGhtbEJ1aWxkZXIgY2Fycmllc1xuICogYXJvdW5kIHdpdGggaXQuIERhdGEgaXMgaGVsZCBpbiBhbiBgU3R5bGVgIG9iamVjdCwgYW5kIHdoZW5cbiAqIHJlY3Vyc2luZywgYSBuZXcgYFN0eWxlYCBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYC53aXRoKmAgZnVuY3Rpb25zLlxuICovXG5cbmNvbnN0IHN1Yk9yU3VwTGV2ZWwgPSBbMiwgMiwgMywgM107XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgbWFpbiBTdHlsZSBjbGFzcy4gSXQgY29udGFpbnMgdGhlIGN1cnJlbnQgc3R5bGUubGV2ZWwsIGNvbG9yLCBhbmQgZm9udC5cbiAqXG4gKiBTdHlsZSBvYmplY3RzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQuIFRvIGNyZWF0ZSBhIG5ldyBTdHlsZSB3aXRoXG4gKiBkaWZmZXJlbnQgcHJvcGVydGllcywgY2FsbCBhIGAud2l0aCpgIG1ldGhvZC5cbiAqL1xuY2xhc3MgU3R5bGUge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgLy8gU3R5bGUubGV2ZWwgY2FuIGJlIDAgfCAxIHwgMiB8IDMsIHdoaWNoIGNvcnJlc3BvbmQgdG9cbiAgICAvLyAgICAgICBkaXNwbGF5c3R5bGUsIHRleHRzdHlsZSwgc2NyaXB0c3R5bGUsIGFuZCBzY3JpcHRzY3JpcHRzdHlsZS5cbiAgICAvLyBzdHlsZS5sZXZlbCB1c3VhbGx5IGRvZXMgbm90IGRpcmVjdGx5IHNldCBNYXRoTUwncyBzY3JpcHQgbGV2ZWwuIE1hdGhNTCBkb2VzIHRoYXQgaXRzZWxmLlxuICAgIC8vIEhvd2V2ZXIsIENocm9taXVtIGRvZXMgbm90IHN0b3Agc2hyaW5raW5nIGFmdGVyIHNjcmlwdHNjcmlwdHN0eWxlLCBzbyB3ZSBkbyBleHBsaWNpdGx5XG4gICAgLy8gc2V0IGEgc2NyaXB0bGV2ZWwgYXR0cmlidXRlIGluIHRob3NlIGNvbmRpdGlvbnMuXG4gICAgLy8gV2UgYWxzbyB1c2Ugc3R5bGUubGV2ZWwgdG8gdHJhY2sgbWF0aCBzdHlsZSBzbyB0aGF0IHdlIGNhbiBnZXQgdGhlIGNvcnJlY3RcbiAgICAvLyBzY3JpcHRsZXZlbCB3aGVuIG5lZWRlZCBpbiBzdXBzdWIuanMsIG1hdGhjaG9pY2UuanMsIG9yIGZvciBkaW1lbnNpb25zIGluIGVtLlxuICAgIHRoaXMubGV2ZWwgPSBkYXRhLmxldmVsO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yOyAgLy8gc3RyaW5nIHwgdm9pZFxuICAgIC8vIEEgZm9udCBmYW1pbHkgYXBwbGllcyB0byBhIGdyb3VwIG9mIGZvbnRzIChpLmUuIFNhbnNTZXJpZiksIHdoaWxlIGEgZm9udFxuICAgIC8vIHJlcHJlc2VudHMgYSBzcGVjaWZpYyBmb250IChpLmUuIFNhbnNTZXJpZiBCb2xkKS5cbiAgICAvLyBTZWU6IGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMjM1MC9kaWZmZXJlbmNlLWJldHdlZW4tdGV4dHJtLWFuZC1tYXRocm1cbiAgICB0aGlzLmZvbnQgPSBkYXRhLmZvbnQgfHwgXCJcIjsgICAgICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgdGhpcy5mb250RmFtaWx5ID0gZGF0YS5mb250RmFtaWx5IHx8IFwiXCI7ICAgIC8vIHN0cmluZ1xuICAgIHRoaXMuZm9udFNpemUgPSBkYXRhLmZvbnRTaXplIHx8IDEuMDsgICAgICAgLy8gbnVtYmVyXG4gICAgdGhpcy5mb250V2VpZ2h0ID0gZGF0YS5mb250V2VpZ2h0IHx8IFwiXCI7XG4gICAgdGhpcy5mb250U2hhcGUgPSBkYXRhLmZvbnRTaGFwZSB8fCBcIlwiO1xuICAgIHRoaXMubWF4U2l6ZSA9IGRhdGEubWF4U2l6ZTsgICAgICAgICAgICAgICAgLy8gW251bWJlciwgbnVtYmVyXVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgc3R5bGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBhcyBcInRoaXNcIi4gIFByb3BlcnRpZXNcbiAgICogZnJvbSBcImV4dGVuc2lvblwiIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgc3R5bGUgb2JqZWN0LlxuICAgKi9cbiAgZXh0ZW5kKGV4dGVuc2lvbikge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBsZXZlbDogdGhpcy5sZXZlbCxcbiAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgZm9udDogdGhpcy5mb250LFxuICAgICAgZm9udEZhbWlseTogdGhpcy5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUsXG4gICAgICBmb250V2VpZ2h0OiB0aGlzLmZvbnRXZWlnaHQsXG4gICAgICBmb250U2hhcGU6IHRoaXMuZm9udFNoYXBlLFxuICAgICAgbWF4U2l6ZTogdGhpcy5tYXhTaXplXG4gICAgfTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIGV4dGVuc2lvbikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHRlbnNpb24sIGtleSkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHlsZShkYXRhKTtcbiAgfVxuXG4gIHdpdGhMZXZlbChuKSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGxldmVsOiBuXG4gICAgfSk7XG4gIH1cblxuICBpbmNyZW1lbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgbGV2ZWw6IE1hdGgubWluKHRoaXMubGV2ZWwgKyAxLCAzKVxuICAgIH0pO1xuICB9XG5cbiAgaW5TdWJPclN1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgbGV2ZWw6IHN1Yk9yU3VwTGV2ZWxbdGhpcy5sZXZlbF1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gY29sb3IuXG4gICAqL1xuICB3aXRoQ29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgY29sb3I6IGNvbG9yXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdHlsZSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gbWF0aCBmb250IG9yIG9sZCB0ZXh0IGZvbnQuXG4gICAqIEB0eXBlIHtbdHlwZV19XG4gICAqL1xuICB3aXRoRm9udChmb250KSB7XG4gICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHtcbiAgICAgIGZvbnRcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc3R5bGUgb2JqZWN0cyB3aXRoIHRoZSBnaXZlbiBmb250RmFtaWx5LlxuICAgKi9cbiAgd2l0aFRleHRGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udEZhbWlseSxcbiAgICAgIGZvbnQ6IFwiXCJcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHN0eWxlIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBmb250IHNpemVcbiAgICovXG4gIHdpdGhGb250U2l6ZShudW0pIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFNpemU6IG51bVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3R5bGUgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgd2VpZ2h0XG4gICAqL1xuICB3aXRoVGV4dEZvbnRXZWlnaHQoZm9udFdlaWdodCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgc3R5bGUgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgd2VpZ2h0XG4gICAqL1xuICB3aXRoVGV4dEZvbnRTaGFwZShmb250U2hhcGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgZm9udFNoYXBlLFxuICAgICAgZm9udDogXCJcIlxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIENTUyBjb2xvciBvZiB0aGUgY3VycmVudCBzdHlsZSBvYmplY3RcbiAgICovXG4gIGdldENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yO1xuICB9XG59XG5cbi8qIFRlbW1sIFBvc3QgUHJvY2Vzc1xuICogUG9wdWxhdGUgdGhlIHRleHQgY29udGVudHMgb2YgZWFjaCBcXHJlZiAmIFxcZXFyZWZcbiAqXG4gKiBBcyB3aXRoIG90aGVyIFRlbW1sIGNvZGUsIHRoaXMgZmlsZSBpcyByZWxlYXNlZCB1bmRlciB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwczovL21pdC1saWNlbnNlLm9yZy9cbiAqL1xuXG5jb25zdCB2ZXJzaW9uID0gXCIwLjExLjAyXCI7XG5cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzKGJsb2NrKSB7XG4gIGNvbnN0IGxhYmVsTWFwID0ge307XG4gIGxldCBpID0gMDtcblxuICAvLyBHZXQgYSBjb2xsZWN0aW9uIG9mIHRoZSBwYXJlbnRzIG9mIGVhY2ggXFx0YWcgJiBhdXRvLW51bWJlcmVkIGVxdWF0aW9uXG4gIGNvbnN0IGFtc0VxbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0bWwtZXFuJyk7XG4gIGZvciAobGV0IHBhcmVudCBvZiBhbXNFcW5zKSB7XG4gICAgLy8gQU1TIGF1dG9tYXRpY2FsbHkgbnVtYmVyZWQgZXF1YXRpb24uXG4gICAgLy8gQXNzaWduIGFuIGlkLlxuICAgIGkgKz0gMTtcbiAgICBwYXJlbnQuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJ0bWwtZXFuLVwiICsgU3RyaW5nKGkpKTtcbiAgICAvLyBObyBuZWVkIHRvIHdyaXRlIGEgbnVtYmVyIGludG8gdGhlIHRleHQgY29udGVudCBvZiB0aGUgZWxlbWVudC5cbiAgICAvLyBBIENTUyBjb3VudGVyIGhhcyBkb25lIHRoYXQgZXZlbiBpZiB0aGlzIHBvc3RQcm9jZXNzKCkgZnVuY3Rpb24gaXMgbm90IHVzZWQuXG5cbiAgICAvLyBGaW5kIGFueSBcXGxhYmVsIHRoYXQgcmVmZXJzIHRvIGFuIEFNUyBhdXRvbWF0aWMgZXFuIG51bWJlci5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHBhcmVudC50YWdOYW1lID09PSBcIm10YWJsZVwiKSB7IGJyZWFrIH1cbiAgICAgIGNvbnN0IGxhYmVscyA9IHBhcmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG1sLWxhYmVsXCIpO1xuICAgICAgaWYgKGxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGlkID0gcGFyZW50LmF0dHJpYnV0ZXMuaWQudmFsdWU7XG4gICAgICAgIGxhYmVsTWFwW2lkXSA9IFN0cmluZyhpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgXFxsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIFxcdGFnXG4gIGNvbnN0IHRhZ2dlZEVxbnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCd0bWwtdGFnZXFuJyk7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHRhZ2dlZEVxbnMpIHtcbiAgICBjb25zdCBsYWJlbHMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRtbC1sYWJlbFwiKTtcbiAgICBpZiAobGFiZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHRhZ3MgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRtbC10YWdcIik7XG4gICAgICBpZiAodGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGlkID0gcGFyZW50LmF0dHJpYnV0ZXMuaWQudmFsdWU7XG4gICAgICAgIGxhYmVsTWFwW2lkXSA9IHRhZ3NbMF0udGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUG9wdWxhdGUgXFxyZWYgJiBcXGVxcmVmIHRleHQgY29udGVudFxuICBjb25zdCByZWZzID0gYmxvY2suZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRtbC1yZWZcIik7XG4gIFsuLi5yZWZzXS5mb3JFYWNoKHJlZiA9PiB7XG4gICAgY29uc3QgYXR0ciA9IHJlZi5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuICAgIGxldCBzdHIgPSBsYWJlbE1hcFthdHRyLnNsaWNlKDEpXTtcbiAgICBpZiAocmVmLmNsYXNzTmFtZS5pbmRleE9mKFwidG1sLWVxcmVmXCIpID09PSAtMSkge1xuICAgICAgLy8gXFxyZWYuIE9taXQgcGFyZW5zLlxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL15cXCgvLCBcIlwiKTtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9cXCkkLywgXCJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFxcZXFyZWYuIEluY2x1ZGUgcGFyZW5zXG4gICAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gXCIoXCIpIHsgc3RyID0gXCIoXCIgKyBzdHI7IH1cbiAgICAgIGlmIChzdHIuc2xpY2UoLTEpICE9PSBcIilcIikgeyBzdHIgPSAgc3RyICsgXCIpXCI7IH1cbiAgICB9XG4gICAgY29uc3QgbXRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsIFwibXRleHRcIik7XG4gICAgbXRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyKSk7XG4gICAgY29uc3QgbWF0aCA9ICBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsIFwibWF0aFwiKTtcbiAgICBtYXRoLmFwcGVuZENoaWxkKG10ZXh0KTtcbiAgICByZWYudGV4dENvbnRlbnQgPSAnJztcbiAgICByZWYuYXBwZW5kQ2hpbGQobWF0aCk7XG4gIH0pO1xufVxuXG5jb25zdCBmaW5kRW5kT2ZNYXRoID0gZnVuY3Rpb24oZGVsaW1pdGVyLCB0ZXh0LCBzdGFydEluZGV4KSB7XG4gIC8vIEFkYXB0ZWQgZnJvbVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vS2hhbi9wZXJzZXVzL2Jsb2IvbWFzdGVyL3NyYy9wZXJzZXVzLW1hcmtkb3duLmpzeFxuICBsZXQgaW5kZXggPSBzdGFydEluZGV4O1xuICBsZXQgYnJhY2VMZXZlbCA9IDA7XG5cbiAgY29uc3QgZGVsaW1MZW5ndGggPSBkZWxpbWl0ZXIubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgY29uc3QgY2hhcmFjdGVyID0gdGV4dFtpbmRleF07XG5cbiAgICBpZiAoYnJhY2VMZXZlbCA8PSAwICYmIHRleHQuc2xpY2UoaW5kZXgsIGluZGV4ICsgZGVsaW1MZW5ndGgpID09PSBkZWxpbWl0ZXIpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9IGVsc2UgaWYgKGNoYXJhY3RlciA9PT0gXCJcXFxcXCIpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IFwie1wiKSB7XG4gICAgICBicmFjZUxldmVsKys7XG4gICAgfSBlbHNlIGlmIChjaGFyYWN0ZXIgPT09IFwifVwiKSB7XG4gICAgICBicmFjZUxldmVsLS07XG4gICAgfVxuXG4gICAgaW5kZXgrKztcbiAgfVxuXG4gIHJldHVybiAtMTtcbn07XG5cbmNvbnN0IGVzY2FwZVJlZ2V4ID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG59O1xuXG5jb25zdCBhbXNSZWdleCA9IC9eXFxcXCg/OmJlZ2lufCg/OmVxKT9yZWYpey87XG5cbmNvbnN0IHNwbGl0QXREZWxpbWl0ZXJzID0gZnVuY3Rpb24odGV4dCwgZGVsaW1pdGVycykge1xuICBsZXQgaW5kZXg7XG4gIGNvbnN0IGRhdGEgPSBbXTtcblxuICBjb25zdCByZWdleExlZnQgPSBuZXcgUmVnRXhwKFxuICAgIFwiKFwiICsgZGVsaW1pdGVycy5tYXAoKHgpID0+IGVzY2FwZVJlZ2V4KHgubGVmdCkpLmpvaW4oXCJ8XCIpICsgXCIpXCJcbiAgKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGluZGV4ID0gdGV4dC5zZWFyY2gocmVnZXhMZWZ0KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGRhdGE6IHRleHQuc2xpY2UoMCwgaW5kZXgpXG4gICAgICB9KTtcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKGluZGV4KTsgLy8gbm93IHRleHQgc3RhcnRzIHdpdGggZGVsaW1pdGVyXG4gICAgfVxuICAgIC8vIC4uLiBzbyB0aGlzIGFsd2F5cyBzdWNjZWVkczpcbiAgICBjb25zdCBpID0gZGVsaW1pdGVycy5maW5kSW5kZXgoKGRlbGltKSA9PiB0ZXh0LnN0YXJ0c1dpdGgoZGVsaW0ubGVmdCkpO1xuICAgIGluZGV4ID0gZmluZEVuZE9mTWF0aChkZWxpbWl0ZXJzW2ldLnJpZ2h0LCB0ZXh0LCBkZWxpbWl0ZXJzW2ldLmxlZnQubGVuZ3RoKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgcmF3RGF0YSA9IHRleHQuc2xpY2UoMCwgaW5kZXggKyBkZWxpbWl0ZXJzW2ldLnJpZ2h0Lmxlbmd0aCk7XG4gICAgY29uc3QgbWF0aCA9IGFtc1JlZ2V4LnRlc3QocmF3RGF0YSlcbiAgICAgID8gcmF3RGF0YVxuICAgICAgOiB0ZXh0LnNsaWNlKGRlbGltaXRlcnNbaV0ubGVmdC5sZW5ndGgsIGluZGV4KTtcbiAgICBkYXRhLnB1c2goe1xuICAgICAgdHlwZTogXCJtYXRoXCIsXG4gICAgICBkYXRhOiBtYXRoLFxuICAgICAgcmF3RGF0YSxcbiAgICAgIGRpc3BsYXk6IGRlbGltaXRlcnNbaV0uZGlzcGxheVxuICAgIH0pO1xuICAgIHRleHQgPSB0ZXh0LnNsaWNlKGluZGV4ICsgZGVsaW1pdGVyc1tpXS5yaWdodC5sZW5ndGgpO1xuICB9XG5cbiAgaWYgKHRleHQgIT09IFwiXCIpIHtcbiAgICBkYXRhLnB1c2goe1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICBkYXRhOiB0ZXh0XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbmNvbnN0IGRlZmF1bHREZWxpbWl0ZXJzID0gW1xuICB7IGxlZnQ6IFwiJCRcIiwgcmlnaHQ6IFwiJCRcIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXChcIiwgcmlnaHQ6IFwiXFxcXClcIiwgZGlzcGxheTogZmFsc2UgfSxcbiAgLy8gTGFUZVggdXNlcyAk4oCmJCwgYnV0IGl0IHJ1aW5zIHRoZSBkaXNwbGF5IG9mIG5vcm1hbCBgJGAgaW4gdGV4dDpcbiAgLy8ge2xlZnQ6IFwiJFwiLCByaWdodDogXCIkXCIsIGRpc3BsYXk6IGZhbHNlfSxcbiAgLy8gJCBtdXN0IGNvbWUgYWZ0ZXIgJCRcblxuICAvLyBSZW5kZXIgQU1TIGVudmlyb25tZW50cyBldmVuIGlmIG91dHNpZGUgJCTigKYkJCBkZWxpbWl0ZXJzLlxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2VxdWF0aW9ufVwiLCByaWdodDogXCJcXFxcZW5ke2VxdWF0aW9ufVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57ZXF1YXRpb24qfVwiLCByaWdodDogXCJcXFxcZW5ke2VxdWF0aW9uKn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWdufVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWdufVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ24qfVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWduKn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWduYXR9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ25hdH1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2FsaWduYXQqfVwiLCByaWdodDogXCJcXFxcZW5ke2FsaWduYXQqfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Z2F0aGVyfVwiLCByaWdodDogXCJcXFxcZW5ke2dhdGhlcn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue2dhdGhlcip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Z2F0aGVyKn1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGJlZ2lue0NEfVwiLCByaWdodDogXCJcXFxcZW5ke0NEfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIC8vIERpdHRvIFxccmVmICYgXFxlcXJlZlxuICB7IGxlZnQ6IFwiXFxcXHJlZntcIiwgcmlnaHQ6IFwifVwiLCBkaXNwbGF5OiBmYWxzZSB9LFxuICB7IGxlZnQ6IFwiXFxcXGVxcmVme1wiLCByaWdodDogXCJ9XCIsIGRpc3BsYXk6IGZhbHNlIH0sXG5cbiAgeyBsZWZ0OiBcIlxcXFxbXCIsIHJpZ2h0OiBcIlxcXFxdXCIsIGRpc3BsYXk6IHRydWUgfVxuXTtcblxuY29uc3QgZmlyc3REcmFmdERlbGltaXRlcnMgPSB7XG4gIFwiJFwiOiBbXG4gICAgICAgICB7IGxlZnQ6IFwiJCRcIiwgcmlnaHQ6IFwiJCRcIiwgZGlzcGxheTogdHJ1ZSB9LFxuICAgICAgICAgeyBsZWZ0OiBcIiRgXCIsIHJpZ2h0OiBcImAkXCIsIGRpc3BsYXk6IGZhbHNlIH0sXG4gICAgICAgICB7IGxlZnQ6IFwiJFwiLCByaWdodDogXCIkXCIsIGRpc3BsYXk6IGZhbHNlIH1cbiAgXSxcbiAgXCIoXCI6IFtcbiAgICB7IGxlZnQ6IFwiXFxcXFtcIiwgcmlnaHQ6IFwiXFxcXF1cIiwgZGlzcGxheTogdHJ1ZSB9LFxuICAgIHsgbGVmdDogXCJcXFxcKFwiLCByaWdodDogXCJcXFxcKVwiLCBkaXNwbGF5OiBmYWxzZSB9XG4gIF1cbn07XG5cbmNvbnN0IGFtc0RlbGltaXRlcnMgPSBbXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57ZXF1YXRpb259XCIsIHJpZ2h0OiBcIlxcXFxlbmR7ZXF1YXRpb259XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntlcXVhdGlvbip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7ZXF1YXRpb24qfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ259XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ259XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbnthbGlnbip9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ24qfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ25hdH1cIiwgcmlnaHQ6IFwiXFxcXGVuZHthbGlnbmF0fVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57YWxpZ25hdCp9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7YWxpZ25hdCp9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxiZWdpbntnYXRoZXJ9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Z2F0aGVyfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Z2F0aGVyKn1cIiwgcmlnaHQ6IFwiXFxcXGVuZHtnYXRoZXIqfVwiLCBkaXNwbGF5OiB0cnVlIH0sXG4gIHsgbGVmdDogXCJcXFxcYmVnaW57Q0R9XCIsIHJpZ2h0OiBcIlxcXFxlbmR7Q0R9XCIsIGRpc3BsYXk6IHRydWUgfSxcbiAgeyBsZWZ0OiBcIlxcXFxyZWZ7XCIsIHJpZ2h0OiBcIn1cIiwgZGlzcGxheTogZmFsc2UgfSxcbiAgeyBsZWZ0OiBcIlxcXFxlcXJlZntcIiwgcmlnaHQ6IFwifVwiLCBkaXNwbGF5OiBmYWxzZSB9XG5dO1xuXG5jb25zdCBkZWxpbWl0ZXJzRnJvbUtleSA9IGtleSA9PiB7XG4gIGlmIChrZXkgPT09IFwiJFwiIHx8IGtleSA9PT0gXCIoXCIpIHtcbiAgICByZXR1cm4gZmlyc3REcmFmdERlbGltaXRlcnNba2V5XTtcbiAgfSBlbHNlIGlmIChrZXkgPT09IFwiJCtcIiB8fCBrZXkgPT09IFwiKCtcIikge1xuICAgIGNvbnN0IGZpcnN0RHJhZnQgPSBmaXJzdERyYWZ0RGVsaW1pdGVyc1trZXkuc2xpY2UoMCwgMSldO1xuICAgIHJldHVybiBmaXJzdERyYWZ0LmNvbmNhdChhbXNEZWxpbWl0ZXJzKVxuICB9IGVsc2UgaWYgKGtleSA9PT0gXCJhbXNcIikge1xuICAgIHJldHVybiBhbXNEZWxpbWl0ZXJzXG4gIH0gZWxzZSBpZiAoa2V5ID09PSBcImFsbFwiKSB7XG4gICAgcmV0dXJuIChmaXJzdERyYWZ0RGVsaW1pdGVyc1tcIihcIl0pLmNvbmNhdChmaXJzdERyYWZ0RGVsaW1pdGVyc1tcIiRcIl0pLmNvbmNhdChhbXNEZWxpbWl0ZXJzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWZhdWx0RGVsaW1pdGVyc1xuICB9XG59O1xuXG4vKiBOb3RlOiBvcHRpb25zQ29weSBpcyBtdXRhdGVkIGJ5IHRoaXMgbWV0aG9kLiBJZiBpdCBpcyBldmVyIGV4cG9zZWQgaW4gdGhlXG4gKiBBUEksIHdlIHNob3VsZCBjb3B5IGl0IGJlZm9yZSBtdXRhdGluZy5cbiAqL1xuY29uc3QgcmVuZGVyTWF0aEluVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnNDb3B5KSB7XG4gIGNvbnN0IGRhdGEgPSBzcGxpdEF0RGVsaW1pdGVycyh0ZXh0LCBvcHRpb25zQ29weS5kZWxpbWl0ZXJzKTtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAxICYmIGRhdGFbMF0udHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAvLyBUaGVyZSBpcyBubyBmb3JtdWxhIGluIHRoZSB0ZXh0LlxuICAgIC8vIExldCdzIHJldHVybiBudWxsIHdoaWNoIG1lYW5zIHRoZXJlIGlzIG5vIG5lZWQgdG8gcmVwbGFjZVxuICAgIC8vIHRoZSBjdXJyZW50IHRleHQgbm9kZSB3aXRoIGEgbmV3IG9uZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkYXRhW2ldLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkYXRhW2ldLmRhdGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbGV0IG1hdGggPSBkYXRhW2ldLmRhdGE7XG4gICAgICAvLyBPdmVycmlkZSBhbnkgZGlzcGxheSBtb2RlIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzIHdpdGggdGhhdFxuICAgICAgLy8gZGVmaW5lZCBieSB0aGUgdGV4dCBpdHNlbGZcbiAgICAgIG9wdGlvbnNDb3B5LmRpc3BsYXlNb2RlID0gZGF0YVtpXS5kaXNwbGF5O1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG9wdGlvbnNDb3B5LnByZVByb2Nlc3MpIHtcbiAgICAgICAgICBtYXRoID0gb3B0aW9uc0NvcHkucHJlUHJvY2VzcyhtYXRoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbXBvcnRpbmcgcmVuZGVyKCkgZnJvbSB0ZW1tbC5qcyB3b3VsZCBiZSBhIGNpcmN1bGFyIGRlcGVuZGVuY3kuXG4gICAgICAgIC8vIFNvIGNhbGwgdGhlIGdsb2JhbCB2ZXJzaW9uLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgICAgdGVtbWwucmVuZGVyKG1hdGgsIHNwYW4sIG9wdGlvbnNDb3B5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFBhcnNlRXJyb3IpKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zQ29weS5lcnJvckNhbGxiYWNrKFxuICAgICAgICAgIFwiVGVtbWwgYXV0by1yZW5kZXI6IEZhaWxlZCB0byBwYXJzZSBgXCIgKyBkYXRhW2ldLmRhdGEgKyBcImAgd2l0aCBcIixcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGFbaV0ucmF3RGF0YSkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn07XG5cbmNvbnN0IHJlbmRlckVsZW0gPSBmdW5jdGlvbihlbGVtLCBvcHRpb25zQ29weSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW0uY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkTm9kZSA9IGVsZW0uY2hpbGROb2Rlc1tpXTtcbiAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAvLyBUZXh0IG5vZGVcbiAgICAgIGNvbnN0IGZyYWcgPSByZW5kZXJNYXRoSW5UZXh0KGNoaWxkTm9kZS50ZXh0Q29udGVudCwgb3B0aW9uc0NvcHkpO1xuICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgaSArPSBmcmFnLmNoaWxkTm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgZWxlbS5yZXBsYWNlQ2hpbGQoZnJhZywgY2hpbGROb2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgLy8gRWxlbWVudCBub2RlXG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBcIiBcIiArIGNoaWxkTm9kZS5jbGFzc05hbWUgKyBcIiBcIjtcbiAgICAgIGNvbnN0IHNob3VsZFJlbmRlciA9XG4gICAgICAgIG9wdGlvbnNDb3B5Lmlnbm9yZWRUYWdzLmluZGV4T2YoY2hpbGROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAtMSAmJlxuICAgICAgICBvcHRpb25zQ29weS5pZ25vcmVkQ2xhc3Nlcy5ldmVyeSgoeCkgPT4gY2xhc3NOYW1lLmluZGV4T2YoXCIgXCIgKyB4ICsgXCIgXCIpID09PSAtMSk7XG5cbiAgICAgIGlmIChzaG91bGRSZW5kZXIpIHtcbiAgICAgICAgcmVuZGVyRWxlbShjaGlsZE5vZGUsIG9wdGlvbnNDb3B5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCBpdCdzIHNvbWV0aGluZyBlbHNlLCBhbmQgaWdub3JlIGl0LlxuICB9XG59O1xuXG5jb25zdCByZW5kZXJNYXRoSW5FbGVtZW50ID0gZnVuY3Rpb24oZWxlbSwgb3B0aW9ucykge1xuICBpZiAoIWVsZW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBlbGVtZW50IHByb3ZpZGVkIHRvIHJlbmRlclwiKTtcbiAgfVxuXG4gIGNvbnN0IG9wdGlvbnNDb3B5ID0ge307XG5cbiAgLy8gT2JqZWN0LmFzc2lnbihvcHRpb25zQ29weSwgb3B0aW9uKVxuICBmb3IgKGNvbnN0IG9wdGlvbiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBvcHRpb24pKSB7XG4gICAgICBvcHRpb25zQ29weVtvcHRpb25dID0gb3B0aW9uc1tvcHRpb25dO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zQ29weS5mZW5jZXMpIHtcbiAgICBvcHRpb25zQ29weS5kZWxpbWl0ZXJzID0gZGVsaW1pdGVyc0Zyb21LZXkob3B0aW9uc0NvcHkuZmVuY2VzKTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zQ29weS5kZWxpbWl0ZXJzID0gb3B0aW9uc0NvcHkuZGVsaW1pdGVycyB8fCBkZWZhdWx0RGVsaW1pdGVycztcbiAgfVxuICBvcHRpb25zQ29weS5pZ25vcmVkVGFncyA9IG9wdGlvbnNDb3B5Lmlnbm9yZWRUYWdzIHx8IFtcbiAgICBcInNjcmlwdFwiLFxuICAgIFwibm9zY3JpcHRcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJ0ZXh0YXJlYVwiLFxuICAgIFwicHJlXCIsXG4gICAgXCJjb2RlXCIsXG4gICAgXCJvcHRpb25cIlxuICBdO1xuICBvcHRpb25zQ29weS5pZ25vcmVkQ2xhc3NlcyA9IG9wdGlvbnNDb3B5Lmlnbm9yZWRDbGFzc2VzIHx8IFtdO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBvcHRpb25zQ29weS5lcnJvckNhbGxiYWNrID0gb3B0aW9uc0NvcHkuZXJyb3JDYWxsYmFjayB8fCBjb25zb2xlLmVycm9yO1xuXG4gIC8vIEVuYWJsZSBzaGFyaW5nIG9mIGdsb2JhbCBtYWNyb3MgZGVmaW5lZCB2aWEgYFxcZ2RlZmAgYmV0d2VlbiBkaWZmZXJlbnRcbiAgLy8gbWF0aCBlbGVtZW50cyB3aXRoaW4gYSBzaW5nbGUgY2FsbCB0byBgcmVuZGVyTWF0aEluRWxlbWVudGAuXG4gIG9wdGlvbnNDb3B5Lm1hY3JvcyA9IG9wdGlvbnNDb3B5Lm1hY3JvcyB8fCB7fTtcblxuICByZW5kZXJFbGVtKGVsZW0sIG9wdGlvbnNDb3B5KTtcbiAgcG9zdFByb2Nlc3MoZWxlbSk7XG59O1xuXG4vKiBlc2xpbnQgbm8tY29uc29sZTowICovXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIFRlbW1sLiBIZXJlLCB3ZSBleHBvc2UgZnVuY3Rpb25zIGZvclxuICogcmVuZGVyaW5nIGV4cHJlc3Npb25zIGVpdGhlciB0byBET00gbm9kZXMgb3IgdG8gbWFya3VwIHN0cmluZ3MuXG4gKlxuICogV2UgYWxzbyBleHBvc2UgdGhlIFBhcnNlRXJyb3IgY2xhc3MgdG8gY2hlY2sgaWYgZXJyb3JzIHRocm93biBmcm9tIFRlbW1sIGFyZVxuICogZXJyb3JzIGluIHRoZSBleHByZXNzaW9uLCBvciBlcnJvcnMgaW4gamF2YXNjcmlwdCBoYW5kbGluZy5cbiAqL1xuXG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90ZW1tbCcpLnJlbmRlcn1cbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcGxhY2UgdGhhdCBleHByZXNzaW9uIGluIHRoZSBET00gbm9kZVxuICogZ2l2ZW4uXG4gKi9cbmxldCByZW5kZXIgPSBmdW5jdGlvbihleHByZXNzaW9uLCBiYXNlTm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGJhc2VOb2RlLnRleHRDb250ZW50ID0gXCJcIjtcbiAgY29uc3QgYWxyZWFkeUluTWF0aEVsZW1lbnQgPSBiYXNlTm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwibWF0aFwiO1xuICBpZiAoYWxyZWFkeUluTWF0aEVsZW1lbnQpIHsgb3B0aW9ucy53cmFwID0gXCJub25lXCI7IH1cbiAgY29uc3QgbWF0aCA9IHJlbmRlclRvTWF0aE1MVHJlZShleHByZXNzaW9uLCBvcHRpb25zKTtcbiAgaWYgKGFscmVhZHlJbk1hdGhFbGVtZW50KSB7XG4gICAgLy8gVGhlIDxtYXRoPiBlbGVtZW50IGFscmVhZHkgZXhpc3RzLiBQb3B1bGF0ZSBpdC5cbiAgICBiYXNlTm9kZS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgbWF0aC5jaGlsZHJlbi5mb3JFYWNoKGUgPT4geyBiYXNlTm9kZS5hcHBlbmRDaGlsZChlLnRvTm9kZSgpKTsgfSk7XG4gIH0gZWxzZSBpZiAobWF0aC5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgYmFzZU5vZGUudGV4dENvbnRlbnQgPSBcIlwiO1xuICAgIG1hdGguY2hpbGRyZW4uZm9yRWFjaChlID0+IHsgYmFzZU5vZGUuYXBwZW5kQ2hpbGQoZS50b05vZGUoKSk7IH0pO1xuICB9IGVsc2Uge1xuICAgIGJhc2VOb2RlLmFwcGVuZENoaWxkKG1hdGgudG9Ob2RlKCkpO1xuICB9XG59O1xuXG4vLyBUZW1tbCdzIHN0eWxlcyBkb24ndCB3b3JrIHByb3Blcmx5IGluIHF1aXJrcyBtb2RlLiBQcmludCBvdXQgYW4gZXJyb3IsIGFuZFxuLy8gZGlzYWJsZSByZW5kZXJpbmcuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGlmIChkb2N1bWVudC5jb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiV2FybmluZzogVGVtbWwgZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLiBNYWtlIHN1cmUgeW91ciBcIiArXG4gICAgICAgICAgXCJ3ZWJzaXRlIGhhcyBhIHN1aXRhYmxlIGRvY3R5cGUuXCJcbiAgICAgICk7XG5cbiAgICByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiVGVtbWwgZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLlwiKTtcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90ZW1tbCcpLnJlbmRlclRvU3RyaW5nfVxuICogUGFyc2UgYW5kIGJ1aWxkIGFuIGV4cHJlc3Npb24sIGFuZCByZXR1cm4gdGhlIG1hcmt1cCBmb3IgdGhhdC5cbiAqL1xuY29uc3QgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gIGNvbnN0IG1hcmt1cCA9IHJlbmRlclRvTWF0aE1MVHJlZShleHByZXNzaW9uLCBvcHRpb25zKS50b01hcmt1cCgpO1xuICByZXR1cm4gbWFya3VwO1xufTtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykuZ2VuZXJhdGVQYXJzZVRyZWV9XG4gKiBQYXJzZSBhbiBleHByZXNzaW9uIGFuZCByZXR1cm4gdGhlIHBhcnNlIHRyZWUuXG4gKi9cbmNvbnN0IGdlbmVyYXRlUGFyc2VUcmVlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgcmV0dXJuIHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG59O1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vdGVtbWwnKS5kZWZpbmVQcmVhbWJsZX1cbiAqIFRha2UgYW4gZXhwcmVzc2lvbiB3aGljaCBjb250YWlucyBhIHByZWFtYmxlLlxuICogUGFyc2UgaXQgYW5kIHJldHVybiB0aGUgbWFjcm9zLlxuICovXG5jb25zdCBkZWZpbmVQcmVhbWJsZSA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG4gIHNldHRpbmdzLm1hY3JvcyA9IHt9O1xuICBpZiAoISh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gXCJzdHJpbmdcIiB8fCBleHByZXNzaW9uIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUZW1tbCBjYW4gb25seSBwYXJzZSBzdHJpbmcgdHlwZWQgZXhwcmVzc2lvblwiKVxuICB9XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoZXhwcmVzc2lvbiwgc2V0dGluZ3MsIHRydWUpO1xuICAvLyBCbGFuayBvdXQgYW55IFxcZGZAdGFnIHRvIGF2b2lkIHNwdXJpb3VzIFwiRHVwbGljYXRlIFxcdGFnXCIgZXJyb3JzXG4gIGRlbGV0ZSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50W1wiXFxcXGRmQHRhZ1wiXTtcbiAgY29uc3QgbWFjcm9zID0gcGFyc2VyLnBhcnNlKCk7XG4gIHJldHVybiBtYWNyb3Ncbn07XG5cbi8qKlxuICogSWYgdGhlIGdpdmVuIGVycm9yIGlzIGEgVGVtbWwgUGFyc2VFcnJvcixcbiAqIHJlbmRlcnMgdGhlIGludmFsaWQgTGFUZVggYXMgYSBzcGFuIHdpdGggaG92ZXIgdGl0bGUgZ2l2aW5nIHRoZSBUZW1tbFxuICogZXJyb3IgbWVzc2FnZS4gIE90aGVyd2lzZSwgc2ltcGx5IHRocm93cyB0aGUgZXJyb3IuXG4gKi9cbmNvbnN0IHJlbmRlckVycm9yID0gZnVuY3Rpb24oZXJyb3IsIGV4cHJlc3Npb24sIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudGhyb3dPbkVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBQYXJzZUVycm9yKSkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG4gIGNvbnN0IG5vZGUgPSBuZXcgU3BhbihbXCJ0ZW1tbC1lcnJvclwiXSwgW25ldyBUZXh0Tm9kZSQxKGV4cHJlc3Npb24gKyBcIlxcblxcblwiICsgZXJyb3IudG9TdHJpbmcoKSldKTtcbiAgbm9kZS5zdHlsZS5jb2xvciA9IG9wdGlvbnMuZXJyb3JDb2xvcjtcbiAgbm9kZS5zdHlsZS53aGl0ZVNwYWNlID0gXCJwcmUtbGluZVwiO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogQHR5cGUge2ltcG9ydCgnLi90ZW1tbCcpLnJlbmRlclRvTWF0aE1MVHJlZX1cbiAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyB0aGUgVGVtbWwgYnVpbGQgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciBhZHZhbmNlZFxuICogdXNlIGNhc2VzIChsaWtlIHJlbmRlcmluZyB0byBjdXN0b20gb3V0cHV0KS5cbiAqL1xuY29uc3QgcmVuZGVyVG9NYXRoTUxUcmVlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgdHJ5IHtcbiAgICBjb25zdCB0cmVlID0gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbiAgICBjb25zdCBzdHlsZSA9IG5ldyBTdHlsZSh7XG4gICAgICBsZXZlbDogc2V0dGluZ3MuZGlzcGxheU1vZGUgPyBTdHlsZUxldmVsLkRJU1BMQVkgOiBTdHlsZUxldmVsLlRFWFQsXG4gICAgICBtYXhTaXplOiBzZXR0aW5ncy5tYXhTaXplXG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1aWxkTWF0aE1MKHRyZWUsIGV4cHJlc3Npb24sIHN0eWxlLCBzZXR0aW5ncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHJlbmRlckVycm9yKGVycm9yLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gIH1cbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3RlbW1sJykuZGVmYXVsdH0gKi9cbnZhciB0ZW1tbCQxID0ge1xuICAvKipcbiAgICogQ3VycmVudCBUZW1tbCB2ZXJzaW9uXG4gICAqL1xuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBNYXRoTUwsIGFuZCBhZGRzXG4gICAqIGl0IGFzIGEgY2hpbGQgdG8gdGhlIHNwZWNpZmllZCBET00gbm9kZS5cbiAgICovXG4gIHJlbmRlcixcbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gTWF0aE1MIHN0cmluZyxcbiAgICogZm9yIHNlbmRpbmcgdG8gdGhlIGNsaWVudC5cbiAgICovXG4gIHJlbmRlclRvU3RyaW5nLFxuICAvKipcbiAgICogRmluZHMgYWxsIHRoZSBtYXRoIGRlbGltaXRlcnMgaW4gYSBnaXZlbiBlbGVtZW50IG9mIGEgcnVubmluZyBIVE1MIGRvY3VtZW50XG4gICAqIGFuZCBjb252ZXJ0cyB0aGUgY29udGVudHMgb2YgZWFjaCBpbnN0YW5jZSBpbnRvIGEgPG1hdGg+IGVsZW1lbnQuXG4gICAqL1xuICByZW5kZXJNYXRoSW5FbGVtZW50LFxuICAvKipcbiAgICogUG9zdC1wcm9jZXNzIGFuIGVudGlyZSBIVE1MIGJsb2NrLlxuICAgKiBXcml0ZXMgQU1TIGF1dG8tbnVtYmVycyBhbmQgaW1wbGVtZW50cyBcXHJlZnt9LlxuICAgKiBUeXBjYWxseSBjYWxsZWQgb25jZSwgYWZ0ZXIgYSBsb29wIGhhcyByZW5kZXJlZCBtYW55IGluZGl2aWR1YWwgc3BhbnMuXG4gICAqL1xuICBwb3N0UHJvY2VzcyxcbiAgLyoqXG4gICAqIFRlbW1sIGVycm9yLCB1c3VhbGx5IGR1cmluZyBwYXJzaW5nLlxuICAgKi9cbiAgUGFyc2VFcnJvcixcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzZXQgb2YgbWFjcm9zIHdpdGggZG9jdW1lbnQtd2lkZSBzY29wZS5cbiAgICovXG4gIGRlZmluZVByZWFtYmxlLFxuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIFRlbW1sJ3MgaW50ZXJuYWwgcGFyc2UgdHJlZSBzdHJ1Y3R1cmUsXG4gICAqIHdpdGhvdXQgcmVuZGVyaW5nIHRvIEhUTUwgb3IgTWF0aE1MLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHlcbiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay5cbiAgICovXG4gIF9fcGFyc2U6IGdlbmVyYXRlUGFyc2VUcmVlLFxuICAvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhIE1hdGhNTCBpbnRlcm5hbCBET00gdHJlZVxuICAgKiByZXByZXNlbnRhdGlvbiwgd2l0aG91dCBmbGF0dGVuaW5nIHRoYXQgcmVwcmVzZW50YXRpb24gdG8gYSBzdHJpbmcuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuXG4gICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgX19yZW5kZXJUb01hdGhNTFRyZWU6IHJlbmRlclRvTWF0aE1MVHJlZSxcbiAgLyoqXG4gICAqIGFkZHMgYSBuZXcgc3ltYm9sIHRvIGJ1aWx0aW4gc3ltYm9scyB0YWJsZVxuICAgKi9cbiAgX19kZWZpbmVTeW1ib2w6IGRlZmluZVN5bWJvbCxcbiAgLyoqXG4gICAqIGFkZHMgYSBuZXcgbWFjcm8gdG8gYnVpbHRpbiBtYWNybyBsaXN0XG4gICAqL1xuICBfX2RlZmluZU1hY3JvOiBkZWZpbmVNYWNyb1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1tbCQxO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsImV4cG9ydCB7IERlZnVkZGxlIH0gZnJvbSAnLi9kZWZ1ZGRsZSc7XG5leHBvcnQgdHlwZSB7IERlZnVkZGxlT3B0aW9ucywgRGVmdWRkbGVSZXNwb25zZSwgRGVmdWRkbGVNZXRhZGF0YSB9IGZyb20gJy4vdHlwZXMnOyAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=